{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_docmd.c: functions for executing an Ex command line.\n */\n\n#include \"vim.h\"\n\nstatic int\tquitmore = 0;\nstatic int\tex_pressedreturn = FALSE;\n#ifndef FEAT_PRINTER\n# define ex_hardcopy\tex_ni\n#endif\n\n#ifdef FEAT_EVAL\nstatic char_u\t*do_one_cmd(char_u **, int, cstack_T *, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\n#else\nstatic char_u\t*do_one_cmd(char_u **, int, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\nstatic int\tif_level = 0;\t\t// depth in :if\n#endif\nstatic void\tappend_command(char_u *cmd);\n\n#ifndef FEAT_MENU\n# define ex_emenu\t\tex_ni\n# define ex_menu\t\tex_ni\n# define ex_menutranslate\tex_ni\n#endif\nstatic void\tex_autocmd(exarg_T *eap);\nstatic void\tex_doautocmd(exarg_T *eap);\nstatic void\tex_bunload(exarg_T *eap);\nstatic void\tex_buffer(exarg_T *eap);\nstatic void\tex_bmodified(exarg_T *eap);\nstatic void\tex_bnext(exarg_T *eap);\nstatic void\tex_bprevious(exarg_T *eap);\nstatic void\tex_brewind(exarg_T *eap);\nstatic void\tex_blast(exarg_T *eap);\nstatic char_u\t*getargcmd(char_u **);\nstatic int\tgetargopt(exarg_T *eap);\n#ifndef FEAT_QUICKFIX\n# define ex_make\t\tex_ni\n# define ex_cbuffer\t\tex_ni\n# define ex_cc\t\t\tex_ni\n# define ex_cnext\t\tex_ni\n# define ex_cbelow\t\tex_ni\n# define ex_cfile\t\tex_ni\n# define qf_list\t\tex_ni\n# define qf_age\t\t\tex_ni\n# define qf_history\t\tex_ni\n# define ex_helpgrep\t\tex_ni\n# define ex_vimgrep\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX)\n# define ex_cclose\t\tex_ni\n# define ex_copen\t\tex_ni\n# define ex_cwindow\t\tex_ni\n# define ex_cbottom\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX) || !defined(FEAT_EVAL)\n# define ex_cexpr\t\tex_ni\n#endif\n\nstatic linenr_T default_address(exarg_T *eap);\nstatic linenr_T get_address(exarg_T *, char_u **, cmd_addr_T addr_type, int skip, int silent, int to_other_file, int address_count);\nstatic void address_default_all(exarg_T *eap);\nstatic void\tget_flags(exarg_T *eap);\n#if !defined(FEAT_PERL) \\\n\t|| !defined(FEAT_PYTHON) || !defined(FEAT_PYTHON3) \\\n\t|| !defined(FEAT_TCL) \\\n\t|| !defined(FEAT_RUBY) \\\n\t|| !defined(FEAT_LUA) \\\n\t|| !defined(FEAT_MZSCHEME)\n# define HAVE_EX_SCRIPT_NI\nstatic void\tex_script_ni(exarg_T *eap);\n#endif\nstatic char\t*invalid_range(exarg_T *eap);\nstatic void\tcorrect_range(exarg_T *eap);\n#ifdef FEAT_QUICKFIX\nstatic char_u\t*replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep);\n#endif\nstatic char_u\t*repl_cmdline(exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep);\nstatic void\tex_highlight(exarg_T *eap);\nstatic void\tex_colorscheme(exarg_T *eap);\nstatic void\tex_cquit(exarg_T *eap);\nstatic void\tex_quit_all(exarg_T *eap);\nstatic void\tex_close(exarg_T *eap);\nstatic void\tex_win_close(int forceit, win_T *win, tabpage_T *tp);\nstatic void\tex_only(exarg_T *eap);\nstatic void\tex_resize(exarg_T *eap);\nstatic void\tex_stag(exarg_T *eap);\nstatic void\tex_tabclose(exarg_T *eap);\nstatic void\tex_tabonly(exarg_T *eap);\nstatic void\tex_tabnext(exarg_T *eap);\nstatic void\tex_tabmove(exarg_T *eap);\nstatic void\tex_tabs(exarg_T *eap);\n#if defined(FEAT_QUICKFIX)\nstatic void\tex_pclose(exarg_T *eap);\nstatic void\tex_ptag(exarg_T *eap);\nstatic void\tex_pedit(exarg_T *eap);\n#else\n# define ex_pclose\t\tex_ni\n# define ex_ptag\t\tex_ni\n# define ex_pedit\t\tex_ni\n#endif\nstatic void\tex_hide(exarg_T *eap);\nstatic void\tex_exit(exarg_T *eap);\nstatic void\tex_print(exarg_T *eap);\n#ifdef FEAT_BYTEOFF\nstatic void\tex_goto(exarg_T *eap);\n#else\n# define ex_goto\t\tex_ni\n#endif\nstatic void\tex_shell(exarg_T *eap);\nstatic void\tex_preserve(exarg_T *eap);\nstatic void\tex_recover(exarg_T *eap);\nstatic void\tex_mode(exarg_T *eap);\nstatic void\tex_wrongmodifier(exarg_T *eap);\nstatic void\tex_find(exarg_T *eap);\nstatic void\tex_open(exarg_T *eap);\nstatic void\tex_edit(exarg_T *eap);\n#ifndef FEAT_GUI\n# define ex_gui\t\t\tex_nogui\nstatic void\tex_nogui(exarg_T *eap);\n#endif\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\nstatic void\tex_tearoff(exarg_T *eap);\n#else\n# define ex_tearoff\t\tex_ni\n#endif\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\nstatic void\tex_popup(exarg_T *eap);\n#else\n# define ex_popup\t\tex_ni\n#endif\n#ifndef FEAT_GUI_MSWIN\n# define ex_simalt\t\tex_ni\n#endif\n#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)\n# define gui_mch_find_dialog\tex_ni\n# define gui_mch_replace_dialog ex_ni\n#endif\n#if !defined(FEAT_GUI_GTK)\n# define ex_helpfind\t\tex_ni\n#endif\n#ifndef FEAT_CSCOPE\n# define ex_cscope\t\tex_ni\n# define ex_scscope\t\tex_ni\n# define ex_cstag\t\tex_ni\n#endif\n#ifndef FEAT_SYN_HL\n# define ex_syntax\t\tex_ni\n# define ex_ownsyntax\t\tex_ni\n#endif\n#if !defined(FEAT_SYN_HL) || !defined(FEAT_PROFILE)\n# define ex_syntime\t\tex_ni\n#endif\n#ifndef FEAT_SPELL\n# define ex_spell\t\tex_ni\n# define ex_mkspell\t\tex_ni\n# define ex_spelldump\t\tex_ni\n# define ex_spellinfo\t\tex_ni\n# define ex_spellrepall\t\tex_ni\n#endif\n#ifndef FEAT_PERSISTENT_UNDO\n# define ex_rundo\t\tex_ni\n# define ex_wundo\t\tex_ni\n#endif\n#ifndef FEAT_LUA\n# define ex_lua\t\t\tex_script_ni\n# define ex_luado\t\tex_ni\n# define ex_luafile\t\tex_ni\n#endif\n#ifndef FEAT_MZSCHEME\n# define ex_mzscheme\t\tex_script_ni\n# define ex_mzfile\t\tex_ni\n#endif\n#ifndef FEAT_PERL\n# define ex_perl\t\tex_script_ni\n# define ex_perldo\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON\n# define ex_python\t\tex_script_ni\n# define ex_pydo\t\tex_ni\n# define ex_pyfile\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON3\n# define ex_py3\t\t\tex_script_ni\n# define ex_py3do\t\tex_ni\n# define ex_py3file\t\tex_ni\n#endif\n#if !defined(FEAT_PYTHON) && !defined(FEAT_PYTHON3)\n# define ex_pyx\t\t\tex_script_ni\n# define ex_pyxdo\t\tex_ni\n# define ex_pyxfile\t\tex_ni\n#endif\n#ifndef FEAT_TCL\n# define ex_tcl\t\t\tex_script_ni\n# define ex_tcldo\t\tex_ni\n# define ex_tclfile\t\tex_ni\n#endif\n#ifndef FEAT_RUBY\n# define ex_ruby\t\tex_script_ni\n# define ex_rubydo\t\tex_ni\n# define ex_rubyfile\t\tex_ni\n#endif\n#ifndef FEAT_KEYMAP\n# define ex_loadkeymap\t\tex_ni\n#endif\nstatic void\tex_swapname(exarg_T *eap);\nstatic void\tex_syncbind(exarg_T *eap);\nstatic void\tex_read(exarg_T *eap);\nstatic void\tex_pwd(exarg_T *eap);\nstatic void\tex_equal(exarg_T *eap);\nstatic void\tex_sleep(exarg_T *eap);\nstatic void\tex_winsize(exarg_T *eap);\nstatic void\tex_wincmd(exarg_T *eap);\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\nstatic void\tex_winpos(exarg_T *eap);\n#else\n# define ex_winpos\t    ex_ni\n#endif\nstatic void\tex_operators(exarg_T *eap);\nstatic void\tex_put(exarg_T *eap);\nstatic void\tex_copymove(exarg_T *eap);\nstatic void\tex_submagic(exarg_T *eap);\nstatic void\tex_join(exarg_T *eap);\nstatic void\tex_at(exarg_T *eap);\nstatic void\tex_bang(exarg_T *eap);\nstatic void\tex_undo(exarg_T *eap);\n#ifdef FEAT_PERSISTENT_UNDO\nstatic void\tex_wundo(exarg_T *eap);\nstatic void\tex_rundo(exarg_T *eap);\n#endif\nstatic void\tex_redo(exarg_T *eap);\nstatic void\tex_later(exarg_T *eap);\nstatic void\tex_redir(exarg_T *eap);\nstatic void\tex_redrawstatus(exarg_T *eap);\nstatic void\tex_redrawtabline(exarg_T *eap);\nstatic void\tclose_redir(void);\nstatic void\tex_mark(exarg_T *eap);\nstatic void\tex_startinsert(exarg_T *eap);\nstatic void\tex_stopinsert(exarg_T *eap);\n#ifdef FEAT_FIND_ID\nstatic void\tex_checkpath(exarg_T *eap);\nstatic void\tex_findpat(exarg_T *eap);\n#else\n# define ex_findpat\t\tex_ni\n# define ex_checkpath\t\tex_ni\n#endif\n#if defined(FEAT_FIND_ID) && defined(FEAT_QUICKFIX)\nstatic void\tex_psearch(exarg_T *eap);\n#else\n# define ex_psearch\t\tex_ni\n#endif\nstatic void\tex_tag(exarg_T *eap);\nstatic void\tex_tag_cmd(exarg_T *eap, char_u *name);\n#ifndef FEAT_EVAL\n# define ex_block\t\tex_ni\n# define ex_break\t\tex_ni\n# define ex_breakadd\t\tex_ni\n# define ex_breakdel\t\tex_ni\n# define ex_breaklist\t\tex_ni\n# define ex_call\t\tex_ni\n# define ex_catch\t\tex_ni\n# define ex_compiler\t\tex_ni\n# define ex_continue\t\tex_ni\n# define ex_debug\t\tex_ni\n# define ex_debuggreedy\t\tex_ni\n# define ex_defcompile\t\tex_ni\n# define ex_delfunction\t\tex_ni\n# define ex_disassemble\t\tex_ni\n# define ex_echo\t\tex_ni\n# define ex_echohl\t\tex_ni\n# define ex_else\t\tex_ni\n# define ex_endblock\t\tex_ni\n# define ex_endfunction\t\tex_ni\n# define ex_endif\t\tex_ni\n# define ex_endtry\t\tex_ni\n# define ex_endwhile\t\tex_ni\n# define ex_eval\t\tex_ni\n# define ex_execute\t\tex_ni\n# define ex_incdec\t\tex_ni\n# define ex_finally\t\tex_ni\n# define ex_finish\t\tex_ni\n# define ex_function\t\tex_ni\n# define ex_if\t\t\tex_ni\n# define ex_let\t\t\tex_ni\n# define ex_var\t\t\tex_ni\n# define ex_lockvar\t\tex_ni\n# define ex_oldfiles\t\tex_ni\n# define ex_options\t\tex_ni\n# define ex_packadd\t\tex_ni\n# define ex_packloadall\t\tex_ni\n# define ex_return\t\tex_ni\n# define ex_scriptnames\t\tex_ni\n# define ex_throw\t\tex_ni\n# define ex_try\t\t\tex_ni\n# define ex_unlet\t\tex_ni\n# define ex_while\t\tex_ni\n# define ex_import\t\tex_ni\n# define ex_export\t\tex_ni\n#endif\n#ifndef FEAT_SESSION\n# define ex_loadview\t\tex_ni\n#endif\n#ifndef FEAT_VIMINFO\n# define ex_viminfo\t\tex_ni\n#endif\nstatic void\tex_behave(exarg_T *eap);\nstatic void\tex_filetype(exarg_T *eap);\nstatic void\tex_setfiletype(exarg_T *eap);\n#ifndef FEAT_DIFF\n# define ex_diffoff\t\tex_ni\n# define ex_diffpatch\t\tex_ni\n# define ex_diffgetput\t\tex_ni\n# define ex_diffsplit\t\tex_ni\n# define ex_diffthis\t\tex_ni\n# define ex_diffupdate\t\tex_ni\n#endif\nstatic void\tex_digraphs(exarg_T *eap);\n#ifdef FEAT_SEARCH_EXTRA\nstatic void\tex_nohlsearch(exarg_T *eap);\n#else\n# define ex_nohlsearch\t\tex_ni\n# define ex_match\t\tex_ni\n#endif\n#ifdef FEAT_CRYPT\nstatic void\tex_X(exarg_T *eap);\n#else\n# define ex_X\t\t\tex_ni\n#endif\n#ifdef FEAT_FOLDING\nstatic void\tex_fold(exarg_T *eap);\nstatic void\tex_foldopen(exarg_T *eap);\nstatic void\tex_folddo(exarg_T *eap);\n#else\n# define ex_fold\t\tex_ni\n# define ex_foldopen\t\tex_ni\n# define ex_folddo\t\tex_ni\n#endif\n#if !(defined(HAVE_LOCALE_H) || defined(X_LOCALE))\n# define ex_language\t\tex_ni\n#endif\n#ifndef FEAT_SIGNS\n# define ex_sign\t\tex_ni\n#endif\n#ifndef FEAT_NETBEANS_INTG\n# define ex_nbclose\t\tex_ni\n# define ex_nbkey\t\tex_ni\n# define ex_nbstart\t\tex_ni\n#endif\n\n#ifndef FEAT_PROFILE\n# define ex_profile\t\tex_ni\n#endif\n#ifndef FEAT_TERMINAL\n# define ex_terminal\t\tex_ni\n#endif\n#if !defined(FEAT_X11) || !defined(FEAT_XCLIPBOARD)\n# define ex_xrestore\t\tex_ni\n#endif\n#if !defined(FEAT_PROP_POPUP)\n# define ex_popupclear\t\tex_ni\n#endif\n\n/*\n * Declare cmdnames[].\n */\n#define DO_DECLARE_EXCMD\n#include \"ex_cmds.h\"\n#include \"ex_cmdidxs.h\"\n\nstatic char_u dollar_command[2] = {'$', 0};\n\n\n#ifdef FEAT_EVAL\n// Struct for storing a line inside a while/for loop\ntypedef struct\n{\n    char_u\t*line;\t\t// command line\n    linenr_T\tlnum;\t\t// sourcing_lnum of the line\n} wcmd_T;\n\n/*\n * Structure used to store info for line position in a while or for loop.\n * This is required, because do_one_cmd() may invoke ex_function(), which\n * reads more lines that may come from the while/for loop.\n */\nstruct loop_cookie\n{\n    garray_T\t*lines_gap;\t\t// growarray with line info\n    int\t\tcurrent_line;\t\t// last read line from growarray\n    int\t\trepeating;\t\t// TRUE when looping a second time\n    // When \"repeating\" is FALSE use \"getline\" and \"cookie\" to get lines\n    char_u\t*(*getline)(int, void *, int, getline_opt_T);\n    void\t*cookie;\n};\n\nstatic char_u\t*get_loop_line(int c, void *cookie, int indent, getline_opt_T options);\nstatic int\tstore_loop_line(garray_T *gap, char_u *line);\nstatic void\tfree_cmdlines(garray_T *gap);\n\n// Struct to save a few things while debugging.  Used in do_cmdline() only.\nstruct dbg_stuff\n{\n    int\t\ttrylevel;\n    int\t\tforce_abort;\n    except_T\t*caught_stack;\n    char_u\t*vv_exception;\n    char_u\t*vv_throwpoint;\n    int\t\tdid_emsg;\n    int\t\tgot_int;\n    int\t\tdid_throw;\n    int\t\tneed_rethrow;\n    int\t\tcheck_cstack;\n    except_T\t*current_exception;\n};\n\n    static void\nsave_dbg_stuff(struct dbg_stuff *dsp)\n{\n    dsp->trylevel\t= trylevel;\t\ttrylevel = 0;\n    dsp->force_abort\t= force_abort;\t\tforce_abort = FALSE;\n    dsp->caught_stack\t= caught_stack;\t\tcaught_stack = NULL;\n    dsp->vv_exception\t= v_exception(NULL);\n    dsp->vv_throwpoint\t= v_throwpoint(NULL);\n\n    // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\"\n    dsp->did_emsg\t= did_emsg;\t\tdid_emsg     = FALSE;\n    dsp->got_int\t= got_int;\t\tgot_int\t     = FALSE;\n    dsp->did_throw\t= did_throw;\t\tdid_throw    = FALSE;\n    dsp->need_rethrow\t= need_rethrow;\t\tneed_rethrow = FALSE;\n    dsp->check_cstack\t= check_cstack;\t\tcheck_cstack = FALSE;\n    dsp->current_exception = current_exception;\tcurrent_exception = NULL;\n}\n\n    static void\nrestore_dbg_stuff(struct dbg_stuff *dsp)\n{\n    suppress_errthrow = FALSE;\n    trylevel = dsp->trylevel;\n    force_abort = dsp->force_abort;\n    caught_stack = dsp->caught_stack;\n    (void)v_exception(dsp->vv_exception);\n    (void)v_throwpoint(dsp->vv_throwpoint);\n    did_emsg = dsp->did_emsg;\n    got_int = dsp->got_int;\n    did_throw = dsp->did_throw;\n    need_rethrow = dsp->need_rethrow;\n    check_cstack = dsp->check_cstack;\n    current_exception = dsp->current_exception;\n}\n#endif\n\n/*\n * do_exmode(): Repeatedly get commands for the \"Ex\" mode, until the \":vi\"\n * command is given.\n */\n    void\ndo_exmode(\n    int\t\timproved)\t    // TRUE for \"improved Ex\" mode\n{\n    int\t\tsave_msg_scroll;\n    int\t\tprev_msg_row;\n    linenr_T\tprev_line;\n    varnumber_T\tchangedtick;\n\n    if (improved)\n\texmode_active = EXMODE_VIM;\n    else\n\texmode_active = EXMODE_NORMAL;\n    State = MODE_NORMAL;\n    may_trigger_modechanged();\n\n    // When using \":global /pat/ visual\" and then \"Q\" we return to continue\n    // the :global command.\n    if (global_busy)\n\treturn;\n\n    save_msg_scroll = msg_scroll;\n    ++RedrawingDisabled;\t    // don't redisplay the window\n    ++no_wait_return;\t\t    // don't wait for return\n#ifdef FEAT_GUI\n    // Ignore scrollbar and mouse events in Ex mode\n    ++hold_gui_events;\n#endif\n\n    msg(_(\"Entering Ex mode.  Type \\\"visual\\\" to go to Normal mode.\"));\n    while (exmode_active)\n    {\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t{\n\t    exmode_active = FALSE;\n\t    break;\n\t}\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tex_pressedreturn = FALSE;\n\tex_no_reprint = FALSE;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tprev_msg_row = msg_row;\n\tprev_line = curwin->w_cursor.lnum;\n\tif (improved)\n\t{\n\t    cmdline_row = msg_row;\n\t    do_cmdline(NULL, getexline, NULL, 0);\n\t}\n\telse\n\t    do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);\n\tlines_left = Rows - 1;\n\n\tif ((prev_line != curwin->w_cursor.lnum\n\t\t   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_empty_buffer));\n\t    else\n\t    {\n\t\tif (ex_pressedreturn)\n\t\t{\n\t\t    // go up one line, to overwrite the \":<CR>\" line, so the\n\t\t    // output doesn't contain empty lines.\n\t\t    msg_row = prev_msg_row;\n\t\t    if (prev_msg_row == Rows - 1)\n\t\t\tmsg_row--;\n\t\t}\n\t\tmsg_col = 0;\n\t\tprint_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);\n\t\tmsg_clr_eos();\n\t    }\n\t}\n\telse if (ex_pressedreturn && !ex_no_reprint)\t// must be at EOF\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_empty_buffer));\n\t    else\n\t\temsg(_(e_at_end_of_file));\n\t}\n    }\n\n#ifdef FEAT_GUI\n    --hold_gui_events;\n#endif\n    --RedrawingDisabled;\n    --no_wait_return;\n    update_screen(CLEAR);\n    need_wait_return = FALSE;\n    msg_scroll = save_msg_scroll;\n}\n\n/*\n * Print the executed command for when 'verbose' is set.\n * When \"lnum\" is 0 only print the command.\n */\n    static void\nmsg_verbose_cmd(linenr_T lnum, char_u *cmd)\n{\n    ++no_wait_return;\n    verbose_enter_scroll();\n\n    if (lnum == 0)\n\tsmsg(_(\"Executing: %s\"), cmd);\n    else\n\tsmsg(_(\"line %ld: %s\"), (long)lnum, cmd);\n    if (msg_silent == 0)\n\tmsg_puts(\"\\n\");   // don't overwrite this\n\n    verbose_leave_scroll();\n    --no_wait_return;\n}\n\n/*\n * Execute a simple command line.  Used for translated commands like \"*\".\n */\n    int\ndo_cmdline_cmd(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n}\n\n/*\n * Execute the \"+cmd\" argument of \"edit +cmd fname\" and the like.\n * This allows for using a range without \":\" in Vim9 script.\n */\n    static int\ndo_cmd_argument(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t      DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED|DOCMD_RANGEOK);\n}\n\n/*\n * do_cmdline(): execute one Ex command line\n *\n * 1. Execute \"cmdline\" when it is not NULL.\n *    If \"cmdline\" is NULL, or more lines are needed, fgetline() is used.\n * 2. Split up in parts separated with '|'.\n *\n * This function can be called recursively!\n *\n * flags:\n * DOCMD_VERBOSE  - The command will be included in the error message.\n * DOCMD_NOWAIT   - Don't call wait_return() and friends.\n * DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.\n * DOCMD_KEYTYPED - Don't reset KeyTyped.\n * DOCMD_EXCRESET - Reset the exception environment (used for debugging).\n * DOCMD_KEEPLINE - Store first typed line (for repeating with \".\").\n *\n * return FAIL if cmdline could not be executed, OK otherwise\n */\n    int\ndo_cmdline(\n    char_u\t*cmdline,\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie,\t\t// argument for fgetline()\n    int\t\tflags)\n{\n    char_u\t*next_cmdline;\t\t// next cmd to execute\n    char_u\t*cmdline_copy = NULL;\t// copy of cmd line\n    int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command\n    static int\trecursive = 0;\t\t// recursive depth\n    int\t\tmsg_didout_before_start = 0;\n    int\t\tcount = 0;\t\t// line number count\n    int\t\tdid_inc = FALSE;\t// incremented RedrawingDisabled\n    int\t\tretval = OK;\n#ifdef FEAT_EVAL\n    cstack_T\tcstack;\t\t\t// conditional stack\n    garray_T\tlines_ga;\t\t// keep lines for \":while\"/\":for\"\n    int\t\tcurrent_line = 0;\t// active line in lines_ga\n    int\t\tcurrent_line_before = 0;\n    char_u\t*fname = NULL;\t\t// function or script name\n    linenr_T\t*breakpoint = NULL;\t// ptr to breakpoint field in cookie\n    int\t\t*dbg_tick = NULL;\t// ptr to dbg_tick field in cookie\n    struct dbg_stuff debug_saved;\t// saved things for debug mode\n    int\t\tinitial_trylevel;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n\n    // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n    char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n    void\t*cmd_cookie;\n    struct loop_cookie cmd_loop_cookie;\n    void\t*real_cookie;\n    int\t\tgetline_is_func;\n#else\n# define cmd_getline fgetline\n# define cmd_cookie cookie\n#endif\n    static int\tcall_depth = 0;\t\t// recursiveness\n#ifdef FEAT_EVAL\n    // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n    // location for storing error messages to be converted to an exception.\n    // This ensures that the do_errthrow() call in do_one_cmd() does not\n    // combine the messages stored by an earlier invocation of do_one_cmd()\n    // with the command name of the later one.  This would happen when\n    // BufWritePost autocommands are executed after a write error.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n#endif\n\n    // It's possible to create an endless loop with \":execute\", catch that\n    // here.  The value of 200 allows nested function calls, \":source\", etc.\n    // Allow 200 or 'maxfuncdepth', whatever is larger.\n    if (call_depth >= 200\n#ifdef FEAT_EVAL\n\t    && call_depth >= p_mfd\n#endif\n\t    )\n    {\n\temsg(_(e_command_too_recursive));\n#ifdef FEAT_EVAL\n\t// When converting to an exception, we do not include the command name\n\t// since this is not an error of the specific command.\n\tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n\tmsg_list = saved_msg_list;\n#endif\n\treturn FAIL;\n    }\n    ++call_depth;\n\n#ifdef FEAT_EVAL\n    CLEAR_FIELD(cstack);\n    cstack.cs_idx = -1;\n    ga_init2(&lines_ga, sizeof(wcmd_T), 10);\n\n    real_cookie = getline_cookie(fgetline, cookie);\n\n    // Inside a function use a higher nesting level.\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n    if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n\t++ex_nesting_level;\n\n    // Get the function or script name and the address where the next breakpoint\n    // line and the debug tick for a function or script are stored.\n    if (getline_is_func)\n    {\n\tfname = func_name(real_cookie);\n\tbreakpoint = func_breakpoint(real_cookie);\n\tdbg_tick = func_dbg_tick(real_cookie);\n    }\n    else if (getline_equal(fgetline, cookie, getsourceline))\n    {\n\tfname = SOURCING_NAME;\n\tbreakpoint = source_breakpoint(real_cookie);\n\tdbg_tick = source_dbg_tick(real_cookie);\n    }\n\n    /*\n     * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n     */\n    if (!recursive)\n    {\n\tforce_abort = FALSE;\n\tsuppress_errthrow = FALSE;\n    }\n\n    /*\n     * If requested, store and reset the global values controlling the\n     * exception handling (used when debugging).  Otherwise clear it to avoid\n     * a bogus compiler warning when the optimizer uses inline functions...\n     */\n    if (flags & DOCMD_EXCRESET)\n\tsave_dbg_stuff(&debug_saved);\n    else\n\tCLEAR_FIELD(debug_saved);\n\n    initial_trylevel = trylevel;\n\n    /*\n     * \"did_throw\" will be set to TRUE when an exception is being thrown.\n     */\n    did_throw = FALSE;\n#endif\n    /*\n     * \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n     * cancel the whole command line, and any if/endif or loop.\n     * If force_abort is set, we cancel everything.\n     */\n#ifdef FEAT_EVAL\n    did_emsg_cumul += did_emsg;\n#endif\n    did_emsg = FALSE;\n\n    /*\n     * KeyTyped is only set when calling vgetc().  Reset it here when not\n     * calling vgetc() (sourced command lines).\n     */\n    if (!(flags & DOCMD_KEYTYPED)\n\t\t\t       && !getline_equal(fgetline, cookie, getexline))\n\tKeyTyped = FALSE;\n\n    /*\n     * Continue executing command lines:\n     * - when inside an \":if\", \":while\" or \":for\"\n     * - for multiple commands on one line, separated with '|'\n     * - when repeating until there are no more lines (for \":source\")\n     */\n    next_cmdline = cmdline;\n    do\n    {\n#ifdef FEAT_EVAL\n\tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n#endif\n\n\t// stop skipping cmds for an error msg after all endif/while/for\n\tif (next_cmdline == NULL\n#ifdef FEAT_EVAL\n\t\t&& !force_abort\n\t\t&& cstack.cs_idx < 0\n\t\t&& !(getline_is_func && func_has_abort(real_cookie))\n#endif\n\t\t\t\t\t\t\t)\n\t{\n#ifdef FEAT_EVAL\n\t    did_emsg_cumul += did_emsg;\n#endif\n\t    did_emsg = FALSE;\n\t}\n\n\t/*\n\t * 1. If repeating a line in a loop, get a line from lines_ga.\n\t * 2. If no line given: Get an allocated line with fgetline().\n\t * 3. If a line is given: Make a copy, so we can mess with it.\n\t */\n\n#ifdef FEAT_EVAL\n\t// 1. If repeating, get a previous line from lines_ga.\n\tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n\t{\n\t    // Each '|' separated command is stored separately in lines_ga, to\n\t    // be able to jump to it.  Don't use next_cmdline now.\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    // Check if a function has returned or, unless it has an unclosed\n\t    // try conditional, aborted.\n\t    if (getline_is_func)\n\t    {\n# ifdef FEAT_PROFILE\n\t\tif (do_profiling == PROF_YES)\n\t\t    func_line_end(real_cookie);\n# endif\n\t\tif (func_has_ended(real_cookie))\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t    }\n#ifdef FEAT_PROFILE\n\t    else if (do_profiling == PROF_YES\n\t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_end();\n#endif\n\n\t    // Check if a sourced file hit a \":finish\" command.\n\t    if (source_finished(fgetline, cookie))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // If breakpoints have been added/deleted need to check for it.\n\t    if (breakpoint != NULL && dbg_tick != NULL\n\t\t\t\t\t\t   && *dbg_tick != debug_tick)\n\t    {\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n\n\t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n\t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n\t    // Did we encounter a breakpoint?\n\t    if (breakpoint != NULL && *breakpoint != 0\n\t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n\t    {\n\t\tdbg_breakpoint(fname, SOURCING_LNUM);\n\t\t// Find next breakpoint.\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n# ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t    {\n\t\tif (getline_is_func)\n\t\t    func_line_start(real_cookie, SOURCING_LNUM);\n\t\telse if (getline_equal(fgetline, cookie, getsourceline))\n\t\t    script_line_start();\n\t    }\n# endif\n\t}\n#endif\n\n\t// 2. If no line given, get an allocated line with fgetline().\n\tif (next_cmdline == NULL)\n\t{\n\t    /*\n\t     * Need to set msg_didout for the first line after an \":if\",\n\t     * otherwise the \":if\" will be overwritten.\n\t     */\n\t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n\t\tmsg_didout = TRUE;\n\t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n#ifdef FEAT_EVAL\n\t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n#else\n\t\t    0\n#endif\n\t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n\t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n\t    {\n\t\t// Don't call wait_return for aborted command line.  The NULL\n\t\t// returned for the end of a sourced file or executed function\n\t\t// doesn't do this.\n\t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n\t\t    need_wait_return = FALSE;\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    used_getline = TRUE;\n\n\t    /*\n\t     * Keep the first typed line.  Clear it when more lines are typed.\n\t     */\n\t    if (flags & DOCMD_KEEPLINE)\n\t    {\n\t\tvim_free(repeat_cmdline);\n\t\tif (count == 0)\n\t\t    repeat_cmdline = vim_strsave(next_cmdline);\n\t\telse\n\t\t    repeat_cmdline = NULL;\n\t    }\n\t}\n\n\t// 3. Make a copy of the command so we can mess with it.\n\telse if (cmdline_copy == NULL)\n\t{\n\t    next_cmdline = vim_strsave(next_cmdline);\n\t    if (next_cmdline == NULL)\n\t    {\n\t\temsg(_(e_out_of_memory));\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\tcmdline_copy = next_cmdline;\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Inside a while/for loop, and when the command looks like a \":while\"\n\t * or \":for\", the line is stored, because we may need it later when\n\t * looping.\n\t *\n\t * When there is a '|' and another command, it is stored separately,\n\t * because we need to be able to jump back to it from an\n\t * :endwhile/:endfor.\n\t *\n\t * Pass a different \"fgetline\" function to do_one_cmd() below,\n\t * that it stores lines in or reads them from \"lines_ga\".  Makes it\n\t * possible to define a function inside a while/for loop and handles\n\t * line continuation.\n\t */\n\tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n\t{\n\t    cmd_getline = get_loop_line;\n\t    cmd_cookie = (void *)&cmd_loop_cookie;\n\t    cmd_loop_cookie.lines_gap = &lines_ga;\n\t    cmd_loop_cookie.current_line = current_line;\n\t    cmd_loop_cookie.getline = fgetline;\n\t    cmd_loop_cookie.cookie = cookie;\n\t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n\n\t    // Save the current line when encountering it the first time.\n\t    if (current_line == lines_ga.ga_len\n\t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    current_line_before = current_line;\n\t}\n\telse\n\t{\n\t    cmd_getline = fgetline;\n\t    cmd_cookie = cookie;\n\t}\n\n\tdid_endif = FALSE;\n#endif\n\n\tif (count++ == 0)\n\t{\n\t    /*\n\t     * All output from the commands is put below each other, without\n\t     * waiting for a return. Don't do this when executing commands\n\t     * from a script or when being called recursive (e.g. for \":e\n\t     * +command file\").\n\t     */\n\t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n\t    {\n\t\tmsg_didout_before_start = msg_didout;\n\t\tmsg_didany = FALSE; // no output yet\n\t\tmsg_start();\n\t\tmsg_scroll = TRUE;  // put messages below each other\n\t\t++no_wait_return;   // don't wait for return until finished\n\t\t++RedrawingDisabled;\n\t\tdid_inc = TRUE;\n\t    }\n\t}\n\n\tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n\t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n\n\t/*\n\t * 2. Execute one '|' separated command.\n\t *    do_one_cmd() will return NULL if there is no trailing '|'.\n\t *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n\t */\n\t++recursive;\n\tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n#ifdef FEAT_EVAL\n\t\t\t\t&cstack,\n#endif\n\t\t\t\tcmd_getline, cmd_cookie);\n\t--recursive;\n\n#ifdef FEAT_EVAL\n\tif (cmd_cookie == (void *)&cmd_loop_cookie)\n\t    // Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n\t    // incremented when defining a function.\n\t    current_line = cmd_loop_cookie.current_line;\n#endif\n\n\tif (next_cmdline == NULL)\n\t{\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    /*\n\t     * If the command was typed, remember it for the ':' register.\n\t     * Do this AFTER executing the command to make :@: work.\n\t     */\n\t    if (getline_equal(fgetline, cookie, getexline)\n\t\t\t\t\t\t  && new_last_cmdline != NULL)\n\t    {\n\t\tvim_free(last_cmdline);\n\t\tlast_cmdline = new_last_cmdline;\n\t\tnew_last_cmdline = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    // need to copy the command after the '|' to cmdline_copy, for the\n\t    // next do_one_cmd()\n\t    STRMOVE(cmdline_copy, next_cmdline);\n\t    next_cmdline = cmdline_copy;\n\t}\n\n\n#ifdef FEAT_EVAL\n\t// reset did_emsg for a function that is not aborted by an error\n\tif (did_emsg && !force_abort\n\t\t&& getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t      && !func_has_abort(real_cookie))\n\t{\n\t    // did_emsg_cumul is not set here\n\t    did_emsg = FALSE;\n\t}\n\n\tif (cstack.cs_looplevel > 0)\n\t{\n\t    ++current_line;\n\n\t    /*\n\t     * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n\t     * If we were executing commands, jump back to the \":while\" or\n\t     * \":for\".\n\t     * If we were not executing commands, decrement cs_looplevel.\n\t     */\n\t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n\t    {\n\t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n\t\t// Jump back to the matching \":while\" or \":for\".  Be careful\n\t\t// not to use a cs_line[] from an entry that isn't a \":while\"\n\t\t// or \":for\": It would make \"current_line\" invalid and can\n\t\t// cause a crash.\n\t\tif (!did_emsg && !got_int && !did_throw\n\t\t\t&& cstack.cs_idx >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n\t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n\t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n\t\t{\n\t\t    current_line = cstack.cs_line[cstack.cs_idx];\n\t\t\t\t\t\t// remember we jumped there\n\t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n\t\t    line_breakcheck();\t\t// check if CTRL-C typed\n\n\t\t    // Check for the next breakpoint at or after the \":while\"\n\t\t    // or \":for\".\n\t\t    if (breakpoint != NULL)\n\t\t    {\n\t\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n\t\t\t*dbg_tick = debug_tick;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // can only get here with \":endwhile\" or \":endfor\"\n\t\t    if (cstack.cs_idx >= 0)\n\t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n\t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n\t\t}\n\t    }\n\n\t    /*\n\t     * For a \":while\" or \":for\" we need to remember the line number.\n\t     */\n\t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n\t    {\n\t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n\t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n\t    }\n\t}\n\n\t// Check for the next breakpoint after a watchexpression\n\tif (breakpoint != NULL && has_watchexpr())\n\t{\n\t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n\t    *dbg_tick = debug_tick;\n\t}\n\n\t/*\n\t * When not inside any \":while\" loop, clear remembered lines.\n\t */\n\tif (cstack.cs_looplevel == 0)\n\t{\n\t    if (lines_ga.ga_len > 0)\n\t    {\n\t\tSOURCING_LNUM =\n\t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n\t\tfree_cmdlines(&lines_ga);\n\t    }\n\t    current_line = 0;\n\t}\n\n\t/*\n\t * A \":finally\" makes did_emsg, got_int, and did_throw pending for\n\t * being restored at the \":endtry\".  Reset them here and set the\n\t * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n\t * This includes the case where a missing \":endif\", \":endwhile\" or\n\t * \":endfor\" was detected by the \":finally\" itself.\n\t */\n\tif (cstack.cs_lflags & CSL_HAD_FINA)\n\t{\n\t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n\t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n\t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n\t\t    did_throw ? (void *)current_exception : NULL);\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n\t}\n\n\t// Update global \"trylevel\" for recursive calls to do_cmdline() from\n\t// within this loop.\n\ttrylevel = initial_trylevel + cstack.cs_trylevel;\n\n\t/*\n\t * If the outermost try conditional (across function calls and sourced\n\t * files) is aborted because of an error, an interrupt, or an uncaught\n\t * exception, cancel everything.  If it is left normally, reset\n\t * force_abort to get the non-EH compatible abortion behavior for\n\t * the rest of the script.\n\t */\n\tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n\t    force_abort = FALSE;\n\n\t// Convert an interrupt to an exception if appropriate.\n\t(void)do_intthrow(&cstack);\n#endif // FEAT_EVAL\n\n    }\n    /*\n     * Continue executing command lines when:\n     * - no CTRL-C typed, no aborting error, no exception thrown or try\n     *   conditionals need to be checked for executing finally clauses or\n     *   catching an interrupt exception\n     * - didn't get an error message or lines are not typed\n     * - there is a command after '|', inside a :if, :while, :for or :try, or\n     *   looping for \":source\" command or function call.\n     */\n    while (!((got_int\n#ifdef FEAT_EVAL\n\t\t    || (did_emsg && (force_abort || in_vim9script()))\n\t\t    || did_throw\n#endif\n\t     )\n#ifdef FEAT_EVAL\n\t\t&& cstack.cs_trylevel == 0\n#endif\n\t    )\n\t    && !(did_emsg\n#ifdef FEAT_EVAL\n\t\t// Keep going when inside try/catch, so that the error can be\n\t\t// deal with, except when it is a syntax error, it may cause\n\t\t// the :endtry to be missed.\n\t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n#endif\n\t\t&& used_getline\n\t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n\t\t\t       || getline_equal(fgetline, cookie, getexline)))\n\t    && (next_cmdline != NULL\n#ifdef FEAT_EVAL\n\t\t\t|| cstack.cs_idx >= 0\n#endif\n\t\t\t|| (flags & DOCMD_REPEAT)));\n\n    vim_free(cmdline_copy);\n    did_emsg_syntax = FALSE;\n#ifdef FEAT_EVAL\n    free_cmdlines(&lines_ga);\n    ga_clear(&lines_ga);\n\n    if (cstack.cs_idx >= 0)\n    {\n\t/*\n\t * If a sourced file or executed function ran to its end, report the\n\t * unclosed conditional.\n\t * In Vim9 script do not give a second error, executing aborts after\n\t * the first one.\n\t */\n\tif (!got_int && !did_throw && !aborting()\n\t\t&& !(did_emsg && in_vim9script())\n\t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n\t\t\t&& !source_finished(fgetline, cookie))\n\t\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t    && !func_has_ended(real_cookie))))\n\t{\n\t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n\t\temsg(_(e_missing_endtry));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n\t\temsg(_(e_missing_endwhile));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n\t\temsg(_(e_missing_endfor));\n\t    else\n\t\temsg(_(e_missing_endif));\n\t}\n\n\t/*\n\t * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n\t * \":endtry\" in a sourced file or executed function.  If the try\n\t * conditional is in its finally clause, ignore anything pending.\n\t * If it is in a catch clause, finish the caught exception.\n\t * Also cleanup any \"cs_forinfo\" structures.\n\t */\n\tdo\n\t{\n\t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n\t    if (idx >= 0)\n\t\t--idx;\t    // remove try block not in its finally clause\n\t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack.cs_looplevel);\n\t}\n\twhile (cstack.cs_idx >= 0);\n\ttrylevel = initial_trylevel;\n    }\n\n    // If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n    // lack was reported above and the error message is to be converted to an\n    // exception, do this now after rewinding the cstack.\n    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n    if (trylevel == 0)\n    {\n\t// Just in case did_throw got set but current_exception wasn't.\n\tif (current_exception == NULL)\n\t    did_throw = FALSE;\n\n\t/*\n\t * When an exception is being thrown out of the outermost try\n\t * conditional, discard the uncaught exception, disable the conversion\n\t * of interrupts or errors to exceptions, and ensure that no more\n\t * commands are executed.\n\t */\n\tif (did_throw)\n\t    handle_did_throw();\n\n\t/*\n\t * On an interrupt or an aborting error not converted to an exception,\n\t * disable the conversion of errors to exceptions.  (Interrupts are not\n\t * converted anymore, here.) This enables also the interrupt message\n\t * when force_abort is set and did_emsg unset in case of an interrupt\n\t * from a finally clause after an error.\n\t */\n\telse if (got_int || (did_emsg && force_abort))\n\t    suppress_errthrow = TRUE;\n    }\n\n    /*\n     * The current cstack will be freed when do_cmdline() returns.  An uncaught\n     * exception will have to be rethrown in the previous cstack.  If a function\n     * has just returned or a script file was just finished and the previous\n     * cstack belongs to the same function or, respectively, script file, it\n     * will have to be checked for finally clauses to be executed due to the\n     * \":return\" or \":finish\".  This is done in do_one_cmd().\n     */\n    if (did_throw)\n\tneed_rethrow = TRUE;\n    if ((getline_equal(fgetline, cookie, getsourceline)\n\t\t&& ex_nesting_level > source_level(real_cookie))\n\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n    {\n\tif (!did_throw)\n\t    check_cstack = TRUE;\n    }\n    else\n    {\n\t// When leaving a function, reduce nesting level.\n\tif (getline_equal(fgetline, cookie, get_func_line))\n\t    --ex_nesting_level;\n\t/*\n\t * Go to debug mode when returning from a function in which we are\n\t * single-stepping.\n\t */\n\tif ((getline_equal(fgetline, cookie, getsourceline)\n\t\t    || getline_equal(fgetline, cookie, get_func_line))\n\t\t&& ex_nesting_level + 1 <= debug_break_level)\n\t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n\t\t    ? (char_u *)_(\"End of sourced file\")\n\t\t    : (char_u *)_(\"End of function\"));\n    }\n\n    /*\n     * Restore the exception environment (done after returning from the\n     * debugger).\n     */\n    if (flags & DOCMD_EXCRESET)\n\trestore_dbg_stuff(&debug_saved);\n\n    msg_list = saved_msg_list;\n\n    // Cleanup if \"cs_emsg_silent_list\" remains.\n    if (cstack.cs_emsg_silent_list != NULL)\n    {\n\teslist_T *elem, *temp;\n\n\tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n\t{\n\t    temp = elem->next;\n\t    vim_free(elem);\n\t}\n    }\n#endif // FEAT_EVAL\n\n    /*\n     * If there was too much output to fit on the command line, ask the user to\n     * hit return before redrawing the screen. With the \":global\" command we do\n     * this only once after the command is finished.\n     */\n    if (did_inc)\n    {\n\t--RedrawingDisabled;\n\t--no_wait_return;\n\tmsg_scroll = FALSE;\n\n\t/*\n\t * When just finished an \":if\"-\":else\" which was typed, no need to\n\t * wait for hit-return.  Also for an error situation.\n\t */\n\tif (retval == FAIL\n#ifdef FEAT_EVAL\n\t\t|| (did_endif && KeyTyped && !did_emsg)\n#endif\n\t\t\t\t\t    )\n\t{\n\t    need_wait_return = FALSE;\n\t    msg_didany = FALSE;\t\t// don't wait when restarting edit\n\t}\n\telse if (need_wait_return)\n\t{\n\t    /*\n\t     * The msg_start() above clears msg_didout. The wait_return we do\n\t     * here should not overwrite the command that may be shown before\n\t     * doing that.\n\t     */\n\t    msg_didout |= msg_didout_before_start;\n\t    wait_return(FALSE);\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    did_endif = FALSE;  // in case do_cmdline used recursively\n#else\n    /*\n     * Reset if_level, in case a sourced script file contains more \":if\" than\n     * \":endif\" (could be \":if x | foo | endif\").\n     */\n    if_level = 0;\n#endif\n\n    --call_depth;\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Handle when \"did_throw\" is set after executing commands.\n */\n    void\nhandle_did_throw()\n{\n    char\t*p = NULL;\n    msglist_T\t*messages = NULL;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * If the uncaught exception is a user exception, report it as an\n     * error.  If it is an error exception, display the saved error\n     * message now.  For an interrupt exception, do nothing; the\n     * interrupt message is given elsewhere.\n     */\n    switch (current_exception->type)\n    {\n\tcase ET_USER:\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t    _(e_exception_not_caught_str),\n\t\t    current_exception->value);\n\t    p = (char *)vim_strsave(IObuff);\n\t    break;\n\tcase ET_ERROR:\n\t    messages = current_exception->messages;\n\t    current_exception->messages = NULL;\n\t    break;\n\tcase ET_INTERRUPT:\n\t    break;\n    }\n\n    estack_push(ETYPE_EXCEPT, current_exception->throw_name,\n\t\t\t\t\tcurrent_exception->throw_lnum);\n    ESTACK_CHECK_SETUP\n    current_exception->throw_name = NULL;\n\n    discard_current_exception();\t// uses IObuff if 'verbose'\n    suppress_errthrow = TRUE;\n    force_abort = TRUE;\n\n    if (messages != NULL)\n    {\n\tdo\n\t{\n\t    msglist_T\t*next = messages->next;\n\t    int\t\tsave_compiling = estack_compiling;\n\n\t    estack_compiling = messages->msg_compiling;\n\t    emsg(messages->msg);\n\t    vim_free(messages->msg);\n\t    vim_free(messages->sfile);\n\t    vim_free(messages);\n\t    messages = next;\n\t    estack_compiling = save_compiling;\n\t}\n\twhile (messages != NULL);\n    }\n    else if (p != NULL)\n    {\n\temsg(p);\n\tvim_free(p);\n    }\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n}\n\n/*\n * Obtain a line when inside a \":while\" or \":for\" loop.\n */\n    static char_u *\nget_loop_line(int c, void *cookie, int indent, getline_opt_T options)\n{\n    struct loop_cookie\t*cp = (struct loop_cookie *)cookie;\n    wcmd_T\t\t*wp;\n    char_u\t\t*line;\n\n    if (cp->current_line + 1 >= cp->lines_gap->ga_len)\n    {\n\tif (cp->repeating)\n\t    return NULL;\t// trying to read past \":endwhile\"/\":endfor\"\n\n\t// First time inside the \":while\"/\":for\": get line normally.\n\tif (cp->getline == NULL)\n\t    line = getcmdline(c, 0L, indent, 0);\n\telse\n\t    line = cp->getline(c, cp->cookie, indent, options);\n\tif (line != NULL && store_loop_line(cp->lines_gap, line) == OK)\n\t    ++cp->current_line;\n\n\treturn line;\n    }\n\n    KeyTyped = FALSE;\n    ++cp->current_line;\n    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;\n    SOURCING_LNUM = wp->lnum;\n    return vim_strsave(wp->line);\n}\n\n/*\n * Store a line in \"gap\" so that a \":while\" loop can execute it again.\n */\n    static int\nstore_loop_line(garray_T *gap, char_u *line)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].line = vim_strsave(line);\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].lnum = SOURCING_LNUM;\n    ++gap->ga_len;\n    return OK;\n}\n\n/*\n * Free the lines stored for a \":while\" or \":for\" loop.\n */\n    static void\nfree_cmdlines(garray_T *gap)\n{\n    while (gap->ga_len > 0)\n    {\n\tvim_free(((wcmd_T *)(gap->ga_data))[gap->ga_len - 1].line);\n\t--gap->ga_len;\n    }\n}\n#endif\n\n/*\n * If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals\n * \"func\".  * Otherwise return TRUE when \"fgetline\" equals \"func\".\n */\n    int\ngetline_equal(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie UNUSED,\t\t// argument for fgetline()\n    char_u\t*(*func)(int, void *, int, getline_opt_T))\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // function that's originally used to obtain the lines.  This may be\n    // nested several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return gp == func;\n#else\n    return fgetline == func;\n#endif\n}\n\n/*\n * If \"fgetline\" is get_loop_line(), return the cookie used by the original\n * getline function.  Otherwise return \"cookie\".\n */\n    void *\ngetline_cookie(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return cp;\n#else\n    return cookie;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROT)\n/*\n * Get the next line source line without advancing.\n */\n    char_u *\ngetline_peek(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n    wcmd_T\t\t*wp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tif (cp->current_line + 1 < cp->lines_gap->ga_len)\n\t{\n\t    // executing lines a second time, use the stored copy\n\t    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line + 1;\n\t    return wp->line;\n\t}\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    if (gp == getsourceline)\n\treturn source_nextline(cp);\n    return NULL;\n}\n#endif\n\n\n/*\n * Helper function to apply an offset for buffer commands, i.e. \":bdelete\",\n * \":bwipeout\", etc.\n * Returns the buffer number.\n */\n    static int\ncompute_buffer_local_count(int addr_type, int lnum, int offset)\n{\n    buf_T   *buf;\n    buf_T   *nextbuf;\n    int     count = offset;\n\n    buf = firstbuf;\n    while (buf->b_next != NULL && buf->b_fnum < lnum)\n\tbuf = buf->b_next;\n    while (count != 0)\n    {\n\tcount += (offset < 0) ? 1 : -1;\n\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\tif (nextbuf == NULL)\n\t    break;\n\tbuf = nextbuf;\n\tif (addr_type == ADDR_LOADED_BUFFERS)\n\t    // skip over unloaded buffers\n\t    while (buf->b_ml.ml_mfp == NULL)\n\t    {\n\t\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\t\tif (nextbuf == NULL)\n\t\t    break;\n\t\tbuf = nextbuf;\n\t    }\n    }\n    // we might have gone too far, last buffer is not loadedd\n    if (addr_type == ADDR_LOADED_BUFFERS)\n\twhile (buf->b_ml.ml_mfp == NULL)\n\t{\n\t    nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;\n\t    if (nextbuf == NULL)\n\t\tbreak;\n\t    buf = nextbuf;\n\t}\n    return buf->b_fnum;\n}\n\n/*\n * Return the window number of \"win\".\n * When \"win\" is NULL return the number of windows.\n */\n    static int\ncurrent_win_nr(win_T *win)\n{\n    win_T\t*wp;\n    int\t\tnr = 0;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\t++nr;\n\tif (wp == win)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncurrent_tab_nr(tabpage_T *tab)\n{\n    tabpage_T\t*tp;\n    int\t\tnr = 0;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\t++nr;\n\tif (tp == tab)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncomment_start(char_u *p, int starts_with_colon UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\treturn p[0] == '#' && !starts_with_colon;\n#endif\n    return *p == '\"';\n}\n\n# define CURRENT_WIN_NR current_win_nr(curwin)\n# define LAST_WIN_NR current_win_nr(NULL)\n# define CURRENT_TAB_NR current_tab_nr(curtab)\n# define LAST_TAB_NR current_tab_nr(NULL)\n\n/*\n * Execute one Ex command.\n *\n * If \"flags\" has DOCMD_VERBOSE, the command will be included in the error\n * message.\n *\n * 1. skip comment lines and leading space\n * 2. handle command modifiers\n * 3. find the command\n * 4. parse range\n * 5. Parse the command.\n * 6. parse arguments\n * 7. switch on command name\n *\n * Note: \"fgetline\" can be NULL.\n *\n * This function may be called recursively!\n */\n    static char_u *\ndo_one_cmd(\n    char_u\t**cmdlinep,\n    int\t\tflags,\n#ifdef FEAT_EVAL\n    cstack_T\t*cstack,\n#endif\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t*p;\n    linenr_T\tlnum;\n    long\tn;\n    char\t*errormsg = NULL;\t// error message\n    char_u\t*after_modifier = NULL;\n    exarg_T\tea;\t\t\t// Ex command arguments\n    cmdmod_T\tsave_cmdmod;\n    int\t\tsave_reg_executing = reg_executing;\n    int\t\tsave_pending_end_reg_executing = pending_end_reg_executing;\n    int\t\tni;\t\t\t// set when Not Implemented\n    char_u\t*cmd;\n    int\t\tstarts_with_colon = FALSE;\n#ifdef FEAT_EVAL\n    int\t\tmay_have_range;\n    int\t\tvim9script;\n    int\t\tdid_set_expr_line = FALSE;\n#endif\n    int\t\tsourcing = flags & DOCMD_VERBOSE;\n    int\t\tdid_append_cmd = FALSE;\n\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n#ifdef FEAT_EVAL\n    ++ex_nesting_level;\n#endif\n\n    // When the last file has not been edited :q has to be typed twice.\n    if (quitmore\n#ifdef FEAT_EVAL\n\t    // avoid that a function call in 'statusline' does this\n\t    && !getline_equal(fgetline, cookie, get_func_line)\n#endif\n\t    // avoid that an autocommand, e.g. QuitPre, does this\n\t    && !getline_equal(fgetline, cookie, getnextac))\n\t--quitmore;\n\n    /*\n     * Reset browse, confirm, etc..  They are restored when returning, for\n     * recursive calls.\n     */\n    save_cmdmod = cmdmod;\n\n    // \"#!anything\" is handled like a comment.\n    if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!')\n\tgoto doend;\n\n/*\n * 1. Skip comment lines and leading white space and colons.\n * 2. Handle command modifiers.\n */\n    // The \"ea\" structure holds the arguments that can be used.\n    ea.cmd = *cmdlinep;\n    ea.cmdlinep = cmdlinep;\n    ea.getline = fgetline;\n    ea.cookie = cookie;\n#ifdef FEAT_EVAL\n    ea.cstack = cstack;\n    starts_with_colon = *skipwhite(ea.cmd) == ':';\n#endif\n    if (parse_command_modifiers(&ea, &errormsg, &cmdmod, FALSE) == FAIL)\n\tgoto doend;\n    apply_cmdmod(&cmdmod);\n#ifdef FEAT_EVAL\n    vim9script = in_vim9script();\n#endif\n    after_modifier = ea.cmd;\n\n#ifdef FEAT_EVAL\n    ea.skip = did_emsg || got_int || did_throw || (cstack->cs_idx >= 0\n\t\t\t && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE));\n#else\n    ea.skip = (if_level > 0);\n#endif\n\n/*\n * 3. Skip over the range to find the command.  Let \"p\" point to after it.\n *\n * We need the command to know what kind of range it uses.\n */\n    cmd = ea.cmd;\n#ifdef FEAT_EVAL\n    // In Vim9 script a colon is required before the range.  This may also be\n    // after command modifiers.\n    if (vim9script && (flags & DOCMD_RANGEOK) == 0)\n    {\n\tmay_have_range = FALSE;\n\tfor (p = ea.cmd; p >= *cmdlinep; --p)\n\t{\n\t    if (*p == ':')\n\t\tmay_have_range = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n    }\n    else\n\tmay_have_range = TRUE;\n    if (may_have_range)\n#endif\n\tea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\n#ifdef FEAT_EVAL\n    if (vim9script && !may_have_range)\n    {\n\tif (ea.cmd == cmd + 1 && *cmd == '$')\n\t    // should be \"$VAR = val\"\n\t    --ea.cmd;\n\tp = find_ex_command(&ea, NULL, lookup_scriptitem, NULL);\n\tif (ea.cmdidx == CMD_SIZE)\n\t{\n\t    char_u *ar = skip_range(ea.cmd, TRUE, NULL);\n\n\t    // If a ':' before the range is missing, give a clearer error\n\t    // message.\n\t    if (ar > ea.cmd && !ea.skip)\n\t    {\n\t\tsemsg(_(e_colon_required_before_range_str), ea.cmd);\n\t\tgoto doend;\n\t    }\n\t}\n    }\n    else\n#endif\n\tp = find_ex_command(&ea, NULL, NULL, NULL);\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    // Count this line for profiling if skip is TRUE.\n    if (do_profiling == PROF_YES\n\t    && (!ea.skip || cstack->cs_idx == 0 || (cstack->cs_idx > 0\n\t\t     && (cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE))))\n    {\n\tint skip = did_emsg || got_int || did_throw;\n\n\tif (ea.cmdidx == CMD_catch)\n\t    skip = !skip && !(cstack->cs_idx >= 0\n\t\t\t  && (cstack->cs_flags[cstack->cs_idx] & CSF_THROWN)\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx] & CSF_CAUGHT));\n\telse if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif)\n\t    skip = skip || !(cstack->cs_idx >= 0\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t\t\t  & (CSF_ACTIVE | CSF_TRUE)));\n\telse if (ea.cmdidx == CMD_finally)\n\t    skip = FALSE;\n\telse if (ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endtry\n\t\t&& ea.cmdidx != CMD_endwhile)\n\t    skip = ea.skip;\n\n\tif (!skip)\n\t{\n\t    if (getline_equal(fgetline, cookie, get_func_line))\n\t\tfunc_line_exec(getline_cookie(fgetline, cookie));\n\t    else if (getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_exec();\n\t}\n    }\n# endif\n\n    // May go to debug mode.  If this happens and the \">quit\" debug command is\n    // used, throw an interrupt exception and skip the next command.\n    dbg_check_breakpoint(&ea);\n    if (!ea.skip && got_int)\n    {\n\tea.skip = TRUE;\n\t(void)do_intthrow(cstack);\n    }\n#endif\n\n/*\n * 4. parse a range specifier of the form: addr [,addr] [;addr] ..\n *\n * where 'addr' is:\n *\n * %\t      (entire file)\n * $  [+-NUM]\n * 'x [+-NUM] (where x denotes a currently defined mark)\n * .  [+-NUM]\n * [+-NUM]..\n * NUM\n *\n * The ea.cmd pointer is updated to point to the first character following the\n * range spec. If an initial address is found, but no second, the upper bound\n * is equal to the lower.\n */\n\n    // ea.addr_type for user commands is set by find_ucmd\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n    {\n\tif (ea.cmdidx != CMD_SIZE)\n\t    ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;\n\telse\n\t    ea.addr_type = ADDR_LINES;\n\n\t// :wincmd range depends on the argument.\n\tif (ea.cmdidx == CMD_wincmd && p != NULL)\n\t    get_wincmd_addr_type(skipwhite(p), &ea);\n#ifdef FEAT_QUICKFIX\n\t// :.cc in quickfix window uses line number\n\tif ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) && bt_quickfix(curbuf))\n\t    ea.addr_type = ADDR_OTHER;\n#endif\n    }\n\n    ea.cmd = cmd;\n#ifdef FEAT_EVAL\n    if (!may_have_range)\n\tea.line1 = ea.line2 = default_address(&ea);\n    else\n#endif\n\tif (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t    goto doend;\n\n/*\n * 5. Parse the command.\n */\n\n    /*\n     * Skip ':' and any white space\n     */\n    ea.cmd = skipwhite(ea.cmd);\n    while (*ea.cmd == ':')\n\tea.cmd = skipwhite(ea.cmd + 1);\n\n    /*\n     * If we got a line, but no command, then go to the line.\n     * If we find a '|' or '\\n' we set ea.nextcmd.\n     */\n    if (*ea.cmd == NUL || comment_start(ea.cmd, starts_with_colon)\n\t\t\t       || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL)\n    {\n\t/*\n\t * strange vi behaviour:\n\t * \":3\"\t\tjumps to line 3\n\t * \":3|...\"\tprints line 3  (not in Vim9 script)\n\t * \":|\"\t\tprints current line  (not in Vim9 script)\n\t */\n\tif (ea.skip)\t    // skip this if inside :if\n\t    goto doend;\n\terrormsg = ex_range_without_command(&ea);\n\tgoto doend;\n    }\n\n    // If this looks like an undefined user command and there are CmdUndefined\n    // autocommands defined, trigger the matching autocommands.\n    if (p != NULL && ea.cmdidx == CMD_SIZE && !ea.skip\n\t    && ASCII_ISUPPER(*ea.cmd)\n\t    && has_cmdundefined())\n    {\n\tint ret;\n\n\tp = ea.cmd;\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n\tp = vim_strnsave(ea.cmd, p - ea.cmd);\n\tret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);\n\tvim_free(p);\n\t// If the autocommands did something and didn't cause an error, try\n\t// finding the command again.\n\tp = (ret\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t\t) ? find_ex_command(&ea, NULL, NULL, NULL) : ea.cmd;\n    }\n\n    if (p == NULL)\n    {\n\tif (!ea.skip)\n\t    errormsg = _(e_ambiguous_use_of_user_defined_command);\n\tgoto doend;\n    }\n    // Check for wrong commands.\n    if (*p == '!' && ea.cmd[1] == 0151 && ea.cmd[0] == 78\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\terrormsg = uc_fun_cmd();\n\tgoto doend;\n    }\n\n    if (ea.cmdidx == CMD_SIZE)\n    {\n\tif (!ea.skip)\n\t{\n\t    STRCPY(IObuff, _(e_not_an_editor_command));\n\t    if (!sourcing)\n\t    {\n\t\t// If the modifier was parsed OK the error must be in the\n\t\t// following command\n\t\tif (after_modifier != NULL)\n\t\t    append_command(after_modifier);\n\t\telse\n\t\t    append_command(*cmdlinep);\n\t\tdid_append_cmd = TRUE;\n\t    }\n\t    errormsg = (char *)IObuff;\n\t    did_emsg_syntax = TRUE;\n\t}\n\tgoto doend;\n    }\n\n    ni = (!IS_USER_CMDIDX(ea.cmdidx)\n\t    && (cmdnames[ea.cmdidx].cmd_func == ex_ni\n#ifdef HAVE_EX_SCRIPT_NI\n\t     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni\n#endif\n\t     ));\n\n#ifndef FEAT_EVAL\n    /*\n     * When the expression evaluation is disabled, recognize the \":if\" and\n     * \":endif\" commands and ignore everything in between it.\n     */\n    if (ea.cmdidx == CMD_if)\n\t++if_level;\n    if (if_level)\n    {\n\tif (ea.cmdidx == CMD_endif)\n\t    --if_level;\n\tgoto doend;\n    }\n\n#endif\n\n    // forced commands\n    if (*p == '!' && ea.cmdidx != CMD_substitute\n\t    && ea.cmdidx != CMD_smagic && ea.cmdidx != CMD_snomagic)\n    {\n\t++p;\n\tea.forceit = TRUE;\n    }\n    else\n\tea.forceit = FALSE;\n\n/*\n * 6. Parse arguments.  Then check for errors.\n */\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n\tea.argt = (long)cmdnames[(int)ea.cmdidx].cmd_argt;\n\n    if (!ea.skip)\n    {\n#ifdef HAVE_SANDBOX\n\tif (sandbox != 0 && !(ea.argt & EX_SBOXOK))\n\t{\n\t    // Command not allowed in sandbox.\n\t    errormsg = _(e_not_allowed_in_sandbox);\n\t    goto doend;\n\t}\n#endif\n\tif (restricted != 0 && (ea.argt & EX_RESTRICT))\n\t{\n\t    errormsg = _(e_command_not_allowed_in_rvim);\n\t    goto doend;\n\t}\n\tif (!curbuf->b_p_ma && (ea.argt & EX_MODIFY))\n\t{\n\t    // Command not allowed in non-'modifiable' buffer\n\t    errormsg = _(e_cannot_make_changes_modifiable_is_off);\n\t    goto doend;\n\t}\n\n\tif (!IS_USER_CMDIDX(ea.cmdidx))\n\t{\n#ifdef FEAT_CMDWIN\n\t    if (cmdwin_type != 0 && !(ea.argt & EX_CMDWIN))\n\t    {\n\t\t// Command not allowed in the command line window\n\t\terrormsg = _(e_invalid_in_cmdline_window);\n\t\tgoto doend;\n\t    }\n#endif\n\t    if (text_locked() && !(ea.argt & EX_LOCK_OK))\n\t    {\n\t\t// Command not allowed when text is locked\n\t\terrormsg = _(get_text_locked_msg());\n\t\tgoto doend;\n\t    }\n\t}\n\n\t// Disallow editing another buffer when \"curbuf_lock\" is set.\n\t// Do allow \":checktime\" (it is postponed).\n\t// Do allow \":edit\" (check for an argument later).\n\t// Do allow \":file\" with no arguments (check for an argument later).\n\tif (!(ea.argt & (EX_CMDWIN | EX_LOCK_OK))\n\t\t&& ea.cmdidx != CMD_checktime\n\t\t&& ea.cmdidx != CMD_edit\n\t\t&& ea.cmdidx != CMD_file\n\t\t&& !IS_USER_CMDIDX(ea.cmdidx)\n\t\t&& curbuf_locked())\n\t    goto doend;\n\n\tif (!ni && !(ea.argt & EX_RANGE) && ea.addr_count > 0)\n\t{\n\t    errormsg = _(e_no_range_allowed);\n\t    goto doend;\n\t}\n    }\n\n    if (!ni && !(ea.argt & EX_BANG) && ea.forceit)\n    {\n\terrormsg = _(e_no_bang_allowed);\n\tgoto doend;\n    }\n\n    /*\n     * Don't complain about the range if it is not used\n     * (could happen if line_count is accidentally set to 0).\n     */\n    if (!ea.skip && !ni && (ea.argt & EX_RANGE))\n    {\n\t/*\n\t * If the range is backwards, ask for confirmation and, if given, swap\n\t * ea.line1 & ea.line2 so it's forwards again.\n\t * When global command is busy, don't ask, will fail below.\n\t */\n\tif (!global_busy && ea.line1 > ea.line2)\n\t{\n\t    if (msg_silent == 0)\n\t    {\n\t\tif (sourcing || exmode_active)\n\t\t{\n\t\t    errormsg = _(e_backwards_range_given);\n\t\t    goto doend;\n\t\t}\n\t\tif (ask_yesno((char_u *)\n\t\t\t_(\"Backwards range given, OK to swap\"), FALSE) != 'y')\n\t\t    goto doend;\n\t    }\n\t    lnum = ea.line1;\n\t    ea.line1 = ea.line2;\n\t    ea.line2 = lnum;\n\t}\n\tif ((errormsg = invalid_range(&ea)) != NULL)\n\t    goto doend;\n    }\n\n    if ((ea.addr_type == ADDR_OTHER) && ea.addr_count == 0)\n\t// default is 1, not cursor\n\tea.line2 = 1;\n\n    correct_range(&ea);\n\n#ifdef FEAT_FOLDING\n    if (((ea.argt & EX_WHOLEFOLD) || ea.addr_count >= 2) && !global_busy\n\t    && ea.addr_type == ADDR_LINES)\n    {\n\t// Put the first line at the start of a closed fold, put the last line\n\t// at the end of a closed fold.\n\t(void)hasFolding(ea.line1, &ea.line1, NULL);\n\t(void)hasFolding(ea.line2, NULL, &ea.line2);\n    }\n#endif\n\n#ifdef FEAT_QUICKFIX\n    /*\n     * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'\n     * option here, so things like % get expanded.\n     */\n    p = replace_makeprg(&ea, p, cmdlinep);\n    if (p == NULL)\n\tgoto doend;\n#endif\n\n    /*\n     * Skip to start of argument.\n     * Don't do this for the \":!\" command, because \":!! -l\" needs the space.\n     */\n    if (ea.cmdidx == CMD_bang)\n\tea.arg = p;\n    else\n\tea.arg = skipwhite(p);\n\n    // \":file\" cannot be run with an argument when \"curbuf_lock\" is set\n    if (ea.cmdidx == CMD_file && *ea.arg != NUL && curbuf_locked())\n\tgoto doend;\n\n    /*\n     * Check for \"++opt=val\" argument.\n     * Must be first, allow \":w ++enc=utf8 !cmd\"\n     */\n    if (ea.argt & EX_ARGOPT)\n\twhile (ea.arg[0] == '+' && ea.arg[1] == '+')\n\t    if (getargopt(&ea) == FAIL && !ni)\n\t    {\n\t\terrormsg = _(e_invalid_argument);\n\t\tgoto doend;\n\t    }\n\n    if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update)\n    {\n\tif (*ea.arg == '>')\t\t\t// append\n\t{\n\t    if (*++ea.arg != '>')\t\t// typed wrong\n\t    {\n\t\terrormsg = _(e_use_w_or_w_gt_gt);\n\t\tgoto doend;\n\t    }\n\t    ea.arg = skipwhite(ea.arg + 1);\n\t    ea.append = TRUE;\n\t}\n\telse if (*ea.arg == '!' && ea.cmdidx == CMD_write)  // :w !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_read)\n    {\n\tif (ea.forceit)\n\t{\n\t    ea.usefilter = TRUE;\t\t// :r! filter if ea.forceit\n\t    ea.forceit = FALSE;\n\t}\n\telse if (*ea.arg == '!')\t\t// :r !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)\n    {\n\tea.amount = 1;\n\twhile (*ea.arg == *ea.cmd)\t\t// count number of '>' or '<'\n\t{\n\t    ++ea.arg;\n\t    ++ea.amount;\n\t}\n\tea.arg = skipwhite(ea.arg);\n    }\n\n    /*\n     * Check for \"+command\" argument, before checking for next command.\n     * Don't do this for \":read !cmd\" and \":write !cmd\".\n     */\n    if ((ea.argt & EX_CMDARG) && !ea.usefilter)\n\tea.do_ecmd_cmd = getargcmd(&ea.arg);\n\n    /*\n     * For commands that do not use '|' inside their argument: Check for '|' to\n     * separate commands and '\"' or '#' to start comments.\n     *\n     * Otherwise: Check for <newline> to end a shell command.\n     * Also do this for \":read !cmd\", \":write !cmd\" and \":global\".\n     * Also do this inside a { - } block after :command and :autocmd.\n     * Any others?\n     */\n    if ((ea.argt & EX_TRLBAR) && !ea.usefilter)\n    {\n\tseparate_nextcmd(&ea, FALSE);\n    }\n    else if (ea.cmdidx == CMD_bang\n\t    || ea.cmdidx == CMD_terminal\n\t    || ea.cmdidx == CMD_global\n\t    || ea.cmdidx == CMD_vglobal\n\t    || ea.usefilter\n#ifdef FEAT_EVAL\n\t    || inside_block(&ea)\n#endif\n\t    )\n    {\n\tfor (p = ea.arg; *p; ++p)\n\t{\n\t    // Remove one backslash before a newline, so that it's possible to\n\t    // pass a newline to the shell and also a newline that is preceded\n\t    // with a backslash.  This makes it impossible to end a shell\n\t    // command in a backslash, but that doesn't appear useful.\n\t    // Halving the number of backslashes is incompatible with previous\n\t    // versions.\n\t    if (*p == '\\\\' && p[1] == '\\n')\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '\\n' && !(ea.argt & EX_EXPR_ARG))\n\t    {\n\t\tea.nextcmd = p + 1;\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if ((ea.argt & EX_DFLALL) && ea.addr_count == 0)\n\taddress_default_all(&ea);\n\n    // accept numbered register only when no count allowed (:put)\n    if (       (ea.argt & EX_REGSTR)\n\t    && *ea.arg != NUL\n\t       // Do not allow register = for user commands\n\t    && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')\n\t    && !((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)))\n    {\n#ifndef FEAT_CLIPBOARD\n\t// check these explicitly for a more specific error message\n\tif (*ea.arg == '*' || *ea.arg == '+')\n\t{\n\t    errormsg = _(e_invalid_register_name);\n\t    goto doend;\n\t}\n#endif\n\tif (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put\n\t\t\t\t\t      && !IS_USER_CMDIDX(ea.cmdidx))))\n\t{\n\t    ea.regname = *ea.arg++;\n#ifdef FEAT_EVAL\n\t    // for '=' register: accept the rest of the line as an expression\n\t    if (ea.arg[-1] == '=' && ea.arg[0] != NUL)\n\t    {\n\t\tif (!ea.skip)\n\t\t{\n\t\t    set_expr_line(vim_strsave(ea.arg), &ea);\n\t\t    did_set_expr_line = TRUE;\n\t\t}\n\t\tea.arg += STRLEN(ea.arg);\n\t    }\n#endif\n\t    ea.arg = skipwhite(ea.arg);\n\t}\n    }\n\n    /*\n     * Check for a count.  When accepting a EX_BUFNAME, don't use \"123foo\" as a\n     * count, it's a buffer name.\n     */\n    if ((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)\n\t    && (!(ea.argt & EX_BUFNAME) || *(p = skipdigits(ea.arg + 1)) == NUL\n\t\t\t\t\t\t\t  || VIM_ISWHITE(*p)))\n    {\n\tn = getdigits_quoted(&ea.arg);\n\tea.arg = skipwhite(ea.arg);\n\tif (n <= 0 && !ni && (ea.argt & EX_ZEROR) == 0)\n\t{\n\t    errormsg = _(e_positive_count_required);\n\t    goto doend;\n\t}\n\tif (ea.addr_type != ADDR_LINES)\t// e.g. :buffer 2, :sleep 3\n\t{\n\t    ea.line2 = n;\n\t    if (ea.addr_count == 0)\n\t\tea.addr_count = 1;\n\t}\n\telse\n\t{\n\t    ea.line1 = ea.line2;\n\t    if (ea.line2 >= LONG_MAX - (n - 1))\n\t\tea.line2 = LONG_MAX;  // avoid overflow\n\t    else\n\t\tea.line2 += n - 1;\n\t    ++ea.addr_count;\n\t    /*\n\t     * Be vi compatible: no error message for out of range.\n\t     */\n\t    if (ea.line2 > curbuf->b_ml.ml_line_count)\n\t\tea.line2 = curbuf->b_ml.ml_line_count;\n\t}\n    }\n\n    /*\n     * Check for flags: 'l', 'p' and '#'.\n     */\n    if (ea.argt & EX_FLAGS)\n\tget_flags(&ea);\n    if (!ni && !(ea.argt & EX_EXTRA) && *ea.arg != NUL\n\t    && *ea.arg != '\"' && (*ea.arg != '|' || (ea.argt & EX_TRLBAR) == 0))\n    {\n\t// no arguments allowed but there is something\n\terrormsg = ex_errmsg(e_trailing_characters_str, ea.arg);\n\tgoto doend;\n    }\n\n    if (!ni && (ea.argt & EX_NEEDARG) && *ea.arg == NUL)\n    {\n\terrormsg = _(e_argument_required);\n\tgoto doend;\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * Skip the command when it's not going to be executed.\n     * The commands like :if, :endif, etc. always need to be executed.\n     * Also make an exception for commands that handle a trailing command\n     * themselves.\n     */\n    if (ea.skip)\n    {\n\tswitch (ea.cmdidx)\n\t{\n\t    // commands that need evaluation\n\t    case CMD_while:\n\t    case CMD_endwhile:\n\t    case CMD_for:\n\t    case CMD_endfor:\n\t    case CMD_if:\n\t    case CMD_elseif:\n\t    case CMD_else:\n\t    case CMD_endif:\n\t    case CMD_try:\n\t    case CMD_catch:\n\t    case CMD_finally:\n\t    case CMD_endtry:\n\t    case CMD_function:\n\t    case CMD_def:\n\t\t\t\tbreak;\n\n\t    // Commands that handle '|' themselves.  Check: A command should\n\t    // either have the EX_TRLBAR flag, appear in this list or appear in\n\t    // the list at \":help :bar\".\n\t    case CMD_aboveleft:\n\t    case CMD_and:\n\t    case CMD_belowright:\n\t    case CMD_botright:\n\t    case CMD_browse:\n\t    case CMD_call:\n\t    case CMD_confirm:\n\t    case CMD_const:\n\t    case CMD_delfunction:\n\t    case CMD_djump:\n\t    case CMD_dlist:\n\t    case CMD_dsearch:\n\t    case CMD_dsplit:\n\t    case CMD_echo:\n\t    case CMD_echoerr:\n\t    case CMD_echomsg:\n\t    case CMD_echon:\n\t    case CMD_eval:\n\t    case CMD_execute:\n\t    case CMD_filter:\n\t    case CMD_final:\n\t    case CMD_help:\n\t    case CMD_hide:\n\t    case CMD_ijump:\n\t    case CMD_ilist:\n\t    case CMD_isearch:\n\t    case CMD_isplit:\n\t    case CMD_keepalt:\n\t    case CMD_keepjumps:\n\t    case CMD_keepmarks:\n\t    case CMD_keeppatterns:\n\t    case CMD_leftabove:\n\t    case CMD_let:\n\t    case CMD_lockmarks:\n\t    case CMD_lockvar:\n\t    case CMD_lua:\n\t    case CMD_match:\n\t    case CMD_mzscheme:\n\t    case CMD_noautocmd:\n\t    case CMD_noswapfile:\n\t    case CMD_perl:\n\t    case CMD_psearch:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_return:\n\t    case CMD_rightbelow:\n\t    case CMD_ruby:\n\t    case CMD_silent:\n\t    case CMD_smagic:\n\t    case CMD_snomagic:\n\t    case CMD_substitute:\n\t    case CMD_syntax:\n\t    case CMD_tab:\n\t    case CMD_tcl:\n\t    case CMD_throw:\n\t    case CMD_tilde:\n\t    case CMD_topleft:\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_var:\n\t    case CMD_verbose:\n\t    case CMD_vertical:\n\t    case CMD_wincmd:\n\t\t\t\tbreak;\n\n\t    default:\t\tgoto doend;\n\t}\n    }\n#endif\n\n    if (ea.argt & EX_XFILE)\n    {\n\tif (expand_filename(&ea, cmdlinep, &errormsg) == FAIL)\n\t    goto doend;\n    }\n\n    /*\n     * Accept buffer name.  Cannot be used at the same time with a buffer\n     * number.  Don't do this for a user command.\n     */\n    if ((ea.argt & EX_BUFNAME) && *ea.arg != NUL && ea.addr_count == 0\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * :bdelete, :bwipeout and :bunload take several arguments, separated\n\t * by spaces: find next space (skipping over escaped characters).\n\t * The others take one argument: ignore trailing spaces.\n\t */\n\tif (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout\n\t\t\t\t\t\t  || ea.cmdidx == CMD_bunload)\n\t    p = skiptowhite_esc(ea.arg);\n\telse\n\t{\n\t    p = ea.arg + STRLEN(ea.arg);\n\t    while (p > ea.arg && VIM_ISWHITE(p[-1]))\n\t\t--p;\n\t}\n\tea.line2 = buflist_findpat(ea.arg, p, (ea.argt & EX_BUFUNL) != 0,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\tif (ea.line2 < 0)\t    // failed\n\t    goto doend;\n\tea.addr_count = 1;\n\tea.arg = skipwhite(p);\n    }\n\n    // The :try command saves the emsg_silent flag, reset it here when\n    // \":silent! try\" was used, it should only apply to :try itself.\n    if (ea.cmdidx == CMD_try && cmdmod.cmod_did_esilent > 0)\n    {\n\temsg_silent -= cmdmod.cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\tcmdmod.cmod_did_esilent = 0;\n    }\n\n/*\n * 7. Execute the command.\n */\n\n    if (IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * Execute a user-defined command.\n\t */\n\tdo_ucmd(&ea);\n    }\n    else\n    {\n\t/*\n\t * Call the function to execute the builtin command.\n\t */\n\tea.errmsg = NULL;\n\t(cmdnames[ea.cmdidx].cmd_func)(&ea);\n\tif (ea.errmsg != NULL)\n\t    errormsg = ea.errmsg;\n    }\n\n#ifdef FEAT_EVAL\n    // Set flag that any command was executed, used by ex_vim9script().\n    // Not if this was a command that wasn't executed or :endif.\n    if (sourcing_a_script(&ea)\n\t    && current_sctx.sc_sid > 0\n\t    && ea.cmdidx != CMD_endif\n\t    && (cstack->cs_idx < 0\n\t\t    || (cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)))\n\tSCRIPT_ITEM(current_sctx.sc_sid)->sn_state = SN_STATE_HAD_COMMAND;\n\n    /*\n     * If the command just executed called do_cmdline(), any throw or \":return\"\n     * or \":finish\" encountered there must also check the cstack of the still\n     * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught\n     * exception, or reanimate a returned function or finished script file and\n     * return or finish it again.\n     */\n    if (need_rethrow)\n\tdo_throw(cstack);\n    else if (check_cstack)\n    {\n\tif (source_finished(fgetline, cookie))\n\t    do_finish(&ea, TRUE);\n\telse if (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t\t   && current_func_returned())\n\t    do_return(&ea, TRUE, FALSE, NULL);\n    }\n    need_rethrow = check_cstack = FALSE;\n#endif\n\ndoend:\n    if (curwin->w_cursor.lnum == 0)\t// can happen with zero line number\n    {\n\tcurwin->w_cursor.lnum = 1;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    if (errormsg != NULL && *errormsg != NUL && !did_emsg)\n    {\n\tif ((sourcing || !KeyTyped) && !did_append_cmd)\n\t{\n\t    if (errormsg != (char *)IObuff)\n\t    {\n\t\tSTRCPY(IObuff, errormsg);\n\t\terrormsg = (char *)IObuff;\n\t    }\n\t    append_command(*cmdlinep);\n\t}\n\temsg(errormsg);\n    }\n#ifdef FEAT_EVAL\n    do_errthrow(cstack,\n\t    (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))\n\t\t\t? cmdnames[(int)ea.cmdidx].cmd_name : (char_u *)NULL);\n\n    if (did_set_expr_line)\n\tset_expr_line(NULL, NULL);\n#endif\n\n    undo_cmdmod(&cmdmod);\n    cmdmod = save_cmdmod;\n    reg_executing = save_reg_executing;\n    pending_end_reg_executing = save_pending_end_reg_executing;\n\n    if (ea.nextcmd && *ea.nextcmd == NUL)\t// not really a next command\n\tea.nextcmd = NULL;\n\n#ifdef FEAT_EVAL\n    --ex_nesting_level;\n    vim_free(ea.cmdline_tofree);\n#endif\n\n    return ea.nextcmd;\n}\n\nstatic char ex_error_buf[MSG_BUF_LEN];\n\n/*\n * Return an error message with argument included.\n * Uses a static buffer, only the last error will be kept.\n * \"msg\" will be translated, caller should use N_().\n */\n     char *\nex_errmsg(char *msg, char_u *arg)\n{\n    vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);\n    return ex_error_buf;\n}\n\n/*\n * Handle a range without a command.\n * Returns an error message on failure.\n */\n    char *\nex_range_without_command(exarg_T *eap)\n{\n    char *errormsg = NULL;\n\n    if ((*eap->cmd == '|' || (exmode_active && eap->line1 != eap->line2))\n#ifdef FEAT_EVAL\n\t    && !in_vim9script()\n#endif\n       )\n    {\n\teap->cmdidx = CMD_print;\n\teap->argt = EX_RANGE+EX_COUNT+EX_TRLBAR;\n\tif ((errormsg = invalid_range(eap)) == NULL)\n\t{\n\t    correct_range(eap);\n\t    ex_print(eap);\n\t}\n    }\n    else if (eap->addr_count != 0)\n    {\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t{\n\t    // With '-' in 'cpoptions' a line number past the file is an\n\t    // error, otherwise put it at the end of the file.\n\t    if (vim_strchr(p_cpo, CPO_MINUS) != NULL)\n\t\teap->line2 = -1;\n\t    else\n\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t}\n\n\tif (eap->line2 < 0)\n\t    errormsg = _(e_invalid_range);\n\telse\n\t{\n\t    if (eap->line2 == 0)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    return errormsg;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n * If \"noparen\" is TRUE do not recognize the command followed by \"(\" or \".\".\n */\n    static int\ncheckforcmd_opt(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen,\t\t// required length\n    int\t\tnoparen)\n{\n    int\t\ti;\n\n    for (i = 0; cmd[i] != NUL; ++i)\n\tif (((char_u *)cmd)[i] != (*pp)[i])\n\t    break;\n    if (i >= len && !isalpha((*pp)[i]) && (*pp)[i] != '_'\n\t\t\t && (!noparen || ((*pp)[i] != '(' && (*pp)[i] != '.')))\n    {\n\t*pp = skipwhite(*pp + i);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, FALSE);\n}\n\n/*\n * Check for an Ex command with optional tail, not followed by \"(\" or \".\".\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd_noparen(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, TRUE);\n}\n\n/*\n * Parse and skip over command modifiers:\n * - update eap->cmd\n * - store flags in \"cmod\".\n * - Set ex_pressedreturn for an empty command line.\n * When \"skip_only\" is TRUE the global variables are not changed, except for\n * \"cmdmod\".\n * When \"skip_only\" is FALSE then undo_cmdmod() must be called later to free\n * any cmod_filter_regmatch.regprog.\n * Call apply_cmdmod() to get the side effects of the modifiers:\n * - Increment \"sandbox\" for \":sandbox\"\n * - set p_verbose for \":verbose\"\n * - set msg_silent for \":silent\"\n * - set 'eventignore' to \"all\" for \":noautocmd\"\n * Return FAIL when the command is not to be executed.\n * May set \"errormsg\" to an error message.\n */\n    int\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods'<,'>+\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \"'<,'>+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"cmod\" has anything set.\n */\n    int\nhas_cmdmod(cmdmod_T *cmod, int ignore_silent)\n{\n    return (cmod->cmod_flags != 0 && (!ignore_silent\n\t\t|| (cmod->cmod_flags\n\t\t      & ~(CMOD_SILENT | CMOD_ERRSILENT | CMOD_UNSILENT)) != 0))\n\t    || cmod->cmod_split != 0\n\t    || cmod->cmod_verbose > 0\n\t    || cmod->cmod_tab != 0\n\t    || cmod->cmod_filter_regmatch.regprog != NULL;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If Vim9 script and \"cmdmod\" has anything set give an error and return TRUE.\n */\n    int\ncmdmod_error(int ignore_silent)\n{\n    if (in_vim9script() && has_cmdmod(&cmdmod, ignore_silent))\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Apply the command modifiers.  Saves current state in \"cmdmod\", call\n * undo_cmdmod() later.\n */\n    void\napply_cmdmod(cmdmod_T *cmod)\n{\n#ifdef HAVE_SANDBOX\n    if ((cmod->cmod_flags & CMOD_SANDBOX) && !cmod->cmod_did_sandbox)\n    {\n\t++sandbox;\n\tcmod->cmod_did_sandbox = TRUE;\n    }\n#endif\n    if (cmod->cmod_verbose > 0)\n    {\n\tif (cmod->cmod_verbose_save == 0)\n\t    cmod->cmod_verbose_save = p_verbose + 1;\n\tp_verbose = cmod->cmod_verbose - 1;\n    }\n\n    if ((cmod->cmod_flags & (CMOD_SILENT | CMOD_UNSILENT))\n\t    && cmod->cmod_save_msg_silent == 0)\n    {\n\tcmod->cmod_save_msg_silent = msg_silent + 1;\n\tcmod->cmod_save_msg_scroll = msg_scroll;\n    }\n    if (cmod->cmod_flags & CMOD_SILENT)\n\t++msg_silent;\n    if (cmod->cmod_flags & CMOD_UNSILENT)\n\tmsg_silent = 0;\n\n    if (cmod->cmod_flags & CMOD_ERRSILENT)\n    {\n\t++emsg_silent;\n\t++cmod->cmod_did_esilent;\n    }\n\n    if ((cmod->cmod_flags & CMOD_NOAUTOCMD) && cmod->cmod_save_ei == NULL)\n    {\n\t// Set 'eventignore' to \"all\".\n\t// First save the existing option value for restoring it later.\n\tcmod->cmod_save_ei = vim_strsave(p_ei);\n\tset_string_option_direct((char_u *)\"ei\", -1,\n\t\t\t\t\t  (char_u *)\"all\", OPT_FREE, SID_NONE);\n    }\n}\n\n/*\n * Undo and free contents of \"cmod\".\n */\n    void\nundo_cmdmod(cmdmod_T *cmod)\n{\n    if (cmod->cmod_verbose_save > 0)\n    {\n\tp_verbose = cmod->cmod_verbose_save - 1;\n\tcmod->cmod_verbose_save = 0;\n    }\n\n#ifdef HAVE_SANDBOX\n    if (cmod->cmod_did_sandbox)\n    {\n\t--sandbox;\n\tcmod->cmod_did_sandbox = FALSE;\n    }\n#endif\n\n    if (cmod->cmod_save_ei != NULL)\n    {\n\t// Restore 'eventignore' to the value before \":noautocmd\".\n\tset_string_option_direct((char_u *)\"ei\", -1, cmod->cmod_save_ei,\n\t\t\t\t\t\t\t   OPT_FREE, SID_NONE);\n\tfree_string_option(cmod->cmod_save_ei);\n\tcmod->cmod_save_ei = NULL;\n    }\n\n    vim_regfree(cmod->cmod_filter_regmatch.regprog);\n\n    if (cmod->cmod_save_msg_silent > 0)\n    {\n\t// messages could be enabled for a serious error, need to check if the\n\t// counters don't become negative\n\tif (!did_emsg || msg_silent > cmod->cmod_save_msg_silent - 1)\n\t    msg_silent = cmod->cmod_save_msg_silent - 1;\n\temsg_silent -= cmod->cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\t// Restore msg_scroll, it's set by file I/O commands, even when no\n\t// message is actually displayed.\n\tmsg_scroll = cmod->cmod_save_msg_scroll;\n\n\t// \"silent reg\" or \"silent echo x\" inside \"redir\" leaves msg_col\n\t// somewhere in the line.  Put it back in the first column.\n\tif (redirecting())\n\t    msg_col = 0;\n\n\tcmod->cmod_save_msg_silent = 0;\n\tcmod->cmod_did_esilent = 0;\n    }\n}\n\n/*\n * Parse the address range, if any, in \"eap\".\n * May set the last search pattern, unless \"silent\" is TRUE.\n * Return FAIL and set \"errormsg\" or return OK.\n */\n    int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n    int\t\tneed_check_cursor = FALSE;\n    int\t\tret = FAIL;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    goto theend;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\tgoto theend;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    goto theend;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly\n\t\t// (where zero usually means to use the first line).\n\t\t// Check the cursor position before returning.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t\telse\n\t\t    check_cursor_col();\n\t\tneed_check_cursor = TRUE;\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    ret = OK;\n\ntheend:\n    if (need_check_cursor)\n\tcheck_cursor();\n    return ret;\n}\n\n/*\n * Append \"cmd\" to the error message in IObuff.\n * Takes care of limiting the length and handling 0xa0, which would be\n * invisible otherwise.\n */\n    static void\nappend_command(char_u *cmd)\n{\n    size_t  len = STRLEN(IObuff);\n    char_u  *s = cmd;\n    char_u  *d;\n\n    if (len > IOSIZE - 100)\n    {\n\t// Not enough space, truncate and put in \"...\".\n\td = IObuff + IOSIZE - 100;\n\td -= mb_head_off(IObuff, d);\n\tSTRCPY(d, \"...\");\n    }\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If \"start\" points \"&opt\", \"&l:opt\", \"&g:opt\" or \"$ENV\" return a pointer to\n * the name.  Otherwise just return \"start\".\n */\n    char_u *\nskip_option_env_lead(char_u *start)\n{\n    char_u *name = start;\n\n    if (*start == '&')\n    {\n\tif ((start[1] == 'l' || start[1] == 'g') && start[2] == ':')\n\t    name += 3;\n\telse\n\t    name += 1;\n    }\n    else if (*start == '$')\n\tname += 1;\n    return name;\n}\n#endif\n\n/*\n * Return TRUE and set \"*idx\" if \"p\" points to a one letter command.\n * If not in Vim9 script:\n * - The 'k' command can directly be followed by any character.\n * - The 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'\n *\t    but :sre[wind] is another command, as are :scr[iptnames],\n *\t    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].\n */\n    static int\none_letter_cmd(char_u *p, cmdidx_T *idx)\n{\n    if (in_vim9script())\n\treturn FALSE;\n    if (*p == 'k')\n    {\n\t*idx = CMD_k;\n\treturn TRUE;\n    }\n    if (p[0] == 's'\n\t    && ((p[1] == 'c' && (p[2] == NUL || (p[2] != 's' && p[2] != 'r'\n\t\t\t&& (p[3] == NUL || (p[3] != 'i' && p[4] != 'p')))))\n\t\t|| p[1] == 'g'\n\t\t|| (p[1] == 'i' && p[2] != 'm' && p[2] != 'l' && p[2] != 'g')\n\t\t|| p[1] == 'I'\n\t\t|| (p[1] == 'r' && p[2] != 'e')))\n    {\n\t*idx = CMD_substitute;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"cmd\" starts with \"123->\", a number followed by a method\n * call.\n */\n    int\nnumber_method(char_u *cmd)\n{\n    char_u *p = skipdigits(cmd);\n\n    return p > cmd && (p = skipwhite(p))[0] == '-' && p[1] == '>';\n}\n\n/*\n * Find an Ex command by its name, either built-in or user.\n * Start of the name can be found at eap->cmd.\n * Sets eap->cmdidx and returns a pointer to char after the command name.\n * \"full\" is set to TRUE if the whole command name matched.\n *\n * If \"lookup\" is not NULL recognize expression without \"eval\" or \"call\" and\n * assignment without \"let\".  Sets eap->cmdidx to the command while returning\n * \"eap->cmd\".\n *\n * Returns NULL for an ambiguous user command.\n */\n    char_u *\nfind_ex_command(\n\texarg_T *eap,\n\tint\t*full UNUSED,\n\tint\t(*lookup)(char_u *, size_t, int cmd, cctx_T *) UNUSED,\n\tcctx_T\t*cctx UNUSED)\n{\n    int\t\tlen;\n    char_u\t*p;\n    int\t\ti;\n#ifndef FEAT_EVAL\n    int\t\tvim9 = FALSE;\n#else\n    int\t\tvim9 = in_vim9script();\n\n    /*\n     * Recognize a Vim9 script function/method call and assignment:\n     * \"lvar = value\", \"lvar(arg)\", \"[1, 2 3]->Func()\"\n     */\n    p = eap->cmd;\n    if (lookup != NULL)\n    {\n\tchar_u *pskip = skip_option_env_lead(eap->cmd);\n\n\tif (vim_strchr((char_u *)\"{('[\\\"@&$\", *p) != NULL\n\t       || ((p = to_name_const_end(pskip)) > eap->cmd && *p != NUL)\n\t       || (p[0] == '0' && p[1] == 'z'))\n\t{\n\t    int\t    oplen;\n\t    int\t    heredoc;\n\t    char_u  *swp;\n\n\t    if (*eap->cmd == '&'\n\t\t    || (eap->cmd[0] == '$'\n\t\t\t\t  && eap->cmd[1] != '\\'' && eap->cmd[1] != '\"')\n\t\t    || (eap->cmd[0] == '@'\n\t\t\t\t\t&& (valid_yank_reg(eap->cmd[1], FALSE)\n\t\t\t\t\t\t       || eap->cmd[1] == '@')))\n\t    {\n\t\tif (*eap->cmd == '&')\n\t\t{\n\t\t    p = eap->cmd + 1;\n\t\t    if (STRNCMP(\"l:\", p, 2) == 0 || STRNCMP(\"g:\", p, 2) == 0)\n\t\t\tp += 2;\n\t\t    p = to_name_end(p, FALSE);\n\t\t}\n\t\telse if (*eap->cmd == '$')\n\t\t    p = to_name_end(eap->cmd + 1, FALSE);\n\t\telse\n\t\t    p = eap->cmd + 2;\n\t\tif (ends_excmd(*skipwhite(p)))\n\t\t{\n\t\t    // \"&option <NL>\", \"$ENV <NL>\" and \"@r <NL>\" are the start\n\t\t    // of an expression.\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\t// \"&option\" can be followed by \"->\" or \"=\", check below\n\t    }\n\n\t    swp = skipwhite(p);\n\n\t    if (\n\t\t// \"(...\" is an expression.\n\t\t// \"funcname(\" is always a function call.\n\t\t*p == '('\n\t\t    || (p == eap->cmd\n\t\t\t? (\n\t\t\t    // \"{...\" is a dict expression or block start.\n\t\t\t    *eap->cmd == '{'\n\t\t\t    // \"'string'->func()\" is an expression.\n\t\t\t || *eap->cmd == '\\''\n\t\t\t    // '\"string\"->func()' is an expression.\n\t\t\t || *eap->cmd == '\"'\n\t\t\t    // '$\"string\"->func()' is an expression.\n\t\t\t    // \"$'string'->func()\" is an expression.\n\t\t\t || (eap->cmd[0] == '$'\n\t\t\t     && (eap->cmd[1] == '\\'' || eap->cmd[1] == '\"'))\n\t\t\t    // '0z1234->func()' is an expression.\n\t\t\t || (eap->cmd[0] == '0' && eap->cmd[1] == 'z')\n\t\t\t    // \"g:varname\" is an expression.\n\t\t\t || eap->cmd[1] == ':'\n\t\t\t    )\n\t\t\t    // \"varname->func()\" is an expression.\n\t\t\t: (*swp == '-' && swp[1] == '>')))\n\t    {\n\t\tif (*eap->cmd == '{' && ends_excmd(*skipwhite(eap->cmd + 1)))\n\t\t{\n\t\t    // \"{\" by itself is the start of a block.\n\t\t    eap->cmdidx = CMD_block;\n\t\t    return eap->cmd + 1;\n\t\t}\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\n\t    if ((p != eap->cmd && (\n\t\t\t    // \"varname[]\" is an expression.\n\t\t\t    *p == '['\n\t\t\t    // \"varname.key\" is an expression.\n\t\t\t || (*p == '.'\n\t\t\t\t     && (ASCII_ISALPHA(p[1]) || p[1] == '_'))))\n\t\t\t// g:[key] is an expression\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0)\n\t    {\n\t\tchar_u\t*after = eap->cmd;\n\n\t\t// When followed by \"=\" or \"+=\" then it is an assignment.\n\t\t// Skip over the whole thing, it can be:\n\t\t//\tname.member = val\n\t\t//\tname[a : b] = val\n\t\t//\tname[idx] = val\n\t\t//\tname[idx].member = val\n\t\t//\tetc.\n\t\teap->cmdidx = CMD_eval;\n\t\t++emsg_silent;\n\t\tif (skip_expr(&after, NULL) == OK)\n\t\t{\n\t\t    after = skipwhite(after);\n\t\t    if (*after == '=' || (*after != NUL && after[1] == '=')\n\t\t\t\t\t || (after[0] == '.' && after[1] == '.'\n\t\t\t\t\t\t\t   && after[2] == '='))\n\t\t\teap->cmdidx = CMD_var;\n\t\t}\n\t\t--emsg_silent;\n\t\treturn eap->cmd;\n\t    }\n\n\t    // \"[...]->Method()\" is a list expression, but \"[a, b] = Func()\" is\n\t    // an assignment.\n\t    // If there is no line break inside the \"[...]\" then \"p\" is\n\t    // advanced to after the \"]\" by to_name_const_end(): check if a \"=\"\n\t    // follows.\n\t    // If \"[...]\" has a line break \"p\" still points at the \"[\" and it\n\t    // can't be an assignment.\n\t    if (*eap->cmd == '[')\n\t    {\n\t\tchar_u\t    *eq;\n\n\t\tp = to_name_const_end(eap->cmd);\n\t\tif (p == eap->cmd && *p == '[')\n\t\t{\n\t\t    int count = 0;\n\t\t    int\tsemicolon = FALSE;\n\n\t\t    p = skip_var_list(eap->cmd, TRUE, &count, &semicolon, TRUE);\n\t\t}\n\t\teq = p;\n\t\tif (eq != NULL)\n\t\t{\n\t\t    eq = skipwhite(eq);\n\t\t    if (vim_strchr((char_u *)\"+-*/%\", *eq) != NULL)\n\t\t\t++eq;\n\t\t}\n\t\tif (p == NULL || p == eap->cmd || *eq != '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\tif (p > eap->cmd && *eq == '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize an assignment if we recognize the variable name:\n\t    // \"g:var = expr\"\n\t    // \"@r = expr\"\n\t    // \"&opt = expr\"\n\t    // \"var = expr\"  where \"var\" is a variable name or we are skipping\n\t    // (variable declaration might have been skipped).\n\t    // Not \"redir => var\" (when skipping).\n\t    oplen = assignment_len(skipwhite(p), &heredoc);\n\t    if (oplen > 0)\n\t    {\n\t\tif (((p - eap->cmd) > 2 && eap->cmd[1] == ':')\n\t\t\t|| *eap->cmd == '&'\n\t\t\t|| *eap->cmd == '$'\n\t\t\t|| *eap->cmd == '@'\n\t\t\t|| (eap->skip && IS_WHITE_OR_NUL(\n\t\t\t\t\t\t      *(skipwhite(p) + oplen)))\n\t\t\t|| lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK)\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize using a type for a w:, b:, t: or g: variable:\n\t    // \"w:varname: number = 123\".\n\t    if (eap->cmd[1] == ':' && *p == ':')\n\t    {\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\t}\n\n\t// 1234->func() is a method call\n\tif (number_method(eap->cmd))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// \"g:\", \"s:\" and \"l:\" are always assumed to be a variable, thus start\n\t// an expression.  A global/substitute/list command needs to use a\n\t// longer name.\n\tif (vim_strchr((char_u *)\"gsl\", *p) != NULL && p[1] == ':')\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// If it is an ID it might be a variable with an operator on the next\n\t// line, if the variable exists it can't be an Ex command.\n\tif (p > eap->cmd && ends_excmd(*skipwhite(p))\n\t\t&& (lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK\n\t\t    || (ASCII_ISALPHA(eap->cmd[0]) && eap->cmd[1] == ':')))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// Check for \"++nr\" and \"--nr\".\n\tif (p == eap->cmd && p[0] != NUL && p[0] == p[1]\n\t\t\t\t\t\t   && (*p == '+' || *p == '-'))\n\t{\n\t    eap->cmdidx = *p == '+' ? CMD_increment : CMD_decrement;\n\t    return eap->cmd + 2;\n\t}\n    }\n#endif\n\n    /*\n     * Isolate the command and search for it in the command table.\n     */\n    p = eap->cmd;\n    if (one_letter_cmd(p, &eap->cmdidx))\n    {\n\t++p;\n    }\n    else\n    {\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n\t// for python 3.x support \":py3\", \":python3\", \":py3file\", etc.\n\tif (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')\n\t{\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t}\n\telse if (*p == '9' && STRNCMP(\"vim9\", eap->cmd, 4) == 0)\n\t{\n\t    // include \"9\" for \"vim9*\" commands; \"vim9cmd\" and \"vim9script\".\n\t    ++p;\n\t    while (ASCII_ISALPHA(*p))\n\t\t++p;\n\t}\n\n\t// check for non-alpha command\n\tif (p == eap->cmd && vim_strchr((char_u *)\"@*!=><&~#}\", *p) != NULL)\n\t    ++p;\n\tlen = (int)(p - eap->cmd);\n\t// The \"d\" command can directly be followed by 'l' or 'p' flag, when\n\t// not in Vim9 script.\n\tif (!vim9 && *eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p'))\n\t{\n\t    // Check for \":dl\", \":dell\", etc. to \":deletel\": that's\n\t    // :delete with the 'l' flag.  Same for 'p'.\n\t    for (i = 0; i < len; ++i)\n\t\tif (eap->cmd[i] != ((char_u *)\"delete\")[i])\n\t\t    break;\n\t    if (i == len - 1)\n\t    {\n\t\t--len;\n\t\tif (p[-1] == 'l')\n\t\t    eap->flags |= EXFLAG_LIST;\n\t\telse\n\t\t    eap->flags |= EXFLAG_PRINT;\n\t    }\n\t}\n\n\tif (ASCII_ISLOWER(eap->cmd[0]))\n\t{\n\t    int c1 = eap->cmd[0];\n\t    int c2 = len == 1 ? NUL : eap->cmd[1];\n\n\t    if (command_count != (int)CMD_SIZE)\n\t    {\n\t\tiemsg(_(e_command_table_needs_to_be_updated_run_make_cmdidxs));\n\t\tgetout(1);\n\t    }\n\n\t    // Use a precomputed index for fast look-up in cmdnames[]\n\t    // taking into account the first 2 letters of eap->cmd.\n\t    eap->cmdidx = cmdidxs1[CharOrdLow(c1)];\n\t    if (ASCII_ISLOWER(c2))\n\t\teap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];\n\t}\n\telse if (ASCII_ISUPPER(eap->cmd[0]))\n\t    eap->cmdidx = CMD_Next;\n\telse\n\t    eap->cmdidx = CMD_bang;\n\n\tfor ( ; (int)eap->cmdidx < (int)CMD_SIZE;\n\t\t\t       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))\n\t    if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,\n\t\t\t\t\t\t\t    (size_t)len) == 0)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (full != NULL && cmdnames[eap->cmdidx].cmd_name[len] == NUL)\n\t\t    *full = TRUE;\n#endif\n\t\tbreak;\n\t    }\n\n\t// :Print and :mode are not supported in Vim9 script.\n\t// Some commands cannot be shortened in Vim9 script.\n\tif (vim9 && eap->cmdidx != CMD_SIZE)\n\t{\n\t    if (eap->cmdidx == CMD_mode || eap->cmdidx == CMD_Print)\n\t\teap->cmdidx = CMD_SIZE;\n\t    else if ((cmdnames[eap->cmdidx].cmd_argt & EX_WHOLE)\n\t\t\t  && len < (int)STRLEN(cmdnames[eap->cmdidx].cmd_name))\n\t    {\n\t\tsemsg(_(e_command_cannot_be_shortened_str), eap->cmd);\n\t\teap->cmdidx = CMD_SIZE;\n\t    }\n\t}\n\n\t// Do not recognize \":*\" as the star command unless '*' is in\n\t// 'cpoptions'.\n\tif (eap->cmdidx == CMD_star && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    p = eap->cmd;\n\n\t// Look for a user defined command as a last resort.  Let \":Print\" be\n\t// overruled by a user defined command.\n\tif ((eap->cmdidx == CMD_SIZE || eap->cmdidx == CMD_Print)\n\t\t&& *eap->cmd >= 'A' && *eap->cmd <= 'Z')\n\t{\n\t    // User defined commands may contain digits.\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t    p = find_ucmd(eap, p, full, NULL, NULL);\n\t}\n\tif (p == NULL || p == eap->cmd)\n\t    eap->cmdidx = CMD_SIZE;\n    }\n\n    // \":fina\" means \":finally\" in legacy script, for backwards compatibility.\n    if (eap->cmdidx == CMD_final && p - eap->cmd == 4 && !vim9)\n\teap->cmdidx = CMD_finally;\n\n#ifdef FEAT_EVAL\n    if (eap->cmdidx < CMD_SIZE\n\t    && vim9\n\t    && !IS_WHITE_OR_NUL(*p) && *p != '\\n' && *p != '!' && *p != '|'\n\t    && (eap->cmdidx < 0 ||\n\t\t(cmdnames[eap->cmdidx].cmd_argt & EX_NONWHITE_OK) == 0))\n    {\n\tchar_u *cmd = vim_strnsave(eap->cmd, p - eap->cmd);\n\n\tsemsg(_(e_command_str_not_followed_by_white_space_str), cmd, eap->cmd);\n\teap->cmdidx = CMD_SIZE;\n\tvim_free(cmd);\n    }\n#endif\n\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic struct cmdmod\n{\n    char\t*name;\n    int\t\tminlen;\n    int\t\thas_count;  // :123verbose  :3tab\n} cmdmods[] = {\n    {\"aboveleft\", 3, FALSE},\n    {\"belowright\", 3, FALSE},\n    {\"botright\", 2, FALSE},\n    {\"browse\", 3, FALSE},\n    {\"confirm\", 4, FALSE},\n    {\"filter\", 4, FALSE},\n    {\"hide\", 3, FALSE},\n    {\"keepalt\", 5, FALSE},\n    {\"keepjumps\", 5, FALSE},\n    {\"keepmarks\", 3, FALSE},\n    {\"keeppatterns\", 5, FALSE},\n    {\"leftabove\", 5, FALSE},\n    {\"lockmarks\", 3, FALSE},\n    {\"noautocmd\", 3, FALSE},\n    {\"noswapfile\", 3, FALSE},\n    {\"rightbelow\", 6, FALSE},\n    {\"sandbox\", 3, FALSE},\n    {\"silent\", 3, FALSE},\n    {\"tab\", 3, TRUE},\n    {\"topleft\", 2, FALSE},\n    {\"unsilent\", 3, FALSE},\n    {\"verbose\", 4, TRUE},\n    {\"vertical\", 4, FALSE},\n};\n\n/*\n * Return length of a command modifier (including optional count).\n * Return zero when it's not a modifier.\n */\n    int\nmodifier_len(char_u *cmd)\n{\n    int\t\ti, j;\n    char_u\t*p = cmd;\n\n    if (VIM_ISDIGIT(*cmd))\n\tp = skipwhite(skipdigits(cmd + 1));\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; p[j] != NUL; ++j)\n\t    if (p[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (!ASCII_ISALPHA(p[j]) && j >= cmdmods[i].minlen\n\t\t\t\t\t&& (p == cmd || cmdmods[i].has_count))\n\t    return j + (int)(p - cmd);\n    }\n    return 0;\n}\n\n/*\n * Return > 0 if an Ex command \"name\" exists.\n * Return 2 if there is an exact match.\n * Return 3 if there is an ambiguous match.\n */\n    int\ncmd_exists(char_u *name)\n{\n    exarg_T\tea;\n    int\t\tfull = FALSE;\n    int\t\ti;\n    int\t\tj;\n    char_u\t*p;\n\n    // Check command modifiers.\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; name[j] != NUL; ++j)\n\t    if (name[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (name[j] == NUL && j >= cmdmods[i].minlen)\n\t    return (cmdmods[i].name[j] == NUL ? 2 : 1);\n    }\n\n    // Check built-in commands and user defined commands.\n    // For \":2match\" and \":3match\" we need to skip the number.\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.flags = 0;\n    p = find_ex_command(&ea, &full, NULL, NULL);\n    if (p == NULL)\n\treturn 3;\n    if (vim_isdigit(*name) && ea.cmdidx != CMD_match)\n\treturn 0;\n    if (*skipwhite(p) != NUL)\n\treturn 0;\t// trailing garbage\n    return (ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1));\n}\n\n/*\n * \"fullcommand\" function\n */\n    void\nf_fullcommand(typval_T *argvars, typval_T *rettv)\n{\n    exarg_T  ea;\n    char_u   *name;\n    char_u   *p;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    name = argvars[0].vval.v_string;\n    if (name == NULL)\n\treturn;\n\n    while (*name == ':')\n\tname++;\n    name = skip_range(name, TRUE, NULL);\n\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.addr_count = 0;\n    p = find_ex_command(&ea, NULL, NULL, NULL);\n    if (p == NULL || ea.cmdidx == CMD_SIZE)\n\treturn;\n    if (in_vim9script())\n    {\n\tint\t     res;\n\n\t++emsg_silent;\n\tres = not_in_vim9(&ea);\n\t--emsg_silent;\n\n\tif (res == FAIL)\n\t    return;\n    }\n\n    rettv->vval.v_string = vim_strsave(IS_USER_CMDIDX(ea.cmdidx)\n\t\t\t\t ? get_user_command_name(ea.useridx, ea.cmdidx)\n\t\t\t\t : cmdnames[ea.cmdidx].cmd_name);\n}\n#endif\n\n    cmdidx_T\nexcmd_get_cmdidx(char_u *cmd, int len)\n{\n    cmdidx_T idx;\n\n    if (!one_letter_cmd(cmd, &idx))\n\tfor (idx = (cmdidx_T)0; (int)idx < (int)CMD_SIZE;\n\t\tidx = (cmdidx_T)((int)idx + 1))\n\t    if (STRNCMP(cmdnames[(int)idx].cmd_name, cmd, (size_t)len) == 0)\n\t\tbreak;\n\n    return idx;\n}\n\n    long\nexcmd_get_argt(cmdidx_T idx)\n{\n    return (long)cmdnames[(int)idx].cmd_argt;\n}\n\n/*\n * Skip a range specifier of the form: addr [,addr] [;addr] ..\n *\n * Backslashed delimiters after / or ? will be skipped, and commands will\n * not be expanded between /'s and ?'s or after \"'\".\n *\n * Also skip white space and \":\" characters after the range.\n * Returns the \"cmd\" pointer advanced to beyond the range.\n */\n    char_u *\nskip_range(\n    char_u\t*cmd_start,\n    int\t\tskip_star,\t// skip \"*\" used for Visual range\n    int\t\t*ctx)\t\t// pointer to xp_context or NULL\n{\n    char_u\t*cmd = cmd_start;\n    unsigned\tdelim;\n\n    while (vim_strchr((char_u *)\" \\t0123456789.$%'/?-+,;\\\\\", *cmd) != NULL)\n    {\n\tif (*cmd == '\\\\')\n\t{\n\t    if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&')\n\t\t++cmd;\n\t    else\n\t\tbreak;\n\t}\n\telse if (*cmd == '\\'')\n\t{\n\t    char_u *p = cmd;\n\n\t    // a quote is only valid at the start or after a separator\n\t    while (p > cmd_start)\n\t    {\n\t\t--p;\n\t\tif (!VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    if (cmd > cmd_start && !VIM_ISWHITE(*p) && *p != ',' && *p != ';')\n\t\tbreak;\n\t    if (*++cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\telse if (*cmd == '/' || *cmd == '?')\n\t{\n\t    delim = *cmd++;\n\t    while (*cmd != NUL && *cmd != delim)\n\t\tif (*cmd++ == '\\\\' && *cmd != NUL)\n\t\t    ++cmd;\n\t    if (*cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\tif (*cmd != NUL)\n\t    ++cmd;\n    }\n\n    // Skip \":\" and white space.\n    while (*cmd == ':')\n\tcmd = skipwhite(cmd + 1);\n\n    // Skip \"*\" used for Visual range.\n    if (skip_star && *cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\tcmd = skipwhite(cmd + 1);\n\n    return cmd;\n}\n\n    static void\naddr_error(cmd_addr_T addr_type)\n{\n    if (addr_type == ADDR_NONE)\n\temsg(_(e_no_range_allowed));\n    else\n\temsg(_(e_invalid_range));\n}\n\n/*\n * Return the default address for an address type.\n */\n    static linenr_T\ndefault_address(exarg_T *eap)\n{\n    linenr_T lnum = 0;\n\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    // Default is the cursor line number.  Avoid using an invalid\n\t    // line number though.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = curwin->w_cursor.lnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    lnum = CURRENT_WIN_NR;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    lnum = curwin->w_arg_idx + 1;\n\t    if (lnum > ARGCOUNT)\n\t\tlnum = ARGCOUNT;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\tcase ADDR_BUFFERS:\n\t    lnum = curbuf->b_fnum;\n\t    break;\n\tcase ADDR_TABS:\n\t    lnum = CURRENT_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\tcase ADDR_UNSIGNED:\n\t    lnum = 1;\n\t    break;\n\tcase ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_valid_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\t    // Will give an error later if a range is found.\n\t    break;\n    }\n    return lnum;\n}\n\n/*\n * Get a single EX address.\n *\n * Set ptr to the next character after the part that was interpreted.\n * Set ptr to NULL when an error is encountered.\n * This may set the last used search pattern.\n *\n * Return MAXLNUM when no Ex address was found.\n */\n    static linenr_T\nget_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum > 0 && lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum =\n\t\t\t\tlnum > curbuf->b_ml.ml_line_count\n\t\t\t\t\t   ? curbuf->b_ml.ml_line_count : lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1', but '+0' is not '+1'\n\t\tn = 1;\n\t    else\n\t    {\n\t\tn = getdigits(&cmd);\n\t\tif (n == MAXLNUM)\n\t\t{\n\t\t    emsg(_(e_line_number_out_of_range));\n\t\t    goto error;\n\t\t}\n\t    }\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing, need to adjust for folded lines\n\t\t// now, but only do it after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t\t\t\t\t && address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t{\n\t\t    if (n >= LONG_MAX - lnum)\n\t\t    {\n\t\t\temsg(_(e_line_number_out_of_range));\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum += n;\n\t\t}\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}\n\n/*\n * Set eap->line1 and eap->line2 to the whole range.\n * Used for commands with the EX_DFLALL flag and no range given.\n */\n    static void\naddress_default_all(exarg_T *eap)\n{\n    eap->line1 = 1;\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\t    {\n\t\tbuf_T *buf = firstbuf;\n\n\t\twhile (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_next;\n\t\teap->line1 = buf->b_fnum;\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_prev;\n\t\teap->line2 = buf->b_fnum;\n\t    }\n\t    break;\n\tcase ADDR_BUFFERS:\n\t    eap->line1 = firstbuf->b_fnum;\n\t    eap->line2 = lastbuf->b_fnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    eap->line2 = LAST_WIN_NR;\n\t    break;\n\tcase ADDR_TABS:\n\t    eap->line2 = LAST_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\t    eap->line2 = 1;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    if (ARGCOUNT == 0)\n\t\teap->line1 = eap->line2 = 0;\n\t    else\n\t\teap->line2 = ARGCOUNT;\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    eap->line2 = qf_get_valid_size(eap);\n\t    if (eap->line2 == 0)\n\t\teap->line2 = 1;\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\tcase ADDR_UNSIGNED:\n\tcase ADDR_QUICKFIX:\n\t    iemsg(_(\"INTERNAL: Cannot use EX_DFLALL with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX\"));\n\t    break;\n    }\n}\n\n\n/*\n * Get flags from an Ex command argument.\n */\n    static void\nget_flags(exarg_T *eap)\n{\n    while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL)\n    {\n\tif (*eap->arg == 'l')\n\t    eap->flags |= EXFLAG_LIST;\n\telse if (*eap->arg == 'p')\n\t    eap->flags |= EXFLAG_PRINT;\n\telse\n\t    eap->flags |= EXFLAG_NR;\n\teap->arg = skipwhite(eap->arg + 1);\n    }\n}\n\n/*\n * Function called for command which is Not Implemented.  NI!\n */\n    void\nex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(e_sorry_command_is_not_available_in_this_version);\n}\n\n#ifdef HAVE_EX_SCRIPT_NI\n/*\n * Function called for script command which is Not Implemented.  NI!\n * Skips over \":perl <<EOF\" constructs.\n */\n    static void\nex_script_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\tex_ni(eap);\n    else\n\tvim_free(script_get(eap, eap->arg));\n}\n#endif\n\n/*\n * Check range in Ex command for validity.\n * Return NULL when valid, error message when invalid.\n */\n    static char *\ninvalid_range(exarg_T *eap)\n{\n    buf_T\t*buf;\n\n    if (       eap->line1 < 0\n\t    || eap->line2 < 0\n\t    || eap->line1 > eap->line2)\n\treturn _(e_invalid_range);\n\n    if (eap->argt & EX_RANGE)\n    {\n\tswitch (eap->addr_type)\n\t{\n\t    case ADDR_LINES:\n\t\tif (eap->line2 > curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t    + (eap->cmdidx == CMD_diffget)\n#endif\n\t\t   )\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_ARGUMENTS:\n\t\t// add 1 if ARGCOUNT is 0\n\t\tif (eap->line2 > ARGCOUNT + (!ARGCOUNT))\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_BUFFERS:\n\t\t// Only a boundary check, not whether the buffers actually\n\t\t// exist.\n\t\tif (eap->line1 < 1 || eap->line2 > get_highest_fnum())\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_LOADED_BUFFERS:\n\t\tbuf = firstbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_next == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_next;\n\t\t}\n\t\tif (eap->line1 < buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_prev == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_prev;\n\t\t}\n\t\tif (eap->line2 > buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_WINDOWS:\n\t\tif (eap->line2 > LAST_WIN_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS:\n\t\tif (eap->line2 > LAST_TAB_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS_RELATIVE:\n\t    case ADDR_OTHER:\n\t\t// Any range is OK.\n\t\tbreak;\n\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t// No error for value that is too big, will use the last entry.\n\t\tif (eap->line2 <= 0)\n\t\t{\n\t\t    if (eap->addr_count == 0)\n\t\t\treturn _(e_no_errors);\n\t\t    return _(e_invalid_range);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\tif ((eap->line2 != 1 && eap->line2 > qf_get_valid_size(eap))\n\t\t\t|| eap->line2 < 0)\n\t\t    return _(e_invalid_range);\n#endif\n\t\tbreak;\n\t    case ADDR_UNSIGNED:\n\t    case ADDR_NONE:\n\t\t// Will give an error elsewhere.\n\t\tbreak;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Correct the range for zero line number, if required.\n */\n    static void\ncorrect_range(exarg_T *eap)\n{\n    if (!(eap->argt & EX_ZEROR))\t    // zero in range not allowed\n    {\n\tif (eap->line1 == 0)\n\t    eap->line1 = 1;\n\tif (eap->line2 == 0)\n\t    eap->line2 = 1;\n    }\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the\n * pattern.  Otherwise return eap->arg.\n */\n    static char_u *\nskip_grep_pat(exarg_T *eap)\n{\n    char_u\t*p = eap->arg;\n\n    if (*p != NUL && (eap->cmdidx == CMD_vimgrep || eap->cmdidx == CMD_lvimgrep\n\t\t|| eap->cmdidx == CMD_vimgrepadd\n\t\t|| eap->cmdidx == CMD_lvimgrepadd\n\t\t|| grep_internal(eap->cmdidx)))\n    {\n\tp = skip_vimgrep_pat(p, NULL, NULL);\n\tif (p == NULL)\n\t    p = eap->arg;\n    }\n    return p;\n}\n\n/*\n * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option\n * in the command line, so that things like % get expanded.\n */\n    static char_u *\nreplace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)\n{\n    char_u\t*new_cmdline;\n    char_u\t*program;\n    char_u\t*pos;\n    char_u\t*ptr;\n    int\t\tlen;\n    int\t\ti;\n\n    /*\n     * Don't do it when \":vimgrep\" is used for \":grep\".\n     */\n    if ((eap->cmdidx == CMD_make || eap->cmdidx == CMD_lmake\n\t\t     || eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t\t     || eap->cmdidx == CMD_grepadd\n\t\t     || eap->cmdidx == CMD_lgrepadd)\n\t    && !grep_internal(eap->cmdidx))\n    {\n\tif (eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t    || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\t{\n\t    if (*curbuf->b_p_gp == NUL)\n\t\tprogram = p_gp;\n\t    else\n\t\tprogram = curbuf->b_p_gp;\n\t}\n\telse\n\t{\n\t    if (*curbuf->b_p_mp == NUL)\n\t\tprogram = p_mp;\n\t    else\n\t\tprogram = curbuf->b_p_mp;\n\t}\n\n\tp = skipwhite(p);\n\n\tif ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t{\n\t    // replace $* by given arguments\n\t    i = 1;\n\t    while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)\n\t\t++i;\n\t    len = (int)STRLEN(p);\n\t    new_cmdline = alloc(STRLEN(program) + (size_t)i * (len - 2) + 1);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    ptr = new_cmdline;\n\t    while ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t    {\n\t\ti = (int)(pos - program);\n\t\tSTRNCPY(ptr, program, i);\n\t\tSTRCPY(ptr += i, p);\n\t\tptr += len;\n\t\tprogram = pos + 2;\n\t    }\n\t    STRCPY(ptr, program);\n\t}\n\telse\n\t{\n\t    new_cmdline = alloc(STRLEN(program) + STRLEN(p) + 2);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    STRCPY(new_cmdline, program);\n\t    STRCAT(new_cmdline, \" \");\n\t    STRCAT(new_cmdline, p);\n\t}\n\tmsg_make(p);\n\n\t// 'eap->cmd' is not set here, because it is not used at CMD_make\n\tvim_free(*cmdlinep);\n\t*cmdlinep = new_cmdline;\n\tp = new_cmdline;\n    }\n    return p;\n}\n#endif\n\n/*\n * Expand file name in Ex command argument.\n * When an error is detected, \"errormsgp\" is set to a non-NULL pointer.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nexpand_filename(\n    exarg_T\t*eap,\n    char_u\t**cmdlinep,\n    char\t**errormsgp)\n{\n    int\t\thas_wildcards;\t// need to expand wildcards\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n    int\t\tn;\n    int\t\tescaped;\n\n#ifdef FEAT_QUICKFIX\n    // Skip a regexp pattern for \":vimgrep[add] pat file...\"\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    /*\n     * Decide to expand wildcards *before* replacing '%', '#', etc.  If\n     * the file name contains a wildcard it should not cause expanding.\n     * (it will be expanded anyway if there is a wildcard before replacing).\n     */\n    has_wildcards = mch_has_wildcard(p);\n    while (*p != NUL)\n    {\n#ifdef FEAT_EVAL\n\t// Skip over `=expr`, wildcards in it are not expanded.\n\tif (p[0] == '`' && p[1] == '=')\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == '`')\n\t\t++p;\n\t    continue;\n\t}\n#endif\n\t/*\n\t * Quick check if this cannot be the start of a special string.\n\t * Also removes backslash before '%', '#' and '<'.\n\t */\n\tif (vim_strchr((char_u *)\"%#<\", *p) == NULL)\n\t{\n\t    ++p;\n\t    continue;\n\t}\n\n\t/*\n\t * Try to find a match at this position.\n\t */\n\trepl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),\n\t\t\t\t\t\t    errormsgp, &escaped, TRUE);\n\tif (*errormsgp != NULL)\t\t// error detected\n\t    return FAIL;\n\tif (repl == NULL)\t\t// no match found\n\t{\n\t    p += srclen;\n\t    continue;\n\t}\n\n\t// Wildcards won't be expanded below, the replacement is taken\n\t// literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\".\n\tif (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL)\n\t{\n\t    char_u *l = repl;\n\n\t    repl = expand_env_save(repl);\n\t    vim_free(l);\n\t}\n\n\t// Need to escape white space et al. with a backslash.\n\t// Don't do this for:\n\t// - replacement that already has been escaped: \"##\"\n\t// - shell commands (may have to use quotes instead).\n\t// - non-unix systems when there is a single argument (spaces don't\n\t//   separate arguments then).\n\tif (!eap->usefilter\n\t\t&& !escaped\n\t\t&& eap->cmdidx != CMD_bang\n\t\t&& eap->cmdidx != CMD_grep\n\t\t&& eap->cmdidx != CMD_grepadd\n\t\t&& eap->cmdidx != CMD_hardcopy\n\t\t&& eap->cmdidx != CMD_lgrep\n\t\t&& eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_lmake\n\t\t&& eap->cmdidx != CMD_make\n\t\t&& eap->cmdidx != CMD_terminal\n#ifndef UNIX\n\t\t&& !(eap->argt & EX_NOSPC)\n#endif\n\t\t)\n\t{\n\t    char_u\t*l;\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Don't escape a backslash here, because rem_backslash() doesn't\n\t    // remove it later.\n\t    static char_u *nobslash = (char_u *)\" \\t\\\"|\";\n# define ESCAPE_CHARS nobslash\n#else\n# define ESCAPE_CHARS escape_chars\n#endif\n\n\t    for (l = repl; *l; ++l)\n\t\tif (vim_strchr(ESCAPE_CHARS, *l) != NULL)\n\t\t{\n\t\t    l = vim_strsave_escaped(repl, ESCAPE_CHARS);\n\t\t    if (l != NULL)\n\t\t    {\n\t\t\tvim_free(repl);\n\t\t\trepl = l;\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\t// For a shell command a '!' must be escaped.\n\tif ((eap->usefilter || eap->cmdidx == CMD_bang\n\t\t\t\t\t\t|| eap->cmdidx == CMD_terminal)\n\t\t\t    && vim_strpbrk(repl, (char_u *)\"!\") != NULL)\n\t{\n\t    char_u\t*l;\n\n\t    l = vim_strsave_escaped(repl, (char_u *)\"!\");\n\t    if (l != NULL)\n\t    {\n\t\tvim_free(repl);\n\t\trepl = l;\n\t    }\n\t}\n\n\tp = repl_cmdline(eap, p, srclen, repl, cmdlinep);\n\tvim_free(repl);\n\tif (p == NULL)\n\t    return FAIL;\n    }\n\n    /*\n     * One file argument: Expand wildcards.\n     * Don't do this with \":r !command\" or \":w !command\".\n     */\n    if ((eap->argt & EX_NOSPC) && !eap->usefilter)\n    {\n\t/*\n\t * May do this twice:\n\t * 1. Replace environment variables.\n\t * 2. Replace any other wildcards, remove backslashes.\n\t */\n\tfor (n = 1; n <= 2; ++n)\n\t{\n\t    if (n == 2)\n\t    {\n\t\t/*\n\t\t * Halve the number of backslashes (this is Vi compatible).\n\t\t * For Unix and OS/2, when wildcards are expanded, this is\n\t\t * done by ExpandOne() below.\n\t\t */\n#if defined(UNIX)\n\t\tif (!has_wildcards)\n#endif\n\t\t    backslash_halve(eap->arg);\n\t    }\n\n\t    if (has_wildcards)\n\t    {\n\t\tif (n == 1)\n\t\t{\n\t\t    /*\n\t\t     * First loop: May expand environment variables.  This\n\t\t     * can be done much faster with expand_env() than with\n\t\t     * something else (e.g., calling a shell).\n\t\t     * After expanding environment variables, check again\n\t\t     * if there are still wildcards present.\n\t\t     */\n\t\t    if (vim_strchr(eap->arg, '$') != NULL\n\t\t\t    || vim_strchr(eap->arg, '~') != NULL)\n\t\t    {\n\t\t\texpand_env_esc(eap->arg, NameBuff, MAXPATHL,\n\t\t\t\t\t\t\t    TRUE, TRUE, NULL);\n\t\t\thas_wildcards = mch_has_wildcard(NameBuff);\n\t\t\tp = NameBuff;\n\t\t    }\n\t\t    else\n\t\t\tp = NULL;\n\t\t}\n\t\telse // n == 2\n\t\t{\n\t\t    expand_T\txpc;\n\t\t    int\t\toptions = WILD_LIST_NOTFOUND\n\t\t\t\t\t       | WILD_NOERROR | WILD_ADD_SLASH;\n\n\t\t    ExpandInit(&xpc);\n\t\t    xpc.xp_context = EXPAND_FILES;\n\t\t    if (p_wic)\n\t\t\toptions += WILD_ICASE;\n\t\t    p = ExpandOne(&xpc, eap->arg, NULL,\n\t\t\t\t\t\t   options, WILD_EXPAND_FREE);\n\t\t    if (p == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\t\tif (p != NULL)\n\t\t{\n\t\t    (void)repl_cmdline(eap, eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t\t\t\t p, cmdlinep);\n\t\t    if (n == 2)\t// p came from ExpandOne()\n\t\t\tvim_free(p);\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n/*\n * Replace part of the command line, keeping eap->cmd, eap->arg and\n * eap->nextcmd correct.\n * \"src\" points to the part that is to be replaced, of length \"srclen\".\n * \"repl\" is the replacement string.\n * Returns a pointer to the character after the replaced string.\n * Returns NULL for failure.\n */\n    static char_u *\nrepl_cmdline(\n    exarg_T\t*eap,\n    char_u\t*src,\n    int\t\tsrclen,\n    char_u\t*repl,\n    char_u\t**cmdlinep)\n{\n    int\t\tlen;\n    int\t\ti;\n    char_u\t*new_cmdline;\n\n    /*\n     * The new command line is build in new_cmdline[].\n     * First allocate it.\n     * Careful: a \"+cmd\" argument may have been NUL terminated.\n     */\n    len = (int)STRLEN(repl);\n    i = (int)(src - *cmdlinep) + (int)STRLEN(src + srclen) + len + 3;\n    if (eap->nextcmd != NULL)\n\ti += (int)STRLEN(eap->nextcmd);// add space for next command\n    if ((new_cmdline = alloc(i)) == NULL)\n\treturn NULL;\t\t\t// out of memory!\n\n    /*\n     * Copy the stuff before the expanded part.\n     * Copy the expanded stuff.\n     * Copy what came after the expanded part.\n     * Copy the next commands, if there are any.\n     */\n    i = (int)(src - *cmdlinep);\t// length of part before match\n    mch_memmove(new_cmdline, *cmdlinep, (size_t)i);\n\n    mch_memmove(new_cmdline + i, repl, (size_t)len);\n    i += len;\t\t\t\t// remember the end of the string\n    STRCPY(new_cmdline + i, src + srclen);\n    src = new_cmdline + i;\t\t// remember where to continue\n\n    if (eap->nextcmd != NULL)\t\t// append next command\n    {\n\ti = (int)STRLEN(new_cmdline) + 1;\n\tSTRCPY(new_cmdline + i, eap->nextcmd);\n\teap->nextcmd = new_cmdline + i;\n    }\n    eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);\n    eap->arg = new_cmdline + (eap->arg - *cmdlinep);\n    if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)\n\teap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);\n    vim_free(*cmdlinep);\n    *cmdlinep = new_cmdline;\n\n    return src;\n}\n\n/*\n * Check for '|' to separate commands and '\"' to start comments.\n * If \"keep_backslash\" is TRUE do not remove any backslash.\n */\n    void\nseparate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t// skip CTRL-V and next char\n\t    else\n\t\t\t\t// remove CTRL-V and skip next char\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n\n#ifdef FEAT_EVAL\n\t// Skip over `=expr` when wildcards are expanded.\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n#endif\n\n\t// Check for '\"': start of comment or '|': next command\n\t// :@\" and :*\" do not start a comment!\n\t// :redir @\" doesn't either.\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    /*\n\t     * We remove the '\\' before the '|', unless EX_CTRLV is used\n\t     * AND 'b' is present in 'cpoptions'.\n\t     */\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t// remove the '\\'\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (!(eap->argt & EX_NOTRLCOM))\t// remove trailing spaces\n\tdel_trailing_spaces(eap->arg);\n}\n\n/*\n * get + command from ex argument\n */\n    static char_u *\ngetargcmd(char_u **argp)\n{\n    char_u *arg = *argp;\n    char_u *command = NULL;\n\n    if (*arg == '+')\t    // +[command]\n    {\n\t++arg;\n\tif (vim_isspace(*arg) || *arg == NUL)\n\t    command = dollar_command;\n\telse\n\t{\n\t    command = arg;\n\t    arg = skip_cmd_arg(command, TRUE);\n\t    if (*arg != NUL)\n\t\t*arg++ = NUL;\t\t// terminate command with NUL\n\t}\n\n\targ = skipwhite(arg);\t// skip over spaces\n\t*argp = arg;\n    }\n    return command;\n}\n\n/*\n * Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\".\n */\n    char_u *\nskip_cmd_arg(\n    char_u *p,\n    int\t   rembs)\t// TRUE to halve the number of backslashes\n{\n    while (*p && !vim_isspace(*p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    if (rembs)\n\t\tSTRMOVE(p, p + 1);\n\t    else\n\t\t++p;\n\t}\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    int\nget_bad_opt(char_u *p, exarg_T *eap)\n{\n    if (STRICMP(p, \"keep\") == 0)\n\teap->bad_char = BAD_KEEP;\n    else if (STRICMP(p, \"drop\") == 0)\n\teap->bad_char = BAD_DROP;\n    else if (MB_BYTE2LEN(*p) == 1 && p[1] == NUL)\n\teap->bad_char = *p;\n    else\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get \"++opt=arg\" argument.\n * Return FAIL or OK.\n */\n    static int\ngetargopt(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg + 2;\n    int\t\t*pp = NULL;\n    int\t\tbad_char_idx;\n    char_u\t*p;\n\n    // \":edit ++[no]bin[ary] file\"\n    if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0)\n    {\n\tif (*arg == 'n')\n\t{\n\t    arg += 2;\n\t    eap->force_bin = FORCE_NOBIN;\n\t}\n\telse\n\t    eap->force_bin = FORCE_BIN;\n\tif (!checkforcmd(&arg, \"binary\", 3))\n\t    return FAIL;\n\teap->arg = skipwhite(arg);\n\treturn OK;\n    }\n\n    // \":read ++edit file\"\n    if (STRNCMP(arg, \"edit\", 4) == 0)\n    {\n\teap->read_edit = TRUE;\n\teap->arg = skipwhite(arg + 4);\n\treturn OK;\n    }\n\n    if (STRNCMP(arg, \"ff\", 2) == 0)\n    {\n\targ += 2;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"fileformat\", 10) == 0)\n    {\n\targ += 10;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"enc\", 3) == 0)\n    {\n\tif (STRNCMP(arg, \"encoding\", 8) == 0)\n\t    arg += 8;\n\telse\n\t    arg += 3;\n\tpp = &eap->force_enc;\n    }\n    else if (STRNCMP(arg, \"bad\", 3) == 0)\n    {\n\targ += 3;\n\tpp = &bad_char_idx;\n    }\n\n    if (pp == NULL || *arg != '=')\n\treturn FAIL;\n\n    ++arg;\n    *pp = (int)(arg - eap->cmd);\n    arg = skip_cmd_arg(arg, FALSE);\n    eap->arg = skipwhite(arg);\n    *arg = NUL;\n\n    if (pp == &eap->force_ff)\n    {\n\tif (check_ff_value(eap->cmd + eap->force_ff) == FAIL)\n\t    return FAIL;\n\teap->force_ff = eap->cmd[eap->force_ff];\n    }\n    else if (pp == &eap->force_enc)\n    {\n\t// Make 'fileencoding' lower case.\n\tfor (p = eap->cmd + eap->force_enc; *p != NUL; ++p)\n\t    *p = TOLOWER_ASC(*p);\n    }\n    else\n    {\n\t// Check ++bad= argument.  Must be a single-byte character, \"keep\" or\n\t// \"drop\".\n\tif (get_bad_opt(eap->cmd + bad_char_idx, eap) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static void\nex_autocmd(exarg_T *eap)\n{\n    /*\n     * Disallow autocommands from .exrc and .vimrc in current\n     * directory for security reasons.\n     */\n    if (secure)\n    {\n\tsecure = 2;\n\teap->errmsg =\n\t      _(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search);\n    }\n    else if (eap->cmdidx == CMD_autocmd)\n\tdo_autocmd(eap, eap->arg, eap->forceit);\n    else\n\tdo_augroup(eap->arg, eap->forceit);\n}\n\n/*\n * \":doautocmd\": Apply the automatic commands to the current buffer.\n */\n    static void\nex_doautocmd(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    (void)do_doautocmd(arg, TRUE, &did_aucmd);\n    // Only when there is no <nomodeline>.\n    if (call_do_modelines && did_aucmd)\n\tdo_modelines(0);\n}\n\n/*\n * :[N]bunload[!] [N] [bufname] unload buffer\n * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list\n * :[N]bwipeout[!] [N] [bufname] delete buffer really\n */\n    static void\nex_bunload(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    eap->errmsg = do_bufdel(\n\t    eap->cmdidx == CMD_bdelete ? DOBUF_DEL\n\t\t: eap->cmdidx == CMD_bwipeout ? DOBUF_WIPE\n\t\t: DOBUF_UNLOAD, eap->arg,\n\t    eap->addr_count, (int)eap->line1, (int)eap->line2, eap->forceit);\n}\n\n/*\n * :[N]buffer [N]\tto buffer N\n * :[N]sbuffer [N]\tto buffer N\n */\n    static void\nex_buffer(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (*eap->arg)\n\teap->errmsg = ex_errmsg(e_trailing_characters_str, eap->arg);\n    else\n    {\n\tif (eap->addr_count == 0)\t// default is current buffer\n\t    goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);\n\telse\n\t    goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n    }\n}\n\n/*\n * :[N]bmodified [N]\tto next mod. buffer\n * :[N]sbmodified [N]\tto next mod. buffer\n */\n    static void\nex_bmodified(exarg_T *eap)\n{\n    goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bnext [N]\tto next buffer\n * :[N]sbnext [N]\tsplit and to next buffer\n */\n    static void\nex_bnext(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bNext [N]\tto previous buffer\n * :[N]bprevious [N]\tto previous buffer\n * :[N]sbNext [N]\tsplit and to previous buffer\n * :[N]sbprevious [N]\tsplit and to previous buffer\n */\n    static void\nex_bprevious(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :brewind\t\tto first buffer\n * :bfirst\t\tto first buffer\n * :sbrewind\t\tsplit and to first buffer\n * :sbfirst\t\tsplit and to first buffer\n */\n    static void\nex_brewind(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :blast\t\tto last buffer\n * :sblast\t\tsplit and to last buffer\n */\n    static void\nex_blast(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * Check if \"c\" ends an Ex command.\n * In Vim9 script does not check for white space before #.\n */\n    int\nends_excmd(int c)\n{\n    int comment_char = '\"';\n\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\tcomment_char = '#';\n#endif\n    return (c == NUL || c == '|' || c == comment_char || c == '\\n');\n}\n\n/*\n * Like ends_excmd() but checks that a # in Vim9 script either has \"cmd\" equal\n * to \"cmd_start\" or has a white space character before it.\n */\n    int\nends_excmd2(char_u *cmd_start UNUSED, char_u *cmd)\n{\n    int c = *cmd;\n\n    if (c == NUL || c == '|' || c == '\\n')\n\treturn TRUE;\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\t//  # starts a comment, #{ might be a mistake, #{{ can start a fold\n\treturn c == '#' && (cmd[1] != '{' || cmd[2] == '{')\n\t\t\t\t && (cmd == cmd_start || VIM_ISWHITE(cmd[-1]));\n#endif\n    return c == '\"';\n}\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_EVAL) \\\n\t|| defined(PROTO)\n/*\n * Return the next command, after the first '|' or '\\n'.\n * Return NULL if not found.\n */\n    char_u *\nfind_nextcmd(char_u *p)\n{\n    while (*p != '|' && *p != '\\n')\n    {\n\tif (*p == NUL)\n\t    return NULL;\n\t++p;\n    }\n    return (p + 1);\n}\n#endif\n\n/*\n * Check if *p is a separator between Ex commands, skipping over white space.\n * Return NULL if it isn't, the following character if it is.\n */\n    char_u *\ncheck_nextcmd(char_u *p)\n{\n    char_u *s = skipwhite(p);\n\n    if (*s == '|' || *s == '\\n')\n\treturn (s + 1);\n    else\n\treturn NULL;\n}\n\n/*\n * If \"eap->nextcmd\" is not set, check for a next command at \"p\".\n */\n    void\nset_nextcmd(exarg_T *eap, char_u *arg)\n{\n    char_u *p = check_nextcmd(arg);\n\n    if (eap->nextcmd == NULL)\n\teap->nextcmd = p;\n    else if (p != NULL)\n\t// cannot use \"| command\" inside a  {} block\n\tsemsg(_(e_cannot_use_bar_to_separate_commands_here_str), arg);\n}\n\n/*\n * - if there are more files to edit\n * - and this is the last window\n * - and forceit not used\n * - and not repeated twice on a row\n *    return FAIL and give error message if 'message' TRUE\n * return OK otherwise\n */\n    static int\ncheck_more(\n    int message,\t    // when FALSE check only, no messages\n    int forceit)\n{\n    int\t    n = ARGCOUNT - curwin->w_arg_idx - 1;\n\n    if (!forceit && only_one_window()\n\t    && ARGCOUNT > 1 && !arg_had_last && n > 0 && quitmore == 0)\n    {\n\tif (message)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t    && curbuf->b_fname != NULL)\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tvim_snprintf((char *)buff, DIALOG_MSG_SIZE,\n\t\t\tNGETTEXT(\"%d more file to edit.  Quit anyway?\",\n\t\t\t    \"%d more files to edit.  Quit anyway?\", n), n);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)\n\t\t    return OK;\n\t\treturn FAIL;\n\t    }\n#endif\n\t    semsg(NGETTEXT(e_nr_more_file_to_edit,\n\t\t\t   e_nr_more_files_to_edit , n), n);\n\t    quitmore = 2;\t    // next try to quit is allowed\n\t}\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of command names.\n */\n    char_u *\nget_command_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx >= (int)CMD_SIZE)\n\treturn expand_user_command_name(idx);\n    return cmdnames[idx].cmd_name;\n}\n\n    static void\nex_colorscheme(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n    {\n#ifdef FEAT_EVAL\n\tchar_u *expr = vim_strsave((char_u *)\"g:colors_name\");\n\tchar_u *p = NULL;\n\n\tif (expr != NULL)\n\t{\n\t    ++emsg_off;\n\t    p = eval_to_string(expr, FALSE);\n\t    --emsg_off;\n\t    vim_free(expr);\n\t}\n\tif (p != NULL)\n\t{\n\t    msg((char *)p);\n\t    vim_free(p);\n\t}\n\telse\n\t    msg(\"default\");\n#else\n\tmsg(_(\"unknown\"));\n#endif\n    }\n    else if (load_colors(eap->arg) == FAIL)\n\tsemsg(_(e_cannot_find_color_scheme_str), eap->arg);\n\n#ifdef FEAT_VTP\n    else if (has_vtp_working())\n    {\n\t// background color change requires clear + redraw\n\tupdate_screen(CLEAR);\n\tredrawcmd();\n    }\n#endif\n}\n\n    static void\nex_highlight(exarg_T *eap)\n{\n    if (*eap->arg == NUL && eap->cmd[2] == '!')\n\tmsg(_(\"Greetings, Vim user!\"));\n    do_highlight(eap->arg, eap->forceit, FALSE);\n}\n\n\n/*\n * Call this function if we thought we were going to exit, but we won't\n * (because of an error).  May need to restore the terminal mode.\n */\n    void\nnot_exiting(void)\n{\n    exiting = FALSE;\n    settmode(TMODE_RAW);\n}\n\n    int\nbefore_quit_autocmds(win_T *wp, int quit_all, int forceit)\n{\n    apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, wp->w_buffer);\n\n    // Bail out when autocommands closed the window.\n    // Refuse to quit when the buffer in the last window is being closed (can\n    // only happen in autocommands).\n    if (!win_valid(wp)\n\t    || curbuf_locked()\n\t    || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0))\n\treturn TRUE;\n\n    if (quit_all || (check_more(FALSE, forceit) == OK && only_one_window()))\n    {\n\tapply_autocmds(EVENT_EXITPRE, NULL, NULL, FALSE, curbuf);\n\t// Refuse to quit when locked or when the window was closed or the\n\t// buffer in the last window is being closed (can only happen in\n\t// autocommands).\n\tif (!win_valid(wp) || curbuf_locked()\n\t\t\t  || (curbuf->b_nwindows == 1 && curbuf->b_locked > 0))\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * \":quit\": quit current window, quit Vim if the last window is closed.\n * \":{nr}quit\": quit window {nr}\n * Also used when closing a terminal window that's the last one.\n */\n    void\nex_quit(exarg_T *eap)\n{\n    win_T\t*wp;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n#endif\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n    if (eap->addr_count > 0)\n    {\n\tint\twnr = eap->line2;\n\n\tfor (wp = firstwin; wp->w_next != NULL; wp = wp->w_next)\n\t    if (--wnr <= 0)\n\t\tbreak;\n    }\n    else\n\twp = curwin;\n\n    // Refuse to quit when locked.\n    if (curbuf_locked())\n\treturn;\n\n    // Trigger QuitPre and maybe ExitPre\n    if (before_quit_autocmds(wp, FALSE, eap->forceit))\n\treturn;\n\n#ifdef FEAT_NETBEANS_INTG\n    netbeansForcedQuit = eap->forceit;\n#endif\n\n    /*\n     * If there is only one relevant window we will exit.\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n    if ((!buf_hide(wp->w_buffer)\n\t\t&& check_changed(wp->w_buffer, (p_awa ? CCGD_AW : 0)\n\t\t\t\t       | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t\t       | CCGD_EXCMD))\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, TRUE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\t// quit last window\n\t// Note: only_one_window() returns true, even so a help window is\n\t// still open. In that case only quit, if no address has been\n\t// specified. Example:\n\t// :h|wincmd w|1q     - don't quit\n\t// :h|wincmd w|q      - quit\n\tif (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))\n\t    getout(0);\n\tnot_exiting();\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\t// close window; may free buffer\n\twin_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);\n    }\n}\n\n/*\n * \":cquit\".\n */\n    static void\nex_cquit(exarg_T *eap UNUSED)\n{\n    // this does not always pass on the exit code to the Manx compiler. why?\n    getout(eap->addr_count > 0 ? (int)eap->line2 : EXIT_FAILURE);\n}\n\n/*\n * \":qall\": try to quit all windows\n */\n    static void\nex_quit_all(exarg_T *eap)\n{\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tif (eap->forceit)\n\t    cmdwin_result = K_XF1;\t// ex_window() takes care of this\n\telse\n\t    cmdwin_result = K_XF2;\n\treturn;\n    }\n# endif\n\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    if (before_quit_autocmds(curwin, TRUE, eap->forceit))\n\treturn;\n\n    exiting = TRUE;\n    if (eap->forceit || !check_changed_any(FALSE, FALSE))\n\tgetout(0);\n    not_exiting();\n}\n\n/*\n * \":close\": close current window, unless it is the last one\n */\n    static void\nex_close(exarg_T *eap)\n{\n    win_T\t*win;\n    int\t\twinnr = 0;\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = Ctrl_C;\n    else\n#endif\n\tif (!text_locked() && !curbuf_locked())\n\t{\n\t    if (eap->addr_count == 0)\n\t\tex_win_close(eap->forceit, curwin, NULL);\n\t    else\n\t    {\n\t\tFOR_ALL_WINDOWS(win)\n\t\t{\n\t\t    winnr++;\n\t\t    if (winnr == eap->line2)\n\t\t\tbreak;\n\t\t}\n\t\tif (win == NULL)\n\t\t    win = lastwin;\n\t\tex_win_close(eap->forceit, win, NULL);\n\t    }\n\t}\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":pclose\": Close any preview window.\n */\n    static void\nex_pclose(exarg_T *eap)\n{\n    win_T\t*win;\n\n    // First close any normal window.\n    FOR_ALL_WINDOWS(win)\n\tif (win->w_p_pvw)\n\t{\n\t    ex_win_close(eap->forceit, win, NULL);\n\t    return;\n\t}\n# ifdef FEAT_PROP_POPUP\n    // Also when 'previewpopup' is empty, it might have been cleared.\n    popup_close_preview();\n# endif\n}\n#endif\n\n/*\n * Close window \"win\" and take care of handling closing the last window for a\n * modified buffer.\n */\n    static void\nex_win_close(\n    int\t\tforceit,\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// NULL or the tab page \"win\" is in\n{\n    int\t\tneed_hide;\n    buf_T\t*buf = win->w_buffer;\n\n    // Never close the autocommand window.\n    if (win == aucmd_win)\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn;\n    }\n\n    need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);\n    if (need_hide && !buf_hide(buf) && !forceit)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(buf, FALSE);\n\t    if (bufref_valid(&bufref) && bufIsChanged(buf))\n\t\treturn;\n\t    need_hide = FALSE;\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return;\n\t}\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // free buffer when not hiding it or when it's a scratch buffer\n    if (tp == NULL)\n\twin_close(win, !need_hide && !buf_hide(buf));\n    else\n\twin_close_othertab(win, !need_hide && !buf_hide(buf), tp);\n}\n\n/*\n * Handle the argument for a tabpage related ex command.\n * Returns a tabpage number.\n * When an error is encountered then eap->errmsg is set.\n */\n    static int\nget_tabpage_arg(exarg_T *eap)\n{\n    int tab_number;\n    int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;\n\n    if (eap->arg && *eap->arg != NUL)\n    {\n\tchar_u *p = eap->arg;\n\tchar_u *p_save;\n\tint    relative = 0; // argument +N/-N means: go to N places to the\n\t\t\t     // right/left relative to the current position.\n\n\tif (*p == '-')\n\t{\n\t    relative = -1;\n\t    p++;\n\t}\n\telse if (*p == '+')\n\t{\n\t    relative = 1;\n\t    p++;\n\t}\n\n\tp_save = p;\n\ttab_number = getdigits(&p);\n\n\tif (relative == 0)\n\t{\n\t    if (STRCMP(p, \"$\") == 0)\n\t\ttab_number = LAST_TAB_NR;\n\t    else if (STRCMP(p, \"#\") == 0)\n\t\tif (valid_tabpage(lastused_tabpage))\n\t\t    tab_number = tabpage_index(lastused_tabpage);\n\t\telse\n\t\t{\n\t\t    eap->errmsg = ex_errmsg(e_invalid_value_for_argument_str, eap->arg);\n\t\t    tab_number = 0;\n\t\t    goto theend;\n\t\t}\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number > LAST_TAB_NR)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (*p_save == NUL)\n\t\ttab_number = 1;\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number == 0)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\tgoto theend;\n\t    }\n\t    tab_number = tab_number * relative + tabpage_index(curtab);\n\t    if (!unaccept_arg0 && relative == -1)\n\t\t--tab_number;\n\t}\n\tif (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)\n\t    eap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n    }\n    else if (eap->addr_count > 0)\n    {\n\tif (unaccept_arg0 && eap->line2 == 0)\n\t{\n\t    eap->errmsg = _(e_invalid_range);\n\t    tab_number = 0;\n\t}\n\telse\n\t{\n\t    tab_number = eap->line2;\n\t    if (!unaccept_arg0 && *skipwhite(*eap->cmdlinep) == '-')\n\t    {\n\t\t--tab_number;\n\t\tif (tab_number < unaccept_arg0)\n\t\t    eap->errmsg = _(e_invalid_range);\n\t    }\n\t}\n    }\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\tcase CMD_tabnext:\n\t    tab_number = tabpage_index(curtab) + 1;\n\t    if (tab_number > LAST_TAB_NR)\n\t\ttab_number = 1;\n\t    break;\n\tcase CMD_tabmove:\n\t    tab_number = LAST_TAB_NR;\n\t    break;\n\tdefault:\n\t    tab_number = tabpage_index(curtab);\n\t}\n    }\n\ntheend:\n    return tab_number;\n}\n\n/*\n * \":tabclose\": close current tab page, unless it is the last one.\n * \":tabclose N\": close tab page N.\n */\n    static void\nex_tabclose(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\ttab_number;\n\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = K_IGNORE;\n    else\n# endif\n\tif (first_tabpage->tp_next == NULL)\n\t    emsg(_(e_cannot_close_last_tab_page));\n\telse\n\t{\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t    {\n\t\ttp = find_tabpage(tab_number);\n\t\tif (tp == NULL)\n\t\t{\n\t\t    beep_flush();\n\t\t    return;\n\t\t}\n\t\tif (tp != curtab)\n\t\t{\n\t\t    tabpage_close_other(tp, eap->forceit);\n\t\t    return;\n\t\t}\n\t\telse if (!text_locked() && !curbuf_locked())\n\t\t    tabpage_close(eap->forceit);\n\t    }\n\t}\n}\n\n/*\n * \":tabonly\": close all tab pages except the current one\n */\n    static void\nex_tabonly(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\tdone;\n    int\t\ttab_number;\n\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = K_IGNORE;\n    else\n# endif\n\tif (first_tabpage->tp_next == NULL)\n\t    msg(_(\"Already only one tab page\"));\n\telse\n\t{\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t    {\n\t\tgoto_tabpage(tab_number);\n\t\t// Repeat this up to a 1000 times, because autocommands may\n\t\t// mess up the lists.\n\t\tfor (done = 0; done < 1000; ++done)\n\t\t{\n\t\t    FOR_ALL_TABPAGES(tp)\n\t\t\tif (tp->tp_topframe != topframe)\n\t\t\t{\n\t\t\t    tabpage_close_other(tp, eap->forceit);\n\t\t\t    // if we failed to close it quit\n\t\t\t    if (valid_tabpage(tp))\n\t\t\t\tdone = 1000;\n\t\t\t    // start over, \"tp\" is now invalid\n\t\t\t    break;\n\t\t\t}\n\t\t    if (first_tabpage->tp_next == NULL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n}\n\n/*\n * Close the current tab page.\n */\n    void\ntabpage_close(int forceit)\n{\n    // First close all the windows but the current one.  If that worked then\n    // close the last window in this tab, that will close it.\n    if (!ONE_WINDOW)\n\tclose_others(TRUE, forceit);\n    if (ONE_WINDOW)\n\tex_win_close(forceit, curwin, NULL);\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n}\n\n/*\n * Close tab page \"tp\", which is not the current tab page.\n * Note that autocommands may make \"tp\" invalid.\n * Also takes care of the tab pages line disappearing when closing the\n * last-but-one tab page.\n */\n    void\ntabpage_close_other(tabpage_T *tp, int forceit)\n{\n    int\t\tdone = 0;\n    win_T\t*wp;\n    int\t\th = tabline_height();\n\n    // Limit to 1000 windows, autocommands may add a window while we close\n    // one.  OK, so I'm paranoid...\n    while (++done < 1000)\n    {\n\twp = tp->tp_firstwin;\n\tex_win_close(forceit, wp, tp);\n\n\t// Autocommands may delete the tab page under our fingers and we may\n\t// fail to close a window with a modified buffer.\n\tif (!valid_tabpage(tp) || tp->tp_firstwin == wp)\n\t    break;\n    }\n\n    apply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * \":only\".\n */\n    static void\nex_only(exarg_T *eap)\n{\n    win_T   *wp;\n    int\t    wnr;\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    if (eap->addr_count > 0)\n    {\n\twnr = eap->line2;\n\tfor (wp = firstwin; --wnr > 0; )\n\t{\n\t    if (wp->w_next == NULL)\n\t\tbreak;\n\t    else\n\t\twp = wp->w_next;\n\t}\n\twin_goto(wp);\n    }\n    close_others(TRUE, eap->forceit);\n}\n\n    static void\nex_hide(exarg_T *eap UNUSED)\n{\n    // \":hide\" or \":hide | cmd\": hide current window\n    if (!eap->skip)\n    {\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\tif (eap->addr_count == 0)\n\t    win_close(curwin, FALSE);\t// don't free buffer\n\telse\n\t{\n\t    int\twinnr = 0;\n\t    win_T\t*win;\n\n\t    FOR_ALL_WINDOWS(win)\n\t    {\n\t\twinnr++;\n\t\tif (winnr == eap->line2)\n\t\t    break;\n\t    }\n\t    if (win == NULL)\n\t\twin = lastwin;\n\t    win_close(win, FALSE);\n\t}\n    }\n}\n\n/*\n * \":stop\" and \":suspend\": Suspend Vim.\n */\n    void\nex_stop(exarg_T *eap)\n{\n    /*\n     * Disallow suspending for \"rvim\".\n     */\n    if (!check_restricted())\n    {\n\tif (!eap->forceit)\n\t    autowrite_all();\n\tapply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, FALSE, NULL);\n\twindgoto((int)Rows - 1, 0);\n\tout_char('\\n');\n\tout_flush();\n\tstoptermcap();\n\tout_flush();\t\t// needed for SUN to restore xterm buffer\n\tmch_restore_title(SAVE_RESTORE_BOTH);\t// restore window titles\n\tui_suspend();\t\t// call machine specific function\n\tmaketitle();\n\tresettitle();\t\t// force updating the title\n\tstarttermcap();\n\tscroll_start();\t\t// scroll screen before redrawing\n\tredraw_later_clear();\n\tshell_resized();\t// may have resized window\n\tapply_autocmds(EVENT_VIMRESUME, NULL, NULL, FALSE, NULL);\n    }\n}\n\n/*\n * \":exit\", \":xit\" and \":wq\": Write file and quit the current window.\n */\n    static void\nex_exit(exarg_T *eap)\n{\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n#endif\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    /*\n     * we plan to exit if there is only one relevant window\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n\n    // Write the buffer for \":wq\" or when it was changed.\n    // Trigger QuitPre and ExitPre.\n    // Check if we can exit now, after autocommands have changed things.\n    if (((eap->cmdidx == CMD_wq || curbufIsChanged()) && do_write(eap) == FAIL)\n\t    || before_quit_autocmds(curwin, FALSE, eap->forceit)\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, FALSE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\tif (only_one_window())\t    // quit last window, exit Vim\n\t    getout(0);\n\tnot_exiting();\n# ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n# endif\n\t// Quit current window, may free the buffer.\n\twin_close(curwin, !buf_hide(curwin->w_buffer));\n    }\n}\n\n/*\n * \":print\", \":list\", \":number\".\n */\n    static void\nex_print(exarg_T *eap)\n{\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\temsg(_(e_empty_buffer));\n    else\n    {\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    print_line(eap->line1,\n\t\t    (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound\n\t\t\t\t\t\t || (eap->flags & EXFLAG_NR)),\n\t\t    eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));\n\t    if (++eap->line1 > eap->line2)\n\t\tbreak;\n\t    out_flush();\t    // show one line at a time\n\t}\n\tsetpcmark();\n\t// put cursor at last line\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    ex_no_reprint = TRUE;\n}\n\n#ifdef FEAT_BYTEOFF\n    static void\nex_goto(exarg_T *eap)\n{\n    goto_byte(eap->line2);\n}\n#endif\n\n/*\n * \":shell\".\n */\n    static void\nex_shell(exarg_T *eap UNUSED)\n{\n    do_shell(NULL, 0);\n}\n\n#if defined(HAVE_DROP_FILE) || defined(PROTO)\n\nstatic int drop_busy = FALSE;\nstatic int drop_filec;\nstatic char_u **drop_filev = NULL;\nstatic int drop_split;\nstatic void (*drop_callback)(void *);\nstatic void *drop_cookie;\n\n    static void\nhandle_drop_internal(void)\n{\n    exarg_T\tea;\n    int\t\tsave_msg_scroll = msg_scroll;\n\n    // Setting the argument list may cause screen updates and being called\n    // recursively.  Avoid that by setting drop_busy.\n    drop_busy = TRUE;\n\n    // Check whether the current buffer is changed. If so, we will need\n    // to split the current window or data could be lost.\n    // We don't need to check if the 'hidden' option is set, as in this\n    // case the buffer won't be lost.\n    if (!buf_hide(curbuf) && !drop_split)\n    {\n\t++emsg_off;\n\tdrop_split = check_changed(curbuf, CCGD_AW);\n\t--emsg_off;\n    }\n    if (drop_split)\n    {\n\tif (win_split(0, 0) == FAIL)\n\t    return;\n\tRESET_BINDING(curwin);\n\n\t// When splitting the window, create a new alist.  Otherwise the\n\t// existing one is overwritten.\n\talist_unlink(curwin->w_alist);\n\talist_new();\n    }\n\n    /*\n     * Set up the new argument list.\n     */\n    alist_set(ALIST(curwin), drop_filec, drop_filev, FALSE, NULL, 0);\n\n    /*\n     * Move to the first file.\n     */\n    // Fake up a minimal \"next\" command for do_argfile()\n    CLEAR_FIELD(ea);\n    ea.cmd = (char_u *)\"next\";\n    do_argfile(&ea, 0);\n\n    // do_ecmd() may set need_start_insertmode, but since we never left Insert\n    // mode that is not needed here.\n    need_start_insertmode = FALSE;\n\n    // Restore msg_scroll, otherwise a following command may cause scrolling\n    // unexpectedly.  The screen will be redrawn by the caller, thus\n    // msg_scroll being set by displaying a message is irrelevant.\n    msg_scroll = save_msg_scroll;\n\n    if (drop_callback != NULL)\n\tdrop_callback(drop_cookie);\n\n    drop_filev = NULL;\n    drop_busy = FALSE;\n}\n\n/*\n * Handle a file drop. The code is here because a drop is *nearly* like an\n * :args command, but not quite (we have a list of exact filenames, so we\n * don't want to (a) parse a command line, or (b) expand wildcards). So the\n * code is very similar to :args and hence needs access to a lot of the static\n * functions in this file.\n *\n * The \"filev\" list must have been allocated using alloc(), as should each item\n * in the list. This function takes over responsibility for freeing the \"filev\"\n * list.\n */\n    void\nhandle_drop(\n    int\t\tfilec,\t\t// the number of files dropped\n    char_u\t**filev,\t// the list of files dropped\n    int\t\tsplit,\t\t// force splitting the window\n    void\t(*callback)(void *), // to be called after setting the argument\n\t\t\t\t     // list\n    void\t*cookie)\t// argument for \"callback\" (allocated)\n{\n    // Cannot handle recursive drops, finish the pending one.\n    if (drop_busy)\n    {\n\tFreeWild(filec, filev);\n\tvim_free(cookie);\n\treturn;\n    }\n\n    // When calling handle_drop() more than once in a row we only use the last\n    // one.\n    if (drop_filev != NULL)\n    {\n\tFreeWild(drop_filec, drop_filev);\n\tvim_free(drop_cookie);\n    }\n\n    drop_filec = filec;\n    drop_filev = filev;\n    drop_split = split;\n    drop_callback = callback;\n    drop_cookie = cookie;\n\n    // Postpone this when:\n    // - editing the command line\n    // - not possible to change the current buffer\n    // - updating the screen\n    // As it may change buffers and window structures that are in use and cause\n    // freed memory to be used.\n    if (text_locked() || curbuf_locked() || updating_screen)\n\treturn;\n\n    handle_drop_internal();\n}\n\n/*\n * To be called when text is unlocked, curbuf is unlocked or updating_screen is\n * reset: Handle a postponed drop.\n */\n    void\nhandle_any_postponed_drop(void)\n{\n    if (!drop_busy && drop_filev != NULL\n\t     && !text_locked() && !curbuf_locked() && !updating_screen)\n\thandle_drop_internal();\n}\n#endif\n\n/*\n * \":preserve\".\n */\n    static void\nex_preserve(exarg_T *eap UNUSED)\n{\n    curbuf->b_flags |= BF_PRESERVED;\n    ml_preserve(curbuf, TRUE);\n}\n\n/*\n * \":recover\".\n */\n    static void\nex_recover(exarg_T *eap)\n{\n    // Set recoverymode right away to avoid the ATTENTION prompt.\n    recoverymode = TRUE;\n    if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t     | CCGD_MULTWIN\n\t\t\t     | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t     | CCGD_EXCMD)\n\n\t    && (*eap->arg == NUL\n\t\t\t     || setfname(curbuf, eap->arg, NULL, TRUE) == OK))\n\tml_recover(TRUE);\n    recoverymode = FALSE;\n}\n\n/*\n * Command modifier used in a wrong way.\n */\n    static void\nex_wrongmodifier(exarg_T *eap)\n{\n    eap->errmsg = _(e_invalid_command);\n}\n\n/*\n * :sview [+command] file\tsplit window with new file, read-only\n * :split [[+command] file]\tsplit window with current or new file\n * :vsplit [[+command] file]\tsplit window vertically with current or new file\n * :new [[+command] file]\tsplit window with no or new file\n * :vnew [[+command] file]\tsplit vertically window with no or new file\n * :sfind [+command] file\tsplit window with file in 'path'\n *\n * :tabedit\t\t\topen new Tab page with empty window\n * :tabedit [+command] file\topen new Tab page and edit \"file\"\n * :tabnew [[+command] file]\tjust like :tabedit\n * :tabfind [+command] file\topen new Tab page and find \"file\"\n */\n    void\nex_splitview(exarg_T *eap)\n{\n    win_T\t*old_curwin = curwin;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)\n    char_u\t*fname = NULL;\n#endif\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#endif\n    int\t\tuse_tab = eap->cmdidx == CMD_tabedit\n\t\t       || eap->cmdidx == CMD_tabfind\n\t\t       || eap->cmdidx == CMD_tabnew;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // A \":split\" in the quickfix window works like \":new\".  Don't want two\n    // quickfix windows.  But it's OK when doing \":tab split\".\n    if (bt_quickfix(curbuf) && cmdmod.cmod_tab == 0)\n    {\n\tif (eap->cmdidx == CMD_split)\n\t    eap->cmdidx = CMD_new;\n\tif (eap->cmdidx == CMD_vsplit)\n\t    eap->cmdidx = CMD_vnew;\n    }\n#endif\n\n#ifdef FEAT_SEARCHPATH\n    if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind)\n    {\n\tfname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t  FNAME_MESS, TRUE, curbuf->b_ffname);\n\tif (fname == NULL)\n\t    goto theend;\n\teap->arg = fname;\n    }\n# ifdef FEAT_BROWSE\n    else\n# endif\n#endif\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE)\n\t    && eap->cmdidx != CMD_vnew\n\t    && eap->cmdidx != CMD_new)\n    {\n\tif (\n# ifdef FEAT_GUI\n\t    !gui.in_use &&\n# endif\n\t\tau_has_group((char_u *)\"FileExplorer\"))\n\t{\n\t    // No browsing supported but we do have the file explorer:\n\t    // Edit the directory.\n\t    if (*eap->arg == NUL || !mch_isdir(eap->arg))\n\t\teap->arg = dot_path;\n\t}\n\telse\n\t{\n\t    fname = do_browse(0, (char_u *)(use_tab\n\t\t\t? _(\"Edit File in new tab page\")\n\t\t\t: _(\"Edit File in new window\")),\n\t\t\t\t\t  eap->arg, NULL, NULL, NULL, curbuf);\n\t    if (fname == NULL)\n\t\tgoto theend;\n\t    eap->arg = fname;\n\t}\n    }\n    cmdmod.cmod_flags &= ~CMOD_BROWSE;\t// Don't browse again in do_ecmd().\n#endif\n\n    /*\n     * Either open new tab page or split the window.\n     */\n    if (use_tab)\n    {\n\tif (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab\n\t\t\t : eap->addr_count == 0 ? 0\n\t\t\t\t\t       : (int)eap->line2 + 1) != FAIL)\n\t{\n\t    do_exedit(eap, old_curwin);\n\n\t    // set the alternate buffer for the window we came from\n\t    if (curwin != old_curwin\n\t\t    && win_valid(old_curwin)\n\t\t    && old_curwin->w_buffer != curbuf\n\t\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\t}\n    }\n    else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,\n\t\t\t\t     *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL)\n    {\n\t// Reset 'scrollbind' when editing another file, but keep it when\n\t// doing \":split\" without arguments.\n\tif (*eap->arg != NUL)\n\t    RESET_BINDING(curwin);\n\telse\n\t    do_check_scrollbind(FALSE);\n\tdo_exedit(eap, old_curwin);\n    }\n\n# ifdef FEAT_BROWSE\n    cmdmod.cmod_flags = save_cmod_flags;\n# endif\n\n# if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)\ntheend:\n    vim_free(fname);\n# endif\n}\n\n/*\n * Open a new tab page.\n */\n    void\ntabpage_new(void)\n{\n    exarg_T\tea;\n\n    CLEAR_FIELD(ea);\n    ea.cmdidx = CMD_tabnew;\n    ea.cmd = (char_u *)\"tabn\";\n    ea.arg = (char_u *)\"\";\n    ex_splitview(&ea);\n}\n\n/*\n * :tabnext command\n */\n    static void\nex_tabnext(exarg_T *eap)\n{\n    int tab_number;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    switch (eap->cmdidx)\n    {\n\tcase CMD_tabfirst:\n\tcase CMD_tabrewind:\n\t    goto_tabpage(1);\n\t    break;\n\tcase CMD_tablast:\n\t    goto_tabpage(9999);\n\t    break;\n\tcase CMD_tabprevious:\n\tcase CMD_tabNext:\n\t    if (eap->arg && *eap->arg != NUL)\n\t    {\n\t\tchar_u *p = eap->arg;\n\t\tchar_u *p_save = p;\n\n\t\ttab_number = getdigits(&p);\n\t\tif (p == p_save || *p_save == '-' || *p != NUL\n\t\t\t    || tab_number == 0)\n\t\t{\n\t\t    // No numbers as argument.\n\t\t    eap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (eap->addr_count == 0)\n\t\t    tab_number = 1;\n\t\telse\n\t\t{\n\t\t    tab_number = eap->line2;\n\t\t    if (tab_number < 1)\n\t\t    {\n\t\t\teap->errmsg = _(e_invalid_range);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t    }\n\t    goto_tabpage(-tab_number);\n\t    break;\n\tdefault: // CMD_tabnext\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t\tgoto_tabpage(tab_number);\n\t    break;\n    }\n}\n\n/*\n * :tabmove command\n */\n    static void\nex_tabmove(exarg_T *eap)\n{\n    int tab_number;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL)\n\ttabpage_move(tab_number);\n}\n\n/*\n * :tabs command: List tabs and their contents.\n */\n    static void\nex_tabs(exarg_T *eap UNUSED)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n    int\t\ttabcount = 1;\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (tp = first_tabpage; tp != NULL && !got_int; tp = tp->tp_next)\n    {\n\tmsg_putchar('\\n');\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Tab page %d\"), tabcount++);\n\tmsg_outtrans_attr(IObuff, HL_ATTR(HLF_T));\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n\n\tif (tp  == curtab)\n\t    wp = firstwin;\n\telse\n\t    wp = tp->tp_firstwin;\n\tfor ( ; wp != NULL && !got_int; wp = wp->w_next)\n\t{\n\t    msg_putchar('\\n');\n\t    msg_putchar(wp == curwin ? '>' : ' ');\n\t    msg_putchar(' ');\n\t    msg_putchar(bufIsChanged(wp->w_buffer) ? '+' : ' ');\n\t    msg_putchar(' ');\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(IObuff, buf_spname(wp->w_buffer), IOSIZE - 1);\n\t    else\n\t\thome_replace(wp->w_buffer, wp->w_buffer->b_fname,\n\t\t\t\t\t\t\tIObuff, IOSIZE, TRUE);\n\t    msg_outtrans(IObuff);\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n}\n\n/*\n * \":mode\": Set screen mode.\n * If no argument given, just get the screen size and redraw.\n */\n    static void\nex_mode(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n\tshell_resized();\n    else\n\temsg(_(e_screen_mode_setting_not_supported));\n}\n\n/*\n * \":resize\".\n * set, increment or decrement current window height\n */\n    static void\nex_resize(exarg_T *eap)\n{\n    int\t\tn;\n    win_T\t*wp = curwin;\n\n    if (eap->addr_count > 0)\n    {\n\tn = eap->line2;\n\tfor (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)\n\t    ;\n    }\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    n = atol((char *)eap->arg);\n    if (cmdmod.cmod_split & WSP_VERT)\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_width;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very wide\n\t    n = 9999;\n\twin_setwidth_win(n, wp);\n    }\n    else\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_height;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very high\n\t    n = 9999;\n\twin_setheight_win(n, wp);\n    }\n}\n\n/*\n * \":find [+command] <file>\" command.\n */\n    static void\nex_find(exarg_T *eap)\n{\n#ifdef FEAT_SEARCHPATH\n    char_u\t*fname;\n    int\t\tcount;\n\n    fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg), FNAME_MESS,\n\t\t\t\t\t\t      TRUE, curbuf->b_ffname);\n    if (eap->addr_count > 0)\n    {\n\t// Repeat finding the file \"count\" times.  This matters when it\n\t// appears several times in the path.\n\tcount = eap->line2;\n\twhile (fname != NULL && --count > 0)\n\t{\n\t    vim_free(fname);\n\t    fname = find_file_in_path(NULL, 0, FNAME_MESS,\n\t\t\t\t\t\t     FALSE, curbuf->b_ffname);\n\t}\n    }\n\n    if (fname != NULL)\n    {\n\teap->arg = fname;\n#endif\n\tdo_exedit(eap, NULL);\n#ifdef FEAT_SEARCHPATH\n\tvim_free(fname);\n    }\n#endif\n}\n\n/*\n * \":open\" simulation: for now just work like \":visual\".\n */\n    static void\nex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    // make a copy of the line, when searching for a mark it might be\n\t    // flushed\n\t    char_u *line = vim_strsave(ml_get_curline());\n\n\t    regmatch.rm_ic = p_ic;\n\t    if (vim_regexec(&regmatch, line, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - line);\n\t    else\n\t\temsg(_(e_no_match));\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(line);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit\", \":badd\", \":balt\", \":visual\".\n */\n    static void\nex_edit(exarg_T *eap)\n{\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit <file>\" command and alike.\n */\n    void\ndo_exedit(\n    exarg_T\t*eap,\n    win_T\t*old_curwin)\t    // curwin before doing a split or NULL\n{\n    int\t\tn;\n    int\t\tneed_hide;\n    int\t\texmode_was = exmode_active;\n\n    if ((eap->cmdidx != CMD_pedit && ERROR_IF_POPUP_WINDOW)\n\t\t\t\t\t\t || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n    /*\n     * \":vi\" command ends Ex mode.\n     */\n    if (exmode_active && (eap->cmdidx == CMD_visual\n\t\t\t\t\t\t|| eap->cmdidx == CMD_view))\n    {\n\texmode_active = FALSE;\n\tex_pressedreturn = FALSE;\n\tif (*eap->arg == NUL)\n\t{\n\t    // Special case:  \":global/pat/visual\\NLvi-commands\"\n\t    if (global_busy)\n\t    {\n\t\tint\trd = RedrawingDisabled;\n\t\tint\tnwr = no_wait_return;\n\t\tint\tms = msg_scroll;\n#ifdef FEAT_GUI\n\t\tint\the = hold_gui_events;\n#endif\n\n\t\tif (eap->nextcmd != NULL)\n\t\t{\n\t\t    stuffReadbuff(eap->nextcmd);\n\t\t    eap->nextcmd = NULL;\n\t\t}\n\n\t\tif (exmode_was != EXMODE_VIM)\n\t\t    settmode(TMODE_RAW);\n\t\tRedrawingDisabled = 0;\n\t\tno_wait_return = 0;\n\t\tneed_wait_return = FALSE;\n\t\tmsg_scroll = 0;\n#ifdef FEAT_GUI\n\t\thold_gui_events = 0;\n#endif\n\t\tmust_redraw = CLEAR;\n\t\tpending_exmode_active = TRUE;\n\n\t\tmain_loop(FALSE, TRUE);\n\n\t\tpending_exmode_active = FALSE;\n\t\tRedrawingDisabled = rd;\n\t\tno_wait_return = nwr;\n\t\tmsg_scroll = ms;\n#ifdef FEAT_GUI\n\t\thold_gui_events = he;\n#endif\n\t    }\n\t    return;\n\t}\n    }\n\n    if ((eap->cmdidx == CMD_new\n\t\t|| eap->cmdidx == CMD_tabnew\n\t\t|| eap->cmdidx == CMD_tabedit\n\t\t|| eap->cmdidx == CMD_vnew) && *eap->arg == NUL)\n    {\n\t// \":new\" or \":tabnew\" without argument: edit a new empty buffer\n\tsetpcmark();\n\t(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,\n\t\t      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),\n\t\t      old_curwin == NULL ? curwin : NULL);\n    }\n    else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)\n\t    || *eap->arg != NUL\n#ifdef FEAT_BROWSE\n\t    || (cmdmod.cmod_flags & CMOD_BROWSE)\n#endif\n\t    )\n    {\n\t// Can't edit another file when \"textlock\" or \"curbuf_lock\" is set.\n\t// Only \":edit\" or \":script\" can bring us here, others are stopped\n\t// earlier.\n\tif (*eap->arg != NUL && text_or_buf_locked())\n\t    return;\n\n\tn = readonlymode;\n\tif (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)\n\t    readonlymode = TRUE;\n\telse if (eap->cmdidx == CMD_enew)\n\t    readonlymode = FALSE;   // 'readonly' doesn't make sense in an\n\t\t\t\t    // empty buffer\n\tif (eap->cmdidx != CMD_balt && eap->cmdidx != CMD_badd)\n\t    setpcmark();\n\tif (do_ecmd(0, (eap->cmdidx == CMD_enew ? NULL : eap->arg),\n\t\t    NULL, eap,\n\t\t    // \":edit\" goes to first line if Vi compatible\n\t\t    (*eap->arg == NUL && eap->do_ecmd_lnum == 0\n\t\t\t\t      && vim_strchr(p_cpo, CPO_GOTO1) != NULL)\n\t\t\t\t\t       ? ECMD_ONE : eap->do_ecmd_lnum,\n\t\t    (buf_hide(curbuf) ? ECMD_HIDE : 0)\n\t\t    + (eap->forceit ? ECMD_FORCEIT : 0)\n\t\t      // after a split we can use an existing buffer\n\t\t    + (old_curwin != NULL ? ECMD_OLDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_balt ? ECMD_ALTBUF : 0)\n\t\t    , old_curwin == NULL ? curwin : NULL) == FAIL)\n\t{\n\t    // Editing the file failed.  If the window was split, close it.\n\t    if (old_curwin != NULL)\n\t    {\n\t\tneed_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);\n\t\tif (!need_hide || buf_hide(curbuf))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    cleanup_T   cs;\n\n\t\t    // Reset the error/interrupt/exception state here so that\n\t\t    // aborting() returns FALSE when closing a window.\n\t\t    enter_cleanup(&cs);\n#endif\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_close(curwin, !need_hide && !buf_hide(curbuf));\n\n#if defined(FEAT_EVAL)\n\t\t    // Restore the error/interrupt/exception state if not\n\t\t    // discarded by a new aborting error, interrupt, or\n\t\t    // uncaught exception.\n\t\t    leave_cleanup(&cs);\n#endif\n\t\t}\n\t    }\n\t}\n\telse if (readonlymode && curbuf->b_nwindows == 1)\n\t{\n\t    // When editing an already visited buffer, 'readonly' won't be set\n\t    // but the previous value is kept.  With \":view\" and \":sview\" we\n\t    // want the  file to be readonly, except when another window is\n\t    // editing the same buffer.\n\t    curbuf->b_p_ro = TRUE;\n\t}\n\treadonlymode = n;\n    }\n    else\n    {\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n\tn = curwin->w_arg_idx_invalid;\n\tcheck_arg_idx(curwin);\n\tif (n != curwin->w_arg_idx_invalid)\n\t    maketitle();\n    }\n\n    /*\n     * if \":split file\" worked, set alternate file name in old window to new\n     * file\n     */\n    if (old_curwin != NULL\n\t    && *eap->arg != NUL\n\t    && curwin != old_curwin\n\t    && win_valid(old_curwin)\n\t    && old_curwin->w_buffer != curbuf\n\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\n    ex_no_reprint = TRUE;\n}\n\n#ifndef FEAT_GUI\n/*\n * \":gui\" and \":gvim\" when there is no GUI.\n */\n    static void\nex_nogui(exarg_T *eap)\n{\n    eap->errmsg = _(e_gui_cannot_be_used_not_enabled_at_compile_time);\n}\n#endif\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n    static void\nex_tearoff(exarg_T *eap)\n{\n    gui_make_tearoff(eap->arg);\n}\n#endif\n\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\n    static void\nex_popup(exarg_T *eap)\n{\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)\n    if (gui.in_use)\n\tgui_make_popup(eap->arg, eap->forceit);\n#  ifdef FEAT_TERM_POPUP_MENU\n    else\n#  endif\n# endif\n# ifdef FEAT_TERM_POPUP_MENU\n\tpum_make_popup(eap->arg, eap->forceit);\n# endif\n}\n#endif\n\n    static void\nex_swapname(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)\n\tmsg(_(\"No swap file\"));\n    else\n\tmsg((char *)curbuf->b_ml.ml_mfp->mf_fname);\n}\n\n/*\n * \":syncbind\" forces all 'scrollbind' windows to have the same relative\n * offset.\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    static void\nex_syncbind(exarg_T *eap UNUSED)\n{\n    win_T\t*wp;\n    win_T\t*save_curwin = curwin;\n    buf_T\t*save_curbuf = curbuf;\n    long\ttopline;\n    long\ty;\n    linenr_T\told_linenr = curwin->w_cursor.lnum;\n\n    setpcmark();\n\n    /*\n     * determine max topline\n     */\n    if (curwin->w_p_scb)\n    {\n\ttopline = curwin->w_topline;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_p_scb && wp->w_buffer)\n\t    {\n\t\ty = wp->w_buffer->b_ml.ml_line_count - get_scrolloff_value();\n\t\tif (topline > y)\n\t\t    topline = y;\n\t    }\n\t}\n\tif (topline < 1)\n\t    topline = 1;\n    }\n    else\n    {\n\ttopline = 1;\n    }\n\n\n    /*\n     * Set all scrollbind windows to the same topline.\n     */\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    curbuf = curwin->w_buffer;\n\t    y = topline - curwin->w_topline;\n\t    if (y > 0)\n\t\tscrollup(y, TRUE);\n\t    else\n\t\tscrolldown(-y, TRUE);\n\t    curwin->w_scbind_pos = topline;\n\t    redraw_later(VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n    curwin = save_curwin;\n    curbuf = save_curbuf;\n    if (curwin->w_p_scb)\n    {\n\tdid_syncbind = TRUE;\n\tcheckpcmark();\n\tif (old_linenr != curwin->w_cursor.lnum)\n\t{\n\t    char_u ctrl_o[2];\n\n\t    ctrl_o[0] = Ctrl_O;\n\t    ctrl_o[1] = 0;\n\t    ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);\n\t}\n    }\n}\n\n\n    static void\nex_read(exarg_T *eap)\n{\n    int\t\ti;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n    linenr_T\tlnum;\n\n    if (eap->usefilter)\t\t\t// :r!cmd\n\tdo_bang(1, eap, FALSE, FALSE, TRUE);\n    else\n    {\n\tif (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL)\n\t    return;\n\n#ifdef FEAT_BROWSE\n\tif (cmdmod.cmod_flags & CMOD_BROWSE)\n\t{\n\t    char_u *browseFile;\n\n\t    browseFile = do_browse(0, (char_u *)_(\"Append File\"), eap->arg,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t    if (browseFile != NULL)\n\t    {\n\t\ti = readfile(browseFile, NULL,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t\tvim_free(browseFile);\n\t    }\n\t    else\n\t\ti = OK;\n\t}\n\telse\n#endif\n\t     if (*eap->arg == NUL)\n\t{\n\t    if (check_fname() == FAIL)\t// check for no file name\n\t\treturn;\n\t    i = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t}\n\telse\n\t{\n\t    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)\n\t\t(void)setaltfname(eap->arg, eap->arg, (linenr_T)1);\n\t    i = readfile(eap->arg, NULL,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\n\t}\n\tif (i != OK)\n\t{\n#if defined(FEAT_EVAL)\n\t    if (!aborting())\n#endif\n\t\tsemsg(_(e_cant_open_file_str), eap->arg);\n\t}\n\telse\n\t{\n\t    if (empty && exmode_active)\n\t    {\n\t\t// Delete the empty line that remains.  Historically ex does\n\t\t// this but vi doesn't.\n\t\tif (eap->line2 == 0)\n\t\t    lnum = curbuf->b_ml.ml_line_count;\n\t\telse\n\t\t    lnum = 1;\n\t\tif (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)\n\t\t{\n\t\t    ml_delete(lnum);\n\t\t    if (curwin->w_cursor.lnum > 1\n\t\t\t\t\t     && curwin->w_cursor.lnum >= lnum)\n\t\t\t--curwin->w_cursor.lnum;\n\t\t    deleted_lines_mark(lnum, 1L);\n\t\t}\n\t    }\n\t    redraw_curbuf_later(VALID);\n\t}\n    }\n}\n\nstatic char_u\t*prev_dir = NULL;\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_cd_dir(void)\n{\n    VIM_CLEAR(prev_dir);\n    VIM_CLEAR(globaldir);\n}\n#endif\n\n/*\n * Get the previous directory for the given chdir scope.\n */\n    static char_u *\nget_prevdir(cdscope_T scope)\n{\n    if (scope == CDSCOPE_WINDOW)\n\treturn curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\treturn curtab->tp_prevdir;\n    return prev_dir;\n}\n\n/*\n * Deal with the side effects of changing the current directory.\n * When 'scope' is CDSCOPE_TABPAGE then this was after an \":tcd\" command.\n * When 'scope' is CDSCOPE_WINDOW then this was after an \":lcd\" command.\n */\n    void\npost_chdir(cdscope_T scope)\n{\n    if (scope != CDSCOPE_WINDOW)\n\t// Clear tab local directory for both :cd and :tcd\n\tVIM_CLEAR(curtab->tp_localdir);\n    VIM_CLEAR(curwin->w_localdir);\n    if (scope != CDSCOPE_GLOBAL)\n    {\n\tchar_u\t*pdir = get_prevdir(scope);\n\n\t// If still in the global directory, need to remember current\n\t// directory as the global directory.\n\tif (globaldir == NULL && pdir != NULL)\n\t    globaldir = vim_strsave(pdir);\n\n\t// Remember this local directory for the window.\n\tif (mch_dirname(NameBuff, MAXPATHL) == OK)\n\t{\n\t    if (scope == CDSCOPE_TABPAGE)\n\t\tcurtab->tp_localdir = vim_strsave(NameBuff);\n\t    else\n\t\tcurwin->w_localdir = vim_strsave(NameBuff);\n\t}\n    }\n    else\n    {\n\t// We are now in the global directory, no need to remember its name.\n\tVIM_CLEAR(globaldir);\n    }\n\n    last_chdir_reason = NULL;\n    shorten_fnames(TRUE);\n}\n\n/*\n * Trigger DirChangedPre for \"acmd_fname\" with directory \"new_dir\".\n */\n    void\ntrigger_DirChangedPre(char_u *acmd_fname, char_u *new_dir)\n{\n#ifdef FEAT_EVAL\n    dict_T\t    *v_event;\n    save_v_event_T  save_v_event;\n\n    v_event = get_v_event(&save_v_event);\n    (void)dict_add_string(v_event, \"directory\", new_dir);\n    dict_set_items_ro(v_event);\n#endif\n    apply_autocmds(EVENT_DIRCHANGEDPRE, acmd_fname, new_dir, FALSE, curbuf);\n#ifdef FEAT_EVAL\n    restore_v_event(v_event, &save_v_event);\n#endif\n}\n\n/*\n * Change directory function used by :cd/:tcd/:lcd Ex commands and the\n * chdir() function.\n * scope == CDSCOPE_WINDOW: changes the window-local directory\n * scope == CDSCOPE_TABPAGE: changes the tab-local directory\n * Otherwise: changes the global directory\n * Returns TRUE if the directory is successfully changed.\n */\n    int\nchangedir_func(\n\tchar_u\t\t*new_dir,\n\tint\t\tforceit,\n\tcdscope_T\tscope)\n{\n    char_u\t*pdir = NULL;\n    int\t\tdir_differs;\n    char_u\t*acmd_fname = NULL;\n    char_u\t**pp;\n    char_u\t*tofree;\n\n    if (new_dir == NULL || allbuf_locked())\n\treturn FALSE;\n\n    if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged() && !forceit)\n    {\n\temsg(_(e_cannot_change_directory_buffer_is_modified_add_bang_to_override));\n\treturn FALSE;\n    }\n\n    // \":cd -\": Change to previous directory\n    if (STRCMP(new_dir, \"-\") == 0)\n    {\n\tpdir = get_prevdir(scope);\n\tif (pdir == NULL)\n\t{\n\t    emsg(_(e_no_previous_directory));\n\t    return FALSE;\n\t}\n\tnew_dir = pdir;\n    }\n\n    // Save current directory for next \":cd -\"\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n\tpdir = vim_strsave(NameBuff);\n    else\n\tpdir = NULL;\n\n    // For UNIX \":cd\" means: go to home directory.\n    // On other systems too if 'cdhome' is set.\n#if defined(UNIX) || defined(VMS)\n    if (*new_dir == NUL)\n#else\n    if (*new_dir == NUL && p_cdh)\n#endif\n    {\n\t// use NameBuff for home directory name\n# ifdef VMS\n\tchar_u\t*p;\n\n\tp = mch_getenv((char_u *)\"SYS$LOGIN\");\n\tif (p == NULL || *p == NUL)\t// empty is the same as not set\n\t    NameBuff[0] = NUL;\n\telse\n\t    vim_strncpy(NameBuff, p, MAXPATHL - 1);\n# else\n\texpand_env((char_u *)\"$HOME\", NameBuff, MAXPATHL);\n# endif\n\tnew_dir = NameBuff;\n    }\n    dir_differs = pdir == NULL\n\t\t\t    || pathcmp((char *)pdir, (char *)new_dir, -1) != 0;\n    if (dir_differs)\n    {\n\tif (scope == CDSCOPE_WINDOW)\n\t    acmd_fname = (char_u *)\"window\";\n\telse if (scope == CDSCOPE_TABPAGE)\n\t    acmd_fname = (char_u *)\"tabpage\";\n\telse\n\t    acmd_fname = (char_u *)\"global\";\n\ttrigger_DirChangedPre(acmd_fname, new_dir);\n\n\tif (vim_chdir(new_dir))\n\t{\n\t    emsg(_(e_command_failed));\n\t    vim_free(pdir);\n\t    return FALSE;\n\t}\n    }\n\n    if (scope == CDSCOPE_WINDOW)\n\tpp = &curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\tpp = &curtab->tp_prevdir;\n    else\n\tpp = &prev_dir;\n    tofree = *pp;  // new_dir may use this\n    *pp = pdir;\n\n    post_chdir(scope);\n\n    if (dir_differs)\n\tapply_autocmds(EVENT_DIRCHANGED, acmd_fname, new_dir, FALSE, curbuf);\n    vim_free(tofree);\n    return TRUE;\n}\n\n/*\n * \":cd\", \":tcd\", \":lcd\", \":chdir\" \":tchdir\" and \":lchdir\".\n */\n    void\nex_cd(exarg_T *eap)\n{\n    char_u\t*new_dir;\n\n    new_dir = eap->arg;\n#if !defined(UNIX) && !defined(VMS)\n    // for non-UNIX \":cd\" means: print current directory unless 'cdhome' is set\n    if (*new_dir == NUL && !p_cdh)\n\tex_pwd(NULL);\n    else\n#endif\n    {\n\tcdscope_T\tscope = CDSCOPE_GLOBAL;\n\n\tif (eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir)\n\t    scope = CDSCOPE_WINDOW;\n\telse if (eap->cmdidx == CMD_tcd || eap->cmdidx == CMD_tchdir)\n\t    scope = CDSCOPE_TABPAGE;\n\n\tif (changedir_func(new_dir, eap->forceit, scope))\n\t{\n\t    // Echo the new current directory if the command was typed.\n\t    if (KeyTyped || p_verbose >= 5)\n\t\tex_pwd(eap);\n\t}\n    }\n}\n\n/*\n * \":pwd\".\n */\n    static void\nex_pwd(exarg_T *eap UNUSED)\n{\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n    {\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(NameBuff);\n#endif\n\tif (p_verbose > 0)\n\t{\n\t    char *context = \"global\";\n\n\t    if (last_chdir_reason != NULL)\n\t\tcontext = last_chdir_reason;\n\t    else if (curwin->w_localdir != NULL)\n\t\tcontext = \"window\";\n\t    else if (curtab->tp_localdir != NULL)\n\t\tcontext = \"tabpage\";\n\t    smsg(\"[%s] %s\", context, (char *)NameBuff);\n\t}\n\telse\n\t    msg((char *)NameBuff);\n    }\n    else\n\temsg(_(e_directory_unknown));\n}\n\n/*\n * \":=\".\n */\n    static void\nex_equal(exarg_T *eap)\n{\n    smsg(\"%ld\", (long)eap->line2);\n    ex_may_print(eap);\n}\n\n    static void\nex_sleep(exarg_T *eap)\n{\n    int\t\tn;\n    long\tlen;\n\n    if (cursor_valid())\n    {\n\tn = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;\n\tif (n >= 0)\n\t    windgoto(n, curwin->w_wincol + curwin->w_wcol);\n    }\n\n    len = eap->line2;\n    switch (*eap->arg)\n    {\n\tcase 'm': break;\n\tcase NUL: len *= 1000L; break;\n\tdefault: semsg(_(e_invalid_argument_str), eap->arg); return;\n    }\n\n    // Hide the cursor if invoked with !\n    do_sleep(len, eap->forceit);\n}\n\n/*\n * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second.\n * Hide the cursor if \"hide_cursor\" is TRUE.\n */\n    void\ndo_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n\n    // Remember at what time we started, so that we know how much longer we\n    // should wait after waiting for a bit.\n    ELAPSED_INIT(start_tv);\n# endif\n\n    if (hide_cursor)\n\tcursor_sleep();\n    else\n\tcursor_on();\n\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\t// Process the netbeans and clientserver messages that may have been\n\t// received in the call to ui_breakcheck() when the GUI is in use. This\n\t// may occur when running a test case.\n\tparse_queued_messages();\n#endif\n\n# ifdef ELAPSED_FUNC\n\t// actual time passed\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\t// guestimate time passed (will actually be more)\n\tdone += wait_now;\n# endif\n    }\n\n    // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the\n    // input buffer, otherwise a following call to input() fails.\n    if (got_int)\n\t(void)vpeekc();\n\n    if (hide_cursor)\n\tcursor_unsleep();\n}\n\n/*\n * \":winsize\" command (obsolete).\n */\n    static void\nex_winsize(exarg_T *eap)\n{\n    int\t\tw, h;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (!isdigit(*arg))\n    {\n\tsemsg(_(e_invalid_argument_str), arg);\n\treturn;\n    }\n    w = getdigits(&arg);\n    arg = skipwhite(arg);\n    p = arg;\n    h = getdigits(&arg);\n    if (*p != NUL && *arg == NUL)\n\tset_shellsize(w, h, TRUE);\n    else\n\temsg(_(e_winsize_requires_two_number_arguments));\n}\n\n    static void\nex_wincmd(exarg_T *eap)\n{\n    int\t\txchar = NUL;\n    char_u\t*p;\n\n    if (*eap->arg == 'g' || *eap->arg == Ctrl_G)\n    {\n\t// CTRL-W g and CTRL-W CTRL-G  have an extra command character\n\tif (eap->arg[1] == NUL)\n\t{\n\t    emsg(_(e_invalid_argument));\n\t    return;\n\t}\n\txchar = eap->arg[1];\n\tp = eap->arg + 2;\n    }\n    else\n\tp = eap->arg + 1;\n\n    set_nextcmd(eap, p);\n    p = skipwhite(p);\n    if (*p != NUL && *p != (\n#ifdef FEAT_EVAL\n\t    in_vim9script() ? '#' :\n#endif\n\t\t'\"')\n\t    && eap->nextcmd == NULL)\n\temsg(_(e_invalid_argument));\n    else if (!eap->skip)\n    {\n\t// Pass flags on for \":vertical wincmd ]\".\n\tpostponed_split_flags = cmdmod.cmod_split;\n\tpostponed_split_tab = cmdmod.cmod_tab;\n\tdo_window(*eap->arg, eap->addr_count > 0 ? eap->line2 : 0L, xchar);\n\tpostponed_split_flags = 0;\n\tpostponed_split_tab = 0;\n    }\n}\n\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\n/*\n * \":winpos\".\n */\n    static void\nex_winpos(exarg_T *eap)\n{\n    int\t\tx, y;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (*arg == NUL)\n    {\n# if defined(FEAT_GUI) || defined(MSWIN)\n#  ifdef VIMDLL\n\tif (gui.in_use ? gui_mch_get_winpos(&x, &y) != FAIL :\n\t\tmch_get_winpos(&x, &y) != FAIL)\n#  elif defined(FEAT_GUI)\n\tif (gui.in_use && gui_mch_get_winpos(&x, &y) != FAIL)\n#  else\n\tif (mch_get_winpos(&x, &y) != FAIL)\n#  endif\n\t{\n\t    sprintf((char *)IObuff, _(\"Window position: X %d, Y %d\"), x, y);\n\t    msg((char *)IObuff);\n\t}\n\telse\n# endif\n\t    emsg(_(e_obtaining_window_position_not_implemented_for_this_platform));\n    }\n    else\n    {\n\tx = getdigits(&arg);\n\targ = skipwhite(arg);\n\tp = arg;\n\ty = getdigits(&arg);\n\tif (*p == NUL || *arg != NUL)\n\t{\n\t    emsg(_(e_winpos_requires_two_number_arguments));\n\t    return;\n\t}\n# ifdef FEAT_GUI\n\tif (gui.in_use)\n\t    gui_mch_set_winpos(x, y);\n\telse if (gui.starting)\n\t{\n\t    // Remember the coordinates for when the window is opened.\n\t    gui_win_x = x;\n\t    gui_win_y = y;\n\t}\n#  if defined(HAVE_TGETENT) || defined(VIMDLL)\n\telse\n#  endif\n# endif\n# if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    mch_set_winpos(x, y);\n# endif\n# ifdef HAVE_TGETENT\n\tif (*T_CWP)\n\t    term_set_winpos(x, y);\n# endif\n    }\n}\n#endif\n\n/*\n * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\".\n */\n    static void\nex_operators(exarg_T *eap)\n{\n    oparg_T\toa;\n\n    clear_oparg(&oa);\n    oa.regname = eap->regname;\n    oa.start.lnum = eap->line1;\n    oa.end.lnum = eap->line2;\n    oa.line_count = eap->line2 - eap->line1 + 1;\n    oa.motion_type = MLINE;\n    virtual_op = FALSE;\n    if (eap->cmdidx != CMD_yank)\t// position cursor for undo\n    {\n\tsetpcmark();\n\tcurwin->w_cursor.lnum = eap->line1;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    if (VIsual_active)\n\tend_visual_mode();\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_delete:\n\t    oa.op_type = OP_DELETE;\n\t    op_delete(&oa);\n\t    break;\n\n\tcase CMD_yank:\n\t    oa.op_type = OP_YANK;\n\t    (void)op_yank(&oa, FALSE, TRUE);\n\t    break;\n\n\tdefault:    // CMD_rshift or CMD_lshift\n\t    if (\n#ifdef FEAT_RIGHTLEFT\n\t\t(eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl\n#else\n\t\teap->cmdidx == CMD_rshift\n#endif\n\t\t\t\t\t\t)\n\t\toa.op_type = OP_RSHIFT;\n\t    else\n\t\toa.op_type = OP_LSHIFT;\n\t    op_shift(&oa, FALSE, eap->amount);\n\t    break;\n    }\n    virtual_op = MAYBE;\n    ex_may_print(eap);\n}\n\n/*\n * \":put\".\n */\n    static void\nex_put(exarg_T *eap)\n{\n    // \":0put\" works like \":1put!\".\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}\n\n/*\n * Handle \":copy\" and \":move\".\n */\n    static void\nex_copymove(exarg_T *eap)\n{\n    long\tn;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    n = get_address(eap, &eap->arg, eap->addr_type, FALSE, FALSE, FALSE, 1);\n    if (eap->arg == NULL)\t    // error detected\n    {\n\teap->nextcmd = NULL;\n\treturn;\n    }\n    get_flags(eap);\n\n    /*\n     * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'\n     */\n    if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_move)\n    {\n\tif (do_move(eap->line1, eap->line2, n) == FAIL)\n\t    return;\n    }\n    else\n\tex_copy(eap->line1, eap->line2, n);\n    u_clearline();\n    beginline(BL_SOL | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * Print the current line if flags were given to the Ex command.\n */\n    void\nex_may_print(exarg_T *eap)\n{\n    if (eap->flags != 0)\n    {\n\tprint_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),\n\t\t\t\t\t\t  (eap->flags & EXFLAG_LIST));\n\tex_no_reprint = TRUE;\n    }\n}\n\n/*\n * \":smagic\" and \":snomagic\".\n */\n    static void\nex_submagic(exarg_T *eap)\n{\n    optmagic_T saved = magic_overruled;\n\n    magic_overruled = eap->cmdidx == CMD_smagic\n\t\t\t\t\t  ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;\n    ex_substitute(eap);\n    magic_overruled = saved;\n}\n\n/*\n * \":join\".\n */\n    static void\nex_join(exarg_T *eap)\n{\n    curwin->w_cursor.lnum = eap->line1;\n    if (eap->line1 == eap->line2)\n    {\n\tif (eap->addr_count >= 2)   // :2,2join does nothing\n\t    return;\n\tif (eap->line2 == curbuf->b_ml.ml_line_count)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\t++eap->line2;\n    }\n    (void)do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, TRUE);\n    beginline(BL_WHITE | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * \":[addr]@r\" or \":[addr]*r\": execute register\n */\n    static void\nex_at(exarg_T *eap)\n{\n    int\t\tc;\n    int\t\tprev_len = typebuf.tb_len;\n\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // get the register name.  No name means to use the previous one\n    c = *eap->arg;\n    if (c == NUL || (c == '*' && *eap->cmd == '*'))\n\tc = '@';\n    // Put the register in the typeahead buffer with the \"silent\" flag.\n    if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)\n\t\t\t\t\t\t\t\t      == FAIL)\n    {\n\tbeep_flush();\n    }\n    else\n    {\n\tint\tsave_efr = exec_from_reg;\n\n\texec_from_reg = TRUE;\n\n\t/*\n\t * Execute from the typeahead buffer.\n\t * Continue until the stuff buffer is empty and all added characters\n\t * have been consumed.\n\t */\n\twhile (!stuff_empty() || typebuf.tb_len > prev_len)\n\t    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\n\texec_from_reg = save_efr;\n    }\n}\n\n/*\n * \":!\".\n */\n    static void\nex_bang(exarg_T *eap)\n{\n    do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);\n}\n\n/*\n * \":undo\".\n */\n    static void\nex_undo(exarg_T *eap)\n{\n    if (eap->addr_count == 1)\t    // :undo 123\n\tundo_time(eap->line2, FALSE, FALSE, TRUE);\n    else\n\tu_undo(1);\n}\n\n#ifdef FEAT_PERSISTENT_UNDO\n    static void\nex_wundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_write_undo(eap->arg, eap->forceit, curbuf, hash);\n}\n\n    static void\nex_rundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_read_undo(eap->arg, hash, NULL);\n}\n#endif\n\n/*\n * \":redo\".\n */\n    static void\nex_redo(exarg_T *eap UNUSED)\n{\n    u_redo(1);\n}\n\n/*\n * \":earlier\" and \":later\".\n */\n    static void\nex_later(exarg_T *eap)\n{\n    long\tcount = 0;\n    int\t\tsec = FALSE;\n    int\t\tfile = FALSE;\n    char_u\t*p = eap->arg;\n\n    if (*p == NUL)\n\tcount = 1;\n    else if (isdigit(*p))\n    {\n\tcount = getdigits(&p);\n\tswitch (*p)\n\t{\n\t    case 's': ++p; sec = TRUE; break;\n\t    case 'm': ++p; sec = TRUE; count *= 60; break;\n\t    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;\n\t    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;\n\t    case 'f': ++p; file = TRUE; break;\n\t}\n    }\n\n    if (*p != NUL)\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n    else\n\tundo_time(eap->cmdidx == CMD_earlier ? -count : count,\n\t\t\t\t\t\t\t    sec, file, FALSE);\n}\n\n/*\n * \":redir\": start/stop redirection.\n */\n    static void\nex_redir(exarg_T *eap)\n{\n    char\t*mode;\n    char_u\t*fname;\n    char_u\t*arg = eap->arg;\n\n#ifdef FEAT_EVAL\n    if (redir_execute)\n    {\n\temsg(_(e_cannot_use_redir_inside_execute));\n\treturn;\n    }\n#endif\n\n    if (STRICMP(eap->arg, \"END\") == 0)\n\tclose_redir();\n    else\n    {\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tmode = \"a\";\n\t    }\n\t    else\n\t\tmode = \"w\";\n\t    arg = skipwhite(arg);\n\n\t    close_redir();\n\n\t    // Expand environment variables and \"~/\".\n\t    fname = expand_env_save(arg);\n\t    if (fname == NULL)\n\t\treturn;\n#ifdef FEAT_BROWSE\n\t    if (cmdmod.cmod_flags & CMOD_BROWSE)\n\t    {\n\t\tchar_u\t*browseFile;\n\n\t\tbrowseFile = do_browse(BROWSE_SAVE,\n\t\t\t(char_u *)_(\"Save Redirection\"),\n\t\t\tfname, NULL, NULL,\n\t\t\t(char_u *)_(BROWSE_FILTER_ALL_FILES), curbuf);\n\t\tif (browseFile == NULL)\n\t\t    return;\t\t// operation cancelled\n\t\tvim_free(fname);\n\t\tfname = browseFile;\n\t\teap->forceit = TRUE;\t// since dialog already asked\n\t    }\n#endif\n\n\t    redir_fd = open_exfile(fname, eap->forceit, mode);\n\t    vim_free(fname);\n\t}\n#ifdef FEAT_EVAL\n\telse if (*arg == '@')\n\t{\n\t    // redirect to a register a-z (resp. A-Z for appending)\n\t    close_redir();\n\t    ++arg;\n\t    if (ASCII_ISALPHA(*arg)\n# ifdef FEAT_CLIPBOARD\n\t\t    || *arg == '*'\n\t\t    || *arg == '+'\n# endif\n\t\t    || *arg == '\"')\n\t    {\n\t\tredir_reg = *arg++;\n\t\tif (*arg == '>' && arg[1] == '>')  // append\n\t\t    arg += 2;\n\t\telse\n\t\t{\n\t\t    // Can use both \"@a\" and \"@a>\".\n\t\t    if (*arg == '>')\n\t\t\targ++;\n\t\t    // Make register empty when not using @A-@Z and the\n\t\t    // command is valid.\n\t\t    if (*arg == NUL && !isupper(redir_reg))\n\t\t\twrite_reg_contents(redir_reg, (char_u *)\"\", -1, FALSE);\n\t\t}\n\t    }\n\t    if (*arg != NUL)\n\t    {\n\t\tredir_reg = 0;\n\t\tsemsg(_(e_invalid_argument_str), eap->arg);\n\t    }\n\t}\n\telse if (*arg == '=' && arg[1] == '>')\n\t{\n\t    int append;\n\n\t    // redirect to a variable\n\t    close_redir();\n\t    arg += 2;\n\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tappend = TRUE;\n\t    }\n\t    else\n\t\tappend = FALSE;\n\n\t    if (var_redir_start(skipwhite(arg), append) == OK)\n\t\tredir_vname = 1;\n\t}\n#endif\n\n\t// TODO: redirect to a buffer\n\n\telse\n\t    semsg(_(e_invalid_argument_str), eap->arg);\n    }\n\n    // Make sure redirection is not off.  Can happen for cmdline completion\n    // that indirectly invokes a command to catch its output.\n    if (redir_fd != NULL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname\n#endif\n\t\t\t\t\t\t\t)\n\tredir_off = FALSE;\n}\n\n/*\n * \":redraw\": force redraw\n */\n    void\nex_redraw(exarg_T *eap)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    validate_cursor();\n    update_topline();\n    update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);\n    if (need_maketitle)\n\tmaketitle();\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = r;\n    p_lz = p;\n\n    // After drawing the statusline screen_attr may still be set.\n    screen_stop_highlight();\n\n    // Reset msg_didout, so that a message that's there is overwritten.\n    msg_didout = FALSE;\n    msg_col = 0;\n\n    // No need to wait after an intentional redraw.\n    need_wait_return = FALSE;\n\n    // When invoked from a callback or autocmd the command line may be active.\n    if (State & MODE_CMDLINE)\n\tredrawcmdline();\n\n    out_flush();\n}\n\n/*\n * \":redrawstatus\": force redraw of status line(s)\n */\n    static void\nex_redrawstatus(exarg_T *eap UNUSED)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    if (eap->forceit)\n\tstatus_redraw_all();\n    else\n\tstatus_redraw_curbuf();\n    update_screen(VIsual_active ? INVERTED : 0);\n    RedrawingDisabled = r;\n    p_lz = p;\n    out_flush();\n}\n\n/*\n * \":redrawtabline\": force redraw of the tabline\n */\n    static void\nex_redrawtabline(exarg_T *eap UNUSED)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n\n    draw_tabline();\n\n    RedrawingDisabled = r;\n    p_lz = p;\n    out_flush();\n}\n\n    static void\nclose_redir(void)\n{\n    if (redir_fd != NULL)\n    {\n\tfclose(redir_fd);\n\tredir_fd = NULL;\n    }\n#ifdef FEAT_EVAL\n    redir_reg = 0;\n    if (redir_vname)\n    {\n\tvar_redir_stop();\n\tredir_vname = 0;\n    }\n#endif\n}\n\n#if (defined(FEAT_SESSION) || defined(FEAT_EVAL)) || defined(PROTO)\n    int\nvim_mkdir_emsg(char_u *name, int prot UNUSED)\n{\n    if (vim_mkdir(name, prot) != 0)\n    {\n\tsemsg(_(e_cannot_create_directory_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Open a file for writing for an Ex command, with some checks.\n * Return file descriptor, or NULL on failure.\n */\n    FILE *\nopen_exfile(\n    char_u\t*fname,\n    int\t\tforceit,\n    char\t*mode)\t    // \"w\" for create new file or \"a\" for append\n{\n    FILE\t*fd;\n\n#ifdef UNIX\n    // with Unix it is possible to open a directory\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_str_is_directory), fname);\n\treturn NULL;\n    }\n#endif\n    if (!forceit && *mode != 'a' && vim_fexists(fname))\n    {\n\tsemsg(_(e_str_exists_add_bang_to_override), fname);\n\treturn NULL;\n    }\n\n    if ((fd = mch_fopen((char *)fname, mode)) == NULL)\n\tsemsg(_(e_cannot_open_str_for_writing_2), fname);\n\n    return fd;\n}\n\n/*\n * \":mark\" and \":k\".\n */\n    static void\nex_mark(exarg_T *eap)\n{\n    pos_T\tpos;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (*eap->arg == NUL)\t\t// No argument?\n\temsg(_(e_argument_required));\n    else if (eap->arg[1] != NUL)\t// more than one character?\n\tsemsg(_(e_trailing_characters_str), eap->arg);\n    else\n    {\n\tpos = curwin->w_cursor;\t\t// save curwin->w_cursor\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_WHITE | BL_FIX);\n\tif (setmark(*eap->arg) == FAIL)\t// set mark\n\t    emsg(_(e_argument_must_be_letter_or_forward_backward_quote));\n\tcurwin->w_cursor = pos;\t\t// restore curwin->w_cursor\n    }\n}\n\n/*\n * Update w_topline, w_leftcol and the cursor position.\n */\n    void\nupdate_topline_cursor(void)\n{\n    check_cursor();\t\t// put cursor on valid line\n    update_topline();\n    if (!curwin->w_p_wrap)\n\tvalidate_cursor();\n    update_curswant();\n}\n\n/*\n * Save the current State and go to Normal mode.\n * Return TRUE if the typeahead could be saved.\n */\n    int\nsave_current_state(save_state_T *sst)\n{\n    sst->save_msg_scroll = msg_scroll;\n    sst->save_restart_edit = restart_edit;\n    sst->save_msg_didout = msg_didout;\n    sst->save_State = State;\n    sst->save_insertmode = p_im;\n    sst->save_finish_op = finish_op;\n    sst->save_opcount = opcount;\n    sst->save_reg_executing = reg_executing;\n    sst->save_pending_end_reg_executing = pending_end_reg_executing;\n\n    msg_scroll = FALSE;\t\t    // no msg scrolling in Normal mode\n    restart_edit = 0;\t\t    // don't go to Insert mode\n    p_im = FALSE;\t\t    // don't use 'insertmode'\n\n    sst->save_script_version = current_sctx.sc_version;\n    current_sctx.sc_version = 1;    // not in Vim9 script\n\n    /*\n     * Save the current typeahead.  This is required to allow using \":normal\"\n     * from an event handler and makes sure we don't hang when the argument\n     * ends with half a command.\n     */\n    save_typeahead(&sst->tabuf);\n    return sst->tabuf.typebuf_valid;\n}\n\n    void\nrestore_current_state(save_state_T *sst)\n{\n    // Restore the previous typeahead.\n    restore_typeahead(&sst->tabuf, FALSE);\n\n    msg_scroll = sst->save_msg_scroll;\n    restart_edit = sst->save_restart_edit;\n    p_im = sst->save_insertmode;\n    finish_op = sst->save_finish_op;\n    opcount = sst->save_opcount;\n    reg_executing = sst->save_reg_executing;\n    pending_end_reg_executing = sst->save_pending_end_reg_executing;\n    msg_didout |= sst->save_msg_didout;\t// don't reset msg_didout now\n    current_sctx.sc_version = sst->save_script_version;\n\n    // Restore the state (needed when called from a function executed for\n    // 'indentexpr'). Update the mouse and cursor, they may have changed.\n    State = sst->save_State;\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * \":normal[!] {commands}\": Execute normal mode commands.\n */\n    void\nex_normal(exarg_T *eap)\n{\n    save_state_T save_state;\n    char_u\t*arg = NULL;\n    int\t\tl;\n    char_u\t*p;\n\n    if (ex_normal_lock > 0)\n    {\n\temsg(_(e_not_allowed_here));\n\treturn;\n    }\n    if (ex_normal_busy >= p_mmd)\n    {\n\temsg(_(e_recursive_use_of_normal_too_deep));\n\treturn;\n    }\n\n    /*\n     * vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do\n     * this for the K_SPECIAL leading byte, otherwise special keys will not\n     * work.\n     */\n    if (has_mbyte)\n    {\n\tint\tlen = 0;\n\n\t// Count the number of characters to be escaped.\n\tfor (p = eap->arg; *p != NUL; ++p)\n\t{\n#ifdef FEAT_GUI\n\t    if (*p == CSI)  // leadbyte CSI\n\t\tlen += 2;\n#endif\n\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\tif (*++p == K_SPECIAL\t  // trailbyte K_SPECIAL or CSI\n#ifdef FEAT_GUI\n\t\t\t|| *p == CSI\n#endif\n\t\t\t)\n\t\t    len += 2;\n\t}\n\tif (len > 0)\n\t{\n\t    arg = alloc(STRLEN(eap->arg) + len + 1);\n\t    if (arg != NULL)\n\t    {\n\t\tlen = 0;\n\t\tfor (p = eap->arg; *p != NUL; ++p)\n\t\t{\n\t\t    arg[len++] = *p;\n#ifdef FEAT_GUI\n\t\t    if (*p == CSI)\n\t\t    {\n\t\t\targ[len++] = KS_EXTRA;\n\t\t\targ[len++] = (int)KE_CSI;\n\t\t    }\n#endif\n\t\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\t    {\n\t\t\targ[len++] = *++p;\n\t\t\tif (*p == K_SPECIAL)\n\t\t\t{\n\t\t\t    arg[len++] = KS_SPECIAL;\n\t\t\t    arg[len++] = KE_FILLER;\n\t\t\t}\n#ifdef FEAT_GUI\n\t\t\telse if (*p == CSI)\n\t\t\t{\n\t\t\t    arg[len++] = KS_EXTRA;\n\t\t\t    arg[len++] = (int)KE_CSI;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    arg[len] = NUL;\n\t\t}\n\t    }\n\t}\n    }\n\n    ++ex_normal_busy;\n    if (save_current_state(&save_state))\n    {\n\t/*\n\t * Repeat the :normal command for each line in the range.  When no\n\t * range given, execute it just once, without positioning the cursor\n\t * first.\n\t */\n\tdo\n\t{\n\t    if (eap->addr_count != 0)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line1++;\n\t\tcurwin->w_cursor.col = 0;\n\t\tcheck_cursor_moved(curwin);\n\t    }\n\n\t    exec_normal_cmd(arg != NULL\n\t\t     ? arg\n\t\t     : eap->arg, eap->forceit ? REMAP_NONE : REMAP_YES, FALSE);\n\t}\n\twhile (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);\n    }\n\n    // Might not return to the main loop when in an event handler.\n    update_topline_cursor();\n\n    restore_current_state(&save_state);\n    --ex_normal_busy;\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    vim_free(arg);\n}\n\n/*\n * \":startinsert\", \":startreplace\" and \":startgreplace\"\n */\n    static void\nex_startinsert(exarg_T *eap)\n{\n    if (eap->forceit)\n    {\n\t// cursor line can be zero on startup\n\tif (!curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\tset_cursor_for_append_to_line();\n    }\n#ifdef FEAT_TERMINAL\n    // Ignore this when running in an active terminal.\n    if (term_job_running(curbuf->b_term))\n\treturn;\n#endif\n\n    // Ignore the command when already in Insert mode.  Inserting an\n    // expression register that invokes a function can do this.\n    if (State & MODE_INSERT)\n\treturn;\n\n    if (eap->cmdidx == CMD_startinsert)\n\trestart_edit = 'a';\n    else if (eap->cmdidx == CMD_startreplace)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'V';\n\n    if (!eap->forceit)\n    {\n\tif (eap->cmdidx == CMD_startinsert)\n\t    restart_edit = 'i';\n\tcurwin->w_curswant = 0;\t    // avoid MAXCOL\n    }\n\n    if (VIsual_active)\n\tshowmode();\n}\n\n/*\n * \":stopinsert\"\n */\n    static void\nex_stopinsert(exarg_T *eap UNUSED)\n{\n    restart_edit = 0;\n    stop_insert_mode = TRUE;\n    clearmode();\n}\n\n/*\n * Execute normal mode command \"cmd\".\n * \"remap\" can be REMAP_NONE or REMAP_YES.\n */\n    void\nexec_normal_cmd(char_u *cmd, int remap, int silent)\n{\n    // Stuff the argument into the typeahead buffer.\n    ins_typebuf(cmd, remap, 0, TRUE, silent);\n    exec_normal(FALSE, FALSE, FALSE);\n}\n\n/*\n * Execute normal_cmd() until there is no typeahead left.\n * When \"use_vpeekc\" is TRUE use vpeekc() to check for available chars.\n */\n    void\nexec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop UNUSED)\n{\n    oparg_T\toa;\n    int\t\tc;\n\n    // When calling vpeekc() from feedkeys() it will return Ctrl_C when there\n    // is nothing to get, so also check for Ctrl_C.\n    clear_oparg(&oa);\n    finish_op = FALSE;\n    while ((!stuff_empty()\n\t\t|| ((was_typed || !typebuf_typed()) && typebuf.tb_len > 0)\n\t\t|| (use_vpeekc && (c = vpeekc()) != NUL && c != Ctrl_C))\n\t    && !got_int)\n    {\n\tupdate_topline_cursor();\n#ifdef FEAT_TERMINAL\n\tif (may_use_terminal_loop && term_use_loop()\n\t\t&& oa.op_type == OP_NOP && oa.regname == NUL\n\t\t&& !VIsual_active)\n\t{\n\t    // If terminal_loop() returns OK we got a key that is handled\n\t    // in Normal model.  With FAIL we first need to position the\n\t    // cursor and the screen needs to be redrawn.\n\t    if (terminal_loop(TRUE) == OK)\n\t\tnormal_cmd(&oa, TRUE);\n\t}\n\telse\n#endif\n\t    // execute a Normal mode cmd\n\t    normal_cmd(&oa, TRUE);\n    }\n}\n\n#ifdef FEAT_FIND_ID\n    static void\nex_checkpath(exarg_T *eap)\n{\n    find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,\n\t\t\t\t   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,\n\t\t\t\t\t      (linenr_T)1, (linenr_T)MAXLNUM);\n}\n\n#if defined(FEAT_QUICKFIX)\n/*\n * \":psearch\"\n */\n    static void\nex_psearch(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;\n    ex_findpat(eap);\n    g_do_tagpreview = 0;\n}\n#endif\n\n    static void\nex_findpat(exarg_T *eap)\n{\n    int\t\twhole = TRUE;\n    long\tn;\n    char_u\t*p;\n    int\t\taction;\n\n    switch (cmdnames[eap->cmdidx].cmd_name[2])\n    {\n\tcase 'e':\t// \":psearch\", \":isearch\" and \":dsearch\"\n\t\tif (cmdnames[eap->cmdidx].cmd_name[0] == 'p')\n\t\t    action = ACTION_GOTO;\n\t\telse\n\t\t    action = ACTION_SHOW;\n\t\tbreak;\n\tcase 'i':\t// \":ilist\" and \":dlist\"\n\t\taction = ACTION_SHOW_ALL;\n\t\tbreak;\n\tcase 'u':\t// \":ijump\" and \":djump\"\n\t\taction = ACTION_GOTO;\n\t\tbreak;\n\tdefault:\t// \":isplit\" and \":dsplit\"\n\t\taction = ACTION_SPLIT;\n\t\tbreak;\n    }\n\n    n = 1;\n    if (vim_isdigit(*eap->arg))\t// get count\n    {\n\tn = getdigits(&eap->arg);\n\teap->arg = skipwhite(eap->arg);\n    }\n    if (*eap->arg == '/')   // Match regexp, not just whole words\n    {\n\twhole = FALSE;\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\tif (*p)\n\t{\n\t    *p++ = NUL;\n\t    p = skipwhite(p);\n\n\t    // Check for trailing illegal characters\n\t    if (!ends_excmd2(eap->arg, p))\n\t\teap->errmsg = ex_errmsg(e_trailing_characters_str, p);\n\t    else\n\t\tset_nextcmd(eap, p);\n\t}\n    }\n    if (!eap->skip)\n\tfind_pattern_in_path(eap->arg, 0, (int)STRLEN(eap->arg),\n\t\t\t    whole, !eap->forceit,\n\t\t\t    *eap->cmd == 'd' ?\tFIND_DEFINE : FIND_ANY,\n\t\t\t    n, action, eap->line1, eap->line2);\n}\n#endif\n\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc.\n */\n    static void\nex_ptag(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;  // will be reset to 0 in ex_tag_cmd()\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n}\n\n/*\n * \":pedit\"\n */\n    static void\nex_pedit(exarg_T *eap)\n{\n    win_T\t*curwin_save = curwin;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    // Open the preview window or popup and make it the current window.\n    g_do_tagpreview = p_pvh;\n    prepare_tagpreview(TRUE, TRUE, FALSE);\n\n    // Edit the file.\n    do_exedit(eap, NULL);\n\n    if (curwin != curwin_save && win_valid(curwin_save))\n    {\n\t// Return cursor to where we were\n\tvalidate_cursor();\n\tredraw_later(VALID);\n\twin_enter(curwin_save, TRUE);\n    }\n# ifdef FEAT_PROP_POPUP\n    else if (WIN_IS_POPUP(curwin))\n    {\n\t// can't keep focus in popup window\n\twin_enter(firstwin, TRUE);\n    }\n# endif\n    g_do_tagpreview = 0;\n}\n#endif\n\n/*\n * \":stag\", \":stselect\" and \":stjump\".\n */\n    static void\nex_stag(exarg_T *eap)\n{\n    postponed_split = -1;\n    postponed_split_flags = cmdmod.cmod_split;\n    postponed_split_tab = cmdmod.cmod_tab;\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n    postponed_split_flags = 0;\n    postponed_split_tab = 0;\n}\n\n/*\n * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc.\n */\n    static void\nex_tag(exarg_T *eap)\n{\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);\n}\n\n    static void\nex_tag_cmd(exarg_T *eap, char_u *name)\n{\n    int\t\tcmd;\n\n    switch (name[1])\n    {\n\tcase 'j': cmd = DT_JUMP;\t// \":tjump\"\n\t\t  break;\n\tcase 's': cmd = DT_SELECT;\t// \":tselect\"\n\t\t  break;\n\tcase 'p': cmd = DT_PREV;\t// \":tprevious\"\n\t\t  break;\n\tcase 'N': cmd = DT_PREV;\t// \":tNext\"\n\t\t  break;\n\tcase 'n': cmd = DT_NEXT;\t// \":tnext\"\n\t\t  break;\n\tcase 'o': cmd = DT_POP;\t\t// \":pop\"\n\t\t  break;\n\tcase 'f':\t\t\t// \":tfirst\"\n\tcase 'r': cmd = DT_FIRST;\t// \":trewind\"\n\t\t  break;\n\tcase 'l': cmd = DT_LAST;\t// \":tlast\"\n\t\t  break;\n\tdefault:\t\t\t// \":tag\"\n#ifdef FEAT_CSCOPE\n\t\t  if (p_cst && *eap->arg != NUL)\n\t\t  {\n\t\t      ex_cstag(eap);\n\t\t      return;\n\t\t  }\n#endif\n\t\t  cmd = DT_TAG;\n\t\t  break;\n    }\n\n    if (name[0] == 'l')\n    {\n#ifndef FEAT_QUICKFIX\n\tex_ni(eap);\n\treturn;\n#else\n\tcmd = DT_LTAG;\n#endif\n    }\n\n    do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,\n\t\t\t\t\t\t\t  eap->forceit, TRUE);\n}\n\n/*\n * Check \"str\" for starting with a special cmdline variable.\n * If found return one of the SPEC_ values and set \"*usedlen\" to the length of\n * the variable.  Otherwise return -1 and \"*usedlen\" is unchanged.\n */\n    int\nfind_cmdline_var(char_u *src, int *usedlen)\n{\n    int\t\tlen;\n    int\t\ti;\n    static char *(spec_str[]) = {\n\t\t    \"%\",\n#define SPEC_PERC   0\n\t\t    \"#\",\n#define SPEC_HASH   (SPEC_PERC + 1)\n\t\t    \"<cword>\",\t\t// cursor word\n#define SPEC_CWORD  (SPEC_HASH + 1)\n\t\t    \"<cWORD>\",\t\t// cursor WORD\n#define SPEC_CCWORD (SPEC_CWORD + 1)\n\t\t    \"<cexpr>\",\t\t// expr under cursor\n#define SPEC_CEXPR  (SPEC_CCWORD + 1)\n\t\t    \"<cfile>\",\t\t// cursor path name\n#define SPEC_CFILE  (SPEC_CEXPR + 1)\n\t\t    \"<sfile>\",\t\t// \":so\" file name\n#define SPEC_SFILE  (SPEC_CFILE + 1)\n\t\t    \"<slnum>\",\t\t// \":so\" file line number\n#define SPEC_SLNUM  (SPEC_SFILE + 1)\n\t\t    \"<stack>\",\t\t// call stack\n#define SPEC_STACK  (SPEC_SLNUM + 1)\n\t\t    \"<script>\",\t\t// script file name\n#define SPEC_SCRIPT (SPEC_STACK + 1)\n\t\t    \"<afile>\",\t\t// autocommand file name\n#define SPEC_AFILE  (SPEC_SCRIPT + 1)\n\t\t    \"<abuf>\",\t\t// autocommand buffer number\n#define SPEC_ABUF   (SPEC_AFILE + 1)\n\t\t    \"<amatch>\",\t\t// autocommand match name\n#define SPEC_AMATCH (SPEC_ABUF + 1)\n\t\t    \"<sflnum>\",\t\t// script file line number\n#define SPEC_SFLNUM  (SPEC_AMATCH + 1)\n\t\t    \"<SID>\",\t\t// script ID: <SNR>123_\n#define SPEC_SID  (SPEC_SFLNUM + 1)\n#ifdef FEAT_CLIENTSERVER\n\t\t    \"<client>\"\n# define SPEC_CLIENT (SPEC_SID + 1)\n#endif\n    };\n\n    for (i = 0; i < (int)ARRAY_LENGTH(spec_str); ++i)\n    {\n\tlen = (int)STRLEN(spec_str[i]);\n\tif (STRNCMP(src, spec_str[i], len) == 0)\n\t{\n\t    *usedlen = len;\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Evaluate cmdline variables.\n *\n * change \"%\"\t    to curbuf->b_ffname\n *\t  \"#\"\t    to curwin->w_alt_fnum\n *\t  \"%%\"\t    to curwin->w_alt_fnum in Vim9 script\n *\t  \"<cword>\" to word under the cursor\n *\t  \"<cWORD>\" to WORD under the cursor\n *\t  \"<cexpr>\" to C-expression under the cursor\n *\t  \"<cfile>\" to path name under the cursor\n *\t  \"<sfile>\" to sourced file name\n *\t  \"<stack>\" to call stack\n *\t  \"<script>\" to current script name\n *\t  \"<slnum>\" to sourced file line number\n *\t  \"<afile>\" to file name for autocommand\n *\t  \"<abuf>\"  to buffer number for autocommand\n *\t  \"<amatch>\" to matching name for autocommand\n *\n * When an error is detected, \"errormsg\" is set to a non-NULL pointer (may be\n * \"\" for error without a message) and NULL is returned.\n * Returns an allocated string if a valid match was found.\n * Returns NULL if no match was found.\t\"usedlen\" then still contains the\n * number of characters to skip.\n */\n    char_u *\neval_vars(\n    char_u\t*src,\t\t// pointer into commandline\n    char_u\t*srcstart,\t// beginning of valid memory for src\n    int\t\t*usedlen,\t// characters after src that are used\n    linenr_T\t*lnump,\t\t// line number for :e command, or NULL\n    char\t**errormsg,\t// pointer to error message\n    int\t\t*escaped,\t// return value has escaped white space (can\n\t\t\t\t// be NULL)\n    int\t\tempty_is_error)\t// empty result is considered an error\n{\n    int\t\ti;\n    char_u\t*s;\n    char_u\t*result;\n    char_u\t*resultbuf = NULL;\n    int\t\tresultlen;\n    buf_T\t*buf;\n    int\t\tvalid = VALID_HEAD + VALID_PATH;    // assume valid result\n    int\t\tspec_idx;\n    int\t\ttilde_file = FALSE;\n    int\t\tskip_mod = FALSE;\n    char_u\tstrbuf[30];\n\n    *errormsg = NULL;\n    if (escaped != NULL)\n\t*escaped = FALSE;\n\n    /*\n     * Check if there is something to do.\n     */\n    spec_idx = find_cmdline_var(src, usedlen);\n    if (spec_idx < 0)\t// no match\n    {\n\t*usedlen = 1;\n\treturn NULL;\n    }\n\n    /*\n     * Skip when preceded with a backslash \"\\%\" and \"\\#\".\n     * Note: In \"\\\\%\" the % is also not recognized!\n     */\n    if (src > srcstart && src[-1] == '\\\\')\n    {\n\t*usedlen = 0;\n\tSTRMOVE(src - 1, src);\t// remove backslash\n\treturn NULL;\n    }\n\n    /*\n     * word or WORD under cursor\n     */\n    if (spec_idx == SPEC_CWORD || spec_idx == SPEC_CCWORD\n\t\t\t\t\t\t     || spec_idx == SPEC_CEXPR)\n    {\n\tresultlen = find_ident_under_cursor(&result,\n\t\tspec_idx == SPEC_CWORD ? (FIND_IDENT | FIND_STRING)\n\t      : spec_idx == SPEC_CEXPR ? (FIND_IDENT | FIND_STRING | FIND_EVAL)\n\t      : FIND_STRING);\n\tif (resultlen == 0)\n\t{\n\t    *errormsg = \"\";\n\t    return NULL;\n\t}\n    }\n\n    /*\n     * '#': Alternate file name\n     * '%': Current file name\n     *\t    File name under the cursor\n     *\t    File name for autocommand\n     *\tand following modifiers\n     */\n    else\n    {\n\tint off = 0;\n\n\tswitch (spec_idx)\n\t{\n\tcase SPEC_PERC:\n#ifdef FEAT_EVAL\n\t\tif (!in_vim9script() || src[1] != '%')\n#endif\n\t\t{\n\t\t    // '%': current file\n\t\t    if (curbuf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = curbuf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t    break;\n\t\t}\n#ifdef FEAT_EVAL\n\t\t// \"%%\" alternate file\n\t\toff = 1;\n#endif\n\t\t// FALLTHROUGH\n\tcase SPEC_HASH:\t\t// '#' or \"#99\": alternate file\n\t\tif (off == 0 ? src[1] == '#' : src[2] == '%')\n\t\t{\n\t\t    // \"##\" or \"%%%\": the argument list\n\t\t    result = arg_all();\n\t\t    resultbuf = result;\n\t\t    *usedlen = off + 2;\n\t\t    if (escaped != NULL)\n\t\t\t*escaped = TRUE;\n\t\t    skip_mod = TRUE;\n\t\t    break;\n\t\t}\n\t\ts = src + off + 1;\n\t\tif (*s == '<')\t\t// \"#<99\" uses v:oldfiles\n\t\t    ++s;\n\t\ti = (int)getdigits(&s);\n\t\tif (s == src + off + 2 && src[off + 1] == '-')\n\t\t    // just a minus sign, don't skip over it\n\t\t    s--;\n\t\t*usedlen = (int)(s - src); // length of what we expand\n\n\t\tif (src[off + 1] == '<' && i != 0)\n\t\t{\n\t\t    if (*usedlen < off + 2)\n\t\t    {\n\t\t\t// Should we give an error message for #<text?\n\t\t\t*usedlen = off + 1;\n\t\t\treturn NULL;\n\t\t    }\n#ifdef FEAT_EVAL\n\t\t    result = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t\t\t\t\t\t\t     (long)i);\n\t\t    if (result == NULL)\n\t\t    {\n\t\t\t*errormsg = \"\";\n\t\t\treturn NULL;\n\t\t    }\n#else\n\t\t    *errormsg = _(e_hashsmall_is_not_available_without_the_eval_feature);\n\t\t    return NULL;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (i == 0 && src[off + 1] == '<' && *usedlen > off + 1)\n\t\t\t*usedlen = off + 1;\n\t\t    buf = buflist_findnr(i);\n\t\t    if (buf == NULL)\n\t\t    {\n\t\t\t*errormsg = _(e_no_alternate_file_name_to_substitute_for_hash);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (lnump != NULL)\n\t\t\t*lnump = ECMD_LAST;\n\t\t    if (buf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = buf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\tcase SPEC_CFILE:\t// file name under cursor\n\t\tresult = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = \"\";\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n#endif\n\n\tcase SPEC_AFILE:\t// file name for autocommand\n\t\tresult = autocmd_fname;\n\t\tif (result != NULL && !autocmd_fname_full)\n\t\t{\n\t\t    // Still need to turn the fname into a full path.  It is\n\t\t    // postponed to avoid a delay when <afile> is not used.\n\t\t    autocmd_fname_full = TRUE;\n\t\t    result = FullName_save(autocmd_fname, FALSE);\n\t\t    vim_free(autocmd_fname);\n\t\t    autocmd_fname = result;\n\t\t}\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_file_name_to_substitute_for_afile);\n\t\t    return NULL;\n\t\t}\n\t\tresult = shorten_fname1(result);\n\t\tbreak;\n\n\tcase SPEC_ABUF:\t\t// buffer number for autocommand\n\t\tif (autocmd_bufnr <= 0)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_buffer_name_to_substitute_for_abuf);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%d\", autocmd_bufnr);\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_AMATCH:\t// match name for autocommand\n\t\tresult = autocmd_match;\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_match_name_to_substitute_for_amatch);\n\t\t    return NULL;\n\t\t}\n\t\tbreak;\n\n\tcase SPEC_SFILE:\t// file name for \":so\" command\n\t\tresult = estack_sfile(ESTACK_SFILE);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_source_file_name_to_substitute_for_sfile);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\tcase SPEC_STACK:\t// call stack\n\t\tresult = estack_sfile(ESTACK_STACK);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_call_stack_to_substitute_for_stack);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\tcase SPEC_SCRIPT:\t// script file name\n\t\tresult = estack_sfile(ESTACK_SCRIPT);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_script_file_name_to_substitute_for_script);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\n\tcase SPEC_SLNUM:\t// line in file for \":so\" command\n\t\tif (SOURCING_NAME == NULL || SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(e_no_line_number_to_use_for_slnum);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\", SOURCING_LNUM);\n\t\tresult = strbuf;\n\t\tbreak;\n\n#ifdef FEAT_EVAL\n\tcase SPEC_SFLNUM:\t// line in script file\n\t\tif (current_sctx.sc_lnum + SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(e_no_line_number_to_use_for_sflnum);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\",\n\t\t\t\t (long)(current_sctx.sc_lnum + SOURCING_LNUM));\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_SID:\n\t\tif (current_sctx.sc_sid <= 0)\n\t\t{\n\t\t    *errormsg = _(e_using_sid_not_in_script_context);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"<SNR>%d_\", current_sctx.sc_sid);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n#ifdef FEAT_CLIENTSERVER\n\tcase SPEC_CLIENT:\t// Source of last submitted input\n\t\tsprintf((char *)strbuf, PRINTF_HEX_LONG_U,\n\t\t\t\t\t\t\t(long_u)clientWindow);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tresult = (char_u *)\"\"; // avoid gcc warning\n\t\tbreak;\n\t}\n\n\tresultlen = (int)STRLEN(result);\t// length of new string\n\tif (src[*usedlen] == '<')\t// remove the file name extension\n\t{\n\t    ++*usedlen;\n\t    if ((s = vim_strrchr(result, '.')) != NULL && s >= gettail(result))\n\t\tresultlen = (int)(s - result);\n\t}\n\telse if (!skip_mod)\n\t{\n\t    valid |= modify_fname(src, tilde_file, usedlen, &result, &resultbuf,\n\t\t\t\t\t\t\t\t  &resultlen);\n\t    if (result == NULL)\n\t    {\n\t\t*errormsg = \"\";\n\t\treturn NULL;\n\t    }\n\t}\n    }\n\n    if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH)\n    {\n\tif (empty_is_error)\n\t{\n\t    if (valid != VALID_HEAD + VALID_PATH)\n\t\t*errormsg = _(e_empty_file_name_for_percent_or_hash_only_works_with_ph);\n\t    else\n\t\t*errormsg = _(e_evaluates_to_an_empty_string);\n\t}\n\tresult = NULL;\n    }\n    else\n\tresult = vim_strnsave(result, resultlen);\n    vim_free(resultbuf);\n    return result;\n}\n\n/*\n * Expand the <sfile> string in \"arg\".\n *\n * Returns an allocated string, or NULL for any error.\n */\n    char_u *\nexpand_sfile(char_u *arg)\n{\n    char\t*errormsg;\n    int\t\tlen;\n    char_u\t*result;\n    char_u\t*newres;\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n\n    result = vim_strsave(arg);\n    if (result == NULL)\n\treturn NULL;\n\n    for (p = result; *p; )\n    {\n\tif (STRNCMP(p, \"<sfile>\", 7) != 0)\n\t    ++p;\n\telse\n\t{\n\t    // replace \"<sfile>\" with the sourced file name, and do \":\" stuff\n\t    repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL, TRUE);\n\t    if (errormsg != NULL)\n\t    {\n\t\tif (*errormsg)\n\t\t    emsg(errormsg);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    if (repl == NULL)\t\t// no match (cannot happen)\n\t    {\n\t\tp += srclen;\n\t\tcontinue;\n\t    }\n\t    len = (int)STRLEN(result) - srclen + (int)STRLEN(repl) + 1;\n\t    newres = alloc(len);\n\t    if (newres == NULL)\n\t    {\n\t\tvim_free(repl);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    mch_memmove(newres, result, (size_t)(p - result));\n\t    STRCPY(newres + (p - result), repl);\n\t    len = (int)STRLEN(newres);\n\t    STRCAT(newres, p + srclen);\n\t    vim_free(repl);\n\t    vim_free(result);\n\t    result = newres;\n\t    p = newres + len;\t\t// continue after the match\n\t}\n    }\n\n    return result;\n}\n\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\".\n * \"format\" must contain \"%s\".\n */\n    void\ndialog_msg(char_u *buff, char *format, char_u *fname)\n{\n    if (fname == NULL)\n\tfname = (char_u *)_(\"Untitled\");\n    vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);\n}\n#endif\n\n/*\n * \":behave {mswin,xterm}\"\n */\n    static void\nex_behave(exarg_T *eap)\n{\n    if (STRCMP(eap->arg, \"mswin\") == 0)\n    {\n\tset_option_value_give_err((char_u *)\"selection\",\n\t\t\t\t\t\t 0L, (char_u *)\"exclusive\", 0);\n\tset_option_value_give_err((char_u *)\"selectmode\",\n\t\t\t\t\t\t 0L, (char_u *)\"mouse,key\", 0);\n\tset_option_value_give_err((char_u *)\"mousemodel\",\n\t\t\t\t\t\t     0L, (char_u *)\"popup\", 0);\n\tset_option_value_give_err((char_u *)\"keymodel\",\n\t\t\t\t\t  0L, (char_u *)\"startsel,stopsel\", 0);\n    }\n    else if (STRCMP(eap->arg, \"xterm\") == 0)\n    {\n\tset_option_value_give_err((char_u *)\"selection\",\n\t\t\t\t\t\t 0L, (char_u *)\"inclusive\", 0);\n\tset_option_value_give_err((char_u *)\"selectmode\", 0L, (char_u *)\"\", 0);\n\tset_option_value_give_err((char_u *)\"mousemodel\",\n\t\t\t\t\t\t    0L, (char_u *)\"extend\", 0);\n\tset_option_value_give_err((char_u *)\"keymodel\", 0L, (char_u *)\"\", 0);\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n}\n\nstatic int filetype_detect = FALSE;\nstatic int filetype_plugin = FALSE;\nstatic int filetype_indent = FALSE;\n\n/*\n * \":filetype [plugin] [indent] {on,off,detect}\"\n * on: Load the filetype.vim file to install autocommands for file types.\n * off: Load the ftoff.vim file to remove all autocommands for file types.\n * plugin on: load filetype.vim and ftplugin.vim\n * plugin off: load ftplugof.vim\n * indent on: load filetype.vim and indent.vim\n * indent off: load indoff.vim\n */\n    static void\nex_filetype(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tplugin = FALSE;\n    int\t\tindent = FALSE;\n\n    if (*eap->arg == NUL)\n    {\n\t// Print current status.\n\tsmsg(\"filetype detection:%s  plugin:%s  indent:%s\",\n\t\tfiletype_detect ? \"ON\" : \"OFF\",\n\t\tfiletype_plugin ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\",\n\t\tfiletype_indent ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\");\n\treturn;\n    }\n\n    // Accept \"plugin\" and \"indent\" in any order.\n    for (;;)\n    {\n\tif (STRNCMP(arg, \"plugin\", 6) == 0)\n\t{\n\t    plugin = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tif (STRNCMP(arg, \"indent\", 6) == 0)\n\t{\n\t    indent = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tbreak;\n    }\n    if (STRCMP(arg, \"on\") == 0 || STRCMP(arg, \"detect\") == 0)\n    {\n\tif (*arg == 'o' || !filetype_detect)\n\t{\n\t    source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);\n\t    filetype_detect = TRUE;\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);\n\t\tfiletype_plugin = TRUE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDENT_FILE, DIP_ALL);\n\t\tfiletype_indent = TRUE;\n\t    }\n\t}\n\tif (*arg == 'd')\n\t{\n\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", TRUE, NULL);\n\t    do_modelines(0);\n\t}\n    }\n    else if (STRCMP(arg, \"off\") == 0)\n    {\n\tif (plugin || indent)\n\t{\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);\n\t\tfiletype_plugin = FALSE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDOFF_FILE, DIP_ALL);\n\t\tfiletype_indent = FALSE;\n\t    }\n\t}\n\telse\n\t{\n\t    source_runtime((char_u *)FTOFF_FILE, DIP_ALL);\n\t    filetype_detect = FALSE;\n\t}\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), arg);\n}\n\n/*\n * \":setfiletype [FALLBACK] {name}\"\n */\n    static void\nex_setfiletype(exarg_T *eap)\n{\n    if (!did_filetype)\n    {\n\tchar_u *arg = eap->arg;\n\n\tif (STRNCMP(arg, \"FALLBACK \", 9) == 0)\n\t    arg += 9;\n\n\tset_option_value_give_err((char_u *)\"filetype\", 0L, arg, OPT_LOCAL);\n\tif (arg != eap->arg)\n\t    did_filetype = FALSE;\n    }\n}\n\n    static void\nex_digraphs(exarg_T *eap UNUSED)\n{\n#ifdef FEAT_DIGRAPHS\n    if (*eap->arg != NUL)\n\tputdigraph(eap->arg);\n    else\n\tlistdigraphs(eap->forceit);\n#else\n    emsg(_(e_no_digraphs_version));\n#endif\n}\n\n#if defined(FEAT_SEARCH_EXTRA) || defined(PROTO)\n    void\nset_no_hlsearch(int flag)\n{\n    no_hlsearch = flag;\n# ifdef FEAT_EVAL\n    set_vim_var_nr(VV_HLSEARCH, !no_hlsearch && p_hls);\n# endif\n}\n\n/*\n * \":nohlsearch\"\n */\n    static void\nex_nohlsearch(exarg_T *eap UNUSED)\n{\n    set_no_hlsearch(TRUE);\n    redraw_all_later(SOME_VALID);\n}\n#endif\n\n#ifdef FEAT_CRYPT\n/*\n * \":X\": Get crypt key\n */\n    static void\nex_X(exarg_T *eap UNUSED)\n{\n    crypt_check_current_method();\n    (void)crypt_get_key(TRUE, TRUE);\n}\n#endif\n\n#ifdef FEAT_FOLDING\n    static void\nex_fold(exarg_T *eap)\n{\n    if (foldManualAllowed(TRUE))\n\tfoldCreate(eap->line1, eap->line2);\n}\n\n    static void\nex_foldopen(exarg_T *eap)\n{\n    opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,\n\t\t\t\t\t\t\t eap->forceit, FALSE);\n}\n\n    static void\nex_folddo(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n# ifdef FEAT_CLIPBOARD\n    start_global_changes();\n# endif\n\n    // First set the marks for all lines closed/open.\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n\tif (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed))\n\t    ml_setmarked(lnum);\n\n    // Execute the command on the marked lines.\n    global_exe(eap->arg);\n    ml_clearmarked();\t   // clear rest of the marks\n# ifdef FEAT_CLIPBOARD\n    end_global_changes();\n# endif\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Returns TRUE if the supplied Ex cmdidx is for a location list command\n * instead of a quickfix command.\n */\n    int\nis_loclist_cmd(int cmdidx)\n{\n    if (cmdidx < 0 || cmdidx >= CMD_SIZE)\n\treturn FALSE;\n    return cmdnames[cmdidx].cmd_name[0] == 'l';\n}\n#endif\n\n#if defined(FEAT_TIMERS) || defined(PROTO)\n    int\nget_pressedreturn(void)\n{\n    return ex_pressedreturn;\n}\n\n    void\nset_pressedreturn(int val)\n{\n     ex_pressedreturn = val;\n}\n#endif\n", "\" Tests for editing the command line.\n\nsource check.vim\nsource screendump.vim\nsource view_util.vim\nsource shared.vim\nimport './vim9.vim' as v9\n\nfunc SetUp()\n  func SaveLastScreenLine()\n    let g:Sline = Screenline(&lines - 1)\n    return ''\n  endfunc\n  cnoremap <expr> <F4> SaveLastScreenLine()\nendfunc\n\nfunc TearDown()\n  delfunc SaveLastScreenLine\n  cunmap <F4>\nendfunc\n\nfunc Test_complete_tab()\n  call writefile(['testfile'], 'Xtestfile')\n  call feedkeys(\":e Xtest\\t\\r\", \"tx\")\n  call assert_equal('testfile', getline(1))\n\n  \" Pressing <Tab> after '%' completes the current file, also on MS-Windows\n  call feedkeys(\":e %\\t\\r\", \"tx\")\n  call assert_equal('e Xtestfile', @:)\n  call delete('Xtestfile')\nendfunc\n\nfunc Test_complete_list()\n  \" We can't see the output, but at least we check the code runs properly.\n  call feedkeys(\":e test\\<C-D>\\r\", \"tx\")\n  call assert_equal('test', expand('%:t'))\n\n  \" If a command doesn't support completion, then CTRL-D should be literally\n  \" used.\n  call feedkeys(\":chistory \\<C-D>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"chistory \\<C-D>\", @:)\n\n  \" Test for displaying the tail of the completion matches\n  set wildmode=longest,full\n  call mkdir('Xtest')\n  call writefile([], 'Xtest/a.c')\n  call writefile([], 'Xtest/a.h')\n  let g:Sline = ''\n  call feedkeys(\":e Xtest/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('a.c  a.h', g:Sline)\n  call assert_equal('\"e Xtest/', @:)\n  if has('win32')\n    \" Test for 'completeslash'\n    set completeslash=backslash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\', @:)\n    call feedkeys(\":e Xtest/\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\a.', @:)\n    set completeslash=slash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/', @:)\n    call feedkeys(\":e Xtest\\\\\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/a.', @:)\n    set completeslash&\n  endif\n\n  \" Test for displaying the tail with wildcards\n  let g:Sline = ''\n  call feedkeys(\":e Xtes?/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes?/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes*/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes*/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes[/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(':e Xtes[/', g:Sline)\n  call assert_equal('\"e Xtes[/', @:)\n\n  call delete('Xtest', 'rf')\n  set wildmode&\nendfunc\n\nfunc Test_complete_wildmenu()\n  call mkdir('Xdir1/Xdir2', 'p')\n  call writefile(['testfile1'], 'Xdir1/Xtestfile1')\n  call writefile(['testfile2'], 'Xdir1/Xtestfile2')\n  call writefile(['testfile3'], 'Xdir1/Xdir2/Xtestfile3')\n  call writefile(['testfile3'], 'Xdir1/Xdir2/Xtestfile4')\n  set wildmenu\n\n  \" Pressing <Tab> completes, and moves to next files when pressing again.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n\n  \" <S-Tab> is like <Tab> but begin with the last match and then go to\n  \" previous.\n  call feedkeys(\":e Xdir1/Xtest\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xdir1/Xtest\\<S-Tab>\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Left>/<Right> to move to previous/next file.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<Right>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Up>/<Down> to go up/down directories.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<CR>\", 'tx')\n  call assert_equal('testfile3', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<Up>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" this fails in some Unix GUIs, not sure why\n  if !has('unix') || !has('gui_running')\n    \" <C-J>/<C-K> mappings to go up/down directories when 'wildcharm' is\n    \" different than 'wildchar'.\n    set wildcharm=<C-Z>\n    cnoremap <C-J> <Down><C-Z>\n    cnoremap <C-K> <Up><C-Z>\n    call feedkeys(\":e Xdir1/\\<Tab>\\<C-J>\\<CR>\", 'tx')\n    call assert_equal('testfile3', getline(1))\n    call feedkeys(\":e Xdir1/\\<Tab>\\<C-J>\\<C-K>\\<CR>\", 'tx')\n    call assert_equal('testfile1', getline(1))\n    set wildcharm=0\n    cunmap <C-J>\n    cunmap <C-K>\n  endif\n\n  \" Test for canceling the wild menu by adding a character\n  redrawstatus\n  call feedkeys(\":e Xdir1/\\<Tab>x\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xdir1/Xdir2/x', @:)\n\n  \" Completion using a relative path\n  cd Xdir1/Xdir2\n  call feedkeys(\":e ../\\<Tab>\\<Right>\\<Down>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xtestfile3 Xtestfile4', @:)\n  cd -\n\n  \" test for wildmenumode()\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":cd Xdir\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cd Xdir1/0', @:)\n  call feedkeys(\":e Xdir1/\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xdir1/Xdir2/1', @:)\n  cunmap <F2>\n\n  \" Test for canceling the wild menu by pressing <PageDown> or <PageUp>.\n  \" After this pressing <Left> or <Right> should not change the selection.\n  call feedkeys(\":sign \\<Tab>\\<PageDown>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign define', @:)\n  call histadd('cmd', 'TestWildMenu')\n  call feedkeys(\":sign \\<Tab>\\<PageUp>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"TestWildMenu', @:)\n\n  \" cleanup\n  %bwipe\n  call delete('Xdir1', 'rf')\n  set nowildmenu\nendfunc\n\nfunc Test_wildmenu_screendump()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    set wildmenu hlsearch\n  [SCRIPT]\n  call writefile(lines, 'XTest_wildmenu')\n\n  let buf = RunVimInTerminal('-S XTest_wildmenu', {'rows': 8})\n  call term_sendkeys(buf, \":vim\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_1', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_2', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_3', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_4', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_wildmenu')\nendfunc\n\nfunc Test_redraw_in_autocmd()\n  CheckScreendump\n\n  let lines =<< trim END\n      set cmdheight=2\n      autocmd CmdlineChanged * redraw\n  END\n  call writefile(lines, 'XTest_redraw')\n\n  let buf = RunVimInTerminal('-S XTest_redraw', {'rows': 8})\n  call term_sendkeys(buf, \":for i in range(3)\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_1', {})\n\n  call term_sendkeys(buf, \"let i =\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<CR>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_redraw')\nendfunc\n\nfunc Test_map_completion()\n  call feedkeys(\":map <unique> <si\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <unique> <silent>', getreg(':'))\n  call feedkeys(\":map <script> <un\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <script> <unique>', getreg(':'))\n  call feedkeys(\":map <expr> <sc\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <expr> <script>', getreg(':'))\n  call feedkeys(\":map <buffer> <e\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <buffer> <expr>', getreg(':'))\n  call feedkeys(\":map <nowait> <b\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <nowait> <buffer>', getreg(':'))\n  call feedkeys(\":map <special> <no\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <special> <nowait>', getreg(':'))\n  call feedkeys(\":map <silent> <sp\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <silent> <special>', getreg(':'))\n\n  map <Middle>x middle\n\n  map ,f commaf\n  map ,g commaf\n  map <Left> left\n  map <A-Left>x shiftleft\n  call feedkeys(\":map ,\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,f', getreg(':'))\n  call feedkeys(\":map ,\\<Tab>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,g', getreg(':'))\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <A-Left>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <A-Left>\\<Tab>\", getreg(':'))\n  unmap ,f\n  unmap ,g\n  unmap <Left>\n  unmap <A-Left>x\n\n  set cpo-=< cpo-=B cpo-=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <M\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <M\\<Tab>\", getreg(':'))\n  unmap <Left>\n\n  set cpo+=<\n  map <Left> left\n  exe \"set t_k6=\\<Esc>[17~\"\n  call feedkeys(\":map \\<Esc>[17~x f6x\\<CR>\", 'xt')\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  if !has('gui_running')\n    call feedkeys(\":map \\<Esc>[17~\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"map <F6>x\", getreg(':'))\n  endif\n  unmap <Left>\n  call feedkeys(\":unmap \\<Esc>[17~x\\<CR>\", 'xt')\n  set cpo-=<\n\n  set cpo+=B\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=B\n\n  set cpo+=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=k\n\n  call assert_fails('call feedkeys(\":map \\\\\\\\%(\\<Tab>\\<Home>\\\"\\<CR>\", \"xt\")', 'E53:')\n\n  unmap <Middle>x\n  set cpo&vim\nendfunc\n\nfunc Test_match_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":match \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match Aardig', @:)\n  call feedkeys(\":match \\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match none', @:)\n  call feedkeys(\":match | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match | chistory', @:)\nendfunc\n\nfunc Test_highlight_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":hi \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi Aardig', getreg(':'))\n  call feedkeys(\":hi default \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default Aardig', getreg(':'))\n  call feedkeys(\":hi clear Aa\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig', getreg(':'))\n  call feedkeys(\":hi li\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi link', getreg(':'))\n  call feedkeys(\":hi d\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default', getreg(':'))\n  call feedkeys(\":hi c\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear', getreg(':'))\n  call feedkeys(\":hi clear Aardig Aard\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig Aardig', getreg(':'))\n  call feedkeys(\":hi Aardig \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Aardig \\t\", getreg(':'))\n\n  \" A cleared group does not show up in completions.\n  hi Anders ctermfg=green\n  call assert_equal(['Aardig', 'Anders'], getcompletion('A', 'highlight'))\n  hi clear Aardig\n  call assert_equal(['Anders'], getcompletion('A', 'highlight'))\n  hi clear Anders\n  call assert_equal([], getcompletion('A', 'highlight'))\nendfunc\n\n\" Test for command-line expansion of \"hi Ni \" (easter egg)\nfunc Test_highlight_easter_egg()\n  call test_override('ui_delay', 1)\n  call feedkeys(\":hi Ni \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Ni \\<Tab>\", @:)\n  call test_override('ALL', 0)\nendfunc\n\nfunc Test_getcompletion()\n  let groupcount = len(getcompletion('', 'event'))\n  call assert_true(groupcount > 0)\n  let matchcount = len('File'->getcompletion('event'))\n  call assert_true(matchcount > 0)\n  call assert_true(groupcount > matchcount)\n\n  if has('menu')\n    source $VIMRUNTIME/menu.vim\n    let matchcount = len(getcompletion('', 'menu'))\n    call assert_true(matchcount > 0)\n    call assert_equal(['File.'], getcompletion('File', 'menu'))\n    call assert_true(matchcount > 0)\n    let matchcount = len(getcompletion('File.', 'menu'))\n    call assert_true(matchcount > 0)\n  endif\n\n  let l = getcompletion('v:n', 'var')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('v:notexists', 'var')\n  call assert_equal([], l)\n\n  args a.c b.c\n  let l = getcompletion('', 'arglist')\n  call assert_equal(['a.c', 'b.c'], l)\n  let l = getcompletion('a.', 'buffer')\n  call assert_equal(['a.c'], l)\n  %argdelete\n\n  let l = getcompletion('', 'augroup')\n  call assert_true(index(l, 'END') >= 0)\n  let l = getcompletion('blahblah', 'augroup')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'behave')\n  call assert_true(index(l, 'mswin') >= 0)\n  let l = getcompletion('not', 'behave')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'color')\n  call assert_true(index(l, 'default') >= 0)\n  let l = getcompletion('dirty', 'color')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'command')\n  call assert_true(index(l, 'sleep') >= 0)\n  let l = getcompletion('awake', 'command')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'dir')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('NoMatch', 'dir')\n  call assert_equal([], l)\n\n  if glob('~/*') !=# ''\n    let l = getcompletion('~/', 'dir')\n    call assert_true(l[0][0] ==# '~')\n  endif\n\n  let l = getcompletion('exe', 'expression')\n  call assert_true(index(l, 'executable(') >= 0)\n  let l = getcompletion('kill', 'expression')\n  call assert_equal([], l)\n\n  let l = getcompletion('tag', 'function')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('paint', 'function')\n  call assert_equal([], l)\n\n  let Flambda = {-> 'hello'}\n  let l = getcompletion('', 'function')\n  let l = filter(l, {i, v -> v =~ 'lambda'})\n  call assert_equal([], l)\n\n  let l = getcompletion('run', 'file')\n  call assert_true(index(l, 'runtest.vim') >= 0)\n  let l = getcompletion('walk', 'file')\n  call assert_equal([], l)\n  set wildignore=*.vim\n  let l = getcompletion('run', 'file', 1)\n  call assert_true(index(l, 'runtest.vim') < 0)\n  set wildignore&\n  \" Directory name with space character\n  call mkdir('Xdir with space')\n  call assert_equal(['Xdir with space/'], getcompletion('Xdir\\ w', 'shellcmd'))\n  call assert_equal(['./Xdir with space/'], getcompletion('./Xdir', 'shellcmd'))\n  call delete('Xdir with space', 'd')\n\n  let l = getcompletion('ha', 'filetype')\n  call assert_true(index(l, 'hamster') >= 0)\n  let l = getcompletion('horse', 'filetype')\n  call assert_equal([], l)\n\n  let l = getcompletion('z', 'syntax')\n  call assert_true(index(l, 'zimbu') >= 0)\n  let l = getcompletion('emacs', 'syntax')\n  call assert_equal([], l)\n\n  let l = getcompletion('jikes', 'compiler')\n  call assert_true(index(l, 'jikes') >= 0)\n  let l = getcompletion('break', 'compiler')\n  call assert_equal([], l)\n\n  let l = getcompletion('last', 'help')\n  call assert_true(index(l, ':tablast') >= 0)\n  let l = getcompletion('giveup', 'help')\n  call assert_equal([], l)\n\n  let l = getcompletion('time', 'option')\n  call assert_true(index(l, 'timeoutlen') >= 0)\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n\n  let l = getcompletion('er', 'highlight')\n  call assert_true(index(l, 'ErrorMsg') >= 0)\n  let l = getcompletion('dark', 'highlight')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'messages')\n  call assert_true(index(l, 'clear') >= 0)\n  let l = getcompletion('not', 'messages')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'mapclear')\n  call assert_true(index(l, '<buffer>') >= 0)\n  let l = getcompletion('not', 'mapclear')\n  call assert_equal([], l)\n\n  let l = getcompletion('.', 'shellcmd')\n  call assert_equal(['./', '../'], filter(l, 'v:val =~ \"\\\\./\"'))\n  call assert_equal(-1, match(l[2:], '^\\.\\.\\?/$'))\n  let root = has('win32') ? 'C:\\\\' : '/'\n  let l = getcompletion(root, 'shellcmd')\n  let expected = map(filter(glob(root . '*', 0, 1),\n        \\ 'isdirectory(v:val) || executable(v:val)'), 'isdirectory(v:val) ? v:val . ''/'' : v:val')\n  call assert_equal(expected, l)\n\n  if has('cscope')\n    let l = getcompletion('', 'cscope')\n    let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":cscope find \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'cscope')\n    call assert_equal(cmds, l)\n    let keys = ['a', 'c', 'd', 'e', 'f', 'g', 'i', 's', 't']\n    let l = getcompletion('find ', 'cscope')\n    call assert_equal(keys, l)\n  endif\n\n  if has('signs')\n    sign define Testing linehl=Comment\n    let l = getcompletion('', 'sign')\n    let cmds = ['define', 'jump', 'list', 'place', 'undefine', 'unplace']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":sign list \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'sign')\n    call assert_equal(cmds, l)\n    let l = getcompletion('list ', 'sign')\n    call assert_equal(['Testing'], l)\n    let l = getcompletion('de*', 'sign')\n    call assert_equal(['define'], l)\n    let l = getcompletion('p?', 'sign')\n    call assert_equal(['place'], l)\n    let l = getcompletion('j.', 'sign')\n    call assert_equal(['jump'], l)\n  endif\n\n  \" Command line completion tests\n  let l = getcompletion('cd ', 'cmdline')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('cd NoMatch', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('let v:n', 'cmdline')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('let v:notexists', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('call tag', 'cmdline')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('call paint', 'cmdline')\n  call assert_equal([], l)\n\n  func T(a, c, p)\n    let g:cmdline_compl_params = [a:a, a:c, a:p]\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n  let l = getcompletion('MyCmd ', 'cmdline')\n  call assert_equal(['oneA', 'oneB', 'oneC'], l)\n  call assert_equal(['', 'MyCmd ', 6], g:cmdline_compl_params)\n\n  delcommand MyCmd\n  delfunc T\n  unlet g:cmdline_compl_params\n\n  \" For others test if the name is recognized.\n  let names = ['buffer', 'environment', 'file_in_path', 'mapping', 'tag', 'tag_listfiles', 'user']\n  if has('cmdline_hist')\n    call add(names, 'history')\n  endif\n  if has('gettext')\n    call add(names, 'locale')\n  endif\n  if has('profile')\n    call add(names, 'syntime')\n  endif\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\", \"word\\tfile\\tcmd\"], 'Xtags')\n\n  for name in names\n    let matchcount = len(getcompletion('', name))\n    call assert_true(matchcount >= 0, 'No matches for ' . name)\n  endfor\n\n  call delete('Xtags')\n  set tags&\n\n  edit a~b\n  enew\n  call assert_equal(['a~b'], getcompletion('a~', 'buffer'))\n  bw a~b\n\n  if has('unix')\n    edit Xtest\\\n    enew\n    call assert_equal(['Xtest\\'], getcompletion('Xtest\\', 'buffer'))\n    bw Xtest\\\n  endif\n\n  call assert_fails(\"call getcompletion('\\\\\\\\@!\\\\\\\\@=', 'buffer')\", 'E871:')\n  call assert_fails('call getcompletion(\"\", \"burp\")', 'E475:')\n  call assert_fails('call getcompletion(\"abc\", [])', 'E475:')\nendfunc\n\n\" Test for getcompletion() with \"fuzzy\" in 'wildoptions'\nfunc Test_getcompletion_wildoptions()\n  let save_wildoptions = &wildoptions\n  set wildoptions&\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n  let l = getcompletion('ier', 'command')\n  call assert_equal([], l)\n  set wildoptions=fuzzy\n  let l = getcompletion('space', 'option')\n  call assert_true(index(l, 'backspace') >= 0)\n  let l = getcompletion('ier', 'command')\n  call assert_true(index(l, 'compiler') >= 0)\n  let &wildoptions = save_wildoptions\nendfunc\n\nfunc Test_complete_autoload_error()\n  let save_rtp = &rtp\n  let lines =<< trim END\n      vim9script\n      export def Complete(..._): string\n        return 'match'\n      enddef\n      echo this will cause an error\n  END\n  call mkdir('Xdir/autoload', 'p')\n  call writefile(lines, 'Xdir/autoload/script.vim')\n  exe 'set rtp+=' .. getcwd() .. '/Xdir'\n\n  let lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      command -nargs=* -complete=custom,script.Complete Cmd eval 0 + 0\n      &wildcharm = char2nr(\"\\<Tab>\")\n      feedkeys(\":Cmd \\<Tab>\", 'xt')\n  END\n  call v9.CheckScriptFailure(lines, 'E121: Undefined variable: this')\n\n  let &rtp = save_rtp\n  call delete('Xdir', 'rf')\nendfunc\n\nfunc Test_fullcommand()\n  let tests = {\n        \\ '':           '',\n        \\ ':':          '',\n        \\ ':::':        '',\n        \\ ':::5':       '',\n        \\ 'not_a_cmd':  '',\n        \\ 'Check':      '',\n        \\ 'syntax':     'syntax',\n        \\ ':syntax':    'syntax',\n        \\ '::::syntax': 'syntax',\n        \\ 'sy':         'syntax',\n        \\ 'syn':        'syntax',\n        \\ 'synt':       'syntax',\n        \\ ':sy':        'syntax',\n        \\ '::::sy':     'syntax',\n        \\ 'match':      'match',\n        \\ '2match':     'match',\n        \\ '3match':     'match',\n        \\ 'aboveleft':  'aboveleft',\n        \\ 'abo':        'aboveleft',\n        \\ 's':          'substitute',\n        \\ '5s':         'substitute',\n        \\ ':5s':        'substitute',\n        \\ \"'<,'>s\":     'substitute',\n        \\ \":'<,'>s\":    'substitute',\n        \\ 'CheckLin':   'CheckLinux',\n        \\ 'CheckLinux': 'CheckLinux',\n  \\ }\n\n  for [in, want] in items(tests)\n    call assert_equal(want, fullcommand(in))\n  endfor\n  call assert_equal('', fullcommand(test_null_string()))\n\n  call assert_equal('syntax', 'syn'->fullcommand())\n\n  command -buffer BufferLocalCommand :\n  command GlobalCommand :\n  call assert_equal('GlobalCommand', fullcommand('GlobalCom'))\n  call assert_equal('BufferLocalCommand', fullcommand('BufferL'))\n  delcommand BufferLocalCommand\n  delcommand GlobalCommand\nendfunc\n\nfunc Test_shellcmd_completion()\n  let save_path = $PATH\n\n  call mkdir('Xpathdir/Xpathsubdir', 'p')\n  call writefile([''], 'Xpathdir/Xfile.exe')\n  call setfperm('Xpathdir/Xfile.exe', 'rwx------')\n\n  \" Set PATH to example directory without trailing slash.\n  let $PATH = getcwd() . '/Xpathdir'\n\n  \" Test for the \":!<TAB>\" case.  Previously, this would include subdirs of\n  \" dirs in the PATH, even though they won't be executed.  We check that only\n  \" subdirs of the PWD and executables from the PATH are included in the\n  \" suggestions.\n  let actual = getcompletion('X', 'shellcmd')\n  let expected = map(filter(glob('*', 0, 1), 'isdirectory(v:val) && v:val[0] == \"X\"'), 'v:val . \"/\"')\n  call insert(expected, 'Xfile.exe')\n  call assert_equal(expected, actual)\n\n  call delete('Xpathdir', 'rf')\n  let $PATH = save_path\nendfunc\n\nfunc Test_expand_star_star()\n  call mkdir('a/b', 'p')\n  call writefile(['asdfasdf'], 'a/b/fileXname')\n  call feedkeys(\":find **/fileXname\\<Tab>\\<CR>\", 'xt')\n  call assert_equal('find a/b/fileXname', @:)\n  bwipe!\n  call delete('a', 'rf')\nendfunc\n\nfunc Test_cmdline_paste()\n  let @a = \"def\"\n  call feedkeys(\":abc \\<C-R>a ghi\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"abc def ghi', @:)\n\n  new\n  call setline(1, 'asdf.x /tmp/some verylongword a;b-c*d ')\n\n  call feedkeys(\":aaa \\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa asdf bbb', @:)\n\n  call feedkeys(\"ft:aaa \\<C-R>\\<C-F> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa /tmp/some bbb', @:)\n\n  call feedkeys(\":aaa \\<C-R>\\<C-L> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa '.getline(1).' bbb', @:)\n\n  set incsearch\n  call feedkeys(\"fy:aaa veryl\\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa verylongword bbb', @:)\n\n  call feedkeys(\"f;:aaa \\<C-R>\\<C-A> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa a;b-c*d bbb', @:)\n\n  call feedkeys(\":\\<C-\\>etoupper(getline(1))\\<CR>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"ASDF.X /TMP/SOME VERYLONGWORD A;B-C*D ', @:)\n  bwipe!\n\n  \" Error while typing a command used to cause that it was not executed\n  \" in the end.\n  new\n  try\n    call feedkeys(\":file \\<C-R>%Xtestfile\\<CR>\", 'tx')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E32/\n    \" ignore error E32\n  endtry\n  call assert_equal(\"Xtestfile\", bufname(\"%\"))\n\n  \" Try to paste an invalid register using <C-R>\n  call feedkeys(\":\\\"one\\<C-R>\\<C-X>two\\<CR>\", 'xt')\n  call assert_equal('\"onetwo', @:)\n\n  \" Test for pasting register containing CTRL-H using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-H>z\"\n  call feedkeys(\":\\\"\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal('\"xz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-O>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n\n  \" Test for pasting register containing CTRL-V using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-V>z\"\n  call feedkeys(\":\\\"\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal('\"xyz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-V>z\", @:)\n\n  call assert_beeps('call feedkeys(\":\\<C-R>=\\<C-R>=\\<Esc>\", \"xt\")')\n\n  bwipe!\nendfunc\n\nfunc Test_cmdline_remove_char()\n  let encoding_save = &encoding\n\n  for e in ['utf8', 'latin1']\n    exe 'set encoding=' . e\n\n    call feedkeys(\":abc def\\<S-Left>\\<Del>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ef', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<BS>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abcdef', @:)\n\n    call feedkeys(\":abc def ghi\\<S-Left>\\<C-W>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ghi', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<C-U>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"def', @:, e)\n\n    \" This was going before the start in latin1.\n    call feedkeys(\": \\<C-W>\\<CR>\", 'tx')\n  endfor\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdline_keymap_ctrl_hat()\n  CheckFeature keymap\n\n  set keymap=esperanto\n  call feedkeys(\":\\\"Jxauxdo \\<C-^>Jxauxdo \\<C-^>Jxauxdo\\<CR>\", 'tx')\n  call assert_equal('\"Jxauxdo \u0134a\u016ddo Jxauxdo', @:)\n  set keymap=\nendfunc\n\nfunc Test_illegal_address1()\n  new\n  2;'(\n  2;')\n  quit\nendfunc\n\nfunc Test_illegal_address2()\n  call writefile(['c', 'x', '  x', '.', '1;y'], 'Xtest.vim')\n  new\n  source Xtest.vim\n  \" Trigger calling validate_cursor()\n  diffsp Xtest.vim\n  quit!\n  bwipe!\n  call delete('Xtest.vim')\nendfunc\n\nfunc Test_mark_from_line_zero()\n  \" this was reading past the end of the first (empty) line\n  new\n  norm oxxxx\n  call assert_fails(\"0;'(\", 'E20:')\n  bwipe!\nendfunc\n\nfunc Test_cmdline_complete_wildoptions()\n  help\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let a = join(sort(split(@:)),' ')\n  set wildoptions=tagfile\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let b = join(sort(split(@:)),' ')\n  call assert_equal(a, b)\n  bw!\nendfunc\n\nfunc Test_cmdline_complete_user_cmd()\n  command! -complete=color -nargs=1 Foo :\n  call feedkeys(\":Foo \\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo a b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo a blue', @:)\n  call feedkeys(\":Foo b\\\\\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\', @:)\n  call feedkeys(\":Foo b\\\\x\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\x', @:)\n  delcommand Foo\nendfunc\n\nfunc s:ScriptLocalFunction()\n  echo 'yes'\nendfunc\n\nfunc Test_cmdline_complete_user_func()\n  call feedkeys(\":func Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func Test_cmdline_complete_user_', @:)\n  call feedkeys(\":func s:ScriptL\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func <SNR>\\d\\+_ScriptLocalFunction', @:)\n\n  \" g: prefix also works\n  call feedkeys(\":echo g:Test_cmdline_complete_user_f\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:Test_cmdline_complete_user_func', @:)\n\n  \" using g: prefix does not result in just \"g:\" matches from a lambda\n  let Fx = { a ->  a }\n  call feedkeys(\":echo g:\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:[A-Z]', @:)\n\n  \" existence of script-local dict function does not break user function name\n  \" completion\n  function s:a_dict_func() dict\n  endfunction\n  call feedkeys(\":call Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"call Test_cmdline_complete_user_', @:)\n  delfunction s:a_dict_func\nendfunc\n\nfunc Test_cmdline_complete_user_names()\n  if has('unix') && executable('whoami')\n    let whoami = systemlist('whoami')[0]\n    let first_letter = whoami[0]\n    if len(first_letter) > 0\n      \" Trying completion of  :e ~x  where x is the first letter of\n      \" the user name should complete to at least the user name.\n      call feedkeys(':e ~' . first_letter . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*\\<' . whoami . '\\>', @:)\n    endif\n  elseif has('win32')\n    \" Just in case: check that the system has an Administrator account.\n    let names = system('net user')\n    if names =~ 'Administrator'\n      \" Trying completion of  :e ~A  should complete to Administrator.\n      \" There could be other names starting with \"A\" before Administrator.\n      call feedkeys(':e ~A' . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*Administrator', @:)\n    endif\n  else\n    throw 'Skipped: does not work on this platform'\n  endif\nendfunc\n\nfunc Test_cmdline_complete_bang()\n  CheckExecutable whoami\n  call feedkeys(\":!whoam\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('^\".*\\<whoami\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_languages()\n  let lang = substitute(execute('language time'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lc_time)\n\n  let lang = substitute(execute('language ctype'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:ctype)\n\n  let lang = substitute(execute('language collate'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:collate)\n\n  let lang = substitute(execute('language messages'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lang)\n\n  call feedkeys(\":language \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<collate\\>.*\\<ctype\\>.*\\<messages\\>.*\\<time\\>', @:)\n\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language messages \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language ctype \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language time \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language collate \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_env_variable()\n  let $X_VIM_TEST_COMPLETE_ENV = 'foo'\n  call feedkeys(\":edit $X_VIM_TEST_COMPLETE_E\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"edit $X_VIM_TEST_COMPLETE_ENV', @:)\n  unlet $X_VIM_TEST_COMPLETE_ENV\nendfunc\n\nfunc Test_cmdline_complete_expression()\n  let g:SomeVar = 'blah'\n  for cmd in ['exe', 'echo', 'echon', 'echomsg']\n    call feedkeys(\":\" .. cmd .. \" SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' SomeVar', @:)\n    call feedkeys(\":\" .. cmd .. \" foo SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' foo SomeVar', @:)\n  endfor\n  unlet g:SomeVar\nendfunc\n\n\" Unique function name for completion below\nfunc s:WeirdFunc()\n  echo 'weird'\nendfunc\n\n\" Test for various command-line completion\nfunc Test_cmdline_complete_various()\n  \" completion for a command starting with a comment\n  call feedkeys(\": :|\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\" :|\\\"\\<C-A>\", @:)\n\n  \" completion for a range followed by a comment\n  call feedkeys(\":1,2\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"1,2\\\"\\<C-A>\", @:)\n\n  \" completion for :k command\n  call feedkeys(\":ka\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ka\\<C-A>\", @:)\n\n  \" completion for short version of the :s command\n  call feedkeys(\":sI \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"sI \\<C-A>\", @:)\n\n  \" completion for :write command\n  call mkdir('Xdir')\n  call writefile(['one'], 'Xdir/Xfile1')\n  let save_cwd = getcwd()\n  cd Xdir\n  call feedkeys(\":w >> \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w >> Xfile1\", @:)\n  call chdir(save_cwd)\n  call delete('Xdir', 'rf')\n\n  \" completion for :w ! and :r ! commands\n  call feedkeys(\":w !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w !invalid_xyz_cmd\", @:)\n  call feedkeys(\":r !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"r !invalid_xyz_cmd\", @:)\n\n  \" completion for :>> and :<< commands\n  call feedkeys(\":>>>\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\">>>\\<C-A>\", @:)\n  call feedkeys(\":<<<\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"<<<\\<C-A>\", @:)\n\n  \" completion for command with +cmd argument\n  call feedkeys(\":buffer +/pat Xabc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat Xabc\", @:)\n  call feedkeys(\":buffer +/pat\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat\\<C-A>\", @:)\n\n  \" completion for a command with a trailing comment\n  call feedkeys(\":ls \\\" comment\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\\" comment\\<C-A>\", @:)\n\n  \" completion for a command with a trailing command\n  call feedkeys(\":ls | ls\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls | ls\", @:)\n\n  \" completion for a command with an CTRL-V escaped argument\n  call feedkeys(\":ls \\<C-V>\\<C-V>a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\<C-V>a\\<C-A>\", @:)\n\n  \" completion for a command that doesn't take additional arguments\n  call feedkeys(\":all abc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"all abc\\<C-A>\", @:)\n\n  \" completion for a command with a command modifier\n  call feedkeys(\":topleft new\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"topleft new\", @:)\n\n  \" completion for vim9 and legacy commands\n  call feedkeys(\":vim9 call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"vim9 call strlen(\", @:)\n  call feedkeys(\":legac call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"legac call strlen(\", @:)\n\n  \" completion for the :disassemble command\n  call feedkeys(\":disas deb\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug\", @:)\n  call feedkeys(\":disas pro\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile\", @:)\n  call feedkeys(\":disas debug Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas profile Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas Test_cmdline_complete_various\", @:)\n\n  call feedkeys(\":disas s:WeirdF\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_WeirdFunc', @:)\n\n  call feedkeys(\":disas \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_', @:)\n  call feedkeys(\":disas debug \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas debug <SNR>\\d\\+_', @:)\n\n  \" completion for the :match command\n  call feedkeys(\":match Search /pat/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"match Search /pat/\\<C-A>\", @:)\n\n  \" completion for the :doautocmd command\n  call feedkeys(\":doautocmd User MyCmd a.c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd User MyCmd a.c\\<C-A>\", @:)\n\n  \" completion of autocmd group after comma\n  call feedkeys(\":doautocmd BufNew,BufEn\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufNew,BufEnter\", @:)\n\n  \" completion of file name in :doautocmd\n  call writefile([], 'Xfile1')\n  call writefile([], 'Xfile2')\n  call feedkeys(\":doautocmd BufEnter Xfi\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufEnter Xfile1 Xfile2\", @:)\n  call delete('Xfile1')\n  call delete('Xfile2')\n\n  \" completion for the :augroup command\n  augroup XTest.test\n  augroup END\n  call feedkeys(\":augroup X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"augroup XTest.test\", @:)\n\n  \" group name completion in :autocmd\n  call feedkeys(\":au X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n  call feedkeys(\":au XTest.test\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n\n  augroup! XTest.test\n\n  \" autocmd pattern completion\n  call feedkeys(\":au BufEnter *.py\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au BufEnter *.py\\t\", @:)\n\n  \" completion for the :unlet command\n  call feedkeys(\":unlet one two\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"unlet one two\", @:)\n\n  \" completion for the :buffer command with curlies\n  \" FIXME: what should happen on MS-Windows?\n  if !has('win32')\n    edit \\{someFile}\n    call feedkeys(\":buf someFile\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"buf {someFile}\", @:)\n    bwipe {someFile}\n  endif\n\n  \" completion for the :bdelete command\n  call feedkeys(\":bdel a b c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"bdel a b c\", @:)\n\n  \" completion for the :mapclear command\n  call feedkeys(\":mapclear \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"mapclear <buffer>\", @:)\n\n  \" completion for user defined commands with menu names\n  menu Test.foo :ls<CR>\n  com -nargs=* -complete=menu MyCmd\n  call feedkeys(\":MyCmd Te\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd Test.', @:)\n  delcom MyCmd\n  unmenu Test\n\n  \" completion for user defined commands with mappings\n  mapclear\n  map <F3> :ls<CR>\n  com -nargs=* -complete=mapping MyCmd\n  call feedkeys(\":MyCmd <F\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd <F3> <F4>', @:)\n  mapclear\n  delcom MyCmd\n\n  \" completion for :set path= with multiple backslashes\n  call feedkeys(\":set path=a\\\\\\\\\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set path=a\\\\\\ b', @:)\n\n  \" completion for :set dir= with a backslash\n  call feedkeys(\":set dir=a\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set dir=a\\ b', @:)\n\n  \" completion for the :py3 commands\n  call feedkeys(\":py3\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3 py3do py3file', @:)\n\n  \" completion for the :vim9 commands\n  call feedkeys(\":vim9\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"vim9cmd vim9script', @:)\n\n  \" redir @\" is not the start of a comment. So complete after that\n  call feedkeys(\":redir @\\\" | cwin\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"redir @\" | cwindow', @:)\n\n  \" completion after a backtick\n  call feedkeys(\":e `a1b2c\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e `a1b2c', @:)\n\n  \" completion for :language command with an invalid argument\n  call feedkeys(\":language dummy \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"language dummy \\t\", @:)\n\n  \" completion for commands after a :global command\n  call feedkeys(\":g/a\\\\xb/clearj\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n\n  \" completion with ambiguous user defined commands\n  com TCmd1 echo 'TCmd1'\n  com TCmd2 echo 'TCmd2'\n  call feedkeys(\":TCmd \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"TCmd ', @:)\n  delcom TCmd1\n  delcom TCmd2\n\n  \" completion after a range followed by a pipe (|) character\n  call feedkeys(\":1,10 | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"1,10 | chistory', @:)\n\n  \" completion after a :global command\n  call feedkeys(\":g/a/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a/chistory', @:)\n  call feedkeys(\":g/a\\\\/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"g/a\\\\/chist\\t\", @:)\n\n  \" use <Esc> as the 'wildchar' for completion\n  set wildchar=<Esc>\n  call feedkeys(\":g/a\\\\xb/clearj\\<Esc>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  \" pressing <esc> twice should cancel the command\n  call feedkeys(\":chist\\<Esc>\\<Esc>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  set wildchar&\n\n  if has('unix')\n    \" should be able to complete a file name that starts with a '~'.\n    call writefile([], '~Xtest')\n    call feedkeys(\":e \\\\~X\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\~Xtest', @:)\n    call delete('~Xtest')\n\n    \" should be able to complete a file name that has a '*'\n    call writefile([], 'Xx*Yy')\n    call feedkeys(\":e Xx\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xx\\*Yy', @:)\n    call delete('Xx*Yy')\n\n    \" use a literal star\n    call feedkeys(\":e \\\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\*', @:)\n  endif\n\n  call feedkeys(\":py3f\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3file', @:)\nendfunc\n\n\" Test for 'wildignorecase'\nfunc Test_cmdline_wildignorecase()\n  CheckUnix\n  call writefile([], 'XTEST')\n  set wildignorecase\n  call feedkeys(\":e xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e XTEST', @:)\n  call assert_equal(['XTEST'], getcompletion('xt', 'file'))\n  let g:Sline = ''\n  call feedkeys(\":e xt\\<C-d>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e xt', @:)\n  call assert_equal('XTEST', g:Sline)\n  set wildignorecase&\n  call delete('XTEST')\nendfunc\n\nfunc Test_cmdline_write_alternatefile()\n  new\n  call setline('.', ['one', 'two'])\n  f foo.txt\n  new\n  f #-A\n  call assert_equal('foo.txt-A', expand('%'))\n  f #<-B.txt\n  call assert_equal('foo-B.txt', expand('%'))\n  f %<\n  call assert_equal('foo-B', expand('%'))\n  new\n  call assert_fails('f #<', 'E95:')\n  bw!\n  f foo-B.txt\n  f %<-A\n  call assert_equal('foo-B-A', expand('%'))\n  bw!\n  bw!\nendfunc\n\n\" using a leading backslash here\nset cpo+=C\n\nfunc Test_cmdline_search_range()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  /d\n  1,\\/s/b/B/\n  call assert_equal('B', getline(2))\n\n  /a\n  $\n  \\?,4s/c/C/\n  call assert_equal('C', getline(3))\n\n  call setline(1, ['a', 'b', 'c', 'd'])\n  %s/c/c/\n  1,\\&s/b/B/\n  call assert_equal('B', getline(2))\n\n  let @/ = 'apple'\n  call assert_fails('\\/print', ['E486:.*apple'])\n\n  bwipe!\nendfunc\n\n\" Test for the tick mark (') in an excmd range\nfunc Test_tick_mark_in_range()\n  \" If only the tick is passed as a range and no command is specified, there\n  \" should not be an error\n  call feedkeys(\":'\\<CR>\", 'xt')\n  call assert_equal(\"'\", @:)\n  call assert_fails(\"',print\", 'E78:')\nendfunc\n\n\" Test for using a line number followed by a search pattern as range\nfunc Test_lnum_and_pattern_as_range()\n  new\n  call setline(1, ['foo 1', 'foo 2', 'foo 3'])\n  let @\" = ''\n  2/foo/yank\n  call assert_equal(\"foo 3\\n\", @\")\n  call assert_equal(1, line('.'))\n  close!\nendfunc\n\n\" Tests for getcmdline(), getcmdpos() and getcmdtype()\nfunc Check_cmdline(cmdtype)\n  call assert_equal('MyCmd a', getcmdline())\n  call assert_equal(8, getcmdpos())\n  call assert_equal(a:cmdtype, getcmdtype())\n  return ''\nendfunc\n\nset cpo&\n\nfunc Test_getcmdtype()\n  call feedkeys(\":MyCmd a\\<C-R>=Check_cmdline(':')\\<CR>\\<Esc>\", \"xt\")\n\n  let cmdtype = ''\n  debuggreedy\n  call feedkeys(\":debug echo 'test'\\<CR>\", \"t\")\n  call feedkeys(\"let cmdtype = \\<C-R>=string(getcmdtype())\\<CR>\\<CR>\", \"t\")\n  call feedkeys(\"cont\\<CR>\", \"xt\")\n  0debuggreedy\n  call assert_equal('>', cmdtype)\n\n  call feedkeys(\"/MyCmd a\\<C-R>=Check_cmdline('/')\\<CR>\\<Esc>\", \"xt\")\n  call feedkeys(\"?MyCmd a\\<C-R>=Check_cmdline('?')\\<CR>\\<Esc>\", \"xt\")\n\n  call feedkeys(\":call input('Answer?')\\<CR>\", \"t\")\n  call feedkeys(\"MyCmd a\\<C-R>=Check_cmdline('@')\\<CR>\\<C-C>\", \"xt\")\n\n  call feedkeys(\":insert\\<CR>MyCmd a\\<C-R>=Check_cmdline('-')\\<CR>\\<Esc>\", \"xt\")\n\n  cnoremap <expr> <F6> Check_cmdline('=')\n  call feedkeys(\"a\\<C-R>=MyCmd a\\<F6>\\<Esc>\\<Esc>\", \"xt\")\n  cunmap <F6>\n\n  call assert_equal('', getcmdline())\nendfunc\n\nfunc Test_getcmdwintype()\n  CheckFeature cmdwin\n\n  call feedkeys(\"q/:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('/', a)\n\n  call feedkeys(\"q?:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('?', a)\n\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call feedkeys(\":\\<C-F>:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call assert_equal('', getcmdwintype())\nendfunc\n\nfunc Test_getcmdwin_autocmd()\n  CheckFeature cmdwin\n\n  let s:seq = []\n  augroup CmdWin\n  au WinEnter * call add(s:seq, 'WinEnter ' .. win_getid())\n  au WinLeave * call add(s:seq, 'WinLeave ' .. win_getid())\n  au BufEnter * call add(s:seq, 'BufEnter ' .. bufnr())\n  au BufLeave * call add(s:seq, 'BufLeave ' .. bufnr())\n  au CmdWinEnter * call add(s:seq, 'CmdWinEnter ' .. win_getid())\n  au CmdWinLeave * call add(s:seq, 'CmdWinLeave ' .. win_getid())\n\n  let org_winid = win_getid()\n  let org_bufnr = bufnr()\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:let s:cmd_winid = win_getid()\\<CR>:let s:cmd_bufnr = bufnr()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n  call assert_equal([\n\t\\ 'WinLeave ' .. org_winid,\n\t\\ 'WinEnter ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. org_bufnr,\n\t\\ 'BufEnter ' .. s:cmd_bufnr,\n\t\\ 'CmdWinEnter ' .. s:cmd_winid,\n\t\\ 'CmdWinLeave ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. s:cmd_bufnr,\n\t\\ 'WinLeave ' .. s:cmd_winid,\n\t\\ 'WinEnter ' .. org_winid,\n\t\\ 'BufEnter ' .. org_bufnr,\n\t\\ ], s:seq)\n\n  au!\n  augroup END\nendfunc\n\nfunc Test_verbosefile()\n  set verbosefile=Xlog\n  echomsg 'foo'\n  echomsg 'bar'\n  set verbosefile=\n  let log = readfile('Xlog')\n  call assert_match(\"foo\\nbar\", join(log, \"\\n\"))\n  call delete('Xlog')\n  call mkdir('Xdir')\n  call assert_fails('set verbosefile=Xdir', ['E484:.*Xdir', 'E474:'])\n  call delete('Xdir', 'd')\nendfunc\n\nfunc Test_verbose_option()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    command DoSomething echo 'hello' |set ts=4 |let v = '123' |echo v\n    call feedkeys(\"\\r\", 't') \" for the hit-enter prompt\n    set verbose=20\n  [SCRIPT]\n  call writefile(lines, 'XTest_verbose')\n\n  let buf = RunVimInTerminal('-S XTest_verbose', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":DoSomething\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_verbose_option_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_verbose')\nendfunc\n\nfunc Test_setcmdpos()\n  func InsertTextAtPos(text, pos)\n    call assert_equal(0, setcmdpos(a:pos))\n    return a:text\n  endfunc\n\n  \" setcmdpos() with position in the middle of the command line.\n  call feedkeys(\":\\\"12\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1ab2', @:)\n\n  call feedkeys(\":\\\"12\\<C-R>\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1b2a', @:)\n\n  \" setcmdpos() with position beyond the end of the command line.\n  call feedkeys(\":\\\"12\\<C-B>\\<C-R>=InsertTextAtPos('a', 10)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"12ab', @:)\n\n  \" setcmdpos() returns 1 when not editing the command line.\n  call assert_equal(1, 3->setcmdpos())\nendfunc\n\nfunc Test_cmdline_overstrike()\n  let encodings = ['latin1', 'utf8']\n  let encoding_save = &encoding\n\n  for e in encodings\n    exe 'set encoding=' . e\n\n    \" Test overstrike in the middle of the command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cd4', @:, e)\n\n    \" Test overstrike going beyond end of command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cdefgh\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cdefgh', @:, e)\n\n    \" Test toggling insert/overstrike a few times.\n    call feedkeys(\":\\\"01234\\<home>\\<right>ab\\<right>\\<insert>cd\\<right>\\<insert>ef\\<enter>\", 'xt')\n    call assert_equal('\"ab0cd3ef4', @:, e)\n  endfor\n\n  \" Test overstrike with multi-byte characters.\n  call feedkeys(\":\\\"\u30c6\u30ad\u30b9\u30c8\u30a8\u30c7\u30a3\u30bf\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n  call assert_equal('\"\u30c6ab\u30adcd\u30a8\u30c7\u30a3\u30bf', @:, e)\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdwin_bug()\n  CheckFeature cmdwin\n\n  let winid = win_getid()\n  sp\n  try\n    call feedkeys(\"q::call win_gotoid(\" .. winid .. \")\\<CR>:q\\<CR>\", 'x!')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E11/\n  endtry\n  bw!\nendfunc\n\nfunc Test_cmdwin_restore()\n  CheckFeature cmdwin\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    augroup vimHints | au! | augroup END\n    call setline(1, range(30))\n    2split\n  [SCRIPT]\n  call writefile(lines, 'XTest_restore')\n\n  let buf = RunVimInTerminal('-S XTest_restore', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"q:\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_1', {})\n\n  \" normal restore\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_2', {})\n\n  \" restore after setting 'lines' with one window\n  call term_sendkeys(buf, \":close\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":set lines=18\\<CR>\")\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_3', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_restore')\nendfunc\n\nfunc Test_cmdwin_no_terminal()\n  CheckFeature cmdwin\n  CheckFeature terminal\n  CheckNotMSWindows\n\n  let buf = RunVimInTerminal('', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":set cmdheight=2\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":let buf = term_start(['/bin/echo'], #{hidden: 1})\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_no_terminal', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_buffers_lastused()\n  \" check that buffers are sorted by time when wildmode has lastused\n  call test_settime(1550020000)\t  \" middle\n  edit bufa\n  enew\n  call test_settime(1550030000)\t  \" newest\n  edit bufb\n  enew\n  call test_settime(1550010000)\t  \" oldest\n  edit bufc\n  enew\n  call test_settime(0)\n  enew\n\n  call assert_equal(['bufa', 'bufb', 'bufc'],\n\t\\ getcompletion('', 'buffer'))\n\n  let save_wildmode = &wildmode\n  set wildmode=full:lastused\n\n  let cap = \"\\<c-r>=execute('let X=getcmdline()')\\<cr>\"\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  edit other\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  let &wildmode = save_wildmode\n\n  bwipeout bufa\n  bwipeout bufb\n  bwipeout bufc\nendfunc\n\nfunc Test_cmdwin_feedkeys()\n  CheckFeature cmdwin\n\n  \" This should not generate E488\n  call feedkeys(\"q:\\<CR>\", 'x')\n  \" Using feedkeys with q: only should automatically close the cmd window\n  call feedkeys('q:', 'xt')\n  call assert_equal(1, winnr('$'))\n  call assert_equal('', getcmdwintype())\nendfunc\n\n\" Tests for the issues fixed in 7.4.441.\n\" When 'cedit' is set to Ctrl-C, opening the command window hangs Vim\nfunc Test_cmdwin_cedit()\n  CheckFeature cmdwin\n\n  exe \"set cedit=\\<C-c>\"\n  normal! :\n  call assert_equal(1, winnr('$'))\n\n  let g:cmd_wintype = ''\n  func CmdWinType()\n      let g:cmd_wintype = getcmdwintype()\n      let g:wintype = win_gettype()\n      return ''\n  endfunc\n\n  call feedkeys(\"\\<C-c>a\\<C-R>=CmdWinType()\\<CR>\\<CR>\")\n  echo input('')\n  call assert_equal('@', g:cmd_wintype)\n  call assert_equal('command', g:wintype)\n\n  set cedit&vim\n  delfunc CmdWinType\nendfunc\n\n\" Test for CmdwinEnter autocmd\nfunc Test_cmdwin_autocmd()\n  CheckFeature cmdwin\n\n  augroup CmdWin\n    au!\n    autocmd BufLeave * if &buftype == '' | update | endif\n    autocmd CmdwinEnter * startinsert\n  augroup END\n\n  call assert_fails('call feedkeys(\"q:xyz\\<CR>\", \"xt\")', 'E492:')\n  call assert_equal('xyz', @:)\n\n  augroup CmdWin\n    au!\n  augroup END\n  augroup! CmdWin\nendfunc\n\nfunc Test_cmdlineclear_tabenter()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    call setline(1, range(30))\n  [SCRIPT]\n\n  call writefile(lines, 'XtestCmdlineClearTabenter')\n  let buf = RunVimInTerminal('-S XtestCmdlineClearTabenter', #{rows: 10})\n  call TermWait(buf, 25)\n  \" in one tab make the command line higher with CTRL-W -\n  call term_sendkeys(buf, \":tabnew\\<cr>\\<C-w>-\\<C-w>-gtgt\")\n  call VerifyScreenDump(buf, 'Test_cmdlineclear_tabenter', {})\n\n  call StopVimInTerminal(buf)\n  call delete('XtestCmdlineClearTabenter')\nendfunc\n\n\" Test for expanding special keywords in cmdline\nfunc Test_cmdline_expand_special()\n  %bwipe!\n  call assert_fails('e #', 'E194:')\n  call assert_fails('e <afile>', 'E495:')\n  call assert_fails('e <abuf>', 'E496:')\n  call assert_fails('e <amatch>', 'E497:')\n\n  call writefile([], 'Xfile.cpp')\n  call writefile([], 'Xfile.java')\n  new Xfile.cpp\n  call feedkeys(\":e %:r\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.cpp Xfile.java', @:)\n  close\n  call delete('Xfile.cpp')\n  call delete('Xfile.java')\nendfunc\n\nfunc Test_cmdwin_jump_to_win()\n  CheckFeature cmdwin\n\n  call assert_fails('call feedkeys(\"q:\\<C-W>\\<C-W>\\<CR>\", \"xt\")', 'E11:')\n  new\n  set modified\n  call assert_fails('call feedkeys(\"q/:qall\\<CR>\", \"xt\")', ['E37:', 'E162:'])\n  close!\n  call feedkeys(\"q/:close\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n  call feedkeys(\"q/:exit\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n\n  \" opening command window twice should fail\n  call assert_beeps('call feedkeys(\"q:q:\\<CR>\\<CR>\", \"xt\")')\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_tabpage()\n  tabedit\n  call assert_fails(\"silent norm q/g\t:I\\<Esc>\", 'E11:')\n  tabclose!\nendfunc\n\nfunc Test_cmdwin_interrupted()\n  CheckFeature cmdwin\n  CheckScreendump\n\n  \" aborting the :smile output caused the cmdline window to use the current\n  \" buffer.\n  let lines =<< trim [SCRIPT]\n    au WinNew * smile\n  [SCRIPT]\n  call writefile(lines, 'XTest_cmdwin')\n\n  let buf = RunVimInTerminal('-S XTest_cmdwin', {'rows': 18})\n  \" open cmdwin\n  call term_sendkeys(buf, \"q:\")\n  call WaitForAssert({-> assert_match('-- More --', term_getline(buf, 18))})\n  \" quit more prompt for :smile command\n  call term_sendkeys(buf, \"q\")\n  call WaitForAssert({-> assert_match('^$', term_getline(buf, 18))})\n  \" execute a simple command\n  call term_sendkeys(buf, \"aecho 'done'\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_interrupted', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_cmdwin')\nendfunc\n\n\" Test for backtick expression in the command line\nfunc Test_cmd_backtick()\n  %argd\n  argadd `=['a', 'b', 'c']`\n  call assert_equal(['a', 'b', 'c'], argv())\n  %argd\n\n  argadd `echo abc def`\n  call assert_equal(['abc def'], argv())\n  %argd\nendfunc\n\n\" Test for the :! command\nfunc Test_cmd_bang()\n  CheckUnix\n\n  let lines =<< trim [SCRIPT]\n    \" Test for no previous command\n    call assert_fails('!!', 'E34:')\n    set nomore\n    \" Test for cmdline expansion with :!\n    call setline(1, 'foo!')\n    silent !echo <cWORD> > Xfile.out\n    call assert_equal(['foo!'], readfile('Xfile.out'))\n    \" Test for using previous command\n    silent !echo \\! !\n    call assert_equal(['! echo foo!'], readfile('Xfile.out'))\n    call writefile(v:errors, 'Xresult')\n    call delete('Xfile.out')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test error: \"E135: *Filter* Autocommands must not change current buffer\"\nfunc Test_cmd_bang_E135()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  augroup test_cmd_filter_E135\n    au!\n    autocmd FilterReadPost * help\n  augroup END\n  call assert_fails('2,3!echo \"x\"', 'E135:')\n\n  augroup test_cmd_filter_E135\n    au!\n  augroup END\n  %bwipe!\nendfunc\n\n\" Test for using ~ for home directory in cmdline completion matches\nfunc Test_cmdline_expand_home()\n  call mkdir('Xdir')\n  call writefile([], 'Xdir/Xfile1')\n  call writefile([], 'Xdir/Xfile2')\n  cd Xdir\n  let save_HOME = $HOME\n  let $HOME = getcwd()\n  call feedkeys(\":e ~/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ~/Xfile1 ~/Xfile2', @:)\n  let $HOME = save_HOME\n  cd ..\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for using CTRL-\\ CTRL-G in the command line to go back to normal mode\n\" or insert mode (when 'insertmode' is set)\nfunc Test_cmdline_ctrl_g()\n  new\n  call setline(1, 'abc')\n  call cursor(1, 3)\n  \" If command line is entered from insert mode, using C-\\ C-G should back to\n  \" insert mode\n  call feedkeys(\"i\\<C-O>:\\<C-\\>\\<C-G>xy\", 'xt')\n  call assert_equal('abxyc', getline(1))\n  call assert_equal(4, col('.'))\n\n  \" If command line is entered in 'insertmode', using C-\\ C-G should back to\n  \" 'insertmode'\n  call feedkeys(\":set im\\<cr>\\<C-L>:\\<C-\\>\\<C-G>12\\<C-L>:set noim\\<cr>\", 'xt')\n  call assert_equal('ab12xyc', getline(1))\n  close!\nendfunc\n\n\" Test for 'wildmode'\nfunc Wildmode_tests()\n  func T(a, c, p)\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n\n  set nowildmenu\n  set wildmode=full,list\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd oneA', @:)\n\n  set wildmode=longest,full\n  call feedkeys(\":MyCmd o\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n  call feedkeys(\":MyCmd o\\t\\t\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneC', @:)\n\n  set wildmode=longest\n  call feedkeys(\":MyCmd one\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=list:longest\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=\"\"\n  call feedkeys(\":MyCmd \\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA', @:)\n\n  \" Test for wildmode=longest with 'fileignorecase' set\n  set wildmode=longest\n  set fileignorecase\n  argadd AAA AAAA AAAAA\n  call feedkeys(\":buffer a\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"buffer AAA', @:)\n  set fileignorecase&\n\n  \" Test for listing files with wildmode=list\n  set wildmode=list\n  let g:Sline = ''\n  call feedkeys(\":b A\\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('AAA    AAAA   AAAAA', g:Sline)\n  call assert_equal('\"b A', @:)\n\n  \" when using longest completion match, matches shorter than the argument\n  \" should be ignored (happens with :help)\n  set wildmode=longest,full\n  set wildmenu\n  call feedkeys(\":help a*\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"help a', @:)\n  \" non existing file\n  call feedkeys(\":e a1b2y3z4\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e a1b2y3z4', @:)\n  set wildmenu&\n\n  \" Test for longest file name completion with 'fileignorecase'\n  \" On MS-Windows, file names are case insensitive.\n  if has('unix')\n    call writefile([], 'XTESTfoo')\n    call writefile([], 'Xtestbar')\n    set nofileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e XTESTfoo', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtestbar', @:)\n    set fileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    set fileignorecase&\n    call delete('XTESTfoo')\n    call delete('Xtestbar')\n  endif\n\n  %argdelete\n  delcommand MyCmd\n  delfunc T\n  set wildmode&\n  %bwipe!\nendfunc\n\nfunc Test_wildmode()\n  \" Test with utf-8 encoding\n  call Wildmode_tests()\n\n  \" Test with latin1 encoding\n  let save_encoding = &encoding\n  set encoding=latin1\n  call Wildmode_tests()\n  let &encoding = save_encoding\nendfunc\n\nfunc Test_custom_complete_autoload()\n  call mkdir('Xdir/autoload', 'p')\n  let save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  let lines =<< trim END\n      func vim8#Complete(a, c, p)\n        return \"oneA\\noneB\\noneC\"\n      endfunc\n  END\n  call writefile(lines, 'Xdir/autoload/vim8.vim')\n\n  command -nargs=1 -complete=custom,vim8#Complete MyCmd\n  set nowildmenu\n  set wildmode=full,list\n  call feedkeys(\":MyCmd \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA oneB oneC', @:)\n\n  let &rtp = save_rtp\n  set wildmode& wildmenu&\n  delcommand MyCmd\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for interrupting the command-line completion\nfunc Test_interrupt_compl()\n  func F(lead, cmdl, p)\n    if a:lead =~ 'tw'\n      call interrupt()\n      return\n    endif\n    return \"one\\ntwo\\nthree\"\n  endfunc\n  command -nargs=1 -complete=custom,F Tcmd\n\n  set nowildmenu\n  set wildmode=full\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<C-d>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  delcommand Tcmd\n  delfunc F\n  set wildmode&\nendfunc\n\n\" Test for moving the cursor on the : command line\nfunc Test_cmdline_edit()\n  let str = \":one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Left>five\\<Right>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Left>one \"\n  let str ..= \"\\<C-Right> three\"\n  let str ..= \"\\<End>\\<S-Left>four \"\n  let str ..= \"\\<S-Right> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call feedkeys(str, 'xt')\n  call assert_equal(\"\\\"one two three four five six seven\", @:)\nendfunc\n\n\" Test for moving the cursor on the / command line in 'rightleft' mode\nfunc Test_cmdline_edit_rightleft()\n  CheckFeature rightleft\n  set rightleft\n  set rightleftcmd=search\n  let str = \"/one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Right>five\\<Left>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Right>one \"\n  let str ..= \"\\<C-Left> three\"\n  let str ..= \"\\<End>\\<S-Right>four \"\n  let str ..= \"\\<S-Left> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call assert_fails(\"call feedkeys(str, 'xt')\", 'E486:')\n  call assert_equal(\"\\\"one two three four five six seven\", @/)\n  set rightleftcmd&\n  set rightleft&\nendfunc\n\n\" Test for using <C-\\>e in the command line to evaluate an expression\nfunc Test_cmdline_expr()\n  \" Evaluate an expression from the beginning of a command line\n  call feedkeys(\":abc\\<C-B>\\<C-\\>e\\\"\\\\\\\"hello\\\"\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"hello', @:)\n\n  \" Use an invalid expression for <C-\\>e\n  call assert_beeps('call feedkeys(\":\\<C-\\>einvalid\\<CR>\", \"tx\")')\n\n  \" Insert literal <CTRL-\\> in the command line\n  call feedkeys(\":\\\"e \\<C-\\>\\<C-Y>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"e \\<C-\\>\\<C-Y>\", @:)\nendfunc\n\n\" This was making the insert position negative\nfunc Test_cmdline_expr_register()\n  exe \"sil! norm! ?\\<C-\\>e0\\<C-R>0\\<Esc>?\\<C-\\>e0\\<CR>\"\nendfunc\n\n\" Test for 'imcmdline' and 'imsearch'\n\" This test doesn't actually test the input method functionality.\nfunc Test_cmdline_inputmethod()\n  new\n  call setline(1, ['', 'abc', ''])\n  set imcmdline\n\n  call feedkeys(\":\\\"abc\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\":\\\"\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  set imsearch=2\n  call cursor(1, 1)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call cursor(1, 1)\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable&\n  set imsearch&\n\n  set imcmdline&\n  %bwipe!\nendfunc\n\n\" Test for recursively getting multiple command line inputs\nfunc Test_cmdwin_multi_input()\n  CheckFeature cmdwin\n\n  call feedkeys(\":\\<C-R>=input('P: ')\\<CR>\\\"cyan\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"cyan', @:)\nendfunc\n\n\" Test for using CTRL-_ in the command line with 'allowrevins'\nfunc Test_cmdline_revins()\n  CheckNotMSWindows\n  CheckFeature rightleft\n  call feedkeys(\":\\\"abc\\<c-_>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"abc\\<c-_>\", @:)\n  set allowrevins\n  call feedkeys(\":\\\"abc\\<c-_>xyz\\<c-_>\\<CR>\", 'xt')\n  call assert_equal('\"abc\u00f1\u00e8\u00e6', @:)\n  set allowrevins&\nendfunc\n\n\" Test for typing UTF-8 composing characters in the command line\nfunc Test_cmdline_composing_chars()\n  call feedkeys(\":\\\"\\<C-V>u3046\\<C-V>u3099\\<CR>\", 'xt')\n  call assert_equal('\"\u3046\u3099', @:)\nendfunc\n\n\" Test for normal mode commands not supported in the cmd window\nfunc Test_cmdwin_blocked_commands()\n  CheckFeature cmdwin\n\n  call assert_fails('call feedkeys(\"q:\\<C-T>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-]>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-^>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Q\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<F1>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>s\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>v\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>^\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>n\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>o\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>w\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>j\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>k\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>h\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>l\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>T\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>x\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>r\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>R\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>K\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>}\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>]\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>f\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>d\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>g\\<CR>\", \"xt\")', 'E11:')\nendfunc\n\n\" Close the Cmd-line window in insert mode using CTRL-C\nfunc Test_cmdwin_insert_mode_close()\n  CheckFeature cmdwin\n\n  %bw!\n  let s = ''\n  exe \"normal q:a\\<C-C>let s='Hello'\\<CR>\"\n  call assert_equal('Hello', s)\n  call assert_equal(1, winnr('$'))\nendfunc\n\n\" test that \";\" works to find a match at the start of the first line\nfunc Test_zero_line_search()\n  new\n  call setline(1, [\"1, pattern\", \"2, \", \"3, pattern\"])\n  call cursor(1,1)\n  0;/pattern/d\n  call assert_equal([\"2, \", \"3, pattern\"], getline(1,'$'))\n  q!\nendfunc\n\nfunc Test_read_shellcmd()\n  CheckUnix\n  if executable('ls')\n    \" There should be ls in the $PATH\n    call feedkeys(\":r! l\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_match('^\"r! .*\\<ls\\>', @:)\n  endif\n\n  if executable('rm')\n    call feedkeys(\":r! ++enc=utf-8 r\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r!.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r!.*\\<rm\\>', @:)\n\n    call feedkeys(\":r ++enc=utf-8 !rm\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r ++enc\\S\\+ !.*\\<rm\\>', @:)\n  endif\nendfunc\n\n\" Test for going up and down the directory tree using 'wildmenu'\nfunc Test_wildmenu_dirstack()\n  CheckUnix\n  %bw!\n  call mkdir('Xdir1/dir2/dir3/dir4', 'p')\n  call writefile([], 'Xdir1/file1_1.txt')\n  call writefile([], 'Xdir1/file1_2.txt')\n  call writefile([], 'Xdir1/dir2/file2_1.txt')\n  call writefile([], 'Xdir1/dir2/file2_2.txt')\n  call writefile([], 'Xdir1/dir2/dir3/file3_1.txt')\n  call writefile([], 'Xdir1/dir2/dir3/file3_2.txt')\n  call writefile([], 'Xdir1/dir2/dir3/dir4/file4_1.txt')\n  call writefile([], 'Xdir1/dir2/dir3/dir4/file4_2.txt')\n  set wildmenu\n\n  cd Xdir1/dir2/dir3/dir4\n  call feedkeys(\":e \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e file4_1.txt', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../../dir2/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/file4_1.txt', @:)\n  cd -\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xdir1/dir2/dir3/dir4/file4_1.txt', @:)\n\n  call delete('Xdir1', 'rf')\n  set wildmenu&\nendfunc\n\n\" Test for recalling newer or older cmdline from history with <Up>, <Down>,\n\" <S-Up>, <S-Down>, <PageUp>, <PageDown>, <kPageUp>, <kPageDown>, <C-p>, or\n\" <C-n>.\nfunc Test_recalling_cmdline()\n  CheckFeature cmdline_hist\n\n  let g:cmdlines = []\n  cnoremap <Plug>(save-cmdline) <Cmd>let g:cmdlines += [getcmdline()]<CR>\n\n  let histories = [\n  \\  #{name: 'cmd',    enter: ':',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'search', enter: '/',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'expr',   enter: \":\\<C-r>=\",             exit: \"\\<Esc>\\<Esc>\"},\n  \\  #{name: 'input',  enter: \":call input('')\\<CR>\", exit: \"\\<CR>\"},\n  \"\\ TODO: {'name': 'debug', ...}\n  \\]\n  let keypairs = [\n  \\  #{older: \"\\<Up>\",     newer: \"\\<Down>\",     prefixmatch: v:true},\n  \\  #{older: \"\\<S-Up>\",   newer: \"\\<S-Down>\",   prefixmatch: v:false},\n  \\  #{older: \"\\<PageUp>\", newer: \"\\<PageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<kPageUp>\", newer: \"\\<kPageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<C-p>\",    newer: \"\\<C-n>\",      prefixmatch: v:false},\n  \\]\n  let prefix = 'vi'\n  for h in histories\n    call histadd(h.name, 'vim')\n    call histadd(h.name, 'virtue')\n    call histadd(h.name, 'Virgo')\n    call histadd(h.name, 'vogue')\n    call histadd(h.name, 'emacs')\n    for k in keypairs\n      let g:cmdlines = []\n      let keyseqs = h.enter\n      \\          .. prefix\n      \\          .. repeat(k.older .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. repeat(k.newer .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. h.exit\n      call feedkeys(keyseqs, 'xt')\n      call histdel(h.name, -1) \" delete the history added by feedkeys above\n      let expect = k.prefixmatch\n      \\          ? ['virtue', 'vim',   'virtue', prefix]\n      \\          : ['emacs',  'vogue', 'emacs',  prefix]\n      call assert_equal(expect, g:cmdlines)\n    endfor\n  endfor\n\n  unlet g:cmdlines\n  cunmap <Plug>(save-cmdline)\nendfunc\n\nfunc Test_cmd_map_cmdlineChanged()\n  let g:log = []\n  cnoremap <F1> l<Cmd><CR>s\n  augroup test\n    autocmd!\n    autocmd CmdlineChanged : let g:log += [getcmdline()]\n  augroup END\n\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['l', 'ls'], g:log)\n\n  let @b = 'b'\n  cnoremap <F1> a<C-R>b\n  let g:log = []\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['a', 'ab'], g:log)\n\n  unlet g:log\n  cunmap <F1>\n  augroup test\n    autocmd!\n  augroup END\nendfunc\n\n\" Test for the 'suffixes' option\nfunc Test_suffixes_opt()\n  call writefile([], 'Xfile')\n  call writefile([], 'Xfile.c')\n  call writefile([], 'Xfile.o')\n  set suffixes=\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile Xfile.c Xfile.o', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.c', @:)\n  set suffixes=.c\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile Xfile.o Xfile.c', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.o', @:)\n  set suffixes=,,\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.c Xfile.o Xfile', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.o', @:)\n  set suffixes&\n  \" Test for getcompletion() with different patterns\n  call assert_equal(['Xfile', 'Xfile.c', 'Xfile.o'], getcompletion('Xfile', 'file'))\n  call assert_equal(['Xfile'], getcompletion('Xfile$', 'file'))\n  call delete('Xfile')\n  call delete('Xfile.c')\n  call delete('Xfile.o')\nendfunc\n\n\" Test for using a popup menu for the command line completion matches\n\" (wildoptions=pum)\nfunc Test_wildmenu_pum()\n  CheckRunVimInTerminal\n\n  let commands =<< trim [CODE]\n    set wildmenu\n    set wildoptions=pum\n    set shm+=I\n    set noruler\n    set noshowcmd\n\n    func CmdCompl(a, b, c)\n      return repeat(['aaaa'], 120)\n    endfunc\n    command -nargs=* -complete=customlist,CmdCompl Tcmd\n\n    func MyStatusLine() abort\n      return 'status'\n    endfunc\n    func SetupStatusline()\n      set statusline=%!MyStatusLine()\n      set laststatus=2\n    endfunc\n\n    func MyTabLine()\n      return 'my tab line'\n    endfunc\n    func SetupTabline()\n      set statusline=\n      set tabline=%!MyTabLine()\n      set showtabline=2\n    endfunc\n\n    func DoFeedKeys()\n      let &wildcharm = char2nr(\"\\t\")\n      call feedkeys(\":edit $VIMRUNTIME/\\<Tab>\\<Left>\\<C-U>ab\\<Tab>\")\n    endfunc\n  [CODE]\n  call writefile(commands, 'Xtest')\n\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n\n  call term_sendkeys(buf, \":sign \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_01', {})\n\n  \" going down the popup menu using <Down>\n  call term_sendkeys(buf, \"\\<Down>\\<Down>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_02', {})\n\n  \" going down the popup menu using <C-N>\n  call term_sendkeys(buf, \"\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_03', {})\n\n  \" going up the popup menu using <C-P>\n  call term_sendkeys(buf, \"\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_04', {})\n\n  \" going up the popup menu using <Up>\n  call term_sendkeys(buf, \"\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_05', {})\n\n  \" pressing <C-E> should end completion and go back to the original match\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_06', {})\n\n  \" pressing <C-Y> should select the current match and end completion\n  call term_sendkeys(buf, \"\\<Tab>\\<C-P>\\<C-P>\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_07', {})\n\n  \" With 'wildmode' set to 'longest,full', completing a match should display\n  \" the longest match, the wildmenu should not be displayed.\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=longest,full\\<CR>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":sign u\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_08', {})\n\n  \" pressing <Tab> should display the wildmenu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_09', {})\n\n  \" pressing <Tab> second time should select the next entry in the menu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_10', {})\n\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=full\\<CR>\")\n  \" showing popup menu in different columns in the cmdline\n  call term_sendkeys(buf, \":sign define \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_11', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_12', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_13', {})\n\n  \" Directory name completion\n  call mkdir('Xdir/XdirA/XdirB', 'p')\n  call writefile([], 'Xdir/XfileA')\n  call writefile([], 'Xdir/XdirA/XfileB')\n  call writefile([], 'Xdir/XdirA/XdirB/XfileC')\n\n  call term_sendkeys(buf, \"\\<C-U>e Xdi\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_14', {})\n\n  \" Pressing <Right> on a directory name should go into that directory\n  call term_sendkeys(buf, \"\\<Right>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_15', {})\n\n  \" Pressing <Left> on a directory name should go to the parent directory\n  call term_sendkeys(buf, \"\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_16', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches but the popup menu should still remain\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-A>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_17', {})\n\n  \" Pressing <C-D> when the popup menu is displayed should remove the popup\n  \" menu\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-D>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_18', {})\n\n  \" Pressing <S-Tab> should open the popup menu with the last entry selected\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<S-Tab>\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_19', {})\n\n  \" Pressing <Esc> should close the popup menu and cancel the cmd line\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<Tab>\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_20', {})\n\n  \" Typing a character when the popup is open, should close the popup\n  call term_sendkeys(buf, \":sign \\<Tab>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_21', {})\n\n  \" When the popup is open, entering the cmdline window should close the popup\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-F>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_22', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n\n  \" After the last popup menu item, <C-N> should show the original string\n  call term_sendkeys(buf, \":sign u\\<Tab>\\<C-N>\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_23', {})\n\n  \" Use the popup menu for the command name\n  call term_sendkeys(buf, \"\\<C-U>bu\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_24', {})\n\n  \" Pressing the left arrow should remove the popup menu\n  call term_sendkeys(buf, \"\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_25', {})\n\n  \" Pressing <BS> should remove the popup menu and erase the last character\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_26', {})\n\n  \" Pressing <C-W> should remove the popup menu and erase the previous word\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-W>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_27', {})\n\n  \" Pressing <C-U> should remove the popup menu and erase the entire line\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-U>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_28', {})\n\n  \" Using <C-E> to cancel the popup menu and then pressing <Up> should recall\n  \" the cmdline from history\n  call term_sendkeys(buf, \"sign xyz\\<Esc>:sign \\<Tab>\\<C-E>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_29', {})\n\n  \" Check \"list\" still works\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=longest,list\\<CR>\")\n  call term_sendkeys(buf, \":cn\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_30', {})\n  call term_sendkeys(buf, \"s\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_31', {})\n\n  \" Tests a directory name contained full-width characters.\n  call mkdir('Xdir/\u3042\u3044\u3046', 'p')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/abc')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/xyz')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/123')\n\n  call term_sendkeys(buf, \"\\<C-U>set wildmode&\\<CR>\")\n  call term_sendkeys(buf, \":\\<C-U>e Xdir/\u3042\u3044\u3046/\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_32', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing a key after that should remove the popup menu\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=full\\<CR>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_33', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing <Left> after that should move the cursor\n  call term_sendkeys(buf, \"\\<C-U>abc\\<Esc>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_34', {})\n\n  \" When <C-A> displays a lot of matches (screen scrolls), all the matches\n  \" should be displayed correctly on the screen.\n  call term_sendkeys(buf, \"\\<End>\\<C-U>Tcmd \\<Tab>\\<C-A>\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_35', {})\n\n  \" After using <C-A> to expand all the filename matches, pressing <Up>\n  \" should not open the popup menu again.\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd Xdir/XdirA\\<CR>\")\n  call term_sendkeys(buf, \":e \\<Tab>\\<C-A>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_36', {})\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd -\\<CR>\")\n\n  \" After using <C-A> to expand all the matches, pressing <S-Tab> used to\n  \" crash Vim\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<S-Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_37', {})\n\n  \" After removing the pum the command line is redrawn\n  call term_sendkeys(buf, \":edit foo\\<CR>\")\n  call term_sendkeys(buf, \":edit bar\\<CR>\")\n  call term_sendkeys(buf, \":ls\\<CR>\")\n  call term_sendkeys(buf, \":com\\<Tab> \")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_38', {})\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n\n  \" Esc still works to abort the command when 'statusline' is set\n  call term_sendkeys(buf, \":call SetupStatusline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_39', {})\n\n  \" Esc still works to abort the command when 'tabline' is set\n  call term_sendkeys(buf, \":call SetupTabline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_40', {})\n\n  \" popup is cleared also when 'lazyredraw' is set\n  call term_sendkeys(buf, \":set showtabline=1 laststatus=1 lazyredraw\\<CR>\")\n  call term_sendkeys(buf, \":call DoFeedKeys()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_41', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Pressing <PageDown> should scroll the menu downward\n  call term_sendkeys(buf, \":sign \\<Tab>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_42', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_43', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_44', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_45', {})\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<Down>\\<Down>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_46', {})\n\n  \" Pressing <PageUp> should scroll the menu upward\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_47', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_48', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_49', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_50', {})\n\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n  call StopVimInTerminal(buf)\n  call delete('Xtest')\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for wildmenumode() with the cmdline popup menu\nfunc Test_wildmenumode_with_pum()\n  set wildmenu\n  set wildoptions=pum\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":sign \\<Tab>\\<F2>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define10', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-A>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define jump list place undefine unplace0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-E>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign 0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-Y>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define0', @:)\n  set nowildmenu wildoptions&\n  cunmap <F2>\nendfunc\n\nfunc Test_wildmenu_with_pum_foldexpr()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      call setline(1, ['folded one', 'folded two', 'some more text'])\n      func MyFoldText()\n        return 'foo'\n      endfunc\n      set foldtext=MyFoldText() wildoptions=pum\n      normal ggzfj\n  END\n  call writefile(lines, 'Xpumfold')\n  let buf = RunVimInTerminal('-S Xpumfold', #{rows: 10})\n  call term_sendkeys(buf, \":set\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_2', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xpumfold')\nendfunc\n\n\" Test for opening the cmdline completion popup menu from the terminal window.\n\" The popup menu should be positioned correctly over the status line of the\n\" bottom-most window.\nfunc Test_wildmenu_pum_from_terminal()\n  CheckRunVimInTerminal\n  let python = PythonProg()\n  call CheckPython(python)\n\n  %bw!\n  let cmds = ['set wildmenu wildoptions=pum']\n  let pcmd = python .. ' -c \"import sys; sys.stdout.write(sys.stdin.read())\"'\n  call add(cmds, \"call term_start('\" .. pcmd .. \"')\")\n  call writefile(cmds, 'Xtest')\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n  call term_sendkeys(buf, \"\\r\\r\\r\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \"\\<C-W>:sign \\<Tab>\")\n  call term_wait(buf)\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_term_01', {})\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\n  call delete('Xtest')\nendfunc\n\n\" Test for completion after a :substitute command followed by a pipe (|)\n\" character\nfunc Test_cmdline_complete_substitute()\n  call feedkeys(\":s | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s | \\t\", @:)\n  call feedkeys(\":s/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/ | \\t\", @:)\n  call feedkeys(\":s/one | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one | \\t\", @:)\n  call feedkeys(\":s/one/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/ | \\t\", @:)\n  call feedkeys(\":s/one/two | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two | \\t\", @:)\n  call feedkeys(\":s/one/two/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/two/ | chistory', @:)\n  call feedkeys(\":s/one/two/g \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g \\t\", @:)\n  call feedkeys(\":s/one/two/g | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g | chistory\", @:)\n  call feedkeys(\":s/one/t\\\\/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/t\\\\/ | \\t\", @:)\n  call feedkeys(\":s/one/t\\\"o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t\"o/ | chistory', @:)\n  call feedkeys(\":s/one/t|o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t|o/ | chistory', @:)\n  call feedkeys(\":&\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"&\\t\", @:)\nendfunc\n\n\" Test for the :dlist command completion\nfunc Test_cmdline_complete_dlist()\n  call feedkeys(\":dlist 10 /pat/ a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ a\\<C-A>\", @:)\n  call feedkeys(\":dlist 10 /pat/ \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ \\t\", @:)\n  call feedkeys(\":dlist 10 /pa\\\\t/\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pa\\\\t/\\t\", @:)\n  call feedkeys(\":dlist 10 /pat\\\\\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat\\\\\\t\", @:)\n  call feedkeys(\":dlist 10 /pat/ | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ | chistory\", @:)\nendfunc\n\n\" argument list (only for :argdel) fuzzy completion\nfunc Test_fuzzy_completion_arglist()\n  argadd change.py count.py charge.py\n  set wildoptions&\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel cge', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel change.py charge.py', @:)\n  %argdelete\n  set wildoptions&\nendfunc\n\n\" autocmd group name fuzzy completion\nfunc Test_fuzzy_completion_autocmd()\n  set wildoptions&\n  augroup MyFuzzyGroup\n  augroup END\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup mfg', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup My*p', @:)\n  augroup! MyFuzzyGroup\n  set wildoptions&\nendfunc\n\n\" buffer name fuzzy completion\nfunc Test_fuzzy_completion_bufname()\n  set wildoptions&\n  edit SomeFile.txt\n  enew\n  call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SF', @:)\n  call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeFile.txt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeFile.txt', @:)\n  call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b S*File.txt', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" buffer name (full path) fuzzy completion\nfunc Test_fuzzy_completion_bufname_fullpath()\n  CheckUnix\n  set wildoptions&\n  call mkdir('Xcmd/Xstate/Xfile.js', 'p')\n  edit Xcmd/Xstate/Xfile.js\n  cd Xcmd/Xstate\n  enew\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b CmdStateFile', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('Xcmd/Xstate/Xfile.js$', @:)\n  cd -\n  call delete('Xcmd', 'rf')\n  set wildoptions&\nendfunc\n\n\" :behave suboptions fuzzy completion\nfunc Test_fuzzy_completion_behave()\n  set wildoptions&\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xt*m', @:)\n  let g:Sline = ''\n  call feedkeys(\":behave win\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('mswin', g:Sline)\n  call assert_equal('\"behave win', @:)\n  set wildoptions&\nendfunc\n\n\" \" colorscheme name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_colorscheme()\n\" endfunc\n\n\" built-in command name fuzzy completion\nfunc Test_fuzzy_completion_cmdname()\n  set wildoptions&\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbwin', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbr*d', @:)\n  set wildoptions&\nendfunc\n\n\" \" compiler name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_compiler()\n\" endfunc\n\n\" :cscope suboptions fuzzy completion\nfunc Test_fuzzy_completion_cscope()\n  CheckFeature cscope\n  set wildoptions&\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope ret', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope re*t', @:)\n  set wildoptions&\nendfunc\n\n\" :diffget/:diffput buffer name fuzzy completion\nfunc Test_fuzzy_completion_diff()\n  new SomeBuffer\n  diffthis\n  new OtherBuffer\n  diffthis\n  set wildoptions&\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget sbuf', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput sbuf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget SomeBuffer', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput SomeBuffer', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" \" directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_dirname()\n\" endfunc\n\n\" environment variable name fuzzy completion\nfunc Test_fuzzy_completion_env()\n  set wildoptions&\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VUT', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VIMRUNTIME', @:)\n  set wildoptions&\nendfunc\n\n\" autocmd event fuzzy completion\nfunc Test_fuzzy_completion_autocmd_event()\n  set wildoptions&\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BWout', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BufWipeout', @:)\n  set wildoptions&\nendfunc\n\n\" vim expression fuzzy completion\nfunc Test_fuzzy_completion_expr()\n  let g:PerPlaceCount = 10\n  set wildoptions&\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = ppc', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = PerPlaceCount', @:)\n  set wildoptions&\nendfunc\n\n\" \" file name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filename()\n\" endfunc\n\n\" \" files in path fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filesinpath()\n\" endfunc\n\n\" \" filetype name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filetype()\n\" endfunc\n\n\" user defined function name completion\nfunc Test_fuzzy_completion_userdefined_func()\n  set wildoptions&\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_f_u_f', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_fuzzy_completion_userdefined_func()', @:)\n  set wildoptions&\nendfunc\n\n\" <SNR> functions should be sorted to the end\nfunc Test_fuzzy_completion_userdefined_snr_func()\n  func s:Sendmail()\n  endfunc\n  func SendSomemail()\n  endfunc\n  func S1e2n3dmail()\n  endfunc\n  set wildoptions=fuzzy\n  call feedkeys(\":call sendmail\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"call SendSomemail() S1e2n3dmail() <SNR>\\d\\+_Sendmail()', @:)\n  set wildoptions&\n  delfunc s:Sendmail\n  delfunc SendSomemail\n  delfunc S1e2n3dmail\nendfunc\n\n\" user defined command name completion\nfunc Test_fuzzy_completion_userdefined_cmd()\n  set wildoptions&\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MsFeat', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MissingFeature', @:)\n  set wildoptions&\nendfunc\n\n\" \" :help tag fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_helptag()\n\" endfunc\n\n\" highlight group name fuzzy completion\nfunc Test_fuzzy_completion_hlgroup()\n  set wildoptions&\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight Sp*Key', @:)\n  set wildoptions&\nendfunc\n\n\" :history suboptions fuzzy completion\nfunc Test_fuzzy_completion_history()\n  set wildoptions&\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history dg', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history search', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history debug', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history se*h', @:)\n  set wildoptions&\nendfunc\n\n\" :language locale name fuzzy completion\nfunc Test_fuzzy_completion_lang()\n  CheckUnix\n  set wildoptions&\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang psx', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang POSIX', @:)\n  set wildoptions&\nendfunc\n\n\" :mapclear buffer argument fuzzy completion\nfunc Test_fuzzy_completion_mapclear()\n  set wildoptions&\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear buf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear <buffer>', @:)\n  set wildoptions&\nendfunc\n\n\" map name fuzzy completion\nfunc Test_fuzzy_completion_mapname()\n  \" test regex completion works\n  set wildoptions=fuzzy\n  call feedkeys(\":cnoremap <ex\\<Tab> <esc> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"cnoremap <expr> <esc> \\<Tab>\", @:)\n  nmap <plug>MyLongMap :p<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  call feedkeys(\":nmap MLM \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap MLM \\t\", @:)\n  call feedkeys(\":nmap <F2> one two \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <F2> one two \\t\", @:)\n  \" duplicate entries should be removed\n  vmap <plug>MyLongMap :<C-U>#<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  nunmap <plug>MyLongMap\n  vunmap <plug>MyLongMap\n  call feedkeys(\":nmap ABC\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap ABC\\t\", @:)\n  \" results should be sorted by best match\n  nmap <Plug>format :\n  nmap <Plug>goformat :\n  nmap <Plug>TestFOrmat :\n  nmap <Plug>fendoff :\n  nmap <Plug>state :\n  nmap <Plug>FendingOff :\n  call feedkeys(\":nmap <Plug>fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>format <Plug>TestFOrmat <Plug>FendingOff <Plug>goformat <Plug>fendoff\", @:)\n  nunmap <Plug>format\n  nunmap <Plug>goformat\n  nunmap <Plug>TestFOrmat\n  nunmap <Plug>fendoff\n  nunmap <Plug>state\n  nunmap <Plug>FendingOff\n  set wildoptions&\nendfunc\n\n\" abbreviation fuzzy completion\nfunc Test_fuzzy_completion_abbr()\n  set wildoptions=fuzzy\n  call feedkeys(\":iabbr wait\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr <nowait>\", @:)\n  iabbr WaitForCompletion WFC\n  call feedkeys(\":iabbr fcl\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr WaitForCompletion\", @:)\n  call feedkeys(\":iabbr a1z\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr a1z\\t\", @:)\n  iunabbrev WaitForCompletion\n  set wildoptions&\nendfunc\n\n\" menu name fuzzy completion\nfunc Test_fuzzy_completion_menu()\n  CheckGui\n  set wildoptions&\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu pup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu PopUp.', @:)\n  set wildoptions&\nendfunc\n\n\" :messages suboptions fuzzy completion\nfunc Test_fuzzy_completion_messages()\n  set wildoptions&\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clear', @:)\n  set wildoptions&\nendfunc\n\n\" :set option name fuzzy completion\nfunc Test_fuzzy_completion_option()\n  set wildoptions&\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set brkopt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set breakindentopt', @:)\n  set wildoptions&\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions&\nendfunc\n\n\" :set <term_option>\nfunc Test_fuzzy_completion_term_option()\n  set wildoptions&\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions&\nendfunc\n\n\" \" :packadd directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_packadd()\n\" endfunc\n\n\" \" shell command name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_shellcmd()\n\" endfunc\n\n\" :sign suboptions fuzzy completion\nfunc Test_fuzzy_completion_sign()\n  set wildoptions&\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign ufe', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign undefine', @:)\n  set wildoptions&\nendfunc\n\n\" :syntax suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntax_cmd()\n  set wildoptions&\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax kwd', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax keyword', @:)\n  set wildoptions&\nendfunc\n\n\" syntax group name fuzzy completion\nfunc Test_fuzzy_completion_syntax_group()\n  set wildoptions&\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list mpar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list MatchParen', @:)\n  set wildoptions&\nendfunc\n\n\" :syntime suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntime()\n  CheckFeature profile\n  set wildoptions&\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clear', @:)\n  set wildoptions&\nendfunc\n\n\" \" tag name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagname()\n\" endfunc\n\n\" \" tag name and file fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagfile()\n\" endfunc\n\n\" \" user names fuzzy completion - how to test this functionality?\n\" func Test_fuzzy_completion_username()\n\" endfunc\n\n\" user defined variable name fuzzy completion\nfunc Test_fuzzy_completion_userdefined_var()\n  let g:SomeVariable=10\n  set wildoptions&\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SVar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SomeVariable', @:)\n  set wildoptions&\nendfunc\n\n\" Test for sorting the results by the best match\nfunc Test_fuzzy_completion_cmd_sort_results()\n  %bw!\n  command T123format :\n  command T123goformat :\n  command T123TestFOrmat :\n  command T123fendoff :\n  command T123state :\n  command T123FendingOff :\n  set wildoptions=fuzzy\n  call feedkeys(\":T123fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"T123format T123TestFOrmat T123FendingOff T123goformat T123fendoff', @:)\n  delcommand T123format\n  delcommand T123goformat\n  delcommand T123TestFOrmat\n  delcommand T123fendoff\n  delcommand T123state\n  delcommand T123FendingOff\n  %bw\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion of a command with lower case letters and a number\nfunc Test_fuzzy_completion_cmd_alnum()\n  command Foo2Bar :\n  set wildoptions=fuzzy\n  call feedkeys(\":foo2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":foo\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":bar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  delcommand Foo2Bar\n  set wildoptions&\nendfunc\n\n\" Test for command completion for a command starting with 'k'\nfunc Test_fuzzy_completion_cmd_k()\n  command KillKillKill :\n  set wildoptions&\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"killkill\\<Tab>\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"KillKillKill', @:)\n  delcom KillKillKill\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion for user defined custom completion function\nfunc Test_fuzzy_completion_custom_func()\n  func Tcompl(a, c, p)\n    return \"format\\ngoformat\\nTestFOrmat\\nfendoff\\nstate\"\n  endfunc\n  command -nargs=* -complete=custom,Tcompl Fuzzy :\n  set wildoptions&\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy ttt\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":Fuzzy \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format goformat TestFOrmat fendoff state\", @:)\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format TestFOrmat goformat fendoff\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy TestFOrmat\", @:)\n  delcom Fuzzy\n  set wildoptions&\nendfunc\n\n\" Test for :breakadd argument completion\nfunc Test_cmdline_complete_breakadd()\n  call feedkeys(\":breakadd \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr file func here\", @:)\n  call feedkeys(\":breakadd \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr\", @:)\n  call feedkeys(\":breakadd    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr\", @:)\n  call feedkeys(\":breakadd he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here\", @:)\n  call feedkeys(\":breakadd    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    here\", @:)\n  call feedkeys(\":breakadd abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd abc\", @:)\n  call assert_equal(['expr', 'file', 'func', 'here'], getcompletion('', 'breakpoint'))\n  let l = getcompletion('not', 'breakpoint')\n  call assert_equal([], l)\n\n  \" Test for :breakadd file [lnum] <file>\n  call writefile([], 'Xscript')\n  call feedkeys(\":breakadd file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript\", @:)\n  call feedkeys(\":breakadd   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   Xscript\", @:)\n  call feedkeys(\":breakadd file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20 Xscript\", @:)\n  call feedkeys(\":breakadd   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   20   Xscript\", @:)\n  call feedkeys(\":breakadd file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakadd file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20\\t\", @:)\n  call feedkeys(\":breakadd file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x\\t\", @:)\n  call feedkeys(\":breakadd file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript  \", @:)\n  call feedkeys(\":breakadd file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file X1B2C3\", @:)\n  call delete('Xscript')\n\n  \" Test for :breakadd func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakadd func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func\", @:)\n  call feedkeys(\":breakadd    func    Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    func    Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakadd   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakadd func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20\\t\", @:)\n  call feedkeys(\":breakadd func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x\\t\", @:)\n  call feedkeys(\":breakadd func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func  \", @:)\n  call feedkeys(\":breakadd func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakadd expr <expression>\n  let g:Xtest_var = 10\n  call feedkeys(\":breakadd expr Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var\", @:)\n  call feedkeys(\":breakadd    expr    Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr    Xtest_var\", @:)\n  call feedkeys(\":breakadd expr Xtest_var  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var  \", @:)\n  call feedkeys(\":breakadd expr X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr X1B2C3\", @:)\n  unlet g:Xtest_var\n\n  \" Test for :breakadd here\n  call feedkeys(\":breakadd here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here Xtest\", @:)\n  call feedkeys(\":breakadd   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   here   Xtest\", @:)\n  call feedkeys(\":breakadd here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here \", @:)\nendfunc\n\n\" Test for :breakdel argument completion\nfunc Test_cmdline_complete_breakdel()\n  call feedkeys(\":breakdel \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file func here\", @:)\n  call feedkeys(\":breakdel \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file\", @:)\n  call feedkeys(\":breakdel    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    file\", @:)\n  call feedkeys(\":breakdel he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here\", @:)\n  call feedkeys(\":breakdel    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    here\", @:)\n  call feedkeys(\":breakdel abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel abc\", @:)\n\n  \" Test for :breakdel file [lnum] <file>\n  call writefile([], 'Xscript')\n  call feedkeys(\":breakdel file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript\", @:)\n  call feedkeys(\":breakdel   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   Xscript\", @:)\n  call feedkeys(\":breakdel file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20 Xscript\", @:)\n  call feedkeys(\":breakdel   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   20   Xscript\", @:)\n  call feedkeys(\":breakdel file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakdel file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20\\t\", @:)\n  call feedkeys(\":breakdel file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x\\t\", @:)\n  call feedkeys(\":breakdel file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript  \", @:)\n  call feedkeys(\":breakdel file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file X1B2C3\", @:)\n  call delete('Xscript')\n\n  \" Test for :breakdel func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakdel func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakdel func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20\\t\", @:)\n  call feedkeys(\":breakdel func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x\\t\", @:)\n  call feedkeys(\":breakdel func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func  \", @:)\n  call feedkeys(\":breakdel func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakdel here\n  call feedkeys(\":breakdel here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here Xtest\", @:)\n  call feedkeys(\":breakdel   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   here   Xtest\", @:)\n  call feedkeys(\":breakdel here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here \", @:)\nendfunc\n\n\" Test for :scriptnames argument completion\nfunc Test_cmdline_complete_scriptnames()\n  set wildmenu\n  call writefile(['let a = 1'], 'Xa1b2c3.vim')\n  source Xa1b2c3.vim\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script    \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script b2c3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script b2c3\", @:)\n  call feedkeys(\":script 2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script 2\\<Tab>$\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim $\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script \", @:)\n  call assert_match('Xa1b2c3.vim$', getcompletion('.*Xa1b2.*', 'scriptnames')[0])\n  call assert_equal([], getcompletion('Xa1b2', 'scriptnames'))\n  new\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('Xa1b2c3.vim', fnamemodify(@%, ':t'))\n  bw!\n  call delete('Xa1b2c3.vim')\n  set wildmenu&\nendfunc\n\n\" this was going over the end of IObuff\nfunc Test_report_error_with_composing()\n  let caught = 'no'\n  try\n    exe repeat('0', 987) .. \"0\\xdd\\x80\\xdd\\x80\\xdd\\x80\\xdd\\x80\"\n  catch /E492:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\n\" Test for expanding 2-letter and 3-letter :substitute command arguments.\n\" These commands don't accept an argument.\nfunc Test_cmdline_complete_substitute_short()\n  for cmd in ['sc', 'sce', 'scg', 'sci', 'scI', 'scn', 'scp', 'scl',\n        \\ 'sgc', 'sge', 'sg', 'sgi', 'sgI', 'sgn', 'sgp', 'sgl', 'sgr',\n        \\ 'sic', 'sie', 'si', 'siI', 'sin', 'sip', 'sir',\n        \\ 'sIc', 'sIe', 'sIg', 'sIi', 'sI', 'sIn', 'sIp', 'sIl', 'sIr',\n        \\ 'src', 'srg', 'sri', 'srI', 'srn', 'srp', 'srl', 'sr']\n    call feedkeys(':' .. cmd .. \" \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"' .. cmd .. \" \\<Tab>\", @:)\n  endfor\nendfunc\n\nfunc Check_completion()\n  call assert_equal('let a', getcmdline())\n  call assert_equal(6, getcmdpos())\n  call assert_equal(7, getcmdscreenpos())\n  call assert_equal('var', getcmdcompltype())\n  return ''\nendfunc\n\nfunc Test_screenpos_and_completion()\n  call feedkeys(\":let a\\<C-R>=Check_completion()\\<CR>\\<Esc>\", \"xt\")\nendfunc\n\nfunc Test_recursive_register()\n  let @= = ''\n  silent! ?\u001ce\u0012/\n  let caught = 'no'\n  try\n    normal /\u0012/ \n  catch /E169:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\nfunc Test_long_error_message()\n  \" the error should be truncated, not overrun IObuff\n  silent! norm Q00000000000000\u00a0\u00a0\u00a0\u00a0\u00a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_docmd.c: functions for executing an Ex command line.\n */\n\n#include \"vim.h\"\n\nstatic int\tquitmore = 0;\nstatic int\tex_pressedreturn = FALSE;\n#ifndef FEAT_PRINTER\n# define ex_hardcopy\tex_ni\n#endif\n\n#ifdef FEAT_EVAL\nstatic char_u\t*do_one_cmd(char_u **, int, cstack_T *, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\n#else\nstatic char_u\t*do_one_cmd(char_u **, int, char_u *(*fgetline)(int, void *, int, getline_opt_T), void *cookie);\nstatic int\tif_level = 0;\t\t// depth in :if\n#endif\nstatic void\tappend_command(char_u *cmd);\n\n#ifndef FEAT_MENU\n# define ex_emenu\t\tex_ni\n# define ex_menu\t\tex_ni\n# define ex_menutranslate\tex_ni\n#endif\nstatic void\tex_autocmd(exarg_T *eap);\nstatic void\tex_doautocmd(exarg_T *eap);\nstatic void\tex_bunload(exarg_T *eap);\nstatic void\tex_buffer(exarg_T *eap);\nstatic void\tex_bmodified(exarg_T *eap);\nstatic void\tex_bnext(exarg_T *eap);\nstatic void\tex_bprevious(exarg_T *eap);\nstatic void\tex_brewind(exarg_T *eap);\nstatic void\tex_blast(exarg_T *eap);\nstatic char_u\t*getargcmd(char_u **);\nstatic int\tgetargopt(exarg_T *eap);\n#ifndef FEAT_QUICKFIX\n# define ex_make\t\tex_ni\n# define ex_cbuffer\t\tex_ni\n# define ex_cc\t\t\tex_ni\n# define ex_cnext\t\tex_ni\n# define ex_cbelow\t\tex_ni\n# define ex_cfile\t\tex_ni\n# define qf_list\t\tex_ni\n# define qf_age\t\t\tex_ni\n# define qf_history\t\tex_ni\n# define ex_helpgrep\t\tex_ni\n# define ex_vimgrep\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX)\n# define ex_cclose\t\tex_ni\n# define ex_copen\t\tex_ni\n# define ex_cwindow\t\tex_ni\n# define ex_cbottom\t\tex_ni\n#endif\n#if !defined(FEAT_QUICKFIX) || !defined(FEAT_EVAL)\n# define ex_cexpr\t\tex_ni\n#endif\n\nstatic linenr_T default_address(exarg_T *eap);\nstatic linenr_T get_address(exarg_T *, char_u **, cmd_addr_T addr_type, int skip, int silent, int to_other_file, int address_count);\nstatic void address_default_all(exarg_T *eap);\nstatic void\tget_flags(exarg_T *eap);\n#if !defined(FEAT_PERL) \\\n\t|| !defined(FEAT_PYTHON) || !defined(FEAT_PYTHON3) \\\n\t|| !defined(FEAT_TCL) \\\n\t|| !defined(FEAT_RUBY) \\\n\t|| !defined(FEAT_LUA) \\\n\t|| !defined(FEAT_MZSCHEME)\n# define HAVE_EX_SCRIPT_NI\nstatic void\tex_script_ni(exarg_T *eap);\n#endif\nstatic char\t*invalid_range(exarg_T *eap);\nstatic void\tcorrect_range(exarg_T *eap);\n#ifdef FEAT_QUICKFIX\nstatic char_u\t*replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep);\n#endif\nstatic char_u\t*repl_cmdline(exarg_T *eap, char_u *src, int srclen, char_u *repl, char_u **cmdlinep);\nstatic void\tex_highlight(exarg_T *eap);\nstatic void\tex_colorscheme(exarg_T *eap);\nstatic void\tex_cquit(exarg_T *eap);\nstatic void\tex_quit_all(exarg_T *eap);\nstatic void\tex_close(exarg_T *eap);\nstatic void\tex_win_close(int forceit, win_T *win, tabpage_T *tp);\nstatic void\tex_only(exarg_T *eap);\nstatic void\tex_resize(exarg_T *eap);\nstatic void\tex_stag(exarg_T *eap);\nstatic void\tex_tabclose(exarg_T *eap);\nstatic void\tex_tabonly(exarg_T *eap);\nstatic void\tex_tabnext(exarg_T *eap);\nstatic void\tex_tabmove(exarg_T *eap);\nstatic void\tex_tabs(exarg_T *eap);\n#if defined(FEAT_QUICKFIX)\nstatic void\tex_pclose(exarg_T *eap);\nstatic void\tex_ptag(exarg_T *eap);\nstatic void\tex_pedit(exarg_T *eap);\n#else\n# define ex_pclose\t\tex_ni\n# define ex_ptag\t\tex_ni\n# define ex_pedit\t\tex_ni\n#endif\nstatic void\tex_hide(exarg_T *eap);\nstatic void\tex_exit(exarg_T *eap);\nstatic void\tex_print(exarg_T *eap);\n#ifdef FEAT_BYTEOFF\nstatic void\tex_goto(exarg_T *eap);\n#else\n# define ex_goto\t\tex_ni\n#endif\nstatic void\tex_shell(exarg_T *eap);\nstatic void\tex_preserve(exarg_T *eap);\nstatic void\tex_recover(exarg_T *eap);\nstatic void\tex_mode(exarg_T *eap);\nstatic void\tex_wrongmodifier(exarg_T *eap);\nstatic void\tex_find(exarg_T *eap);\nstatic void\tex_open(exarg_T *eap);\nstatic void\tex_edit(exarg_T *eap);\n#ifndef FEAT_GUI\n# define ex_gui\t\t\tex_nogui\nstatic void\tex_nogui(exarg_T *eap);\n#endif\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\nstatic void\tex_tearoff(exarg_T *eap);\n#else\n# define ex_tearoff\t\tex_ni\n#endif\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\nstatic void\tex_popup(exarg_T *eap);\n#else\n# define ex_popup\t\tex_ni\n#endif\n#ifndef FEAT_GUI_MSWIN\n# define ex_simalt\t\tex_ni\n#endif\n#if !defined(FEAT_GUI_MSWIN) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MOTIF)\n# define gui_mch_find_dialog\tex_ni\n# define gui_mch_replace_dialog ex_ni\n#endif\n#if !defined(FEAT_GUI_GTK)\n# define ex_helpfind\t\tex_ni\n#endif\n#ifndef FEAT_CSCOPE\n# define ex_cscope\t\tex_ni\n# define ex_scscope\t\tex_ni\n# define ex_cstag\t\tex_ni\n#endif\n#ifndef FEAT_SYN_HL\n# define ex_syntax\t\tex_ni\n# define ex_ownsyntax\t\tex_ni\n#endif\n#if !defined(FEAT_SYN_HL) || !defined(FEAT_PROFILE)\n# define ex_syntime\t\tex_ni\n#endif\n#ifndef FEAT_SPELL\n# define ex_spell\t\tex_ni\n# define ex_mkspell\t\tex_ni\n# define ex_spelldump\t\tex_ni\n# define ex_spellinfo\t\tex_ni\n# define ex_spellrepall\t\tex_ni\n#endif\n#ifndef FEAT_PERSISTENT_UNDO\n# define ex_rundo\t\tex_ni\n# define ex_wundo\t\tex_ni\n#endif\n#ifndef FEAT_LUA\n# define ex_lua\t\t\tex_script_ni\n# define ex_luado\t\tex_ni\n# define ex_luafile\t\tex_ni\n#endif\n#ifndef FEAT_MZSCHEME\n# define ex_mzscheme\t\tex_script_ni\n# define ex_mzfile\t\tex_ni\n#endif\n#ifndef FEAT_PERL\n# define ex_perl\t\tex_script_ni\n# define ex_perldo\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON\n# define ex_python\t\tex_script_ni\n# define ex_pydo\t\tex_ni\n# define ex_pyfile\t\tex_ni\n#endif\n#ifndef FEAT_PYTHON3\n# define ex_py3\t\t\tex_script_ni\n# define ex_py3do\t\tex_ni\n# define ex_py3file\t\tex_ni\n#endif\n#if !defined(FEAT_PYTHON) && !defined(FEAT_PYTHON3)\n# define ex_pyx\t\t\tex_script_ni\n# define ex_pyxdo\t\tex_ni\n# define ex_pyxfile\t\tex_ni\n#endif\n#ifndef FEAT_TCL\n# define ex_tcl\t\t\tex_script_ni\n# define ex_tcldo\t\tex_ni\n# define ex_tclfile\t\tex_ni\n#endif\n#ifndef FEAT_RUBY\n# define ex_ruby\t\tex_script_ni\n# define ex_rubydo\t\tex_ni\n# define ex_rubyfile\t\tex_ni\n#endif\n#ifndef FEAT_KEYMAP\n# define ex_loadkeymap\t\tex_ni\n#endif\nstatic void\tex_swapname(exarg_T *eap);\nstatic void\tex_syncbind(exarg_T *eap);\nstatic void\tex_read(exarg_T *eap);\nstatic void\tex_pwd(exarg_T *eap);\nstatic void\tex_equal(exarg_T *eap);\nstatic void\tex_sleep(exarg_T *eap);\nstatic void\tex_winsize(exarg_T *eap);\nstatic void\tex_wincmd(exarg_T *eap);\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\nstatic void\tex_winpos(exarg_T *eap);\n#else\n# define ex_winpos\t    ex_ni\n#endif\nstatic void\tex_operators(exarg_T *eap);\nstatic void\tex_put(exarg_T *eap);\nstatic void\tex_copymove(exarg_T *eap);\nstatic void\tex_submagic(exarg_T *eap);\nstatic void\tex_join(exarg_T *eap);\nstatic void\tex_at(exarg_T *eap);\nstatic void\tex_bang(exarg_T *eap);\nstatic void\tex_undo(exarg_T *eap);\n#ifdef FEAT_PERSISTENT_UNDO\nstatic void\tex_wundo(exarg_T *eap);\nstatic void\tex_rundo(exarg_T *eap);\n#endif\nstatic void\tex_redo(exarg_T *eap);\nstatic void\tex_later(exarg_T *eap);\nstatic void\tex_redir(exarg_T *eap);\nstatic void\tex_redrawstatus(exarg_T *eap);\nstatic void\tex_redrawtabline(exarg_T *eap);\nstatic void\tclose_redir(void);\nstatic void\tex_mark(exarg_T *eap);\nstatic void\tex_startinsert(exarg_T *eap);\nstatic void\tex_stopinsert(exarg_T *eap);\n#ifdef FEAT_FIND_ID\nstatic void\tex_checkpath(exarg_T *eap);\nstatic void\tex_findpat(exarg_T *eap);\n#else\n# define ex_findpat\t\tex_ni\n# define ex_checkpath\t\tex_ni\n#endif\n#if defined(FEAT_FIND_ID) && defined(FEAT_QUICKFIX)\nstatic void\tex_psearch(exarg_T *eap);\n#else\n# define ex_psearch\t\tex_ni\n#endif\nstatic void\tex_tag(exarg_T *eap);\nstatic void\tex_tag_cmd(exarg_T *eap, char_u *name);\n#ifndef FEAT_EVAL\n# define ex_block\t\tex_ni\n# define ex_break\t\tex_ni\n# define ex_breakadd\t\tex_ni\n# define ex_breakdel\t\tex_ni\n# define ex_breaklist\t\tex_ni\n# define ex_call\t\tex_ni\n# define ex_catch\t\tex_ni\n# define ex_compiler\t\tex_ni\n# define ex_continue\t\tex_ni\n# define ex_debug\t\tex_ni\n# define ex_debuggreedy\t\tex_ni\n# define ex_defcompile\t\tex_ni\n# define ex_delfunction\t\tex_ni\n# define ex_disassemble\t\tex_ni\n# define ex_echo\t\tex_ni\n# define ex_echohl\t\tex_ni\n# define ex_else\t\tex_ni\n# define ex_endblock\t\tex_ni\n# define ex_endfunction\t\tex_ni\n# define ex_endif\t\tex_ni\n# define ex_endtry\t\tex_ni\n# define ex_endwhile\t\tex_ni\n# define ex_eval\t\tex_ni\n# define ex_execute\t\tex_ni\n# define ex_incdec\t\tex_ni\n# define ex_finally\t\tex_ni\n# define ex_finish\t\tex_ni\n# define ex_function\t\tex_ni\n# define ex_if\t\t\tex_ni\n# define ex_let\t\t\tex_ni\n# define ex_var\t\t\tex_ni\n# define ex_lockvar\t\tex_ni\n# define ex_oldfiles\t\tex_ni\n# define ex_options\t\tex_ni\n# define ex_packadd\t\tex_ni\n# define ex_packloadall\t\tex_ni\n# define ex_return\t\tex_ni\n# define ex_scriptnames\t\tex_ni\n# define ex_throw\t\tex_ni\n# define ex_try\t\t\tex_ni\n# define ex_unlet\t\tex_ni\n# define ex_while\t\tex_ni\n# define ex_import\t\tex_ni\n# define ex_export\t\tex_ni\n#endif\n#ifndef FEAT_SESSION\n# define ex_loadview\t\tex_ni\n#endif\n#ifndef FEAT_VIMINFO\n# define ex_viminfo\t\tex_ni\n#endif\nstatic void\tex_behave(exarg_T *eap);\nstatic void\tex_filetype(exarg_T *eap);\nstatic void\tex_setfiletype(exarg_T *eap);\n#ifndef FEAT_DIFF\n# define ex_diffoff\t\tex_ni\n# define ex_diffpatch\t\tex_ni\n# define ex_diffgetput\t\tex_ni\n# define ex_diffsplit\t\tex_ni\n# define ex_diffthis\t\tex_ni\n# define ex_diffupdate\t\tex_ni\n#endif\nstatic void\tex_digraphs(exarg_T *eap);\n#ifdef FEAT_SEARCH_EXTRA\nstatic void\tex_nohlsearch(exarg_T *eap);\n#else\n# define ex_nohlsearch\t\tex_ni\n# define ex_match\t\tex_ni\n#endif\n#ifdef FEAT_CRYPT\nstatic void\tex_X(exarg_T *eap);\n#else\n# define ex_X\t\t\tex_ni\n#endif\n#ifdef FEAT_FOLDING\nstatic void\tex_fold(exarg_T *eap);\nstatic void\tex_foldopen(exarg_T *eap);\nstatic void\tex_folddo(exarg_T *eap);\n#else\n# define ex_fold\t\tex_ni\n# define ex_foldopen\t\tex_ni\n# define ex_folddo\t\tex_ni\n#endif\n#if !(defined(HAVE_LOCALE_H) || defined(X_LOCALE))\n# define ex_language\t\tex_ni\n#endif\n#ifndef FEAT_SIGNS\n# define ex_sign\t\tex_ni\n#endif\n#ifndef FEAT_NETBEANS_INTG\n# define ex_nbclose\t\tex_ni\n# define ex_nbkey\t\tex_ni\n# define ex_nbstart\t\tex_ni\n#endif\n\n#ifndef FEAT_PROFILE\n# define ex_profile\t\tex_ni\n#endif\n#ifndef FEAT_TERMINAL\n# define ex_terminal\t\tex_ni\n#endif\n#if !defined(FEAT_X11) || !defined(FEAT_XCLIPBOARD)\n# define ex_xrestore\t\tex_ni\n#endif\n#if !defined(FEAT_PROP_POPUP)\n# define ex_popupclear\t\tex_ni\n#endif\n\n/*\n * Declare cmdnames[].\n */\n#define DO_DECLARE_EXCMD\n#include \"ex_cmds.h\"\n#include \"ex_cmdidxs.h\"\n\nstatic char_u dollar_command[2] = {'$', 0};\n\n\n#ifdef FEAT_EVAL\n// Struct for storing a line inside a while/for loop\ntypedef struct\n{\n    char_u\t*line;\t\t// command line\n    linenr_T\tlnum;\t\t// sourcing_lnum of the line\n} wcmd_T;\n\n/*\n * Structure used to store info for line position in a while or for loop.\n * This is required, because do_one_cmd() may invoke ex_function(), which\n * reads more lines that may come from the while/for loop.\n */\nstruct loop_cookie\n{\n    garray_T\t*lines_gap;\t\t// growarray with line info\n    int\t\tcurrent_line;\t\t// last read line from growarray\n    int\t\trepeating;\t\t// TRUE when looping a second time\n    // When \"repeating\" is FALSE use \"getline\" and \"cookie\" to get lines\n    char_u\t*(*getline)(int, void *, int, getline_opt_T);\n    void\t*cookie;\n};\n\nstatic char_u\t*get_loop_line(int c, void *cookie, int indent, getline_opt_T options);\nstatic int\tstore_loop_line(garray_T *gap, char_u *line);\nstatic void\tfree_cmdlines(garray_T *gap);\n\n// Struct to save a few things while debugging.  Used in do_cmdline() only.\nstruct dbg_stuff\n{\n    int\t\ttrylevel;\n    int\t\tforce_abort;\n    except_T\t*caught_stack;\n    char_u\t*vv_exception;\n    char_u\t*vv_throwpoint;\n    int\t\tdid_emsg;\n    int\t\tgot_int;\n    int\t\tdid_throw;\n    int\t\tneed_rethrow;\n    int\t\tcheck_cstack;\n    except_T\t*current_exception;\n};\n\n    static void\nsave_dbg_stuff(struct dbg_stuff *dsp)\n{\n    dsp->trylevel\t= trylevel;\t\ttrylevel = 0;\n    dsp->force_abort\t= force_abort;\t\tforce_abort = FALSE;\n    dsp->caught_stack\t= caught_stack;\t\tcaught_stack = NULL;\n    dsp->vv_exception\t= v_exception(NULL);\n    dsp->vv_throwpoint\t= v_throwpoint(NULL);\n\n    // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\"\n    dsp->did_emsg\t= did_emsg;\t\tdid_emsg     = FALSE;\n    dsp->got_int\t= got_int;\t\tgot_int\t     = FALSE;\n    dsp->did_throw\t= did_throw;\t\tdid_throw    = FALSE;\n    dsp->need_rethrow\t= need_rethrow;\t\tneed_rethrow = FALSE;\n    dsp->check_cstack\t= check_cstack;\t\tcheck_cstack = FALSE;\n    dsp->current_exception = current_exception;\tcurrent_exception = NULL;\n}\n\n    static void\nrestore_dbg_stuff(struct dbg_stuff *dsp)\n{\n    suppress_errthrow = FALSE;\n    trylevel = dsp->trylevel;\n    force_abort = dsp->force_abort;\n    caught_stack = dsp->caught_stack;\n    (void)v_exception(dsp->vv_exception);\n    (void)v_throwpoint(dsp->vv_throwpoint);\n    did_emsg = dsp->did_emsg;\n    got_int = dsp->got_int;\n    did_throw = dsp->did_throw;\n    need_rethrow = dsp->need_rethrow;\n    check_cstack = dsp->check_cstack;\n    current_exception = dsp->current_exception;\n}\n#endif\n\n/*\n * do_exmode(): Repeatedly get commands for the \"Ex\" mode, until the \":vi\"\n * command is given.\n */\n    void\ndo_exmode(\n    int\t\timproved)\t    // TRUE for \"improved Ex\" mode\n{\n    int\t\tsave_msg_scroll;\n    int\t\tprev_msg_row;\n    linenr_T\tprev_line;\n    varnumber_T\tchangedtick;\n\n    if (improved)\n\texmode_active = EXMODE_VIM;\n    else\n\texmode_active = EXMODE_NORMAL;\n    State = MODE_NORMAL;\n    may_trigger_modechanged();\n\n    // When using \":global /pat/ visual\" and then \"Q\" we return to continue\n    // the :global command.\n    if (global_busy)\n\treturn;\n\n    save_msg_scroll = msg_scroll;\n    ++RedrawingDisabled;\t    // don't redisplay the window\n    ++no_wait_return;\t\t    // don't wait for return\n#ifdef FEAT_GUI\n    // Ignore scrollbar and mouse events in Ex mode\n    ++hold_gui_events;\n#endif\n\n    msg(_(\"Entering Ex mode.  Type \\\"visual\\\" to go to Normal mode.\"));\n    while (exmode_active)\n    {\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t{\n\t    exmode_active = FALSE;\n\t    break;\n\t}\n\tmsg_scroll = TRUE;\n\tneed_wait_return = FALSE;\n\tex_pressedreturn = FALSE;\n\tex_no_reprint = FALSE;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tprev_msg_row = msg_row;\n\tprev_line = curwin->w_cursor.lnum;\n\tif (improved)\n\t{\n\t    cmdline_row = msg_row;\n\t    do_cmdline(NULL, getexline, NULL, 0);\n\t}\n\telse\n\t    do_cmdline(NULL, getexmodeline, NULL, DOCMD_NOWAIT);\n\tlines_left = Rows - 1;\n\n\tif ((prev_line != curwin->w_cursor.lnum\n\t\t   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_empty_buffer));\n\t    else\n\t    {\n\t\tif (ex_pressedreturn)\n\t\t{\n\t\t    // go up one line, to overwrite the \":<CR>\" line, so the\n\t\t    // output doesn't contain empty lines.\n\t\t    msg_row = prev_msg_row;\n\t\t    if (prev_msg_row == Rows - 1)\n\t\t\tmsg_row--;\n\t\t}\n\t\tmsg_col = 0;\n\t\tprint_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);\n\t\tmsg_clr_eos();\n\t    }\n\t}\n\telse if (ex_pressedreturn && !ex_no_reprint)\t// must be at EOF\n\t{\n\t    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t\temsg(_(e_empty_buffer));\n\t    else\n\t\temsg(_(e_at_end_of_file));\n\t}\n    }\n\n#ifdef FEAT_GUI\n    --hold_gui_events;\n#endif\n    --RedrawingDisabled;\n    --no_wait_return;\n    update_screen(CLEAR);\n    need_wait_return = FALSE;\n    msg_scroll = save_msg_scroll;\n}\n\n/*\n * Print the executed command for when 'verbose' is set.\n * When \"lnum\" is 0 only print the command.\n */\n    static void\nmsg_verbose_cmd(linenr_T lnum, char_u *cmd)\n{\n    ++no_wait_return;\n    verbose_enter_scroll();\n\n    if (lnum == 0)\n\tsmsg(_(\"Executing: %s\"), cmd);\n    else\n\tsmsg(_(\"line %ld: %s\"), (long)lnum, cmd);\n    if (msg_silent == 0)\n\tmsg_puts(\"\\n\");   // don't overwrite this\n\n    verbose_leave_scroll();\n    --no_wait_return;\n}\n\n/*\n * Execute a simple command line.  Used for translated commands like \"*\".\n */\n    int\ndo_cmdline_cmd(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n}\n\n/*\n * Execute the \"+cmd\" argument of \"edit +cmd fname\" and the like.\n * This allows for using a range without \":\" in Vim9 script.\n */\n    static int\ndo_cmd_argument(char_u *cmd)\n{\n    return do_cmdline(cmd, NULL, NULL,\n\t\t      DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED|DOCMD_RANGEOK);\n}\n\n/*\n * do_cmdline(): execute one Ex command line\n *\n * 1. Execute \"cmdline\" when it is not NULL.\n *    If \"cmdline\" is NULL, or more lines are needed, fgetline() is used.\n * 2. Split up in parts separated with '|'.\n *\n * This function can be called recursively!\n *\n * flags:\n * DOCMD_VERBOSE  - The command will be included in the error message.\n * DOCMD_NOWAIT   - Don't call wait_return() and friends.\n * DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.\n * DOCMD_KEYTYPED - Don't reset KeyTyped.\n * DOCMD_EXCRESET - Reset the exception environment (used for debugging).\n * DOCMD_KEEPLINE - Store first typed line (for repeating with \".\").\n *\n * return FAIL if cmdline could not be executed, OK otherwise\n */\n    int\ndo_cmdline(\n    char_u\t*cmdline,\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie,\t\t// argument for fgetline()\n    int\t\tflags)\n{\n    char_u\t*next_cmdline;\t\t// next cmd to execute\n    char_u\t*cmdline_copy = NULL;\t// copy of cmd line\n    int\t\tused_getline = FALSE;\t// used \"fgetline\" to obtain command\n    static int\trecursive = 0;\t\t// recursive depth\n    int\t\tmsg_didout_before_start = 0;\n    int\t\tcount = 0;\t\t// line number count\n    int\t\tdid_inc = FALSE;\t// incremented RedrawingDisabled\n    int\t\tretval = OK;\n#ifdef FEAT_EVAL\n    cstack_T\tcstack;\t\t\t// conditional stack\n    garray_T\tlines_ga;\t\t// keep lines for \":while\"/\":for\"\n    int\t\tcurrent_line = 0;\t// active line in lines_ga\n    int\t\tcurrent_line_before = 0;\n    char_u\t*fname = NULL;\t\t// function or script name\n    linenr_T\t*breakpoint = NULL;\t// ptr to breakpoint field in cookie\n    int\t\t*dbg_tick = NULL;\t// ptr to dbg_tick field in cookie\n    struct dbg_stuff debug_saved;\t// saved things for debug mode\n    int\t\tinitial_trylevel;\n    msglist_T\t**saved_msg_list = NULL;\n    msglist_T\t*private_msg_list = NULL;\n\n    // \"fgetline\" and \"cookie\" passed to do_one_cmd()\n    char_u\t*(*cmd_getline)(int, void *, int, getline_opt_T);\n    void\t*cmd_cookie;\n    struct loop_cookie cmd_loop_cookie;\n    void\t*real_cookie;\n    int\t\tgetline_is_func;\n#else\n# define cmd_getline fgetline\n# define cmd_cookie cookie\n#endif\n    static int\tcall_depth = 0;\t\t// recursiveness\n#ifdef FEAT_EVAL\n    // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory\n    // location for storing error messages to be converted to an exception.\n    // This ensures that the do_errthrow() call in do_one_cmd() does not\n    // combine the messages stored by an earlier invocation of do_one_cmd()\n    // with the command name of the later one.  This would happen when\n    // BufWritePost autocommands are executed after a write error.\n    saved_msg_list = msg_list;\n    msg_list = &private_msg_list;\n#endif\n\n    // It's possible to create an endless loop with \":execute\", catch that\n    // here.  The value of 200 allows nested function calls, \":source\", etc.\n    // Allow 200 or 'maxfuncdepth', whatever is larger.\n    if (call_depth >= 200\n#ifdef FEAT_EVAL\n\t    && call_depth >= p_mfd\n#endif\n\t    )\n    {\n\temsg(_(e_command_too_recursive));\n#ifdef FEAT_EVAL\n\t// When converting to an exception, we do not include the command name\n\t// since this is not an error of the specific command.\n\tdo_errthrow((cstack_T *)NULL, (char_u *)NULL);\n\tmsg_list = saved_msg_list;\n#endif\n\treturn FAIL;\n    }\n    ++call_depth;\n\n#ifdef FEAT_EVAL\n    CLEAR_FIELD(cstack);\n    cstack.cs_idx = -1;\n    ga_init2(&lines_ga, sizeof(wcmd_T), 10);\n\n    real_cookie = getline_cookie(fgetline, cookie);\n\n    // Inside a function use a higher nesting level.\n    getline_is_func = getline_equal(fgetline, cookie, get_func_line);\n    if (getline_is_func && ex_nesting_level == func_level(real_cookie))\n\t++ex_nesting_level;\n\n    // Get the function or script name and the address where the next breakpoint\n    // line and the debug tick for a function or script are stored.\n    if (getline_is_func)\n    {\n\tfname = func_name(real_cookie);\n\tbreakpoint = func_breakpoint(real_cookie);\n\tdbg_tick = func_dbg_tick(real_cookie);\n    }\n    else if (getline_equal(fgetline, cookie, getsourceline))\n    {\n\tfname = SOURCING_NAME;\n\tbreakpoint = source_breakpoint(real_cookie);\n\tdbg_tick = source_dbg_tick(real_cookie);\n    }\n\n    /*\n     * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level.\n     */\n    if (!recursive)\n    {\n\tforce_abort = FALSE;\n\tsuppress_errthrow = FALSE;\n    }\n\n    /*\n     * If requested, store and reset the global values controlling the\n     * exception handling (used when debugging).  Otherwise clear it to avoid\n     * a bogus compiler warning when the optimizer uses inline functions...\n     */\n    if (flags & DOCMD_EXCRESET)\n\tsave_dbg_stuff(&debug_saved);\n    else\n\tCLEAR_FIELD(debug_saved);\n\n    initial_trylevel = trylevel;\n\n    /*\n     * \"did_throw\" will be set to TRUE when an exception is being thrown.\n     */\n    did_throw = FALSE;\n#endif\n    /*\n     * \"did_emsg\" will be set to TRUE when emsg() is used, in which case we\n     * cancel the whole command line, and any if/endif or loop.\n     * If force_abort is set, we cancel everything.\n     */\n#ifdef FEAT_EVAL\n    did_emsg_cumul += did_emsg;\n#endif\n    did_emsg = FALSE;\n\n    /*\n     * KeyTyped is only set when calling vgetc().  Reset it here when not\n     * calling vgetc() (sourced command lines).\n     */\n    if (!(flags & DOCMD_KEYTYPED)\n\t\t\t       && !getline_equal(fgetline, cookie, getexline))\n\tKeyTyped = FALSE;\n\n    /*\n     * Continue executing command lines:\n     * - when inside an \":if\", \":while\" or \":for\"\n     * - for multiple commands on one line, separated with '|'\n     * - when repeating until there are no more lines (for \":source\")\n     */\n    next_cmdline = cmdline;\n    do\n    {\n#ifdef FEAT_EVAL\n\tgetline_is_func = getline_equal(fgetline, cookie, get_func_line);\n#endif\n\n\t// stop skipping cmds for an error msg after all endif/while/for\n\tif (next_cmdline == NULL\n#ifdef FEAT_EVAL\n\t\t&& !force_abort\n\t\t&& cstack.cs_idx < 0\n\t\t&& !(getline_is_func && func_has_abort(real_cookie))\n#endif\n\t\t\t\t\t\t\t)\n\t{\n#ifdef FEAT_EVAL\n\t    did_emsg_cumul += did_emsg;\n#endif\n\t    did_emsg = FALSE;\n\t}\n\n\t/*\n\t * 1. If repeating a line in a loop, get a line from lines_ga.\n\t * 2. If no line given: Get an allocated line with fgetline().\n\t * 3. If a line is given: Make a copy, so we can mess with it.\n\t */\n\n#ifdef FEAT_EVAL\n\t// 1. If repeating, get a previous line from lines_ga.\n\tif (cstack.cs_looplevel > 0 && current_line < lines_ga.ga_len)\n\t{\n\t    // Each '|' separated command is stored separately in lines_ga, to\n\t    // be able to jump to it.  Don't use next_cmdline now.\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    // Check if a function has returned or, unless it has an unclosed\n\t    // try conditional, aborted.\n\t    if (getline_is_func)\n\t    {\n# ifdef FEAT_PROFILE\n\t\tif (do_profiling == PROF_YES)\n\t\t    func_line_end(real_cookie);\n# endif\n\t\tif (func_has_ended(real_cookie))\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t    }\n#ifdef FEAT_PROFILE\n\t    else if (do_profiling == PROF_YES\n\t\t\t    && getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_end();\n#endif\n\n\t    // Check if a sourced file hit a \":finish\" command.\n\t    if (source_finished(fgetline, cookie))\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // If breakpoints have been added/deleted need to check for it.\n\t    if (breakpoint != NULL && dbg_tick != NULL\n\t\t\t\t\t\t   && *dbg_tick != debug_tick)\n\t    {\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t\tgetline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n\n\t    next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;\n\t    SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;\n\n\t    // Did we encounter a breakpoint?\n\t    if (breakpoint != NULL && *breakpoint != 0\n\t\t\t\t\t      && *breakpoint <= SOURCING_LNUM)\n\t    {\n\t\tdbg_breakpoint(fname, SOURCING_LNUM);\n\t\t// Find next breakpoint.\n\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\tfname, SOURCING_LNUM);\n\t\t*dbg_tick = debug_tick;\n\t    }\n# ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t    {\n\t\tif (getline_is_func)\n\t\t    func_line_start(real_cookie, SOURCING_LNUM);\n\t\telse if (getline_equal(fgetline, cookie, getsourceline))\n\t\t    script_line_start();\n\t    }\n# endif\n\t}\n#endif\n\n\t// 2. If no line given, get an allocated line with fgetline().\n\tif (next_cmdline == NULL)\n\t{\n\t    /*\n\t     * Need to set msg_didout for the first line after an \":if\",\n\t     * otherwise the \":if\" will be overwritten.\n\t     */\n\t    if (count == 1 && getline_equal(fgetline, cookie, getexline))\n\t\tmsg_didout = TRUE;\n\t    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,\n#ifdef FEAT_EVAL\n\t\t    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2\n#else\n\t\t    0\n#endif\n\t\t    , in_vim9script() ? GETLINE_CONCAT_CONTBAR\n\t\t\t\t\t       : GETLINE_CONCAT_CONT)) == NULL)\n\t    {\n\t\t// Don't call wait_return for aborted command line.  The NULL\n\t\t// returned for the end of a sourced file or executed function\n\t\t// doesn't do this.\n\t\tif (KeyTyped && !(flags & DOCMD_REPEAT))\n\t\t    need_wait_return = FALSE;\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    used_getline = TRUE;\n\n\t    /*\n\t     * Keep the first typed line.  Clear it when more lines are typed.\n\t     */\n\t    if (flags & DOCMD_KEEPLINE)\n\t    {\n\t\tvim_free(repeat_cmdline);\n\t\tif (count == 0)\n\t\t    repeat_cmdline = vim_strsave(next_cmdline);\n\t\telse\n\t\t    repeat_cmdline = NULL;\n\t    }\n\t}\n\n\t// 3. Make a copy of the command so we can mess with it.\n\telse if (cmdline_copy == NULL)\n\t{\n\t    next_cmdline = vim_strsave(next_cmdline);\n\t    if (next_cmdline == NULL)\n\t    {\n\t\temsg(_(e_out_of_memory));\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\tcmdline_copy = next_cmdline;\n\n#ifdef FEAT_EVAL\n\t/*\n\t * Inside a while/for loop, and when the command looks like a \":while\"\n\t * or \":for\", the line is stored, because we may need it later when\n\t * looping.\n\t *\n\t * When there is a '|' and another command, it is stored separately,\n\t * because we need to be able to jump back to it from an\n\t * :endwhile/:endfor.\n\t *\n\t * Pass a different \"fgetline\" function to do_one_cmd() below,\n\t * that it stores lines in or reads them from \"lines_ga\".  Makes it\n\t * possible to define a function inside a while/for loop and handles\n\t * line continuation.\n\t */\n\tif ((cstack.cs_looplevel > 0 || has_loop_cmd(next_cmdline)))\n\t{\n\t    cmd_getline = get_loop_line;\n\t    cmd_cookie = (void *)&cmd_loop_cookie;\n\t    cmd_loop_cookie.lines_gap = &lines_ga;\n\t    cmd_loop_cookie.current_line = current_line;\n\t    cmd_loop_cookie.getline = fgetline;\n\t    cmd_loop_cookie.cookie = cookie;\n\t    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);\n\n\t    // Save the current line when encountering it the first time.\n\t    if (current_line == lines_ga.ga_len\n\t\t    && store_loop_line(&lines_ga, next_cmdline) == FAIL)\n\t    {\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n\t    current_line_before = current_line;\n\t}\n\telse\n\t{\n\t    cmd_getline = fgetline;\n\t    cmd_cookie = cookie;\n\t}\n\n\tdid_endif = FALSE;\n#endif\n\n\tif (count++ == 0)\n\t{\n\t    /*\n\t     * All output from the commands is put below each other, without\n\t     * waiting for a return. Don't do this when executing commands\n\t     * from a script or when being called recursive (e.g. for \":e\n\t     * +command file\").\n\t     */\n\t    if (!(flags & DOCMD_NOWAIT) && !recursive)\n\t    {\n\t\tmsg_didout_before_start = msg_didout;\n\t\tmsg_didany = FALSE; // no output yet\n\t\tmsg_start();\n\t\tmsg_scroll = TRUE;  // put messages below each other\n\t\t++no_wait_return;   // don't wait for return until finished\n\t\t++RedrawingDisabled;\n\t\tdid_inc = TRUE;\n\t    }\n\t}\n\n\tif ((p_verbose >= 15 && SOURCING_NAME != NULL) || p_verbose >= 16)\n\t    msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);\n\n\t/*\n\t * 2. Execute one '|' separated command.\n\t *    do_one_cmd() will return NULL if there is no trailing '|'.\n\t *    \"cmdline_copy\" can change, e.g. for '%' and '#' expansion.\n\t */\n\t++recursive;\n\tnext_cmdline = do_one_cmd(&cmdline_copy, flags,\n#ifdef FEAT_EVAL\n\t\t\t\t&cstack,\n#endif\n\t\t\t\tcmd_getline, cmd_cookie);\n\t--recursive;\n\n#ifdef FEAT_EVAL\n\tif (cmd_cookie == (void *)&cmd_loop_cookie)\n\t    // Use \"current_line\" from \"cmd_loop_cookie\", it may have been\n\t    // incremented when defining a function.\n\t    current_line = cmd_loop_cookie.current_line;\n#endif\n\n\tif (next_cmdline == NULL)\n\t{\n\t    VIM_CLEAR(cmdline_copy);\n\n\t    /*\n\t     * If the command was typed, remember it for the ':' register.\n\t     * Do this AFTER executing the command to make :@: work.\n\t     */\n\t    if (getline_equal(fgetline, cookie, getexline)\n\t\t\t\t\t\t  && new_last_cmdline != NULL)\n\t    {\n\t\tvim_free(last_cmdline);\n\t\tlast_cmdline = new_last_cmdline;\n\t\tnew_last_cmdline = NULL;\n\t    }\n\t}\n\telse\n\t{\n\t    // need to copy the command after the '|' to cmdline_copy, for the\n\t    // next do_one_cmd()\n\t    STRMOVE(cmdline_copy, next_cmdline);\n\t    next_cmdline = cmdline_copy;\n\t}\n\n\n#ifdef FEAT_EVAL\n\t// reset did_emsg for a function that is not aborted by an error\n\tif (did_emsg && !force_abort\n\t\t&& getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t      && !func_has_abort(real_cookie))\n\t{\n\t    // did_emsg_cumul is not set here\n\t    did_emsg = FALSE;\n\t}\n\n\tif (cstack.cs_looplevel > 0)\n\t{\n\t    ++current_line;\n\n\t    /*\n\t     * An \":endwhile\", \":endfor\" and \":continue\" is handled here.\n\t     * If we were executing commands, jump back to the \":while\" or\n\t     * \":for\".\n\t     * If we were not executing commands, decrement cs_looplevel.\n\t     */\n\t    if (cstack.cs_lflags & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))\n\t    {\n\t\tcstack.cs_lflags &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);\n\n\t\t// Jump back to the matching \":while\" or \":for\".  Be careful\n\t\t// not to use a cs_line[] from an entry that isn't a \":while\"\n\t\t// or \":for\": It would make \"current_line\" invalid and can\n\t\t// cause a crash.\n\t\tif (!did_emsg && !got_int && !did_throw\n\t\t\t&& cstack.cs_idx >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx]\n\t\t\t\t\t\t      & (CSF_WHILE | CSF_FOR))\n\t\t\t&& cstack.cs_line[cstack.cs_idx] >= 0\n\t\t\t&& (cstack.cs_flags[cstack.cs_idx] & CSF_ACTIVE))\n\t\t{\n\t\t    current_line = cstack.cs_line[cstack.cs_idx];\n\t\t\t\t\t\t// remember we jumped there\n\t\t    cstack.cs_lflags |= CSL_HAD_LOOP;\n\t\t    line_breakcheck();\t\t// check if CTRL-C typed\n\n\t\t    // Check for the next breakpoint at or after the \":while\"\n\t\t    // or \":for\".\n\t\t    if (breakpoint != NULL)\n\t\t    {\n\t\t\t*breakpoint = dbg_find_breakpoint(\n\t\t\t       getline_equal(fgetline, cookie, getsourceline),\n\t\t\t\t\t\t\t\t\tfname,\n\t\t\t   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);\n\t\t\t*dbg_tick = debug_tick;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // can only get here with \":endwhile\" or \":endfor\"\n\t\t    if (cstack.cs_idx >= 0)\n\t\t\trewind_conditionals(&cstack, cstack.cs_idx - 1,\n\t\t\t\t   CSF_WHILE | CSF_FOR, &cstack.cs_looplevel);\n\t\t}\n\t    }\n\n\t    /*\n\t     * For a \":while\" or \":for\" we need to remember the line number.\n\t     */\n\t    else if (cstack.cs_lflags & CSL_HAD_LOOP)\n\t    {\n\t\tcstack.cs_lflags &= ~CSL_HAD_LOOP;\n\t\tcstack.cs_line[cstack.cs_idx] = current_line_before;\n\t    }\n\t}\n\n\t// Check for the next breakpoint after a watchexpression\n\tif (breakpoint != NULL && has_watchexpr())\n\t{\n\t    *breakpoint = dbg_find_breakpoint(FALSE, fname, SOURCING_LNUM);\n\t    *dbg_tick = debug_tick;\n\t}\n\n\t/*\n\t * When not inside any \":while\" loop, clear remembered lines.\n\t */\n\tif (cstack.cs_looplevel == 0)\n\t{\n\t    if (lines_ga.ga_len > 0)\n\t    {\n\t\tSOURCING_LNUM =\n\t\t       ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;\n\t\tfree_cmdlines(&lines_ga);\n\t    }\n\t    current_line = 0;\n\t}\n\n\t/*\n\t * A \":finally\" makes did_emsg, got_int, and did_throw pending for\n\t * being restored at the \":endtry\".  Reset them here and set the\n\t * ACTIVE and FINALLY flags, so that the finally clause gets executed.\n\t * This includes the case where a missing \":endif\", \":endwhile\" or\n\t * \":endfor\" was detected by the \":finally\" itself.\n\t */\n\tif (cstack.cs_lflags & CSL_HAD_FINA)\n\t{\n\t    cstack.cs_lflags &= ~CSL_HAD_FINA;\n\t    report_make_pending(cstack.cs_pending[cstack.cs_idx]\n\t\t    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),\n\t\t    did_throw ? (void *)current_exception : NULL);\n\t    did_emsg = got_int = did_throw = FALSE;\n\t    cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;\n\t}\n\n\t// Update global \"trylevel\" for recursive calls to do_cmdline() from\n\t// within this loop.\n\ttrylevel = initial_trylevel + cstack.cs_trylevel;\n\n\t/*\n\t * If the outermost try conditional (across function calls and sourced\n\t * files) is aborted because of an error, an interrupt, or an uncaught\n\t * exception, cancel everything.  If it is left normally, reset\n\t * force_abort to get the non-EH compatible abortion behavior for\n\t * the rest of the script.\n\t */\n\tif (trylevel == 0 && !did_emsg && !got_int && !did_throw)\n\t    force_abort = FALSE;\n\n\t// Convert an interrupt to an exception if appropriate.\n\t(void)do_intthrow(&cstack);\n#endif // FEAT_EVAL\n\n    }\n    /*\n     * Continue executing command lines when:\n     * - no CTRL-C typed, no aborting error, no exception thrown or try\n     *   conditionals need to be checked for executing finally clauses or\n     *   catching an interrupt exception\n     * - didn't get an error message or lines are not typed\n     * - there is a command after '|', inside a :if, :while, :for or :try, or\n     *   looping for \":source\" command or function call.\n     */\n    while (!((got_int\n#ifdef FEAT_EVAL\n\t\t    || (did_emsg && (force_abort || in_vim9script()))\n\t\t    || did_throw\n#endif\n\t     )\n#ifdef FEAT_EVAL\n\t\t&& cstack.cs_trylevel == 0\n#endif\n\t    )\n\t    && !(did_emsg\n#ifdef FEAT_EVAL\n\t\t// Keep going when inside try/catch, so that the error can be\n\t\t// deal with, except when it is a syntax error, it may cause\n\t\t// the :endtry to be missed.\n\t\t&& (cstack.cs_trylevel == 0 || did_emsg_syntax)\n#endif\n\t\t&& used_getline\n\t\t\t    && (getline_equal(fgetline, cookie, getexmodeline)\n\t\t\t       || getline_equal(fgetline, cookie, getexline)))\n\t    && (next_cmdline != NULL\n#ifdef FEAT_EVAL\n\t\t\t|| cstack.cs_idx >= 0\n#endif\n\t\t\t|| (flags & DOCMD_REPEAT)));\n\n    vim_free(cmdline_copy);\n    did_emsg_syntax = FALSE;\n#ifdef FEAT_EVAL\n    free_cmdlines(&lines_ga);\n    ga_clear(&lines_ga);\n\n    if (cstack.cs_idx >= 0)\n    {\n\t/*\n\t * If a sourced file or executed function ran to its end, report the\n\t * unclosed conditional.\n\t * In Vim9 script do not give a second error, executing aborts after\n\t * the first one.\n\t */\n\tif (!got_int && !did_throw && !aborting()\n\t\t&& !(did_emsg && in_vim9script())\n\t\t&& ((getline_equal(fgetline, cookie, getsourceline)\n\t\t\t&& !source_finished(fgetline, cookie))\n\t\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t    && !func_has_ended(real_cookie))))\n\t{\n\t    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)\n\t\temsg(_(e_missing_endtry));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)\n\t\temsg(_(e_missing_endwhile));\n\t    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)\n\t\temsg(_(e_missing_endfor));\n\t    else\n\t\temsg(_(e_missing_endif));\n\t}\n\n\t/*\n\t * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing\n\t * \":endtry\" in a sourced file or executed function.  If the try\n\t * conditional is in its finally clause, ignore anything pending.\n\t * If it is in a catch clause, finish the caught exception.\n\t * Also cleanup any \"cs_forinfo\" structures.\n\t */\n\tdo\n\t{\n\t    int idx = cleanup_conditionals(&cstack, 0, TRUE);\n\n\t    if (idx >= 0)\n\t\t--idx;\t    // remove try block not in its finally clause\n\t    rewind_conditionals(&cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack.cs_looplevel);\n\t}\n\twhile (cstack.cs_idx >= 0);\n\ttrylevel = initial_trylevel;\n    }\n\n    // If a missing \":endtry\", \":endwhile\", \":endfor\", or \":endif\" or a memory\n    // lack was reported above and the error message is to be converted to an\n    // exception, do this now after rewinding the cstack.\n    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t  ? (char_u *)\"endfunction\" : (char_u *)NULL);\n\n    if (trylevel == 0)\n    {\n\t// Just in case did_throw got set but current_exception wasn't.\n\tif (current_exception == NULL)\n\t    did_throw = FALSE;\n\n\t/*\n\t * When an exception is being thrown out of the outermost try\n\t * conditional, discard the uncaught exception, disable the conversion\n\t * of interrupts or errors to exceptions, and ensure that no more\n\t * commands are executed.\n\t */\n\tif (did_throw)\n\t    handle_did_throw();\n\n\t/*\n\t * On an interrupt or an aborting error not converted to an exception,\n\t * disable the conversion of errors to exceptions.  (Interrupts are not\n\t * converted anymore, here.) This enables also the interrupt message\n\t * when force_abort is set and did_emsg unset in case of an interrupt\n\t * from a finally clause after an error.\n\t */\n\telse if (got_int || (did_emsg && force_abort))\n\t    suppress_errthrow = TRUE;\n    }\n\n    /*\n     * The current cstack will be freed when do_cmdline() returns.  An uncaught\n     * exception will have to be rethrown in the previous cstack.  If a function\n     * has just returned or a script file was just finished and the previous\n     * cstack belongs to the same function or, respectively, script file, it\n     * will have to be checked for finally clauses to be executed due to the\n     * \":return\" or \":finish\".  This is done in do_one_cmd().\n     */\n    if (did_throw)\n\tneed_rethrow = TRUE;\n    if ((getline_equal(fgetline, cookie, getsourceline)\n\t\t&& ex_nesting_level > source_level(real_cookie))\n\t    || (getline_equal(fgetline, cookie, get_func_line)\n\t\t&& ex_nesting_level > func_level(real_cookie) + 1))\n    {\n\tif (!did_throw)\n\t    check_cstack = TRUE;\n    }\n    else\n    {\n\t// When leaving a function, reduce nesting level.\n\tif (getline_equal(fgetline, cookie, get_func_line))\n\t    --ex_nesting_level;\n\t/*\n\t * Go to debug mode when returning from a function in which we are\n\t * single-stepping.\n\t */\n\tif ((getline_equal(fgetline, cookie, getsourceline)\n\t\t    || getline_equal(fgetline, cookie, get_func_line))\n\t\t&& ex_nesting_level + 1 <= debug_break_level)\n\t    do_debug(getline_equal(fgetline, cookie, getsourceline)\n\t\t    ? (char_u *)_(\"End of sourced file\")\n\t\t    : (char_u *)_(\"End of function\"));\n    }\n\n    /*\n     * Restore the exception environment (done after returning from the\n     * debugger).\n     */\n    if (flags & DOCMD_EXCRESET)\n\trestore_dbg_stuff(&debug_saved);\n\n    msg_list = saved_msg_list;\n\n    // Cleanup if \"cs_emsg_silent_list\" remains.\n    if (cstack.cs_emsg_silent_list != NULL)\n    {\n\teslist_T *elem, *temp;\n\n\tfor (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp)\n\t{\n\t    temp = elem->next;\n\t    vim_free(elem);\n\t}\n    }\n#endif // FEAT_EVAL\n\n    /*\n     * If there was too much output to fit on the command line, ask the user to\n     * hit return before redrawing the screen. With the \":global\" command we do\n     * this only once after the command is finished.\n     */\n    if (did_inc)\n    {\n\t--RedrawingDisabled;\n\t--no_wait_return;\n\tmsg_scroll = FALSE;\n\n\t/*\n\t * When just finished an \":if\"-\":else\" which was typed, no need to\n\t * wait for hit-return.  Also for an error situation.\n\t */\n\tif (retval == FAIL\n#ifdef FEAT_EVAL\n\t\t|| (did_endif && KeyTyped && !did_emsg)\n#endif\n\t\t\t\t\t    )\n\t{\n\t    need_wait_return = FALSE;\n\t    msg_didany = FALSE;\t\t// don't wait when restarting edit\n\t}\n\telse if (need_wait_return)\n\t{\n\t    /*\n\t     * The msg_start() above clears msg_didout. The wait_return we do\n\t     * here should not overwrite the command that may be shown before\n\t     * doing that.\n\t     */\n\t    msg_didout |= msg_didout_before_start;\n\t    wait_return(FALSE);\n\t}\n    }\n\n#ifdef FEAT_EVAL\n    did_endif = FALSE;  // in case do_cmdline used recursively\n#else\n    /*\n     * Reset if_level, in case a sourced script file contains more \":if\" than\n     * \":endif\" (could be \":if x | foo | endif\").\n     */\n    if_level = 0;\n#endif\n\n    --call_depth;\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Handle when \"did_throw\" is set after executing commands.\n */\n    void\nhandle_did_throw()\n{\n    char\t*p = NULL;\n    msglist_T\t*messages = NULL;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * If the uncaught exception is a user exception, report it as an\n     * error.  If it is an error exception, display the saved error\n     * message now.  For an interrupt exception, do nothing; the\n     * interrupt message is given elsewhere.\n     */\n    switch (current_exception->type)\n    {\n\tcase ET_USER:\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t    _(e_exception_not_caught_str),\n\t\t    current_exception->value);\n\t    p = (char *)vim_strsave(IObuff);\n\t    break;\n\tcase ET_ERROR:\n\t    messages = current_exception->messages;\n\t    current_exception->messages = NULL;\n\t    break;\n\tcase ET_INTERRUPT:\n\t    break;\n    }\n\n    estack_push(ETYPE_EXCEPT, current_exception->throw_name,\n\t\t\t\t\tcurrent_exception->throw_lnum);\n    ESTACK_CHECK_SETUP\n    current_exception->throw_name = NULL;\n\n    discard_current_exception();\t// uses IObuff if 'verbose'\n    suppress_errthrow = TRUE;\n    force_abort = TRUE;\n\n    if (messages != NULL)\n    {\n\tdo\n\t{\n\t    msglist_T\t*next = messages->next;\n\t    int\t\tsave_compiling = estack_compiling;\n\n\t    estack_compiling = messages->msg_compiling;\n\t    emsg(messages->msg);\n\t    vim_free(messages->msg);\n\t    vim_free(messages->sfile);\n\t    vim_free(messages);\n\t    messages = next;\n\t    estack_compiling = save_compiling;\n\t}\n\twhile (messages != NULL);\n    }\n    else if (p != NULL)\n    {\n\temsg(p);\n\tvim_free(p);\n    }\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n}\n\n/*\n * Obtain a line when inside a \":while\" or \":for\" loop.\n */\n    static char_u *\nget_loop_line(int c, void *cookie, int indent, getline_opt_T options)\n{\n    struct loop_cookie\t*cp = (struct loop_cookie *)cookie;\n    wcmd_T\t\t*wp;\n    char_u\t\t*line;\n\n    if (cp->current_line + 1 >= cp->lines_gap->ga_len)\n    {\n\tif (cp->repeating)\n\t    return NULL;\t// trying to read past \":endwhile\"/\":endfor\"\n\n\t// First time inside the \":while\"/\":for\": get line normally.\n\tif (cp->getline == NULL)\n\t    line = getcmdline(c, 0L, indent, 0);\n\telse\n\t    line = cp->getline(c, cp->cookie, indent, options);\n\tif (line != NULL && store_loop_line(cp->lines_gap, line) == OK)\n\t    ++cp->current_line;\n\n\treturn line;\n    }\n\n    KeyTyped = FALSE;\n    ++cp->current_line;\n    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line;\n    SOURCING_LNUM = wp->lnum;\n    return vim_strsave(wp->line);\n}\n\n/*\n * Store a line in \"gap\" so that a \":while\" loop can execute it again.\n */\n    static int\nstore_loop_line(garray_T *gap, char_u *line)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].line = vim_strsave(line);\n    ((wcmd_T *)(gap->ga_data))[gap->ga_len].lnum = SOURCING_LNUM;\n    ++gap->ga_len;\n    return OK;\n}\n\n/*\n * Free the lines stored for a \":while\" or \":for\" loop.\n */\n    static void\nfree_cmdlines(garray_T *gap)\n{\n    while (gap->ga_len > 0)\n    {\n\tvim_free(((wcmd_T *)(gap->ga_data))[gap->ga_len - 1].line);\n\t--gap->ga_len;\n    }\n}\n#endif\n\n/*\n * If \"fgetline\" is get_loop_line(), return TRUE if the getline it uses equals\n * \"func\".  * Otherwise return TRUE when \"fgetline\" equals \"func\".\n */\n    int\ngetline_equal(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie UNUSED,\t\t// argument for fgetline()\n    char_u\t*(*func)(int, void *, int, getline_opt_T))\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // function that's originally used to obtain the lines.  This may be\n    // nested several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return gp == func;\n#else\n    return fgetline == func;\n#endif\n}\n\n/*\n * If \"fgetline\" is get_loop_line(), return the cookie used by the original\n * getline function.  Otherwise return \"cookie\".\n */\n    void *\ngetline_cookie(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n#ifdef FEAT_EVAL\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    return cp;\n#else\n    return cookie;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROT)\n/*\n * Get the next line source line without advancing.\n */\n    char_u *\ngetline_peek(\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T) UNUSED,\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t\t*(*gp)(int, void *, int, getline_opt_T);\n    struct loop_cookie  *cp;\n    wcmd_T\t\t*wp;\n\n    // When \"fgetline\" is \"get_loop_line()\" use the \"cookie\" to find the\n    // cookie that's originally used to obtain the lines.  This may be nested\n    // several levels.\n    gp = fgetline;\n    cp = (struct loop_cookie *)cookie;\n    while (gp == get_loop_line)\n    {\n\tif (cp->current_line + 1 < cp->lines_gap->ga_len)\n\t{\n\t    // executing lines a second time, use the stored copy\n\t    wp = (wcmd_T *)(cp->lines_gap->ga_data) + cp->current_line + 1;\n\t    return wp->line;\n\t}\n\tgp = cp->getline;\n\tcp = cp->cookie;\n    }\n    if (gp == getsourceline)\n\treturn source_nextline(cp);\n    return NULL;\n}\n#endif\n\n\n/*\n * Helper function to apply an offset for buffer commands, i.e. \":bdelete\",\n * \":bwipeout\", etc.\n * Returns the buffer number.\n */\n    static int\ncompute_buffer_local_count(int addr_type, int lnum, int offset)\n{\n    buf_T   *buf;\n    buf_T   *nextbuf;\n    int     count = offset;\n\n    buf = firstbuf;\n    while (buf->b_next != NULL && buf->b_fnum < lnum)\n\tbuf = buf->b_next;\n    while (count != 0)\n    {\n\tcount += (offset < 0) ? 1 : -1;\n\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\tif (nextbuf == NULL)\n\t    break;\n\tbuf = nextbuf;\n\tif (addr_type == ADDR_LOADED_BUFFERS)\n\t    // skip over unloaded buffers\n\t    while (buf->b_ml.ml_mfp == NULL)\n\t    {\n\t\tnextbuf = (offset < 0) ? buf->b_prev : buf->b_next;\n\t\tif (nextbuf == NULL)\n\t\t    break;\n\t\tbuf = nextbuf;\n\t    }\n    }\n    // we might have gone too far, last buffer is not loadedd\n    if (addr_type == ADDR_LOADED_BUFFERS)\n\twhile (buf->b_ml.ml_mfp == NULL)\n\t{\n\t    nextbuf = (offset >= 0) ? buf->b_prev : buf->b_next;\n\t    if (nextbuf == NULL)\n\t\tbreak;\n\t    buf = nextbuf;\n\t}\n    return buf->b_fnum;\n}\n\n/*\n * Return the window number of \"win\".\n * When \"win\" is NULL return the number of windows.\n */\n    static int\ncurrent_win_nr(win_T *win)\n{\n    win_T\t*wp;\n    int\t\tnr = 0;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\t++nr;\n\tif (wp == win)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncurrent_tab_nr(tabpage_T *tab)\n{\n    tabpage_T\t*tp;\n    int\t\tnr = 0;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\t++nr;\n\tif (tp == tab)\n\t    break;\n    }\n    return nr;\n}\n\n    static int\ncomment_start(char_u *p, int starts_with_colon UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\treturn p[0] == '#' && !starts_with_colon;\n#endif\n    return *p == '\"';\n}\n\n# define CURRENT_WIN_NR current_win_nr(curwin)\n# define LAST_WIN_NR current_win_nr(NULL)\n# define CURRENT_TAB_NR current_tab_nr(curtab)\n# define LAST_TAB_NR current_tab_nr(NULL)\n\n/*\n * Execute one Ex command.\n *\n * If \"flags\" has DOCMD_VERBOSE, the command will be included in the error\n * message.\n *\n * 1. skip comment lines and leading space\n * 2. handle command modifiers\n * 3. find the command\n * 4. parse range\n * 5. Parse the command.\n * 6. parse arguments\n * 7. switch on command name\n *\n * Note: \"fgetline\" can be NULL.\n *\n * This function may be called recursively!\n */\n    static char_u *\ndo_one_cmd(\n    char_u\t**cmdlinep,\n    int\t\tflags,\n#ifdef FEAT_EVAL\n    cstack_T\t*cstack,\n#endif\n    char_u\t*(*fgetline)(int, void *, int, getline_opt_T),\n    void\t*cookie)\t\t// argument for fgetline()\n{\n    char_u\t*p;\n    linenr_T\tlnum;\n    long\tn;\n    char\t*errormsg = NULL;\t// error message\n    char_u\t*after_modifier = NULL;\n    exarg_T\tea;\t\t\t// Ex command arguments\n    cmdmod_T\tsave_cmdmod;\n    int\t\tsave_reg_executing = reg_executing;\n    int\t\tsave_pending_end_reg_executing = pending_end_reg_executing;\n    int\t\tni;\t\t\t// set when Not Implemented\n    char_u\t*cmd;\n    int\t\tstarts_with_colon = FALSE;\n#ifdef FEAT_EVAL\n    int\t\tmay_have_range;\n    int\t\tvim9script;\n    int\t\tdid_set_expr_line = FALSE;\n#endif\n    int\t\tsourcing = flags & DOCMD_VERBOSE;\n    int\t\tdid_append_cmd = FALSE;\n\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n#ifdef FEAT_EVAL\n    ++ex_nesting_level;\n#endif\n\n    // When the last file has not been edited :q has to be typed twice.\n    if (quitmore\n#ifdef FEAT_EVAL\n\t    // avoid that a function call in 'statusline' does this\n\t    && !getline_equal(fgetline, cookie, get_func_line)\n#endif\n\t    // avoid that an autocommand, e.g. QuitPre, does this\n\t    && !getline_equal(fgetline, cookie, getnextac))\n\t--quitmore;\n\n    /*\n     * Reset browse, confirm, etc..  They are restored when returning, for\n     * recursive calls.\n     */\n    save_cmdmod = cmdmod;\n\n    // \"#!anything\" is handled like a comment.\n    if ((*cmdlinep)[0] == '#' && (*cmdlinep)[1] == '!')\n\tgoto doend;\n\n/*\n * 1. Skip comment lines and leading white space and colons.\n * 2. Handle command modifiers.\n */\n    // The \"ea\" structure holds the arguments that can be used.\n    ea.cmd = *cmdlinep;\n    ea.cmdlinep = cmdlinep;\n    ea.getline = fgetline;\n    ea.cookie = cookie;\n#ifdef FEAT_EVAL\n    ea.cstack = cstack;\n    starts_with_colon = *skipwhite(ea.cmd) == ':';\n#endif\n    if (parse_command_modifiers(&ea, &errormsg, &cmdmod, FALSE) == FAIL)\n\tgoto doend;\n    apply_cmdmod(&cmdmod);\n#ifdef FEAT_EVAL\n    vim9script = in_vim9script();\n#endif\n    after_modifier = ea.cmd;\n\n#ifdef FEAT_EVAL\n    ea.skip = did_emsg || got_int || did_throw || (cstack->cs_idx >= 0\n\t\t\t && !(cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE));\n#else\n    ea.skip = (if_level > 0);\n#endif\n\n/*\n * 3. Skip over the range to find the command.  Let \"p\" point to after it.\n *\n * We need the command to know what kind of range it uses.\n */\n    cmd = ea.cmd;\n#ifdef FEAT_EVAL\n    // In Vim9 script a colon is required before the range.  This may also be\n    // after command modifiers.\n    if (vim9script && (flags & DOCMD_RANGEOK) == 0)\n    {\n\tmay_have_range = FALSE;\n\tfor (p = ea.cmd; p >= *cmdlinep; --p)\n\t{\n\t    if (*p == ':')\n\t\tmay_have_range = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n    }\n    else\n\tmay_have_range = TRUE;\n    if (may_have_range)\n#endif\n\tea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\n#ifdef FEAT_EVAL\n    if (vim9script && !may_have_range)\n    {\n\tif (ea.cmd == cmd + 1 && *cmd == '$')\n\t    // should be \"$VAR = val\"\n\t    --ea.cmd;\n\tp = find_ex_command(&ea, NULL, lookup_scriptitem, NULL);\n\tif (ea.cmdidx == CMD_SIZE)\n\t{\n\t    char_u *ar = skip_range(ea.cmd, TRUE, NULL);\n\n\t    // If a ':' before the range is missing, give a clearer error\n\t    // message.\n\t    if (ar > ea.cmd && !ea.skip)\n\t    {\n\t\tsemsg(_(e_colon_required_before_range_str), ea.cmd);\n\t\tgoto doend;\n\t    }\n\t}\n    }\n    else\n#endif\n\tp = find_ex_command(&ea, NULL, NULL, NULL);\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    // Count this line for profiling if skip is TRUE.\n    if (do_profiling == PROF_YES\n\t    && (!ea.skip || cstack->cs_idx == 0 || (cstack->cs_idx > 0\n\t\t     && (cstack->cs_flags[cstack->cs_idx - 1] & CSF_ACTIVE))))\n    {\n\tint skip = did_emsg || got_int || did_throw;\n\n\tif (ea.cmdidx == CMD_catch)\n\t    skip = !skip && !(cstack->cs_idx >= 0\n\t\t\t  && (cstack->cs_flags[cstack->cs_idx] & CSF_THROWN)\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx] & CSF_CAUGHT));\n\telse if (ea.cmdidx == CMD_else || ea.cmdidx == CMD_elseif)\n\t    skip = skip || !(cstack->cs_idx >= 0\n\t\t\t  && !(cstack->cs_flags[cstack->cs_idx]\n\t\t\t\t\t\t  & (CSF_ACTIVE | CSF_TRUE)));\n\telse if (ea.cmdidx == CMD_finally)\n\t    skip = FALSE;\n\telse if (ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endtry\n\t\t&& ea.cmdidx != CMD_endwhile)\n\t    skip = ea.skip;\n\n\tif (!skip)\n\t{\n\t    if (getline_equal(fgetline, cookie, get_func_line))\n\t\tfunc_line_exec(getline_cookie(fgetline, cookie));\n\t    else if (getline_equal(fgetline, cookie, getsourceline))\n\t\tscript_line_exec();\n\t}\n    }\n# endif\n\n    // May go to debug mode.  If this happens and the \">quit\" debug command is\n    // used, throw an interrupt exception and skip the next command.\n    dbg_check_breakpoint(&ea);\n    if (!ea.skip && got_int)\n    {\n\tea.skip = TRUE;\n\t(void)do_intthrow(cstack);\n    }\n#endif\n\n/*\n * 4. parse a range specifier of the form: addr [,addr] [;addr] ..\n *\n * where 'addr' is:\n *\n * %\t      (entire file)\n * $  [+-NUM]\n * 'x [+-NUM] (where x denotes a currently defined mark)\n * .  [+-NUM]\n * [+-NUM]..\n * NUM\n *\n * The ea.cmd pointer is updated to point to the first character following the\n * range spec. If an initial address is found, but no second, the upper bound\n * is equal to the lower.\n */\n\n    // ea.addr_type for user commands is set by find_ucmd\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n    {\n\tif (ea.cmdidx != CMD_SIZE)\n\t    ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;\n\telse\n\t    ea.addr_type = ADDR_LINES;\n\n\t// :wincmd range depends on the argument.\n\tif (ea.cmdidx == CMD_wincmd && p != NULL)\n\t    get_wincmd_addr_type(skipwhite(p), &ea);\n#ifdef FEAT_QUICKFIX\n\t// :.cc in quickfix window uses line number\n\tif ((ea.cmdidx == CMD_cc || ea.cmdidx == CMD_ll) && bt_quickfix(curbuf))\n\t    ea.addr_type = ADDR_OTHER;\n#endif\n    }\n\n    ea.cmd = cmd;\n#ifdef FEAT_EVAL\n    if (!may_have_range)\n\tea.line1 = ea.line2 = default_address(&ea);\n    else\n#endif\n\tif (parse_cmd_address(&ea, &errormsg, FALSE) == FAIL)\n\t    goto doend;\n\n/*\n * 5. Parse the command.\n */\n\n    /*\n     * Skip ':' and any white space\n     */\n    ea.cmd = skipwhite(ea.cmd);\n    while (*ea.cmd == ':')\n\tea.cmd = skipwhite(ea.cmd + 1);\n\n    /*\n     * If we got a line, but no command, then go to the line.\n     * If we find a '|' or '\\n' we set ea.nextcmd.\n     */\n    if (*ea.cmd == NUL || comment_start(ea.cmd, starts_with_colon)\n\t\t\t       || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL)\n    {\n\t/*\n\t * strange vi behaviour:\n\t * \":3\"\t\tjumps to line 3\n\t * \":3|...\"\tprints line 3  (not in Vim9 script)\n\t * \":|\"\t\tprints current line  (not in Vim9 script)\n\t */\n\tif (ea.skip)\t    // skip this if inside :if\n\t    goto doend;\n\terrormsg = ex_range_without_command(&ea);\n\tgoto doend;\n    }\n\n    // If this looks like an undefined user command and there are CmdUndefined\n    // autocommands defined, trigger the matching autocommands.\n    if (p != NULL && ea.cmdidx == CMD_SIZE && !ea.skip\n\t    && ASCII_ISUPPER(*ea.cmd)\n\t    && has_cmdundefined())\n    {\n\tint ret;\n\n\tp = ea.cmd;\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n\tp = vim_strnsave(ea.cmd, p - ea.cmd);\n\tret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, TRUE, NULL);\n\tvim_free(p);\n\t// If the autocommands did something and didn't cause an error, try\n\t// finding the command again.\n\tp = (ret\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t\t) ? find_ex_command(&ea, NULL, NULL, NULL) : ea.cmd;\n    }\n\n    if (p == NULL)\n    {\n\tif (!ea.skip)\n\t    errormsg = _(e_ambiguous_use_of_user_defined_command);\n\tgoto doend;\n    }\n    // Check for wrong commands.\n    if (*p == '!' && ea.cmd[1] == 0151 && ea.cmd[0] == 78\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\terrormsg = uc_fun_cmd();\n\tgoto doend;\n    }\n\n    if (ea.cmdidx == CMD_SIZE)\n    {\n\tif (!ea.skip)\n\t{\n\t    STRCPY(IObuff, _(e_not_an_editor_command));\n\t    if (!sourcing)\n\t    {\n\t\t// If the modifier was parsed OK the error must be in the\n\t\t// following command\n\t\tif (after_modifier != NULL)\n\t\t    append_command(after_modifier);\n\t\telse\n\t\t    append_command(*cmdlinep);\n\t\tdid_append_cmd = TRUE;\n\t    }\n\t    errormsg = (char *)IObuff;\n\t    did_emsg_syntax = TRUE;\n\t}\n\tgoto doend;\n    }\n\n    ni = (!IS_USER_CMDIDX(ea.cmdidx)\n\t    && (cmdnames[ea.cmdidx].cmd_func == ex_ni\n#ifdef HAVE_EX_SCRIPT_NI\n\t     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni\n#endif\n\t     ));\n\n#ifndef FEAT_EVAL\n    /*\n     * When the expression evaluation is disabled, recognize the \":if\" and\n     * \":endif\" commands and ignore everything in between it.\n     */\n    if (ea.cmdidx == CMD_if)\n\t++if_level;\n    if (if_level)\n    {\n\tif (ea.cmdidx == CMD_endif)\n\t    --if_level;\n\tgoto doend;\n    }\n\n#endif\n\n    // forced commands\n    if (*p == '!' && ea.cmdidx != CMD_substitute\n\t    && ea.cmdidx != CMD_smagic && ea.cmdidx != CMD_snomagic)\n    {\n\t++p;\n\tea.forceit = TRUE;\n    }\n    else\n\tea.forceit = FALSE;\n\n/*\n * 6. Parse arguments.  Then check for errors.\n */\n    if (!IS_USER_CMDIDX(ea.cmdidx))\n\tea.argt = (long)cmdnames[(int)ea.cmdidx].cmd_argt;\n\n    if (!ea.skip)\n    {\n#ifdef HAVE_SANDBOX\n\tif (sandbox != 0 && !(ea.argt & EX_SBOXOK))\n\t{\n\t    // Command not allowed in sandbox.\n\t    errormsg = _(e_not_allowed_in_sandbox);\n\t    goto doend;\n\t}\n#endif\n\tif (restricted != 0 && (ea.argt & EX_RESTRICT))\n\t{\n\t    errormsg = _(e_command_not_allowed_in_rvim);\n\t    goto doend;\n\t}\n\tif (!curbuf->b_p_ma && (ea.argt & EX_MODIFY))\n\t{\n\t    // Command not allowed in non-'modifiable' buffer\n\t    errormsg = _(e_cannot_make_changes_modifiable_is_off);\n\t    goto doend;\n\t}\n\n\tif (!IS_USER_CMDIDX(ea.cmdidx))\n\t{\n#ifdef FEAT_CMDWIN\n\t    if (cmdwin_type != 0 && !(ea.argt & EX_CMDWIN))\n\t    {\n\t\t// Command not allowed in the command line window\n\t\terrormsg = _(e_invalid_in_cmdline_window);\n\t\tgoto doend;\n\t    }\n#endif\n\t    if (text_locked() && !(ea.argt & EX_LOCK_OK))\n\t    {\n\t\t// Command not allowed when text is locked\n\t\terrormsg = _(get_text_locked_msg());\n\t\tgoto doend;\n\t    }\n\t}\n\n\t// Disallow editing another buffer when \"curbuf_lock\" is set.\n\t// Do allow \":checktime\" (it is postponed).\n\t// Do allow \":edit\" (check for an argument later).\n\t// Do allow \":file\" with no arguments (check for an argument later).\n\tif (!(ea.argt & (EX_CMDWIN | EX_LOCK_OK))\n\t\t&& ea.cmdidx != CMD_checktime\n\t\t&& ea.cmdidx != CMD_edit\n\t\t&& ea.cmdidx != CMD_file\n\t\t&& !IS_USER_CMDIDX(ea.cmdidx)\n\t\t&& curbuf_locked())\n\t    goto doend;\n\n\tif (!ni && !(ea.argt & EX_RANGE) && ea.addr_count > 0)\n\t{\n\t    errormsg = _(e_no_range_allowed);\n\t    goto doend;\n\t}\n    }\n\n    if (!ni && !(ea.argt & EX_BANG) && ea.forceit)\n    {\n\terrormsg = _(e_no_bang_allowed);\n\tgoto doend;\n    }\n\n    /*\n     * Don't complain about the range if it is not used\n     * (could happen if line_count is accidentally set to 0).\n     */\n    if (!ea.skip && !ni && (ea.argt & EX_RANGE))\n    {\n\t/*\n\t * If the range is backwards, ask for confirmation and, if given, swap\n\t * ea.line1 & ea.line2 so it's forwards again.\n\t * When global command is busy, don't ask, will fail below.\n\t */\n\tif (!global_busy && ea.line1 > ea.line2)\n\t{\n\t    if (msg_silent == 0)\n\t    {\n\t\tif (sourcing || exmode_active)\n\t\t{\n\t\t    errormsg = _(e_backwards_range_given);\n\t\t    goto doend;\n\t\t}\n\t\tif (ask_yesno((char_u *)\n\t\t\t_(\"Backwards range given, OK to swap\"), FALSE) != 'y')\n\t\t    goto doend;\n\t    }\n\t    lnum = ea.line1;\n\t    ea.line1 = ea.line2;\n\t    ea.line2 = lnum;\n\t}\n\tif ((errormsg = invalid_range(&ea)) != NULL)\n\t    goto doend;\n    }\n\n    if ((ea.addr_type == ADDR_OTHER) && ea.addr_count == 0)\n\t// default is 1, not cursor\n\tea.line2 = 1;\n\n    correct_range(&ea);\n\n#ifdef FEAT_FOLDING\n    if (((ea.argt & EX_WHOLEFOLD) || ea.addr_count >= 2) && !global_busy\n\t    && ea.addr_type == ADDR_LINES)\n    {\n\t// Put the first line at the start of a closed fold, put the last line\n\t// at the end of a closed fold.\n\t(void)hasFolding(ea.line1, &ea.line1, NULL);\n\t(void)hasFolding(ea.line2, NULL, &ea.line2);\n    }\n#endif\n\n#ifdef FEAT_QUICKFIX\n    /*\n     * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'\n     * option here, so things like % get expanded.\n     */\n    p = replace_makeprg(&ea, p, cmdlinep);\n    if (p == NULL)\n\tgoto doend;\n#endif\n\n    /*\n     * Skip to start of argument.\n     * Don't do this for the \":!\" command, because \":!! -l\" needs the space.\n     */\n    if (ea.cmdidx == CMD_bang)\n\tea.arg = p;\n    else\n\tea.arg = skipwhite(p);\n\n    // \":file\" cannot be run with an argument when \"curbuf_lock\" is set\n    if (ea.cmdidx == CMD_file && *ea.arg != NUL && curbuf_locked())\n\tgoto doend;\n\n    /*\n     * Check for \"++opt=val\" argument.\n     * Must be first, allow \":w ++enc=utf8 !cmd\"\n     */\n    if (ea.argt & EX_ARGOPT)\n\twhile (ea.arg[0] == '+' && ea.arg[1] == '+')\n\t    if (getargopt(&ea) == FAIL && !ni)\n\t    {\n\t\terrormsg = _(e_invalid_argument);\n\t\tgoto doend;\n\t    }\n\n    if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update)\n    {\n\tif (*ea.arg == '>')\t\t\t// append\n\t{\n\t    if (*++ea.arg != '>')\t\t// typed wrong\n\t    {\n\t\terrormsg = _(e_use_w_or_w_gt_gt);\n\t\tgoto doend;\n\t    }\n\t    ea.arg = skipwhite(ea.arg + 1);\n\t    ea.append = TRUE;\n\t}\n\telse if (*ea.arg == '!' && ea.cmdidx == CMD_write)  // :w !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_read)\n    {\n\tif (ea.forceit)\n\t{\n\t    ea.usefilter = TRUE;\t\t// :r! filter if ea.forceit\n\t    ea.forceit = FALSE;\n\t}\n\telse if (*ea.arg == '!')\t\t// :r !filter\n\t{\n\t    ++ea.arg;\n\t    ea.usefilter = TRUE;\n\t}\n    }\n\n    if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift)\n    {\n\tea.amount = 1;\n\twhile (*ea.arg == *ea.cmd)\t\t// count number of '>' or '<'\n\t{\n\t    ++ea.arg;\n\t    ++ea.amount;\n\t}\n\tea.arg = skipwhite(ea.arg);\n    }\n\n    /*\n     * Check for \"+command\" argument, before checking for next command.\n     * Don't do this for \":read !cmd\" and \":write !cmd\".\n     */\n    if ((ea.argt & EX_CMDARG) && !ea.usefilter)\n\tea.do_ecmd_cmd = getargcmd(&ea.arg);\n\n    /*\n     * For commands that do not use '|' inside their argument: Check for '|' to\n     * separate commands and '\"' or '#' to start comments.\n     *\n     * Otherwise: Check for <newline> to end a shell command.\n     * Also do this for \":read !cmd\", \":write !cmd\" and \":global\".\n     * Also do this inside a { - } block after :command and :autocmd.\n     * Any others?\n     */\n    if ((ea.argt & EX_TRLBAR) && !ea.usefilter)\n    {\n\tseparate_nextcmd(&ea, FALSE);\n    }\n    else if (ea.cmdidx == CMD_bang\n\t    || ea.cmdidx == CMD_terminal\n\t    || ea.cmdidx == CMD_global\n\t    || ea.cmdidx == CMD_vglobal\n\t    || ea.usefilter\n#ifdef FEAT_EVAL\n\t    || inside_block(&ea)\n#endif\n\t    )\n    {\n\tfor (p = ea.arg; *p; ++p)\n\t{\n\t    // Remove one backslash before a newline, so that it's possible to\n\t    // pass a newline to the shell and also a newline that is preceded\n\t    // with a backslash.  This makes it impossible to end a shell\n\t    // command in a backslash, but that doesn't appear useful.\n\t    // Halving the number of backslashes is incompatible with previous\n\t    // versions.\n\t    if (*p == '\\\\' && p[1] == '\\n')\n\t\tSTRMOVE(p, p + 1);\n\t    else if (*p == '\\n' && !(ea.argt & EX_EXPR_ARG))\n\t    {\n\t\tea.nextcmd = p + 1;\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if ((ea.argt & EX_DFLALL) && ea.addr_count == 0)\n\taddress_default_all(&ea);\n\n    // accept numbered register only when no count allowed (:put)\n    if (       (ea.argt & EX_REGSTR)\n\t    && *ea.arg != NUL\n\t       // Do not allow register = for user commands\n\t    && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')\n\t    && !((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)))\n    {\n#ifndef FEAT_CLIPBOARD\n\t// check these explicitly for a more specific error message\n\tif (*ea.arg == '*' || *ea.arg == '+')\n\t{\n\t    errormsg = _(e_invalid_register_name);\n\t    goto doend;\n\t}\n#endif\n\tif (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put\n\t\t\t\t\t      && !IS_USER_CMDIDX(ea.cmdidx))))\n\t{\n\t    ea.regname = *ea.arg++;\n#ifdef FEAT_EVAL\n\t    // for '=' register: accept the rest of the line as an expression\n\t    if (ea.arg[-1] == '=' && ea.arg[0] != NUL)\n\t    {\n\t\tif (!ea.skip)\n\t\t{\n\t\t    set_expr_line(vim_strsave(ea.arg), &ea);\n\t\t    did_set_expr_line = TRUE;\n\t\t}\n\t\tea.arg += STRLEN(ea.arg);\n\t    }\n#endif\n\t    ea.arg = skipwhite(ea.arg);\n\t}\n    }\n\n    /*\n     * Check for a count.  When accepting a EX_BUFNAME, don't use \"123foo\" as a\n     * count, it's a buffer name.\n     */\n    if ((ea.argt & EX_COUNT) && VIM_ISDIGIT(*ea.arg)\n\t    && (!(ea.argt & EX_BUFNAME) || *(p = skipdigits(ea.arg + 1)) == NUL\n\t\t\t\t\t\t\t  || VIM_ISWHITE(*p)))\n    {\n\tn = getdigits_quoted(&ea.arg);\n\tea.arg = skipwhite(ea.arg);\n\tif (n <= 0 && !ni && (ea.argt & EX_ZEROR) == 0)\n\t{\n\t    errormsg = _(e_positive_count_required);\n\t    goto doend;\n\t}\n\tif (ea.addr_type != ADDR_LINES)\t// e.g. :buffer 2, :sleep 3\n\t{\n\t    ea.line2 = n;\n\t    if (ea.addr_count == 0)\n\t\tea.addr_count = 1;\n\t}\n\telse\n\t{\n\t    ea.line1 = ea.line2;\n\t    if (ea.line2 >= LONG_MAX - (n - 1))\n\t\tea.line2 = LONG_MAX;  // avoid overflow\n\t    else\n\t\tea.line2 += n - 1;\n\t    ++ea.addr_count;\n\t    /*\n\t     * Be vi compatible: no error message for out of range.\n\t     */\n\t    if (ea.line2 > curbuf->b_ml.ml_line_count)\n\t\tea.line2 = curbuf->b_ml.ml_line_count;\n\t}\n    }\n\n    /*\n     * Check for flags: 'l', 'p' and '#'.\n     */\n    if (ea.argt & EX_FLAGS)\n\tget_flags(&ea);\n    if (!ni && !(ea.argt & EX_EXTRA) && *ea.arg != NUL\n\t    && *ea.arg != '\"' && (*ea.arg != '|' || (ea.argt & EX_TRLBAR) == 0))\n    {\n\t// no arguments allowed but there is something\n\terrormsg = ex_errmsg(e_trailing_characters_str, ea.arg);\n\tgoto doend;\n    }\n\n    if (!ni && (ea.argt & EX_NEEDARG) && *ea.arg == NUL)\n    {\n\terrormsg = _(e_argument_required);\n\tgoto doend;\n    }\n\n#ifdef FEAT_EVAL\n    /*\n     * Skip the command when it's not going to be executed.\n     * The commands like :if, :endif, etc. always need to be executed.\n     * Also make an exception for commands that handle a trailing command\n     * themselves.\n     */\n    if (ea.skip)\n    {\n\tswitch (ea.cmdidx)\n\t{\n\t    // commands that need evaluation\n\t    case CMD_while:\n\t    case CMD_endwhile:\n\t    case CMD_for:\n\t    case CMD_endfor:\n\t    case CMD_if:\n\t    case CMD_elseif:\n\t    case CMD_else:\n\t    case CMD_endif:\n\t    case CMD_try:\n\t    case CMD_catch:\n\t    case CMD_finally:\n\t    case CMD_endtry:\n\t    case CMD_function:\n\t    case CMD_def:\n\t\t\t\tbreak;\n\n\t    // Commands that handle '|' themselves.  Check: A command should\n\t    // either have the EX_TRLBAR flag, appear in this list or appear in\n\t    // the list at \":help :bar\".\n\t    case CMD_aboveleft:\n\t    case CMD_and:\n\t    case CMD_belowright:\n\t    case CMD_botright:\n\t    case CMD_browse:\n\t    case CMD_call:\n\t    case CMD_confirm:\n\t    case CMD_const:\n\t    case CMD_delfunction:\n\t    case CMD_djump:\n\t    case CMD_dlist:\n\t    case CMD_dsearch:\n\t    case CMD_dsplit:\n\t    case CMD_echo:\n\t    case CMD_echoerr:\n\t    case CMD_echomsg:\n\t    case CMD_echon:\n\t    case CMD_eval:\n\t    case CMD_execute:\n\t    case CMD_filter:\n\t    case CMD_final:\n\t    case CMD_help:\n\t    case CMD_hide:\n\t    case CMD_ijump:\n\t    case CMD_ilist:\n\t    case CMD_isearch:\n\t    case CMD_isplit:\n\t    case CMD_keepalt:\n\t    case CMD_keepjumps:\n\t    case CMD_keepmarks:\n\t    case CMD_keeppatterns:\n\t    case CMD_leftabove:\n\t    case CMD_let:\n\t    case CMD_lockmarks:\n\t    case CMD_lockvar:\n\t    case CMD_lua:\n\t    case CMD_match:\n\t    case CMD_mzscheme:\n\t    case CMD_noautocmd:\n\t    case CMD_noswapfile:\n\t    case CMD_perl:\n\t    case CMD_psearch:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_return:\n\t    case CMD_rightbelow:\n\t    case CMD_ruby:\n\t    case CMD_silent:\n\t    case CMD_smagic:\n\t    case CMD_snomagic:\n\t    case CMD_substitute:\n\t    case CMD_syntax:\n\t    case CMD_tab:\n\t    case CMD_tcl:\n\t    case CMD_throw:\n\t    case CMD_tilde:\n\t    case CMD_topleft:\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_var:\n\t    case CMD_verbose:\n\t    case CMD_vertical:\n\t    case CMD_wincmd:\n\t\t\t\tbreak;\n\n\t    default:\t\tgoto doend;\n\t}\n    }\n#endif\n\n    if (ea.argt & EX_XFILE)\n    {\n\tif (expand_filename(&ea, cmdlinep, &errormsg) == FAIL)\n\t    goto doend;\n    }\n\n    /*\n     * Accept buffer name.  Cannot be used at the same time with a buffer\n     * number.  Don't do this for a user command.\n     */\n    if ((ea.argt & EX_BUFNAME) && *ea.arg != NUL && ea.addr_count == 0\n\t    && !IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * :bdelete, :bwipeout and :bunload take several arguments, separated\n\t * by spaces: find next space (skipping over escaped characters).\n\t * The others take one argument: ignore trailing spaces.\n\t */\n\tif (ea.cmdidx == CMD_bdelete || ea.cmdidx == CMD_bwipeout\n\t\t\t\t\t\t  || ea.cmdidx == CMD_bunload)\n\t    p = skiptowhite_esc(ea.arg);\n\telse\n\t{\n\t    p = ea.arg + STRLEN(ea.arg);\n\t    while (p > ea.arg && VIM_ISWHITE(p[-1]))\n\t\t--p;\n\t}\n\tea.line2 = buflist_findpat(ea.arg, p, (ea.argt & EX_BUFUNL) != 0,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\tif (ea.line2 < 0)\t    // failed\n\t    goto doend;\n\tea.addr_count = 1;\n\tea.arg = skipwhite(p);\n    }\n\n    // The :try command saves the emsg_silent flag, reset it here when\n    // \":silent! try\" was used, it should only apply to :try itself.\n    if (ea.cmdidx == CMD_try && cmdmod.cmod_did_esilent > 0)\n    {\n\temsg_silent -= cmdmod.cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\tcmdmod.cmod_did_esilent = 0;\n    }\n\n/*\n * 7. Execute the command.\n */\n\n    if (IS_USER_CMDIDX(ea.cmdidx))\n    {\n\t/*\n\t * Execute a user-defined command.\n\t */\n\tdo_ucmd(&ea);\n    }\n    else\n    {\n\t/*\n\t * Call the function to execute the builtin command.\n\t */\n\tea.errmsg = NULL;\n\t(cmdnames[ea.cmdidx].cmd_func)(&ea);\n\tif (ea.errmsg != NULL)\n\t    errormsg = ea.errmsg;\n    }\n\n#ifdef FEAT_EVAL\n    // Set flag that any command was executed, used by ex_vim9script().\n    // Not if this was a command that wasn't executed or :endif.\n    if (sourcing_a_script(&ea)\n\t    && current_sctx.sc_sid > 0\n\t    && ea.cmdidx != CMD_endif\n\t    && (cstack->cs_idx < 0\n\t\t    || (cstack->cs_flags[cstack->cs_idx] & CSF_ACTIVE)))\n\tSCRIPT_ITEM(current_sctx.sc_sid)->sn_state = SN_STATE_HAD_COMMAND;\n\n    /*\n     * If the command just executed called do_cmdline(), any throw or \":return\"\n     * or \":finish\" encountered there must also check the cstack of the still\n     * active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught\n     * exception, or reanimate a returned function or finished script file and\n     * return or finish it again.\n     */\n    if (need_rethrow)\n\tdo_throw(cstack);\n    else if (check_cstack)\n    {\n\tif (source_finished(fgetline, cookie))\n\t    do_finish(&ea, TRUE);\n\telse if (getline_equal(fgetline, cookie, get_func_line)\n\t\t\t\t\t\t   && current_func_returned())\n\t    do_return(&ea, TRUE, FALSE, NULL);\n    }\n    need_rethrow = check_cstack = FALSE;\n#endif\n\ndoend:\n    if (curwin->w_cursor.lnum == 0)\t// can happen with zero line number\n    {\n\tcurwin->w_cursor.lnum = 1;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    if (errormsg != NULL && *errormsg != NUL && !did_emsg)\n    {\n\tif ((sourcing || !KeyTyped) && !did_append_cmd)\n\t{\n\t    if (errormsg != (char *)IObuff)\n\t    {\n\t\tSTRCPY(IObuff, errormsg);\n\t\terrormsg = (char *)IObuff;\n\t    }\n\t    append_command(*cmdlinep);\n\t}\n\temsg(errormsg);\n    }\n#ifdef FEAT_EVAL\n    do_errthrow(cstack,\n\t    (ea.cmdidx != CMD_SIZE && !IS_USER_CMDIDX(ea.cmdidx))\n\t\t\t? cmdnames[(int)ea.cmdidx].cmd_name : (char_u *)NULL);\n\n    if (did_set_expr_line)\n\tset_expr_line(NULL, NULL);\n#endif\n\n    undo_cmdmod(&cmdmod);\n    cmdmod = save_cmdmod;\n    reg_executing = save_reg_executing;\n    pending_end_reg_executing = save_pending_end_reg_executing;\n\n    if (ea.nextcmd && *ea.nextcmd == NUL)\t// not really a next command\n\tea.nextcmd = NULL;\n\n#ifdef FEAT_EVAL\n    --ex_nesting_level;\n    vim_free(ea.cmdline_tofree);\n#endif\n\n    return ea.nextcmd;\n}\n\nstatic char ex_error_buf[MSG_BUF_LEN];\n\n/*\n * Return an error message with argument included.\n * Uses a static buffer, only the last error will be kept.\n * \"msg\" will be translated, caller should use N_().\n */\n     char *\nex_errmsg(char *msg, char_u *arg)\n{\n    vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);\n    return ex_error_buf;\n}\n\n/*\n * Handle a range without a command.\n * Returns an error message on failure.\n */\n    char *\nex_range_without_command(exarg_T *eap)\n{\n    char *errormsg = NULL;\n\n    if ((*eap->cmd == '|' || (exmode_active && eap->line1 != eap->line2))\n#ifdef FEAT_EVAL\n\t    && !in_vim9script()\n#endif\n       )\n    {\n\teap->cmdidx = CMD_print;\n\teap->argt = EX_RANGE+EX_COUNT+EX_TRLBAR;\n\tif ((errormsg = invalid_range(eap)) == NULL)\n\t{\n\t    correct_range(eap);\n\t    ex_print(eap);\n\t}\n    }\n    else if (eap->addr_count != 0)\n    {\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t{\n\t    // With '-' in 'cpoptions' a line number past the file is an\n\t    // error, otherwise put it at the end of the file.\n\t    if (vim_strchr(p_cpo, CPO_MINUS) != NULL)\n\t\teap->line2 = -1;\n\t    else\n\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t}\n\n\tif (eap->line2 < 0)\n\t    errormsg = _(e_invalid_range);\n\telse\n\t{\n\t    if (eap->line2 == 0)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    return errormsg;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n * If \"noparen\" is TRUE do not recognize the command followed by \"(\" or \".\".\n */\n    static int\ncheckforcmd_opt(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen,\t\t// required length\n    int\t\tnoparen)\n{\n    int\t\ti;\n\n    for (i = 0; cmd[i] != NUL; ++i)\n\tif (((char_u *)cmd)[i] != (*pp)[i])\n\t    break;\n    if (i >= len && !isalpha((*pp)[i]) && (*pp)[i] != '_'\n\t\t\t && (!noparen || ((*pp)[i] != '(' && (*pp)[i] != '.')))\n    {\n\t*pp = skipwhite(*pp + i);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check for an Ex command with optional tail.\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, FALSE);\n}\n\n/*\n * Check for an Ex command with optional tail, not followed by \"(\" or \".\".\n * If there is a match advance \"pp\" to the argument and return TRUE.\n */\n    int\ncheckforcmd_noparen(\n    char_u\t**pp,\t\t// start of command\n    char\t*cmd,\t\t// name of command\n    int\t\tlen)\t\t// required length\n{\n    return checkforcmd_opt(pp, cmd, len, TRUE);\n}\n\n/*\n * Parse and skip over command modifiers:\n * - update eap->cmd\n * - store flags in \"cmod\".\n * - Set ex_pressedreturn for an empty command line.\n * When \"skip_only\" is TRUE the global variables are not changed, except for\n * \"cmdmod\".\n * When \"skip_only\" is FALSE then undo_cmdmod() must be called later to free\n * any cmod_filter_regmatch.regprog.\n * Call apply_cmdmod() to get the side effects of the modifiers:\n * - Increment \"sandbox\" for \":sandbox\"\n * - set p_verbose for \":verbose\"\n * - set msg_silent for \":silent\"\n * - set 'eventignore' to \"all\" for \":noautocmd\"\n * Return FAIL when the command is not to be executed.\n * May set \"errormsg\" to an error message.\n */\n    int\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t// range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd, '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod, FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s); ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\tif (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd, \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3, TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n#endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4, TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat# cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\tp = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t    else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p, &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL || *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd, \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\", 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\", 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\tif (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd, \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t    cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t    ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\", 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\", 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t    // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\tbreak;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\t    // Since the modifiers have been parsed put the colon on top of the\n\t    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\t\t//  longer, in case is was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start, len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -= 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t    // No modifiers, move the pointer back.\n\t    // Special case: change empty command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\";\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\teap->cmd = (char_u *)\"+\";\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"cmod\" has anything set.\n */\n    int\nhas_cmdmod(cmdmod_T *cmod, int ignore_silent)\n{\n    return (cmod->cmod_flags != 0 && (!ignore_silent\n\t\t|| (cmod->cmod_flags\n\t\t      & ~(CMOD_SILENT | CMOD_ERRSILENT | CMOD_UNSILENT)) != 0))\n\t    || cmod->cmod_split != 0\n\t    || cmod->cmod_verbose > 0\n\t    || cmod->cmod_tab != 0\n\t    || cmod->cmod_filter_regmatch.regprog != NULL;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If Vim9 script and \"cmdmod\" has anything set give an error and return TRUE.\n */\n    int\ncmdmod_error(int ignore_silent)\n{\n    if (in_vim9script() && has_cmdmod(&cmdmod, ignore_silent))\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Apply the command modifiers.  Saves current state in \"cmdmod\", call\n * undo_cmdmod() later.\n */\n    void\napply_cmdmod(cmdmod_T *cmod)\n{\n#ifdef HAVE_SANDBOX\n    if ((cmod->cmod_flags & CMOD_SANDBOX) && !cmod->cmod_did_sandbox)\n    {\n\t++sandbox;\n\tcmod->cmod_did_sandbox = TRUE;\n    }\n#endif\n    if (cmod->cmod_verbose > 0)\n    {\n\tif (cmod->cmod_verbose_save == 0)\n\t    cmod->cmod_verbose_save = p_verbose + 1;\n\tp_verbose = cmod->cmod_verbose - 1;\n    }\n\n    if ((cmod->cmod_flags & (CMOD_SILENT | CMOD_UNSILENT))\n\t    && cmod->cmod_save_msg_silent == 0)\n    {\n\tcmod->cmod_save_msg_silent = msg_silent + 1;\n\tcmod->cmod_save_msg_scroll = msg_scroll;\n    }\n    if (cmod->cmod_flags & CMOD_SILENT)\n\t++msg_silent;\n    if (cmod->cmod_flags & CMOD_UNSILENT)\n\tmsg_silent = 0;\n\n    if (cmod->cmod_flags & CMOD_ERRSILENT)\n    {\n\t++emsg_silent;\n\t++cmod->cmod_did_esilent;\n    }\n\n    if ((cmod->cmod_flags & CMOD_NOAUTOCMD) && cmod->cmod_save_ei == NULL)\n    {\n\t// Set 'eventignore' to \"all\".\n\t// First save the existing option value for restoring it later.\n\tcmod->cmod_save_ei = vim_strsave(p_ei);\n\tset_string_option_direct((char_u *)\"ei\", -1,\n\t\t\t\t\t  (char_u *)\"all\", OPT_FREE, SID_NONE);\n    }\n}\n\n/*\n * Undo and free contents of \"cmod\".\n */\n    void\nundo_cmdmod(cmdmod_T *cmod)\n{\n    if (cmod->cmod_verbose_save > 0)\n    {\n\tp_verbose = cmod->cmod_verbose_save - 1;\n\tcmod->cmod_verbose_save = 0;\n    }\n\n#ifdef HAVE_SANDBOX\n    if (cmod->cmod_did_sandbox)\n    {\n\t--sandbox;\n\tcmod->cmod_did_sandbox = FALSE;\n    }\n#endif\n\n    if (cmod->cmod_save_ei != NULL)\n    {\n\t// Restore 'eventignore' to the value before \":noautocmd\".\n\tset_string_option_direct((char_u *)\"ei\", -1, cmod->cmod_save_ei,\n\t\t\t\t\t\t\t   OPT_FREE, SID_NONE);\n\tfree_string_option(cmod->cmod_save_ei);\n\tcmod->cmod_save_ei = NULL;\n    }\n\n    vim_regfree(cmod->cmod_filter_regmatch.regprog);\n\n    if (cmod->cmod_save_msg_silent > 0)\n    {\n\t// messages could be enabled for a serious error, need to check if the\n\t// counters don't become negative\n\tif (!did_emsg || msg_silent > cmod->cmod_save_msg_silent - 1)\n\t    msg_silent = cmod->cmod_save_msg_silent - 1;\n\temsg_silent -= cmod->cmod_did_esilent;\n\tif (emsg_silent < 0)\n\t    emsg_silent = 0;\n\t// Restore msg_scroll, it's set by file I/O commands, even when no\n\t// message is actually displayed.\n\tmsg_scroll = cmod->cmod_save_msg_scroll;\n\n\t// \"silent reg\" or \"silent echo x\" inside \"redir\" leaves msg_col\n\t// somewhere in the line.  Put it back in the first column.\n\tif (redirecting())\n\t    msg_col = 0;\n\n\tcmod->cmod_save_msg_silent = 0;\n\tcmod->cmod_did_esilent = 0;\n    }\n}\n\n/*\n * Parse the address range, if any, in \"eap\".\n * May set the last search pattern, unless \"silent\" is TRUE.\n * Return FAIL and set \"errormsg\" or return OK.\n */\n    int\nparse_cmd_address(exarg_T *eap, char **errormsg, int silent)\n{\n    int\t\taddress_count = 1;\n    linenr_T\tlnum;\n    int\t\tneed_check_cursor = FALSE;\n    int\t\tret = FAIL;\n\n    // Repeat for all ',' or ';' separated addresses.\n    for (;;)\n    {\n\teap->line1 = eap->line2;\n\teap->line2 = default_address(eap);\n\teap->cmd = skipwhite(eap->cmd);\n\tlnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent,\n\t\t\t\t\teap->addr_count == 0, address_count++);\n\tif (eap->cmd == NULL)\t// error detected\n\t    goto theend;\n\tif (lnum == MAXLNUM)\n\t{\n\t    if (*eap->cmd == '%')   // '%' - all lines\n\t    {\n\t\t++eap->cmd;\n\t\tswitch (eap->addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\t{\n\t\t\t    buf_T\t*buf = firstbuf;\n\n\t\t\t    while (buf->b_next != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_next;\n\t\t\t    eap->line1 = buf->b_fnum;\n\t\t\t    buf = lastbuf;\n\t\t\t    while (buf->b_prev != NULL\n\t\t\t\t\t\t  && buf->b_ml.ml_mfp == NULL)\n\t\t\t\tbuf = buf->b_prev;\n\t\t\t    eap->line2 = buf->b_fnum;\n\t\t\t    break;\n\t\t\t}\n\t\t    case ADDR_BUFFERS:\n\t\t\teap->line1 = firstbuf->b_fnum;\n\t\t\teap->line2 = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t    case ADDR_TABS:\n\t\t\tif (IS_USER_CMDIDX(eap->cmdidx))\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = eap->addr_type == ADDR_WINDOWS\n\t\t\t\t\t\t  ? LAST_WIN_NR : LAST_TAB_NR;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // there is no Vim command which uses '%' and\n\t\t\t    // ADDR_WINDOWS or ADDR_TABS\n\t\t\t    *errormsg = _(e_invalid_range);\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t    case ADDR_QUICKFIX:\n\t\t\t*errormsg = _(e_invalid_range);\n\t\t\tgoto theend;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tif (ARGCOUNT == 0)\n\t\t\t    eap->line1 = eap->line2 = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t    eap->line1 = 1;\n\t\t\t    eap->line2 = ARGCOUNT;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\teap->line1 = 1;\n\t\t\teap->line2 = qf_get_valid_size(eap);\n\t\t\tif (eap->line2 == 0)\n\t\t\t    eap->line2 = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t\t// Will give an error later if a range is found.\n\t\t\tbreak;\n\t\t}\n\t\t++eap->addr_count;\n\t    }\n\t    else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    {\n\t\tpos_T\t    *fp;\n\n\t\t// '*' - visual area\n\t\tif (eap->addr_type != ADDR_LINES)\n\t\t{\n\t\t    *errormsg = _(e_invalid_range);\n\t\t    goto theend;\n\t\t}\n\n\t\t++eap->cmd;\n\t\tif (!eap->skip)\n\t\t{\n\t\t    fp = getmark('<', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line1 = fp->lnum;\n\t\t    fp = getmark('>', FALSE);\n\t\t    if (check_mark(fp) == FAIL)\n\t\t\tgoto theend;\n\t\t    eap->line2 = fp->lnum;\n\t\t    ++eap->addr_count;\n\t\t}\n\t    }\n\t}\n\telse\n\t    eap->line2 = lnum;\n\teap->addr_count++;\n\n\tif (*eap->cmd == ';')\n\t{\n\t    if (!eap->skip)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line2;\n\n\t\t// Don't leave the cursor on an illegal line or column, but do\n\t\t// accept zero as address, so 0;/PATTERN/ works correctly\n\t\t// (where zero usually means to use the first line).\n\t\t// Check the cursor position before returning.\n\t\tif (eap->line2 > 0)\n\t\t    check_cursor();\n\t\telse\n\t\t    check_cursor_col();\n\t\tneed_check_cursor = TRUE;\n\t    }\n\t}\n\telse if (*eap->cmd != ',')\n\t    break;\n\t++eap->cmd;\n    }\n\n    // One address given: set start and end lines.\n    if (eap->addr_count == 1)\n    {\n\teap->line1 = eap->line2;\n\t// ... but only implicit: really no address given\n\tif (lnum == MAXLNUM)\n\t    eap->addr_count = 0;\n    }\n    ret = OK;\n\ntheend:\n    if (need_check_cursor)\n\tcheck_cursor();\n    return ret;\n}\n\n/*\n * Append \"cmd\" to the error message in IObuff.\n * Takes care of limiting the length and handling 0xa0, which would be\n * invisible otherwise.\n */\n    static void\nappend_command(char_u *cmd)\n{\n    size_t  len = STRLEN(IObuff);\n    char_u  *s = cmd;\n    char_u  *d;\n\n    if (len > IOSIZE - 100)\n    {\n\t// Not enough space, truncate and put in \"...\".\n\td = IObuff + IOSIZE - 100;\n\td -= mb_head_off(IObuff, d);\n\tSTRCPY(d, \"...\");\n    }\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * If \"start\" points \"&opt\", \"&l:opt\", \"&g:opt\" or \"$ENV\" return a pointer to\n * the name.  Otherwise just return \"start\".\n */\n    char_u *\nskip_option_env_lead(char_u *start)\n{\n    char_u *name = start;\n\n    if (*start == '&')\n    {\n\tif ((start[1] == 'l' || start[1] == 'g') && start[2] == ':')\n\t    name += 3;\n\telse\n\t    name += 1;\n    }\n    else if (*start == '$')\n\tname += 1;\n    return name;\n}\n#endif\n\n/*\n * Return TRUE and set \"*idx\" if \"p\" points to a one letter command.\n * If not in Vim9 script:\n * - The 'k' command can directly be followed by any character.\n * - The 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'\n *\t    but :sre[wind] is another command, as are :scr[iptnames],\n *\t    :scs[cope], :sim[alt], :sig[ns] and :sil[ent].\n */\n    static int\none_letter_cmd(char_u *p, cmdidx_T *idx)\n{\n    if (in_vim9script())\n\treturn FALSE;\n    if (*p == 'k')\n    {\n\t*idx = CMD_k;\n\treturn TRUE;\n    }\n    if (p[0] == 's'\n\t    && ((p[1] == 'c' && (p[2] == NUL || (p[2] != 's' && p[2] != 'r'\n\t\t\t&& (p[3] == NUL || (p[3] != 'i' && p[4] != 'p')))))\n\t\t|| p[1] == 'g'\n\t\t|| (p[1] == 'i' && p[2] != 'm' && p[2] != 'l' && p[2] != 'g')\n\t\t|| p[1] == 'I'\n\t\t|| (p[1] == 'r' && p[2] != 'e')))\n    {\n\t*idx = CMD_substitute;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"cmd\" starts with \"123->\", a number followed by a method\n * call.\n */\n    int\nnumber_method(char_u *cmd)\n{\n    char_u *p = skipdigits(cmd);\n\n    return p > cmd && (p = skipwhite(p))[0] == '-' && p[1] == '>';\n}\n\n/*\n * Find an Ex command by its name, either built-in or user.\n * Start of the name can be found at eap->cmd.\n * Sets eap->cmdidx and returns a pointer to char after the command name.\n * \"full\" is set to TRUE if the whole command name matched.\n *\n * If \"lookup\" is not NULL recognize expression without \"eval\" or \"call\" and\n * assignment without \"let\".  Sets eap->cmdidx to the command while returning\n * \"eap->cmd\".\n *\n * Returns NULL for an ambiguous user command.\n */\n    char_u *\nfind_ex_command(\n\texarg_T *eap,\n\tint\t*full UNUSED,\n\tint\t(*lookup)(char_u *, size_t, int cmd, cctx_T *) UNUSED,\n\tcctx_T\t*cctx UNUSED)\n{\n    int\t\tlen;\n    char_u\t*p;\n    int\t\ti;\n#ifndef FEAT_EVAL\n    int\t\tvim9 = FALSE;\n#else\n    int\t\tvim9 = in_vim9script();\n\n    /*\n     * Recognize a Vim9 script function/method call and assignment:\n     * \"lvar = value\", \"lvar(arg)\", \"[1, 2 3]->Func()\"\n     */\n    p = eap->cmd;\n    if (lookup != NULL)\n    {\n\tchar_u *pskip = skip_option_env_lead(eap->cmd);\n\n\tif (vim_strchr((char_u *)\"{('[\\\"@&$\", *p) != NULL\n\t       || ((p = to_name_const_end(pskip)) > eap->cmd && *p != NUL)\n\t       || (p[0] == '0' && p[1] == 'z'))\n\t{\n\t    int\t    oplen;\n\t    int\t    heredoc;\n\t    char_u  *swp;\n\n\t    if (*eap->cmd == '&'\n\t\t    || (eap->cmd[0] == '$'\n\t\t\t\t  && eap->cmd[1] != '\\'' && eap->cmd[1] != '\"')\n\t\t    || (eap->cmd[0] == '@'\n\t\t\t\t\t&& (valid_yank_reg(eap->cmd[1], FALSE)\n\t\t\t\t\t\t       || eap->cmd[1] == '@')))\n\t    {\n\t\tif (*eap->cmd == '&')\n\t\t{\n\t\t    p = eap->cmd + 1;\n\t\t    if (STRNCMP(\"l:\", p, 2) == 0 || STRNCMP(\"g:\", p, 2) == 0)\n\t\t\tp += 2;\n\t\t    p = to_name_end(p, FALSE);\n\t\t}\n\t\telse if (*eap->cmd == '$')\n\t\t    p = to_name_end(eap->cmd + 1, FALSE);\n\t\telse\n\t\t    p = eap->cmd + 2;\n\t\tif (ends_excmd(*skipwhite(p)))\n\t\t{\n\t\t    // \"&option <NL>\", \"$ENV <NL>\" and \"@r <NL>\" are the start\n\t\t    // of an expression.\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\t// \"&option\" can be followed by \"->\" or \"=\", check below\n\t    }\n\n\t    swp = skipwhite(p);\n\n\t    if (\n\t\t// \"(...\" is an expression.\n\t\t// \"funcname(\" is always a function call.\n\t\t*p == '('\n\t\t    || (p == eap->cmd\n\t\t\t? (\n\t\t\t    // \"{...\" is a dict expression or block start.\n\t\t\t    *eap->cmd == '{'\n\t\t\t    // \"'string'->func()\" is an expression.\n\t\t\t || *eap->cmd == '\\''\n\t\t\t    // '\"string\"->func()' is an expression.\n\t\t\t || *eap->cmd == '\"'\n\t\t\t    // '$\"string\"->func()' is an expression.\n\t\t\t    // \"$'string'->func()\" is an expression.\n\t\t\t || (eap->cmd[0] == '$'\n\t\t\t     && (eap->cmd[1] == '\\'' || eap->cmd[1] == '\"'))\n\t\t\t    // '0z1234->func()' is an expression.\n\t\t\t || (eap->cmd[0] == '0' && eap->cmd[1] == 'z')\n\t\t\t    // \"g:varname\" is an expression.\n\t\t\t || eap->cmd[1] == ':'\n\t\t\t    )\n\t\t\t    // \"varname->func()\" is an expression.\n\t\t\t: (*swp == '-' && swp[1] == '>')))\n\t    {\n\t\tif (*eap->cmd == '{' && ends_excmd(*skipwhite(eap->cmd + 1)))\n\t\t{\n\t\t    // \"{\" by itself is the start of a block.\n\t\t    eap->cmdidx = CMD_block;\n\t\t    return eap->cmd + 1;\n\t\t}\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\n\t    if ((p != eap->cmd && (\n\t\t\t    // \"varname[]\" is an expression.\n\t\t\t    *p == '['\n\t\t\t    // \"varname.key\" is an expression.\n\t\t\t || (*p == '.'\n\t\t\t\t     && (ASCII_ISALPHA(p[1]) || p[1] == '_'))))\n\t\t\t// g:[key] is an expression\n\t\t    || STRNCMP(eap->cmd, \"g:[\", 3) == 0)\n\t    {\n\t\tchar_u\t*after = eap->cmd;\n\n\t\t// When followed by \"=\" or \"+=\" then it is an assignment.\n\t\t// Skip over the whole thing, it can be:\n\t\t//\tname.member = val\n\t\t//\tname[a : b] = val\n\t\t//\tname[idx] = val\n\t\t//\tname[idx].member = val\n\t\t//\tetc.\n\t\teap->cmdidx = CMD_eval;\n\t\t++emsg_silent;\n\t\tif (skip_expr(&after, NULL) == OK)\n\t\t{\n\t\t    after = skipwhite(after);\n\t\t    if (*after == '=' || (*after != NUL && after[1] == '=')\n\t\t\t\t\t || (after[0] == '.' && after[1] == '.'\n\t\t\t\t\t\t\t   && after[2] == '='))\n\t\t\teap->cmdidx = CMD_var;\n\t\t}\n\t\t--emsg_silent;\n\t\treturn eap->cmd;\n\t    }\n\n\t    // \"[...]->Method()\" is a list expression, but \"[a, b] = Func()\" is\n\t    // an assignment.\n\t    // If there is no line break inside the \"[...]\" then \"p\" is\n\t    // advanced to after the \"]\" by to_name_const_end(): check if a \"=\"\n\t    // follows.\n\t    // If \"[...]\" has a line break \"p\" still points at the \"[\" and it\n\t    // can't be an assignment.\n\t    if (*eap->cmd == '[')\n\t    {\n\t\tchar_u\t    *eq;\n\n\t\tp = to_name_const_end(eap->cmd);\n\t\tif (p == eap->cmd && *p == '[')\n\t\t{\n\t\t    int count = 0;\n\t\t    int\tsemicolon = FALSE;\n\n\t\t    p = skip_var_list(eap->cmd, TRUE, &count, &semicolon, TRUE);\n\t\t}\n\t\teq = p;\n\t\tif (eq != NULL)\n\t\t{\n\t\t    eq = skipwhite(eq);\n\t\t    if (vim_strchr((char_u *)\"+-*/%\", *eq) != NULL)\n\t\t\t++eq;\n\t\t}\n\t\tif (p == NULL || p == eap->cmd || *eq != '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_eval;\n\t\t    return eap->cmd;\n\t\t}\n\t\tif (p > eap->cmd && *eq == '=')\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize an assignment if we recognize the variable name:\n\t    // \"g:var = expr\"\n\t    // \"@r = expr\"\n\t    // \"&opt = expr\"\n\t    // \"var = expr\"  where \"var\" is a variable name or we are skipping\n\t    // (variable declaration might have been skipped).\n\t    // Not \"redir => var\" (when skipping).\n\t    oplen = assignment_len(skipwhite(p), &heredoc);\n\t    if (oplen > 0)\n\t    {\n\t\tif (((p - eap->cmd) > 2 && eap->cmd[1] == ':')\n\t\t\t|| *eap->cmd == '&'\n\t\t\t|| *eap->cmd == '$'\n\t\t\t|| *eap->cmd == '@'\n\t\t\t|| (eap->skip && IS_WHITE_OR_NUL(\n\t\t\t\t\t\t      *(skipwhite(p) + oplen)))\n\t\t\t|| lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK)\n\t\t{\n\t\t    eap->cmdidx = CMD_var;\n\t\t    return eap->cmd;\n\t\t}\n\t    }\n\n\t    // Recognize using a type for a w:, b:, t: or g: variable:\n\t    // \"w:varname: number = 123\".\n\t    if (eap->cmd[1] == ':' && *p == ':')\n\t    {\n\t\teap->cmdidx = CMD_eval;\n\t\treturn eap->cmd;\n\t    }\n\t}\n\n\t// 1234->func() is a method call\n\tif (number_method(eap->cmd))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// \"g:\", \"s:\" and \"l:\" are always assumed to be a variable, thus start\n\t// an expression.  A global/substitute/list command needs to use a\n\t// longer name.\n\tif (vim_strchr((char_u *)\"gsl\", *p) != NULL && p[1] == ':')\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// If it is an ID it might be a variable with an operator on the next\n\t// line, if the variable exists it can't be an Ex command.\n\tif (p > eap->cmd && ends_excmd(*skipwhite(p))\n\t\t&& (lookup(eap->cmd, p - eap->cmd, TRUE, cctx) == OK\n\t\t    || (ASCII_ISALPHA(eap->cmd[0]) && eap->cmd[1] == ':')))\n\t{\n\t    eap->cmdidx = CMD_eval;\n\t    return eap->cmd;\n\t}\n\n\t// Check for \"++nr\" and \"--nr\".\n\tif (p == eap->cmd && p[0] != NUL && p[0] == p[1]\n\t\t\t\t\t\t   && (*p == '+' || *p == '-'))\n\t{\n\t    eap->cmdidx = *p == '+' ? CMD_increment : CMD_decrement;\n\t    return eap->cmd + 2;\n\t}\n    }\n#endif\n\n    /*\n     * Isolate the command and search for it in the command table.\n     */\n    p = eap->cmd;\n    if (one_letter_cmd(p, &eap->cmdidx))\n    {\n\t++p;\n    }\n    else\n    {\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n\t// for python 3.x support \":py3\", \":python3\", \":py3file\", etc.\n\tif (eap->cmd[0] == 'p' && eap->cmd[1] == 'y')\n\t{\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t}\n\telse if (*p == '9' && STRNCMP(\"vim9\", eap->cmd, 4) == 0)\n\t{\n\t    // include \"9\" for \"vim9*\" commands; \"vim9cmd\" and \"vim9script\".\n\t    ++p;\n\t    while (ASCII_ISALPHA(*p))\n\t\t++p;\n\t}\n\n\t// check for non-alpha command\n\tif (p == eap->cmd && vim_strchr((char_u *)\"@*!=><&~#}\", *p) != NULL)\n\t    ++p;\n\tlen = (int)(p - eap->cmd);\n\t// The \"d\" command can directly be followed by 'l' or 'p' flag, when\n\t// not in Vim9 script.\n\tif (!vim9 && *eap->cmd == 'd' && (p[-1] == 'l' || p[-1] == 'p'))\n\t{\n\t    // Check for \":dl\", \":dell\", etc. to \":deletel\": that's\n\t    // :delete with the 'l' flag.  Same for 'p'.\n\t    for (i = 0; i < len; ++i)\n\t\tif (eap->cmd[i] != ((char_u *)\"delete\")[i])\n\t\t    break;\n\t    if (i == len - 1)\n\t    {\n\t\t--len;\n\t\tif (p[-1] == 'l')\n\t\t    eap->flags |= EXFLAG_LIST;\n\t\telse\n\t\t    eap->flags |= EXFLAG_PRINT;\n\t    }\n\t}\n\n\tif (ASCII_ISLOWER(eap->cmd[0]))\n\t{\n\t    int c1 = eap->cmd[0];\n\t    int c2 = len == 1 ? NUL : eap->cmd[1];\n\n\t    if (command_count != (int)CMD_SIZE)\n\t    {\n\t\tiemsg(_(e_command_table_needs_to_be_updated_run_make_cmdidxs));\n\t\tgetout(1);\n\t    }\n\n\t    // Use a precomputed index for fast look-up in cmdnames[]\n\t    // taking into account the first 2 letters of eap->cmd.\n\t    eap->cmdidx = cmdidxs1[CharOrdLow(c1)];\n\t    if (ASCII_ISLOWER(c2))\n\t\teap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];\n\t}\n\telse if (ASCII_ISUPPER(eap->cmd[0]))\n\t    eap->cmdidx = CMD_Next;\n\telse\n\t    eap->cmdidx = CMD_bang;\n\n\tfor ( ; (int)eap->cmdidx < (int)CMD_SIZE;\n\t\t\t       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))\n\t    if (STRNCMP(cmdnames[(int)eap->cmdidx].cmd_name, (char *)eap->cmd,\n\t\t\t\t\t\t\t    (size_t)len) == 0)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (full != NULL && cmdnames[eap->cmdidx].cmd_name[len] == NUL)\n\t\t    *full = TRUE;\n#endif\n\t\tbreak;\n\t    }\n\n\t// :Print and :mode are not supported in Vim9 script.\n\t// Some commands cannot be shortened in Vim9 script.\n\tif (vim9 && eap->cmdidx != CMD_SIZE)\n\t{\n\t    if (eap->cmdidx == CMD_mode || eap->cmdidx == CMD_Print)\n\t\teap->cmdidx = CMD_SIZE;\n\t    else if ((cmdnames[eap->cmdidx].cmd_argt & EX_WHOLE)\n\t\t\t  && len < (int)STRLEN(cmdnames[eap->cmdidx].cmd_name))\n\t    {\n\t\tsemsg(_(e_command_cannot_be_shortened_str), eap->cmd);\n\t\teap->cmdidx = CMD_SIZE;\n\t    }\n\t}\n\n\t// Do not recognize \":*\" as the star command unless '*' is in\n\t// 'cpoptions'.\n\tif (eap->cmdidx == CMD_star && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\t    p = eap->cmd;\n\n\t// Look for a user defined command as a last resort.  Let \":Print\" be\n\t// overruled by a user defined command.\n\tif ((eap->cmdidx == CMD_SIZE || eap->cmdidx == CMD_Print)\n\t\t&& *eap->cmd >= 'A' && *eap->cmd <= 'Z')\n\t{\n\t    // User defined commands may contain digits.\n\t    while (ASCII_ISALNUM(*p))\n\t\t++p;\n\t    p = find_ucmd(eap, p, full, NULL, NULL);\n\t}\n\tif (p == NULL || p == eap->cmd)\n\t    eap->cmdidx = CMD_SIZE;\n    }\n\n    // \":fina\" means \":finally\" in legacy script, for backwards compatibility.\n    if (eap->cmdidx == CMD_final && p - eap->cmd == 4 && !vim9)\n\teap->cmdidx = CMD_finally;\n\n#ifdef FEAT_EVAL\n    if (eap->cmdidx < CMD_SIZE\n\t    && vim9\n\t    && !IS_WHITE_OR_NUL(*p) && *p != '\\n' && *p != '!' && *p != '|'\n\t    && (eap->cmdidx < 0 ||\n\t\t(cmdnames[eap->cmdidx].cmd_argt & EX_NONWHITE_OK) == 0))\n    {\n\tchar_u *cmd = vim_strnsave(eap->cmd, p - eap->cmd);\n\n\tsemsg(_(e_command_str_not_followed_by_white_space_str), cmd, eap->cmd);\n\teap->cmdidx = CMD_SIZE;\n\tvim_free(cmd);\n    }\n#endif\n\n    return p;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic struct cmdmod\n{\n    char\t*name;\n    int\t\tminlen;\n    int\t\thas_count;  // :123verbose  :3tab\n} cmdmods[] = {\n    {\"aboveleft\", 3, FALSE},\n    {\"belowright\", 3, FALSE},\n    {\"botright\", 2, FALSE},\n    {\"browse\", 3, FALSE},\n    {\"confirm\", 4, FALSE},\n    {\"filter\", 4, FALSE},\n    {\"hide\", 3, FALSE},\n    {\"keepalt\", 5, FALSE},\n    {\"keepjumps\", 5, FALSE},\n    {\"keepmarks\", 3, FALSE},\n    {\"keeppatterns\", 5, FALSE},\n    {\"leftabove\", 5, FALSE},\n    {\"lockmarks\", 3, FALSE},\n    {\"noautocmd\", 3, FALSE},\n    {\"noswapfile\", 3, FALSE},\n    {\"rightbelow\", 6, FALSE},\n    {\"sandbox\", 3, FALSE},\n    {\"silent\", 3, FALSE},\n    {\"tab\", 3, TRUE},\n    {\"topleft\", 2, FALSE},\n    {\"unsilent\", 3, FALSE},\n    {\"verbose\", 4, TRUE},\n    {\"vertical\", 4, FALSE},\n};\n\n/*\n * Return length of a command modifier (including optional count).\n * Return zero when it's not a modifier.\n */\n    int\nmodifier_len(char_u *cmd)\n{\n    int\t\ti, j;\n    char_u\t*p = cmd;\n\n    if (VIM_ISDIGIT(*cmd))\n\tp = skipwhite(skipdigits(cmd + 1));\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; p[j] != NUL; ++j)\n\t    if (p[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (!ASCII_ISALPHA(p[j]) && j >= cmdmods[i].minlen\n\t\t\t\t\t&& (p == cmd || cmdmods[i].has_count))\n\t    return j + (int)(p - cmd);\n    }\n    return 0;\n}\n\n/*\n * Return > 0 if an Ex command \"name\" exists.\n * Return 2 if there is an exact match.\n * Return 3 if there is an ambiguous match.\n */\n    int\ncmd_exists(char_u *name)\n{\n    exarg_T\tea;\n    int\t\tfull = FALSE;\n    int\t\ti;\n    int\t\tj;\n    char_u\t*p;\n\n    // Check command modifiers.\n    for (i = 0; i < (int)ARRAY_LENGTH(cmdmods); ++i)\n    {\n\tfor (j = 0; name[j] != NUL; ++j)\n\t    if (name[j] != cmdmods[i].name[j])\n\t\tbreak;\n\tif (name[j] == NUL && j >= cmdmods[i].minlen)\n\t    return (cmdmods[i].name[j] == NUL ? 2 : 1);\n    }\n\n    // Check built-in commands and user defined commands.\n    // For \":2match\" and \":3match\" we need to skip the number.\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.flags = 0;\n    p = find_ex_command(&ea, &full, NULL, NULL);\n    if (p == NULL)\n\treturn 3;\n    if (vim_isdigit(*name) && ea.cmdidx != CMD_match)\n\treturn 0;\n    if (*skipwhite(p) != NUL)\n\treturn 0;\t// trailing garbage\n    return (ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1));\n}\n\n/*\n * \"fullcommand\" function\n */\n    void\nf_fullcommand(typval_T *argvars, typval_T *rettv)\n{\n    exarg_T  ea;\n    char_u   *name;\n    char_u   *p;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    name = argvars[0].vval.v_string;\n    if (name == NULL)\n\treturn;\n\n    while (*name == ':')\n\tname++;\n    name = skip_range(name, TRUE, NULL);\n\n    ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;\n    ea.cmdidx = (cmdidx_T)0;\n    ea.addr_count = 0;\n    p = find_ex_command(&ea, NULL, NULL, NULL);\n    if (p == NULL || ea.cmdidx == CMD_SIZE)\n\treturn;\n    if (in_vim9script())\n    {\n\tint\t     res;\n\n\t++emsg_silent;\n\tres = not_in_vim9(&ea);\n\t--emsg_silent;\n\n\tif (res == FAIL)\n\t    return;\n    }\n\n    rettv->vval.v_string = vim_strsave(IS_USER_CMDIDX(ea.cmdidx)\n\t\t\t\t ? get_user_command_name(ea.useridx, ea.cmdidx)\n\t\t\t\t : cmdnames[ea.cmdidx].cmd_name);\n}\n#endif\n\n    cmdidx_T\nexcmd_get_cmdidx(char_u *cmd, int len)\n{\n    cmdidx_T idx;\n\n    if (!one_letter_cmd(cmd, &idx))\n\tfor (idx = (cmdidx_T)0; (int)idx < (int)CMD_SIZE;\n\t\tidx = (cmdidx_T)((int)idx + 1))\n\t    if (STRNCMP(cmdnames[(int)idx].cmd_name, cmd, (size_t)len) == 0)\n\t\tbreak;\n\n    return idx;\n}\n\n    long\nexcmd_get_argt(cmdidx_T idx)\n{\n    return (long)cmdnames[(int)idx].cmd_argt;\n}\n\n/*\n * Skip a range specifier of the form: addr [,addr] [;addr] ..\n *\n * Backslashed delimiters after / or ? will be skipped, and commands will\n * not be expanded between /'s and ?'s or after \"'\".\n *\n * Also skip white space and \":\" characters after the range.\n * Returns the \"cmd\" pointer advanced to beyond the range.\n */\n    char_u *\nskip_range(\n    char_u\t*cmd_start,\n    int\t\tskip_star,\t// skip \"*\" used for Visual range\n    int\t\t*ctx)\t\t// pointer to xp_context or NULL\n{\n    char_u\t*cmd = cmd_start;\n    unsigned\tdelim;\n\n    while (vim_strchr((char_u *)\" \\t0123456789.$%'/?-+,;\\\\\", *cmd) != NULL)\n    {\n\tif (*cmd == '\\\\')\n\t{\n\t    if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&')\n\t\t++cmd;\n\t    else\n\t\tbreak;\n\t}\n\telse if (*cmd == '\\'')\n\t{\n\t    char_u *p = cmd;\n\n\t    // a quote is only valid at the start or after a separator\n\t    while (p > cmd_start)\n\t    {\n\t\t--p;\n\t\tif (!VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    if (cmd > cmd_start && !VIM_ISWHITE(*p) && *p != ',' && *p != ';')\n\t\tbreak;\n\t    if (*++cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\telse if (*cmd == '/' || *cmd == '?')\n\t{\n\t    delim = *cmd++;\n\t    while (*cmd != NUL && *cmd != delim)\n\t\tif (*cmd++ == '\\\\' && *cmd != NUL)\n\t\t    ++cmd;\n\t    if (*cmd == NUL && ctx != NULL)\n\t\t*ctx = EXPAND_NOTHING;\n\t}\n\tif (*cmd != NUL)\n\t    ++cmd;\n    }\n\n    // Skip \":\" and white space.\n    while (*cmd == ':')\n\tcmd = skipwhite(cmd + 1);\n\n    // Skip \"*\" used for Visual range.\n    if (skip_star && *cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL)\n\tcmd = skipwhite(cmd + 1);\n\n    return cmd;\n}\n\n    static void\naddr_error(cmd_addr_T addr_type)\n{\n    if (addr_type == ADDR_NONE)\n\temsg(_(e_no_range_allowed));\n    else\n\temsg(_(e_invalid_range));\n}\n\n/*\n * Return the default address for an address type.\n */\n    static linenr_T\ndefault_address(exarg_T *eap)\n{\n    linenr_T lnum = 0;\n\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    // Default is the cursor line number.  Avoid using an invalid\n\t    // line number though.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = curwin->w_cursor.lnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    lnum = CURRENT_WIN_NR;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    lnum = curwin->w_arg_idx + 1;\n\t    if (lnum > ARGCOUNT)\n\t\tlnum = ARGCOUNT;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\tcase ADDR_BUFFERS:\n\t    lnum = curbuf->b_fnum;\n\t    break;\n\tcase ADDR_TABS:\n\t    lnum = CURRENT_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\tcase ADDR_UNSIGNED:\n\t    lnum = 1;\n\t    break;\n\tcase ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    lnum = qf_get_cur_valid_idx(eap);\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\t    // Will give an error later if a range is found.\n\t    break;\n    }\n    return lnum;\n}\n\n/*\n * Get a single EX address.\n *\n * Set ptr to the next character after the part that was interpreted.\n * Set ptr to NULL when an error is encountered.\n * This may set the last used search pattern.\n *\n * Return MAXLNUM when no Ex address was found.\n */\n    static linenr_T\nget_address(\n    exarg_T\t*eap UNUSED,\n    char_u\t**ptr,\n    cmd_addr_T\taddr_type,\n    int\t\tskip,\t\t// only skip the address, don't use it\n    int\t\tsilent,\t\t// no errors or side effects\n    int\t\tto_other_file,  // flag: may jump to other file\n    int\t\taddress_count UNUSED) // 1 for first address, >1 after comma\n{\n    int\t\tc;\n    int\t\ti;\n    long\tn;\n    char_u\t*cmd;\n    pos_T\tpos;\n    pos_T\t*fp;\n    linenr_T\tlnum;\n    buf_T\t*buf;\n\n    cmd = skipwhite(*ptr);\n    lnum = MAXLNUM;\n    do\n    {\n\tswitch (*cmd)\n\t{\n\t    case '.':\t\t\t    // '.' - Cursor position\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '$':\t\t\t    // '$' - last line\n\t\t++cmd;\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\tlnum = curbuf->b_ml.ml_line_count;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = LAST_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = ARGCOUNT;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t\tbuf = lastbuf;\n\t\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t\t{\n\t\t\t    if (buf->b_prev == NULL)\n\t\t\t\tbreak;\n\t\t\t    buf = buf->b_prev;\n\t\t\t}\n\t\t\tlnum = buf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = lastbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = LAST_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\taddr_error(addr_type);\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_valid_size(eap);\n\t\t\tif (lnum == 0)\n\t\t\t    lnum = 1;\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case '\\'':\t\t\t    // ''' - mark\n\t\tif (*++cmd == NUL)\n\t\t{\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\n\t\t    ++cmd;\n\t\telse\n\t\t{\n\t\t    // Only accept a mark in another file when it is\n\t\t    // used by itself: \":'M\".\n\t\t    fp = getmark(*cmd, to_other_file && cmd[1] == NUL);\n\t\t    ++cmd;\n\t\t    if (fp == (pos_T *)-1)\n\t\t\t// Jumped to another file.\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t    else\n\t\t    {\n\t\t\tif (check_mark(fp) == FAIL)\n\t\t\t{\n\t\t\t    cmd = NULL;\n\t\t\t    goto error;\n\t\t\t}\n\t\t\tlnum = fp->lnum;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case '/':\n\t    case '?':\t\t\t// '/' or '?' - search\n\t\tc = *cmd++;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (skip)\t// skip \"/pat/\"\n\t\t{\n\t\t    cmd = skip_regexp(cmd, c, magic_isset());\n\t\t    if (*cmd == c)\n\t\t\t++cmd;\n\t\t}\n\t\telse\n\t\t{\n\t\t    int flags;\n\n\t\t    pos = curwin->w_cursor; // save curwin->w_cursor\n\n\t\t    // When '/' or '?' follows another address, start from\n\t\t    // there.\n\t\t    if (lnum > 0 && lnum != MAXLNUM)\n\t\t\tcurwin->w_cursor.lnum =\n\t\t\t\tlnum > curbuf->b_ml.ml_line_count\n\t\t\t\t\t   ? curbuf->b_ml.ml_line_count : lnum;\n\n\t\t    // Start a forward search at the end of the line (unless\n\t\t    // before the first line).\n\t\t    // Start a backward search at the start of the line.\n\t\t    // This makes sure we never match in the current\n\t\t    // line, and can match anywhere in the\n\t\t    // next/previous line.\n\t\t    if (c == '/' && curwin->w_cursor.lnum > 0)\n\t\t\tcurwin->w_cursor.col = MAXCOL;\n\t\t    else\n\t\t\tcurwin->w_cursor.col = 0;\n\t\t    searchcmdlen = 0;\n\t\t    flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;\n\t\t    if (!do_search(NULL, c, c, cmd, 1L, flags, NULL))\n\t\t    {\n\t\t\tcurwin->w_cursor = pos;\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum = curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor = pos;\n\t\t    // adjust command string pointer\n\t\t    cmd += searchcmdlen;\n\t\t}\n\t\tbreak;\n\n\t    case '\\\\':\t\t    // \"\\?\", \"\\/\" or \"\\&\", repeat search\n\t\t++cmd;\n\t\tif (addr_type != ADDR_LINES)\n\t\t{\n\t\t    addr_error(addr_type);\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\t\tif (*cmd == '&')\n\t\t    i = RE_SUBST;\n\t\telse if (*cmd == '?' || *cmd == '/')\n\t\t    i = RE_SEARCH;\n\t\telse\n\t\t{\n\t\t    emsg(_(e_backslash_should_be_followed_by));\n\t\t    cmd = NULL;\n\t\t    goto error;\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t    /*\n\t\t     * When search follows another address, start from\n\t\t     * there.\n\t\t     */\n\t\t    if (lnum != MAXLNUM)\n\t\t\tpos.lnum = lnum;\n\t\t    else\n\t\t\tpos.lnum = curwin->w_cursor.lnum;\n\n\t\t    /*\n\t\t     * Start the search just like for the above\n\t\t     * do_search().\n\t\t     */\n\t\t    if (*cmd != '?')\n\t\t\tpos.col = MAXCOL;\n\t\t    else\n\t\t\tpos.col = 0;\n\t\t    pos.coladd = 0;\n\t\t    if (searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t*cmd == '?' ? BACKWARD : FORWARD,\n\t\t\t\t(char_u *)\"\", 1L, SEARCH_MSG, i, NULL) != FAIL)\n\t\t\tlnum = pos.lnum;\n\t\t    else\n\t\t    {\n\t\t\tcmd = NULL;\n\t\t\tgoto error;\n\t\t    }\n\t\t}\n\t\t++cmd;\n\t\tbreak;\n\n\t    default:\n\t\tif (VIM_ISDIGIT(*cmd))\t// absolute line number\n\t\t    lnum = getdigits(&cmd);\n\t}\n\n\tfor (;;)\n\t{\n\t    cmd = skipwhite(cmd);\n\t    if (*cmd != '-' && *cmd != '+' && !VIM_ISDIGIT(*cmd))\n\t\tbreak;\n\n\t    if (lnum == MAXLNUM)\n\t    {\n\t\tswitch (addr_type)\n\t\t{\n\t\t    case ADDR_LINES:\n\t\t    case ADDR_OTHER:\n\t\t\t// \"+1\" is same as \".+1\"\n\t\t\tlnum = curwin->w_cursor.lnum;\n\t\t\tbreak;\n\t\t    case ADDR_WINDOWS:\n\t\t\tlnum = CURRENT_WIN_NR;\n\t\t\tbreak;\n\t\t    case ADDR_ARGUMENTS:\n\t\t\tlnum = curwin->w_arg_idx + 1;\n\t\t\tbreak;\n\t\t    case ADDR_LOADED_BUFFERS:\n\t\t    case ADDR_BUFFERS:\n\t\t\tlnum = curbuf->b_fnum;\n\t\t\tbreak;\n\t\t    case ADDR_TABS:\n\t\t\tlnum = CURRENT_TAB_NR;\n\t\t\tbreak;\n\t\t    case ADDR_TABS_RELATIVE:\n\t\t\tlnum = 1;\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\t\tlnum = qf_get_cur_valid_idx(eap);\n#endif\n\t\t\tbreak;\n\t\t    case ADDR_NONE:\n\t\t    case ADDR_UNSIGNED:\n\t\t\tlnum = 0;\n\t\t\tbreak;\n\t\t}\n\t    }\n\n\t    if (VIM_ISDIGIT(*cmd))\n\t\ti = '+';\t\t// \"number\" is same as \"+number\"\n\t    else\n\t\ti = *cmd++;\n\t    if (!VIM_ISDIGIT(*cmd))\t// '+' is '+1', but '+0' is not '+1'\n\t\tn = 1;\n\t    else\n\t    {\n\t\tn = getdigits(&cmd);\n\t\tif (n == MAXLNUM)\n\t\t{\n\t\t    emsg(_(e_line_number_out_of_range));\n\t\t    goto error;\n\t\t}\n\t    }\n\n\t    if (addr_type == ADDR_TABS_RELATIVE)\n\t    {\n\t\temsg(_(e_invalid_range));\n\t\tcmd = NULL;\n\t\tgoto error;\n\t    }\n\t    else if (addr_type == ADDR_LOADED_BUFFERS\n\t\t    || addr_type == ADDR_BUFFERS)\n\t\tlnum = compute_buffer_local_count(\n\t\t\t\t    addr_type, lnum, (i == '-') ? -1 * n : n);\n\t    else\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Relative line addressing, need to adjust for folded lines\n\t\t// now, but only do it after the first address.\n\t\tif (addr_type == ADDR_LINES && (i == '-' || i == '+')\n\t\t\t\t\t\t\t && address_count >= 2)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t\tif (i == '-')\n\t\t    lnum -= n;\n\t\telse\n\t\t{\n\t\t    if (n >= LONG_MAX - lnum)\n\t\t    {\n\t\t\temsg(_(e_line_number_out_of_range));\n\t\t\tgoto error;\n\t\t    }\n\t\t    lnum += n;\n\t\t}\n\t    }\n\t}\n    } while (*cmd == '/' || *cmd == '?');\n\nerror:\n    *ptr = cmd;\n    return lnum;\n}\n\n/*\n * Set eap->line1 and eap->line2 to the whole range.\n * Used for commands with the EX_DFLALL flag and no range given.\n */\n    static void\naddress_default_all(exarg_T *eap)\n{\n    eap->line1 = 1;\n    switch (eap->addr_type)\n    {\n\tcase ADDR_LINES:\n\tcase ADDR_OTHER:\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\t    break;\n\tcase ADDR_LOADED_BUFFERS:\n\t    {\n\t\tbuf_T *buf = firstbuf;\n\n\t\twhile (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_next;\n\t\teap->line1 = buf->b_fnum;\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL)\n\t\t    buf = buf->b_prev;\n\t\teap->line2 = buf->b_fnum;\n\t    }\n\t    break;\n\tcase ADDR_BUFFERS:\n\t    eap->line1 = firstbuf->b_fnum;\n\t    eap->line2 = lastbuf->b_fnum;\n\t    break;\n\tcase ADDR_WINDOWS:\n\t    eap->line2 = LAST_WIN_NR;\n\t    break;\n\tcase ADDR_TABS:\n\t    eap->line2 = LAST_TAB_NR;\n\t    break;\n\tcase ADDR_TABS_RELATIVE:\n\t    eap->line2 = 1;\n\t    break;\n\tcase ADDR_ARGUMENTS:\n\t    if (ARGCOUNT == 0)\n\t\teap->line1 = eap->line2 = 0;\n\t    else\n\t\teap->line2 = ARGCOUNT;\n\t    break;\n\tcase ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t    eap->line2 = qf_get_valid_size(eap);\n\t    if (eap->line2 == 0)\n\t\teap->line2 = 1;\n#endif\n\t    break;\n\tcase ADDR_NONE:\n\tcase ADDR_UNSIGNED:\n\tcase ADDR_QUICKFIX:\n\t    iemsg(_(\"INTERNAL: Cannot use EX_DFLALL with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX\"));\n\t    break;\n    }\n}\n\n\n/*\n * Get flags from an Ex command argument.\n */\n    static void\nget_flags(exarg_T *eap)\n{\n    while (vim_strchr((char_u *)\"lp#\", *eap->arg) != NULL)\n    {\n\tif (*eap->arg == 'l')\n\t    eap->flags |= EXFLAG_LIST;\n\telse if (*eap->arg == 'p')\n\t    eap->flags |= EXFLAG_PRINT;\n\telse\n\t    eap->flags |= EXFLAG_NR;\n\teap->arg = skipwhite(eap->arg + 1);\n    }\n}\n\n/*\n * Function called for command which is Not Implemented.  NI!\n */\n    void\nex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(e_sorry_command_is_not_available_in_this_version);\n}\n\n#ifdef HAVE_EX_SCRIPT_NI\n/*\n * Function called for script command which is Not Implemented.  NI!\n * Skips over \":perl <<EOF\" constructs.\n */\n    static void\nex_script_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\tex_ni(eap);\n    else\n\tvim_free(script_get(eap, eap->arg));\n}\n#endif\n\n/*\n * Check range in Ex command for validity.\n * Return NULL when valid, error message when invalid.\n */\n    static char *\ninvalid_range(exarg_T *eap)\n{\n    buf_T\t*buf;\n\n    if (       eap->line1 < 0\n\t    || eap->line2 < 0\n\t    || eap->line1 > eap->line2)\n\treturn _(e_invalid_range);\n\n    if (eap->argt & EX_RANGE)\n    {\n\tswitch (eap->addr_type)\n\t{\n\t    case ADDR_LINES:\n\t\tif (eap->line2 > curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t    + (eap->cmdidx == CMD_diffget)\n#endif\n\t\t   )\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_ARGUMENTS:\n\t\t// add 1 if ARGCOUNT is 0\n\t\tif (eap->line2 > ARGCOUNT + (!ARGCOUNT))\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_BUFFERS:\n\t\t// Only a boundary check, not whether the buffers actually\n\t\t// exist.\n\t\tif (eap->line1 < 1 || eap->line2 > get_highest_fnum())\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_LOADED_BUFFERS:\n\t\tbuf = firstbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_next == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_next;\n\t\t}\n\t\tif (eap->line1 < buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbuf = lastbuf;\n\t\twhile (buf->b_ml.ml_mfp == NULL)\n\t\t{\n\t\t    if (buf->b_prev == NULL)\n\t\t\treturn _(e_invalid_range);\n\t\t    buf = buf->b_prev;\n\t\t}\n\t\tif (eap->line2 > buf->b_fnum)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_WINDOWS:\n\t\tif (eap->line2 > LAST_WIN_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS:\n\t\tif (eap->line2 > LAST_TAB_NR)\n\t\t    return _(e_invalid_range);\n\t\tbreak;\n\t    case ADDR_TABS_RELATIVE:\n\t    case ADDR_OTHER:\n\t\t// Any range is OK.\n\t\tbreak;\n\t    case ADDR_QUICKFIX:\n#ifdef FEAT_QUICKFIX\n\t\t// No error for value that is too big, will use the last entry.\n\t\tif (eap->line2 <= 0)\n\t\t{\n\t\t    if (eap->addr_count == 0)\n\t\t\treturn _(e_no_errors);\n\t\t    return _(e_invalid_range);\n\t\t}\n#endif\n\t\tbreak;\n\t    case ADDR_QUICKFIX_VALID:\n#ifdef FEAT_QUICKFIX\n\t\tif ((eap->line2 != 1 && eap->line2 > qf_get_valid_size(eap))\n\t\t\t|| eap->line2 < 0)\n\t\t    return _(e_invalid_range);\n#endif\n\t\tbreak;\n\t    case ADDR_UNSIGNED:\n\t    case ADDR_NONE:\n\t\t// Will give an error elsewhere.\n\t\tbreak;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Correct the range for zero line number, if required.\n */\n    static void\ncorrect_range(exarg_T *eap)\n{\n    if (!(eap->argt & EX_ZEROR))\t    // zero in range not allowed\n    {\n\tif (eap->line1 == 0)\n\t    eap->line1 = 1;\n\tif (eap->line2 == 0)\n\t    eap->line2 = 1;\n    }\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * For a \":vimgrep\" or \":vimgrepadd\" command return a pointer past the\n * pattern.  Otherwise return eap->arg.\n */\n    static char_u *\nskip_grep_pat(exarg_T *eap)\n{\n    char_u\t*p = eap->arg;\n\n    if (*p != NUL && (eap->cmdidx == CMD_vimgrep || eap->cmdidx == CMD_lvimgrep\n\t\t|| eap->cmdidx == CMD_vimgrepadd\n\t\t|| eap->cmdidx == CMD_lvimgrepadd\n\t\t|| grep_internal(eap->cmdidx)))\n    {\n\tp = skip_vimgrep_pat(p, NULL, NULL);\n\tif (p == NULL)\n\t    p = eap->arg;\n    }\n    return p;\n}\n\n/*\n * For the \":make\" and \":grep\" commands insert the 'makeprg'/'grepprg' option\n * in the command line, so that things like % get expanded.\n */\n    static char_u *\nreplace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep)\n{\n    char_u\t*new_cmdline;\n    char_u\t*program;\n    char_u\t*pos;\n    char_u\t*ptr;\n    int\t\tlen;\n    int\t\ti;\n\n    /*\n     * Don't do it when \":vimgrep\" is used for \":grep\".\n     */\n    if ((eap->cmdidx == CMD_make || eap->cmdidx == CMD_lmake\n\t\t     || eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t\t     || eap->cmdidx == CMD_grepadd\n\t\t     || eap->cmdidx == CMD_lgrepadd)\n\t    && !grep_internal(eap->cmdidx))\n    {\n\tif (eap->cmdidx == CMD_grep || eap->cmdidx == CMD_lgrep\n\t    || eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\t{\n\t    if (*curbuf->b_p_gp == NUL)\n\t\tprogram = p_gp;\n\t    else\n\t\tprogram = curbuf->b_p_gp;\n\t}\n\telse\n\t{\n\t    if (*curbuf->b_p_mp == NUL)\n\t\tprogram = p_mp;\n\t    else\n\t\tprogram = curbuf->b_p_mp;\n\t}\n\n\tp = skipwhite(p);\n\n\tif ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t{\n\t    // replace $* by given arguments\n\t    i = 1;\n\t    while ((pos = (char_u *)strstr((char *)pos + 2, \"$*\")) != NULL)\n\t\t++i;\n\t    len = (int)STRLEN(p);\n\t    new_cmdline = alloc(STRLEN(program) + (size_t)i * (len - 2) + 1);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    ptr = new_cmdline;\n\t    while ((pos = (char_u *)strstr((char *)program, \"$*\")) != NULL)\n\t    {\n\t\ti = (int)(pos - program);\n\t\tSTRNCPY(ptr, program, i);\n\t\tSTRCPY(ptr += i, p);\n\t\tptr += len;\n\t\tprogram = pos + 2;\n\t    }\n\t    STRCPY(ptr, program);\n\t}\n\telse\n\t{\n\t    new_cmdline = alloc(STRLEN(program) + STRLEN(p) + 2);\n\t    if (new_cmdline == NULL)\n\t\treturn NULL;\t\t\t// out of memory\n\t    STRCPY(new_cmdline, program);\n\t    STRCAT(new_cmdline, \" \");\n\t    STRCAT(new_cmdline, p);\n\t}\n\tmsg_make(p);\n\n\t// 'eap->cmd' is not set here, because it is not used at CMD_make\n\tvim_free(*cmdlinep);\n\t*cmdlinep = new_cmdline;\n\tp = new_cmdline;\n    }\n    return p;\n}\n#endif\n\n/*\n * Expand file name in Ex command argument.\n * When an error is detected, \"errormsgp\" is set to a non-NULL pointer.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nexpand_filename(\n    exarg_T\t*eap,\n    char_u\t**cmdlinep,\n    char\t**errormsgp)\n{\n    int\t\thas_wildcards;\t// need to expand wildcards\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n    int\t\tn;\n    int\t\tescaped;\n\n#ifdef FEAT_QUICKFIX\n    // Skip a regexp pattern for \":vimgrep[add] pat file...\"\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    /*\n     * Decide to expand wildcards *before* replacing '%', '#', etc.  If\n     * the file name contains a wildcard it should not cause expanding.\n     * (it will be expanded anyway if there is a wildcard before replacing).\n     */\n    has_wildcards = mch_has_wildcard(p);\n    while (*p != NUL)\n    {\n#ifdef FEAT_EVAL\n\t// Skip over `=expr`, wildcards in it are not expanded.\n\tif (p[0] == '`' && p[1] == '=')\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == '`')\n\t\t++p;\n\t    continue;\n\t}\n#endif\n\t/*\n\t * Quick check if this cannot be the start of a special string.\n\t * Also removes backslash before '%', '#' and '<'.\n\t */\n\tif (vim_strchr((char_u *)\"%#<\", *p) == NULL)\n\t{\n\t    ++p;\n\t    continue;\n\t}\n\n\t/*\n\t * Try to find a match at this position.\n\t */\n\trepl = eval_vars(p, eap->arg, &srclen, &(eap->do_ecmd_lnum),\n\t\t\t\t\t\t    errormsgp, &escaped, TRUE);\n\tif (*errormsgp != NULL)\t\t// error detected\n\t    return FAIL;\n\tif (repl == NULL)\t\t// no match found\n\t{\n\t    p += srclen;\n\t    continue;\n\t}\n\n\t// Wildcards won't be expanded below, the replacement is taken\n\t// literally.  But do expand \"~/file\", \"~user/file\" and \"$HOME/file\".\n\tif (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL)\n\t{\n\t    char_u *l = repl;\n\n\t    repl = expand_env_save(repl);\n\t    vim_free(l);\n\t}\n\n\t// Need to escape white space et al. with a backslash.\n\t// Don't do this for:\n\t// - replacement that already has been escaped: \"##\"\n\t// - shell commands (may have to use quotes instead).\n\t// - non-unix systems when there is a single argument (spaces don't\n\t//   separate arguments then).\n\tif (!eap->usefilter\n\t\t&& !escaped\n\t\t&& eap->cmdidx != CMD_bang\n\t\t&& eap->cmdidx != CMD_grep\n\t\t&& eap->cmdidx != CMD_grepadd\n\t\t&& eap->cmdidx != CMD_hardcopy\n\t\t&& eap->cmdidx != CMD_lgrep\n\t\t&& eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_lmake\n\t\t&& eap->cmdidx != CMD_make\n\t\t&& eap->cmdidx != CMD_terminal\n#ifndef UNIX\n\t\t&& !(eap->argt & EX_NOSPC)\n#endif\n\t\t)\n\t{\n\t    char_u\t*l;\n#ifdef BACKSLASH_IN_FILENAME\n\t    // Don't escape a backslash here, because rem_backslash() doesn't\n\t    // remove it later.\n\t    static char_u *nobslash = (char_u *)\" \\t\\\"|\";\n# define ESCAPE_CHARS nobslash\n#else\n# define ESCAPE_CHARS escape_chars\n#endif\n\n\t    for (l = repl; *l; ++l)\n\t\tif (vim_strchr(ESCAPE_CHARS, *l) != NULL)\n\t\t{\n\t\t    l = vim_strsave_escaped(repl, ESCAPE_CHARS);\n\t\t    if (l != NULL)\n\t\t    {\n\t\t\tvim_free(repl);\n\t\t\trepl = l;\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\t// For a shell command a '!' must be escaped.\n\tif ((eap->usefilter || eap->cmdidx == CMD_bang\n\t\t\t\t\t\t|| eap->cmdidx == CMD_terminal)\n\t\t\t    && vim_strpbrk(repl, (char_u *)\"!\") != NULL)\n\t{\n\t    char_u\t*l;\n\n\t    l = vim_strsave_escaped(repl, (char_u *)\"!\");\n\t    if (l != NULL)\n\t    {\n\t\tvim_free(repl);\n\t\trepl = l;\n\t    }\n\t}\n\n\tp = repl_cmdline(eap, p, srclen, repl, cmdlinep);\n\tvim_free(repl);\n\tif (p == NULL)\n\t    return FAIL;\n    }\n\n    /*\n     * One file argument: Expand wildcards.\n     * Don't do this with \":r !command\" or \":w !command\".\n     */\n    if ((eap->argt & EX_NOSPC) && !eap->usefilter)\n    {\n\t/*\n\t * May do this twice:\n\t * 1. Replace environment variables.\n\t * 2. Replace any other wildcards, remove backslashes.\n\t */\n\tfor (n = 1; n <= 2; ++n)\n\t{\n\t    if (n == 2)\n\t    {\n\t\t/*\n\t\t * Halve the number of backslashes (this is Vi compatible).\n\t\t * For Unix and OS/2, when wildcards are expanded, this is\n\t\t * done by ExpandOne() below.\n\t\t */\n#if defined(UNIX)\n\t\tif (!has_wildcards)\n#endif\n\t\t    backslash_halve(eap->arg);\n\t    }\n\n\t    if (has_wildcards)\n\t    {\n\t\tif (n == 1)\n\t\t{\n\t\t    /*\n\t\t     * First loop: May expand environment variables.  This\n\t\t     * can be done much faster with expand_env() than with\n\t\t     * something else (e.g., calling a shell).\n\t\t     * After expanding environment variables, check again\n\t\t     * if there are still wildcards present.\n\t\t     */\n\t\t    if (vim_strchr(eap->arg, '$') != NULL\n\t\t\t    || vim_strchr(eap->arg, '~') != NULL)\n\t\t    {\n\t\t\texpand_env_esc(eap->arg, NameBuff, MAXPATHL,\n\t\t\t\t\t\t\t    TRUE, TRUE, NULL);\n\t\t\thas_wildcards = mch_has_wildcard(NameBuff);\n\t\t\tp = NameBuff;\n\t\t    }\n\t\t    else\n\t\t\tp = NULL;\n\t\t}\n\t\telse // n == 2\n\t\t{\n\t\t    expand_T\txpc;\n\t\t    int\t\toptions = WILD_LIST_NOTFOUND\n\t\t\t\t\t       | WILD_NOERROR | WILD_ADD_SLASH;\n\n\t\t    ExpandInit(&xpc);\n\t\t    xpc.xp_context = EXPAND_FILES;\n\t\t    if (p_wic)\n\t\t\toptions += WILD_ICASE;\n\t\t    p = ExpandOne(&xpc, eap->arg, NULL,\n\t\t\t\t\t\t   options, WILD_EXPAND_FREE);\n\t\t    if (p == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\t\tif (p != NULL)\n\t\t{\n\t\t    (void)repl_cmdline(eap, eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t\t\t\t p, cmdlinep);\n\t\t    if (n == 2)\t// p came from ExpandOne()\n\t\t\tvim_free(p);\n\t\t}\n\t    }\n\t}\n    }\n    return OK;\n}\n\n/*\n * Replace part of the command line, keeping eap->cmd, eap->arg and\n * eap->nextcmd correct.\n * \"src\" points to the part that is to be replaced, of length \"srclen\".\n * \"repl\" is the replacement string.\n * Returns a pointer to the character after the replaced string.\n * Returns NULL for failure.\n */\n    static char_u *\nrepl_cmdline(\n    exarg_T\t*eap,\n    char_u\t*src,\n    int\t\tsrclen,\n    char_u\t*repl,\n    char_u\t**cmdlinep)\n{\n    int\t\tlen;\n    int\t\ti;\n    char_u\t*new_cmdline;\n\n    /*\n     * The new command line is build in new_cmdline[].\n     * First allocate it.\n     * Careful: a \"+cmd\" argument may have been NUL terminated.\n     */\n    len = (int)STRLEN(repl);\n    i = (int)(src - *cmdlinep) + (int)STRLEN(src + srclen) + len + 3;\n    if (eap->nextcmd != NULL)\n\ti += (int)STRLEN(eap->nextcmd);// add space for next command\n    if ((new_cmdline = alloc(i)) == NULL)\n\treturn NULL;\t\t\t// out of memory!\n\n    /*\n     * Copy the stuff before the expanded part.\n     * Copy the expanded stuff.\n     * Copy what came after the expanded part.\n     * Copy the next commands, if there are any.\n     */\n    i = (int)(src - *cmdlinep);\t// length of part before match\n    mch_memmove(new_cmdline, *cmdlinep, (size_t)i);\n\n    mch_memmove(new_cmdline + i, repl, (size_t)len);\n    i += len;\t\t\t\t// remember the end of the string\n    STRCPY(new_cmdline + i, src + srclen);\n    src = new_cmdline + i;\t\t// remember where to continue\n\n    if (eap->nextcmd != NULL)\t\t// append next command\n    {\n\ti = (int)STRLEN(new_cmdline) + 1;\n\tSTRCPY(new_cmdline + i, eap->nextcmd);\n\teap->nextcmd = new_cmdline + i;\n    }\n    eap->cmd = new_cmdline + (eap->cmd - *cmdlinep);\n    eap->arg = new_cmdline + (eap->arg - *cmdlinep);\n    if (eap->do_ecmd_cmd != NULL && eap->do_ecmd_cmd != dollar_command)\n\teap->do_ecmd_cmd = new_cmdline + (eap->do_ecmd_cmd - *cmdlinep);\n    vim_free(*cmdlinep);\n    *cmdlinep = new_cmdline;\n\n    return src;\n}\n\n/*\n * Check for '|' to separate commands and '\"' to start comments.\n * If \"keep_backslash\" is TRUE do not remove any backslash.\n */\n    void\nseparate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t// skip CTRL-V and next char\n\t    else\n\t\t\t\t// remove CTRL-V and skip next char\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n\n#ifdef FEAT_EVAL\n\t// Skip over `=expr` when wildcards are expanded.\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t// stop at NUL after CTRL-V\n\t\tbreak;\n\t}\n#endif\n\n\t// Check for '\"': start of comment or '|': next command\n\t// :@\" and :*\" do not start a comment!\n\t// :redir @\" doesn't either.\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    /*\n\t     * We remove the '\\' before the '|', unless EX_CTRLV is used\n\t     * AND 'b' is present in 'cpoptions'.\n\t     */\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t// remove the '\\'\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (!(eap->argt & EX_NOTRLCOM))\t// remove trailing spaces\n\tdel_trailing_spaces(eap->arg);\n}\n\n/*\n * get + command from ex argument\n */\n    static char_u *\ngetargcmd(char_u **argp)\n{\n    char_u *arg = *argp;\n    char_u *command = NULL;\n\n    if (*arg == '+')\t    // +[command]\n    {\n\t++arg;\n\tif (vim_isspace(*arg) || *arg == NUL)\n\t    command = dollar_command;\n\telse\n\t{\n\t    command = arg;\n\t    arg = skip_cmd_arg(command, TRUE);\n\t    if (*arg != NUL)\n\t\t*arg++ = NUL;\t\t// terminate command with NUL\n\t}\n\n\targ = skipwhite(arg);\t// skip over spaces\n\t*argp = arg;\n    }\n    return command;\n}\n\n/*\n * Find end of \"+command\" argument.  Skip over \"\\ \" and \"\\\\\".\n */\n    char_u *\nskip_cmd_arg(\n    char_u *p,\n    int\t   rembs)\t// TRUE to halve the number of backslashes\n{\n    while (*p && !vim_isspace(*p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    if (rembs)\n\t\tSTRMOVE(p, p + 1);\n\t    else\n\t\t++p;\n\t}\n\tMB_PTR_ADV(p);\n    }\n    return p;\n}\n\n    int\nget_bad_opt(char_u *p, exarg_T *eap)\n{\n    if (STRICMP(p, \"keep\") == 0)\n\teap->bad_char = BAD_KEEP;\n    else if (STRICMP(p, \"drop\") == 0)\n\teap->bad_char = BAD_DROP;\n    else if (MB_BYTE2LEN(*p) == 1 && p[1] == NUL)\n\teap->bad_char = *p;\n    else\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get \"++opt=arg\" argument.\n * Return FAIL or OK.\n */\n    static int\ngetargopt(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg + 2;\n    int\t\t*pp = NULL;\n    int\t\tbad_char_idx;\n    char_u\t*p;\n\n    // \":edit ++[no]bin[ary] file\"\n    if (STRNCMP(arg, \"bin\", 3) == 0 || STRNCMP(arg, \"nobin\", 5) == 0)\n    {\n\tif (*arg == 'n')\n\t{\n\t    arg += 2;\n\t    eap->force_bin = FORCE_NOBIN;\n\t}\n\telse\n\t    eap->force_bin = FORCE_BIN;\n\tif (!checkforcmd(&arg, \"binary\", 3))\n\t    return FAIL;\n\teap->arg = skipwhite(arg);\n\treturn OK;\n    }\n\n    // \":read ++edit file\"\n    if (STRNCMP(arg, \"edit\", 4) == 0)\n    {\n\teap->read_edit = TRUE;\n\teap->arg = skipwhite(arg + 4);\n\treturn OK;\n    }\n\n    if (STRNCMP(arg, \"ff\", 2) == 0)\n    {\n\targ += 2;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"fileformat\", 10) == 0)\n    {\n\targ += 10;\n\tpp = &eap->force_ff;\n    }\n    else if (STRNCMP(arg, \"enc\", 3) == 0)\n    {\n\tif (STRNCMP(arg, \"encoding\", 8) == 0)\n\t    arg += 8;\n\telse\n\t    arg += 3;\n\tpp = &eap->force_enc;\n    }\n    else if (STRNCMP(arg, \"bad\", 3) == 0)\n    {\n\targ += 3;\n\tpp = &bad_char_idx;\n    }\n\n    if (pp == NULL || *arg != '=')\n\treturn FAIL;\n\n    ++arg;\n    *pp = (int)(arg - eap->cmd);\n    arg = skip_cmd_arg(arg, FALSE);\n    eap->arg = skipwhite(arg);\n    *arg = NUL;\n\n    if (pp == &eap->force_ff)\n    {\n\tif (check_ff_value(eap->cmd + eap->force_ff) == FAIL)\n\t    return FAIL;\n\teap->force_ff = eap->cmd[eap->force_ff];\n    }\n    else if (pp == &eap->force_enc)\n    {\n\t// Make 'fileencoding' lower case.\n\tfor (p = eap->cmd + eap->force_enc; *p != NUL; ++p)\n\t    *p = TOLOWER_ASC(*p);\n    }\n    else\n    {\n\t// Check ++bad= argument.  Must be a single-byte character, \"keep\" or\n\t// \"drop\".\n\tif (get_bad_opt(eap->cmd + bad_char_idx, eap) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static void\nex_autocmd(exarg_T *eap)\n{\n    /*\n     * Disallow autocommands from .exrc and .vimrc in current\n     * directory for security reasons.\n     */\n    if (secure)\n    {\n\tsecure = 2;\n\teap->errmsg =\n\t      _(e_command_not_allowed_from_vimrc_in_current_dir_or_tag_search);\n    }\n    else if (eap->cmdidx == CMD_autocmd)\n\tdo_autocmd(eap, eap->arg, eap->forceit);\n    else\n\tdo_augroup(eap->arg, eap->forceit);\n}\n\n/*\n * \":doautocmd\": Apply the automatic commands to the current buffer.\n */\n    static void\nex_doautocmd(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    (void)do_doautocmd(arg, TRUE, &did_aucmd);\n    // Only when there is no <nomodeline>.\n    if (call_do_modelines && did_aucmd)\n\tdo_modelines(0);\n}\n\n/*\n * :[N]bunload[!] [N] [bufname] unload buffer\n * :[N]bdelete[!] [N] [bufname] delete buffer from buffer list\n * :[N]bwipeout[!] [N] [bufname] delete buffer really\n */\n    static void\nex_bunload(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    eap->errmsg = do_bufdel(\n\t    eap->cmdidx == CMD_bdelete ? DOBUF_DEL\n\t\t: eap->cmdidx == CMD_bwipeout ? DOBUF_WIPE\n\t\t: DOBUF_UNLOAD, eap->arg,\n\t    eap->addr_count, (int)eap->line1, (int)eap->line2, eap->forceit);\n}\n\n/*\n * :[N]buffer [N]\tto buffer N\n * :[N]sbuffer [N]\tto buffer N\n */\n    static void\nex_buffer(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (*eap->arg)\n\teap->errmsg = ex_errmsg(e_trailing_characters_str, eap->arg);\n    else\n    {\n\tif (eap->addr_count == 0)\t// default is current buffer\n\t    goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);\n\telse\n\t    goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap->line2);\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n    }\n}\n\n/*\n * :[N]bmodified [N]\tto next mod. buffer\n * :[N]sbmodified [N]\tto next mod. buffer\n */\n    static void\nex_bmodified(exarg_T *eap)\n{\n    goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bnext [N]\tto next buffer\n * :[N]sbnext [N]\tsplit and to next buffer\n */\n    static void\nex_bnext(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :[N]bNext [N]\tto previous buffer\n * :[N]bprevious [N]\tto previous buffer\n * :[N]sbNext [N]\tsplit and to previous buffer\n * :[N]sbprevious [N]\tsplit and to previous buffer\n */\n    static void\nex_bprevious(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap->line2);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :brewind\t\tto first buffer\n * :bfirst\t\tto first buffer\n * :sbrewind\t\tsplit and to first buffer\n * :sbfirst\t\tsplit and to first buffer\n */\n    static void\nex_brewind(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * :blast\t\tto last buffer\n * :sblast\t\tsplit and to last buffer\n */\n    static void\nex_blast(exarg_T *eap)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);\n    if (eap->do_ecmd_cmd != NULL)\n\tdo_cmd_argument(eap->do_ecmd_cmd);\n}\n\n/*\n * Check if \"c\" ends an Ex command.\n * In Vim9 script does not check for white space before #.\n */\n    int\nends_excmd(int c)\n{\n    int comment_char = '\"';\n\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\tcomment_char = '#';\n#endif\n    return (c == NUL || c == '|' || c == comment_char || c == '\\n');\n}\n\n/*\n * Like ends_excmd() but checks that a # in Vim9 script either has \"cmd\" equal\n * to \"cmd_start\" or has a white space character before it.\n */\n    int\nends_excmd2(char_u *cmd_start UNUSED, char_u *cmd)\n{\n    int c = *cmd;\n\n    if (c == NUL || c == '|' || c == '\\n')\n\treturn TRUE;\n#ifdef FEAT_EVAL\n    if (in_vim9script())\n\t//  # starts a comment, #{ might be a mistake, #{{ can start a fold\n\treturn c == '#' && (cmd[1] != '{' || cmd[2] == '{')\n\t\t\t\t && (cmd == cmd_start || VIM_ISWHITE(cmd[-1]));\n#endif\n    return c == '\"';\n}\n\n#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_EVAL) \\\n\t|| defined(PROTO)\n/*\n * Return the next command, after the first '|' or '\\n'.\n * Return NULL if not found.\n */\n    char_u *\nfind_nextcmd(char_u *p)\n{\n    while (*p != '|' && *p != '\\n')\n    {\n\tif (*p == NUL)\n\t    return NULL;\n\t++p;\n    }\n    return (p + 1);\n}\n#endif\n\n/*\n * Check if *p is a separator between Ex commands, skipping over white space.\n * Return NULL if it isn't, the following character if it is.\n */\n    char_u *\ncheck_nextcmd(char_u *p)\n{\n    char_u *s = skipwhite(p);\n\n    if (*s == '|' || *s == '\\n')\n\treturn (s + 1);\n    else\n\treturn NULL;\n}\n\n/*\n * If \"eap->nextcmd\" is not set, check for a next command at \"p\".\n */\n    void\nset_nextcmd(exarg_T *eap, char_u *arg)\n{\n    char_u *p = check_nextcmd(arg);\n\n    if (eap->nextcmd == NULL)\n\teap->nextcmd = p;\n    else if (p != NULL)\n\t// cannot use \"| command\" inside a  {} block\n\tsemsg(_(e_cannot_use_bar_to_separate_commands_here_str), arg);\n}\n\n/*\n * - if there are more files to edit\n * - and this is the last window\n * - and forceit not used\n * - and not repeated twice on a row\n *    return FAIL and give error message if 'message' TRUE\n * return OK otherwise\n */\n    static int\ncheck_more(\n    int message,\t    // when FALSE check only, no messages\n    int forceit)\n{\n    int\t    n = ARGCOUNT - curwin->w_arg_idx - 1;\n\n    if (!forceit && only_one_window()\n\t    && ARGCOUNT > 1 && !arg_had_last && n > 0 && quitmore == 0)\n    {\n\tif (message)\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM))\n\t\t\t\t\t\t    && curbuf->b_fname != NULL)\n\t    {\n\t\tchar_u\tbuff[DIALOG_MSG_SIZE];\n\n\t\tvim_snprintf((char *)buff, DIALOG_MSG_SIZE,\n\t\t\tNGETTEXT(\"%d more file to edit.  Quit anyway?\",\n\t\t\t    \"%d more files to edit.  Quit anyway?\", n), n);\n\t\tif (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)\n\t\t    return OK;\n\t\treturn FAIL;\n\t    }\n#endif\n\t    semsg(NGETTEXT(e_nr_more_file_to_edit,\n\t\t\t   e_nr_more_files_to_edit , n), n);\n\t    quitmore = 2;\t    // next try to quit is allowed\n\t}\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of command names.\n */\n    char_u *\nget_command_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx >= (int)CMD_SIZE)\n\treturn expand_user_command_name(idx);\n    return cmdnames[idx].cmd_name;\n}\n\n    static void\nex_colorscheme(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n    {\n#ifdef FEAT_EVAL\n\tchar_u *expr = vim_strsave((char_u *)\"g:colors_name\");\n\tchar_u *p = NULL;\n\n\tif (expr != NULL)\n\t{\n\t    ++emsg_off;\n\t    p = eval_to_string(expr, FALSE);\n\t    --emsg_off;\n\t    vim_free(expr);\n\t}\n\tif (p != NULL)\n\t{\n\t    msg((char *)p);\n\t    vim_free(p);\n\t}\n\telse\n\t    msg(\"default\");\n#else\n\tmsg(_(\"unknown\"));\n#endif\n    }\n    else if (load_colors(eap->arg) == FAIL)\n\tsemsg(_(e_cannot_find_color_scheme_str), eap->arg);\n\n#ifdef FEAT_VTP\n    else if (has_vtp_working())\n    {\n\t// background color change requires clear + redraw\n\tupdate_screen(CLEAR);\n\tredrawcmd();\n    }\n#endif\n}\n\n    static void\nex_highlight(exarg_T *eap)\n{\n    if (*eap->arg == NUL && eap->cmd[2] == '!')\n\tmsg(_(\"Greetings, Vim user!\"));\n    do_highlight(eap->arg, eap->forceit, FALSE);\n}\n\n\n/*\n * Call this function if we thought we were going to exit, but we won't\n * (because of an error).  May need to restore the terminal mode.\n */\n    void\nnot_exiting(void)\n{\n    exiting = FALSE;\n    settmode(TMODE_RAW);\n}\n\n    int\nbefore_quit_autocmds(win_T *wp, int quit_all, int forceit)\n{\n    apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, wp->w_buffer);\n\n    // Bail out when autocommands closed the window.\n    // Refuse to quit when the buffer in the last window is being closed (can\n    // only happen in autocommands).\n    if (!win_valid(wp)\n\t    || curbuf_locked()\n\t    || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0))\n\treturn TRUE;\n\n    if (quit_all || (check_more(FALSE, forceit) == OK && only_one_window()))\n    {\n\tapply_autocmds(EVENT_EXITPRE, NULL, NULL, FALSE, curbuf);\n\t// Refuse to quit when locked or when the window was closed or the\n\t// buffer in the last window is being closed (can only happen in\n\t// autocommands).\n\tif (!win_valid(wp) || curbuf_locked()\n\t\t\t  || (curbuf->b_nwindows == 1 && curbuf->b_locked > 0))\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * \":quit\": quit current window, quit Vim if the last window is closed.\n * \":{nr}quit\": quit window {nr}\n * Also used when closing a terminal window that's the last one.\n */\n    void\nex_quit(exarg_T *eap)\n{\n    win_T\t*wp;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n#endif\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n    if (eap->addr_count > 0)\n    {\n\tint\twnr = eap->line2;\n\n\tfor (wp = firstwin; wp->w_next != NULL; wp = wp->w_next)\n\t    if (--wnr <= 0)\n\t\tbreak;\n    }\n    else\n\twp = curwin;\n\n    // Refuse to quit when locked.\n    if (curbuf_locked())\n\treturn;\n\n    // Trigger QuitPre and maybe ExitPre\n    if (before_quit_autocmds(wp, FALSE, eap->forceit))\n\treturn;\n\n#ifdef FEAT_NETBEANS_INTG\n    netbeansForcedQuit = eap->forceit;\n#endif\n\n    /*\n     * If there is only one relevant window we will exit.\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n    if ((!buf_hide(wp->w_buffer)\n\t\t&& check_changed(wp->w_buffer, (p_awa ? CCGD_AW : 0)\n\t\t\t\t       | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t\t       | CCGD_EXCMD))\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, TRUE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\t// quit last window\n\t// Note: only_one_window() returns true, even so a help window is\n\t// still open. In that case only quit, if no address has been\n\t// specified. Example:\n\t// :h|wincmd w|1q     - don't quit\n\t// :h|wincmd w|q      - quit\n\tif (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))\n\t    getout(0);\n\tnot_exiting();\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\t// close window; may free buffer\n\twin_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);\n    }\n}\n\n/*\n * \":cquit\".\n */\n    static void\nex_cquit(exarg_T *eap UNUSED)\n{\n    // this does not always pass on the exit code to the Manx compiler. why?\n    getout(eap->addr_count > 0 ? (int)eap->line2 : EXIT_FAILURE);\n}\n\n/*\n * \":qall\": try to quit all windows\n */\n    static void\nex_quit_all(exarg_T *eap)\n{\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tif (eap->forceit)\n\t    cmdwin_result = K_XF1;\t// ex_window() takes care of this\n\telse\n\t    cmdwin_result = K_XF2;\n\treturn;\n    }\n# endif\n\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    if (before_quit_autocmds(curwin, TRUE, eap->forceit))\n\treturn;\n\n    exiting = TRUE;\n    if (eap->forceit || !check_changed_any(FALSE, FALSE))\n\tgetout(0);\n    not_exiting();\n}\n\n/*\n * \":close\": close current window, unless it is the last one\n */\n    static void\nex_close(exarg_T *eap)\n{\n    win_T\t*win;\n    int\t\twinnr = 0;\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = Ctrl_C;\n    else\n#endif\n\tif (!text_locked() && !curbuf_locked())\n\t{\n\t    if (eap->addr_count == 0)\n\t\tex_win_close(eap->forceit, curwin, NULL);\n\t    else\n\t    {\n\t\tFOR_ALL_WINDOWS(win)\n\t\t{\n\t\t    winnr++;\n\t\t    if (winnr == eap->line2)\n\t\t\tbreak;\n\t\t}\n\t\tif (win == NULL)\n\t\t    win = lastwin;\n\t\tex_win_close(eap->forceit, win, NULL);\n\t    }\n\t}\n}\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":pclose\": Close any preview window.\n */\n    static void\nex_pclose(exarg_T *eap)\n{\n    win_T\t*win;\n\n    // First close any normal window.\n    FOR_ALL_WINDOWS(win)\n\tif (win->w_p_pvw)\n\t{\n\t    ex_win_close(eap->forceit, win, NULL);\n\t    return;\n\t}\n# ifdef FEAT_PROP_POPUP\n    // Also when 'previewpopup' is empty, it might have been cleared.\n    popup_close_preview();\n# endif\n}\n#endif\n\n/*\n * Close window \"win\" and take care of handling closing the last window for a\n * modified buffer.\n */\n    static void\nex_win_close(\n    int\t\tforceit,\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// NULL or the tab page \"win\" is in\n{\n    int\t\tneed_hide;\n    buf_T\t*buf = win->w_buffer;\n\n    // Never close the autocommand window.\n    if (win == aucmd_win)\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn;\n    }\n\n    need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);\n    if (need_hide && !buf_hide(buf) && !forceit)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(buf, FALSE);\n\t    if (bufref_valid(&bufref) && bufIsChanged(buf))\n\t\treturn;\n\t    need_hide = FALSE;\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return;\n\t}\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // free buffer when not hiding it or when it's a scratch buffer\n    if (tp == NULL)\n\twin_close(win, !need_hide && !buf_hide(buf));\n    else\n\twin_close_othertab(win, !need_hide && !buf_hide(buf), tp);\n}\n\n/*\n * Handle the argument for a tabpage related ex command.\n * Returns a tabpage number.\n * When an error is encountered then eap->errmsg is set.\n */\n    static int\nget_tabpage_arg(exarg_T *eap)\n{\n    int tab_number;\n    int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;\n\n    if (eap->arg && *eap->arg != NUL)\n    {\n\tchar_u *p = eap->arg;\n\tchar_u *p_save;\n\tint    relative = 0; // argument +N/-N means: go to N places to the\n\t\t\t     // right/left relative to the current position.\n\n\tif (*p == '-')\n\t{\n\t    relative = -1;\n\t    p++;\n\t}\n\telse if (*p == '+')\n\t{\n\t    relative = 1;\n\t    p++;\n\t}\n\n\tp_save = p;\n\ttab_number = getdigits(&p);\n\n\tif (relative == 0)\n\t{\n\t    if (STRCMP(p, \"$\") == 0)\n\t\ttab_number = LAST_TAB_NR;\n\t    else if (STRCMP(p, \"#\") == 0)\n\t\tif (valid_tabpage(lastused_tabpage))\n\t\t    tab_number = tabpage_index(lastused_tabpage);\n\t\telse\n\t\t{\n\t\t    eap->errmsg = ex_errmsg(e_invalid_value_for_argument_str, eap->arg);\n\t\t    tab_number = 0;\n\t\t    goto theend;\n\t\t}\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number > LAST_TAB_NR)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (*p_save == NUL)\n\t\ttab_number = 1;\n\t    else if (p == p_save || *p_save == '-' || *p != NUL\n\t\t    || tab_number == 0)\n\t    {\n\t\t// No numbers as argument.\n\t\teap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\tgoto theend;\n\t    }\n\t    tab_number = tab_number * relative + tabpage_index(curtab);\n\t    if (!unaccept_arg0 && relative == -1)\n\t\t--tab_number;\n\t}\n\tif (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)\n\t    eap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n    }\n    else if (eap->addr_count > 0)\n    {\n\tif (unaccept_arg0 && eap->line2 == 0)\n\t{\n\t    eap->errmsg = _(e_invalid_range);\n\t    tab_number = 0;\n\t}\n\telse\n\t{\n\t    tab_number = eap->line2;\n\t    if (!unaccept_arg0 && *skipwhite(*eap->cmdlinep) == '-')\n\t    {\n\t\t--tab_number;\n\t\tif (tab_number < unaccept_arg0)\n\t\t    eap->errmsg = _(e_invalid_range);\n\t    }\n\t}\n    }\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\tcase CMD_tabnext:\n\t    tab_number = tabpage_index(curtab) + 1;\n\t    if (tab_number > LAST_TAB_NR)\n\t\ttab_number = 1;\n\t    break;\n\tcase CMD_tabmove:\n\t    tab_number = LAST_TAB_NR;\n\t    break;\n\tdefault:\n\t    tab_number = tabpage_index(curtab);\n\t}\n    }\n\ntheend:\n    return tab_number;\n}\n\n/*\n * \":tabclose\": close current tab page, unless it is the last one.\n * \":tabclose N\": close tab page N.\n */\n    static void\nex_tabclose(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\ttab_number;\n\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = K_IGNORE;\n    else\n# endif\n\tif (first_tabpage->tp_next == NULL)\n\t    emsg(_(e_cannot_close_last_tab_page));\n\telse\n\t{\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t    {\n\t\ttp = find_tabpage(tab_number);\n\t\tif (tp == NULL)\n\t\t{\n\t\t    beep_flush();\n\t\t    return;\n\t\t}\n\t\tif (tp != curtab)\n\t\t{\n\t\t    tabpage_close_other(tp, eap->forceit);\n\t\t    return;\n\t\t}\n\t\telse if (!text_locked() && !curbuf_locked())\n\t\t    tabpage_close(eap->forceit);\n\t    }\n\t}\n}\n\n/*\n * \":tabonly\": close all tab pages except the current one\n */\n    static void\nex_tabonly(exarg_T *eap)\n{\n    tabpage_T\t*tp;\n    int\t\tdone;\n    int\t\ttab_number;\n\n# ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\tcmdwin_result = K_IGNORE;\n    else\n# endif\n\tif (first_tabpage->tp_next == NULL)\n\t    msg(_(\"Already only one tab page\"));\n\telse\n\t{\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t    {\n\t\tgoto_tabpage(tab_number);\n\t\t// Repeat this up to a 1000 times, because autocommands may\n\t\t// mess up the lists.\n\t\tfor (done = 0; done < 1000; ++done)\n\t\t{\n\t\t    FOR_ALL_TABPAGES(tp)\n\t\t\tif (tp->tp_topframe != topframe)\n\t\t\t{\n\t\t\t    tabpage_close_other(tp, eap->forceit);\n\t\t\t    // if we failed to close it quit\n\t\t\t    if (valid_tabpage(tp))\n\t\t\t\tdone = 1000;\n\t\t\t    // start over, \"tp\" is now invalid\n\t\t\t    break;\n\t\t\t}\n\t\t    if (first_tabpage->tp_next == NULL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t}\n}\n\n/*\n * Close the current tab page.\n */\n    void\ntabpage_close(int forceit)\n{\n    // First close all the windows but the current one.  If that worked then\n    // close the last window in this tab, that will close it.\n    if (!ONE_WINDOW)\n\tclose_others(TRUE, forceit);\n    if (ONE_WINDOW)\n\tex_win_close(forceit, curwin, NULL);\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n}\n\n/*\n * Close tab page \"tp\", which is not the current tab page.\n * Note that autocommands may make \"tp\" invalid.\n * Also takes care of the tab pages line disappearing when closing the\n * last-but-one tab page.\n */\n    void\ntabpage_close_other(tabpage_T *tp, int forceit)\n{\n    int\t\tdone = 0;\n    win_T\t*wp;\n    int\t\th = tabline_height();\n\n    // Limit to 1000 windows, autocommands may add a window while we close\n    // one.  OK, so I'm paranoid...\n    while (++done < 1000)\n    {\n\twp = tp->tp_firstwin;\n\tex_win_close(forceit, wp, tp);\n\n\t// Autocommands may delete the tab page under our fingers and we may\n\t// fail to close a window with a modified buffer.\n\tif (!valid_tabpage(tp) || tp->tp_firstwin == wp)\n\t    break;\n    }\n\n    apply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * \":only\".\n */\n    static void\nex_only(exarg_T *eap)\n{\n    win_T   *wp;\n    int\t    wnr;\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    if (eap->addr_count > 0)\n    {\n\twnr = eap->line2;\n\tfor (wp = firstwin; --wnr > 0; )\n\t{\n\t    if (wp->w_next == NULL)\n\t\tbreak;\n\t    else\n\t\twp = wp->w_next;\n\t}\n\twin_goto(wp);\n    }\n    close_others(TRUE, eap->forceit);\n}\n\n    static void\nex_hide(exarg_T *eap UNUSED)\n{\n    // \":hide\" or \":hide | cmd\": hide current window\n    if (!eap->skip)\n    {\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\tif (eap->addr_count == 0)\n\t    win_close(curwin, FALSE);\t// don't free buffer\n\telse\n\t{\n\t    int\twinnr = 0;\n\t    win_T\t*win;\n\n\t    FOR_ALL_WINDOWS(win)\n\t    {\n\t\twinnr++;\n\t\tif (winnr == eap->line2)\n\t\t    break;\n\t    }\n\t    if (win == NULL)\n\t\twin = lastwin;\n\t    win_close(win, FALSE);\n\t}\n    }\n}\n\n/*\n * \":stop\" and \":suspend\": Suspend Vim.\n */\n    void\nex_stop(exarg_T *eap)\n{\n    /*\n     * Disallow suspending for \"rvim\".\n     */\n    if (!check_restricted())\n    {\n\tif (!eap->forceit)\n\t    autowrite_all();\n\tapply_autocmds(EVENT_VIMSUSPEND, NULL, NULL, FALSE, NULL);\n\twindgoto((int)Rows - 1, 0);\n\tout_char('\\n');\n\tout_flush();\n\tstoptermcap();\n\tout_flush();\t\t// needed for SUN to restore xterm buffer\n\tmch_restore_title(SAVE_RESTORE_BOTH);\t// restore window titles\n\tui_suspend();\t\t// call machine specific function\n\tmaketitle();\n\tresettitle();\t\t// force updating the title\n\tstarttermcap();\n\tscroll_start();\t\t// scroll screen before redrawing\n\tredraw_later_clear();\n\tshell_resized();\t// may have resized window\n\tapply_autocmds(EVENT_VIMRESUME, NULL, NULL, FALSE, NULL);\n    }\n}\n\n/*\n * \":exit\", \":xit\" and \":wq\": Write file and quit the current window.\n */\n    static void\nex_exit(exarg_T *eap)\n{\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\tcmdwin_result = Ctrl_C;\n\treturn;\n    }\n#endif\n    // Don't quit while editing the command line.\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n\n    /*\n     * we plan to exit if there is only one relevant window\n     */\n    if (check_more(FALSE, eap->forceit) == OK && only_one_window())\n\texiting = TRUE;\n\n    // Write the buffer for \":wq\" or when it was changed.\n    // Trigger QuitPre and ExitPre.\n    // Check if we can exit now, after autocommands have changed things.\n    if (((eap->cmdidx == CMD_wq || curbufIsChanged()) && do_write(eap) == FAIL)\n\t    || before_quit_autocmds(curwin, FALSE, eap->forceit)\n\t    || check_more(TRUE, eap->forceit) == FAIL\n\t    || (only_one_window() && check_changed_any(eap->forceit, FALSE)))\n    {\n\tnot_exiting();\n    }\n    else\n    {\n\tif (only_one_window())\t    // quit last window, exit Vim\n\t    getout(0);\n\tnot_exiting();\n# ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n# endif\n\t// Quit current window, may free the buffer.\n\twin_close(curwin, !buf_hide(curwin->w_buffer));\n    }\n}\n\n/*\n * \":print\", \":list\", \":number\".\n */\n    static void\nex_print(exarg_T *eap)\n{\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\temsg(_(e_empty_buffer));\n    else\n    {\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    print_line(eap->line1,\n\t\t    (eap->cmdidx == CMD_number || eap->cmdidx == CMD_pound\n\t\t\t\t\t\t || (eap->flags & EXFLAG_NR)),\n\t\t    eap->cmdidx == CMD_list || (eap->flags & EXFLAG_LIST));\n\t    if (++eap->line1 > eap->line2)\n\t\tbreak;\n\t    out_flush();\t    // show one line at a time\n\t}\n\tsetpcmark();\n\t// put cursor at last line\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    ex_no_reprint = TRUE;\n}\n\n#ifdef FEAT_BYTEOFF\n    static void\nex_goto(exarg_T *eap)\n{\n    goto_byte(eap->line2);\n}\n#endif\n\n/*\n * \":shell\".\n */\n    static void\nex_shell(exarg_T *eap UNUSED)\n{\n    do_shell(NULL, 0);\n}\n\n#if defined(HAVE_DROP_FILE) || defined(PROTO)\n\nstatic int drop_busy = FALSE;\nstatic int drop_filec;\nstatic char_u **drop_filev = NULL;\nstatic int drop_split;\nstatic void (*drop_callback)(void *);\nstatic void *drop_cookie;\n\n    static void\nhandle_drop_internal(void)\n{\n    exarg_T\tea;\n    int\t\tsave_msg_scroll = msg_scroll;\n\n    // Setting the argument list may cause screen updates and being called\n    // recursively.  Avoid that by setting drop_busy.\n    drop_busy = TRUE;\n\n    // Check whether the current buffer is changed. If so, we will need\n    // to split the current window or data could be lost.\n    // We don't need to check if the 'hidden' option is set, as in this\n    // case the buffer won't be lost.\n    if (!buf_hide(curbuf) && !drop_split)\n    {\n\t++emsg_off;\n\tdrop_split = check_changed(curbuf, CCGD_AW);\n\t--emsg_off;\n    }\n    if (drop_split)\n    {\n\tif (win_split(0, 0) == FAIL)\n\t    return;\n\tRESET_BINDING(curwin);\n\n\t// When splitting the window, create a new alist.  Otherwise the\n\t// existing one is overwritten.\n\talist_unlink(curwin->w_alist);\n\talist_new();\n    }\n\n    /*\n     * Set up the new argument list.\n     */\n    alist_set(ALIST(curwin), drop_filec, drop_filev, FALSE, NULL, 0);\n\n    /*\n     * Move to the first file.\n     */\n    // Fake up a minimal \"next\" command for do_argfile()\n    CLEAR_FIELD(ea);\n    ea.cmd = (char_u *)\"next\";\n    do_argfile(&ea, 0);\n\n    // do_ecmd() may set need_start_insertmode, but since we never left Insert\n    // mode that is not needed here.\n    need_start_insertmode = FALSE;\n\n    // Restore msg_scroll, otherwise a following command may cause scrolling\n    // unexpectedly.  The screen will be redrawn by the caller, thus\n    // msg_scroll being set by displaying a message is irrelevant.\n    msg_scroll = save_msg_scroll;\n\n    if (drop_callback != NULL)\n\tdrop_callback(drop_cookie);\n\n    drop_filev = NULL;\n    drop_busy = FALSE;\n}\n\n/*\n * Handle a file drop. The code is here because a drop is *nearly* like an\n * :args command, but not quite (we have a list of exact filenames, so we\n * don't want to (a) parse a command line, or (b) expand wildcards). So the\n * code is very similar to :args and hence needs access to a lot of the static\n * functions in this file.\n *\n * The \"filev\" list must have been allocated using alloc(), as should each item\n * in the list. This function takes over responsibility for freeing the \"filev\"\n * list.\n */\n    void\nhandle_drop(\n    int\t\tfilec,\t\t// the number of files dropped\n    char_u\t**filev,\t// the list of files dropped\n    int\t\tsplit,\t\t// force splitting the window\n    void\t(*callback)(void *), // to be called after setting the argument\n\t\t\t\t     // list\n    void\t*cookie)\t// argument for \"callback\" (allocated)\n{\n    // Cannot handle recursive drops, finish the pending one.\n    if (drop_busy)\n    {\n\tFreeWild(filec, filev);\n\tvim_free(cookie);\n\treturn;\n    }\n\n    // When calling handle_drop() more than once in a row we only use the last\n    // one.\n    if (drop_filev != NULL)\n    {\n\tFreeWild(drop_filec, drop_filev);\n\tvim_free(drop_cookie);\n    }\n\n    drop_filec = filec;\n    drop_filev = filev;\n    drop_split = split;\n    drop_callback = callback;\n    drop_cookie = cookie;\n\n    // Postpone this when:\n    // - editing the command line\n    // - not possible to change the current buffer\n    // - updating the screen\n    // As it may change buffers and window structures that are in use and cause\n    // freed memory to be used.\n    if (text_locked() || curbuf_locked() || updating_screen)\n\treturn;\n\n    handle_drop_internal();\n}\n\n/*\n * To be called when text is unlocked, curbuf is unlocked or updating_screen is\n * reset: Handle a postponed drop.\n */\n    void\nhandle_any_postponed_drop(void)\n{\n    if (!drop_busy && drop_filev != NULL\n\t     && !text_locked() && !curbuf_locked() && !updating_screen)\n\thandle_drop_internal();\n}\n#endif\n\n/*\n * \":preserve\".\n */\n    static void\nex_preserve(exarg_T *eap UNUSED)\n{\n    curbuf->b_flags |= BF_PRESERVED;\n    ml_preserve(curbuf, TRUE);\n}\n\n/*\n * \":recover\".\n */\n    static void\nex_recover(exarg_T *eap)\n{\n    // Set recoverymode right away to avoid the ATTENTION prompt.\n    recoverymode = TRUE;\n    if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t     | CCGD_MULTWIN\n\t\t\t     | (eap->forceit ? CCGD_FORCEIT : 0)\n\t\t\t     | CCGD_EXCMD)\n\n\t    && (*eap->arg == NUL\n\t\t\t     || setfname(curbuf, eap->arg, NULL, TRUE) == OK))\n\tml_recover(TRUE);\n    recoverymode = FALSE;\n}\n\n/*\n * Command modifier used in a wrong way.\n */\n    static void\nex_wrongmodifier(exarg_T *eap)\n{\n    eap->errmsg = _(e_invalid_command);\n}\n\n/*\n * :sview [+command] file\tsplit window with new file, read-only\n * :split [[+command] file]\tsplit window with current or new file\n * :vsplit [[+command] file]\tsplit window vertically with current or new file\n * :new [[+command] file]\tsplit window with no or new file\n * :vnew [[+command] file]\tsplit vertically window with no or new file\n * :sfind [+command] file\tsplit window with file in 'path'\n *\n * :tabedit\t\t\topen new Tab page with empty window\n * :tabedit [+command] file\topen new Tab page and edit \"file\"\n * :tabnew [[+command] file]\tjust like :tabedit\n * :tabfind [+command] file\topen new Tab page and find \"file\"\n */\n    void\nex_splitview(exarg_T *eap)\n{\n    win_T\t*old_curwin = curwin;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)\n    char_u\t*fname = NULL;\n#endif\n#ifdef FEAT_BROWSE\n    char_u\tdot_path[] = \".\";\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#endif\n    int\t\tuse_tab = eap->cmdidx == CMD_tabedit\n\t\t       || eap->cmdidx == CMD_tabfind\n\t\t       || eap->cmdidx == CMD_tabnew;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // A \":split\" in the quickfix window works like \":new\".  Don't want two\n    // quickfix windows.  But it's OK when doing \":tab split\".\n    if (bt_quickfix(curbuf) && cmdmod.cmod_tab == 0)\n    {\n\tif (eap->cmdidx == CMD_split)\n\t    eap->cmdidx = CMD_new;\n\tif (eap->cmdidx == CMD_vsplit)\n\t    eap->cmdidx = CMD_vnew;\n    }\n#endif\n\n#ifdef FEAT_SEARCHPATH\n    if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind)\n    {\n\tfname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),\n\t\t\t\t\t  FNAME_MESS, TRUE, curbuf->b_ffname);\n\tif (fname == NULL)\n\t    goto theend;\n\teap->arg = fname;\n    }\n# ifdef FEAT_BROWSE\n    else\n# endif\n#endif\n#ifdef FEAT_BROWSE\n    if ((cmdmod.cmod_flags & CMOD_BROWSE)\n\t    && eap->cmdidx != CMD_vnew\n\t    && eap->cmdidx != CMD_new)\n    {\n\tif (\n# ifdef FEAT_GUI\n\t    !gui.in_use &&\n# endif\n\t\tau_has_group((char_u *)\"FileExplorer\"))\n\t{\n\t    // No browsing supported but we do have the file explorer:\n\t    // Edit the directory.\n\t    if (*eap->arg == NUL || !mch_isdir(eap->arg))\n\t\teap->arg = dot_path;\n\t}\n\telse\n\t{\n\t    fname = do_browse(0, (char_u *)(use_tab\n\t\t\t? _(\"Edit File in new tab page\")\n\t\t\t: _(\"Edit File in new window\")),\n\t\t\t\t\t  eap->arg, NULL, NULL, NULL, curbuf);\n\t    if (fname == NULL)\n\t\tgoto theend;\n\t    eap->arg = fname;\n\t}\n    }\n    cmdmod.cmod_flags &= ~CMOD_BROWSE;\t// Don't browse again in do_ecmd().\n#endif\n\n    /*\n     * Either open new tab page or split the window.\n     */\n    if (use_tab)\n    {\n\tif (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab\n\t\t\t : eap->addr_count == 0 ? 0\n\t\t\t\t\t       : (int)eap->line2 + 1) != FAIL)\n\t{\n\t    do_exedit(eap, old_curwin);\n\n\t    // set the alternate buffer for the window we came from\n\t    if (curwin != old_curwin\n\t\t    && win_valid(old_curwin)\n\t\t    && old_curwin->w_buffer != curbuf\n\t\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\t\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\t}\n    }\n    else if (win_split(eap->addr_count > 0 ? (int)eap->line2 : 0,\n\t\t\t\t     *eap->cmd == 'v' ? WSP_VERT : 0) != FAIL)\n    {\n\t// Reset 'scrollbind' when editing another file, but keep it when\n\t// doing \":split\" without arguments.\n\tif (*eap->arg != NUL)\n\t    RESET_BINDING(curwin);\n\telse\n\t    do_check_scrollbind(FALSE);\n\tdo_exedit(eap, old_curwin);\n    }\n\n# ifdef FEAT_BROWSE\n    cmdmod.cmod_flags = save_cmod_flags;\n# endif\n\n# if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)\ntheend:\n    vim_free(fname);\n# endif\n}\n\n/*\n * Open a new tab page.\n */\n    void\ntabpage_new(void)\n{\n    exarg_T\tea;\n\n    CLEAR_FIELD(ea);\n    ea.cmdidx = CMD_tabnew;\n    ea.cmd = (char_u *)\"tabn\";\n    ea.arg = (char_u *)\"\";\n    ex_splitview(&ea);\n}\n\n/*\n * :tabnext command\n */\n    static void\nex_tabnext(exarg_T *eap)\n{\n    int tab_number;\n\n    if (ERROR_IF_POPUP_WINDOW)\n\treturn;\n    switch (eap->cmdidx)\n    {\n\tcase CMD_tabfirst:\n\tcase CMD_tabrewind:\n\t    goto_tabpage(1);\n\t    break;\n\tcase CMD_tablast:\n\t    goto_tabpage(9999);\n\t    break;\n\tcase CMD_tabprevious:\n\tcase CMD_tabNext:\n\t    if (eap->arg && *eap->arg != NUL)\n\t    {\n\t\tchar_u *p = eap->arg;\n\t\tchar_u *p_save = p;\n\n\t\ttab_number = getdigits(&p);\n\t\tif (p == p_save || *p_save == '-' || *p != NUL\n\t\t\t    || tab_number == 0)\n\t\t{\n\t\t    // No numbers as argument.\n\t\t    eap->errmsg = ex_errmsg(e_invalid_argument_str, eap->arg);\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (eap->addr_count == 0)\n\t\t    tab_number = 1;\n\t\telse\n\t\t{\n\t\t    tab_number = eap->line2;\n\t\t    if (tab_number < 1)\n\t\t    {\n\t\t\teap->errmsg = _(e_invalid_range);\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t    }\n\t    goto_tabpage(-tab_number);\n\t    break;\n\tdefault: // CMD_tabnext\n\t    tab_number = get_tabpage_arg(eap);\n\t    if (eap->errmsg == NULL)\n\t\tgoto_tabpage(tab_number);\n\t    break;\n    }\n}\n\n/*\n * :tabmove command\n */\n    static void\nex_tabmove(exarg_T *eap)\n{\n    int tab_number;\n\n    tab_number = get_tabpage_arg(eap);\n    if (eap->errmsg == NULL)\n\ttabpage_move(tab_number);\n}\n\n/*\n * :tabs command: List tabs and their contents.\n */\n    static void\nex_tabs(exarg_T *eap UNUSED)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n    int\t\ttabcount = 1;\n\n    msg_start();\n    msg_scroll = TRUE;\n    for (tp = first_tabpage; tp != NULL && !got_int; tp = tp->tp_next)\n    {\n\tmsg_putchar('\\n');\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Tab page %d\"), tabcount++);\n\tmsg_outtrans_attr(IObuff, HL_ATTR(HLF_T));\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n\n\tif (tp  == curtab)\n\t    wp = firstwin;\n\telse\n\t    wp = tp->tp_firstwin;\n\tfor ( ; wp != NULL && !got_int; wp = wp->w_next)\n\t{\n\t    msg_putchar('\\n');\n\t    msg_putchar(wp == curwin ? '>' : ' ');\n\t    msg_putchar(' ');\n\t    msg_putchar(bufIsChanged(wp->w_buffer) ? '+' : ' ');\n\t    msg_putchar(' ');\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(IObuff, buf_spname(wp->w_buffer), IOSIZE - 1);\n\t    else\n\t\thome_replace(wp->w_buffer, wp->w_buffer->b_fname,\n\t\t\t\t\t\t\tIObuff, IOSIZE, TRUE);\n\t    msg_outtrans(IObuff);\n\t    out_flush();\t    // output one line at a time\n\t    ui_breakcheck();\n\t}\n    }\n}\n\n/*\n * \":mode\": Set screen mode.\n * If no argument given, just get the screen size and redraw.\n */\n    static void\nex_mode(exarg_T *eap)\n{\n    if (*eap->arg == NUL)\n\tshell_resized();\n    else\n\temsg(_(e_screen_mode_setting_not_supported));\n}\n\n/*\n * \":resize\".\n * set, increment or decrement current window height\n */\n    static void\nex_resize(exarg_T *eap)\n{\n    int\t\tn;\n    win_T\t*wp = curwin;\n\n    if (eap->addr_count > 0)\n    {\n\tn = eap->line2;\n\tfor (wp = firstwin; wp->w_next != NULL && --n > 0; wp = wp->w_next)\n\t    ;\n    }\n\n# ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n# endif\n    n = atol((char *)eap->arg);\n    if (cmdmod.cmod_split & WSP_VERT)\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_width;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very wide\n\t    n = 9999;\n\twin_setwidth_win(n, wp);\n    }\n    else\n    {\n\tif (*eap->arg == '-' || *eap->arg == '+')\n\t    n += wp->w_height;\n\telse if (n == 0 && eap->arg[0] == NUL)\t// default is very high\n\t    n = 9999;\n\twin_setheight_win(n, wp);\n    }\n}\n\n/*\n * \":find [+command] <file>\" command.\n */\n    static void\nex_find(exarg_T *eap)\n{\n#ifdef FEAT_SEARCHPATH\n    char_u\t*fname;\n    int\t\tcount;\n\n    fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg), FNAME_MESS,\n\t\t\t\t\t\t      TRUE, curbuf->b_ffname);\n    if (eap->addr_count > 0)\n    {\n\t// Repeat finding the file \"count\" times.  This matters when it\n\t// appears several times in the path.\n\tcount = eap->line2;\n\twhile (fname != NULL && --count > 0)\n\t{\n\t    vim_free(fname);\n\t    fname = find_file_in_path(NULL, 0, FNAME_MESS,\n\t\t\t\t\t\t     FALSE, curbuf->b_ffname);\n\t}\n    }\n\n    if (fname != NULL)\n    {\n\teap->arg = fname;\n#endif\n\tdo_exedit(eap, NULL);\n#ifdef FEAT_SEARCHPATH\n\tvim_free(fname);\n    }\n#endif\n}\n\n/*\n * \":open\" simulation: for now just work like \":visual\".\n */\n    static void\nex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    // make a copy of the line, when searching for a mark it might be\n\t    // flushed\n\t    char_u *line = vim_strsave(ml_get_curline());\n\n\t    regmatch.rm_ic = p_ic;\n\t    if (vim_regexec(&regmatch, line, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - line);\n\t    else\n\t\temsg(_(e_no_match));\n\t    vim_regfree(regmatch.regprog);\n\t    vim_free(line);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit\", \":badd\", \":balt\", \":visual\".\n */\n    static void\nex_edit(exarg_T *eap)\n{\n    do_exedit(eap, NULL);\n}\n\n/*\n * \":edit <file>\" command and alike.\n */\n    void\ndo_exedit(\n    exarg_T\t*eap,\n    win_T\t*old_curwin)\t    // curwin before doing a split or NULL\n{\n    int\t\tn;\n    int\t\tneed_hide;\n    int\t\texmode_was = exmode_active;\n\n    if ((eap->cmdidx != CMD_pedit && ERROR_IF_POPUP_WINDOW)\n\t\t\t\t\t\t || ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n    /*\n     * \":vi\" command ends Ex mode.\n     */\n    if (exmode_active && (eap->cmdidx == CMD_visual\n\t\t\t\t\t\t|| eap->cmdidx == CMD_view))\n    {\n\texmode_active = FALSE;\n\tex_pressedreturn = FALSE;\n\tif (*eap->arg == NUL)\n\t{\n\t    // Special case:  \":global/pat/visual\\NLvi-commands\"\n\t    if (global_busy)\n\t    {\n\t\tint\trd = RedrawingDisabled;\n\t\tint\tnwr = no_wait_return;\n\t\tint\tms = msg_scroll;\n#ifdef FEAT_GUI\n\t\tint\the = hold_gui_events;\n#endif\n\n\t\tif (eap->nextcmd != NULL)\n\t\t{\n\t\t    stuffReadbuff(eap->nextcmd);\n\t\t    eap->nextcmd = NULL;\n\t\t}\n\n\t\tif (exmode_was != EXMODE_VIM)\n\t\t    settmode(TMODE_RAW);\n\t\tRedrawingDisabled = 0;\n\t\tno_wait_return = 0;\n\t\tneed_wait_return = FALSE;\n\t\tmsg_scroll = 0;\n#ifdef FEAT_GUI\n\t\thold_gui_events = 0;\n#endif\n\t\tmust_redraw = CLEAR;\n\t\tpending_exmode_active = TRUE;\n\n\t\tmain_loop(FALSE, TRUE);\n\n\t\tpending_exmode_active = FALSE;\n\t\tRedrawingDisabled = rd;\n\t\tno_wait_return = nwr;\n\t\tmsg_scroll = ms;\n#ifdef FEAT_GUI\n\t\thold_gui_events = he;\n#endif\n\t    }\n\t    return;\n\t}\n    }\n\n    if ((eap->cmdidx == CMD_new\n\t\t|| eap->cmdidx == CMD_tabnew\n\t\t|| eap->cmdidx == CMD_tabedit\n\t\t|| eap->cmdidx == CMD_vnew) && *eap->arg == NUL)\n    {\n\t// \":new\" or \":tabnew\" without argument: edit a new empty buffer\n\tsetpcmark();\n\t(void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,\n\t\t      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),\n\t\t      old_curwin == NULL ? curwin : NULL);\n    }\n    else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)\n\t    || *eap->arg != NUL\n#ifdef FEAT_BROWSE\n\t    || (cmdmod.cmod_flags & CMOD_BROWSE)\n#endif\n\t    )\n    {\n\t// Can't edit another file when \"textlock\" or \"curbuf_lock\" is set.\n\t// Only \":edit\" or \":script\" can bring us here, others are stopped\n\t// earlier.\n\tif (*eap->arg != NUL && text_or_buf_locked())\n\t    return;\n\n\tn = readonlymode;\n\tif (eap->cmdidx == CMD_view || eap->cmdidx == CMD_sview)\n\t    readonlymode = TRUE;\n\telse if (eap->cmdidx == CMD_enew)\n\t    readonlymode = FALSE;   // 'readonly' doesn't make sense in an\n\t\t\t\t    // empty buffer\n\tif (eap->cmdidx != CMD_balt && eap->cmdidx != CMD_badd)\n\t    setpcmark();\n\tif (do_ecmd(0, (eap->cmdidx == CMD_enew ? NULL : eap->arg),\n\t\t    NULL, eap,\n\t\t    // \":edit\" goes to first line if Vi compatible\n\t\t    (*eap->arg == NUL && eap->do_ecmd_lnum == 0\n\t\t\t\t      && vim_strchr(p_cpo, CPO_GOTO1) != NULL)\n\t\t\t\t\t       ? ECMD_ONE : eap->do_ecmd_lnum,\n\t\t    (buf_hide(curbuf) ? ECMD_HIDE : 0)\n\t\t    + (eap->forceit ? ECMD_FORCEIT : 0)\n\t\t      // after a split we can use an existing buffer\n\t\t    + (old_curwin != NULL ? ECMD_OLDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_badd ? ECMD_ADDBUF : 0)\n\t\t    + (eap->cmdidx == CMD_balt ? ECMD_ALTBUF : 0)\n\t\t    , old_curwin == NULL ? curwin : NULL) == FAIL)\n\t{\n\t    // Editing the file failed.  If the window was split, close it.\n\t    if (old_curwin != NULL)\n\t    {\n\t\tneed_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);\n\t\tif (!need_hide || buf_hide(curbuf))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    cleanup_T   cs;\n\n\t\t    // Reset the error/interrupt/exception state here so that\n\t\t    // aborting() returns FALSE when closing a window.\n\t\t    enter_cleanup(&cs);\n#endif\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n\t\t    win_close(curwin, !need_hide && !buf_hide(curbuf));\n\n#if defined(FEAT_EVAL)\n\t\t    // Restore the error/interrupt/exception state if not\n\t\t    // discarded by a new aborting error, interrupt, or\n\t\t    // uncaught exception.\n\t\t    leave_cleanup(&cs);\n#endif\n\t\t}\n\t    }\n\t}\n\telse if (readonlymode && curbuf->b_nwindows == 1)\n\t{\n\t    // When editing an already visited buffer, 'readonly' won't be set\n\t    // but the previous value is kept.  With \":view\" and \":sview\" we\n\t    // want the  file to be readonly, except when another window is\n\t    // editing the same buffer.\n\t    curbuf->b_p_ro = TRUE;\n\t}\n\treadonlymode = n;\n    }\n    else\n    {\n\tif (eap->do_ecmd_cmd != NULL)\n\t    do_cmd_argument(eap->do_ecmd_cmd);\n\tn = curwin->w_arg_idx_invalid;\n\tcheck_arg_idx(curwin);\n\tif (n != curwin->w_arg_idx_invalid)\n\t    maketitle();\n    }\n\n    /*\n     * if \":split file\" worked, set alternate file name in old window to new\n     * file\n     */\n    if (old_curwin != NULL\n\t    && *eap->arg != NUL\n\t    && curwin != old_curwin\n\t    && win_valid(old_curwin)\n\t    && old_curwin->w_buffer != curbuf\n\t    && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\told_curwin->w_alt_fnum = curbuf->b_fnum;\n\n    ex_no_reprint = TRUE;\n}\n\n#ifndef FEAT_GUI\n/*\n * \":gui\" and \":gvim\" when there is no GUI.\n */\n    static void\nex_nogui(exarg_T *eap)\n{\n    eap->errmsg = _(e_gui_cannot_be_used_not_enabled_at_compile_time);\n}\n#endif\n\n#if defined(FEAT_GUI_MSWIN) && defined(FEAT_MENU) && defined(FEAT_TEAROFF)\n    static void\nex_tearoff(exarg_T *eap)\n{\n    gui_make_tearoff(eap->arg);\n}\n#endif\n\n#if (defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_TERM_POPUP_MENU)) && defined(FEAT_MENU)\n    static void\nex_popup(exarg_T *eap)\n{\n# if defined(FEAT_GUI_MSWIN) || defined(FEAT_GUI_GTK)\n    if (gui.in_use)\n\tgui_make_popup(eap->arg, eap->forceit);\n#  ifdef FEAT_TERM_POPUP_MENU\n    else\n#  endif\n# endif\n# ifdef FEAT_TERM_POPUP_MENU\n\tpum_make_popup(eap->arg, eap->forceit);\n# endif\n}\n#endif\n\n    static void\nex_swapname(exarg_T *eap UNUSED)\n{\n    if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)\n\tmsg(_(\"No swap file\"));\n    else\n\tmsg((char *)curbuf->b_ml.ml_mfp->mf_fname);\n}\n\n/*\n * \":syncbind\" forces all 'scrollbind' windows to have the same relative\n * offset.\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    static void\nex_syncbind(exarg_T *eap UNUSED)\n{\n    win_T\t*wp;\n    win_T\t*save_curwin = curwin;\n    buf_T\t*save_curbuf = curbuf;\n    long\ttopline;\n    long\ty;\n    linenr_T\told_linenr = curwin->w_cursor.lnum;\n\n    setpcmark();\n\n    /*\n     * determine max topline\n     */\n    if (curwin->w_p_scb)\n    {\n\ttopline = curwin->w_topline;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_p_scb && wp->w_buffer)\n\t    {\n\t\ty = wp->w_buffer->b_ml.ml_line_count - get_scrolloff_value();\n\t\tif (topline > y)\n\t\t    topline = y;\n\t    }\n\t}\n\tif (topline < 1)\n\t    topline = 1;\n    }\n    else\n    {\n\ttopline = 1;\n    }\n\n\n    /*\n     * Set all scrollbind windows to the same topline.\n     */\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tif (curwin->w_p_scb)\n\t{\n\t    curbuf = curwin->w_buffer;\n\t    y = topline - curwin->w_topline;\n\t    if (y > 0)\n\t\tscrollup(y, TRUE);\n\t    else\n\t\tscrolldown(-y, TRUE);\n\t    curwin->w_scbind_pos = topline;\n\t    redraw_later(VALID);\n\t    cursor_correct();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n    curwin = save_curwin;\n    curbuf = save_curbuf;\n    if (curwin->w_p_scb)\n    {\n\tdid_syncbind = TRUE;\n\tcheckpcmark();\n\tif (old_linenr != curwin->w_cursor.lnum)\n\t{\n\t    char_u ctrl_o[2];\n\n\t    ctrl_o[0] = Ctrl_O;\n\t    ctrl_o[1] = 0;\n\t    ins_typebuf(ctrl_o, REMAP_NONE, 0, TRUE, FALSE);\n\t}\n    }\n}\n\n\n    static void\nex_read(exarg_T *eap)\n{\n    int\t\ti;\n    int\t\tempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n    linenr_T\tlnum;\n\n    if (eap->usefilter)\t\t\t// :r!cmd\n\tdo_bang(1, eap, FALSE, FALSE, TRUE);\n    else\n    {\n\tif (u_save(eap->line2, (linenr_T)(eap->line2 + 1)) == FAIL)\n\t    return;\n\n#ifdef FEAT_BROWSE\n\tif (cmdmod.cmod_flags & CMOD_BROWSE)\n\t{\n\t    char_u *browseFile;\n\n\t    browseFile = do_browse(0, (char_u *)_(\"Append File\"), eap->arg,\n\t\t\t\t\t\t    NULL, NULL, NULL, curbuf);\n\t    if (browseFile != NULL)\n\t    {\n\t\ti = readfile(browseFile, NULL,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t\tvim_free(browseFile);\n\t    }\n\t    else\n\t\ti = OK;\n\t}\n\telse\n#endif\n\t     if (*eap->arg == NUL)\n\t{\n\t    if (check_fname() == FAIL)\t// check for no file name\n\t\treturn;\n\t    i = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\t}\n\telse\n\t{\n\t    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL)\n\t\t(void)setaltfname(eap->arg, eap->arg, (linenr_T)1);\n\t    i = readfile(eap->arg, NULL,\n\t\t\t  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);\n\n\t}\n\tif (i != OK)\n\t{\n#if defined(FEAT_EVAL)\n\t    if (!aborting())\n#endif\n\t\tsemsg(_(e_cant_open_file_str), eap->arg);\n\t}\n\telse\n\t{\n\t    if (empty && exmode_active)\n\t    {\n\t\t// Delete the empty line that remains.  Historically ex does\n\t\t// this but vi doesn't.\n\t\tif (eap->line2 == 0)\n\t\t    lnum = curbuf->b_ml.ml_line_count;\n\t\telse\n\t\t    lnum = 1;\n\t\tif (*ml_get(lnum) == NUL && u_savedel(lnum, 1L) == OK)\n\t\t{\n\t\t    ml_delete(lnum);\n\t\t    if (curwin->w_cursor.lnum > 1\n\t\t\t\t\t     && curwin->w_cursor.lnum >= lnum)\n\t\t\t--curwin->w_cursor.lnum;\n\t\t    deleted_lines_mark(lnum, 1L);\n\t\t}\n\t    }\n\t    redraw_curbuf_later(VALID);\n\t}\n    }\n}\n\nstatic char_u\t*prev_dir = NULL;\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_cd_dir(void)\n{\n    VIM_CLEAR(prev_dir);\n    VIM_CLEAR(globaldir);\n}\n#endif\n\n/*\n * Get the previous directory for the given chdir scope.\n */\n    static char_u *\nget_prevdir(cdscope_T scope)\n{\n    if (scope == CDSCOPE_WINDOW)\n\treturn curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\treturn curtab->tp_prevdir;\n    return prev_dir;\n}\n\n/*\n * Deal with the side effects of changing the current directory.\n * When 'scope' is CDSCOPE_TABPAGE then this was after an \":tcd\" command.\n * When 'scope' is CDSCOPE_WINDOW then this was after an \":lcd\" command.\n */\n    void\npost_chdir(cdscope_T scope)\n{\n    if (scope != CDSCOPE_WINDOW)\n\t// Clear tab local directory for both :cd and :tcd\n\tVIM_CLEAR(curtab->tp_localdir);\n    VIM_CLEAR(curwin->w_localdir);\n    if (scope != CDSCOPE_GLOBAL)\n    {\n\tchar_u\t*pdir = get_prevdir(scope);\n\n\t// If still in the global directory, need to remember current\n\t// directory as the global directory.\n\tif (globaldir == NULL && pdir != NULL)\n\t    globaldir = vim_strsave(pdir);\n\n\t// Remember this local directory for the window.\n\tif (mch_dirname(NameBuff, MAXPATHL) == OK)\n\t{\n\t    if (scope == CDSCOPE_TABPAGE)\n\t\tcurtab->tp_localdir = vim_strsave(NameBuff);\n\t    else\n\t\tcurwin->w_localdir = vim_strsave(NameBuff);\n\t}\n    }\n    else\n    {\n\t// We are now in the global directory, no need to remember its name.\n\tVIM_CLEAR(globaldir);\n    }\n\n    last_chdir_reason = NULL;\n    shorten_fnames(TRUE);\n}\n\n/*\n * Trigger DirChangedPre for \"acmd_fname\" with directory \"new_dir\".\n */\n    void\ntrigger_DirChangedPre(char_u *acmd_fname, char_u *new_dir)\n{\n#ifdef FEAT_EVAL\n    dict_T\t    *v_event;\n    save_v_event_T  save_v_event;\n\n    v_event = get_v_event(&save_v_event);\n    (void)dict_add_string(v_event, \"directory\", new_dir);\n    dict_set_items_ro(v_event);\n#endif\n    apply_autocmds(EVENT_DIRCHANGEDPRE, acmd_fname, new_dir, FALSE, curbuf);\n#ifdef FEAT_EVAL\n    restore_v_event(v_event, &save_v_event);\n#endif\n}\n\n/*\n * Change directory function used by :cd/:tcd/:lcd Ex commands and the\n * chdir() function.\n * scope == CDSCOPE_WINDOW: changes the window-local directory\n * scope == CDSCOPE_TABPAGE: changes the tab-local directory\n * Otherwise: changes the global directory\n * Returns TRUE if the directory is successfully changed.\n */\n    int\nchangedir_func(\n\tchar_u\t\t*new_dir,\n\tint\t\tforceit,\n\tcdscope_T\tscope)\n{\n    char_u\t*pdir = NULL;\n    int\t\tdir_differs;\n    char_u\t*acmd_fname = NULL;\n    char_u\t**pp;\n    char_u\t*tofree;\n\n    if (new_dir == NULL || allbuf_locked())\n\treturn FALSE;\n\n    if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged() && !forceit)\n    {\n\temsg(_(e_cannot_change_directory_buffer_is_modified_add_bang_to_override));\n\treturn FALSE;\n    }\n\n    // \":cd -\": Change to previous directory\n    if (STRCMP(new_dir, \"-\") == 0)\n    {\n\tpdir = get_prevdir(scope);\n\tif (pdir == NULL)\n\t{\n\t    emsg(_(e_no_previous_directory));\n\t    return FALSE;\n\t}\n\tnew_dir = pdir;\n    }\n\n    // Save current directory for next \":cd -\"\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n\tpdir = vim_strsave(NameBuff);\n    else\n\tpdir = NULL;\n\n    // For UNIX \":cd\" means: go to home directory.\n    // On other systems too if 'cdhome' is set.\n#if defined(UNIX) || defined(VMS)\n    if (*new_dir == NUL)\n#else\n    if (*new_dir == NUL && p_cdh)\n#endif\n    {\n\t// use NameBuff for home directory name\n# ifdef VMS\n\tchar_u\t*p;\n\n\tp = mch_getenv((char_u *)\"SYS$LOGIN\");\n\tif (p == NULL || *p == NUL)\t// empty is the same as not set\n\t    NameBuff[0] = NUL;\n\telse\n\t    vim_strncpy(NameBuff, p, MAXPATHL - 1);\n# else\n\texpand_env((char_u *)\"$HOME\", NameBuff, MAXPATHL);\n# endif\n\tnew_dir = NameBuff;\n    }\n    dir_differs = pdir == NULL\n\t\t\t    || pathcmp((char *)pdir, (char *)new_dir, -1) != 0;\n    if (dir_differs)\n    {\n\tif (scope == CDSCOPE_WINDOW)\n\t    acmd_fname = (char_u *)\"window\";\n\telse if (scope == CDSCOPE_TABPAGE)\n\t    acmd_fname = (char_u *)\"tabpage\";\n\telse\n\t    acmd_fname = (char_u *)\"global\";\n\ttrigger_DirChangedPre(acmd_fname, new_dir);\n\n\tif (vim_chdir(new_dir))\n\t{\n\t    emsg(_(e_command_failed));\n\t    vim_free(pdir);\n\t    return FALSE;\n\t}\n    }\n\n    if (scope == CDSCOPE_WINDOW)\n\tpp = &curwin->w_prevdir;\n    else if (scope == CDSCOPE_TABPAGE)\n\tpp = &curtab->tp_prevdir;\n    else\n\tpp = &prev_dir;\n    tofree = *pp;  // new_dir may use this\n    *pp = pdir;\n\n    post_chdir(scope);\n\n    if (dir_differs)\n\tapply_autocmds(EVENT_DIRCHANGED, acmd_fname, new_dir, FALSE, curbuf);\n    vim_free(tofree);\n    return TRUE;\n}\n\n/*\n * \":cd\", \":tcd\", \":lcd\", \":chdir\" \":tchdir\" and \":lchdir\".\n */\n    void\nex_cd(exarg_T *eap)\n{\n    char_u\t*new_dir;\n\n    new_dir = eap->arg;\n#if !defined(UNIX) && !defined(VMS)\n    // for non-UNIX \":cd\" means: print current directory unless 'cdhome' is set\n    if (*new_dir == NUL && !p_cdh)\n\tex_pwd(NULL);\n    else\n#endif\n    {\n\tcdscope_T\tscope = CDSCOPE_GLOBAL;\n\n\tif (eap->cmdidx == CMD_lcd || eap->cmdidx == CMD_lchdir)\n\t    scope = CDSCOPE_WINDOW;\n\telse if (eap->cmdidx == CMD_tcd || eap->cmdidx == CMD_tchdir)\n\t    scope = CDSCOPE_TABPAGE;\n\n\tif (changedir_func(new_dir, eap->forceit, scope))\n\t{\n\t    // Echo the new current directory if the command was typed.\n\t    if (KeyTyped || p_verbose >= 5)\n\t\tex_pwd(eap);\n\t}\n    }\n}\n\n/*\n * \":pwd\".\n */\n    static void\nex_pwd(exarg_T *eap UNUSED)\n{\n    if (mch_dirname(NameBuff, MAXPATHL) == OK)\n    {\n#ifdef BACKSLASH_IN_FILENAME\n\tslash_adjust(NameBuff);\n#endif\n\tif (p_verbose > 0)\n\t{\n\t    char *context = \"global\";\n\n\t    if (last_chdir_reason != NULL)\n\t\tcontext = last_chdir_reason;\n\t    else if (curwin->w_localdir != NULL)\n\t\tcontext = \"window\";\n\t    else if (curtab->tp_localdir != NULL)\n\t\tcontext = \"tabpage\";\n\t    smsg(\"[%s] %s\", context, (char *)NameBuff);\n\t}\n\telse\n\t    msg((char *)NameBuff);\n    }\n    else\n\temsg(_(e_directory_unknown));\n}\n\n/*\n * \":=\".\n */\n    static void\nex_equal(exarg_T *eap)\n{\n    smsg(\"%ld\", (long)eap->line2);\n    ex_may_print(eap);\n}\n\n    static void\nex_sleep(exarg_T *eap)\n{\n    int\t\tn;\n    long\tlen;\n\n    if (cursor_valid())\n    {\n\tn = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;\n\tif (n >= 0)\n\t    windgoto(n, curwin->w_wincol + curwin->w_wcol);\n    }\n\n    len = eap->line2;\n    switch (*eap->arg)\n    {\n\tcase 'm': break;\n\tcase NUL: len *= 1000L; break;\n\tdefault: semsg(_(e_invalid_argument_str), eap->arg); return;\n    }\n\n    // Hide the cursor if invoked with !\n    do_sleep(len, eap->forceit);\n}\n\n/*\n * Sleep for \"msec\" milliseconds, but keep checking for a CTRL-C every second.\n * Hide the cursor if \"hide_cursor\" is TRUE.\n */\n    void\ndo_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n\n    // Remember at what time we started, so that we know how much longer we\n    // should wait after waiting for a bit.\n    ELAPSED_INIT(start_tv);\n# endif\n\n    if (hide_cursor)\n\tcursor_sleep();\n    else\n\tcursor_on();\n\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\t// Process the netbeans and clientserver messages that may have been\n\t// received in the call to ui_breakcheck() when the GUI is in use. This\n\t// may occur when running a test case.\n\tparse_queued_messages();\n#endif\n\n# ifdef ELAPSED_FUNC\n\t// actual time passed\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\t// guestimate time passed (will actually be more)\n\tdone += wait_now;\n# endif\n    }\n\n    // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the\n    // input buffer, otherwise a following call to input() fails.\n    if (got_int)\n\t(void)vpeekc();\n\n    if (hide_cursor)\n\tcursor_unsleep();\n}\n\n/*\n * \":winsize\" command (obsolete).\n */\n    static void\nex_winsize(exarg_T *eap)\n{\n    int\t\tw, h;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (!isdigit(*arg))\n    {\n\tsemsg(_(e_invalid_argument_str), arg);\n\treturn;\n    }\n    w = getdigits(&arg);\n    arg = skipwhite(arg);\n    p = arg;\n    h = getdigits(&arg);\n    if (*p != NUL && *arg == NUL)\n\tset_shellsize(w, h, TRUE);\n    else\n\temsg(_(e_winsize_requires_two_number_arguments));\n}\n\n    static void\nex_wincmd(exarg_T *eap)\n{\n    int\t\txchar = NUL;\n    char_u\t*p;\n\n    if (*eap->arg == 'g' || *eap->arg == Ctrl_G)\n    {\n\t// CTRL-W g and CTRL-W CTRL-G  have an extra command character\n\tif (eap->arg[1] == NUL)\n\t{\n\t    emsg(_(e_invalid_argument));\n\t    return;\n\t}\n\txchar = eap->arg[1];\n\tp = eap->arg + 2;\n    }\n    else\n\tp = eap->arg + 1;\n\n    set_nextcmd(eap, p);\n    p = skipwhite(p);\n    if (*p != NUL && *p != (\n#ifdef FEAT_EVAL\n\t    in_vim9script() ? '#' :\n#endif\n\t\t'\"')\n\t    && eap->nextcmd == NULL)\n\temsg(_(e_invalid_argument));\n    else if (!eap->skip)\n    {\n\t// Pass flags on for \":vertical wincmd ]\".\n\tpostponed_split_flags = cmdmod.cmod_split;\n\tpostponed_split_tab = cmdmod.cmod_tab;\n\tdo_window(*eap->arg, eap->addr_count > 0 ? eap->line2 : 0L, xchar);\n\tpostponed_split_flags = 0;\n\tpostponed_split_tab = 0;\n    }\n}\n\n#if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)\n/*\n * \":winpos\".\n */\n    static void\nex_winpos(exarg_T *eap)\n{\n    int\t\tx, y;\n    char_u\t*arg = eap->arg;\n    char_u\t*p;\n\n    if (*arg == NUL)\n    {\n# if defined(FEAT_GUI) || defined(MSWIN)\n#  ifdef VIMDLL\n\tif (gui.in_use ? gui_mch_get_winpos(&x, &y) != FAIL :\n\t\tmch_get_winpos(&x, &y) != FAIL)\n#  elif defined(FEAT_GUI)\n\tif (gui.in_use && gui_mch_get_winpos(&x, &y) != FAIL)\n#  else\n\tif (mch_get_winpos(&x, &y) != FAIL)\n#  endif\n\t{\n\t    sprintf((char *)IObuff, _(\"Window position: X %d, Y %d\"), x, y);\n\t    msg((char *)IObuff);\n\t}\n\telse\n# endif\n\t    emsg(_(e_obtaining_window_position_not_implemented_for_this_platform));\n    }\n    else\n    {\n\tx = getdigits(&arg);\n\targ = skipwhite(arg);\n\tp = arg;\n\ty = getdigits(&arg);\n\tif (*p == NUL || *arg != NUL)\n\t{\n\t    emsg(_(e_winpos_requires_two_number_arguments));\n\t    return;\n\t}\n# ifdef FEAT_GUI\n\tif (gui.in_use)\n\t    gui_mch_set_winpos(x, y);\n\telse if (gui.starting)\n\t{\n\t    // Remember the coordinates for when the window is opened.\n\t    gui_win_x = x;\n\t    gui_win_y = y;\n\t}\n#  if defined(HAVE_TGETENT) || defined(VIMDLL)\n\telse\n#  endif\n# endif\n# if defined(MSWIN) && (!defined(FEAT_GUI) || defined(VIMDLL))\n\t    mch_set_winpos(x, y);\n# endif\n# ifdef HAVE_TGETENT\n\tif (*T_CWP)\n\t    term_set_winpos(x, y);\n# endif\n    }\n}\n#endif\n\n/*\n * Handle command that work like operators: \":delete\", \":yank\", \":>\" and \":<\".\n */\n    static void\nex_operators(exarg_T *eap)\n{\n    oparg_T\toa;\n\n    clear_oparg(&oa);\n    oa.regname = eap->regname;\n    oa.start.lnum = eap->line1;\n    oa.end.lnum = eap->line2;\n    oa.line_count = eap->line2 - eap->line1 + 1;\n    oa.motion_type = MLINE;\n    virtual_op = FALSE;\n    if (eap->cmdidx != CMD_yank)\t// position cursor for undo\n    {\n\tsetpcmark();\n\tcurwin->w_cursor.lnum = eap->line1;\n\tbeginline(BL_SOL | BL_FIX);\n    }\n\n    if (VIsual_active)\n\tend_visual_mode();\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_delete:\n\t    oa.op_type = OP_DELETE;\n\t    op_delete(&oa);\n\t    break;\n\n\tcase CMD_yank:\n\t    oa.op_type = OP_YANK;\n\t    (void)op_yank(&oa, FALSE, TRUE);\n\t    break;\n\n\tdefault:    // CMD_rshift or CMD_lshift\n\t    if (\n#ifdef FEAT_RIGHTLEFT\n\t\t(eap->cmdidx == CMD_rshift) ^ curwin->w_p_rl\n#else\n\t\teap->cmdidx == CMD_rshift\n#endif\n\t\t\t\t\t\t)\n\t\toa.op_type = OP_RSHIFT;\n\t    else\n\t\toa.op_type = OP_LSHIFT;\n\t    op_shift(&oa, FALSE, eap->amount);\n\t    break;\n    }\n    virtual_op = MAYBE;\n    ex_may_print(eap);\n}\n\n/*\n * \":put\".\n */\n    static void\nex_put(exarg_T *eap)\n{\n    // \":0put\" works like \":1put!\".\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}\n\n/*\n * Handle \":copy\" and \":move\".\n */\n    static void\nex_copymove(exarg_T *eap)\n{\n    long\tn;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    n = get_address(eap, &eap->arg, eap->addr_type, FALSE, FALSE, FALSE, 1);\n    if (eap->arg == NULL)\t    // error detected\n    {\n\teap->nextcmd = NULL;\n\treturn;\n    }\n    get_flags(eap);\n\n    /*\n     * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'\n     */\n    if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_move)\n    {\n\tif (do_move(eap->line1, eap->line2, n) == FAIL)\n\t    return;\n    }\n    else\n\tex_copy(eap->line1, eap->line2, n);\n    u_clearline();\n    beginline(BL_SOL | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * Print the current line if flags were given to the Ex command.\n */\n    void\nex_may_print(exarg_T *eap)\n{\n    if (eap->flags != 0)\n    {\n\tprint_line(curwin->w_cursor.lnum, (eap->flags & EXFLAG_NR),\n\t\t\t\t\t\t  (eap->flags & EXFLAG_LIST));\n\tex_no_reprint = TRUE;\n    }\n}\n\n/*\n * \":smagic\" and \":snomagic\".\n */\n    static void\nex_submagic(exarg_T *eap)\n{\n    optmagic_T saved = magic_overruled;\n\n    magic_overruled = eap->cmdidx == CMD_smagic\n\t\t\t\t\t  ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;\n    ex_substitute(eap);\n    magic_overruled = saved;\n}\n\n/*\n * \":join\".\n */\n    static void\nex_join(exarg_T *eap)\n{\n    curwin->w_cursor.lnum = eap->line1;\n    if (eap->line1 == eap->line2)\n    {\n\tif (eap->addr_count >= 2)   // :2,2join does nothing\n\t    return;\n\tif (eap->line2 == curbuf->b_ml.ml_line_count)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\t++eap->line2;\n    }\n    (void)do_join(eap->line2 - eap->line1 + 1, !eap->forceit, TRUE, TRUE, TRUE);\n    beginline(BL_WHITE | BL_FIX);\n    ex_may_print(eap);\n}\n\n/*\n * \":[addr]@r\" or \":[addr]*r\": execute register\n */\n    static void\nex_at(exarg_T *eap)\n{\n    int\t\tc;\n    int\t\tprev_len = typebuf.tb_len;\n\n    curwin->w_cursor.lnum = eap->line2;\n    check_cursor_col();\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // get the register name.  No name means to use the previous one\n    c = *eap->arg;\n    if (c == NUL || (c == '*' && *eap->cmd == '*'))\n\tc = '@';\n    // Put the register in the typeahead buffer with the \"silent\" flag.\n    if (do_execreg(c, TRUE, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, TRUE)\n\t\t\t\t\t\t\t\t      == FAIL)\n    {\n\tbeep_flush();\n    }\n    else\n    {\n\tint\tsave_efr = exec_from_reg;\n\n\texec_from_reg = TRUE;\n\n\t/*\n\t * Execute from the typeahead buffer.\n\t * Continue until the stuff buffer is empty and all added characters\n\t * have been consumed.\n\t */\n\twhile (!stuff_empty() || typebuf.tb_len > prev_len)\n\t    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\n\texec_from_reg = save_efr;\n    }\n}\n\n/*\n * \":!\".\n */\n    static void\nex_bang(exarg_T *eap)\n{\n    do_bang(eap->addr_count, eap, eap->forceit, TRUE, TRUE);\n}\n\n/*\n * \":undo\".\n */\n    static void\nex_undo(exarg_T *eap)\n{\n    if (eap->addr_count == 1)\t    // :undo 123\n\tundo_time(eap->line2, FALSE, FALSE, TRUE);\n    else\n\tu_undo(1);\n}\n\n#ifdef FEAT_PERSISTENT_UNDO\n    static void\nex_wundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_write_undo(eap->arg, eap->forceit, curbuf, hash);\n}\n\n    static void\nex_rundo(exarg_T *eap)\n{\n    char_u hash[UNDO_HASH_SIZE];\n\n    u_compute_hash(hash);\n    u_read_undo(eap->arg, hash, NULL);\n}\n#endif\n\n/*\n * \":redo\".\n */\n    static void\nex_redo(exarg_T *eap UNUSED)\n{\n    u_redo(1);\n}\n\n/*\n * \":earlier\" and \":later\".\n */\n    static void\nex_later(exarg_T *eap)\n{\n    long\tcount = 0;\n    int\t\tsec = FALSE;\n    int\t\tfile = FALSE;\n    char_u\t*p = eap->arg;\n\n    if (*p == NUL)\n\tcount = 1;\n    else if (isdigit(*p))\n    {\n\tcount = getdigits(&p);\n\tswitch (*p)\n\t{\n\t    case 's': ++p; sec = TRUE; break;\n\t    case 'm': ++p; sec = TRUE; count *= 60; break;\n\t    case 'h': ++p; sec = TRUE; count *= 60 * 60; break;\n\t    case 'd': ++p; sec = TRUE; count *= 24 * 60 * 60; break;\n\t    case 'f': ++p; file = TRUE; break;\n\t}\n    }\n\n    if (*p != NUL)\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n    else\n\tundo_time(eap->cmdidx == CMD_earlier ? -count : count,\n\t\t\t\t\t\t\t    sec, file, FALSE);\n}\n\n/*\n * \":redir\": start/stop redirection.\n */\n    static void\nex_redir(exarg_T *eap)\n{\n    char\t*mode;\n    char_u\t*fname;\n    char_u\t*arg = eap->arg;\n\n#ifdef FEAT_EVAL\n    if (redir_execute)\n    {\n\temsg(_(e_cannot_use_redir_inside_execute));\n\treturn;\n    }\n#endif\n\n    if (STRICMP(eap->arg, \"END\") == 0)\n\tclose_redir();\n    else\n    {\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tmode = \"a\";\n\t    }\n\t    else\n\t\tmode = \"w\";\n\t    arg = skipwhite(arg);\n\n\t    close_redir();\n\n\t    // Expand environment variables and \"~/\".\n\t    fname = expand_env_save(arg);\n\t    if (fname == NULL)\n\t\treturn;\n#ifdef FEAT_BROWSE\n\t    if (cmdmod.cmod_flags & CMOD_BROWSE)\n\t    {\n\t\tchar_u\t*browseFile;\n\n\t\tbrowseFile = do_browse(BROWSE_SAVE,\n\t\t\t(char_u *)_(\"Save Redirection\"),\n\t\t\tfname, NULL, NULL,\n\t\t\t(char_u *)_(BROWSE_FILTER_ALL_FILES), curbuf);\n\t\tif (browseFile == NULL)\n\t\t    return;\t\t// operation cancelled\n\t\tvim_free(fname);\n\t\tfname = browseFile;\n\t\teap->forceit = TRUE;\t// since dialog already asked\n\t    }\n#endif\n\n\t    redir_fd = open_exfile(fname, eap->forceit, mode);\n\t    vim_free(fname);\n\t}\n#ifdef FEAT_EVAL\n\telse if (*arg == '@')\n\t{\n\t    // redirect to a register a-z (resp. A-Z for appending)\n\t    close_redir();\n\t    ++arg;\n\t    if (ASCII_ISALPHA(*arg)\n# ifdef FEAT_CLIPBOARD\n\t\t    || *arg == '*'\n\t\t    || *arg == '+'\n# endif\n\t\t    || *arg == '\"')\n\t    {\n\t\tredir_reg = *arg++;\n\t\tif (*arg == '>' && arg[1] == '>')  // append\n\t\t    arg += 2;\n\t\telse\n\t\t{\n\t\t    // Can use both \"@a\" and \"@a>\".\n\t\t    if (*arg == '>')\n\t\t\targ++;\n\t\t    // Make register empty when not using @A-@Z and the\n\t\t    // command is valid.\n\t\t    if (*arg == NUL && !isupper(redir_reg))\n\t\t\twrite_reg_contents(redir_reg, (char_u *)\"\", -1, FALSE);\n\t\t}\n\t    }\n\t    if (*arg != NUL)\n\t    {\n\t\tredir_reg = 0;\n\t\tsemsg(_(e_invalid_argument_str), eap->arg);\n\t    }\n\t}\n\telse if (*arg == '=' && arg[1] == '>')\n\t{\n\t    int append;\n\n\t    // redirect to a variable\n\t    close_redir();\n\t    arg += 2;\n\n\t    if (*arg == '>')\n\t    {\n\t\t++arg;\n\t\tappend = TRUE;\n\t    }\n\t    else\n\t\tappend = FALSE;\n\n\t    if (var_redir_start(skipwhite(arg), append) == OK)\n\t\tredir_vname = 1;\n\t}\n#endif\n\n\t// TODO: redirect to a buffer\n\n\telse\n\t    semsg(_(e_invalid_argument_str), eap->arg);\n    }\n\n    // Make sure redirection is not off.  Can happen for cmdline completion\n    // that indirectly invokes a command to catch its output.\n    if (redir_fd != NULL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname\n#endif\n\t\t\t\t\t\t\t)\n\tredir_off = FALSE;\n}\n\n/*\n * \":redraw\": force redraw\n */\n    void\nex_redraw(exarg_T *eap)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    validate_cursor();\n    update_topline();\n    update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);\n    if (need_maketitle)\n\tmaketitle();\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = r;\n    p_lz = p;\n\n    // After drawing the statusline screen_attr may still be set.\n    screen_stop_highlight();\n\n    // Reset msg_didout, so that a message that's there is overwritten.\n    msg_didout = FALSE;\n    msg_col = 0;\n\n    // No need to wait after an intentional redraw.\n    need_wait_return = FALSE;\n\n    // When invoked from a callback or autocmd the command line may be active.\n    if (State & MODE_CMDLINE)\n\tredrawcmdline();\n\n    out_flush();\n}\n\n/*\n * \":redrawstatus\": force redraw of status line(s)\n */\n    static void\nex_redrawstatus(exarg_T *eap UNUSED)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    if (eap->forceit)\n\tstatus_redraw_all();\n    else\n\tstatus_redraw_curbuf();\n    update_screen(VIsual_active ? INVERTED : 0);\n    RedrawingDisabled = r;\n    p_lz = p;\n    out_flush();\n}\n\n/*\n * \":redrawtabline\": force redraw of the tabline\n */\n    static void\nex_redrawtabline(exarg_T *eap UNUSED)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n\n    draw_tabline();\n\n    RedrawingDisabled = r;\n    p_lz = p;\n    out_flush();\n}\n\n    static void\nclose_redir(void)\n{\n    if (redir_fd != NULL)\n    {\n\tfclose(redir_fd);\n\tredir_fd = NULL;\n    }\n#ifdef FEAT_EVAL\n    redir_reg = 0;\n    if (redir_vname)\n    {\n\tvar_redir_stop();\n\tredir_vname = 0;\n    }\n#endif\n}\n\n#if (defined(FEAT_SESSION) || defined(FEAT_EVAL)) || defined(PROTO)\n    int\nvim_mkdir_emsg(char_u *name, int prot UNUSED)\n{\n    if (vim_mkdir(name, prot) != 0)\n    {\n\tsemsg(_(e_cannot_create_directory_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n#endif\n\n/*\n * Open a file for writing for an Ex command, with some checks.\n * Return file descriptor, or NULL on failure.\n */\n    FILE *\nopen_exfile(\n    char_u\t*fname,\n    int\t\tforceit,\n    char\t*mode)\t    // \"w\" for create new file or \"a\" for append\n{\n    FILE\t*fd;\n\n#ifdef UNIX\n    // with Unix it is possible to open a directory\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_str_is_directory), fname);\n\treturn NULL;\n    }\n#endif\n    if (!forceit && *mode != 'a' && vim_fexists(fname))\n    {\n\tsemsg(_(e_str_exists_add_bang_to_override), fname);\n\treturn NULL;\n    }\n\n    if ((fd = mch_fopen((char *)fname, mode)) == NULL)\n\tsemsg(_(e_cannot_open_str_for_writing_2), fname);\n\n    return fd;\n}\n\n/*\n * \":mark\" and \":k\".\n */\n    static void\nex_mark(exarg_T *eap)\n{\n    pos_T\tpos;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    if (*eap->arg == NUL)\t\t// No argument?\n\temsg(_(e_argument_required));\n    else if (eap->arg[1] != NUL)\t// more than one character?\n\tsemsg(_(e_trailing_characters_str), eap->arg);\n    else\n    {\n\tpos = curwin->w_cursor;\t\t// save curwin->w_cursor\n\tcurwin->w_cursor.lnum = eap->line2;\n\tbeginline(BL_WHITE | BL_FIX);\n\tif (setmark(*eap->arg) == FAIL)\t// set mark\n\t    emsg(_(e_argument_must_be_letter_or_forward_backward_quote));\n\tcurwin->w_cursor = pos;\t\t// restore curwin->w_cursor\n    }\n}\n\n/*\n * Update w_topline, w_leftcol and the cursor position.\n */\n    void\nupdate_topline_cursor(void)\n{\n    check_cursor();\t\t// put cursor on valid line\n    update_topline();\n    if (!curwin->w_p_wrap)\n\tvalidate_cursor();\n    update_curswant();\n}\n\n/*\n * Save the current State and go to Normal mode.\n * Return TRUE if the typeahead could be saved.\n */\n    int\nsave_current_state(save_state_T *sst)\n{\n    sst->save_msg_scroll = msg_scroll;\n    sst->save_restart_edit = restart_edit;\n    sst->save_msg_didout = msg_didout;\n    sst->save_State = State;\n    sst->save_insertmode = p_im;\n    sst->save_finish_op = finish_op;\n    sst->save_opcount = opcount;\n    sst->save_reg_executing = reg_executing;\n    sst->save_pending_end_reg_executing = pending_end_reg_executing;\n\n    msg_scroll = FALSE;\t\t    // no msg scrolling in Normal mode\n    restart_edit = 0;\t\t    // don't go to Insert mode\n    p_im = FALSE;\t\t    // don't use 'insertmode'\n\n    sst->save_script_version = current_sctx.sc_version;\n    current_sctx.sc_version = 1;    // not in Vim9 script\n\n    /*\n     * Save the current typeahead.  This is required to allow using \":normal\"\n     * from an event handler and makes sure we don't hang when the argument\n     * ends with half a command.\n     */\n    save_typeahead(&sst->tabuf);\n    return sst->tabuf.typebuf_valid;\n}\n\n    void\nrestore_current_state(save_state_T *sst)\n{\n    // Restore the previous typeahead.\n    restore_typeahead(&sst->tabuf, FALSE);\n\n    msg_scroll = sst->save_msg_scroll;\n    restart_edit = sst->save_restart_edit;\n    p_im = sst->save_insertmode;\n    finish_op = sst->save_finish_op;\n    opcount = sst->save_opcount;\n    reg_executing = sst->save_reg_executing;\n    pending_end_reg_executing = sst->save_pending_end_reg_executing;\n    msg_didout |= sst->save_msg_didout;\t// don't reset msg_didout now\n    current_sctx.sc_version = sst->save_script_version;\n\n    // Restore the state (needed when called from a function executed for\n    // 'indentexpr'). Update the mouse and cursor, they may have changed.\n    State = sst->save_State;\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * \":normal[!] {commands}\": Execute normal mode commands.\n */\n    void\nex_normal(exarg_T *eap)\n{\n    save_state_T save_state;\n    char_u\t*arg = NULL;\n    int\t\tl;\n    char_u\t*p;\n\n    if (ex_normal_lock > 0)\n    {\n\temsg(_(e_not_allowed_here));\n\treturn;\n    }\n    if (ex_normal_busy >= p_mmd)\n    {\n\temsg(_(e_recursive_use_of_normal_too_deep));\n\treturn;\n    }\n\n    /*\n     * vgetc() expects a CSI and K_SPECIAL to have been escaped.  Don't do\n     * this for the K_SPECIAL leading byte, otherwise special keys will not\n     * work.\n     */\n    if (has_mbyte)\n    {\n\tint\tlen = 0;\n\n\t// Count the number of characters to be escaped.\n\tfor (p = eap->arg; *p != NUL; ++p)\n\t{\n#ifdef FEAT_GUI\n\t    if (*p == CSI)  // leadbyte CSI\n\t\tlen += 2;\n#endif\n\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\tif (*++p == K_SPECIAL\t  // trailbyte K_SPECIAL or CSI\n#ifdef FEAT_GUI\n\t\t\t|| *p == CSI\n#endif\n\t\t\t)\n\t\t    len += 2;\n\t}\n\tif (len > 0)\n\t{\n\t    arg = alloc(STRLEN(eap->arg) + len + 1);\n\t    if (arg != NULL)\n\t    {\n\t\tlen = 0;\n\t\tfor (p = eap->arg; *p != NUL; ++p)\n\t\t{\n\t\t    arg[len++] = *p;\n#ifdef FEAT_GUI\n\t\t    if (*p == CSI)\n\t\t    {\n\t\t\targ[len++] = KS_EXTRA;\n\t\t\targ[len++] = (int)KE_CSI;\n\t\t    }\n#endif\n\t\t    for (l = (*mb_ptr2len)(p) - 1; l > 0; --l)\n\t\t    {\n\t\t\targ[len++] = *++p;\n\t\t\tif (*p == K_SPECIAL)\n\t\t\t{\n\t\t\t    arg[len++] = KS_SPECIAL;\n\t\t\t    arg[len++] = KE_FILLER;\n\t\t\t}\n#ifdef FEAT_GUI\n\t\t\telse if (*p == CSI)\n\t\t\t{\n\t\t\t    arg[len++] = KS_EXTRA;\n\t\t\t    arg[len++] = (int)KE_CSI;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    arg[len] = NUL;\n\t\t}\n\t    }\n\t}\n    }\n\n    ++ex_normal_busy;\n    if (save_current_state(&save_state))\n    {\n\t/*\n\t * Repeat the :normal command for each line in the range.  When no\n\t * range given, execute it just once, without positioning the cursor\n\t * first.\n\t */\n\tdo\n\t{\n\t    if (eap->addr_count != 0)\n\t    {\n\t\tcurwin->w_cursor.lnum = eap->line1++;\n\t\tcurwin->w_cursor.col = 0;\n\t\tcheck_cursor_moved(curwin);\n\t    }\n\n\t    exec_normal_cmd(arg != NULL\n\t\t     ? arg\n\t\t     : eap->arg, eap->forceit ? REMAP_NONE : REMAP_YES, FALSE);\n\t}\n\twhile (eap->addr_count > 0 && eap->line1 <= eap->line2 && !got_int);\n    }\n\n    // Might not return to the main loop when in an event handler.\n    update_topline_cursor();\n\n    restore_current_state(&save_state);\n    --ex_normal_busy;\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    vim_free(arg);\n}\n\n/*\n * \":startinsert\", \":startreplace\" and \":startgreplace\"\n */\n    static void\nex_startinsert(exarg_T *eap)\n{\n    if (eap->forceit)\n    {\n\t// cursor line can be zero on startup\n\tif (!curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\tset_cursor_for_append_to_line();\n    }\n#ifdef FEAT_TERMINAL\n    // Ignore this when running in an active terminal.\n    if (term_job_running(curbuf->b_term))\n\treturn;\n#endif\n\n    // Ignore the command when already in Insert mode.  Inserting an\n    // expression register that invokes a function can do this.\n    if (State & MODE_INSERT)\n\treturn;\n\n    if (eap->cmdidx == CMD_startinsert)\n\trestart_edit = 'a';\n    else if (eap->cmdidx == CMD_startreplace)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'V';\n\n    if (!eap->forceit)\n    {\n\tif (eap->cmdidx == CMD_startinsert)\n\t    restart_edit = 'i';\n\tcurwin->w_curswant = 0;\t    // avoid MAXCOL\n    }\n\n    if (VIsual_active)\n\tshowmode();\n}\n\n/*\n * \":stopinsert\"\n */\n    static void\nex_stopinsert(exarg_T *eap UNUSED)\n{\n    restart_edit = 0;\n    stop_insert_mode = TRUE;\n    clearmode();\n}\n\n/*\n * Execute normal mode command \"cmd\".\n * \"remap\" can be REMAP_NONE or REMAP_YES.\n */\n    void\nexec_normal_cmd(char_u *cmd, int remap, int silent)\n{\n    // Stuff the argument into the typeahead buffer.\n    ins_typebuf(cmd, remap, 0, TRUE, silent);\n    exec_normal(FALSE, FALSE, FALSE);\n}\n\n/*\n * Execute normal_cmd() until there is no typeahead left.\n * When \"use_vpeekc\" is TRUE use vpeekc() to check for available chars.\n */\n    void\nexec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop UNUSED)\n{\n    oparg_T\toa;\n    int\t\tc;\n\n    // When calling vpeekc() from feedkeys() it will return Ctrl_C when there\n    // is nothing to get, so also check for Ctrl_C.\n    clear_oparg(&oa);\n    finish_op = FALSE;\n    while ((!stuff_empty()\n\t\t|| ((was_typed || !typebuf_typed()) && typebuf.tb_len > 0)\n\t\t|| (use_vpeekc && (c = vpeekc()) != NUL && c != Ctrl_C))\n\t    && !got_int)\n    {\n\tupdate_topline_cursor();\n#ifdef FEAT_TERMINAL\n\tif (may_use_terminal_loop && term_use_loop()\n\t\t&& oa.op_type == OP_NOP && oa.regname == NUL\n\t\t&& !VIsual_active)\n\t{\n\t    // If terminal_loop() returns OK we got a key that is handled\n\t    // in Normal model.  With FAIL we first need to position the\n\t    // cursor and the screen needs to be redrawn.\n\t    if (terminal_loop(TRUE) == OK)\n\t\tnormal_cmd(&oa, TRUE);\n\t}\n\telse\n#endif\n\t    // execute a Normal mode cmd\n\t    normal_cmd(&oa, TRUE);\n    }\n}\n\n#ifdef FEAT_FIND_ID\n    static void\nex_checkpath(exarg_T *eap)\n{\n    find_pattern_in_path(NULL, 0, 0, FALSE, FALSE, CHECK_PATH, 1L,\n\t\t\t\t   eap->forceit ? ACTION_SHOW_ALL : ACTION_SHOW,\n\t\t\t\t\t      (linenr_T)1, (linenr_T)MAXLNUM);\n}\n\n#if defined(FEAT_QUICKFIX)\n/*\n * \":psearch\"\n */\n    static void\nex_psearch(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;\n    ex_findpat(eap);\n    g_do_tagpreview = 0;\n}\n#endif\n\n    static void\nex_findpat(exarg_T *eap)\n{\n    int\t\twhole = TRUE;\n    long\tn;\n    char_u\t*p;\n    int\t\taction;\n\n    switch (cmdnames[eap->cmdidx].cmd_name[2])\n    {\n\tcase 'e':\t// \":psearch\", \":isearch\" and \":dsearch\"\n\t\tif (cmdnames[eap->cmdidx].cmd_name[0] == 'p')\n\t\t    action = ACTION_GOTO;\n\t\telse\n\t\t    action = ACTION_SHOW;\n\t\tbreak;\n\tcase 'i':\t// \":ilist\" and \":dlist\"\n\t\taction = ACTION_SHOW_ALL;\n\t\tbreak;\n\tcase 'u':\t// \":ijump\" and \":djump\"\n\t\taction = ACTION_GOTO;\n\t\tbreak;\n\tdefault:\t// \":isplit\" and \":dsplit\"\n\t\taction = ACTION_SPLIT;\n\t\tbreak;\n    }\n\n    n = 1;\n    if (vim_isdigit(*eap->arg))\t// get count\n    {\n\tn = getdigits(&eap->arg);\n\teap->arg = skipwhite(eap->arg);\n    }\n    if (*eap->arg == '/')   // Match regexp, not just whole words\n    {\n\twhole = FALSE;\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\tif (*p)\n\t{\n\t    *p++ = NUL;\n\t    p = skipwhite(p);\n\n\t    // Check for trailing illegal characters\n\t    if (!ends_excmd2(eap->arg, p))\n\t\teap->errmsg = ex_errmsg(e_trailing_characters_str, p);\n\t    else\n\t\tset_nextcmd(eap, p);\n\t}\n    }\n    if (!eap->skip)\n\tfind_pattern_in_path(eap->arg, 0, (int)STRLEN(eap->arg),\n\t\t\t    whole, !eap->forceit,\n\t\t\t    *eap->cmd == 'd' ?\tFIND_DEFINE : FIND_ANY,\n\t\t\t    n, action, eap->line1, eap->line2);\n}\n#endif\n\n\n#ifdef FEAT_QUICKFIX\n/*\n * \":ptag\", \":ptselect\", \":ptjump\", \":ptnext\", etc.\n */\n    static void\nex_ptag(exarg_T *eap)\n{\n    g_do_tagpreview = p_pvh;  // will be reset to 0 in ex_tag_cmd()\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n}\n\n/*\n * \":pedit\"\n */\n    static void\nex_pedit(exarg_T *eap)\n{\n    win_T\t*curwin_save = curwin;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n    // Open the preview window or popup and make it the current window.\n    g_do_tagpreview = p_pvh;\n    prepare_tagpreview(TRUE, TRUE, FALSE);\n\n    // Edit the file.\n    do_exedit(eap, NULL);\n\n    if (curwin != curwin_save && win_valid(curwin_save))\n    {\n\t// Return cursor to where we were\n\tvalidate_cursor();\n\tredraw_later(VALID);\n\twin_enter(curwin_save, TRUE);\n    }\n# ifdef FEAT_PROP_POPUP\n    else if (WIN_IS_POPUP(curwin))\n    {\n\t// can't keep focus in popup window\n\twin_enter(firstwin, TRUE);\n    }\n# endif\n    g_do_tagpreview = 0;\n}\n#endif\n\n/*\n * \":stag\", \":stselect\" and \":stjump\".\n */\n    static void\nex_stag(exarg_T *eap)\n{\n    postponed_split = -1;\n    postponed_split_flags = cmdmod.cmod_split;\n    postponed_split_tab = cmdmod.cmod_tab;\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);\n    postponed_split_flags = 0;\n    postponed_split_tab = 0;\n}\n\n/*\n * \":tag\", \":tselect\", \":tjump\", \":tnext\", etc.\n */\n    static void\nex_tag(exarg_T *eap)\n{\n    ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name);\n}\n\n    static void\nex_tag_cmd(exarg_T *eap, char_u *name)\n{\n    int\t\tcmd;\n\n    switch (name[1])\n    {\n\tcase 'j': cmd = DT_JUMP;\t// \":tjump\"\n\t\t  break;\n\tcase 's': cmd = DT_SELECT;\t// \":tselect\"\n\t\t  break;\n\tcase 'p': cmd = DT_PREV;\t// \":tprevious\"\n\t\t  break;\n\tcase 'N': cmd = DT_PREV;\t// \":tNext\"\n\t\t  break;\n\tcase 'n': cmd = DT_NEXT;\t// \":tnext\"\n\t\t  break;\n\tcase 'o': cmd = DT_POP;\t\t// \":pop\"\n\t\t  break;\n\tcase 'f':\t\t\t// \":tfirst\"\n\tcase 'r': cmd = DT_FIRST;\t// \":trewind\"\n\t\t  break;\n\tcase 'l': cmd = DT_LAST;\t// \":tlast\"\n\t\t  break;\n\tdefault:\t\t\t// \":tag\"\n#ifdef FEAT_CSCOPE\n\t\t  if (p_cst && *eap->arg != NUL)\n\t\t  {\n\t\t      ex_cstag(eap);\n\t\t      return;\n\t\t  }\n#endif\n\t\t  cmd = DT_TAG;\n\t\t  break;\n    }\n\n    if (name[0] == 'l')\n    {\n#ifndef FEAT_QUICKFIX\n\tex_ni(eap);\n\treturn;\n#else\n\tcmd = DT_LTAG;\n#endif\n    }\n\n    do_tag(eap->arg, cmd, eap->addr_count > 0 ? (int)eap->line2 : 1,\n\t\t\t\t\t\t\t  eap->forceit, TRUE);\n}\n\n/*\n * Check \"str\" for starting with a special cmdline variable.\n * If found return one of the SPEC_ values and set \"*usedlen\" to the length of\n * the variable.  Otherwise return -1 and \"*usedlen\" is unchanged.\n */\n    int\nfind_cmdline_var(char_u *src, int *usedlen)\n{\n    int\t\tlen;\n    int\t\ti;\n    static char *(spec_str[]) = {\n\t\t    \"%\",\n#define SPEC_PERC   0\n\t\t    \"#\",\n#define SPEC_HASH   (SPEC_PERC + 1)\n\t\t    \"<cword>\",\t\t// cursor word\n#define SPEC_CWORD  (SPEC_HASH + 1)\n\t\t    \"<cWORD>\",\t\t// cursor WORD\n#define SPEC_CCWORD (SPEC_CWORD + 1)\n\t\t    \"<cexpr>\",\t\t// expr under cursor\n#define SPEC_CEXPR  (SPEC_CCWORD + 1)\n\t\t    \"<cfile>\",\t\t// cursor path name\n#define SPEC_CFILE  (SPEC_CEXPR + 1)\n\t\t    \"<sfile>\",\t\t// \":so\" file name\n#define SPEC_SFILE  (SPEC_CFILE + 1)\n\t\t    \"<slnum>\",\t\t// \":so\" file line number\n#define SPEC_SLNUM  (SPEC_SFILE + 1)\n\t\t    \"<stack>\",\t\t// call stack\n#define SPEC_STACK  (SPEC_SLNUM + 1)\n\t\t    \"<script>\",\t\t// script file name\n#define SPEC_SCRIPT (SPEC_STACK + 1)\n\t\t    \"<afile>\",\t\t// autocommand file name\n#define SPEC_AFILE  (SPEC_SCRIPT + 1)\n\t\t    \"<abuf>\",\t\t// autocommand buffer number\n#define SPEC_ABUF   (SPEC_AFILE + 1)\n\t\t    \"<amatch>\",\t\t// autocommand match name\n#define SPEC_AMATCH (SPEC_ABUF + 1)\n\t\t    \"<sflnum>\",\t\t// script file line number\n#define SPEC_SFLNUM  (SPEC_AMATCH + 1)\n\t\t    \"<SID>\",\t\t// script ID: <SNR>123_\n#define SPEC_SID  (SPEC_SFLNUM + 1)\n#ifdef FEAT_CLIENTSERVER\n\t\t    \"<client>\"\n# define SPEC_CLIENT (SPEC_SID + 1)\n#endif\n    };\n\n    for (i = 0; i < (int)ARRAY_LENGTH(spec_str); ++i)\n    {\n\tlen = (int)STRLEN(spec_str[i]);\n\tif (STRNCMP(src, spec_str[i], len) == 0)\n\t{\n\t    *usedlen = len;\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Evaluate cmdline variables.\n *\n * change \"%\"\t    to curbuf->b_ffname\n *\t  \"#\"\t    to curwin->w_alt_fnum\n *\t  \"%%\"\t    to curwin->w_alt_fnum in Vim9 script\n *\t  \"<cword>\" to word under the cursor\n *\t  \"<cWORD>\" to WORD under the cursor\n *\t  \"<cexpr>\" to C-expression under the cursor\n *\t  \"<cfile>\" to path name under the cursor\n *\t  \"<sfile>\" to sourced file name\n *\t  \"<stack>\" to call stack\n *\t  \"<script>\" to current script name\n *\t  \"<slnum>\" to sourced file line number\n *\t  \"<afile>\" to file name for autocommand\n *\t  \"<abuf>\"  to buffer number for autocommand\n *\t  \"<amatch>\" to matching name for autocommand\n *\n * When an error is detected, \"errormsg\" is set to a non-NULL pointer (may be\n * \"\" for error without a message) and NULL is returned.\n * Returns an allocated string if a valid match was found.\n * Returns NULL if no match was found.\t\"usedlen\" then still contains the\n * number of characters to skip.\n */\n    char_u *\neval_vars(\n    char_u\t*src,\t\t// pointer into commandline\n    char_u\t*srcstart,\t// beginning of valid memory for src\n    int\t\t*usedlen,\t// characters after src that are used\n    linenr_T\t*lnump,\t\t// line number for :e command, or NULL\n    char\t**errormsg,\t// pointer to error message\n    int\t\t*escaped,\t// return value has escaped white space (can\n\t\t\t\t// be NULL)\n    int\t\tempty_is_error)\t// empty result is considered an error\n{\n    int\t\ti;\n    char_u\t*s;\n    char_u\t*result;\n    char_u\t*resultbuf = NULL;\n    int\t\tresultlen;\n    buf_T\t*buf;\n    int\t\tvalid = VALID_HEAD + VALID_PATH;    // assume valid result\n    int\t\tspec_idx;\n    int\t\ttilde_file = FALSE;\n    int\t\tskip_mod = FALSE;\n    char_u\tstrbuf[30];\n\n    *errormsg = NULL;\n    if (escaped != NULL)\n\t*escaped = FALSE;\n\n    /*\n     * Check if there is something to do.\n     */\n    spec_idx = find_cmdline_var(src, usedlen);\n    if (spec_idx < 0)\t// no match\n    {\n\t*usedlen = 1;\n\treturn NULL;\n    }\n\n    /*\n     * Skip when preceded with a backslash \"\\%\" and \"\\#\".\n     * Note: In \"\\\\%\" the % is also not recognized!\n     */\n    if (src > srcstart && src[-1] == '\\\\')\n    {\n\t*usedlen = 0;\n\tSTRMOVE(src - 1, src);\t// remove backslash\n\treturn NULL;\n    }\n\n    /*\n     * word or WORD under cursor\n     */\n    if (spec_idx == SPEC_CWORD || spec_idx == SPEC_CCWORD\n\t\t\t\t\t\t     || spec_idx == SPEC_CEXPR)\n    {\n\tresultlen = find_ident_under_cursor(&result,\n\t\tspec_idx == SPEC_CWORD ? (FIND_IDENT | FIND_STRING)\n\t      : spec_idx == SPEC_CEXPR ? (FIND_IDENT | FIND_STRING | FIND_EVAL)\n\t      : FIND_STRING);\n\tif (resultlen == 0)\n\t{\n\t    *errormsg = \"\";\n\t    return NULL;\n\t}\n    }\n\n    /*\n     * '#': Alternate file name\n     * '%': Current file name\n     *\t    File name under the cursor\n     *\t    File name for autocommand\n     *\tand following modifiers\n     */\n    else\n    {\n\tint off = 0;\n\n\tswitch (spec_idx)\n\t{\n\tcase SPEC_PERC:\n#ifdef FEAT_EVAL\n\t\tif (!in_vim9script() || src[1] != '%')\n#endif\n\t\t{\n\t\t    // '%': current file\n\t\t    if (curbuf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = curbuf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t    break;\n\t\t}\n#ifdef FEAT_EVAL\n\t\t// \"%%\" alternate file\n\t\toff = 1;\n#endif\n\t\t// FALLTHROUGH\n\tcase SPEC_HASH:\t\t// '#' or \"#99\": alternate file\n\t\tif (off == 0 ? src[1] == '#' : src[2] == '%')\n\t\t{\n\t\t    // \"##\" or \"%%%\": the argument list\n\t\t    result = arg_all();\n\t\t    resultbuf = result;\n\t\t    *usedlen = off + 2;\n\t\t    if (escaped != NULL)\n\t\t\t*escaped = TRUE;\n\t\t    skip_mod = TRUE;\n\t\t    break;\n\t\t}\n\t\ts = src + off + 1;\n\t\tif (*s == '<')\t\t// \"#<99\" uses v:oldfiles\n\t\t    ++s;\n\t\ti = (int)getdigits(&s);\n\t\tif (s == src + off + 2 && src[off + 1] == '-')\n\t\t    // just a minus sign, don't skip over it\n\t\t    s--;\n\t\t*usedlen = (int)(s - src); // length of what we expand\n\n\t\tif (src[off + 1] == '<' && i != 0)\n\t\t{\n\t\t    if (*usedlen < off + 2)\n\t\t    {\n\t\t\t// Should we give an error message for #<text?\n\t\t\t*usedlen = off + 1;\n\t\t\treturn NULL;\n\t\t    }\n#ifdef FEAT_EVAL\n\t\t    result = list_find_str(get_vim_var_list(VV_OLDFILES),\n\t\t\t\t\t\t\t\t     (long)i);\n\t\t    if (result == NULL)\n\t\t    {\n\t\t\t*errormsg = \"\";\n\t\t\treturn NULL;\n\t\t    }\n#else\n\t\t    *errormsg = _(e_hashsmall_is_not_available_without_the_eval_feature);\n\t\t    return NULL;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (i == 0 && src[off + 1] == '<' && *usedlen > off + 1)\n\t\t\t*usedlen = off + 1;\n\t\t    buf = buflist_findnr(i);\n\t\t    if (buf == NULL)\n\t\t    {\n\t\t\t*errormsg = _(e_no_alternate_file_name_to_substitute_for_hash);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (lnump != NULL)\n\t\t\t*lnump = ECMD_LAST;\n\t\t    if (buf->b_fname == NULL)\n\t\t    {\n\t\t\tresult = (char_u *)\"\";\n\t\t\tvalid = 0;\t    // Must have \":p:h\" to be valid\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = buf->b_fname;\n\t\t\ttilde_file = STRCMP(result, \"~\") == 0;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\tcase SPEC_CFILE:\t// file name under cursor\n\t\tresult = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = \"\";\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n#endif\n\n\tcase SPEC_AFILE:\t// file name for autocommand\n\t\tresult = autocmd_fname;\n\t\tif (result != NULL && !autocmd_fname_full)\n\t\t{\n\t\t    // Still need to turn the fname into a full path.  It is\n\t\t    // postponed to avoid a delay when <afile> is not used.\n\t\t    autocmd_fname_full = TRUE;\n\t\t    result = FullName_save(autocmd_fname, FALSE);\n\t\t    vim_free(autocmd_fname);\n\t\t    autocmd_fname = result;\n\t\t}\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_file_name_to_substitute_for_afile);\n\t\t    return NULL;\n\t\t}\n\t\tresult = shorten_fname1(result);\n\t\tbreak;\n\n\tcase SPEC_ABUF:\t\t// buffer number for autocommand\n\t\tif (autocmd_bufnr <= 0)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_buffer_name_to_substitute_for_abuf);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%d\", autocmd_bufnr);\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_AMATCH:\t// match name for autocommand\n\t\tresult = autocmd_match;\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_autocommand_match_name_to_substitute_for_amatch);\n\t\t    return NULL;\n\t\t}\n\t\tbreak;\n\n\tcase SPEC_SFILE:\t// file name for \":so\" command\n\t\tresult = estack_sfile(ESTACK_SFILE);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_source_file_name_to_substitute_for_sfile);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\tcase SPEC_STACK:\t// call stack\n\t\tresult = estack_sfile(ESTACK_STACK);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_call_stack_to_substitute_for_stack);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\tcase SPEC_SCRIPT:\t// script file name\n\t\tresult = estack_sfile(ESTACK_SCRIPT);\n\t\tif (result == NULL)\n\t\t{\n\t\t    *errormsg = _(e_no_script_file_name_to_substitute_for_script);\n\t\t    return NULL;\n\t\t}\n\t\tresultbuf = result;\t    // remember allocated string\n\t\tbreak;\n\n\tcase SPEC_SLNUM:\t// line in file for \":so\" command\n\t\tif (SOURCING_NAME == NULL || SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(e_no_line_number_to_use_for_slnum);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\", SOURCING_LNUM);\n\t\tresult = strbuf;\n\t\tbreak;\n\n#ifdef FEAT_EVAL\n\tcase SPEC_SFLNUM:\t// line in script file\n\t\tif (current_sctx.sc_lnum + SOURCING_LNUM == 0)\n\t\t{\n\t\t    *errormsg = _(e_no_line_number_to_use_for_sflnum);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"%ld\",\n\t\t\t\t (long)(current_sctx.sc_lnum + SOURCING_LNUM));\n\t\tresult = strbuf;\n\t\tbreak;\n\n\tcase SPEC_SID:\n\t\tif (current_sctx.sc_sid <= 0)\n\t\t{\n\t\t    *errormsg = _(e_using_sid_not_in_script_context);\n\t\t    return NULL;\n\t\t}\n\t\tsprintf((char *)strbuf, \"<SNR>%d_\", current_sctx.sc_sid);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n#ifdef FEAT_CLIENTSERVER\n\tcase SPEC_CLIENT:\t// Source of last submitted input\n\t\tsprintf((char *)strbuf, PRINTF_HEX_LONG_U,\n\t\t\t\t\t\t\t(long_u)clientWindow);\n\t\tresult = strbuf;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tresult = (char_u *)\"\"; // avoid gcc warning\n\t\tbreak;\n\t}\n\n\tresultlen = (int)STRLEN(result);\t// length of new string\n\tif (src[*usedlen] == '<')\t// remove the file name extension\n\t{\n\t    ++*usedlen;\n\t    if ((s = vim_strrchr(result, '.')) != NULL && s >= gettail(result))\n\t\tresultlen = (int)(s - result);\n\t}\n\telse if (!skip_mod)\n\t{\n\t    valid |= modify_fname(src, tilde_file, usedlen, &result, &resultbuf,\n\t\t\t\t\t\t\t\t  &resultlen);\n\t    if (result == NULL)\n\t    {\n\t\t*errormsg = \"\";\n\t\treturn NULL;\n\t    }\n\t}\n    }\n\n    if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH)\n    {\n\tif (empty_is_error)\n\t{\n\t    if (valid != VALID_HEAD + VALID_PATH)\n\t\t*errormsg = _(e_empty_file_name_for_percent_or_hash_only_works_with_ph);\n\t    else\n\t\t*errormsg = _(e_evaluates_to_an_empty_string);\n\t}\n\tresult = NULL;\n    }\n    else\n\tresult = vim_strnsave(result, resultlen);\n    vim_free(resultbuf);\n    return result;\n}\n\n/*\n * Expand the <sfile> string in \"arg\".\n *\n * Returns an allocated string, or NULL for any error.\n */\n    char_u *\nexpand_sfile(char_u *arg)\n{\n    char\t*errormsg;\n    int\t\tlen;\n    char_u\t*result;\n    char_u\t*newres;\n    char_u\t*repl;\n    int\t\tsrclen;\n    char_u\t*p;\n\n    result = vim_strsave(arg);\n    if (result == NULL)\n\treturn NULL;\n\n    for (p = result; *p; )\n    {\n\tif (STRNCMP(p, \"<sfile>\", 7) != 0)\n\t    ++p;\n\telse\n\t{\n\t    // replace \"<sfile>\" with the sourced file name, and do \":\" stuff\n\t    repl = eval_vars(p, result, &srclen, NULL, &errormsg, NULL, TRUE);\n\t    if (errormsg != NULL)\n\t    {\n\t\tif (*errormsg)\n\t\t    emsg(errormsg);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    if (repl == NULL)\t\t// no match (cannot happen)\n\t    {\n\t\tp += srclen;\n\t\tcontinue;\n\t    }\n\t    len = (int)STRLEN(result) - srclen + (int)STRLEN(repl) + 1;\n\t    newres = alloc(len);\n\t    if (newres == NULL)\n\t    {\n\t\tvim_free(repl);\n\t\tvim_free(result);\n\t\treturn NULL;\n\t    }\n\t    mch_memmove(newres, result, (size_t)(p - result));\n\t    STRCPY(newres + (p - result), repl);\n\t    len = (int)STRLEN(newres);\n\t    STRCAT(newres, p + srclen);\n\t    vim_free(repl);\n\t    vim_free(result);\n\t    result = newres;\n\t    p = newres + len;\t\t// continue after the match\n\t}\n    }\n\n    return result;\n}\n\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Make a dialog message in \"buff[DIALOG_MSG_SIZE]\".\n * \"format\" must contain \"%s\".\n */\n    void\ndialog_msg(char_u *buff, char *format, char_u *fname)\n{\n    if (fname == NULL)\n\tfname = (char_u *)_(\"Untitled\");\n    vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);\n}\n#endif\n\n/*\n * \":behave {mswin,xterm}\"\n */\n    static void\nex_behave(exarg_T *eap)\n{\n    if (STRCMP(eap->arg, \"mswin\") == 0)\n    {\n\tset_option_value_give_err((char_u *)\"selection\",\n\t\t\t\t\t\t 0L, (char_u *)\"exclusive\", 0);\n\tset_option_value_give_err((char_u *)\"selectmode\",\n\t\t\t\t\t\t 0L, (char_u *)\"mouse,key\", 0);\n\tset_option_value_give_err((char_u *)\"mousemodel\",\n\t\t\t\t\t\t     0L, (char_u *)\"popup\", 0);\n\tset_option_value_give_err((char_u *)\"keymodel\",\n\t\t\t\t\t  0L, (char_u *)\"startsel,stopsel\", 0);\n    }\n    else if (STRCMP(eap->arg, \"xterm\") == 0)\n    {\n\tset_option_value_give_err((char_u *)\"selection\",\n\t\t\t\t\t\t 0L, (char_u *)\"inclusive\", 0);\n\tset_option_value_give_err((char_u *)\"selectmode\", 0L, (char_u *)\"\", 0);\n\tset_option_value_give_err((char_u *)\"mousemodel\",\n\t\t\t\t\t\t    0L, (char_u *)\"extend\", 0);\n\tset_option_value_give_err((char_u *)\"keymodel\", 0L, (char_u *)\"\", 0);\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n}\n\nstatic int filetype_detect = FALSE;\nstatic int filetype_plugin = FALSE;\nstatic int filetype_indent = FALSE;\n\n/*\n * \":filetype [plugin] [indent] {on,off,detect}\"\n * on: Load the filetype.vim file to install autocommands for file types.\n * off: Load the ftoff.vim file to remove all autocommands for file types.\n * plugin on: load filetype.vim and ftplugin.vim\n * plugin off: load ftplugof.vim\n * indent on: load filetype.vim and indent.vim\n * indent off: load indoff.vim\n */\n    static void\nex_filetype(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tplugin = FALSE;\n    int\t\tindent = FALSE;\n\n    if (*eap->arg == NUL)\n    {\n\t// Print current status.\n\tsmsg(\"filetype detection:%s  plugin:%s  indent:%s\",\n\t\tfiletype_detect ? \"ON\" : \"OFF\",\n\t\tfiletype_plugin ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\",\n\t\tfiletype_indent ? (filetype_detect ? \"ON\" : \"(on)\") : \"OFF\");\n\treturn;\n    }\n\n    // Accept \"plugin\" and \"indent\" in any order.\n    for (;;)\n    {\n\tif (STRNCMP(arg, \"plugin\", 6) == 0)\n\t{\n\t    plugin = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tif (STRNCMP(arg, \"indent\", 6) == 0)\n\t{\n\t    indent = TRUE;\n\t    arg = skipwhite(arg + 6);\n\t    continue;\n\t}\n\tbreak;\n    }\n    if (STRCMP(arg, \"on\") == 0 || STRCMP(arg, \"detect\") == 0)\n    {\n\tif (*arg == 'o' || !filetype_detect)\n\t{\n\t    source_runtime((char_u *)FILETYPE_FILE, DIP_ALL);\n\t    filetype_detect = TRUE;\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGIN_FILE, DIP_ALL);\n\t\tfiletype_plugin = TRUE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDENT_FILE, DIP_ALL);\n\t\tfiletype_indent = TRUE;\n\t    }\n\t}\n\tif (*arg == 'd')\n\t{\n\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", TRUE, NULL);\n\t    do_modelines(0);\n\t}\n    }\n    else if (STRCMP(arg, \"off\") == 0)\n    {\n\tif (plugin || indent)\n\t{\n\t    if (plugin)\n\t    {\n\t\tsource_runtime((char_u *)FTPLUGOF_FILE, DIP_ALL);\n\t\tfiletype_plugin = FALSE;\n\t    }\n\t    if (indent)\n\t    {\n\t\tsource_runtime((char_u *)INDOFF_FILE, DIP_ALL);\n\t\tfiletype_indent = FALSE;\n\t    }\n\t}\n\telse\n\t{\n\t    source_runtime((char_u *)FTOFF_FILE, DIP_ALL);\n\t    filetype_detect = FALSE;\n\t}\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), arg);\n}\n\n/*\n * \":setfiletype [FALLBACK] {name}\"\n */\n    static void\nex_setfiletype(exarg_T *eap)\n{\n    if (!did_filetype)\n    {\n\tchar_u *arg = eap->arg;\n\n\tif (STRNCMP(arg, \"FALLBACK \", 9) == 0)\n\t    arg += 9;\n\n\tset_option_value_give_err((char_u *)\"filetype\", 0L, arg, OPT_LOCAL);\n\tif (arg != eap->arg)\n\t    did_filetype = FALSE;\n    }\n}\n\n    static void\nex_digraphs(exarg_T *eap UNUSED)\n{\n#ifdef FEAT_DIGRAPHS\n    if (*eap->arg != NUL)\n\tputdigraph(eap->arg);\n    else\n\tlistdigraphs(eap->forceit);\n#else\n    emsg(_(e_no_digraphs_version));\n#endif\n}\n\n#if defined(FEAT_SEARCH_EXTRA) || defined(PROTO)\n    void\nset_no_hlsearch(int flag)\n{\n    no_hlsearch = flag;\n# ifdef FEAT_EVAL\n    set_vim_var_nr(VV_HLSEARCH, !no_hlsearch && p_hls);\n# endif\n}\n\n/*\n * \":nohlsearch\"\n */\n    static void\nex_nohlsearch(exarg_T *eap UNUSED)\n{\n    set_no_hlsearch(TRUE);\n    redraw_all_later(SOME_VALID);\n}\n#endif\n\n#ifdef FEAT_CRYPT\n/*\n * \":X\": Get crypt key\n */\n    static void\nex_X(exarg_T *eap UNUSED)\n{\n    crypt_check_current_method();\n    (void)crypt_get_key(TRUE, TRUE);\n}\n#endif\n\n#ifdef FEAT_FOLDING\n    static void\nex_fold(exarg_T *eap)\n{\n    if (foldManualAllowed(TRUE))\n\tfoldCreate(eap->line1, eap->line2);\n}\n\n    static void\nex_foldopen(exarg_T *eap)\n{\n    opFoldRange(eap->line1, eap->line2, eap->cmdidx == CMD_foldopen,\n\t\t\t\t\t\t\t eap->forceit, FALSE);\n}\n\n    static void\nex_folddo(exarg_T *eap)\n{\n    linenr_T\tlnum;\n\n# ifdef FEAT_CLIPBOARD\n    start_global_changes();\n# endif\n\n    // First set the marks for all lines closed/open.\n    for (lnum = eap->line1; lnum <= eap->line2; ++lnum)\n\tif (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed))\n\t    ml_setmarked(lnum);\n\n    // Execute the command on the marked lines.\n    global_exe(eap->arg);\n    ml_clearmarked();\t   // clear rest of the marks\n# ifdef FEAT_CLIPBOARD\n    end_global_changes();\n# endif\n}\n#endif\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Returns TRUE if the supplied Ex cmdidx is for a location list command\n * instead of a quickfix command.\n */\n    int\nis_loclist_cmd(int cmdidx)\n{\n    if (cmdidx < 0 || cmdidx >= CMD_SIZE)\n\treturn FALSE;\n    return cmdnames[cmdidx].cmd_name[0] == 'l';\n}\n#endif\n\n#if defined(FEAT_TIMERS) || defined(PROTO)\n    int\nget_pressedreturn(void)\n{\n    return ex_pressedreturn;\n}\n\n    void\nset_pressedreturn(int val)\n{\n     ex_pressedreturn = val;\n}\n#endif\n", "\" Tests for editing the command line.\n\nsource check.vim\nsource screendump.vim\nsource view_util.vim\nsource shared.vim\nimport './vim9.vim' as v9\n\nfunc SetUp()\n  func SaveLastScreenLine()\n    let g:Sline = Screenline(&lines - 1)\n    return ''\n  endfunc\n  cnoremap <expr> <F4> SaveLastScreenLine()\nendfunc\n\nfunc TearDown()\n  delfunc SaveLastScreenLine\n  cunmap <F4>\nendfunc\n\nfunc Test_complete_tab()\n  call writefile(['testfile'], 'Xtestfile')\n  call feedkeys(\":e Xtest\\t\\r\", \"tx\")\n  call assert_equal('testfile', getline(1))\n\n  \" Pressing <Tab> after '%' completes the current file, also on MS-Windows\n  call feedkeys(\":e %\\t\\r\", \"tx\")\n  call assert_equal('e Xtestfile', @:)\n  call delete('Xtestfile')\nendfunc\n\nfunc Test_complete_list()\n  \" We can't see the output, but at least we check the code runs properly.\n  call feedkeys(\":e test\\<C-D>\\r\", \"tx\")\n  call assert_equal('test', expand('%:t'))\n\n  \" If a command doesn't support completion, then CTRL-D should be literally\n  \" used.\n  call feedkeys(\":chistory \\<C-D>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"chistory \\<C-D>\", @:)\n\n  \" Test for displaying the tail of the completion matches\n  set wildmode=longest,full\n  call mkdir('Xtest')\n  call writefile([], 'Xtest/a.c')\n  call writefile([], 'Xtest/a.h')\n  let g:Sline = ''\n  call feedkeys(\":e Xtest/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('a.c  a.h', g:Sline)\n  call assert_equal('\"e Xtest/', @:)\n  if has('win32')\n    \" Test for 'completeslash'\n    set completeslash=backslash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\', @:)\n    call feedkeys(\":e Xtest/\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest\\a.', @:)\n    set completeslash=slash\n    call feedkeys(\":e Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/', @:)\n    call feedkeys(\":e Xtest\\\\\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest/a.', @:)\n    set completeslash&\n  endif\n\n  \" Test for displaying the tail with wildcards\n  let g:Sline = ''\n  call feedkeys(\":e Xtes?/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes?/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes*/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('Xtest/a.c  Xtest/a.h', g:Sline)\n  call assert_equal('\"e Xtes*/', @:)\n  let g:Sline = ''\n  call feedkeys(\":e Xtes[/\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(':e Xtes[/', g:Sline)\n  call assert_equal('\"e Xtes[/', @:)\n\n  call delete('Xtest', 'rf')\n  set wildmode&\nendfunc\n\nfunc Test_complete_wildmenu()\n  call mkdir('Xdir1/Xdir2', 'p')\n  call writefile(['testfile1'], 'Xdir1/Xtestfile1')\n  call writefile(['testfile2'], 'Xdir1/Xtestfile2')\n  call writefile(['testfile3'], 'Xdir1/Xdir2/Xtestfile3')\n  call writefile(['testfile3'], 'Xdir1/Xdir2/Xtestfile4')\n  set wildmenu\n\n  \" Pressing <Tab> completes, and moves to next files when pressing again.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Tab>\\<Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n\n  \" <S-Tab> is like <Tab> but begin with the last match and then go to\n  \" previous.\n  call feedkeys(\":e Xdir1/Xtest\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xdir1/Xtest\\<S-Tab>\\<S-Tab>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Left>/<Right> to move to previous/next file.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile2', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Right>\\<Right>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" <Up>/<Down> to go up/down directories.\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<CR>\", 'tx')\n  call assert_equal('testfile3', getline(1))\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<Up>\\<Right>\\<CR>\", 'tx')\n  call assert_equal('testfile1', getline(1))\n\n  \" this fails in some Unix GUIs, not sure why\n  if !has('unix') || !has('gui_running')\n    \" <C-J>/<C-K> mappings to go up/down directories when 'wildcharm' is\n    \" different than 'wildchar'.\n    set wildcharm=<C-Z>\n    cnoremap <C-J> <Down><C-Z>\n    cnoremap <C-K> <Up><C-Z>\n    call feedkeys(\":e Xdir1/\\<Tab>\\<C-J>\\<CR>\", 'tx')\n    call assert_equal('testfile3', getline(1))\n    call feedkeys(\":e Xdir1/\\<Tab>\\<C-J>\\<C-K>\\<CR>\", 'tx')\n    call assert_equal('testfile1', getline(1))\n    set wildcharm=0\n    cunmap <C-J>\n    cunmap <C-K>\n  endif\n\n  \" Test for canceling the wild menu by adding a character\n  redrawstatus\n  call feedkeys(\":e Xdir1/\\<Tab>x\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xdir1/Xdir2/x', @:)\n\n  \" Completion using a relative path\n  cd Xdir1/Xdir2\n  call feedkeys(\":e ../\\<Tab>\\<Right>\\<Down>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xtestfile3 Xtestfile4', @:)\n  cd -\n\n  \" test for wildmenumode()\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":cd Xdir\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cd Xdir1/0', @:)\n  call feedkeys(\":e Xdir1/\\<Tab>\\<F2>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"e Xdir1/Xdir2/1', @:)\n  cunmap <F2>\n\n  \" Test for canceling the wild menu by pressing <PageDown> or <PageUp>.\n  \" After this pressing <Left> or <Right> should not change the selection.\n  call feedkeys(\":sign \\<Tab>\\<PageDown>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign define', @:)\n  call histadd('cmd', 'TestWildMenu')\n  call feedkeys(\":sign \\<Tab>\\<PageUp>\\<Left>\\<Right>\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"TestWildMenu', @:)\n\n  \" cleanup\n  %bwipe\n  call delete('Xdir1', 'rf')\n  set nowildmenu\nendfunc\n\nfunc Test_wildmenu_screendump()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    set wildmenu hlsearch\n  [SCRIPT]\n  call writefile(lines, 'XTest_wildmenu')\n\n  let buf = RunVimInTerminal('-S XTest_wildmenu', {'rows': 8})\n  call term_sendkeys(buf, \":vim\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_1', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_2', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_3', {})\n\n  call term_sendkeys(buf, \"\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_4', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_wildmenu')\nendfunc\n\nfunc Test_redraw_in_autocmd()\n  CheckScreendump\n\n  let lines =<< trim END\n      set cmdheight=2\n      autocmd CmdlineChanged * redraw\n  END\n  call writefile(lines, 'XTest_redraw')\n\n  let buf = RunVimInTerminal('-S XTest_redraw', {'rows': 8})\n  call term_sendkeys(buf, \":for i in range(3)\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_1', {})\n\n  call term_sendkeys(buf, \"let i =\")\n  call VerifyScreenDump(buf, 'Test_redraw_in_autocmd_2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<CR>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_redraw')\nendfunc\n\nfunc Test_map_completion()\n  call feedkeys(\":map <unique> <si\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <unique> <silent>', getreg(':'))\n  call feedkeys(\":map <script> <un\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <script> <unique>', getreg(':'))\n  call feedkeys(\":map <expr> <sc\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <expr> <script>', getreg(':'))\n  call feedkeys(\":map <buffer> <e\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <buffer> <expr>', getreg(':'))\n  call feedkeys(\":map <nowait> <b\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <nowait> <buffer>', getreg(':'))\n  call feedkeys(\":map <special> <no\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <special> <nowait>', getreg(':'))\n  call feedkeys(\":map <silent> <sp\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <silent> <special>', getreg(':'))\n\n  map <Middle>x middle\n\n  map ,f commaf\n  map ,g commaf\n  map <Left> left\n  map <A-Left>x shiftleft\n  call feedkeys(\":map ,\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,f', getreg(':'))\n  call feedkeys(\":map ,\\<Tab>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map ,g', getreg(':'))\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <A-Left>\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <A-Left>\\<Tab>\", getreg(':'))\n  unmap ,f\n  unmap ,g\n  unmap <Left>\n  unmap <A-Left>x\n\n  set cpo-=< cpo-=B cpo-=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  call feedkeys(\":map <M\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"map <M\\<Tab>\", getreg(':'))\n  unmap <Left>\n\n  set cpo+=<\n  map <Left> left\n  exe \"set t_k6=\\<Esc>[17~\"\n  call feedkeys(\":map \\<Esc>[17~x f6x\\<CR>\", 'xt')\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  if !has('gui_running')\n    call feedkeys(\":map \\<Esc>[17~\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"map <F6>x\", getreg(':'))\n  endif\n  unmap <Left>\n  call feedkeys(\":unmap \\<Esc>[17~x\\<CR>\", 'xt')\n  set cpo-=<\n\n  set cpo+=B\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=B\n\n  set cpo+=k\n  map <Left> left\n  call feedkeys(\":map <L\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"map <Left>', getreg(':'))\n  unmap <Left>\n  set cpo-=k\n\n  call assert_fails('call feedkeys(\":map \\\\\\\\%(\\<Tab>\\<Home>\\\"\\<CR>\", \"xt\")', 'E53:')\n\n  unmap <Middle>x\n  set cpo&vim\nendfunc\n\nfunc Test_match_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":match \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match Aardig', @:)\n  call feedkeys(\":match \\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match none', @:)\n  call feedkeys(\":match | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"match | chistory', @:)\nendfunc\n\nfunc Test_highlight_completion()\n  hi Aardig ctermfg=green\n  call feedkeys(\":hi \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi Aardig', getreg(':'))\n  call feedkeys(\":hi default \\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default Aardig', getreg(':'))\n  call feedkeys(\":hi clear Aa\\<Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig', getreg(':'))\n  call feedkeys(\":hi li\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi link', getreg(':'))\n  call feedkeys(\":hi d\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi default', getreg(':'))\n  call feedkeys(\":hi c\\<S-Tab>\\<Home>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear', getreg(':'))\n  call feedkeys(\":hi clear Aardig Aard\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"hi clear Aardig Aardig', getreg(':'))\n  call feedkeys(\":hi Aardig \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Aardig \\t\", getreg(':'))\n\n  \" A cleared group does not show up in completions.\n  hi Anders ctermfg=green\n  call assert_equal(['Aardig', 'Anders'], getcompletion('A', 'highlight'))\n  hi clear Aardig\n  call assert_equal(['Anders'], getcompletion('A', 'highlight'))\n  hi clear Anders\n  call assert_equal([], getcompletion('A', 'highlight'))\nendfunc\n\n\" Test for command-line expansion of \"hi Ni \" (easter egg)\nfunc Test_highlight_easter_egg()\n  call test_override('ui_delay', 1)\n  call feedkeys(\":hi Ni \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"hi Ni \\<Tab>\", @:)\n  call test_override('ALL', 0)\nendfunc\n\nfunc Test_getcompletion()\n  let groupcount = len(getcompletion('', 'event'))\n  call assert_true(groupcount > 0)\n  let matchcount = len('File'->getcompletion('event'))\n  call assert_true(matchcount > 0)\n  call assert_true(groupcount > matchcount)\n\n  if has('menu')\n    source $VIMRUNTIME/menu.vim\n    let matchcount = len(getcompletion('', 'menu'))\n    call assert_true(matchcount > 0)\n    call assert_equal(['File.'], getcompletion('File', 'menu'))\n    call assert_true(matchcount > 0)\n    let matchcount = len(getcompletion('File.', 'menu'))\n    call assert_true(matchcount > 0)\n  endif\n\n  let l = getcompletion('v:n', 'var')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('v:notexists', 'var')\n  call assert_equal([], l)\n\n  args a.c b.c\n  let l = getcompletion('', 'arglist')\n  call assert_equal(['a.c', 'b.c'], l)\n  let l = getcompletion('a.', 'buffer')\n  call assert_equal(['a.c'], l)\n  %argdelete\n\n  let l = getcompletion('', 'augroup')\n  call assert_true(index(l, 'END') >= 0)\n  let l = getcompletion('blahblah', 'augroup')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'behave')\n  call assert_true(index(l, 'mswin') >= 0)\n  let l = getcompletion('not', 'behave')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'color')\n  call assert_true(index(l, 'default') >= 0)\n  let l = getcompletion('dirty', 'color')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'command')\n  call assert_true(index(l, 'sleep') >= 0)\n  let l = getcompletion('awake', 'command')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'dir')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('NoMatch', 'dir')\n  call assert_equal([], l)\n\n  if glob('~/*') !=# ''\n    let l = getcompletion('~/', 'dir')\n    call assert_true(l[0][0] ==# '~')\n  endif\n\n  let l = getcompletion('exe', 'expression')\n  call assert_true(index(l, 'executable(') >= 0)\n  let l = getcompletion('kill', 'expression')\n  call assert_equal([], l)\n\n  let l = getcompletion('tag', 'function')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('paint', 'function')\n  call assert_equal([], l)\n\n  let Flambda = {-> 'hello'}\n  let l = getcompletion('', 'function')\n  let l = filter(l, {i, v -> v =~ 'lambda'})\n  call assert_equal([], l)\n\n  let l = getcompletion('run', 'file')\n  call assert_true(index(l, 'runtest.vim') >= 0)\n  let l = getcompletion('walk', 'file')\n  call assert_equal([], l)\n  set wildignore=*.vim\n  let l = getcompletion('run', 'file', 1)\n  call assert_true(index(l, 'runtest.vim') < 0)\n  set wildignore&\n  \" Directory name with space character\n  call mkdir('Xdir with space')\n  call assert_equal(['Xdir with space/'], getcompletion('Xdir\\ w', 'shellcmd'))\n  call assert_equal(['./Xdir with space/'], getcompletion('./Xdir', 'shellcmd'))\n  call delete('Xdir with space', 'd')\n\n  let l = getcompletion('ha', 'filetype')\n  call assert_true(index(l, 'hamster') >= 0)\n  let l = getcompletion('horse', 'filetype')\n  call assert_equal([], l)\n\n  let l = getcompletion('z', 'syntax')\n  call assert_true(index(l, 'zimbu') >= 0)\n  let l = getcompletion('emacs', 'syntax')\n  call assert_equal([], l)\n\n  let l = getcompletion('jikes', 'compiler')\n  call assert_true(index(l, 'jikes') >= 0)\n  let l = getcompletion('break', 'compiler')\n  call assert_equal([], l)\n\n  let l = getcompletion('last', 'help')\n  call assert_true(index(l, ':tablast') >= 0)\n  let l = getcompletion('giveup', 'help')\n  call assert_equal([], l)\n\n  let l = getcompletion('time', 'option')\n  call assert_true(index(l, 'timeoutlen') >= 0)\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n\n  let l = getcompletion('er', 'highlight')\n  call assert_true(index(l, 'ErrorMsg') >= 0)\n  let l = getcompletion('dark', 'highlight')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'messages')\n  call assert_true(index(l, 'clear') >= 0)\n  let l = getcompletion('not', 'messages')\n  call assert_equal([], l)\n\n  let l = getcompletion('', 'mapclear')\n  call assert_true(index(l, '<buffer>') >= 0)\n  let l = getcompletion('not', 'mapclear')\n  call assert_equal([], l)\n\n  let l = getcompletion('.', 'shellcmd')\n  call assert_equal(['./', '../'], filter(l, 'v:val =~ \"\\\\./\"'))\n  call assert_equal(-1, match(l[2:], '^\\.\\.\\?/$'))\n  let root = has('win32') ? 'C:\\\\' : '/'\n  let l = getcompletion(root, 'shellcmd')\n  let expected = map(filter(glob(root . '*', 0, 1),\n        \\ 'isdirectory(v:val) || executable(v:val)'), 'isdirectory(v:val) ? v:val . ''/'' : v:val')\n  call assert_equal(expected, l)\n\n  if has('cscope')\n    let l = getcompletion('', 'cscope')\n    let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":cscope find \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'cscope')\n    call assert_equal(cmds, l)\n    let keys = ['a', 'c', 'd', 'e', 'f', 'g', 'i', 's', 't']\n    let l = getcompletion('find ', 'cscope')\n    call assert_equal(keys, l)\n  endif\n\n  if has('signs')\n    sign define Testing linehl=Comment\n    let l = getcompletion('', 'sign')\n    let cmds = ['define', 'jump', 'list', 'place', 'undefine', 'unplace']\n    call assert_equal(cmds, l)\n    \" using cmdline completion must not change the result\n    call feedkeys(\":sign list \\<c-d>\\<c-c>\", 'xt')\n    let l = getcompletion('', 'sign')\n    call assert_equal(cmds, l)\n    let l = getcompletion('list ', 'sign')\n    call assert_equal(['Testing'], l)\n    let l = getcompletion('de*', 'sign')\n    call assert_equal(['define'], l)\n    let l = getcompletion('p?', 'sign')\n    call assert_equal(['place'], l)\n    let l = getcompletion('j.', 'sign')\n    call assert_equal(['jump'], l)\n  endif\n\n  \" Command line completion tests\n  let l = getcompletion('cd ', 'cmdline')\n  call assert_true(index(l, 'samples/') >= 0)\n  let l = getcompletion('cd NoMatch', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('let v:n', 'cmdline')\n  call assert_true(index(l, 'v:null') >= 0)\n  let l = getcompletion('let v:notexists', 'cmdline')\n  call assert_equal([], l)\n  let l = getcompletion('call tag', 'cmdline')\n  call assert_true(index(l, 'taglist(') >= 0)\n  let l = getcompletion('call paint', 'cmdline')\n  call assert_equal([], l)\n\n  func T(a, c, p)\n    let g:cmdline_compl_params = [a:a, a:c, a:p]\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n  let l = getcompletion('MyCmd ', 'cmdline')\n  call assert_equal(['oneA', 'oneB', 'oneC'], l)\n  call assert_equal(['', 'MyCmd ', 6], g:cmdline_compl_params)\n\n  delcommand MyCmd\n  delfunc T\n  unlet g:cmdline_compl_params\n\n  \" For others test if the name is recognized.\n  let names = ['buffer', 'environment', 'file_in_path', 'mapping', 'tag', 'tag_listfiles', 'user']\n  if has('cmdline_hist')\n    call add(names, 'history')\n  endif\n  if has('gettext')\n    call add(names, 'locale')\n  endif\n  if has('profile')\n    call add(names, 'syntime')\n  endif\n\n  set tags=Xtags\n  call writefile([\"!_TAG_FILE_ENCODING\\tutf-8\\t//\", \"word\\tfile\\tcmd\"], 'Xtags')\n\n  for name in names\n    let matchcount = len(getcompletion('', name))\n    call assert_true(matchcount >= 0, 'No matches for ' . name)\n  endfor\n\n  call delete('Xtags')\n  set tags&\n\n  edit a~b\n  enew\n  call assert_equal(['a~b'], getcompletion('a~', 'buffer'))\n  bw a~b\n\n  if has('unix')\n    edit Xtest\\\n    enew\n    call assert_equal(['Xtest\\'], getcompletion('Xtest\\', 'buffer'))\n    bw Xtest\\\n  endif\n\n  call assert_fails(\"call getcompletion('\\\\\\\\@!\\\\\\\\@=', 'buffer')\", 'E871:')\n  call assert_fails('call getcompletion(\"\", \"burp\")', 'E475:')\n  call assert_fails('call getcompletion(\"abc\", [])', 'E475:')\nendfunc\n\n\" Test for getcompletion() with \"fuzzy\" in 'wildoptions'\nfunc Test_getcompletion_wildoptions()\n  let save_wildoptions = &wildoptions\n  set wildoptions&\n  let l = getcompletion('space', 'option')\n  call assert_equal([], l)\n  let l = getcompletion('ier', 'command')\n  call assert_equal([], l)\n  set wildoptions=fuzzy\n  let l = getcompletion('space', 'option')\n  call assert_true(index(l, 'backspace') >= 0)\n  let l = getcompletion('ier', 'command')\n  call assert_true(index(l, 'compiler') >= 0)\n  let &wildoptions = save_wildoptions\nendfunc\n\nfunc Test_complete_autoload_error()\n  let save_rtp = &rtp\n  let lines =<< trim END\n      vim9script\n      export def Complete(..._): string\n        return 'match'\n      enddef\n      echo this will cause an error\n  END\n  call mkdir('Xdir/autoload', 'p')\n  call writefile(lines, 'Xdir/autoload/script.vim')\n  exe 'set rtp+=' .. getcwd() .. '/Xdir'\n\n  let lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      command -nargs=* -complete=custom,script.Complete Cmd eval 0 + 0\n      &wildcharm = char2nr(\"\\<Tab>\")\n      feedkeys(\":Cmd \\<Tab>\", 'xt')\n  END\n  call v9.CheckScriptFailure(lines, 'E121: Undefined variable: this')\n\n  let &rtp = save_rtp\n  call delete('Xdir', 'rf')\nendfunc\n\nfunc Test_fullcommand()\n  let tests = {\n        \\ '':           '',\n        \\ ':':          '',\n        \\ ':::':        '',\n        \\ ':::5':       '',\n        \\ 'not_a_cmd':  '',\n        \\ 'Check':      '',\n        \\ 'syntax':     'syntax',\n        \\ ':syntax':    'syntax',\n        \\ '::::syntax': 'syntax',\n        \\ 'sy':         'syntax',\n        \\ 'syn':        'syntax',\n        \\ 'synt':       'syntax',\n        \\ ':sy':        'syntax',\n        \\ '::::sy':     'syntax',\n        \\ 'match':      'match',\n        \\ '2match':     'match',\n        \\ '3match':     'match',\n        \\ 'aboveleft':  'aboveleft',\n        \\ 'abo':        'aboveleft',\n        \\ 's':          'substitute',\n        \\ '5s':         'substitute',\n        \\ ':5s':        'substitute',\n        \\ \"'<,'>s\":     'substitute',\n        \\ \":'<,'>s\":    'substitute',\n        \\ 'CheckLin':   'CheckLinux',\n        \\ 'CheckLinux': 'CheckLinux',\n  \\ }\n\n  for [in, want] in items(tests)\n    call assert_equal(want, fullcommand(in))\n  endfor\n  call assert_equal('', fullcommand(test_null_string()))\n\n  call assert_equal('syntax', 'syn'->fullcommand())\n\n  command -buffer BufferLocalCommand :\n  command GlobalCommand :\n  call assert_equal('GlobalCommand', fullcommand('GlobalCom'))\n  call assert_equal('BufferLocalCommand', fullcommand('BufferL'))\n  delcommand BufferLocalCommand\n  delcommand GlobalCommand\nendfunc\n\nfunc Test_shellcmd_completion()\n  let save_path = $PATH\n\n  call mkdir('Xpathdir/Xpathsubdir', 'p')\n  call writefile([''], 'Xpathdir/Xfile.exe')\n  call setfperm('Xpathdir/Xfile.exe', 'rwx------')\n\n  \" Set PATH to example directory without trailing slash.\n  let $PATH = getcwd() . '/Xpathdir'\n\n  \" Test for the \":!<TAB>\" case.  Previously, this would include subdirs of\n  \" dirs in the PATH, even though they won't be executed.  We check that only\n  \" subdirs of the PWD and executables from the PATH are included in the\n  \" suggestions.\n  let actual = getcompletion('X', 'shellcmd')\n  let expected = map(filter(glob('*', 0, 1), 'isdirectory(v:val) && v:val[0] == \"X\"'), 'v:val . \"/\"')\n  call insert(expected, 'Xfile.exe')\n  call assert_equal(expected, actual)\n\n  call delete('Xpathdir', 'rf')\n  let $PATH = save_path\nendfunc\n\nfunc Test_expand_star_star()\n  call mkdir('a/b', 'p')\n  call writefile(['asdfasdf'], 'a/b/fileXname')\n  call feedkeys(\":find **/fileXname\\<Tab>\\<CR>\", 'xt')\n  call assert_equal('find a/b/fileXname', @:)\n  bwipe!\n  call delete('a', 'rf')\nendfunc\n\nfunc Test_cmdline_paste()\n  let @a = \"def\"\n  call feedkeys(\":abc \\<C-R>a ghi\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"abc def ghi', @:)\n\n  new\n  call setline(1, 'asdf.x /tmp/some verylongword a;b-c*d ')\n\n  call feedkeys(\":aaa \\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa asdf bbb', @:)\n\n  call feedkeys(\"ft:aaa \\<C-R>\\<C-F> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa /tmp/some bbb', @:)\n\n  call feedkeys(\":aaa \\<C-R>\\<C-L> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa '.getline(1).' bbb', @:)\n\n  set incsearch\n  call feedkeys(\"fy:aaa veryl\\<C-R>\\<C-W> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa verylongword bbb', @:)\n\n  call feedkeys(\"f;:aaa \\<C-R>\\<C-A> bbb\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"aaa a;b-c*d bbb', @:)\n\n  call feedkeys(\":\\<C-\\>etoupper(getline(1))\\<CR>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"ASDF.X /TMP/SOME VERYLONGWORD A;B-C*D ', @:)\n  bwipe!\n\n  \" Error while typing a command used to cause that it was not executed\n  \" in the end.\n  new\n  try\n    call feedkeys(\":file \\<C-R>%Xtestfile\\<CR>\", 'tx')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E32/\n    \" ignore error E32\n  endtry\n  call assert_equal(\"Xtestfile\", bufname(\"%\"))\n\n  \" Try to paste an invalid register using <C-R>\n  call feedkeys(\":\\\"one\\<C-R>\\<C-X>two\\<CR>\", 'xt')\n  call assert_equal('\"onetwo', @:)\n\n  \" Test for pasting register containing CTRL-H using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-H>z\"\n  call feedkeys(\":\\\"\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal('\"xz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-O>a\\<CR>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-H>z\", @:)\n\n  \" Test for pasting register containing CTRL-V using CTRL-R and CTRL-R CTRL-R\n  let @a = \"xy\\<C-V>z\"\n  call feedkeys(\":\\\"\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal('\"xyz', @:)\n  call feedkeys(\":\\\"\\<C-R>\\<C-R>=@a\\<CR>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"xy\\<C-V>z\", @:)\n\n  call assert_beeps('call feedkeys(\":\\<C-R>=\\<C-R>=\\<Esc>\", \"xt\")')\n\n  bwipe!\nendfunc\n\nfunc Test_cmdline_remove_char()\n  let encoding_save = &encoding\n\n  for e in ['utf8', 'latin1']\n    exe 'set encoding=' . e\n\n    call feedkeys(\":abc def\\<S-Left>\\<Del>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ef', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<BS>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abcdef', @:)\n\n    call feedkeys(\":abc def ghi\\<S-Left>\\<C-W>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"abc ghi', @:, e)\n\n    call feedkeys(\":abc def\\<S-Left>\\<C-U>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"def', @:, e)\n\n    \" This was going before the start in latin1.\n    call feedkeys(\": \\<C-W>\\<CR>\", 'tx')\n  endfor\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdline_keymap_ctrl_hat()\n  CheckFeature keymap\n\n  set keymap=esperanto\n  call feedkeys(\":\\\"Jxauxdo \\<C-^>Jxauxdo \\<C-^>Jxauxdo\\<CR>\", 'tx')\n  call assert_equal('\"Jxauxdo \u0134a\u016ddo Jxauxdo', @:)\n  set keymap=\nendfunc\n\nfunc Test_illegal_address1()\n  new\n  2;'(\n  2;')\n  quit\nendfunc\n\nfunc Test_illegal_address2()\n  call writefile(['c', 'x', '  x', '.', '1;y'], 'Xtest.vim')\n  new\n  source Xtest.vim\n  \" Trigger calling validate_cursor()\n  diffsp Xtest.vim\n  quit!\n  bwipe!\n  call delete('Xtest.vim')\nendfunc\n\nfunc Test_mark_from_line_zero()\n  \" this was reading past the end of the first (empty) line\n  new\n  norm oxxxx\n  call assert_fails(\"0;'(\", 'E20:')\n  bwipe!\nendfunc\n\nfunc Test_cmdline_complete_wildoptions()\n  help\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let a = join(sort(split(@:)),' ')\n  set wildoptions=tagfile\n  call feedkeys(\":tag /\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  let b = join(sort(split(@:)),' ')\n  call assert_equal(a, b)\n  bw!\nendfunc\n\nfunc Test_cmdline_complete_user_cmd()\n  command! -complete=color -nargs=1 Foo :\n  call feedkeys(\":Foo \\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo blue', @:)\n  call feedkeys(\":Foo a b\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo a blue', @:)\n  call feedkeys(\":Foo b\\\\\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\', @:)\n  call feedkeys(\":Foo b\\\\x\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_equal('\"Foo b\\x', @:)\n  delcommand Foo\nendfunc\n\nfunc s:ScriptLocalFunction()\n  echo 'yes'\nendfunc\n\nfunc Test_cmdline_complete_user_func()\n  call feedkeys(\":func Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func Test_cmdline_complete_user_', @:)\n  call feedkeys(\":func s:ScriptL\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"func <SNR>\\d\\+_ScriptLocalFunction', @:)\n\n  \" g: prefix also works\n  call feedkeys(\":echo g:Test_cmdline_complete_user_f\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:Test_cmdline_complete_user_func', @:)\n\n  \" using g: prefix does not result in just \"g:\" matches from a lambda\n  let Fx = { a ->  a }\n  call feedkeys(\":echo g:\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"echo g:[A-Z]', @:)\n\n  \" existence of script-local dict function does not break user function name\n  \" completion\n  function s:a_dict_func() dict\n  endfunction\n  call feedkeys(\":call Test_cmdline_complete_user\\<Tab>\\<Home>\\\"\\<cr>\", 'tx')\n  call assert_match('\"call Test_cmdline_complete_user_', @:)\n  delfunction s:a_dict_func\nendfunc\n\nfunc Test_cmdline_complete_user_names()\n  if has('unix') && executable('whoami')\n    let whoami = systemlist('whoami')[0]\n    let first_letter = whoami[0]\n    if len(first_letter) > 0\n      \" Trying completion of  :e ~x  where x is the first letter of\n      \" the user name should complete to at least the user name.\n      call feedkeys(':e ~' . first_letter . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*\\<' . whoami . '\\>', @:)\n    endif\n  elseif has('win32')\n    \" Just in case: check that the system has an Administrator account.\n    let names = system('net user')\n    if names =~ 'Administrator'\n      \" Trying completion of  :e ~A  should complete to Administrator.\n      \" There could be other names starting with \"A\" before Administrator.\n      call feedkeys(':e ~A' . \"\\<c-a>\\<c-B>\\\"\\<cr>\", 'tx')\n      call assert_match('^\"e \\~.*Administrator', @:)\n    endif\n  else\n    throw 'Skipped: does not work on this platform'\n  endif\nendfunc\n\nfunc Test_cmdline_complete_bang()\n  CheckExecutable whoami\n  call feedkeys(\":!whoam\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('^\".*\\<whoami\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_languages()\n  let lang = substitute(execute('language time'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lc_time)\n\n  let lang = substitute(execute('language ctype'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:ctype)\n\n  let lang = substitute(execute('language collate'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:collate)\n\n  let lang = substitute(execute('language messages'), '.*\"\\(.*\\)\"$', '\\1', '')\n  call assert_equal(lang, v:lang)\n\n  call feedkeys(\":language \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<collate\\>.*\\<ctype\\>.*\\<messages\\>.*\\<time\\>', @:)\n\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language messages \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language ctype \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language time \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\n\n  call feedkeys(\":language collate \\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n  call assert_match('^\"language .*\\<' . lang . '\\>', @:)\nendfunc\n\nfunc Test_cmdline_complete_env_variable()\n  let $X_VIM_TEST_COMPLETE_ENV = 'foo'\n  call feedkeys(\":edit $X_VIM_TEST_COMPLETE_E\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"edit $X_VIM_TEST_COMPLETE_ENV', @:)\n  unlet $X_VIM_TEST_COMPLETE_ENV\nendfunc\n\nfunc Test_cmdline_complete_expression()\n  let g:SomeVar = 'blah'\n  for cmd in ['exe', 'echo', 'echon', 'echomsg']\n    call feedkeys(\":\" .. cmd .. \" SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' SomeVar', @:)\n    call feedkeys(\":\" .. cmd .. \" foo SomeV\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_match('\"' .. cmd .. ' foo SomeVar', @:)\n  endfor\n  unlet g:SomeVar\nendfunc\n\n\" Unique function name for completion below\nfunc s:WeirdFunc()\n  echo 'weird'\nendfunc\n\n\" Test for various command-line completion\nfunc Test_cmdline_complete_various()\n  \" completion for a command starting with a comment\n  call feedkeys(\": :|\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\" :|\\\"\\<C-A>\", @:)\n\n  \" completion for a range followed by a comment\n  call feedkeys(\":1,2\\\"\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"1,2\\\"\\<C-A>\", @:)\n\n  \" completion for :k command\n  call feedkeys(\":ka\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ka\\<C-A>\", @:)\n\n  \" completion for short version of the :s command\n  call feedkeys(\":sI \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"sI \\<C-A>\", @:)\n\n  \" completion for :write command\n  call mkdir('Xdir')\n  call writefile(['one'], 'Xdir/Xfile1')\n  let save_cwd = getcwd()\n  cd Xdir\n  call feedkeys(\":w >> \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w >> Xfile1\", @:)\n  call chdir(save_cwd)\n  call delete('Xdir', 'rf')\n\n  \" completion for :w ! and :r ! commands\n  call feedkeys(\":w !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"w !invalid_xyz_cmd\", @:)\n  call feedkeys(\":r !invalid_xyz_cmd\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"r !invalid_xyz_cmd\", @:)\n\n  \" completion for :>> and :<< commands\n  call feedkeys(\":>>>\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\">>>\\<C-A>\", @:)\n  call feedkeys(\":<<<\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"<<<\\<C-A>\", @:)\n\n  \" completion for command with +cmd argument\n  call feedkeys(\":buffer +/pat Xabc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat Xabc\", @:)\n  call feedkeys(\":buffer +/pat\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"buffer +/pat\\<C-A>\", @:)\n\n  \" completion for a command with a trailing comment\n  call feedkeys(\":ls \\\" comment\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\\" comment\\<C-A>\", @:)\n\n  \" completion for a command with a trailing command\n  call feedkeys(\":ls | ls\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls | ls\", @:)\n\n  \" completion for a command with an CTRL-V escaped argument\n  call feedkeys(\":ls \\<C-V>\\<C-V>a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"ls \\<C-V>a\\<C-A>\", @:)\n\n  \" completion for a command that doesn't take additional arguments\n  call feedkeys(\":all abc\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"all abc\\<C-A>\", @:)\n\n  \" completion for a command with a command modifier\n  call feedkeys(\":topleft new\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"topleft new\", @:)\n\n  \" completion for vim9 and legacy commands\n  call feedkeys(\":vim9 call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"vim9 call strlen(\", @:)\n  call feedkeys(\":legac call strle\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"legac call strlen(\", @:)\n\n  \" completion for the :disassemble command\n  call feedkeys(\":disas deb\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug\", @:)\n  call feedkeys(\":disas pro\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile\", @:)\n  call feedkeys(\":disas debug Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas debug Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas profile Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas profile Test_cmdline_complete_various\", @:)\n  call feedkeys(\":disas Test_cmdline_complete_var\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"disas Test_cmdline_complete_various\", @:)\n\n  call feedkeys(\":disas s:WeirdF\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_WeirdFunc', @:)\n\n  call feedkeys(\":disas \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas <SNR>\\d\\+_', @:)\n  call feedkeys(\":disas debug \\<S-Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_match('\"disas debug <SNR>\\d\\+_', @:)\n\n  \" completion for the :match command\n  call feedkeys(\":match Search /pat/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"match Search /pat/\\<C-A>\", @:)\n\n  \" completion for the :doautocmd command\n  call feedkeys(\":doautocmd User MyCmd a.c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd User MyCmd a.c\\<C-A>\", @:)\n\n  \" completion of autocmd group after comma\n  call feedkeys(\":doautocmd BufNew,BufEn\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufNew,BufEnter\", @:)\n\n  \" completion of file name in :doautocmd\n  call writefile([], 'Xfile1')\n  call writefile([], 'Xfile2')\n  call feedkeys(\":doautocmd BufEnter Xfi\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"doautocmd BufEnter Xfile1 Xfile2\", @:)\n  call delete('Xfile1')\n  call delete('Xfile2')\n\n  \" completion for the :augroup command\n  augroup XTest.test\n  augroup END\n  call feedkeys(\":augroup X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"augroup XTest.test\", @:)\n\n  \" group name completion in :autocmd\n  call feedkeys(\":au X\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n  call feedkeys(\":au XTest.test\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au XTest.test\", @:)\n\n  augroup! XTest.test\n\n  \" autocmd pattern completion\n  call feedkeys(\":au BufEnter *.py\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"au BufEnter *.py\\t\", @:)\n\n  \" completion for the :unlet command\n  call feedkeys(\":unlet one two\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"unlet one two\", @:)\n\n  \" completion for the :buffer command with curlies\n  \" FIXME: what should happen on MS-Windows?\n  if !has('win32')\n    edit \\{someFile}\n    call feedkeys(\":buf someFile\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal(\"\\\"buf {someFile}\", @:)\n    bwipe {someFile}\n  endif\n\n  \" completion for the :bdelete command\n  call feedkeys(\":bdel a b c\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"bdel a b c\", @:)\n\n  \" completion for the :mapclear command\n  call feedkeys(\":mapclear \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"mapclear <buffer>\", @:)\n\n  \" completion for user defined commands with menu names\n  menu Test.foo :ls<CR>\n  com -nargs=* -complete=menu MyCmd\n  call feedkeys(\":MyCmd Te\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd Test.', @:)\n  delcom MyCmd\n  unmenu Test\n\n  \" completion for user defined commands with mappings\n  mapclear\n  map <F3> :ls<CR>\n  com -nargs=* -complete=mapping MyCmd\n  call feedkeys(\":MyCmd <F\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd <F3> <F4>', @:)\n  mapclear\n  delcom MyCmd\n\n  \" completion for :set path= with multiple backslashes\n  call feedkeys(\":set path=a\\\\\\\\\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set path=a\\\\\\ b', @:)\n\n  \" completion for :set dir= with a backslash\n  call feedkeys(\":set dir=a\\\\ b\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"set dir=a\\ b', @:)\n\n  \" completion for the :py3 commands\n  call feedkeys(\":py3\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3 py3do py3file', @:)\n\n  \" completion for the :vim9 commands\n  call feedkeys(\":vim9\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"vim9cmd vim9script', @:)\n\n  \" redir @\" is not the start of a comment. So complete after that\n  call feedkeys(\":redir @\\\" | cwin\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"redir @\" | cwindow', @:)\n\n  \" completion after a backtick\n  call feedkeys(\":e `a1b2c\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e `a1b2c', @:)\n\n  \" completion for :language command with an invalid argument\n  call feedkeys(\":language dummy \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"language dummy \\t\", @:)\n\n  \" completion for commands after a :global command\n  call feedkeys(\":g/a\\\\xb/clearj\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n\n  \" completion with ambiguous user defined commands\n  com TCmd1 echo 'TCmd1'\n  com TCmd2 echo 'TCmd2'\n  call feedkeys(\":TCmd \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"TCmd ', @:)\n  delcom TCmd1\n  delcom TCmd2\n\n  \" completion after a range followed by a pipe (|) character\n  call feedkeys(\":1,10 | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"1,10 | chistory', @:)\n\n  \" completion after a :global command\n  call feedkeys(\":g/a/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a/chistory', @:)\n  call feedkeys(\":g/a\\\\/chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"g/a\\\\/chist\\t\", @:)\n\n  \" use <Esc> as the 'wildchar' for completion\n  set wildchar=<Esc>\n  call feedkeys(\":g/a\\\\xb/clearj\\<Esc>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  \" pressing <esc> twice should cancel the command\n  call feedkeys(\":chist\\<Esc>\\<Esc>\", 'xt')\n  call assert_equal('\"g/a\\xb/clearjumps', @:)\n  set wildchar&\n\n  if has('unix')\n    \" should be able to complete a file name that starts with a '~'.\n    call writefile([], '~Xtest')\n    call feedkeys(\":e \\\\~X\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\~Xtest', @:)\n    call delete('~Xtest')\n\n    \" should be able to complete a file name that has a '*'\n    call writefile([], 'Xx*Yy')\n    call feedkeys(\":e Xx\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xx\\*Yy', @:)\n    call delete('Xx*Yy')\n\n    \" use a literal star\n    call feedkeys(\":e \\\\*\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e \\*', @:)\n  endif\n\n  call feedkeys(\":py3f\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"py3file', @:)\nendfunc\n\n\" Test for 'wildignorecase'\nfunc Test_cmdline_wildignorecase()\n  CheckUnix\n  call writefile([], 'XTEST')\n  set wildignorecase\n  call feedkeys(\":e xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e XTEST', @:)\n  call assert_equal(['XTEST'], getcompletion('xt', 'file'))\n  let g:Sline = ''\n  call feedkeys(\":e xt\\<C-d>\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e xt', @:)\n  call assert_equal('XTEST', g:Sline)\n  set wildignorecase&\n  call delete('XTEST')\nendfunc\n\nfunc Test_cmdline_write_alternatefile()\n  new\n  call setline('.', ['one', 'two'])\n  f foo.txt\n  new\n  f #-A\n  call assert_equal('foo.txt-A', expand('%'))\n  f #<-B.txt\n  call assert_equal('foo-B.txt', expand('%'))\n  f %<\n  call assert_equal('foo-B', expand('%'))\n  new\n  call assert_fails('f #<', 'E95:')\n  bw!\n  f foo-B.txt\n  f %<-A\n  call assert_equal('foo-B-A', expand('%'))\n  bw!\n  bw!\nendfunc\n\n\" using a leading backslash here\nset cpo+=C\n\nfunc Test_cmdline_search_range()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  /d\n  1,\\/s/b/B/\n  call assert_equal('B', getline(2))\n\n  /a\n  $\n  \\?,4s/c/C/\n  call assert_equal('C', getline(3))\n\n  call setline(1, ['a', 'b', 'c', 'd'])\n  %s/c/c/\n  1,\\&s/b/B/\n  call assert_equal('B', getline(2))\n\n  let @/ = 'apple'\n  call assert_fails('\\/print', ['E486:.*apple'])\n\n  bwipe!\nendfunc\n\n\" Test for the tick mark (') in an excmd range\nfunc Test_tick_mark_in_range()\n  \" If only the tick is passed as a range and no command is specified, there\n  \" should not be an error\n  call feedkeys(\":'\\<CR>\", 'xt')\n  call assert_equal(\"'\", @:)\n  call assert_fails(\"',print\", 'E78:')\nendfunc\n\n\" Test for using a line number followed by a search pattern as range\nfunc Test_lnum_and_pattern_as_range()\n  new\n  call setline(1, ['foo 1', 'foo 2', 'foo 3'])\n  let @\" = ''\n  2/foo/yank\n  call assert_equal(\"foo 3\\n\", @\")\n  call assert_equal(1, line('.'))\n  close!\nendfunc\n\n\" Tests for getcmdline(), getcmdpos() and getcmdtype()\nfunc Check_cmdline(cmdtype)\n  call assert_equal('MyCmd a', getcmdline())\n  call assert_equal(8, getcmdpos())\n  call assert_equal(a:cmdtype, getcmdtype())\n  return ''\nendfunc\n\nset cpo&\n\nfunc Test_getcmdtype()\n  call feedkeys(\":MyCmd a\\<C-R>=Check_cmdline(':')\\<CR>\\<Esc>\", \"xt\")\n\n  let cmdtype = ''\n  debuggreedy\n  call feedkeys(\":debug echo 'test'\\<CR>\", \"t\")\n  call feedkeys(\"let cmdtype = \\<C-R>=string(getcmdtype())\\<CR>\\<CR>\", \"t\")\n  call feedkeys(\"cont\\<CR>\", \"xt\")\n  0debuggreedy\n  call assert_equal('>', cmdtype)\n\n  call feedkeys(\"/MyCmd a\\<C-R>=Check_cmdline('/')\\<CR>\\<Esc>\", \"xt\")\n  call feedkeys(\"?MyCmd a\\<C-R>=Check_cmdline('?')\\<CR>\\<Esc>\", \"xt\")\n\n  call feedkeys(\":call input('Answer?')\\<CR>\", \"t\")\n  call feedkeys(\"MyCmd a\\<C-R>=Check_cmdline('@')\\<CR>\\<C-C>\", \"xt\")\n\n  call feedkeys(\":insert\\<CR>MyCmd a\\<C-R>=Check_cmdline('-')\\<CR>\\<Esc>\", \"xt\")\n\n  cnoremap <expr> <F6> Check_cmdline('=')\n  call feedkeys(\"a\\<C-R>=MyCmd a\\<F6>\\<Esc>\\<Esc>\", \"xt\")\n  cunmap <F6>\n\n  call assert_equal('', getcmdline())\nendfunc\n\nfunc Test_getcmdwintype()\n  CheckFeature cmdwin\n\n  call feedkeys(\"q/:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('/', a)\n\n  call feedkeys(\"q?:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('?', a)\n\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call feedkeys(\":\\<C-F>:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call assert_equal('', getcmdwintype())\nendfunc\n\nfunc Test_getcmdwin_autocmd()\n  CheckFeature cmdwin\n\n  let s:seq = []\n  augroup CmdWin\n  au WinEnter * call add(s:seq, 'WinEnter ' .. win_getid())\n  au WinLeave * call add(s:seq, 'WinLeave ' .. win_getid())\n  au BufEnter * call add(s:seq, 'BufEnter ' .. bufnr())\n  au BufLeave * call add(s:seq, 'BufLeave ' .. bufnr())\n  au CmdWinEnter * call add(s:seq, 'CmdWinEnter ' .. win_getid())\n  au CmdWinLeave * call add(s:seq, 'CmdWinLeave ' .. win_getid())\n\n  let org_winid = win_getid()\n  let org_bufnr = bufnr()\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:let s:cmd_winid = win_getid()\\<CR>:let s:cmd_bufnr = bufnr()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n  call assert_equal([\n\t\\ 'WinLeave ' .. org_winid,\n\t\\ 'WinEnter ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. org_bufnr,\n\t\\ 'BufEnter ' .. s:cmd_bufnr,\n\t\\ 'CmdWinEnter ' .. s:cmd_winid,\n\t\\ 'CmdWinLeave ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. s:cmd_bufnr,\n\t\\ 'WinLeave ' .. s:cmd_winid,\n\t\\ 'WinEnter ' .. org_winid,\n\t\\ 'BufEnter ' .. org_bufnr,\n\t\\ ], s:seq)\n\n  au!\n  augroup END\nendfunc\n\nfunc Test_verbosefile()\n  set verbosefile=Xlog\n  echomsg 'foo'\n  echomsg 'bar'\n  set verbosefile=\n  let log = readfile('Xlog')\n  call assert_match(\"foo\\nbar\", join(log, \"\\n\"))\n  call delete('Xlog')\n  call mkdir('Xdir')\n  call assert_fails('set verbosefile=Xdir', ['E484:.*Xdir', 'E474:'])\n  call delete('Xdir', 'd')\nendfunc\n\nfunc Test_verbose_option()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    command DoSomething echo 'hello' |set ts=4 |let v = '123' |echo v\n    call feedkeys(\"\\r\", 't') \" for the hit-enter prompt\n    set verbose=20\n  [SCRIPT]\n  call writefile(lines, 'XTest_verbose')\n\n  let buf = RunVimInTerminal('-S XTest_verbose', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":DoSomething\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_verbose_option_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_verbose')\nendfunc\n\nfunc Test_setcmdpos()\n  func InsertTextAtPos(text, pos)\n    call assert_equal(0, setcmdpos(a:pos))\n    return a:text\n  endfunc\n\n  \" setcmdpos() with position in the middle of the command line.\n  call feedkeys(\":\\\"12\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1ab2', @:)\n\n  call feedkeys(\":\\\"12\\<C-R>\\<C-R>=InsertTextAtPos('a', 3)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"1b2a', @:)\n\n  \" setcmdpos() with position beyond the end of the command line.\n  call feedkeys(\":\\\"12\\<C-B>\\<C-R>=InsertTextAtPos('a', 10)\\<CR>b\\<CR>\", 'xt')\n  call assert_equal('\"12ab', @:)\n\n  \" setcmdpos() returns 1 when not editing the command line.\n  call assert_equal(1, 3->setcmdpos())\nendfunc\n\nfunc Test_cmdline_overstrike()\n  let encodings = ['latin1', 'utf8']\n  let encoding_save = &encoding\n\n  for e in encodings\n    exe 'set encoding=' . e\n\n    \" Test overstrike in the middle of the command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cd4', @:, e)\n\n    \" Test overstrike going beyond end of command line.\n    call feedkeys(\":\\\"01234\\<home>\\<right>\\<right>ab\\<right>\\<insert>cdefgh\\<enter>\", 'xt')\n    call assert_equal('\"0ab1cdefgh', @:, e)\n\n    \" Test toggling insert/overstrike a few times.\n    call feedkeys(\":\\\"01234\\<home>\\<right>ab\\<right>\\<insert>cd\\<right>\\<insert>ef\\<enter>\", 'xt')\n    call assert_equal('\"ab0cd3ef4', @:, e)\n  endfor\n\n  \" Test overstrike with multi-byte characters.\n  call feedkeys(\":\\\"\u30c6\u30ad\u30b9\u30c8\u30a8\u30c7\u30a3\u30bf\\<home>\\<right>\\<right>ab\\<right>\\<insert>cd\\<enter>\", 'xt')\n  call assert_equal('\"\u30c6ab\u30adcd\u30a8\u30c7\u30a3\u30bf', @:, e)\n\n  let &encoding = encoding_save\nendfunc\n\nfunc Test_cmdwin_bug()\n  CheckFeature cmdwin\n\n  let winid = win_getid()\n  sp\n  try\n    call feedkeys(\"q::call win_gotoid(\" .. winid .. \")\\<CR>:q\\<CR>\", 'x!')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E11/\n  endtry\n  bw!\nendfunc\n\nfunc Test_cmdwin_restore()\n  CheckFeature cmdwin\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    augroup vimHints | au! | augroup END\n    call setline(1, range(30))\n    2split\n  [SCRIPT]\n  call writefile(lines, 'XTest_restore')\n\n  let buf = RunVimInTerminal('-S XTest_restore', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"q:\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_1', {})\n\n  \" normal restore\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_2', {})\n\n  \" restore after setting 'lines' with one window\n  call term_sendkeys(buf, \":close\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":set lines=18\\<CR>\")\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_3', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_restore')\nendfunc\n\nfunc Test_cmdwin_no_terminal()\n  CheckFeature cmdwin\n  CheckFeature terminal\n  CheckNotMSWindows\n\n  let buf = RunVimInTerminal('', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":set cmdheight=2\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":let buf = term_start(['/bin/echo'], #{hidden: 1})\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_no_terminal', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_buffers_lastused()\n  \" check that buffers are sorted by time when wildmode has lastused\n  call test_settime(1550020000)\t  \" middle\n  edit bufa\n  enew\n  call test_settime(1550030000)\t  \" newest\n  edit bufb\n  enew\n  call test_settime(1550010000)\t  \" oldest\n  edit bufc\n  enew\n  call test_settime(0)\n  enew\n\n  call assert_equal(['bufa', 'bufb', 'bufc'],\n\t\\ getcompletion('', 'buffer'))\n\n  let save_wildmode = &wildmode\n  set wildmode=full:lastused\n\n  let cap = \"\\<c-r>=execute('let X=getcmdline()')\\<cr>\"\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  edit other\n  call feedkeys(\":b \\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufb', X)\n  call feedkeys(\":b \\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufa', X)\n  call feedkeys(\":b \\<tab>\\<tab>\\<tab>\" .. cap .. \"\\<esc>\", 'xt')\n  call assert_equal('b bufc', X)\n  enew\n\n  let &wildmode = save_wildmode\n\n  bwipeout bufa\n  bwipeout bufb\n  bwipeout bufc\nendfunc\n\nfunc Test_cmdwin_feedkeys()\n  CheckFeature cmdwin\n\n  \" This should not generate E488\n  call feedkeys(\"q:\\<CR>\", 'x')\n  \" Using feedkeys with q: only should automatically close the cmd window\n  call feedkeys('q:', 'xt')\n  call assert_equal(1, winnr('$'))\n  call assert_equal('', getcmdwintype())\nendfunc\n\n\" Tests for the issues fixed in 7.4.441.\n\" When 'cedit' is set to Ctrl-C, opening the command window hangs Vim\nfunc Test_cmdwin_cedit()\n  CheckFeature cmdwin\n\n  exe \"set cedit=\\<C-c>\"\n  normal! :\n  call assert_equal(1, winnr('$'))\n\n  let g:cmd_wintype = ''\n  func CmdWinType()\n      let g:cmd_wintype = getcmdwintype()\n      let g:wintype = win_gettype()\n      return ''\n  endfunc\n\n  call feedkeys(\"\\<C-c>a\\<C-R>=CmdWinType()\\<CR>\\<CR>\")\n  echo input('')\n  call assert_equal('@', g:cmd_wintype)\n  call assert_equal('command', g:wintype)\n\n  set cedit&vim\n  delfunc CmdWinType\nendfunc\n\n\" Test for CmdwinEnter autocmd\nfunc Test_cmdwin_autocmd()\n  CheckFeature cmdwin\n\n  augroup CmdWin\n    au!\n    autocmd BufLeave * if &buftype == '' | update | endif\n    autocmd CmdwinEnter * startinsert\n  augroup END\n\n  call assert_fails('call feedkeys(\"q:xyz\\<CR>\", \"xt\")', 'E492:')\n  call assert_equal('xyz', @:)\n\n  augroup CmdWin\n    au!\n  augroup END\n  augroup! CmdWin\nendfunc\n\nfunc Test_cmdlineclear_tabenter()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    call setline(1, range(30))\n  [SCRIPT]\n\n  call writefile(lines, 'XtestCmdlineClearTabenter')\n  let buf = RunVimInTerminal('-S XtestCmdlineClearTabenter', #{rows: 10})\n  call TermWait(buf, 25)\n  \" in one tab make the command line higher with CTRL-W -\n  call term_sendkeys(buf, \":tabnew\\<cr>\\<C-w>-\\<C-w>-gtgt\")\n  call VerifyScreenDump(buf, 'Test_cmdlineclear_tabenter', {})\n\n  call StopVimInTerminal(buf)\n  call delete('XtestCmdlineClearTabenter')\nendfunc\n\n\" Test for expanding special keywords in cmdline\nfunc Test_cmdline_expand_special()\n  %bwipe!\n  call assert_fails('e #', 'E194:')\n  call assert_fails('e <afile>', 'E495:')\n  call assert_fails('e <abuf>', 'E496:')\n  call assert_fails('e <amatch>', 'E497:')\n\n  call writefile([], 'Xfile.cpp')\n  call writefile([], 'Xfile.java')\n  new Xfile.cpp\n  call feedkeys(\":e %:r\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.cpp Xfile.java', @:)\n  close\n  call delete('Xfile.cpp')\n  call delete('Xfile.java')\nendfunc\n\nfunc Test_cmdwin_jump_to_win()\n  CheckFeature cmdwin\n\n  call assert_fails('call feedkeys(\"q:\\<C-W>\\<C-W>\\<CR>\", \"xt\")', 'E11:')\n  new\n  set modified\n  call assert_fails('call feedkeys(\"q/:qall\\<CR>\", \"xt\")', ['E37:', 'E162:'])\n  close!\n  call feedkeys(\"q/:close\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n  call feedkeys(\"q/:exit\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n\n  \" opening command window twice should fail\n  call assert_beeps('call feedkeys(\"q:q:\\<CR>\\<CR>\", \"xt\")')\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_tabpage()\n  tabedit\n  call assert_fails(\"silent norm q/g\t:I\\<Esc>\", 'E11:')\n  tabclose!\nendfunc\n\nfunc Test_cmdwin_interrupted()\n  CheckFeature cmdwin\n  CheckScreendump\n\n  \" aborting the :smile output caused the cmdline window to use the current\n  \" buffer.\n  let lines =<< trim [SCRIPT]\n    au WinNew * smile\n  [SCRIPT]\n  call writefile(lines, 'XTest_cmdwin')\n\n  let buf = RunVimInTerminal('-S XTest_cmdwin', {'rows': 18})\n  \" open cmdwin\n  call term_sendkeys(buf, \"q:\")\n  call WaitForAssert({-> assert_match('-- More --', term_getline(buf, 18))})\n  \" quit more prompt for :smile command\n  call term_sendkeys(buf, \"q\")\n  call WaitForAssert({-> assert_match('^$', term_getline(buf, 18))})\n  \" execute a simple command\n  call term_sendkeys(buf, \"aecho 'done'\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_interrupted', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('XTest_cmdwin')\nendfunc\n\n\" Test for backtick expression in the command line\nfunc Test_cmd_backtick()\n  %argd\n  argadd `=['a', 'b', 'c']`\n  call assert_equal(['a', 'b', 'c'], argv())\n  %argd\n\n  argadd `echo abc def`\n  call assert_equal(['abc def'], argv())\n  %argd\nendfunc\n\n\" Test for the :! command\nfunc Test_cmd_bang()\n  CheckUnix\n\n  let lines =<< trim [SCRIPT]\n    \" Test for no previous command\n    call assert_fails('!!', 'E34:')\n    set nomore\n    \" Test for cmdline expansion with :!\n    call setline(1, 'foo!')\n    silent !echo <cWORD> > Xfile.out\n    call assert_equal(['foo!'], readfile('Xfile.out'))\n    \" Test for using previous command\n    silent !echo \\! !\n    call assert_equal(['! echo foo!'], readfile('Xfile.out'))\n    call writefile(v:errors, 'Xresult')\n    call delete('Xfile.out')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n  call delete('Xscript')\n  call delete('Xresult')\nendfunc\n\n\" Test error: \"E135: *Filter* Autocommands must not change current buffer\"\nfunc Test_cmd_bang_E135()\n  new\n  call setline(1, ['a', 'b', 'c', 'd'])\n  augroup test_cmd_filter_E135\n    au!\n    autocmd FilterReadPost * help\n  augroup END\n  call assert_fails('2,3!echo \"x\"', 'E135:')\n\n  augroup test_cmd_filter_E135\n    au!\n  augroup END\n  %bwipe!\nendfunc\n\n\" Test for using ~ for home directory in cmdline completion matches\nfunc Test_cmdline_expand_home()\n  call mkdir('Xdir')\n  call writefile([], 'Xdir/Xfile1')\n  call writefile([], 'Xdir/Xfile2')\n  cd Xdir\n  let save_HOME = $HOME\n  let $HOME = getcwd()\n  call feedkeys(\":e ~/\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ~/Xfile1 ~/Xfile2', @:)\n  let $HOME = save_HOME\n  cd ..\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for using CTRL-\\ CTRL-G in the command line to go back to normal mode\n\" or insert mode (when 'insertmode' is set)\nfunc Test_cmdline_ctrl_g()\n  new\n  call setline(1, 'abc')\n  call cursor(1, 3)\n  \" If command line is entered from insert mode, using C-\\ C-G should back to\n  \" insert mode\n  call feedkeys(\"i\\<C-O>:\\<C-\\>\\<C-G>xy\", 'xt')\n  call assert_equal('abxyc', getline(1))\n  call assert_equal(4, col('.'))\n\n  \" If command line is entered in 'insertmode', using C-\\ C-G should back to\n  \" 'insertmode'\n  call feedkeys(\":set im\\<cr>\\<C-L>:\\<C-\\>\\<C-G>12\\<C-L>:set noim\\<cr>\", 'xt')\n  call assert_equal('ab12xyc', getline(1))\n  close!\nendfunc\n\n\" Test for 'wildmode'\nfunc Wildmode_tests()\n  func T(a, c, p)\n    return \"oneA\\noneB\\noneC\"\n  endfunc\n  command -nargs=1 -complete=custom,T MyCmd\n\n  set nowildmenu\n  set wildmode=full,list\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd oneA', @:)\n\n  set wildmode=longest,full\n  call feedkeys(\":MyCmd o\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n  call feedkeys(\":MyCmd o\\t\\t\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneC', @:)\n\n  set wildmode=longest\n  call feedkeys(\":MyCmd one\\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=list:longest\n  let g:Sline = ''\n  call feedkeys(\":MyCmd \\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('oneA  oneB  oneC', g:Sline)\n  call assert_equal('\"MyCmd one', @:)\n\n  set wildmode=\"\"\n  call feedkeys(\":MyCmd \\t\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA', @:)\n\n  \" Test for wildmode=longest with 'fileignorecase' set\n  set wildmode=longest\n  set fileignorecase\n  argadd AAA AAAA AAAAA\n  call feedkeys(\":buffer a\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"buffer AAA', @:)\n  set fileignorecase&\n\n  \" Test for listing files with wildmode=list\n  set wildmode=list\n  let g:Sline = ''\n  call feedkeys(\":b A\\t\\t\\<F4>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('AAA    AAAA   AAAAA', g:Sline)\n  call assert_equal('\"b A', @:)\n\n  \" when using longest completion match, matches shorter than the argument\n  \" should be ignored (happens with :help)\n  set wildmode=longest,full\n  set wildmenu\n  call feedkeys(\":help a*\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"help a', @:)\n  \" non existing file\n  call feedkeys(\":e a1b2y3z4\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e a1b2y3z4', @:)\n  set wildmenu&\n\n  \" Test for longest file name completion with 'fileignorecase'\n  \" On MS-Windows, file names are case insensitive.\n  if has('unix')\n    call writefile([], 'XTESTfoo')\n    call writefile([], 'Xtestbar')\n    set nofileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e XTESTfoo', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtestbar', @:)\n    set fileignorecase\n    call feedkeys(\":e XT\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    call feedkeys(\":e Xt\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n    call assert_equal('\"e Xtest', @:)\n    set fileignorecase&\n    call delete('XTESTfoo')\n    call delete('Xtestbar')\n  endif\n\n  %argdelete\n  delcommand MyCmd\n  delfunc T\n  set wildmode&\n  %bwipe!\nendfunc\n\nfunc Test_wildmode()\n  \" Test with utf-8 encoding\n  call Wildmode_tests()\n\n  \" Test with latin1 encoding\n  let save_encoding = &encoding\n  set encoding=latin1\n  call Wildmode_tests()\n  let &encoding = save_encoding\nendfunc\n\nfunc Test_custom_complete_autoload()\n  call mkdir('Xdir/autoload', 'p')\n  let save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  let lines =<< trim END\n      func vim8#Complete(a, c, p)\n        return \"oneA\\noneB\\noneC\"\n      endfunc\n  END\n  call writefile(lines, 'Xdir/autoload/vim8.vim')\n\n  command -nargs=1 -complete=custom,vim8#Complete MyCmd\n  set nowildmenu\n  set wildmode=full,list\n  call feedkeys(\":MyCmd \\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"MyCmd oneA oneB oneC', @:)\n\n  let &rtp = save_rtp\n  set wildmode& wildmenu&\n  delcommand MyCmd\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for interrupting the command-line completion\nfunc Test_interrupt_compl()\n  func F(lead, cmdl, p)\n    if a:lead =~ 'tw'\n      call interrupt()\n      return\n    endif\n    return \"one\\ntwo\\nthree\"\n  endfunc\n  command -nargs=1 -complete=custom,F Tcmd\n\n  set nowildmenu\n  set wildmode=full\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  let interrupted = 0\n  try\n    call feedkeys(\":Tcmd tw\\<C-d>\\<C-B>\\\"\\<CR>\", 'xt')\n  catch /^Vim:Interrupt$/\n    let interrupted = 1\n  endtry\n  call assert_equal(1, interrupted)\n\n  delcommand Tcmd\n  delfunc F\n  set wildmode&\nendfunc\n\n\" Test for moving the cursor on the : command line\nfunc Test_cmdline_edit()\n  let str = \":one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Left>five\\<Right>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Left>one \"\n  let str ..= \"\\<C-Right> three\"\n  let str ..= \"\\<End>\\<S-Left>four \"\n  let str ..= \"\\<S-Right> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call feedkeys(str, 'xt')\n  call assert_equal(\"\\\"one two three four five six seven\", @:)\nendfunc\n\n\" Test for moving the cursor on the / command line in 'rightleft' mode\nfunc Test_cmdline_edit_rightleft()\n  CheckFeature rightleft\n  set rightleft\n  set rightleftcmd=search\n  let str = \"/one two\\<C-U>\"\n  let str ..= \"one two\\<C-W>\\<C-W>\"\n  let str ..= \"four\\<BS>\\<C-H>\\<Del>\\<kDel>\"\n  let str ..= \"\\<Right>five\\<Left>\"\n  let str ..= \"\\<Home>two \"\n  let str ..= \"\\<C-Right>one \"\n  let str ..= \"\\<C-Left> three\"\n  let str ..= \"\\<End>\\<S-Right>four \"\n  let str ..= \"\\<S-Left> six\"\n  let str ..= \"\\<C-B>\\\"\\<C-E> seven\\<CR>\"\n  call assert_fails(\"call feedkeys(str, 'xt')\", 'E486:')\n  call assert_equal(\"\\\"one two three four five six seven\", @/)\n  set rightleftcmd&\n  set rightleft&\nendfunc\n\n\" Test for using <C-\\>e in the command line to evaluate an expression\nfunc Test_cmdline_expr()\n  \" Evaluate an expression from the beginning of a command line\n  call feedkeys(\":abc\\<C-B>\\<C-\\>e\\\"\\\\\\\"hello\\\"\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"hello', @:)\n\n  \" Use an invalid expression for <C-\\>e\n  call assert_beeps('call feedkeys(\":\\<C-\\>einvalid\\<CR>\", \"tx\")')\n\n  \" Insert literal <CTRL-\\> in the command line\n  call feedkeys(\":\\\"e \\<C-\\>\\<C-Y>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"e \\<C-\\>\\<C-Y>\", @:)\nendfunc\n\n\" This was making the insert position negative\nfunc Test_cmdline_expr_register()\n  exe \"sil! norm! ?\\<C-\\>e0\\<C-R>0\\<Esc>?\\<C-\\>e0\\<CR>\"\nendfunc\n\n\" Test for 'imcmdline' and 'imsearch'\n\" This test doesn't actually test the input method functionality.\nfunc Test_cmdline_inputmethod()\n  new\n  call setline(1, ['', 'abc', ''])\n  set imcmdline\n\n  call feedkeys(\":\\\"abc\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\":\\\"\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal(\"\\\"abc\", @:)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n\n  set imsearch=2\n  call cursor(1, 1)\n  call feedkeys(\"/abc\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  call cursor(1, 1)\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable\n  call feedkeys(\"/\\<C-^>abc\\<C-^>\\<CR>\", 'xt')\n  call assert_equal([2, 1], [line('.'), col('.')])\n  set imdisable&\n  set imsearch&\n\n  set imcmdline&\n  %bwipe!\nendfunc\n\n\" Test for recursively getting multiple command line inputs\nfunc Test_cmdwin_multi_input()\n  CheckFeature cmdwin\n\n  call feedkeys(\":\\<C-R>=input('P: ')\\<CR>\\\"cyan\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"cyan', @:)\nendfunc\n\n\" Test for using CTRL-_ in the command line with 'allowrevins'\nfunc Test_cmdline_revins()\n  CheckNotMSWindows\n  CheckFeature rightleft\n  call feedkeys(\":\\\"abc\\<c-_>\\<cr>\", 'xt')\n  call assert_equal(\"\\\"abc\\<c-_>\", @:)\n  set allowrevins\n  call feedkeys(\":\\\"abc\\<c-_>xyz\\<c-_>\\<CR>\", 'xt')\n  call assert_equal('\"abc\u00f1\u00e8\u00e6', @:)\n  set allowrevins&\nendfunc\n\n\" Test for typing UTF-8 composing characters in the command line\nfunc Test_cmdline_composing_chars()\n  call feedkeys(\":\\\"\\<C-V>u3046\\<C-V>u3099\\<CR>\", 'xt')\n  call assert_equal('\"\u3046\u3099', @:)\nendfunc\n\n\" Test for normal mode commands not supported in the cmd window\nfunc Test_cmdwin_blocked_commands()\n  CheckFeature cmdwin\n\n  call assert_fails('call feedkeys(\"q:\\<C-T>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-]>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-^>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Q\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<F1>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>s\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>v\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>^\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>n\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>o\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>w\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>j\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>k\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>h\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>l\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>T\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>x\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>r\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>R\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>K\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>}\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>]\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>f\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>d\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>g\\<CR>\", \"xt\")', 'E11:')\nendfunc\n\n\" Close the Cmd-line window in insert mode using CTRL-C\nfunc Test_cmdwin_insert_mode_close()\n  CheckFeature cmdwin\n\n  %bw!\n  let s = ''\n  exe \"normal q:a\\<C-C>let s='Hello'\\<CR>\"\n  call assert_equal('Hello', s)\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_ex_mode_with_modifier()\n  \" this was accessing memory after allocated text in Ex mode\n  new\n  call setline(1, ['some', 'text', 'lines'])\n  silent! call feedkeys(\"gQnormal vq:atopleft\\<C-V>\\<CR>\\<CR>\", 'xt')\n  bwipe!\nendfunc\n\n\" test that \";\" works to find a match at the start of the first line\nfunc Test_zero_line_search()\n  new\n  call setline(1, [\"1, pattern\", \"2, \", \"3, pattern\"])\n  call cursor(1,1)\n  0;/pattern/d\n  call assert_equal([\"2, \", \"3, pattern\"], getline(1,'$'))\n  q!\nendfunc\n\nfunc Test_read_shellcmd()\n  CheckUnix\n  if executable('ls')\n    \" There should be ls in the $PATH\n    call feedkeys(\":r! l\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_match('^\"r! .*\\<ls\\>', @:)\n  endif\n\n  if executable('rm')\n    call feedkeys(\":r! ++enc=utf-8 r\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r!.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r!.*\\<rm\\>', @:)\n\n    call feedkeys(\":r ++enc=utf-8 !rm\\<c-a>\\<c-b>\\\"\\<cr>\", 'tx')\n    call assert_notmatch('^\"r.*\\<runtest.vim\\>', @:)\n    call assert_match('^\"r ++enc\\S\\+ !.*\\<rm\\>', @:)\n  endif\nendfunc\n\n\" Test for going up and down the directory tree using 'wildmenu'\nfunc Test_wildmenu_dirstack()\n  CheckUnix\n  %bw!\n  call mkdir('Xdir1/dir2/dir3/dir4', 'p')\n  call writefile([], 'Xdir1/file1_1.txt')\n  call writefile([], 'Xdir1/file1_2.txt')\n  call writefile([], 'Xdir1/dir2/file2_1.txt')\n  call writefile([], 'Xdir1/dir2/file2_2.txt')\n  call writefile([], 'Xdir1/dir2/dir3/file3_1.txt')\n  call writefile([], 'Xdir1/dir2/dir3/file3_2.txt')\n  call writefile([], 'Xdir1/dir2/dir3/dir4/file4_1.txt')\n  call writefile([], 'Xdir1/dir2/dir3/dir4/file4_2.txt')\n  set wildmenu\n\n  cd Xdir1/dir2/dir3/dir4\n  call feedkeys(\":e \\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e file4_1.txt', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Up>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../../dir2/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/', @:)\n  call feedkeys(\":e \\<Tab>\\<Up>\\<Up>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e ../../dir3/dir4/file4_1.txt', @:)\n  cd -\n  call feedkeys(\":e Xdir1/\\<Tab>\\<Down>\\<Down>\\<Down>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xdir1/dir2/dir3/dir4/file4_1.txt', @:)\n\n  call delete('Xdir1', 'rf')\n  set wildmenu&\nendfunc\n\n\" Test for recalling newer or older cmdline from history with <Up>, <Down>,\n\" <S-Up>, <S-Down>, <PageUp>, <PageDown>, <kPageUp>, <kPageDown>, <C-p>, or\n\" <C-n>.\nfunc Test_recalling_cmdline()\n  CheckFeature cmdline_hist\n\n  let g:cmdlines = []\n  cnoremap <Plug>(save-cmdline) <Cmd>let g:cmdlines += [getcmdline()]<CR>\n\n  let histories = [\n  \\  #{name: 'cmd',    enter: ':',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'search', enter: '/',                    exit: \"\\<Esc>\"},\n  \\  #{name: 'expr',   enter: \":\\<C-r>=\",             exit: \"\\<Esc>\\<Esc>\"},\n  \\  #{name: 'input',  enter: \":call input('')\\<CR>\", exit: \"\\<CR>\"},\n  \"\\ TODO: {'name': 'debug', ...}\n  \\]\n  let keypairs = [\n  \\  #{older: \"\\<Up>\",     newer: \"\\<Down>\",     prefixmatch: v:true},\n  \\  #{older: \"\\<S-Up>\",   newer: \"\\<S-Down>\",   prefixmatch: v:false},\n  \\  #{older: \"\\<PageUp>\", newer: \"\\<PageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<kPageUp>\", newer: \"\\<kPageDown>\", prefixmatch: v:false},\n  \\  #{older: \"\\<C-p>\",    newer: \"\\<C-n>\",      prefixmatch: v:false},\n  \\]\n  let prefix = 'vi'\n  for h in histories\n    call histadd(h.name, 'vim')\n    call histadd(h.name, 'virtue')\n    call histadd(h.name, 'Virgo')\n    call histadd(h.name, 'vogue')\n    call histadd(h.name, 'emacs')\n    for k in keypairs\n      let g:cmdlines = []\n      let keyseqs = h.enter\n      \\          .. prefix\n      \\          .. repeat(k.older .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. repeat(k.newer .. \"\\<Plug>(save-cmdline)\", 2)\n      \\          .. h.exit\n      call feedkeys(keyseqs, 'xt')\n      call histdel(h.name, -1) \" delete the history added by feedkeys above\n      let expect = k.prefixmatch\n      \\          ? ['virtue', 'vim',   'virtue', prefix]\n      \\          : ['emacs',  'vogue', 'emacs',  prefix]\n      call assert_equal(expect, g:cmdlines)\n    endfor\n  endfor\n\n  unlet g:cmdlines\n  cunmap <Plug>(save-cmdline)\nendfunc\n\nfunc Test_cmd_map_cmdlineChanged()\n  let g:log = []\n  cnoremap <F1> l<Cmd><CR>s\n  augroup test\n    autocmd!\n    autocmd CmdlineChanged : let g:log += [getcmdline()]\n  augroup END\n\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['l', 'ls'], g:log)\n\n  let @b = 'b'\n  cnoremap <F1> a<C-R>b\n  let g:log = []\n  call feedkeys(\":\\<F1>\\<CR>\", 'xt')\n  call assert_equal(['a', 'ab'], g:log)\n\n  unlet g:log\n  cunmap <F1>\n  augroup test\n    autocmd!\n  augroup END\nendfunc\n\n\" Test for the 'suffixes' option\nfunc Test_suffixes_opt()\n  call writefile([], 'Xfile')\n  call writefile([], 'Xfile.c')\n  call writefile([], 'Xfile.o')\n  set suffixes=\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile Xfile.c Xfile.o', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.c', @:)\n  set suffixes=.c\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile Xfile.o Xfile.c', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.o', @:)\n  set suffixes=,,\n  call feedkeys(\":e Xfi*\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.c Xfile.o Xfile', @:)\n  call feedkeys(\":e Xfi*\\<Tab>\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"e Xfile.o', @:)\n  set suffixes&\n  \" Test for getcompletion() with different patterns\n  call assert_equal(['Xfile', 'Xfile.c', 'Xfile.o'], getcompletion('Xfile', 'file'))\n  call assert_equal(['Xfile'], getcompletion('Xfile$', 'file'))\n  call delete('Xfile')\n  call delete('Xfile.c')\n  call delete('Xfile.o')\nendfunc\n\n\" Test for using a popup menu for the command line completion matches\n\" (wildoptions=pum)\nfunc Test_wildmenu_pum()\n  CheckRunVimInTerminal\n\n  let commands =<< trim [CODE]\n    set wildmenu\n    set wildoptions=pum\n    set shm+=I\n    set noruler\n    set noshowcmd\n\n    func CmdCompl(a, b, c)\n      return repeat(['aaaa'], 120)\n    endfunc\n    command -nargs=* -complete=customlist,CmdCompl Tcmd\n\n    func MyStatusLine() abort\n      return 'status'\n    endfunc\n    func SetupStatusline()\n      set statusline=%!MyStatusLine()\n      set laststatus=2\n    endfunc\n\n    func MyTabLine()\n      return 'my tab line'\n    endfunc\n    func SetupTabline()\n      set statusline=\n      set tabline=%!MyTabLine()\n      set showtabline=2\n    endfunc\n\n    func DoFeedKeys()\n      let &wildcharm = char2nr(\"\\t\")\n      call feedkeys(\":edit $VIMRUNTIME/\\<Tab>\\<Left>\\<C-U>ab\\<Tab>\")\n    endfunc\n  [CODE]\n  call writefile(commands, 'Xtest')\n\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n\n  call term_sendkeys(buf, \":sign \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_01', {})\n\n  \" going down the popup menu using <Down>\n  call term_sendkeys(buf, \"\\<Down>\\<Down>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_02', {})\n\n  \" going down the popup menu using <C-N>\n  call term_sendkeys(buf, \"\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_03', {})\n\n  \" going up the popup menu using <C-P>\n  call term_sendkeys(buf, \"\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_04', {})\n\n  \" going up the popup menu using <Up>\n  call term_sendkeys(buf, \"\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_05', {})\n\n  \" pressing <C-E> should end completion and go back to the original match\n  call term_sendkeys(buf, \"\\<C-E>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_06', {})\n\n  \" pressing <C-Y> should select the current match and end completion\n  call term_sendkeys(buf, \"\\<Tab>\\<C-P>\\<C-P>\\<C-Y>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_07', {})\n\n  \" With 'wildmode' set to 'longest,full', completing a match should display\n  \" the longest match, the wildmenu should not be displayed.\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=longest,full\\<CR>\")\n  call TermWait(buf)\n  call term_sendkeys(buf, \":sign u\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_08', {})\n\n  \" pressing <Tab> should display the wildmenu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_09', {})\n\n  \" pressing <Tab> second time should select the next entry in the menu\n  call term_sendkeys(buf, \"\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_10', {})\n\n  call term_sendkeys(buf, \":\\<C-U>set wildmode=full\\<CR>\")\n  \" showing popup menu in different columns in the cmdline\n  call term_sendkeys(buf, \":sign define \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_11', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_12', {})\n\n  call term_sendkeys(buf, \" \\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_13', {})\n\n  \" Directory name completion\n  call mkdir('Xdir/XdirA/XdirB', 'p')\n  call writefile([], 'Xdir/XfileA')\n  call writefile([], 'Xdir/XdirA/XfileB')\n  call writefile([], 'Xdir/XdirA/XdirB/XfileC')\n\n  call term_sendkeys(buf, \"\\<C-U>e Xdi\\<Tab>\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_14', {})\n\n  \" Pressing <Right> on a directory name should go into that directory\n  call term_sendkeys(buf, \"\\<Right>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_15', {})\n\n  \" Pressing <Left> on a directory name should go to the parent directory\n  call term_sendkeys(buf, \"\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_16', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches but the popup menu should still remain\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-A>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_17', {})\n\n  \" Pressing <C-D> when the popup menu is displayed should remove the popup\n  \" menu\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-D>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_18', {})\n\n  \" Pressing <S-Tab> should open the popup menu with the last entry selected\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<S-Tab>\\<C-P>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_19', {})\n\n  \" Pressing <Esc> should close the popup menu and cancel the cmd line\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>:sign \\<Tab>\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_20', {})\n\n  \" Typing a character when the popup is open, should close the popup\n  call term_sendkeys(buf, \":sign \\<Tab>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_21', {})\n\n  \" When the popup is open, entering the cmdline window should close the popup\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<C-F>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_22', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n\n  \" After the last popup menu item, <C-N> should show the original string\n  call term_sendkeys(buf, \":sign u\\<Tab>\\<C-N>\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_23', {})\n\n  \" Use the popup menu for the command name\n  call term_sendkeys(buf, \"\\<C-U>bu\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_24', {})\n\n  \" Pressing the left arrow should remove the popup menu\n  call term_sendkeys(buf, \"\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_25', {})\n\n  \" Pressing <BS> should remove the popup menu and erase the last character\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<BS>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_26', {})\n\n  \" Pressing <C-W> should remove the popup menu and erase the previous word\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-W>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_27', {})\n\n  \" Pressing <C-U> should remove the popup menu and erase the entire line\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>sign \\<Tab>\\<C-U>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_28', {})\n\n  \" Using <C-E> to cancel the popup menu and then pressing <Up> should recall\n  \" the cmdline from history\n  call term_sendkeys(buf, \"sign xyz\\<Esc>:sign \\<Tab>\\<C-E>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_29', {})\n\n  \" Check \"list\" still works\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=longest,list\\<CR>\")\n  call term_sendkeys(buf, \":cn\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_30', {})\n  call term_sendkeys(buf, \"s\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_31', {})\n\n  \" Tests a directory name contained full-width characters.\n  call mkdir('Xdir/\u3042\u3044\u3046', 'p')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/abc')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/xyz')\n  call writefile([], 'Xdir/\u3042\u3044\u3046/123')\n\n  call term_sendkeys(buf, \"\\<C-U>set wildmode&\\<CR>\")\n  call term_sendkeys(buf, \":\\<C-U>e Xdir/\u3042\u3044\u3046/\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_32', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing a key after that should remove the popup menu\n  call term_sendkeys(buf, \"\\<C-U>set wildmode=full\\<CR>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>x\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_33', {})\n\n  \" Pressing <C-A> when the popup menu is displayed should list all the\n  \" matches and pressing <Left> after that should move the cursor\n  call term_sendkeys(buf, \"\\<C-U>abc\\<Esc>\")\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_34', {})\n\n  \" When <C-A> displays a lot of matches (screen scrolls), all the matches\n  \" should be displayed correctly on the screen.\n  call term_sendkeys(buf, \"\\<End>\\<C-U>Tcmd \\<Tab>\\<C-A>\\<Left>\\<Left>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_35', {})\n\n  \" After using <C-A> to expand all the filename matches, pressing <Up>\n  \" should not open the popup menu again.\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd Xdir/XdirA\\<CR>\")\n  call term_sendkeys(buf, \":e \\<Tab>\\<C-A>\\<Up>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_36', {})\n  call term_sendkeys(buf, \"\\<C-E>\\<C-U>:cd -\\<CR>\")\n\n  \" After using <C-A> to expand all the matches, pressing <S-Tab> used to\n  \" crash Vim\n  call term_sendkeys(buf, \":sign \\<Tab>\\<C-A>\\<S-Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_37', {})\n\n  \" After removing the pum the command line is redrawn\n  call term_sendkeys(buf, \":edit foo\\<CR>\")\n  call term_sendkeys(buf, \":edit bar\\<CR>\")\n  call term_sendkeys(buf, \":ls\\<CR>\")\n  call term_sendkeys(buf, \":com\\<Tab> \")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_38', {})\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n\n  \" Esc still works to abort the command when 'statusline' is set\n  call term_sendkeys(buf, \":call SetupStatusline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_39', {})\n\n  \" Esc still works to abort the command when 'tabline' is set\n  call term_sendkeys(buf, \":call SetupTabline()\\<CR>\")\n  call term_sendkeys(buf, \":si\\<Tab>\")\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_40', {})\n\n  \" popup is cleared also when 'lazyredraw' is set\n  call term_sendkeys(buf, \":set showtabline=1 laststatus=1 lazyredraw\\<CR>\")\n  call term_sendkeys(buf, \":call DoFeedKeys()\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_41', {})\n  call term_sendkeys(buf, \"\\<Esc>\")\n\n  \" Pressing <PageDown> should scroll the menu downward\n  call term_sendkeys(buf, \":sign \\<Tab>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_42', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_43', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_44', {})\n  call term_sendkeys(buf, \"\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_45', {})\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<Down>\\<Down>\\<PageDown>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_46', {})\n\n  \" Pressing <PageUp> should scroll the menu upward\n  call term_sendkeys(buf, \"\\<C-U>sign \\<Tab>\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_47', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_48', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_49', {})\n  call term_sendkeys(buf, \"\\<PageUp>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_50', {})\n\n  call term_sendkeys(buf, \"\\<C-U>\\<CR>\")\n  call StopVimInTerminal(buf)\n  call delete('Xtest')\n  call delete('Xdir', 'rf')\nendfunc\n\n\" Test for wildmenumode() with the cmdline popup menu\nfunc Test_wildmenumode_with_pum()\n  set wildmenu\n  set wildoptions=pum\n  cnoremap <expr> <F2> wildmenumode()\n  call feedkeys(\":sign \\<Tab>\\<F2>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define10', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-A>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define jump list place undefine unplace0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-E>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign 0', @:)\n  call feedkeys(\":sign \\<Tab>\\<C-Y>\\<F2>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"sign define0', @:)\n  set nowildmenu wildoptions&\n  cunmap <F2>\nendfunc\n\nfunc Test_wildmenu_with_pum_foldexpr()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n      call setline(1, ['folded one', 'folded two', 'some more text'])\n      func MyFoldText()\n        return 'foo'\n      endfunc\n      set foldtext=MyFoldText() wildoptions=pum\n      normal ggzfj\n  END\n  call writefile(lines, 'Xpumfold')\n  let buf = RunVimInTerminal('-S Xpumfold', #{rows: 10})\n  call term_sendkeys(buf, \":set\\<Tab>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_wildmenu_with_pum_foldexpr_2', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xpumfold')\nendfunc\n\n\" Test for opening the cmdline completion popup menu from the terminal window.\n\" The popup menu should be positioned correctly over the status line of the\n\" bottom-most window.\nfunc Test_wildmenu_pum_from_terminal()\n  CheckRunVimInTerminal\n  let python = PythonProg()\n  call CheckPython(python)\n\n  %bw!\n  let cmds = ['set wildmenu wildoptions=pum']\n  let pcmd = python .. ' -c \"import sys; sys.stdout.write(sys.stdin.read())\"'\n  call add(cmds, \"call term_start('\" .. pcmd .. \"')\")\n  call writefile(cmds, 'Xtest')\n  let buf = RunVimInTerminal('-S Xtest', #{rows: 10})\n  call term_sendkeys(buf, \"\\r\\r\\r\")\n  call term_wait(buf)\n  call term_sendkeys(buf, \"\\<C-W>:sign \\<Tab>\")\n  call term_wait(buf)\n  call VerifyScreenDump(buf, 'Test_wildmenu_pum_term_01', {})\n  call term_wait(buf)\n  call StopVimInTerminal(buf)\n  call delete('Xtest')\nendfunc\n\n\" Test for completion after a :substitute command followed by a pipe (|)\n\" character\nfunc Test_cmdline_complete_substitute()\n  call feedkeys(\":s | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s | \\t\", @:)\n  call feedkeys(\":s/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/ | \\t\", @:)\n  call feedkeys(\":s/one | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one | \\t\", @:)\n  call feedkeys(\":s/one/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/ | \\t\", @:)\n  call feedkeys(\":s/one/two | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two | \\t\", @:)\n  call feedkeys(\":s/one/two/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/two/ | chistory', @:)\n  call feedkeys(\":s/one/two/g \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g \\t\", @:)\n  call feedkeys(\":s/one/two/g | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/two/g | chistory\", @:)\n  call feedkeys(\":s/one/t\\\\/ | \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"s/one/t\\\\/ | \\t\", @:)\n  call feedkeys(\":s/one/t\\\"o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t\"o/ | chistory', @:)\n  call feedkeys(\":s/one/t|o/ | chist\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal('\"s/one/t|o/ | chistory', @:)\n  call feedkeys(\":&\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"&\\t\", @:)\nendfunc\n\n\" Test for the :dlist command completion\nfunc Test_cmdline_complete_dlist()\n  call feedkeys(\":dlist 10 /pat/ a\\<C-A>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ a\\<C-A>\", @:)\n  call feedkeys(\":dlist 10 /pat/ \\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ \\t\", @:)\n  call feedkeys(\":dlist 10 /pa\\\\t/\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pa\\\\t/\\t\", @:)\n  call feedkeys(\":dlist 10 /pat\\\\\\t\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat\\\\\\t\", @:)\n  call feedkeys(\":dlist 10 /pat/ | chist\\<Tab>\\<C-B>\\\"\\<CR>\", 'xt')\n  call assert_equal(\"\\\"dlist 10 /pat/ | chistory\", @:)\nendfunc\n\n\" argument list (only for :argdel) fuzzy completion\nfunc Test_fuzzy_completion_arglist()\n  argadd change.py count.py charge.py\n  set wildoptions&\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel cge', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"argdel change.py charge.py', @:)\n  %argdelete\n  set wildoptions&\nendfunc\n\n\" autocmd group name fuzzy completion\nfunc Test_fuzzy_completion_autocmd()\n  set wildoptions&\n  augroup MyFuzzyGroup\n  augroup END\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup mfg', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup MyFuzzyGroup', @:)\n  call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"augroup My*p', @:)\n  augroup! MyFuzzyGroup\n  set wildoptions&\nendfunc\n\n\" buffer name fuzzy completion\nfunc Test_fuzzy_completion_bufname()\n  set wildoptions&\n  edit SomeFile.txt\n  enew\n  call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SF', @:)\n  call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeFile.txt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b SomeFile.txt', @:)\n  call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b S*File.txt', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" buffer name (full path) fuzzy completion\nfunc Test_fuzzy_completion_bufname_fullpath()\n  CheckUnix\n  set wildoptions&\n  call mkdir('Xcmd/Xstate/Xfile.js', 'p')\n  edit Xcmd/Xstate/Xfile.js\n  cd Xcmd/Xstate\n  enew\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"b CmdStateFile', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('Xcmd/Xstate/Xfile.js$', @:)\n  cd -\n  call delete('Xcmd', 'rf')\n  set wildoptions&\nendfunc\n\n\" :behave suboptions fuzzy completion\nfunc Test_fuzzy_completion_behave()\n  set wildoptions&\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xterm', @:)\n  call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"behave xt*m', @:)\n  let g:Sline = ''\n  call feedkeys(\":behave win\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('mswin', g:Sline)\n  call assert_equal('\"behave win', @:)\n  set wildoptions&\nendfunc\n\n\" \" colorscheme name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_colorscheme()\n\" endfunc\n\n\" built-in command name fuzzy completion\nfunc Test_fuzzy_completion_cmdname()\n  set wildoptions&\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbwin', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbrewind', @:)\n  call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sbr*d', @:)\n  set wildoptions&\nendfunc\n\n\" \" compiler name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_compiler()\n\" endfunc\n\n\" :cscope suboptions fuzzy completion\nfunc Test_fuzzy_completion_cscope()\n  CheckFeature cscope\n  set wildoptions&\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope ret', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope reset', @:)\n  call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"cscope re*t', @:)\n  set wildoptions&\nendfunc\n\n\" :diffget/:diffput buffer name fuzzy completion\nfunc Test_fuzzy_completion_diff()\n  new SomeBuffer\n  diffthis\n  new OtherBuffer\n  diffthis\n  set wildoptions&\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget sbuf', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput sbuf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget SomeBuffer', @:)\n  call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput SomeBuffer', @:)\n  %bw!\n  set wildoptions&\nendfunc\n\n\" \" directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_dirname()\n\" endfunc\n\n\" environment variable name fuzzy completion\nfunc Test_fuzzy_completion_env()\n  set wildoptions&\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VUT', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"echo $VIMRUNTIME', @:)\n  set wildoptions&\nendfunc\n\n\" autocmd event fuzzy completion\nfunc Test_fuzzy_completion_autocmd_event()\n  set wildoptions&\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BWout', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"autocmd BufWipeout', @:)\n  set wildoptions&\nendfunc\n\n\" vim expression fuzzy completion\nfunc Test_fuzzy_completion_expr()\n  let g:PerPlaceCount = 10\n  set wildoptions&\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = ppc', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let c = PerPlaceCount', @:)\n  set wildoptions&\nendfunc\n\n\" \" file name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filename()\n\" endfunc\n\n\" \" files in path fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filesinpath()\n\" endfunc\n\n\" \" filetype name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_filetype()\n\" endfunc\n\n\" user defined function name completion\nfunc Test_fuzzy_completion_userdefined_func()\n  set wildoptions&\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_f_u_f', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":call Test_f_u_f\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"call Test_fuzzy_completion_userdefined_func()', @:)\n  set wildoptions&\nendfunc\n\n\" <SNR> functions should be sorted to the end\nfunc Test_fuzzy_completion_userdefined_snr_func()\n  func s:Sendmail()\n  endfunc\n  func SendSomemail()\n  endfunc\n  func S1e2n3dmail()\n  endfunc\n  set wildoptions=fuzzy\n  call feedkeys(\":call sendmail\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match('\"call SendSomemail() S1e2n3dmail() <SNR>\\d\\+_Sendmail()', @:)\n  set wildoptions&\n  delfunc s:Sendmail\n  delfunc SendSomemail\n  delfunc S1e2n3dmail\nendfunc\n\n\" user defined command name completion\nfunc Test_fuzzy_completion_userdefined_cmd()\n  set wildoptions&\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MsFeat', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"MissingFeature', @:)\n  set wildoptions&\nendfunc\n\n\" \" :help tag fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_helptag()\n\" endfunc\n\n\" highlight group name fuzzy completion\nfunc Test_fuzzy_completion_hlgroup()\n  set wildoptions&\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight SpecialKey', @:)\n  call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"highlight Sp*Key', @:)\n  set wildoptions&\nendfunc\n\n\" :history suboptions fuzzy completion\nfunc Test_fuzzy_completion_history()\n  set wildoptions&\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history dg', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history search', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history debug', @:)\n  call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"history se*h', @:)\n  set wildoptions&\nendfunc\n\n\" :language locale name fuzzy completion\nfunc Test_fuzzy_completion_lang()\n  CheckUnix\n  set wildoptions&\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang psx', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"lang POSIX', @:)\n  set wildoptions&\nendfunc\n\n\" :mapclear buffer argument fuzzy completion\nfunc Test_fuzzy_completion_mapclear()\n  set wildoptions&\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear buf', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"mapclear <buffer>', @:)\n  set wildoptions&\nendfunc\n\n\" map name fuzzy completion\nfunc Test_fuzzy_completion_mapname()\n  \" test regex completion works\n  set wildoptions=fuzzy\n  call feedkeys(\":cnoremap <ex\\<Tab> <esc> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"cnoremap <expr> <esc> \\<Tab>\", @:)\n  nmap <plug>MyLongMap :p<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  call feedkeys(\":nmap MLM \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap MLM \\t\", @:)\n  call feedkeys(\":nmap <F2> one two \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <F2> one two \\t\", @:)\n  \" duplicate entries should be removed\n  vmap <plug>MyLongMap :<C-U>#<CR>\n  call feedkeys(\":nmap MLM\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>MyLongMap\", @:)\n  nunmap <plug>MyLongMap\n  vunmap <plug>MyLongMap\n  call feedkeys(\":nmap ABC\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap ABC\\t\", @:)\n  \" results should be sorted by best match\n  nmap <Plug>format :\n  nmap <Plug>goformat :\n  nmap <Plug>TestFOrmat :\n  nmap <Plug>fendoff :\n  nmap <Plug>state :\n  nmap <Plug>FendingOff :\n  call feedkeys(\":nmap <Plug>fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"nmap <Plug>format <Plug>TestFOrmat <Plug>FendingOff <Plug>goformat <Plug>fendoff\", @:)\n  nunmap <Plug>format\n  nunmap <Plug>goformat\n  nunmap <Plug>TestFOrmat\n  nunmap <Plug>fendoff\n  nunmap <Plug>state\n  nunmap <Plug>FendingOff\n  set wildoptions&\nendfunc\n\n\" abbreviation fuzzy completion\nfunc Test_fuzzy_completion_abbr()\n  set wildoptions=fuzzy\n  call feedkeys(\":iabbr wait\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr <nowait>\", @:)\n  iabbr WaitForCompletion WFC\n  call feedkeys(\":iabbr fcl\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr WaitForCompletion\", @:)\n  call feedkeys(\":iabbr a1z\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"iabbr a1z\\t\", @:)\n  iunabbrev WaitForCompletion\n  set wildoptions&\nendfunc\n\n\" menu name fuzzy completion\nfunc Test_fuzzy_completion_menu()\n  CheckGui\n  set wildoptions&\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu pup', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"menu PopUp.', @:)\n  set wildoptions&\nendfunc\n\n\" :messages suboptions fuzzy completion\nfunc Test_fuzzy_completion_messages()\n  set wildoptions&\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"messages clear', @:)\n  set wildoptions&\nendfunc\n\n\" :set option name fuzzy completion\nfunc Test_fuzzy_completion_option()\n  set wildoptions&\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set brkopt', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set breakindentopt', @:)\n  set wildoptions&\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set fixendofline', @:)\n  set wildoptions&\nendfunc\n\n\" :set <term_option>\nfunc Test_fuzzy_completion_term_option()\n  set wildoptions&\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set t_EC', @:)\n  call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"set <t_EC>', @:)\n  set wildoptions&\nendfunc\n\n\" \" :packadd directory name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_packadd()\n\" endfunc\n\n\" \" shell command name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_shellcmd()\n\" endfunc\n\n\" :sign suboptions fuzzy completion\nfunc Test_fuzzy_completion_sign()\n  set wildoptions&\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign ufe', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"sign undefine', @:)\n  set wildoptions&\nendfunc\n\n\" :syntax suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntax_cmd()\n  set wildoptions&\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax kwd', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax keyword', @:)\n  set wildoptions&\nendfunc\n\n\" syntax group name fuzzy completion\nfunc Test_fuzzy_completion_syntax_group()\n  set wildoptions&\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list mpar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntax list MatchParen', @:)\n  set wildoptions&\nendfunc\n\n\" :syntime suboptions fuzzy completion\nfunc Test_fuzzy_completion_syntime()\n  CheckFeature profile\n  set wildoptions&\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clr', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"syntime clear', @:)\n  set wildoptions&\nendfunc\n\n\" \" tag name fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagname()\n\" endfunc\n\n\" \" tag name and file fuzzy completion - NOT supported\n\" func Test_fuzzy_completion_tagfile()\n\" endfunc\n\n\" \" user names fuzzy completion - how to test this functionality?\n\" func Test_fuzzy_completion_username()\n\" endfunc\n\n\" user defined variable name fuzzy completion\nfunc Test_fuzzy_completion_userdefined_var()\n  let g:SomeVariable=10\n  set wildoptions&\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SVar', @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"let SomeVariable', @:)\n  set wildoptions&\nendfunc\n\n\" Test for sorting the results by the best match\nfunc Test_fuzzy_completion_cmd_sort_results()\n  %bw!\n  command T123format :\n  command T123goformat :\n  command T123TestFOrmat :\n  command T123fendoff :\n  command T123state :\n  command T123FendingOff :\n  set wildoptions=fuzzy\n  call feedkeys(\":T123fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"T123format T123TestFOrmat T123FendingOff T123goformat T123fendoff', @:)\n  delcommand T123format\n  delcommand T123goformat\n  delcommand T123TestFOrmat\n  delcommand T123fendoff\n  delcommand T123state\n  delcommand T123FendingOff\n  %bw\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion of a command with lower case letters and a number\nfunc Test_fuzzy_completion_cmd_alnum()\n  command Foo2Bar :\n  set wildoptions=fuzzy\n  call feedkeys(\":foo2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":foo\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  call feedkeys(\":bar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"Foo2Bar', @:)\n  delcommand Foo2Bar\n  set wildoptions&\nendfunc\n\n\" Test for command completion for a command starting with 'k'\nfunc Test_fuzzy_completion_cmd_k()\n  command KillKillKill :\n  set wildoptions&\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"killkill\\<Tab>\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":killkill\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"KillKillKill', @:)\n  delcom KillKillKill\n  set wildoptions&\nendfunc\n\n\" Test for fuzzy completion for user defined custom completion function\nfunc Test_fuzzy_completion_custom_func()\n  func Tcompl(a, c, p)\n    return \"format\\ngoformat\\nTestFOrmat\\nfendoff\\nstate\"\n  endfunc\n  command -nargs=* -complete=custom,Tcompl Fuzzy :\n  set wildoptions&\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy ttt\", @:)\n  set wildoptions=fuzzy\n  call feedkeys(\":Fuzzy \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format goformat TestFOrmat fendoff state\", @:)\n  call feedkeys(\":Fuzzy fo\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy format TestFOrmat goformat fendoff\", @:)\n  call feedkeys(\":Fuzzy xy\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy xy\", @:)\n  call feedkeys(\":Fuzzy ttt\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"Fuzzy TestFOrmat\", @:)\n  delcom Fuzzy\n  set wildoptions&\nendfunc\n\n\" Test for :breakadd argument completion\nfunc Test_cmdline_complete_breakadd()\n  call feedkeys(\":breakadd \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr file func here\", @:)\n  call feedkeys(\":breakadd \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr\", @:)\n  call feedkeys(\":breakadd    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr\", @:)\n  call feedkeys(\":breakadd he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here\", @:)\n  call feedkeys(\":breakadd    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    here\", @:)\n  call feedkeys(\":breakadd abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd abc\", @:)\n  call assert_equal(['expr', 'file', 'func', 'here'], getcompletion('', 'breakpoint'))\n  let l = getcompletion('not', 'breakpoint')\n  call assert_equal([], l)\n\n  \" Test for :breakadd file [lnum] <file>\n  call writefile([], 'Xscript')\n  call feedkeys(\":breakadd file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript\", @:)\n  call feedkeys(\":breakadd   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   Xscript\", @:)\n  call feedkeys(\":breakadd file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20 Xscript\", @:)\n  call feedkeys(\":breakadd   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   file   20   Xscript\", @:)\n  call feedkeys(\":breakadd file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakadd file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20\\t\", @:)\n  call feedkeys(\":breakadd file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file 20x\\t\", @:)\n  call feedkeys(\":breakadd file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file Xscript  \", @:)\n  call feedkeys(\":breakadd file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd file X1B2C3\", @:)\n  call delete('Xscript')\n\n  \" Test for :breakadd func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakadd func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func\", @:)\n  call feedkeys(\":breakadd    func    Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    func    Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakadd   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakadd func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakadd func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20\\t\", @:)\n  call feedkeys(\":breakadd func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func 20x\\t\", @:)\n  call feedkeys(\":breakadd func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func Xbreak_func  \", @:)\n  call feedkeys(\":breakadd func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakadd expr <expression>\n  let g:Xtest_var = 10\n  call feedkeys(\":breakadd expr Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var\", @:)\n  call feedkeys(\":breakadd    expr    Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd    expr    Xtest_var\", @:)\n  call feedkeys(\":breakadd expr Xtest_var  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr Xtest_var  \", @:)\n  call feedkeys(\":breakadd expr X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd expr X1B2C3\", @:)\n  unlet g:Xtest_var\n\n  \" Test for :breakadd here\n  call feedkeys(\":breakadd here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here Xtest\", @:)\n  call feedkeys(\":breakadd   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd   here   Xtest\", @:)\n  call feedkeys(\":breakadd here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakadd here \", @:)\nendfunc\n\n\" Test for :breakdel argument completion\nfunc Test_cmdline_complete_breakdel()\n  call feedkeys(\":breakdel \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file func here\", @:)\n  call feedkeys(\":breakdel \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file\", @:)\n  call feedkeys(\":breakdel    \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    file\", @:)\n  call feedkeys(\":breakdel he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here\", @:)\n  call feedkeys(\":breakdel    he\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel    here\", @:)\n  call feedkeys(\":breakdel abc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel abc\", @:)\n\n  \" Test for :breakdel file [lnum] <file>\n  call writefile([], 'Xscript')\n  call feedkeys(\":breakdel file Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript\", @:)\n  call feedkeys(\":breakdel   file   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   Xscript\", @:)\n  call feedkeys(\":breakdel file 20 Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20 Xscript\", @:)\n  call feedkeys(\":breakdel   file   20   Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   file   20   Xscript\", @:)\n  call feedkeys(\":breakdel file 20x Xsc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x Xsc\\t\", @:)\n  call feedkeys(\":breakdel file 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20\\t\", @:)\n  call feedkeys(\":breakdel file 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file 20x\\t\", @:)\n  call feedkeys(\":breakdel file Xscript  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file Xscript  \", @:)\n  call feedkeys(\":breakdel file X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel file X1B2C3\", @:)\n  call delete('Xscript')\n\n  \" Test for :breakdel func [lnum] <function>\n  func Xbreak_func()\n  endfunc\n  call feedkeys(\":breakdel func Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20 Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20 Xbreak_func\", @:)\n  call feedkeys(\":breakdel   func   20   Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   func   20   Xbreak_func\", @:)\n  call feedkeys(\":breakdel func 20x Xbr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x Xbr\\t\", @:)\n  call feedkeys(\":breakdel func 20\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20\\t\", @:)\n  call feedkeys(\":breakdel func 20x\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func 20x\\t\", @:)\n  call feedkeys(\":breakdel func Xbreak_func  \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func Xbreak_func  \", @:)\n  call feedkeys(\":breakdel func X1B2C3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel func X1B2C3\", @:)\n  delfunc Xbreak_func\n\n  \" Test for :breakdel here\n  call feedkeys(\":breakdel here Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here Xtest\", @:)\n  call feedkeys(\":breakdel   here   Xtest\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel   here   Xtest\", @:)\n  call feedkeys(\":breakdel here \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"breakdel here \", @:)\nendfunc\n\n\" Test for :scriptnames argument completion\nfunc Test_cmdline_complete_scriptnames()\n  set wildmenu\n  call writefile(['let a = 1'], 'Xa1b2c3.vim')\n  source Xa1b2c3.vim\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script    \\<Tab>\\<Left>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim$\", @:)\n  call feedkeys(\":script b2c3\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script b2c3\", @:)\n  call feedkeys(\":script 2\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script 2\\<Tab>$\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left> \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_match(\"\\\"script .*Xa1b2c3.vim $\", @:)\n  call feedkeys(\":script \\<Tab>\\<Left>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal(\"\\\"script \", @:)\n  call assert_match('Xa1b2c3.vim$', getcompletion('.*Xa1b2.*', 'scriptnames')[0])\n  call assert_equal([], getcompletion('Xa1b2', 'scriptnames'))\n  new\n  call feedkeys(\":script \\<Tab>\\<Left>\\<Left>\\<CR>\", 'tx')\n  call assert_equal('Xa1b2c3.vim', fnamemodify(@%, ':t'))\n  bw!\n  call delete('Xa1b2c3.vim')\n  set wildmenu&\nendfunc\n\n\" this was going over the end of IObuff\nfunc Test_report_error_with_composing()\n  let caught = 'no'\n  try\n    exe repeat('0', 987) .. \"0\\xdd\\x80\\xdd\\x80\\xdd\\x80\\xdd\\x80\"\n  catch /E492:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\n\" Test for expanding 2-letter and 3-letter :substitute command arguments.\n\" These commands don't accept an argument.\nfunc Test_cmdline_complete_substitute_short()\n  for cmd in ['sc', 'sce', 'scg', 'sci', 'scI', 'scn', 'scp', 'scl',\n        \\ 'sgc', 'sge', 'sg', 'sgi', 'sgI', 'sgn', 'sgp', 'sgl', 'sgr',\n        \\ 'sic', 'sie', 'si', 'siI', 'sin', 'sip', 'sir',\n        \\ 'sIc', 'sIe', 'sIg', 'sIi', 'sI', 'sIn', 'sIp', 'sIl', 'sIr',\n        \\ 'src', 'srg', 'sri', 'srI', 'srn', 'srp', 'srl', 'sr']\n    call feedkeys(':' .. cmd .. \" \\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')\n    call assert_equal('\"' .. cmd .. \" \\<Tab>\", @:)\n  endfor\nendfunc\n\nfunc Check_completion()\n  call assert_equal('let a', getcmdline())\n  call assert_equal(6, getcmdpos())\n  call assert_equal(7, getcmdscreenpos())\n  call assert_equal('var', getcmdcompltype())\n  return ''\nendfunc\n\nfunc Test_screenpos_and_completion()\n  call feedkeys(\":let a\\<C-R>=Check_completion()\\<CR>\\<Esc>\", \"xt\")\nendfunc\n\nfunc Test_recursive_register()\n  let @= = ''\n  silent! ?\u001ce\u0012/\n  let caught = 'no'\n  try\n    normal /\u0012/ \n  catch /E169:/\n    let caught = 'yes'\n  endtry\n  call assert_equal('yes', caught)\nendfunc\n\nfunc Test_long_error_message()\n  \" the error should be truncated, not overrun IObuff\n  silent! norm Q00000000000000\u00a0\u00a0\u00a0\u00a0\u00a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ex_docmd.c", "src/testdir/test_cmdline.vim", "src/version.c"], "buggy_code_start_loc": [3121, 2103, 737], "buggy_code_end_loc": [3124, 2103, 737], "fixing_code_start_loc": [3121, 2104, 738], "fixing_code_end_loc": [3126, 2112, 740], "type": "CWE-787", "message": "Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.", "other": {"cve": {"id": "CVE-2022-2288", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-03T13:15:07.920", "lastModified": "2023-05-03T12:15:55.943", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Out-of-bounds Write in GitHub repository vim/vim prior to 9.0."}, {"lang": "es", "value": "Una Escritura Fuera de L\u00edmites en el repositorio de GitHub vim/vim versiones anteriores a 9.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0025", "matchCriteriaId": "68FFD594-F28E-48D7-B47E-CB4BB5D182A8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/c6fdb15d423df22e1776844811d082322475e48a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a71bdcb7-4e9b-4650-ab6a-fe8e3e9852ad", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/43Y3VJPOTTY3NTREDIFUPITM2POG4ZLP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UXPO5EHDV6J4B27E65DOQGZFELUFPRSK/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/c6fdb15d423df22e1776844811d082322475e48a"}}