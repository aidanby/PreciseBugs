{"buggy_code": ["# This configuration file is for the **development** setup.\n# For a production example please refer to getredash/setup repository on GitHub.\nversion: \"2.2\"\nx-redash-service: &redash-service\n  build:\n    context: .\n    args:\n      skip_frontend_build: \"true\"\n  volumes:\n    - .:/app\nx-redash-environment: &redash-environment\n  REDASH_LOG_LEVEL: \"INFO\"\n  REDASH_REDIS_URL: \"redis://redis:6379/0\"\n  REDASH_DATABASE_URL: \"postgresql://postgres@postgres/postgres\"\n  REDASH_RATELIMIT_ENABLED: \"false\"\n  REDASH_MAIL_DEFAULT_SENDER: \"redash@example.com\"\n  REDASH_MAIL_SERVER: \"email\"\n  REDASH_ENFORCE_CSRF: \"true\"\nservices:\n  server:\n    <<: *redash-service\n    command: dev_server\n    depends_on:\n      - postgres\n      - redis\n    ports:\n      - \"5000:5000\"\n      - \"5678:5678\"\n    environment:\n      <<: *redash-environment\n      PYTHONUNBUFFERED: 0\n  scheduler:\n    <<: *redash-service\n    command: dev_scheduler\n    depends_on:\n      - server\n    environment:\n      <<: *redash-environment\n  worker:\n    <<: *redash-service\n    command: dev_worker\n    depends_on:\n      - server\n    environment:\n      <<: *redash-environment\n      PYTHONUNBUFFERED: 0\n  redis:\n    image: redis:3-alpine\n    restart: unless-stopped\n  postgres:\n    image: postgres:9.5-alpine\n    # The following turns the DB into less durable, but gains significant performance improvements for the tests run (x3\n    # improvement on my personal machine). We should consider moving this into a dedicated Docker Compose configuration for\n    # tests.\n    ports:\n      - \"15432:5432\"\n    command: \"postgres -c fsync=off -c full_page_writes=off -c synchronous_commit=OFF\"\n    restart: unless-stopped\n    environment:\n      POSTGRES_HOST_AUTH_METHOD: \"trust\"\n  email:\n    image: djfarrelly/maildev\n    ports:\n      - \"1080:80\"\n    restart: unless-stopped\n", "import os\nimport importlib\nimport ssl\nfrom funcy import distinct, remove\nfrom flask_talisman import talisman\n\nfrom .helpers import (\n    fix_assets_path,\n    array_from_string,\n    parse_boolean,\n    int_or_none,\n    set_from_string,\n    add_decode_responses_to_redis_url,\n    cast_int_or_default\n)\nfrom .organization import DATE_FORMAT, TIME_FORMAT  # noqa\n\n# _REDIS_URL is the unchanged REDIS_URL we get from env vars, to be used later with RQ\n_REDIS_URL = os.environ.get(\n    \"REDASH_REDIS_URL\", os.environ.get(\"REDIS_URL\", \"redis://localhost:6379/0\")\n)\n# This is the one to use for Redash' own connection:\nREDIS_URL = add_decode_responses_to_redis_url(_REDIS_URL)\nPROXIES_COUNT = int(os.environ.get(\"REDASH_PROXIES_COUNT\", \"1\"))\n\nSTATSD_HOST = os.environ.get(\"REDASH_STATSD_HOST\", \"127.0.0.1\")\nSTATSD_PORT = int(os.environ.get(\"REDASH_STATSD_PORT\", \"8125\"))\nSTATSD_PREFIX = os.environ.get(\"REDASH_STATSD_PREFIX\", \"redash\")\nSTATSD_USE_TAGS = parse_boolean(os.environ.get(\"REDASH_STATSD_USE_TAGS\", \"false\"))\n\n# Connection settings for Redash's own database (where we store the queries, results, etc)\nSQLALCHEMY_DATABASE_URI = os.environ.get(\n    \"REDASH_DATABASE_URL\", os.environ.get(\"DATABASE_URL\", \"postgresql:///postgres\")\n)\nSQLALCHEMY_MAX_OVERFLOW = int_or_none(os.environ.get(\"SQLALCHEMY_MAX_OVERFLOW\"))\nSQLALCHEMY_POOL_SIZE = int_or_none(os.environ.get(\"SQLALCHEMY_POOL_SIZE\"))\nSQLALCHEMY_DISABLE_POOL = parse_boolean(\n    os.environ.get(\"SQLALCHEMY_DISABLE_POOL\", \"false\")\n)\nSQLALCHEMY_ENABLE_POOL_PRE_PING = parse_boolean(\n    os.environ.get(\"SQLALCHEMY_ENABLE_POOL_PRE_PING\", \"false\")\n)\nSQLALCHEMY_TRACK_MODIFICATIONS = False\nSQLALCHEMY_ECHO = False\n\nRQ_REDIS_URL = os.environ.get(\"RQ_REDIS_URL\", _REDIS_URL)\n\n# The following enables periodic job (every 5 minutes) of removing unused query results.\nQUERY_RESULTS_CLEANUP_ENABLED = parse_boolean(\n    os.environ.get(\"REDASH_QUERY_RESULTS_CLEANUP_ENABLED\", \"true\")\n)\nQUERY_RESULTS_CLEANUP_COUNT = int(\n    os.environ.get(\"REDASH_QUERY_RESULTS_CLEANUP_COUNT\", \"100\")\n)\nQUERY_RESULTS_CLEANUP_MAX_AGE = int(\n    os.environ.get(\"REDASH_QUERY_RESULTS_CLEANUP_MAX_AGE\", \"7\")\n)\n\nSCHEMAS_REFRESH_SCHEDULE = int(os.environ.get(\"REDASH_SCHEMAS_REFRESH_SCHEDULE\", 30))\n\nAUTH_TYPE = os.environ.get(\"REDASH_AUTH_TYPE\", \"api_key\")\nINVITATION_TOKEN_MAX_AGE = int(\n    os.environ.get(\"REDASH_INVITATION_TOKEN_MAX_AGE\", 60 * 60 * 24 * 7)\n)\n\n# The secret key to use in the Flask app for various cryptographic features\nSECRET_KEY = os.environ.get(\"REDASH_COOKIE_SECRET\", \"c292a0a3aa32397cdb050e233733900f\")\n# The secret key to use when encrypting data source options\nDATASOURCE_SECRET_KEY = os.environ.get(\"REDASH_SECRET_KEY\", SECRET_KEY)\n\n# Whether and how to redirect non-HTTP requests to HTTPS. Disabled by default.\nENFORCE_HTTPS = parse_boolean(os.environ.get(\"REDASH_ENFORCE_HTTPS\", \"false\"))\nENFORCE_HTTPS_PERMANENT = parse_boolean(\n    os.environ.get(\"REDASH_ENFORCE_HTTPS_PERMANENT\", \"false\")\n)\n# Whether file downloads are enforced or not.\nENFORCE_FILE_SAVE = parse_boolean(os.environ.get(\"REDASH_ENFORCE_FILE_SAVE\", \"true\"))\n\n# Whether api calls using the json query runner will block private addresses\nENFORCE_PRIVATE_ADDRESS_BLOCK = parse_boolean(\n    os.environ.get(\"REDASH_ENFORCE_PRIVATE_IP_BLOCK\", \"true\")\n)\n\n# Whether to use secure cookies by default.\nCOOKIES_SECURE = parse_boolean(\n    os.environ.get(\"REDASH_COOKIES_SECURE\", str(ENFORCE_HTTPS))\n)\n# Whether the session cookie is set to secure.\nSESSION_COOKIE_SECURE = parse_boolean(\n    os.environ.get(\"REDASH_SESSION_COOKIE_SECURE\") or str(COOKIES_SECURE)\n)\n# Whether the session cookie is set HttpOnly.\nSESSION_COOKIE_HTTPONLY = parse_boolean(\n    os.environ.get(\"REDASH_SESSION_COOKIE_HTTPONLY\", \"true\")\n)\nSESSION_EXPIRY_TIME = int(os.environ.get(\"REDASH_SESSION_EXPIRY_TIME\", 60 * 60 * 6))\n\n# Whether the session cookie is set to secure.\nREMEMBER_COOKIE_SECURE = parse_boolean(\n    os.environ.get(\"REDASH_REMEMBER_COOKIE_SECURE\") or str(COOKIES_SECURE)\n)\n# Whether the remember cookie is set HttpOnly.\nREMEMBER_COOKIE_HTTPONLY = parse_boolean(\n    os.environ.get(\"REDASH_REMEMBER_COOKIE_HTTPONLY\", \"true\")\n)\n# The amount of time before the remember cookie expires.\nREMEMBER_COOKIE_DURATION = int(\n    os.environ.get(\"REDASH_REMEMBER_COOKIE_DURATION\", 60 * 60 * 24 * 31)\n)\n\n# Doesn't set X-Frame-Options by default since it's highly dependent\n# on the specific deployment.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n# for more information.\nFRAME_OPTIONS = os.environ.get(\"REDASH_FRAME_OPTIONS\", \"deny\")\nFRAME_OPTIONS_ALLOW_FROM = os.environ.get(\"REDASH_FRAME_OPTIONS_ALLOW_FROM\", \"\")\n\n# Whether and how to send Strict-Transport-Security response headers.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security\n# for more information.\nHSTS_ENABLED = parse_boolean(\n    os.environ.get(\"REDASH_HSTS_ENABLED\") or str(ENFORCE_HTTPS)\n)\nHSTS_PRELOAD = parse_boolean(os.environ.get(\"REDASH_HSTS_PRELOAD\", \"false\"))\nHSTS_MAX_AGE = int(os.environ.get(\"REDASH_HSTS_MAX_AGE\", talisman.ONE_YEAR_IN_SECS))\nHSTS_INCLUDE_SUBDOMAINS = parse_boolean(\n    os.environ.get(\"REDASH_HSTS_INCLUDE_SUBDOMAINS\", \"false\")\n)\n\n# Whether and how to send Content-Security-Policy response headers.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\n# for more information.\n# Overriding this value via an environment variables requires setting it\n# as a string in the general CSP format of a semicolon separated list of\n# individual CSP directives, see https://github.com/GoogleCloudPlatform/flask-talisman#example-7\n# for more information. E.g.:\nCONTENT_SECURITY_POLICY = os.environ.get(\n    \"REDASH_CONTENT_SECURITY_POLICY\",\n    \"default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-eval'; font-src 'self' data:; img-src 'self' http: https: data: blob:; object-src 'none'; frame-ancestors 'none'; frame-src redash.io;\",\n)\nCONTENT_SECURITY_POLICY_REPORT_URI = os.environ.get(\n    \"REDASH_CONTENT_SECURITY_POLICY_REPORT_URI\", \"\"\n)\nCONTENT_SECURITY_POLICY_REPORT_ONLY = parse_boolean(\n    os.environ.get(\"REDASH_CONTENT_SECURITY_POLICY_REPORT_ONLY\", \"false\")\n)\nCONTENT_SECURITY_POLICY_NONCE_IN = array_from_string(\n    os.environ.get(\"REDASH_CONTENT_SECURITY_POLICY_NONCE_IN\", \"\")\n)\n\n# Whether and how to send Referrer-Policy response headers. Defaults to\n# 'strict-origin-when-cross-origin'.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n# for more information.\nREFERRER_POLICY = os.environ.get(\n    \"REDASH_REFERRER_POLICY\", \"strict-origin-when-cross-origin\"\n)\n# Whether and how to send Feature-Policy response headers. Defaults to\n# an empty value.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy\n# for more information.\nFEATURE_POLICY = os.environ.get(\"REDASH_REFERRER_POLICY\", \"\")\n\nMULTI_ORG = parse_boolean(os.environ.get(\"REDASH_MULTI_ORG\", \"false\"))\n\nGOOGLE_CLIENT_ID = os.environ.get(\"REDASH_GOOGLE_CLIENT_ID\", \"\")\nGOOGLE_CLIENT_SECRET = os.environ.get(\"REDASH_GOOGLE_CLIENT_SECRET\", \"\")\nGOOGLE_OAUTH_ENABLED = bool(GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET)\n\n# If Redash is behind a proxy it might sometimes receive a X-Forwarded-Proto of HTTP\n# even if your actual Redash URL scheme is HTTPS. This will cause Flask to build\n# the SAML redirect URL incorrect thus failing auth. This is especially common if\n# you're behind a SSL/TCP configured AWS ELB or similar.\n# This setting will force the URL scheme.\nSAML_SCHEME_OVERRIDE = os.environ.get(\"REDASH_SAML_SCHEME_OVERRIDE\", \"\")\n\nSAML_ENCRYPTION_PEM_PATH = os.environ.get(\"REDASH_SAML_ENCRYPTION_PEM_PATH\", \"\")\nSAML_ENCRYPTION_CERT_PATH = os.environ.get(\"REDASH_SAML_ENCRYPTION_CERT_PATH\", \"\")\nSAML_ENCRYPTION_ENABLED = SAML_ENCRYPTION_PEM_PATH != \"\" and SAML_ENCRYPTION_CERT_PATH != \"\"\n\n# Enables the use of an externally-provided and trusted remote user via an HTTP\n# header.  The \"user\" must be an email address.\n#\n# By default the trusted header is X-Forwarded-Remote-User.  You can change\n# this by setting REDASH_REMOTE_USER_HEADER.\n#\n# Enabling this authentication method is *potentially dangerous*, and it is\n# your responsibility to ensure that only a trusted frontend (usually on the\n# same server) can talk to the redash backend server, otherwise people will be\n# able to login as anyone they want by directly talking to the redash backend.\n# You must *also* ensure that any special header in the original request is\n# removed or always overwritten by your frontend, otherwise your frontend may\n# pass it through to the backend unchanged.\n#\n# Note that redash will only check the remote user once, upon the first need\n# for a login, and then set a cookie which keeps the user logged in.  Dropping\n# the remote user header after subsequent requests won't automatically log the\n# user out.  Doing so could be done with further work, but usually it's\n# unnecessary.\n#\n# If you also set the organization setting auth_password_login_enabled to false,\n# then your authentication will be seamless.  Otherwise a link will be presented\n# on the login page to trigger remote user auth.\nREMOTE_USER_LOGIN_ENABLED = parse_boolean(\n    os.environ.get(\"REDASH_REMOTE_USER_LOGIN_ENABLED\", \"false\")\n)\nREMOTE_USER_HEADER = os.environ.get(\n    \"REDASH_REMOTE_USER_HEADER\", \"X-Forwarded-Remote-User\"\n)\n\n# If the organization setting auth_password_login_enabled is not false, then users will still be\n# able to login through Redash instead of the LDAP server\nLDAP_LOGIN_ENABLED = parse_boolean(os.environ.get(\"REDASH_LDAP_LOGIN_ENABLED\", \"false\"))\n# Bind LDAP using SSL. Default is False\nLDAP_SSL = parse_boolean(os.environ.get(\"REDASH_LDAP_USE_SSL\", \"false\"))\n# Choose authentication method(SIMPLE, ANONYMOUS or NTLM). Default is SIMPLE\nLDAP_AUTH_METHOD = os.environ.get(\"REDASH_LDAP_AUTH_METHOD\", \"SIMPLE\")\n# The LDAP directory address (ex. ldap://10.0.10.1:389)\nLDAP_HOST_URL = os.environ.get(\"REDASH_LDAP_URL\", None)\n# The DN & password used to connect to LDAP to determine the identity of the user being authenticated.\n# For AD this should be \"org\\\\user\".\nLDAP_BIND_DN = os.environ.get(\"REDASH_LDAP_BIND_DN\", None)\nLDAP_BIND_DN_PASSWORD = os.environ.get(\"REDASH_LDAP_BIND_DN_PASSWORD\", \"\")\n# AD/LDAP email and display name keys\nLDAP_DISPLAY_NAME_KEY = os.environ.get(\"REDASH_LDAP_DISPLAY_NAME_KEY\", \"displayName\")\nLDAP_EMAIL_KEY = os.environ.get(\"REDASH_LDAP_EMAIL_KEY\", \"mail\")\n# Prompt that should be shown above username/email field.\nLDAP_CUSTOM_USERNAME_PROMPT = os.environ.get(\n    \"REDASH_LDAP_CUSTOM_USERNAME_PROMPT\", \"LDAP/AD/SSO username:\"\n)\n# LDAP Search DN TEMPLATE (for AD this should be \"(sAMAccountName=%(username)s)\"\")\nLDAP_SEARCH_TEMPLATE = os.environ.get(\n    \"REDASH_LDAP_SEARCH_TEMPLATE\", \"(cn=%(username)s)\"\n)\n# The schema to bind to (ex. cn=users,dc=ORG,dc=local)\nLDAP_SEARCH_DN = os.environ.get(\n    \"REDASH_LDAP_SEARCH_DN\", os.environ.get(\"REDASH_SEARCH_DN\")\n)\n\nSTATIC_ASSETS_PATH = fix_assets_path(\n    os.environ.get(\"REDASH_STATIC_ASSETS_PATH\", \"../client/dist/\")\n)\nFLASK_TEMPLATE_PATH = fix_assets_path(\n    os.environ.get(\"REDASH_FLASK_TEMPLATE_PATH\", STATIC_ASSETS_PATH)\n)\n# Time limit (in seconds) for scheduled queries. Set this to -1 to execute without a time limit.\nSCHEDULED_QUERY_TIME_LIMIT = int(\n    os.environ.get(\"REDASH_SCHEDULED_QUERY_TIME_LIMIT\", -1)\n)\n\n# Time limit (in seconds) for adhoc queries. Set this to -1 to execute without a time limit.\nADHOC_QUERY_TIME_LIMIT = int(os.environ.get(\"REDASH_ADHOC_QUERY_TIME_LIMIT\", -1))\n\nJOB_EXPIRY_TIME = int(os.environ.get(\"REDASH_JOB_EXPIRY_TIME\", 3600 * 12))\nJOB_DEFAULT_FAILURE_TTL = int(\n    os.environ.get(\"REDASH_JOB_DEFAULT_FAILURE_TTL\", 7 * 24 * 60 * 60)\n)\n\nLOG_LEVEL = os.environ.get(\"REDASH_LOG_LEVEL\", \"INFO\")\nLOG_STDOUT = parse_boolean(os.environ.get(\"REDASH_LOG_STDOUT\", \"false\"))\nLOG_PREFIX = os.environ.get(\"REDASH_LOG_PREFIX\", \"\")\nLOG_FORMAT = os.environ.get(\n    \"REDASH_LOG_FORMAT\",\n    LOG_PREFIX + \"[%(asctime)s][PID:%(process)d][%(levelname)s][%(name)s] %(message)s\",\n)\nRQ_WORKER_JOB_LOG_FORMAT = os.environ.get(\n    \"REDASH_RQ_WORKER_JOB_LOG_FORMAT\",\n    (\n        LOG_PREFIX + \"[%(asctime)s][PID:%(process)d][%(levelname)s][%(name)s] \"\n        \"job.func_name=%(job_func_name)s \"\n        \"job.id=%(job_id)s %(message)s\"\n    ),\n)\n\n# Mail settings:\nMAIL_SERVER = os.environ.get(\"REDASH_MAIL_SERVER\", \"localhost\")\nMAIL_PORT = int(os.environ.get(\"REDASH_MAIL_PORT\", 25))\nMAIL_USE_TLS = parse_boolean(os.environ.get(\"REDASH_MAIL_USE_TLS\", \"false\"))\nMAIL_USE_SSL = parse_boolean(os.environ.get(\"REDASH_MAIL_USE_SSL\", \"false\"))\nMAIL_USERNAME = os.environ.get(\"REDASH_MAIL_USERNAME\", None)\nMAIL_PASSWORD = os.environ.get(\"REDASH_MAIL_PASSWORD\", None)\nMAIL_DEFAULT_SENDER = os.environ.get(\"REDASH_MAIL_DEFAULT_SENDER\", None)\nMAIL_MAX_EMAILS = os.environ.get(\"REDASH_MAIL_MAX_EMAILS\", None)\nMAIL_ASCII_ATTACHMENTS = parse_boolean(\n    os.environ.get(\"REDASH_MAIL_ASCII_ATTACHMENTS\", \"false\")\n)\n\n\ndef email_server_is_configured():\n    return MAIL_DEFAULT_SENDER is not None\n\n\nHOST = os.environ.get(\"REDASH_HOST\", \"\")\n\nSEND_FAILURE_EMAIL_INTERVAL = int(\n    os.environ.get(\"REDASH_SEND_FAILURE_EMAIL_INTERVAL\", 60)\n)\nMAX_FAILURE_REPORTS_PER_QUERY = int(\n    os.environ.get(\"REDASH_MAX_FAILURE_REPORTS_PER_QUERY\", 100)\n)\n\nALERTS_DEFAULT_MAIL_SUBJECT_TEMPLATE = os.environ.get(\n    \"REDASH_ALERTS_DEFAULT_MAIL_SUBJECT_TEMPLATE\", \"({state}) {alert_name}\"\n)\n\n# How many requests are allowed per IP to the login page before\n# being throttled?\n# See https://flask-limiter.readthedocs.io/en/stable/#rate-limit-string-notation\n\nRATELIMIT_ENABLED = parse_boolean(os.environ.get(\"REDASH_RATELIMIT_ENABLED\", \"true\"))\nTHROTTLE_LOGIN_PATTERN = os.environ.get(\"REDASH_THROTTLE_LOGIN_PATTERN\", \"50/hour\")\nLIMITER_STORAGE = os.environ.get(\"REDASH_LIMITER_STORAGE\", REDIS_URL)\nTHROTTLE_PASS_RESET_PATTERN = os.environ.get(\"REDASH_THROTTLE_PASS_RESET_PATTERN\", \"10/hour\")\n\n# CORS settings for the Query Result API (and possibly future external APIs).\n# In most cases all you need to do is set REDASH_CORS_ACCESS_CONTROL_ALLOW_ORIGIN\n# to the calling domain (or domains in a comma separated list).\nACCESS_CONTROL_ALLOW_ORIGIN = set_from_string(\n    os.environ.get(\"REDASH_CORS_ACCESS_CONTROL_ALLOW_ORIGIN\", \"\")\n)\nACCESS_CONTROL_ALLOW_CREDENTIALS = parse_boolean(\n    os.environ.get(\"REDASH_CORS_ACCESS_CONTROL_ALLOW_CREDENTIALS\", \"false\")\n)\nACCESS_CONTROL_REQUEST_METHOD = os.environ.get(\n    \"REDASH_CORS_ACCESS_CONTROL_REQUEST_METHOD\", \"GET, POST, PUT\"\n)\nACCESS_CONTROL_ALLOW_HEADERS = os.environ.get(\n    \"REDASH_CORS_ACCESS_CONTROL_ALLOW_HEADERS\", \"Content-Type\"\n)\n\n# Query Runners\ndefault_query_runners = [\n    \"redash.query_runner.athena\",\n    \"redash.query_runner.big_query\",\n    \"redash.query_runner.google_spreadsheets\",\n    \"redash.query_runner.graphite\",\n    \"redash.query_runner.mongodb\",\n    \"redash.query_runner.couchbase\",\n    \"redash.query_runner.mysql\",\n    \"redash.query_runner.pg\",\n    \"redash.query_runner.url\",\n    \"redash.query_runner.influx_db\",\n    \"redash.query_runner.elasticsearch\",\n    \"redash.query_runner.amazon_elasticsearch\",\n    \"redash.query_runner.trino\",\n    \"redash.query_runner.presto\",\n    \"redash.query_runner.databricks\",\n    \"redash.query_runner.hive_ds\",\n    \"redash.query_runner.impala_ds\",\n    \"redash.query_runner.vertica\",\n    \"redash.query_runner.clickhouse\",\n    \"redash.query_runner.yandex_metrica\",\n    \"redash.query_runner.rockset\",\n    \"redash.query_runner.treasuredata\",\n    \"redash.query_runner.sqlite\",\n    \"redash.query_runner.dynamodb_sql\",\n    \"redash.query_runner.mssql\",\n    \"redash.query_runner.mssql_odbc\",\n    \"redash.query_runner.memsql_ds\",\n    \"redash.query_runner.mapd\",\n    \"redash.query_runner.jql\",\n    \"redash.query_runner.google_analytics\",\n    \"redash.query_runner.axibase_tsd\",\n    \"redash.query_runner.salesforce\",\n    \"redash.query_runner.query_results\",\n    \"redash.query_runner.prometheus\",\n    \"redash.query_runner.qubole\",\n    \"redash.query_runner.db2\",\n    \"redash.query_runner.druid\",\n    \"redash.query_runner.kylin\",\n    \"redash.query_runner.drill\",\n    \"redash.query_runner.uptycs\",\n    \"redash.query_runner.snowflake\",\n    \"redash.query_runner.phoenix\",\n    \"redash.query_runner.json_ds\",\n    \"redash.query_runner.cass\",\n    \"redash.query_runner.dgraph\",\n    \"redash.query_runner.azure_kusto\",\n    \"redash.query_runner.exasol\",\n    \"redash.query_runner.cloudwatch\",\n    \"redash.query_runner.cloudwatch_insights\",\n    \"redash.query_runner.corporate_memory\",\n    \"redash.query_runner.sparql_endpoint\",\n    \"redash.query_runner.excel\",\n    \"redash.query_runner.csv\",\n    \"redash.query_runner.firebolt\"\n]\n\nenabled_query_runners = array_from_string(\n    os.environ.get(\"REDASH_ENABLED_QUERY_RUNNERS\", \",\".join(default_query_runners))\n)\nadditional_query_runners = array_from_string(\n    os.environ.get(\"REDASH_ADDITIONAL_QUERY_RUNNERS\", \"\")\n)\ndisabled_query_runners = array_from_string(\n    os.environ.get(\"REDASH_DISABLED_QUERY_RUNNERS\", \"\")\n)\n\nQUERY_RUNNERS = remove(\n    set(disabled_query_runners),\n    distinct(enabled_query_runners + additional_query_runners),\n)\n\ndynamic_settings = importlib.import_module(\n    os.environ.get(\"REDASH_DYNAMIC_SETTINGS_MODULE\", \"redash.settings.dynamic_settings\")\n)\n\n# Destinations\ndefault_destinations = [\n    \"redash.destinations.email\",\n    \"redash.destinations.slack\",\n    \"redash.destinations.webhook\",\n    \"redash.destinations.hipchat\",\n    \"redash.destinations.mattermost\",\n    \"redash.destinations.chatwork\",\n    \"redash.destinations.pagerduty\",\n    \"redash.destinations.hangoutschat\",\n]\n\nenabled_destinations = array_from_string(\n    os.environ.get(\"REDASH_ENABLED_DESTINATIONS\", \",\".join(default_destinations))\n)\nadditional_destinations = array_from_string(\n    os.environ.get(\"REDASH_ADDITIONAL_DESTINATIONS\", \"\")\n)\n\nDESTINATIONS = distinct(enabled_destinations + additional_destinations)\n\nEVENT_REPORTING_WEBHOOKS = array_from_string(\n    os.environ.get(\"REDASH_EVENT_REPORTING_WEBHOOKS\", \"\")\n)\n\n# Support for Sentry (https://getsentry.com/). Just set your Sentry DSN to enable it:\nSENTRY_DSN = os.environ.get(\"REDASH_SENTRY_DSN\", \"\")\nSENTRY_ENVIRONMENT = os.environ.get(\"REDASH_SENTRY_ENVIRONMENT\")\n\n# Client side toggles:\nALLOW_SCRIPTS_IN_USER_INPUT = parse_boolean(\n    os.environ.get(\"REDASH_ALLOW_SCRIPTS_IN_USER_INPUT\", \"false\")\n)\nDASHBOARD_REFRESH_INTERVALS = list(\n    map(\n        int,\n        array_from_string(\n            os.environ.get(\n                \"REDASH_DASHBOARD_REFRESH_INTERVALS\", \"60,300,600,1800,3600,43200,86400\"\n            )\n        ),\n    )\n)\nQUERY_REFRESH_INTERVALS = list(\n    map(\n        int,\n        array_from_string(\n            os.environ.get(\n                \"REDASH_QUERY_REFRESH_INTERVALS\",\n                \"60, 300, 600, 900, 1800, 3600, 7200, 10800, 14400, 18000, 21600, 25200, 28800, 32400, 36000, 39600, 43200, 86400, 604800, 1209600, 2592000\",\n            )\n        ),\n    )\n)\nPAGE_SIZE = int(os.environ.get(\"REDASH_PAGE_SIZE\", 20))\nPAGE_SIZE_OPTIONS = list(\n    map(\n        int,\n        array_from_string(os.environ.get(\"REDASH_PAGE_SIZE_OPTIONS\", \"5,10,20,50,100\")),\n    )\n)\nTABLE_CELL_MAX_JSON_SIZE = int(os.environ.get(\"REDASH_TABLE_CELL_MAX_JSON_SIZE\", 50000))\n\n# Features:\nVERSION_CHECK = parse_boolean(os.environ.get(\"REDASH_VERSION_CHECK\", \"true\"))\nFEATURE_DISABLE_REFRESH_QUERIES = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_DISABLE_REFRESH_QUERIES\", \"false\")\n)\nFEATURE_SHOW_QUERY_RESULTS_COUNT = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_SHOW_QUERY_RESULTS_COUNT\", \"true\")\n)\nFEATURE_ALLOW_CUSTOM_JS_VISUALIZATIONS = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_ALLOW_CUSTOM_JS_VISUALIZATIONS\", \"false\")\n)\nFEATURE_AUTO_PUBLISH_NAMED_QUERIES = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_AUTO_PUBLISH_NAMED_QUERIES\", \"true\")\n)\nFEATURE_EXTENDED_ALERT_OPTIONS = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_EXTENDED_ALERT_OPTIONS\", \"false\")\n)\n\n# BigQuery\nBIGQUERY_HTTP_TIMEOUT = int(os.environ.get(\"REDASH_BIGQUERY_HTTP_TIMEOUT\", \"600\"))\n\n# Allow Parameters in Embeds\n# WARNING: Deprecated!\n# See https://discuss.redash.io/t/support-for-parameters-in-embedded-visualizations/3337 for more details.\nALLOW_PARAMETERS_IN_EMBEDS = parse_boolean(\n    os.environ.get(\"REDASH_ALLOW_PARAMETERS_IN_EMBEDS\", \"false\")\n)\n\n# Enhance schema fetching\nSCHEMA_RUN_TABLE_SIZE_CALCULATIONS = parse_boolean(\n    os.environ.get(\"REDASH_SCHEMA_RUN_TABLE_SIZE_CALCULATIONS\", \"false\")\n)\n\n# kylin\nKYLIN_OFFSET = int(os.environ.get(\"REDASH_KYLIN_OFFSET\", 0))\nKYLIN_LIMIT = int(os.environ.get(\"REDASH_KYLIN_LIMIT\", 50000))\nKYLIN_ACCEPT_PARTIAL = parse_boolean(\n    os.environ.get(\"REDASH_KYLIN_ACCEPT_PARTIAL\", \"false\")\n)\n\n# sqlparse\nSQLPARSE_FORMAT_OPTIONS = {\n    \"reindent\": parse_boolean(os.environ.get(\"SQLPARSE_FORMAT_REINDENT\", \"true\")),\n    \"keyword_case\": os.environ.get(\"SQLPARSE_FORMAT_KEYWORD_CASE\", \"upper\"),\n}\n\n# requests\nREQUESTS_ALLOW_REDIRECTS = parse_boolean(\n    os.environ.get(\"REDASH_REQUESTS_ALLOW_REDIRECTS\", \"false\")\n)\n\n# Enforces CSRF token validation on API requests.\n# This is turned off by default to avoid breaking any existing deployments but it is highly recommended to turn this toggle on to prevent CSRF attacks.\nENFORCE_CSRF = parse_boolean(\n    os.environ.get(\"REDASH_ENFORCE_CSRF\", \"false\")\n)\n\n# Databricks\n\nCSRF_TIME_LIMIT = int(os.environ.get(\"REDASH_CSRF_TIME_LIMIT\", 3600 * 6))\n\n# Email blocked domains, use delimiter comma to separated multiple domains\nBLOCKED_DOMAINS = set_from_string(os.environ.get(\"REDASH_BLOCKED_DOMAINS\", \"qq.com\"))\n", "Flask==1.1.1\nJinja2==2.10.3\nitsdangerous==1.1.0\nclick==6.7\nMarkupSafe==1.1.1\npyOpenSSL==19.0.0\nhttplib2==0.14.0\nwtforms==2.2.1\nFlask-RESTful==0.3.7\nFlask-Login==0.4.1\nFlask-SQLAlchemy==2.4.1\nFlask-Migrate==2.5.2\nflask-mail==0.9.1\nflask-talisman==0.7.0\nFlask-Limiter==0.9.3\nFlask-WTF==0.14.3\npasslib==1.7.1\naniso8601==8.0.0\nblinker==1.4\npsycopg2==2.8.3\npython-dateutil==2.8.0\npytz>=2019.3\nPyYAML==5.1.2\nredis==3.5.0\nrequests==2.21.0\nSQLAlchemy==1.3.10\n# We can't upgrade SQLAlchemy-Searchable version as newer versions require PostgreSQL > 9.6, but we target older versions at the moment.\nSQLAlchemy-Searchable==0.10.6\n# We need to pin the version of pyparsing, as newer versions break SQLAlchemy-Searchable-10.0.6 (newer versions no longer depend on it)\npyparsing==2.3.0\nSQLAlchemy-Utils==0.34.2\nsqlparse==0.3.0\nstatsd==3.3.0\ngreenlet==0.4.16\ngunicorn==20.0.4\nrq==1.5.0\nrq-scheduler==0.9.1\njsonschema==3.1.1\nRestrictedPython==5.0\npysaml2==6.1.0\npycrypto==2.6.1\nfuncy==1.13\nsentry-sdk>=0.14.3,<0.15.0\nsemver==2.8.1\nxlsxwriter==1.2.2\npystache==0.5.4\nparsedatetime==2.4\nPyJWT==1.7.1\ncryptography==2.8\nsimplejson==3.16.0\nua-parser==0.8.0\nuser-agents==2.0\nmaxminddb-geolite2==2018.703\npypd==1.1.0\ndisposable-email-domains>=0.0.52\ngevent==1.4.0\nsshtunnel==0.1.5\nsupervisor==4.1.0\nsupervisor_checks==0.8.1\nwerkzeug==0.16.1\n# Install the dependencies of the bin/bundle-extensions script here.\n# It has its own requirements file to simplify the frontend client build process\n-r requirements_bundles.txt\n# Uncomment the requirement for ldap3 if using ldap.\n# It is not included by default because of the GPL license conflict.\n# ldap3==2.2.4\nAuthlib==0.15.5"], "fixing_code": ["# This configuration file is for the **development** setup.\n# For a production example please refer to getredash/setup repository on GitHub.\nversion: \"2.2\"\nx-redash-service: &redash-service\n  build:\n    context: .\n    args:\n      skip_frontend_build: \"true\"\n  volumes:\n    - .:/app\n  env_file:\n    - .env\nx-redash-environment: &redash-environment\n  REDASH_LOG_LEVEL: \"INFO\"\n  REDASH_REDIS_URL: \"redis://redis:6379/0\"\n  REDASH_DATABASE_URL: \"postgresql://postgres@postgres/postgres\"\n  REDASH_RATELIMIT_ENABLED: \"false\"\n  REDASH_MAIL_DEFAULT_SENDER: \"redash@example.com\"\n  REDASH_MAIL_SERVER: \"email\"\n  REDASH_ENFORCE_CSRF: \"true\"\n  # Set secret keys in the .env file\nservices:\n  server:\n    <<: *redash-service\n    command: dev_server\n    depends_on:\n      - postgres\n      - redis\n    ports:\n      - \"5000:5000\"\n      - \"5678:5678\"\n    environment:\n      <<: *redash-environment\n      PYTHONUNBUFFERED: 0\n  scheduler:\n    <<: *redash-service\n    command: dev_scheduler\n    depends_on:\n      - server\n    environment:\n      <<: *redash-environment\n  worker:\n    <<: *redash-service\n    command: dev_worker\n    depends_on:\n      - server\n    environment:\n      <<: *redash-environment\n      PYTHONUNBUFFERED: 0\n  redis:\n    image: redis:3-alpine\n    restart: unless-stopped\n  postgres:\n    image: postgres:9.5-alpine\n    # The following turns the DB into less durable, but gains significant performance improvements for the tests run (x3\n    # improvement on my personal machine). We should consider moving this into a dedicated Docker Compose configuration for\n    # tests.\n    ports:\n      - \"15432:5432\"\n    command: \"postgres -c fsync=off -c full_page_writes=off -c synchronous_commit=OFF\"\n    restart: unless-stopped\n    environment:\n      POSTGRES_HOST_AUTH_METHOD: \"trust\"\n  email:\n    image: djfarrelly/maildev\n    ports:\n      - \"1080:80\"\n    restart: unless-stopped\n", "import os\nimport importlib\nimport ssl\nfrom funcy import distinct, remove\nfrom flask_talisman import talisman\n\nfrom .helpers import (\n    fix_assets_path,\n    array_from_string,\n    parse_boolean,\n    int_or_none,\n    set_from_string,\n    add_decode_responses_to_redis_url,\n    cast_int_or_default\n)\nfrom .organization import DATE_FORMAT, TIME_FORMAT  # noqa\n\n# _REDIS_URL is the unchanged REDIS_URL we get from env vars, to be used later with RQ\n_REDIS_URL = os.environ.get(\n    \"REDASH_REDIS_URL\", os.environ.get(\"REDIS_URL\", \"redis://localhost:6379/0\")\n)\n# This is the one to use for Redash' own connection:\nREDIS_URL = add_decode_responses_to_redis_url(_REDIS_URL)\nPROXIES_COUNT = int(os.environ.get(\"REDASH_PROXIES_COUNT\", \"1\"))\n\nSTATSD_HOST = os.environ.get(\"REDASH_STATSD_HOST\", \"127.0.0.1\")\nSTATSD_PORT = int(os.environ.get(\"REDASH_STATSD_PORT\", \"8125\"))\nSTATSD_PREFIX = os.environ.get(\"REDASH_STATSD_PREFIX\", \"redash\")\nSTATSD_USE_TAGS = parse_boolean(os.environ.get(\"REDASH_STATSD_USE_TAGS\", \"false\"))\n\n# Connection settings for Redash's own database (where we store the queries, results, etc)\nSQLALCHEMY_DATABASE_URI = os.environ.get(\n    \"REDASH_DATABASE_URL\", os.environ.get(\"DATABASE_URL\", \"postgresql:///postgres\")\n)\nSQLALCHEMY_MAX_OVERFLOW = int_or_none(os.environ.get(\"SQLALCHEMY_MAX_OVERFLOW\"))\nSQLALCHEMY_POOL_SIZE = int_or_none(os.environ.get(\"SQLALCHEMY_POOL_SIZE\"))\nSQLALCHEMY_DISABLE_POOL = parse_boolean(\n    os.environ.get(\"SQLALCHEMY_DISABLE_POOL\", \"false\")\n)\nSQLALCHEMY_ENABLE_POOL_PRE_PING = parse_boolean(\n    os.environ.get(\"SQLALCHEMY_ENABLE_POOL_PRE_PING\", \"false\")\n)\nSQLALCHEMY_TRACK_MODIFICATIONS = False\nSQLALCHEMY_ECHO = False\n\nRQ_REDIS_URL = os.environ.get(\"RQ_REDIS_URL\", _REDIS_URL)\n\n# The following enables periodic job (every 5 minutes) of removing unused query results.\nQUERY_RESULTS_CLEANUP_ENABLED = parse_boolean(\n    os.environ.get(\"REDASH_QUERY_RESULTS_CLEANUP_ENABLED\", \"true\")\n)\nQUERY_RESULTS_CLEANUP_COUNT = int(\n    os.environ.get(\"REDASH_QUERY_RESULTS_CLEANUP_COUNT\", \"100\")\n)\nQUERY_RESULTS_CLEANUP_MAX_AGE = int(\n    os.environ.get(\"REDASH_QUERY_RESULTS_CLEANUP_MAX_AGE\", \"7\")\n)\n\nSCHEMAS_REFRESH_SCHEDULE = int(os.environ.get(\"REDASH_SCHEMAS_REFRESH_SCHEDULE\", 30))\n\nAUTH_TYPE = os.environ.get(\"REDASH_AUTH_TYPE\", \"api_key\")\nINVITATION_TOKEN_MAX_AGE = int(\n    os.environ.get(\"REDASH_INVITATION_TOKEN_MAX_AGE\", 60 * 60 * 24 * 7)\n)\n\n# The secret key to use in the Flask app for various cryptographic features\nSECRET_KEY = os.environ.get(\"REDASH_COOKIE_SECRET\")\n\nif SECRET_KEY is None:\n    raise Exception(\"You must set the REDASH_COOKIE_SECRET environment variable. Visit http://redash.io/help/open-source/admin-guide/secrets for more information.\")\n\n# The secret key to use when encrypting data source options\nDATASOURCE_SECRET_KEY = os.environ.get(\"REDASH_SECRET_KEY\", SECRET_KEY)\n\n# Whether and how to redirect non-HTTP requests to HTTPS. Disabled by default.\nENFORCE_HTTPS = parse_boolean(os.environ.get(\"REDASH_ENFORCE_HTTPS\", \"false\"))\nENFORCE_HTTPS_PERMANENT = parse_boolean(\n    os.environ.get(\"REDASH_ENFORCE_HTTPS_PERMANENT\", \"false\")\n)\n# Whether file downloads are enforced or not.\nENFORCE_FILE_SAVE = parse_boolean(os.environ.get(\"REDASH_ENFORCE_FILE_SAVE\", \"true\"))\n\n# Whether api calls using the json query runner will block private addresses\nENFORCE_PRIVATE_ADDRESS_BLOCK = parse_boolean(\n    os.environ.get(\"REDASH_ENFORCE_PRIVATE_IP_BLOCK\", \"true\")\n)\n\n# Whether to use secure cookies by default.\nCOOKIES_SECURE = parse_boolean(\n    os.environ.get(\"REDASH_COOKIES_SECURE\", str(ENFORCE_HTTPS))\n)\n# Whether the session cookie is set to secure.\nSESSION_COOKIE_SECURE = parse_boolean(\n    os.environ.get(\"REDASH_SESSION_COOKIE_SECURE\") or str(COOKIES_SECURE)\n)\n# Whether the session cookie is set HttpOnly.\nSESSION_COOKIE_HTTPONLY = parse_boolean(\n    os.environ.get(\"REDASH_SESSION_COOKIE_HTTPONLY\", \"true\")\n)\nSESSION_EXPIRY_TIME = int(os.environ.get(\"REDASH_SESSION_EXPIRY_TIME\", 60 * 60 * 6))\n\n# Whether the session cookie is set to secure.\nREMEMBER_COOKIE_SECURE = parse_boolean(\n    os.environ.get(\"REDASH_REMEMBER_COOKIE_SECURE\") or str(COOKIES_SECURE)\n)\n# Whether the remember cookie is set HttpOnly.\nREMEMBER_COOKIE_HTTPONLY = parse_boolean(\n    os.environ.get(\"REDASH_REMEMBER_COOKIE_HTTPONLY\", \"true\")\n)\n# The amount of time before the remember cookie expires.\nREMEMBER_COOKIE_DURATION = int(\n    os.environ.get(\"REDASH_REMEMBER_COOKIE_DURATION\", 60 * 60 * 24 * 31)\n)\n\n# Doesn't set X-Frame-Options by default since it's highly dependent\n# on the specific deployment.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n# for more information.\nFRAME_OPTIONS = os.environ.get(\"REDASH_FRAME_OPTIONS\", \"deny\")\nFRAME_OPTIONS_ALLOW_FROM = os.environ.get(\"REDASH_FRAME_OPTIONS_ALLOW_FROM\", \"\")\n\n# Whether and how to send Strict-Transport-Security response headers.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security\n# for more information.\nHSTS_ENABLED = parse_boolean(\n    os.environ.get(\"REDASH_HSTS_ENABLED\") or str(ENFORCE_HTTPS)\n)\nHSTS_PRELOAD = parse_boolean(os.environ.get(\"REDASH_HSTS_PRELOAD\", \"false\"))\nHSTS_MAX_AGE = int(os.environ.get(\"REDASH_HSTS_MAX_AGE\", talisman.ONE_YEAR_IN_SECS))\nHSTS_INCLUDE_SUBDOMAINS = parse_boolean(\n    os.environ.get(\"REDASH_HSTS_INCLUDE_SUBDOMAINS\", \"false\")\n)\n\n# Whether and how to send Content-Security-Policy response headers.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\n# for more information.\n# Overriding this value via an environment variables requires setting it\n# as a string in the general CSP format of a semicolon separated list of\n# individual CSP directives, see https://github.com/GoogleCloudPlatform/flask-talisman#example-7\n# for more information. E.g.:\nCONTENT_SECURITY_POLICY = os.environ.get(\n    \"REDASH_CONTENT_SECURITY_POLICY\",\n    \"default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-eval'; font-src 'self' data:; img-src 'self' http: https: data: blob:; object-src 'none'; frame-ancestors 'none'; frame-src redash.io;\",\n)\nCONTENT_SECURITY_POLICY_REPORT_URI = os.environ.get(\n    \"REDASH_CONTENT_SECURITY_POLICY_REPORT_URI\", \"\"\n)\nCONTENT_SECURITY_POLICY_REPORT_ONLY = parse_boolean(\n    os.environ.get(\"REDASH_CONTENT_SECURITY_POLICY_REPORT_ONLY\", \"false\")\n)\nCONTENT_SECURITY_POLICY_NONCE_IN = array_from_string(\n    os.environ.get(\"REDASH_CONTENT_SECURITY_POLICY_NONCE_IN\", \"\")\n)\n\n# Whether and how to send Referrer-Policy response headers. Defaults to\n# 'strict-origin-when-cross-origin'.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n# for more information.\nREFERRER_POLICY = os.environ.get(\n    \"REDASH_REFERRER_POLICY\", \"strict-origin-when-cross-origin\"\n)\n# Whether and how to send Feature-Policy response headers. Defaults to\n# an empty value.\n# See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy\n# for more information.\nFEATURE_POLICY = os.environ.get(\"REDASH_REFERRER_POLICY\", \"\")\n\nMULTI_ORG = parse_boolean(os.environ.get(\"REDASH_MULTI_ORG\", \"false\"))\n\nGOOGLE_CLIENT_ID = os.environ.get(\"REDASH_GOOGLE_CLIENT_ID\", \"\")\nGOOGLE_CLIENT_SECRET = os.environ.get(\"REDASH_GOOGLE_CLIENT_SECRET\", \"\")\nGOOGLE_OAUTH_ENABLED = bool(GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET)\n\n# If Redash is behind a proxy it might sometimes receive a X-Forwarded-Proto of HTTP\n# even if your actual Redash URL scheme is HTTPS. This will cause Flask to build\n# the SAML redirect URL incorrect thus failing auth. This is especially common if\n# you're behind a SSL/TCP configured AWS ELB or similar.\n# This setting will force the URL scheme.\nSAML_SCHEME_OVERRIDE = os.environ.get(\"REDASH_SAML_SCHEME_OVERRIDE\", \"\")\n\nSAML_ENCRYPTION_PEM_PATH = os.environ.get(\"REDASH_SAML_ENCRYPTION_PEM_PATH\", \"\")\nSAML_ENCRYPTION_CERT_PATH = os.environ.get(\"REDASH_SAML_ENCRYPTION_CERT_PATH\", \"\")\nSAML_ENCRYPTION_ENABLED = SAML_ENCRYPTION_PEM_PATH != \"\" and SAML_ENCRYPTION_CERT_PATH != \"\"\n\n# Enables the use of an externally-provided and trusted remote user via an HTTP\n# header.  The \"user\" must be an email address.\n#\n# By default the trusted header is X-Forwarded-Remote-User.  You can change\n# this by setting REDASH_REMOTE_USER_HEADER.\n#\n# Enabling this authentication method is *potentially dangerous*, and it is\n# your responsibility to ensure that only a trusted frontend (usually on the\n# same server) can talk to the redash backend server, otherwise people will be\n# able to login as anyone they want by directly talking to the redash backend.\n# You must *also* ensure that any special header in the original request is\n# removed or always overwritten by your frontend, otherwise your frontend may\n# pass it through to the backend unchanged.\n#\n# Note that redash will only check the remote user once, upon the first need\n# for a login, and then set a cookie which keeps the user logged in.  Dropping\n# the remote user header after subsequent requests won't automatically log the\n# user out.  Doing so could be done with further work, but usually it's\n# unnecessary.\n#\n# If you also set the organization setting auth_password_login_enabled to false,\n# then your authentication will be seamless.  Otherwise a link will be presented\n# on the login page to trigger remote user auth.\nREMOTE_USER_LOGIN_ENABLED = parse_boolean(\n    os.environ.get(\"REDASH_REMOTE_USER_LOGIN_ENABLED\", \"false\")\n)\nREMOTE_USER_HEADER = os.environ.get(\n    \"REDASH_REMOTE_USER_HEADER\", \"X-Forwarded-Remote-User\"\n)\n\n# If the organization setting auth_password_login_enabled is not false, then users will still be\n# able to login through Redash instead of the LDAP server\nLDAP_LOGIN_ENABLED = parse_boolean(os.environ.get(\"REDASH_LDAP_LOGIN_ENABLED\", \"false\"))\n# Bind LDAP using SSL. Default is False\nLDAP_SSL = parse_boolean(os.environ.get(\"REDASH_LDAP_USE_SSL\", \"false\"))\n# Choose authentication method(SIMPLE, ANONYMOUS or NTLM). Default is SIMPLE\nLDAP_AUTH_METHOD = os.environ.get(\"REDASH_LDAP_AUTH_METHOD\", \"SIMPLE\")\n# The LDAP directory address (ex. ldap://10.0.10.1:389)\nLDAP_HOST_URL = os.environ.get(\"REDASH_LDAP_URL\", None)\n# The DN & password used to connect to LDAP to determine the identity of the user being authenticated.\n# For AD this should be \"org\\\\user\".\nLDAP_BIND_DN = os.environ.get(\"REDASH_LDAP_BIND_DN\", None)\nLDAP_BIND_DN_PASSWORD = os.environ.get(\"REDASH_LDAP_BIND_DN_PASSWORD\", \"\")\n# AD/LDAP email and display name keys\nLDAP_DISPLAY_NAME_KEY = os.environ.get(\"REDASH_LDAP_DISPLAY_NAME_KEY\", \"displayName\")\nLDAP_EMAIL_KEY = os.environ.get(\"REDASH_LDAP_EMAIL_KEY\", \"mail\")\n# Prompt that should be shown above username/email field.\nLDAP_CUSTOM_USERNAME_PROMPT = os.environ.get(\n    \"REDASH_LDAP_CUSTOM_USERNAME_PROMPT\", \"LDAP/AD/SSO username:\"\n)\n# LDAP Search DN TEMPLATE (for AD this should be \"(sAMAccountName=%(username)s)\"\")\nLDAP_SEARCH_TEMPLATE = os.environ.get(\n    \"REDASH_LDAP_SEARCH_TEMPLATE\", \"(cn=%(username)s)\"\n)\n# The schema to bind to (ex. cn=users,dc=ORG,dc=local)\nLDAP_SEARCH_DN = os.environ.get(\n    \"REDASH_LDAP_SEARCH_DN\", os.environ.get(\"REDASH_SEARCH_DN\")\n)\n\nSTATIC_ASSETS_PATH = fix_assets_path(\n    os.environ.get(\"REDASH_STATIC_ASSETS_PATH\", \"../client/dist/\")\n)\nFLASK_TEMPLATE_PATH = fix_assets_path(\n    os.environ.get(\"REDASH_FLASK_TEMPLATE_PATH\", STATIC_ASSETS_PATH)\n)\n# Time limit (in seconds) for scheduled queries. Set this to -1 to execute without a time limit.\nSCHEDULED_QUERY_TIME_LIMIT = int(\n    os.environ.get(\"REDASH_SCHEDULED_QUERY_TIME_LIMIT\", -1)\n)\n\n# Time limit (in seconds) for adhoc queries. Set this to -1 to execute without a time limit.\nADHOC_QUERY_TIME_LIMIT = int(os.environ.get(\"REDASH_ADHOC_QUERY_TIME_LIMIT\", -1))\n\nJOB_EXPIRY_TIME = int(os.environ.get(\"REDASH_JOB_EXPIRY_TIME\", 3600 * 12))\nJOB_DEFAULT_FAILURE_TTL = int(\n    os.environ.get(\"REDASH_JOB_DEFAULT_FAILURE_TTL\", 7 * 24 * 60 * 60)\n)\n\nLOG_LEVEL = os.environ.get(\"REDASH_LOG_LEVEL\", \"INFO\")\nLOG_STDOUT = parse_boolean(os.environ.get(\"REDASH_LOG_STDOUT\", \"false\"))\nLOG_PREFIX = os.environ.get(\"REDASH_LOG_PREFIX\", \"\")\nLOG_FORMAT = os.environ.get(\n    \"REDASH_LOG_FORMAT\",\n    LOG_PREFIX + \"[%(asctime)s][PID:%(process)d][%(levelname)s][%(name)s] %(message)s\",\n)\nRQ_WORKER_JOB_LOG_FORMAT = os.environ.get(\n    \"REDASH_RQ_WORKER_JOB_LOG_FORMAT\",\n    (\n        LOG_PREFIX + \"[%(asctime)s][PID:%(process)d][%(levelname)s][%(name)s] \"\n        \"job.func_name=%(job_func_name)s \"\n        \"job.id=%(job_id)s %(message)s\"\n    ),\n)\n\n# Mail settings:\nMAIL_SERVER = os.environ.get(\"REDASH_MAIL_SERVER\", \"localhost\")\nMAIL_PORT = int(os.environ.get(\"REDASH_MAIL_PORT\", 25))\nMAIL_USE_TLS = parse_boolean(os.environ.get(\"REDASH_MAIL_USE_TLS\", \"false\"))\nMAIL_USE_SSL = parse_boolean(os.environ.get(\"REDASH_MAIL_USE_SSL\", \"false\"))\nMAIL_USERNAME = os.environ.get(\"REDASH_MAIL_USERNAME\", None)\nMAIL_PASSWORD = os.environ.get(\"REDASH_MAIL_PASSWORD\", None)\nMAIL_DEFAULT_SENDER = os.environ.get(\"REDASH_MAIL_DEFAULT_SENDER\", None)\nMAIL_MAX_EMAILS = os.environ.get(\"REDASH_MAIL_MAX_EMAILS\", None)\nMAIL_ASCII_ATTACHMENTS = parse_boolean(\n    os.environ.get(\"REDASH_MAIL_ASCII_ATTACHMENTS\", \"false\")\n)\n\n\ndef email_server_is_configured():\n    return MAIL_DEFAULT_SENDER is not None\n\n\nHOST = os.environ.get(\"REDASH_HOST\", \"\")\n\nSEND_FAILURE_EMAIL_INTERVAL = int(\n    os.environ.get(\"REDASH_SEND_FAILURE_EMAIL_INTERVAL\", 60)\n)\nMAX_FAILURE_REPORTS_PER_QUERY = int(\n    os.environ.get(\"REDASH_MAX_FAILURE_REPORTS_PER_QUERY\", 100)\n)\n\nALERTS_DEFAULT_MAIL_SUBJECT_TEMPLATE = os.environ.get(\n    \"REDASH_ALERTS_DEFAULT_MAIL_SUBJECT_TEMPLATE\", \"({state}) {alert_name}\"\n)\n\n# How many requests are allowed per IP to the login page before\n# being throttled?\n# See https://flask-limiter.readthedocs.io/en/stable/#rate-limit-string-notation\n\nRATELIMIT_ENABLED = parse_boolean(os.environ.get(\"REDASH_RATELIMIT_ENABLED\", \"true\"))\nTHROTTLE_LOGIN_PATTERN = os.environ.get(\"REDASH_THROTTLE_LOGIN_PATTERN\", \"50/hour\")\nLIMITER_STORAGE = os.environ.get(\"REDASH_LIMITER_STORAGE\", REDIS_URL)\nTHROTTLE_PASS_RESET_PATTERN = os.environ.get(\"REDASH_THROTTLE_PASS_RESET_PATTERN\", \"10/hour\")\n\n# CORS settings for the Query Result API (and possibly future external APIs).\n# In most cases all you need to do is set REDASH_CORS_ACCESS_CONTROL_ALLOW_ORIGIN\n# to the calling domain (or domains in a comma separated list).\nACCESS_CONTROL_ALLOW_ORIGIN = set_from_string(\n    os.environ.get(\"REDASH_CORS_ACCESS_CONTROL_ALLOW_ORIGIN\", \"\")\n)\nACCESS_CONTROL_ALLOW_CREDENTIALS = parse_boolean(\n    os.environ.get(\"REDASH_CORS_ACCESS_CONTROL_ALLOW_CREDENTIALS\", \"false\")\n)\nACCESS_CONTROL_REQUEST_METHOD = os.environ.get(\n    \"REDASH_CORS_ACCESS_CONTROL_REQUEST_METHOD\", \"GET, POST, PUT\"\n)\nACCESS_CONTROL_ALLOW_HEADERS = os.environ.get(\n    \"REDASH_CORS_ACCESS_CONTROL_ALLOW_HEADERS\", \"Content-Type\"\n)\n\n# Query Runners\ndefault_query_runners = [\n    \"redash.query_runner.athena\",\n    \"redash.query_runner.big_query\",\n    \"redash.query_runner.google_spreadsheets\",\n    \"redash.query_runner.graphite\",\n    \"redash.query_runner.mongodb\",\n    \"redash.query_runner.couchbase\",\n    \"redash.query_runner.mysql\",\n    \"redash.query_runner.pg\",\n    \"redash.query_runner.url\",\n    \"redash.query_runner.influx_db\",\n    \"redash.query_runner.elasticsearch\",\n    \"redash.query_runner.amazon_elasticsearch\",\n    \"redash.query_runner.trino\",\n    \"redash.query_runner.presto\",\n    \"redash.query_runner.databricks\",\n    \"redash.query_runner.hive_ds\",\n    \"redash.query_runner.impala_ds\",\n    \"redash.query_runner.vertica\",\n    \"redash.query_runner.clickhouse\",\n    \"redash.query_runner.yandex_metrica\",\n    \"redash.query_runner.rockset\",\n    \"redash.query_runner.treasuredata\",\n    \"redash.query_runner.sqlite\",\n    \"redash.query_runner.dynamodb_sql\",\n    \"redash.query_runner.mssql\",\n    \"redash.query_runner.mssql_odbc\",\n    \"redash.query_runner.memsql_ds\",\n    \"redash.query_runner.mapd\",\n    \"redash.query_runner.jql\",\n    \"redash.query_runner.google_analytics\",\n    \"redash.query_runner.axibase_tsd\",\n    \"redash.query_runner.salesforce\",\n    \"redash.query_runner.query_results\",\n    \"redash.query_runner.prometheus\",\n    \"redash.query_runner.qubole\",\n    \"redash.query_runner.db2\",\n    \"redash.query_runner.druid\",\n    \"redash.query_runner.kylin\",\n    \"redash.query_runner.drill\",\n    \"redash.query_runner.uptycs\",\n    \"redash.query_runner.snowflake\",\n    \"redash.query_runner.phoenix\",\n    \"redash.query_runner.json_ds\",\n    \"redash.query_runner.cass\",\n    \"redash.query_runner.dgraph\",\n    \"redash.query_runner.azure_kusto\",\n    \"redash.query_runner.exasol\",\n    \"redash.query_runner.cloudwatch\",\n    \"redash.query_runner.cloudwatch_insights\",\n    \"redash.query_runner.corporate_memory\",\n    \"redash.query_runner.sparql_endpoint\",\n    \"redash.query_runner.excel\",\n    \"redash.query_runner.csv\",\n    \"redash.query_runner.firebolt\"\n]\n\nenabled_query_runners = array_from_string(\n    os.environ.get(\"REDASH_ENABLED_QUERY_RUNNERS\", \",\".join(default_query_runners))\n)\nadditional_query_runners = array_from_string(\n    os.environ.get(\"REDASH_ADDITIONAL_QUERY_RUNNERS\", \"\")\n)\ndisabled_query_runners = array_from_string(\n    os.environ.get(\"REDASH_DISABLED_QUERY_RUNNERS\", \"\")\n)\n\nQUERY_RUNNERS = remove(\n    set(disabled_query_runners),\n    distinct(enabled_query_runners + additional_query_runners),\n)\n\ndynamic_settings = importlib.import_module(\n    os.environ.get(\"REDASH_DYNAMIC_SETTINGS_MODULE\", \"redash.settings.dynamic_settings\")\n)\n\n# Destinations\ndefault_destinations = [\n    \"redash.destinations.email\",\n    \"redash.destinations.slack\",\n    \"redash.destinations.webhook\",\n    \"redash.destinations.hipchat\",\n    \"redash.destinations.mattermost\",\n    \"redash.destinations.chatwork\",\n    \"redash.destinations.pagerduty\",\n    \"redash.destinations.hangoutschat\",\n]\n\nenabled_destinations = array_from_string(\n    os.environ.get(\"REDASH_ENABLED_DESTINATIONS\", \",\".join(default_destinations))\n)\nadditional_destinations = array_from_string(\n    os.environ.get(\"REDASH_ADDITIONAL_DESTINATIONS\", \"\")\n)\n\nDESTINATIONS = distinct(enabled_destinations + additional_destinations)\n\nEVENT_REPORTING_WEBHOOKS = array_from_string(\n    os.environ.get(\"REDASH_EVENT_REPORTING_WEBHOOKS\", \"\")\n)\n\n# Support for Sentry (https://getsentry.com/). Just set your Sentry DSN to enable it:\nSENTRY_DSN = os.environ.get(\"REDASH_SENTRY_DSN\", \"\")\nSENTRY_ENVIRONMENT = os.environ.get(\"REDASH_SENTRY_ENVIRONMENT\")\n\n# Client side toggles:\nALLOW_SCRIPTS_IN_USER_INPUT = parse_boolean(\n    os.environ.get(\"REDASH_ALLOW_SCRIPTS_IN_USER_INPUT\", \"false\")\n)\nDASHBOARD_REFRESH_INTERVALS = list(\n    map(\n        int,\n        array_from_string(\n            os.environ.get(\n                \"REDASH_DASHBOARD_REFRESH_INTERVALS\", \"60,300,600,1800,3600,43200,86400\"\n            )\n        ),\n    )\n)\nQUERY_REFRESH_INTERVALS = list(\n    map(\n        int,\n        array_from_string(\n            os.environ.get(\n                \"REDASH_QUERY_REFRESH_INTERVALS\",\n                \"60, 300, 600, 900, 1800, 3600, 7200, 10800, 14400, 18000, 21600, 25200, 28800, 32400, 36000, 39600, 43200, 86400, 604800, 1209600, 2592000\",\n            )\n        ),\n    )\n)\nPAGE_SIZE = int(os.environ.get(\"REDASH_PAGE_SIZE\", 20))\nPAGE_SIZE_OPTIONS = list(\n    map(\n        int,\n        array_from_string(os.environ.get(\"REDASH_PAGE_SIZE_OPTIONS\", \"5,10,20,50,100\")),\n    )\n)\nTABLE_CELL_MAX_JSON_SIZE = int(os.environ.get(\"REDASH_TABLE_CELL_MAX_JSON_SIZE\", 50000))\n\n# Features:\nVERSION_CHECK = parse_boolean(os.environ.get(\"REDASH_VERSION_CHECK\", \"true\"))\nFEATURE_DISABLE_REFRESH_QUERIES = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_DISABLE_REFRESH_QUERIES\", \"false\")\n)\nFEATURE_SHOW_QUERY_RESULTS_COUNT = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_SHOW_QUERY_RESULTS_COUNT\", \"true\")\n)\nFEATURE_ALLOW_CUSTOM_JS_VISUALIZATIONS = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_ALLOW_CUSTOM_JS_VISUALIZATIONS\", \"false\")\n)\nFEATURE_AUTO_PUBLISH_NAMED_QUERIES = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_AUTO_PUBLISH_NAMED_QUERIES\", \"true\")\n)\nFEATURE_EXTENDED_ALERT_OPTIONS = parse_boolean(\n    os.environ.get(\"REDASH_FEATURE_EXTENDED_ALERT_OPTIONS\", \"false\")\n)\n\n# BigQuery\nBIGQUERY_HTTP_TIMEOUT = int(os.environ.get(\"REDASH_BIGQUERY_HTTP_TIMEOUT\", \"600\"))\n\n# Allow Parameters in Embeds\n# WARNING: Deprecated!\n# See https://discuss.redash.io/t/support-for-parameters-in-embedded-visualizations/3337 for more details.\nALLOW_PARAMETERS_IN_EMBEDS = parse_boolean(\n    os.environ.get(\"REDASH_ALLOW_PARAMETERS_IN_EMBEDS\", \"false\")\n)\n\n# Enhance schema fetching\nSCHEMA_RUN_TABLE_SIZE_CALCULATIONS = parse_boolean(\n    os.environ.get(\"REDASH_SCHEMA_RUN_TABLE_SIZE_CALCULATIONS\", \"false\")\n)\n\n# kylin\nKYLIN_OFFSET = int(os.environ.get(\"REDASH_KYLIN_OFFSET\", 0))\nKYLIN_LIMIT = int(os.environ.get(\"REDASH_KYLIN_LIMIT\", 50000))\nKYLIN_ACCEPT_PARTIAL = parse_boolean(\n    os.environ.get(\"REDASH_KYLIN_ACCEPT_PARTIAL\", \"false\")\n)\n\n# sqlparse\nSQLPARSE_FORMAT_OPTIONS = {\n    \"reindent\": parse_boolean(os.environ.get(\"SQLPARSE_FORMAT_REINDENT\", \"true\")),\n    \"keyword_case\": os.environ.get(\"SQLPARSE_FORMAT_KEYWORD_CASE\", \"upper\"),\n}\n\n# requests\nREQUESTS_ALLOW_REDIRECTS = parse_boolean(\n    os.environ.get(\"REDASH_REQUESTS_ALLOW_REDIRECTS\", \"false\")\n)\n\n# Enforces CSRF token validation on API requests.\n# This is turned off by default to avoid breaking any existing deployments but it is highly recommended to turn this toggle on to prevent CSRF attacks.\nENFORCE_CSRF = parse_boolean(\n    os.environ.get(\"REDASH_ENFORCE_CSRF\", \"false\")\n)\n\n# Databricks\n\nCSRF_TIME_LIMIT = int(os.environ.get(\"REDASH_CSRF_TIME_LIMIT\", 3600 * 6))\n\n# Email blocked domains, use delimiter comma to separated multiple domains\nBLOCKED_DOMAINS = set_from_string(os.environ.get(\"REDASH_BLOCKED_DOMAINS\", \"qq.com\"))\n", "Flask==1.1.1\nJinja2==2.10.3\nitsdangerous==1.1.0\nclick==6.7\nMarkupSafe==1.1.1\npyOpenSSL==19.0.0\nhttplib2==0.14.0\nwtforms==2.2.1\nFlask-RESTful==0.3.7\nFlask-Login==0.4.1\nFlask-SQLAlchemy==2.4.1\nFlask-Migrate==2.5.2\nflask-mail==0.9.1\nflask-talisman==0.7.0\nFlask-Limiter==0.9.3\nFlask-WTF==0.14.3\npasslib==1.7.1\naniso8601==8.0.0\nblinker==1.4\npsycopg2==2.8.3\npython-dateutil==2.8.0\npytz>=2019.3\nPyYAML==5.1.2\nredis==3.5.0\nrequests==2.21.0\nSQLAlchemy==1.3.10\n# We can't upgrade SQLAlchemy-Searchable version as newer versions require PostgreSQL > 9.6, but we target older versions at the moment.\nSQLAlchemy-Searchable==0.10.6\n# We need to pin the version of pyparsing, as newer versions break SQLAlchemy-Searchable-10.0.6 (newer versions no longer depend on it)\npyparsing==2.3.0\nSQLAlchemy-Utils==0.34.2\nsqlparse==0.3.0\nstatsd==3.3.0\ngreenlet==0.4.16\ngunicorn==20.0.4\nrq==1.5.0\nrq-scheduler==0.9.1\njsonschema==3.1.1\nRestrictedPython==5.0\npysaml2==6.1.0\npycrypto==2.6.1\npython-dotenv==0.19.2\nfuncy==1.13\nsentry-sdk>=0.14.3,<0.15.0\nsemver==2.8.1\nxlsxwriter==1.2.2\npystache==0.5.4\nparsedatetime==2.4\nPyJWT==1.7.1\ncryptography==2.8\nsimplejson==3.16.0\nua-parser==0.8.0\nuser-agents==2.0\nmaxminddb-geolite2==2018.703\npypd==1.1.0\ndisposable-email-domains>=0.0.52\ngevent==1.4.0\nsshtunnel==0.1.5\nsupervisor==4.1.0\nsupervisor_checks==0.8.1\nwerkzeug==0.16.1\n# Install the dependencies of the bin/bundle-extensions script here.\n# It has its own requirements file to simplify the frontend client build process\n-r requirements_bundles.txt\n# Uncomment the requirement for ldap3 if using ldap.\n# It is not included by default because of the GPL license conflict.\n# ldap3==2.2.4\nAuthlib==0.15.5"], "filenames": ["docker-compose.yml", "redash/settings/__init__.py", "requirements.txt"], "buggy_code_start_loc": [10, 67, 41], "buggy_code_end_loc": [18, 68, 41], "fixing_code_start_loc": [11, 67, 42], "fixing_code_end_loc": [22, 72, 43], "type": "CWE-1188", "message": "Redash is a package for data visualization and sharing. If an admin sets up Redash versions 10.0.0 and prior without explicitly specifying the `REDASH_COOKIE_SECRET` or `REDASH_SECRET_KEY` environment variables, a default value is used for both that is the same across all installations. In such cases, the instance is vulnerable to attackers being able to forge sessions using the known default value. This issue only affects installations where the `REDASH_COOKIE_SECRET or REDASH_SECRET_KEY` environment variables have not been explicitly set. This issue does not affect users of the official Redash cloud images, Redash's Digital Ocean marketplace droplets, or the scripts in the `getredash/setup` repository. These instances automatically generate unique secret keys during installation. One can verify whether one's instance is affected by checking the value of the `REDASH_COOKIE_SECRET` environment variable. If it is `c292a0a3aa32397cdb050e233733900f`, should follow the steps to secure the instance, outlined in the GitHub Security Advisory.", "other": {"cve": {"id": "CVE-2021-41192", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-24T16:15:14.173", "lastModified": "2022-03-29T18:05:30.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redash is a package for data visualization and sharing. If an admin sets up Redash versions 10.0.0 and prior without explicitly specifying the `REDASH_COOKIE_SECRET` or `REDASH_SECRET_KEY` environment variables, a default value is used for both that is the same across all installations. In such cases, the instance is vulnerable to attackers being able to forge sessions using the known default value. This issue only affects installations where the `REDASH_COOKIE_SECRET or REDASH_SECRET_KEY` environment variables have not been explicitly set. This issue does not affect users of the official Redash cloud images, Redash's Digital Ocean marketplace droplets, or the scripts in the `getredash/setup` repository. These instances automatically generate unique secret keys during installation. One can verify whether one's instance is affected by checking the value of the `REDASH_COOKIE_SECRET` environment variable. If it is `c292a0a3aa32397cdb050e233733900f`, should follow the steps to secure the instance, outlined in the GitHub Security Advisory."}, {"lang": "es", "value": "Redash es un paquete para visualizar y compartir datos. Si un administrador configura las versiones 10.0.0 y anteriores de Redash sin especificar expl\u00edcitamente las variables de entorno \"REDASH_COOKIE_SECRET\" o \"REDASH_SECRET_KEY\", es usado un valor por defecto para ambas que es el mismo en todas las instalaciones. En estos casos, la instancia es vulnerable a que los atacantes puedan falsificar sesiones usando el valor por defecto conocido. Este problema s\u00f3lo afecta a las instalaciones en las que las variables de entorno \"REDASH_COOKIE_SECRET o REDASH_SECRET_KEY\" no se han establecido expl\u00edcitamente. Este problema no afecta a usuarios de las im\u00e1genes oficiales de Redash en la nube, los droplets del mercado de Digital Ocean de Redash o los scripts del repositorio \"getredash/setup\". Estas instancias generan autom\u00e1ticamente claves secretas \u00fanicas durante la instalaci\u00f3n. Uno puede verificar si su instancia est\u00e1 afectada comprobando el valor de la variable de entorno \"REDASH_COOKIE_SECRET\". Si es \"c292a0a3aa32397cdb050e233733900f\", deben seguir los pasos para asegurar la instancia, indicados en el aviso de seguridad de GitHub"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1188"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1188"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redash:redash:*:*:*:*:*:*:*:*", "versionEndIncluding": "10.0.0", "matchCriteriaId": "5D326B6D-E6EE-4598-845F-63258E732F02"}]}]}], "references": [{"url": "https://github.com/getredash/redash/commit/ce60d20c4e3d1537581f2f70f1308fe77ab6a214", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/getredash/redash/security/advisories/GHSA-g8xr-f424-h2rv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://ian.sh/redash", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/getredash/redash/commit/ce60d20c4e3d1537581f2f70f1308fe77ab6a214"}}