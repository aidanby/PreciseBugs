{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\RememberMe;\n\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\n\n/**\n * Concrete implementation of the RememberMeServicesInterface providing\n * remember-me capabilities without requiring a TokenProvider.\n *\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\nclass TokenBasedRememberMeServices extends AbstractRememberMeServices\n{\n    /**\n     * {@inheritdoc}\n     */\n    protected function processAutoLoginCookie(array $cookieParts, Request $request)\n    {\n        if (4 !== \\count($cookieParts)) {\n            throw new AuthenticationException('The cookie is invalid.');\n        }\n\n        list($class, $username, $expires, $hash) = $cookieParts;\n        if (false === $username = base64_decode($username, true)) {\n            throw new AuthenticationException('$username contains a character from outside the base64 alphabet.');\n        }\n        try {\n            $user = $this->getUserProvider($class)->loadUserByUsername($username);\n        } catch (\\Exception $e) {\n            if (!$e instanceof AuthenticationException) {\n                $e = new AuthenticationException($e->getMessage(), $e->getCode(), $e);\n            }\n\n            throw $e;\n        }\n\n        if (!$user instanceof UserInterface) {\n            throw new \\RuntimeException(sprintf('The UserProviderInterface implementation must return an instance of UserInterface, but returned \"%s\".', \\get_class($user)));\n        }\n\n        if (true !== hash_equals($this->generateCookieHash($class, $username, $expires, $user->getPassword()), $hash)) {\n            throw new AuthenticationException('The cookie\\'s hash is invalid.');\n        }\n\n        if ($expires < time()) {\n            throw new AuthenticationException('The cookie has expired.');\n        }\n\n        return $user;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function onLoginSuccess(Request $request, Response $response, TokenInterface $token)\n    {\n        $user = $token->getUser();\n        $expires = time() + $this->options['lifetime'];\n        $value = $this->generateCookieValue(\\get_class($user), $user->getUsername(), $expires, $user->getPassword());\n\n        $response->headers->setCookie(\n            new Cookie(\n                $this->options['name'],\n                $value,\n                $expires,\n                $this->options['path'],\n                $this->options['domain'],\n                $this->options['secure'],\n                $this->options['httponly']\n            )\n        );\n    }\n\n    /**\n     * Generates the cookie value.\n     *\n     * @param string $class\n     * @param string $username The username\n     * @param int    $expires  The Unix timestamp when the cookie expires\n     * @param string $password The encoded password\n     *\n     * @return string\n     */\n    protected function generateCookieValue($class, $username, $expires, $password)\n    {\n        // $username is encoded because it might contain COOKIE_DELIMITER,\n        // we assume other values don't\n        return $this->encodeCookie([\n            $class,\n            base64_encode($username),\n            $expires,\n            $this->generateCookieHash($class, $username, $expires, $password),\n        ]);\n    }\n\n    /**\n     * Generates a hash for the cookie to ensure it is not being tempered with.\n     *\n     * @param string $class\n     * @param string $username The username\n     * @param int    $expires  The Unix timestamp when the cookie expires\n     * @param string $password The encoded password\n     *\n     * @return string\n     */\n    protected function generateCookieHash($class, $username, $expires, $password)\n    {\n        return hash_hmac('sha256', $class.$username.$expires.$password, $this->getSecret());\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\RememberMe;\n\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationException;\nuse Symfony\\Component\\Security\\Core\\User\\UserInterface;\n\n/**\n * Concrete implementation of the RememberMeServicesInterface providing\n * remember-me capabilities without requiring a TokenProvider.\n *\n * @author Johannes M. Schmitt <schmittjoh@gmail.com>\n */\nclass TokenBasedRememberMeServices extends AbstractRememberMeServices\n{\n    /**\n     * {@inheritdoc}\n     */\n    protected function processAutoLoginCookie(array $cookieParts, Request $request)\n    {\n        if (4 !== \\count($cookieParts)) {\n            throw new AuthenticationException('The cookie is invalid.');\n        }\n\n        list($class, $username, $expires, $hash) = $cookieParts;\n        if (false === $username = base64_decode($username, true)) {\n            throw new AuthenticationException('$username contains a character from outside the base64 alphabet.');\n        }\n        try {\n            $user = $this->getUserProvider($class)->loadUserByUsername($username);\n        } catch (\\Exception $e) {\n            if (!$e instanceof AuthenticationException) {\n                $e = new AuthenticationException($e->getMessage(), $e->getCode(), $e);\n            }\n\n            throw $e;\n        }\n\n        if (!$user instanceof UserInterface) {\n            throw new \\RuntimeException(sprintf('The UserProviderInterface implementation must return an instance of UserInterface, but returned \"%s\".', \\get_class($user)));\n        }\n\n        if (true !== hash_equals($this->generateCookieHash($class, $username, $expires, $user->getPassword()), $hash)) {\n            throw new AuthenticationException('The cookie\\'s hash is invalid.');\n        }\n\n        if ($expires < time()) {\n            throw new AuthenticationException('The cookie has expired.');\n        }\n\n        return $user;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function onLoginSuccess(Request $request, Response $response, TokenInterface $token)\n    {\n        $user = $token->getUser();\n        $expires = time() + $this->options['lifetime'];\n        $value = $this->generateCookieValue(\\get_class($user), $user->getUsername(), $expires, $user->getPassword());\n\n        $response->headers->setCookie(\n            new Cookie(\n                $this->options['name'],\n                $value,\n                $expires,\n                $this->options['path'],\n                $this->options['domain'],\n                $this->options['secure'],\n                $this->options['httponly']\n            )\n        );\n    }\n\n    /**\n     * Generates the cookie value.\n     *\n     * @param string $class\n     * @param string $username The username\n     * @param int    $expires  The Unix timestamp when the cookie expires\n     * @param string $password The encoded password\n     *\n     * @return string\n     */\n    protected function generateCookieValue($class, $username, $expires, $password)\n    {\n        // $username is encoded because it might contain COOKIE_DELIMITER,\n        // we assume other values don't\n        return $this->encodeCookie([\n            $class,\n            base64_encode($username),\n            $expires,\n            $this->generateCookieHash($class, $username, $expires, $password),\n        ]);\n    }\n\n    /**\n     * Generates a hash for the cookie to ensure it is not being tempered with.\n     *\n     * @param string $class\n     * @param string $username The username\n     * @param int    $expires  The Unix timestamp when the cookie expires\n     * @param string $password The encoded password\n     *\n     * @return string\n     */\n    protected function generateCookieHash($class, $username, $expires, $password)\n    {\n        return hash_hmac('sha256', $class.self::COOKIE_DELIMITER.$username.self::COOKIE_DELIMITER.$expires.self::COOKIE_DELIMITER.$password, $this->getSecret());\n    }\n}\n"], "filenames": ["src/Symfony/Component/Security/Http/RememberMe/TokenBasedRememberMeServices.php"], "buggy_code_start_loc": [123], "buggy_code_end_loc": [124], "fixing_code_start_loc": [123], "fixing_code_end_loc": [124], "type": "CWE-287", "message": "In Symfony before 2.7.51, 2.8.x before 2.8.50, 3.x before 3.4.26, 4.x before 4.1.12, and 4.2.x before 4.2.7, a vulnerability would allow an attacker to authenticate as a privileged user on sites with user registration and remember me login functionality enabled. This is related to symfony/security.", "other": {"cve": {"id": "CVE-2019-10911", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-16T22:29:00.500", "lastModified": "2021-09-29T16:27:10.053", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Symfony before 2.7.51, 2.8.x before 2.8.50, 3.x before 3.4.26, 4.x before 4.1.12, and 4.2.x before 4.2.7, a vulnerability would allow an attacker to authenticate as a privileged user on sites with user registration and remember me login functionality enabled. This is related to symfony/security."}, {"lang": "es", "value": "En Symfony la versi\u00f3n anterior a  2.7.51, versi\u00f3n 2.8.x anterior a 2.8.50, versi\u00f3n 3.x anterior a 3.4.26, versi\u00f3n 4.x anterior a 4.1.12 y versi\u00f3n 4.2.x anterior a 4.2.7, una vulnerabilidad permitir\u00eda que un atacante se identifique como un Usuario privilegiado en sitios con registro de usuario y recordar la funcionalidad de inicio de sesi\u00f3n habilitada. Esto est\u00e1 relacionado con Symfony/Seguridad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.51", "matchCriteriaId": "A86884C0-A185-4CCF-AB21-1D1529AEDAED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.50", "matchCriteriaId": "A4716654-1055-44B3-8E51-5BC0E739E0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.26", "matchCriteriaId": "CF53486E-FAAC-40B3-82CE-4EDCD2C96690"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.12", "matchCriteriaId": "25A92454-6E0B-4BDE-8967-BB3E32125102"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndExcluding": "4.2.7", "matchCriteriaId": "53E58B92-6D5D-4949-B75F-687F52961FDA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.5.0", "versionEndExcluding": "8.5.15", "matchCriteriaId": "9106BF81-B898-4EB0-B63C-9919D3B22260"}, {"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.6.0", "versionEndExcluding": "8.6.15", "matchCriteriaId": "9B37281E-9B44-42A5-AE0A-17CE6770995C"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/a29ce2817cf43bb1850cf6af114004ac26c7a081", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://symfony.com/blog/cve-2019-10911-add-a-separator-in-the-remember-me-cookie-hash", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.synology.com/security/advisory/Synology_SA_19_19", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/a29ce2817cf43bb1850cf6af114004ac26c7a081"}}