{"buggy_code": ["const middlewares = require('../lib/middlewares');\nconst AppCache = require('../lib/cache').AppCache;\n\ndescribe('middlewares', () => {\n  let fakeReq, fakeRes;\n\n  beforeEach(() => {\n    fakeReq = {\n      originalUrl: 'http://example.com/parse/',\n      url: 'http://example.com/',\n      body: {\n        _ApplicationId: 'FakeAppId',\n      },\n      headers: {},\n      get: key => {\n        return fakeReq.headers[key.toLowerCase()];\n      },\n    };\n    fakeRes = jasmine.createSpyObj('fakeRes', ['end', 'status']);\n    AppCache.put(fakeReq.body._ApplicationId, {});\n  });\n\n  afterEach(() => {\n    AppCache.del(fakeReq.body._ApplicationId);\n  });\n\n  it('should use _ContentType if provided', done => {\n    expect(fakeReq.headers['content-type']).toEqual(undefined);\n    const contentType = 'image/jpeg';\n    fakeReq.body._ContentType = contentType;\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeReq.headers['content-type']).toEqual(contentType);\n      expect(fakeReq.body._ContentType).toEqual(undefined);\n      done();\n    });\n  });\n\n  it('should give invalid response when keys are configured but no key supplied', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should give invalid response when keys are configured but supplied key is incorrect', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    fakeReq.headers['x-parse-rest-api-key'] = 'wrongKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should give invalid response when keys are configured but different key is supplied', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    fakeReq.headers['x-parse-client-key'] = 'clientKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should succeed when any one of the configured keys supplied', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      clientKey: 'clientKey',\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    fakeReq.headers['x-parse-rest-api-key'] = 'restAPIKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should succeed when client key supplied but empty', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      clientKey: '',\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    fakeReq.headers['x-parse-client-key'] = '';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should succeed when no keys are configured and none supplied', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n    });\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  const BodyParams = {\n    clientVersion: '_ClientVersion',\n    installationId: '_InstallationId',\n    sessionToken: '_SessionToken',\n    masterKey: '_MasterKey',\n    javascriptKey: '_JavaScriptKey',\n  };\n\n  const BodyKeys = Object.keys(BodyParams);\n\n  BodyKeys.forEach(infoKey => {\n    const bodyKey = BodyParams[infoKey];\n    const keyValue = 'Fake' + bodyKey;\n    // javascriptKey is the only one that gets defaulted,\n    const otherKeys = BodyKeys.filter(\n      otherKey => otherKey !== infoKey && otherKey !== 'javascriptKey'\n    );\n\n    it(`it should pull ${bodyKey} into req.info`, done => {\n      fakeReq.body[bodyKey] = keyValue;\n\n      middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n        expect(fakeReq.body[bodyKey]).toEqual(undefined);\n        expect(fakeReq.info[infoKey]).toEqual(keyValue);\n\n        otherKeys.forEach(otherKey => {\n          expect(fakeReq.info[otherKey]).toEqual(undefined);\n        });\n\n        done();\n      });\n    });\n  });\n\n  it('should not succeed if the ip does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.ip = 'ip3';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should succeed if the ip does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.ip = 'ip1';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should not succeed if the connection.remoteAddress does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.connection = { remoteAddress: 'ip3' };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should succeed if the connection.remoteAddress does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.connection = { remoteAddress: 'ip1' };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should not succeed if the socket.remoteAddress does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.socket = { remoteAddress: 'ip3' };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should succeed if the socket.remoteAddress does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.socket = { remoteAddress: 'ip1' };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should not succeed if the connection.socket.remoteAddress does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.connection = { socket: { remoteAddress: 'ip3' } };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should succeed if the connection.socket.remoteAddress does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.connection = { socket: { remoteAddress: 'ip1' } };\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should allow any ip to use masterKey if masterKeyIps is empty', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: [],\n    });\n    fakeReq.ip = 'ip1';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should succeed if xff header does belong to masterKeyIps', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1'],\n    });\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    fakeReq.headers['x-forwarded-for'] = 'ip1, ip2, ip3';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should succeed if xff header with one ip does belong to masterKeyIps', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1'],\n    });\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    fakeReq.headers['x-forwarded-for'] = 'ip1';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should not succeed if xff header does not belong to masterKeyIps', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip4'],\n    });\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    fakeReq.headers['x-forwarded-for'] = 'ip1, ip2, ip3';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should not succeed if xff header is empty and masterKeyIps is set', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1'],\n    });\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    fakeReq.headers['x-forwarded-for'] = '';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should properly expose the headers', () => {\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(Object.keys(headers).length).toBe(4);\n    expect(headers['Access-Control-Expose-Headers']).toBe(\n      'X-Parse-Job-Status-Id, X-Parse-Push-Status-Id'\n    );\n  });\n\n  it('should set default Access-Control-Allow-Headers if allowHeaders are empty', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: undefined,\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: [],\n    });\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n  });\n\n  it('should append custom headers to Access-Control-Allow-Headers if allowHeaders provided', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: ['Header-1', 'Header-2'],\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain('Header-1, Header-2');\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n  });\n\n  it('should set default Access-Control-Allow-Origin if allowOrigin is empty', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowOrigin: undefined,\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Origin']).toEqual('*');\n  });\n\n  it('should set custom origin to Access-Control-Allow-Origin if allowOrigin is provided', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowOrigin: 'https://parseplatform.org/',\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Origin']).toEqual('https://parseplatform.org/');\n  });\n\n  it('should use user provided on field userFromJWT', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n    });\n    fakeReq.userFromJWT = 'fake-user';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeReq.auth.user).toEqual('fake-user');\n      done();\n    });\n  });\n\n  it('should give invalid response when upload file without x-parse-application-id in header', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n    });\n    fakeReq.body = Buffer.from('fake-file');\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n});\n", "/*\n**** GENERATED CODE ****\nThis code has been generated by resources/buildConfigDefinitions.js\nDo not edit manually, but update Options/index.js\n*/\nvar parsers = require('./parsers');\n\nmodule.exports.SchemaOptions = {\n  afterMigration: {\n    env: 'PARSE_SERVER_SCHEMA_AFTER_MIGRATION',\n    help: 'Execute a callback after running schema migrations.',\n  },\n  beforeMigration: {\n    env: 'PARSE_SERVER_SCHEMA_BEFORE_MIGRATION',\n    help: 'Execute a callback before running schema migrations.',\n  },\n  definitions: {\n    env: 'PARSE_SERVER_SCHEMA_DEFINITIONS',\n    help:\n      'Rest representation on Parse.Schema https://docs.parseplatform.org/rest/guide/#adding-a-schema',\n    required: true,\n    action: parsers.objectParser,\n    default: [],\n  },\n  deleteExtraFields: {\n    env: 'PARSE_SERVER_SCHEMA_DELETE_EXTRA_FIELDS',\n    help:\n      'Is true if Parse Server should delete any fields not defined in a schema definition. This should only be used during development.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  lockSchemas: {\n    env: 'PARSE_SERVER_SCHEMA_LOCK_SCHEMAS',\n    help:\n      'Is true if Parse Server will reject any attempts to modify the schema while the server is running.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  recreateModifiedFields: {\n    env: 'PARSE_SERVER_SCHEMA_RECREATE_MODIFIED_FIELDS',\n    help:\n      'Is true if Parse Server should recreate any fields that are different between the current database schema and theschema definition. This should only be used during development.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  strict: {\n    env: 'PARSE_SERVER_SCHEMA_STRICT',\n    help: 'Is true if Parse Server should exit if schema update fail.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.ParseServerOptions = {\n  accountLockout: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT',\n    help: 'The account lockout policy for failed login attempts.',\n    action: parsers.objectParser,\n  },\n  allowClientClassCreation: {\n    env: 'PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION',\n    help: 'Enable (or disable) client class creation, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  allowCustomObjectId: {\n    env: 'PARSE_SERVER_ALLOW_CUSTOM_OBJECT_ID',\n    help: 'Enable (or disable) custom objectId',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  allowHeaders: {\n    env: 'PARSE_SERVER_ALLOW_HEADERS',\n    help: 'Add headers to Access-Control-Allow-Headers',\n    action: parsers.arrayParser,\n  },\n  allowOrigin: {\n    env: 'PARSE_SERVER_ALLOW_ORIGIN',\n    help: 'Sets the origin to Access-Control-Allow-Origin',\n  },\n  analyticsAdapter: {\n    env: 'PARSE_SERVER_ANALYTICS_ADAPTER',\n    help: 'Adapter module for the analytics',\n    action: parsers.moduleOrObjectParser,\n  },\n  appId: {\n    env: 'PARSE_SERVER_APPLICATION_ID',\n    help: 'Your Parse Application ID',\n    required: true,\n  },\n  appName: {\n    env: 'PARSE_SERVER_APP_NAME',\n    help: 'Sets the app name',\n  },\n  auth: {\n    env: 'PARSE_SERVER_AUTH_PROVIDERS',\n    help:\n      'Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication',\n    action: parsers.arrayParser,\n  },\n  cacheAdapter: {\n    env: 'PARSE_SERVER_CACHE_ADAPTER',\n    help: 'Adapter module for the cache',\n    action: parsers.moduleOrObjectParser,\n  },\n  cacheMaxSize: {\n    env: 'PARSE_SERVER_CACHE_MAX_SIZE',\n    help: 'Sets the maximum size for the in memory cache, defaults to 10000',\n    action: parsers.numberParser('cacheMaxSize'),\n    default: 10000,\n  },\n  cacheTTL: {\n    env: 'PARSE_SERVER_CACHE_TTL',\n    help: 'Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)',\n    action: parsers.numberParser('cacheTTL'),\n    default: 5000,\n  },\n  clientKey: {\n    env: 'PARSE_SERVER_CLIENT_KEY',\n    help: 'Key for iOS, MacOS, tvOS clients',\n  },\n  cloud: {\n    env: 'PARSE_SERVER_CLOUD',\n    help: 'Full path to your cloud code main.js',\n  },\n  cluster: {\n    env: 'PARSE_SERVER_CLUSTER',\n    help: 'Run with cluster, optionally set the number of processes default to os.cpus().length',\n    action: parsers.numberOrBooleanParser,\n  },\n  collectionPrefix: {\n    env: 'PARSE_SERVER_COLLECTION_PREFIX',\n    help: 'A collection prefix for the classes',\n    default: '',\n  },\n  customPages: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES',\n    help: 'custom pages for password validation and reset',\n    action: parsers.objectParser,\n    default: {},\n  },\n  databaseAdapter: {\n    env: 'PARSE_SERVER_DATABASE_ADAPTER',\n    help:\n      'Adapter module for the database; any options that are not explicitly described here are passed directly to the database client.',\n    action: parsers.moduleOrObjectParser,\n  },\n  databaseOptions: {\n    env: 'PARSE_SERVER_DATABASE_OPTIONS',\n    help: 'Options to pass to the database client',\n    action: parsers.objectParser,\n  },\n  databaseURI: {\n    env: 'PARSE_SERVER_DATABASE_URI',\n    help: 'The full URI to your database. Supported databases are mongodb or postgres.',\n    required: true,\n    default: 'mongodb://localhost:27017/parse',\n  },\n  defaultLimit: {\n    env: 'PARSE_SERVER_DEFAULT_LIMIT',\n    help: 'Default value for limit option on queries, defaults to `100`.',\n    action: parsers.numberParser('defaultLimit'),\n    default: 100,\n  },\n  directAccess: {\n    env: 'PARSE_SERVER_DIRECT_ACCESS',\n    help:\n      'Set to `true` if Parse requests within the same Node.js environment as Parse Server should be routed to Parse Server directly instead of via the HTTP interface. Default is `false`.<br><br>If set to `false` then Parse requests within the same Node.js environment as Parse Server are executed as HTTP requests sent to Parse Server via the `serverURL`. For example, a `Parse.Query` in Cloud Code is calling Parse Server via a HTTP request. The server is essentially making a HTTP request to itself, unnecessarily using network resources such as network ports.<br><br>\\u26A0\\uFE0F In environments where multiple Parse Server instances run behind a load balancer and Parse requests within the current Node.js environment should be routed via the load balancer and distributed as HTTP requests among all instances via the `serverURL`, this should be set to `false`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  dotNetKey: {\n    env: 'PARSE_SERVER_DOT_NET_KEY',\n    help: 'Key for Unity and .Net SDK',\n  },\n  emailAdapter: {\n    env: 'PARSE_SERVER_EMAIL_ADAPTER',\n    help: 'Adapter module for email sending',\n    action: parsers.moduleOrObjectParser,\n  },\n  emailVerifyTokenReuseIfValid: {\n    env: 'PARSE_SERVER_EMAIL_VERIFY_TOKEN_REUSE_IF_VALID',\n    help:\n      'Set to `true` if a email verification token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.<br><br>Default is `false`.<br>Requires option `verifyUserEmails: true`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  emailVerifyTokenValidityDuration: {\n    env: 'PARSE_SERVER_EMAIL_VERIFY_TOKEN_VALIDITY_DURATION',\n    help:\n      'Set the validity duration of the email verification token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.<br><br>For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).<br><br>Default is `undefined`.<br>Requires option `verifyUserEmails: true`.',\n    action: parsers.numberParser('emailVerifyTokenValidityDuration'),\n  },\n  enableAnonymousUsers: {\n    env: 'PARSE_SERVER_ENABLE_ANON_USERS',\n    help: 'Enable (or disable) anonymous users, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  enableExpressErrorHandler: {\n    env: 'PARSE_SERVER_ENABLE_EXPRESS_ERROR_HANDLER',\n    help: 'Enables the default express error handler for all errors',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  encryptionKey: {\n    env: 'PARSE_SERVER_ENCRYPTION_KEY',\n    help: 'Key for encrypting your files',\n  },\n  enforcePrivateUsers: {\n    env: 'PARSE_SERVER_ENFORCE_PRIVATE_USERS',\n    help: 'Set to true if new users should be created without public read and write access.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  expireInactiveSessions: {\n    env: 'PARSE_SERVER_EXPIRE_INACTIVE_SESSIONS',\n    help:\n      'Sets whether we should expire the inactive sessions, defaults to true. If false, all new sessions are created with no expiration date.',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  fileKey: {\n    env: 'PARSE_SERVER_FILE_KEY',\n    help: 'Key for your files',\n  },\n  filesAdapter: {\n    env: 'PARSE_SERVER_FILES_ADAPTER',\n    help: 'Adapter module for the files sub-system',\n    action: parsers.moduleOrObjectParser,\n  },\n  fileUpload: {\n    env: 'PARSE_SERVER_FILE_UPLOAD_OPTIONS',\n    help: 'Options for file uploads',\n    action: parsers.objectParser,\n    default: {},\n  },\n  graphQLPath: {\n    env: 'PARSE_SERVER_GRAPHQL_PATH',\n    help: 'Mount path for the GraphQL endpoint, defaults to /graphql',\n    default: '/graphql',\n  },\n  graphQLSchema: {\n    env: 'PARSE_SERVER_GRAPH_QLSCHEMA',\n    help: 'Full path to your GraphQL custom schema.graphql file',\n  },\n  host: {\n    env: 'PARSE_SERVER_HOST',\n    help: 'The host to serve ParseServer on, defaults to 0.0.0.0',\n    default: '0.0.0.0',\n  },\n  idempotencyOptions: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_OPTIONS',\n    help:\n      'Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  javascriptKey: {\n    env: 'PARSE_SERVER_JAVASCRIPT_KEY',\n    help: 'Key for the Javascript SDK',\n  },\n  jsonLogs: {\n    env: 'JSON_LOGS',\n    help: 'Log as structured JSON objects',\n    action: parsers.booleanParser,\n  },\n  liveQuery: {\n    env: 'PARSE_SERVER_LIVE_QUERY',\n    help: \"parse-server's LiveQuery configuration object\",\n    action: parsers.objectParser,\n  },\n  liveQueryServerOptions: {\n    env: 'PARSE_SERVER_LIVE_QUERY_SERVER_OPTIONS',\n    help: 'Live query server configuration options (will start the liveQuery server)',\n    action: parsers.objectParser,\n  },\n  loggerAdapter: {\n    env: 'PARSE_SERVER_LOGGER_ADAPTER',\n    help: 'Adapter module for the logging sub-system',\n    action: parsers.moduleOrObjectParser,\n  },\n  logLevel: {\n    env: 'PARSE_SERVER_LOG_LEVEL',\n    help: 'Sets the level for logs',\n  },\n  logsFolder: {\n    env: 'PARSE_SERVER_LOGS_FOLDER',\n    help: \"Folder for the logs (defaults to './logs'); set to null to disable file based logging\",\n    default: './logs',\n  },\n  masterKey: {\n    env: 'PARSE_SERVER_MASTER_KEY',\n    help: 'Your Parse Master Key',\n    required: true,\n  },\n  masterKeyIps: {\n    env: 'PARSE_SERVER_MASTER_KEY_IPS',\n    help: 'Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  maxLimit: {\n    env: 'PARSE_SERVER_MAX_LIMIT',\n    help: 'Max value for limit option on queries, defaults to unlimited',\n    action: parsers.numberParser('maxLimit'),\n  },\n  maxLogFiles: {\n    env: 'PARSE_SERVER_MAX_LOG_FILES',\n    help:\n      \"Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null)\",\n    action: parsers.objectParser,\n  },\n  maxUploadSize: {\n    env: 'PARSE_SERVER_MAX_UPLOAD_SIZE',\n    help: 'Max file size for uploads, defaults to 20mb',\n    default: '20mb',\n  },\n  middleware: {\n    env: 'PARSE_SERVER_MIDDLEWARE',\n    help: 'middleware for express server, can be string or function',\n  },\n  mountGraphQL: {\n    env: 'PARSE_SERVER_MOUNT_GRAPHQL',\n    help: 'Mounts the GraphQL endpoint',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  mountPath: {\n    env: 'PARSE_SERVER_MOUNT_PATH',\n    help: 'Mount path for the server, defaults to /parse',\n    default: '/parse',\n  },\n  mountPlayground: {\n    env: 'PARSE_SERVER_MOUNT_PLAYGROUND',\n    help: 'Mounts the GraphQL Playground - never use this option in production',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  objectIdSize: {\n    env: 'PARSE_SERVER_OBJECT_ID_SIZE',\n    help: \"Sets the number of characters in generated object id's, default 10\",\n    action: parsers.numberParser('objectIdSize'),\n    default: 10,\n  },\n  pages: {\n    env: 'PARSE_SERVER_PAGES',\n    help:\n      'The options for pages such as password reset and email verification. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  passwordPolicy: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY',\n    help: 'The password policy for enforcing password related rules.',\n    action: parsers.objectParser,\n  },\n  playgroundPath: {\n    env: 'PARSE_SERVER_PLAYGROUND_PATH',\n    help: 'Mount path for the GraphQL Playground, defaults to /playground',\n    default: '/playground',\n  },\n  port: {\n    env: 'PORT',\n    help: 'The port to run the ParseServer, defaults to 1337.',\n    action: parsers.numberParser('port'),\n    default: 1337,\n  },\n  preserveFileName: {\n    env: 'PARSE_SERVER_PRESERVE_FILE_NAME',\n    help: 'Enable (or disable) the addition of a unique hash to the file names',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  preventLoginWithUnverifiedEmail: {\n    env: 'PARSE_SERVER_PREVENT_LOGIN_WITH_UNVERIFIED_EMAIL',\n    help:\n      'Set to `true` to prevent a user from logging in if the email has not yet been verified and email verification is required.<br><br>Default is `false`.<br>Requires option `verifyUserEmails: true`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  protectedFields: {\n    env: 'PARSE_SERVER_PROTECTED_FIELDS',\n    help: 'Protected fields that should be treated with extra security when fetching details.',\n    action: parsers.objectParser,\n    default: {\n      _User: {\n        '*': ['email'],\n      },\n    },\n  },\n  publicServerURL: {\n    env: 'PARSE_PUBLIC_SERVER_URL',\n    help: 'Public URL to your parse server with http:// or https://.',\n  },\n  push: {\n    env: 'PARSE_SERVER_PUSH',\n    help:\n      'Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications',\n    action: parsers.objectParser,\n  },\n  readOnlyMasterKey: {\n    env: 'PARSE_SERVER_READ_ONLY_MASTER_KEY',\n    help: 'Read-only key, which has the same capabilities as MasterKey without writes',\n  },\n  requestKeywordDenylist: {\n    env: 'PARSE_SERVER_REQUEST_KEYWORD_DENYLIST',\n    help:\n      'An array of keys and values that are prohibited in database read and write requests to prevent potential security vulnerabilities. It is possible to specify only a key (`{\"key\":\"...\"}`), only a value (`{\"value\":\"...\"}`) or a key-value pair (`{\"key\":\"...\",\"value\":\"...\"}`). The specification can use the following types: `boolean`, `numeric` or `string`, where `string` will be interpreted as a regex notation. Request data is deep-scanned for matching definitions to detect also any nested occurrences. Defaults are patterns that are likely to be used in malicious requests. Setting this option will override the default patterns.',\n    action: parsers.arrayParser,\n    default: [\n      {\n        key: '_bsontype',\n        value: 'Code',\n      },\n      {\n        key: 'constructor',\n      },\n      {\n        key: '__proto__',\n      },\n    ],\n  },\n  restAPIKey: {\n    env: 'PARSE_SERVER_REST_API_KEY',\n    help: 'Key for REST calls',\n  },\n  revokeSessionOnPasswordReset: {\n    env: 'PARSE_SERVER_REVOKE_SESSION_ON_PASSWORD_RESET',\n    help:\n      \"When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\",\n    action: parsers.booleanParser,\n    default: true,\n  },\n  scheduledPush: {\n    env: 'PARSE_SERVER_SCHEDULED_PUSH',\n    help: 'Configuration for push scheduling, defaults to false.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  schema: {\n    env: 'PARSE_SERVER_SCHEMA',\n    help: 'Defined schema',\n    action: parsers.objectParser,\n  },\n  security: {\n    env: 'PARSE_SERVER_SECURITY',\n    help: 'The security options to identify and report weak security settings.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  serverCloseComplete: {\n    env: 'PARSE_SERVER_SERVER_CLOSE_COMPLETE',\n    help: 'Callback when server has closed',\n  },\n  serverStartComplete: {\n    env: 'PARSE_SERVER_SERVER_START_COMPLETE',\n    help: 'Callback when server has started',\n  },\n  serverURL: {\n    env: 'PARSE_SERVER_URL',\n    help: 'URL to your parse server with http:// or https://.',\n    required: true,\n  },\n  sessionLength: {\n    env: 'PARSE_SERVER_SESSION_LENGTH',\n    help: 'Session duration, in seconds, defaults to 1 year',\n    action: parsers.numberParser('sessionLength'),\n    default: 31536000,\n  },\n  silent: {\n    env: 'SILENT',\n    help: 'Disables console output',\n    action: parsers.booleanParser,\n  },\n  startLiveQueryServer: {\n    env: 'PARSE_SERVER_START_LIVE_QUERY_SERVER',\n    help: 'Starts the liveQuery server',\n    action: parsers.booleanParser,\n  },\n  userSensitiveFields: {\n    env: 'PARSE_SERVER_USER_SENSITIVE_FIELDS',\n    help:\n      'Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields',\n    action: parsers.arrayParser,\n  },\n  verbose: {\n    env: 'VERBOSE',\n    help: 'Set the logging to verbose',\n    action: parsers.booleanParser,\n  },\n  verifyUserEmails: {\n    env: 'PARSE_SERVER_VERIFY_USER_EMAILS',\n    help:\n      'Set to `true` to require users to verify their email address to complete the sign-up process.<br><br>Default is `false`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  webhookKey: {\n    env: 'PARSE_SERVER_WEBHOOK_KEY',\n    help: 'Key sent with outgoing webhook calls',\n  },\n};\nmodule.exports.SecurityOptions = {\n  checkGroups: {\n    env: 'PARSE_SERVER_SECURITY_CHECK_GROUPS',\n    help:\n      'The security check groups to run. This allows to add custom security checks or override existing ones. Default are the groups defined in `CheckGroups.js`.',\n    action: parsers.arrayParser,\n  },\n  enableCheck: {\n    env: 'PARSE_SERVER_SECURITY_ENABLE_CHECK',\n    help: 'Is true if Parse Server should check for weak security settings.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  enableCheckLog: {\n    env: 'PARSE_SERVER_SECURITY_ENABLE_CHECK_LOG',\n    help:\n      'Is true if the security check report should be written to logs. This should only be enabled temporarily to not expose weak security settings in logs.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.PagesOptions = {\n  customRoutes: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_ROUTES',\n    help: 'The custom routes.',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  customUrls: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URLS',\n    help: 'The URLs to the custom pages.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  enableLocalization: {\n    env: 'PARSE_SERVER_PAGES_ENABLE_LOCALIZATION',\n    help: 'Is true if pages should be localized; this has no effect on custom page redirects.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  enableRouter: {\n    env: 'PARSE_SERVER_PAGES_ENABLE_ROUTER',\n    help:\n      'Is true if the pages router should be enabled; this is required for any of the pages options to take effect. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  forceRedirect: {\n    env: 'PARSE_SERVER_PAGES_FORCE_REDIRECT',\n    help:\n      'Is true if responses should always be redirects and never content, false if the response type should depend on the request type (GET request -> content response; POST request -> redirect response).',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  localizationFallbackLocale: {\n    env: 'PARSE_SERVER_PAGES_LOCALIZATION_FALLBACK_LOCALE',\n    help:\n      'The fallback locale for localization if no matching translation is provided for the given locale. This is only relevant when providing translation resources via JSON file.',\n    default: 'en',\n  },\n  localizationJsonPath: {\n    env: 'PARSE_SERVER_PAGES_LOCALIZATION_JSON_PATH',\n    help:\n      'The path to the JSON file for localization; the translations will be used to fill template placeholders according to the locale.',\n  },\n  pagesEndpoint: {\n    env: 'PARSE_SERVER_PAGES_PAGES_ENDPOINT',\n    help: \"The API endpoint for the pages. Default is 'apps'.\",\n    default: 'apps',\n  },\n  pagesPath: {\n    env: 'PARSE_SERVER_PAGES_PAGES_PATH',\n    help:\n      \"The path to the pages directory; this also defines where the static endpoint '/apps' points to. Default is the './public/' directory.\",\n    default: './public',\n  },\n  placeholders: {\n    env: 'PARSE_SERVER_PAGES_PLACEHOLDERS',\n    help:\n      'The placeholder keys and values which will be filled in pages; this can be a simple object or a callback function.',\n    action: parsers.objectParser,\n    default: {},\n  },\n};\nmodule.exports.PagesRoute = {\n  handler: {\n    env: 'PARSE_SERVER_PAGES_ROUTE_HANDLER',\n    help: 'The route handler that is an async function.',\n    required: true,\n  },\n  method: {\n    env: 'PARSE_SERVER_PAGES_ROUTE_METHOD',\n    help: \"The route method, e.g. 'GET' or 'POST'.\",\n    required: true,\n  },\n  path: {\n    env: 'PARSE_SERVER_PAGES_ROUTE_PATH',\n    help: 'The route path.',\n    required: true,\n  },\n};\nmodule.exports.PagesCustomUrlsOptions = {\n  emailVerificationLinkExpired: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_LINK_EXPIRED',\n    help: 'The URL to the custom page for email verification -> link expired.',\n  },\n  emailVerificationLinkInvalid: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_LINK_INVALID',\n    help: 'The URL to the custom page for email verification -> link invalid.',\n  },\n  emailVerificationSendFail: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_SEND_FAIL',\n    help: 'The URL to the custom page for email verification -> link send fail.',\n  },\n  emailVerificationSendSuccess: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_SEND_SUCCESS',\n    help: 'The URL to the custom page for email verification -> resend link -> success.',\n  },\n  emailVerificationSuccess: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_SUCCESS',\n    help: 'The URL to the custom page for email verification -> success.',\n  },\n  passwordReset: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_PASSWORD_RESET',\n    help: 'The URL to the custom page for password reset.',\n  },\n  passwordResetLinkInvalid: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_PASSWORD_RESET_LINK_INVALID',\n    help: 'The URL to the custom page for password reset -> link invalid.',\n  },\n  passwordResetSuccess: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_PASSWORD_RESET_SUCCESS',\n    help: 'The URL to the custom page for password reset -> success.',\n  },\n};\nmodule.exports.CustomPagesOptions = {\n  choosePassword: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_CHOOSE_PASSWORD',\n    help: 'choose password page path',\n  },\n  expiredVerificationLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_EXPIRED_VERIFICATION_LINK',\n    help: 'expired verification link page path',\n  },\n  invalidLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_LINK',\n    help: 'invalid link page path',\n  },\n  invalidPasswordResetLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_PASSWORD_RESET_LINK',\n    help: 'invalid password reset link page path',\n  },\n  invalidVerificationLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_VERIFICATION_LINK',\n    help: 'invalid verification link page path',\n  },\n  linkSendFail: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_LINK_SEND_FAIL',\n    help: 'verification link send fail page path',\n  },\n  linkSendSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_LINK_SEND_SUCCESS',\n    help: 'verification link send success page path',\n  },\n  parseFrameURL: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_PARSE_FRAME_URL',\n    help: 'for masking user-facing pages',\n  },\n  passwordResetSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_PASSWORD_RESET_SUCCESS',\n    help: 'password reset success page path',\n  },\n  verifyEmailSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_VERIFY_EMAIL_SUCCESS',\n    help: 'verify email success page path',\n  },\n};\nmodule.exports.LiveQueryOptions = {\n  classNames: {\n    env: 'PARSE_SERVER_LIVEQUERY_CLASSNAMES',\n    help: \"parse-server's LiveQuery classNames\",\n    action: parsers.arrayParser,\n  },\n  pubSubAdapter: {\n    env: 'PARSE_SERVER_LIVEQUERY_PUB_SUB_ADAPTER',\n    help: 'LiveQuery pubsub adapter',\n    action: parsers.moduleOrObjectParser,\n  },\n  redisOptions: {\n    env: 'PARSE_SERVER_LIVEQUERY_REDIS_OPTIONS',\n    help: \"parse-server's LiveQuery redisOptions\",\n    action: parsers.objectParser,\n  },\n  redisURL: {\n    env: 'PARSE_SERVER_LIVEQUERY_REDIS_URL',\n    help: \"parse-server's LiveQuery redisURL\",\n  },\n  wssAdapter: {\n    env: 'PARSE_SERVER_LIVEQUERY_WSS_ADAPTER',\n    help: 'Adapter module for the WebSocketServer',\n    action: parsers.moduleOrObjectParser,\n  },\n};\nmodule.exports.LiveQueryServerOptions = {\n  appId: {\n    env: 'PARSE_LIVE_QUERY_SERVER_APP_ID',\n    help:\n      'This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.',\n  },\n  cacheTimeout: {\n    env: 'PARSE_LIVE_QUERY_SERVER_CACHE_TIMEOUT',\n    help:\n      \"Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).\",\n    action: parsers.numberParser('cacheTimeout'),\n  },\n  keyPairs: {\n    env: 'PARSE_LIVE_QUERY_SERVER_KEY_PAIRS',\n    help:\n      'A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.',\n    action: parsers.objectParser,\n  },\n  logLevel: {\n    env: 'PARSE_LIVE_QUERY_SERVER_LOG_LEVEL',\n    help:\n      'This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.',\n  },\n  masterKey: {\n    env: 'PARSE_LIVE_QUERY_SERVER_MASTER_KEY',\n    help:\n      'This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.',\n  },\n  port: {\n    env: 'PARSE_LIVE_QUERY_SERVER_PORT',\n    help: 'The port to run the LiveQuery server, defaults to 1337.',\n    action: parsers.numberParser('port'),\n    default: 1337,\n  },\n  pubSubAdapter: {\n    env: 'PARSE_LIVE_QUERY_SERVER_PUB_SUB_ADAPTER',\n    help: 'LiveQuery pubsub adapter',\n    action: parsers.moduleOrObjectParser,\n  },\n  redisOptions: {\n    env: 'PARSE_LIVE_QUERY_SERVER_REDIS_OPTIONS',\n    help: \"parse-server's LiveQuery redisOptions\",\n    action: parsers.objectParser,\n  },\n  redisURL: {\n    env: 'PARSE_LIVE_QUERY_SERVER_REDIS_URL',\n    help: \"parse-server's LiveQuery redisURL\",\n  },\n  serverURL: {\n    env: 'PARSE_LIVE_QUERY_SERVER_SERVER_URL',\n    help:\n      'This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.',\n  },\n  websocketTimeout: {\n    env: 'PARSE_LIVE_QUERY_SERVER_WEBSOCKET_TIMEOUT',\n    help:\n      'Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).',\n    action: parsers.numberParser('websocketTimeout'),\n  },\n  wssAdapter: {\n    env: 'PARSE_LIVE_QUERY_SERVER_WSS_ADAPTER',\n    help: 'Adapter module for the WebSocketServer',\n    action: parsers.moduleOrObjectParser,\n  },\n};\nmodule.exports.IdempotencyOptions = {\n  paths: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_PATHS',\n    help:\n      'An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  ttl: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_TTL',\n    help:\n      'The duration in seconds after which a request record is discarded from the database, defaults to 300s.',\n    action: parsers.numberParser('ttl'),\n    default: 300,\n  },\n};\nmodule.exports.AccountLockoutOptions = {\n  duration: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT_DURATION',\n    help:\n      'Set the duration in minutes that a locked-out account remains locked out before automatically becoming unlocked.<br><br>Valid values are greater than `0` and less than `100000`.',\n    action: parsers.numberParser('duration'),\n  },\n  threshold: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT_THRESHOLD',\n    help:\n      'Set the number of failed sign-in attempts that will cause a user account to be locked. If the account is locked. The account will unlock after the duration set in the `duration` option has passed and no further login attempts have been made.<br><br>Valid values are greater than `0` and less than `1000`.',\n    action: parsers.numberParser('threshold'),\n  },\n  unlockOnPasswordReset: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT_UNLOCK_ON_PASSWORD_RESET',\n    help:\n      'Set to `true`  if the account should be unlocked after a successful password reset.<br><br>Default is `false`.<br>Requires options `duration` and `threshold` to be set.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.PasswordPolicyOptions = {\n  doNotAllowUsername: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_DO_NOT_ALLOW_USERNAME',\n    help:\n      'Set to `true` to disallow the username as part of the password.<br><br>Default is `false`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  maxPasswordAge: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_MAX_PASSWORD_AGE',\n    help:\n      'Set the number of days after which a password expires. Login attempts fail if the user does not reset the password before expiration.',\n    action: parsers.numberParser('maxPasswordAge'),\n  },\n  maxPasswordHistory: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_MAX_PASSWORD_HISTORY',\n    help:\n      'Set the number of previous password that will not be allowed to be set as new password. If the option is not set or set to `0`, no previous passwords will be considered.<br><br>Valid values are >= `0` and <= `20`.<br>Default is `0`.',\n    action: parsers.numberParser('maxPasswordHistory'),\n  },\n  resetTokenReuseIfValid: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_RESET_TOKEN_REUSE_IF_VALID',\n    help:\n      'Set to `true` if a password reset token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.<br><br>Default is `false`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  resetTokenValidityDuration: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_RESET_TOKEN_VALIDITY_DURATION',\n    help:\n      'Set the validity duration of the password reset token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.<br><br>For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).<br><br>Default is `undefined`.',\n    action: parsers.numberParser('resetTokenValidityDuration'),\n  },\n  validationError: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_VALIDATION_ERROR',\n    help:\n      'Set the error message to be sent.<br><br>Default is `Password does not meet the Password Policy requirements.`',\n  },\n  validatorCallback: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_VALIDATOR_CALLBACK',\n    help:\n      'Set a callback function to validate a password to be accepted.<br><br>If used in combination with `validatorPattern`, the password must pass both to be accepted.',\n  },\n  validatorPattern: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_VALIDATOR_PATTERN',\n    help:\n      'Set the regular expression validation pattern a password must match to be accepted.<br><br>If used in combination with `validatorCallback`, the password must pass both to be accepted.',\n  },\n};\nmodule.exports.FileUploadOptions = {\n  enableForAnonymousUser: {\n    env: 'PARSE_SERVER_FILE_UPLOAD_ENABLE_FOR_ANONYMOUS_USER',\n    help: 'Is true if file upload should be allowed for anonymous users.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  enableForAuthenticatedUser: {\n    env: 'PARSE_SERVER_FILE_UPLOAD_ENABLE_FOR_AUTHENTICATED_USER',\n    help: 'Is true if file upload should be allowed for authenticated users.',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  enableForPublic: {\n    env: 'PARSE_SERVER_FILE_UPLOAD_ENABLE_FOR_PUBLIC',\n    help: 'Is true if file upload should be allowed for anyone, regardless of user authentication.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.DatabaseOptions = {\n  enableSchemaHooks: {\n    env: 'PARSE_SERVER_DATABASE_ENABLE_SCHEMA_HOOKS',\n    help:\n      'Enables database real-time hooks to update single schema cache. Set to `true` if using multiple Parse Servers instances connected to the same database. Failing to do so will cause a schema change to not propagate to all instances and re-syncing will only happen when the instances restart. To use this feature with MongoDB, a replica set cluster with [change stream](https://docs.mongodb.com/manual/changeStreams/#availability) support is required.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.AuthAdapter = {\n  enabled: {\n    help: 'Is `true` if the auth adapter is enabled, `false` otherwise.',\n    action: parsers.booleanParser,\n    default: true,\n  },\n};\n", "/**\n * @interface SchemaOptions\n * @property {Function} afterMigration Execute a callback after running schema migrations.\n * @property {Function} beforeMigration Execute a callback before running schema migrations.\n * @property {Any} definitions Rest representation on Parse.Schema https://docs.parseplatform.org/rest/guide/#adding-a-schema\n * @property {Boolean} deleteExtraFields Is true if Parse Server should delete any fields not defined in a schema definition. This should only be used during development.\n * @property {Boolean} lockSchemas Is true if Parse Server will reject any attempts to modify the schema while the server is running.\n * @property {Boolean} recreateModifiedFields Is true if Parse Server should recreate any fields that are different between the current database schema and theschema definition. This should only be used during development.\n * @property {Boolean} strict Is true if Parse Server should exit if schema update fail.\n */\n\n/**\n * @interface ParseServerOptions\n * @property {AccountLockoutOptions} accountLockout The account lockout policy for failed login attempts.\n * @property {Boolean} allowClientClassCreation Enable (or disable) client class creation, defaults to true\n * @property {Boolean} allowCustomObjectId Enable (or disable) custom objectId\n * @property {String[]} allowHeaders Add headers to Access-Control-Allow-Headers\n * @property {String} allowOrigin Sets the origin to Access-Control-Allow-Origin\n * @property {Adapter<AnalyticsAdapter>} analyticsAdapter Adapter module for the analytics\n * @property {String} appId Your Parse Application ID\n * @property {String} appName Sets the app name\n * @property {AuthAdapter[]} auth Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication\n * @property {Adapter<CacheAdapter>} cacheAdapter Adapter module for the cache\n * @property {Number} cacheMaxSize Sets the maximum size for the in memory cache, defaults to 10000\n * @property {Number} cacheTTL Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)\n * @property {String} clientKey Key for iOS, MacOS, tvOS clients\n * @property {String} cloud Full path to your cloud code main.js\n * @property {Number|Boolean} cluster Run with cluster, optionally set the number of processes default to os.cpus().length\n * @property {String} collectionPrefix A collection prefix for the classes\n * @property {CustomPagesOptions} customPages custom pages for password validation and reset\n * @property {Adapter<StorageAdapter>} databaseAdapter Adapter module for the database; any options that are not explicitly described here are passed directly to the database client.\n * @property {DatabaseOptions} databaseOptions Options to pass to the database client\n * @property {String} databaseURI The full URI to your database. Supported databases are mongodb or postgres.\n * @property {Number} defaultLimit Default value for limit option on queries, defaults to `100`.\n * @property {Boolean} directAccess Set to `true` if Parse requests within the same Node.js environment as Parse Server should be routed to Parse Server directly instead of via the HTTP interface. Default is `false`.<br><br>If set to `false` then Parse requests within the same Node.js environment as Parse Server are executed as HTTP requests sent to Parse Server via the `serverURL`. For example, a `Parse.Query` in Cloud Code is calling Parse Server via a HTTP request. The server is essentially making a HTTP request to itself, unnecessarily using network resources such as network ports.<br><br>\u26a0\ufe0f In environments where multiple Parse Server instances run behind a load balancer and Parse requests within the current Node.js environment should be routed via the load balancer and distributed as HTTP requests among all instances via the `serverURL`, this should be set to `false`.\n * @property {String} dotNetKey Key for Unity and .Net SDK\n * @property {Adapter<MailAdapter>} emailAdapter Adapter module for email sending\n * @property {Boolean} emailVerifyTokenReuseIfValid Set to `true` if a email verification token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.<br><br>Default is `false`.<br>Requires option `verifyUserEmails: true`.\n * @property {Number} emailVerifyTokenValidityDuration Set the validity duration of the email verification token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.<br><br>For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).<br><br>Default is `undefined`.<br>Requires option `verifyUserEmails: true`.\n * @property {Boolean} enableAnonymousUsers Enable (or disable) anonymous users, defaults to true\n * @property {Boolean} enableExpressErrorHandler Enables the default express error handler for all errors\n * @property {String} encryptionKey Key for encrypting your files\n * @property {Boolean} enforcePrivateUsers Set to true if new users should be created without public read and write access.\n * @property {Boolean} expireInactiveSessions Sets whether we should expire the inactive sessions, defaults to true. If false, all new sessions are created with no expiration date.\n * @property {String} fileKey Key for your files\n * @property {Adapter<FilesAdapter>} filesAdapter Adapter module for the files sub-system\n * @property {FileUploadOptions} fileUpload Options for file uploads\n * @property {String} graphQLPath Mount path for the GraphQL endpoint, defaults to /graphql\n * @property {String} graphQLSchema Full path to your GraphQL custom schema.graphql file\n * @property {String} host The host to serve ParseServer on, defaults to 0.0.0.0\n * @property {IdempotencyOptions} idempotencyOptions Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {String} javascriptKey Key for the Javascript SDK\n * @property {Boolean} jsonLogs Log as structured JSON objects\n * @property {LiveQueryOptions} liveQuery parse-server's LiveQuery configuration object\n * @property {LiveQueryServerOptions} liveQueryServerOptions Live query server configuration options (will start the liveQuery server)\n * @property {Adapter<LoggerAdapter>} loggerAdapter Adapter module for the logging sub-system\n * @property {String} logLevel Sets the level for logs\n * @property {String} logsFolder Folder for the logs (defaults to './logs'); set to null to disable file based logging\n * @property {String} masterKey Your Parse Master Key\n * @property {String[]} masterKeyIps Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)\n * @property {Number} maxLimit Max value for limit option on queries, defaults to unlimited\n * @property {Number|String} maxLogFiles Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null)\n * @property {String} maxUploadSize Max file size for uploads, defaults to 20mb\n * @property {Union} middleware middleware for express server, can be string or function\n * @property {Boolean} mountGraphQL Mounts the GraphQL endpoint\n * @property {String} mountPath Mount path for the server, defaults to /parse\n * @property {Boolean} mountPlayground Mounts the GraphQL Playground - never use this option in production\n * @property {Number} objectIdSize Sets the number of characters in generated object id's, default 10\n * @property {PagesOptions} pages The options for pages such as password reset and email verification. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {PasswordPolicyOptions} passwordPolicy The password policy for enforcing password related rules.\n * @property {String} playgroundPath Mount path for the GraphQL Playground, defaults to /playground\n * @property {Number} port The port to run the ParseServer, defaults to 1337.\n * @property {Boolean} preserveFileName Enable (or disable) the addition of a unique hash to the file names\n * @property {Boolean} preventLoginWithUnverifiedEmail Set to `true` to prevent a user from logging in if the email has not yet been verified and email verification is required.<br><br>Default is `false`.<br>Requires option `verifyUserEmails: true`.\n * @property {ProtectedFields} protectedFields Protected fields that should be treated with extra security when fetching details.\n * @property {String} publicServerURL Public URL to your parse server with http:// or https://.\n * @property {Any} push Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications\n * @property {String} readOnlyMasterKey Read-only key, which has the same capabilities as MasterKey without writes\n * @property {RequestKeywordDenylist[]} requestKeywordDenylist An array of keys and values that are prohibited in database read and write requests to prevent potential security vulnerabilities. It is possible to specify only a key (`{\"key\":\"...\"}`), only a value (`{\"value\":\"...\"}`) or a key-value pair (`{\"key\":\"...\",\"value\":\"...\"}`). The specification can use the following types: `boolean`, `numeric` or `string`, where `string` will be interpreted as a regex notation. Request data is deep-scanned for matching definitions to detect also any nested occurrences. Defaults are patterns that are likely to be used in malicious requests. Setting this option will override the default patterns.\n * @property {String} restAPIKey Key for REST calls\n * @property {Boolean} revokeSessionOnPasswordReset When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\n * @property {Boolean} scheduledPush Configuration for push scheduling, defaults to false.\n * @property {SchemaOptions} schema Defined schema\n * @property {SecurityOptions} security The security options to identify and report weak security settings.\n * @property {Function} serverCloseComplete Callback when server has closed\n * @property {Function} serverStartComplete Callback when server has started\n * @property {String} serverURL URL to your parse server with http:// or https://.\n * @property {Number} sessionLength Session duration, in seconds, defaults to 1 year\n * @property {Boolean} silent Disables console output\n * @property {Boolean} startLiveQueryServer Starts the liveQuery server\n * @property {String[]} userSensitiveFields Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields\n * @property {Boolean} verbose Set the logging to verbose\n * @property {Boolean} verifyUserEmails Set to `true` to require users to verify their email address to complete the sign-up process.<br><br>Default is `false`.\n * @property {String} webhookKey Key sent with outgoing webhook calls\n */\n\n/**\n * @interface SecurityOptions\n * @property {CheckGroup[]} checkGroups The security check groups to run. This allows to add custom security checks or override existing ones. Default are the groups defined in `CheckGroups.js`.\n * @property {Boolean} enableCheck Is true if Parse Server should check for weak security settings.\n * @property {Boolean} enableCheckLog Is true if the security check report should be written to logs. This should only be enabled temporarily to not expose weak security settings in logs.\n */\n\n/**\n * @interface PagesOptions\n * @property {PagesRoute[]} customRoutes The custom routes.\n * @property {PagesCustomUrlsOptions} customUrls The URLs to the custom pages.\n * @property {Boolean} enableLocalization Is true if pages should be localized; this has no effect on custom page redirects.\n * @property {Boolean} enableRouter Is true if the pages router should be enabled; this is required for any of the pages options to take effect. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {Boolean} forceRedirect Is true if responses should always be redirects and never content, false if the response type should depend on the request type (GET request -> content response; POST request -> redirect response).\n * @property {String} localizationFallbackLocale The fallback locale for localization if no matching translation is provided for the given locale. This is only relevant when providing translation resources via JSON file.\n * @property {String} localizationJsonPath The path to the JSON file for localization; the translations will be used to fill template placeholders according to the locale.\n * @property {String} pagesEndpoint The API endpoint for the pages. Default is 'apps'.\n * @property {String} pagesPath The path to the pages directory; this also defines where the static endpoint '/apps' points to. Default is the './public/' directory.\n * @property {Object} placeholders The placeholder keys and values which will be filled in pages; this can be a simple object or a callback function.\n */\n\n/**\n * @interface PagesRoute\n * @property {Function} handler The route handler that is an async function.\n * @property {String} method The route method, e.g. 'GET' or 'POST'.\n * @property {String} path The route path.\n */\n\n/**\n * @interface PagesCustomUrlsOptions\n * @property {String} emailVerificationLinkExpired The URL to the custom page for email verification -> link expired.\n * @property {String} emailVerificationLinkInvalid The URL to the custom page for email verification -> link invalid.\n * @property {String} emailVerificationSendFail The URL to the custom page for email verification -> link send fail.\n * @property {String} emailVerificationSendSuccess The URL to the custom page for email verification -> resend link -> success.\n * @property {String} emailVerificationSuccess The URL to the custom page for email verification -> success.\n * @property {String} passwordReset The URL to the custom page for password reset.\n * @property {String} passwordResetLinkInvalid The URL to the custom page for password reset -> link invalid.\n * @property {String} passwordResetSuccess The URL to the custom page for password reset -> success.\n */\n\n/**\n * @interface CustomPagesOptions\n * @property {String} choosePassword choose password page path\n * @property {String} expiredVerificationLink expired verification link page path\n * @property {String} invalidLink invalid link page path\n * @property {String} invalidPasswordResetLink invalid password reset link page path\n * @property {String} invalidVerificationLink invalid verification link page path\n * @property {String} linkSendFail verification link send fail page path\n * @property {String} linkSendSuccess verification link send success page path\n * @property {String} parseFrameURL for masking user-facing pages\n * @property {String} passwordResetSuccess password reset success page path\n * @property {String} verifyEmailSuccess verify email success page path\n */\n\n/**\n * @interface LiveQueryOptions\n * @property {String[]} classNames parse-server's LiveQuery classNames\n * @property {Adapter<PubSubAdapter>} pubSubAdapter LiveQuery pubsub adapter\n * @property {Any} redisOptions parse-server's LiveQuery redisOptions\n * @property {String} redisURL parse-server's LiveQuery redisURL\n * @property {Adapter<WSSAdapter>} wssAdapter Adapter module for the WebSocketServer\n */\n\n/**\n * @interface LiveQueryServerOptions\n * @property {String} appId This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.\n * @property {Number} cacheTimeout Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).\n * @property {Any} keyPairs A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.\n * @property {String} logLevel This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.\n * @property {String} masterKey This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.\n * @property {Number} port The port to run the LiveQuery server, defaults to 1337.\n * @property {Adapter<PubSubAdapter>} pubSubAdapter LiveQuery pubsub adapter\n * @property {Any} redisOptions parse-server's LiveQuery redisOptions\n * @property {String} redisURL parse-server's LiveQuery redisURL\n * @property {String} serverURL This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.\n * @property {Number} websocketTimeout Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).\n * @property {Adapter<WSSAdapter>} wssAdapter Adapter module for the WebSocketServer\n */\n\n/**\n * @interface IdempotencyOptions\n * @property {String[]} paths An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.\n * @property {Number} ttl The duration in seconds after which a request record is discarded from the database, defaults to 300s.\n */\n\n/**\n * @interface AccountLockoutOptions\n * @property {Number} duration Set the duration in minutes that a locked-out account remains locked out before automatically becoming unlocked.<br><br>Valid values are greater than `0` and less than `100000`.\n * @property {Number} threshold Set the number of failed sign-in attempts that will cause a user account to be locked. If the account is locked. The account will unlock after the duration set in the `duration` option has passed and no further login attempts have been made.<br><br>Valid values are greater than `0` and less than `1000`.\n * @property {Boolean} unlockOnPasswordReset Set to `true`  if the account should be unlocked after a successful password reset.<br><br>Default is `false`.<br>Requires options `duration` and `threshold` to be set.\n */\n\n/**\n * @interface PasswordPolicyOptions\n * @property {Boolean} doNotAllowUsername Set to `true` to disallow the username as part of the password.<br><br>Default is `false`.\n * @property {Number} maxPasswordAge Set the number of days after which a password expires. Login attempts fail if the user does not reset the password before expiration.\n * @property {Number} maxPasswordHistory Set the number of previous password that will not be allowed to be set as new password. If the option is not set or set to `0`, no previous passwords will be considered.<br><br>Valid values are >= `0` and <= `20`.<br>Default is `0`.\n * @property {Boolean} resetTokenReuseIfValid Set to `true` if a password reset token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.<br><br>Default is `false`.\n * @property {Number} resetTokenValidityDuration Set the validity duration of the password reset token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.<br><br>For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).<br><br>Default is `undefined`.\n * @property {String} validationError Set the error message to be sent.<br><br>Default is `Password does not meet the Password Policy requirements.`\n * @property {Function} validatorCallback Set a callback function to validate a password to be accepted.<br><br>If used in combination with `validatorPattern`, the password must pass both to be accepted.\n * @property {String} validatorPattern Set the regular expression validation pattern a password must match to be accepted.<br><br>If used in combination with `validatorCallback`, the password must pass both to be accepted.\n */\n\n/**\n * @interface FileUploadOptions\n * @property {Boolean} enableForAnonymousUser Is true if file upload should be allowed for anonymous users.\n * @property {Boolean} enableForAuthenticatedUser Is true if file upload should be allowed for authenticated users.\n * @property {Boolean} enableForPublic Is true if file upload should be allowed for anyone, regardless of user authentication.\n */\n\n/**\n * @interface DatabaseOptions\n * @property {Boolean} enableSchemaHooks Enables database real-time hooks to update single schema cache. Set to `true` if using multiple Parse Servers instances connected to the same database. Failing to do so will cause a schema change to not propagate to all instances and re-syncing will only happen when the instances restart. To use this feature with MongoDB, a replica set cluster with [change stream](https://docs.mongodb.com/manual/changeStreams/#availability) support is required.\n */\n\n/**\n * @interface AuthAdapter\n * @property {Boolean} enabled Is `true` if the auth adapter is enabled, `false` otherwise.\n */\n", "// @flow\nimport { AnalyticsAdapter } from '../Adapters/Analytics/AnalyticsAdapter';\nimport { FilesAdapter } from '../Adapters/Files/FilesAdapter';\nimport { LoggerAdapter } from '../Adapters/Logger/LoggerAdapter';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport { CacheAdapter } from '../Adapters/Cache/CacheAdapter';\nimport { MailAdapter } from '../Adapters/Email/MailAdapter';\nimport { PubSubAdapter } from '../Adapters/PubSub/PubSubAdapter';\nimport { WSSAdapter } from '../Adapters/WebSocketServer/WSSAdapter';\nimport { CheckGroup } from '../Security/CheckGroup';\n\nexport interface SchemaOptions {\n  /* Rest representation on Parse.Schema https://docs.parseplatform.org/rest/guide/#adding-a-schema\n  :DEFAULT: [] */\n  definitions: any;\n  /* Is true if Parse Server should exit if schema update fail.\n  :DEFAULT: false */\n  strict: ?boolean;\n  /* Is true if Parse Server should delete any fields not defined in a schema definition. This should only be used during development.\n  :DEFAULT: false */\n  deleteExtraFields: ?boolean;\n  /* Is true if Parse Server should recreate any fields that are different between the current database schema and theschema definition. This should only be used during development.\n  :DEFAULT: false */\n  recreateModifiedFields: ?boolean;\n  /* Is true if Parse Server will reject any attempts to modify the schema while the server is running.\n  :DEFAULT: false */\n  lockSchemas: ?boolean;\n  /* Execute a callback before running schema migrations. */\n  beforeMigration: ?() => void | Promise<void>;\n  /* Execute a callback after running schema migrations. */\n  afterMigration: ?() => void | Promise<void>;\n}\n\ntype Adapter<T> = string | any | T;\ntype NumberOrBoolean = number | boolean;\ntype NumberOrString = number | string;\ntype ProtectedFields = any;\ntype RequestKeywordDenylist = {\n  key: string | any,\n  value: any,\n};\n\nexport interface ParseServerOptions {\n  /* Your Parse Application ID\n  :ENV: PARSE_SERVER_APPLICATION_ID */\n  appId: string;\n  /* Your Parse Master Key */\n  masterKey: string;\n  /* URL to your parse server with http:// or https://.\n  :ENV: PARSE_SERVER_URL */\n  serverURL: string;\n  /* Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)\n  :DEFAULT: [] */\n  masterKeyIps: ?(string[]);\n  /* Sets the app name */\n  appName: ?string;\n  /* Add headers to Access-Control-Allow-Headers */\n  allowHeaders: ?(string[]);\n  /* Sets the origin to Access-Control-Allow-Origin */\n  allowOrigin: ?string;\n  /* Adapter module for the analytics */\n  analyticsAdapter: ?Adapter<AnalyticsAdapter>;\n  /* Adapter module for the files sub-system */\n  filesAdapter: ?Adapter<FilesAdapter>;\n  /* Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications */\n  push: ?any;\n  /* Configuration for push scheduling, defaults to false.\n  :DEFAULT: false */\n  scheduledPush: ?boolean;\n  /* Adapter module for the logging sub-system */\n  loggerAdapter: ?Adapter<LoggerAdapter>;\n  /* Log as structured JSON objects\n  :ENV: JSON_LOGS */\n  jsonLogs: ?boolean;\n  /* Folder for the logs (defaults to './logs'); set to null to disable file based logging\n  :ENV: PARSE_SERVER_LOGS_FOLDER\n  :DEFAULT: ./logs */\n  logsFolder: ?string;\n  /* Set the logging to verbose\n  :ENV: VERBOSE */\n  verbose: ?boolean;\n  /* Sets the level for logs */\n  logLevel: ?string;\n  /* Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null) */\n  maxLogFiles: ?NumberOrString;\n  /* Disables console output\n  :ENV: SILENT */\n  silent: ?boolean;\n  /* The full URI to your database. Supported databases are mongodb or postgres.\n  :DEFAULT: mongodb://localhost:27017/parse */\n  databaseURI: string;\n  /* Options to pass to the database client\n  :ENV: PARSE_SERVER_DATABASE_OPTIONS */\n  databaseOptions: ?DatabaseOptions;\n  /* Adapter module for the database; any options that are not explicitly described here are passed directly to the database client. */\n  databaseAdapter: ?Adapter<StorageAdapter>;\n  /* Full path to your cloud code main.js */\n  cloud: ?string;\n  /* A collection prefix for the classes\n  :DEFAULT: '' */\n  collectionPrefix: ?string;\n  /* Key for iOS, MacOS, tvOS clients */\n  clientKey: ?string;\n  /* Key for the Javascript SDK */\n  javascriptKey: ?string;\n  /* Key for Unity and .Net SDK */\n  dotNetKey: ?string;\n  /* Key for encrypting your files\n  :ENV: PARSE_SERVER_ENCRYPTION_KEY */\n  encryptionKey: ?string;\n  /* Key for REST calls\n  :ENV: PARSE_SERVER_REST_API_KEY */\n  restAPIKey: ?string;\n  /* Read-only key, which has the same capabilities as MasterKey without writes */\n  readOnlyMasterKey: ?string;\n  /* Key sent with outgoing webhook calls */\n  webhookKey: ?string;\n  /* Key for your files */\n  fileKey: ?string;\n  /* Enable (or disable) the addition of a unique hash to the file names\n  :ENV: PARSE_SERVER_PRESERVE_FILE_NAME\n  :DEFAULT: false */\n  preserveFileName: ?boolean;\n  /* Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields */\n  userSensitiveFields: ?(string[]);\n  /* Protected fields that should be treated with extra security when fetching details.\n  :DEFAULT: {\"_User\": {\"*\": [\"email\"]}} */\n  protectedFields: ?ProtectedFields;\n  /* Enable (or disable) anonymous users, defaults to true\n  :ENV: PARSE_SERVER_ENABLE_ANON_USERS\n  :DEFAULT: true */\n  enableAnonymousUsers: ?boolean;\n  /* Enable (or disable) client class creation, defaults to true\n  :ENV: PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION\n  :DEFAULT: true */\n  allowClientClassCreation: ?boolean;\n  /* Enable (or disable) custom objectId\n  :ENV: PARSE_SERVER_ALLOW_CUSTOM_OBJECT_ID\n  :DEFAULT: false */\n  allowCustomObjectId: ?boolean;\n  /* Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication\n  :ENV: PARSE_SERVER_AUTH_PROVIDERS */\n  auth: ?(AuthAdapter[]);\n  /* Max file size for uploads, defaults to 20mb\n  :DEFAULT: 20mb */\n  maxUploadSize: ?string;\n  /* Set to `true` to require users to verify their email address to complete the sign-up process.\n  <br><br>\n  Default is `false`.\n  :DEFAULT: false */\n  verifyUserEmails: ?boolean;\n  /* Set to `true` to prevent a user from logging in if the email has not yet been verified and email verification is required.\n  <br><br>\n  Default is `false`.\n  <br>\n  Requires option `verifyUserEmails: true`.\n  :DEFAULT: false */\n  preventLoginWithUnverifiedEmail: ?boolean;\n  /* Set the validity duration of the email verification token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.\n  <br><br>\n  For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).\n  <br><br>\n  Default is `undefined`.\n  <br>\n  Requires option `verifyUserEmails: true`.\n  */\n  emailVerifyTokenValidityDuration: ?number;\n  /* Set to `true` if a email verification token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.\n  <br><br>\n  Default is `false`.\n  <br>\n  Requires option `verifyUserEmails: true`.\n  :DEFAULT: false */\n  emailVerifyTokenReuseIfValid: ?boolean;\n  /* The account lockout policy for failed login attempts. */\n  accountLockout: ?AccountLockoutOptions;\n  /* The password policy for enforcing password related rules. */\n  passwordPolicy: ?PasswordPolicyOptions;\n  /* Adapter module for the cache */\n  cacheAdapter: ?Adapter<CacheAdapter>;\n  /* Adapter module for email sending */\n  emailAdapter: ?Adapter<MailAdapter>;\n  /* Public URL to your parse server with http:// or https://.\n  :ENV: PARSE_PUBLIC_SERVER_URL */\n  publicServerURL: ?string;\n  /* The options for pages such as password reset and email verification. Caution, this is an experimental feature that may not be appropriate for production.\n  :DEFAULT: {} */\n  pages: ?PagesOptions;\n  /* custom pages for password validation and reset\n  :DEFAULT: {} */\n  customPages: ?CustomPagesOptions;\n  /* parse-server's LiveQuery configuration object */\n  liveQuery: ?LiveQueryOptions;\n  /* Session duration, in seconds, defaults to 1 year\n  :DEFAULT: 31536000 */\n  sessionLength: ?number;\n  /* Default value for limit option on queries, defaults to `100`.\n  :DEFAULT: 100 */\n  defaultLimit: ?number;\n  /* Max value for limit option on queries, defaults to unlimited */\n  maxLimit: ?number;\n  /* Sets whether we should expire the inactive sessions, defaults to true. If false, all new sessions are created with no expiration date.\n  :DEFAULT: true */\n  expireInactiveSessions: ?boolean;\n  /* When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\n  :DEFAULT: true */\n  revokeSessionOnPasswordReset: ?boolean;\n  /* Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)\n  :DEFAULT: 5000 */\n  cacheTTL: ?number;\n  /* Sets the maximum size for the in memory cache, defaults to 10000\n  :DEFAULT: 10000 */\n  cacheMaxSize: ?number;\n  /* Set to `true` if Parse requests within the same Node.js environment as Parse Server should be routed to Parse Server directly instead of via the HTTP interface. Default is `false`.\n  <br><br>\n  If set to `false` then Parse requests within the same Node.js environment as Parse Server are executed as HTTP requests sent to Parse Server via the `serverURL`. For example, a `Parse.Query` in Cloud Code is calling Parse Server via a HTTP request. The server is essentially making a HTTP request to itself, unnecessarily using network resources such as network ports.\n  <br><br>\n  \u26a0\ufe0f In environments where multiple Parse Server instances run behind a load balancer and Parse requests within the current Node.js environment should be routed via the load balancer and distributed as HTTP requests among all instances via the `serverURL`, this should be set to `false`.\n  :DEFAULT: false */\n  directAccess: ?boolean;\n  /* Enables the default express error handler for all errors\n  :DEFAULT: false */\n  enableExpressErrorHandler: ?boolean;\n  /* Sets the number of characters in generated object id's, default 10\n  :DEFAULT: 10 */\n  objectIdSize: ?number;\n  /* The port to run the ParseServer, defaults to 1337.\n  :ENV: PORT\n  :DEFAULT: 1337 */\n  port: ?number;\n  /* The host to serve ParseServer on, defaults to 0.0.0.0\n  :DEFAULT: 0.0.0.0 */\n  host: ?string;\n  /* Mount path for the server, defaults to /parse\n  :DEFAULT: /parse */\n  mountPath: ?string;\n  /* Run with cluster, optionally set the number of processes default to os.cpus().length */\n  cluster: ?NumberOrBoolean;\n  /* middleware for express server, can be string or function */\n  middleware: ?((() => void) | string);\n  /* Starts the liveQuery server */\n  startLiveQueryServer: ?boolean;\n  /* Live query server configuration options (will start the liveQuery server) */\n  liveQueryServerOptions: ?LiveQueryServerOptions;\n  /* Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.\n  :ENV: PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_OPTIONS\n  :DEFAULT: false */\n  idempotencyOptions: ?IdempotencyOptions;\n  /* Options for file uploads\n  :ENV: PARSE_SERVER_FILE_UPLOAD_OPTIONS\n  :DEFAULT: {} */\n  fileUpload: ?FileUploadOptions;\n  /* Full path to your GraphQL custom schema.graphql file */\n  graphQLSchema: ?string;\n  /* Mounts the GraphQL endpoint\n  :ENV: PARSE_SERVER_MOUNT_GRAPHQL\n  :DEFAULT: false */\n  mountGraphQL: ?boolean;\n  /* Mount path for the GraphQL endpoint, defaults to /graphql\n  :ENV: PARSE_SERVER_GRAPHQL_PATH\n  :DEFAULT: /graphql */\n  graphQLPath: ?string;\n  /* Mounts the GraphQL Playground - never use this option in production\n  :ENV: PARSE_SERVER_MOUNT_PLAYGROUND\n  :DEFAULT: false */\n  mountPlayground: ?boolean;\n  /* Mount path for the GraphQL Playground, defaults to /playground\n  :ENV: PARSE_SERVER_PLAYGROUND_PATH\n  :DEFAULT: /playground */\n  playgroundPath: ?string;\n  /* Callback when server has started */\n  serverStartComplete: ?(error: ?Error) => void;\n  /* Defined schema\n  :ENV: PARSE_SERVER_SCHEMA\n  */\n  schema: ?SchemaOptions;\n  /* Callback when server has closed */\n  serverCloseComplete: ?() => void;\n  /* The security options to identify and report weak security settings.\n  :DEFAULT: {} */\n  security: ?SecurityOptions;\n  /* Set to true if new users should be created without public read and write access.\n  :DEFAULT: false */\n  enforcePrivateUsers: ?boolean;\n  /* An array of keys and values that are prohibited in database read and write requests to prevent potential security vulnerabilities. It is possible to specify only a key (`{\"key\":\"...\"}`), only a value (`{\"value\":\"...\"}`) or a key-value pair (`{\"key\":\"...\",\"value\":\"...\"}`). The specification can use the following types: `boolean`, `numeric` or `string`, where `string` will be interpreted as a regex notation. Request data is deep-scanned for matching definitions to detect also any nested occurrences. Defaults are patterns that are likely to be used in malicious requests. Setting this option will override the default patterns.\n  :DEFAULT: [{\"key\":\"_bsontype\",\"value\":\"Code\"},{\"key\":\"constructor\"},{\"key\":\"__proto__\"}] */\n  requestKeywordDenylist: ?(RequestKeywordDenylist[]);\n}\n\nexport interface SecurityOptions {\n  /* Is true if Parse Server should check for weak security settings.\n  :DEFAULT: false */\n  enableCheck: ?boolean;\n  /* Is true if the security check report should be written to logs. This should only be enabled temporarily to not expose weak security settings in logs.\n  :DEFAULT: false */\n  enableCheckLog: ?boolean;\n  /* The security check groups to run. This allows to add custom security checks or override existing ones. Default are the groups defined in `CheckGroups.js`. */\n  checkGroups: ?(CheckGroup[]);\n}\n\nexport interface PagesOptions {\n  /* Is true if the pages router should be enabled; this is required for any of the pages options to take effect. Caution, this is an experimental feature that may not be appropriate for production.\n  :DEFAULT: false */\n  enableRouter: ?boolean;\n  /* Is true if pages should be localized; this has no effect on custom page redirects.\n  :DEFAULT: false */\n  enableLocalization: ?boolean;\n  /* The path to the JSON file for localization; the translations will be used to fill template placeholders according to the locale. */\n  localizationJsonPath: ?string;\n  /* The fallback locale for localization if no matching translation is provided for the given locale. This is only relevant when providing translation resources via JSON file.\n  :DEFAULT: en */\n  localizationFallbackLocale: ?string;\n  /* The placeholder keys and values which will be filled in pages; this can be a simple object or a callback function.\n  :DEFAULT: {} */\n  placeholders: ?Object;\n  /* Is true if responses should always be redirects and never content, false if the response type should depend on the request type (GET request -> content response; POST request -> redirect response).\n  :DEFAULT: false */\n  forceRedirect: ?boolean;\n  /* The path to the pages directory; this also defines where the static endpoint '/apps' points to. Default is the './public/' directory.\n  :DEFAULT: ./public */\n  pagesPath: ?string;\n  /* The API endpoint for the pages. Default is 'apps'.\n  :DEFAULT: apps */\n  pagesEndpoint: ?string;\n  /* The URLs to the custom pages.\n  :DEFAULT: {} */\n  customUrls: ?PagesCustomUrlsOptions;\n  /* The custom routes.\n  :DEFAULT: [] */\n  customRoutes: ?(PagesRoute[]);\n}\n\nexport interface PagesRoute {\n  /* The route path. */\n  path: string;\n  /* The route method, e.g. 'GET' or 'POST'. */\n  method: string;\n  /* The route handler that is an async function. */\n  handler: () => void;\n}\n\nexport interface PagesCustomUrlsOptions {\n  /* The URL to the custom page for password reset. */\n  passwordReset: ?string;\n  /* The URL to the custom page for password reset -> link invalid. */\n  passwordResetLinkInvalid: ?string;\n  /* The URL to the custom page for password reset -> success. */\n  passwordResetSuccess: ?string;\n  /* The URL to the custom page for email verification -> success. */\n  emailVerificationSuccess: ?string;\n  /* The URL to the custom page for email verification -> link send fail. */\n  emailVerificationSendFail: ?string;\n  /* The URL to the custom page for email verification -> resend link -> success. */\n  emailVerificationSendSuccess: ?string;\n  /* The URL to the custom page for email verification -> link invalid. */\n  emailVerificationLinkInvalid: ?string;\n  /* The URL to the custom page for email verification -> link expired. */\n  emailVerificationLinkExpired: ?string;\n}\n\nexport interface CustomPagesOptions {\n  /* invalid link page path */\n  invalidLink: ?string;\n  /* verification link send fail page path */\n  linkSendFail: ?string;\n  /* choose password page path */\n  choosePassword: ?string;\n  /* verification link send success page path */\n  linkSendSuccess: ?string;\n  /* verify email success page path */\n  verifyEmailSuccess: ?string;\n  /* password reset success page path */\n  passwordResetSuccess: ?string;\n  /* invalid verification link page path */\n  invalidVerificationLink: ?string;\n  /* expired verification link page path */\n  expiredVerificationLink: ?string;\n  /* invalid password reset link page path */\n  invalidPasswordResetLink: ?string;\n  /* for masking user-facing pages */\n  parseFrameURL: ?string;\n}\n\nexport interface LiveQueryOptions {\n  /* parse-server's LiveQuery classNames\n  :ENV: PARSE_SERVER_LIVEQUERY_CLASSNAMES */\n  classNames: ?(string[]);\n  /* parse-server's LiveQuery redisOptions */\n  redisOptions: ?any;\n  /* parse-server's LiveQuery redisURL */\n  redisURL: ?string;\n  /* LiveQuery pubsub adapter */\n  pubSubAdapter: ?Adapter<PubSubAdapter>;\n  /* Adapter module for the WebSocketServer */\n  wssAdapter: ?Adapter<WSSAdapter>;\n}\n\nexport interface LiveQueryServerOptions {\n  /* This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.*/\n  appId: ?string;\n  /* This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.*/\n  masterKey: ?string;\n  /* This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.*/\n  serverURL: ?string;\n  /* A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.*/\n  keyPairs: ?any;\n  /* Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).*/\n  websocketTimeout: ?number;\n  /* Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).*/\n  cacheTimeout: ?number;\n  /* This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.*/\n  logLevel: ?string;\n  /* The port to run the LiveQuery server, defaults to 1337.\n  :DEFAULT: 1337 */\n  port: ?number;\n  /* parse-server's LiveQuery redisOptions */\n  redisOptions: ?any;\n  /* parse-server's LiveQuery redisURL */\n  redisURL: ?string;\n  /* LiveQuery pubsub adapter */\n  pubSubAdapter: ?Adapter<PubSubAdapter>;\n  /* Adapter module for the WebSocketServer */\n  wssAdapter: ?Adapter<WSSAdapter>;\n}\n\nexport interface IdempotencyOptions {\n  /* An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.\n  :DEFAULT: [] */\n  paths: ?(string[]);\n  /* The duration in seconds after which a request record is discarded from the database, defaults to 300s.\n  :DEFAULT: 300 */\n  ttl: ?number;\n}\n\nexport interface AccountLockoutOptions {\n  /* Set the duration in minutes that a locked-out account remains locked out before automatically becoming unlocked.\n  <br><br>\n  Valid values are greater than `0` and less than `100000`. */\n  duration: ?number;\n  /* Set the number of failed sign-in attempts that will cause a user account to be locked. If the account is locked. The account will unlock after the duration set in the `duration` option has passed and no further login attempts have been made.\n  <br><br>\n  Valid values are greater than `0` and less than `1000`. */\n  threshold: ?number;\n  /* Set to `true`  if the account should be unlocked after a successful password reset.\n  <br><br>\n  Default is `false`.\n  <br>\n  Requires options `duration` and `threshold` to be set.\n  :DEFAULT: false */\n  unlockOnPasswordReset: ?boolean;\n}\n\nexport interface PasswordPolicyOptions {\n  /* Set the regular expression validation pattern a password must match to be accepted.\n  <br><br>\n  If used in combination with `validatorCallback`, the password must pass both to be accepted. */\n  validatorPattern: ?string;\n  /*   */\n  /* Set a callback function to validate a password to be accepted.\n  <br><br>\n  If used in combination with `validatorPattern`, the password must pass both to be accepted. */\n  validatorCallback: ?() => void;\n  /* Set the error message to be sent.\n  <br><br>\n  Default is `Password does not meet the Password Policy requirements.` */\n  validationError: ?string;\n  /* Set to `true` to disallow the username as part of the password.\n  <br><br>\n  Default is `false`.\n  :DEFAULT: false */\n  doNotAllowUsername: ?boolean;\n  /* Set the number of days after which a password expires. Login attempts fail if the user does not reset the password before expiration. */\n  maxPasswordAge: ?number;\n  /* Set the number of previous password that will not be allowed to be set as new password. If the option is not set or set to `0`, no previous passwords will be considered.\n  <br><br>\n  Valid values are >= `0` and <= `20`.\n  <br>\n  Default is `0`.\n  */\n  maxPasswordHistory: ?number;\n  /* Set the validity duration of the password reset token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.\n  <br><br>\n  For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).\n  <br><br>\n  Default is `undefined`.\n  */\n  resetTokenValidityDuration: ?number;\n  /* Set to `true` if a password reset token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.\n  <br><br>\n  Default is `false`.\n  :DEFAULT: false */\n  resetTokenReuseIfValid: ?boolean;\n}\n\nexport interface FileUploadOptions {\n  /*  Is true if file upload should be allowed for anonymous users.\n  :DEFAULT: false */\n  enableForAnonymousUser: ?boolean;\n  /* Is true if file upload should be allowed for authenticated users.\n  :DEFAULT: true */\n  enableForAuthenticatedUser: ?boolean;\n  /* Is true if file upload should be allowed for anyone, regardless of user authentication.\n  :DEFAULT: false */\n  enableForPublic: ?boolean;\n}\n\nexport interface DatabaseOptions {\n  /* Enables database real-time hooks to update single schema cache. Set to `true` if using multiple Parse Servers instances connected to the same database. Failing to do so will cause a schema change to not propagate to all instances and re-syncing will only happen when the instances restart. To use this feature with MongoDB, a replica set cluster with [change stream](https://docs.mongodb.com/manual/changeStreams/#availability) support is required.\n  :DEFAULT: false */\n  enableSchemaHooks: ?boolean;\n}\n\nexport interface AuthAdapter {\n  /* Is `true` if the auth adapter is enabled, `false` otherwise.\n  :DEFAULT: true\n  :ENV:\n  */\n  enabled: ?boolean;\n}\n", "// ParseServer - open-source compatible API Server for Parse apps\n\nvar batch = require('./batch'),\n  bodyParser = require('body-parser'),\n  express = require('express'),\n  middlewares = require('./middlewares'),\n  Parse = require('parse/node').Parse,\n  { parse } = require('graphql'),\n  path = require('path'),\n  fs = require('fs');\n\nimport { ParseServerOptions, LiveQueryServerOptions } from './Options';\nimport defaults from './defaults';\nimport * as logging from './logger';\nimport Config from './Config';\nimport PromiseRouter from './PromiseRouter';\nimport requiredParameter from './requiredParameter';\nimport { AnalyticsRouter } from './Routers/AnalyticsRouter';\nimport { ClassesRouter } from './Routers/ClassesRouter';\nimport { FeaturesRouter } from './Routers/FeaturesRouter';\nimport { FilesRouter } from './Routers/FilesRouter';\nimport { FunctionsRouter } from './Routers/FunctionsRouter';\nimport { GlobalConfigRouter } from './Routers/GlobalConfigRouter';\nimport { GraphQLRouter } from './Routers/GraphQLRouter';\nimport { HooksRouter } from './Routers/HooksRouter';\nimport { IAPValidationRouter } from './Routers/IAPValidationRouter';\nimport { InstallationsRouter } from './Routers/InstallationsRouter';\nimport { LogsRouter } from './Routers/LogsRouter';\nimport { ParseLiveQueryServer } from './LiveQuery/ParseLiveQueryServer';\nimport { PagesRouter } from './Routers/PagesRouter';\nimport { PublicAPIRouter } from './Routers/PublicAPIRouter';\nimport { PushRouter } from './Routers/PushRouter';\nimport { CloudCodeRouter } from './Routers/CloudCodeRouter';\nimport { RolesRouter } from './Routers/RolesRouter';\nimport { SchemasRouter } from './Routers/SchemasRouter';\nimport { SessionsRouter } from './Routers/SessionsRouter';\nimport { UsersRouter } from './Routers/UsersRouter';\nimport { PurgeRouter } from './Routers/PurgeRouter';\nimport { AudiencesRouter } from './Routers/AudiencesRouter';\nimport { AggregateRouter } from './Routers/AggregateRouter';\nimport { ParseServerRESTController } from './ParseServerRESTController';\nimport * as controllers from './Controllers';\nimport { ParseGraphQLServer } from './GraphQL/ParseGraphQLServer';\nimport { SecurityRouter } from './Routers/SecurityRouter';\nimport CheckRunner from './Security/CheckRunner';\nimport Deprecator from './Deprecator/Deprecator';\nimport { DefinedSchemas } from './SchemaMigrations/DefinedSchemas';\n\n// Mutate the Parse object to add the Cloud Code handlers\naddParseCloud();\n\n// ParseServer works like a constructor of an express app.\n// https://parseplatform.org/parse-server/api/master/ParseServerOptions.html\nclass ParseServer {\n  /**\n   * @constructor\n   * @param {ParseServerOptions} options the parse server initialization options\n   */\n  constructor(options: ParseServerOptions) {\n    // Scan for deprecated Parse Server options\n    Deprecator.scanParseServerOptions(options);\n    // Set option defaults\n    injectDefaults(options);\n    const {\n      appId = requiredParameter('You must provide an appId!'),\n      masterKey = requiredParameter('You must provide a masterKey!'),\n      cloud,\n      security,\n      javascriptKey,\n      serverURL = requiredParameter('You must provide a serverURL!'),\n      serverStartComplete,\n      schema,\n    } = options;\n    // Initialize the node client SDK automatically\n    Parse.initialize(appId, javascriptKey || 'unused', masterKey);\n    Parse.serverURL = serverURL;\n\n    const allControllers = controllers.getControllers(options);\n\n    const { loggerController, databaseController, hooksController } = allControllers;\n    this.config = Config.put(Object.assign({}, options, allControllers));\n\n    logging.setLogger(loggerController);\n\n    // Note: Tests will start to fail if any validation happens after this is called.\n    databaseController\n      .performInitialization()\n      .then(() => hooksController.load())\n      .then(async () => {\n        if (schema) {\n          await new DefinedSchemas(schema, this.config).execute();\n        }\n        if (serverStartComplete) {\n          serverStartComplete();\n        }\n      })\n      .catch(error => {\n        if (serverStartComplete) {\n          serverStartComplete(error);\n        } else {\n          console.error(error);\n          process.exit(1);\n        }\n      });\n\n    if (cloud) {\n      addParseCloud();\n      if (typeof cloud === 'function') {\n        cloud(Parse);\n      } else if (typeof cloud === 'string') {\n        require(path.resolve(process.cwd(), cloud));\n      } else {\n        throw \"argument 'cloud' must either be a string or a function\";\n      }\n    }\n\n    if (security && security.enableCheck && security.enableCheckLog) {\n      new CheckRunner(options.security).run();\n    }\n  }\n\n  get app() {\n    if (!this._app) {\n      this._app = ParseServer.app(this.config);\n    }\n    return this._app;\n  }\n\n  handleShutdown() {\n    const promises = [];\n    const { adapter: databaseAdapter } = this.config.databaseController;\n    if (databaseAdapter && typeof databaseAdapter.handleShutdown === 'function') {\n      promises.push(databaseAdapter.handleShutdown());\n    }\n    const { adapter: fileAdapter } = this.config.filesController;\n    if (fileAdapter && typeof fileAdapter.handleShutdown === 'function') {\n      promises.push(fileAdapter.handleShutdown());\n    }\n    const { adapter: cacheAdapter } = this.config.cacheController;\n    if (cacheAdapter && typeof cacheAdapter.handleShutdown === 'function') {\n      promises.push(cacheAdapter.handleShutdown());\n    }\n    return (promises.length > 0 ? Promise.all(promises) : Promise.resolve()).then(() => {\n      if (this.config.serverCloseComplete) {\n        this.config.serverCloseComplete();\n      }\n    });\n  }\n\n  /**\n   * @static\n   * Create an express app for the parse server\n   * @param {Object} options let you specify the maxUploadSize when creating the express app  */\n  static app(options) {\n    const { maxUploadSize = '20mb', appId, directAccess, pages } = options;\n    // This app serves the Parse API directly.\n    // It's the equivalent of https://api.parse.com/1 in the hosted Parse API.\n    var api = express();\n    //api.use(\"/apps\", express.static(__dirname + \"/public\"));\n    api.use(middlewares.allowCrossDomain(appId));\n    // File handling needs to be before default middlewares are applied\n    api.use(\n      '/',\n      new FilesRouter().expressRouter({\n        maxUploadSize: maxUploadSize,\n      })\n    );\n\n    api.use('/health', function (req, res) {\n      res.json({\n        status: 'ok',\n      });\n    });\n\n    api.use(\n      '/',\n      bodyParser.urlencoded({ extended: false }),\n      pages.enableRouter\n        ? new PagesRouter(pages).expressRouter()\n        : new PublicAPIRouter().expressRouter()\n    );\n\n    api.use(bodyParser.json({ type: '*/*', limit: maxUploadSize }));\n    api.use(middlewares.allowMethodOverride);\n    api.use(middlewares.handleParseHeaders);\n\n    const appRouter = ParseServer.promiseRouter({ appId });\n    api.use(appRouter.expressRouter());\n\n    api.use(middlewares.handleParseErrors);\n\n    // run the following when not testing\n    if (!process.env.TESTING) {\n      //This causes tests to spew some useless warnings, so disable in test\n      /* istanbul ignore next */\n      process.on('uncaughtException', err => {\n        if (err.code === 'EADDRINUSE') {\n          // user-friendly message for this common error\n          process.stderr.write(`Unable to listen on port ${err.port}. The port is already in use.`);\n          process.exit(0);\n        } else {\n          throw err;\n        }\n      });\n      // verify the server url after a 'mount' event is received\n      /* istanbul ignore next */\n      api.on('mount', function () {\n        ParseServer.verifyServerUrl();\n      });\n    }\n    if (process.env.PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS === '1' || directAccess) {\n      Parse.CoreManager.setRESTController(ParseServerRESTController(appId, appRouter));\n    }\n    return api;\n  }\n\n  static promiseRouter({ appId }) {\n    const routers = [\n      new ClassesRouter(),\n      new UsersRouter(),\n      new SessionsRouter(),\n      new RolesRouter(),\n      new AnalyticsRouter(),\n      new InstallationsRouter(),\n      new FunctionsRouter(),\n      new SchemasRouter(),\n      new PushRouter(),\n      new LogsRouter(),\n      new IAPValidationRouter(),\n      new FeaturesRouter(),\n      new GlobalConfigRouter(),\n      new GraphQLRouter(),\n      new PurgeRouter(),\n      new HooksRouter(),\n      new CloudCodeRouter(),\n      new AudiencesRouter(),\n      new AggregateRouter(),\n      new SecurityRouter(),\n    ];\n\n    const routes = routers.reduce((memo, router) => {\n      return memo.concat(router.routes);\n    }, []);\n\n    const appRouter = new PromiseRouter(routes, appId);\n\n    batch.mountOnto(appRouter);\n    return appRouter;\n  }\n\n  /**\n   * starts the parse server's express app\n   * @param {ParseServerOptions} options to use to start the server\n   * @param {Function} callback called when the server has started\n   * @returns {ParseServer} the parse server instance\n   */\n  start(options: ParseServerOptions, callback: ?() => void) {\n    const app = express();\n    if (options.middleware) {\n      let middleware;\n      if (typeof options.middleware == 'string') {\n        middleware = require(path.resolve(process.cwd(), options.middleware));\n      } else {\n        middleware = options.middleware; // use as-is let express fail\n      }\n      app.use(middleware);\n    }\n\n    app.use(options.mountPath, this.app);\n\n    if (options.mountGraphQL === true || options.mountPlayground === true) {\n      let graphQLCustomTypeDefs = undefined;\n      if (typeof options.graphQLSchema === 'string') {\n        graphQLCustomTypeDefs = parse(fs.readFileSync(options.graphQLSchema, 'utf8'));\n      } else if (\n        typeof options.graphQLSchema === 'object' ||\n        typeof options.graphQLSchema === 'function'\n      ) {\n        graphQLCustomTypeDefs = options.graphQLSchema;\n      }\n\n      const parseGraphQLServer = new ParseGraphQLServer(this, {\n        graphQLPath: options.graphQLPath,\n        playgroundPath: options.playgroundPath,\n        graphQLCustomTypeDefs,\n      });\n\n      if (options.mountGraphQL) {\n        parseGraphQLServer.applyGraphQL(app);\n      }\n\n      if (options.mountPlayground) {\n        parseGraphQLServer.applyPlayground(app);\n      }\n    }\n\n    const server = app.listen(options.port, options.host, callback);\n    this.server = server;\n\n    if (options.startLiveQueryServer || options.liveQueryServerOptions) {\n      this.liveQueryServer = ParseServer.createLiveQueryServer(\n        server,\n        options.liveQueryServerOptions,\n        options\n      );\n    }\n    /* istanbul ignore next */\n    if (!process.env.TESTING) {\n      configureListeners(this);\n    }\n    this.expressApp = app;\n    return this;\n  }\n\n  /**\n   * Creates a new ParseServer and starts it.\n   * @param {ParseServerOptions} options used to start the server\n   * @param {Function} callback called when the server has started\n   * @returns {ParseServer} the parse server instance\n   */\n  static start(options: ParseServerOptions, callback: ?() => void) {\n    const parseServer = new ParseServer(options);\n    return parseServer.start(options, callback);\n  }\n\n  /**\n   * Helper method to create a liveQuery server\n   * @static\n   * @param {Server} httpServer an optional http server to pass\n   * @param {LiveQueryServerOptions} config options for the liveQueryServer\n   * @param {ParseServerOptions} options options for the ParseServer\n   * @returns {ParseLiveQueryServer} the live query server instance\n   */\n  static createLiveQueryServer(\n    httpServer,\n    config: LiveQueryServerOptions,\n    options: ParseServerOptions\n  ) {\n    if (!httpServer || (config && config.port)) {\n      var app = express();\n      httpServer = require('http').createServer(app);\n      httpServer.listen(config.port);\n    }\n    return new ParseLiveQueryServer(httpServer, config, options);\n  }\n\n  static verifyServerUrl(callback) {\n    // perform a health check on the serverURL value\n    if (Parse.serverURL) {\n      const request = require('./request');\n      request({ url: Parse.serverURL.replace(/\\/$/, '') + '/health' })\n        .catch(response => response)\n        .then(response => {\n          const json = response.data || null;\n          if (response.status !== 200 || !json || (json && json.status !== 'ok')) {\n            /* eslint-disable no-console */\n            console.warn(\n              `\\nWARNING, Unable to connect to '${Parse.serverURL}'.` +\n                ` Cloud code and push notifications may be unavailable!\\n`\n            );\n            /* eslint-enable no-console */\n            if (callback) {\n              callback(false);\n            }\n          } else {\n            if (callback) {\n              callback(true);\n            }\n          }\n        });\n    }\n  }\n}\n\nfunction addParseCloud() {\n  const ParseCloud = require('./cloud-code/Parse.Cloud');\n  Object.defineProperty(Parse, 'Server', {\n    get() {\n      return Config.get(Parse.applicationId);\n    },\n    set(newVal) {\n      newVal.appId = Parse.applicationId;\n      Config.put(newVal);\n    },\n    configurable: true,\n  });\n  Object.assign(Parse.Cloud, ParseCloud);\n  global.Parse = Parse;\n}\n\nfunction injectDefaults(options: ParseServerOptions) {\n  Object.keys(defaults).forEach(key => {\n    if (!Object.prototype.hasOwnProperty.call(options, key)) {\n      options[key] = defaults[key];\n    }\n  });\n\n  if (!Object.prototype.hasOwnProperty.call(options, 'serverURL')) {\n    options.serverURL = `http://localhost:${options.port}${options.mountPath}`;\n  }\n\n  // Reserved Characters\n  if (options.appId) {\n    const regex = /[!#$%'()*+&/:;=?@[\\]{}^,|<>]/g;\n    if (options.appId.match(regex)) {\n      console.warn(\n        `\\nWARNING, appId that contains special characters can cause issues while using with urls.\\n`\n      );\n    }\n  }\n\n  // Backwards compatibility\n  if (options.userSensitiveFields) {\n    /* eslint-disable no-console */\n    !process.env.TESTING &&\n      console.warn(\n        `\\nDEPRECATED: userSensitiveFields has been replaced by protectedFields allowing the ability to protect fields in all classes with CLP. \\n`\n      );\n    /* eslint-enable no-console */\n\n    const userSensitiveFields = Array.from(\n      new Set([...(defaults.userSensitiveFields || []), ...(options.userSensitiveFields || [])])\n    );\n\n    // If the options.protectedFields is unset,\n    // it'll be assigned the default above.\n    // Here, protect against the case where protectedFields\n    // is set, but doesn't have _User.\n    if (!('_User' in options.protectedFields)) {\n      options.protectedFields = Object.assign({ _User: [] }, options.protectedFields);\n    }\n\n    options.protectedFields['_User']['*'] = Array.from(\n      new Set([...(options.protectedFields['_User']['*'] || []), ...userSensitiveFields])\n    );\n  }\n\n  // Merge protectedFields options with defaults.\n  Object.keys(defaults.protectedFields).forEach(c => {\n    const cur = options.protectedFields[c];\n    if (!cur) {\n      options.protectedFields[c] = defaults.protectedFields[c];\n    } else {\n      Object.keys(defaults.protectedFields[c]).forEach(r => {\n        const unq = new Set([\n          ...(options.protectedFields[c][r] || []),\n          ...defaults.protectedFields[c][r],\n        ]);\n        options.protectedFields[c][r] = Array.from(unq);\n      });\n    }\n  });\n\n  options.masterKeyIps = Array.from(\n    new Set(options.masterKeyIps.concat(defaults.masterKeyIps, options.masterKeyIps))\n  );\n}\n\n// Those can't be tested as it requires a subprocess\n/* istanbul ignore next */\nfunction configureListeners(parseServer) {\n  const server = parseServer.server;\n  const sockets = {};\n  /* Currently, express doesn't shut down immediately after receiving SIGINT/SIGTERM if it has client connections that haven't timed out. (This is a known issue with node - https://github.com/nodejs/node/issues/2642)\n    This function, along with `destroyAliveConnections()`, intend to fix this behavior such that parse server will close all open connections and initiate the shutdown process as soon as it receives a SIGINT/SIGTERM signal. */\n  server.on('connection', socket => {\n    const socketId = socket.remoteAddress + ':' + socket.remotePort;\n    sockets[socketId] = socket;\n    socket.on('close', () => {\n      delete sockets[socketId];\n    });\n  });\n\n  const destroyAliveConnections = function () {\n    for (const socketId in sockets) {\n      try {\n        sockets[socketId].destroy();\n      } catch (e) {\n        /* */\n      }\n    }\n  };\n\n  const handleShutdown = function () {\n    process.stdout.write('Termination signal received. Shutting down.');\n    destroyAliveConnections();\n    server.close();\n    parseServer.handleShutdown();\n  };\n  process.on('SIGTERM', handleShutdown);\n  process.on('SIGINT', handleShutdown);\n}\n\nexport default ParseServer;\n", "import AppCache from './cache';\nimport Parse from 'parse/node';\nimport auth from './Auth';\nimport Config from './Config';\nimport ClientSDK from './ClientSDK';\nimport defaultLogger from './logger';\nimport rest from './rest';\nimport MongoStorageAdapter from './Adapters/Storage/Mongo/MongoStorageAdapter';\nimport PostgresStorageAdapter from './Adapters/Storage/Postgres/PostgresStorageAdapter';\n\nexport const DEFAULT_ALLOWED_HEADERS =\n  'X-Parse-Master-Key, X-Parse-REST-API-Key, X-Parse-Javascript-Key, X-Parse-Application-Id, X-Parse-Client-Version, X-Parse-Session-Token, X-Requested-With, X-Parse-Revocable-Session, X-Parse-Request-Id, Content-Type, Pragma, Cache-Control';\n\nconst getMountForRequest = function (req) {\n  const mountPathLength = req.originalUrl.length - req.url.length;\n  const mountPath = req.originalUrl.slice(0, mountPathLength);\n  return req.protocol + '://' + req.get('host') + mountPath;\n};\n\n// Checks that the request is authorized for this app and checks user\n// auth too.\n// The bodyparser should run before this middleware.\n// Adds info to the request:\n// req.config - the Config for this app\n// req.auth - the Auth for this request\nexport function handleParseHeaders(req, res, next) {\n  var mount = getMountForRequest(req);\n\n  let context = {};\n  if (req.get('X-Parse-Cloud-Context') != null) {\n    try {\n      context = JSON.parse(req.get('X-Parse-Cloud-Context'));\n      if (Object.prototype.toString.call(context) !== '[object Object]') {\n        throw 'Context is not an object';\n      }\n    } catch (e) {\n      return malformedContext(req, res);\n    }\n  }\n  var info = {\n    appId: req.get('X-Parse-Application-Id'),\n    sessionToken: req.get('X-Parse-Session-Token'),\n    masterKey: req.get('X-Parse-Master-Key'),\n    installationId: req.get('X-Parse-Installation-Id'),\n    clientKey: req.get('X-Parse-Client-Key'),\n    javascriptKey: req.get('X-Parse-Javascript-Key'),\n    dotNetKey: req.get('X-Parse-Windows-Key'),\n    restAPIKey: req.get('X-Parse-REST-API-Key'),\n    clientVersion: req.get('X-Parse-Client-Version'),\n    context: context,\n  };\n\n  var basicAuth = httpAuth(req);\n\n  if (basicAuth) {\n    var basicAuthAppId = basicAuth.appId;\n    if (AppCache.get(basicAuthAppId)) {\n      info.appId = basicAuthAppId;\n      info.masterKey = basicAuth.masterKey || info.masterKey;\n      info.javascriptKey = basicAuth.javascriptKey || info.javascriptKey;\n    }\n  }\n\n  if (req.body) {\n    // Unity SDK sends a _noBody key which needs to be removed.\n    // Unclear at this point if action needs to be taken.\n    delete req.body._noBody;\n  }\n\n  var fileViaJSON = false;\n\n  if (!info.appId || !AppCache.get(info.appId)) {\n    // See if we can find the app id on the body.\n    if (req.body instanceof Buffer) {\n      // The only chance to find the app id is if this is a file\n      // upload that actually is a JSON body. So try to parse it.\n      // https://github.com/parse-community/parse-server/issues/6589\n      // It is also possible that the client is trying to upload a file but forgot\n      // to provide x-parse-app-id in header and parse a binary file will fail\n      try {\n        req.body = JSON.parse(req.body);\n      } catch (e) {\n        return invalidRequest(req, res);\n      }\n      fileViaJSON = true;\n    }\n\n    if (req.body) {\n      delete req.body._RevocableSession;\n    }\n\n    if (\n      req.body &&\n      req.body._ApplicationId &&\n      AppCache.get(req.body._ApplicationId) &&\n      (!info.masterKey || AppCache.get(req.body._ApplicationId).masterKey === info.masterKey)\n    ) {\n      info.appId = req.body._ApplicationId;\n      info.javascriptKey = req.body._JavaScriptKey || '';\n      delete req.body._ApplicationId;\n      delete req.body._JavaScriptKey;\n      // TODO: test that the REST API formats generated by the other\n      // SDKs are handled ok\n      if (req.body._ClientVersion) {\n        info.clientVersion = req.body._ClientVersion;\n        delete req.body._ClientVersion;\n      }\n      if (req.body._InstallationId) {\n        info.installationId = req.body._InstallationId;\n        delete req.body._InstallationId;\n      }\n      if (req.body._SessionToken) {\n        info.sessionToken = req.body._SessionToken;\n        delete req.body._SessionToken;\n      }\n      if (req.body._MasterKey) {\n        info.masterKey = req.body._MasterKey;\n        delete req.body._MasterKey;\n      }\n      if (req.body._context) {\n        if (req.body._context instanceof Object) {\n          info.context = req.body._context;\n        } else {\n          try {\n            info.context = JSON.parse(req.body._context);\n            if (Object.prototype.toString.call(info.context) !== '[object Object]') {\n              throw 'Context is not an object';\n            }\n          } catch (e) {\n            return malformedContext(req, res);\n          }\n        }\n        delete req.body._context;\n      }\n      if (req.body._ContentType) {\n        req.headers['content-type'] = req.body._ContentType;\n        delete req.body._ContentType;\n      }\n    } else {\n      return invalidRequest(req, res);\n    }\n  }\n\n  if (info.sessionToken && typeof info.sessionToken !== 'string') {\n    info.sessionToken = info.sessionToken.toString();\n  }\n\n  if (info.clientVersion) {\n    info.clientSDK = ClientSDK.fromString(info.clientVersion);\n  }\n\n  if (fileViaJSON) {\n    req.fileData = req.body.fileData;\n    // We need to repopulate req.body with a buffer\n    var base64 = req.body.base64;\n    req.body = Buffer.from(base64, 'base64');\n  }\n\n  const clientIp = getClientIp(req);\n\n  info.app = AppCache.get(info.appId);\n  req.config = Config.get(info.appId, mount);\n  req.config.headers = req.headers || {};\n  req.config.ip = clientIp;\n  req.info = info;\n\n  if (\n    info.masterKey &&\n    req.config.masterKeyIps &&\n    req.config.masterKeyIps.length !== 0 &&\n    req.config.masterKeyIps.indexOf(clientIp) === -1\n  ) {\n    return invalidRequest(req, res);\n  }\n\n  var isMaster = info.masterKey === req.config.masterKey;\n\n  if (isMaster) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: true,\n    });\n    next();\n    return;\n  }\n\n  var isReadOnlyMaster = info.masterKey === req.config.readOnlyMasterKey;\n  if (\n    typeof req.config.readOnlyMasterKey != 'undefined' &&\n    req.config.readOnlyMasterKey &&\n    isReadOnlyMaster\n  ) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: true,\n      isReadOnly: true,\n    });\n    next();\n    return;\n  }\n\n  // Client keys are not required in parse-server, but if any have been configured in the server, validate them\n  //  to preserve original behavior.\n  const keys = ['clientKey', 'javascriptKey', 'dotNetKey', 'restAPIKey'];\n  const oneKeyConfigured = keys.some(function (key) {\n    return req.config[key] !== undefined;\n  });\n  const oneKeyMatches = keys.some(function (key) {\n    return req.config[key] !== undefined && info[key] === req.config[key];\n  });\n\n  if (oneKeyConfigured && !oneKeyMatches) {\n    return invalidRequest(req, res);\n  }\n\n  if (req.url == '/login') {\n    delete info.sessionToken;\n  }\n\n  if (req.userFromJWT) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: false,\n      user: req.userFromJWT,\n    });\n    next();\n    return;\n  }\n\n  if (!info.sessionToken) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: false,\n    });\n    next();\n    return;\n  }\n\n  return Promise.resolve()\n    .then(() => {\n      // handle the upgradeToRevocableSession path on it's own\n      if (\n        info.sessionToken &&\n        req.url === '/upgradeToRevocableSession' &&\n        info.sessionToken.indexOf('r:') != 0\n      ) {\n        return auth.getAuthForLegacySessionToken({\n          config: req.config,\n          installationId: info.installationId,\n          sessionToken: info.sessionToken,\n        });\n      } else {\n        return auth.getAuthForSessionToken({\n          config: req.config,\n          installationId: info.installationId,\n          sessionToken: info.sessionToken,\n        });\n      }\n    })\n    .then(auth => {\n      if (auth) {\n        req.auth = auth;\n        next();\n      }\n    })\n    .catch(error => {\n      if (error instanceof Parse.Error) {\n        next(error);\n        return;\n      } else {\n        // TODO: Determine the correct error scenario.\n        req.config.loggerController.error('error getting auth for sessionToken', error);\n        throw new Parse.Error(Parse.Error.UNKNOWN_ERROR, error);\n      }\n    });\n}\n\nfunction getClientIp(req) {\n  if (req.headers['x-forwarded-for']) {\n    // try to get from x-forwared-for if it set (behind reverse proxy)\n    return req.headers['x-forwarded-for'].split(',')[0];\n  } else if (req.connection && req.connection.remoteAddress) {\n    // no proxy, try getting from connection.remoteAddress\n    return req.connection.remoteAddress;\n  } else if (req.socket) {\n    // try to get it from req.socket\n    return req.socket.remoteAddress;\n  } else if (req.connection && req.connection.socket) {\n    // try to get it form the connection.socket\n    return req.connection.socket.remoteAddress;\n  } else {\n    // if non above, fallback.\n    return req.ip;\n  }\n}\n\nfunction httpAuth(req) {\n  if (!(req.req || req).headers.authorization) return;\n\n  var header = (req.req || req).headers.authorization;\n  var appId, masterKey, javascriptKey;\n\n  // parse header\n  var authPrefix = 'basic ';\n\n  var match = header.toLowerCase().indexOf(authPrefix);\n\n  if (match == 0) {\n    var encodedAuth = header.substring(authPrefix.length, header.length);\n    var credentials = decodeBase64(encodedAuth).split(':');\n\n    if (credentials.length == 2) {\n      appId = credentials[0];\n      var key = credentials[1];\n\n      var jsKeyPrefix = 'javascript-key=';\n\n      var matchKey = key.indexOf(jsKeyPrefix);\n      if (matchKey == 0) {\n        javascriptKey = key.substring(jsKeyPrefix.length, key.length);\n      } else {\n        masterKey = key;\n      }\n    }\n  }\n\n  return { appId: appId, masterKey: masterKey, javascriptKey: javascriptKey };\n}\n\nfunction decodeBase64(str) {\n  return Buffer.from(str, 'base64').toString();\n}\n\nexport function allowCrossDomain(appId) {\n  return (req, res, next) => {\n    const config = Config.get(appId, getMountForRequest(req));\n    let allowHeaders = DEFAULT_ALLOWED_HEADERS;\n    if (config && config.allowHeaders) {\n      allowHeaders += `, ${config.allowHeaders.join(', ')}`;\n    }\n    const allowOrigin = (config && config.allowOrigin) || '*';\n    res.header('Access-Control-Allow-Origin', allowOrigin);\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');\n    res.header('Access-Control-Allow-Headers', allowHeaders);\n    res.header('Access-Control-Expose-Headers', 'X-Parse-Job-Status-Id, X-Parse-Push-Status-Id');\n    // intercept OPTIONS method\n    if ('OPTIONS' == req.method) {\n      res.sendStatus(200);\n    } else {\n      next();\n    }\n  };\n}\n\nexport function allowMethodOverride(req, res, next) {\n  if (req.method === 'POST' && req.body._method) {\n    req.originalMethod = req.method;\n    req.method = req.body._method;\n    delete req.body._method;\n  }\n  next();\n}\n\nexport function handleParseErrors(err, req, res, next) {\n  const log = (req.config && req.config.loggerController) || defaultLogger;\n  if (err instanceof Parse.Error) {\n    if (req.config && req.config.enableExpressErrorHandler) {\n      return next(err);\n    }\n    let httpStatus;\n    // TODO: fill out this mapping\n    switch (err.code) {\n      case Parse.Error.INTERNAL_SERVER_ERROR:\n        httpStatus = 500;\n        break;\n      case Parse.Error.OBJECT_NOT_FOUND:\n        httpStatus = 404;\n        break;\n      default:\n        httpStatus = 400;\n    }\n    res.status(httpStatus);\n    res.json({ code: err.code, error: err.message });\n    log.error('Parse error: ', err);\n  } else if (err.status && err.message) {\n    res.status(err.status);\n    res.json({ error: err.message });\n    if (!(process && process.env.TESTING)) {\n      next(err);\n    }\n  } else {\n    log.error('Uncaught internal server error.', err, err.stack);\n    res.status(500);\n    res.json({\n      code: Parse.Error.INTERNAL_SERVER_ERROR,\n      message: 'Internal server error.',\n    });\n    if (!(process && process.env.TESTING)) {\n      next(err);\n    }\n  }\n}\n\nexport function enforceMasterKeyAccess(req, res, next) {\n  if (!req.auth.isMaster) {\n    res.status(403);\n    res.end('{\"error\":\"unauthorized: master key is required\"}');\n    return;\n  }\n  next();\n}\n\nexport function promiseEnforceMasterKeyAccess(request) {\n  if (!request.auth.isMaster) {\n    const error = new Error();\n    error.status = 403;\n    error.message = 'unauthorized: master key is required';\n    throw error;\n  }\n  return Promise.resolve();\n}\n\n/**\n * Deduplicates a request to ensure idempotency. Duplicates are determined by the request ID\n * in the request header. If a request has no request ID, it is executed anyway.\n * @param {*} req The request to evaluate.\n * @returns Promise<{}>\n */\nexport function promiseEnsureIdempotency(req) {\n  // Enable feature only for MongoDB\n  if (\n    !(\n      req.config.database.adapter instanceof MongoStorageAdapter ||\n      req.config.database.adapter instanceof PostgresStorageAdapter\n    )\n  ) {\n    return Promise.resolve();\n  }\n  // Get parameters\n  const config = req.config;\n  const requestId = ((req || {}).headers || {})['x-parse-request-id'];\n  const { paths, ttl } = config.idempotencyOptions;\n  if (!requestId || !config.idempotencyOptions) {\n    return Promise.resolve();\n  }\n  // Request path may contain trailing slashes, depending on the original request, so remove\n  // leading and trailing slashes to make it easier to specify paths in the configuration\n  const reqPath = req.path.replace(/^\\/|\\/$/, '');\n  // Determine whether idempotency is enabled for current request path\n  let match = false;\n  for (const path of paths) {\n    // Assume one wants a path to always match from the beginning to prevent any mistakes\n    const regex = new RegExp(path.charAt(0) === '^' ? path : '^' + path);\n    if (reqPath.match(regex)) {\n      match = true;\n      break;\n    }\n  }\n  if (!match) {\n    return Promise.resolve();\n  }\n  // Try to store request\n  const expiryDate = new Date(new Date().setSeconds(new Date().getSeconds() + ttl));\n  return rest\n    .create(config, auth.master(config), '_Idempotency', {\n      reqId: requestId,\n      expire: Parse._encode(expiryDate),\n    })\n    .catch(e => {\n      if (e.code == Parse.Error.DUPLICATE_VALUE) {\n        throw new Parse.Error(Parse.Error.DUPLICATE_REQUEST, 'Duplicate request');\n      }\n      throw e;\n    });\n}\n\nfunction invalidRequest(req, res) {\n  res.status(403);\n  res.end('{\"error\":\"unauthorized\"}');\n}\n\nfunction malformedContext(req, res) {\n  res.status(400);\n  res.json({ code: Parse.Error.INVALID_JSON, error: 'Invalid object for context.' });\n}\n"], "fixing_code": ["const middlewares = require('../lib/middlewares');\nconst AppCache = require('../lib/cache').AppCache;\n\ndescribe('middlewares', () => {\n  let fakeReq, fakeRes;\n\n  beforeEach(() => {\n    fakeReq = {\n      originalUrl: 'http://example.com/parse/',\n      url: 'http://example.com/',\n      body: {\n        _ApplicationId: 'FakeAppId',\n      },\n      headers: {},\n      get: key => {\n        return fakeReq.headers[key.toLowerCase()];\n      },\n    };\n    fakeRes = jasmine.createSpyObj('fakeRes', ['end', 'status']);\n    AppCache.put(fakeReq.body._ApplicationId, {});\n  });\n\n  afterEach(() => {\n    AppCache.del(fakeReq.body._ApplicationId);\n  });\n\n  it('should use _ContentType if provided', done => {\n    expect(fakeReq.headers['content-type']).toEqual(undefined);\n    const contentType = 'image/jpeg';\n    fakeReq.body._ContentType = contentType;\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeReq.headers['content-type']).toEqual(contentType);\n      expect(fakeReq.body._ContentType).toEqual(undefined);\n      done();\n    });\n  });\n\n  it('should give invalid response when keys are configured but no key supplied', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should give invalid response when keys are configured but supplied key is incorrect', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    fakeReq.headers['x-parse-rest-api-key'] = 'wrongKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should give invalid response when keys are configured but different key is supplied', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    fakeReq.headers['x-parse-client-key'] = 'clientKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should succeed when any one of the configured keys supplied', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      clientKey: 'clientKey',\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    fakeReq.headers['x-parse-rest-api-key'] = 'restAPIKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should succeed when client key supplied but empty', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      clientKey: '',\n      masterKey: 'masterKey',\n      restAPIKey: 'restAPIKey',\n    });\n    fakeReq.headers['x-parse-client-key'] = '';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should succeed when no keys are configured and none supplied', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n    });\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  const BodyParams = {\n    clientVersion: '_ClientVersion',\n    installationId: '_InstallationId',\n    sessionToken: '_SessionToken',\n    masterKey: '_MasterKey',\n    javascriptKey: '_JavaScriptKey',\n  };\n\n  const BodyKeys = Object.keys(BodyParams);\n\n  BodyKeys.forEach(infoKey => {\n    const bodyKey = BodyParams[infoKey];\n    const keyValue = 'Fake' + bodyKey;\n    // javascriptKey is the only one that gets defaulted,\n    const otherKeys = BodyKeys.filter(\n      otherKey => otherKey !== infoKey && otherKey !== 'javascriptKey'\n    );\n\n    it(`it should pull ${bodyKey} into req.info`, done => {\n      fakeReq.body[bodyKey] = keyValue;\n\n      middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n        expect(fakeReq.body[bodyKey]).toEqual(undefined);\n        expect(fakeReq.info[infoKey]).toEqual(keyValue);\n\n        otherKeys.forEach(otherKey => {\n          expect(fakeReq.info[otherKey]).toEqual(undefined);\n        });\n\n        done();\n      });\n    });\n  });\n\n  it('should not succeed if the ip does not belong to masterKeyIps list', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.ip = 'ip3';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n\n  it('should succeed if the ip does belong to masterKeyIps list', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: ['ip1', 'ip2'],\n    });\n    fakeReq.ip = 'ip1';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('should allow any ip to use masterKey if masterKeyIps is empty', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n      masterKeyIps: [],\n    });\n    fakeReq.ip = 'ip1';\n    fakeReq.headers['x-parse-master-key'] = 'masterKey';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeRes.status).not.toHaveBeenCalled();\n      done();\n    });\n  });\n\n  it('can set trust proxy', async () => {\n    const server = await reconfigureServer({ trustProxy: 1 });\n    expect(server.app.parent.settings['trust proxy']).toBe(1);\n  });\n\n  it('should properly expose the headers', () => {\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(Object.keys(headers).length).toBe(4);\n    expect(headers['Access-Control-Expose-Headers']).toBe(\n      'X-Parse-Job-Status-Id, X-Parse-Push-Status-Id'\n    );\n  });\n\n  it('should set default Access-Control-Allow-Headers if allowHeaders are empty', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: undefined,\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: [],\n    });\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n  });\n\n  it('should append custom headers to Access-Control-Allow-Headers if allowHeaders provided', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowHeaders: ['Header-1', 'Header-2'],\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Headers']).toContain('Header-1, Header-2');\n    expect(headers['Access-Control-Allow-Headers']).toContain(middlewares.DEFAULT_ALLOWED_HEADERS);\n  });\n\n  it('should set default Access-Control-Allow-Origin if allowOrigin is empty', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowOrigin: undefined,\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Origin']).toEqual('*');\n  });\n\n  it('should set custom origin to Access-Control-Allow-Origin if allowOrigin is provided', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      allowOrigin: 'https://parseplatform.org/',\n    });\n    const headers = {};\n    const res = {\n      header: (key, value) => {\n        headers[key] = value;\n      },\n    };\n    const allowCrossDomain = middlewares.allowCrossDomain(fakeReq.body._ApplicationId);\n    allowCrossDomain(fakeReq, res, () => {});\n    expect(headers['Access-Control-Allow-Origin']).toEqual('https://parseplatform.org/');\n  });\n\n  it('should use user provided on field userFromJWT', done => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n    });\n    fakeReq.userFromJWT = 'fake-user';\n    middlewares.handleParseHeaders(fakeReq, fakeRes, () => {\n      expect(fakeReq.auth.user).toEqual('fake-user');\n      done();\n    });\n  });\n\n  it('should give invalid response when upload file without x-parse-application-id in header', () => {\n    AppCache.put(fakeReq.body._ApplicationId, {\n      masterKey: 'masterKey',\n    });\n    fakeReq.body = Buffer.from('fake-file');\n    middlewares.handleParseHeaders(fakeReq, fakeRes);\n    expect(fakeRes.status).toHaveBeenCalledWith(403);\n  });\n});\n", "/*\n**** GENERATED CODE ****\nThis code has been generated by resources/buildConfigDefinitions.js\nDo not edit manually, but update Options/index.js\n*/\nvar parsers = require('./parsers');\n\nmodule.exports.SchemaOptions = {\n  afterMigration: {\n    env: 'PARSE_SERVER_SCHEMA_AFTER_MIGRATION',\n    help: 'Execute a callback after running schema migrations.',\n  },\n  beforeMigration: {\n    env: 'PARSE_SERVER_SCHEMA_BEFORE_MIGRATION',\n    help: 'Execute a callback before running schema migrations.',\n  },\n  definitions: {\n    env: 'PARSE_SERVER_SCHEMA_DEFINITIONS',\n    help:\n      'Rest representation on Parse.Schema https://docs.parseplatform.org/rest/guide/#adding-a-schema',\n    required: true,\n    action: parsers.objectParser,\n    default: [],\n  },\n  deleteExtraFields: {\n    env: 'PARSE_SERVER_SCHEMA_DELETE_EXTRA_FIELDS',\n    help:\n      'Is true if Parse Server should delete any fields not defined in a schema definition. This should only be used during development.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  lockSchemas: {\n    env: 'PARSE_SERVER_SCHEMA_LOCK_SCHEMAS',\n    help:\n      'Is true if Parse Server will reject any attempts to modify the schema while the server is running.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  recreateModifiedFields: {\n    env: 'PARSE_SERVER_SCHEMA_RECREATE_MODIFIED_FIELDS',\n    help:\n      'Is true if Parse Server should recreate any fields that are different between the current database schema and theschema definition. This should only be used during development.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  strict: {\n    env: 'PARSE_SERVER_SCHEMA_STRICT',\n    help: 'Is true if Parse Server should exit if schema update fail.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.ParseServerOptions = {\n  accountLockout: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT',\n    help: 'The account lockout policy for failed login attempts.',\n    action: parsers.objectParser,\n  },\n  allowClientClassCreation: {\n    env: 'PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION',\n    help: 'Enable (or disable) client class creation, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  allowCustomObjectId: {\n    env: 'PARSE_SERVER_ALLOW_CUSTOM_OBJECT_ID',\n    help: 'Enable (or disable) custom objectId',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  allowHeaders: {\n    env: 'PARSE_SERVER_ALLOW_HEADERS',\n    help: 'Add headers to Access-Control-Allow-Headers',\n    action: parsers.arrayParser,\n  },\n  allowOrigin: {\n    env: 'PARSE_SERVER_ALLOW_ORIGIN',\n    help: 'Sets the origin to Access-Control-Allow-Origin',\n  },\n  analyticsAdapter: {\n    env: 'PARSE_SERVER_ANALYTICS_ADAPTER',\n    help: 'Adapter module for the analytics',\n    action: parsers.moduleOrObjectParser,\n  },\n  appId: {\n    env: 'PARSE_SERVER_APPLICATION_ID',\n    help: 'Your Parse Application ID',\n    required: true,\n  },\n  appName: {\n    env: 'PARSE_SERVER_APP_NAME',\n    help: 'Sets the app name',\n  },\n  auth: {\n    env: 'PARSE_SERVER_AUTH_PROVIDERS',\n    help:\n      'Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication',\n    action: parsers.arrayParser,\n  },\n  cacheAdapter: {\n    env: 'PARSE_SERVER_CACHE_ADAPTER',\n    help: 'Adapter module for the cache',\n    action: parsers.moduleOrObjectParser,\n  },\n  cacheMaxSize: {\n    env: 'PARSE_SERVER_CACHE_MAX_SIZE',\n    help: 'Sets the maximum size for the in memory cache, defaults to 10000',\n    action: parsers.numberParser('cacheMaxSize'),\n    default: 10000,\n  },\n  cacheTTL: {\n    env: 'PARSE_SERVER_CACHE_TTL',\n    help: 'Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)',\n    action: parsers.numberParser('cacheTTL'),\n    default: 5000,\n  },\n  clientKey: {\n    env: 'PARSE_SERVER_CLIENT_KEY',\n    help: 'Key for iOS, MacOS, tvOS clients',\n  },\n  cloud: {\n    env: 'PARSE_SERVER_CLOUD',\n    help: 'Full path to your cloud code main.js',\n  },\n  cluster: {\n    env: 'PARSE_SERVER_CLUSTER',\n    help: 'Run with cluster, optionally set the number of processes default to os.cpus().length',\n    action: parsers.numberOrBooleanParser,\n  },\n  collectionPrefix: {\n    env: 'PARSE_SERVER_COLLECTION_PREFIX',\n    help: 'A collection prefix for the classes',\n    default: '',\n  },\n  customPages: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES',\n    help: 'custom pages for password validation and reset',\n    action: parsers.objectParser,\n    default: {},\n  },\n  databaseAdapter: {\n    env: 'PARSE_SERVER_DATABASE_ADAPTER',\n    help:\n      'Adapter module for the database; any options that are not explicitly described here are passed directly to the database client.',\n    action: parsers.moduleOrObjectParser,\n  },\n  databaseOptions: {\n    env: 'PARSE_SERVER_DATABASE_OPTIONS',\n    help: 'Options to pass to the database client',\n    action: parsers.objectParser,\n  },\n  databaseURI: {\n    env: 'PARSE_SERVER_DATABASE_URI',\n    help: 'The full URI to your database. Supported databases are mongodb or postgres.',\n    required: true,\n    default: 'mongodb://localhost:27017/parse',\n  },\n  defaultLimit: {\n    env: 'PARSE_SERVER_DEFAULT_LIMIT',\n    help: 'Default value for limit option on queries, defaults to `100`.',\n    action: parsers.numberParser('defaultLimit'),\n    default: 100,\n  },\n  directAccess: {\n    env: 'PARSE_SERVER_DIRECT_ACCESS',\n    help:\n      'Set to `true` if Parse requests within the same Node.js environment as Parse Server should be routed to Parse Server directly instead of via the HTTP interface. Default is `false`.<br><br>If set to `false` then Parse requests within the same Node.js environment as Parse Server are executed as HTTP requests sent to Parse Server via the `serverURL`. For example, a `Parse.Query` in Cloud Code is calling Parse Server via a HTTP request. The server is essentially making a HTTP request to itself, unnecessarily using network resources such as network ports.<br><br>\\u26A0\\uFE0F In environments where multiple Parse Server instances run behind a load balancer and Parse requests within the current Node.js environment should be routed via the load balancer and distributed as HTTP requests among all instances via the `serverURL`, this should be set to `false`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  dotNetKey: {\n    env: 'PARSE_SERVER_DOT_NET_KEY',\n    help: 'Key for Unity and .Net SDK',\n  },\n  emailAdapter: {\n    env: 'PARSE_SERVER_EMAIL_ADAPTER',\n    help: 'Adapter module for email sending',\n    action: parsers.moduleOrObjectParser,\n  },\n  emailVerifyTokenReuseIfValid: {\n    env: 'PARSE_SERVER_EMAIL_VERIFY_TOKEN_REUSE_IF_VALID',\n    help:\n      'Set to `true` if a email verification token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.<br><br>Default is `false`.<br>Requires option `verifyUserEmails: true`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  emailVerifyTokenValidityDuration: {\n    env: 'PARSE_SERVER_EMAIL_VERIFY_TOKEN_VALIDITY_DURATION',\n    help:\n      'Set the validity duration of the email verification token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.<br><br>For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).<br><br>Default is `undefined`.<br>Requires option `verifyUserEmails: true`.',\n    action: parsers.numberParser('emailVerifyTokenValidityDuration'),\n  },\n  enableAnonymousUsers: {\n    env: 'PARSE_SERVER_ENABLE_ANON_USERS',\n    help: 'Enable (or disable) anonymous users, defaults to true',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  enableExpressErrorHandler: {\n    env: 'PARSE_SERVER_ENABLE_EXPRESS_ERROR_HANDLER',\n    help: 'Enables the default express error handler for all errors',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  encryptionKey: {\n    env: 'PARSE_SERVER_ENCRYPTION_KEY',\n    help: 'Key for encrypting your files',\n  },\n  enforcePrivateUsers: {\n    env: 'PARSE_SERVER_ENFORCE_PRIVATE_USERS',\n    help: 'Set to true if new users should be created without public read and write access.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  expireInactiveSessions: {\n    env: 'PARSE_SERVER_EXPIRE_INACTIVE_SESSIONS',\n    help:\n      'Sets whether we should expire the inactive sessions, defaults to true. If false, all new sessions are created with no expiration date.',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  fileKey: {\n    env: 'PARSE_SERVER_FILE_KEY',\n    help: 'Key for your files',\n  },\n  filesAdapter: {\n    env: 'PARSE_SERVER_FILES_ADAPTER',\n    help: 'Adapter module for the files sub-system',\n    action: parsers.moduleOrObjectParser,\n  },\n  fileUpload: {\n    env: 'PARSE_SERVER_FILE_UPLOAD_OPTIONS',\n    help: 'Options for file uploads',\n    action: parsers.objectParser,\n    default: {},\n  },\n  graphQLPath: {\n    env: 'PARSE_SERVER_GRAPHQL_PATH',\n    help: 'Mount path for the GraphQL endpoint, defaults to /graphql',\n    default: '/graphql',\n  },\n  graphQLSchema: {\n    env: 'PARSE_SERVER_GRAPH_QLSCHEMA',\n    help: 'Full path to your GraphQL custom schema.graphql file',\n  },\n  host: {\n    env: 'PARSE_SERVER_HOST',\n    help: 'The host to serve ParseServer on, defaults to 0.0.0.0',\n    default: '0.0.0.0',\n  },\n  idempotencyOptions: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_OPTIONS',\n    help:\n      'Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  javascriptKey: {\n    env: 'PARSE_SERVER_JAVASCRIPT_KEY',\n    help: 'Key for the Javascript SDK',\n  },\n  jsonLogs: {\n    env: 'JSON_LOGS',\n    help: 'Log as structured JSON objects',\n    action: parsers.booleanParser,\n  },\n  liveQuery: {\n    env: 'PARSE_SERVER_LIVE_QUERY',\n    help: \"parse-server's LiveQuery configuration object\",\n    action: parsers.objectParser,\n  },\n  liveQueryServerOptions: {\n    env: 'PARSE_SERVER_LIVE_QUERY_SERVER_OPTIONS',\n    help: 'Live query server configuration options (will start the liveQuery server)',\n    action: parsers.objectParser,\n  },\n  loggerAdapter: {\n    env: 'PARSE_SERVER_LOGGER_ADAPTER',\n    help: 'Adapter module for the logging sub-system',\n    action: parsers.moduleOrObjectParser,\n  },\n  logLevel: {\n    env: 'PARSE_SERVER_LOG_LEVEL',\n    help: 'Sets the level for logs',\n  },\n  logsFolder: {\n    env: 'PARSE_SERVER_LOGS_FOLDER',\n    help: \"Folder for the logs (defaults to './logs'); set to null to disable file based logging\",\n    default: './logs',\n  },\n  masterKey: {\n    env: 'PARSE_SERVER_MASTER_KEY',\n    help: 'Your Parse Master Key',\n    required: true,\n  },\n  masterKeyIps: {\n    env: 'PARSE_SERVER_MASTER_KEY_IPS',\n    help: 'Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  maxLimit: {\n    env: 'PARSE_SERVER_MAX_LIMIT',\n    help: 'Max value for limit option on queries, defaults to unlimited',\n    action: parsers.numberParser('maxLimit'),\n  },\n  maxLogFiles: {\n    env: 'PARSE_SERVER_MAX_LOG_FILES',\n    help:\n      \"Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null)\",\n    action: parsers.objectParser,\n  },\n  maxUploadSize: {\n    env: 'PARSE_SERVER_MAX_UPLOAD_SIZE',\n    help: 'Max file size for uploads, defaults to 20mb',\n    default: '20mb',\n  },\n  middleware: {\n    env: 'PARSE_SERVER_MIDDLEWARE',\n    help: 'middleware for express server, can be string or function',\n  },\n  mountGraphQL: {\n    env: 'PARSE_SERVER_MOUNT_GRAPHQL',\n    help: 'Mounts the GraphQL endpoint',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  mountPath: {\n    env: 'PARSE_SERVER_MOUNT_PATH',\n    help: 'Mount path for the server, defaults to /parse',\n    default: '/parse',\n  },\n  mountPlayground: {\n    env: 'PARSE_SERVER_MOUNT_PLAYGROUND',\n    help: 'Mounts the GraphQL Playground - never use this option in production',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  objectIdSize: {\n    env: 'PARSE_SERVER_OBJECT_ID_SIZE',\n    help: \"Sets the number of characters in generated object id's, default 10\",\n    action: parsers.numberParser('objectIdSize'),\n    default: 10,\n  },\n  pages: {\n    env: 'PARSE_SERVER_PAGES',\n    help:\n      'The options for pages such as password reset and email verification. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  passwordPolicy: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY',\n    help: 'The password policy for enforcing password related rules.',\n    action: parsers.objectParser,\n  },\n  playgroundPath: {\n    env: 'PARSE_SERVER_PLAYGROUND_PATH',\n    help: 'Mount path for the GraphQL Playground, defaults to /playground',\n    default: '/playground',\n  },\n  port: {\n    env: 'PORT',\n    help: 'The port to run the ParseServer, defaults to 1337.',\n    action: parsers.numberParser('port'),\n    default: 1337,\n  },\n  preserveFileName: {\n    env: 'PARSE_SERVER_PRESERVE_FILE_NAME',\n    help: 'Enable (or disable) the addition of a unique hash to the file names',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  preventLoginWithUnverifiedEmail: {\n    env: 'PARSE_SERVER_PREVENT_LOGIN_WITH_UNVERIFIED_EMAIL',\n    help:\n      'Set to `true` to prevent a user from logging in if the email has not yet been verified and email verification is required.<br><br>Default is `false`.<br>Requires option `verifyUserEmails: true`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  protectedFields: {\n    env: 'PARSE_SERVER_PROTECTED_FIELDS',\n    help: 'Protected fields that should be treated with extra security when fetching details.',\n    action: parsers.objectParser,\n    default: {\n      _User: {\n        '*': ['email'],\n      },\n    },\n  },\n  publicServerURL: {\n    env: 'PARSE_PUBLIC_SERVER_URL',\n    help: 'Public URL to your parse server with http:// or https://.',\n  },\n  push: {\n    env: 'PARSE_SERVER_PUSH',\n    help:\n      'Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications',\n    action: parsers.objectParser,\n  },\n  readOnlyMasterKey: {\n    env: 'PARSE_SERVER_READ_ONLY_MASTER_KEY',\n    help: 'Read-only key, which has the same capabilities as MasterKey without writes',\n  },\n  requestKeywordDenylist: {\n    env: 'PARSE_SERVER_REQUEST_KEYWORD_DENYLIST',\n    help:\n      'An array of keys and values that are prohibited in database read and write requests to prevent potential security vulnerabilities. It is possible to specify only a key (`{\"key\":\"...\"}`), only a value (`{\"value\":\"...\"}`) or a key-value pair (`{\"key\":\"...\",\"value\":\"...\"}`). The specification can use the following types: `boolean`, `numeric` or `string`, where `string` will be interpreted as a regex notation. Request data is deep-scanned for matching definitions to detect also any nested occurrences. Defaults are patterns that are likely to be used in malicious requests. Setting this option will override the default patterns.',\n    action: parsers.arrayParser,\n    default: [\n      {\n        key: '_bsontype',\n        value: 'Code',\n      },\n      {\n        key: 'constructor',\n      },\n      {\n        key: '__proto__',\n      },\n    ],\n  },\n  restAPIKey: {\n    env: 'PARSE_SERVER_REST_API_KEY',\n    help: 'Key for REST calls',\n  },\n  revokeSessionOnPasswordReset: {\n    env: 'PARSE_SERVER_REVOKE_SESSION_ON_PASSWORD_RESET',\n    help:\n      \"When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\",\n    action: parsers.booleanParser,\n    default: true,\n  },\n  scheduledPush: {\n    env: 'PARSE_SERVER_SCHEDULED_PUSH',\n    help: 'Configuration for push scheduling, defaults to false.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  schema: {\n    env: 'PARSE_SERVER_SCHEMA',\n    help: 'Defined schema',\n    action: parsers.objectParser,\n  },\n  security: {\n    env: 'PARSE_SERVER_SECURITY',\n    help: 'The security options to identify and report weak security settings.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  serverCloseComplete: {\n    env: 'PARSE_SERVER_SERVER_CLOSE_COMPLETE',\n    help: 'Callback when server has closed',\n  },\n  serverStartComplete: {\n    env: 'PARSE_SERVER_SERVER_START_COMPLETE',\n    help: 'Callback when server has started',\n  },\n  serverURL: {\n    env: 'PARSE_SERVER_URL',\n    help: 'URL to your parse server with http:// or https://.',\n    required: true,\n  },\n  sessionLength: {\n    env: 'PARSE_SERVER_SESSION_LENGTH',\n    help: 'Session duration, in seconds, defaults to 1 year',\n    action: parsers.numberParser('sessionLength'),\n    default: 31536000,\n  },\n  silent: {\n    env: 'SILENT',\n    help: 'Disables console output',\n    action: parsers.booleanParser,\n  },\n  startLiveQueryServer: {\n    env: 'PARSE_SERVER_START_LIVE_QUERY_SERVER',\n    help: 'Starts the liveQuery server',\n    action: parsers.booleanParser,\n  },\n  trustProxy: {\n    env: 'PARSE_SERVER_TRUST_PROXY',\n    help:\n      'The trust proxy settings. It is important to understand the exact setup of the reverse proxy, since this setting will trust values provided in the Parse Server API request. See the <a href=\"https://expressjs.com/en/guide/behind-proxies.html\">express trust proxy settings</a> documentation. Defaults to `false`.',\n    action: parsers.objectParser,\n    default: [],\n  },\n  userSensitiveFields: {\n    env: 'PARSE_SERVER_USER_SENSITIVE_FIELDS',\n    help:\n      'Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields',\n    action: parsers.arrayParser,\n  },\n  verbose: {\n    env: 'VERBOSE',\n    help: 'Set the logging to verbose',\n    action: parsers.booleanParser,\n  },\n  verifyUserEmails: {\n    env: 'PARSE_SERVER_VERIFY_USER_EMAILS',\n    help:\n      'Set to `true` to require users to verify their email address to complete the sign-up process.<br><br>Default is `false`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  webhookKey: {\n    env: 'PARSE_SERVER_WEBHOOK_KEY',\n    help: 'Key sent with outgoing webhook calls',\n  },\n};\nmodule.exports.SecurityOptions = {\n  checkGroups: {\n    env: 'PARSE_SERVER_SECURITY_CHECK_GROUPS',\n    help:\n      'The security check groups to run. This allows to add custom security checks or override existing ones. Default are the groups defined in `CheckGroups.js`.',\n    action: parsers.arrayParser,\n  },\n  enableCheck: {\n    env: 'PARSE_SERVER_SECURITY_ENABLE_CHECK',\n    help: 'Is true if Parse Server should check for weak security settings.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  enableCheckLog: {\n    env: 'PARSE_SERVER_SECURITY_ENABLE_CHECK_LOG',\n    help:\n      'Is true if the security check report should be written to logs. This should only be enabled temporarily to not expose weak security settings in logs.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.PagesOptions = {\n  customRoutes: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_ROUTES',\n    help: 'The custom routes.',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  customUrls: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URLS',\n    help: 'The URLs to the custom pages.',\n    action: parsers.objectParser,\n    default: {},\n  },\n  enableLocalization: {\n    env: 'PARSE_SERVER_PAGES_ENABLE_LOCALIZATION',\n    help: 'Is true if pages should be localized; this has no effect on custom page redirects.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  enableRouter: {\n    env: 'PARSE_SERVER_PAGES_ENABLE_ROUTER',\n    help:\n      'Is true if the pages router should be enabled; this is required for any of the pages options to take effect. Caution, this is an experimental feature that may not be appropriate for production.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  forceRedirect: {\n    env: 'PARSE_SERVER_PAGES_FORCE_REDIRECT',\n    help:\n      'Is true if responses should always be redirects and never content, false if the response type should depend on the request type (GET request -> content response; POST request -> redirect response).',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  localizationFallbackLocale: {\n    env: 'PARSE_SERVER_PAGES_LOCALIZATION_FALLBACK_LOCALE',\n    help:\n      'The fallback locale for localization if no matching translation is provided for the given locale. This is only relevant when providing translation resources via JSON file.',\n    default: 'en',\n  },\n  localizationJsonPath: {\n    env: 'PARSE_SERVER_PAGES_LOCALIZATION_JSON_PATH',\n    help:\n      'The path to the JSON file for localization; the translations will be used to fill template placeholders according to the locale.',\n  },\n  pagesEndpoint: {\n    env: 'PARSE_SERVER_PAGES_PAGES_ENDPOINT',\n    help: \"The API endpoint for the pages. Default is 'apps'.\",\n    default: 'apps',\n  },\n  pagesPath: {\n    env: 'PARSE_SERVER_PAGES_PAGES_PATH',\n    help:\n      \"The path to the pages directory; this also defines where the static endpoint '/apps' points to. Default is the './public/' directory.\",\n    default: './public',\n  },\n  placeholders: {\n    env: 'PARSE_SERVER_PAGES_PLACEHOLDERS',\n    help:\n      'The placeholder keys and values which will be filled in pages; this can be a simple object or a callback function.',\n    action: parsers.objectParser,\n    default: {},\n  },\n};\nmodule.exports.PagesRoute = {\n  handler: {\n    env: 'PARSE_SERVER_PAGES_ROUTE_HANDLER',\n    help: 'The route handler that is an async function.',\n    required: true,\n  },\n  method: {\n    env: 'PARSE_SERVER_PAGES_ROUTE_METHOD',\n    help: \"The route method, e.g. 'GET' or 'POST'.\",\n    required: true,\n  },\n  path: {\n    env: 'PARSE_SERVER_PAGES_ROUTE_PATH',\n    help: 'The route path.',\n    required: true,\n  },\n};\nmodule.exports.PagesCustomUrlsOptions = {\n  emailVerificationLinkExpired: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_LINK_EXPIRED',\n    help: 'The URL to the custom page for email verification -> link expired.',\n  },\n  emailVerificationLinkInvalid: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_LINK_INVALID',\n    help: 'The URL to the custom page for email verification -> link invalid.',\n  },\n  emailVerificationSendFail: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_SEND_FAIL',\n    help: 'The URL to the custom page for email verification -> link send fail.',\n  },\n  emailVerificationSendSuccess: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_SEND_SUCCESS',\n    help: 'The URL to the custom page for email verification -> resend link -> success.',\n  },\n  emailVerificationSuccess: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_EMAIL_VERIFICATION_SUCCESS',\n    help: 'The URL to the custom page for email verification -> success.',\n  },\n  passwordReset: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_PASSWORD_RESET',\n    help: 'The URL to the custom page for password reset.',\n  },\n  passwordResetLinkInvalid: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_PASSWORD_RESET_LINK_INVALID',\n    help: 'The URL to the custom page for password reset -> link invalid.',\n  },\n  passwordResetSuccess: {\n    env: 'PARSE_SERVER_PAGES_CUSTOM_URL_PASSWORD_RESET_SUCCESS',\n    help: 'The URL to the custom page for password reset -> success.',\n  },\n};\nmodule.exports.CustomPagesOptions = {\n  choosePassword: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_CHOOSE_PASSWORD',\n    help: 'choose password page path',\n  },\n  expiredVerificationLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_EXPIRED_VERIFICATION_LINK',\n    help: 'expired verification link page path',\n  },\n  invalidLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_LINK',\n    help: 'invalid link page path',\n  },\n  invalidPasswordResetLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_PASSWORD_RESET_LINK',\n    help: 'invalid password reset link page path',\n  },\n  invalidVerificationLink: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_INVALID_VERIFICATION_LINK',\n    help: 'invalid verification link page path',\n  },\n  linkSendFail: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_LINK_SEND_FAIL',\n    help: 'verification link send fail page path',\n  },\n  linkSendSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_LINK_SEND_SUCCESS',\n    help: 'verification link send success page path',\n  },\n  parseFrameURL: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_PARSE_FRAME_URL',\n    help: 'for masking user-facing pages',\n  },\n  passwordResetSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_PASSWORD_RESET_SUCCESS',\n    help: 'password reset success page path',\n  },\n  verifyEmailSuccess: {\n    env: 'PARSE_SERVER_CUSTOM_PAGES_VERIFY_EMAIL_SUCCESS',\n    help: 'verify email success page path',\n  },\n};\nmodule.exports.LiveQueryOptions = {\n  classNames: {\n    env: 'PARSE_SERVER_LIVEQUERY_CLASSNAMES',\n    help: \"parse-server's LiveQuery classNames\",\n    action: parsers.arrayParser,\n  },\n  pubSubAdapter: {\n    env: 'PARSE_SERVER_LIVEQUERY_PUB_SUB_ADAPTER',\n    help: 'LiveQuery pubsub adapter',\n    action: parsers.moduleOrObjectParser,\n  },\n  redisOptions: {\n    env: 'PARSE_SERVER_LIVEQUERY_REDIS_OPTIONS',\n    help: \"parse-server's LiveQuery redisOptions\",\n    action: parsers.objectParser,\n  },\n  redisURL: {\n    env: 'PARSE_SERVER_LIVEQUERY_REDIS_URL',\n    help: \"parse-server's LiveQuery redisURL\",\n  },\n  wssAdapter: {\n    env: 'PARSE_SERVER_LIVEQUERY_WSS_ADAPTER',\n    help: 'Adapter module for the WebSocketServer',\n    action: parsers.moduleOrObjectParser,\n  },\n};\nmodule.exports.LiveQueryServerOptions = {\n  appId: {\n    env: 'PARSE_LIVE_QUERY_SERVER_APP_ID',\n    help:\n      'This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.',\n  },\n  cacheTimeout: {\n    env: 'PARSE_LIVE_QUERY_SERVER_CACHE_TIMEOUT',\n    help:\n      \"Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).\",\n    action: parsers.numberParser('cacheTimeout'),\n  },\n  keyPairs: {\n    env: 'PARSE_LIVE_QUERY_SERVER_KEY_PAIRS',\n    help:\n      'A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.',\n    action: parsers.objectParser,\n  },\n  logLevel: {\n    env: 'PARSE_LIVE_QUERY_SERVER_LOG_LEVEL',\n    help:\n      'This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.',\n  },\n  masterKey: {\n    env: 'PARSE_LIVE_QUERY_SERVER_MASTER_KEY',\n    help:\n      'This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.',\n  },\n  port: {\n    env: 'PARSE_LIVE_QUERY_SERVER_PORT',\n    help: 'The port to run the LiveQuery server, defaults to 1337.',\n    action: parsers.numberParser('port'),\n    default: 1337,\n  },\n  pubSubAdapter: {\n    env: 'PARSE_LIVE_QUERY_SERVER_PUB_SUB_ADAPTER',\n    help: 'LiveQuery pubsub adapter',\n    action: parsers.moduleOrObjectParser,\n  },\n  redisOptions: {\n    env: 'PARSE_LIVE_QUERY_SERVER_REDIS_OPTIONS',\n    help: \"parse-server's LiveQuery redisOptions\",\n    action: parsers.objectParser,\n  },\n  redisURL: {\n    env: 'PARSE_LIVE_QUERY_SERVER_REDIS_URL',\n    help: \"parse-server's LiveQuery redisURL\",\n  },\n  serverURL: {\n    env: 'PARSE_LIVE_QUERY_SERVER_SERVER_URL',\n    help:\n      'This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.',\n  },\n  websocketTimeout: {\n    env: 'PARSE_LIVE_QUERY_SERVER_WEBSOCKET_TIMEOUT',\n    help:\n      'Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).',\n    action: parsers.numberParser('websocketTimeout'),\n  },\n  wssAdapter: {\n    env: 'PARSE_LIVE_QUERY_SERVER_WSS_ADAPTER',\n    help: 'Adapter module for the WebSocketServer',\n    action: parsers.moduleOrObjectParser,\n  },\n};\nmodule.exports.IdempotencyOptions = {\n  paths: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_PATHS',\n    help:\n      'An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.',\n    action: parsers.arrayParser,\n    default: [],\n  },\n  ttl: {\n    env: 'PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_TTL',\n    help:\n      'The duration in seconds after which a request record is discarded from the database, defaults to 300s.',\n    action: parsers.numberParser('ttl'),\n    default: 300,\n  },\n};\nmodule.exports.AccountLockoutOptions = {\n  duration: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT_DURATION',\n    help:\n      'Set the duration in minutes that a locked-out account remains locked out before automatically becoming unlocked.<br><br>Valid values are greater than `0` and less than `100000`.',\n    action: parsers.numberParser('duration'),\n  },\n  threshold: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT_THRESHOLD',\n    help:\n      'Set the number of failed sign-in attempts that will cause a user account to be locked. If the account is locked. The account will unlock after the duration set in the `duration` option has passed and no further login attempts have been made.<br><br>Valid values are greater than `0` and less than `1000`.',\n    action: parsers.numberParser('threshold'),\n  },\n  unlockOnPasswordReset: {\n    env: 'PARSE_SERVER_ACCOUNT_LOCKOUT_UNLOCK_ON_PASSWORD_RESET',\n    help:\n      'Set to `true`  if the account should be unlocked after a successful password reset.<br><br>Default is `false`.<br>Requires options `duration` and `threshold` to be set.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.PasswordPolicyOptions = {\n  doNotAllowUsername: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_DO_NOT_ALLOW_USERNAME',\n    help:\n      'Set to `true` to disallow the username as part of the password.<br><br>Default is `false`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  maxPasswordAge: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_MAX_PASSWORD_AGE',\n    help:\n      'Set the number of days after which a password expires. Login attempts fail if the user does not reset the password before expiration.',\n    action: parsers.numberParser('maxPasswordAge'),\n  },\n  maxPasswordHistory: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_MAX_PASSWORD_HISTORY',\n    help:\n      'Set the number of previous password that will not be allowed to be set as new password. If the option is not set or set to `0`, no previous passwords will be considered.<br><br>Valid values are >= `0` and <= `20`.<br>Default is `0`.',\n    action: parsers.numberParser('maxPasswordHistory'),\n  },\n  resetTokenReuseIfValid: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_RESET_TOKEN_REUSE_IF_VALID',\n    help:\n      'Set to `true` if a password reset token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.<br><br>Default is `false`.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  resetTokenValidityDuration: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_RESET_TOKEN_VALIDITY_DURATION',\n    help:\n      'Set the validity duration of the password reset token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.<br><br>For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).<br><br>Default is `undefined`.',\n    action: parsers.numberParser('resetTokenValidityDuration'),\n  },\n  validationError: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_VALIDATION_ERROR',\n    help:\n      'Set the error message to be sent.<br><br>Default is `Password does not meet the Password Policy requirements.`',\n  },\n  validatorCallback: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_VALIDATOR_CALLBACK',\n    help:\n      'Set a callback function to validate a password to be accepted.<br><br>If used in combination with `validatorPattern`, the password must pass both to be accepted.',\n  },\n  validatorPattern: {\n    env: 'PARSE_SERVER_PASSWORD_POLICY_VALIDATOR_PATTERN',\n    help:\n      'Set the regular expression validation pattern a password must match to be accepted.<br><br>If used in combination with `validatorCallback`, the password must pass both to be accepted.',\n  },\n};\nmodule.exports.FileUploadOptions = {\n  enableForAnonymousUser: {\n    env: 'PARSE_SERVER_FILE_UPLOAD_ENABLE_FOR_ANONYMOUS_USER',\n    help: 'Is true if file upload should be allowed for anonymous users.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n  enableForAuthenticatedUser: {\n    env: 'PARSE_SERVER_FILE_UPLOAD_ENABLE_FOR_AUTHENTICATED_USER',\n    help: 'Is true if file upload should be allowed for authenticated users.',\n    action: parsers.booleanParser,\n    default: true,\n  },\n  enableForPublic: {\n    env: 'PARSE_SERVER_FILE_UPLOAD_ENABLE_FOR_PUBLIC',\n    help: 'Is true if file upload should be allowed for anyone, regardless of user authentication.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.DatabaseOptions = {\n  enableSchemaHooks: {\n    env: 'PARSE_SERVER_DATABASE_ENABLE_SCHEMA_HOOKS',\n    help:\n      'Enables database real-time hooks to update single schema cache. Set to `true` if using multiple Parse Servers instances connected to the same database. Failing to do so will cause a schema change to not propagate to all instances and re-syncing will only happen when the instances restart. To use this feature with MongoDB, a replica set cluster with [change stream](https://docs.mongodb.com/manual/changeStreams/#availability) support is required.',\n    action: parsers.booleanParser,\n    default: false,\n  },\n};\nmodule.exports.AuthAdapter = {\n  enabled: {\n    help: 'Is `true` if the auth adapter is enabled, `false` otherwise.',\n    action: parsers.booleanParser,\n    default: true,\n  },\n};\n", "/**\n * @interface SchemaOptions\n * @property {Function} afterMigration Execute a callback after running schema migrations.\n * @property {Function} beforeMigration Execute a callback before running schema migrations.\n * @property {Any} definitions Rest representation on Parse.Schema https://docs.parseplatform.org/rest/guide/#adding-a-schema\n * @property {Boolean} deleteExtraFields Is true if Parse Server should delete any fields not defined in a schema definition. This should only be used during development.\n * @property {Boolean} lockSchemas Is true if Parse Server will reject any attempts to modify the schema while the server is running.\n * @property {Boolean} recreateModifiedFields Is true if Parse Server should recreate any fields that are different between the current database schema and theschema definition. This should only be used during development.\n * @property {Boolean} strict Is true if Parse Server should exit if schema update fail.\n */\n\n/**\n * @interface ParseServerOptions\n * @property {AccountLockoutOptions} accountLockout The account lockout policy for failed login attempts.\n * @property {Boolean} allowClientClassCreation Enable (or disable) client class creation, defaults to true\n * @property {Boolean} allowCustomObjectId Enable (or disable) custom objectId\n * @property {String[]} allowHeaders Add headers to Access-Control-Allow-Headers\n * @property {String} allowOrigin Sets the origin to Access-Control-Allow-Origin\n * @property {Adapter<AnalyticsAdapter>} analyticsAdapter Adapter module for the analytics\n * @property {String} appId Your Parse Application ID\n * @property {String} appName Sets the app name\n * @property {AuthAdapter[]} auth Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication\n * @property {Adapter<CacheAdapter>} cacheAdapter Adapter module for the cache\n * @property {Number} cacheMaxSize Sets the maximum size for the in memory cache, defaults to 10000\n * @property {Number} cacheTTL Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)\n * @property {String} clientKey Key for iOS, MacOS, tvOS clients\n * @property {String} cloud Full path to your cloud code main.js\n * @property {Number|Boolean} cluster Run with cluster, optionally set the number of processes default to os.cpus().length\n * @property {String} collectionPrefix A collection prefix for the classes\n * @property {CustomPagesOptions} customPages custom pages for password validation and reset\n * @property {Adapter<StorageAdapter>} databaseAdapter Adapter module for the database; any options that are not explicitly described here are passed directly to the database client.\n * @property {DatabaseOptions} databaseOptions Options to pass to the database client\n * @property {String} databaseURI The full URI to your database. Supported databases are mongodb or postgres.\n * @property {Number} defaultLimit Default value for limit option on queries, defaults to `100`.\n * @property {Boolean} directAccess Set to `true` if Parse requests within the same Node.js environment as Parse Server should be routed to Parse Server directly instead of via the HTTP interface. Default is `false`.<br><br>If set to `false` then Parse requests within the same Node.js environment as Parse Server are executed as HTTP requests sent to Parse Server via the `serverURL`. For example, a `Parse.Query` in Cloud Code is calling Parse Server via a HTTP request. The server is essentially making a HTTP request to itself, unnecessarily using network resources such as network ports.<br><br>\u26a0\ufe0f In environments where multiple Parse Server instances run behind a load balancer and Parse requests within the current Node.js environment should be routed via the load balancer and distributed as HTTP requests among all instances via the `serverURL`, this should be set to `false`.\n * @property {String} dotNetKey Key for Unity and .Net SDK\n * @property {Adapter<MailAdapter>} emailAdapter Adapter module for email sending\n * @property {Boolean} emailVerifyTokenReuseIfValid Set to `true` if a email verification token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.<br><br>Default is `false`.<br>Requires option `verifyUserEmails: true`.\n * @property {Number} emailVerifyTokenValidityDuration Set the validity duration of the email verification token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.<br><br>For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).<br><br>Default is `undefined`.<br>Requires option `verifyUserEmails: true`.\n * @property {Boolean} enableAnonymousUsers Enable (or disable) anonymous users, defaults to true\n * @property {Boolean} enableExpressErrorHandler Enables the default express error handler for all errors\n * @property {String} encryptionKey Key for encrypting your files\n * @property {Boolean} enforcePrivateUsers Set to true if new users should be created without public read and write access.\n * @property {Boolean} expireInactiveSessions Sets whether we should expire the inactive sessions, defaults to true. If false, all new sessions are created with no expiration date.\n * @property {String} fileKey Key for your files\n * @property {Adapter<FilesAdapter>} filesAdapter Adapter module for the files sub-system\n * @property {FileUploadOptions} fileUpload Options for file uploads\n * @property {String} graphQLPath Mount path for the GraphQL endpoint, defaults to /graphql\n * @property {String} graphQLSchema Full path to your GraphQL custom schema.graphql file\n * @property {String} host The host to serve ParseServer on, defaults to 0.0.0.0\n * @property {IdempotencyOptions} idempotencyOptions Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {String} javascriptKey Key for the Javascript SDK\n * @property {Boolean} jsonLogs Log as structured JSON objects\n * @property {LiveQueryOptions} liveQuery parse-server's LiveQuery configuration object\n * @property {LiveQueryServerOptions} liveQueryServerOptions Live query server configuration options (will start the liveQuery server)\n * @property {Adapter<LoggerAdapter>} loggerAdapter Adapter module for the logging sub-system\n * @property {String} logLevel Sets the level for logs\n * @property {String} logsFolder Folder for the logs (defaults to './logs'); set to null to disable file based logging\n * @property {String} masterKey Your Parse Master Key\n * @property {String[]} masterKeyIps Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)\n * @property {Number} maxLimit Max value for limit option on queries, defaults to unlimited\n * @property {Number|String} maxLogFiles Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null)\n * @property {String} maxUploadSize Max file size for uploads, defaults to 20mb\n * @property {Union} middleware middleware for express server, can be string or function\n * @property {Boolean} mountGraphQL Mounts the GraphQL endpoint\n * @property {String} mountPath Mount path for the server, defaults to /parse\n * @property {Boolean} mountPlayground Mounts the GraphQL Playground - never use this option in production\n * @property {Number} objectIdSize Sets the number of characters in generated object id's, default 10\n * @property {PagesOptions} pages The options for pages such as password reset and email verification. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {PasswordPolicyOptions} passwordPolicy The password policy for enforcing password related rules.\n * @property {String} playgroundPath Mount path for the GraphQL Playground, defaults to /playground\n * @property {Number} port The port to run the ParseServer, defaults to 1337.\n * @property {Boolean} preserveFileName Enable (or disable) the addition of a unique hash to the file names\n * @property {Boolean} preventLoginWithUnverifiedEmail Set to `true` to prevent a user from logging in if the email has not yet been verified and email verification is required.<br><br>Default is `false`.<br>Requires option `verifyUserEmails: true`.\n * @property {ProtectedFields} protectedFields Protected fields that should be treated with extra security when fetching details.\n * @property {String} publicServerURL Public URL to your parse server with http:// or https://.\n * @property {Any} push Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications\n * @property {String} readOnlyMasterKey Read-only key, which has the same capabilities as MasterKey without writes\n * @property {RequestKeywordDenylist[]} requestKeywordDenylist An array of keys and values that are prohibited in database read and write requests to prevent potential security vulnerabilities. It is possible to specify only a key (`{\"key\":\"...\"}`), only a value (`{\"value\":\"...\"}`) or a key-value pair (`{\"key\":\"...\",\"value\":\"...\"}`). The specification can use the following types: `boolean`, `numeric` or `string`, where `string` will be interpreted as a regex notation. Request data is deep-scanned for matching definitions to detect also any nested occurrences. Defaults are patterns that are likely to be used in malicious requests. Setting this option will override the default patterns.\n * @property {String} restAPIKey Key for REST calls\n * @property {Boolean} revokeSessionOnPasswordReset When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\n * @property {Boolean} scheduledPush Configuration for push scheduling, defaults to false.\n * @property {SchemaOptions} schema Defined schema\n * @property {SecurityOptions} security The security options to identify and report weak security settings.\n * @property {Function} serverCloseComplete Callback when server has closed\n * @property {Function} serverStartComplete Callback when server has started\n * @property {String} serverURL URL to your parse server with http:// or https://.\n * @property {Number} sessionLength Session duration, in seconds, defaults to 1 year\n * @property {Boolean} silent Disables console output\n * @property {Boolean} startLiveQueryServer Starts the liveQuery server\n * @property {Any} trustProxy The trust proxy settings. It is important to understand the exact setup of the reverse proxy, since this setting will trust values provided in the Parse Server API request. See the <a href=\"https://expressjs.com/en/guide/behind-proxies.html\">express trust proxy settings</a> documentation. Defaults to `false`.\n * @property {String[]} userSensitiveFields Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields\n * @property {Boolean} verbose Set the logging to verbose\n * @property {Boolean} verifyUserEmails Set to `true` to require users to verify their email address to complete the sign-up process.<br><br>Default is `false`.\n * @property {String} webhookKey Key sent with outgoing webhook calls\n */\n\n/**\n * @interface SecurityOptions\n * @property {CheckGroup[]} checkGroups The security check groups to run. This allows to add custom security checks or override existing ones. Default are the groups defined in `CheckGroups.js`.\n * @property {Boolean} enableCheck Is true if Parse Server should check for weak security settings.\n * @property {Boolean} enableCheckLog Is true if the security check report should be written to logs. This should only be enabled temporarily to not expose weak security settings in logs.\n */\n\n/**\n * @interface PagesOptions\n * @property {PagesRoute[]} customRoutes The custom routes.\n * @property {PagesCustomUrlsOptions} customUrls The URLs to the custom pages.\n * @property {Boolean} enableLocalization Is true if pages should be localized; this has no effect on custom page redirects.\n * @property {Boolean} enableRouter Is true if the pages router should be enabled; this is required for any of the pages options to take effect. Caution, this is an experimental feature that may not be appropriate for production.\n * @property {Boolean} forceRedirect Is true if responses should always be redirects and never content, false if the response type should depend on the request type (GET request -> content response; POST request -> redirect response).\n * @property {String} localizationFallbackLocale The fallback locale for localization if no matching translation is provided for the given locale. This is only relevant when providing translation resources via JSON file.\n * @property {String} localizationJsonPath The path to the JSON file for localization; the translations will be used to fill template placeholders according to the locale.\n * @property {String} pagesEndpoint The API endpoint for the pages. Default is 'apps'.\n * @property {String} pagesPath The path to the pages directory; this also defines where the static endpoint '/apps' points to. Default is the './public/' directory.\n * @property {Object} placeholders The placeholder keys and values which will be filled in pages; this can be a simple object or a callback function.\n */\n\n/**\n * @interface PagesRoute\n * @property {Function} handler The route handler that is an async function.\n * @property {String} method The route method, e.g. 'GET' or 'POST'.\n * @property {String} path The route path.\n */\n\n/**\n * @interface PagesCustomUrlsOptions\n * @property {String} emailVerificationLinkExpired The URL to the custom page for email verification -> link expired.\n * @property {String} emailVerificationLinkInvalid The URL to the custom page for email verification -> link invalid.\n * @property {String} emailVerificationSendFail The URL to the custom page for email verification -> link send fail.\n * @property {String} emailVerificationSendSuccess The URL to the custom page for email verification -> resend link -> success.\n * @property {String} emailVerificationSuccess The URL to the custom page for email verification -> success.\n * @property {String} passwordReset The URL to the custom page for password reset.\n * @property {String} passwordResetLinkInvalid The URL to the custom page for password reset -> link invalid.\n * @property {String} passwordResetSuccess The URL to the custom page for password reset -> success.\n */\n\n/**\n * @interface CustomPagesOptions\n * @property {String} choosePassword choose password page path\n * @property {String} expiredVerificationLink expired verification link page path\n * @property {String} invalidLink invalid link page path\n * @property {String} invalidPasswordResetLink invalid password reset link page path\n * @property {String} invalidVerificationLink invalid verification link page path\n * @property {String} linkSendFail verification link send fail page path\n * @property {String} linkSendSuccess verification link send success page path\n * @property {String} parseFrameURL for masking user-facing pages\n * @property {String} passwordResetSuccess password reset success page path\n * @property {String} verifyEmailSuccess verify email success page path\n */\n\n/**\n * @interface LiveQueryOptions\n * @property {String[]} classNames parse-server's LiveQuery classNames\n * @property {Adapter<PubSubAdapter>} pubSubAdapter LiveQuery pubsub adapter\n * @property {Any} redisOptions parse-server's LiveQuery redisOptions\n * @property {String} redisURL parse-server's LiveQuery redisURL\n * @property {Adapter<WSSAdapter>} wssAdapter Adapter module for the WebSocketServer\n */\n\n/**\n * @interface LiveQueryServerOptions\n * @property {String} appId This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.\n * @property {Number} cacheTimeout Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).\n * @property {Any} keyPairs A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.\n * @property {String} logLevel This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.\n * @property {String} masterKey This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.\n * @property {Number} port The port to run the LiveQuery server, defaults to 1337.\n * @property {Adapter<PubSubAdapter>} pubSubAdapter LiveQuery pubsub adapter\n * @property {Any} redisOptions parse-server's LiveQuery redisOptions\n * @property {String} redisURL parse-server's LiveQuery redisURL\n * @property {String} serverURL This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.\n * @property {Number} websocketTimeout Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).\n * @property {Adapter<WSSAdapter>} wssAdapter Adapter module for the WebSocketServer\n */\n\n/**\n * @interface IdempotencyOptions\n * @property {String[]} paths An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.\n * @property {Number} ttl The duration in seconds after which a request record is discarded from the database, defaults to 300s.\n */\n\n/**\n * @interface AccountLockoutOptions\n * @property {Number} duration Set the duration in minutes that a locked-out account remains locked out before automatically becoming unlocked.<br><br>Valid values are greater than `0` and less than `100000`.\n * @property {Number} threshold Set the number of failed sign-in attempts that will cause a user account to be locked. If the account is locked. The account will unlock after the duration set in the `duration` option has passed and no further login attempts have been made.<br><br>Valid values are greater than `0` and less than `1000`.\n * @property {Boolean} unlockOnPasswordReset Set to `true`  if the account should be unlocked after a successful password reset.<br><br>Default is `false`.<br>Requires options `duration` and `threshold` to be set.\n */\n\n/**\n * @interface PasswordPolicyOptions\n * @property {Boolean} doNotAllowUsername Set to `true` to disallow the username as part of the password.<br><br>Default is `false`.\n * @property {Number} maxPasswordAge Set the number of days after which a password expires. Login attempts fail if the user does not reset the password before expiration.\n * @property {Number} maxPasswordHistory Set the number of previous password that will not be allowed to be set as new password. If the option is not set or set to `0`, no previous passwords will be considered.<br><br>Valid values are >= `0` and <= `20`.<br>Default is `0`.\n * @property {Boolean} resetTokenReuseIfValid Set to `true` if a password reset token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.<br><br>Default is `false`.\n * @property {Number} resetTokenValidityDuration Set the validity duration of the password reset token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.<br><br>For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).<br><br>Default is `undefined`.\n * @property {String} validationError Set the error message to be sent.<br><br>Default is `Password does not meet the Password Policy requirements.`\n * @property {Function} validatorCallback Set a callback function to validate a password to be accepted.<br><br>If used in combination with `validatorPattern`, the password must pass both to be accepted.\n * @property {String} validatorPattern Set the regular expression validation pattern a password must match to be accepted.<br><br>If used in combination with `validatorCallback`, the password must pass both to be accepted.\n */\n\n/**\n * @interface FileUploadOptions\n * @property {Boolean} enableForAnonymousUser Is true if file upload should be allowed for anonymous users.\n * @property {Boolean} enableForAuthenticatedUser Is true if file upload should be allowed for authenticated users.\n * @property {Boolean} enableForPublic Is true if file upload should be allowed for anyone, regardless of user authentication.\n */\n\n/**\n * @interface DatabaseOptions\n * @property {Boolean} enableSchemaHooks Enables database real-time hooks to update single schema cache. Set to `true` if using multiple Parse Servers instances connected to the same database. Failing to do so will cause a schema change to not propagate to all instances and re-syncing will only happen when the instances restart. To use this feature with MongoDB, a replica set cluster with [change stream](https://docs.mongodb.com/manual/changeStreams/#availability) support is required.\n */\n\n/**\n * @interface AuthAdapter\n * @property {Boolean} enabled Is `true` if the auth adapter is enabled, `false` otherwise.\n */\n", "// @flow\nimport { AnalyticsAdapter } from '../Adapters/Analytics/AnalyticsAdapter';\nimport { FilesAdapter } from '../Adapters/Files/FilesAdapter';\nimport { LoggerAdapter } from '../Adapters/Logger/LoggerAdapter';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport { CacheAdapter } from '../Adapters/Cache/CacheAdapter';\nimport { MailAdapter } from '../Adapters/Email/MailAdapter';\nimport { PubSubAdapter } from '../Adapters/PubSub/PubSubAdapter';\nimport { WSSAdapter } from '../Adapters/WebSocketServer/WSSAdapter';\nimport { CheckGroup } from '../Security/CheckGroup';\n\nexport interface SchemaOptions {\n  /* Rest representation on Parse.Schema https://docs.parseplatform.org/rest/guide/#adding-a-schema\n  :DEFAULT: [] */\n  definitions: any;\n  /* Is true if Parse Server should exit if schema update fail.\n  :DEFAULT: false */\n  strict: ?boolean;\n  /* Is true if Parse Server should delete any fields not defined in a schema definition. This should only be used during development.\n  :DEFAULT: false */\n  deleteExtraFields: ?boolean;\n  /* Is true if Parse Server should recreate any fields that are different between the current database schema and theschema definition. This should only be used during development.\n  :DEFAULT: false */\n  recreateModifiedFields: ?boolean;\n  /* Is true if Parse Server will reject any attempts to modify the schema while the server is running.\n  :DEFAULT: false */\n  lockSchemas: ?boolean;\n  /* Execute a callback before running schema migrations. */\n  beforeMigration: ?() => void | Promise<void>;\n  /* Execute a callback after running schema migrations. */\n  afterMigration: ?() => void | Promise<void>;\n}\n\ntype Adapter<T> = string | any | T;\ntype NumberOrBoolean = number | boolean;\ntype NumberOrString = number | string;\ntype ProtectedFields = any;\ntype RequestKeywordDenylist = {\n  key: string | any,\n  value: any,\n};\n\nexport interface ParseServerOptions {\n  /* Your Parse Application ID\n  :ENV: PARSE_SERVER_APPLICATION_ID */\n  appId: string;\n  /* Your Parse Master Key */\n  masterKey: string;\n  /* URL to your parse server with http:// or https://.\n  :ENV: PARSE_SERVER_URL */\n  serverURL: string;\n  /* Restrict masterKey to be used by only these ips, defaults to [] (allow all ips)\n  :DEFAULT: [] */\n  masterKeyIps: ?(string[]);\n  /* Sets the app name */\n  appName: ?string;\n  /* Add headers to Access-Control-Allow-Headers */\n  allowHeaders: ?(string[]);\n  /* Sets the origin to Access-Control-Allow-Origin */\n  allowOrigin: ?string;\n  /* Adapter module for the analytics */\n  analyticsAdapter: ?Adapter<AnalyticsAdapter>;\n  /* Adapter module for the files sub-system */\n  filesAdapter: ?Adapter<FilesAdapter>;\n  /* Configuration for push, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#push-notifications */\n  push: ?any;\n  /* Configuration for push scheduling, defaults to false.\n  :DEFAULT: false */\n  scheduledPush: ?boolean;\n  /* Adapter module for the logging sub-system */\n  loggerAdapter: ?Adapter<LoggerAdapter>;\n  /* Log as structured JSON objects\n  :ENV: JSON_LOGS */\n  jsonLogs: ?boolean;\n  /* Folder for the logs (defaults to './logs'); set to null to disable file based logging\n  :ENV: PARSE_SERVER_LOGS_FOLDER\n  :DEFAULT: ./logs */\n  logsFolder: ?string;\n  /* Set the logging to verbose\n  :ENV: VERBOSE */\n  verbose: ?boolean;\n  /* Sets the level for logs */\n  logLevel: ?string;\n  /* Maximum number of logs to keep. If not set, no logs will be removed. This can be a number of files or number of days. If using days, add 'd' as the suffix. (default: null) */\n  maxLogFiles: ?NumberOrString;\n  /* Disables console output\n  :ENV: SILENT */\n  silent: ?boolean;\n  /* The full URI to your database. Supported databases are mongodb or postgres.\n  :DEFAULT: mongodb://localhost:27017/parse */\n  databaseURI: string;\n  /* Options to pass to the database client\n  :ENV: PARSE_SERVER_DATABASE_OPTIONS */\n  databaseOptions: ?DatabaseOptions;\n  /* Adapter module for the database; any options that are not explicitly described here are passed directly to the database client. */\n  databaseAdapter: ?Adapter<StorageAdapter>;\n  /* Full path to your cloud code main.js */\n  cloud: ?string;\n  /* A collection prefix for the classes\n  :DEFAULT: '' */\n  collectionPrefix: ?string;\n  /* Key for iOS, MacOS, tvOS clients */\n  clientKey: ?string;\n  /* Key for the Javascript SDK */\n  javascriptKey: ?string;\n  /* Key for Unity and .Net SDK */\n  dotNetKey: ?string;\n  /* Key for encrypting your files\n  :ENV: PARSE_SERVER_ENCRYPTION_KEY */\n  encryptionKey: ?string;\n  /* Key for REST calls\n  :ENV: PARSE_SERVER_REST_API_KEY */\n  restAPIKey: ?string;\n  /* Read-only key, which has the same capabilities as MasterKey without writes */\n  readOnlyMasterKey: ?string;\n  /* Key sent with outgoing webhook calls */\n  webhookKey: ?string;\n  /* Key for your files */\n  fileKey: ?string;\n  /* Enable (or disable) the addition of a unique hash to the file names\n  :ENV: PARSE_SERVER_PRESERVE_FILE_NAME\n  :DEFAULT: false */\n  preserveFileName: ?boolean;\n  /* Personally identifiable information fields in the user table the should be removed for non-authorized users. Deprecated @see protectedFields */\n  userSensitiveFields: ?(string[]);\n  /* Protected fields that should be treated with extra security when fetching details.\n  :DEFAULT: {\"_User\": {\"*\": [\"email\"]}} */\n  protectedFields: ?ProtectedFields;\n  /* Enable (or disable) anonymous users, defaults to true\n  :ENV: PARSE_SERVER_ENABLE_ANON_USERS\n  :DEFAULT: true */\n  enableAnonymousUsers: ?boolean;\n  /* Enable (or disable) client class creation, defaults to true\n  :ENV: PARSE_SERVER_ALLOW_CLIENT_CLASS_CREATION\n  :DEFAULT: true */\n  allowClientClassCreation: ?boolean;\n  /* Enable (or disable) custom objectId\n  :ENV: PARSE_SERVER_ALLOW_CUSTOM_OBJECT_ID\n  :DEFAULT: false */\n  allowCustomObjectId: ?boolean;\n  /* Configuration for your authentication providers, as stringified JSON. See http://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication\n  :ENV: PARSE_SERVER_AUTH_PROVIDERS */\n  auth: ?(AuthAdapter[]);\n  /* Max file size for uploads, defaults to 20mb\n  :DEFAULT: 20mb */\n  maxUploadSize: ?string;\n  /* Set to `true` to require users to verify their email address to complete the sign-up process.\n  <br><br>\n  Default is `false`.\n  :DEFAULT: false */\n  verifyUserEmails: ?boolean;\n  /* Set to `true` to prevent a user from logging in if the email has not yet been verified and email verification is required.\n  <br><br>\n  Default is `false`.\n  <br>\n  Requires option `verifyUserEmails: true`.\n  :DEFAULT: false */\n  preventLoginWithUnverifiedEmail: ?boolean;\n  /* Set the validity duration of the email verification token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.\n  <br><br>\n  For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).\n  <br><br>\n  Default is `undefined`.\n  <br>\n  Requires option `verifyUserEmails: true`.\n  */\n  emailVerifyTokenValidityDuration: ?number;\n  /* Set to `true` if a email verification token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.\n  <br><br>\n  Default is `false`.\n  <br>\n  Requires option `verifyUserEmails: true`.\n  :DEFAULT: false */\n  emailVerifyTokenReuseIfValid: ?boolean;\n  /* The account lockout policy for failed login attempts. */\n  accountLockout: ?AccountLockoutOptions;\n  /* The password policy for enforcing password related rules. */\n  passwordPolicy: ?PasswordPolicyOptions;\n  /* Adapter module for the cache */\n  cacheAdapter: ?Adapter<CacheAdapter>;\n  /* Adapter module for email sending */\n  emailAdapter: ?Adapter<MailAdapter>;\n  /* Public URL to your parse server with http:// or https://.\n  :ENV: PARSE_PUBLIC_SERVER_URL */\n  publicServerURL: ?string;\n  /* The options for pages such as password reset and email verification. Caution, this is an experimental feature that may not be appropriate for production.\n  :DEFAULT: {} */\n  pages: ?PagesOptions;\n  /* custom pages for password validation and reset\n  :DEFAULT: {} */\n  customPages: ?CustomPagesOptions;\n  /* parse-server's LiveQuery configuration object */\n  liveQuery: ?LiveQueryOptions;\n  /* Session duration, in seconds, defaults to 1 year\n  :DEFAULT: 31536000 */\n  sessionLength: ?number;\n  /* Default value for limit option on queries, defaults to `100`.\n  :DEFAULT: 100 */\n  defaultLimit: ?number;\n  /* Max value for limit option on queries, defaults to unlimited */\n  maxLimit: ?number;\n  /* Sets whether we should expire the inactive sessions, defaults to true. If false, all new sessions are created with no expiration date.\n  :DEFAULT: true */\n  expireInactiveSessions: ?boolean;\n  /* When a user changes their password, either through the reset password email or while logged in, all sessions are revoked if this is true. Set to false if you don't want to revoke sessions.\n  :DEFAULT: true */\n  revokeSessionOnPasswordReset: ?boolean;\n  /* Sets the TTL for the in memory cache (in ms), defaults to 5000 (5 seconds)\n  :DEFAULT: 5000 */\n  cacheTTL: ?number;\n  /* Sets the maximum size for the in memory cache, defaults to 10000\n  :DEFAULT: 10000 */\n  cacheMaxSize: ?number;\n  /* Set to `true` if Parse requests within the same Node.js environment as Parse Server should be routed to Parse Server directly instead of via the HTTP interface. Default is `false`.\n  <br><br>\n  If set to `false` then Parse requests within the same Node.js environment as Parse Server are executed as HTTP requests sent to Parse Server via the `serverURL`. For example, a `Parse.Query` in Cloud Code is calling Parse Server via a HTTP request. The server is essentially making a HTTP request to itself, unnecessarily using network resources such as network ports.\n  <br><br>\n  \u26a0\ufe0f In environments where multiple Parse Server instances run behind a load balancer and Parse requests within the current Node.js environment should be routed via the load balancer and distributed as HTTP requests among all instances via the `serverURL`, this should be set to `false`.\n  :DEFAULT: false */\n  directAccess: ?boolean;\n  /* Enables the default express error handler for all errors\n  :DEFAULT: false */\n  enableExpressErrorHandler: ?boolean;\n  /* Sets the number of characters in generated object id's, default 10\n  :DEFAULT: 10 */\n  objectIdSize: ?number;\n  /* The port to run the ParseServer, defaults to 1337.\n  :ENV: PORT\n  :DEFAULT: 1337 */\n  port: ?number;\n  /* The host to serve ParseServer on, defaults to 0.0.0.0\n  :DEFAULT: 0.0.0.0 */\n  host: ?string;\n  /* Mount path for the server, defaults to /parse\n  :DEFAULT: /parse */\n  mountPath: ?string;\n  /* Run with cluster, optionally set the number of processes default to os.cpus().length */\n  cluster: ?NumberOrBoolean;\n  /* middleware for express server, can be string or function */\n  middleware: ?((() => void) | string);\n  /* The trust proxy settings. It is important to understand the exact setup of the reverse proxy, since this setting will trust values provided in the Parse Server API request. See the <a href=\"https://expressjs.com/en/guide/behind-proxies.html\">express trust proxy settings</a> documentation. Defaults to `false`.\n  :DEFAULT: false */\n  trustProxy: ?any;\n  /* Starts the liveQuery server */\n  startLiveQueryServer: ?boolean;\n  /* Live query server configuration options (will start the liveQuery server) */\n  liveQueryServerOptions: ?LiveQueryServerOptions;\n  /* Options for request idempotency to deduplicate identical requests that may be caused by network issues. Caution, this is an experimental feature that may not be appropriate for production.\n  :ENV: PARSE_SERVER_EXPERIMENTAL_IDEMPOTENCY_OPTIONS\n  :DEFAULT: false */\n  idempotencyOptions: ?IdempotencyOptions;\n  /* Options for file uploads\n  :ENV: PARSE_SERVER_FILE_UPLOAD_OPTIONS\n  :DEFAULT: {} */\n  fileUpload: ?FileUploadOptions;\n  /* Full path to your GraphQL custom schema.graphql file */\n  graphQLSchema: ?string;\n  /* Mounts the GraphQL endpoint\n  :ENV: PARSE_SERVER_MOUNT_GRAPHQL\n  :DEFAULT: false */\n  mountGraphQL: ?boolean;\n  /* Mount path for the GraphQL endpoint, defaults to /graphql\n  :ENV: PARSE_SERVER_GRAPHQL_PATH\n  :DEFAULT: /graphql */\n  graphQLPath: ?string;\n  /* Mounts the GraphQL Playground - never use this option in production\n  :ENV: PARSE_SERVER_MOUNT_PLAYGROUND\n  :DEFAULT: false */\n  mountPlayground: ?boolean;\n  /* Mount path for the GraphQL Playground, defaults to /playground\n  :ENV: PARSE_SERVER_PLAYGROUND_PATH\n  :DEFAULT: /playground */\n  playgroundPath: ?string;\n  /* Callback when server has started */\n  serverStartComplete: ?(error: ?Error) => void;\n  /* Defined schema\n  :ENV: PARSE_SERVER_SCHEMA\n  */\n  schema: ?SchemaOptions;\n  /* Callback when server has closed */\n  serverCloseComplete: ?() => void;\n  /* The security options to identify and report weak security settings.\n  :DEFAULT: {} */\n  security: ?SecurityOptions;\n  /* Set to true if new users should be created without public read and write access.\n  :DEFAULT: false */\n  enforcePrivateUsers: ?boolean;\n  /* An array of keys and values that are prohibited in database read and write requests to prevent potential security vulnerabilities. It is possible to specify only a key (`{\"key\":\"...\"}`), only a value (`{\"value\":\"...\"}`) or a key-value pair (`{\"key\":\"...\",\"value\":\"...\"}`). The specification can use the following types: `boolean`, `numeric` or `string`, where `string` will be interpreted as a regex notation. Request data is deep-scanned for matching definitions to detect also any nested occurrences. Defaults are patterns that are likely to be used in malicious requests. Setting this option will override the default patterns.\n  :DEFAULT: [{\"key\":\"_bsontype\",\"value\":\"Code\"},{\"key\":\"constructor\"},{\"key\":\"__proto__\"}] */\n  requestKeywordDenylist: ?(RequestKeywordDenylist[]);\n}\n\nexport interface SecurityOptions {\n  /* Is true if Parse Server should check for weak security settings.\n  :DEFAULT: false */\n  enableCheck: ?boolean;\n  /* Is true if the security check report should be written to logs. This should only be enabled temporarily to not expose weak security settings in logs.\n  :DEFAULT: false */\n  enableCheckLog: ?boolean;\n  /* The security check groups to run. This allows to add custom security checks or override existing ones. Default are the groups defined in `CheckGroups.js`. */\n  checkGroups: ?(CheckGroup[]);\n}\n\nexport interface PagesOptions {\n  /* Is true if the pages router should be enabled; this is required for any of the pages options to take effect. Caution, this is an experimental feature that may not be appropriate for production.\n  :DEFAULT: false */\n  enableRouter: ?boolean;\n  /* Is true if pages should be localized; this has no effect on custom page redirects.\n  :DEFAULT: false */\n  enableLocalization: ?boolean;\n  /* The path to the JSON file for localization; the translations will be used to fill template placeholders according to the locale. */\n  localizationJsonPath: ?string;\n  /* The fallback locale for localization if no matching translation is provided for the given locale. This is only relevant when providing translation resources via JSON file.\n  :DEFAULT: en */\n  localizationFallbackLocale: ?string;\n  /* The placeholder keys and values which will be filled in pages; this can be a simple object or a callback function.\n  :DEFAULT: {} */\n  placeholders: ?Object;\n  /* Is true if responses should always be redirects and never content, false if the response type should depend on the request type (GET request -> content response; POST request -> redirect response).\n  :DEFAULT: false */\n  forceRedirect: ?boolean;\n  /* The path to the pages directory; this also defines where the static endpoint '/apps' points to. Default is the './public/' directory.\n  :DEFAULT: ./public */\n  pagesPath: ?string;\n  /* The API endpoint for the pages. Default is 'apps'.\n  :DEFAULT: apps */\n  pagesEndpoint: ?string;\n  /* The URLs to the custom pages.\n  :DEFAULT: {} */\n  customUrls: ?PagesCustomUrlsOptions;\n  /* The custom routes.\n  :DEFAULT: [] */\n  customRoutes: ?(PagesRoute[]);\n}\n\nexport interface PagesRoute {\n  /* The route path. */\n  path: string;\n  /* The route method, e.g. 'GET' or 'POST'. */\n  method: string;\n  /* The route handler that is an async function. */\n  handler: () => void;\n}\n\nexport interface PagesCustomUrlsOptions {\n  /* The URL to the custom page for password reset. */\n  passwordReset: ?string;\n  /* The URL to the custom page for password reset -> link invalid. */\n  passwordResetLinkInvalid: ?string;\n  /* The URL to the custom page for password reset -> success. */\n  passwordResetSuccess: ?string;\n  /* The URL to the custom page for email verification -> success. */\n  emailVerificationSuccess: ?string;\n  /* The URL to the custom page for email verification -> link send fail. */\n  emailVerificationSendFail: ?string;\n  /* The URL to the custom page for email verification -> resend link -> success. */\n  emailVerificationSendSuccess: ?string;\n  /* The URL to the custom page for email verification -> link invalid. */\n  emailVerificationLinkInvalid: ?string;\n  /* The URL to the custom page for email verification -> link expired. */\n  emailVerificationLinkExpired: ?string;\n}\n\nexport interface CustomPagesOptions {\n  /* invalid link page path */\n  invalidLink: ?string;\n  /* verification link send fail page path */\n  linkSendFail: ?string;\n  /* choose password page path */\n  choosePassword: ?string;\n  /* verification link send success page path */\n  linkSendSuccess: ?string;\n  /* verify email success page path */\n  verifyEmailSuccess: ?string;\n  /* password reset success page path */\n  passwordResetSuccess: ?string;\n  /* invalid verification link page path */\n  invalidVerificationLink: ?string;\n  /* expired verification link page path */\n  expiredVerificationLink: ?string;\n  /* invalid password reset link page path */\n  invalidPasswordResetLink: ?string;\n  /* for masking user-facing pages */\n  parseFrameURL: ?string;\n}\n\nexport interface LiveQueryOptions {\n  /* parse-server's LiveQuery classNames\n  :ENV: PARSE_SERVER_LIVEQUERY_CLASSNAMES */\n  classNames: ?(string[]);\n  /* parse-server's LiveQuery redisOptions */\n  redisOptions: ?any;\n  /* parse-server's LiveQuery redisURL */\n  redisURL: ?string;\n  /* LiveQuery pubsub adapter */\n  pubSubAdapter: ?Adapter<PubSubAdapter>;\n  /* Adapter module for the WebSocketServer */\n  wssAdapter: ?Adapter<WSSAdapter>;\n}\n\nexport interface LiveQueryServerOptions {\n  /* This string should match the appId in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same appId.*/\n  appId: ?string;\n  /* This string should match the masterKey in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same masterKey.*/\n  masterKey: ?string;\n  /* This string should match the serverURL in use by your Parse Server. If you deploy the LiveQuery server alongside Parse Server, the LiveQuery server will try to use the same serverURL.*/\n  serverURL: ?string;\n  /* A JSON object that serves as a whitelist of keys. It is used for validating clients when they try to connect to the LiveQuery server. Check the following Security section and our protocol specification for details.*/\n  keyPairs: ?any;\n  /* Number of milliseconds between ping/pong frames. The WebSocket server sends ping/pong frames to the clients to keep the WebSocket alive. This value defines the interval of the ping/pong frame from the server to clients, defaults to 10 * 1000 ms (10 s).*/\n  websocketTimeout: ?number;\n  /* Number in milliseconds. When clients provide the sessionToken to the LiveQuery server, the LiveQuery server will try to fetch its ParseUser's objectId from parse server and store it in the cache. The value defines the duration of the cache. Check the following Security section and our protocol specification for details, defaults to 5 * 1000 ms (5 seconds).*/\n  cacheTimeout: ?number;\n  /* This string defines the log level of the LiveQuery server. We support VERBOSE, INFO, ERROR, NONE, defaults to INFO.*/\n  logLevel: ?string;\n  /* The port to run the LiveQuery server, defaults to 1337.\n  :DEFAULT: 1337 */\n  port: ?number;\n  /* parse-server's LiveQuery redisOptions */\n  redisOptions: ?any;\n  /* parse-server's LiveQuery redisURL */\n  redisURL: ?string;\n  /* LiveQuery pubsub adapter */\n  pubSubAdapter: ?Adapter<PubSubAdapter>;\n  /* Adapter module for the WebSocketServer */\n  wssAdapter: ?Adapter<WSSAdapter>;\n}\n\nexport interface IdempotencyOptions {\n  /* An array of paths for which the feature should be enabled. The mount path must not be included, for example instead of `/parse/functions/myFunction` specifiy `functions/myFunction`. The entries are interpreted as regular expression, for example `functions/.*` matches all functions, `jobs/.*` matches all jobs, `classes/.*` matches all classes, `.*` matches all paths.\n  :DEFAULT: [] */\n  paths: ?(string[]);\n  /* The duration in seconds after which a request record is discarded from the database, defaults to 300s.\n  :DEFAULT: 300 */\n  ttl: ?number;\n}\n\nexport interface AccountLockoutOptions {\n  /* Set the duration in minutes that a locked-out account remains locked out before automatically becoming unlocked.\n  <br><br>\n  Valid values are greater than `0` and less than `100000`. */\n  duration: ?number;\n  /* Set the number of failed sign-in attempts that will cause a user account to be locked. If the account is locked. The account will unlock after the duration set in the `duration` option has passed and no further login attempts have been made.\n  <br><br>\n  Valid values are greater than `0` and less than `1000`. */\n  threshold: ?number;\n  /* Set to `true`  if the account should be unlocked after a successful password reset.\n  <br><br>\n  Default is `false`.\n  <br>\n  Requires options `duration` and `threshold` to be set.\n  :DEFAULT: false */\n  unlockOnPasswordReset: ?boolean;\n}\n\nexport interface PasswordPolicyOptions {\n  /* Set the regular expression validation pattern a password must match to be accepted.\n  <br><br>\n  If used in combination with `validatorCallback`, the password must pass both to be accepted. */\n  validatorPattern: ?string;\n  /*   */\n  /* Set a callback function to validate a password to be accepted.\n  <br><br>\n  If used in combination with `validatorPattern`, the password must pass both to be accepted. */\n  validatorCallback: ?() => void;\n  /* Set the error message to be sent.\n  <br><br>\n  Default is `Password does not meet the Password Policy requirements.` */\n  validationError: ?string;\n  /* Set to `true` to disallow the username as part of the password.\n  <br><br>\n  Default is `false`.\n  :DEFAULT: false */\n  doNotAllowUsername: ?boolean;\n  /* Set the number of days after which a password expires. Login attempts fail if the user does not reset the password before expiration. */\n  maxPasswordAge: ?number;\n  /* Set the number of previous password that will not be allowed to be set as new password. If the option is not set or set to `0`, no previous passwords will be considered.\n  <br><br>\n  Valid values are >= `0` and <= `20`.\n  <br>\n  Default is `0`.\n  */\n  maxPasswordHistory: ?number;\n  /* Set the validity duration of the password reset token in seconds after which the token expires. The token is used in the link that is set in the email. After the token expires, the link becomes invalid and a new link has to be sent. If the option is not set or set to `undefined`, then the token never expires.\n  <br><br>\n  For example, to expire the token after 2 hours, set a value of 7200 seconds (= 60 seconds * 60 minutes * 2 hours).\n  <br><br>\n  Default is `undefined`.\n  */\n  resetTokenValidityDuration: ?number;\n  /* Set to `true` if a password reset token should be reused in case another token is requested but there is a token that is still valid, i.e. has not expired. This avoids the often observed issue that a user requests multiple emails and does not know which link contains a valid token because each newly generated token would invalidate the previous token.\n  <br><br>\n  Default is `false`.\n  :DEFAULT: false */\n  resetTokenReuseIfValid: ?boolean;\n}\n\nexport interface FileUploadOptions {\n  /*  Is true if file upload should be allowed for anonymous users.\n  :DEFAULT: false */\n  enableForAnonymousUser: ?boolean;\n  /* Is true if file upload should be allowed for authenticated users.\n  :DEFAULT: true */\n  enableForAuthenticatedUser: ?boolean;\n  /* Is true if file upload should be allowed for anyone, regardless of user authentication.\n  :DEFAULT: false */\n  enableForPublic: ?boolean;\n}\n\nexport interface DatabaseOptions {\n  /* Enables database real-time hooks to update single schema cache. Set to `true` if using multiple Parse Servers instances connected to the same database. Failing to do so will cause a schema change to not propagate to all instances and re-syncing will only happen when the instances restart. To use this feature with MongoDB, a replica set cluster with [change stream](https://docs.mongodb.com/manual/changeStreams/#availability) support is required.\n  :DEFAULT: false */\n  enableSchemaHooks: ?boolean;\n}\n\nexport interface AuthAdapter {\n  /* Is `true` if the auth adapter is enabled, `false` otherwise.\n  :DEFAULT: true\n  :ENV:\n  */\n  enabled: ?boolean;\n}\n", "// ParseServer - open-source compatible API Server for Parse apps\n\nvar batch = require('./batch'),\n  bodyParser = require('body-parser'),\n  express = require('express'),\n  middlewares = require('./middlewares'),\n  Parse = require('parse/node').Parse,\n  { parse } = require('graphql'),\n  path = require('path'),\n  fs = require('fs');\n\nimport { ParseServerOptions, LiveQueryServerOptions } from './Options';\nimport defaults from './defaults';\nimport * as logging from './logger';\nimport Config from './Config';\nimport PromiseRouter from './PromiseRouter';\nimport requiredParameter from './requiredParameter';\nimport { AnalyticsRouter } from './Routers/AnalyticsRouter';\nimport { ClassesRouter } from './Routers/ClassesRouter';\nimport { FeaturesRouter } from './Routers/FeaturesRouter';\nimport { FilesRouter } from './Routers/FilesRouter';\nimport { FunctionsRouter } from './Routers/FunctionsRouter';\nimport { GlobalConfigRouter } from './Routers/GlobalConfigRouter';\nimport { GraphQLRouter } from './Routers/GraphQLRouter';\nimport { HooksRouter } from './Routers/HooksRouter';\nimport { IAPValidationRouter } from './Routers/IAPValidationRouter';\nimport { InstallationsRouter } from './Routers/InstallationsRouter';\nimport { LogsRouter } from './Routers/LogsRouter';\nimport { ParseLiveQueryServer } from './LiveQuery/ParseLiveQueryServer';\nimport { PagesRouter } from './Routers/PagesRouter';\nimport { PublicAPIRouter } from './Routers/PublicAPIRouter';\nimport { PushRouter } from './Routers/PushRouter';\nimport { CloudCodeRouter } from './Routers/CloudCodeRouter';\nimport { RolesRouter } from './Routers/RolesRouter';\nimport { SchemasRouter } from './Routers/SchemasRouter';\nimport { SessionsRouter } from './Routers/SessionsRouter';\nimport { UsersRouter } from './Routers/UsersRouter';\nimport { PurgeRouter } from './Routers/PurgeRouter';\nimport { AudiencesRouter } from './Routers/AudiencesRouter';\nimport { AggregateRouter } from './Routers/AggregateRouter';\nimport { ParseServerRESTController } from './ParseServerRESTController';\nimport * as controllers from './Controllers';\nimport { ParseGraphQLServer } from './GraphQL/ParseGraphQLServer';\nimport { SecurityRouter } from './Routers/SecurityRouter';\nimport CheckRunner from './Security/CheckRunner';\nimport Deprecator from './Deprecator/Deprecator';\nimport { DefinedSchemas } from './SchemaMigrations/DefinedSchemas';\n\n// Mutate the Parse object to add the Cloud Code handlers\naddParseCloud();\n\n// ParseServer works like a constructor of an express app.\n// https://parseplatform.org/parse-server/api/master/ParseServerOptions.html\nclass ParseServer {\n  /**\n   * @constructor\n   * @param {ParseServerOptions} options the parse server initialization options\n   */\n  constructor(options: ParseServerOptions) {\n    // Scan for deprecated Parse Server options\n    Deprecator.scanParseServerOptions(options);\n    // Set option defaults\n    injectDefaults(options);\n    const {\n      appId = requiredParameter('You must provide an appId!'),\n      masterKey = requiredParameter('You must provide a masterKey!'),\n      cloud,\n      security,\n      javascriptKey,\n      serverURL = requiredParameter('You must provide a serverURL!'),\n      serverStartComplete,\n      schema,\n    } = options;\n    // Initialize the node client SDK automatically\n    Parse.initialize(appId, javascriptKey || 'unused', masterKey);\n    Parse.serverURL = serverURL;\n\n    const allControllers = controllers.getControllers(options);\n\n    const { loggerController, databaseController, hooksController } = allControllers;\n    this.config = Config.put(Object.assign({}, options, allControllers));\n\n    logging.setLogger(loggerController);\n\n    // Note: Tests will start to fail if any validation happens after this is called.\n    databaseController\n      .performInitialization()\n      .then(() => hooksController.load())\n      .then(async () => {\n        if (schema) {\n          await new DefinedSchemas(schema, this.config).execute();\n        }\n        if (serverStartComplete) {\n          serverStartComplete();\n        }\n      })\n      .catch(error => {\n        if (serverStartComplete) {\n          serverStartComplete(error);\n        } else {\n          console.error(error);\n          process.exit(1);\n        }\n      });\n\n    if (cloud) {\n      addParseCloud();\n      if (typeof cloud === 'function') {\n        cloud(Parse);\n      } else if (typeof cloud === 'string') {\n        require(path.resolve(process.cwd(), cloud));\n      } else {\n        throw \"argument 'cloud' must either be a string or a function\";\n      }\n    }\n\n    if (security && security.enableCheck && security.enableCheckLog) {\n      new CheckRunner(options.security).run();\n    }\n  }\n\n  get app() {\n    if (!this._app) {\n      this._app = ParseServer.app(this.config);\n    }\n    return this._app;\n  }\n\n  handleShutdown() {\n    const promises = [];\n    const { adapter: databaseAdapter } = this.config.databaseController;\n    if (databaseAdapter && typeof databaseAdapter.handleShutdown === 'function') {\n      promises.push(databaseAdapter.handleShutdown());\n    }\n    const { adapter: fileAdapter } = this.config.filesController;\n    if (fileAdapter && typeof fileAdapter.handleShutdown === 'function') {\n      promises.push(fileAdapter.handleShutdown());\n    }\n    const { adapter: cacheAdapter } = this.config.cacheController;\n    if (cacheAdapter && typeof cacheAdapter.handleShutdown === 'function') {\n      promises.push(cacheAdapter.handleShutdown());\n    }\n    return (promises.length > 0 ? Promise.all(promises) : Promise.resolve()).then(() => {\n      if (this.config.serverCloseComplete) {\n        this.config.serverCloseComplete();\n      }\n    });\n  }\n\n  /**\n   * @static\n   * Create an express app for the parse server\n   * @param {Object} options let you specify the maxUploadSize when creating the express app  */\n  static app(options) {\n    const { maxUploadSize = '20mb', appId, directAccess, pages } = options;\n    // This app serves the Parse API directly.\n    // It's the equivalent of https://api.parse.com/1 in the hosted Parse API.\n    var api = express();\n    //api.use(\"/apps\", express.static(__dirname + \"/public\"));\n    api.use(middlewares.allowCrossDomain(appId));\n    // File handling needs to be before default middlewares are applied\n    api.use(\n      '/',\n      new FilesRouter().expressRouter({\n        maxUploadSize: maxUploadSize,\n      })\n    );\n\n    api.use('/health', function (req, res) {\n      res.json({\n        status: 'ok',\n      });\n    });\n\n    api.use(\n      '/',\n      bodyParser.urlencoded({ extended: false }),\n      pages.enableRouter\n        ? new PagesRouter(pages).expressRouter()\n        : new PublicAPIRouter().expressRouter()\n    );\n\n    api.use(bodyParser.json({ type: '*/*', limit: maxUploadSize }));\n    api.use(middlewares.allowMethodOverride);\n    api.use(middlewares.handleParseHeaders);\n\n    const appRouter = ParseServer.promiseRouter({ appId });\n    api.use(appRouter.expressRouter());\n\n    api.use(middlewares.handleParseErrors);\n\n    // run the following when not testing\n    if (!process.env.TESTING) {\n      //This causes tests to spew some useless warnings, so disable in test\n      /* istanbul ignore next */\n      process.on('uncaughtException', err => {\n        if (err.code === 'EADDRINUSE') {\n          // user-friendly message for this common error\n          process.stderr.write(`Unable to listen on port ${err.port}. The port is already in use.`);\n          process.exit(0);\n        } else {\n          throw err;\n        }\n      });\n      // verify the server url after a 'mount' event is received\n      /* istanbul ignore next */\n      api.on('mount', function () {\n        ParseServer.verifyServerUrl();\n      });\n    }\n    if (process.env.PARSE_SERVER_ENABLE_EXPERIMENTAL_DIRECT_ACCESS === '1' || directAccess) {\n      Parse.CoreManager.setRESTController(ParseServerRESTController(appId, appRouter));\n    }\n    return api;\n  }\n\n  static promiseRouter({ appId }) {\n    const routers = [\n      new ClassesRouter(),\n      new UsersRouter(),\n      new SessionsRouter(),\n      new RolesRouter(),\n      new AnalyticsRouter(),\n      new InstallationsRouter(),\n      new FunctionsRouter(),\n      new SchemasRouter(),\n      new PushRouter(),\n      new LogsRouter(),\n      new IAPValidationRouter(),\n      new FeaturesRouter(),\n      new GlobalConfigRouter(),\n      new GraphQLRouter(),\n      new PurgeRouter(),\n      new HooksRouter(),\n      new CloudCodeRouter(),\n      new AudiencesRouter(),\n      new AggregateRouter(),\n      new SecurityRouter(),\n    ];\n\n    const routes = routers.reduce((memo, router) => {\n      return memo.concat(router.routes);\n    }, []);\n\n    const appRouter = new PromiseRouter(routes, appId);\n\n    batch.mountOnto(appRouter);\n    return appRouter;\n  }\n\n  /**\n   * starts the parse server's express app\n   * @param {ParseServerOptions} options to use to start the server\n   * @param {Function} callback called when the server has started\n   * @returns {ParseServer} the parse server instance\n   */\n  start(options: ParseServerOptions, callback: ?() => void) {\n    const app = express();\n    if (options.middleware) {\n      let middleware;\n      if (typeof options.middleware == 'string') {\n        middleware = require(path.resolve(process.cwd(), options.middleware));\n      } else {\n        middleware = options.middleware; // use as-is let express fail\n      }\n      app.use(middleware);\n    }\n\n    app.use(options.mountPath, this.app);\n\n    if (options.mountGraphQL === true || options.mountPlayground === true) {\n      let graphQLCustomTypeDefs = undefined;\n      if (typeof options.graphQLSchema === 'string') {\n        graphQLCustomTypeDefs = parse(fs.readFileSync(options.graphQLSchema, 'utf8'));\n      } else if (\n        typeof options.graphQLSchema === 'object' ||\n        typeof options.graphQLSchema === 'function'\n      ) {\n        graphQLCustomTypeDefs = options.graphQLSchema;\n      }\n\n      const parseGraphQLServer = new ParseGraphQLServer(this, {\n        graphQLPath: options.graphQLPath,\n        playgroundPath: options.playgroundPath,\n        graphQLCustomTypeDefs,\n      });\n\n      if (options.mountGraphQL) {\n        parseGraphQLServer.applyGraphQL(app);\n      }\n\n      if (options.mountPlayground) {\n        parseGraphQLServer.applyPlayground(app);\n      }\n    }\n\n    const server = app.listen(options.port, options.host, callback);\n    this.server = server;\n\n    if (options.startLiveQueryServer || options.liveQueryServerOptions) {\n      this.liveQueryServer = ParseServer.createLiveQueryServer(\n        server,\n        options.liveQueryServerOptions,\n        options\n      );\n    }\n    if (options.trustProxy) {\n      app.set('trust proxy', options.trustProxy);\n    }\n    /* istanbul ignore next */\n    if (!process.env.TESTING) {\n      configureListeners(this);\n    }\n    this.expressApp = app;\n    return this;\n  }\n\n  /**\n   * Creates a new ParseServer and starts it.\n   * @param {ParseServerOptions} options used to start the server\n   * @param {Function} callback called when the server has started\n   * @returns {ParseServer} the parse server instance\n   */\n  static start(options: ParseServerOptions, callback: ?() => void) {\n    const parseServer = new ParseServer(options);\n    return parseServer.start(options, callback);\n  }\n\n  /**\n   * Helper method to create a liveQuery server\n   * @static\n   * @param {Server} httpServer an optional http server to pass\n   * @param {LiveQueryServerOptions} config options for the liveQueryServer\n   * @param {ParseServerOptions} options options for the ParseServer\n   * @returns {ParseLiveQueryServer} the live query server instance\n   */\n  static createLiveQueryServer(\n    httpServer,\n    config: LiveQueryServerOptions,\n    options: ParseServerOptions\n  ) {\n    if (!httpServer || (config && config.port)) {\n      var app = express();\n      httpServer = require('http').createServer(app);\n      httpServer.listen(config.port);\n    }\n    return new ParseLiveQueryServer(httpServer, config, options);\n  }\n\n  static verifyServerUrl(callback) {\n    // perform a health check on the serverURL value\n    if (Parse.serverURL) {\n      const request = require('./request');\n      request({ url: Parse.serverURL.replace(/\\/$/, '') + '/health' })\n        .catch(response => response)\n        .then(response => {\n          const json = response.data || null;\n          if (response.status !== 200 || !json || (json && json.status !== 'ok')) {\n            /* eslint-disable no-console */\n            console.warn(\n              `\\nWARNING, Unable to connect to '${Parse.serverURL}'.` +\n                ` Cloud code and push notifications may be unavailable!\\n`\n            );\n            /* eslint-enable no-console */\n            if (callback) {\n              callback(false);\n            }\n          } else {\n            if (callback) {\n              callback(true);\n            }\n          }\n        });\n    }\n  }\n}\n\nfunction addParseCloud() {\n  const ParseCloud = require('./cloud-code/Parse.Cloud');\n  Object.defineProperty(Parse, 'Server', {\n    get() {\n      return Config.get(Parse.applicationId);\n    },\n    set(newVal) {\n      newVal.appId = Parse.applicationId;\n      Config.put(newVal);\n    },\n    configurable: true,\n  });\n  Object.assign(Parse.Cloud, ParseCloud);\n  global.Parse = Parse;\n}\n\nfunction injectDefaults(options: ParseServerOptions) {\n  Object.keys(defaults).forEach(key => {\n    if (!Object.prototype.hasOwnProperty.call(options, key)) {\n      options[key] = defaults[key];\n    }\n  });\n\n  if (!Object.prototype.hasOwnProperty.call(options, 'serverURL')) {\n    options.serverURL = `http://localhost:${options.port}${options.mountPath}`;\n  }\n\n  // Reserved Characters\n  if (options.appId) {\n    const regex = /[!#$%'()*+&/:;=?@[\\]{}^,|<>]/g;\n    if (options.appId.match(regex)) {\n      console.warn(\n        `\\nWARNING, appId that contains special characters can cause issues while using with urls.\\n`\n      );\n    }\n  }\n\n  // Backwards compatibility\n  if (options.userSensitiveFields) {\n    /* eslint-disable no-console */\n    !process.env.TESTING &&\n      console.warn(\n        `\\nDEPRECATED: userSensitiveFields has been replaced by protectedFields allowing the ability to protect fields in all classes with CLP. \\n`\n      );\n    /* eslint-enable no-console */\n\n    const userSensitiveFields = Array.from(\n      new Set([...(defaults.userSensitiveFields || []), ...(options.userSensitiveFields || [])])\n    );\n\n    // If the options.protectedFields is unset,\n    // it'll be assigned the default above.\n    // Here, protect against the case where protectedFields\n    // is set, but doesn't have _User.\n    if (!('_User' in options.protectedFields)) {\n      options.protectedFields = Object.assign({ _User: [] }, options.protectedFields);\n    }\n\n    options.protectedFields['_User']['*'] = Array.from(\n      new Set([...(options.protectedFields['_User']['*'] || []), ...userSensitiveFields])\n    );\n  }\n\n  // Merge protectedFields options with defaults.\n  Object.keys(defaults.protectedFields).forEach(c => {\n    const cur = options.protectedFields[c];\n    if (!cur) {\n      options.protectedFields[c] = defaults.protectedFields[c];\n    } else {\n      Object.keys(defaults.protectedFields[c]).forEach(r => {\n        const unq = new Set([\n          ...(options.protectedFields[c][r] || []),\n          ...defaults.protectedFields[c][r],\n        ]);\n        options.protectedFields[c][r] = Array.from(unq);\n      });\n    }\n  });\n\n  options.masterKeyIps = Array.from(\n    new Set(options.masterKeyIps.concat(defaults.masterKeyIps, options.masterKeyIps))\n  );\n}\n\n// Those can't be tested as it requires a subprocess\n/* istanbul ignore next */\nfunction configureListeners(parseServer) {\n  const server = parseServer.server;\n  const sockets = {};\n  /* Currently, express doesn't shut down immediately after receiving SIGINT/SIGTERM if it has client connections that haven't timed out. (This is a known issue with node - https://github.com/nodejs/node/issues/2642)\n    This function, along with `destroyAliveConnections()`, intend to fix this behavior such that parse server will close all open connections and initiate the shutdown process as soon as it receives a SIGINT/SIGTERM signal. */\n  server.on('connection', socket => {\n    const socketId = socket.remoteAddress + ':' + socket.remotePort;\n    sockets[socketId] = socket;\n    socket.on('close', () => {\n      delete sockets[socketId];\n    });\n  });\n\n  const destroyAliveConnections = function () {\n    for (const socketId in sockets) {\n      try {\n        sockets[socketId].destroy();\n      } catch (e) {\n        /* */\n      }\n    }\n  };\n\n  const handleShutdown = function () {\n    process.stdout.write('Termination signal received. Shutting down.');\n    destroyAliveConnections();\n    server.close();\n    parseServer.handleShutdown();\n  };\n  process.on('SIGTERM', handleShutdown);\n  process.on('SIGINT', handleShutdown);\n}\n\nexport default ParseServer;\n", "import AppCache from './cache';\nimport Parse from 'parse/node';\nimport auth from './Auth';\nimport Config from './Config';\nimport ClientSDK from './ClientSDK';\nimport defaultLogger from './logger';\nimport rest from './rest';\nimport MongoStorageAdapter from './Adapters/Storage/Mongo/MongoStorageAdapter';\nimport PostgresStorageAdapter from './Adapters/Storage/Postgres/PostgresStorageAdapter';\n\nexport const DEFAULT_ALLOWED_HEADERS =\n  'X-Parse-Master-Key, X-Parse-REST-API-Key, X-Parse-Javascript-Key, X-Parse-Application-Id, X-Parse-Client-Version, X-Parse-Session-Token, X-Requested-With, X-Parse-Revocable-Session, X-Parse-Request-Id, Content-Type, Pragma, Cache-Control';\n\nconst getMountForRequest = function (req) {\n  const mountPathLength = req.originalUrl.length - req.url.length;\n  const mountPath = req.originalUrl.slice(0, mountPathLength);\n  return req.protocol + '://' + req.get('host') + mountPath;\n};\n\n// Checks that the request is authorized for this app and checks user\n// auth too.\n// The bodyparser should run before this middleware.\n// Adds info to the request:\n// req.config - the Config for this app\n// req.auth - the Auth for this request\nexport function handleParseHeaders(req, res, next) {\n  var mount = getMountForRequest(req);\n\n  let context = {};\n  if (req.get('X-Parse-Cloud-Context') != null) {\n    try {\n      context = JSON.parse(req.get('X-Parse-Cloud-Context'));\n      if (Object.prototype.toString.call(context) !== '[object Object]') {\n        throw 'Context is not an object';\n      }\n    } catch (e) {\n      return malformedContext(req, res);\n    }\n  }\n  var info = {\n    appId: req.get('X-Parse-Application-Id'),\n    sessionToken: req.get('X-Parse-Session-Token'),\n    masterKey: req.get('X-Parse-Master-Key'),\n    installationId: req.get('X-Parse-Installation-Id'),\n    clientKey: req.get('X-Parse-Client-Key'),\n    javascriptKey: req.get('X-Parse-Javascript-Key'),\n    dotNetKey: req.get('X-Parse-Windows-Key'),\n    restAPIKey: req.get('X-Parse-REST-API-Key'),\n    clientVersion: req.get('X-Parse-Client-Version'),\n    context: context,\n  };\n\n  var basicAuth = httpAuth(req);\n\n  if (basicAuth) {\n    var basicAuthAppId = basicAuth.appId;\n    if (AppCache.get(basicAuthAppId)) {\n      info.appId = basicAuthAppId;\n      info.masterKey = basicAuth.masterKey || info.masterKey;\n      info.javascriptKey = basicAuth.javascriptKey || info.javascriptKey;\n    }\n  }\n\n  if (req.body) {\n    // Unity SDK sends a _noBody key which needs to be removed.\n    // Unclear at this point if action needs to be taken.\n    delete req.body._noBody;\n  }\n\n  var fileViaJSON = false;\n\n  if (!info.appId || !AppCache.get(info.appId)) {\n    // See if we can find the app id on the body.\n    if (req.body instanceof Buffer) {\n      // The only chance to find the app id is if this is a file\n      // upload that actually is a JSON body. So try to parse it.\n      // https://github.com/parse-community/parse-server/issues/6589\n      // It is also possible that the client is trying to upload a file but forgot\n      // to provide x-parse-app-id in header and parse a binary file will fail\n      try {\n        req.body = JSON.parse(req.body);\n      } catch (e) {\n        return invalidRequest(req, res);\n      }\n      fileViaJSON = true;\n    }\n\n    if (req.body) {\n      delete req.body._RevocableSession;\n    }\n\n    if (\n      req.body &&\n      req.body._ApplicationId &&\n      AppCache.get(req.body._ApplicationId) &&\n      (!info.masterKey || AppCache.get(req.body._ApplicationId).masterKey === info.masterKey)\n    ) {\n      info.appId = req.body._ApplicationId;\n      info.javascriptKey = req.body._JavaScriptKey || '';\n      delete req.body._ApplicationId;\n      delete req.body._JavaScriptKey;\n      // TODO: test that the REST API formats generated by the other\n      // SDKs are handled ok\n      if (req.body._ClientVersion) {\n        info.clientVersion = req.body._ClientVersion;\n        delete req.body._ClientVersion;\n      }\n      if (req.body._InstallationId) {\n        info.installationId = req.body._InstallationId;\n        delete req.body._InstallationId;\n      }\n      if (req.body._SessionToken) {\n        info.sessionToken = req.body._SessionToken;\n        delete req.body._SessionToken;\n      }\n      if (req.body._MasterKey) {\n        info.masterKey = req.body._MasterKey;\n        delete req.body._MasterKey;\n      }\n      if (req.body._context) {\n        if (req.body._context instanceof Object) {\n          info.context = req.body._context;\n        } else {\n          try {\n            info.context = JSON.parse(req.body._context);\n            if (Object.prototype.toString.call(info.context) !== '[object Object]') {\n              throw 'Context is not an object';\n            }\n          } catch (e) {\n            return malformedContext(req, res);\n          }\n        }\n        delete req.body._context;\n      }\n      if (req.body._ContentType) {\n        req.headers['content-type'] = req.body._ContentType;\n        delete req.body._ContentType;\n      }\n    } else {\n      return invalidRequest(req, res);\n    }\n  }\n\n  if (info.sessionToken && typeof info.sessionToken !== 'string') {\n    info.sessionToken = info.sessionToken.toString();\n  }\n\n  if (info.clientVersion) {\n    info.clientSDK = ClientSDK.fromString(info.clientVersion);\n  }\n\n  if (fileViaJSON) {\n    req.fileData = req.body.fileData;\n    // We need to repopulate req.body with a buffer\n    var base64 = req.body.base64;\n    req.body = Buffer.from(base64, 'base64');\n  }\n\n  const clientIp = getClientIp(req);\n\n  info.app = AppCache.get(info.appId);\n  req.config = Config.get(info.appId, mount);\n  req.config.headers = req.headers || {};\n  req.config.ip = clientIp;\n  req.info = info;\n\n  if (\n    info.masterKey &&\n    req.config.masterKeyIps &&\n    req.config.masterKeyIps.length !== 0 &&\n    req.config.masterKeyIps.indexOf(clientIp) === -1\n  ) {\n    return invalidRequest(req, res);\n  }\n\n  var isMaster = info.masterKey === req.config.masterKey;\n\n  if (isMaster) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: true,\n    });\n    next();\n    return;\n  }\n\n  var isReadOnlyMaster = info.masterKey === req.config.readOnlyMasterKey;\n  if (\n    typeof req.config.readOnlyMasterKey != 'undefined' &&\n    req.config.readOnlyMasterKey &&\n    isReadOnlyMaster\n  ) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: true,\n      isReadOnly: true,\n    });\n    next();\n    return;\n  }\n\n  // Client keys are not required in parse-server, but if any have been configured in the server, validate them\n  //  to preserve original behavior.\n  const keys = ['clientKey', 'javascriptKey', 'dotNetKey', 'restAPIKey'];\n  const oneKeyConfigured = keys.some(function (key) {\n    return req.config[key] !== undefined;\n  });\n  const oneKeyMatches = keys.some(function (key) {\n    return req.config[key] !== undefined && info[key] === req.config[key];\n  });\n\n  if (oneKeyConfigured && !oneKeyMatches) {\n    return invalidRequest(req, res);\n  }\n\n  if (req.url == '/login') {\n    delete info.sessionToken;\n  }\n\n  if (req.userFromJWT) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: false,\n      user: req.userFromJWT,\n    });\n    next();\n    return;\n  }\n\n  if (!info.sessionToken) {\n    req.auth = new auth.Auth({\n      config: req.config,\n      installationId: info.installationId,\n      isMaster: false,\n    });\n    next();\n    return;\n  }\n\n  return Promise.resolve()\n    .then(() => {\n      // handle the upgradeToRevocableSession path on it's own\n      if (\n        info.sessionToken &&\n        req.url === '/upgradeToRevocableSession' &&\n        info.sessionToken.indexOf('r:') != 0\n      ) {\n        return auth.getAuthForLegacySessionToken({\n          config: req.config,\n          installationId: info.installationId,\n          sessionToken: info.sessionToken,\n        });\n      } else {\n        return auth.getAuthForSessionToken({\n          config: req.config,\n          installationId: info.installationId,\n          sessionToken: info.sessionToken,\n        });\n      }\n    })\n    .then(auth => {\n      if (auth) {\n        req.auth = auth;\n        next();\n      }\n    })\n    .catch(error => {\n      if (error instanceof Parse.Error) {\n        next(error);\n        return;\n      } else {\n        // TODO: Determine the correct error scenario.\n        req.config.loggerController.error('error getting auth for sessionToken', error);\n        throw new Parse.Error(Parse.Error.UNKNOWN_ERROR, error);\n      }\n    });\n}\n\nfunction getClientIp(req) {\n  return req.ip;\n}\n\nfunction httpAuth(req) {\n  if (!(req.req || req).headers.authorization) return;\n\n  var header = (req.req || req).headers.authorization;\n  var appId, masterKey, javascriptKey;\n\n  // parse header\n  var authPrefix = 'basic ';\n\n  var match = header.toLowerCase().indexOf(authPrefix);\n\n  if (match == 0) {\n    var encodedAuth = header.substring(authPrefix.length, header.length);\n    var credentials = decodeBase64(encodedAuth).split(':');\n\n    if (credentials.length == 2) {\n      appId = credentials[0];\n      var key = credentials[1];\n\n      var jsKeyPrefix = 'javascript-key=';\n\n      var matchKey = key.indexOf(jsKeyPrefix);\n      if (matchKey == 0) {\n        javascriptKey = key.substring(jsKeyPrefix.length, key.length);\n      } else {\n        masterKey = key;\n      }\n    }\n  }\n\n  return { appId: appId, masterKey: masterKey, javascriptKey: javascriptKey };\n}\n\nfunction decodeBase64(str) {\n  return Buffer.from(str, 'base64').toString();\n}\n\nexport function allowCrossDomain(appId) {\n  return (req, res, next) => {\n    const config = Config.get(appId, getMountForRequest(req));\n    let allowHeaders = DEFAULT_ALLOWED_HEADERS;\n    if (config && config.allowHeaders) {\n      allowHeaders += `, ${config.allowHeaders.join(', ')}`;\n    }\n    const allowOrigin = (config && config.allowOrigin) || '*';\n    res.header('Access-Control-Allow-Origin', allowOrigin);\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');\n    res.header('Access-Control-Allow-Headers', allowHeaders);\n    res.header('Access-Control-Expose-Headers', 'X-Parse-Job-Status-Id, X-Parse-Push-Status-Id');\n    // intercept OPTIONS method\n    if ('OPTIONS' == req.method) {\n      res.sendStatus(200);\n    } else {\n      next();\n    }\n  };\n}\n\nexport function allowMethodOverride(req, res, next) {\n  if (req.method === 'POST' && req.body._method) {\n    req.originalMethod = req.method;\n    req.method = req.body._method;\n    delete req.body._method;\n  }\n  next();\n}\n\nexport function handleParseErrors(err, req, res, next) {\n  const log = (req.config && req.config.loggerController) || defaultLogger;\n  if (err instanceof Parse.Error) {\n    if (req.config && req.config.enableExpressErrorHandler) {\n      return next(err);\n    }\n    let httpStatus;\n    // TODO: fill out this mapping\n    switch (err.code) {\n      case Parse.Error.INTERNAL_SERVER_ERROR:\n        httpStatus = 500;\n        break;\n      case Parse.Error.OBJECT_NOT_FOUND:\n        httpStatus = 404;\n        break;\n      default:\n        httpStatus = 400;\n    }\n    res.status(httpStatus);\n    res.json({ code: err.code, error: err.message });\n    log.error('Parse error: ', err);\n  } else if (err.status && err.message) {\n    res.status(err.status);\n    res.json({ error: err.message });\n    if (!(process && process.env.TESTING)) {\n      next(err);\n    }\n  } else {\n    log.error('Uncaught internal server error.', err, err.stack);\n    res.status(500);\n    res.json({\n      code: Parse.Error.INTERNAL_SERVER_ERROR,\n      message: 'Internal server error.',\n    });\n    if (!(process && process.env.TESTING)) {\n      next(err);\n    }\n  }\n}\n\nexport function enforceMasterKeyAccess(req, res, next) {\n  if (!req.auth.isMaster) {\n    res.status(403);\n    res.end('{\"error\":\"unauthorized: master key is required\"}');\n    return;\n  }\n  next();\n}\n\nexport function promiseEnforceMasterKeyAccess(request) {\n  if (!request.auth.isMaster) {\n    const error = new Error();\n    error.status = 403;\n    error.message = 'unauthorized: master key is required';\n    throw error;\n  }\n  return Promise.resolve();\n}\n\n/**\n * Deduplicates a request to ensure idempotency. Duplicates are determined by the request ID\n * in the request header. If a request has no request ID, it is executed anyway.\n * @param {*} req The request to evaluate.\n * @returns Promise<{}>\n */\nexport function promiseEnsureIdempotency(req) {\n  // Enable feature only for MongoDB\n  if (\n    !(\n      req.config.database.adapter instanceof MongoStorageAdapter ||\n      req.config.database.adapter instanceof PostgresStorageAdapter\n    )\n  ) {\n    return Promise.resolve();\n  }\n  // Get parameters\n  const config = req.config;\n  const requestId = ((req || {}).headers || {})['x-parse-request-id'];\n  const { paths, ttl } = config.idempotencyOptions;\n  if (!requestId || !config.idempotencyOptions) {\n    return Promise.resolve();\n  }\n  // Request path may contain trailing slashes, depending on the original request, so remove\n  // leading and trailing slashes to make it easier to specify paths in the configuration\n  const reqPath = req.path.replace(/^\\/|\\/$/, '');\n  // Determine whether idempotency is enabled for current request path\n  let match = false;\n  for (const path of paths) {\n    // Assume one wants a path to always match from the beginning to prevent any mistakes\n    const regex = new RegExp(path.charAt(0) === '^' ? path : '^' + path);\n    if (reqPath.match(regex)) {\n      match = true;\n      break;\n    }\n  }\n  if (!match) {\n    return Promise.resolve();\n  }\n  // Try to store request\n  const expiryDate = new Date(new Date().setSeconds(new Date().getSeconds() + ttl));\n  return rest\n    .create(config, auth.master(config), '_Idempotency', {\n      reqId: requestId,\n      expire: Parse._encode(expiryDate),\n    })\n    .catch(e => {\n      if (e.code == Parse.Error.DUPLICATE_VALUE) {\n        throw new Parse.Error(Parse.Error.DUPLICATE_REQUEST, 'Duplicate request');\n      }\n      throw e;\n    });\n}\n\nfunction invalidRequest(req, res) {\n  res.status(403);\n  res.end('{\"error\":\"unauthorized\"}');\n}\n\nfunction malformedContext(req, res) {\n  res.status(400);\n  res.json({ code: Parse.Error.INVALID_JSON, error: 'Invalid object for context.' });\n}\n"], "filenames": ["spec/Middlewares.spec.js", "src/Options/Definitions.js", "src/Options/docs.js", "src/Options/index.js", "src/ParseServer.js", "src/middlewares.js"], "buggy_code_start_loc": [161, 479, 90, 240, 306, 283], "buggy_code_end_loc": [292, 479, 90, 240, 306, 299], "fixing_code_start_loc": [160, 480, 91, 241, 307, 283], "fixing_code_end_loc": [177, 487, 92, 244, 310, 284], "type": "CWE-290", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Parse Server uses the request header `x-forwarded-for` to determine the client IP address. If Parse Server doesn't run behind a proxy server, then a client can set this header and Parse Server will trust the value of the header. The incorrect client IP address will be used by various features in Parse Server. This allows to circumvent the security mechanism of the Parse Server option `masterKeyIps` by setting an allowed IP address as the `x-forwarded-for` header value. This issue has been patched in version 5.4.1. The mechanism to determine the client IP address has been rewritten. The correct IP address determination now requires to set the Parse Server option `trustProxy`.", "other": {"cve": {"id": "CVE-2023-22474", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-03T20:15:10.197", "lastModified": "2023-02-10T17:32:28.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Parse Server uses the request header `x-forwarded-for` to determine the client IP address. If Parse Server doesn't run behind a proxy server, then a client can set this header and Parse Server will trust the value of the header. The incorrect client IP address will be used by various features in Parse Server. This allows to circumvent the security mechanism of the Parse Server option `masterKeyIps` by setting an allowed IP address as the `x-forwarded-for` header value. This issue has been patched in version 5.4.1. The mechanism to determine the client IP address has been rewritten. The correct IP address determination now requires to set the Parse Server option `trustProxy`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-290"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.4.1", "matchCriteriaId": "89DA5320-8060-4E94-8876-0C1A83C100DF"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/e016d813e083ce6828f9abce245d15b681a224d8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-vm5r-c87r-pf6x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/e016d813e083ce6828f9abce245d15b681a224d8"}}