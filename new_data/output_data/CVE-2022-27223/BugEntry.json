{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * Xilinx USB peripheral controller driver\n *\n * Copyright (C) 2004 by Thomas Rathbone\n * Copyright (C) 2005 by HP Labs\n * Copyright (C) 2005 by David Brownell\n * Copyright (C) 2010 - 2014 Xilinx, Inc.\n *\n * Some parts of this driver code is based on the driver for at91-series\n * USB peripheral controller (at91_udc.c).\n */\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n#include <linux/prefetch.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n/* Register offsets for the USB device.*/\n#define XUSB_EP0_CONFIG_OFFSET\t\t0x0000  /* EP0 Config Reg Offset */\n#define XUSB_SETUP_PKT_ADDR_OFFSET\t0x0080  /* Setup Packet Address */\n#define XUSB_ADDRESS_OFFSET\t\t0x0100  /* Address Register */\n#define XUSB_CONTROL_OFFSET\t\t0x0104  /* Control Register */\n#define XUSB_STATUS_OFFSET\t\t0x0108  /* Status Register */\n#define XUSB_FRAMENUM_OFFSET\t\t0x010C\t/* Frame Number Register */\n#define XUSB_IER_OFFSET\t\t\t0x0110\t/* Interrupt Enable Register */\n#define XUSB_BUFFREADY_OFFSET\t\t0x0114\t/* Buffer Ready Register */\n#define XUSB_TESTMODE_OFFSET\t\t0x0118\t/* Test Mode Register */\n#define XUSB_DMA_RESET_OFFSET\t\t0x0200  /* DMA Soft Reset Register */\n#define XUSB_DMA_CONTROL_OFFSET\t\t0x0204\t/* DMA Control Register */\n#define XUSB_DMA_DSAR_ADDR_OFFSET\t0x0208\t/* DMA source Address Reg */\n#define XUSB_DMA_DDAR_ADDR_OFFSET\t0x020C\t/* DMA destination Addr Reg */\n#define XUSB_DMA_LENGTH_OFFSET\t\t0x0210\t/* DMA Length Register */\n#define XUSB_DMA_STATUS_OFFSET\t\t0x0214\t/* DMA Status Register */\n\n/* Endpoint Configuration Space offsets */\n#define XUSB_EP_CFGSTATUS_OFFSET\t0x00\t/* Endpoint Config Status  */\n#define XUSB_EP_BUF0COUNT_OFFSET\t0x08\t/* Buffer 0 Count */\n#define XUSB_EP_BUF1COUNT_OFFSET\t0x0C\t/* Buffer 1 Count */\n\n#define XUSB_CONTROL_USB_READY_MASK\t0x80000000 /* USB ready Mask */\n#define XUSB_CONTROL_USB_RMTWAKE_MASK\t0x40000000 /* Remote wake up mask */\n\n/* Interrupt register related masks.*/\n#define XUSB_STATUS_GLOBAL_INTR_MASK\t0x80000000 /* Global Intr Enable */\n#define XUSB_STATUS_DMADONE_MASK\t0x04000000 /* DMA done Mask */\n#define XUSB_STATUS_DMAERR_MASK\t\t0x02000000 /* DMA Error Mask */\n#define XUSB_STATUS_DMABUSY_MASK\t0x80000000 /* DMA Error Mask */\n#define XUSB_STATUS_RESUME_MASK\t\t0x01000000 /* USB Resume Mask */\n#define XUSB_STATUS_RESET_MASK\t\t0x00800000 /* USB Reset Mask */\n#define XUSB_STATUS_SUSPEND_MASK\t0x00400000 /* USB Suspend Mask */\n#define XUSB_STATUS_DISCONNECT_MASK\t0x00200000 /* USB Disconnect Mask */\n#define XUSB_STATUS_FIFO_BUFF_RDY_MASK\t0x00100000 /* FIFO Buff Ready Mask */\n#define XUSB_STATUS_FIFO_BUFF_FREE_MASK\t0x00080000 /* FIFO Buff Free Mask */\n#define XUSB_STATUS_SETUP_PACKET_MASK\t0x00040000 /* Setup packet received */\n#define XUSB_STATUS_EP1_BUFF2_COMP_MASK\t0x00000200 /* EP 1 Buff 2 Processed */\n#define XUSB_STATUS_EP1_BUFF1_COMP_MASK\t0x00000002 /* EP 1 Buff 1 Processed */\n#define XUSB_STATUS_EP0_BUFF2_COMP_MASK\t0x00000100 /* EP 0 Buff 2 Processed */\n#define XUSB_STATUS_EP0_BUFF1_COMP_MASK\t0x00000001 /* EP 0 Buff 1 Processed */\n#define XUSB_STATUS_HIGH_SPEED_MASK\t0x00010000 /* USB Speed Mask */\n/* Suspend,Reset,Suspend and Disconnect Mask */\n#define XUSB_STATUS_INTR_EVENT_MASK\t0x01E00000\n/* Buffers  completion Mask */\n#define XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK\t0x0000FEFF\n/* Mask for buffer 0 and buffer 1 completion for all Endpoints */\n#define XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK\t0x00000101\n#define XUSB_STATUS_EP_BUFF2_SHIFT\t8\t   /* EP buffer offset */\n\n/* Endpoint Configuration Status Register */\n#define XUSB_EP_CFG_VALID_MASK\t\t0x80000000 /* Endpoint Valid bit */\n#define XUSB_EP_CFG_STALL_MASK\t\t0x40000000 /* Endpoint Stall bit */\n#define XUSB_EP_CFG_DATA_TOGGLE_MASK\t0x08000000 /* Endpoint Data toggle */\n\n/* USB device specific global configuration constants.*/\n#define XUSB_MAX_ENDPOINTS\t\t8\t/* Maximum End Points */\n#define XUSB_EP_NUMBER_ZERO\t\t0\t/* End point Zero */\n/* DPRAM is the source address for DMA transfer */\n#define XUSB_DMA_READ_FROM_DPRAM\t0x80000000\n#define XUSB_DMA_DMASR_BUSY\t\t0x80000000 /* DMA busy */\n#define XUSB_DMA_DMASR_ERROR\t\t0x40000000 /* DMA Error */\n/*\n * When this bit is set, the DMA buffer ready bit is set by hardware upon\n * DMA transfer completion.\n */\n#define XUSB_DMA_BRR_CTRL\t\t0x40000000 /* DMA bufready ctrl bit */\n/* Phase States */\n#define SETUP_PHASE\t\t\t0x0000\t/* Setup Phase */\n#define DATA_PHASE\t\t\t0x0001  /* Data Phase */\n#define STATUS_PHASE\t\t\t0x0002  /* Status Phase */\n\n#define EP0_MAX_PACKET\t\t64 /* Endpoint 0 maximum packet length */\n#define STATUSBUFF_SIZE\t\t2  /* Buffer size for GET_STATUS command */\n#define EPNAME_SIZE\t\t4  /* Buffer size for endpoint name */\n\n/* container_of helper macros */\n#define to_udc(g)\t container_of((g), struct xusb_udc, gadget)\n#define to_xusb_ep(ep)\t container_of((ep), struct xusb_ep, ep_usb)\n#define to_xusb_req(req) container_of((req), struct xusb_req, usb_req)\n\n/**\n * struct xusb_req - Xilinx USB device request structure\n * @usb_req: Linux usb request structure\n * @queue: usb device request queue\n * @ep: pointer to xusb_endpoint structure\n */\nstruct xusb_req {\n\tstruct usb_request usb_req;\n\tstruct list_head queue;\n\tstruct xusb_ep *ep;\n};\n\n/**\n * struct xusb_ep - USB end point structure.\n * @ep_usb: usb endpoint instance\n * @queue: endpoint message queue\n * @udc: xilinx usb peripheral driver instance pointer\n * @desc: pointer to the usb endpoint descriptor\n * @rambase: the endpoint buffer address\n * @offset: the endpoint register offset value\n * @name: name of the endpoint\n * @epnumber: endpoint number\n * @maxpacket: maximum packet size the endpoint can store\n * @buffer0count: the size of the packet recieved in the first buffer\n * @buffer1count: the size of the packet received in the second buffer\n * @curbufnum: current buffer of endpoint that will be processed next\n * @buffer0ready: the busy state of first buffer\n * @buffer1ready: the busy state of second buffer\n * @is_in: endpoint direction (IN or OUT)\n * @is_iso: endpoint type(isochronous or non isochronous)\n */\nstruct xusb_ep {\n\tstruct usb_ep ep_usb;\n\tstruct list_head queue;\n\tstruct xusb_udc *udc;\n\tconst struct usb_endpoint_descriptor *desc;\n\tu32  rambase;\n\tu32  offset;\n\tchar name[4];\n\tu16  epnumber;\n\tu16  maxpacket;\n\tu16  buffer0count;\n\tu16  buffer1count;\n\tu8   curbufnum;\n\tbool buffer0ready;\n\tbool buffer1ready;\n\tbool is_in;\n\tbool is_iso;\n};\n\n/**\n * struct xusb_udc -  USB peripheral driver structure\n * @gadget: USB gadget driver instance\n * @ep: an array of endpoint structures\n * @driver: pointer to the usb gadget driver instance\n * @setup: usb_ctrlrequest structure for control requests\n * @req: pointer to dummy request for get status command\n * @dev: pointer to device structure in gadget\n * @usb_state: device in suspended state or not\n * @remote_wkp: remote wakeup enabled by host\n * @setupseqtx: tx status\n * @setupseqrx: rx status\n * @addr: the usb device base address\n * @lock: instance of spinlock\n * @dma_enabled: flag indicating whether the dma is included in the system\n * @clk: pointer to struct clk\n * @read_fn: function pointer to read device registers\n * @write_fn: function pointer to write to device registers\n */\nstruct xusb_udc {\n\tstruct usb_gadget gadget;\n\tstruct xusb_ep ep[8];\n\tstruct usb_gadget_driver *driver;\n\tstruct usb_ctrlrequest setup;\n\tstruct xusb_req *req;\n\tstruct device *dev;\n\tu32 usb_state;\n\tu32 remote_wkp;\n\tu32 setupseqtx;\n\tu32 setupseqrx;\n\tvoid __iomem *addr;\n\tspinlock_t lock;\n\tbool dma_enabled;\n\tstruct clk *clk;\n\n\tunsigned int (*read_fn)(void __iomem *);\n\tvoid (*write_fn)(void __iomem *, u32, u32);\n};\n\n/* Endpoint buffer start addresses in the core */\nstatic u32 rambase[8] = { 0x22, 0x1000, 0x1100, 0x1200, 0x1300, 0x1400, 0x1500,\n\t\t\t  0x1600 };\n\nstatic const char driver_name[] = \"xilinx-udc\";\nstatic const char ep0name[] = \"ep0\";\n\n/* Control endpoint configuration.*/\nstatic const struct usb_endpoint_descriptor config_bulk_out_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize\t\t= cpu_to_le16(EP0_MAX_PACKET),\n};\n\n/**\n * xudc_write32 - little endian write to device registers\n * @addr: base addr of device registers\n * @offset: register offset\n * @val: data to be written\n */\nstatic void xudc_write32(void __iomem *addr, u32 offset, u32 val)\n{\n\tiowrite32(val, addr + offset);\n}\n\n/**\n * xudc_read32 - little endian read from device registers\n * @addr: addr of device register\n * Return: value at addr\n */\nstatic unsigned int xudc_read32(void __iomem *addr)\n{\n\treturn ioread32(addr);\n}\n\n/**\n * xudc_write32_be - big endian write to device registers\n * @addr: base addr of device registers\n * @offset: register offset\n * @val: data to be written\n */\nstatic void xudc_write32_be(void __iomem *addr, u32 offset, u32 val)\n{\n\tiowrite32be(val, addr + offset);\n}\n\n/**\n * xudc_read32_be - big endian read from device registers\n * @addr: addr of device register\n * Return: value at addr\n */\nstatic unsigned int xudc_read32_be(void __iomem *addr)\n{\n\treturn ioread32be(addr);\n}\n\n/**\n * xudc_wrstatus - Sets up the usb device status stages.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_wrstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\n\tu32 epcfgreg;\n\n\tepcfgreg = udc->read_fn(udc->addr + ep0->offset)|\n\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK;\n\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n\tudc->write_fn(udc->addr, ep0->offset + XUSB_EP_BUF0COUNT_OFFSET, 0);\n\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n}\n\n/**\n * xudc_epconfig - Configures the given endpoint.\n * @ep: pointer to the usb device endpoint structure.\n * @udc: pointer to the usb peripheral controller structure.\n *\n * This function configures a specific endpoint with the given configuration\n * data.\n */\nstatic void xudc_epconfig(struct xusb_ep *ep, struct xusb_udc *udc)\n{\n\tu32 epcfgreg;\n\n\t/*\n\t * Configure the end point direction, type, Max Packet Size and the\n\t * EP buffer location.\n\t */\n\tepcfgreg = ((ep->is_in << 29) | (ep->is_iso << 28) |\n\t\t   (ep->ep_usb.maxpacket << 15) | (ep->rambase));\n\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\n\t/* Set the Buffer count and the Buffer ready bits.*/\n\tudc->write_fn(udc->addr, ep->offset + XUSB_EP_BUF0COUNT_OFFSET,\n\t\t      ep->buffer0count);\n\tudc->write_fn(udc->addr, ep->offset + XUSB_EP_BUF1COUNT_OFFSET,\n\t\t      ep->buffer1count);\n\tif (ep->buffer0ready)\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\tif (ep->buffer1ready)\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT));\n}\n\n/**\n * xudc_start_dma - Starts DMA transfer.\n * @ep: pointer to the usb device endpoint structure.\n * @src: DMA source address.\n * @dst: DMA destination address.\n * @length: number of bytes to transfer.\n *\n * Return: 0 on success, error code on failure\n *\n * This function starts DMA transfer by writing to DMA source,\n * destination and lenth registers.\n */\nstatic int xudc_start_dma(struct xusb_ep *ep, dma_addr_t src,\n\t\t\t  dma_addr_t dst, u32 length)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\tint rc = 0;\n\tu32 timeout = 500;\n\tu32 reg;\n\n\t/*\n\t * Set the addresses in the DMA source and\n\t * destination registers and then set the length\n\t * into the DMA length register.\n\t */\n\tudc->write_fn(udc->addr, XUSB_DMA_DSAR_ADDR_OFFSET, src);\n\tudc->write_fn(udc->addr, XUSB_DMA_DDAR_ADDR_OFFSET, dst);\n\tudc->write_fn(udc->addr, XUSB_DMA_LENGTH_OFFSET, length);\n\n\t/*\n\t * Wait till DMA transaction is complete and\n\t * check whether the DMA transaction was\n\t * successful.\n\t */\n\tdo {\n\t\treg = udc->read_fn(udc->addr + XUSB_DMA_STATUS_OFFSET);\n\t\tif (!(reg &  XUSB_DMA_DMASR_BUSY))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We can't sleep here, because it's also called from\n\t\t * interrupt context.\n\t\t */\n\t\ttimeout--;\n\t\tif (!timeout) {\n\t\t\tdev_err(udc->dev, \"DMA timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t} while (1);\n\n\tif ((udc->read_fn(udc->addr + XUSB_DMA_STATUS_OFFSET) &\n\t\t\t  XUSB_DMA_DMASR_ERROR) == XUSB_DMA_DMASR_ERROR){\n\t\tdev_err(udc->dev, \"DMA Error\\n\");\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\n/**\n * xudc_dma_send - Sends IN data using DMA.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n * @buffer: pointer to data to be sent.\n * @length: number of bytes to send.\n *\n * Return: 0 on success, -EAGAIN if no buffer is free and error\n *\t   code on failure.\n *\n * This function sends data using DMA.\n */\nstatic int xudc_dma_send(struct xusb_ep *ep, struct xusb_req *req,\n\t\t\t u8 *buffer, u32 length)\n{\n\tu32 *eprambase;\n\tdma_addr_t src;\n\tdma_addr_t dst;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tsrc = req->usb_req.dma + req->usb_req.actual;\n\tif (req->usb_req.length)\n\t\tdma_sync_single_for_device(udc->dev, src,\n\t\t\t\t\t   length, DMA_TO_DEVICE);\n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t/* Get the Buffer address and copy the transmit data.*/\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tdst = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t      XUSB_EP_BUF0COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | (1 << ep->epnumber));\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t/* Get the Buffer address and copy the transmit data.*/\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase +\n\t\t\t     ep->ep_usb.maxpacket);\n\t\tdst = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t      XUSB_EP_BUF1COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t/* None of ping pong buffers are ready currently .*/\n\t\treturn -EAGAIN;\n\t}\n\n\treturn xudc_start_dma(ep, src, dst, length);\n}\n\n/**\n * xudc_dma_receive - Receives OUT data using DMA.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n * @buffer: pointer to storage buffer of received data.\n * @length: number of bytes to receive.\n *\n * Return: 0 on success, -EAGAIN if no buffer is free and error\n *\t   code on failure.\n *\n * This function receives data using DMA.\n */\nstatic int xudc_dma_receive(struct xusb_ep *ep, struct xusb_req *req,\n\t\t\t    u8 *buffer, u32 length)\n{\n\tu32 *eprambase;\n\tdma_addr_t src;\n\tdma_addr_t dst;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tdst = req->usb_req.dma + req->usb_req.actual;\n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t/* Get the Buffer address and copy the transmit data */\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tsrc = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | XUSB_DMA_READ_FROM_DPRAM |\n\t\t\t      (1 << ep->epnumber));\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t/* Get the Buffer address and copy the transmit data */\n\t\teprambase = (u32 __force *)(udc->addr +\n\t\t\t     ep->rambase + ep->ep_usb.maxpacket);\n\t\tsrc = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | XUSB_DMA_READ_FROM_DPRAM |\n\t\t\t      (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t/* None of the ping-pong buffers are ready currently */\n\t\treturn -EAGAIN;\n\t}\n\n\treturn xudc_start_dma(ep, src, dst, length);\n}\n\n/**\n * xudc_eptxrx - Transmits or receives data to or from an endpoint.\n * @ep: pointer to the usb endpoint configuration structure.\n * @req: pointer to the usb request structure.\n * @bufferptr: pointer to buffer containing the data to be sent.\n * @bufferlen: The number of data bytes to be sent.\n *\n * Return: 0 on success, -EAGAIN if no buffer is free.\n *\n * This function copies the transmit/receive data to/from the end point buffer\n * and enables the buffer for transmission/reception.\n */\nstatic int xudc_eptxrx(struct xusb_ep *ep, struct xusb_req *req,\n\t\t       u8 *bufferptr, u32 bufferlen)\n{\n\tu32 *eprambase;\n\tu32 bytestosend;\n\tint rc = 0;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tbytestosend = bufferlen;\n\tif (udc->dma_enabled) {\n\t\tif (ep->is_in)\n\t\t\trc = xudc_dma_send(ep, req, bufferptr, bufferlen);\n\t\telse\n\t\t\trc = xudc_dma_receive(ep, req, bufferptr, bufferlen);\n\t\treturn rc;\n\t}\n\t/* Put the transmit buffer into the correct ping-pong buffer.*/\n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t/* Get the Buffer address and copy the transmit data.*/\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tif (ep->is_in) {\n\t\t\tmemcpy(eprambase, bufferptr, bytestosend);\n\t\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t\t      XUSB_EP_BUF0COUNT_OFFSET, bufferlen);\n\t\t} else {\n\t\t\tmemcpy(bufferptr, eprambase, bytestosend);\n\t\t}\n\t\t/*\n\t\t * Enable the buffer for transmission.\n\t\t */\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t/* Get the Buffer address and copy the transmit data.*/\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase +\n\t\t\t     ep->ep_usb.maxpacket);\n\t\tif (ep->is_in) {\n\t\t\tmemcpy(eprambase, bufferptr, bytestosend);\n\t\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t\t      XUSB_EP_BUF1COUNT_OFFSET, bufferlen);\n\t\t} else {\n\t\t\tmemcpy(bufferptr, eprambase, bytestosend);\n\t\t}\n\t\t/*\n\t\t * Enable the buffer for transmission.\n\t\t */\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t/* None of the ping-pong buffers are ready currently */\n\t\treturn -EAGAIN;\n\t}\n\treturn rc;\n}\n\n/**\n * xudc_done - Exeutes the endpoint data transfer completion tasks.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n * @status: Status of the data transfer.\n *\n * Deletes the message from the queue and updates data transfer completion\n * status.\n */\nstatic void xudc_done(struct xusb_ep *ep, struct xusb_req *req, int status)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\n\tlist_del_init(&req->queue);\n\n\tif (req->usb_req.status == -EINPROGRESS)\n\t\treq->usb_req.status = status;\n\telse\n\t\tstatus = req->usb_req.status;\n\n\tif (status && status != -ESHUTDOWN)\n\t\tdev_dbg(udc->dev, \"%s done %p, status %d\\n\",\n\t\t\tep->ep_usb.name, req, status);\n\t/* unmap request if DMA is present*/\n\tif (udc->dma_enabled && ep->epnumber && req->usb_req.length)\n\t\tusb_gadget_unmap_request(&udc->gadget, &req->usb_req,\n\t\t\t\t\t ep->is_in);\n\n\tif (req->usb_req.complete) {\n\t\tspin_unlock(&udc->lock);\n\t\treq->usb_req.complete(&ep->ep_usb, &req->usb_req);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n\n/**\n * xudc_read_fifo - Reads the data from the given endpoint buffer.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n *\n * Return: 0 if request is completed and -EAGAIN if not completed.\n *\n * Pulls OUT packet data from the endpoint buffer.\n */\nstatic int xudc_read_fifo(struct xusb_ep *ep, struct xusb_req *req)\n{\n\tu8 *buf;\n\tu32 is_short, count, bufferspace;\n\tu8 bufoffset;\n\tu8 two_pkts = 0;\n\tint ret;\n\tint retval = -EAGAIN;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tif (ep->buffer0ready && ep->buffer1ready) {\n\t\tdev_dbg(udc->dev, \"Packet NOT ready!\\n\");\n\t\treturn retval;\n\t}\ntop:\n\tif (ep->curbufnum)\n\t\tbufoffset = XUSB_EP_BUF1COUNT_OFFSET;\n\telse\n\t\tbufoffset = XUSB_EP_BUF0COUNT_OFFSET;\n\n\tcount = udc->read_fn(udc->addr + ep->offset + bufoffset);\n\n\tif (!ep->buffer0ready && !ep->buffer1ready)\n\t\ttwo_pkts = 1;\n\n\tbuf = req->usb_req.buf + req->usb_req.actual;\n\tprefetchw(buf);\n\tbufferspace = req->usb_req.length - req->usb_req.actual;\n\tis_short = count < ep->ep_usb.maxpacket;\n\n\tif (unlikely(!bufferspace)) {\n\t\t/*\n\t\t * This happens when the driver's buffer\n\t\t * is smaller than what the host sent.\n\t\t * discard the extra data.\n\t\t */\n\t\tif (req->usb_req.status != -EOVERFLOW)\n\t\t\tdev_dbg(udc->dev, \"%s overflow %d\\n\",\n\t\t\t\tep->ep_usb.name, count);\n\t\treq->usb_req.status = -EOVERFLOW;\n\t\txudc_done(ep, req, -EOVERFLOW);\n\t\treturn 0;\n\t}\n\n\tret = xudc_eptxrx(ep, req, buf, count);\n\tswitch (ret) {\n\tcase 0:\n\t\treq->usb_req.actual += min(count, bufferspace);\n\t\tdev_dbg(udc->dev, \"read %s, %d bytes%s req %p %d/%d\\n\",\n\t\t\tep->ep_usb.name, count, is_short ? \"/S\" : \"\", req,\n\t\t\treq->usb_req.actual, req->usb_req.length);\n\t\tbufferspace -= count;\n\t\t/* Completion */\n\t\tif ((req->usb_req.actual == req->usb_req.length) || is_short) {\n\t\t\tif (udc->dma_enabled && req->usb_req.length)\n\t\t\t\tdma_sync_single_for_cpu(udc->dev,\n\t\t\t\t\t\t\treq->usb_req.dma,\n\t\t\t\t\t\t\treq->usb_req.actual,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\txudc_done(ep, req, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tif (two_pkts) {\n\t\t\ttwo_pkts = 0;\n\t\t\tgoto top;\n\t\t}\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tdev_dbg(udc->dev, \"receive busy\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -ETIMEDOUT:\n\t\t/* DMA error, dequeue the request */\n\t\txudc_done(ep, req, -ECONNRESET);\n\t\tretval = 0;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/**\n * xudc_write_fifo - Writes data into the given endpoint buffer.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n *\n * Return: 0 if request is completed and -EAGAIN if not completed.\n *\n * Loads endpoint buffer for an IN packet.\n */\nstatic int xudc_write_fifo(struct xusb_ep *ep, struct xusb_req *req)\n{\n\tu32 max;\n\tu32 length;\n\tint ret;\n\tint retval = -EAGAIN;\n\tstruct xusb_udc *udc = ep->udc;\n\tint is_last, is_short = 0;\n\tu8 *buf;\n\n\tmax = le16_to_cpu(ep->desc->wMaxPacketSize);\n\tbuf = req->usb_req.buf + req->usb_req.actual;\n\tprefetch(buf);\n\tlength = req->usb_req.length - req->usb_req.actual;\n\tlength = min(length, max);\n\n\tret = xudc_eptxrx(ep, req, buf, length);\n\tswitch (ret) {\n\tcase 0:\n\t\treq->usb_req.actual += length;\n\t\tif (unlikely(length != max)) {\n\t\t\tis_last = is_short = 1;\n\t\t} else {\n\t\t\tif (likely(req->usb_req.length !=\n\t\t\t\t   req->usb_req.actual) || req->usb_req.zero)\n\t\t\t\tis_last = 0;\n\t\t\telse\n\t\t\t\tis_last = 1;\n\t\t}\n\t\tdev_dbg(udc->dev, \"%s: wrote %s %d bytes%s%s %d left %p\\n\",\n\t\t\t__func__, ep->ep_usb.name, length, is_last ? \"/L\" : \"\",\n\t\t\tis_short ? \"/S\" : \"\",\n\t\t\treq->usb_req.length - req->usb_req.actual, req);\n\t\t/* completion */\n\t\tif (is_last) {\n\t\t\txudc_done(ep, req, 0);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tdev_dbg(udc->dev, \"Send busy\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -ETIMEDOUT:\n\t\t/* DMA error, dequeue the request */\n\t\txudc_done(ep, req, -ECONNRESET);\n\t\tretval = 0;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/**\n * xudc_nuke - Cleans up the data transfer message list.\n * @ep: pointer to the usb device endpoint structure.\n * @status: Status of the data transfer.\n */\nstatic void xudc_nuke(struct xusb_ep *ep, int status)\n{\n\tstruct xusb_req *req;\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_first_entry(&ep->queue, struct xusb_req, queue);\n\t\txudc_done(ep, req, status);\n\t}\n}\n\n/**\n * xudc_ep_set_halt - Stalls/unstalls the given endpoint.\n * @_ep: pointer to the usb device endpoint structure.\n * @value: value to indicate stall/unstall.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct xusb_ep *ep = to_xusb_ep(_ep);\n\tstruct xusb_udc *udc;\n\tunsigned long flags;\n\tu32 epcfgreg;\n\n\tif (!_ep || (!ep->desc && ep->epnumber)) {\n\t\tpr_debug(\"%s: bad ep or descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tudc = ep->udc;\n\n\tif (ep->is_in && (!list_empty(&ep->queue)) && value) {\n\t\tdev_dbg(udc->dev, \"requests pending can't halt\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ep->buffer0ready || ep->buffer1ready) {\n\t\tdev_dbg(udc->dev, \"HW buffers busy can't halt\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (value) {\n\t\t/* Stall the device.*/\n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t} else {\n\t\t/* Unstall the device.*/\n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\tif (ep->epnumber) {\n\t\t\t/* Reset the toggle bit.*/\n\t\t\tepcfgreg = udc->read_fn(ep->udc->addr + ep->offset);\n\t\t\tepcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n/**\n * __xudc_ep_enable - Enables the given endpoint.\n * @ep: pointer to the xusb endpoint structure.\n * @desc: pointer to usb endpoint descriptor.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int __xudc_ep_enable(struct xusb_ep *ep,\n\t\t\t    const struct usb_endpoint_descriptor *desc)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\tu32 tmp;\n\tu32 epcfg;\n\tu32 ier;\n\tu16 maxpacket;\n\n\tep->is_in = ((desc->bEndpointAddress & USB_DIR_IN) != 0);\n\t/* Bit 3...0:endpoint number */\n\tep->epnumber = (desc->bEndpointAddress & 0x0f);\n\tep->desc = desc;\n\tep->ep_usb.desc = desc;\n\ttmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n\tep->ep_usb.maxpacket = maxpacket = le16_to_cpu(desc->wMaxPacketSize);\n\n\tswitch (tmp) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tdev_dbg(udc->dev, \"only one control endpoint\\n\");\n\t\t/* NON- ISO */\n\t\tep->is_iso = 0;\n\t\treturn -EINVAL;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t/* NON- ISO */\n\t\tep->is_iso = 0;\n\t\tif (maxpacket > 64) {\n\t\t\tdev_dbg(udc->dev, \"bogus maxpacket %d\\n\", maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\t/* NON- ISO */\n\t\tep->is_iso = 0;\n\t\tif (!(is_power_of_2(maxpacket) && maxpacket >= 8 &&\n\t\t\t\tmaxpacket <= 512)) {\n\t\t\tdev_dbg(udc->dev, \"bogus maxpacket %d\\n\", maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t/* ISO */\n\t\tep->is_iso = 1;\n\t\tbreak;\n\t}\n\n\tep->buffer0ready = false;\n\tep->buffer1ready = false;\n\tep->curbufnum = 0;\n\tep->rambase = rambase[ep->epnumber];\n\txudc_epconfig(ep, udc);\n\n\tdev_dbg(udc->dev, \"Enable Endpoint %d max pkt is %d\\n\",\n\t\tep->epnumber, maxpacket);\n\n\t/* Enable the End point.*/\n\tepcfg = udc->read_fn(udc->addr + ep->offset);\n\tepcfg |= XUSB_EP_CFG_VALID_MASK;\n\tudc->write_fn(udc->addr, ep->offset, epcfg);\n\tif (ep->epnumber)\n\t\tep->rambase <<= 2;\n\n\t/* Enable buffer completion interrupts for endpoint */\n\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\tier |= (XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK << ep->epnumber);\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t/* for OUT endpoint set buffers ready to receive */\n\tif (ep->epnumber && !ep->is_in) {\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\t\tep->buffer0ready = true;\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t     (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = true;\n\t}\n\n\treturn 0;\n}\n\n/**\n * xudc_ep_enable - Enables the given endpoint.\n * @_ep: pointer to the usb endpoint structure.\n * @desc: pointer to usb endpoint descriptor.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_enable(struct usb_ep *_ep,\n\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct xusb_ep *ep;\n\tstruct xusb_udc *udc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\n\t\tpr_debug(\"%s: bad ep or descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = to_xusb_ep(_ep);\n\tudc = ep->udc;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"bogus device state\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tret = __xudc_ep_enable(ep, desc);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\n/**\n * xudc_ep_disable - Disables the given endpoint.\n * @_ep: pointer to the usb endpoint structure.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_disable(struct usb_ep *_ep)\n{\n\tstruct xusb_ep *ep;\n\tunsigned long flags;\n\tu32 epcfg;\n\tstruct xusb_udc *udc;\n\n\tif (!_ep) {\n\t\tpr_debug(\"%s: invalid ep\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = to_xusb_ep(_ep);\n\tudc = ep->udc;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\txudc_nuke(ep, -ESHUTDOWN);\n\n\t/* Restore the endpoint's pristine config */\n\tep->desc = NULL;\n\tep->ep_usb.desc = NULL;\n\n\tdev_dbg(udc->dev, \"USB Ep %d disable\\n \", ep->epnumber);\n\t/* Disable the endpoint.*/\n\tepcfg = udc->read_fn(udc->addr + ep->offset);\n\tepcfg &= ~XUSB_EP_CFG_VALID_MASK;\n\tudc->write_fn(udc->addr, ep->offset, epcfg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n/**\n * xudc_ep_alloc_request - Initializes the request queue.\n * @_ep: pointer to the usb endpoint structure.\n * @gfp_flags: Flags related to the request call.\n *\n * Return: pointer to request structure on success and a NULL on failure.\n */\nstatic struct usb_request *xudc_ep_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct xusb_ep *ep = to_xusb_ep(_ep);\n\tstruct xusb_req *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->ep = ep;\n\tINIT_LIST_HEAD(&req->queue);\n\treturn &req->usb_req;\n}\n\n/**\n * xudc_free_request - Releases the request from queue.\n * @_ep: pointer to the usb device endpoint structure.\n * @_req: pointer to the usb request structure.\n */\nstatic void xudc_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct xusb_req *req = to_xusb_req(_req);\n\n\tkfree(req);\n}\n\n/**\n * __xudc_ep0_queue - Adds the request to endpoint 0 queue.\n * @ep0: pointer to the xusb endpoint 0 structure.\n * @req: pointer to the xusb request structure.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int __xudc_ep0_queue(struct xusb_ep *ep0, struct xusb_req *req)\n{\n\tstruct xusb_udc *udc = ep0->udc;\n\tu32 length;\n\tu8 *corebuf;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"%s, bogus device state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!list_empty(&ep0->queue)) {\n\t\tdev_dbg(udc->dev, \"%s:ep0 busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\treq->usb_req.status = -EINPROGRESS;\n\treq->usb_req.actual = 0;\n\n\tlist_add_tail(&req->queue, &ep0->queue);\n\n\tif (udc->setup.bRequestType & USB_DIR_IN) {\n\t\tprefetch(req->usb_req.buf);\n\t\tlength = req->usb_req.length;\n\t\tcorebuf = (void __force *) ((ep0->rambase << 2) +\n\t\t\t   udc->addr);\n\t\tlength = req->usb_req.actual = min_t(u32, length,\n\t\t\t\t\t\t     EP0_MAX_PACKET);\n\t\tmemcpy(corebuf, req->usb_req.buf, length);\n\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t} else {\n\t\tif (udc->setup.wLength) {\n\t\t\t/* Enable EP0 buffer to receive data */\n\t\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, 0);\n\t\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\t} else {\n\t\t\txudc_wrstatus(udc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * xudc_ep0_queue - Adds the request to endpoint 0 queue.\n * @_ep: pointer to the usb endpoint 0 structure.\n * @_req: pointer to the usb request structure.\n * @gfp_flags: Flags related to the request call.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep0_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t  gfp_t gfp_flags)\n{\n\tstruct xusb_req *req\t= to_xusb_req(_req);\n\tstruct xusb_ep\t*ep0\t= to_xusb_ep(_ep);\n\tstruct xusb_udc *udc\t= ep0->udc;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tret = __xudc_ep0_queue(ep0, req);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\n/**\n * xudc_ep_queue - Adds the request to endpoint queue.\n * @_ep: pointer to the usb endpoint structure.\n * @_req: pointer to the usb request structure.\n * @gfp_flags: Flags related to the request call.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xusb_req *req = to_xusb_req(_req);\n\tstruct xusb_ep\t*ep  = to_xusb_ep(_ep);\n\tstruct xusb_udc *udc = ep->udc;\n\tint  ret;\n\tunsigned long flags;\n\n\tif (!ep->desc) {\n\t\tdev_dbg(udc->dev, \"%s: queuing request to disabled %s\\n\",\n\t\t\t__func__, ep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"%s, bogus device state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tif (udc->dma_enabled) {\n\t\tret = usb_gadget_map_request(&udc->gadget, &req->usb_req,\n\t\t\t\t\t     ep->is_in);\n\t\tif (ret) {\n\t\t\tdev_dbg(udc->dev, \"gadget_map failed ep%d\\n\",\n\t\t\t\tep->epnumber);\n\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (list_empty(&ep->queue)) {\n\t\tif (ep->is_in) {\n\t\t\tdev_dbg(udc->dev, \"xudc_write_fifo from ep_queue\\n\");\n\t\t\tif (!xudc_write_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t} else {\n\t\t\tdev_dbg(udc->dev, \"xudc_read_fifo from ep_queue\\n\");\n\t\t\tif (!xudc_read_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t}\n\t}\n\n\tif (req != NULL)\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n/**\n * xudc_ep_dequeue - Removes the request from the queue.\n * @_ep: pointer to the usb device endpoint structure.\n * @_req: pointer to the usb request structure.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct xusb_ep *ep\t= to_xusb_ep(_ep);\n\tstruct xusb_req *req\t= to_xusb_req(_req);\n\tstruct xusb_udc *udc\t= ep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t/* Make sure it's actually queued on this endpoint */\n\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\tif (&req->usb_req == _req)\n\t\t\tbreak;\n\t}\n\tif (&req->usb_req != _req) {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\txudc_done(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n/**\n * xudc_ep0_enable - Enables the given endpoint.\n * @ep: pointer to the usb endpoint structure.\n * @desc: pointer to usb endpoint descriptor.\n *\n * Return: error always.\n *\n * endpoint 0 enable should not be called by gadget layer.\n */\nstatic int xudc_ep0_enable(struct usb_ep *ep,\n\t\t\t   const struct usb_endpoint_descriptor *desc)\n{\n\treturn -EINVAL;\n}\n\n/**\n * xudc_ep0_disable - Disables the given endpoint.\n * @ep: pointer to the usb endpoint structure.\n *\n * Return: error always.\n *\n * endpoint 0 disable should not be called by gadget layer.\n */\nstatic int xudc_ep0_disable(struct usb_ep *ep)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct usb_ep_ops xusb_ep0_ops = {\n\t.enable\t\t= xudc_ep0_enable,\n\t.disable\t= xudc_ep0_disable,\n\t.alloc_request\t= xudc_ep_alloc_request,\n\t.free_request\t= xudc_free_request,\n\t.queue\t\t= xudc_ep0_queue,\n\t.dequeue\t= xudc_ep_dequeue,\n\t.set_halt\t= xudc_ep_set_halt,\n};\n\nstatic const struct usb_ep_ops xusb_ep_ops = {\n\t.enable\t\t= xudc_ep_enable,\n\t.disable\t= xudc_ep_disable,\n\t.alloc_request\t= xudc_ep_alloc_request,\n\t.free_request\t= xudc_free_request,\n\t.queue\t\t= xudc_ep_queue,\n\t.dequeue\t= xudc_ep_dequeue,\n\t.set_halt\t= xudc_ep_set_halt,\n};\n\n/**\n * xudc_get_frame - Reads the current usb frame number.\n * @gadget: pointer to the usb gadget structure.\n *\n * Return: current frame number for success and error value on failure.\n */\nstatic int xudc_get_frame(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc;\n\tint frame;\n\n\tif (!gadget)\n\t\treturn -ENODEV;\n\n\tudc = to_udc(gadget);\n\tframe = udc->read_fn(udc->addr + XUSB_FRAMENUM_OFFSET);\n\treturn frame;\n}\n\n/**\n * xudc_wakeup - Send remote wakeup signal to host\n * @gadget: pointer to the usb gadget structure.\n *\n * Return: 0 on success and error on failure\n */\nstatic int xudc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tu32 crtlreg;\n\tint status = -EINVAL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t/* Remote wake up not enabled by host */\n\tif (!udc->remote_wkp)\n\t\tgoto done;\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg |= XUSB_CONTROL_USB_RMTWAKE_MASK;\n\t/* set remote wake up bit */\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\t/*\n\t * wait for a while and reset remote wake up bit since this bit\n\t * is not cleared by HW after sending remote wakeup to host.\n\t */\n\tmdelay(2);\n\n\tcrtlreg &= ~XUSB_CONTROL_USB_RMTWAKE_MASK;\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\tstatus = 0;\ndone:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn status;\n}\n\n/**\n * xudc_pullup - start/stop USB traffic\n * @gadget: pointer to the usb gadget structure.\n * @is_on: flag to start or stop\n *\n * Return: 0 always\n *\n * This function starts/stops SIE engine of IP based on is_on.\n */\nstatic int xudc_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\tu32 crtlreg;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tif (is_on)\n\t\tcrtlreg |= XUSB_CONTROL_USB_READY_MASK;\n\telse\n\t\tcrtlreg &= ~XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n/**\n * xudc_eps_init - initialize endpoints.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_eps_init(struct xusb_udc *udc)\n{\n\tu32 ep_number;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\n\tfor (ep_number = 0; ep_number < XUSB_MAX_ENDPOINTS; ep_number++) {\n\t\tstruct xusb_ep *ep = &udc->ep[ep_number];\n\n\t\tif (ep_number) {\n\t\t\tlist_add_tail(&ep->ep_usb.ep_list,\n\t\t\t\t      &udc->gadget.ep_list);\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep_usb,\n\t\t\t\t\t\t  (unsigned short) ~0);\n\t\t\tsnprintf(ep->name, EPNAME_SIZE, \"ep%d\", ep_number);\n\t\t\tep->ep_usb.name = ep->name;\n\t\t\tep->ep_usb.ops = &xusb_ep_ops;\n\n\t\t\tep->ep_usb.caps.type_iso = true;\n\t\t\tep->ep_usb.caps.type_bulk = true;\n\t\t\tep->ep_usb.caps.type_int = true;\n\t\t} else {\n\t\t\tep->ep_usb.name = ep0name;\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep_usb, EP0_MAX_PACKET);\n\t\t\tep->ep_usb.ops = &xusb_ep0_ops;\n\n\t\t\tep->ep_usb.caps.type_control = true;\n\t\t}\n\n\t\tep->ep_usb.caps.dir_in = true;\n\t\tep->ep_usb.caps.dir_out = true;\n\n\t\tep->udc = udc;\n\t\tep->epnumber = ep_number;\n\t\tep->desc = NULL;\n\t\t/*\n\t\t * The configuration register address offset between\n\t\t * each endpoint is 0x10.\n\t\t */\n\t\tep->offset = XUSB_EP0_CONFIG_OFFSET + (ep_number * 0x10);\n\t\tep->is_in = 0;\n\t\tep->is_iso = 0;\n\t\tep->maxpacket = 0;\n\t\txudc_epconfig(ep, udc);\n\n\t\t/* Initialize one queue per endpoint */\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t}\n}\n\n/**\n * xudc_stop_activity - Stops any further activity on the device.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_stop_activity(struct xusb_udc *udc)\n{\n\tint i;\n\tstruct xusb_ep *ep;\n\n\tfor (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\txudc_nuke(ep, -ESHUTDOWN);\n\t}\n}\n\n/**\n * xudc_start - Starts the device.\n * @gadget: pointer to the usb gadget structure\n * @driver: pointer to gadget driver structure\n *\n * Return: zero on success and error on failure\n */\nstatic int xudc_start(struct usb_gadget *gadget,\n\t\t      struct usb_gadget_driver *driver)\n{\n\tstruct xusb_udc *udc\t= to_udc(gadget);\n\tstruct xusb_ep *ep0\t= &udc->ep[XUSB_EP_NUMBER_ZERO];\n\tconst struct usb_endpoint_descriptor *desc = &config_bulk_out_desc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (udc->driver) {\n\t\tdev_err(udc->dev, \"%s is already bound to %s\\n\",\n\t\t\tudc->gadget.name, udc->driver->driver.name);\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t/* hook up the driver */\n\tudc->driver = driver;\n\tudc->gadget.speed = driver->max_speed;\n\n\t/* Enable the control endpoint. */\n\tret = __xudc_ep_enable(ep0, desc);\n\n\t/* Set device address and remote wakeup to 0 */\n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\tudc->remote_wkp = 0;\nerr:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn ret;\n}\n\n/**\n * xudc_stop - stops the device.\n * @gadget: pointer to the usb gadget structure\n *\n * Return: zero always\n */\nstatic int xudc_stop(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->driver = NULL;\n\n\t/* Set device address and remote wakeup to 0 */\n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\tudc->remote_wkp = 0;\n\n\txudc_stop_activity(udc);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops xusb_udc_ops = {\n\t.get_frame\t= xudc_get_frame,\n\t.wakeup\t\t= xudc_wakeup,\n\t.pullup\t\t= xudc_pullup,\n\t.udc_start\t= xudc_start,\n\t.udc_stop\t= xudc_stop,\n};\n\n/**\n * xudc_clear_stall_all_ep - clears stall of every endpoint.\n * @udc: pointer to the udc structure.\n */\nstatic void xudc_clear_stall_all_ep(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep;\n\tu32 epcfgreg;\n\tint i;\n\n\tfor (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\tif (ep->epnumber) {\n\t\t\t/* Reset the toggle bit.*/\n\t\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\t\tepcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\t}\n\t}\n}\n\n/**\n * xudc_startup_handler - The usb device controller interrupt handler.\n * @udc: pointer to the udc structure.\n * @intrstatus: The mask value containing the interrupt sources.\n *\n * This function handles the RESET,SUSPEND,RESUME and DISCONNECT interrupts.\n */\nstatic void xudc_startup_handler(struct xusb_udc *udc, u32 intrstatus)\n{\n\tu32 intrreg;\n\n\tif (intrstatus & XUSB_STATUS_RESET_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Reset\\n\");\n\n\t\tif (intrstatus & XUSB_STATUS_HIGH_SPEED_MASK)\n\t\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t\telse\n\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\n\t\txudc_stop_activity(udc);\n\t\txudc_clear_stall_all_ep(udc);\n\t\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, 0);\n\n\t\t/* Set device address and remote wakeup to 0 */\n\t\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\t\tudc->remote_wkp = 0;\n\n\t\t/* Enable the suspend, resume and disconnect */\n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_SUSPEND_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\t}\n\tif (intrstatus & XUSB_STATUS_SUSPEND_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Suspend\\n\");\n\n\t\t/* Enable the reset, resume and disconnect */\n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tudc->usb_state = USB_STATE_SUSPENDED;\n\n\t\tif (udc->driver->suspend) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\tif (intrstatus & XUSB_STATUS_RESUME_MASK) {\n\t\tbool condition = (udc->usb_state != USB_STATE_SUSPENDED);\n\n\t\tdev_WARN_ONCE(udc->dev, condition,\n\t\t\t\t\"Resume IRQ while not suspended\\n\");\n\n\t\tdev_dbg(udc->dev, \"Resume\\n\");\n\n\t\t/* Enable the reset, suspend and disconnect */\n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_SUSPEND_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tudc->usb_state = 0;\n\n\t\tif (udc->driver->resume) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\tif (intrstatus & XUSB_STATUS_DISCONNECT_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Disconnect\\n\");\n\n\t\t/* Enable the reset, resume and suspend */\n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_SUSPEND_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tif (udc->driver && udc->driver->disconnect) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->disconnect(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n}\n\n/**\n * xudc_ep0_stall - Stall endpoint zero.\n * @udc: pointer to the udc structure.\n *\n * This function stalls endpoint zero.\n */\nstatic void xudc_ep0_stall(struct xusb_udc *udc)\n{\n\tu32 epcfgreg;\n\tstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\n\n\tepcfgreg = udc->read_fn(udc->addr + ep0->offset);\n\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n}\n\n/**\n * xudc_setaddress - executes SET_ADDRESS command\n * @udc: pointer to the udc structure.\n *\n * This function executes USB SET_ADDRESS command\n */\nstatic void xudc_setaddress(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tint ret;\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"Can't respond to SET ADDRESS request\\n\");\n\txudc_ep0_stall(udc);\n}\n\n/**\n * xudc_getstatus - executes GET_STATUS command\n * @udc: pointer to the udc structure.\n *\n * This function executes USB GET_STATUS command\n */\nstatic void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\t/* Get device status */\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}\n\n/**\n * xudc_set_clear_feature - Executes the set feature and clear feature commands.\n * @udc: pointer to the usb device controller structure.\n *\n * Processes the SET_FEATURE and CLEAR_FEATURE commands.\n */\nstatic void xudc_set_clear_feature(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu8 endpoint;\n\tu8 outinbit;\n\tu32 epcfgreg;\n\tint flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0);\n\tint ret;\n\n\tswitch (udc->setup.bRequestType) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (udc->setup.wValue) {\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t/*\n\t\t\t * The Test Mode will be executed\n\t\t\t * after the status phase.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tif (flag)\n\t\t\t\tudc->remote_wkp = 1;\n\t\t\telse\n\t\t\t\tudc->remote_wkp = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txudc_ep0_stall(udc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (!udc->setup.wValue) {\n\t\t\tendpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\ttarget_ep = &udc->ep[endpoint];\n\t\t\toutinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK;\n\t\t\toutinbit = outinbit >> 7;\n\n\t\t\t/* Make sure direction matches.*/\n\t\t\tif (outinbit != target_ep->is_in) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\t\tif (!endpoint) {\n\t\t\t\t/* Clear the stall.*/\n\t\t\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t      target_ep->offset, epcfgreg);\n\t\t\t} else {\n\t\t\t\tif (flag) {\n\t\t\t\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t} else {\n\t\t\t\t\t/* Unstall the endpoint.*/\n\t\t\t\t\tepcfgreg &= ~(XUSB_EP_CFG_STALL_MASK |\n\t\t\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK);\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\txudc_ep0_stall(udc);\n\t\treturn;\n\t}\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"Can't respond to SET/CLEAR FEATURE\\n\");\n\txudc_ep0_stall(udc);\n}\n\n/**\n * xudc_handle_setup - Processes the setup packet.\n * @udc: pointer to the usb device controller structure.\n *\n * Process setup packet and delegate to gadget layer.\n */\nstatic void xudc_handle_setup(struct xusb_udc *udc)\n\t__must_hold(&udc->lock)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct usb_ctrlrequest setup;\n\tu32 *ep0rambase;\n\n\t/* Load up the chapter 9 command buffer.*/\n\tep0rambase = (u32 __force *) (udc->addr + XUSB_SETUP_PKT_ADDR_OFFSET);\n\tmemcpy(&setup, ep0rambase, 8);\n\n\tudc->setup = setup;\n\tudc->setup.wValue = cpu_to_le16(setup.wValue);\n\tudc->setup.wIndex = cpu_to_le16(setup.wIndex);\n\tudc->setup.wLength = cpu_to_le16(setup.wLength);\n\n\t/* Clear previous requests */\n\txudc_nuke(ep0, -ECONNRESET);\n\n\tif (udc->setup.bRequestType & USB_DIR_IN) {\n\t\t/* Execute the get command.*/\n\t\tudc->setupseqrx = STATUS_PHASE;\n\t\tudc->setupseqtx = DATA_PHASE;\n\t} else {\n\t\t/* Execute the put command.*/\n\t\tudc->setupseqrx = DATA_PHASE;\n\t\tudc->setupseqtx = STATUS_PHASE;\n\t}\n\n\tswitch (udc->setup.bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\t/* Data+Status phase form udc */\n\t\tif ((udc->setup.bRequestType &\n\t\t\t\t(USB_DIR_IN | USB_TYPE_MASK)) !=\n\t\t\t\t(USB_DIR_IN | USB_TYPE_STANDARD))\n\t\t\tbreak;\n\t\txudc_getstatus(udc);\n\t\treturn;\n\tcase USB_REQ_SET_ADDRESS:\n\t\t/* Status phase from udc */\n\t\tif (udc->setup.bRequestType != (USB_DIR_OUT |\n\t\t\t\tUSB_TYPE_STANDARD | USB_RECIP_DEVICE))\n\t\t\tbreak;\n\t\txudc_setaddress(udc);\n\t\treturn;\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\t/* Requests with no data phase, status phase from udc */\n\t\tif ((udc->setup.bRequestType & USB_TYPE_MASK)\n\t\t\t\t!= USB_TYPE_STANDARD)\n\t\t\tbreak;\n\t\txudc_set_clear_feature(udc);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock(&udc->lock);\n\tif (udc->driver->setup(&udc->gadget, &setup) < 0)\n\t\txudc_ep0_stall(udc);\n\tspin_lock(&udc->lock);\n}\n\n/**\n * xudc_ep0_out - Processes the endpoint 0 OUT token.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_ep0_out(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct xusb_req *req;\n\tu8 *ep0rambase;\n\tunsigned int bytes_to_rx;\n\tvoid *buffer;\n\n\treq = list_first_entry(&ep0->queue, struct xusb_req, queue);\n\n\tswitch (udc->setupseqrx) {\n\tcase STATUS_PHASE:\n\t\t/*\n\t\t * This resets both state machines for the next\n\t\t * Setup packet.\n\t\t */\n\t\tudc->setupseqrx = SETUP_PHASE;\n\t\tudc->setupseqtx = SETUP_PHASE;\n\t\treq->usb_req.actual = req->usb_req.length;\n\t\txudc_done(ep0, req, 0);\n\t\tbreak;\n\tcase DATA_PHASE:\n\t\tbytes_to_rx = udc->read_fn(udc->addr +\n\t\t\t\t\t   XUSB_EP_BUF0COUNT_OFFSET);\n\t\t/* Copy the data to be received from the DPRAM. */\n\t\tep0rambase = (u8 __force *) (udc->addr +\n\t\t\t     (ep0->rambase << 2));\n\t\tbuffer = req->usb_req.buf + req->usb_req.actual;\n\t\treq->usb_req.actual = req->usb_req.actual + bytes_to_rx;\n\t\tmemcpy(buffer, ep0rambase, bytes_to_rx);\n\n\t\tif (req->usb_req.length == req->usb_req.actual) {\n\t\t\t/* Data transfer completed get ready for Status stage */\n\t\t\txudc_wrstatus(udc);\n\t\t} else {\n\t\t\t/* Enable EP0 buffer to receive data */\n\t\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, 0);\n\t\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * xudc_ep0_in - Processes the endpoint 0 IN token.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_ep0_in(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct xusb_req *req;\n\tunsigned int bytes_to_tx;\n\tvoid *buffer;\n\tu32 epcfgreg;\n\tu16 count = 0;\n\tu16 length;\n\tu8 *ep0rambase;\n\tu8 test_mode = udc->setup.wIndex >> 8;\n\n\treq = list_first_entry(&ep0->queue, struct xusb_req, queue);\n\tbytes_to_tx = req->usb_req.length - req->usb_req.actual;\n\n\tswitch (udc->setupseqtx) {\n\tcase STATUS_PHASE:\n\t\tswitch (udc->setup.bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\t/* Set the address of the device.*/\n\t\t\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET,\n\t\t\t\t      udc->setup.wValue);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tif (udc->setup.bRequestType ==\n\t\t\t\t\tUSB_RECIP_DEVICE) {\n\t\t\t\tif (udc->setup.wValue ==\n\t\t\t\t\t\tUSB_DEVICE_TEST_MODE)\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      XUSB_TESTMODE_OFFSET,\n\t\t\t\t\t\t      test_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treq->usb_req.actual = req->usb_req.length;\n\t\txudc_done(ep0, req, 0);\n\t\tbreak;\n\tcase DATA_PHASE:\n\t\tif (!bytes_to_tx) {\n\t\t\t/*\n\t\t\t * We're done with data transfer, next\n\t\t\t * will be zero length OUT with data toggle of\n\t\t\t * 1. Setup data_toggle.\n\t\t\t */\n\t\t\tepcfgreg = udc->read_fn(udc->addr + ep0->offset);\n\t\t\tepcfgreg |= XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n\t\t\tudc->setupseqtx = STATUS_PHASE;\n\t\t} else {\n\t\t\tlength = count = min_t(u32, bytes_to_tx,\n\t\t\t\t\t       EP0_MAX_PACKET);\n\t\t\t/* Copy the data to be transmitted into the DPRAM. */\n\t\t\tep0rambase = (u8 __force *) (udc->addr +\n\t\t\t\t     (ep0->rambase << 2));\n\t\t\tbuffer = req->usb_req.buf + req->usb_req.actual;\n\t\t\treq->usb_req.actual = req->usb_req.actual + length;\n\t\t\tmemcpy(ep0rambase, buffer, length);\n\t\t}\n\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, count);\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * xudc_ctrl_ep_handler - Endpoint 0 interrupt handler.\n * @udc: pointer to the udc structure.\n * @intrstatus:\tIt's the mask value for the interrupt sources on endpoint 0.\n *\n * Processes the commands received during enumeration phase.\n */\nstatic void xudc_ctrl_ep_handler(struct xusb_udc *udc, u32 intrstatus)\n{\n\n\tif (intrstatus & XUSB_STATUS_SETUP_PACKET_MASK) {\n\t\txudc_handle_setup(udc);\n\t} else {\n\t\tif (intrstatus & XUSB_STATUS_FIFO_BUFF_RDY_MASK)\n\t\t\txudc_ep0_out(udc);\n\t\telse if (intrstatus & XUSB_STATUS_FIFO_BUFF_FREE_MASK)\n\t\t\txudc_ep0_in(udc);\n\t}\n}\n\n/**\n * xudc_nonctrl_ep_handler - Non control endpoint interrupt handler.\n * @udc: pointer to the udc structure.\n * @epnum: End point number for which the interrupt is to be processed\n * @intrstatus:\tmask value for interrupt sources of endpoints other\n *\t\tthan endpoint 0.\n *\n * Processes the buffer completion interrupts.\n */\nstatic void xudc_nonctrl_ep_handler(struct xusb_udc *udc, u8 epnum,\n\t\t\t\t    u32 intrstatus)\n{\n\n\tstruct xusb_req *req;\n\tstruct xusb_ep *ep;\n\n\tep = &udc->ep[epnum];\n\t/* Process the End point interrupts.*/\n\tif (intrstatus & (XUSB_STATUS_EP0_BUFF1_COMP_MASK << epnum))\n\t\tep->buffer0ready = 0;\n\tif (intrstatus & (XUSB_STATUS_EP0_BUFF2_COMP_MASK << epnum))\n\t\tep->buffer1ready = false;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\n\treq = list_first_entry(&ep->queue, struct xusb_req, queue);\n\n\tif (ep->is_in)\n\t\txudc_write_fifo(ep, req);\n\telse\n\t\txudc_read_fifo(ep, req);\n}\n\n/**\n * xudc_irq - The main interrupt handler.\n * @irq: The interrupt number.\n * @_udc: pointer to the usb device controller structure.\n *\n * Return: IRQ_HANDLED after the interrupt is handled.\n */\nstatic irqreturn_t xudc_irq(int irq, void *_udc)\n{\n\tstruct xusb_udc *udc = _udc;\n\tu32 intrstatus;\n\tu32 ier;\n\tu8 index;\n\tu32 bufintr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t/*\n\t * Event interrupts are level sensitive hence first disable\n\t * IER, read ISR and figure out active interrupts.\n\t */\n\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\tier &= ~XUSB_STATUS_INTR_EVENT_MASK;\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t/* Read the Interrupt Status Register.*/\n\tintrstatus = udc->read_fn(udc->addr + XUSB_STATUS_OFFSET);\n\n\t/* Call the handler for the event interrupt.*/\n\tif (intrstatus & XUSB_STATUS_INTR_EVENT_MASK) {\n\t\t/*\n\t\t * Check if there is any action to be done for :\n\t\t * - USB Reset received {XUSB_STATUS_RESET_MASK}\n\t\t * - USB Suspend received {XUSB_STATUS_SUSPEND_MASK}\n\t\t * - USB Resume received {XUSB_STATUS_RESUME_MASK}\n\t\t * - USB Disconnect received {XUSB_STATUS_DISCONNECT_MASK}\n\t\t */\n\t\txudc_startup_handler(udc, intrstatus);\n\t}\n\n\t/* Check the buffer completion interrupts */\n\tif (intrstatus & XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK) {\n\t\t/* Enable Reset, Suspend, Resume and Disconnect  */\n\t\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tier |= XUSB_STATUS_INTR_EVENT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t\tif (intrstatus & XUSB_STATUS_EP0_BUFF1_COMP_MASK)\n\t\t\txudc_ctrl_ep_handler(udc, intrstatus);\n\n\t\tfor (index = 1; index < 8; index++) {\n\t\t\tbufintr = ((intrstatus &\n\t\t\t\t  (XUSB_STATUS_EP1_BUFF1_COMP_MASK <<\n\t\t\t\t  (index - 1))) || (intrstatus &\n\t\t\t\t  (XUSB_STATUS_EP1_BUFF2_COMP_MASK <<\n\t\t\t\t  (index - 1))));\n\t\t\tif (bufintr) {\n\t\t\t\txudc_nonctrl_ep_handler(udc, index,\n\t\t\t\t\t\t\tintrstatus);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n/**\n * xudc_probe - The device probe function for driver initialization.\n * @pdev: pointer to the platform device structure.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource *res;\n\tstruct xusb_udc *udc;\n\tint irq;\n\tint ret;\n\tu32 ier;\n\tu8 *buff;\n\n\tudc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\t/* Create a dummy request for GET_STATUS, SET_ADDRESS */\n\tudc->req = devm_kzalloc(&pdev->dev, sizeof(struct xusb_req),\n\t\t\t\tGFP_KERNEL);\n\tif (!udc->req)\n\t\treturn -ENOMEM;\n\n\tbuff = devm_kzalloc(&pdev->dev, STATUSBUFF_SIZE, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tudc->req->usb_req.buf = buff;\n\n\t/* Map the registers */\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tudc->addr = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(udc->addr))\n\t\treturn PTR_ERR(udc->addr);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_irq(&pdev->dev, irq, xudc_irq, 0,\n\t\t\t       dev_name(&pdev->dev), udc);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"unable to request irq %d\", irq);\n\t\tgoto fail;\n\t}\n\n\tudc->dma_enabled = of_property_read_bool(np, \"xlnx,has-builtin-dma\");\n\n\t/* Setup gadget structure */\n\tudc->gadget.ops = &xusb_udc_ops;\n\tudc->gadget.max_speed = USB_SPEED_HIGH;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->gadget.ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO].ep_usb;\n\tudc->gadget.name = driver_name;\n\n\tudc->clk = devm_clk_get(&pdev->dev, \"s_axi_aclk\");\n\tif (IS_ERR(udc->clk)) {\n\t\tif (PTR_ERR(udc->clk) != -ENOENT) {\n\t\t\tret = PTR_ERR(udc->clk);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Clock framework support is optional, continue on,\n\t\t * anyways if we don't find a matching clock\n\t\t */\n\t\tdev_warn(&pdev->dev, \"s_axi_aclk clock property is not found\\n\");\n\t\tudc->clk = NULL;\n\t}\n\n\tret = clk_prepare_enable(udc->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tspin_lock_init(&udc->lock);\n\n\t/* Check for IP endianness */\n\tudc->write_fn = xudc_write32_be;\n\tudc->read_fn = xudc_read32_be;\n\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, USB_TEST_J);\n\tif ((udc->read_fn(udc->addr + XUSB_TESTMODE_OFFSET))\n\t\t\t!= USB_TEST_J) {\n\t\tudc->write_fn = xudc_write32;\n\t\tudc->read_fn = xudc_read32;\n\t}\n\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, 0);\n\n\txudc_eps_init(udc);\n\n\t/* Set device address to 0.*/\n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\n\tret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\n\tif (ret)\n\t\tgoto err_disable_unprepare_clk;\n\n\tudc->dev = &udc->gadget.dev;\n\n\t/* Enable the interrupts.*/\n\tier = XUSB_STATUS_GLOBAL_INTR_MASK | XUSB_STATUS_INTR_EVENT_MASK |\n\t      XUSB_STATUS_FIFO_BUFF_RDY_MASK | XUSB_STATUS_FIFO_BUFF_FREE_MASK |\n\t      XUSB_STATUS_SETUP_PACKET_MASK |\n\t      XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\tplatform_set_drvdata(pdev, udc);\n\n\tdev_vdbg(&pdev->dev, \"%s at 0x%08X mapped to %p %s\\n\",\n\t\t driver_name, (u32)res->start, udc->addr,\n\t\t udc->dma_enabled ? \"with DMA\" : \"without DMA\");\n\n\treturn 0;\n\nerr_disable_unprepare_clk:\n\tclk_disable_unprepare(udc->clk);\nfail:\n\tdev_err(&pdev->dev, \"probe failed, %d\\n\", ret);\n\treturn ret;\n}\n\n/**\n * xudc_remove - Releases the resources allocated during the initialization.\n * @pdev: pointer to the platform device structure.\n *\n * Return: 0 always\n */\nstatic int xudc_remove(struct platform_device *pdev)\n{\n\tstruct xusb_udc *udc = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\tclk_disable_unprepare(udc->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int xudc_suspend(struct device *dev)\n{\n\tstruct xusb_udc *udc;\n\tu32 crtlreg;\n\tunsigned long flags;\n\n\tudc = dev_get_drvdata(dev);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg &= ~XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tif (udc->driver && udc->driver->suspend)\n\t\tudc->driver->suspend(&udc->gadget);\n\n\tclk_disable(udc->clk);\n\n\treturn 0;\n}\n\nstatic int xudc_resume(struct device *dev)\n{\n\tstruct xusb_udc *udc;\n\tu32 crtlreg;\n\tunsigned long flags;\n\tint ret;\n\n\tudc = dev_get_drvdata(dev);\n\n\tret = clk_enable(udc->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg |= XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n#endif /* CONFIG_PM_SLEEP */\n\nstatic const struct dev_pm_ops xudc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xudc_suspend, xudc_resume)\n};\n\n/* Match table for of_platform binding */\nstatic const struct of_device_id usb_of_match[] = {\n\t{ .compatible = \"xlnx,usb2-device-4.00.a\", },\n\t{ /* end of list */ },\n};\nMODULE_DEVICE_TABLE(of, usb_of_match);\n\nstatic struct platform_driver xudc_driver = {\n\t.driver = {\n\t\t.name = driver_name,\n\t\t.of_match_table = usb_of_match,\n\t\t.pm\t= &xudc_pm_ops,\n\t},\n\t.probe = xudc_probe,\n\t.remove = xudc_remove,\n};\n\nmodule_platform_driver(xudc_driver);\n\nMODULE_DESCRIPTION(\"Xilinx udc driver\");\nMODULE_AUTHOR(\"Xilinx, Inc\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * Xilinx USB peripheral controller driver\n *\n * Copyright (C) 2004 by Thomas Rathbone\n * Copyright (C) 2005 by HP Labs\n * Copyright (C) 2005 by David Brownell\n * Copyright (C) 2010 - 2014 Xilinx, Inc.\n *\n * Some parts of this driver code is based on the driver for at91-series\n * USB peripheral controller (at91_udc.c).\n */\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/of_irq.h>\n#include <linux/prefetch.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n/* Register offsets for the USB device.*/\n#define XUSB_EP0_CONFIG_OFFSET\t\t0x0000  /* EP0 Config Reg Offset */\n#define XUSB_SETUP_PKT_ADDR_OFFSET\t0x0080  /* Setup Packet Address */\n#define XUSB_ADDRESS_OFFSET\t\t0x0100  /* Address Register */\n#define XUSB_CONTROL_OFFSET\t\t0x0104  /* Control Register */\n#define XUSB_STATUS_OFFSET\t\t0x0108  /* Status Register */\n#define XUSB_FRAMENUM_OFFSET\t\t0x010C\t/* Frame Number Register */\n#define XUSB_IER_OFFSET\t\t\t0x0110\t/* Interrupt Enable Register */\n#define XUSB_BUFFREADY_OFFSET\t\t0x0114\t/* Buffer Ready Register */\n#define XUSB_TESTMODE_OFFSET\t\t0x0118\t/* Test Mode Register */\n#define XUSB_DMA_RESET_OFFSET\t\t0x0200  /* DMA Soft Reset Register */\n#define XUSB_DMA_CONTROL_OFFSET\t\t0x0204\t/* DMA Control Register */\n#define XUSB_DMA_DSAR_ADDR_OFFSET\t0x0208\t/* DMA source Address Reg */\n#define XUSB_DMA_DDAR_ADDR_OFFSET\t0x020C\t/* DMA destination Addr Reg */\n#define XUSB_DMA_LENGTH_OFFSET\t\t0x0210\t/* DMA Length Register */\n#define XUSB_DMA_STATUS_OFFSET\t\t0x0214\t/* DMA Status Register */\n\n/* Endpoint Configuration Space offsets */\n#define XUSB_EP_CFGSTATUS_OFFSET\t0x00\t/* Endpoint Config Status  */\n#define XUSB_EP_BUF0COUNT_OFFSET\t0x08\t/* Buffer 0 Count */\n#define XUSB_EP_BUF1COUNT_OFFSET\t0x0C\t/* Buffer 1 Count */\n\n#define XUSB_CONTROL_USB_READY_MASK\t0x80000000 /* USB ready Mask */\n#define XUSB_CONTROL_USB_RMTWAKE_MASK\t0x40000000 /* Remote wake up mask */\n\n/* Interrupt register related masks.*/\n#define XUSB_STATUS_GLOBAL_INTR_MASK\t0x80000000 /* Global Intr Enable */\n#define XUSB_STATUS_DMADONE_MASK\t0x04000000 /* DMA done Mask */\n#define XUSB_STATUS_DMAERR_MASK\t\t0x02000000 /* DMA Error Mask */\n#define XUSB_STATUS_DMABUSY_MASK\t0x80000000 /* DMA Error Mask */\n#define XUSB_STATUS_RESUME_MASK\t\t0x01000000 /* USB Resume Mask */\n#define XUSB_STATUS_RESET_MASK\t\t0x00800000 /* USB Reset Mask */\n#define XUSB_STATUS_SUSPEND_MASK\t0x00400000 /* USB Suspend Mask */\n#define XUSB_STATUS_DISCONNECT_MASK\t0x00200000 /* USB Disconnect Mask */\n#define XUSB_STATUS_FIFO_BUFF_RDY_MASK\t0x00100000 /* FIFO Buff Ready Mask */\n#define XUSB_STATUS_FIFO_BUFF_FREE_MASK\t0x00080000 /* FIFO Buff Free Mask */\n#define XUSB_STATUS_SETUP_PACKET_MASK\t0x00040000 /* Setup packet received */\n#define XUSB_STATUS_EP1_BUFF2_COMP_MASK\t0x00000200 /* EP 1 Buff 2 Processed */\n#define XUSB_STATUS_EP1_BUFF1_COMP_MASK\t0x00000002 /* EP 1 Buff 1 Processed */\n#define XUSB_STATUS_EP0_BUFF2_COMP_MASK\t0x00000100 /* EP 0 Buff 2 Processed */\n#define XUSB_STATUS_EP0_BUFF1_COMP_MASK\t0x00000001 /* EP 0 Buff 1 Processed */\n#define XUSB_STATUS_HIGH_SPEED_MASK\t0x00010000 /* USB Speed Mask */\n/* Suspend,Reset,Suspend and Disconnect Mask */\n#define XUSB_STATUS_INTR_EVENT_MASK\t0x01E00000\n/* Buffers  completion Mask */\n#define XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK\t0x0000FEFF\n/* Mask for buffer 0 and buffer 1 completion for all Endpoints */\n#define XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK\t0x00000101\n#define XUSB_STATUS_EP_BUFF2_SHIFT\t8\t   /* EP buffer offset */\n\n/* Endpoint Configuration Status Register */\n#define XUSB_EP_CFG_VALID_MASK\t\t0x80000000 /* Endpoint Valid bit */\n#define XUSB_EP_CFG_STALL_MASK\t\t0x40000000 /* Endpoint Stall bit */\n#define XUSB_EP_CFG_DATA_TOGGLE_MASK\t0x08000000 /* Endpoint Data toggle */\n\n/* USB device specific global configuration constants.*/\n#define XUSB_MAX_ENDPOINTS\t\t8\t/* Maximum End Points */\n#define XUSB_EP_NUMBER_ZERO\t\t0\t/* End point Zero */\n/* DPRAM is the source address for DMA transfer */\n#define XUSB_DMA_READ_FROM_DPRAM\t0x80000000\n#define XUSB_DMA_DMASR_BUSY\t\t0x80000000 /* DMA busy */\n#define XUSB_DMA_DMASR_ERROR\t\t0x40000000 /* DMA Error */\n/*\n * When this bit is set, the DMA buffer ready bit is set by hardware upon\n * DMA transfer completion.\n */\n#define XUSB_DMA_BRR_CTRL\t\t0x40000000 /* DMA bufready ctrl bit */\n/* Phase States */\n#define SETUP_PHASE\t\t\t0x0000\t/* Setup Phase */\n#define DATA_PHASE\t\t\t0x0001  /* Data Phase */\n#define STATUS_PHASE\t\t\t0x0002  /* Status Phase */\n\n#define EP0_MAX_PACKET\t\t64 /* Endpoint 0 maximum packet length */\n#define STATUSBUFF_SIZE\t\t2  /* Buffer size for GET_STATUS command */\n#define EPNAME_SIZE\t\t4  /* Buffer size for endpoint name */\n\n/* container_of helper macros */\n#define to_udc(g)\t container_of((g), struct xusb_udc, gadget)\n#define to_xusb_ep(ep)\t container_of((ep), struct xusb_ep, ep_usb)\n#define to_xusb_req(req) container_of((req), struct xusb_req, usb_req)\n\n/**\n * struct xusb_req - Xilinx USB device request structure\n * @usb_req: Linux usb request structure\n * @queue: usb device request queue\n * @ep: pointer to xusb_endpoint structure\n */\nstruct xusb_req {\n\tstruct usb_request usb_req;\n\tstruct list_head queue;\n\tstruct xusb_ep *ep;\n};\n\n/**\n * struct xusb_ep - USB end point structure.\n * @ep_usb: usb endpoint instance\n * @queue: endpoint message queue\n * @udc: xilinx usb peripheral driver instance pointer\n * @desc: pointer to the usb endpoint descriptor\n * @rambase: the endpoint buffer address\n * @offset: the endpoint register offset value\n * @name: name of the endpoint\n * @epnumber: endpoint number\n * @maxpacket: maximum packet size the endpoint can store\n * @buffer0count: the size of the packet recieved in the first buffer\n * @buffer1count: the size of the packet received in the second buffer\n * @curbufnum: current buffer of endpoint that will be processed next\n * @buffer0ready: the busy state of first buffer\n * @buffer1ready: the busy state of second buffer\n * @is_in: endpoint direction (IN or OUT)\n * @is_iso: endpoint type(isochronous or non isochronous)\n */\nstruct xusb_ep {\n\tstruct usb_ep ep_usb;\n\tstruct list_head queue;\n\tstruct xusb_udc *udc;\n\tconst struct usb_endpoint_descriptor *desc;\n\tu32  rambase;\n\tu32  offset;\n\tchar name[4];\n\tu16  epnumber;\n\tu16  maxpacket;\n\tu16  buffer0count;\n\tu16  buffer1count;\n\tu8   curbufnum;\n\tbool buffer0ready;\n\tbool buffer1ready;\n\tbool is_in;\n\tbool is_iso;\n};\n\n/**\n * struct xusb_udc -  USB peripheral driver structure\n * @gadget: USB gadget driver instance\n * @ep: an array of endpoint structures\n * @driver: pointer to the usb gadget driver instance\n * @setup: usb_ctrlrequest structure for control requests\n * @req: pointer to dummy request for get status command\n * @dev: pointer to device structure in gadget\n * @usb_state: device in suspended state or not\n * @remote_wkp: remote wakeup enabled by host\n * @setupseqtx: tx status\n * @setupseqrx: rx status\n * @addr: the usb device base address\n * @lock: instance of spinlock\n * @dma_enabled: flag indicating whether the dma is included in the system\n * @clk: pointer to struct clk\n * @read_fn: function pointer to read device registers\n * @write_fn: function pointer to write to device registers\n */\nstruct xusb_udc {\n\tstruct usb_gadget gadget;\n\tstruct xusb_ep ep[8];\n\tstruct usb_gadget_driver *driver;\n\tstruct usb_ctrlrequest setup;\n\tstruct xusb_req *req;\n\tstruct device *dev;\n\tu32 usb_state;\n\tu32 remote_wkp;\n\tu32 setupseqtx;\n\tu32 setupseqrx;\n\tvoid __iomem *addr;\n\tspinlock_t lock;\n\tbool dma_enabled;\n\tstruct clk *clk;\n\n\tunsigned int (*read_fn)(void __iomem *);\n\tvoid (*write_fn)(void __iomem *, u32, u32);\n};\n\n/* Endpoint buffer start addresses in the core */\nstatic u32 rambase[8] = { 0x22, 0x1000, 0x1100, 0x1200, 0x1300, 0x1400, 0x1500,\n\t\t\t  0x1600 };\n\nstatic const char driver_name[] = \"xilinx-udc\";\nstatic const char ep0name[] = \"ep0\";\n\n/* Control endpoint configuration.*/\nstatic const struct usb_endpoint_descriptor config_bulk_out_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize\t\t= cpu_to_le16(EP0_MAX_PACKET),\n};\n\n/**\n * xudc_write32 - little endian write to device registers\n * @addr: base addr of device registers\n * @offset: register offset\n * @val: data to be written\n */\nstatic void xudc_write32(void __iomem *addr, u32 offset, u32 val)\n{\n\tiowrite32(val, addr + offset);\n}\n\n/**\n * xudc_read32 - little endian read from device registers\n * @addr: addr of device register\n * Return: value at addr\n */\nstatic unsigned int xudc_read32(void __iomem *addr)\n{\n\treturn ioread32(addr);\n}\n\n/**\n * xudc_write32_be - big endian write to device registers\n * @addr: base addr of device registers\n * @offset: register offset\n * @val: data to be written\n */\nstatic void xudc_write32_be(void __iomem *addr, u32 offset, u32 val)\n{\n\tiowrite32be(val, addr + offset);\n}\n\n/**\n * xudc_read32_be - big endian read from device registers\n * @addr: addr of device register\n * Return: value at addr\n */\nstatic unsigned int xudc_read32_be(void __iomem *addr)\n{\n\treturn ioread32be(addr);\n}\n\n/**\n * xudc_wrstatus - Sets up the usb device status stages.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_wrstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\n\tu32 epcfgreg;\n\n\tepcfgreg = udc->read_fn(udc->addr + ep0->offset)|\n\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK;\n\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n\tudc->write_fn(udc->addr, ep0->offset + XUSB_EP_BUF0COUNT_OFFSET, 0);\n\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n}\n\n/**\n * xudc_epconfig - Configures the given endpoint.\n * @ep: pointer to the usb device endpoint structure.\n * @udc: pointer to the usb peripheral controller structure.\n *\n * This function configures a specific endpoint with the given configuration\n * data.\n */\nstatic void xudc_epconfig(struct xusb_ep *ep, struct xusb_udc *udc)\n{\n\tu32 epcfgreg;\n\n\t/*\n\t * Configure the end point direction, type, Max Packet Size and the\n\t * EP buffer location.\n\t */\n\tepcfgreg = ((ep->is_in << 29) | (ep->is_iso << 28) |\n\t\t   (ep->ep_usb.maxpacket << 15) | (ep->rambase));\n\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\n\t/* Set the Buffer count and the Buffer ready bits.*/\n\tudc->write_fn(udc->addr, ep->offset + XUSB_EP_BUF0COUNT_OFFSET,\n\t\t      ep->buffer0count);\n\tudc->write_fn(udc->addr, ep->offset + XUSB_EP_BUF1COUNT_OFFSET,\n\t\t      ep->buffer1count);\n\tif (ep->buffer0ready)\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\tif (ep->buffer1ready)\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT));\n}\n\n/**\n * xudc_start_dma - Starts DMA transfer.\n * @ep: pointer to the usb device endpoint structure.\n * @src: DMA source address.\n * @dst: DMA destination address.\n * @length: number of bytes to transfer.\n *\n * Return: 0 on success, error code on failure\n *\n * This function starts DMA transfer by writing to DMA source,\n * destination and lenth registers.\n */\nstatic int xudc_start_dma(struct xusb_ep *ep, dma_addr_t src,\n\t\t\t  dma_addr_t dst, u32 length)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\tint rc = 0;\n\tu32 timeout = 500;\n\tu32 reg;\n\n\t/*\n\t * Set the addresses in the DMA source and\n\t * destination registers and then set the length\n\t * into the DMA length register.\n\t */\n\tudc->write_fn(udc->addr, XUSB_DMA_DSAR_ADDR_OFFSET, src);\n\tudc->write_fn(udc->addr, XUSB_DMA_DDAR_ADDR_OFFSET, dst);\n\tudc->write_fn(udc->addr, XUSB_DMA_LENGTH_OFFSET, length);\n\n\t/*\n\t * Wait till DMA transaction is complete and\n\t * check whether the DMA transaction was\n\t * successful.\n\t */\n\tdo {\n\t\treg = udc->read_fn(udc->addr + XUSB_DMA_STATUS_OFFSET);\n\t\tif (!(reg &  XUSB_DMA_DMASR_BUSY))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We can't sleep here, because it's also called from\n\t\t * interrupt context.\n\t\t */\n\t\ttimeout--;\n\t\tif (!timeout) {\n\t\t\tdev_err(udc->dev, \"DMA timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t} while (1);\n\n\tif ((udc->read_fn(udc->addr + XUSB_DMA_STATUS_OFFSET) &\n\t\t\t  XUSB_DMA_DMASR_ERROR) == XUSB_DMA_DMASR_ERROR){\n\t\tdev_err(udc->dev, \"DMA Error\\n\");\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\n/**\n * xudc_dma_send - Sends IN data using DMA.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n * @buffer: pointer to data to be sent.\n * @length: number of bytes to send.\n *\n * Return: 0 on success, -EAGAIN if no buffer is free and error\n *\t   code on failure.\n *\n * This function sends data using DMA.\n */\nstatic int xudc_dma_send(struct xusb_ep *ep, struct xusb_req *req,\n\t\t\t u8 *buffer, u32 length)\n{\n\tu32 *eprambase;\n\tdma_addr_t src;\n\tdma_addr_t dst;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tsrc = req->usb_req.dma + req->usb_req.actual;\n\tif (req->usb_req.length)\n\t\tdma_sync_single_for_device(udc->dev, src,\n\t\t\t\t\t   length, DMA_TO_DEVICE);\n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t/* Get the Buffer address and copy the transmit data.*/\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tdst = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t      XUSB_EP_BUF0COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | (1 << ep->epnumber));\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t/* Get the Buffer address and copy the transmit data.*/\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase +\n\t\t\t     ep->ep_usb.maxpacket);\n\t\tdst = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t      XUSB_EP_BUF1COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t/* None of ping pong buffers are ready currently .*/\n\t\treturn -EAGAIN;\n\t}\n\n\treturn xudc_start_dma(ep, src, dst, length);\n}\n\n/**\n * xudc_dma_receive - Receives OUT data using DMA.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n * @buffer: pointer to storage buffer of received data.\n * @length: number of bytes to receive.\n *\n * Return: 0 on success, -EAGAIN if no buffer is free and error\n *\t   code on failure.\n *\n * This function receives data using DMA.\n */\nstatic int xudc_dma_receive(struct xusb_ep *ep, struct xusb_req *req,\n\t\t\t    u8 *buffer, u32 length)\n{\n\tu32 *eprambase;\n\tdma_addr_t src;\n\tdma_addr_t dst;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tdst = req->usb_req.dma + req->usb_req.actual;\n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t/* Get the Buffer address and copy the transmit data */\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tsrc = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | XUSB_DMA_READ_FROM_DPRAM |\n\t\t\t      (1 << ep->epnumber));\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t/* Get the Buffer address and copy the transmit data */\n\t\teprambase = (u32 __force *)(udc->addr +\n\t\t\t     ep->rambase + ep->ep_usb.maxpacket);\n\t\tsrc = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | XUSB_DMA_READ_FROM_DPRAM |\n\t\t\t      (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t/* None of the ping-pong buffers are ready currently */\n\t\treturn -EAGAIN;\n\t}\n\n\treturn xudc_start_dma(ep, src, dst, length);\n}\n\n/**\n * xudc_eptxrx - Transmits or receives data to or from an endpoint.\n * @ep: pointer to the usb endpoint configuration structure.\n * @req: pointer to the usb request structure.\n * @bufferptr: pointer to buffer containing the data to be sent.\n * @bufferlen: The number of data bytes to be sent.\n *\n * Return: 0 on success, -EAGAIN if no buffer is free.\n *\n * This function copies the transmit/receive data to/from the end point buffer\n * and enables the buffer for transmission/reception.\n */\nstatic int xudc_eptxrx(struct xusb_ep *ep, struct xusb_req *req,\n\t\t       u8 *bufferptr, u32 bufferlen)\n{\n\tu32 *eprambase;\n\tu32 bytestosend;\n\tint rc = 0;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tbytestosend = bufferlen;\n\tif (udc->dma_enabled) {\n\t\tif (ep->is_in)\n\t\t\trc = xudc_dma_send(ep, req, bufferptr, bufferlen);\n\t\telse\n\t\t\trc = xudc_dma_receive(ep, req, bufferptr, bufferlen);\n\t\treturn rc;\n\t}\n\t/* Put the transmit buffer into the correct ping-pong buffer.*/\n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t/* Get the Buffer address and copy the transmit data.*/\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tif (ep->is_in) {\n\t\t\tmemcpy(eprambase, bufferptr, bytestosend);\n\t\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t\t      XUSB_EP_BUF0COUNT_OFFSET, bufferlen);\n\t\t} else {\n\t\t\tmemcpy(bufferptr, eprambase, bytestosend);\n\t\t}\n\t\t/*\n\t\t * Enable the buffer for transmission.\n\t\t */\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t/* Get the Buffer address and copy the transmit data.*/\n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase +\n\t\t\t     ep->ep_usb.maxpacket);\n\t\tif (ep->is_in) {\n\t\t\tmemcpy(eprambase, bufferptr, bytestosend);\n\t\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t\t      XUSB_EP_BUF1COUNT_OFFSET, bufferlen);\n\t\t} else {\n\t\t\tmemcpy(bufferptr, eprambase, bytestosend);\n\t\t}\n\t\t/*\n\t\t * Enable the buffer for transmission.\n\t\t */\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t/* None of the ping-pong buffers are ready currently */\n\t\treturn -EAGAIN;\n\t}\n\treturn rc;\n}\n\n/**\n * xudc_done - Exeutes the endpoint data transfer completion tasks.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n * @status: Status of the data transfer.\n *\n * Deletes the message from the queue and updates data transfer completion\n * status.\n */\nstatic void xudc_done(struct xusb_ep *ep, struct xusb_req *req, int status)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\n\tlist_del_init(&req->queue);\n\n\tif (req->usb_req.status == -EINPROGRESS)\n\t\treq->usb_req.status = status;\n\telse\n\t\tstatus = req->usb_req.status;\n\n\tif (status && status != -ESHUTDOWN)\n\t\tdev_dbg(udc->dev, \"%s done %p, status %d\\n\",\n\t\t\tep->ep_usb.name, req, status);\n\t/* unmap request if DMA is present*/\n\tif (udc->dma_enabled && ep->epnumber && req->usb_req.length)\n\t\tusb_gadget_unmap_request(&udc->gadget, &req->usb_req,\n\t\t\t\t\t ep->is_in);\n\n\tif (req->usb_req.complete) {\n\t\tspin_unlock(&udc->lock);\n\t\treq->usb_req.complete(&ep->ep_usb, &req->usb_req);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n\n/**\n * xudc_read_fifo - Reads the data from the given endpoint buffer.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n *\n * Return: 0 if request is completed and -EAGAIN if not completed.\n *\n * Pulls OUT packet data from the endpoint buffer.\n */\nstatic int xudc_read_fifo(struct xusb_ep *ep, struct xusb_req *req)\n{\n\tu8 *buf;\n\tu32 is_short, count, bufferspace;\n\tu8 bufoffset;\n\tu8 two_pkts = 0;\n\tint ret;\n\tint retval = -EAGAIN;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tif (ep->buffer0ready && ep->buffer1ready) {\n\t\tdev_dbg(udc->dev, \"Packet NOT ready!\\n\");\n\t\treturn retval;\n\t}\ntop:\n\tif (ep->curbufnum)\n\t\tbufoffset = XUSB_EP_BUF1COUNT_OFFSET;\n\telse\n\t\tbufoffset = XUSB_EP_BUF0COUNT_OFFSET;\n\n\tcount = udc->read_fn(udc->addr + ep->offset + bufoffset);\n\n\tif (!ep->buffer0ready && !ep->buffer1ready)\n\t\ttwo_pkts = 1;\n\n\tbuf = req->usb_req.buf + req->usb_req.actual;\n\tprefetchw(buf);\n\tbufferspace = req->usb_req.length - req->usb_req.actual;\n\tis_short = count < ep->ep_usb.maxpacket;\n\n\tif (unlikely(!bufferspace)) {\n\t\t/*\n\t\t * This happens when the driver's buffer\n\t\t * is smaller than what the host sent.\n\t\t * discard the extra data.\n\t\t */\n\t\tif (req->usb_req.status != -EOVERFLOW)\n\t\t\tdev_dbg(udc->dev, \"%s overflow %d\\n\",\n\t\t\t\tep->ep_usb.name, count);\n\t\treq->usb_req.status = -EOVERFLOW;\n\t\txudc_done(ep, req, -EOVERFLOW);\n\t\treturn 0;\n\t}\n\n\tret = xudc_eptxrx(ep, req, buf, count);\n\tswitch (ret) {\n\tcase 0:\n\t\treq->usb_req.actual += min(count, bufferspace);\n\t\tdev_dbg(udc->dev, \"read %s, %d bytes%s req %p %d/%d\\n\",\n\t\t\tep->ep_usb.name, count, is_short ? \"/S\" : \"\", req,\n\t\t\treq->usb_req.actual, req->usb_req.length);\n\t\tbufferspace -= count;\n\t\t/* Completion */\n\t\tif ((req->usb_req.actual == req->usb_req.length) || is_short) {\n\t\t\tif (udc->dma_enabled && req->usb_req.length)\n\t\t\t\tdma_sync_single_for_cpu(udc->dev,\n\t\t\t\t\t\t\treq->usb_req.dma,\n\t\t\t\t\t\t\treq->usb_req.actual,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\txudc_done(ep, req, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tif (two_pkts) {\n\t\t\ttwo_pkts = 0;\n\t\t\tgoto top;\n\t\t}\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tdev_dbg(udc->dev, \"receive busy\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -ETIMEDOUT:\n\t\t/* DMA error, dequeue the request */\n\t\txudc_done(ep, req, -ECONNRESET);\n\t\tretval = 0;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/**\n * xudc_write_fifo - Writes data into the given endpoint buffer.\n * @ep: pointer to the usb device endpoint structure.\n * @req: pointer to the usb request structure.\n *\n * Return: 0 if request is completed and -EAGAIN if not completed.\n *\n * Loads endpoint buffer for an IN packet.\n */\nstatic int xudc_write_fifo(struct xusb_ep *ep, struct xusb_req *req)\n{\n\tu32 max;\n\tu32 length;\n\tint ret;\n\tint retval = -EAGAIN;\n\tstruct xusb_udc *udc = ep->udc;\n\tint is_last, is_short = 0;\n\tu8 *buf;\n\n\tmax = le16_to_cpu(ep->desc->wMaxPacketSize);\n\tbuf = req->usb_req.buf + req->usb_req.actual;\n\tprefetch(buf);\n\tlength = req->usb_req.length - req->usb_req.actual;\n\tlength = min(length, max);\n\n\tret = xudc_eptxrx(ep, req, buf, length);\n\tswitch (ret) {\n\tcase 0:\n\t\treq->usb_req.actual += length;\n\t\tif (unlikely(length != max)) {\n\t\t\tis_last = is_short = 1;\n\t\t} else {\n\t\t\tif (likely(req->usb_req.length !=\n\t\t\t\t   req->usb_req.actual) || req->usb_req.zero)\n\t\t\t\tis_last = 0;\n\t\t\telse\n\t\t\t\tis_last = 1;\n\t\t}\n\t\tdev_dbg(udc->dev, \"%s: wrote %s %d bytes%s%s %d left %p\\n\",\n\t\t\t__func__, ep->ep_usb.name, length, is_last ? \"/L\" : \"\",\n\t\t\tis_short ? \"/S\" : \"\",\n\t\t\treq->usb_req.length - req->usb_req.actual, req);\n\t\t/* completion */\n\t\tif (is_last) {\n\t\t\txudc_done(ep, req, 0);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tdev_dbg(udc->dev, \"Send busy\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -ETIMEDOUT:\n\t\t/* DMA error, dequeue the request */\n\t\txudc_done(ep, req, -ECONNRESET);\n\t\tretval = 0;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/**\n * xudc_nuke - Cleans up the data transfer message list.\n * @ep: pointer to the usb device endpoint structure.\n * @status: Status of the data transfer.\n */\nstatic void xudc_nuke(struct xusb_ep *ep, int status)\n{\n\tstruct xusb_req *req;\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_first_entry(&ep->queue, struct xusb_req, queue);\n\t\txudc_done(ep, req, status);\n\t}\n}\n\n/**\n * xudc_ep_set_halt - Stalls/unstalls the given endpoint.\n * @_ep: pointer to the usb device endpoint structure.\n * @value: value to indicate stall/unstall.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct xusb_ep *ep = to_xusb_ep(_ep);\n\tstruct xusb_udc *udc;\n\tunsigned long flags;\n\tu32 epcfgreg;\n\n\tif (!_ep || (!ep->desc && ep->epnumber)) {\n\t\tpr_debug(\"%s: bad ep or descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tudc = ep->udc;\n\n\tif (ep->is_in && (!list_empty(&ep->queue)) && value) {\n\t\tdev_dbg(udc->dev, \"requests pending can't halt\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ep->buffer0ready || ep->buffer1ready) {\n\t\tdev_dbg(udc->dev, \"HW buffers busy can't halt\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (value) {\n\t\t/* Stall the device.*/\n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t} else {\n\t\t/* Unstall the device.*/\n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\tif (ep->epnumber) {\n\t\t\t/* Reset the toggle bit.*/\n\t\t\tepcfgreg = udc->read_fn(ep->udc->addr + ep->offset);\n\t\t\tepcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n/**\n * __xudc_ep_enable - Enables the given endpoint.\n * @ep: pointer to the xusb endpoint structure.\n * @desc: pointer to usb endpoint descriptor.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int __xudc_ep_enable(struct xusb_ep *ep,\n\t\t\t    const struct usb_endpoint_descriptor *desc)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\tu32 tmp;\n\tu32 epcfg;\n\tu32 ier;\n\tu16 maxpacket;\n\n\tep->is_in = ((desc->bEndpointAddress & USB_DIR_IN) != 0);\n\t/* Bit 3...0:endpoint number */\n\tep->epnumber = (desc->bEndpointAddress & 0x0f);\n\tep->desc = desc;\n\tep->ep_usb.desc = desc;\n\ttmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n\tep->ep_usb.maxpacket = maxpacket = le16_to_cpu(desc->wMaxPacketSize);\n\n\tswitch (tmp) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tdev_dbg(udc->dev, \"only one control endpoint\\n\");\n\t\t/* NON- ISO */\n\t\tep->is_iso = 0;\n\t\treturn -EINVAL;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t/* NON- ISO */\n\t\tep->is_iso = 0;\n\t\tif (maxpacket > 64) {\n\t\t\tdev_dbg(udc->dev, \"bogus maxpacket %d\\n\", maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\t/* NON- ISO */\n\t\tep->is_iso = 0;\n\t\tif (!(is_power_of_2(maxpacket) && maxpacket >= 8 &&\n\t\t\t\tmaxpacket <= 512)) {\n\t\t\tdev_dbg(udc->dev, \"bogus maxpacket %d\\n\", maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t/* ISO */\n\t\tep->is_iso = 1;\n\t\tbreak;\n\t}\n\n\tep->buffer0ready = false;\n\tep->buffer1ready = false;\n\tep->curbufnum = 0;\n\tep->rambase = rambase[ep->epnumber];\n\txudc_epconfig(ep, udc);\n\n\tdev_dbg(udc->dev, \"Enable Endpoint %d max pkt is %d\\n\",\n\t\tep->epnumber, maxpacket);\n\n\t/* Enable the End point.*/\n\tepcfg = udc->read_fn(udc->addr + ep->offset);\n\tepcfg |= XUSB_EP_CFG_VALID_MASK;\n\tudc->write_fn(udc->addr, ep->offset, epcfg);\n\tif (ep->epnumber)\n\t\tep->rambase <<= 2;\n\n\t/* Enable buffer completion interrupts for endpoint */\n\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\tier |= (XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK << ep->epnumber);\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t/* for OUT endpoint set buffers ready to receive */\n\tif (ep->epnumber && !ep->is_in) {\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\t\tep->buffer0ready = true;\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t     (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = true;\n\t}\n\n\treturn 0;\n}\n\n/**\n * xudc_ep_enable - Enables the given endpoint.\n * @_ep: pointer to the usb endpoint structure.\n * @desc: pointer to usb endpoint descriptor.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_enable(struct usb_ep *_ep,\n\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct xusb_ep *ep;\n\tstruct xusb_udc *udc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\n\t\tpr_debug(\"%s: bad ep or descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = to_xusb_ep(_ep);\n\tudc = ep->udc;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"bogus device state\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tret = __xudc_ep_enable(ep, desc);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\n/**\n * xudc_ep_disable - Disables the given endpoint.\n * @_ep: pointer to the usb endpoint structure.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_disable(struct usb_ep *_ep)\n{\n\tstruct xusb_ep *ep;\n\tunsigned long flags;\n\tu32 epcfg;\n\tstruct xusb_udc *udc;\n\n\tif (!_ep) {\n\t\tpr_debug(\"%s: invalid ep\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = to_xusb_ep(_ep);\n\tudc = ep->udc;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\txudc_nuke(ep, -ESHUTDOWN);\n\n\t/* Restore the endpoint's pristine config */\n\tep->desc = NULL;\n\tep->ep_usb.desc = NULL;\n\n\tdev_dbg(udc->dev, \"USB Ep %d disable\\n \", ep->epnumber);\n\t/* Disable the endpoint.*/\n\tepcfg = udc->read_fn(udc->addr + ep->offset);\n\tepcfg &= ~XUSB_EP_CFG_VALID_MASK;\n\tudc->write_fn(udc->addr, ep->offset, epcfg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n/**\n * xudc_ep_alloc_request - Initializes the request queue.\n * @_ep: pointer to the usb endpoint structure.\n * @gfp_flags: Flags related to the request call.\n *\n * Return: pointer to request structure on success and a NULL on failure.\n */\nstatic struct usb_request *xudc_ep_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct xusb_ep *ep = to_xusb_ep(_ep);\n\tstruct xusb_req *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->ep = ep;\n\tINIT_LIST_HEAD(&req->queue);\n\treturn &req->usb_req;\n}\n\n/**\n * xudc_free_request - Releases the request from queue.\n * @_ep: pointer to the usb device endpoint structure.\n * @_req: pointer to the usb request structure.\n */\nstatic void xudc_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct xusb_req *req = to_xusb_req(_req);\n\n\tkfree(req);\n}\n\n/**\n * __xudc_ep0_queue - Adds the request to endpoint 0 queue.\n * @ep0: pointer to the xusb endpoint 0 structure.\n * @req: pointer to the xusb request structure.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int __xudc_ep0_queue(struct xusb_ep *ep0, struct xusb_req *req)\n{\n\tstruct xusb_udc *udc = ep0->udc;\n\tu32 length;\n\tu8 *corebuf;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"%s, bogus device state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!list_empty(&ep0->queue)) {\n\t\tdev_dbg(udc->dev, \"%s:ep0 busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\treq->usb_req.status = -EINPROGRESS;\n\treq->usb_req.actual = 0;\n\n\tlist_add_tail(&req->queue, &ep0->queue);\n\n\tif (udc->setup.bRequestType & USB_DIR_IN) {\n\t\tprefetch(req->usb_req.buf);\n\t\tlength = req->usb_req.length;\n\t\tcorebuf = (void __force *) ((ep0->rambase << 2) +\n\t\t\t   udc->addr);\n\t\tlength = req->usb_req.actual = min_t(u32, length,\n\t\t\t\t\t\t     EP0_MAX_PACKET);\n\t\tmemcpy(corebuf, req->usb_req.buf, length);\n\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t} else {\n\t\tif (udc->setup.wLength) {\n\t\t\t/* Enable EP0 buffer to receive data */\n\t\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, 0);\n\t\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\t} else {\n\t\t\txudc_wrstatus(udc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * xudc_ep0_queue - Adds the request to endpoint 0 queue.\n * @_ep: pointer to the usb endpoint 0 structure.\n * @_req: pointer to the usb request structure.\n * @gfp_flags: Flags related to the request call.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep0_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t  gfp_t gfp_flags)\n{\n\tstruct xusb_req *req\t= to_xusb_req(_req);\n\tstruct xusb_ep\t*ep0\t= to_xusb_ep(_ep);\n\tstruct xusb_udc *udc\t= ep0->udc;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tret = __xudc_ep0_queue(ep0, req);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\n/**\n * xudc_ep_queue - Adds the request to endpoint queue.\n * @_ep: pointer to the usb endpoint structure.\n * @_req: pointer to the usb request structure.\n * @gfp_flags: Flags related to the request call.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xusb_req *req = to_xusb_req(_req);\n\tstruct xusb_ep\t*ep  = to_xusb_ep(_ep);\n\tstruct xusb_udc *udc = ep->udc;\n\tint  ret;\n\tunsigned long flags;\n\n\tif (!ep->desc) {\n\t\tdev_dbg(udc->dev, \"%s: queuing request to disabled %s\\n\",\n\t\t\t__func__, ep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"%s, bogus device state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tif (udc->dma_enabled) {\n\t\tret = usb_gadget_map_request(&udc->gadget, &req->usb_req,\n\t\t\t\t\t     ep->is_in);\n\t\tif (ret) {\n\t\t\tdev_dbg(udc->dev, \"gadget_map failed ep%d\\n\",\n\t\t\t\tep->epnumber);\n\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (list_empty(&ep->queue)) {\n\t\tif (ep->is_in) {\n\t\t\tdev_dbg(udc->dev, \"xudc_write_fifo from ep_queue\\n\");\n\t\t\tif (!xudc_write_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t} else {\n\t\t\tdev_dbg(udc->dev, \"xudc_read_fifo from ep_queue\\n\");\n\t\t\tif (!xudc_read_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t}\n\t}\n\n\tif (req != NULL)\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n/**\n * xudc_ep_dequeue - Removes the request from the queue.\n * @_ep: pointer to the usb device endpoint structure.\n * @_req: pointer to the usb request structure.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct xusb_ep *ep\t= to_xusb_ep(_ep);\n\tstruct xusb_req *req\t= to_xusb_req(_req);\n\tstruct xusb_udc *udc\t= ep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t/* Make sure it's actually queued on this endpoint */\n\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\tif (&req->usb_req == _req)\n\t\t\tbreak;\n\t}\n\tif (&req->usb_req != _req) {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\txudc_done(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n/**\n * xudc_ep0_enable - Enables the given endpoint.\n * @ep: pointer to the usb endpoint structure.\n * @desc: pointer to usb endpoint descriptor.\n *\n * Return: error always.\n *\n * endpoint 0 enable should not be called by gadget layer.\n */\nstatic int xudc_ep0_enable(struct usb_ep *ep,\n\t\t\t   const struct usb_endpoint_descriptor *desc)\n{\n\treturn -EINVAL;\n}\n\n/**\n * xudc_ep0_disable - Disables the given endpoint.\n * @ep: pointer to the usb endpoint structure.\n *\n * Return: error always.\n *\n * endpoint 0 disable should not be called by gadget layer.\n */\nstatic int xudc_ep0_disable(struct usb_ep *ep)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct usb_ep_ops xusb_ep0_ops = {\n\t.enable\t\t= xudc_ep0_enable,\n\t.disable\t= xudc_ep0_disable,\n\t.alloc_request\t= xudc_ep_alloc_request,\n\t.free_request\t= xudc_free_request,\n\t.queue\t\t= xudc_ep0_queue,\n\t.dequeue\t= xudc_ep_dequeue,\n\t.set_halt\t= xudc_ep_set_halt,\n};\n\nstatic const struct usb_ep_ops xusb_ep_ops = {\n\t.enable\t\t= xudc_ep_enable,\n\t.disable\t= xudc_ep_disable,\n\t.alloc_request\t= xudc_ep_alloc_request,\n\t.free_request\t= xudc_free_request,\n\t.queue\t\t= xudc_ep_queue,\n\t.dequeue\t= xudc_ep_dequeue,\n\t.set_halt\t= xudc_ep_set_halt,\n};\n\n/**\n * xudc_get_frame - Reads the current usb frame number.\n * @gadget: pointer to the usb gadget structure.\n *\n * Return: current frame number for success and error value on failure.\n */\nstatic int xudc_get_frame(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc;\n\tint frame;\n\n\tif (!gadget)\n\t\treturn -ENODEV;\n\n\tudc = to_udc(gadget);\n\tframe = udc->read_fn(udc->addr + XUSB_FRAMENUM_OFFSET);\n\treturn frame;\n}\n\n/**\n * xudc_wakeup - Send remote wakeup signal to host\n * @gadget: pointer to the usb gadget structure.\n *\n * Return: 0 on success and error on failure\n */\nstatic int xudc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tu32 crtlreg;\n\tint status = -EINVAL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t/* Remote wake up not enabled by host */\n\tif (!udc->remote_wkp)\n\t\tgoto done;\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg |= XUSB_CONTROL_USB_RMTWAKE_MASK;\n\t/* set remote wake up bit */\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\t/*\n\t * wait for a while and reset remote wake up bit since this bit\n\t * is not cleared by HW after sending remote wakeup to host.\n\t */\n\tmdelay(2);\n\n\tcrtlreg &= ~XUSB_CONTROL_USB_RMTWAKE_MASK;\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\tstatus = 0;\ndone:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn status;\n}\n\n/**\n * xudc_pullup - start/stop USB traffic\n * @gadget: pointer to the usb gadget structure.\n * @is_on: flag to start or stop\n *\n * Return: 0 always\n *\n * This function starts/stops SIE engine of IP based on is_on.\n */\nstatic int xudc_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\tu32 crtlreg;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tif (is_on)\n\t\tcrtlreg |= XUSB_CONTROL_USB_READY_MASK;\n\telse\n\t\tcrtlreg &= ~XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n/**\n * xudc_eps_init - initialize endpoints.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_eps_init(struct xusb_udc *udc)\n{\n\tu32 ep_number;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\n\tfor (ep_number = 0; ep_number < XUSB_MAX_ENDPOINTS; ep_number++) {\n\t\tstruct xusb_ep *ep = &udc->ep[ep_number];\n\n\t\tif (ep_number) {\n\t\t\tlist_add_tail(&ep->ep_usb.ep_list,\n\t\t\t\t      &udc->gadget.ep_list);\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep_usb,\n\t\t\t\t\t\t  (unsigned short) ~0);\n\t\t\tsnprintf(ep->name, EPNAME_SIZE, \"ep%d\", ep_number);\n\t\t\tep->ep_usb.name = ep->name;\n\t\t\tep->ep_usb.ops = &xusb_ep_ops;\n\n\t\t\tep->ep_usb.caps.type_iso = true;\n\t\t\tep->ep_usb.caps.type_bulk = true;\n\t\t\tep->ep_usb.caps.type_int = true;\n\t\t} else {\n\t\t\tep->ep_usb.name = ep0name;\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep_usb, EP0_MAX_PACKET);\n\t\t\tep->ep_usb.ops = &xusb_ep0_ops;\n\n\t\t\tep->ep_usb.caps.type_control = true;\n\t\t}\n\n\t\tep->ep_usb.caps.dir_in = true;\n\t\tep->ep_usb.caps.dir_out = true;\n\n\t\tep->udc = udc;\n\t\tep->epnumber = ep_number;\n\t\tep->desc = NULL;\n\t\t/*\n\t\t * The configuration register address offset between\n\t\t * each endpoint is 0x10.\n\t\t */\n\t\tep->offset = XUSB_EP0_CONFIG_OFFSET + (ep_number * 0x10);\n\t\tep->is_in = 0;\n\t\tep->is_iso = 0;\n\t\tep->maxpacket = 0;\n\t\txudc_epconfig(ep, udc);\n\n\t\t/* Initialize one queue per endpoint */\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t}\n}\n\n/**\n * xudc_stop_activity - Stops any further activity on the device.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_stop_activity(struct xusb_udc *udc)\n{\n\tint i;\n\tstruct xusb_ep *ep;\n\n\tfor (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\txudc_nuke(ep, -ESHUTDOWN);\n\t}\n}\n\n/**\n * xudc_start - Starts the device.\n * @gadget: pointer to the usb gadget structure\n * @driver: pointer to gadget driver structure\n *\n * Return: zero on success and error on failure\n */\nstatic int xudc_start(struct usb_gadget *gadget,\n\t\t      struct usb_gadget_driver *driver)\n{\n\tstruct xusb_udc *udc\t= to_udc(gadget);\n\tstruct xusb_ep *ep0\t= &udc->ep[XUSB_EP_NUMBER_ZERO];\n\tconst struct usb_endpoint_descriptor *desc = &config_bulk_out_desc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (udc->driver) {\n\t\tdev_err(udc->dev, \"%s is already bound to %s\\n\",\n\t\t\tudc->gadget.name, udc->driver->driver.name);\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t/* hook up the driver */\n\tudc->driver = driver;\n\tudc->gadget.speed = driver->max_speed;\n\n\t/* Enable the control endpoint. */\n\tret = __xudc_ep_enable(ep0, desc);\n\n\t/* Set device address and remote wakeup to 0 */\n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\tudc->remote_wkp = 0;\nerr:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn ret;\n}\n\n/**\n * xudc_stop - stops the device.\n * @gadget: pointer to the usb gadget structure\n *\n * Return: zero always\n */\nstatic int xudc_stop(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->driver = NULL;\n\n\t/* Set device address and remote wakeup to 0 */\n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\tudc->remote_wkp = 0;\n\n\txudc_stop_activity(udc);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops xusb_udc_ops = {\n\t.get_frame\t= xudc_get_frame,\n\t.wakeup\t\t= xudc_wakeup,\n\t.pullup\t\t= xudc_pullup,\n\t.udc_start\t= xudc_start,\n\t.udc_stop\t= xudc_stop,\n};\n\n/**\n * xudc_clear_stall_all_ep - clears stall of every endpoint.\n * @udc: pointer to the udc structure.\n */\nstatic void xudc_clear_stall_all_ep(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep;\n\tu32 epcfgreg;\n\tint i;\n\n\tfor (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\tif (ep->epnumber) {\n\t\t\t/* Reset the toggle bit.*/\n\t\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\t\tepcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\t}\n\t}\n}\n\n/**\n * xudc_startup_handler - The usb device controller interrupt handler.\n * @udc: pointer to the udc structure.\n * @intrstatus: The mask value containing the interrupt sources.\n *\n * This function handles the RESET,SUSPEND,RESUME and DISCONNECT interrupts.\n */\nstatic void xudc_startup_handler(struct xusb_udc *udc, u32 intrstatus)\n{\n\tu32 intrreg;\n\n\tif (intrstatus & XUSB_STATUS_RESET_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Reset\\n\");\n\n\t\tif (intrstatus & XUSB_STATUS_HIGH_SPEED_MASK)\n\t\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t\telse\n\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\n\t\txudc_stop_activity(udc);\n\t\txudc_clear_stall_all_ep(udc);\n\t\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, 0);\n\n\t\t/* Set device address and remote wakeup to 0 */\n\t\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\t\tudc->remote_wkp = 0;\n\n\t\t/* Enable the suspend, resume and disconnect */\n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_SUSPEND_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\t}\n\tif (intrstatus & XUSB_STATUS_SUSPEND_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Suspend\\n\");\n\n\t\t/* Enable the reset, resume and disconnect */\n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tudc->usb_state = USB_STATE_SUSPENDED;\n\n\t\tif (udc->driver->suspend) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\tif (intrstatus & XUSB_STATUS_RESUME_MASK) {\n\t\tbool condition = (udc->usb_state != USB_STATE_SUSPENDED);\n\n\t\tdev_WARN_ONCE(udc->dev, condition,\n\t\t\t\t\"Resume IRQ while not suspended\\n\");\n\n\t\tdev_dbg(udc->dev, \"Resume\\n\");\n\n\t\t/* Enable the reset, suspend and disconnect */\n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_SUSPEND_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tudc->usb_state = 0;\n\n\t\tif (udc->driver->resume) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\tif (intrstatus & XUSB_STATUS_DISCONNECT_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Disconnect\\n\");\n\n\t\t/* Enable the reset, resume and suspend */\n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_SUSPEND_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tif (udc->driver && udc->driver->disconnect) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->disconnect(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n}\n\n/**\n * xudc_ep0_stall - Stall endpoint zero.\n * @udc: pointer to the udc structure.\n *\n * This function stalls endpoint zero.\n */\nstatic void xudc_ep0_stall(struct xusb_udc *udc)\n{\n\tu32 epcfgreg;\n\tstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\n\n\tepcfgreg = udc->read_fn(udc->addr + ep0->offset);\n\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n}\n\n/**\n * xudc_setaddress - executes SET_ADDRESS command\n * @udc: pointer to the udc structure.\n *\n * This function executes USB SET_ADDRESS command\n */\nstatic void xudc_setaddress(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tint ret;\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"Can't respond to SET ADDRESS request\\n\");\n\txudc_ep0_stall(udc);\n}\n\n/**\n * xudc_getstatus - executes GET_STATUS command\n * @udc: pointer to the udc structure.\n *\n * This function executes USB GET_STATUS command\n */\nstatic void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\t/* Get device status */\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}\n\n/**\n * xudc_set_clear_feature - Executes the set feature and clear feature commands.\n * @udc: pointer to the usb device controller structure.\n *\n * Processes the SET_FEATURE and CLEAR_FEATURE commands.\n */\nstatic void xudc_set_clear_feature(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu8 endpoint;\n\tu8 outinbit;\n\tu32 epcfgreg;\n\tint flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0);\n\tint ret;\n\n\tswitch (udc->setup.bRequestType) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (udc->setup.wValue) {\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t/*\n\t\t\t * The Test Mode will be executed\n\t\t\t * after the status phase.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tif (flag)\n\t\t\t\tudc->remote_wkp = 1;\n\t\t\telse\n\t\t\t\tudc->remote_wkp = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txudc_ep0_stall(udc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (!udc->setup.wValue) {\n\t\t\tendpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\tif (endpoint >= XUSB_MAX_ENDPOINTS) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget_ep = &udc->ep[endpoint];\n\t\t\toutinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK;\n\t\t\toutinbit = outinbit >> 7;\n\n\t\t\t/* Make sure direction matches.*/\n\t\t\tif (outinbit != target_ep->is_in) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\t\tif (!endpoint) {\n\t\t\t\t/* Clear the stall.*/\n\t\t\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t      target_ep->offset, epcfgreg);\n\t\t\t} else {\n\t\t\t\tif (flag) {\n\t\t\t\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t} else {\n\t\t\t\t\t/* Unstall the endpoint.*/\n\t\t\t\t\tepcfgreg &= ~(XUSB_EP_CFG_STALL_MASK |\n\t\t\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK);\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\txudc_ep0_stall(udc);\n\t\treturn;\n\t}\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"Can't respond to SET/CLEAR FEATURE\\n\");\n\txudc_ep0_stall(udc);\n}\n\n/**\n * xudc_handle_setup - Processes the setup packet.\n * @udc: pointer to the usb device controller structure.\n *\n * Process setup packet and delegate to gadget layer.\n */\nstatic void xudc_handle_setup(struct xusb_udc *udc)\n\t__must_hold(&udc->lock)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct usb_ctrlrequest setup;\n\tu32 *ep0rambase;\n\n\t/* Load up the chapter 9 command buffer.*/\n\tep0rambase = (u32 __force *) (udc->addr + XUSB_SETUP_PKT_ADDR_OFFSET);\n\tmemcpy(&setup, ep0rambase, 8);\n\n\tudc->setup = setup;\n\tudc->setup.wValue = cpu_to_le16(setup.wValue);\n\tudc->setup.wIndex = cpu_to_le16(setup.wIndex);\n\tudc->setup.wLength = cpu_to_le16(setup.wLength);\n\n\t/* Clear previous requests */\n\txudc_nuke(ep0, -ECONNRESET);\n\n\tif (udc->setup.bRequestType & USB_DIR_IN) {\n\t\t/* Execute the get command.*/\n\t\tudc->setupseqrx = STATUS_PHASE;\n\t\tudc->setupseqtx = DATA_PHASE;\n\t} else {\n\t\t/* Execute the put command.*/\n\t\tudc->setupseqrx = DATA_PHASE;\n\t\tudc->setupseqtx = STATUS_PHASE;\n\t}\n\n\tswitch (udc->setup.bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\t/* Data+Status phase form udc */\n\t\tif ((udc->setup.bRequestType &\n\t\t\t\t(USB_DIR_IN | USB_TYPE_MASK)) !=\n\t\t\t\t(USB_DIR_IN | USB_TYPE_STANDARD))\n\t\t\tbreak;\n\t\txudc_getstatus(udc);\n\t\treturn;\n\tcase USB_REQ_SET_ADDRESS:\n\t\t/* Status phase from udc */\n\t\tif (udc->setup.bRequestType != (USB_DIR_OUT |\n\t\t\t\tUSB_TYPE_STANDARD | USB_RECIP_DEVICE))\n\t\t\tbreak;\n\t\txudc_setaddress(udc);\n\t\treturn;\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\t/* Requests with no data phase, status phase from udc */\n\t\tif ((udc->setup.bRequestType & USB_TYPE_MASK)\n\t\t\t\t!= USB_TYPE_STANDARD)\n\t\t\tbreak;\n\t\txudc_set_clear_feature(udc);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock(&udc->lock);\n\tif (udc->driver->setup(&udc->gadget, &setup) < 0)\n\t\txudc_ep0_stall(udc);\n\tspin_lock(&udc->lock);\n}\n\n/**\n * xudc_ep0_out - Processes the endpoint 0 OUT token.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_ep0_out(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct xusb_req *req;\n\tu8 *ep0rambase;\n\tunsigned int bytes_to_rx;\n\tvoid *buffer;\n\n\treq = list_first_entry(&ep0->queue, struct xusb_req, queue);\n\n\tswitch (udc->setupseqrx) {\n\tcase STATUS_PHASE:\n\t\t/*\n\t\t * This resets both state machines for the next\n\t\t * Setup packet.\n\t\t */\n\t\tudc->setupseqrx = SETUP_PHASE;\n\t\tudc->setupseqtx = SETUP_PHASE;\n\t\treq->usb_req.actual = req->usb_req.length;\n\t\txudc_done(ep0, req, 0);\n\t\tbreak;\n\tcase DATA_PHASE:\n\t\tbytes_to_rx = udc->read_fn(udc->addr +\n\t\t\t\t\t   XUSB_EP_BUF0COUNT_OFFSET);\n\t\t/* Copy the data to be received from the DPRAM. */\n\t\tep0rambase = (u8 __force *) (udc->addr +\n\t\t\t     (ep0->rambase << 2));\n\t\tbuffer = req->usb_req.buf + req->usb_req.actual;\n\t\treq->usb_req.actual = req->usb_req.actual + bytes_to_rx;\n\t\tmemcpy(buffer, ep0rambase, bytes_to_rx);\n\n\t\tif (req->usb_req.length == req->usb_req.actual) {\n\t\t\t/* Data transfer completed get ready for Status stage */\n\t\t\txudc_wrstatus(udc);\n\t\t} else {\n\t\t\t/* Enable EP0 buffer to receive data */\n\t\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, 0);\n\t\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * xudc_ep0_in - Processes the endpoint 0 IN token.\n * @udc: pointer to the usb device controller structure.\n */\nstatic void xudc_ep0_in(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct xusb_req *req;\n\tunsigned int bytes_to_tx;\n\tvoid *buffer;\n\tu32 epcfgreg;\n\tu16 count = 0;\n\tu16 length;\n\tu8 *ep0rambase;\n\tu8 test_mode = udc->setup.wIndex >> 8;\n\n\treq = list_first_entry(&ep0->queue, struct xusb_req, queue);\n\tbytes_to_tx = req->usb_req.length - req->usb_req.actual;\n\n\tswitch (udc->setupseqtx) {\n\tcase STATUS_PHASE:\n\t\tswitch (udc->setup.bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\t/* Set the address of the device.*/\n\t\t\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET,\n\t\t\t\t      udc->setup.wValue);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tif (udc->setup.bRequestType ==\n\t\t\t\t\tUSB_RECIP_DEVICE) {\n\t\t\t\tif (udc->setup.wValue ==\n\t\t\t\t\t\tUSB_DEVICE_TEST_MODE)\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      XUSB_TESTMODE_OFFSET,\n\t\t\t\t\t\t      test_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treq->usb_req.actual = req->usb_req.length;\n\t\txudc_done(ep0, req, 0);\n\t\tbreak;\n\tcase DATA_PHASE:\n\t\tif (!bytes_to_tx) {\n\t\t\t/*\n\t\t\t * We're done with data transfer, next\n\t\t\t * will be zero length OUT with data toggle of\n\t\t\t * 1. Setup data_toggle.\n\t\t\t */\n\t\t\tepcfgreg = udc->read_fn(udc->addr + ep0->offset);\n\t\t\tepcfgreg |= XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n\t\t\tudc->setupseqtx = STATUS_PHASE;\n\t\t} else {\n\t\t\tlength = count = min_t(u32, bytes_to_tx,\n\t\t\t\t\t       EP0_MAX_PACKET);\n\t\t\t/* Copy the data to be transmitted into the DPRAM. */\n\t\t\tep0rambase = (u8 __force *) (udc->addr +\n\t\t\t\t     (ep0->rambase << 2));\n\t\t\tbuffer = req->usb_req.buf + req->usb_req.actual;\n\t\t\treq->usb_req.actual = req->usb_req.actual + length;\n\t\t\tmemcpy(ep0rambase, buffer, length);\n\t\t}\n\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, count);\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * xudc_ctrl_ep_handler - Endpoint 0 interrupt handler.\n * @udc: pointer to the udc structure.\n * @intrstatus:\tIt's the mask value for the interrupt sources on endpoint 0.\n *\n * Processes the commands received during enumeration phase.\n */\nstatic void xudc_ctrl_ep_handler(struct xusb_udc *udc, u32 intrstatus)\n{\n\n\tif (intrstatus & XUSB_STATUS_SETUP_PACKET_MASK) {\n\t\txudc_handle_setup(udc);\n\t} else {\n\t\tif (intrstatus & XUSB_STATUS_FIFO_BUFF_RDY_MASK)\n\t\t\txudc_ep0_out(udc);\n\t\telse if (intrstatus & XUSB_STATUS_FIFO_BUFF_FREE_MASK)\n\t\t\txudc_ep0_in(udc);\n\t}\n}\n\n/**\n * xudc_nonctrl_ep_handler - Non control endpoint interrupt handler.\n * @udc: pointer to the udc structure.\n * @epnum: End point number for which the interrupt is to be processed\n * @intrstatus:\tmask value for interrupt sources of endpoints other\n *\t\tthan endpoint 0.\n *\n * Processes the buffer completion interrupts.\n */\nstatic void xudc_nonctrl_ep_handler(struct xusb_udc *udc, u8 epnum,\n\t\t\t\t    u32 intrstatus)\n{\n\n\tstruct xusb_req *req;\n\tstruct xusb_ep *ep;\n\n\tep = &udc->ep[epnum];\n\t/* Process the End point interrupts.*/\n\tif (intrstatus & (XUSB_STATUS_EP0_BUFF1_COMP_MASK << epnum))\n\t\tep->buffer0ready = 0;\n\tif (intrstatus & (XUSB_STATUS_EP0_BUFF2_COMP_MASK << epnum))\n\t\tep->buffer1ready = false;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\n\treq = list_first_entry(&ep->queue, struct xusb_req, queue);\n\n\tif (ep->is_in)\n\t\txudc_write_fifo(ep, req);\n\telse\n\t\txudc_read_fifo(ep, req);\n}\n\n/**\n * xudc_irq - The main interrupt handler.\n * @irq: The interrupt number.\n * @_udc: pointer to the usb device controller structure.\n *\n * Return: IRQ_HANDLED after the interrupt is handled.\n */\nstatic irqreturn_t xudc_irq(int irq, void *_udc)\n{\n\tstruct xusb_udc *udc = _udc;\n\tu32 intrstatus;\n\tu32 ier;\n\tu8 index;\n\tu32 bufintr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t/*\n\t * Event interrupts are level sensitive hence first disable\n\t * IER, read ISR and figure out active interrupts.\n\t */\n\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\tier &= ~XUSB_STATUS_INTR_EVENT_MASK;\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t/* Read the Interrupt Status Register.*/\n\tintrstatus = udc->read_fn(udc->addr + XUSB_STATUS_OFFSET);\n\n\t/* Call the handler for the event interrupt.*/\n\tif (intrstatus & XUSB_STATUS_INTR_EVENT_MASK) {\n\t\t/*\n\t\t * Check if there is any action to be done for :\n\t\t * - USB Reset received {XUSB_STATUS_RESET_MASK}\n\t\t * - USB Suspend received {XUSB_STATUS_SUSPEND_MASK}\n\t\t * - USB Resume received {XUSB_STATUS_RESUME_MASK}\n\t\t * - USB Disconnect received {XUSB_STATUS_DISCONNECT_MASK}\n\t\t */\n\t\txudc_startup_handler(udc, intrstatus);\n\t}\n\n\t/* Check the buffer completion interrupts */\n\tif (intrstatus & XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK) {\n\t\t/* Enable Reset, Suspend, Resume and Disconnect  */\n\t\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tier |= XUSB_STATUS_INTR_EVENT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t\tif (intrstatus & XUSB_STATUS_EP0_BUFF1_COMP_MASK)\n\t\t\txudc_ctrl_ep_handler(udc, intrstatus);\n\n\t\tfor (index = 1; index < 8; index++) {\n\t\t\tbufintr = ((intrstatus &\n\t\t\t\t  (XUSB_STATUS_EP1_BUFF1_COMP_MASK <<\n\t\t\t\t  (index - 1))) || (intrstatus &\n\t\t\t\t  (XUSB_STATUS_EP1_BUFF2_COMP_MASK <<\n\t\t\t\t  (index - 1))));\n\t\t\tif (bufintr) {\n\t\t\t\txudc_nonctrl_ep_handler(udc, index,\n\t\t\t\t\t\t\tintrstatus);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n/**\n * xudc_probe - The device probe function for driver initialization.\n * @pdev: pointer to the platform device structure.\n *\n * Return: 0 for success and error value on failure\n */\nstatic int xudc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource *res;\n\tstruct xusb_udc *udc;\n\tint irq;\n\tint ret;\n\tu32 ier;\n\tu8 *buff;\n\n\tudc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\t/* Create a dummy request for GET_STATUS, SET_ADDRESS */\n\tudc->req = devm_kzalloc(&pdev->dev, sizeof(struct xusb_req),\n\t\t\t\tGFP_KERNEL);\n\tif (!udc->req)\n\t\treturn -ENOMEM;\n\n\tbuff = devm_kzalloc(&pdev->dev, STATUSBUFF_SIZE, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tudc->req->usb_req.buf = buff;\n\n\t/* Map the registers */\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tudc->addr = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(udc->addr))\n\t\treturn PTR_ERR(udc->addr);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_irq(&pdev->dev, irq, xudc_irq, 0,\n\t\t\t       dev_name(&pdev->dev), udc);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"unable to request irq %d\", irq);\n\t\tgoto fail;\n\t}\n\n\tudc->dma_enabled = of_property_read_bool(np, \"xlnx,has-builtin-dma\");\n\n\t/* Setup gadget structure */\n\tudc->gadget.ops = &xusb_udc_ops;\n\tudc->gadget.max_speed = USB_SPEED_HIGH;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->gadget.ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO].ep_usb;\n\tudc->gadget.name = driver_name;\n\n\tudc->clk = devm_clk_get(&pdev->dev, \"s_axi_aclk\");\n\tif (IS_ERR(udc->clk)) {\n\t\tif (PTR_ERR(udc->clk) != -ENOENT) {\n\t\t\tret = PTR_ERR(udc->clk);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Clock framework support is optional, continue on,\n\t\t * anyways if we don't find a matching clock\n\t\t */\n\t\tdev_warn(&pdev->dev, \"s_axi_aclk clock property is not found\\n\");\n\t\tudc->clk = NULL;\n\t}\n\n\tret = clk_prepare_enable(udc->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tspin_lock_init(&udc->lock);\n\n\t/* Check for IP endianness */\n\tudc->write_fn = xudc_write32_be;\n\tudc->read_fn = xudc_read32_be;\n\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, USB_TEST_J);\n\tif ((udc->read_fn(udc->addr + XUSB_TESTMODE_OFFSET))\n\t\t\t!= USB_TEST_J) {\n\t\tudc->write_fn = xudc_write32;\n\t\tudc->read_fn = xudc_read32;\n\t}\n\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, 0);\n\n\txudc_eps_init(udc);\n\n\t/* Set device address to 0.*/\n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\n\tret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\n\tif (ret)\n\t\tgoto err_disable_unprepare_clk;\n\n\tudc->dev = &udc->gadget.dev;\n\n\t/* Enable the interrupts.*/\n\tier = XUSB_STATUS_GLOBAL_INTR_MASK | XUSB_STATUS_INTR_EVENT_MASK |\n\t      XUSB_STATUS_FIFO_BUFF_RDY_MASK | XUSB_STATUS_FIFO_BUFF_FREE_MASK |\n\t      XUSB_STATUS_SETUP_PACKET_MASK |\n\t      XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\tplatform_set_drvdata(pdev, udc);\n\n\tdev_vdbg(&pdev->dev, \"%s at 0x%08X mapped to %p %s\\n\",\n\t\t driver_name, (u32)res->start, udc->addr,\n\t\t udc->dma_enabled ? \"with DMA\" : \"without DMA\");\n\n\treturn 0;\n\nerr_disable_unprepare_clk:\n\tclk_disable_unprepare(udc->clk);\nfail:\n\tdev_err(&pdev->dev, \"probe failed, %d\\n\", ret);\n\treturn ret;\n}\n\n/**\n * xudc_remove - Releases the resources allocated during the initialization.\n * @pdev: pointer to the platform device structure.\n *\n * Return: 0 always\n */\nstatic int xudc_remove(struct platform_device *pdev)\n{\n\tstruct xusb_udc *udc = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\tclk_disable_unprepare(udc->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int xudc_suspend(struct device *dev)\n{\n\tstruct xusb_udc *udc;\n\tu32 crtlreg;\n\tunsigned long flags;\n\n\tudc = dev_get_drvdata(dev);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg &= ~XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tif (udc->driver && udc->driver->suspend)\n\t\tudc->driver->suspend(&udc->gadget);\n\n\tclk_disable(udc->clk);\n\n\treturn 0;\n}\n\nstatic int xudc_resume(struct device *dev)\n{\n\tstruct xusb_udc *udc;\n\tu32 crtlreg;\n\tunsigned long flags;\n\tint ret;\n\n\tudc = dev_get_drvdata(dev);\n\n\tret = clk_enable(udc->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg |= XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n#endif /* CONFIG_PM_SLEEP */\n\nstatic const struct dev_pm_ops xudc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xudc_suspend, xudc_resume)\n};\n\n/* Match table for of_platform binding */\nstatic const struct of_device_id usb_of_match[] = {\n\t{ .compatible = \"xlnx,usb2-device-4.00.a\", },\n\t{ /* end of list */ },\n};\nMODULE_DEVICE_TABLE(of, usb_of_match);\n\nstatic struct platform_driver xudc_driver = {\n\t.driver = {\n\t\t.name = driver_name,\n\t\t.of_match_table = usb_of_match,\n\t\t.pm\t= &xudc_pm_ops,\n\t},\n\t.probe = xudc_probe,\n\t.remove = xudc_remove,\n};\n\nmodule_platform_driver(xudc_driver);\n\nMODULE_DESCRIPTION(\"Xilinx udc driver\");\nMODULE_AUTHOR(\"Xilinx, Inc\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/usb/gadget/udc/udc-xilinx.c"], "buggy_code_start_loc": [1617], "buggy_code_end_loc": [1684], "fixing_code_start_loc": [1618], "fixing_code_end_loc": [1691], "type": "CWE-129", "message": "In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access.", "other": {"cve": {"id": "CVE-2022-27223", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-16T00:15:09.993", "lastModified": "2023-01-19T03:24:11.227", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access."}, {"lang": "es", "value": "En el archivo drivers/usb/gadget/udc/udc-xilinx.c en el kernel de Linux versiones anteriores a 5.16.12, el \u00edndice del punto final no se comprueba y podr\u00eda ser manipulado por el host para el acceso fuera de la matriz"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-129"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16.12", "matchCriteriaId": "FD5AEF0D-5C5B-4ABC-BC82-E0A5C7822EC0"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vsphere:*:*", "matchCriteriaId": "E8F29E19-3A64-4426-A2AA-F169440267CC"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.12", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/7f14c7227f342d9932f9b918893c8814f86d2a0d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220419-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7f14c7227f342d9932f9b918893c8814f86d2a0d"}}