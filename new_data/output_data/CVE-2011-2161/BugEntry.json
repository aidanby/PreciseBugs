{"buggy_code": ["/*\n * Monkey's Audio APE demuxer\n * Copyright (c) 2007 Benjamin Zores <ben@geexbox.org>\n *  based upon libdemac from Dave Chapman.\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdio.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avformat.h\"\n#include \"apetag.h\"\n\n#define ENABLE_DEBUG 0\n\n/* The earliest and latest file formats supported by this library */\n#define APE_MIN_VERSION 3950\n#define APE_MAX_VERSION 3990\n\n#define MAC_FORMAT_FLAG_8_BIT                 1 // is 8-bit [OBSOLETE]\n#define MAC_FORMAT_FLAG_CRC                   2 // uses the new CRC32 error detection [OBSOLETE]\n#define MAC_FORMAT_FLAG_HAS_PEAK_LEVEL        4 // uint32 nPeakLevel after the header [OBSOLETE]\n#define MAC_FORMAT_FLAG_24_BIT                8 // is 24-bit [OBSOLETE]\n#define MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS    16 // has the number of seek elements after the peak level\n#define MAC_FORMAT_FLAG_CREATE_WAV_HEADER    32 // create the wave header on decompression (not stored)\n\n#define MAC_SUBFRAME_SIZE 4608\n\n#define APE_EXTRADATA_SIZE 6\n\ntypedef struct {\n    int64_t pos;\n    int nblocks;\n    int size;\n    int skip;\n    int64_t pts;\n} APEFrame;\n\ntypedef struct {\n    /* Derived fields */\n    uint32_t junklength;\n    uint32_t firstframe;\n    uint32_t totalsamples;\n    int currentframe;\n    APEFrame *frames;\n\n    /* Info from Descriptor Block */\n    char magic[4];\n    int16_t fileversion;\n    int16_t padding1;\n    uint32_t descriptorlength;\n    uint32_t headerlength;\n    uint32_t seektablelength;\n    uint32_t wavheaderlength;\n    uint32_t audiodatalength;\n    uint32_t audiodatalength_high;\n    uint32_t wavtaillength;\n    uint8_t md5[16];\n\n    /* Info from Header Block */\n    uint16_t compressiontype;\n    uint16_t formatflags;\n    uint32_t blocksperframe;\n    uint32_t finalframeblocks;\n    uint32_t totalframes;\n    uint16_t bps;\n    uint16_t channels;\n    uint32_t samplerate;\n\n    /* Seektable */\n    uint32_t *seektable;\n} APEContext;\n\nstatic int ape_probe(AVProbeData * p)\n{\n    if (p->buf[0] == 'M' && p->buf[1] == 'A' && p->buf[2] == 'C' && p->buf[3] == ' ')\n        return AVPROBE_SCORE_MAX;\n\n    return 0;\n}\n\nstatic void ape_dumpinfo(AVFormatContext * s, APEContext * ape_ctx)\n{\n#if ENABLE_DEBUG\n    int i;\n\n    av_log(s, AV_LOG_DEBUG, \"Descriptor Block:\\n\\n\");\n    av_log(s, AV_LOG_DEBUG, \"magic                = \\\"%c%c%c%c\\\"\\n\", ape_ctx->magic[0], ape_ctx->magic[1], ape_ctx->magic[2], ape_ctx->magic[3]);\n    av_log(s, AV_LOG_DEBUG, \"fileversion          = %d\\n\", ape_ctx->fileversion);\n    av_log(s, AV_LOG_DEBUG, \"descriptorlength     = %d\\n\", ape_ctx->descriptorlength);\n    av_log(s, AV_LOG_DEBUG, \"headerlength         = %d\\n\", ape_ctx->headerlength);\n    av_log(s, AV_LOG_DEBUG, \"seektablelength      = %d\\n\", ape_ctx->seektablelength);\n    av_log(s, AV_LOG_DEBUG, \"wavheaderlength      = %d\\n\", ape_ctx->wavheaderlength);\n    av_log(s, AV_LOG_DEBUG, \"audiodatalength      = %d\\n\", ape_ctx->audiodatalength);\n    av_log(s, AV_LOG_DEBUG, \"audiodatalength_high = %d\\n\", ape_ctx->audiodatalength_high);\n    av_log(s, AV_LOG_DEBUG, \"wavtaillength        = %d\\n\", ape_ctx->wavtaillength);\n    av_log(s, AV_LOG_DEBUG, \"md5                  = \");\n    for (i = 0; i < 16; i++)\n         av_log(s, AV_LOG_DEBUG, \"%02x\", ape_ctx->md5[i]);\n    av_log(s, AV_LOG_DEBUG, \"\\n\");\n\n    av_log(s, AV_LOG_DEBUG, \"\\nHeader Block:\\n\\n\");\n\n    av_log(s, AV_LOG_DEBUG, \"compressiontype      = %d\\n\", ape_ctx->compressiontype);\n    av_log(s, AV_LOG_DEBUG, \"formatflags          = %d\\n\", ape_ctx->formatflags);\n    av_log(s, AV_LOG_DEBUG, \"blocksperframe       = %d\\n\", ape_ctx->blocksperframe);\n    av_log(s, AV_LOG_DEBUG, \"finalframeblocks     = %d\\n\", ape_ctx->finalframeblocks);\n    av_log(s, AV_LOG_DEBUG, \"totalframes          = %d\\n\", ape_ctx->totalframes);\n    av_log(s, AV_LOG_DEBUG, \"bps                  = %d\\n\", ape_ctx->bps);\n    av_log(s, AV_LOG_DEBUG, \"channels             = %d\\n\", ape_ctx->channels);\n    av_log(s, AV_LOG_DEBUG, \"samplerate           = %d\\n\", ape_ctx->samplerate);\n\n    av_log(s, AV_LOG_DEBUG, \"\\nSeektable\\n\\n\");\n    if ((ape_ctx->seektablelength / sizeof(uint32_t)) != ape_ctx->totalframes) {\n        av_log(s, AV_LOG_DEBUG, \"No seektable\\n\");\n    } else {\n        for (i = 0; i < ape_ctx->seektablelength / sizeof(uint32_t); i++) {\n            if (i < ape_ctx->totalframes - 1) {\n                av_log(s, AV_LOG_DEBUG, \"%8d   %d (%d bytes)\\n\", i, ape_ctx->seektable[i], ape_ctx->seektable[i + 1] - ape_ctx->seektable[i]);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \"%8d   %d\\n\", i, ape_ctx->seektable[i]);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"\\nFrames\\n\\n\");\n    for (i = 0; i < ape_ctx->totalframes; i++)\n        av_log(s, AV_LOG_DEBUG, \"%8d   %8lld %8d (%d samples)\\n\", i, ape_ctx->frames[i].pos, ape_ctx->frames[i].size, ape_ctx->frames[i].nblocks);\n\n    av_log(s, AV_LOG_DEBUG, \"\\nCalculated information:\\n\\n\");\n    av_log(s, AV_LOG_DEBUG, \"junklength           = %d\\n\", ape_ctx->junklength);\n    av_log(s, AV_LOG_DEBUG, \"firstframe           = %d\\n\", ape_ctx->firstframe);\n    av_log(s, AV_LOG_DEBUG, \"totalsamples         = %d\\n\", ape_ctx->totalsamples);\n#endif\n}\n\nstatic int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n{\n    AVIOContext *pb = s->pb;\n    APEContext *ape = s->priv_data;\n    AVStream *st;\n    uint32_t tag;\n    int i;\n    int total_blocks;\n    int64_t pts;\n\n    /* TODO: Skip any leading junk such as id3v2 tags */\n    ape->junklength = 0;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('M', 'A', 'C', ' '))\n        return -1;\n\n    ape->fileversion = avio_rl16(pb);\n\n    if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Unsupported file version - %d.%02d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);\n        return -1;\n    }\n\n    if (ape->fileversion >= 3980) {\n        ape->padding1             = avio_rl16(pb);\n        ape->descriptorlength     = avio_rl32(pb);\n        ape->headerlength         = avio_rl32(pb);\n        ape->seektablelength      = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->audiodatalength      = avio_rl32(pb);\n        ape->audiodatalength_high = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        avio_read(pb, ape->md5, 16);\n\n        /* Skip any unknown bytes at the end of the descriptor.\n           This is for future compatibility */\n        if (ape->descriptorlength > 52)\n            avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);\n\n        /* Read header data */\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->blocksperframe       = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->bps                  = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n    } else {\n        ape->descriptorlength = 0;\n        ape->headerlength = 32;\n\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {\n            avio_seek(pb, 4, SEEK_CUR); /* Skip the peak level */\n            ape->headerlength += 4;\n        }\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {\n            ape->seektablelength = avio_rl32(pb);\n            ape->headerlength += 4;\n            ape->seektablelength *= sizeof(int32_t);\n        } else\n            ape->seektablelength = ape->totalframes * sizeof(int32_t);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)\n            ape->bps = 8;\n        else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)\n            ape->bps = 24;\n        else\n            ape->bps = 16;\n\n        if (ape->fileversion >= 3950)\n            ape->blocksperframe = 73728 * 4;\n        else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))\n            ape->blocksperframe = 73728;\n        else\n            ape->blocksperframe = 9216;\n\n        /* Skip any stored wav header */\n        if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))\n            avio_seek(pb, ape->wavheaderlength, SEEK_CUR);\n    }\n\n    if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %d\\n\", ape->totalframes);\n        return -1;\n    }\n    ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));\n    if(!ape->frames)\n        return AVERROR(ENOMEM);\n    ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;\n    ape->currentframe = 0;\n\n\n    ape->totalsamples = ape->finalframeblocks;\n    if (ape->totalframes > 1)\n        ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);\n\n    if (ape->seektablelength > 0) {\n        ape->seektable = av_malloc(ape->seektablelength);\n        for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)\n            ape->seektable[i] = avio_rl32(pb);\n    }\n\n    ape->frames[0].pos     = ape->firstframe;\n    ape->frames[0].nblocks = ape->blocksperframe;\n    ape->frames[0].skip    = 0;\n    for (i = 1; i < ape->totalframes; i++) {\n        ape->frames[i].pos      = ape->seektable[i]; //ape->frames[i-1].pos + ape->blocksperframe;\n        ape->frames[i].nblocks  = ape->blocksperframe;\n        ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;\n        ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;\n    }\n    ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;\n    ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;\n\n    for (i = 0; i < ape->totalframes; i++) {\n        if(ape->frames[i].skip){\n            ape->frames[i].pos  -= ape->frames[i].skip;\n            ape->frames[i].size += ape->frames[i].skip;\n        }\n        ape->frames[i].size = (ape->frames[i].size + 3) & ~3;\n    }\n\n\n    ape_dumpinfo(s, ape);\n\n    /* try to read APE tags */\n    if (!url_is_streamed(pb)) {\n        ff_ape_parse_tag(s);\n        avio_seek(pb, 0, SEEK_SET);\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"Decoding file - v%d.%02d, compression level %d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);\n\n    /* now we are ready: build format streams */\n    st = av_new_stream(s, 0);\n    if (!st)\n        return -1;\n\n    total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n    st->codec->codec_id        = CODEC_ID_APE;\n    st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');\n    st->codec->channels        = ape->channels;\n    st->codec->sample_rate     = ape->samplerate;\n    st->codec->bits_per_coded_sample = ape->bps;\n    st->codec->frame_size      = MAC_SUBFRAME_SIZE;\n\n    st->nb_frames = ape->totalframes;\n    st->start_time = 0;\n    st->duration  = total_blocks / MAC_SUBFRAME_SIZE;\n    av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);\n\n    st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);\n    st->codec->extradata_size = APE_EXTRADATA_SIZE;\n    AV_WL16(st->codec->extradata + 0, ape->fileversion);\n    AV_WL16(st->codec->extradata + 2, ape->compressiontype);\n    AV_WL16(st->codec->extradata + 4, ape->formatflags);\n\n    pts = 0;\n    for (i = 0; i < ape->totalframes; i++) {\n        ape->frames[i].pts = pts;\n        av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);\n        pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;\n    }\n\n    return 0;\n}\n\nstatic int ape_read_packet(AVFormatContext * s, AVPacket * pkt)\n{\n    int ret;\n    int nblocks;\n    APEContext *ape = s->priv_data;\n    uint32_t extra_size = 8;\n\n    if (s->pb->eof_reached)\n        return AVERROR(EIO);\n    if (ape->currentframe > ape->totalframes)\n        return AVERROR(EIO);\n\n    avio_seek (s->pb, ape->frames[ape->currentframe].pos, SEEK_SET);\n\n    /* Calculate how many blocks there are in this frame */\n    if (ape->currentframe == (ape->totalframes - 1))\n        nblocks = ape->finalframeblocks;\n    else\n        nblocks = ape->blocksperframe;\n\n    if (av_new_packet(pkt,  ape->frames[ape->currentframe].size + extra_size) < 0)\n        return AVERROR(ENOMEM);\n\n    AV_WL32(pkt->data    , nblocks);\n    AV_WL32(pkt->data + 4, ape->frames[ape->currentframe].skip);\n    ret = avio_read(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);\n\n    pkt->pts = ape->frames[ape->currentframe].pts;\n    pkt->stream_index = 0;\n\n    /* note: we need to modify the packet size here to handle the last\n       packet */\n    pkt->size = ret + extra_size;\n\n    ape->currentframe++;\n\n    return 0;\n}\n\nstatic int ape_read_close(AVFormatContext * s)\n{\n    APEContext *ape = s->priv_data;\n\n    av_freep(&ape->frames);\n    av_freep(&ape->seektable);\n    return 0;\n}\n\nstatic int ape_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n{\n    AVStream *st = s->streams[stream_index];\n    APEContext *ape = s->priv_data;\n    int index = av_index_search_timestamp(st, timestamp, flags);\n\n    if (index < 0)\n        return -1;\n\n    ape->currentframe = index;\n    return 0;\n}\n\nAVInputFormat ff_ape_demuxer = {\n    \"ape\",\n    NULL_IF_CONFIG_SMALL(\"Monkey's Audio\"),\n    sizeof(APEContext),\n    ape_probe,\n    ape_read_header,\n    ape_read_packet,\n    ape_read_close,\n    ape_read_seek,\n    .extensions = \"ape,apl,mac\"\n};\n"], "fixing_code": ["/*\n * Monkey's Audio APE demuxer\n * Copyright (c) 2007 Benjamin Zores <ben@geexbox.org>\n *  based upon libdemac from Dave Chapman.\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdio.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"avformat.h\"\n#include \"apetag.h\"\n\n#define ENABLE_DEBUG 0\n\n/* The earliest and latest file formats supported by this library */\n#define APE_MIN_VERSION 3950\n#define APE_MAX_VERSION 3990\n\n#define MAC_FORMAT_FLAG_8_BIT                 1 // is 8-bit [OBSOLETE]\n#define MAC_FORMAT_FLAG_CRC                   2 // uses the new CRC32 error detection [OBSOLETE]\n#define MAC_FORMAT_FLAG_HAS_PEAK_LEVEL        4 // uint32 nPeakLevel after the header [OBSOLETE]\n#define MAC_FORMAT_FLAG_24_BIT                8 // is 24-bit [OBSOLETE]\n#define MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS    16 // has the number of seek elements after the peak level\n#define MAC_FORMAT_FLAG_CREATE_WAV_HEADER    32 // create the wave header on decompression (not stored)\n\n#define MAC_SUBFRAME_SIZE 4608\n\n#define APE_EXTRADATA_SIZE 6\n\ntypedef struct {\n    int64_t pos;\n    int nblocks;\n    int size;\n    int skip;\n    int64_t pts;\n} APEFrame;\n\ntypedef struct {\n    /* Derived fields */\n    uint32_t junklength;\n    uint32_t firstframe;\n    uint32_t totalsamples;\n    int currentframe;\n    APEFrame *frames;\n\n    /* Info from Descriptor Block */\n    char magic[4];\n    int16_t fileversion;\n    int16_t padding1;\n    uint32_t descriptorlength;\n    uint32_t headerlength;\n    uint32_t seektablelength;\n    uint32_t wavheaderlength;\n    uint32_t audiodatalength;\n    uint32_t audiodatalength_high;\n    uint32_t wavtaillength;\n    uint8_t md5[16];\n\n    /* Info from Header Block */\n    uint16_t compressiontype;\n    uint16_t formatflags;\n    uint32_t blocksperframe;\n    uint32_t finalframeblocks;\n    uint32_t totalframes;\n    uint16_t bps;\n    uint16_t channels;\n    uint32_t samplerate;\n\n    /* Seektable */\n    uint32_t *seektable;\n} APEContext;\n\nstatic int ape_probe(AVProbeData * p)\n{\n    if (p->buf[0] == 'M' && p->buf[1] == 'A' && p->buf[2] == 'C' && p->buf[3] == ' ')\n        return AVPROBE_SCORE_MAX;\n\n    return 0;\n}\n\nstatic void ape_dumpinfo(AVFormatContext * s, APEContext * ape_ctx)\n{\n#if ENABLE_DEBUG\n    int i;\n\n    av_log(s, AV_LOG_DEBUG, \"Descriptor Block:\\n\\n\");\n    av_log(s, AV_LOG_DEBUG, \"magic                = \\\"%c%c%c%c\\\"\\n\", ape_ctx->magic[0], ape_ctx->magic[1], ape_ctx->magic[2], ape_ctx->magic[3]);\n    av_log(s, AV_LOG_DEBUG, \"fileversion          = %d\\n\", ape_ctx->fileversion);\n    av_log(s, AV_LOG_DEBUG, \"descriptorlength     = %d\\n\", ape_ctx->descriptorlength);\n    av_log(s, AV_LOG_DEBUG, \"headerlength         = %d\\n\", ape_ctx->headerlength);\n    av_log(s, AV_LOG_DEBUG, \"seektablelength      = %d\\n\", ape_ctx->seektablelength);\n    av_log(s, AV_LOG_DEBUG, \"wavheaderlength      = %d\\n\", ape_ctx->wavheaderlength);\n    av_log(s, AV_LOG_DEBUG, \"audiodatalength      = %d\\n\", ape_ctx->audiodatalength);\n    av_log(s, AV_LOG_DEBUG, \"audiodatalength_high = %d\\n\", ape_ctx->audiodatalength_high);\n    av_log(s, AV_LOG_DEBUG, \"wavtaillength        = %d\\n\", ape_ctx->wavtaillength);\n    av_log(s, AV_LOG_DEBUG, \"md5                  = \");\n    for (i = 0; i < 16; i++)\n         av_log(s, AV_LOG_DEBUG, \"%02x\", ape_ctx->md5[i]);\n    av_log(s, AV_LOG_DEBUG, \"\\n\");\n\n    av_log(s, AV_LOG_DEBUG, \"\\nHeader Block:\\n\\n\");\n\n    av_log(s, AV_LOG_DEBUG, \"compressiontype      = %d\\n\", ape_ctx->compressiontype);\n    av_log(s, AV_LOG_DEBUG, \"formatflags          = %d\\n\", ape_ctx->formatflags);\n    av_log(s, AV_LOG_DEBUG, \"blocksperframe       = %d\\n\", ape_ctx->blocksperframe);\n    av_log(s, AV_LOG_DEBUG, \"finalframeblocks     = %d\\n\", ape_ctx->finalframeblocks);\n    av_log(s, AV_LOG_DEBUG, \"totalframes          = %d\\n\", ape_ctx->totalframes);\n    av_log(s, AV_LOG_DEBUG, \"bps                  = %d\\n\", ape_ctx->bps);\n    av_log(s, AV_LOG_DEBUG, \"channels             = %d\\n\", ape_ctx->channels);\n    av_log(s, AV_LOG_DEBUG, \"samplerate           = %d\\n\", ape_ctx->samplerate);\n\n    av_log(s, AV_LOG_DEBUG, \"\\nSeektable\\n\\n\");\n    if ((ape_ctx->seektablelength / sizeof(uint32_t)) != ape_ctx->totalframes) {\n        av_log(s, AV_LOG_DEBUG, \"No seektable\\n\");\n    } else {\n        for (i = 0; i < ape_ctx->seektablelength / sizeof(uint32_t); i++) {\n            if (i < ape_ctx->totalframes - 1) {\n                av_log(s, AV_LOG_DEBUG, \"%8d   %d (%d bytes)\\n\", i, ape_ctx->seektable[i], ape_ctx->seektable[i + 1] - ape_ctx->seektable[i]);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \"%8d   %d\\n\", i, ape_ctx->seektable[i]);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"\\nFrames\\n\\n\");\n    for (i = 0; i < ape_ctx->totalframes; i++)\n        av_log(s, AV_LOG_DEBUG, \"%8d   %8lld %8d (%d samples)\\n\", i, ape_ctx->frames[i].pos, ape_ctx->frames[i].size, ape_ctx->frames[i].nblocks);\n\n    av_log(s, AV_LOG_DEBUG, \"\\nCalculated information:\\n\\n\");\n    av_log(s, AV_LOG_DEBUG, \"junklength           = %d\\n\", ape_ctx->junklength);\n    av_log(s, AV_LOG_DEBUG, \"firstframe           = %d\\n\", ape_ctx->firstframe);\n    av_log(s, AV_LOG_DEBUG, \"totalsamples         = %d\\n\", ape_ctx->totalsamples);\n#endif\n}\n\nstatic int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n{\n    AVIOContext *pb = s->pb;\n    APEContext *ape = s->priv_data;\n    AVStream *st;\n    uint32_t tag;\n    int i;\n    int total_blocks;\n    int64_t pts;\n\n    /* TODO: Skip any leading junk such as id3v2 tags */\n    ape->junklength = 0;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('M', 'A', 'C', ' '))\n        return -1;\n\n    ape->fileversion = avio_rl16(pb);\n\n    if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Unsupported file version - %d.%02d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);\n        return -1;\n    }\n\n    if (ape->fileversion >= 3980) {\n        ape->padding1             = avio_rl16(pb);\n        ape->descriptorlength     = avio_rl32(pb);\n        ape->headerlength         = avio_rl32(pb);\n        ape->seektablelength      = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->audiodatalength      = avio_rl32(pb);\n        ape->audiodatalength_high = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        avio_read(pb, ape->md5, 16);\n\n        /* Skip any unknown bytes at the end of the descriptor.\n           This is for future compatibility */\n        if (ape->descriptorlength > 52)\n            avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);\n\n        /* Read header data */\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->blocksperframe       = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->bps                  = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n    } else {\n        ape->descriptorlength = 0;\n        ape->headerlength = 32;\n\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {\n            avio_seek(pb, 4, SEEK_CUR); /* Skip the peak level */\n            ape->headerlength += 4;\n        }\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {\n            ape->seektablelength = avio_rl32(pb);\n            ape->headerlength += 4;\n            ape->seektablelength *= sizeof(int32_t);\n        } else\n            ape->seektablelength = ape->totalframes * sizeof(int32_t);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)\n            ape->bps = 8;\n        else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)\n            ape->bps = 24;\n        else\n            ape->bps = 16;\n\n        if (ape->fileversion >= 3950)\n            ape->blocksperframe = 73728 * 4;\n        else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))\n            ape->blocksperframe = 73728;\n        else\n            ape->blocksperframe = 9216;\n\n        /* Skip any stored wav header */\n        if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))\n            avio_seek(pb, ape->wavheaderlength, SEEK_CUR);\n    }\n\n    if(!ape->totalframes){\n        av_log(s, AV_LOG_ERROR, \"No frames in the file!\\n\");\n        return AVERROR(EINVAL);\n    }\n    if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %d\\n\", ape->totalframes);\n        return -1;\n    }\n    ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));\n    if(!ape->frames)\n        return AVERROR(ENOMEM);\n    ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;\n    ape->currentframe = 0;\n\n\n    ape->totalsamples = ape->finalframeblocks;\n    if (ape->totalframes > 1)\n        ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);\n\n    if (ape->seektablelength > 0) {\n        ape->seektable = av_malloc(ape->seektablelength);\n        for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)\n            ape->seektable[i] = avio_rl32(pb);\n    }\n\n    ape->frames[0].pos     = ape->firstframe;\n    ape->frames[0].nblocks = ape->blocksperframe;\n    ape->frames[0].skip    = 0;\n    for (i = 1; i < ape->totalframes; i++) {\n        ape->frames[i].pos      = ape->seektable[i]; //ape->frames[i-1].pos + ape->blocksperframe;\n        ape->frames[i].nblocks  = ape->blocksperframe;\n        ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;\n        ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;\n    }\n    ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;\n    ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;\n\n    for (i = 0; i < ape->totalframes; i++) {\n        if(ape->frames[i].skip){\n            ape->frames[i].pos  -= ape->frames[i].skip;\n            ape->frames[i].size += ape->frames[i].skip;\n        }\n        ape->frames[i].size = (ape->frames[i].size + 3) & ~3;\n    }\n\n\n    ape_dumpinfo(s, ape);\n\n    /* try to read APE tags */\n    if (!url_is_streamed(pb)) {\n        ff_ape_parse_tag(s);\n        avio_seek(pb, 0, SEEK_SET);\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"Decoding file - v%d.%02d, compression level %d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);\n\n    /* now we are ready: build format streams */\n    st = av_new_stream(s, 0);\n    if (!st)\n        return -1;\n\n    total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n    st->codec->codec_id        = CODEC_ID_APE;\n    st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');\n    st->codec->channels        = ape->channels;\n    st->codec->sample_rate     = ape->samplerate;\n    st->codec->bits_per_coded_sample = ape->bps;\n    st->codec->frame_size      = MAC_SUBFRAME_SIZE;\n\n    st->nb_frames = ape->totalframes;\n    st->start_time = 0;\n    st->duration  = total_blocks / MAC_SUBFRAME_SIZE;\n    av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);\n\n    st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);\n    st->codec->extradata_size = APE_EXTRADATA_SIZE;\n    AV_WL16(st->codec->extradata + 0, ape->fileversion);\n    AV_WL16(st->codec->extradata + 2, ape->compressiontype);\n    AV_WL16(st->codec->extradata + 4, ape->formatflags);\n\n    pts = 0;\n    for (i = 0; i < ape->totalframes; i++) {\n        ape->frames[i].pts = pts;\n        av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);\n        pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;\n    }\n\n    return 0;\n}\n\nstatic int ape_read_packet(AVFormatContext * s, AVPacket * pkt)\n{\n    int ret;\n    int nblocks;\n    APEContext *ape = s->priv_data;\n    uint32_t extra_size = 8;\n\n    if (s->pb->eof_reached)\n        return AVERROR(EIO);\n    if (ape->currentframe > ape->totalframes)\n        return AVERROR(EIO);\n\n    avio_seek (s->pb, ape->frames[ape->currentframe].pos, SEEK_SET);\n\n    /* Calculate how many blocks there are in this frame */\n    if (ape->currentframe == (ape->totalframes - 1))\n        nblocks = ape->finalframeblocks;\n    else\n        nblocks = ape->blocksperframe;\n\n    if (av_new_packet(pkt,  ape->frames[ape->currentframe].size + extra_size) < 0)\n        return AVERROR(ENOMEM);\n\n    AV_WL32(pkt->data    , nblocks);\n    AV_WL32(pkt->data + 4, ape->frames[ape->currentframe].skip);\n    ret = avio_read(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);\n\n    pkt->pts = ape->frames[ape->currentframe].pts;\n    pkt->stream_index = 0;\n\n    /* note: we need to modify the packet size here to handle the last\n       packet */\n    pkt->size = ret + extra_size;\n\n    ape->currentframe++;\n\n    return 0;\n}\n\nstatic int ape_read_close(AVFormatContext * s)\n{\n    APEContext *ape = s->priv_data;\n\n    av_freep(&ape->frames);\n    av_freep(&ape->seektable);\n    return 0;\n}\n\nstatic int ape_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n{\n    AVStream *st = s->streams[stream_index];\n    APEContext *ape = s->priv_data;\n    int index = av_index_search_timestamp(st, timestamp, flags);\n\n    if (index < 0)\n        return -1;\n\n    ape->currentframe = index;\n    return 0;\n}\n\nAVInputFormat ff_ape_demuxer = {\n    \"ape\",\n    NULL_IF_CONFIG_SMALL(\"Monkey's Audio\"),\n    sizeof(APEContext),\n    ape_probe,\n    ape_read_header,\n    ape_read_packet,\n    ape_read_close,\n    ape_read_seek,\n    .extensions = \"ape,apl,mac\"\n};\n"], "filenames": ["libavformat/ape.c"], "buggy_code_start_loc": [244], "buggy_code_end_loc": [244], "fixing_code_start_loc": [245], "fixing_code_end_loc": [249], "type": "CWE-399", "message": "The ape_read_header function in ape.c in libavformat in FFmpeg before 0.5.4, as used in MPlayer, VideoLAN VLC media player, and other products, allows remote attackers to cause a denial of service (application crash) via an APE (aka Monkey's Audio) file that contains a header but no frames.", "other": {"cve": {"id": "CVE-2011-2161", "sourceIdentifier": "cve@mitre.org", "published": "2011-05-20T22:55:06.000", "lastModified": "2018-10-17T14:40:15.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ape_read_header function in ape.c in libavformat in FFmpeg before 0.5.4, as used in MPlayer, VideoLAN VLC media player, and other products, allows remote attackers to cause a denial of service (application crash) via an APE (aka Monkey's Audio) file that contains a header but no frames."}, {"lang": "es", "value": "La funci\u00f3n ape_read_header en ape.c en libavformat en FFmpeg antes de v0.5.4, tal como se utiliza en MPlayer, VideoLAN VLC media player, y otros productos, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (solicitud de bloqueo) a trav\u00e9s de un archivo APE (tambi\u00e9n conocido como Monkey's Audio) que contiene un encabezado pero sin marcos."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.5.4", "matchCriteriaId": "4FED443E-75BC-4534-89EE-D0B9CD93209A"}]}]}], "references": [{"url": "http://ffmpeg.mplayerhq.hu/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://packetstorm.linuxsecurity.com/1103-exploits/vlc105-dos.txt", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/8312e3fc9041027a33c8bc667bb99740fdf41dd5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/8312e3fc9041027a33c8bc667bb99740fdf41dd5"}}