{"buggy_code": ["The primary author of mod_auth_openidc is:\n\n\tHans Zandbelt <https://github.com/zandbelt>\n\nThanks to the following people for contributing to mod_auth_openidc by\nreporting bugs, providing fixes, suggesting useful features or other:\n\n\tD\u00e1niel S\u00dcTT\u0150 <https://github.com/suttod>\n\tRoland Hedberg <https://github.com/rohe>\n\tBill Simon <https://github.com/billsimon>\n\tJim Fox <https://github.com/jimfox>\n\tMartin Srom <https://github.com/martinsrom>\n\tDejan Latinovic <https://github.com/latinovic>\n\tHiroyuki Wada <https://github.com/wadahiro>\n\tGunnar Scherf <https://github.com/g10f>\n\tTerrence Fleury <https://github.com/terrencegf>\n\tJeremy Archer <https://github.com/fatlotus>\n\tForkbomber <https://github.com/forkbomber>\n\tKanthi Vaidya <https://github.com/ekanthi>\n\tszakharchenko <https://github.com/szakharchenko>\n\tJohn Bradley <https://bitbucket.org/ve7jtb>\n\tStefano Vercelli <https://github.com/steverc>\n\tDavid Bernick <https://github.com/davidbernick>\n\tJoseph Bester <https://github.com/bester>\n\tDaniel Pfile <https://github.com/pfiled>\n\tRebecka Gulliksson <https://github.com/rebeckag>\n\tRyan Kelly <https://github.com/rfk>\n\tJohn R. Dennis <https://github.com/jdennis>\n\tsteve-dave <https://github.com/steve-dave>\n\tglatzert <https://github.com/glatzert>\n\tAmit Joshi <amitsharadjoshi@gmail.com>\n\tAndy Curtis <https://github.com/asc1>\n\tsolsson\t<https://github.com/solsson>\n\tdrdivano <https://github.com/drdivano>\n\tAliceWonderMiscreations <https://github.com/AliceWonderMiscreations>\n\tWouter Hund <https://github.com/wouterhund>\n\tHans Keeler <https://github.com/hkeeler> \n\tMoritz Schlarb <https://github.com/moschlar>\n\tremi-cc <https://github.com/remi-cc>\n\thihellobolke <https://github.com/hihellobolke>\n\tHoratiu Eugen Vlad <https://github.com/iconoeugen>\n\tcristichiru <https://github.com/cristichiru>\n\tBono de Visser <https://github.com/kerrermanisNL>\n\tPatrick Uiterwijk <https://github.com/puiterwijk>\n\tMarcel Kottmann <https://github.com/pepe79>\n\ttimpuri <https://github.com/timpuri>\n\tEldar Zaitov <https://github.com/kyprizel>\n\tGergan Penkov <https://github.com/gergan>\n\tFlorian Weimer <https://github.com/fweimer>\n\tAaron Donovan <https://github.com/amdonov>\n\tHans Petter Bieker <https://github.com/hpbieker>\n\tarchzone <https://github.com/archzone>\n\tPetteri Stenius <https://github.com/psteniusubi>\n\tLance Fannin <lancekf08@gmail.com>\n\tRicardo Martin Camarero <https://github.com/rickyepoderi>\n\tFilip Vujicic <https://github.com/FilipVujicic>\n\tJanusz Ulanowski <https://github.com/janul>\n\tAimoto Norihito <https://github.com/oss-aimoto>\n\tAndy Lindeman <https://github.com/alindeman>\n\tStefan Wachter <https://github.com/swachter>\n\tPaolo Battino\n\tabsynth76 <https://github.com/absynth76>\n\tAaron Jones <https://github.com/wwaaron>\n\tBryan Ingram <https://github/bcingram>\n\tTim Deisser <https://github.com/deisser>\n\tPeter Hurtenbach <https://github.com/Peter0x48>\n\tPaul Spangler <https://github.com/spanglerco>\n\tChris Pawling <https://github.com/chris468>\n\tMatthias Flesch\u00fctz <https://github.com/blindzero>\n\tHarri Rautila <https://github.com/hrautila>\n\tTatsuhiko Yasumatsu <https://github.com/ty60>\n\tAdam Stadler <https://github.com/tzfx>\n\tSteffen Greber <https://github.com/codemaker219>\n\tIain Heggie <https://github.com/iainh>\n\tDirk Kok <https://github.com/Foxite>\n\n\n", "09/03/2021\n- don't apply authz in discovery process; fixes 2.4.9.3\n\n08/26/2021\n- don't apply authz to the redirect URI; fixes ac5686495a51bc93e257e42bfdc9c9c46252feb1\n- bump to 2.4.9.3\n\n08/20/2021\n- fix graceful restart (regression); see #458; thanks @Foxite\n- bump to 2.4.9.2\n\n08/18/2021\n- preserve session cookie in the event of a cache backend failure\n- update the id_token in the session cache if one is provided while refreshing the access token\n\n08/13/2021\n- fix retried Redis commands after a reconnect; thanks @iainh\n- release 2.4.9.1\n\n07/22/2021\n- use redisvCommand to avoid crash with crafted key when using Redis without encryption; thanks @thomas-chauchefoin-sonarsource\n- replace potentially harmful backslashes with forward slashes when validating redirection URLs; thanks @thomas-chauchefoin-sonarsource\n- release 2.4.9\n- don't use DEFAULT_LIMIT_REQUEST_LINE constant; since it does not exist in Apache 2.2.x\n\n07/15/2021\n- verify that \"alg\" is not none in logout_token explicitly\n- make session not found on backchannel logout produce a log warning instead of error\n- don't clear POST params authn on token revocation; thanks @iainh\n- bump to 2.4.9rc0\n\n07/02/2021\n- handle discovery in the content handler\n- return OK in the content handler for calls to the redirect URI and when preserving POST data\n\n06/25/2021\n- avoid XSS vulnerability when using OIDCPreservePost On and supplying URLs that contain single quotes\n  thanks @oss-aimoto\n\n06/21/2021\n- strip A256GCM JWT header from encrypted JWTS used for state cookies, cache encryption and by-value session cookies\n  resulting in smaller cookies and reduced cache content size\n\n06/10/2021\n- use encrypted JWTs for storing encrypted cache contents and avoid using static AAD/IV; thanks @niebardzo\n- bump to 2.4.9-dev\n\n06/04/2021\n- fix a problem where the host and port are calculated incorrectly, when you use literal ipv6 address.\n\n06/02/2021\n- do not send state timeout HTML document when OIDCDefaultURL is set; this can be overridden by using e.g.:\n  SetEnvIfExpr true OIDC_NO_DEFAULT_URL_ON_STATE_TIMEOUT=true \n- release 2.4.8.4\n\n06/01/2021\n- avoid Apache 2.4 appending 400/302(200/404) HTML document text to state timeout HTML info page\n  see also f5959d767b0eec4856d561cbaa6d2262a52da551 and #484; at least Debian Buster was affected\n- release 2.4.8.3\n\n05/18/2021\n- make error \"session corrupted: no issuer found in session\" a warning only so a logout call for a\n  non-existing session no longer produces error messages\n\n05/08/2021\n- store timestamps in session in seconds to avoid string conversion problems on some (libapr-1)\n  platform build/run combinations, causing \"maximum session duration exceeded\" errors\n- bump to 2.4.8.2\n\n05/07/2021\n- add OIDCClientTokenEndpointKeyPassword option to allow the use of an encrypted private key\n- release 2.4.8.1\n\n04/30/2021\n- fix potential crash when Content-Type is not set in POST requests; thanks Tatsuhiko Yasumatsu of JPCERT/CC\n- release 2.4.8\n\n04/21/2021\n- on OAuth 2.0 RS token scope/claim 401 error, add environment variable for usage with mod_headers,\n  instead of adding a header ourselves; see #572; usage, e.g;\n    Header always append WWW-Authenticate %{OIDC_OAUTH_BEARER_SCOPE_ERROR}e \"expr=(%{REQUEST_STATUS} == 401) && (-n reqenv('OIDC_OAUTH_BEARER_SCOPE_ERROR'))\"\n- bump to 2.4.8-dev\n\n04/13/2021\n- add OIDCRedisCacheConnectTimeout and OIDCRedisCacheTimeout options to configure Redis timeouts\n- bump to 2.4.7.2\n\n04/12/2021\n- fix memory leaks when caching fails\n- bump to 2.4.7.1\n\n04/04/2021\n- improve documentation on OIDCPreservePost\n- release 2.4.7\n\n04/01/2021\n- bump to 2.4.7rc1\n\n02/16/2021\n- remove session from cache before clearing it.\n\n02/12/2021\n- add maximum session lifetime (exp), inactivity timeout (timeout) and remote_user to OIDCInfoHook\n- bump to 2.4.7-dev\n\n02/08/2021\n- return 400 instead of 500 when state cookie matching fails\n- release 2.4.6\n\n02/03/2021\n- avoid displaying the client_secret in debug logs\n\n01/28/2021\n- avoid segmentation fault when hitting an endpoint configured with AuthType openid-connect\n  in an OAuth 2.0 only setup; see #529\n\n01/23/2021\n- fix semaphore cleanup on graceful restarts; see #522\n\n01/12/2021\n- fix inconsistent public/private keys loading order; closes #515\n\n12/17/2020\n- remove support for https://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state\n\n12/10/2020\n- add \"base64url\" option to OIDCPassClaimsAs primitive; closes #417\n\n12/09/2020\n- add Redis database selection option with OIDCRedisCacheDatabase; closes #423\n- optimize Redis AUTH execution once per connection\n\n12/07/2020\n- don't set SameSite=None on cookies when on plain http\n\n12/03/2020\n- add environment variable to control libcURL CURLOPT_SSL_OPTIONS behaviors\n  e.g.: SetEnvIfExpr true CURLOPT_SSL_OPTIONS=CURLSSLOPT_NO_REVOKE\n\n11/23/2020\n- release 2.4.5\n- make sure the module compiles with Apache 2.2 for passphrase exec:\n- bump to 2.4.6-dev\n\n11/19/2020\n- ensure that \"sub\" is returned from the userinfo endpoint following https://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse\n  prevents potential ID spoofing; thanks Christian Fries of Ruhr-University Bochum\n- don't printout JSON errors about NULL characters in error log; thanks Christian Fries of Ruhr-University Bochum\n- restrict printout of JSON parsing errors to 4096 bytes; thanks Christian Fries of Ruhr-University Bochum\n- bump to 2.4.5rc6\n\n11/5/2020\n- fix content processing for info and JWKs handler so mod_headers etc. works; closes #497\n- bump to 2.4.5rc5\n\n11/2/2020\n- improve sanity checking on Redis reply\n- bump to 2.4.5rc4\n\n10/30/2020\n- disable caching token introspection results by setting OIDCOAuthTokenIntrospectionInterval to -1; thanks @wadahiro\n- bump to 2.4.5rc3\n\n10/27/2020\n- config check on OIDCCryptoPassphrase in OAuth 2.0 RS setup with cache encryption enabled\n- bump to 2.4.5rc2\n\n10/22/2020\n- hash define expression option to OIDCUnAuthAction so it compiles for Apache 2.2; fixes 1461634\n- bump to 2.4.5rc1\n- add exec support to OIDCCryptoPassphrase\n \n10/19/2020\n- delete stale session cookies that aren't in the cache\n- allow OIDCDiscoverURL to be a relative URL\n\n10/08/2020\n- add OIDCCABundlePath for configuring path to curl CA bundle\n\n09/22/2020\n- avoid Apache 2.4 appending 401 HTML document text to step-up authentication HTML refresh page; closes #484\n- bump to 2.4.5rc0\n\n09/21/2020\n- populate AUTH_TYPE when performing authentication; thanks @spanglerco\n\n09/19/2020\n- enable authentication of sub-requests when the main request doesn't require\n  authentication; thanks @spanglerco\n\n09/03/2020\n- add SameSite attribute on cookie clearance / logout; thanks @v0gler\n- bump to 2.4.4.1\n\n09/01/2020\n- forward port Tufin patches\n- always set session cookie same site policy to Lax\n- disable cookie domain check\n- unset host headers for metadata URL retrieval\n- bump to 2.4.4-tufin\n\n09/01/2020\n- avoid GCC 9 compiler warnings\n- release 2.4.4\n\n08/28/2020\n- allow Content-Type check on backchannel logout to have postfixes (utf-8 etc)\n- terminate backchannel logout with DONE instead of OK to avoid authz error 500\n- bump to 2.4.4rc8\n\n08/18/2020\n- add recommended cache headers on backchannel logout response\n  https://openid.net/specs/openid-connect-backchannel-1_0.html#rfc.section.2.8\n- bump to 2.4.4rc7\n\n08/10/2020\n- add new OIDCStateCookiePrefix primitive for the state cookie prefix\n\n08/01/2020\n- add conditional expression to OIDCUnAuthAction; see #479; thanks @raro42 and @marcstern\n- bump to 2.4.4rc6\n\n07/31/2020\n- reverse order of creating HTML response and adding session cookie; thanks @deisser\n- bump to 2.4.4rc5\n\n07/30/2020\n- fix doubled Set-Cookie behaviour when using `client-cookie`, calling the session info hook\n  and writing out a session update (twice); thanks @deisser\n- bump to 2.4.4rc4\n\n07/27/2020\n- prevent XSS and open redirect on OIDC session managemement OP iframe with OIDCRedirectURLsAllowed\n  thanks Andrew Brady\n- bump to 2.4.4rc3\n\n07/22/2020\n- delete state cookie when it cannot be decoded/decrypted\n- bump to 2.4.4rc2\n\n07/03/2020\n- fix for loop initial declarations to not require c99 for compilation (RHEL 6)\n- add ap_expr.h include in stub.c (RHEL 6)\n- bump to 2.4.4rc1\n\n06/30/2020\n- add grant_types to dynamic client registration request\n- don't send access_token in user info request when method is set to POST; conform OIDC test suite 4.0.5\n- bump to 2.4.4rc0\n\n06/10/2020\n- prevent open redirect on refresh token requests\n  add new OIDCRedirectURLsAllowed primitive to handle post logout and refresh-return-to validation\n  addresses #453; closes #466\n- release 2.4.3\n\n06/09/2020\n- fix complex expressions crash when compiled from source with libjq; closes #472\n  thanks vincentscharf0803\n  introduced by OIDCStateInputHeaders addition in 2.4.3rc0\n- bump to 2.4.3rc1\n\n05/11/2020\n- added OIDCValidateIssuer to allow for disabling of issuer matching.  helps to support multi-tenant applications.\n\n05/02/2020\n- when stripping cookies, add a space between cookies in the resulting header (required by RFC 6265)\n- move oidc_parse_config inside MODULE_MAGIC_NUMBER_MAJOR to make sure the module compiles with Apache 2.0\n\n04/25/2020\n- add OIDCStateInputHeaders that allows configuring the header values used to calculate the fingerprint of the state during authentication\n- bump to 2.4.3rc0\n\n03/25/2020\n- oops: fix json_deep_copy of claims\n- release 2.4.2.1\n\n03/24/2020\n- fix memory leak in OAuth 2.0 JWT validation; closes #470; thanks Conrad Thukral\n- fix configured private/public key cleanup on process exit\n\n03/21/2020\n- allow for expressions in Require statements, see #469; thanks @wwaaron\n  also see: https://github.com/zmartzone/mod_auth_openidc/wiki/Authorization#expressions-in-require-statements\n- bump to 2.4.2rc5\n\n03/19/2020\n- always refresh keys from jwks_uri when there is no kid in the JWT header\n- bump to 2.4.2rc4\n\n03/15/2020\n- destroy shared memory segments only in parent process; see #458\n- bump to 2.4.2rc3\n\n03/10/2020\n- fix memory leaks introduced by #457\n- bump to 2.4.2rc2\n\n02/19/2020\n- if content was already returned via html/http send then don't return 500\n  but send 200 to avoid extraneous internal error document text to be sent\n  on some Apache 2.4.x versions e.g. CentOS 7\n- bump to 2.4.2rc1\n\n02/03/2020\n- if OIDCPublicKeyFiles contains a certificate, the corresponding x5c, x5t and x5t#256 \n  parameters will be added to the generated jwkset available at \"<redirect_uri>?jwks=rsa\"\n  thanks @absynth76\n- fix: also add SameSite=None to by-value session cookies\n- bump to 2.4.2rc0\n\n01/30/2020\n- try to fix graceful restart crash; see #458\n- release 2.4.1\n\n01/29/2020\n- always add a SameSite value to the Set-Cookie header to satisfy upcoming Chrome/Firefox changes\n  this can be overridden by using, e.g.:\n    SetEnvIf User-Agent \".*IOS.*\" OIDC_SET_COOKIE_APPEND=;\n- release 2.4.1rc6\n\n01/22/2020\n- URL encode logout url in session management JS; thanks Paolo Battino\n- bump to 2.4.1rc5\n\n01/15/2020\n- add value of OIDC_SET_COOKIE_APPEND env var to Set-Cookie headers\n  useful for handling changing/upcoming SameSite behaviors across different browsers, e.g.:\n    SetEnvIf User-Agent \".*IOS.*\" OIDC_SET_COOKIE_APPEND=SameSite=None\n- bump to 2.4.1rc4\n\n01/08/2020\n- support 407 option on OIDCUnAuthAction\n\n12/09/2019\n- fix parsing of values from metadata files when the default is non-NULL (e.g. UNSET)\n- enforce OIDCIDTokenSignedResponseAlg and OIDCUserInfoSignedResponseAlg; see #435\n- bump to 2.4.1rc2\n- support login with OIDC session management; address #456\n- bump to 2.4.1rc3\n\n12/05/2019\n- add the possibility to use a public key instead of a certificate for OIDCPublicKeyFiles parameter\n- added an alpine dockerfile =~ 20MB container size\n\n12/04/2019\n- return 200 OK for backchannel logout if session not found\n- bump to 2.4.1rc1\n\n11/19/2019\n- make cleaning of expired state cookies log with a warning rather than an error; thanks Pavel Drobov\n- bump to 2.4.1rc0\n\n10/03/2019\n- improve validation of the post-logout URL parameter on logout; thanks AIMOTO Norihito; closes #449\n- release 2.4.0.3\n- clear any existing chunked cookies when setting a non-chunked cookie; prevents login loops in some scenarios\n\n08/28/2019\n- fixes #447 #441 : changed storing POST params from localStorage to\n  sessionStorage due to some issue of losing data in localStorage in Firefox\n  (private mode) \n\n08/22/2019\n- release 2.4.0\n\n08/16/2019\n- revert 3d95b4a3fbc493c6acc745626ac33143eb4968bf: don't return early from the content handler\n\n08/15/2019\n- be smart about picking the token endpoint authentication method when not configured explicitly:\n  don't choose the first one published by the OP but prefer client_secret_basic if that is listed as well\n  see: panva/node-oidc-provider#514; thanks @richard-drummond and @panva\n- bump to 2.4.0rc24\n\n08/12/2019\n- fix not clearing claims in session when setting claims to null; closes #445; thanks @FilipVujicic\n\n08/12/2019\n- fix JWT decryption crashing on non-null terminated input\n- bump to 2.4.0rc23\n\n08/09/2019\n- add logout_on_error option to OIDCRefreshAccessTokenBeforeExpiry to kill the session when\n  refreshing an access token fails; thanks @rickyepoderi\n- bump to 2.4.0rc22\n\n08/08/2019\n- no longer use the fixup handler for environment variable setting but do it as part of the authn handler\n- bump to 2.4.0rc21\n\n08/04/2019\n- avoid decoding non-form-encoded POST data; closes #443\n- bump to 2.4.0rc20\n\n08/02/2019\n- return DONE from the content handler early to prevent triggering other content handlers\n- fix `OIDCOAuthAcceptTokenAs post` so POST data is propagated and not lost; see #443\n- bump to 2.4.0rc19\n\n07/10/2019\n- fix RSA JWK \"x5c\" parsing issue (e.g. when parsing \"n\" fails): explicitly set the \"kid\" into to JWK\n- bump to 2.4.0rc18\n\n06/19/2019\n- fix regression bug that includes a HTTP 500 message after rendering content\n- bump to 2.4.0rc17\n\n06/14/2019\n- fix regression bug when no per-provider keys have been configured and private_key_jwt is used\n- bump to 2.4.0rc15\n\n06/06/2019\n- use per-provider signing keys in private_key_jwt authentication towards token endpoint\n- bump to 2.4.0rc14\n\n06/05/2019\n- avoid passing empty key set for JWT decryption (solve but introduced in 2.4.0rc12)\n- bump to 2.4.0rc13\n\n06/03/2019\n- enable per-provider signing and encryption keys; limitations:\n  - for request object signing and id_token decryption only\n  - take the first configured key, no kid specification\n  - no publishing of key information on client endpoints\n  - no userinfo JWT decryption\n  - no composite claims decryption\n  - no backchannel logout with encrypted logout token (inherent)\n- bump to 2.4.0rc12\n\n05/31/2019\n- make sure the content handler is called for every request to the configured Redirect URI so all\n  Apache processing is executed (e.g. setting headers with mod_headers) before returning the response\n  thanks Don Sengpiehl (NB: this may affect browser behavior and backwards compatibility)\n- add ability to view session info in HTML via the session info hook: <redirect_uri)?info=html\n- bump to 2.4.0rc11\n\n05/24/2019\n- fix oidc_proto_html_post auto-post-submit so it no longer results in duplicate parentheses\n  closes #440; thanks @gobreak\n- bump to 2.4.0rc10\n\n05/21/2019\n- log the original URL for expired state cookies, useful for debugging SPA/JS issues\n\n05/17/2019\n- allow removing an access token from the cache (\"remove_at_cache\") when running in OAuth 2.0 RS mode only\n- support refresh and access tokens revocation from an RFC 7009 endpoint upon OIDC session logout\n- bump to 2.4.0rc9\n\n05/03/2019\n- fix (cached) parsing of OIDCOAuthServerMetadataURL; thanks Lance Fannin\n- bump to 2.4.0rc5\n\n05/02/2019\n- correct caching for OIDCOAuthServerMetadataURL\n- bump to 2.4.0rc4\n\n04/21/2019\n- remove option to skip scrubbing request headers (thus avoiding potentionally insecure setups)\n- bump to 2.4.0rc3\n\n04/19/2019\n- add USE_URANDOM compile time option to use /dev/urandom explicitly for non-blocking random number generation\n  configure with APXS2_OPTS=\"-DUSE_URANDOM\"\n- bump to 2.4.0rc2\n\n04/15/2019\n- add debug logs in oidc_proto_generate_random_string\n- URL-encode client_id/client_secret when using client_secret_basic according to: https://tools.ietf.org/html/rfc6749#section-2.3.1\n- bump to 2.4.0rc1\n\n04/09/2019\n- deprecate the OAuth 2.0 Resource Server functionality\n- bump to 2.4.0rc0\n\n03/13/2019\n- release 2.3.11\n\n02/26/2019\n- add session expiry to session info hook response (and change inactivity timeout key)\n- bump to 2.3.11rc2\n\n02/25/2019\n- add option to dynamically pass query parameters to the authorization request; closes #401\n- bump to 2.3.11rc1\n\n01/31/2019\n- support conditional compilation of memcache support\n- bump to 2.3.11rc0\n\n01/22/2019\n- fix XSS vulnerability CSNC-2019-001 wrt. poll parameter in OIDC Session Management RP iframe; thanks Mischa Bachmann\n- release 2.3.10.2\n\n01/16/2019\n- fix bug in current URL detection where query parameters would be duplicated; see #420; thanks @jreynaert\n- release 2.3.10.1\n\n12/31/2018\n- fix warning printout in oidc_delete_oldest_state_cookies\n- release 2.3.10\n\n12/16/2018\n- fix encryption buffer tag length mismatch\n\n12/06/2018\n- retain the unparsed URL path in current/original URL determination, and thereby preserve\n  and support URL-encoded characters in paths when redirecting back to the original URL\n- add state to code exchange token requests only in multi-provider setups; see #402\n- optionally delete the oldest state cookie(s); see #399\n- bump to 2.3.10rc3\n\n11/29/2018\n- add support for refreshing an access token associated with an OIDC session using OIDCRefreshAccessTokenBeforeExpiry\n- bump to 2.3.10rc0\n\n11/15/2018\n- release 2.3.9\n\n11/13/2018\n- fix parsing of cookie name in OIDCOAuthAcceptTokenAs when the cookie option is not listed last \n- bump to 2.3.9rc7\n\n11/12/2018\n- fix OAuth 2.0 RS config check when OIDCOAuthServerMetadataURL is set; thanks @psteniusubi\n- bump to 2.3.9rc6\n\n10/24/2018\n- add support for draft https://www.ietf.org/id/draft-ietf-oauth-mtls-12.txt:\n  OAuth 2.0 Mutual TLS Client Certificate Bound Access Tokens\n  when running as an OAuth 2.0 RS, validating cnf[\"x5t#S256\"] claims.\n- bump to 2.3.9rc5\n\n10/17/2018\n- ignore/trim spaces in X-Forwarded-* headers\n- deal with forwarding proxy setups; see #395 ; thanks @archzone\n- bump to 2.3.9rc4\n\n10/02/2018\n- improve OIDC backchannel logout based on config/Discover\n  - add OIDCProviderBackChannelLogoutSupported config primitive\n  - parse/interpret `backchannel_logout_supported` in Discovery document\n- add `id_token_token_binding_cnf`: `tbh` to dynamic client registration metadata\n- bump to 2.3.9rc3\n\n10/01/2018\n- support backchannel logout according to: https://openid.net/specs/openid-connect-backchannel-1_0.html\n- bump to 2.3.9rc2\n\n10/01/2018\n- add test-cmd command to generate hashes base64urlencoded inputs (cnf/tbh claims)\n\n09/30/2018\n- support Token Binding for Access Tokens according to: https://tools.ietf.org/html/draft-ietf-oauth-token-binding\n- bump to 2.3.9rc1\n\n09/16/2018\n- support nested arrays in Require claim authorization evaluation; see #392; thanks @hpbieker\n- bump to 2.3.9rc0\n\n09/12/2018\n- fix return result FALSE when JWT payload parsing fails; see #389; thanks @amdonov\n- release 2.3.8\n\n08/30/2018\n- add LGTM code quality badges, see #385; thanks @xcorail\n- fix 3 LGTM alerts\n\n08/23/2018\n- improve auto-detection of XMLHttpRequests via Accept header; see #331\n- bump to 2.3.8rc5\n\n08/15/2018\n- initialize test_proto_authorization_request properly; see #382; thanks @jdennis\n- add sanity check on provider->auth_request_method; closes #382; thanks @jdennis\n- bump to 2.3.8rc4\n\n08/14/2018\n- allow usage with LibreSSL; closes #380; thanks @hihellobolke\n- bump to 2.3.8rc3\n\n08/04/2018\n- don't return content with 503 since it will turn the HTTP status code into a 200; see #331\n- bump to 2.3.8rc2\n\n08/03/2018\n- add option to set an upper limit to the number of concurrent state cookies via OIDCStateMaxNumberOfCookies; see #331\n- make the default maximum number of parallel state cookies 7 instead of unlimited; see #331\n- bump to 2.3.8rc1\n\n07/30/2018\n- fix using access token as endpoint auth method in introspection calls; closes #377; thanks @skauffmann\n\n07/25/2018\n- fix reading access_token form POST parameters when combined with `AuthType auth-openidc`; see #376; thanks Nicolas Salerno\n- bump to 2.3.8rc0\n\n07/06/2018\n- abort when string length for remote user name substitution is larger than 255 characters\n- release 2.3.7\n\n07/04/2018\n- fix Redis concurrency issue when used with multiple vhosts\n- bump to 2.3.7rc4 and 2.3.7rc5\n\n06/29/2018\n- add support for authorization server metadata with OIDCOAuthServerMetadataURL as in RFC 8414\n- bump to 2.3.7rc3\n\n06/23/2018\n- refactor session object creation\n- bump to 2.3.7rc2\n\n06/22/2018\n- clear session cookie and contents if cache corruption is detected\n- bump to 2.3.7rc0\n- use apr_pstrdup when setting r->user\n- reserve 255 characters in remote username substition instead of 50\n- bump to 2.3.7rc1\n\n06/15/2018\n- add check to detect session cache corruption for server-based caches and cached static metadata\n- release 2.3.6\n\n05/29/2018\n- avoid using pipelining for Redis\n- bump to 2.3.6rc4\n\n05/28/2018\n- send Basic header in OAuth www-authenticate response if that's the only accepted method; thanks @puiterwijk\n\n05/28/2018\n- refactor Redis cache backend to solve issues on AUTH errors: a) memory leak and b) redisGetReply lagging behind\n- adjust copyright year/org\n- bump to 2.3.6rc3\n\n05/23/2018\n- fix buffer overflow in shm cache key set strcpy; thanks @kyprizel\n- bump to 2.3.6rc2\n\n05/22/2018\n- turn missing session_state from warning into a debug statement\n- fix missing \"return\" on error return from the OP; see #345; thanks @gergan\n- bump to 2.3.6rc1\n\n05/19/2018\n- explicitly set encryption kid so we're compatible with cjose >= 0.6.0\n- bump to 2.3.6rc0\n\n05/18/2018\n- fix encoding of preserved POST data; see #338; thanks @timpuri\n- avoid buffer overflow in shm cache key construction; thanks @kyprizel\n- release 2.3.5\n\n05/08/2018\n- compile with with Libressl; closes #358; thanks @hihellobolke\n- bump to 2.3.5rc0\n\n04/27/2018\n- avoid crash when a relative logout URL parameter is passed in; thanks Vivien Delenne \n- release 2.3.4\n\n03/22/2018\n- interpret X-Forwarded-Host when doing XSRF protection on the after-logout URL; see #341; thanks @pepe79\n- bump to 2.3.4rc4\n\n02/06/2018\n- add support for passing an access token in a HTTP Basic authentication password; thanks @puiterwijk\n- bump to 2.3.4rc3\n\n01/26/2018\n- send session management Javascript logging to debug; thanks @kerrermanisNL\n\n01/25/2018\n- add Cache-Control no-cache header to authorization requests to avoid replays of state/nonce; see #321\n- bump to 2.3.4rc2\n\n01/23/2018\n- add explicit endpoint authentication method \"bearer_access_token\"\n\n12/29/2017\n- correct documentation on kid usage for OIDCOAuthVerifyCertFiles; closes #318\n\n12/21/2017\n- fix compiler warnings for OpenSSL 1.1.x\n- bump to 2.3.4rc1\n\n11/21/2017\n- fix bug where endpoint authentication method \"private_key_jwt\" would not co-exist with \"none\"\n- bump to 2.3.4rc0\n\n11/16/2017\n- add support for passing userinfo as a JSON object or JWT; see #311\n- release 2.3.3\n\n11/13/2017\n- add support for authentication to the introspection endpoint with a bearer token using OIDCOAuthIntrospectionClientAuthBearerToken; thanks @cristichiru\n- bump to 2.3.3rc3\n\n11/08/2017\n- address a number of static code analysis issues\n- bump to 2.3.3rc2\n\n10/10/2017\n- avoid crash when no scheme is set on OIDCProviderMetadataURL; closes #303; thanks @iconoeugen\n- bump to 2.3.3rc1\n\n10/6/2017\n- avoid crash when no OIDCOAuthClientID is set for remote access token validation\n- don't enforce \"iat\" slack checks on locally validaed JWT access tokens\n- bump to 2.3.3rc0\n\n09/18/2017\n- release 2.3.2\n\n09/11/2017\n- fix \"graceful\" restart for shm/redis cache backends; see #296\n- bump to 2.3.2rc8\n\n09/05/2017\n- optionally remove request object parameters from the authorization request URL with \"copy_and_remove_from_request\"; see #294\n- bump to 2.3.2rc7\n\n08/29/2017\n- properly support JSON boolean values in metadata .conf files\n- add regex substitution for *RemoteUserClaim; thanks @hihellobolke\n- bump to 2.3.2rc6\n\n08/27/2017\n- add issuer specific redirect URI option (\"issuer_specific_redirect_uri\") for multi-provider setups to mitigate IDP mixup\n- bump to 2.3.2rc5\n\n08/20/2017\n- fix public clients; add endpoint authentication method \"none\"\n- bump to 2.3.2rc4\n\n08/02/2017\n- update experimental token binding support to https://tools.ietf.org/html/draft-ietf-tokbind-ttrp-01\n  and use header names prefixed with \"Sec-\"; depends on mod_token_binding >= 0.3.4 now\n- bump to 2.3.2rc3\n\n08/01/2017\n- don't abort when mutex operations fail\n- printout textual descriptions of errors returned by mutex operations\n- bump to 2.3.2rc2\n\n07/28/2017\n- fix issue with the combination of shared memory (shm) cache and using encryption (OIDCCacheEncrypt On)\n  where the cache value would be corrupted after the first (successful) retrieval\n- bump to 2.3.2rc1\n\n07/27/2017\n- support paths that are relative to the Apache root dir for:\n  OIDCHTMLErrorTemplate, OIDCPublicKeyFiles, OIDCPrivateKeyFiles,\n  OIDCOAuthVerifyCertFiles, OIDCClientTokenEndpointCert, OIDCClientTokenEndpointKey,\n  OIDCOAuthIntrospectionEndpointCert and OIDCOAuthIntrospectionEndpointKey\n- bump to 2.3.2rc0\n\n07/19/2017\n- handle multiple values in X-Forwarded-* headers as to better support chains of reverse proxies in front of mod_auth_openidc\n- log request headers in oidc_util_hdr_in_get\n- release 2.3.1\n\n07/13/2017\n- remove A128GCM/A192GCM from the supported algorithms in docs/auth_openidc.conf\n  because cjose doesn't support A128GCM and A192GCM (yet)\n- bump to 2.3.1rc5\n\n07/09/2017\n- refactor oidc_get_current_url_port so that it assumes the default port when\n  X-Forwarded-Proto has been set; closes #282 and may address #278\n- bump to 2.3.1rc4\n\n07/07/2017\n- use the defined name (`Provided-Token-Binding-ID`) for the provided token binding ID HTTP header\n  see: https://tools.ietf.org/html/draft-campbell-tokbind-ttrp-00#section-2.1\n  depends on mod_token_binding >= 0.3.0 now\n- bump to 2.3.1rc3\n\n06/29/2017\n- support sending the authentication request via HTTP POST through HTML/Javascript autosubmit\n- bump to 2.3.1rc2\n\n06/28/2017\n- support private_key_jwt and client_secret_jwt as client authentication methods for token introspection\n- bump to 2.3.1rc1\n\n06/22/2017\n- fix bug where token_endpoint_auth set to private_key_jwt would fail to provide the credential if client_secret wasn't set\n- bump to 2.3.1rc0\n\n06/13/2017\n- release 2.3.0\n\n06/07/2017\n- fix file cache backend: allow caching of non-filename friendly keys such as configuration URLs and JWKs URIs\n- enable JQ-based claims expression matching when compiled from source with --with-jq=<dir>, e.g.:\n  Require claims_expr '.aud == \"ac_oic_client\" and (.scope | index(\"profile\") != null)'\n- normalize cache backend logging\n- bump to 2.3.0rc3\n\n06/06/2017\n- avoid cleaning our own state cookie twice when it is expired\n- bump to 2.3.0rc2\n\n06/02/2017\n- refactor remote user handling so it allows for postfixing with the issuer value after applying the regex\n- bump to 2.3.0rc1\n\n05/31/2017\n- add support for custom actions to take after authorization fails with OIDCUnAutzAction\n  this enables stepup authentication scenarios when combined with the following:\n- add OIDCPathAuthRequestParams that is configurable on a per-path basis and use OIDCAuthRequestParams for the static per-provider value\n- add OIDCPathScope that is configurable on a per-path basis and concatenate with OIDCScope as static per-provider value\n- support 3rd-party-init-SSO with additional authentication request params when a single static provider has been configured\n- add support for an empty OIDCClaimPrefix; can be used with OIDCWhiteListedClaims to protect selected headers\n- bump to 2.3.0rc0\n\n05/30/2017\n- support sending Authorization Request as \"request\" object in addition to \"request_uri\"; thanks @suttod\n- support nested claim matching in Require directives; thanks @suttod\n- support explicitly setting the \"kid\" of the private key in OIDCPrivateKeyFiles; thanks @suttod\n\n05/25/2017\n- fix cache fallback so it happens (when enabled) only after failure\n\n05/19/2017\n- make OIDCStripCookies work on AuthType oauth20 paths; closes #273; thanks Michele Danieli\n- bump to 2.2.1rc6\n\n05/18/2017\n- fix parse function of OIDCRequestObject configuration option; thanks @suttod \n\n05/17/2017\n- avoid crash when the X-Forwarded-Proto header is not correctly set by a reverse proxy in front of mod_auth_openidc\n\n05/14/2017\n- support JWT verification against multiple keys with no provided kid by looping over the provided keys with cjose 0.5.0\n- remove OIDC RP certification files; moved to separate repository\n\n05/04/2017\n- improve documentation for OIDCCryptoPassphrase; closes #268\n\n04/30/2017\n- fix wrong return value for cache_file_set in the file cache backend (OIDCCacheType file); thanks Ernani Joppert Pontes Martins\n- bump to 2.2.1rc5\n\n04/29/2017\n- correctly log success/failure in cache_file_set\n- avoid decoding a JSON object and logging an error when the input is NULL\n  e.g. when claims have not been resolved because userinfo endpoint is not set\n\n04/20/2017\n- support relative RedirectURIs; closes #200; thanks @moschlar\n- don't assume that having OIDCCryptPassphrase set means we should validate the config for\n  openid-connect since it can now also be used to encrypt (auth20) cache entries\n- bump to 2.2.1rc4\n\n04/08/2017\n- fix potential crash on prefork process exit when used with Redis cache backend (3x)\n- bump to 2.2.1rc3\n\n04/06/2017\n- change warn log about missing token binding ID to debug log\n\n04/05/2017\n- allow for high session inactivity timeout max value\n- improve error message in oidc_util_http_send when ap_pass_brigade fails and mention possible interference with mod_deflate\n- bump to 2.2.1rc0\n\n03/30/2017\n- merge feature branch back to master:\n  - better support for Single Page Applications, see:\n    https://github.com/zmartzone/mod_auth_openidc/wiki/Single-Page-Applications\n    - add session info hook that is configurable through OIDCInfoHook\n    - add \"AuthType auth-openidc\" option that allows both \"oauth20\" and \"openid-connect\" on the same path\n  - add encryption for all cache entries instead of just session data through OIDCCacheEncrypt\n  - add cookie SameSite flag/policy through OIDCCookieSameSite\n  - return HTTP 200 on OPTIONS requests to (unauthenticated) \"oauth20\" paths\n  - add fallback to a by-value session cookie if the primary session cache fails with OIDCSessionCacheFallbackToCookie\n  - add support for black- and/or white-listing claims with OIDCBlackListedClaims and OIDCWhiteListedClaims\n  - add prototype token binding support in conjunction with:\n    https://github.com/zmartzone/mod_token_binding:\n    - for state & session cookies, see:\n      https://github.com/TokenBinding/Internet-Drafts\n    - for ID tokens with OpenID Connect Token Bound Authentication support, see:\n      http://openid.net/specs/openid-connect-token-bound-authentication-1_0.html\n    - for Authorization Codes with OAuth 2.0 Token Binding for Authorization Codes, see:\n       https://tools.ietf.org/html/draft-ietf-oauth-token-binding\n  - refactoring:\n    - refactor session state, proto state and headers into getters/setters functions\n    - refactor PKCE support\n  - fix removing session state from cache on logout\n  - fix clearing chunked session cookies on logout; closes #246; thanks @Jharmuth\n- release 2.2.0\n\n02/20/2017\n- security fix: scrub headers for \"AuthType oauth20\"\n- release 2.1.6 \n\n02/15/2017\n- improve logging of session max duration and session inactivity timeout\n- refactor so that the call to the refresh hook also resets the session inactivity timeout and passes tokens down\n\n02/14/2017\n- treat only \"X-Requested-With: XMLHttpRequest\" header as a non-browser client; closes #228 ; thanks @mguillem\n- improve error message on state timeout; closes #226; thanks @security4java\n\n02/09/2017\n- correctly parse \"kid\" in OIDCPublicKeyFiles and OIDCOAuthVerifyCertFiles; thanks Alessandro Papacci\n- bump to 2.1.6rc2\n\n02/07/2017\n- fix parsing of mandatory/optional attribute in OIDCOAuthTokenExpiryClaim; closes #225; thanks Alessandro Papacci\n- bump to 2.1.6rc1\n\n02/06/2017\n- improve logging around the availability of session management; closes #223\n\n02/02/2017\n- interpret OIDCUnAuthAction also when the maximum session duration has been exceeded; see #220\n- bump to 2.1.6rc0\n\n01/30/2017\n- security fix: scrub headers when `OIDCUnAuthAction pass` is used for an unauthenticated user\n- release 2.1.5\n\n01/29/2017\n- fix error message about passing id_token with session type client-cookie; mentioned in #220\n- bump to 2.1.5rc0\n\n01/25/2017\n- release 2.1.4\n\n01/18/2017\n- don't echo the query parameters on the error page when an invalid request is made to the Redirect URI; closes #212; thanks @LukasReschke\n\n01/14/2017\n- use dynamic memory buffer for writing HTTP call responses; solves curl/mpm-event interference; see #207\n- bump to 2.1.4rc1\n\n01/10/2017\n- don't crash when data is POST-ed to the redirect URL, it has just 1 POST parameter and it is not \"response_mode\"\n\n01/2/2017\n- remove trailing linebreaks from input in test-cmd tool\n- bump copyright year to 2017\n\n12/14/2016\n- support Libre SSL, see #205, thanks @AliceWonderMiscreations\n- update OIDC logout support to Front-Channel Logout 1.0 draft 01: http://openid.net/specs/openid-connect-frontchannel-1_0.html\n- bump to 2.1.4rc0\n\n12/13/2016\n- release 2.1.3\n\n12/12/2016\n- don't rollover session id's and keep the same session cookie name for cache storage over session updates\n- bump to 2.1.3rc0\n\n11/19/2016\n- release 2.1.2\n\n11/18/2016\n- fix crash when searching for keys with a kid, there's no initial match and x5t values exist for the non-matching keys; closes #196\n\n11/9/2016\n- remove stale claims from session when refreshing them from the userinfo endpoint fails; addresses #194\n- release 2.1.1\n\n11/8/2016\n- log readable error messages when memcache operations fail\n\n11/6/2016\n- fix memory leak when skipping jwks_uri keys with a non-matching \"use\" value\n\n11/4/2016\n- always restore id_token/claims on sub-requests so e.g. listing claims-protected subdirectories will work\n- remove obsolete functions for storing the session in the request state\n- bump to 2.1.1rc0\n\n11/3/2016\n- remove obsolete sessions from session cache; thanks @stevedave\n\n11/1/2016\n- release version 2.1.0\n\n10/28/2016\n- don't include encryption keys from the jwks_uri when verifying a JWT and no kid has been specified\n- fix memory leaks in composite claim handling\n\n10/27/2016\n- handle aggregated and distributed claims from the userinfo endpoint\n- only pick private_key_jwt token endpoint authentication if a private key is configured; closes #189\n- bump to 2.0.1rc7\n\n10/24/2016\n- add OpenID Connect RP certification test script\n- handle non-integer exp/iat timestamps; closes #187; thanks @drdivano\n\n10/21/2016\n- bugfix: first truncate files before writing them\n- support refreshing provider metadata based on timestamp and OIDCProviderMetadataRefreshInterval\n\n10/20/2016\n- bugfix: correctly truncate encryption keys derived from client secret for algorithms that require a key size < 256 bits\n- add test/test-cmd tool\n- bugfix: return error on session cache failures; closes #185; thanks @solsson\n- bump to 2.0.1rc6\n\n10/18/2016\n- bugfix: JWTs with a header that doesn't specify a `kid` that would not validate when used with more than 1 key; closes #184; thanks @solsson\n- bump to 2.0.1rc5\n\n10/13/2016\n- urlencode provider URL cache key to fix file cache backend issue; closes #179, thanks @djahandarie\n\n10/9/2016\n- fix null pointer segfault in debug printout in oidc_util_read_form_encoded_params\n- fix OIDCOAuthAcceptTokenAs parsing flaw introduced in 2.0.0rc5\n- bump to 2.0.1rc4\n\n10/2/2016\n- support presenting the access token to the userinfo endpoint in a POST parameter\n- bump to 2.0.1rc3\n\n9/30/2016\n- support WebFinger Discovery with URL-style user identifiers\n\n9/28/2016\n- fix memory leak in oidc_jwk_to_json\n- add \"remove_at_cache\" hook; addresses #177\n- bump to 2.0.1rc2\n\n9/27/2016\n- add support for Request URI with signed and/or encrypted Request Objects\n- bump to 2.0.1rc1\n\n9/22/2016\n- refuse webfinger responses with an href value that is not on secure https\n- add userinfo JWT response verification and decryption\n\n9/20/2016\n- log the JWT header before optional decryption is applied\n\n9/19/2016\n- check that a sub claim returned from the userinfo endpoint matches the one in the id_token\n- fix issue in oidc_metadata_parse_url so that static default would not be honored\n  - this only affected server-wide OIDCClientJwksUri usage in dynamic client registration\n- non-functional changes for OIDC RP certification:\n  - explicitly log the client authentication method when calling the token endpoint\n  - log the keys that are included for token verification\n- bump to 2.0.1rc0\n\n9/9/2016\n- fix overriding provider token endpoint auth with static config when not set in .conf file\n- don't add our own cookies to the incoming headers\n- allow stripping cookies from the Cookie header sent to the application/backend with OIDCStripCookies\n- release 2.0.0\n\n9/5/2016\n- encapsulate (sub-)directory config handling and fix merging so values can be set back to default values in subdirs\n- bump to 2.0.0rc5\n\n9/2/2016\n- fix JWK creation when no client secret is set e.g. in Implicit flows; closes #168; thanks @asc1\n- bump to 2.0.0rc4\n\n9/1/2016\n- fix HTML decoding of OIDCPreservePost data; closes #165\n- limit max POST data size to 1Mb\n- allow chunked data in POST handling; revise handler\n- change preserve POST JSON data format to urlencoded for performance reasons\n\n8/31/2016\n- allow setting the token endpoint authentication method in the .conf file (for dynamic client registration that sets the .client)\n\n8/30/2016\n- pass refresh token in header/environment variable with OIDCPassRefreshToken; thanks Amit Joshi\n- fix front-channel img-style logout with newer versions of PingFederate that don't send an Accept: image/png header\n\n8/29/2016\n- preserve POST data across authentication requests and discovery with OIDCPreservePost\n- bump to 2.0.0rc3\n\n8/24/2016\n- fix parsing of OIDCOAuthAcceptTokenAs to accept options following \":\"\n- bump to 2.0.0rc2\n\n8/5/2016\n- delete the debian directory\n- rename OIDCOAuthTokenEndpointCert/Key to OIDCOAuthIntrospectionEndpointCert/Key\n- pre-release 2.0.0rc1\n\n7/30/2016\n- encrypt state/session JWT cookies and session JWT cache values for non-shm storages\n\n7/29/2016\n- use cjose - https://github.com/cisco/cjose (master) - for JOSE functions\n- use stricter input parsing functions for configuration values\n- bump to 2.0.0rc0\n\n7/21/2016\n- support TLS client authentication to token and introspection endpoints\n- bump to 1.9.0rc3\n\n7/19/2016\n- add support for chunked session cookies; closes #153; thanks @glatzert \n- bump to 1.9.0rc2\n\n7/9/2016\n- fix Elliptic Curve signature verification for corrupted input\n- support OpenSSL 1.1.x\n- bump to 1.9.0rc1\n\n7/5/2016\n- use AUTHZ_DENIED instead of HTTP_UNAUTHORIZED in oidc_authz_checker; closes #151; thanks @gwollman\n- use signed JWTs for state/session cookies\n- achieve smaller client-cookie sizes for regular cases; no id_token is stored in the session:\n  - (optional) id_token_hint no longer available in session management calls (logout/prompt=none) with \"OIDCSessionType client-cookie\"\n  - \"OIDCPassIDTokenAs serialized\" is not available with \"OIDCSessionType client-cookie\"\n- bump to 1.9.0rc0\n\n6/27/2016\n- use EVP_CIPHER_CTX_new to avoid compilation errors with OpenSSL 1.1.0\n- release 1.8.10\n\n6/22/2016\n- don't use local port setting for current URL determination when X-Forwarded-Host has been set\n- bump to 1.8.10rc4\n\n6/20/2016\n- fix memory leak in OAuth access token introspection result caching (introduced only in 1.8.10rc0)\n- fix setting private_key_jwt or client_secret_jwt with OIDCProviderTokenEndpointAuth\n- bump to 1.8.10rc3\n\n6/19/2016\n- allow setting OIDCRemoteUserClaim with values obtained from the userinfo endpoint; thanks @steve-dave\n- fix OIDCUnAuthAction pass mode for Apache 2.4 and in case `Require claim` primitives used for 2.4 and 2.2; thanks @steve-dave\n- bump to 1.8.10rc2\n\n6/15/2016\n- add support for JWT based client authentication to the token endpoint (client_secret_jwt, private_key_jwt)\n- bump to 1.8.10rc1\n\n6/9/2016\n- add per-path configurable token introspection result cache expiry with OIDCOAuthTokenIntrospectionInterval\n- bump to 1.8.10rc0\n\n6/5/2016\n- release 1.8.9\n\n5/9/2016\n- support 410 option on OIDCUnAuthAction; closes #141\n- bump to 1.8.9rc6\n\n5/1/2016\n- avoid segmentation fault on invalid OIDC configuration when OIDCRedirectURI is not set; fixes #138; thanks @brianwcook\n- bump to 1.8.9rc5\n\n4/18/2016\n- fix get_current_url (proxy) case where r->parsed_uri.path would be null\n\n4/13/2016\n- improve X-Forwarded-Host handling over Host in a) port detection and b) remove port from host value\n- bump to 1.8.9rc4\n\n4/10/2016\n- do not require OIDCClientSecret in configs; allows for Implicit grant without setting a dummy client secret; closes #130\n- allow for public clients calling the token endpoint\n- bump to 1.8.9rc3\n\n4/9/2016\n- ensure that claims from id_token are available for authz also when OIDCPassIDTokenAs does not contain \"claims\"; closes #129\n- bump to 1.8.9rc2\n\n4/3/2016\n- return WWW-Authenticate header and error messages on OAuth paths where access is not granted; closes #124; thanks @spinto\n- bump to 1.8.9rc1\n\n4/1/2016\n- apr_jwe_decrypt_content_aesgcm() null terminate string, #128, thanks @jdennis\n- bump to 1.8.9rc0\n\n3/10/2016\n- release 1.8.8\n\n3/7/2016\n- issue a warning if the \"openid\" scope is not requested\n\n3/6/2016\n- sanitize the OIDCAuthNHeader value before setting the header; thanks @rfk\n- bump to 1.8.8rc7\n\n3/5/2016\n- log exact version of OpenSSL and EC/GCM/Redis support\n- tidy up auth_openidc.conf docs\n- bump to 1.8.8rc6\n\n2/26/2016\n- add option to refresh claims from the userinfo endpoint using OIDCUserInfoRefreshInterval; see #119\n- merge id_token claims in to the set of claims used for authorization for Apache >=2.4; see #120\n- bump to 1.8.8rc5\n\n2/23/2016\n- make state cookie a session cookie and clean expired cookies on entry (merge of fix-firefox-cookie-storage)\n- fix HTML error template initialization in vhosts\n- bump to 1.8.8rc4\n\n2/22/2016\n- don't authenticate (redirect/state) when X-Requested-With header exists; as suggested in #113\n- bump to 1.8.8rc3\n\n2/18/2016\n- pass plain state to the token endpoint on code flows: https://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation-01\n- fix loose (prefix-only) matching of cookie names\n- allow passing OAuth bearer token as a cookie (OIDCOAuthAcceptTokenAs extension for PingAccess)\n- bump to 1.8.8rc2\n\n2/11/2016\n- include token_endpoint_auth_method in dynamic client registration request, set to selected method from provider\n\n2/10/2016\n- Elliptic Curve support now requires OpenSSL 1.0.1 detection\n- bump to 1.8.8rc1\n\n1/14/2016\n- add support for passing in OAuth bearer tokens as one or more of: header, post param or query param (OIDCOAuthAcceptTokenAs)\n- bump to 1.8.8rc0\n\n1/8/2016\n- release 1.8.7\n\n1/7/2016\n- update copyright year\n\n12/17/2015\n- enforce strict matching of issuer in Discovery document against the originally requested issuer\n- check iss/client_id if present in an authentication response\n- push a hash of state to the token endpoint on code flows\n- bump to 1.8.7rc4\n\n12/9/2015\n- improve debug logging around session management capabilities (i.e. enabled/disabled)\n- return 404 for op/rp iframes if session management is not enabled\n- bump to 1.8.7rc3\n\n12/4/2015\n- add support for RFC 7636 PKCE plain & S256 https://tools.ietf.org/html/rfc7636\n- bump to 1.8.7rc2\n\n12/3/2015\n- fix crash when using a custom error template and the error description is NULL\n- fix crash when target_link_uri is not a valid URI or parts are empty\n- fix memory corruption when using custom html template across different server requests; closes #106\n- bump to 1.8.7rc1\n\n11/18/2015\n- fix compiler warning on double sizeof call; close #103; thanks to @dcb314\n- bump to 1.8.7rc0\n\n10/26/2015\n- add option to make session cookie persistent; closes #97\n- release 1.8.6\n\n10/19/2015\n- add support for applying a custom HTML error template with OIDCHTMLErrorTemplate\n- bump to 1.8.6rc3\n\n10/12/2015\n- check the cookie domain that the session was created for against the configured domain\n- log a warning if the Set-Cookie value length is greater than 4093 bytes\n- include and prioritize the X-Forwarded-Host header in hostname determination\n- allow for missing Host header i.e. HTTP 1.0\n- return DONE instead of HTTP_UNAUTHORIZED with Discovery page (prevent double HTML in HTTP 1.0)\n- use apr_strnatcmp instead of strcmp in util.c and mod_auth_openidc.c\n- bump to 1.8.6rc2\n\n10/9/2015\n- support subdomain cookies in OIDCCookieDomain checks; PR #96, thanks @pfiled\n- bump to 1.8.6rc1\n\n10/6/2015\n- add key identifier (\"kid\") option to `OIDCOAuthVerifySharedKeys`, `OIDCOAuthVerifyCertFiles` and `OIDCPublicKeyFiles` configs\n- bump to 1.8.6rc0\n\n9/21/2015\n- support (non-sid-based) HTTP logout: http://openid.net/specs/openid-connect-logout-1_0.html\n- release 1.8.5\n\n9/16/2015\n- improve logging on provider/client/conf metadata parsing failures; closes #94\n- bump to 1.8.5rc7\n\n9/9/2015\n- fix parsing of OIDCOAuthTokenExpiryClaim, thanks to @bester #90\n- bump to 1.8.5rc6\n\n9/4/2015\n- add CSRF protection to external Discovery as well\n- allow browser back after authorization response, see #89\n- handle invalid (expired) authorization response state by sending the user to OIDCDefaultURL, see #86\n- bump to 1.8.5rc5\n\n8/26/2015\n- add CSRF protection to Discovery\n- bump to 1.8.5rc4\n\n8/19/2015\n- support encrypted JWTs using A192KW for key encryption and A192CBC-HS384 for content encryption\n- bump to 1.8.5rc3\n\n8/15/2015\n- support encrypted JWTs using RSA-OAEP for key encryption and A128GCM,A192GCM,A256GCM for content encryption\n- bump to 1.8.5rc2\n\n8/4/2015\n- support for OIDCUnAuthAction: how to act on unauthenticated requests (OIDCReturn401 is deprecated)\n- bump to 1.8.5rc1\n\n7/15/2015\n- add authentication option for Redis server with OIDCRedisCachePassword\n- bump to 1.8.5rc0\n\n7/3/2015\n- allow for compilation on Windows using VS 2013\n- bump to 1.8.4\n\n6/30/2015\n- improve memcache logging: don't report cache misses as an error, thanks to @scottdear\n- work around JSON timestamp print modifier issue (%lld) on some platforms, thanks to @ralphvanetten\n- bump to 1.8.4rc3\n\n6/24/2015\n- support passing claims as environment variables (OIDCPassClaimsAs)\n- bump to 1.8.4rc1\n\n6/22/2015\n- correct debug printout in oidc_util_read_form_encoded_params\n\n6/20/2015\n- avoid double free of JWT after parsing errors have been encountered\n- bump to 1.8.4rc0\n\n6/19/2015\n- make public keys for encrypted access tokens available in OAuth-only configurations; fixes #74\n- remove exceptions for accounts.google.com since Google is OpenID Connect compliant now\n- release 1.8.3\n\n6/15/2015\n- add a complete JWT sample that includes validation of \"exp\" and \"iat\" to the test suite\n\n6/10/2015\n- allow JSON string values for the \"active\" claim in access token validation responses\n- bump to 1.8.3rc4\n\n6/7/2015\n- improve error logging on non-supported JWT signing/encryption algorithms\n- bump to 1.8.3rc3\n\n5/31/2015\n- merge id_token (\"iss\"!) and user info claims for authz processing\n- bump to 1.8.3rc2\n\n5/29/2015\n- fix hash comparison when padded, thanks to @steverc as mentioned in #65\n- fix post-logout URL being set to SSO URL\n- add post-logout URL validation, thanks to @davidbernick\n- bump to 1.8.3rc1\n\n5/18/2015\n- fix OpenSSL version detection for Elliptic Curve support in apr_jwt_signature_to_jwk_type: include opensslv.h\n- fix hash length calculation for Elliptic Curve algorithms\n- release 1.8.2\n\n5/5/2015\n- release 1.8.1\n\n4/21/2015\n- allow setting OIDCDiscoverURL inside of Directory and Location directives as well\n- bump to 1.8.1rc5\n\n4/20/2015\n- allow setting OIDCCookie outside of Directory and Location directives as well\n- bump to 1.8.1rc4\n\n4/17/2015\n- add support for applying regular expressions to OIDCRemoteUserClaim and OIDCOAuthRemoteUserClaim\n- bump to 1.8.1rc3\n\n4/12/2015\n- make token expiry parsing of introspection result configurable (OIDCOAuthTokenExpiryClaim)\n- increase SHM cache key size from 255 to 512 (allows for JWT access tokens cache keys for introspection result)\n- bump to 1.8.1rc2\n\n4/1/2015\n- avoid timing attacks on symmetric key signature/hash comparisons as pointed out by @timmclean\n- bump to 1.8.1rc1\n\n3/19/2015\n- merge #57: fix build with OpenSSL <1.0 re. apr_jws_signature_is_ec (thanks to @szakharchenko)\n\n2/26/2015\n- release 1.8.0\n\n2/23/2015\n- avoid including line feeds in header values (thanks to @forkbomber and @ekanthi)\n- bump to 1.8.0rc5\n\n2/16/2015\n- fix free() crash on simple-valued error printouts\n- fix returning keys without a \"kid\"\n- fix searching for keys with a \"x5t\" thumbprint\n- refactor response type handling; more strict matching of requested response type\n- make compiled in Redis support optional\n- fix oauth.introspection_endpoint_method in initialization\n- bump to 1.8.0rc4\n\n2/15/2015\n- add support for configurable introspection HTTP method (OIDCOAuthIntrospectionEndpointMethod)\n- add preliminary support for GET-style logout\n- bump to 1.8.0rc2\n\n2/12/2015\n- add support for configuration of maximum session duration\n- bump to 1.8.0rc1\n\n2/9/2015\n- check JWT signature against all configured keys (jwks_uri) if no \"kid\" is provided, not just the first one\n- revise JOSE JWS handling part 2\n- complete support for local JWT access token validation\n- bump to 1.8.0rc0\n\n2/5/2015\n- fix symmetric key decryption of JWTs (A128CBC-HS256/A256CBC-HS512)\n- sha256 client secrets before using them as symmetric keys for decryption\n- extended decryption test coverage; avoid double printouts on error\n- refactor JWT header parsing\n- simplify JWK URI refresh handling\n- release 1.7.3\n\n2/4/2015\n- revise JOSE JWK handling part 1\n- change change target_uri parameter name to target_link_uri following draft-bradley-oauth-jwt-encoded-state-03\n- extended tests with stubs\n- refactor JWT validation (iss, exp, iat)\n- fix memory leak with RSA key conversion in apr_jwk.c - apr_jwk_rsa_bio_to_key\n- bump to 1.7.3rc4\n\n1/25/2015\n- Allow {... \"error\": null ...} in JSON responses. (@fatlotus)\n\n1/22/2015\n- fix configuration validation check where no config would be checked if OIDCProviderIssuer is set\n  but both OIDRedirectURI and OIDCCryptoPassphrase are not set\n- add preliminary support for local JWT access token validation\n- bump to 1.7.3rc1\n- sanitize set cookie syntax (get rid of extraneous \";\")\n\n1/21/2015\n- add support for OIDCOAuthIntrospectionTokenParamName (incl. Google OAuth 2.0 access token validation)\n- add a sample OAuth 2.0 config for Google access tokens to README.md\n- release 1.7.2\n\n- add APXS2_OPTS to configure.ac to accommodate RPM builds\n- bump to 1.7.3rc0\n- fix JWT timestamp (iat/exp) initialization issue\n- fix README.md on Google's scope required for returning the \"hd\" claim\n\n1/14/2015\n- add Apache function stubs to enable extending the scope of tests\n- add tests for oidc_proto_validate_access_token and oidc_proto_validate_code\n- bump to 1.7.2rc3\n\n1/12/2015\n- improve accuracy of expired/invalid session handling\n\n1/11/2015\n- add error type and return values to JOSE functions\n- fix return result on error in function that decrypts CEK\n- bump to 1.7.2rc2\n\n1/1/2015\n- update copyright to 2015\n- use json_int_t (seconds) for \"exp\" and \"iat\" fields, instead of apr_time_t (microseconds) \n- correct expiry debug printout\n- bump to 1.7.2rc1\n\n12/15/2014\n- fix Redis reconnect behavior: avoid keep reconnecting after first failure\n- bump to 1.7.2rc0\n\n12/12/2014\n- support passing cookies specified in OIDCPassCookies from browser on to OP/AS calls (for loadbalancing purposes)\n- release 1.7.1\n- document OIDCPassCookies in auth_openidc.conf\n\n12/10/2014\n- reconnect to the Redis server after I/O failure as raised in #43\n- bump to 1.7.1rc4\n\n12/8/2014\n- return http 500 when detecting requests that will loop on return\n- bump to 1.7.1rc3\n\n12/3/2014\n- require the expiring access_token on the refresh hook for XSRF protection\n- pass error codes back to the caller when the refresh hook fails\n- bump to 1.7.1rc2\n\n12/2/2014\n- improve handling of non-string (=non-compliant) error responses\n\n11/26/2014\n- make shared memory cache entry max size configurable through OIDCCacheShmEntrySizeMax\n- add OIDCReturn401 configuration primitive\n- bump to 1.7.1rc1\n\n11/11/2014\n- allow OIDCRedirectURI's with an empty path and fix crash; thanks to @CedricCabessa\n\n11/9/2014\n- support for adding configurable JSON parameters to Dynamic Client Registration requests\n\n11/5/2014\n- release 1.7.0\n\n10/30/2014\n- correct expires_in conversion\n- first stab at HTML templating and make all html HTML 4.01 Strict compliant\n- bump to 1.7.0rc4\n\n10/29/2014\n- document refresh flow\n\n10/28/2014\n- scrub all OIDC_ headers\n- add support for the refresh_token flow + hook\n- pass the expires_in as an absolute timestamp in OIDC_access_token_expires\n- use a global mutex for the Redis cache\n- bump to 1.7.0rc3\n\n10/27/2014\n- generalize support for OAuth 2.0 token introspection and conform to:\n  https://tools.ietf.org/html/draft-ietf-oauth-introspection-00\n\n10/26/2014\n- support regular expressions in Require statements\n\n10/24/2014\n- add support for Redis cache backend; there's a dependency on hiredis headers/library now\n\n10/21/2014\n- refactor nonce generation and remove base64url padding from value\n\n10/13/2014\n- add libssl-dev to Debian control build dependencies\n- release 1.6.0\n\n10/6/2014\n- apply html encoding to error display\n- bump version number to 1.6.0rc4\n\n10/2/2014\n- avoid crash when downloading metadata from OIDCProviderMetadataURL fails\n- set OIDCProviderMetadataURL retrieval interval to 24 hours\n- return error on configurations mixing OIDCProviderMetadataURL and OIDCMetadataDir\n- bump version number to 1.6.0rc3\n\n10/1/2014\n- support provider configuration from a metadata URL (OIDCProviderMetadataURL)\n- bump version number to 1.6.0rc2\n\n9/30/2014\n- be less strict about issuer validation in metadata\n- refactor metadata.c\n- improve logging about userinfo endpoint\n\n9/29/2014\n- refactor cache so it is partitioned in to sections (i.e. avoid future key collisions)\n\n9/25/2014\n- add support for \"x5c\" JWK representation\n- return JWKS on jwks_uri with content-type \"application/json\"\n\n9/17/2014\n- remove support for the X-Frame-Options as it is not needed in 302s\n- create and use log macros that printout function name\n\n9/16/2014\n- support for passing runtime determined authentication request parameters in the discovery response\n- include name/version in logs and bump to 1.6.0rc1\n- don't use the X-Frame-Options by default\n\n9/13/2014\n- add support for the X-Frame-Options header as recommended by the spec\n\n9/12/2014\n- set expiry on state cookies; don't clear session cookie after cache miss or corruption\n- fix JSON array memory leak in oauth.c\n\n9/10/2014\n- merge #34 (g10f), fix session management Javascript bug\n\n9/3/2014\n- improve error handling on hitting the redirect URI directly\n- fix set_slot functions for algorithm/url used as default for dynamic registration\n- rewording of auth_openidc.conf docs on JWK settings\n\n9/1/2014\n- add session management based on http://openid.net/specs/openid-connect-session-1_0.html (draft 21)\n\n8/29/2014\n- add configuration option to POST extra parameters to the token endpoint\n\n8/26/2014\n- correct cookie_path comparison\n- release 1.5.5\n\n8/20/2014\n- correctly error out on flows where no id_token was provided (\"token\")\n\n8/19/2014\n- fix debug printout on open redirect prevention\n- cleanup in-memory crypto context on shutdown\n- use default of \"/\" for OIDCCookiePath to simplify quickstart/simple deployments\n- disable OIDCMetadataDir in sample/default config file\n- clear session cookie after cache miss or corruption\n\n8/18/2014\n- add HttpOnly flag to cookies by default; can be disabled by config\n\n8/14/2014\n- support for passing the id_token in multiple formats (claims|payload|serialized)\n- release 1.5.4\n\n8/13/2014\n- pass the access_token in OIDC_access_token header to the application\n\n8/9/2014\n- merge #21 (Latinovic) to close #18 (big endian JWE issue)\n- merge #20 (wadahiro), support for \"none\" JWT signing algorithm\n\n8/1/2014\n- fix cache initialization/destroy leak\n- release 1.5.3\n\n7/26/2014\n- refactor http code; cleanup JSON encoding in client registration\n- refactor padding handling in base64url encoding/decoding\n\n7/20/2014\n- check for open redirect on passed target_link_uri\n- prevent JWE timing attacks on CEK; add JWE test\n- include client_id and scope values in resolved access_token\n\n7/1/2014\n- pass JSON objects in app HTTP headers as plain JSON\n- correct printout in id_token hash comparisons\n- add more tests\n- release 1.5.2\n\n6/12/2014\n- support third-party-initiated login as defined in the spec\n- release 1.5.1\n- fix PF OAuth 2.0 RS functionality after upgrading to jansson\n\n6/6/2014\n- more changes for Debian packaging (1.5-3)\n\n6/5/2014\n- do not set Secure cookies for plain HTTP\n- add warning/errors when configured hosts/domains do not match\n- release 1.5\n- changes for Debian packaging\n\n6/4/2014\n- fix passing integer claims on non-Mac OS X systems\n- fix claims-based authorization with integer values (@martinsrom)\n- fix getting the id_token from request state and error logging\n- add AUTHORS file with credits\n- migrate README to Markdown README.md\n\n6/3/2014\n- change JSON parser from https://github.com/moriyoshi/apr-json to http://www.digip.org/jansson/\n\n6/2/2014\n- handle X-Forwarded-Proto/X-Forwarded-Port when running behind a proxy/load-balancer\n- release version 1.4\n\n6/1/2014\n- compile with OpenSSL <1.0 and but then disable Elliptic Curve verification\n- fix jwks_uri setting in nested vhosts\n- use OpenSSL_add_all_digests in initialization and EVP_cleanup on shutdown\n\n5/31/2014\n- README additions/improvements\n\n5/29/2014\n- correct big endian detection\n- allow for key identification in JWKs based on thumbprint (x5t)\n\n5/24/2014\n- add cache destroy function and destroy shm cache resources on shutdown\n\n5/23/2014\n- doc corrections to auth_openidc.conf\n\n5/22/2014\n- add implementation of OP-initiated-SSO based on:\n  http://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-01\n- fix nonce caching for replay prevention\n\n5/21/2014\n- correct README on enabling Google+ APIs before applying the sample Google configs\n- fix AuthNHeader setting and allow server-wide config too\n- avoid segfault on corrupted/non- JSON/JWT input\n\n5/20/2014\n- fix URL assembly when running on non-standard port\n- release 1.3\n\n5/17/2014\n- support outgoing proxy using OIDCOutgoingProxy\n- correct sample configs in documentation for missing OIDCCookiePath\n- support OIDCCookiePath in server-wide config as well\n\n5/13/2014\n- support configurable (custom) query parameters in the authorization request\n\n5/12/2014\n- support encrypted JWTs using A128KW and A256KW for the Content Encryption Key\n- support A256CBC-HS512 encrypted JWTs\n- support custom client JWKs URI\n\n5/8/2014\n- support encrypted JWTs using RSA1_5 and A128CBC-HS256\n\n5/2/2014\n- do not use ap_get_remote_host for browser fingerprinting\n\n5/1/2014\n- split out custom client config into separate <issuer>.conf file\n- allow to override client_contact, client_name and registration_token in .conf file\n- remove OIDCRegistrationToken command for the static OP config\n\n4/29/2014\n- support JWT verification of ES256, ES384 and ES512 algorithms\n\n4/28/2014\n- support configurable response_mode (fragment, query or form_post)\n- use nonce in all flows except for OP Google and flows \"code\" or \"code token\"\n\n4/26/2014\n- make client secret optional (support self-issued OP)\n\n4/25/2014\n- support Hybrid flows\n\n4/24/2014\n- fix using Bearer token Authorization header on JSON POST calls\n- support using a Bearer token on client registration calls\n\n4/22/2014\n- match request and response type \n- check at_hash value on \"token id_token\" implicit flow\n- use shared memory caching by default\n- release 1.2\n\n4/19/2014\n- store response_type in state and make state a JSON object\n\n4/18/2014\n- support RSASSA-PSS token signing algorithms (PS256,PS384,PS512)\n\n4/17/2014\n- improve session inactivity timeout handling\n\n4/16/2014\n- set REMOTE_USER and HTTP headers on OAuth 2.0 protected paths\n\n4/15/2014\n- add session inactivity timeout\n- register all supported response_types during client registration and try\n  to pick the one that matches the configured default\n- use long timeouts on JWK retrieval calls\n- allow for non-null but empty query parameters on implicit authorization response\n- simplify azp/aud and nonce handling\n- change session_type naming (to \"server-cache\"/\"client-cookie\")\n\n4/14/2014\n- factor out JOSE related code\n\n4/3/2014\n- add configurable claim name for the REMOTE_USER variable, optionally postfixed with the  url-encoded\n  issuer value; the default for the remote username is \"sub@\" now, makeing it unique across OPs\n- some refactoring of id_token validation functions\n- add INSTALL, move auth_openidc.conf to main directory\n- release 1.1\n\n3/28/2014\n- fix Require claim name mismatch for Apache 2.4\n- fix hmac method/printout naming artifacts from earlier\nauto-search-and-replace\n- release v1.0.1\n\n3/27/2014\n- initial import named mod_auth_openidc\n- updated README\n- fix debian/changelog\n", "########################################################################################\n#\n# Common Settings\n#\n########################################################################################\n\n# (Mandatory)\n# The redirect_uri for this OpenID Connect client; this is a vanity URL\n# that must ONLY point to a path on your server protected by this module\n# but it must NOT point to any actual content that needs to be served.\n# You can use a relative URL like /protected/redirect_uri if you want to\n# support multiple vhosts that belong to the same security domain in a dynamic way\n#OIDCRedirectURI https://www.example.com/protected/redirect_uri\n\n# (Mandatory)\n# Set a password for crypto purposes, this is used for:\n# - encryption of the (temporary) state cookie\n# - encryption of cache entries, that may include the session cookie, see: OIDCCacheEncrypt and OIDCSessionType\n# Note that an encrypted cache mechanism can be shared between servers if they use the same OIDCCryptoPassphrase\n# Only for Apache >= 2.4.x:\n# If the value begins with exec: the resulting command will be executed and the\n# first line returned to standard output by the program will be used as the password.\n# The command may be absolute or relative to the web server root.\n#OIDCCryptoPassphrase [ <passphrase> | \"exec:/path/to/otherProgram arg1\" ]\n\n#\n# All other entries below this are optional though some may be required in a\n# particular setup e.g. OAuth 2.0 Resource Server vs. OpenID Connect Relying Party\n#\n\n# When using multiple OpenID Connect Providers, possibly combined with Dynamic Client\n# Registration and account-based OP Discovery.\n# Specifies the directory that holds metadata files (must be writable for the Apache process/user).\n# When not specified, it is assumed that we use a single statically configured provider as\n# described under the section \"OpenID Connect Provider\" below, most likely using OIDCProviderMetadataURL.\n#OIDCMetadataDir /var/cache/apache2/mod_auth_openidc/metadata\n\n########################################################################################\n#\n# OpenID Connect Provider\n#\n# For configuration of a single static provider, not using OpenID Connect Provider Discovery.\n#\n########################################################################################\n\n# URL where OpenID Connect Provider metadata can be found (e.g. https://accounts.google.com/.well-known/openid-configuration)\n# The obtained metadata will be cached and refreshed every 24 hours.\n# If set, individual entries below will not have to be configured but can be used to add\n# extra entries/endpoints to settings obtained from the metadata.\n# If OIDCProviderMetadataURL is not set, the entries below it will have to be configured for a single\n# static OP configuration or OIDCMetadataDir will have to be set for configuration of multiple OPs.\n#OIDCProviderMetadataURL <url>\n\n# OpenID Connect Provider issuer identifier (e.g. https://localhost:9031 or https://accounts.google.com)\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderIssuer <issuer>\n\n# OpenID Connect Provider Authorization Endpoint URL (e.g. https://localhost:9031/as/authorization.oauth2)\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderAuthorizationEndpoint <authorization_endpoint>\n\n# OpenID Connect Provider JWKS URL (e.g. https://localhost:9031/pf/JWKS)\n# i.e. the URL on which the signing keys for this OP are hosted, in JWK formatting\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderJwksUri <jwks_url>\n\n# OpenID Connect Provider Token Endpoint URL (e.g. https://localhost:9031/as/token.oauth2)\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderTokenEndpoint <token_endpoint>\n\n# Authentication method for the OpenID Connect Provider Token Endpoint.\n# When \"private_key_jwt\" is used, OIDCPrivateKeyFiles and OIDCPublicKeyFiles must have been set.\n# When not defined the default method from the specification is used, i.e. \"client_secret_basic\".\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n# NB: this can be overridden for dynamic client registration on a per-OP basis in the .conf file using the key: token_endpoint_auth\n#OIDCProviderTokenEndpointAuth [ client_secret_basic | client_secret_post | client_secret_jwt | private_key_jwt | none ]\n\n# Extra parameters that need to be passed in the POST request to the Token Endpoint.\n# Parameter names and values need to be provided in URL-encoded form.\n# When not defined no extra parameters will be passed.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: token_endpoint_params\n#OIDCProviderTokenEndpointParams <urlencoded-name1>=<urlencoded-value1>[&<urlencoded-nameN>=<urlencoded-valueN>]* \n\n# OpenID Connect Provider UserInfo Endpoint URL (e.g. https://localhost:9031/idp/userinfo.openid)\n# When not defined no claims will be resolved from such endpoint.\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderUserInfoEndpoint <user_info_endpoint>\n\n# OpenID OP Check Session iFrame URL, for Session Management purposes.\n# When not defined, no Session Management will be applied.\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderCheckSessionIFrame <url>\n\n# OpenID OP End Session Endpoint URL, for Single Logout (Session Management) purposes.\n# When not defined, no logout to the OP will be performed.\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderEndSessionEndpoint <url>\n\n# The RFC 7009 Token Revocation Endpoint URL.\n# When defined, the refresh token and access token stored in an OIDC session will be revoked on logout.\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderRevocationEndpoint <url>\n\n# Define whether the OP supports OpenID Connect Back Channel Logout.\n# According to: https://openid.net/specs/openid-connect-backchannel-1_0.html\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderBackChannelLogoutSupported [On|Off]\n\n# Extra JSON parameters that need to be passed in the registration request to the Registration Endpoint.\n# This settings serves as a default value for multiple OPs only.\n# Parameter names and values need to be provided in JSON form and will be merged in to the request.\n# When not defined no extra parameters will be passed.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: registration_endpoint_params\n#OIDCProviderRegistrationEndpointJson <json-string>\n\n# Define the OpenID Connect scope that is requested from the OP (eg. \"openid email profile\").\n# When not defined, the bare minimal scope \"openid\" is used.\n# NB: multiple scope values must be enclosed in a single pair of double quotes \n# NB: this can be overridden on a per-OP basis in the .conf file using the key: scope\n#OIDCScope \"<scope(s)-separated-by-spaces-and-enclosed-in-double-quotes>\"\n\n# Extra parameters that will be sent along with the Authorization Request.\n# These must be URL-query-encoded as in: \"display=popup&prompt=consent\" or\n# specific for Google's implementation: \"approval_prompt=force\".\n# This is used against a statically configured (single) OP or serves as the default for discovered OPs.\n# As an alternative to this option, one may choose to add the parameters as\n# part of the URL set in OIDCProviderAuthorizationEndpoint or \"authorization_endpoint\"\n# in the .provider metadata (though that would not work with Discovery OPs).\n#\n# Since version 2.3.11rc1 one can pass on query parameters from the request to the authorization\n# request by adding e.g. \"foo=#\" which which will dynamically pull in the query parameter value\n# from the request query parameter and add it to the authentication request to the OP.\n#\n# The default is to not add extra parameters.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: auth_request_params\n#OIDCAuthRequestParams <query-encoded-string>\n\n# Require a valid SSL server certificate when communicating with the OP.\n# (i.e. on token endpoint, UserInfo endpoint and Dynamic Client Registration endpoint)\n# When not defined, the default value is \"On\".\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: ssl_validate_server\n#OIDCSSLValidateServer [On|Off]\n\n# Require configured issuer to match the issuer returned in id_token.\n# (Disable to support Azure AD multi-tenant applications.)\n# When not defined, the default value is \"On\".\n#OIDCValidateIssuer [On|Off]\n\n# The refresh interval in seconds for the claims obtained from the userinfo endpoint\n# When not defined the default is 0, i.e. the claims are retrieved only at session creation time.\n# If refreshing fails, it is assumed that the access token is expired and an attempt will be made\n# to refresh the access token using the refresh token grant, after which a second attempt is made\n# to obtain claims from the userinfo endpoint with the new access token.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_refresh_interval\n#OIDCUserInfoRefreshInterval <seconds>\n\n# The refresh interval in seconds for the JWKs key set obtained from the jwk_uri.\n# When not defined the default is 3600 seconds.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: jwks_refresh_interval\n#OIDCJWKSRefreshInterval <seconds>\n\n# Defines the way in which the access token will be presented to the userinfo endpoint\n# \"authz_header\" means that the token will be presented in an \"Authorization: Bearer\" header using HTTP GET\n# \"post_param\" means that the token will be presented a form-encoded POST parameter using HTTP POST\n# When not defined the default is \"authz_header\".\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_token_method\n#OIDCUserInfoTokenMethod [authz_header|post_param]\n\n# Defines the HTTP method used to pass the parameters in the Authentication Request to the Authorization Endpoint.\n# \"GET\" means that the parameters will be passed as query parameters in an HTTP GET\n# \"POST\" means that the parameters will be passed as form-post parameters in an HTTP POST\n# When not defined the default is \"GET\".\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: auth_request_method\n# OIDCProviderAuthRequestMethod [ GET | POST ]\n\n# The fully qualified names of the files that contain the PEM-formatted RSA Public key or a X.509 certificates\n# that contain the RSA public keys to be used for JWT (OP state/id_token) encryption by the OP.\n# One of these keys must correspond to the private keys defined in OIDCPrivateKeyFiles.\n# When not defined no encryption will be requested.\n# You can also prefix <filename> with a JWK key identifier to manually override the automatically\n# generated \"kid\" that will be used for this key in the JWKs derived from this certificate and\n# published at OIDCClientJwksUri.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key \"keys\" whose value is a JWK set/array (use=sign)\n#OIDCPublicKeyFiles ([<kid>#]<filename>)+\n\n# The fully qualified names of the files that contain the PEM-formatted RSA private\n# keys that can be used to decrypt content sent to us by the OP.\n# These keys must correspond to the public keys defined in OIDCPublicKeyFiles.\n# When not defined no decryption will be possible.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key \"keys\" whose value is a JWK set/array (use=enc)\n#OIDCPrivateKeyFiles ([<kid>#]<filename>)+\n\n########################################################################################\n#\n# OpenID Connect Client\n#\n# Settings used by the client in communication with the OpenID Connect Provider(s),\n# i.e. in Authorization Requests, Dynamic Client Registration and UserInfo Endpoint access.\n# These settings are used when a single static provider is configured and serve as defaults\n# when multiple providers are configured.\n#\n########################################################################################\n\n# The response type (or OpenID Connect Flow) used (this serves as default value for discovered OPs too)\n# When not defined the \"code\" response type is used.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: response_type\n#OIDCResponseType [\"code\"|\"id_token\"|\"id_token token\"|\"code id_token\"|\"code token\"|\"code id_token token\"]\n\n# The response mode used (this serves as default value for discovered OPs too)\n# When not defined the default response mode for the requested flow (OIDCResponseType) is used.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: response_mode\n#OIDCResponseMode [fragment|query|form_post]\n\n# Only used for a single static provider has been configured, see below in OpenID Connect Provider.\n# Client identifier used in calls to the statically configured OpenID Connect Provider.\n#OIDCClientID <client_id>\n\n# Only used for a single static provider has been configured, see below in OpenID Connect Provider.\n# Client secret used in calls to the statically configured OpenID Connect Provider.\n# (not used/required in the Implicit Client Profile, i.e. when OIDCResponseType is \"id_token\")\n#OIDCClientSecret <client_secret>\n\n# Filename with the PEM-formatted client certificate used to authenticate the Client in calls to the\n# token endpoint of the OAuth 2.0 Authorization server.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: token_endpoint_tls_client_cert\n#OIDCClientTokenEndpointCert <filename>\n\n# Filename with the PEM-formatted private key that belongs to the client certificate used to authenticate the\n# Client in calls to the token endpoint of the OAuth 2.0 Authorization server.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: token_endpoint_tls_client_key\n#OIDCClientTokenEndpointKey <filename>\n\n# Password for the PEM-formatted private key that belongs to the client certificate used to authenticate the\n# Client in calls to the token endpoint of the OAuth 2.0 Authorization server.\n# If the value begins with exec: the resulting command will be executed and the\n# first line returned to standard output by the program will be used as the password.\n# The command may be absolute or relative to the web server root.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: token_endpoint_tls_client_key_pwd\n#OIDCClientTokenEndpointKeyPassword [ <passphrase> | \"exec:/path/to/otherProgram arg1\" ]\n\n# The client name that the client registers in dynamic registration with the OP.\n# When not defined, no client name will be sent with the registration request.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: client_name\n#OIDCClientName <client_name>\n\n# The contacts that the client registers in dynamic registration with the OP.\n# Must be formatted as e-mail addresses by specification.\n# Single value only; when not defined, no contact e-mail address will be sent with the registration request.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: client_contact\n#OIDCClientContact <contact>\n\n# The PKCE method used (this serves as default value for discovered OPs too)\n# When not defined PKCE is not used.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: pkce_method\n#OIDCPKCEMethod [plain|S256|referred_tb]\n\n# The OpenID Connect Bound Authentication policy used,\n# see: http://openid.net/specs/openid-connect-token-bound-authentication-1_0.html\n# \"disabled\": no referred token binding will be requested from the User Agent upon redirection to the OP\n# \"optional\": referred token binding will be requested, the \"cnf[\"tbh\"]\" claim is optional on return\n# \"required\": referred token binding will be requested, the \"cnf[\"tbh\"]\" claim must be present when the Client supports Token Binding\n# \"enforced\": referred token binding will be requested, the \"cnf[\"tbh\"]\" claim must be present and the User Agent must support Token Binding\n# When not defined the default is \"optional\".\n#OIDCTokenBindingPolicy [disabled|optional|required|enforced]\n\n# (used only in dynamic client registration)\n# Define the Client JWKs URL (e.g. https://localhost/protected/?jwks=rsa)\") that will be\n# used during client registration to point to the JWK set with public keys for this client.\n# If not defined the default <redirect_uri>?jwks=rsa will be used, on which a JWK set\n# is automatically published based on the OIDCPublicKeyFiles setting so normally you don't\n# need to touch this unless this client is on a (test) host that is not reachable from the internet.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: client_jwks_uri\n#OIDCClientJwksUri <url>\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to sign the id_token.\n# When not defined the default that the OP should use by spec is RS256.\n# (ES??? algorithms only supported when using OpenSSL >= 1.0)\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: id_token_signed_response_alg\n#OIDCIDTokenSignedResponseAlg [RS256|RS384|RS512|PS256|PS384|PS512|HS256|HS384|HS512|ES256|ES384|ES512]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to encrypt the Content Encryption Key that is used to encrypt the id_token.\n# When not defined the default (by spec) is that the OP does not encrypt the id_token.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: id_token_encrypted_response_alg\n#OIDCIDTokenEncryptedResponseAlg [RSA1_5|A128KW|A256KW|RSA-OAEP]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to encrypt to the id_token with the Content Encryption Key.\n# If OIDCIDTokenEncryptedResponseAlg is specified, the default for this value is A128CBC-HS256.\n# When OIDCIDTokenEncryptedResponseEnc is included, OIDCIDTokenEncryptedResponseAlg MUST also be provided.\n# (A256GCM algorithm only supported when using OpenSSL >= 1.0.1)\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: id_token_encrypted_response_enc\n#OIDCIDTokenEncryptedResponseEnc [A128CBC-HS256|A256CBC-HS512|A256GCM]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to sign the UserInfo response\n# When not defined the default (by spec) is that the OP does not sign the response.\n# (ES??? algorithms only supported when using OpenSSL >= 1.0)\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_signed_response_alg\n#OIDCUserInfoSignedResponseAlg RS256|RS384|RS512|PS256|PS384|PS512|HS256|HS384|HS512|ES256|ES384|ES512]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to encrypt the Content Encryption Key that is used to encrypt the UserInfo response.\n# When not defined the default (by spec) is that the OP does not encrypt the response.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_encrypted_response_alg\n#OIDCUserInfoEncryptedResponseAlg [RSA1_5|A128KW|A256KW|RSA-OAEP]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to encrypt to encrypt the UserInfo response with the Content Encryption Key\n# If OIDCUserInfoEncryptedResponseAlg is specified, the default for this value is A128CBC-HS256.\n# When OIDCUserInfoEncryptedResponseEnc is included, OIDCUserInfoEncryptedResponseAlg MUST also be provided.\n# (A256GCM algorithm only supported when using OpenSSL >= 1.0.1)\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_encrypted_response_enc\n#OIDCUserInfoEncryptedResponseEnc [A128CBC-HS256|A256CBC-HS512|A256GCM]\n\n########################################################################################\n#\n# WARNING:\n#\n# THE OAUTH 2.0 RESOURCE SERVER FUNCTIONALITY IS DEPRECATED NOW AND SUPERSEDED\n# BY A SEPARATE MODULE, SEE: https://github.com/zmartzone/mod_oauth2\n#\n# OAuth 2.0 Resource Server Settings\n#\n# Used when this module functions as a Resource Server against an OAuth 2.0 Authorization\n# Server, introspecting/validating bearer Access Tokens.\n#\n########################################################################################\n\n# URL where Authorization Provider Provider metadata can be found (e.g. https://example.com/.well-known/oauth-authorization-server)\n# as defined in RFC 8414. The obtained metadata will be cached and refreshed every 24 hours.\n# If set, individual entries below will not have to be configured but can be used to add\n# extra entries/endpoints to settings obtained from the metadata.\n# If OIDCOAuthServerMetadataURL is not set, the endpoint entries below it will have to be configured.\n#OIDCOAuthServerMetadataURL <url>\n\n# (Mandatory when introspecting opaque access tokens, Optional when performing local JWT access token validation)\n# OAuth 2.0 Authorization Server token introspection endpoint (e.g. https://localhost:9031/as/token.oauth2)\n#OIDCOAuthIntrospectionEndpoint <token-introspection-endpoint>\n\n# Client identifier used in token introspection calls to the OAuth 2.0 Authorization server.\n#OIDCOAuthClientID <client_id>\n\n# Client secret used in token introspection calls to the OAuth 2.0 Authorization server.\n#OIDCOAuthClientSecret <client_secret>\n\n# Authentication method for the OAuth 2.0 Authorization Server introspection endpoint,\n# Used to authenticate the client to the introspection endpoint e.g. with a client_id/client_secret\n# when OIDCOAuthClientID and OIDCOAuthClientSecret have been set and \"client_secret_basic\" or \"client_secret_post\"\n# has been configured.\n# When \"private_key_jwt\" is used, OIDCPrivateKeyFiles and OIDCPublicKeyFiles must have been set.\n# When not defined \"client_secret_basic\" is used.\n#OIDCOAuthIntrospectionEndpointAuth [ client_secret_basic | client_secret_post | client_secret_jwt | private_key_jwt | bearer_access_token | none ]\n\n# Used when \"OIDCOAuthIntrospectionEndpointAuth bearer_access_token\" is configured.\n# Specifies a static token to be used for authorizing the call to the introspection endpoint.\n# If empty, the introspected token will be used for authorization as well.\n#OIDCOAuthIntrospectionClientAuthBearerToken [ a-static-bearer-token | ]\n\n# Filename that contains the PEM-formatted client certificate used to authenticate the\n# caller in token introspection calls to the OAuth 2.0 Authorization server.\n#OIDCOAuthIntrospectionEndpointCert <filename>\n\n# Filename that contains the PEM-formatted private key that belongs to the client certificate used\n# to authenticate the caller in token introspection calls to the OAuth 2.0 Authorization server.\n#OIDCOAuthIntrospectionEndpointKey <filename>\n\n# Define the HTTP method to use for the introspection call. Must be GET or POST.\n# When not defined the default is POST.\n#OIDCOAuthIntrospectionEndpointMethod [POST|GET]\n\n# Extra parameters that need to be passed in the POST request to the Introspection Endpoint.\n# Parameter names and values need to be provided in URL-encoded form.\n# When not defined no extra parameters will be passed.\n#OIDCOAuthIntrospectionEndpointParams <urlencoded-name1>=<urlencoded-value1>[&<urlencoded-nameN>=<urlencoded-valueN>]* \n\n# Name of the parameter whose value carries the access token value in an validation request to the token introspection endpoint.\n# When not defined the default \"token\" is used.\n#OIDCOAuthIntrospectionTokenParamName <param_name>\n\n# Defines the name of the claim that contains the token expiry timestamp, whether it is absolute (seconds since\n# 1970), relative (seconds from now after which the token will expire), and whether it is optional.\n# If the claim is optional and not found in the response, the introspection result will not be cached.\n# (which means that the overall performance may suffer)\n#\n# Only applies when the \"active\" claim is not found in the introspection response, which is interpreted as\n# an introspection method that does not conform to draft-ietf-oauth-introspection, but is custom.\n#\n# When not defined the default \"expires_in\" is used, the expiry is \"relative\" and mandatory, matching\n# Google and PingFederate's introspection behavior.\n#OIDCOAuthTokenExpiryClaim <claim-name> [absolute|relative] [mandatory|optional]\n\n# Define the interval in seconds after which a cached and introspected access token needs\n# to be refreshed by introspecting (and validating) it again against the Authorization Server.\n# (can be configured on a per-path basis)\n# When not defined the value is 0, which means it only expires after the `exp` (or alternative,\n# see OIDCOAuthTokenExpiryClaim) hint as returned by the Authorization Server.\n# When set to -1, caching of the introspection results is disabled and the token will be introspected\n# on each request presenting it.\n#OIDCOAuthTokenIntrospectionInterval <seconds>\n\n# Require a valid SSL server certificate when communicating with the Authorization Server\n# on the token introspection endpoint. When not defined, the default value is \"On\".\n#OIDCOAuthSSLValidateServer [On|Off]\n\n# The symmetric shared key(s) that can be used for local JWT access token validation.\n# NB: this is one or more key tuples where a key tuple consists of:\n#  plain|b64|hex#[<key-identifier>]#<key>\n# When not defined, no access token validation with shared keys will be performed.\n# Examples:\n# - a plaintext secret and a key identifier (kid)\n#     plain#1#mysecret\n# - a base64 encoded secret, no key identifier provided\n#     b64##AF515DE==\n# - a hex encoded secret, no key identifier provided\n#     hex##ede012\n#OIDCOAuthVerifySharedKeys ([plain|b64|hex#][<kid>#]<key>)+\n\n# The fully qualified names of the files that contain the X.509 certificates with the RSA public\n# keys that can be used for local JWT access token verification.\n# NB: this is one or more key tuples where a key tuple consists of:\n#  [<key-identifier>#]<path-to-cert>\n# and the key identifier part is required when the JWT access token contains a \"kid\" in its header.\n# When not defined, no access token validation with statically configured certificates will be performed.\n#OIDCOAuthVerifyCertFiles ([<kid>#]<filename>)+\n\n# The JWKs URL on which the Authorization Server publishes the keys used to sign its JWT access tokens.\n# When not defined local validation of JWTs can still be done using statically configured keys,\n# by setting OIDCOAuthVerifyCertFiles and/or OIDCOAuthVerifySharedKeys.\n#OIDCOAuthVerifyJwksUri <jwks_url>\n\n# The claim that is used when setting the REMOTE_USER variable on OAuth 2.0 protected paths.\n# When not defined the default \"sub\" is used.\n#\n# An optional regular expression can be added as a 2nd parameter that will be applied to the\n# claim value from the 1st parameter and the first match returned from that expression will\n# be set as the REMOTE_USER. E.g. to strip a domain from an e-mail style address you'd use ^(.*)@\n#\n# An optional 3rd parameter can be added that would contain string with number backrefrences.\n# Backrefrences must be in the form $1, $2.. etc.\n# E.g. to extract username in the form DOMAIN\\userid from e-mail style address you may use\n#   ^(.*)@([^.]+)\\..+$ $2\\\\$1\n#OIDCOAuthRemoteUserClaim <claim-name> [<regular-expression>] [substitution-string]\n\n# Define the way(s) in which bearer OAuth 2.0 access tokens can be passed to this Resource Server.\n# Must be one or several of:\n# \"header\" : an \"Authorization: bearer\" header\n# \"post\" :   an HTTP Post parameter called \"access_token\"\n# \"query\" :  as an HTTP query parameter called \"access_token\"\n# \"cookie\" : as a cookie header called \"PA.global\" or using the name specified after \":\"\n# \"basic\":   as a HTTP Basic Auth (RFC2617, section 2) password, with any username\n# When not defined the default \"header\" is used.\n#OIDCOAuthAcceptTokenAs [header|post|query|cookie[:<cookie-name>|basic]+\n\n# The Token Binding policy used for OAuth 2.0 Access Tokens\n# see: https://tools.ietf.org/html/draft-ietf-oauth-token-binding\n# \"disabled\": no token binding ID will be verified in the access token, present or not\n# \"optional\": the \"cnf[\"tbh\"]\" claim is optional in the introspection result or the JWT access token, if it is present it will be verified\n# \"required\": the \"cnf[\"tbh\"]\" claim must be present when the Client supports Token Binding\n# \"enforced\": the \"cnf[\"tbh\"]\" claim must be present and the Client must support Token Binding\n# When not defined the default is \"optional\".\n#OIDCOAuthAccessTokenBindingPolicy [disabled|optional|required|enforced]\n\n\n########################################################################################\n#\n# Cookie Settings\n#\n########################################################################################\n\n# Define the cookie path for the \"state\" and \"session\" cookies.\n# When not defined the default is a server-wide \"/\".\n#OIDCCookiePath <cookie-path>\n\n# Specify the domain for which the \"state\" and \"session\" cookies will be set.\n# This must match the OIDCRedirectURI and the URL on which you host your protected\n# application. When using a relative OIDCRedirectURI this setting should most probably empty.\n# When not defined the default is the server hostname that is currently accessed.\n#OIDCCookieDomain <cookie-domain>\n\n# Define the cookie name for the session cookie.\n# When not defined the default is \"mod_auth_openidc_session\".\n#OIDCCookie <cookie-name>\n\n# OpenID Connect session cookie chunk size.\n# When using \"OIDCSessionType client-cookie\" the session cookie may become quite large if a lot of session\n# data needs to be stored, typically the size depends on the \"scopes\" of information you request. To work\n# around cookie size limitations for most web browsers (usually 4096 bytes), the \"client-cookie\" will be split\n# over a number of \"chunked\" cookies if the resulting session data is over a certain number of bytes, \n# If you want to prevent splitting the session cookie regardless of its size, set the value to 0.\n# When not defined the default chunk size is 4000 bytes\n#OIDCSessionCookieChunkSize 4000\n\n# Defines whether the HttpOnly flag will be set on cookies.\n# When not defined the default is On.\n#OIDCCookieHTTPOnly [On|Off]\n\n# Defines whether the SameSite flag will be set on cookies.\n# When On the following will apply:\n#   state cookie: Lax\n#   session cookie: first time set Lax, updates (e.g. after inactivity timeout) Strict\n#   x_csrf discovery: Strict:\n#\n# The default `SameSite=None` cookie appendix on `Set-Cookie` response headers can be \n# conditionally overridden using an environment variable in the Apache config as in:\n#   SetEnvIf User-Agent \".*IOS.*\" OIDC_SET_COOKIE_APPEND=;\n# (since version 2.4.1)\n#\n# When not defined the default is Off.\n#OIDCCookieSameSite [On|Off]\n\n# Specify the names of cookies to pickup from the browser and send along on backchannel\n# calls to the OP and AS endpoints. This can be used for load-balancing purposes.\n# When not defined, no such cookies are sent.\n#OIDCPassCookies [<cookie-name>]+\n\n# Specify the names of cookies to strip from the incoming request so they are not passed\n# on to the target application(s). This may prevent a large set of chunked session cookies to\n# be sent to the backend. In that case you'd set it to (when using the default OIDCCookie setting):\n#   mod_auth_openidc_session mod_auth_openidc_session_chunks mod_auth_openidc_session_0 mod_auth_openidc_session_1 \n# When not defined, no cookies are stripped.\n#OIDCStripCookies [<cookie-name>]+\n\n# Specify the maximum number of state cookies i.e. the maximum number of parallel outstanding\n# authentication requests. See: https://github.com/zmartzone/mod_auth_openidc/issues/331\n# Setting this to 0 means unlimited, until the browser or server gives up which is the\n# behavior of mod_auth_openidc < 2.3.8, which did not have this configuration option. \n#\n# The optional second boolean parameter if the oldest state cookie(s) will be deleted, \n# even if still valid; see #399.\n#\n# When not defined, the default is 7 and \"false\", thus the oldest cookie(s) will not be deleted.\n#OIDCStateMaxNumberOfCookies <number> [false|true]\n\n# Define the cookie prefix for the state cookie.\n# When not defined the default is \"mod_auth_openidc_state_\".\n#OIDCStateCookiePrefix <cookie-prefix>\n\n########################################################################################\n#\n# Session Settings (only relevant in an OpenID Connect Relying Party setup)\n#\n########################################################################################\n\n# Interval in seconds after which the session will be invalidated when no interaction has occurred.\n# When not defined, the default is 300 seconds.\n#OIDCSessionInactivityTimeout <seconds>\n\n# Maximum duration of the application session\n# When not defined the default is 8 hours (3600 * 8 seconds).\n# When set to 0, the session duration will be set equal to the expiry time of the ID token.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: session_max_duration\n#OIDCSessionMaxDuration <seconds>\n\n# OpenID Connect session storage type.\n# \"server-cache\" server-side caching storage.\n# \"client-cookie\" uses browser-side sessions stored in a cookie; see also OIDCSessionCookieChunkSize next\n# A suffix \":persistent\" can be added if you want to use a persistent cookie that survives browser restarts\n# instead of a session cookie that is tied to the lifetime of the browser session.\n# The \"expires\" value of the persistent cookie is controlled by the OIDCSessionInactivityTimeout setting.\n# When not defined the default \"server-cache\" is used.\n#OIDCSessionType server-cache[:persistent]|client-cookie[:persistent]\n\n# Fallback to \"OIDCSessionType client-cookie\" when \"OIDCSessionType server-cache\" is set and the primary\n# cache mechanism (e.g. memcache or redis) fails. Note that this will come at a cost of:\n#   a) performance\n#       1) since on each subsequent request the primary cache will still be polled and\n#           failback will happen as soon as the primary cache is available again\n#       2) information other than sessions cannot be cached, e.g. resolved access tokens or metadata; see: OIDCCacheType\n#   b) security, since nonce's and jti's are not cached, see: OIDCCacheType\n#   c) (prototype) functionality, since request_uri's won't work anymore\n# When not defined the default is \"Off\".\n#OIDCSessionCacheFallbackToCookie [On|Off]\n\n########################################################################################\n#\n# Cache Settings\n#\n########################################################################################\n\n# Cache type, used for temporary storage that is shared across Apache processes/servers for:\n#  a) session state\n#  b) nonce values to prevent replay attacks\n#  c) validated OAuth 2.0 tokens\n#  d) JWK sets that have been retrieved from jwk_uri's\n#  e) resolved OP metadata when using OIDCProviderMetadataUrl\n#  f) temporary state associated with Request URI's\n# must be one of \\\"shm\\\", \\\"memcache\\\", \\\"file\\\" or, if Redis support is compiled in, \\\"redis\\\" \n# When not defined, \"shm\" (shared memory) is used.\n#OIDCCacheType [shm|memcache|file[|redis]]\n\n# Indicate whether data in the cache backend should be encrypted.\n# When not defined the default is \"Off\" for the \"shm\" backend and \"On\" for all other cache backends\n#OIDCCacheEncrypt [On|Off]\n\n# When using OIDCCacheType \"shm\":\n# Specifies the maximum number of name/value pair entries that can be cached.\n# When caching a large number of entries the cache size limit may be reached and the\n# least recently used entry will be overwritten. If this happens within 1 hour, \n# errors will be displayed in the error.log and the OIDCCacheShmMax value may be increased.\n# When not specified, a default of 500 entries is used.\n# OIDCCacheShmMax <number>\n\n# When using OIDCCacheType \"shm\":\n# Specifies the maximum size for a single cache entry in bytes with a minimum of 8464 bytes.\n# When caching large values such as numbers of attributes in a session or large metadata documents the \n# entry size limit may be overrun, in which case errors will be displayed in the error.log\n# and the OIDCCacheShmEntrySizeMax value has to be increased.\n# When not specified, a default entry size of 16913 bytes (16384 value + 512 key + 17 overhead) is used.\n# OIDCCacheShmEntrySizeMax <bytes>\n\n# When using OIDCCacheType \"file\":\n# Directory that holds cache files; must be writable for the Apache process/user.\n# When not specified a system defined temporary directory (/tmp) will be used.\n#OIDCCacheDir /var/cache/apache2/mod_auth_openidc/cache\n\n# When using OIDCCacheType \"file\":\n# Cache file clean interval in seconds (only triggered on writes).\n# When not specified a default of 60 seconds is used.\n# OIDCCacheFileCleanInterval <seconds>\n\n# Required when using OIDCCacheType \"memcache\":\n# Specifies the memcache servers used for caching as a space separated list of <hostname>[:<port>] tuples.\n#OIDCMemCacheServers \"(<hostname>[:<port>])+\"\n\n# Required if Redis support is compiled in and when using OIDCCacheType \"redis\":\n# Specifies the Redis server used for caching as a <hostname>[:<port>] tuple.\n#OIDCRedisCacheServer <hostname>[:<port>]\n\n# Password to be used if the Redis server requires authentication: http://redis.io/commands/auth\n# When not specified, no authentication is performed.\n#OIDCRedisCachePassword <password>\n\n# Logical database to select on the Redis server: https://redis.io/commands/select\n# When not defined the default database 0 is used.\n#OIDCRedisCacheDatabase <number>\n\n# Timeout for connecting to the Redis servers.\n# When not defined the default connect timeout is 5 seconds.\n#OIDCRedisCacheConnectTimeout <seconds>\n\n# Timeout waiting for a response of the Redis servers after a request was sent.\n# When not defined the default timeout is 5 seconds.\n#OIDCRedisCacheTimeout <seconds>\n\n########################################################################################\n#\n# Advanced Settings\n#\n########################################################################################\n\n# Defines an external OP Discovery page. That page will be called with:\n#    <discovery-url>?oidc_callback=<callback-url>\n# additional parameters may be added, a.o. `target_link_uri`, `x_csrf` and `method`.\n#\n# An Issuer selection can be passed back to the callback URL as in:\n#    <callback-url>?iss=[${issuer}|${domain}|${e-mail-style-account-name}][parameters][&login_hint=<login-hint>][&scopes=<scopes>][&auth_request_params=<params>]\n# where the <iss> parameter contains the URL-encoded issuer value of\n# the selected Provider, or a URL-encoded account name for OpenID\n# Connect Discovery purposes (aka. e-mail style identifier), or a domain name.\n# [parameters] contains the additional parameters that were passed in on the discovery request (e.g. target_link_uri=<url>&x_csrf=<x_csrf>&method=<method>&scopes=<scopes>)\n#\n# When not defined the bare-bones internal OP Discovery page is used.\n#OIDCDiscoverURL <discovery-url>\n\n# Template used to display error messages.\n# The template must be prepared to take two strings, an error title and a more details error description,\n# both HTML encoded values, in that order and referenced by (C-style) \"%s\", e.g. <p>Message:%s</p><p>Description:%s</p>.\n# A minimal example that posts error+detail to another webpage:\n# <html><body onload=\"document.forms[0].submit()\">\n#    <form method=\"post\" action=\"http://example.org/error\">\n#      <input name=\"error\" value=\"%s\">\n#      <input name=\"description\" value=\"%s\">\n#    </form>\n#  </body></html>\n# When not defined a bare-bones internal template is used.\n#OIDCHTMLErrorTemplate <filename>\n\n# Defines a default URL to be used in case of 3rd-party-init-SSO when no explicit target_link_uri\n# has been provided. The user is also redirected to this URL in case an invalid authorization\n# response was received.\n#\n# By default, when no OIDCDefaultURL is set, an expired state cookie will lead to an HTML error page\n# being sent to the browser explaining what happened. To copy that (legacy) behaviour when OIDCDefaultURL is set,\n# so that the browser is no longer redirected to the OIDCDefaultURL in case of state cookie expiry, use:\n#   SetEnvIfExpr true OIDC_NO_DEFAULT_URL_ON_STATE_TIMEOUT=true \n#\n# The default is to not redirect the browser to any URL but return an HTTP/HTML error to the user.\n#OIDCDefaultURL <default-url>\n\n# Defines a default URL where the user is sent to after logout, which may be overridden explicitly during logout.\n# When not defined and no URL was passed explicitly, a default internal page will be shown.\n#OIDCDefaultLoggedOutURL <url>\n\n# Define the OpenID Connect scope(s) that is requested from the OP (eg. \"admin edit\")\n# on a per-path basis in addition to the per-provider configured scopes (OIDCScope).\n# NB: multiple scope values must be enclosed in a single pair of double quotes \n#OIDCPathScope \"<scope(s)-separated-by-spaces-and-enclosed-in-double-quotes>\"\n\n# Extra parameters that will be sent along with the Authorization Request.\n# These must be URL-query-encoded as in: \"display=popup&prompt=consent\".\n#\n# NB: since version 2.3.0 this can be configured on a per-path basis across all configured Providers.\n#\n# Since version 2.3.11rc1 one can pass on query parameters from the request to the authorization\n# request by adding e.g. \"foo=#\" which which will dynamically pull in the query parameter value\n# from the request query parameter and add it to the authentication request to the OP.\n#\n# The default is to not add extra parameters.\n#OIDCPathAuthRequestParams <query-encoded-string>\n\n# Acceptable offset (before and after) for checking the \\\"iat\\\" (= issued at) timestamp in the id_token.\n# When not defined the default is 600 seconds.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: idtoken_iat_slack\n#OIDCIDTokenIatSlack <seconds>\n\n# The prefix to use when setting claims (openid-connect or oauth20) in the HTTP headers/environment variables.\n# This prefix should not be set to \"\" except when combined with OIDCWhiteListedClaims to maintain a secure setup.\n# When not defined, the default \"OIDC_CLAIM_\" is used.\n#OIDCClaimPrefix <prefix>\n\n# The delimiter to use when setting multi-valued claims (openid-connect or oauth20) in the HTTP headers/environment variables.\n# When not defined the default \",\" is used.\n#OIDCClaimDelimiter <char>\n\n# The claim that is used when setting the REMOTE_USER variable on OpenID Connect protected paths.\n# If the claim name is postfixed with a \\\"@\\\", the claim value will be post-fixed with the\n# \\\"iss\\\" value value (with leading \"https://\" stripped) to make this value unique across different OPs.\n# When not defined the default \"sub@\" is used.\n#\n# An optional regular expression can be added as a 2nd parameter that will be applied to the\n# resulting value from the 1st parameter and the first match returned from that expression will\n# be set as the REMOTE_USER. E.g. to strip a domain from an e-mail style address you'd use ^(.*)@\n#\n# An optional 3rd parameter can be added that would contain string with number backrefrences.\n# Backrefrences must be in the form $1, $2.. etc.\n# E.g. to extract username in the form DOMAIN\\userid from e-mail style address you may use\n#  ^(.*)@([^.]+)\\..+$ $2\\\\$1\n#OIDCRemoteUserClaim <claim-name>[@] [<regular-expression>] [substitution-string]\n\n# Define the way(s) in which the id_token contents are passed to the application according to OIDCPassClaimsAs.\n# Must be one or several of:\n# \"claims\" :     the claims in the id_token are passed in individual headers/environment variables\n# \"payload\" :    the payload of the id_token is passed as a JSON object in the \"OIDC_id_token_payload\" header/environment variable\n# \"serialized\" : the complete id_token is passed in compact serialized format in the \"OIDC_id_token\" header/environment variable\n# Note that when OIDCSessionType client-cookie is set, the id_token itself is not stored in the session/cookie and as such\n# the headers for the \"payload\" and \"serialized\" option will not be created.\n# When not defined the default \"claims\" is used.\n#OIDCPassIDTokenAs [claims|payload|serialized]+\n\n# Define the way(s) in which the claims resolved from the userinfo endpoint are passed to the application according to OIDCPassClaimsAs.\n# Must be one or several of:\n# \"claims\" :     the userinfo claims are passed in individual headers/environment variables\n# \"json\" :       a self-contained userinfo JSON object is passed in the \"OIDC_userinfo_json\" header/environment variable\n# \"jwt\" :        a signed/encrypted JWT (if available!) optionally resolved from the userinfo endpoint is passed in the \"OIDC_userinfo_jwt\" header/environment variable\n# When not defined the default \"claims\" is used.\n#OIDCPassUserInfoAs [claims|json|jwt]+\n\n# Define the way in which the claims and tokens are passed to the application environment:\n# \"none\": no claims/tokens are passed\n# \"environment\": claims/tokens are passed as environment variables\n# \"headers\": claims/tokens are passed in headers (also useful in reverse proxy scenario's)\n# \"both\": claims/tokens are passed as both headers as well as environment variables (default)\n#\n# Since version 2.4.6 one can specify \"base64url\" as the 2nd argument to apply base64url encoding to\n# all values passed in headers.\n#\n# When not defined the default is \"both\" and base64url encoding is not applied to the header values.\n#\n# The access token is passed in OIDC_access_token; the access token expiry is passed in OIDC_access_token_expires.\n# The refresh token is only passed in OIDC_refresh_token if enabled for that specific directory/location (see: OIDCPassRefreshToken)\n#OIDCPassClaimsAs [none|headers|environment|both] [base64url]\n\n# Specify the HTTP header variable name to set with the name of the authenticated user,\n# i.e. copy what is set in REMOTE_USER and configured in OIDCRemoteUserClaim or OIDCOAuthRemoteUserClaim.\n# When not defined no such header is added.\n# This setting can be configured for both the \"openid-connect\" and \"oauth20\" AuthType on\n# a server-wide or directory level.\n#OIDCAuthNHeader <header-name>\n\n# Timeout in seconds for long duration HTTP calls. This is used for most requests to remote endpoints/servers.\n# When not defined the default of 60 seconds is used.\n#OIDCHTTPTimeoutLong <seconds>\n\n# Timeout in seconds for short duration HTTP calls; used for Client Registration and OP Discovery requests.\n# When not defined the default of 5 seconds is used.\n#OIDCHTTPTimeoutShort <seconds>\n\n# Time to live in seconds for state parameter i.e. the interval in which the authorization request\n# and the corresponding response need to be processed. When not defined the default of 300 seconds is used.\n#OIDCStateTimeout <seconds>\n\n# Scrub user name and claim headers (as configured above) from the user's request.\n# The default is \"On\"; use \"Off\" only for testing and debugging because it renders your system insecure.\n#OIDCScrubRequestHeaders [On|Off] \n\n# Specify an outgoing proxy for your network.\n# When not defined no outgoing proxy is used.\n#OIDCOutgoingProxy <host>[:<port>]\n\n# Defines the action to be taken when an unauthenticated request is made.\n#\n# \"auth\" means that the user is redirected to the OpenID Connect Provider or Discovery page.\n# \"401\" means that HTTP 401 Unauthorized is returned.\n# \"407\" means that HTTP 407 Proxy Authentication Required is returned\n# \"410\" means that HTTP 410 Gone is returned\n# \"pass\" means that an unauthenticated request will pass but claims will still be passed when a user happens to be authenticated already\n#\n# Useful in Location/Directory/Proxy path contexts that serve AJAX/Javascript calls and for \"anonymous access\"\n#\n# When not defined the default is \"auth\" with auto-detection of XML HTTP requests, which would get \"401\".\n# The default auto-detection algorithm looks for the \"X-Requested-With: XMLHttpRequest\" header/value,\n# and/or the absence of \"Accept\" header with any of the values \"text/html\" \"application/xhtml+xml\" or \"*/*\"\n# and returns 401 for such non-browser/non-html clients. See: https://github.com/zmartzone/mod_auth_openidc/wiki/Cookies#tldr\n# \n# Only for Apache >= 2.4.x:\n# Since verson 2.4.4 a boolean Apache expression as the second parameter to specify which requests\n# need to match to return the configured value in the first parameter to override the default \"auth\".\n# See also: https://httpd.apache.org/docs/2.4/expr.html.\n# E.g.:\n#   OIDCUnAuthAction 401 \"%{HTTP_USER_AGENT} =~ /curl/\"\n# to return 401 for cURL based user agents and \"auth\" for any other browsers/user agents.\n#   OIDCUnAuthAction 401 \"%{HTTP:X-Requested-With} == 'XMLHttpRequest'\"\n# to effectively override the default XML request detection algorithm by ignoring the Accept headers\n#   OIDCUnAuthAction 401 \"%{HTTP_ACCEPT} !~ m#text/html#\"\n# to return 401 for all user agents that do not send an Accept header that includes a \"text/html\" value\n#   OIDCUnAuthAction 401 \"%{HTTP:X-Requested-With} == 'XMLHttpRequest' || ( ( %{HTTP_ACCEPT} !~ m#text/html# ) && ( %{HTTP_ACCEPT} !~ m#application/xhtml\\+xml# ) && ( %{HTTP_ACCEPT} !~ m#\\*/\\*# ) )\"\n# just as a more complex example, it equals the default XML request detection algorithm\n#   OIDCUnAuthAction auth true\n# To disable auto-detection of XML HTTP request altogether and uncondtionally return \"auth\" for all clients.\n# Note that actually *any* expression value in \"OIDCUnAuthAction auth <expr>\" will *always* render \"auth\"\n# (even when set to \"false\"...) because of the default, so using an <expr> value (other than \"true\") only\n# makes sense in combination with one of the values other than \"auth\".\n#OIDCUnAuthAction [auth|pass|401|407|410] [<expr>]\n\n# Defines the action to be taken when an unauthorized request is made i.e. the user is authenticated but\n# does not meet the `Require claim *:*` directives or similar.\n# \"401\" means that HTTP 401 Unauthorized is returned.\n# \"403\" means that HTTP 403 Forbidded is returned: NB: for Apache 2.4 this is controlled by the AuthzSendForbiddenOnFailure directive!\n# \"auth\" means that the user is redirected to the OpenID Connect Provider or Discovery page.\n# Useful in Location/Directory/Proxy path contexts that need to do stepup authentication\n# When not defined the default \"401\" is used.\n#OIDCUnAutzAction [401|403|auth]\n\n# Indicates whether POST data will be preserved across authentication requests (and discovery in case of multiple OPs).\n# This is designed to prevent data loss when a session timeout occurs in a (long) user filled HTML form.\n# It cannot handle arbitrary payloads for security (DOS) reasons, merely form-encoded user data.\n# Preservation is done via HTML 5 local storage: note that this can lead to private data exposure on shared terminals.\n# The default is \"Off\" (for security reasons). Can be configured on a per Directory/Location basis.\n#OIDCPreservePost [On|Off]\n\n# Indicates whether the refresh token will be passed to the application in a header/environment variable, according\n# to the OIDCPassClaimsAs directive.\n# Can be configured on a per Directory/Location basis. The default is \"Off\". \n#OIDCPassRefreshToken [On|Off]\n\n# Request Object/URI settings expressed as a string that is a \"double-quote-escaped\" JSON object. For example:\n# \"{ \\\"copy_from_request\\\": [ \\\"claims\\\", \\\"response_type\\\", \\\"response_mode\\\", \\\"login_hint\\\", \\\"id_token_hint\\\", \\\"nonce\\\", \\\"state\\\", \\\"redirect_uri\\\", \\\"scope\\\", \\\"client_id\\\" ], \\\"static\\\": { \\\"some\\\": \\\"value\\\", \\\"some_nested\\\": { \\\"some_array\\\": [ 1,2,3] } }, \\\"crypto\\\": { \\\"sign_alg\\\": \\\"HS256\\\", \\\"crypt_alg\\\": \\\"A256KW\\\", \\\"crypt_enc\\\": \\\"A256CBC-HS512\\\" }, \\\"url\\\": \\\"https://www.zmartzone.eu/protected/\\\", \\\"request_object_type\\\" : \\\"request\\\" }\"\n# Parameters:\n#   copy_from_request (array)            : array of query parameter names copied from request\n#   copy_and_remove_from_request (array) : array of parameter names copied from request and removed as query parameter\n#   static (object)                      : parameter value is merged to the request object\n#   crypto (object)                      : defines cryptography used to create request object\n#     sign_alg (string)                  : algorithm used to sign request object (JWS alg parameter)\n#     crypt_alg (string)                 : algorithm used to encrypt CEK of request object (JWE alg parameter)\n#     crypt_enc (string)                 : algorithm used to encrypt request object (JWE enc parameter)\n#   url (string)                         : use this url instead of redirect_uri for request_uri\n#   request_object_type (string)         : parameter used for sending authorization request object\n#                                          \"request_uri\" (default) or \"request\"\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: request_object\n#OIDCRequestObject <stringified-and-double-quote-escaped-JSON-object>\n\n# Provider metadata refresh interval for the metadata in a multi-provider setup (with OIDCMetadataDir).\n# When not defined the default is 0 seconds, i.e. it is never refreshed.\n# Also used in a single provider setup with OIDCProviderMetadatURL but 0 then means the default of 1 day.\n#OIDCProviderMetadataRefreshInterval <seconds>\n\n# Define the data that will be returned upon calling the info hook.\n# The data can be JSON formatted using <redirect_uri>?info=json, or HTML formatted, using <redirect_uri>?info=html.\n#   iat (int)                  : Unix timestamp indicating when this data was created\n#   access_token (string)      : the access token\n#   access_token_expires (int) : the Unix timestamp which is a hint about when the access token will expire (as indicated by the OP)\n#   id_token (object)          : the claims presented in the ID token\n#   userinfo (object)          : the claims resolved from the UserInfo endpoint\n#   refresh_token (string)     : the refresh token (if returned by the OP)\n#   exp (int)                  : the maximum session lifetime (Unix timestamp in seconds)\n#   timeout (int)              : the session inactivity timeout (Unix timestamp in seconds)\n#   remote_user (string)       : the remote user name\n#   session (object)           : (for debugging) mod_auth_openidc specific session data such as \"remote user\", \"session expiry\", \"session id\" and a \"state\" object\n# Note that when using ProxyPass / you may have to add a proxy exception for the Redirect URI \n# for this to work, e.g. ProxyPass /redirect_uri !\n# When not defined the session hook will not return any data but a HTTP 404\n#OIDCInfoHook [iat|access_token|access_token_expires|id_token|userinfo|refresh_token|exp|timeout|remote_user|session]+\n\n# Specify claims that should be removed from the userinfo and/or id_token before storing them in the session.\n# Note that OIDCBlackListedClaims takes precedence over OIDCWhiteListedClaims\n# When not defined no claims are blacklisted and all claims are stored except when OIDCWhiteListedClaims is used.\n#OIDCBlackListedClaims [<claim>]+\n\n# Specify claims from the userinfo and/or id_token that should be stored in the session (all other claims will be discarded).\n# Note that OIDCBlackListedClaims takes precedence over OIDCWhiteListedClaims\n# When not defined no claims are whitelisted and all claims are stored except when blacklisted with OIDCBlackListedClaims.\n#OIDCWhiteListedClaims [<claim>]+\n\n# Specify the minimum time-to-live for the access token stored in the OIDC session.\n# When the access token expiry timestamp (or at tleast the hint given to that) is less than this value,\n# an attempt will be made to refresh the access token using the refresh token grant type with the OP.\n# This only has effect if a refresh token was actually returned from the OP and an \"expires_in\" hint\n# was returned as part of the authorization response (and subsequent refresh token responses).\n# When not defined no attempt is made to refresh the access token (unless implicitly with OIDCUserInfoRefreshInterval)\n# The optional logout_on_error flag makes the refresh logout the current local session if the refresh fails.\n#OIDCRefreshAccessTokenBeforeExpiry <seconds> [logout_on_error]\n\n# Defines whether the value of the User-Agent and X-Forwarded-For headers will be used as the input\n# for calculating the fingerprint of the state during authentication.\n# When not defined the default \"both\" is used.\n#OIDCStateInputHeaders [none|user-agent|x-forwarded-for|both]\n\n# Define one or more regular expressions that specify URLs (or domains) allowed for post logout and\n# other redirects such as the \"return_to\" value on refresh token requests, and the \"login_uri\" value\n# on session management based logins through the OP iframe, e.g.:\n#   OIDCRedirectURLsAllowed ^https://www.example.com ^https://(\\w+).example.org ^https://example.net/app\n# or:\n#   OIDCRedirectURLsAllowed ^https://www.example.com/logout$ ^https://www.example.com/app/return_to$ \n# When not defined, the default is to match the hostname in the URL redirected to against\n# the hostname in the current request.\n#OIDCRedirectURLsAllowed [<regexp>]+\n", "AC_INIT([mod_auth_openidc],[2.4.9.3],[hans.zandbelt@zmartzone.eu])\n\nAC_SUBST(NAMEVER, AC_PACKAGE_TARNAME()-AC_PACKAGE_VERSION())\n\n# This section defines the --with-apxs2 option.\nAC_ARG_WITH(\n\t[apxs2],\n\t[  --with-apxs2=PATH       Full path to the apxs2 executable.],\n\t[\n\t\tAPXS2=${withval}\n\t],)\n\n\nif test \"x$APXS2\" = \"x\"; then\n   # The user didn't specify the --with-apxs2-option.\n\n   # Search for apxs2 in the specified directories\n   AC_PATH_PROG(APXS2, apxs2,,\n\t\t/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin)\n\n   if test \"x$APXS2\" = \"x\"; then\n      # Didn't find apxs2 in any of the specified directories.\n      # Search for apxs instead.\n      AC_PATH_PROG(APXS2, apxs,,\n\t\t   /usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin)\n   fi\n\nfi\n\n# Test if $APXS2 exists and is an executable.\nif test ! -x \"$APXS2\"; then\n   # $APXS2 isn't a executable file.\n   AC_MSG_ERROR([\nCould not find apxs2. Please specify the path to apxs2\nusing the --with-apxs2=/full/path/to/apxs2 option.\nThe executable may also be named 'apxs'.\n])\nfi\n\n# Replace any occurrences of @APXS2@ with the value of $APXS2 in the Makefile.\nAC_SUBST(APXS2)\n\n# Use environment variable APXS2_OPTS to pass params to APXS2 command\nAC_ARG_VAR(APXS2_OPTS, [Additional command line options to pass to apxs2.])\n\n# We need the curl library for HTTP callouts.\nPKG_CHECK_MODULES(CURL, libcurl)\nAC_SUBST(CURL_CFLAGS)\nAC_SUBST(CURL_LIBS)\n\n# We need OpenSSL for crypto and HTTPS callouts.\nPKG_CHECK_MODULES(OPENSSL, openssl)\nAC_SUBST(OPENSSL_CFLAGS)\nAC_SUBST(OPENSSL_LIBS)\n\nPKG_CHECK_MODULES(APR, [apr-1, apr-util-1])\nAC_SUBST(APR_CFLAGS)\nAC_SUBST(APR_LIBS)\n\n# older versions of libapr may not have memcache support\nold_CPPFLAGS=$CPPFLAGS\nCPPFLAGS=\"${APR_CFLAGS} $CPPFLAGS\"\nAC_CHECK_HEADERS([apr_memcache.h], [HAVE_MEMCACHE=1], [HAVE_MEMCACHE=0])\nAC_SUBST(HAVE_MEMCACHE)\nCPPFLAGS=$old_CPPFLAGS\n\n# We need Jansson for JSON parsing.\nPKG_CHECK_MODULES(JANSSON, jansson)\nAC_SUBST(JANSSON_CFLAGS)\nAC_SUBST(JANSSON_LIBS)\n\n# cjose\nPKG_CHECK_MODULES(CJOSE, cjose)\nAC_SUBST(CJOSE_CFLAGS)\nAC_SUBST(CJOSE_LIBS)\n\n# PCRE\nPKG_CHECK_MODULES(PCRE, libpcre)\nAC_SUBST(PCRE_CFLAGS)\nAC_SUBST(PCRE_LIBS)\n\n# Redis\nAC_ARG_WITH([hiredis],\n  [AS_HELP_STRING([--with-hiredis],\n    [support Redis @<:@default=check@:>@])],\n  [],\n  [with_hiredis=yes])\nAS_CASE([\"$with_hiredis\"],\n  [yes], [if test \"$HIREDIS_LIBS\" == \"\"; then PKG_CHECK_MODULES([HIREDIS], [hiredis], [HAVE_LIBHIREDIS=1], [HAVE_LIBHIREDIS=0]) ; else [HAVE_LIBHIREDIS=1] ; fi],\n  [no], [HAVE_LIBHIREDIS=0],\n  [PKG_CHECK_MODULES([HIREDIS], [hiredis], [HAVE_LIBHIREDIS=1], [HAVE_LIBHIREDIS=0])])\nAC_SUBST(HAVE_LIBHIREDIS)\nAC_SUBST(HIREDIS_CFLAGS)\nAC_SUBST(HIREDIS_LIBS)\n\n# JQ\nHAVE_LIBJQ=0\n\nAC_ARG_WITH(jq,\n        [  --with-jq=PATH          location of your libjq installation])\n    \nif test -n \"$with_jq\"\nthen\n    JQ_CFLAGS=\"-I$with_jq/include\"\n    JQ_LIBS=\"-L$with_jq/lib -ljq\"\n\n\tCPPFLAGS=\"$JQ_CFLAGS $CPPFLAGS\"\n\tAC_CHECK_HEADERS([jq.h], , [HAVE_LIBJQ=0])\n\n\tLDFLAGS=\"$JQ_LIBS $LDFLAGS\"\n\tAC_CHECK_LIB([jq], [jq_init], [HAVE_LIBJQ=1], [HAVE_LIBJQ=0])\n\tif test \"x$have_jq\" = \"x0\" ; then\n  \t\tAC_MSG_WARN(\"cannot find library for -ljq.\")\n\tfi\nfi\n\nAC_SUBST(HAVE_LIBJQ)\nAC_SUBST(JQ_CFLAGS)\nAC_SUBST(JQ_LIBS)\n\n# Create Makefile from Makefile.in\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/***************************************************************************\n * Copyright (C) 2017-2021 ZmartZone Holding BV\n * Copyright (C) 2013-2017 Ping Identity Corporation\n * All rights reserved.\n *\n * DISCLAIMER OF WARRANTIES:\n *\n * THE SOFTWARE PROVIDED HEREUNDER IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT\n * ANY WARRANTIES OR REPRESENTATIONS EXPRESS, IMPLIED OR STATUTORY; INCLUDING,\n * WITHOUT LIMITATION, WARRANTIES OF QUALITY, PERFORMANCE, NONINFRINGEMENT,\n * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  NOR ARE THERE ANY\n * WARRANTIES CREATED BY A COURSE OR DEALING, COURSE OF PERFORMANCE OR TRADE\n * USAGE.  FURTHERMORE, THERE ARE NO WARRANTIES THAT THE SOFTWARE WILL MEET\n * YOUR NEEDS OR BE FREE FROM ERRORS, OR THAT THE OPERATION OF THE SOFTWARE\n * WILL BE UNINTERRUPTED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Initially based on mod_auth_cas.c:\n * https://github.com/Jasig/mod_auth_cas\n *\n * Other code copied/borrowed/adapted:\n * shared memory caching: mod_auth_mellon\n *\n * @Author: Hans Zandbelt - hans.zandbelt@zmartzone.eu\n *\n **************************************************************************/\n\n#include \"apr_hash.h\"\n#include \"apr_strings.h\"\n#include \"ap_config.h\"\n#include \"ap_provider.h\"\n#include \"apr_lib.h\"\n#include \"apr_file_io.h\"\n#include \"apr_sha1.h\"\n#include \"apr_base64.h\"\n\n#include \"httpd.h\"\n#include \"http_core.h\"\n#include \"http_config.h\"\n#include \"http_log.h\"\n#include \"http_protocol.h\"\n#include \"http_request.h\"\n\n#include \"mod_auth_openidc.h\"\n\n#define OIDC_REFRESH_ERROR 2\n\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url);\n\n// TODO:\n// - sort out oidc_cfg vs. oidc_dir_cfg stuff\n// - rigid input checking on discovery responses\n// - check self-issued support\n// - README.quickstart\n// - refresh metadata once-per too? (for non-signing key changes)\n\nextern module AP_MODULE_DECLARE_DATA auth_openidc_module;\n\n/*\n * clean any suspicious headers in the HTTP request sent by the user agent\n */\nstatic void oidc_scrub_request_headers(request_rec *r, const char *claim_prefix,\n\t\tapr_hash_t *scrub) {\n\n\tconst int prefix_len = claim_prefix ? strlen(claim_prefix) : 0;\n\n\t/* get an array representation of the incoming HTTP headers */\n\tconst apr_array_header_t *const h = apr_table_elts(r->headers_in);\n\n\t/* table to keep the non-suspicious headers */\n\tapr_table_t *clean_headers = apr_table_make(r->pool, h->nelts);\n\n\t/* loop over the incoming HTTP headers */\n\tconst apr_table_entry_t *const e = (const apr_table_entry_t*) h->elts;\n\tint i;\n\tfor (i = 0; i < h->nelts; i++) {\n\t\tconst char *const k = e[i].key;\n\n\t\t/* is this header's name equivalent to a header that needs scrubbing? */\n\t\tconst char *hdr =\n\t\t\t\t(k != NULL) && (scrub != NULL) ?\n\t\t\t\t\t\tapr_hash_get(scrub, k, APR_HASH_KEY_STRING) : NULL;\n\t\tconst int header_matches = (hdr != NULL)\n\t\t\t\t\t\t&& (oidc_strnenvcmp(k, hdr, -1) == 0);\n\n\t\t/*\n\t\t * would this header be interpreted as a mod_auth_openidc attribute? Note\n\t\t * that prefix_len will be zero if no attr_prefix is defined,\n\t\t * so this will always be false. Also note that we do not\n\t\t * scrub headers if the prefix is empty because every header\n\t\t * would match.\n\t\t */\n\t\tconst int prefix_matches = (k != NULL) && prefix_len\n\t\t\t\t&& (oidc_strnenvcmp(k, claim_prefix, prefix_len) == 0);\n\n\t\t/* add to the clean_headers if non-suspicious, skip and report otherwise */\n\t\tif (!prefix_matches && !header_matches) {\n\t\t\tapr_table_addn(clean_headers, k, e[i].val);\n\t\t} else {\n\t\t\toidc_warn(r, \"scrubbed suspicious request header (%s: %.32s)\", k,\n\t\t\t\t\te[i].val);\n\t\t}\n\t}\n\n\t/* overwrite the incoming headers with the cleaned result */\n\tr->headers_in = clean_headers;\n}\n\n/*\n * scrub all mod_auth_openidc related headers\n */\nvoid oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *prefix = oidc_cfg_claim_prefix(r);\n\tapr_hash_t *hdrs = apr_hash_make(r->pool);\n\n\tif (apr_strnatcmp(prefix, \"\") == 0) {\n\t\tif ((cfg->white_listed_claims != NULL)\n\t\t\t\t&& (apr_hash_count(cfg->white_listed_claims) > 0))\n\t\t\thdrs = apr_hash_overlay(r->pool, cfg->white_listed_claims, hdrs);\n\t\telse\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"both \" OIDCClaimPrefix \" and \" OIDCWhiteListedClaims \" are empty: this renders an insecure setup!\");\n\t}\n\n\tchar *authn_hdr = oidc_cfg_dir_authn_header(r);\n\tif (authn_hdr != NULL)\n\t\tapr_hash_set(hdrs, authn_hdr, APR_HASH_KEY_STRING, authn_hdr);\n\n\t/*\n\t * scrub all headers starting with OIDC_ first\n\t */\n\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX, hdrs);\n\n\t/*\n\t * then see if the claim headers need to be removed on top of that\n\t * (i.e. the prefix does not start with the default OIDC_)\n\t */\n\tif ((strstr(prefix, OIDC_DEFAULT_HEADER_PREFIX) != prefix)) {\n\t\toidc_scrub_request_headers(r, prefix, NULL);\n\t}\n}\n\n/*\n * strip the session cookie from the headers sent to the application/backend\n */\nvoid oidc_strip_cookies(request_rec *r) {\n\n\tchar *cookie, *ctx, *result = NULL;\n\tconst char *name = NULL;\n\tint i;\n\n\tapr_array_header_t *strip = oidc_dir_cfg_strip_cookies(r);\n\n\tchar *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));\n\n\tif ((cookies != NULL) && (strip != NULL)) {\n\n\t\toidc_debug(r,\n\t\t\t\t\"looking for the following cookies to strip from cookie header: %s\",\n\t\t\t\tapr_array_pstrcat(r->pool, strip, OIDC_CHAR_COMMA));\n\n\t\tcookie = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &ctx);\n\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == OIDC_CHAR_SPACE)\n\t\t\t\tcookie++;\n\n\t\t\tfor (i = 0; i < strip->nelts; i++) {\n\t\t\t\tname = ((const char**) strip->elts)[i];\n\t\t\t\tif ((strncmp(cookie, name, strlen(name)) == 0)\n\t\t\t\t\t\t&& (cookie[strlen(name)] == OIDC_CHAR_EQUAL)) {\n\t\t\t\t\toidc_debug(r, \"stripping: %s\", name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == strip->nelts) {\n\t\t\t\tresult = result ? apr_psprintf(r->pool, \"%s%s %s\", result,\n\t\t\t\t\t\tOIDC_STR_SEMI_COLON, cookie) :\n\t\t\t\t\t\tcookie;\n\t\t\t}\n\n\t\t\tcookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &ctx);\n\t\t} while (cookie != NULL);\n\n\t\toidc_util_hdr_in_cookie_set(r, result);\n\t}\n}\n\n#define OIDC_SHA1_LEN 20\n\n/*\n * calculates a hash value based on request fingerprint plus a provided nonce string.\n */\nstatic char* oidc_get_browser_state_hash(request_rec *r, oidc_cfg *c,\n\t\tconst char *nonce) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* helper to hold to header values */\n\tconst char *value = NULL;\n\t/* the hash context */\n\tapr_sha1_ctx_t sha1;\n\n\t/* Initialize the hash context */\n\tapr_sha1_init(&sha1);\n\n\tif (c->state_input_headers & OIDC_STATE_INPUT_HEADERS_X_FORWARDED_FOR) {\n\t\t/* get the X-FORWARDED-FOR header value  */\n\t\tvalue = oidc_util_hdr_in_x_forwarded_for_get(r);\n\t\t/* if we have a value for this header, concat it to the hash input */\n\t\tif (value != NULL)\n\t\t\tapr_sha1_update(&sha1, value, strlen(value));\n\t}\n\n\tif (c->state_input_headers & OIDC_STATE_INPUT_HEADERS_USER_AGENT) {\n\t\t/* get the USER-AGENT header value  */\n\t\tvalue = oidc_util_hdr_in_user_agent_get(r);\n\t\t/* if we have a value for this header, concat it to the hash input */\n\t\tif (value != NULL)\n\t\t\tapr_sha1_update(&sha1, value, strlen(value));\n\t}\n\n\t/* get the remote client IP address or host name */\n\t/*\n\t int remotehost_is_ip;\n\t value = ap_get_remote_host(r->connection, r->per_dir_config,\n\t REMOTE_NOLOOKUP, &remotehost_is_ip);\n\t apr_sha1_update(&sha1, value, strlen(value));\n\t */\n\n\t/* concat the nonce parameter to the hash input */\n\tapr_sha1_update(&sha1, nonce, strlen(nonce));\n\n\t/* concat the token binding ID if present */\n\tvalue = oidc_util_get_provided_token_binding_id(r);\n\tif (value != NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"Provided Token Binding ID environment variable found; adding its value to the state\");\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\t}\n\n\t/* finalize the hash input and calculate the resulting hash output */\n\tunsigned char hash[OIDC_SHA1_LEN];\n\tapr_sha1_final(hash, &sha1);\n\n\t/* base64url-encode the resulting hash and return it */\n\tchar *result = NULL;\n\toidc_base64url_encode(r, &result, (const char*) hash, OIDC_SHA1_LEN, TRUE);\n\treturn result;\n}\n\n/*\n * return the name for the state cookie\n */\nstatic char* oidc_get_state_cookie_name(request_rec *r, const char *state) {\n\treturn apr_psprintf(r->pool, \"%s%s\", oidc_cfg_dir_state_cookie_prefix(r),\n\t\t\tstate);\n}\n\n/*\n * return the static provider configuration, i.e. from a metadata URL or configuration primitives\n */\nstatic apr_byte_t oidc_provider_static_config(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t **provider) {\n\n\tjson_t *j_provider = NULL;\n\tchar *s_json = NULL;\n\n\t/* see if we should configure a static provider based on external (cached) metadata */\n\tif ((c->metadata_dir != NULL) || (c->provider.metadata_url == NULL)) {\n\t\t*provider = &c->provider;\n\t\treturn TRUE;\n\t}\n\n\toidc_cache_get_provider(r, c->provider.metadata_url, &s_json);\n\n\tif (s_json == NULL) {\n\n\t\tif (oidc_metadata_provider_retrieve(r, c, NULL,\n\t\t\t\tc->provider.metadata_url, &j_provider, &s_json) == FALSE) {\n\t\t\toidc_error(r, \"could not retrieve metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\toidc_cache_set_provider(r, c->provider.metadata_url, s_json,\n\t\t\t\tapr_time_now() + (c->provider_metadata_refresh_interval <= 0 ? apr_time_from_sec( OIDC_CACHE_PROVIDER_METADATA_EXPIRY_DEFAULT) : c->provider_metadata_refresh_interval));\n\n\t} else {\n\n\t\toidc_util_decode_json_object(r, s_json, &j_provider);\n\n\t\t/* check to see if it is valid metadata */\n\t\tif (oidc_metadata_provider_is_valid(r, c, j_provider, NULL) == FALSE) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"cache corruption detected: invalid metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t*provider = apr_pcalloc(r->pool, sizeof(oidc_provider_t));\n\tmemcpy(*provider, &c->provider, sizeof(oidc_provider_t));\n\n\tif (oidc_metadata_provider_parse(r, c, j_provider, *provider) == FALSE) {\n\t\toidc_error(r, \"could not parse metadata from url: %s\",\n\t\t\t\tc->provider.metadata_url);\n\t\tif (j_provider)\n\t\t\tjson_decref(j_provider);\n\t\treturn FALSE;\n\t}\n\n\tjson_decref(j_provider);\n\n\treturn TRUE;\n}\n\n/*\n * return the oidc_provider_t struct for the specified issuer\n */\nstatic oidc_provider_t* oidc_get_provider_for_issuer(request_rec *r,\n\t\toidc_cfg *c, const char *issuer, apr_byte_t allow_discovery) {\n\n\t/* by default we'll assume that we're dealing with a single statically configured OP */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\treturn NULL;\n\n\t/* unless a metadata directory was configured, so we'll try and get the provider settings from there */\n\tif (c->metadata_dir != NULL) {\n\n\t\t/* try and get metadata from the metadata directory for the OP that sent this response */\n\t\tif ((oidc_metadata_get(r, c, issuer, &provider, allow_discovery)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\n\t\t\t/* don't know nothing about this OP/issuer */\n\t\t\toidc_error(r, \"no provider metadata found for issuer \\\"%s\\\"\",\n\t\t\t\t\tissuer);\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn provider;\n}\n\n/*\n * find out whether the request is a response from an IDP discovery page\n */\nstatic apr_byte_t oidc_is_discovery_response(request_rec *r, oidc_cfg *cfg) {\n\t/*\n\t * prereq: this is a call to the configured redirect_uri, now see if:\n\t * the OIDC_DISC_OP_PARAM is present\n\t */\n\treturn oidc_util_request_has_parameter(r, OIDC_DISC_OP_PARAM)\n\t\t\t|| oidc_util_request_has_parameter(r, OIDC_DISC_USER_PARAM);\n}\n\n/*\n * return the HTTP method being called: only for POST data persistence purposes\n */\nstatic const char* oidc_original_request_method(request_rec *r, oidc_cfg *cfg,\n\t\tapr_byte_t handle_discovery_response) {\n\tconst char *method = OIDC_METHOD_GET;\n\n\tchar *m = NULL;\n\tif ((handle_discovery_response == TRUE)\n\t\t\t&& (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, cfg)))\n\t\t\t&& (oidc_is_discovery_response(r, cfg))) {\n\t\toidc_util_get_request_parameter(r, OIDC_DISC_RM_PARAM, &m);\n\t\tif (m != NULL)\n\t\t\tmethod = apr_pstrdup(r->pool, m);\n\t} else {\n\n\t\t/*\n\t\t * if POST preserve is not enabled for this location, there's no point in preserving\n\t\t * the method either which would result in POSTing empty data on return;\n\t\t * so we revert to legacy behavior\n\t\t */\n\t\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\t\treturn OIDC_METHOD_GET;\n\n\t\tconst char *content_type = oidc_util_hdr_in_content_type_get(r);\n\t\tif ((r->method_number == M_POST) && (apr_strnatcmp(content_type,\n\t\t\t\tOIDC_CONTENT_TYPE_FORM_ENCODED) == 0))\n\t\t\tmethod = OIDC_METHOD_FORM_POST;\n\t}\n\n\toidc_debug(r, \"return: %s\", method);\n\n\treturn method;\n}\n\n/*\n * send an OpenID Connect authorization request to the specified provider preserving POST parameters using HTML5 storage\n */\napr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\toidc_util_javascript_escape(r->pool, location)) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * restore POST parameters on original_url from HTML5 local storage\n */\nstatic int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}\n\ntypedef struct oidc_state_cookies_t {\n\tchar *name;\n\tapr_time_t timestamp;\n\tstruct oidc_state_cookies_t *next;\n} oidc_state_cookies_t;\n\nstatic int oidc_delete_oldest_state_cookies(request_rec *r,\n\t\tint number_of_valid_state_cookies, int max_number_of_state_cookies,\n\t\toidc_state_cookies_t *first) {\n\toidc_state_cookies_t *cur = NULL, *prev = NULL, *prev_oldest = NULL,\n\t\t\t*oldest = NULL;\n\twhile (number_of_valid_state_cookies >= max_number_of_state_cookies) {\n\t\toldest = first;\n\t\tprev_oldest = NULL;\n\t\tprev = first;\n\t\tcur = first->next;\n\t\twhile (cur) {\n\t\t\tif ((cur->timestamp < oldest->timestamp)) {\n\t\t\t\toldest = cur;\n\t\t\t\tprev_oldest = prev;\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t\toidc_warn(r,\n\t\t\t\t\"deleting oldest state cookie: %s (time until expiry %\" APR_TIME_T_FMT \" seconds)\",\n\t\t\t\toldest->name, apr_time_sec(oldest->timestamp - apr_time_now()));\n\t\toidc_util_set_cookie(r, oldest->name, \"\", 0,\n\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\t\tif (prev_oldest)\n\t\t\tprev_oldest->next = oldest->next;\n\t\telse\n\t\t\tfirst = first->next;\n\t\tnumber_of_valid_state_cookies--;\n\t}\n\treturn number_of_valid_state_cookies;\n}\n\n/*\n * clean state cookies that have expired i.e. for outstanding requests that will never return\n * successfully and return the number of remaining valid cookies/outstanding-requests while\n * doing so\n */\nstatic int oidc_clean_expired_state_cookies(request_rec *r, oidc_cfg *c,\n\t\tconst char *currentCookieName, int delete_oldest) {\n\tint number_of_valid_state_cookies = 0;\n\toidc_state_cookies_t *first = NULL, *last = NULL;\n\tchar *cookie, *tokenizerCtx = NULL;\n\tchar *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));\n\tif (cookies != NULL) {\n\t\tcookie = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &tokenizerCtx);\n\t\twhile (cookie != NULL) {\n\t\t\twhile (*cookie == OIDC_CHAR_SPACE)\n\t\t\t\tcookie++;\n\t\t\tif (strstr(cookie, oidc_cfg_dir_state_cookie_prefix(r)) == cookie) {\n\t\t\t\tchar *cookieName = cookie;\n\t\t\t\twhile (cookie != NULL && *cookie != OIDC_CHAR_EQUAL)\n\t\t\t\t\tcookie++;\n\t\t\t\tif (*cookie == OIDC_CHAR_EQUAL) {\n\t\t\t\t\t*cookie = '\\0';\n\t\t\t\t\tcookie++;\n\t\t\t\t\tif ((currentCookieName == NULL)\n\t\t\t\t\t\t\t|| (apr_strnatcmp(cookieName, currentCookieName)\n\t\t\t\t\t\t\t\t\t!= 0)) {\n\t\t\t\t\t\toidc_proto_state_t *proto_state =\n\t\t\t\t\t\t\t\toidc_proto_state_from_cookie(r, c, cookie);\n\t\t\t\t\t\tif (proto_state != NULL) {\n\t\t\t\t\t\t\tjson_int_t ts = oidc_proto_state_get_timestamp(\n\t\t\t\t\t\t\t\t\tproto_state);\n\t\t\t\t\t\t\tif (apr_time_now() > ts + apr_time_from_sec(c->state_timeout)) {\n\t\t\t\t\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\t\t\t\t\"state (%s) has expired (original_url=%s)\",\n\t\t\t\t\t\t\t\t\t\tcookieName,\n\t\t\t\t\t\t\t\t\t\toidc_proto_state_get_original_url(\n\t\t\t\t\t\t\t\t\t\t\t\tproto_state));\n\t\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0,\n\t\t\t\t\t\t\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (first == NULL) {\n\t\t\t\t\t\t\t\t\tfirst = apr_pcalloc(r->pool,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(oidc_state_cookies_t));\n\t\t\t\t\t\t\t\t\tlast = first;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlast->next = apr_pcalloc(r->pool,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(oidc_state_cookies_t));\n\t\t\t\t\t\t\t\t\tlast = last->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlast->name = cookieName;\n\t\t\t\t\t\t\t\tlast->timestamp = ts;\n\t\t\t\t\t\t\t\tlast->next = NULL;\n\t\t\t\t\t\t\t\tnumber_of_valid_state_cookies++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\t\t\t\"state cookie could not be retrieved/decoded, deleting: %s\",\n\t\t\t\t\t\t\t\t\tcookieName);\n\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0,\n\t\t\t\t\t\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &tokenizerCtx);\n\t\t}\n\t}\n\n\tif (delete_oldest > 0)\n\t\tnumber_of_valid_state_cookies = oidc_delete_oldest_state_cookies(r,\n\t\t\t\tnumber_of_valid_state_cookies, c->max_number_of_state_cookies,\n\t\t\t\tfirst);\n\n\treturn number_of_valid_state_cookies;\n}\n\n/*\n * restore the state that was maintained between authorization request and response in an encrypted cookie\n */\nstatic apr_byte_t oidc_restore_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t **proto_state) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* clean expired state cookies to avoid pollution */\n\toidc_clean_expired_state_cookies(r, c, cookieName, FALSE);\n\n\t/* get the state cookie value first */\n\tchar *cookieValue = oidc_util_get_cookie(r, cookieName);\n\tif (cookieValue == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"no \\\"%s\\\" state cookie found: check domain and samesite cookie settings\",\n\t\t\t\tcookieName);\n\t\treturn FALSE;\n\t}\n\n\t/* clear state cookie because we don't need it anymore */\n\toidc_util_set_cookie(r, cookieName, \"\", 0,\n\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\n\t*proto_state = oidc_proto_state_from_cookie(r, c, cookieValue);\n\tif (*proto_state == NULL)\n\t\treturn FALSE;\n\n\tconst char *nonce = oidc_proto_state_get_nonce(*proto_state);\n\n\t/* calculate the hash of the browser fingerprint concatenated with the nonce */\n\tchar *calc = oidc_get_browser_state_hash(r, c, nonce);\n\t/* compare the calculated hash with the value provided in the authorization response */\n\tif (apr_strnatcmp(calc, state) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"calculated state from cookie does not match state parameter passed back in URL: \\\"%s\\\" != \\\"%s\\\"\",\n\t\t\t\tstate, calc);\n\t\toidc_proto_state_destroy(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\tapr_time_t ts = oidc_proto_state_get_timestamp(*proto_state);\n\n\t/* check that the timestamp is not beyond the valid interval */\n\tif (apr_time_now() > ts + apr_time_from_sec(c->state_timeout)) {\n\t\toidc_error(r, \"state has expired\");\n\t\tif ((c->default_sso_url == NULL)\n\t\t\t\t|| (apr_table_get(r->subprocess_env, \"OIDC_NO_DEFAULT_URL_ON_STATE_TIMEOUT\") != NULL)) {\n\t\t\toidc_util_html_send_error(r, c->error_template, \"Invalid Authentication Response\", apr_psprintf(r->pool, \"This is due to a timeout; please restart your authentication session by re-entering the URL/bookmark you originally wanted to access: %s\", oidc_proto_state_get_original_url(*proto_state)),\n\t\t\t\t\t\t\t\t\t  OK);\n\t\t\t/*\n\t\t\t * a hack for Apache 2.4 to prevent it from writing its own 500/400/302 HTML document\n\t\t\t * text by making ap_send_error_response in http_protocol.c return early...\n\t\t\t */\n\t\t\tr->header_only = 1;\n\t\t}\n\t\toidc_proto_state_destroy(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\t/* add the state */\n\toidc_proto_state_set_state(*proto_state, state);\n\n\t/* log the restored state object */\n\toidc_debug(r, \"restored state: %s\",\n\t\t\toidc_proto_state_to_string(r, *proto_state));\n\n\t/* we've made it */\n\treturn TRUE;\n}\n\n/*\n * set the state that is maintained between an authorization request and an authorization response\n * in a cookie in the browser that is cryptographically bound to that state\n */\nstatic int oidc_authorization_request_set_cookie(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t *proto_state) {\n\t/*\n\t * create a cookie consisting of 8 elements:\n\t * random value, original URL, original method, issuer, response_type, response_mod, prompt and timestamp\n\t * encoded as JSON, encrypting the resulting JSON value\n\t */\n\tchar *cookieValue = oidc_proto_state_to_cookie(r, c, proto_state);\n\tif (cookieValue == NULL)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/*\n\t * clean expired state cookies to avoid pollution and optionally\n\t * try to avoid the number of state cookies exceeding a max\n\t */\n\tint number_of_cookies = oidc_clean_expired_state_cookies(r, c, NULL,\n\t\t\toidc_cfg_delete_oldest_state_cookies(c));\n\tint max_number_of_cookies = oidc_cfg_max_number_of_state_cookies(c);\n\tif ((max_number_of_cookies > 0)\n\t\t\t&& (number_of_cookies >= max_number_of_cookies)) {\n\n\t\toidc_warn(r,\n\t\t\t\t\"the number of existing, valid state cookies (%d) has exceeded the limit (%d), no additional authorization request + state cookie can be generated, aborting the request\",\n\t\t\t\tnumber_of_cookies, max_number_of_cookies);\n\t\t/*\n\t\t * TODO: the html_send code below caters for the case that there's a user behind a\n\t\t * browser generating this request, rather than a piece of XHR code; how would an\n\t\t * XHR client handle this?\n\t\t */\n\n\t\t/*\n\t\t * it appears that sending content with a 503 turns the HTTP status code\n\t\t * into a 200 so we'll avoid that for now: the user will see Apache specific\n\t\t * readable text anyway\n\t\t *\n\t\t return oidc_util_html_send_error(r, c->error_template,\n\t\t \"Too Many Outstanding Requests\",\n\t\t apr_psprintf(r->pool,\n\t\t \"No authentication request could be generated since there are too many outstanding authentication requests already; you may have to wait up to %d seconds to be able to create a new request\",\n\t\t c->state_timeout),\n\t\t HTTP_SERVICE_UNAVAILABLE);\n\t\t */\n\n\t\treturn HTTP_SERVICE_UNAVAILABLE;\n\t}\n\n\t/* assemble the cookie name for the state cookie */\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* set it as a cookie */\n\toidc_util_set_cookie(r, cookieName, cookieValue, -1,\n\t\t\tOIDC_COOKIE_SAMESITE_LAX(c, r));\n\n\treturn OK;\n}\n\n/*\n * get the mod_auth_openidc related context from the (userdata in the) request\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nstatic apr_table_t* oidc_request_state(request_rec *rr) {\n\n\t/* our state is always stored in the main request */\n\trequest_rec *r = (rr->main != NULL) ? rr->main : rr;\n\n\t/* our state is a table, get it */\n\tapr_table_t *state = NULL;\n\tapr_pool_userdata_get((void**) &state, OIDC_USERDATA_KEY, r->pool);\n\n\t/* if it does not exist, we'll create a new table */\n\tif (state == NULL) {\n\t\tstate = apr_table_make(r->pool, 5);\n\t\tapr_pool_userdata_set(state, OIDC_USERDATA_KEY, NULL, r->pool);\n\t}\n\n\t/* return the resulting table, always non-null now */\n\treturn state;\n}\n\n/*\n * set a name/value pair in the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nvoid oidc_request_state_set(request_rec *r, const char *key, const char *value) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* put the name/value pair in that table */\n\tapr_table_set(state, key, value);\n}\n\n/*\n * get a name/value pair from the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nconst char* oidc_request_state_get(request_rec *r, const char *key) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* return the value from the table */\n\treturn apr_table_get(state, key);\n}\n\n/*\n * set the claims from a JSON object (c.q. id_token or user_info response) stored\n * in the session in to HTTP headers passed on to the application\n */\nstatic apr_byte_t oidc_set_app_claims(request_rec *r, const oidc_cfg *const cfg,\n\t\toidc_session_t *session, const char *s_claims) {\n\n\tjson_t *j_claims = NULL;\n\n\t/* decode the string-encoded attributes in to a JSON structure */\n\tif (s_claims != NULL) {\n\t\tif (oidc_util_decode_json_object(r, s_claims, &j_claims) == FALSE)\n\t\t\treturn FALSE;\n\t}\n\n\t/* set the resolved claims a HTTP headers for the application */\n\tif (j_claims != NULL) {\n\t\toidc_util_set_app_infos(r, j_claims, oidc_cfg_claim_prefix(r),\n\t\t\t\tcfg->claim_delimiter, oidc_cfg_dir_pass_info_in_headers(r),\n\t\t\t\toidc_cfg_dir_pass_info_in_envvars(r),\n\t\t\t\toidc_cfg_dir_pass_info_base64url(r));\n\n\t\t/* release resources */\n\t\tjson_decref(j_claims);\n\t}\n\n\treturn TRUE;\n}\n\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params, const char *path_scope);\n\n/*\n * log message about max session duration\n */\nstatic void oidc_log_session_expires(request_rec *r, const char *msg,\n\t\tapr_time_t session_expires) {\n\tchar buf[APR_RFC822_DATE_LEN + 1];\n\tapr_rfc822_date(buf, session_expires);\n\toidc_debug(r, \"%s: %s (in %\" APR_TIME_T_FMT \" secs from now)\", msg, buf,\n\t\t\tapr_time_sec(session_expires - apr_time_now()));\n}\n\n/*\n * see if this is a non-browser request\n */\nstatic apr_byte_t oidc_is_xml_http_request(request_rec *r) {\n\n\tif ((oidc_util_hdr_in_x_requested_with_get(r) != NULL)\n\t\t\t&& (apr_strnatcasecmp(oidc_util_hdr_in_x_requested_with_get(r),\n\t\t\t\t\tOIDC_HTTP_HDR_VAL_XML_HTTP_REQUEST) == 0))\n\t\treturn TRUE;\n\n\tif ((oidc_util_hdr_in_accept_contains(r, OIDC_CONTENT_TYPE_TEXT_HTML)\n\t\t\t== FALSE) && (oidc_util_hdr_in_accept_contains(r,\n\t\t\t\t\tOIDC_CONTENT_TYPE_APP_XHTML_XML) == FALSE)\n\t\t\t\t\t&& (oidc_util_hdr_in_accept_contains(r,\n\t\t\t\t\t\t\tOIDC_CONTENT_TYPE_ANY) == FALSE))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\n/*\n * find out which action we need to take when encountering an unauthenticated request\n */\nstatic int oidc_handle_unauthenticated_user(request_rec *r, oidc_cfg *c) {\n\n\t/* see if we've configured OIDCUnAuthAction for this path */\n\tswitch (oidc_dir_cfg_unauth_action(r)) {\n\tcase OIDC_UNAUTH_RETURN410:\n\t\treturn HTTP_GONE;\n\tcase OIDC_UNAUTH_RETURN407:\n\t\treturn HTTP_PROXY_AUTHENTICATION_REQUIRED;\n\tcase OIDC_UNAUTH_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTH_PASS:\n\t\tr->user = \"\";\n\n\t\t/*\n\t\t * we're not going to pass information about an authenticated user to the application,\n\t\t * but we do need to scrub the headers that mod_auth_openidc would set for security reasons\n\t\t */\n\t\toidc_scrub_headers(r);\n\n\t\treturn OK;\n\n\tcase OIDC_UNAUTH_AUTHENTICATE:\n\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif ((oidc_dir_cfg_unauth_expr_is_set(r) == FALSE)\n\t\t\t\t&& (oidc_is_xml_http_request(r) == TRUE))\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/*\n\t * else: no session (regardless of whether it is main or sub-request),\n\t * and we need to authenticate the user\n\t */\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r),\n\t\t\toidc_dir_cfg_path_scope(r));\n}\n\n/*\n * check if maximum session duration was exceeded\n */\nstatic int oidc_check_max_session_duration(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\t/* get the session expiry from the session data */\n\tapr_time_t session_expires = oidc_session_get_session_expires(r, session);\n\n\t/* check the expire timestamp against the current time */\n\tif (apr_time_now() > session_expires) {\n\t\toidc_warn(r, \"maximum session duration exceeded for user: %s\",\n\t\t\t\tsession->remote_user);\n\t\toidc_session_kill(r, session);\n\t\treturn oidc_handle_unauthenticated_user(r, cfg);\n\t}\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\n\treturn OK;\n}\n\n/*\n * validate received session cookie against the domain it was issued for:\n *\n * this handles the case where the cache configured is a the same single memcache, Redis, or file\n * backend for different (virtual) hosts, or a client-side cookie protected with the same secret\n *\n * it also handles the case that a cookie is unexpectedly shared across multiple hosts in\n * name-based virtual hosting even though the OP(s) would be the same\n */\nstatic apr_byte_t oidc_check_cookie_domain(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tconst char *c_cookie_domain =\n\t\t\tcfg->cookie_domain ?\n\t\t\t\t\tcfg->cookie_domain : oidc_get_current_url_host(r);\n\tconst char *s_cookie_domain = oidc_session_get_cookie_domain(r, session);\n\tif ((s_cookie_domain == NULL)\n\t\t\t|| (apr_strnatcmp(c_cookie_domain, s_cookie_domain) != 0)) {\n\t\toidc_warn(r,\n\t\t\t\t\"aborting: detected attempt to play cookie against a different domain/host than issued for! (issued=%s, current=%s)\",\n\t\t\t\ts_cookie_domain, c_cookie_domain);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * get a handle to the provider configuration via the \"issuer\" stored in the session\n */\napr_byte_t oidc_get_provider_from_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t **provider) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the issuer value from the session state */\n\tconst char *issuer = oidc_session_get_issuer(r, session);\n\tif (issuer == NULL) {\n\t\toidc_warn(r, \"empty or invalid session: no issuer found\");\n\t\treturn FALSE;\n\t}\n\n\t/* get the provider info associated with the issuer value */\n\toidc_provider_t *p = oidc_get_provider_for_issuer(r, c, issuer, FALSE);\n\tif (p == NULL) {\n\t\toidc_error(r, \"session corrupted: no provider found for issuer: %s\",\n\t\t\t\tissuer);\n\t\treturn FALSE;\n\t}\n\n\t*provider = p;\n\n\treturn TRUE;\n}\n\n/*\n * store claims resolved from the userinfo endpoint in the session\n */\nstatic void oidc_store_userinfo_claims(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider, const char *claims,\n\t\tconst char *userinfo_jwt) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* see if we've resolved any claims */\n\tif (claims != NULL) {\n\t\t/*\n\t\t * Successfully decoded a set claims from the response so we can store them\n\t\t * (well actually the stringified representation in the response)\n\t\t * in the session context safely now\n\t\t */\n\t\toidc_session_set_userinfo_claims(r, session, claims);\n\n\t\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* this will also clear the entry if a JWT was not returned at this point */\n\t\t\toidc_session_set_userinfo_jwt(r, session, userinfo_jwt);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * clear the existing claims because we could not refresh them\n\t\t */\n\t\toidc_session_set_userinfo_claims(r, session, NULL);\n\n\t\toidc_session_set_userinfo_jwt(r, session, NULL);\n\t}\n\n\t/* store the last refresh time if we've configured a userinfo refresh interval */\n\tif (provider->userinfo_refresh_interval > 0)\n\t\toidc_session_reset_userinfo_last_refresh(r, session);\n}\n\n/*\n * execute refresh token grant to refresh the existing access token\n */\nstatic apr_byte_t oidc_refresh_access_token(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tchar **new_access_token) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the refresh token that was stored in the session */\n\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\tif (refresh_token == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"refresh token routine called but no refresh_token found in the session\");\n\t\treturn FALSE;\n\t}\n\n\t/* elements returned in the refresh response */\n\tchar *s_id_token = NULL;\n\tint expires_in = -1;\n\tchar *s_token_type = NULL;\n\tchar *s_access_token = NULL;\n\tchar *s_refresh_token = NULL;\n\n\t/* refresh the tokens by calling the token endpoint */\n\tif (oidc_proto_refresh_request(r, c, provider, refresh_token, &s_id_token,\n\t\t\t&s_access_token, &s_token_type, &expires_in, &s_refresh_token)\n\t\t\t== FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\treturn FALSE;\n\t}\n\n\t/* store the new access_token in the session and discard the old one */\n\toidc_session_set_access_token(r, session, s_access_token);\n\toidc_session_set_access_token_expires(r, session, expires_in);\n\n\t/* reset the access token refresh timestamp */\n\toidc_session_reset_access_token_last_refresh(r, session);\n\n\t/* see if we need to return it as a parameter */\n\tif (new_access_token != NULL)\n\t\t*new_access_token = s_access_token;\n\n\t/* if we have a new refresh token (rolling refresh), store it in the session and overwrite the old one */\n\tif (s_refresh_token != NULL)\n\t\toidc_session_set_refresh_token(r, session, s_refresh_token);\n\n\t/* if we have a new id_token, store it in the session and update the session max lifetime if required */\n\tif (s_id_token != NULL) {\n\t\t/* only store the serialized representation when client cookie based session tracking is not in use */\n\t\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) \n\t\t\toidc_session_set_idtoken(r, session, s_id_token);\n\t\t\n\t\toidc_jwt_t *id_token_jwt = NULL;\n\t\toidc_jose_error_t err;\n\t\tif (oidc_jwt_parse(r->pool, s_id_token, &id_token_jwt, NULL, &err) == TRUE) {\n\n\t\t\t/* store the claims payload in the id_token for later reference */\n\t\t\toidc_session_set_idtoken_claims(r, session,\n\t\t\t\tid_token_jwt->payload.value.str);\n\n\t\t\tif (provider->session_max_duration == 0) {\n\t\t\t\t/* update the session expiry to match the expiry of the id_token */\n\t\t\t\tapr_time_t session_expires = apr_time_from_sec(id_token_jwt->payload.exp);\n\t\t\t\toidc_session_set_session_expires(r, session, session_expires);\n\n\t\t\t\t/* log message about the updated max session duration */\n\t\t\t\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\t\t\t}\t\t\n\t\t} else { \n\t\t\toidc_warn(r, \"parsing of id_token failed\");\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * retrieve claims from the userinfo endpoint and return the stringified response\n */\nstatic const char* oidc_retrieve_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *c, oidc_provider_t *provider, const char *access_token,\n\t\toidc_session_t *session, char *id_token_sub, char **userinfo_jwt) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *result = NULL;\n\tchar *refreshed_access_token = NULL;\n\n\t/* see if a userinfo endpoint is set, otherwise there's nothing to do for us */\n\tif (provider->userinfo_endpoint_url == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because userinfo_endpoint is not set\");\n\t\treturn NULL;\n\t}\n\n\t/* see if there's an access token, otherwise we can't call the userinfo endpoint at all */\n\tif (access_token == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because access_token is not provided\");\n\t\treturn NULL;\n\t}\n\n\tif ((id_token_sub == NULL) && (session != NULL)) {\n\n\t\t// when refreshing claims from the userinfo endpoint\n\t\tjson_t *id_token_claims = oidc_session_get_idtoken_claims_json(r,\n\t\t\t\tsession);\n\t\tif (id_token_claims == NULL) {\n\t\t\toidc_error(r, \"no id_token_claims found in session\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\toidc_jose_get_string(r->pool, id_token_claims, OIDC_CLAIM_SUB, FALSE,\n\t\t\t\t&id_token_sub, NULL);\n\t}\n\n\t// TODO: return code should indicate whether the token expired or some other error occurred\n\t// TODO: long-term: session storage should be JSON (with explicit types and less conversion, using standard routines)\n\n\t/* try to get claims from the userinfo endpoint using the provided access token */\n\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,\n\t\t\t&result, userinfo_jwt) == FALSE) {\n\n\t\t/* see if we have an existing session and we are refreshing the user info claims */\n\t\tif (session != NULL) {\n\n\t\t\t/* first call to user info endpoint failed, but the access token may have just expired, so refresh it */\n\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t&refreshed_access_token) == TRUE) {\n\n\t\t\t\t/* try again with the new access token */\n\t\t\t\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub,\n\t\t\t\t\t\trefreshed_access_token, &result, userinfo_jwt)\n\t\t\t\t\t\t== FALSE) {\n\n\t\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\t\"resolving user info claims with the refreshed access token failed, nothing will be stored in the session\");\n\t\t\t\t\tresult = NULL;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"refreshing access token failed, claims will not be retrieved/refreshed from the userinfo endpoint\");\n\t\t\t\tresult = NULL;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toidc_error(r,\n\t\t\t\t\t\"resolving user info claims with the existing/provided access token failed, nothing will be stored in the session\");\n\t\t\tresult = NULL;\n\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*\n * get (new) claims from the userinfo endpoint\n */\nstatic apr_byte_t oidc_refresh_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\tconst char *claims = NULL;\n\tconst char *access_token = NULL;\n\tchar *userinfo_jwt = NULL;\n\n\t/* get the current provider info */\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\t/* see if we can do anything here, i.e. we have a userinfo endpoint and a refresh interval is configured */\n\tapr_time_t interval = apr_time_from_sec(\n\t\t\tprovider->userinfo_refresh_interval);\n\n\toidc_debug(r, \"userinfo_endpoint=%s, interval=%d\",\n\t\t\tprovider->userinfo_endpoint_url,\n\t\t\tprovider->userinfo_refresh_interval);\n\n\tif ((provider->userinfo_endpoint_url != NULL) && (interval > 0)) {\n\n\t\t/* get the last refresh timestamp from the session info */\n\t\tapr_time_t last_refresh = oidc_session_get_userinfo_last_refresh(r,\n\t\t\t\tsession);\n\n\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\tapr_time_sec(last_refresh + interval - apr_time_now()));\n\n\t\t/* see if we need to refresh again */\n\t\tif (last_refresh + interval < apr_time_now()) {\n\n\t\t\t/* get the current access token */\n\t\t\taccess_token = oidc_session_get_access_token(r, session);\n\n\t\t\t/* retrieve the current claims */\n\t\t\tclaims = oidc_retrieve_claims_from_userinfo_endpoint(r, cfg,\n\t\t\t\t\tprovider, access_token, session, NULL, &userinfo_jwt);\n\n\t\t\t/* store claims resolved from userinfo endpoint */\n\t\t\toidc_store_userinfo_claims(r, cfg, session, provider, claims,\n\t\t\t\t\tuserinfo_jwt);\n\n\t\t\t/* indicated something changed */\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*\n * copy the claims and id_token from the session to the request state and optionally return them\n */\nstatic void oidc_copy_tokens_to_request_state(request_rec *r,\n\t\toidc_session_t *session, const char **s_id_token, const char **s_claims) {\n\n\tconst char *id_token = oidc_session_get_idtoken_claims(r, session);\n\tconst char *claims = oidc_session_get_userinfo_claims(r, session);\n\n\toidc_debug(r, \"id_token=%s claims=%s\", id_token, claims);\n\n\tif (id_token != NULL) {\n\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_IDTOKEN, id_token);\n\t\tif (s_id_token != NULL)\n\t\t\t*s_id_token = id_token;\n\t}\n\n\tif (claims != NULL) {\n\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_CLAIMS, claims);\n\t\tif (s_claims != NULL)\n\t\t\t*s_claims = claims;\n\t}\n}\n\n/*\n * pass refresh_token, access_token and access_token_expires as headers/environment variables to the application\n */\nstatic apr_byte_t oidc_session_pass_tokens(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session, apr_byte_t *needs_save) {\n\n\tapr_byte_t pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tapr_byte_t pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\tapr_byte_t pass_base64url = oidc_cfg_dir_pass_info_base64url(r);\n\n\t/* set the refresh_token in the app headers/variables, if enabled for this location/directory */\n\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\tif ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_REFRESH_TOKEN, refresh_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars, pass_base64url);\n\t}\n\n\t/* set the access_token in the app headers/variables */\n\tconst char *access_token = oidc_session_get_access_token(r, session);\n\tif (access_token != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN, access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars, pass_base64url);\n\t}\n\n\t/* set the expiry timestamp in the app headers/variables */\n\tconst char *access_token_expires = oidc_session_get_access_token_expires(r,\n\t\t\tsession);\n\tif (access_token_expires != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN_EXP,\n\t\t\t\taccess_token_expires,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars,\n\t\t\t\tpass_base64url);\n\t}\n\n\t/*\n\t * reset the session inactivity timer\n\t * but only do this once per 10% of the inactivity timeout interval (with a max to 60 seconds)\n\t * for performance reasons\n\t *\n\t * now there's a small chance that the session ends 10% (or a minute) earlier than configured/expected\n\t * cq. when there's a request after a recent save (so no update) and then no activity happens until\n\t * a request comes in just before the session should expire\n\t * (\"recent\" and \"just before\" refer to 10%-with-a-max-of-60-seconds of the inactivity interval after\n\t * the start/last-update and before the expiry of the session respectively)\n\t *\n\t * this is be deemed acceptable here because of performance gain\n\t */\n\tapr_time_t interval = apr_time_from_sec(cfg->session_inactivity_timeout);\n\tapr_time_t now = apr_time_now();\n\tapr_time_t slack = interval / 10;\n\tif (slack > apr_time_from_sec(60))\n\t\tslack = apr_time_from_sec(60);\n\tif (session->expiry - now < interval - slack) {\n\t\tsession->expiry = now + interval;\n\t\t*needs_save = TRUE;\n\t}\n\n\t/* log message about session expiry */\n\toidc_log_session_expires(r, \"session inactivity timeout\", session->expiry);\n\n\treturn TRUE;\n}\n\nstatic apr_byte_t oidc_refresh_access_token_before_expiry(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session, int ttl_minimum,\n\t\tint logout_on_error) {\n\n\tconst char *s_access_token_expires = NULL;\n\tapr_time_t t_expires = -1;\n\toidc_provider_t *provider = NULL;\n\n\toidc_debug(r, \"ttl_minimum=%d\", ttl_minimum);\n\n\tif (ttl_minimum < 0)\n\t\treturn FALSE;\n\n\ts_access_token_expires = oidc_session_get_access_token_expires(r, session);\n\tif (s_access_token_expires == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"no access token expires_in stored in the session (i.e. returned from in the authorization response), so cannot refresh the access token based on TTL requirement\");\n\t\treturn FALSE;\n\t}\n\n\tif (oidc_session_get_refresh_token(r, session) == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"no refresh token stored in the session, so cannot refresh the access token based on TTL requirement\");\n\t\treturn FALSE;\n\t}\n\n\tif (sscanf(s_access_token_expires, \"%\" APR_TIME_T_FMT, &t_expires) != 1) {\n\t\toidc_error(r, \"could not parse s_access_token_expires %s\",\n\t\t\t\ts_access_token_expires);\n\t\treturn FALSE;\n\t}\n\n\tt_expires = apr_time_from_sec(t_expires - ttl_minimum);\n\n\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\tapr_time_sec(t_expires - apr_time_now()));\n\n\tif (t_expires > apr_time_now())\n\t\treturn FALSE;\n\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\tif (oidc_refresh_access_token(r, cfg, session, provider,\n\t\t\tNULL) == FALSE) {\n\t\toidc_warn(r, \"access_token could not be refreshed, logout=%d\",\n\t\t\t\tlogout_on_error & OIDC_LOGOUT_ON_ERROR_REFRESH);\n\t\tif (logout_on_error & OIDC_LOGOUT_ON_ERROR_REFRESH)\n\t\t\treturn OIDC_REFRESH_ERROR;\n\t\telse\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * handle the case where we have identified an existing authentication session for a user\n */\nstatic int oidc_handle_existing_session(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session, apr_byte_t *needs_save) {\n\n\tapr_byte_t rv = FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\t/* set the user in the main request for further (incl. sub-request) processing */\n\tr->user = apr_pstrdup(r->pool, session->remote_user);\n\toidc_debug(r, \"set remote_user to \\\"%s\\\"\", r->user);\n\n\t/* get the header name in which the remote user name needs to be passed */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tapr_byte_t pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tapr_byte_t pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\tapr_byte_t pass_base64url = oidc_cfg_dir_pass_info_base64url(r);\n\n\t/* verify current cookie domain against issued cookie domain */\n\tif (oidc_check_cookie_domain(r, cfg, session) == FALSE)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* check if the maximum session duration was exceeded */\n\tint rc = oidc_check_max_session_duration(r, cfg, session);\n\tif (rc != OK)\n\t\treturn rc;\n\n\t/* if needed, refresh the access token */\n\trv = oidc_refresh_access_token_before_expiry(r, cfg, session,\n\t\t\toidc_cfg_dir_refresh_access_token_before_expiry(r),\n\t\t\toidc_cfg_dir_logout_on_error_refresh(r));\n\n\tif (rv == OIDC_REFRESH_ERROR) {\n\t\t*needs_save = FALSE;\n\t\treturn oidc_handle_logout_request(r, cfg, session, cfg->default_slo_url);\n\t}\n\n\t*needs_save |= rv;\n\n\t/* if needed, refresh claims from the user info endpoint */\n\tif (oidc_refresh_claims_from_userinfo_endpoint(r, cfg, session) == TRUE)\n\t\t*needs_save = TRUE;\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\toidc_scrub_headers(r);\n\n\t/* set the user authentication HTTP header if set and required */\n\tif ((r->user != NULL) && (authn_header != NULL))\n\t\toidc_util_hdr_in_set(r, authn_header, r->user);\n\n\tconst char *s_claims = NULL;\n\tconst char *s_id_token = NULL;\n\n\t/* copy id_token and claims from session to request state and obtain their values */\n\toidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_CLAIMS)) {\n\t\t/* set the userinfo claims in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JSON_OBJECT)) {\n\t\t/* pass the userinfo JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JSON, s_claims,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars, pass_base64url);\n\t}\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JWT)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\tconst char *s_userinfo_jwt = oidc_session_get_userinfo_jwt(r,\n\t\t\t\t\tsession);\n\t\t\tif (s_userinfo_jwt != NULL) {\n\t\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\t\toidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JWT,\n\t\t\t\t\t\ts_userinfo_jwt,\n\t\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars,\n\t\t\t\t\t\tpass_base64url);\n\t\t\t} else {\n\t\t\t\toidc_debug(r,\n\t\t\t\t\t\t\"configured to pass userinfo in a JWT, but no such JWT was found in the session (probably no such JWT was returned from the userinfo endpoint)\");\n\t\t\t}\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing a userinfo JWT; use \\\"\" OIDCSessionType \" server-cache\\\" for that\");\n\t\t}\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {\n\t\t/* set the id_token in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {\n\t\t/* pass the id_token JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN_PAYLOAD, s_id_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars, pass_base64url);\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\tconst char *s_id_token = oidc_session_get_idtoken(r, session);\n\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN, s_id_token,\n\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars,\n\t\t\t\t\tpass_base64url);\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing the id_token; use \\\"\" OIDCSessionType \" server-cache\\\" for that\");\n\t\t}\n\t}\n\n\t/* pass the at, rt and at expiry to the application, possibly update the session expiry */\n\tif (oidc_session_pass_tokens(r, cfg, session, needs_save) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/* return \"user authenticated\" status */\n\treturn OK;\n}\n\n/*\n * helper function for basic/implicit client flows upon receiving an authorization response:\n * check that it matches the state stored in the browser and return the variables associated\n * with the state, such as original_url and OP oidc_provider_t pointer.\n */\nstatic apr_byte_t oidc_authorization_response_match_state(request_rec *r,\n\t\toidc_cfg *c, const char *state, struct oidc_provider_t **provider,\n\t\toidc_proto_state_t **proto_state) {\n\n\toidc_debug(r, \"enter (state=%s)\", state);\n\n\tif ((state == NULL) || (apr_strnatcmp(state, \"\") == 0)) {\n\t\toidc_error(r, \"state parameter is not set\");\n\t\treturn FALSE;\n\t}\n\n\t/* check the state parameter against what we stored in a cookie */\n\tif (oidc_restore_proto_state(r, c, state, proto_state) == FALSE) {\n\t\toidc_error(r, \"unable to restore state\");\n\t\treturn FALSE;\n\t}\n\n\t*provider = oidc_get_provider_for_issuer(r, c,\n\t\t\toidc_proto_state_get_issuer(*proto_state), FALSE);\n\n\tif (*provider == NULL) {\n\t\toidc_proto_state_destroy(*proto_state);\n\t\t*proto_state = NULL;\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * redirect the browser to the session logout endpoint\n */\nstatic int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_util_javascript_escape(r->pool, oidc_get_redirect_uri(r, c)));\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}\n\n/*\n * handle an error returned by the OP\n */\nstatic int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,\n\t\toidc_proto_state_t *proto_state, const char *error,\n\t\tconst char *error_description) {\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\tif (prompt != NULL)\n\t\tprompt = apr_pstrdup(r->pool, prompt);\n\toidc_proto_state_destroy(proto_state);\n\tif ((prompt != NULL)\n\t\t\t&& (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\tapr_psprintf(r->pool, \"OpenID Connect Provider error: %s\", error),\n\t\t\terror_description, OK);\n}\n\n/*\n * get the r->user for this request based on the configuration for OIDC/OAuth\n */\napr_byte_t oidc_get_remote_user(request_rec *r, const char *claim_name,\n\t\tconst char *reg_exp, const char *replace, json_t *json,\n\t\tchar **request_user) {\n\n\t/* get the claim value from the JSON object */\n\tjson_t *username = json_object_get(json, claim_name);\n\tif ((username == NULL) || (!json_is_string(username))) {\n\t\toidc_warn(r, \"JSON object did not contain a \\\"%s\\\" string\", claim_name);\n\t\treturn FALSE;\n\t}\n\n\t*request_user = apr_pstrdup(r->pool, json_string_value(username));\n\n\tif (reg_exp != NULL) {\n\n\t\tchar *error_str = NULL;\n\n\t\tif (replace == NULL) {\n\n\t\t\tif (oidc_util_regexp_first_match(r->pool, *request_user, reg_exp,\n\t\t\t\t\trequest_user, &error_str) == FALSE) {\n\t\t\t\toidc_error(r, \"oidc_util_regexp_first_match failed: %s\",\n\t\t\t\t\t\terror_str);\n\t\t\t\t*request_user = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t} else if (oidc_util_regexp_substitute(r->pool, *request_user, reg_exp,\n\t\t\t\treplace, request_user, &error_str) == FALSE) {\n\n\t\t\toidc_error(r, \"oidc_util_regexp_substitute failed: %s\", error_str);\n\t\t\t*request_user = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * set the unique user identifier that will be propagated in the Apache r->user and REMOTE_USER variables\n */\nstatic apr_byte_t oidc_set_request_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, oidc_jwt_t *jwt, const char *s_claims) {\n\n\tchar *issuer = provider->issuer;\n\tchar *claim_name = apr_pstrdup(r->pool, c->remote_user_claim.claim_name);\n\tint n = strlen(claim_name);\n\tapr_byte_t post_fix_with_issuer = (claim_name[n - 1] == OIDC_CHAR_AT);\n\tif (post_fix_with_issuer == TRUE) {\n\t\tclaim_name[n - 1] = '\\0';\n\t\tissuer =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\t}\n\n\t/* extract the username claim (default: \"sub\") from the id_token payload or user claims */\n\tapr_byte_t rc = FALSE;\n\tchar *remote_user = NULL;\n\tjson_t *claims = NULL;\n\toidc_util_decode_json_object(r, s_claims, &claims);\n\tif (claims == NULL) {\n\t\trc = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,\n\t\t\t\tc->remote_user_claim.replace, jwt->payload.value.json,\n\t\t\t\t&remote_user);\n\t} else {\n\t\toidc_util_json_merge(r, jwt->payload.value.json, claims);\n\t\trc = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,\n\t\t\t\tc->remote_user_claim.replace, claims, &remote_user);\n\t\tjson_decref(claims);\n\t}\n\n\tif ((rc == FALSE) || (remote_user == NULL)) {\n\t\toidc_error(r,\n\t\t\t\t\"\" OIDCRemoteUserClaim \"is set to \\\"%s\\\", but could not set the remote user based on the requested claim \\\"%s\\\" and the available claims for the user\",\n\t\t\t\tc->remote_user_claim.claim_name, claim_name);\n\t\treturn FALSE;\n\t}\n\n\tif (post_fix_with_issuer == TRUE)\n\t\tremote_user = apr_psprintf(r->pool, \"%s%s%s\", remote_user, OIDC_STR_AT,\n\t\t\t\tissuer);\n\n\tr->user = apr_pstrdup(r->pool, remote_user);\n\n\toidc_debug(r, \"set remote_user to \\\"%s\\\" based on claim: \\\"%s\\\"%s\", r->user,\n\t\t\tc->remote_user_claim.claim_name,\n\t\t\tc->remote_user_claim.reg_exp ?\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\" and expression: \\\"%s\\\" and replace string: \\\"%s\\\"\",\n\t\t\t\t\t\t\tc->remote_user_claim.reg_exp,\n\t\t\t\t\t\t\tc->remote_user_claim.replace) :\n\t\t\t\t\t\t\t\"\");\n\n\treturn TRUE;\n}\n\nstatic char* oidc_make_sid_iss_unique(request_rec *r, const char *sid,\n\t\tconst char *issuer) {\n\treturn apr_psprintf(r->pool, \"%s@%s\", sid, issuer);\n}\n\n/*\n * store resolved information in the session\n */\nstatic apr_byte_t oidc_save_in_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tconst char *remoteUser, const char *id_token, oidc_jwt_t *id_token_jwt,\n\t\tconst char *claims, const char *access_token, const int expires_in,\n\t\tconst char *refresh_token, const char *session_state, const char *state,\n\t\tconst char *original_url, const char *userinfo_jwt) {\n\n\t/* store the user in the session */\n\tsession->remote_user = remoteUser;\n\n\t/* set the session expiry to the inactivity timeout */\n\tsession->expiry =\n\t\t\tapr_time_now() + apr_time_from_sec(c->session_inactivity_timeout);\n\n\t/* store the claims payload in the id_token for later reference */\n\toidc_session_set_idtoken_claims(r, session,\n\t\t\tid_token_jwt->payload.value.str);\n\n\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t/* store the compact serialized representation of the id_token for later reference  */\n\t\toidc_session_set_idtoken(r, session, id_token);\n\t}\n\n\t/* store the issuer in the session (at least needed for session mgmt and token refresh */\n\toidc_session_set_issuer(r, session, provider->issuer);\n\n\t/* store the state and original URL in the session for handling browser-back more elegantly */\n\toidc_session_set_request_state(r, session, state);\n\toidc_session_set_original_url(r, session, original_url);\n\n\tif ((session_state != NULL) && (provider->check_session_iframe != NULL)) {\n\t\t/* store the session state and required parameters session management  */\n\t\toidc_session_set_session_state(r, session, session_state);\n\t\toidc_debug(r,\n\t\t\t\t\"session management enabled: stored session_state (%s), check_session_iframe (%s) and client_id (%s) in the session\",\n\t\t\t\tsession_state, provider->check_session_iframe,\n\t\t\t\tprovider->client_id);\n\t} else if (provider->check_session_iframe == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: \\\"check_session_iframe\\\" is not set in provider configuration\");\n\t} else {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: no \\\"session_state\\\" value is provided in the authentication response even though \\\"check_session_iframe\\\" (%s) is set in the provider configuration\",\n\t\t\t\tprovider->check_session_iframe);\n\t}\n\n\t/* store claims resolved from userinfo endpoint */\n\toidc_store_userinfo_claims(r, c, session, provider, claims, userinfo_jwt);\n\n\t/* see if we have an access_token */\n\tif (access_token != NULL) {\n\t\t/* store the access_token in the session context */\n\t\toidc_session_set_access_token(r, session, access_token);\n\t\t/* store the associated expires_in value */\n\t\toidc_session_set_access_token_expires(r, session, expires_in);\n\t\t/* reset the access token refresh timestamp */\n\t\toidc_session_reset_access_token_last_refresh(r, session);\n\t}\n\n\t/* see if we have a refresh_token */\n\tif (refresh_token != NULL) {\n\t\t/* store the refresh_token in the session context */\n\t\toidc_session_set_refresh_token(r, session, refresh_token);\n\t}\n\n\t/* store max session duration in the session as a hard cut-off expiry timestamp */\n\tapr_time_t session_expires =\n\t\t\t(provider->session_max_duration == 0) ?\n\t\t\t\t\tapr_time_from_sec(id_token_jwt->payload.exp) :\n\t\t\t\t\t(apr_time_now()\n\t\t\t\t\t\t\t+ apr_time_from_sec(provider->session_max_duration));\n\toidc_session_set_session_expires(r, session, session_expires);\n\n\toidc_debug(r,\n\t\t\t\"provider->session_max_duration = %d, session_expires=%\" APR_TIME_T_FMT,\n\t\t\tprovider->session_max_duration, session_expires);\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\n\t/* store the domain for which this session is valid */\n\toidc_session_set_cookie_domain(r, session,\n\t\t\tc->cookie_domain ? c->cookie_domain : oidc_get_current_url_host(r));\n\n\tchar *sid = NULL;\n\toidc_debug(r, \"provider->backchannel_logout_supported=%d\",\n\t\t\tprovider->backchannel_logout_supported);\n\tif (provider->backchannel_logout_supported > 0) {\n\t\toidc_jose_get_string(r->pool, id_token_jwt->payload.value.json,\n\t\t\t\tOIDC_CLAIM_SID, FALSE, &sid, NULL);\n\t\tif (sid == NULL)\n\t\t\tsid = id_token_jwt->payload.sub;\n\t\tsession->sid = oidc_make_sid_iss_unique(r, sid, provider->issuer);\n\t}\n\n\t/* store the session */\n\treturn oidc_session_save(r, session, TRUE);\n}\n\n/*\n * parse the expiry for the access token\n */\nstatic int oidc_parse_expires_in(request_rec *r, const char *expires_in) {\n\tif (expires_in != NULL) {\n\t\tchar *ptr = NULL;\n\t\tlong number = strtol(expires_in, &ptr, 10);\n\t\tif (number <= 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"could not convert \\\"expires_in\\\" value (%s) to a number\",\n\t\t\t\t\texpires_in);\n\t\t\treturn -1;\n\t\t}\n\t\treturn number;\n\t}\n\treturn -1;\n}\n\n/*\n * handle the different flows (hybrid, implicit, Authorization Code)\n */\nstatic apr_byte_t oidc_handle_flows(request_rec *r, oidc_cfg *c,\n\t\toidc_proto_state_t *proto_state, oidc_provider_t *provider,\n\t\tapr_table_t *params, const char *response_mode, oidc_jwt_t **jwt) {\n\n\tapr_byte_t rc = FALSE;\n\n\tconst char *requested_response_type = oidc_proto_state_get_response_type(\n\t\t\tproto_state);\n\n\t/* handle the requested response type/mode */\n\tif (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN_TOKEN)) {\n\t\trc = oidc_proto_authorization_response_code_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN)) {\n\t\trc = oidc_proto_authorization_response_code_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_TOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_code_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE)) {\n\t\trc = oidc_proto_handle_authorization_response_code(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_IDTOKEN_TOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_IDTOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else {\n\t\toidc_error(r, \"unsupported response type: \\\"%s\\\"\",\n\t\t\t\trequested_response_type);\n\t}\n\n\tif ((rc == FALSE) && (*jwt != NULL)) {\n\t\toidc_jwt_destroy(*jwt);\n\t\t*jwt = NULL;\n\t}\n\n\treturn rc;\n}\n\n/* handle the browser back on an authorization response */\nstatic apr_byte_t oidc_handle_browser_back(request_rec *r, const char *r_state,\n\t\toidc_session_t *session) {\n\n\t/*  see if we have an existing session and browser-back was used */\n\tconst char *s_state = NULL, *o_url = NULL;\n\n\tif (session->remote_user != NULL) {\n\n\t\ts_state = oidc_session_get_request_state(r, session);\n\t\to_url = oidc_session_get_original_url(r, session);\n\n\t\tif ((r_state != NULL) && (s_state != NULL)\n\t\t\t\t&& (apr_strnatcmp(r_state, s_state) == 0)) {\n\n\t\t\t/* log the browser back event detection */\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"browser back detected, redirecting to original URL: %s\",\n\t\t\t\t\to_url);\n\n\t\t\t/* go back to the URL that he originally tried to access */\n\t\t\toidc_util_hdr_out_location_set(r, o_url);\n\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n/*\n * complete the handling of an authorization response by obtaining, parsing and verifying the\n * id_token and storing the authenticated user state in the session\n */\nstatic int oidc_handle_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, apr_table_t *params, const char *response_mode) {\n\n\toidc_debug(r, \"enter, response_mode=%s\", response_mode);\n\n\toidc_provider_t *provider = NULL;\n\toidc_proto_state_t *proto_state = NULL;\n\toidc_jwt_t *jwt = NULL;\n\n\t/* see if this response came from a browser-back event */\n\tif (oidc_handle_browser_back(r, apr_table_get(params, OIDC_PROTO_STATE),\n\t\t\tsession) == TRUE)\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\n\t/* match the returned state parameter against the state stored in the browser */\n\tif (oidc_authorization_response_match_state(r, c,\n\t\t\tapr_table_get(params, OIDC_PROTO_STATE), &provider, &proto_state)\n\t\t\t== FALSE) {\n\t\tif (c->default_sso_url != NULL) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"invalid authorization response state; a default SSO URL is set, sending the user there: %s\",\n\t\t\t\t\tc->default_sso_url);\n\t\t\toidc_util_hdr_out_location_set(r, c->default_sso_url);\n\t\t\t//oidc_util_hdr_err_out_add(r, \"Location\", c->default_sso_url));\n\t\t\treturn HTTP_MOVED_TEMPORARILY;\n\t\t}\n\t\toidc_error(r,\n\t\t\t\t\"invalid authorization response state and no default SSO URL is set, sending an error...\");\n\t\t// if content was already returned via html/http send then don't return 500\n\t\t// but send 200 to avoid extraneous internal error document text to be sent\n\t\treturn ((r->user) && (strncmp(r->user, \"\", 1) == 0)) ?\n\t\t\t\tOK :\n\t\t\t\tHTTP_BAD_REQUEST;\n\t}\n\n\t/* see if the response is an error response */\n\tif (apr_table_get(params, OIDC_PROTO_ERROR) != NULL)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ERROR),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ERROR_DESCRIPTION));\n\n\t/* handle the code, implicit or hybrid flow */\n\tif (oidc_handle_flows(r, c, proto_state, provider, params, response_mode,\n\t\t\t&jwt) == FALSE)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Error in handling response type.\", NULL);\n\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no id_token was provided\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"No id_token was provided.\", NULL);\n\t}\n\n\tint expires_in = oidc_parse_expires_in(r,\n\t\t\tapr_table_get(params, OIDC_PROTO_EXPIRES_IN));\n\tchar *userinfo_jwt = NULL;\n\n\t/*\n\t * optionally resolve additional claims against the userinfo endpoint\n\t * parsed claims are not actually used here but need to be parsed anyway for error checking purposes\n\t */\n\tconst char *claims = oidc_retrieve_claims_from_userinfo_endpoint(r, c,\n\t\t\tprovider, apr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), NULL,\n\t\t\tjwt->payload.sub, &userinfo_jwt);\n\n\t/* restore the original protected URL that the user was trying to access */\n\tconst char *original_url = oidc_proto_state_get_original_url(proto_state);\n\tif (original_url != NULL)\n\t\toriginal_url = apr_pstrdup(r->pool, original_url);\n\tconst char *original_method = oidc_proto_state_get_original_method(\n\t\t\tproto_state);\n\tif (original_method != NULL)\n\t\toriginal_method = apr_pstrdup(r->pool, original_method);\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\n\t/* set the user */\n\tif (oidc_set_request_user(r, c, provider, jwt, claims) == TRUE) {\n\n\t\t/* session management: if the user in the new response is not equal to the old one, error out */\n\t\tif ((prompt != NULL)\n\t\t\t\t&& (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {\n\t\t\t// TOOD: actually need to compare sub? (need to store it in the session separately then\n\t\t\t//const char *sub = NULL;\n\t\t\t//oidc_session_get(r, session, \"sub\", &sub);\n\t\t\t//if (apr_strnatcmp(sub, jwt->payload.sub) != 0) {\n\t\t\tif (apr_strnatcmp(session->remote_user, r->user) != 0) {\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"user set from new id_token is different from current one\");\n\t\t\t\toidc_jwt_destroy(jwt);\n\t\t\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\t\t\"User changed!\", NULL);\n\t\t\t}\n\t\t}\n\n\t\t/* store resolved information in the session */\n\t\tif (oidc_save_in_session(r, c, session, provider, r->user,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ID_TOKEN), jwt, claims,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), expires_in,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_REFRESH_TOKEN),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_SESSION_STATE),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_STATE), original_url,\n\t\t\t\tuserinfo_jwt) == FALSE) {\n\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\n\t} else {\n\t\toidc_error(r, \"remote user could not be set\");\n\t\toidc_jwt_destroy(jwt);\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Remote user could not be set: contact the website administrator\",\n\t\t\t\tNULL);\n\t}\n\n\t/* cleanup */\n\toidc_proto_state_destroy(proto_state);\n\toidc_jwt_destroy(jwt);\n\n\t/* check that we've actually authenticated a user; functions as error handling for oidc_get_remote_user */\n\tif (r->user == NULL)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* log the successful response */\n\toidc_debug(r,\n\t\t\t\"session created and stored, returning to original URL: %s, original method: %s\",\n\t\t\toriginal_url, original_method);\n\n\t/* check whether form post data was preserved; if so restore it */\n\tif (apr_strnatcmp(original_method, OIDC_METHOD_FORM_POST) == 0) {\n\t\treturn oidc_request_post_preserved_restore(r, original_url);\n\t}\n\n\t/* now we've authenticated the user so go back to the URL that he originally tried to access */\n\toidc_util_hdr_out_location_set(r, original_url);\n\n\t/* do the actual redirect to the original URL */\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the POST (+fragment->POST) response_mode\n */\nstatic int oidc_handle_post_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* initialize local variables */\n\tchar *response_mode = NULL;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if we've got any POST-ed data at all */\n\tif ((apr_table_elts(params)->nelts < 1)\n\t\t\t|| ((apr_table_elts(params)->nelts == 1)\n\t\t\t\t\t&& apr_table_get(params, OIDC_PROTO_RESPONSE_MODE)\n\t\t\t\t\t&& (apr_strnatcmp(\n\t\t\t\t\t\t\tapr_table_get(params, OIDC_PROTO_RESPONSE_MODE),\n\t\t\t\t\t\t\tOIDC_PROTO_RESPONSE_MODE_FRAGMENT) == 0))) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"You've hit an OpenID Connect Redirect URI with no parameters, this is an invalid request; you should not open this URL in your browser directly, or have the server administrator use a different \" OIDCRedirectURI \" setting.\",\n\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t}\n\n\t/* get the parameters */\n\tresponse_mode = (char*) apr_table_get(params, OIDC_PROTO_RESPONSE_MODE);\n\n\t/* do the actual implicit work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tresponse_mode ? response_mode : OIDC_PROTO_RESPONSE_MODE_FORM_POST);\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the redirect response_mode\n */\nstatic int oidc_handle_redirect_authorization_response(request_rec *r,\n\t\toidc_cfg *c, oidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* read the parameters from the query string */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\toidc_util_read_form_encoded_params(r, params, r->args);\n\n\t/* do the actual work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tOIDC_PROTO_RESPONSE_MODE_QUERY);\n}\n\n/*\n * present the user with an OP selection screen\n */\nstatic int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *path_scopes = oidc_dir_cfg_path_scope(r);\n\tchar *path_auth_request_params = oidc_dir_cfg_path_auth_request_params(r);\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \"%s%s%s=%s&%s=%s&%s=%s&%s=%s\",\n\t\t\t\tdiscover_url,\n\t\t\t\tstrchr(discover_url, OIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, oidc_get_redirect_uri(r, cfg)),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\tif (path_scopes != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_SC_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \"redirecting to external discovery page: %s\", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\t\tOIDC_COOKIE_SAMESITE_STRICT(cfg, r));\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn OK;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\toidc_util_hdr_out_location_set(r, url);\n\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\"Configuration Error\",\n\t\t\t\t\"No configured providers found, contact your administrator\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \"\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\t\t// TODO: html escape (especially & character)\n\n\t\tchar *href = apr_psprintf(r->pool,\n\t\t\t\t\"%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\",\n\t\t\t\toidc_get_redirect_uri(r, cfg), OIDC_DISC_OP_PARAM,\n\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\tOIDC_CSRF_NAME, csrf);\n\n\t\tif (path_scopes != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_SC_PARAM, oidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\n\t\t/* strip port number */\n\t\t//char *p = strstr(display, \":\");\n\t\t//if (p != NULL) *p = '\\0';\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts = apr_psprintf(r->pool, \"%s<p><a href=\\\"%s\\\">%s</a></p>\\n\", s, href,\n\t\t\t\tdisplay);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \"%s<form method=\\\"get\\\" action=\\\"%s\\\">\\n\", s,\n\t\t\toidc_get_redirect_uri(r, cfg));\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\n\tif (path_scopes != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_SC_PARAM, path_scopes);\n\tif (path_auth_request_params != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_AR_PARAM, path_auth_request_params);\n\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"text\\\" name=\\\"%s\\\" value=\\\"%s\\\"></p>\\n\", s,\n\t\t\tOIDC_DISC_OP_PARAM, \"\");\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"submit\\\" value=\\\"Submit\\\"></p>\\n\", s);\n\ts = apr_psprintf(r->pool, \"%s</form>\\n\", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\tOIDC_COOKIE_SAMESITE_STRICT(cfg, r));\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\"<style type=\\\"text/css\\\">body {text-align: center}</style>\";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript, &javascript_method)\n\t\t\t== TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \"%s%s\", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \"OpenID Connect Provider Discovery\",\n\t\t\thtml_head, javascript_method, s, OK);\n}\n\n/*\n * authenticate the user to the selected OP, if the OP is not selected yet perform discovery first\n */\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params, const char *path_scope) {\n\n\toidc_debug(r, \"enter\");\n\n\tif (provider == NULL) {\n\n\t\t// TODO: should we use an explicit redirect to the discovery endpoint (maybe a \"discovery\" param to the redirect_uri)?\n\t\tif (c->metadata_dir != NULL) {\n\t\t\t/*\n\t\t\t * Will be handled in the content handler; avoid:\n\t\t\t * No authentication done but request not allowed without authentication\n\t\t\t * by setting r->user\n\t\t\t */\n\t\t\toidc_debug(r, \"defer discovery to the content handler\");\n\t\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_DISCOVERY, \"\");\n\t\t\tr->user = \"\";\n\t\t\treturn OK;\n\t\t}\n\n\t\t/* we're not using multiple OP's configured in a metadata directory, pick the statically configured OP */\n\t\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* generate the random nonce value that correlates requests and responses */\n\tchar *nonce = NULL;\n\tif (oidc_proto_generate_nonce(r, &nonce, OIDC_PROTO_NONCE_LENGTH) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *pkce_state = NULL;\n\tchar *code_challenge = NULL;\n\n\tif ((oidc_util_spaced_string_contains(r->pool, provider->response_type,\n\t\t\tOIDC_PROTO_CODE) == TRUE) && (provider->pkce != NULL)) {\n\n\t\t/* generate the code verifier value that correlates authorization requests and code exchange requests */\n\t\tif (provider->pkce->state(r, &pkce_state) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t/* generate the PKCE code challenge */\n\t\tif (provider->pkce->challenge(r, pkce_state, &code_challenge) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* create the state between request/response */\n\toidc_proto_state_t *proto_state = oidc_proto_state_new();\n\toidc_proto_state_set_original_url(proto_state, original_url);\n\toidc_proto_state_set_original_method(proto_state,\n\t\t\toidc_original_request_method(r, c, TRUE));\n\toidc_proto_state_set_issuer(proto_state, provider->issuer);\n\toidc_proto_state_set_response_type(proto_state, provider->response_type);\n\toidc_proto_state_set_nonce(proto_state, nonce);\n\toidc_proto_state_set_timestamp_now(proto_state);\n\tif (provider->response_mode)\n\t\toidc_proto_state_set_response_mode(proto_state,\n\t\t\t\tprovider->response_mode);\n\tif (prompt)\n\t\toidc_proto_state_set_prompt(proto_state, prompt);\n\tif (pkce_state)\n\t\toidc_proto_state_set_pkce_state(proto_state, pkce_state);\n\n\t/* get a hash value that fingerprints the browser concatenated with the random input */\n\tchar *state = oidc_get_browser_state_hash(r, c, nonce);\n\n\t/*\n\t * create state that restores the context when the authorization response comes in\n\t * and cryptographically bind it to the browser\n\t */\n\tint rc = oidc_authorization_request_set_cookie(r, c, state, proto_state);\n\tif (rc != OK) {\n\t\toidc_proto_state_destroy(proto_state);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * printout errors if Cookie settings are not going to work\n\t * TODO: separate this code out into its own function\n\t */\n\tapr_uri_t o_uri;\n\tmemset(&o_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_t r_uri;\n\tmemset(&r_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_parse(r->pool, original_url, &o_uri);\n\tapr_uri_parse(r->pool, oidc_get_redirect_uri(r, c), &r_uri);\n\tif ((apr_strnatcmp(o_uri.scheme, r_uri.scheme) != 0)\n\t\t\t&& (apr_strnatcmp(r_uri.scheme, \"https\") == 0)) {\n\t\toidc_error(r,\n\t\t\t\t\"the URL scheme (%s) of the configured \" OIDCRedirectURI \" does not match the URL scheme of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\tr_uri.scheme, o_uri.scheme);\n\t\toidc_proto_state_destroy(proto_state);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (c->cookie_domain == NULL) {\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured \" OIDCRedirectURI \" does not match the URL hostname of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!oidc_util_cookie_domain_valid(r_uri.hostname, c->cookie_domain)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in \" OIDCCookieDomain \" does not match the URL hostname (%s) of the URL being accessed (%s): setting \\\"state\\\" and \\\"session\\\" cookies will not work!!\",\n\t\t\t\t\tc->cookie_domain, o_uri.hostname, original_url);\n\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n\n\t/* send off to the OpenID Connect Provider */\n\t// TODO: maybe show intermediate/progress screen \"redirecting to\"\n\treturn oidc_proto_authorization_request(r, provider, login_hint,\n\t\t\toidc_get_redirect_uri_iss(r, c, provider), state, proto_state,\n\t\t\tid_token_hint, code_challenge, auth_request_params, path_scope);\n}\n\n/*\n * check if the target_link_uri matches to configuration settings to prevent an open redirect\n */\nstatic int oidc_target_link_uri_matches_configuration(request_rec *r,\n\t\toidc_cfg *cfg, const char *target_link_uri) {\n\n\tapr_uri_t o_uri;\n\tapr_uri_parse(r->pool, target_link_uri, &o_uri);\n\tif (o_uri.hostname == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse the \\\"target_link_uri\\\" (%s) in to a valid URL: aborting.\",\n\t\t\t\ttarget_link_uri);\n\t\treturn FALSE;\n\t}\n\n\tapr_uri_t r_uri;\n\tapr_uri_parse(r->pool, oidc_get_redirect_uri(r, cfg), &r_uri);\n\n\tif (cfg->cookie_domain == NULL) {\n\t\t/* cookie_domain set: see if the target_link_uri matches the redirect_uri host (because the session cookie will be set host-wide) */\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured \" OIDCRedirectURI \" does not match the URL hostname of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* cookie_domain set: see if the target_link_uri is within the cookie_domain */\n\t\tchar *p = strstr(o_uri.hostname, cfg->cookie_domain);\n\t\tif ((p == NULL) || (apr_strnatcmp(cfg->cookie_domain, p) != 0)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in \" OIDCCookieDomain \" does not match the URL hostname (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.hostname, target_link_uri);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* see if the cookie_path setting matches the target_link_uri path */\n\tchar *cookie_path = oidc_cfg_dir_cookie_path(r);\n\tif (cookie_path != NULL) {\n\t\tchar *p = (o_uri.path != NULL) ? strstr(o_uri.path, cookie_path) : NULL;\n\t\tif ((p == NULL) || (p != o_uri.path)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the path (%s) configured in \" OIDCCookiePath \" does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\treturn FALSE;\n\t\t} else if (strlen(o_uri.path) > strlen(cookie_path)) {\n\t\t\tint n = strlen(cookie_path);\n\t\t\tif (cookie_path[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\t\t\tn--;\n\t\t\tif (o_uri.path[n] != OIDC_CHAR_FORWARD_SLASH) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the path (%s) configured in \" OIDCCookiePath \" does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n * handle a response from an IDP discovery page and/or handle 3rd-party initiated SSO\n */\nstatic int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL, *path_scopes;\n\toidc_provider_t *provider = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_SC_PARAM, &path_scopes);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0,\n\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because \" OIDCDefaultURL \" is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention */\n\tif (oidc_target_link_uri_matches_configuration(r, c, target_link_uri)\n\t\t\t== FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* see if this is a static setup */\n\tif (c->metadata_dir == NULL) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == TRUE)\n\t\t\t\t&& (issuer != NULL)) {\n\t\t\tif (apr_strnatcmp(provider->issuer, issuer) != 0) {\n\t\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\t\"The \\\"iss\\\" value must match the configured providers' one (%s != %s).\",\n\t\t\t\t\t\t\t\tissuer, c->provider.issuer),\n\t\t\t\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t\treturn oidc_authenticate_user(r, c, NULL, target_link_uri, login_hint,\n\t\t\t\tNULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, OIDC_STR_AT) != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, OIDC_STR_AT);\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer)\n\t\t\t\t== FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}\n\nstatic apr_uint32_t oidc_transparent_pixel[17] = { 0x474e5089, 0x0a1a0a0d,\n\t\t0x0d000000, 0x52444849, 0x01000000, 0x01000000, 0x00000408, 0x0c1cb500,\n\t\t0x00000002, 0x4144490b, 0x639c7854, 0x0000cffa, 0x02010702, 0x71311c9a,\n\t\t0x00000000, 0x444e4549, 0x826042ae };\n\nstatic apr_byte_t oidc_is_front_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL)\n\t\t\t&& ((apr_strnatcmp(logout_param_value,\n\t\t\t\t\tOIDC_GET_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t\t|| (apr_strnatcmp(logout_param_value,\n\t\t\t\t\t\t\tOIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)));\n}\n\nstatic apr_byte_t oidc_is_back_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL) && (apr_strnatcmp(logout_param_value,\n\t\t\tOIDC_BACKCHANNEL_STYLE_LOGOUT_PARAM_VALUE) == 0));\n}\n\n/*\n * revoke refresh token and access token stored in the session if the\n * OP has an RFC 7009 compliant token revocation endpoint\n */\nstatic void oidc_revoke_tokens(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *response = NULL;\n\tchar *basic_auth = NULL;\n\tchar *bearer_auth = NULL;\n\tapr_table_t *params = NULL;\n\tconst char *token = NULL;\n\toidc_provider_t *provider = NULL;\n\n\toidc_debug(r, \"enter\");\n\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE)\n\t\tgoto out;\n\n\toidc_debug(r, \"revocation_endpoint=%s\",\n\t\t\tprovider->revocation_endpoint_url ?\n\t\t\t\t\tprovider->revocation_endpoint_url : \"(null)\");\n\n\tif (provider->revocation_endpoint_url == NULL)\n\t\tgoto out;\n\n\tparams = apr_table_make(r->pool, 4);\n\n\t// add the token endpoint authentication credentials to the revocation endpoint call...\n\tif (oidc_proto_token_endpoint_auth(r, c, provider->token_endpoint_auth,\n\t\t\tprovider->client_id, provider->client_secret,\n\t\t\tprovider->client_signing_keys, provider->token_endpoint_url, params,\n\t\t\tNULL, &basic_auth, &bearer_auth) == FALSE)\n\t\tgoto out;\n\n\t// TODO: use oauth.ssl_validate_server ...\n\ttoken = oidc_session_get_refresh_token(r, session);\n\tif (token != NULL) {\n\t\tapr_table_setn(params, OIDC_PROTO_TOKEN_TYPE_HINT, OIDC_PROTO_REFRESH_TOKEN);\n\t\tapr_table_setn(params, OIDC_PROTO_TOKEN, token);\n\n\t\tif (oidc_util_http_post_form(r, provider->revocation_endpoint_url,\n\t\t\t\tparams, basic_auth, bearer_auth, c->oauth.ssl_validate_server,\n\t\t\t\t&response, c->http_timeout_long, c->outgoing_proxy,\n\t\t\t\toidc_dir_cfg_pass_cookies(r), NULL,\n\t\t\t\tNULL, NULL) == FALSE) {\n\t\t\toidc_warn(r, \"revoking refresh token failed\");\n\t\t}\n\t\tapr_table_unset(params, OIDC_PROTO_TOKEN_TYPE_HINT);\n\t\tapr_table_unset(params, OIDC_PROTO_TOKEN);\n\t}\n\n\ttoken = oidc_session_get_access_token(r, session);\n\tif (token != NULL) {\n\t\tapr_table_setn(params, OIDC_PROTO_TOKEN_TYPE_HINT, OIDC_PROTO_ACCESS_TOKEN);\n\t\tapr_table_setn(params, OIDC_PROTO_TOKEN, token);\n\n\t\tif (oidc_util_http_post_form(r, provider->revocation_endpoint_url,\n\t\t\t\tparams, basic_auth, bearer_auth, c->oauth.ssl_validate_server,\n\t\t\t\t&response, c->http_timeout_long, c->outgoing_proxy,\n\t\t\t\toidc_dir_cfg_pass_cookies(r), NULL,\n\t\t\t\tNULL, NULL) == FALSE) {\n\t\t\toidc_warn(r, \"revoking access token failed\");\n\t\t}\n\t}\n\nout:\n\n\toidc_debug(r, \"leave\");\n}\n\n/*\n * handle a local logout\n */\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url) {\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\t/* if there's no remote_user then there's no (stored) session to kill */\n\tif (session->remote_user != NULL)\n\t\toidc_revoke_tokens(r, c, session);\n\n\t/*\n\t * remove session state (cq. cache entry and cookie)\n\t * always clear the session cookie because the cookie may be not sent (but still in the browser)\n\t * due to SameSite policies\n\t */\n\toidc_session_kill(r, session);\n\n\t/* see if this is the OP calling us */\n\tif (oidc_is_front_channel_logout(url)) {\n\n\t\t/* set recommended cache control headers */\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,\n\t\t\t\t\"no-cache, no-store\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_PRAGMA, \"no-cache\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_P3P, \"CAO PSA OUR\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_EXPIRES, \"0\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_X_FRAME_OPTIONS, \"DENY\");\n\n\t\t/* see if this is PF-PA style logout in which case we return a transparent pixel */\n\t\tconst char *accept = oidc_util_hdr_in_accept_get(r);\n\t\tif ((apr_strnatcmp(url, OIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t|| ((accept) && strstr(accept, OIDC_CONTENT_TYPE_IMAGE_PNG))) {\n\t\t\treturn oidc_util_http_send(r, (const char*) &oidc_transparent_pixel,\n\t\t\t\t\tsizeof(oidc_transparent_pixel), OIDC_CONTENT_TYPE_IMAGE_PNG,\n\t\t\t\t\tOK);\n\t\t}\n\n\t\t/* standard HTTP based logout: should be called in an iframe from the OP */\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", OK);\n\t}\n\n\t/* see if we don't need to go somewhere special after killing the session locally */\n\tif (url == NULL)\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", OK);\n\n\t/* send the user to the specified where-to-go-after-logout URL */\n\toidc_util_hdr_out_location_set(r, url);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle a backchannel logout\n */\n#define OIDC_EVENTS_BLOGOUT_KEY \"http://schemas.openid.net/event/backchannel-logout\"\n\nstatic int oidc_handle_logout_backchannel(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *logout_token = NULL;\n\toidc_jwt_t *jwt = NULL;\n\toidc_jose_error_t err;\n\toidc_jwk_t *jwk = NULL;\n\toidc_provider_t *provider = NULL;\n\tchar *sid = NULL, *uuid = NULL;\n\toidc_session_t session;\n\tint rc = HTTP_BAD_REQUEST;\n\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"could not read POST-ed parameters to the logout endpoint\");\n\t\tgoto out;\n\t}\n\n\tlogout_token = apr_table_get(params, OIDC_PROTO_LOGOUT_TOKEN);\n\tif (logout_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"backchannel lggout endpoint was called but could not find a parameter named \\\"%s\\\"\",\n\t\t\t\tOIDC_PROTO_LOGOUT_TOKEN);\n\t\tgoto out;\n\t}\n\n\t// TODO: jwk symmetric key based on provider\n\n\tif (oidc_jwt_parse(r->pool, logout_token, &jwt,\n\t\t\toidc_util_merge_symmetric_key(r->pool, cfg->private_keys, NULL),\n\t\t\t&err) == FALSE) {\n\t\toidc_error(r, \"oidc_jwt_parse failed: %s\", oidc_jose_e2s(r->pool, err));\n\t\tgoto out;\n\t}\n\n\tif ((jwt->header.alg == NULL) || (strcmp(jwt->header.alg, \"none\") == 0)) {\n\t\toidc_error(r, \"logout token is not signed\");\n\t\tgoto out;\n\t}\n\n\tprovider = oidc_get_provider_for_issuer(r, cfg, jwt->payload.iss, FALSE);\n\tif (provider == NULL) {\n\t\toidc_error(r, \"no provider found for issuer: %s\", jwt->payload.iss);\n\t\tgoto out;\n\t}\n\n\t// TODO: destroy the JWK used for decryption\n\n\tjwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, provider->client_secret, 0,\n\t\t\tNULL, TRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwks_uri_t jwks_uri = { provider->jwks_uri,\n\t\t\tprovider->jwks_refresh_interval, provider->ssl_validate_server };\n\tif (oidc_proto_jwt_verify(r, cfg, jwt, &jwks_uri,\n\t\t\toidc_util_merge_symmetric_key(r->pool, NULL, jwk),\n\t\t\tprovider->id_token_signed_response_alg) == FALSE) {\n\n\t\toidc_error(r, \"id_token signature could not be validated, aborting\");\n\t\tgoto out;\n\t}\n\n\t// oidc_proto_validate_idtoken would try and require a token binding cnf\n\t// if the policy is set to \"required\", so don't use that here\n\tif (oidc_proto_validate_jwt(r, jwt,\n\t\t\tprovider->validate_issuer ? provider->issuer : NULL, FALSE, FALSE,\n\t\t\t\t\tprovider->idtoken_iat_slack,\n\t\t\t\t\tOIDC_TOKEN_BINDING_POLICY_DISABLED) == FALSE)\n\t\tgoto out;\n\n\t/* verify the \"aud\" and \"azp\" values */\n\tif (oidc_proto_validate_aud_and_azp(r, cfg, provider, &jwt->payload)\n\t\t\t== FALSE)\n\t\tgoto out;\n\n\tjson_t *events = json_object_get(jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_EVENTS);\n\tif (events == NULL) {\n\t\toidc_error(r, \"\\\"%s\\\" claim could not be found in logout token\",\n\t\t\t\tOIDC_CLAIM_EVENTS);\n\t\tgoto out;\n\t}\n\n\tjson_t *blogout = json_object_get(events, OIDC_EVENTS_BLOGOUT_KEY);\n\tif (!json_is_object(blogout)) {\n\t\toidc_error(r, \"\\\"%s\\\" object could not be found in \\\"%s\\\" claim\",\n\t\t\t\tOIDC_EVENTS_BLOGOUT_KEY, OIDC_CLAIM_EVENTS);\n\t\tgoto out;\n\t}\n\n\tchar *nonce = NULL;\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_NONCE, &nonce, NULL);\n\tif (nonce != NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"rejecting logout request/token since it contains a \\\"%s\\\" claim\",\n\t\t\t\tOIDC_CLAIM_NONCE);\n\t\tgoto out;\n\t}\n\n\tchar *jti = NULL;\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_JTI, &jti, NULL);\n\tif (jti != NULL) {\n\t\tchar *replay = NULL;\n\t\toidc_cache_get_jti(r, jti, &replay);\n\t\tif (replay != NULL) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the \\\"%s\\\" value (%s) passed in logout token was found in the cache already; possible replay attack!?\",\n\t\t\t\t\tOIDC_CLAIM_JTI, jti);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* jti cache duration is the configured replay prevention window for token issuance plus 10 seconds for safety */\n\tapr_time_t jti_cache_duration = apr_time_from_sec(\n\t\t\tprovider->idtoken_iat_slack * 2 + 10);\n\n\t/* store it in the cache for the calculated duration */\n\toidc_cache_set_jti(r, jti, jti, apr_time_now() + jti_cache_duration);\n\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_EVENTS, &sid, NULL);\n\n\t// TODO: by-spec we should cater for the fact that \"sid\" has been provided\n\t//       in the id_token returned in the authentication request, but \"sub\"\n\t//       is used in the logout token but that requires a 2nd entry in the\n\t//       cache and a separate session \"sub\" member, ugh; we'll just assume\n\t//       that is \"sid\" is specified in the id_token, the OP will actually use\n\t//       this for logout\n\t//       (and probably call us multiple times or the same sub if needed)\n\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_SID, &sid, NULL);\n\tif (sid == NULL)\n\t\tsid = jwt->payload.sub;\n\n\tif (sid == NULL) {\n\t\toidc_error(r, \"no \\\"sub\\\" and no \\\"sid\\\" claim found in logout token\");\n\t\tgoto out;\n\t}\n\n\t// TODO: when dealing with sub instead of a true sid, we'll be killing all sessions for\n\t//       a specific user, across hosts that share the *same* cache backend\n\t//       if those hosts haven't been configured with a different OIDCCryptoPassphrase\n\t//       - perhaps that's even acceptable since non-memory caching is encrypted by default\n\t//         and memory-based caching doesn't suffer from this (different shm segments)?\n\t//       - it will result in 400 errors returned from backchannel logout calls to the other hosts...\n\n\tsid = oidc_make_sid_iss_unique(r, sid, provider->issuer);\n\toidc_cache_get_sid(r, sid, &uuid);\n\tif (uuid == NULL) {\n\t\t// this may happen when we are the caller\n\t\toidc_warn(r,\n\t\t\t\t\"could not (or no longer) find a session based on sid/sub provided in logout token: %s\",\n\t\t\t\tsid);\n\t\tr->user = \"\";\n\t\trc = OK;\n\t\tgoto out;\n\t}\n\n\t// revoke tokens if we can get a handle on those\n\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\tif (oidc_session_load_cache_by_uuid(r, cfg, uuid, &session) != FALSE)\n\t\t\tif (oidc_session_extract(r, &session) != FALSE)\n\t\t\t\toidc_revoke_tokens(r, cfg, &session);\n\t}\n\n\t// clear the session cache\n\toidc_cache_set_sid(r, sid, NULL, 0);\n\toidc_cache_set_session(r, uuid, NULL, 0);\n\n\tr->user = \"\";\n\trc = OK;\n\nout:\n\n\tif (jwk != NULL) {\n\t\toidc_jwk_destroy(jwk);\n\t\tjwk = NULL;\n\n\t}\n\tif (jwt != NULL) {\n\t\toidc_jwt_destroy(jwt);\n\t\tjwt = NULL;\n\t}\n\n\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,\n\t\t\t\"no-cache, no-store\");\n\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_PRAGMA, \"no-cache\");\n\n\treturn rc;\n}\n\n#define OIDC_MAX_URL_LENGTH 8192 * 2\n\nstatic apr_byte_t oidc_validate_redirect_url(request_rec *r, oidc_cfg *c,\n\t\tconst char *redirect_to_url, apr_byte_t restrict_to_host, char **err_str,\n\t\tchar **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\tapr_hash_index_t *hi = NULL;\n\tsize_t i = 0;\n\tchar *url = apr_pstrndup(r->pool, redirect_to_url, OIDC_MAX_URL_LENGTH);\n\n\t// replace potentially harmful backslashes with forward slashes\n\tfor (i = 0; i < strlen(url); i++)\n\t\tif (url[i] == '\\\\')\n\t\t\turl[i] = '/';\n\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"not a valid URL value: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\tif (c->redirect_urls_allowed != NULL) {\n\t\tfor (hi = apr_hash_first(NULL, c->redirect_urls_allowed); hi; hi =\n\t\t\t\tapr_hash_next(hi)) {\n\t\t\tapr_hash_this(hi, (const void**) &c_host, NULL, NULL);\n\t\t\tif (oidc_util_regexp_first_match(r->pool, url, c_host,\n\t\t\t\t\tNULL, err_str) == TRUE)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (hi == NULL) {\n\t\t\t*err_str = apr_pstrdup(r->pool, \"URL not allowed\");\n\t\t\t*err_desc =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"value does not match the list of allowed redirect URLs: %s\",\n\t\t\t\t\t\t\turl);\n\t\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\t\treturn FALSE;\n\t\t}\n\t} else if ((uri.hostname != NULL) && (restrict_to_host == TRUE)) {\n\t\tc_host = oidc_get_current_url_host(r);\n\t\tif ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL)) {\n\t\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t\t*err_desc =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"URL value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"//\") == url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool,\n\t\t\t\t\"No hostname was parsed and starting with '//': %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\\\\\") == url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool,\n\t\t\t\t\"No hostname was parsed and starting with '/\\\\': %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the URL to prevent HTTP header splitting */\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"URL value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * perform (single) logout\n */\nstatic int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\t\tif (oidc_validate_redirect_url(r, c, url, TRUE, &error_str,\n\t\t\t\t&error_description) == FALSE) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\t\terror_description,\n\t\t\t\t\tHTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\t//char *state = NULL;\n\t\t//oidc_proto_generate_nonce(r, &state, 8);\n\t\t//url = apr_psprintf(r->pool, \"%s&state=%s\", logout_request, state);\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}\n\n/*\n * handle request for JWKs\n */\nint oidc_handle_jwks(request_rec *r, oidc_cfg *c) {\n\n\t/* pickup requested JWKs type */\n\t//\tchar *jwks_type = NULL;\n\t//\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_JWKS, &jwks_type);\n\tchar *jwks = apr_pstrdup(r->pool, \"{ \\\"keys\\\" : [\");\n\tint i = 0;\n\tapr_byte_t first = TRUE;\n\toidc_jose_error_t err;\n\n\tif (c->public_keys != NULL) {\n\n\t\t/* loop over the RSA public keys */\n\t\tfor (i = 0; i < c->public_keys->nelts; i++) {\n\t\t\tconst oidc_jwk_t *jwk =\n\t\t\t\t\t((const oidc_jwk_t**) c->public_keys->elts)[i];\n\t\t\tchar *s_json = NULL;\n\n\t\t\tif (oidc_jwk_to_json(r->pool, jwk, &s_json, &err) == TRUE) {\n\t\t\t\tjwks = apr_psprintf(r->pool, \"%s%s %s \", jwks, first ? \"\" : \",\",\n\t\t\t\t\t\ts_json);\n\t\t\t\tfirst = FALSE;\n\t\t\t} else {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"could not convert RSA JWK to JSON using oidc_jwk_to_json: %s\",\n\t\t\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: send stuff if first == FALSE?\n\tjwks = apr_psprintf(r->pool, \"%s ] }\", jwks);\n\n\treturn oidc_util_http_send(r, jwks, strlen(jwks), OIDC_CONTENT_TYPE_JSON,\n\t\t\tOK);\n}\n\nstatic int oidc_handle_session_management_iframe_op(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *check_session_iframe) {\n\toidc_debug(r, \"enter\");\n\toidc_util_hdr_out_location_set(r, check_session_iframe);\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\nstatic int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var clientId  = '%s';\\n\"\n\t\t\t\"      var sessionId  = '%s';\\n\"\n\t\t\t\"      var loginUrl  = '%s';\\n\"\n\t\t\t\"      var message = clientId + ' ' + sessionId;\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %d);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed' && sessionId == '' ) {\\n\"\n\t\t\t\"\t\t\t // 'changed' + no session: enforce a login (if we have a login url...)\\n\"\n\t\t\t\"            if (loginUrl != '') {\\n\"\n\t\t\t\"              window.top.location.replace(loginUrl);\\n\"\n\t\t\t\"            }\\n\"\n\t\t\t\"\t\t   } else {\\n\"\n\t\t\t\"              // either 'changed' + active session, or 'error': enforce a logout\\n\"\n\t\t\t\"              window.top.location.replace('%s?logout=' + encodeURIComponent(window.top.location.href));\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\t//return OK;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;\n\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))\n\t\tpoll_interval = 3000;\n\n\tchar *login_uri = NULL, *error_str = NULL, *error_description = NULL;\n\toidc_util_get_request_parameter(r, \"login_uri\", &login_uri);\n\tif ((login_uri != NULL)\n\t\t\t&& (oidc_validate_redirect_url(r, c, login_uri, FALSE, &error_str,\n\t\t\t\t\t&error_description) == FALSE)) {\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state ? session_state : \"\", login_uri ? login_uri : \"\",\n\t\t\t\t\top_iframe_id, poll_interval, redirect_uri, redirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, OK);\n}\n\n/*\n * handle session management request\n */\nstatic int oidc_handle_session_management(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tchar *cmd = NULL;\n\tconst char *id_token_hint = NULL;\n\toidc_provider_t *provider = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_SESSION, &cmd);\n\tif (cmd == NULL) {\n\t\toidc_error(r, \"session management handler called with no command\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if this is a local logout during session management */\n\tif (apr_strnatcmp(\"logout\", cmd) == 0) {\n\t\toidc_debug(r,\n\t\t\t\t\"[session=logout] calling oidc_handle_logout_request because of session mgmt local logout call.\");\n\t\treturn oidc_handle_logout_request(r, c, session, c->default_slo_url);\n\t}\n\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\t\t\t|| (provider == NULL))\n\t\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the OP iframe */\n\tif (apr_strnatcmp(\"iframe_op\", cmd) == 0) {\n\t\tif (provider->check_session_iframe != NULL) {\n\t\t\treturn oidc_handle_session_management_iframe_op(r, c, session,\n\t\t\t\t\tprovider->check_session_iframe);\n\t\t}\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the RP iframe */\n\tif (apr_strnatcmp(\"iframe_rp\", cmd) == 0) {\n\t\tif ((provider->client_id != NULL)\n\t\t\t\t&& (provider->check_session_iframe != NULL)) {\n\t\t\treturn oidc_handle_session_management_iframe_rp(r, c, session,\n\t\t\t\t\tprovider->client_id, provider->check_session_iframe);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"iframe_rp command issued but no client (%s) and/or no check_session_iframe (%s) set\",\n\t\t\t\tprovider->client_id, provider->check_session_iframe);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request check the login state with the OP */\n\tif (apr_strnatcmp(\"check\", cmd) == 0) {\n\t\tid_token_hint = oidc_session_get_idtoken(r, session);\n\t\t/*\n\t\t * TODO: this doesn't work with per-path provided auth_request_params and scopes\n\t\t *       as oidc_dir_cfg_path_auth_request_params and oidc_dir_cfg_path_scope will pick\n\t\t *       those for the redirect_uri itself; do we need to store those as part of the\n\t\t *       session now?\n\t\t */\n\t\treturn oidc_authenticate_user(r, c, provider,\n\t\t\t\tapr_psprintf(r->pool, \"%s?session=iframe_rp\",\n\t\t\t\t\t\toidc_get_redirect_uri_iss(r, c, provider)), NULL,\n\t\t\t\t\t\tid_token_hint, \"none\", oidc_dir_cfg_path_auth_request_params(r),\n\t\t\t\t\t\toidc_dir_cfg_path_scope(r));\n\t}\n\n\t/* handle failure in fallthrough */\n\toidc_error(r, \"unknown command: %s\", cmd);\n\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n}\n\n/*\n * handle refresh token request\n */\nstatic int oidc_handle_refresh_token_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *return_to = NULL;\n\tchar *r_access_token = NULL;\n\tchar *error_code = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\tapr_byte_t needs_save = TRUE;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REFRESH,\n\t\t\t&return_to);\n\toidc_util_get_request_parameter(r, OIDC_PROTO_ACCESS_TOKEN,\n\t\t\t&r_access_token);\n\n\t/* check the input parameters */\n\tif (return_to == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no URL to return to\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* do input validation on the return to parameter value */\n\tif (oidc_validate_redirect_url(r, c, return_to, TRUE, &error_str,\n\t\t\t&error_description) == FALSE) {\n\t\toidc_error(r, \"return_to URL validation failed: %s: %s\", error_str,\n\t\t\t\terror_description);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (r_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no access_token parameter\");\n\t\terror_code = \"no_access_token\";\n\t\tgoto end;\n\t}\n\n\tconst char *s_access_token = oidc_session_get_access_token(r, session);\n\tif (s_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"no existing access_token found in the session, nothing to refresh\");\n\t\terror_code = \"no_access_token_exists\";\n\t\tgoto end;\n\t}\n\n\t/* compare the access_token parameter used for XSRF protection */\n\tif (apr_strnatcmp(s_access_token, r_access_token) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"access_token passed in refresh request does not match the one stored in the session\");\n\t\terror_code = \"no_access_token_match\";\n\t\tgoto end;\n\t}\n\n\t/* get a handle to the provider configuration */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\n\t/* execute the actual refresh grant */\n\tif (oidc_refresh_access_token(r, c, session, provider, NULL) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\terror_code = \"refresh_failed\";\n\t\tgoto end;\n\t}\n\n\t/* pass the tokens to the application, possibly updating the expiry */\n\tif (oidc_session_pass_tokens(r, c, session, &needs_save) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\n\tif (oidc_session_save(r, session, FALSE) == FALSE) {\n\t\terror_code = \"error saving session\";\n\t\tgoto end;\n\t}\n\nend:\n\n\t/* pass optional error message to the return URL */\n\tif (error_code != NULL)\n\t\treturn_to = apr_psprintf(r->pool, \"%s%serror_code=%s\", return_to,\n\t\t\t\tstrchr(return_to ? return_to : \"\", OIDC_CHAR_QUERY) ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY, oidc_util_escape_string(r, error_code));\n\n\t/* add the redirect location header */\n\toidc_util_hdr_out_location_set(r, return_to);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle request object by reference request\n */\nstatic int oidc_handle_request_uri(request_rec *r, oidc_cfg *c) {\n\n\tchar *request_ref = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REQUEST_URI,\n\t\t\t&request_ref);\n\tif (request_ref == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" parameter found\",\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI);\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\n\tchar *jwt = NULL;\n\toidc_cache_get_request_uri(r, request_ref, &jwt);\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no cached JWT found for %s reference: %s\",\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI, request_ref);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\toidc_cache_set_request_uri(r, request_ref, NULL, 0);\n\n\treturn oidc_util_http_send(r, jwt, strlen(jwt), OIDC_CONTENT_TYPE_JWT, OK);\n}\n\n/*\n * handle a request to invalidate a cached access token introspection result\n */\nint oidc_handle_remove_at_cache(request_rec *r, oidc_cfg *c) {\n\tchar *access_token = NULL;\n\toidc_util_get_request_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE, &access_token);\n\n\tchar *cache_entry = NULL;\n\toidc_cache_get_access_token(r, access_token, &cache_entry);\n\tif (cache_entry == NULL) {\n\t\toidc_error(r, \"no cached access token found for value: %s\",\n\t\t\t\taccess_token);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\toidc_cache_set_access_token(r, access_token, NULL, 0);\n\n\treturn OK;\n}\n\n#define OIDC_INFO_PARAM_ACCESS_TOKEN_REFRESH_INTERVAL \"access_token_refresh_interval\"\n\n/*\n * handle request for session info\n */\nstatic int oidc_handle_info_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, apr_byte_t needs_save) {\n\tint rc = HTTP_UNAUTHORIZED;\n\tchar *s_format = NULL, *s_interval = NULL, *r_value = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_INFO,\n\t\t\t&s_format);\n\toidc_util_get_request_parameter(r,\n\t\t\tOIDC_INFO_PARAM_ACCESS_TOKEN_REFRESH_INTERVAL, &s_interval);\n\n\t/* see if this is a request for a format that is supported */\n\tif ((apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) != 0)\n\t\t\t&& (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_HTML, s_format) != 0)) {\n\t\toidc_warn(r, \"request for unknown format: %s\", s_format);\n\t\treturn HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t}\n\n\t/* check that we actually have a user session and this is someone calling with a proper session cookie */\n\tif (session->remote_user == NULL) {\n\t\toidc_warn(r, \"no user session found\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/* set the user in the main request for further (incl. sub-request and authz) processing */\n\tr->user = apr_pstrdup(r->pool, session->remote_user);\n\n\tif (c->info_hook_data == NULL) {\n\t\toidc_warn(r, \"no data configured to return in \" OIDCInfoHook);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if we can and need to refresh the access token */\n\tif ((s_interval != NULL)\n\t\t\t&& (oidc_session_get_refresh_token(r, session) != NULL)) {\n\n\t\tapr_time_t t_interval;\n\t\tif (sscanf(s_interval, \"%\" APR_TIME_T_FMT, &t_interval) == 1) {\n\t\t\tt_interval = apr_time_from_sec(t_interval);\n\n\t\t\t/* get the last refresh timestamp from the session info */\n\t\t\tapr_time_t last_refresh =\n\t\t\t\t\toidc_session_get_access_token_last_refresh(r, session);\n\n\t\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\t\tapr_time_sec(last_refresh + t_interval - apr_time_now()));\n\n\t\t\t/* see if we need to refresh again */\n\t\t\tif (last_refresh + t_interval < apr_time_now()) {\n\n\t\t\t\t/* get the current provider info */\n\t\t\t\toidc_provider_t *provider = NULL;\n\t\t\t\tif (oidc_get_provider_from_session(r, c, session, &provider)\n\t\t\t\t\t\t== FALSE)\n\t\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t\t\t/* execute the actual refresh grant */\n\t\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t\tNULL) == FALSE)\n\t\t\t\t\toidc_warn(r, \"access_token could not be refreshed\");\n\t\t\t\telse\n\t\t\t\t\tneeds_save = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* create the JSON object */\n\tjson_t *json = json_object();\n\n\t/* add a timestamp of creation in there for the caller */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_TIMESTAMP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_TIMESTAMP,\n\t\t\t\tjson_integer(apr_time_sec(apr_time_now())));\n\t}\n\n\t/*\n\t * refresh the claims from the userinfo endpoint\n\t * side-effect is that this may refresh the access token if not already done\n\t * note that OIDCUserInfoRefreshInterval should be set to control the refresh policy\n\t */\n\tneeds_save |= oidc_refresh_claims_from_userinfo_endpoint(r, c, session);\n\n\t/* include the access token in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tconst char *access_token = oidc_session_get_access_token(r, session);\n\t\tif (access_token != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN,\n\t\t\t\t\tjson_string(access_token));\n\t}\n\n\t/* include the access token expiry timestamp in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tconst char *access_token_expires =\n\t\t\t\toidc_session_get_access_token_expires(r, session);\n\t\tif (access_token_expires != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,\n\t\t\t\t\tjson_string(access_token_expires));\n\t}\n\n\t/* include the id_token claims in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ID_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_t *id_token = oidc_session_get_idtoken_claims_json(r, session);\n\t\tif (id_token)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ID_TOKEN, id_token);\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_USER_INFO,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\t/* include the claims from the userinfo endpoint the session info */\n\t\tjson_t *claims = oidc_session_get_userinfo_claims_json(r, session);\n\t\tif (claims)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_USER_INFO, claims);\n\t}\n\n\t/* include the maximum session lifetime in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION_EXP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tapr_time_t session_expires = oidc_session_get_session_expires(r,\n\t\t\t\tsession);\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION_EXP,\n\t\t\t\tjson_integer(apr_time_sec(session_expires)));\n\t}\n\n\t/* include the inactivity timeout in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION_TIMEOUT,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION_TIMEOUT,\n\t\t\t\tjson_integer(apr_time_sec(session->expiry)));\n\t}\n\n\t/* include the remote_user in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION_REMOTE_USER,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION_REMOTE_USER,\n\t\t\t\tjson_string(session->remote_user));\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_t *j_session = json_object();\n\t\tjson_object_set(j_session, OIDC_HOOK_INFO_SESSION_STATE,\n\t\t\t\tsession->state);\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_UUID,\n\t\t\t\tjson_string(session->uuid));\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION, j_session);\n\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_REFRESH_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\t/* include the refresh token in the session info */\n\t\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\t\tif (refresh_token != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_REFRESH_TOKEN,\n\t\t\t\t\tjson_string(refresh_token));\n\t}\n\n\t/* pass the tokens to the application and save the session, possibly updating the expiry */\n\tif (oidc_session_pass_tokens(r, c, session, &needs_save) == FALSE)\n\t\toidc_warn(r, \"error passing tokens\");\n\n\t/* check if something was updated in the session and we need to save it again */\n\tif (needs_save) {\n\t\tif (oidc_session_save(r, session, FALSE) == FALSE) {\n\t\t\toidc_warn(r, \"error saving session\");\n\t\t\trc = HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n\n\tif (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) == 0) {\n\t\t/* JSON-encode the result */\n\t\tr_value = oidc_util_encode_json_object(r, json, 0);\n\t\t/* return the stringified JSON result */\n\t\trc = oidc_util_http_send(r, r_value, strlen(r_value),\n\t\t\t\tOIDC_CONTENT_TYPE_JSON, OK);\n\t} else if (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_HTML, s_format) == 0) {\n\t\t/* JSON-encode the result */\n\t\tr_value = oidc_util_encode_json_object(r, json, JSON_INDENT(2));\n\t\trc = oidc_util_html_send(r, \"Session Info\", NULL, NULL,\n\t\t\t\tapr_psprintf(r->pool, \"<pre>%s</pre>\", r_value), OK);\n\t}\n\n\t/* free the allocated resources */\n\tjson_decref(json);\n\n\treturn rc;\n}\n\n/*\n * handle all requests to the redirect_uri\n */\nint oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response from the OP using the Basic Client profile or a Hybrid flow*/\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t\t/*\n\t\t *\n\t\t * Note that we are checking for logout *before* checking for a POST authorization response\n\t\t * to handle backchannel POST-based logout\n\t\t *\n\t\t * so any POST to the Redirect URI that does not have a logout query parameter will be handled\n\t\t * as an authorization response; alternatively we could assume that a POST response has no\n\t\t * parameters\n\t\t */\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_LOGOUT)) {\n\t\t/* handle logout */\n\t\treturn oidc_handle_logout(r, c, session);\n\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response using the fragment(+POST) response_mode with the Implicit Client profile */\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\n\t} else if (oidc_is_discovery_response(r, c)) {\n\n\t\t/* this is response from the OP discovery page */\n\t\treturn oidc_handle_discovery_response(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_JWKS)) {\n\t\t/*\n\t\t * Will be handled in the content handler; avoid:\n\t\t * No authentication done but request not allowed without authentication\n\t\t * by setting r->user\n\t\t */\n\t\tr->user = \"\";\n\t\treturn OK;\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_SESSION)) {\n\n\t\t/* handle session management request */\n\t\treturn oidc_handle_session_management(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REFRESH)) {\n\n\t\t/* handle refresh token request */\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI)) {\n\n\t\t/* handle request object by reference request */\n\t\treturn oidc_handle_request_uri(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE)) {\n\n\t\t/* handle request to invalidate access token cache */\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_INFO)) {\n\n\t\tif (session->remote_user == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\n\t\t/*\n\t\t * Will be handled in the content handler; avoid:\n\t\t * No authentication done but request not allowed without authentication\n\t\t * by setting r->user\n\t\t */\n\t\tr->user = \"\";\n\t\treturn OK;\n\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\n\t\t/* this is a \"bare\" request to the redirect URI, indicating implicit flow using the fragment response_mode */\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\n\t/* this is not an authorization response or logout request */\n\n\t/* check for \"error\" response */\n\tif (oidc_util_request_has_parameter(r, OIDC_PROTO_ERROR)) {\n\n\t\t//\t\tchar *error = NULL, *descr = NULL;\n\t\t//\t\toidc_util_get_request_parameter(r, \"error\", &error);\n\t\t//\t\toidc_util_get_request_parameter(r, \"error_description\", &descr);\n\t\t//\n\t\t//\t\t/* send user facing error to browser */\n\t\t//\t\treturn oidc_util_html_send_error(r, error, descr, OK);\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\n\toidc_error(r,\n\t\t\t\"The OpenID Connect callback URL received an invalid request: %s; returning HTTP_INTERNAL_SERVER_ERROR\",\n\t\t\tr->args);\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request\"),\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n}\n\n#define OIDC_AUTH_TYPE_OPENID_CONNECT \"openid-connect\"\n#define OIDC_AUTH_TYPE_OPENID_OAUTH20 \"oauth20\"\n#define OIDC_AUTH_TYPE_OPENID_BOTH    \"auth-openidc\"\n\n/*\n * main routine: handle OpenID Connect authentication\n */\nstatic int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (oidc_get_redirect_uri(r, c) == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"\" OIDC_AUTH_TYPE_OPENID_CONNECT \"\\\" but \" OIDCRedirectURI \" has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (!ap_is_initial_req(r)) {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * try to load a new session as if this were the initial request\n\t\t */\n\t}\n\n\tint rc = OK;\n\tapr_byte_t needs_save = FALSE;\n\n\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\toidc_session_t *session = NULL;\n\toidc_session_load(r, &session);\n\n\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\tif (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c))) {\n\n\t\t/* handle request to the redirect_uri */\n\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\treturn rc;\n\n\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t} else if (session->remote_user != NULL) {\n\n\t\t/* this is initial request and we already have a session */\n\t\trc = oidc_handle_existing_session(r, c, session, &needs_save);\n\t\tif (rc == OK) {\n\n\t\t\t/* check if something was updated in the session and we need to save it again */\n\t\t\tif (needs_save) {\n\t\t\t\tif (oidc_session_save(r, session, FALSE) == FALSE) {\n\t\t\t\t\toidc_warn(r, \"error saving session\");\n\t\t\t\t\trc = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/* strip any cookies that we need to */\n\t\toidc_strip_cookies(r);\n\n\t\treturn rc;\n\t}\n\n\t/* free resources allocated for the session */\n\toidc_session_free(r, session);\n\n\t/*\n\t * else: we have no session and it is not an authorization or\n\t *       discovery response: just hit the default flow for unauthenticated users\n\t */\n\n\treturn oidc_handle_unauthenticated_user(r, c);\n}\n\n/*\n * main routine: handle \"mixed\" OIDC/OAuth authentication\n */\nstatic int oidc_check_mixed_userid_oauth(request_rec *r, oidc_cfg *c) {\n\n\t/* get the bearer access token from the Authorization header */\n\tconst char *access_token = NULL;\n\tif (oidc_oauth_get_bearer_token(r, &access_token) == TRUE) {\n\n\t\tr->ap_auth_type = apr_pstrdup(r->pool, OIDC_AUTH_TYPE_OPENID_OAUTH20);\n\t\treturn oidc_oauth_check_userid(r, c, access_token);\n\t}\n\n\t/* no bearer token found: then treat this as a regular OIDC browser request */\n\tr->ap_auth_type = apr_pstrdup(r->pool, OIDC_AUTH_TYPE_OPENID_CONNECT);\n\treturn oidc_check_userid_openidc(r, c);\n}\n\n/*\n * generic Apache authentication hook for this module: dispatches to OpenID Connect or OAuth 2.0 specific routines\n */\nint oidc_check_user_id(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\t/* log some stuff about the incoming HTTP request */\n\toidc_debug(r, \"incoming request: \\\"%s?%s\\\", ap_is_initial_req(r)=%d\",\n\t\t\tr->parsed_uri.path, r->args, ap_is_initial_req(r));\n\n\t/* see if any authentication has been defined at all */\n\tconst char *current_auth = ap_auth_type(r);\n\tif (current_auth == NULL)\n\t\treturn DECLINED;\n\n\t/* see if we've configured OpenID Connect user authentication for this request */\n\tif (strcasecmp(current_auth, OIDC_AUTH_TYPE_OPENID_CONNECT) == 0) {\n\n\t\tr->ap_auth_type = (char*) current_auth;\n\t\treturn oidc_check_userid_openidc(r, c);\n\t}\n\n\t/* see if we've configured OAuth 2.0 access control for this request */\n\tif (strcasecmp(current_auth, OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\n\t\tr->ap_auth_type = (char*) current_auth;\n\t\treturn oidc_oauth_check_userid(r, c, NULL);\n\t}\n\n\t/* see if we've configured \"mixed mode\" for this request */\n\tif (strcasecmp(current_auth, OIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn oidc_check_mixed_userid_oauth(r, c);\n\n\t/* this is not for us but for some other handler */\n\treturn DECLINED;\n}\n\n/*\n * get the claims and id_token from request state\n */\nstatic void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}\n\n#if MODULE_MAGIC_NUMBER_MAJOR >= 20100714\n\n#define OIDC_OAUTH_BEARER_SCOPE_ERROR \"OIDC_OAUTH_BEARER_SCOPE_ERROR\"\n#define OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE \"Bearer error=\\\"insufficient_scope\\\", error_description=\\\"Different scope(s) or other claims required\\\"\"\n\n/*\n * find out which action we need to take when encountering an unauthorized request\n */\nstatic authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\n\t/* see if we've configured OIDCUnAutzAction for this path */\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\t// TODO: document that AuthzSendForbiddenOnFailure is required to return 403 FORBIDDEN\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\t/*\n\t\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t\t */\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\n\tif (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_DISCOVERY) != NULL)\n\t\treturn AUTHZ_GRANTED;\n\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\t/*\n\t\t * a hack for Apache 2.4 to prevent it from writing its own 401 HTML document\n\t\t * text by making ap_send_error_response in http_protocol.c return early...\n\t\t */\n\t\tr->header_only = 1;\n\t}\n\n\treturn AUTHZ_DENIED;\n}\n\n/*\n * generic Apache >=2.4 authorization hook for this module\n * handles both OpenID Connect or OAuth 2.0 in the same way, based on the claims stored in the session\n */\nauthz_status oidc_authz_checker(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args,\n\t\toidc_authz_match_claim_fn_type match_claim_fn) {\n\n\toidc_debug(r, \"enter: require_args=\\\"%s\\\"\", require_args);\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn AUTHZ_GRANTED;\n\t\tif (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_DISCOVERY) != NULL)\n\t\t\treturn AUTHZ_GRANTED;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(r, id_token, claims);\n\n\t/* dispatch to the >=2.4 specific authz routine */\n\tauthz_status rc = oidc_authz_worker24(r, claims ? claims : id_token,\n\t\t\trequire_args, parsed_require_args, match_claim_fn);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == AUTHZ_DENIED) && ap_auth_type(r))\n\t\trc = oidc_handle_unauthorized_user24(r);\n\n\treturn rc;\n}\n\nauthz_status oidc_authz_checker_claim(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args,\n\t\t\toidc_authz_match_claim);\n}\n\n#ifdef USE_LIBJQ\nauthz_status oidc_authz_checker_claims_expr(request_rec *r, const char *require_args, const void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args, oidc_authz_match_claims_expr);\n}\n#endif\n\n#else\n\n/*\n * find out which action we need to take when encountering an unauthorized request\n */\nstatic int oidc_handle_unauthorized_user22(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\", \"Different scope(s) or other claims required\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/* see if we've configured OIDCUnAutzAction for this path */\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\tcase OIDC_UNAUTZ_RETURN403:\n\t\treturn HTTP_FORBIDDEN;\n\tcase OIDC_UNAUTZ_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n}\n\n/*\n * generic Apache <2.4 authorization hook for this module\n * handles both OpenID Connect and OAuth 2.0 in the same way, based on the claims stored in the request context\n */\nint oidc_auth_checker(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn OK;\n\t\tif if (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_DISCOVERY) != NULL)\n\t\t\treturn OK;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* get the Require statements */\n\tconst apr_array_header_t * const reqs_arr = ap_requires(r);\n\n\t/* see if we have any */\n\tconst require_line * const reqs =\n\t\t\treqs_arr ? (require_line *) reqs_arr->elts : NULL;\n\tif (!reqs_arr) {\n\t\toidc_debug(r,\n\t\t\t\t\"no require statements found, so declining to perform authorization.\");\n\t\treturn DECLINED;\n\t}\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(r, id_token, claims);\n\n\t/* dispatch to the <2.4 specific authz routine */\n\tint rc = oidc_authz_worker22(r, claims ? claims : id_token, reqs,\n\t\t\treqs_arr->nelts);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == HTTP_UNAUTHORIZED) && ap_auth_type(r))\n\t\trc = oidc_handle_unauthorized_user22(r);\n\n\treturn rc;\n}\n\n#endif\n\napr_byte_t oidc_enabled(request_rec *r) {\n\tif (ap_auth_type(r) == NULL)\n\t\treturn FALSE;\n\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn TRUE;\n\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn TRUE;\n\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n/*\n * handle content generating requests\n */\nint oidc_content_handler(request_rec *r) {\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint rc = DECLINED;\n\t/* track if the session needs to be updated/saved into the cache */\n\tapr_byte_t needs_save = FALSE;\n\toidc_session_t *session = NULL;\n\n\tif (oidc_enabled(r) == TRUE) {\n\n\t\tif (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c)) == TRUE) {\n\n\t\t\tif (oidc_util_request_has_parameter(r,\n\t\t\t\t\tOIDC_REDIRECT_URI_REQUEST_INFO)) {\n\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\trc = oidc_handle_existing_session(r, c, session, &needs_save);\n\t\t\t\tif (rc == OK)\n\t\t\t\t\t/* handle request for session info */\n\t\t\t\t\trc = oidc_handle_info_request(r, c, session, needs_save);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\n\t\t\t} else if (oidc_util_request_has_parameter(r,\n\t\t\t\t\tOIDC_REDIRECT_URI_REQUEST_JWKS)) {\n\n\t\t\t\t/* handle JWKs request */\n\t\t\t\trc = oidc_handle_jwks(r, c);\n\n\t\t\t} else {\n\n\t\t\t\trc = OK;\n\n\t\t\t}\n\n\t\t} else if (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_DISCOVERY) != NULL) {\n\n\t\t\trc = oidc_discovery(r, c);\n\n\t\t} else if (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_AUTHN) != NULL) {\n\n\t\t\trc = OK;\n\n\t\t}\n\n\t}\n\n\treturn rc;\n}\n\nextern const command_rec oidc_config_cmds[];\n\nmodule AP_MODULE_DECLARE_DATA auth_openidc_module = {\n\t\tSTANDARD20_MODULE_STUFF,\n\t\toidc_create_dir_config,\n\t\toidc_merge_dir_config,\n\t\toidc_create_server_config,\n\t\toidc_merge_server_config,\n\t\toidc_config_cmds,\n\t\toidc_register_hooks\n};\n"], "fixing_code": ["The primary author of mod_auth_openidc is:\n\n\tHans Zandbelt <https://github.com/zandbelt>\n\nThanks to the following people for contributing to mod_auth_openidc by\nreporting bugs, providing fixes, suggesting useful features or other:\n\n\tD\u00e1niel S\u00dcTT\u0150 <https://github.com/suttod>\n\tRoland Hedberg <https://github.com/rohe>\n\tBill Simon <https://github.com/billsimon>\n\tJim Fox <https://github.com/jimfox>\n\tMartin Srom <https://github.com/martinsrom>\n\tDejan Latinovic <https://github.com/latinovic>\n\tHiroyuki Wada <https://github.com/wadahiro>\n\tGunnar Scherf <https://github.com/g10f>\n\tTerrence Fleury <https://github.com/terrencegf>\n\tJeremy Archer <https://github.com/fatlotus>\n\tForkbomber <https://github.com/forkbomber>\n\tKanthi Vaidya <https://github.com/ekanthi>\n\tszakharchenko <https://github.com/szakharchenko>\n\tJohn Bradley <https://bitbucket.org/ve7jtb>\n\tStefano Vercelli <https://github.com/steverc>\n\tDavid Bernick <https://github.com/davidbernick>\n\tJoseph Bester <https://github.com/bester>\n\tDaniel Pfile <https://github.com/pfiled>\n\tRebecka Gulliksson <https://github.com/rebeckag>\n\tRyan Kelly <https://github.com/rfk>\n\tJohn R. Dennis <https://github.com/jdennis>\n\tsteve-dave <https://github.com/steve-dave>\n\tglatzert <https://github.com/glatzert>\n\tAmit Joshi <amitsharadjoshi@gmail.com>\n\tAndy Curtis <https://github.com/asc1>\n\tsolsson\t<https://github.com/solsson>\n\tdrdivano <https://github.com/drdivano>\n\tAliceWonderMiscreations <https://github.com/AliceWonderMiscreations>\n\tWouter Hund <https://github.com/wouterhund>\n\tHans Keeler <https://github.com/hkeeler> \n\tMoritz Schlarb <https://github.com/moschlar>\n\tremi-cc <https://github.com/remi-cc>\n\thihellobolke <https://github.com/hihellobolke>\n\tHoratiu Eugen Vlad <https://github.com/iconoeugen>\n\tcristichiru <https://github.com/cristichiru>\n\tBono de Visser <https://github.com/kerrermanisNL>\n\tPatrick Uiterwijk <https://github.com/puiterwijk>\n\tMarcel Kottmann <https://github.com/pepe79>\n\ttimpuri <https://github.com/timpuri>\n\tEldar Zaitov <https://github.com/kyprizel>\n\tGergan Penkov <https://github.com/gergan>\n\tFlorian Weimer <https://github.com/fweimer>\n\tAaron Donovan <https://github.com/amdonov>\n\tHans Petter Bieker <https://github.com/hpbieker>\n\tarchzone <https://github.com/archzone>\n\tPetteri Stenius <https://github.com/psteniusubi>\n\tLance Fannin <lancekf08@gmail.com>\n\tRicardo Martin Camarero <https://github.com/rickyepoderi>\n\tFilip Vujicic <https://github.com/FilipVujicic>\n\tJanusz Ulanowski <https://github.com/janul>\n\tAimoto Norihito <https://github.com/oss-aimoto>\n\tAndy Lindeman <https://github.com/alindeman>\n\tStefan Wachter <https://github.com/swachter>\n\tPaolo Battino\n\tabsynth76 <https://github.com/absynth76>\n\tAaron Jones <https://github.com/wwaaron>\n\tBryan Ingram <https://github/bcingram>\n\tTim Deisser <https://github.com/deisser>\n\tPeter Hurtenbach <https://github.com/Peter0x48>\n\tPaul Spangler <https://github.com/spanglerco>\n\tChris Pawling <https://github.com/chris468>\n\tMatthias Flesch\u00fctz <https://github.com/blindzero>\n\tHarri Rautila <https://github.com/hrautila>\n\tTatsuhiko Yasumatsu <https://github.com/ty60>\n\tAdam Stadler <https://github.com/tzfx>\n\tSteffen Greber <https://github.com/codemaker219>\n\tIain Heggie <https://github.com/iainh>\n\tDirk Kok <https://github.com/Foxite>\n\tMeheni https://github.com/Meheni\n\n\n\n", "09/03/2021\n- don't apply authz in discovery process; fixes 2.4.9.3\n- apply OIDCRedirectURLsAllowed setting to target_link_uri; closes #672; thanks @Meheni\n- release 2.4.9.4\n\n08/26/2021\n- don't apply authz to the redirect URI; fixes ac5686495a51bc93e257e42bfdc9c9c46252feb1\n- bump to 2.4.9.3\n\n08/20/2021\n- fix graceful restart (regression); see #458; thanks @Foxite\n- bump to 2.4.9.2\n\n08/18/2021\n- preserve session cookie in the event of a cache backend failure\n- update the id_token in the session cache if one is provided while refreshing the access token\n\n08/13/2021\n- fix retried Redis commands after a reconnect; thanks @iainh\n- release 2.4.9.1\n\n07/22/2021\n- use redisvCommand to avoid crash with crafted key when using Redis without encryption; thanks @thomas-chauchefoin-sonarsource\n- replace potentially harmful backslashes with forward slashes when validating redirection URLs; thanks @thomas-chauchefoin-sonarsource\n- release 2.4.9\n- don't use DEFAULT_LIMIT_REQUEST_LINE constant; since it does not exist in Apache 2.2.x\n\n07/15/2021\n- verify that \"alg\" is not none in logout_token explicitly\n- make session not found on backchannel logout produce a log warning instead of error\n- don't clear POST params authn on token revocation; thanks @iainh\n- bump to 2.4.9rc0\n\n07/02/2021\n- handle discovery in the content handler\n- return OK in the content handler for calls to the redirect URI and when preserving POST data\n\n06/25/2021\n- avoid XSS vulnerability when using OIDCPreservePost On and supplying URLs that contain single quotes\n  thanks @oss-aimoto\n\n06/21/2021\n- strip A256GCM JWT header from encrypted JWTS used for state cookies, cache encryption and by-value session cookies\n  resulting in smaller cookies and reduced cache content size\n\n06/10/2021\n- use encrypted JWTs for storing encrypted cache contents and avoid using static AAD/IV; thanks @niebardzo\n- bump to 2.4.9-dev\n\n06/04/2021\n- fix a problem where the host and port are calculated incorrectly, when you use literal ipv6 address.\n\n06/02/2021\n- do not send state timeout HTML document when OIDCDefaultURL is set; this can be overridden by using e.g.:\n  SetEnvIfExpr true OIDC_NO_DEFAULT_URL_ON_STATE_TIMEOUT=true \n- release 2.4.8.4\n\n06/01/2021\n- avoid Apache 2.4 appending 400/302(200/404) HTML document text to state timeout HTML info page\n  see also f5959d767b0eec4856d561cbaa6d2262a52da551 and #484; at least Debian Buster was affected\n- release 2.4.8.3\n\n05/18/2021\n- make error \"session corrupted: no issuer found in session\" a warning only so a logout call for a\n  non-existing session no longer produces error messages\n\n05/08/2021\n- store timestamps in session in seconds to avoid string conversion problems on some (libapr-1)\n  platform build/run combinations, causing \"maximum session duration exceeded\" errors\n- bump to 2.4.8.2\n\n05/07/2021\n- add OIDCClientTokenEndpointKeyPassword option to allow the use of an encrypted private key\n- release 2.4.8.1\n\n04/30/2021\n- fix potential crash when Content-Type is not set in POST requests; thanks Tatsuhiko Yasumatsu of JPCERT/CC\n- release 2.4.8\n\n04/21/2021\n- on OAuth 2.0 RS token scope/claim 401 error, add environment variable for usage with mod_headers,\n  instead of adding a header ourselves; see #572; usage, e.g;\n    Header always append WWW-Authenticate %{OIDC_OAUTH_BEARER_SCOPE_ERROR}e \"expr=(%{REQUEST_STATUS} == 401) && (-n reqenv('OIDC_OAUTH_BEARER_SCOPE_ERROR'))\"\n- bump to 2.4.8-dev\n\n04/13/2021\n- add OIDCRedisCacheConnectTimeout and OIDCRedisCacheTimeout options to configure Redis timeouts\n- bump to 2.4.7.2\n\n04/12/2021\n- fix memory leaks when caching fails\n- bump to 2.4.7.1\n\n04/04/2021\n- improve documentation on OIDCPreservePost\n- release 2.4.7\n\n04/01/2021\n- bump to 2.4.7rc1\n\n02/16/2021\n- remove session from cache before clearing it.\n\n02/12/2021\n- add maximum session lifetime (exp), inactivity timeout (timeout) and remote_user to OIDCInfoHook\n- bump to 2.4.7-dev\n\n02/08/2021\n- return 400 instead of 500 when state cookie matching fails\n- release 2.4.6\n\n02/03/2021\n- avoid displaying the client_secret in debug logs\n\n01/28/2021\n- avoid segmentation fault when hitting an endpoint configured with AuthType openid-connect\n  in an OAuth 2.0 only setup; see #529\n\n01/23/2021\n- fix semaphore cleanup on graceful restarts; see #522\n\n01/12/2021\n- fix inconsistent public/private keys loading order; closes #515\n\n12/17/2020\n- remove support for https://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state\n\n12/10/2020\n- add \"base64url\" option to OIDCPassClaimsAs primitive; closes #417\n\n12/09/2020\n- add Redis database selection option with OIDCRedisCacheDatabase; closes #423\n- optimize Redis AUTH execution once per connection\n\n12/07/2020\n- don't set SameSite=None on cookies when on plain http\n\n12/03/2020\n- add environment variable to control libcURL CURLOPT_SSL_OPTIONS behaviors\n  e.g.: SetEnvIfExpr true CURLOPT_SSL_OPTIONS=CURLSSLOPT_NO_REVOKE\n\n11/23/2020\n- release 2.4.5\n- make sure the module compiles with Apache 2.2 for passphrase exec:\n- bump to 2.4.6-dev\n\n11/19/2020\n- ensure that \"sub\" is returned from the userinfo endpoint following https://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse\n  prevents potential ID spoofing; thanks Christian Fries of Ruhr-University Bochum\n- don't printout JSON errors about NULL characters in error log; thanks Christian Fries of Ruhr-University Bochum\n- restrict printout of JSON parsing errors to 4096 bytes; thanks Christian Fries of Ruhr-University Bochum\n- bump to 2.4.5rc6\n\n11/5/2020\n- fix content processing for info and JWKs handler so mod_headers etc. works; closes #497\n- bump to 2.4.5rc5\n\n11/2/2020\n- improve sanity checking on Redis reply\n- bump to 2.4.5rc4\n\n10/30/2020\n- disable caching token introspection results by setting OIDCOAuthTokenIntrospectionInterval to -1; thanks @wadahiro\n- bump to 2.4.5rc3\n\n10/27/2020\n- config check on OIDCCryptoPassphrase in OAuth 2.0 RS setup with cache encryption enabled\n- bump to 2.4.5rc2\n\n10/22/2020\n- hash define expression option to OIDCUnAuthAction so it compiles for Apache 2.2; fixes 1461634\n- bump to 2.4.5rc1\n- add exec support to OIDCCryptoPassphrase\n \n10/19/2020\n- delete stale session cookies that aren't in the cache\n- allow OIDCDiscoverURL to be a relative URL\n\n10/08/2020\n- add OIDCCABundlePath for configuring path to curl CA bundle\n\n09/22/2020\n- avoid Apache 2.4 appending 401 HTML document text to step-up authentication HTML refresh page; closes #484\n- bump to 2.4.5rc0\n\n09/21/2020\n- populate AUTH_TYPE when performing authentication; thanks @spanglerco\n\n09/19/2020\n- enable authentication of sub-requests when the main request doesn't require\n  authentication; thanks @spanglerco\n\n09/03/2020\n- add SameSite attribute on cookie clearance / logout; thanks @v0gler\n- bump to 2.4.4.1\n\n09/01/2020\n- forward port Tufin patches\n- always set session cookie same site policy to Lax\n- disable cookie domain check\n- unset host headers for metadata URL retrieval\n- bump to 2.4.4-tufin\n\n09/01/2020\n- avoid GCC 9 compiler warnings\n- release 2.4.4\n\n08/28/2020\n- allow Content-Type check on backchannel logout to have postfixes (utf-8 etc)\n- terminate backchannel logout with DONE instead of OK to avoid authz error 500\n- bump to 2.4.4rc8\n\n08/18/2020\n- add recommended cache headers on backchannel logout response\n  https://openid.net/specs/openid-connect-backchannel-1_0.html#rfc.section.2.8\n- bump to 2.4.4rc7\n\n08/10/2020\n- add new OIDCStateCookiePrefix primitive for the state cookie prefix\n\n08/01/2020\n- add conditional expression to OIDCUnAuthAction; see #479; thanks @raro42 and @marcstern\n- bump to 2.4.4rc6\n\n07/31/2020\n- reverse order of creating HTML response and adding session cookie; thanks @deisser\n- bump to 2.4.4rc5\n\n07/30/2020\n- fix doubled Set-Cookie behaviour when using `client-cookie`, calling the session info hook\n  and writing out a session update (twice); thanks @deisser\n- bump to 2.4.4rc4\n\n07/27/2020\n- prevent XSS and open redirect on OIDC session managemement OP iframe with OIDCRedirectURLsAllowed\n  thanks Andrew Brady\n- bump to 2.4.4rc3\n\n07/22/2020\n- delete state cookie when it cannot be decoded/decrypted\n- bump to 2.4.4rc2\n\n07/03/2020\n- fix for loop initial declarations to not require c99 for compilation (RHEL 6)\n- add ap_expr.h include in stub.c (RHEL 6)\n- bump to 2.4.4rc1\n\n06/30/2020\n- add grant_types to dynamic client registration request\n- don't send access_token in user info request when method is set to POST; conform OIDC test suite 4.0.5\n- bump to 2.4.4rc0\n\n06/10/2020\n- prevent open redirect on refresh token requests\n  add new OIDCRedirectURLsAllowed primitive to handle post logout and refresh-return-to validation\n  addresses #453; closes #466\n- release 2.4.3\n\n06/09/2020\n- fix complex expressions crash when compiled from source with libjq; closes #472\n  thanks vincentscharf0803\n  introduced by OIDCStateInputHeaders addition in 2.4.3rc0\n- bump to 2.4.3rc1\n\n05/11/2020\n- added OIDCValidateIssuer to allow for disabling of issuer matching.  helps to support multi-tenant applications.\n\n05/02/2020\n- when stripping cookies, add a space between cookies in the resulting header (required by RFC 6265)\n- move oidc_parse_config inside MODULE_MAGIC_NUMBER_MAJOR to make sure the module compiles with Apache 2.0\n\n04/25/2020\n- add OIDCStateInputHeaders that allows configuring the header values used to calculate the fingerprint of the state during authentication\n- bump to 2.4.3rc0\n\n03/25/2020\n- oops: fix json_deep_copy of claims\n- release 2.4.2.1\n\n03/24/2020\n- fix memory leak in OAuth 2.0 JWT validation; closes #470; thanks Conrad Thukral\n- fix configured private/public key cleanup on process exit\n\n03/21/2020\n- allow for expressions in Require statements, see #469; thanks @wwaaron\n  also see: https://github.com/zmartzone/mod_auth_openidc/wiki/Authorization#expressions-in-require-statements\n- bump to 2.4.2rc5\n\n03/19/2020\n- always refresh keys from jwks_uri when there is no kid in the JWT header\n- bump to 2.4.2rc4\n\n03/15/2020\n- destroy shared memory segments only in parent process; see #458\n- bump to 2.4.2rc3\n\n03/10/2020\n- fix memory leaks introduced by #457\n- bump to 2.4.2rc2\n\n02/19/2020\n- if content was already returned via html/http send then don't return 500\n  but send 200 to avoid extraneous internal error document text to be sent\n  on some Apache 2.4.x versions e.g. CentOS 7\n- bump to 2.4.2rc1\n\n02/03/2020\n- if OIDCPublicKeyFiles contains a certificate, the corresponding x5c, x5t and x5t#256 \n  parameters will be added to the generated jwkset available at \"<redirect_uri>?jwks=rsa\"\n  thanks @absynth76\n- fix: also add SameSite=None to by-value session cookies\n- bump to 2.4.2rc0\n\n01/30/2020\n- try to fix graceful restart crash; see #458\n- release 2.4.1\n\n01/29/2020\n- always add a SameSite value to the Set-Cookie header to satisfy upcoming Chrome/Firefox changes\n  this can be overridden by using, e.g.:\n    SetEnvIf User-Agent \".*IOS.*\" OIDC_SET_COOKIE_APPEND=;\n- release 2.4.1rc6\n\n01/22/2020\n- URL encode logout url in session management JS; thanks Paolo Battino\n- bump to 2.4.1rc5\n\n01/15/2020\n- add value of OIDC_SET_COOKIE_APPEND env var to Set-Cookie headers\n  useful for handling changing/upcoming SameSite behaviors across different browsers, e.g.:\n    SetEnvIf User-Agent \".*IOS.*\" OIDC_SET_COOKIE_APPEND=SameSite=None\n- bump to 2.4.1rc4\n\n01/08/2020\n- support 407 option on OIDCUnAuthAction\n\n12/09/2019\n- fix parsing of values from metadata files when the default is non-NULL (e.g. UNSET)\n- enforce OIDCIDTokenSignedResponseAlg and OIDCUserInfoSignedResponseAlg; see #435\n- bump to 2.4.1rc2\n- support login with OIDC session management; address #456\n- bump to 2.4.1rc3\n\n12/05/2019\n- add the possibility to use a public key instead of a certificate for OIDCPublicKeyFiles parameter\n- added an alpine dockerfile =~ 20MB container size\n\n12/04/2019\n- return 200 OK for backchannel logout if session not found\n- bump to 2.4.1rc1\n\n11/19/2019\n- make cleaning of expired state cookies log with a warning rather than an error; thanks Pavel Drobov\n- bump to 2.4.1rc0\n\n10/03/2019\n- improve validation of the post-logout URL parameter on logout; thanks AIMOTO Norihito; closes #449\n- release 2.4.0.3\n- clear any existing chunked cookies when setting a non-chunked cookie; prevents login loops in some scenarios\n\n08/28/2019\n- fixes #447 #441 : changed storing POST params from localStorage to\n  sessionStorage due to some issue of losing data in localStorage in Firefox\n  (private mode) \n\n08/22/2019\n- release 2.4.0\n\n08/16/2019\n- revert 3d95b4a3fbc493c6acc745626ac33143eb4968bf: don't return early from the content handler\n\n08/15/2019\n- be smart about picking the token endpoint authentication method when not configured explicitly:\n  don't choose the first one published by the OP but prefer client_secret_basic if that is listed as well\n  see: panva/node-oidc-provider#514; thanks @richard-drummond and @panva\n- bump to 2.4.0rc24\n\n08/12/2019\n- fix not clearing claims in session when setting claims to null; closes #445; thanks @FilipVujicic\n\n08/12/2019\n- fix JWT decryption crashing on non-null terminated input\n- bump to 2.4.0rc23\n\n08/09/2019\n- add logout_on_error option to OIDCRefreshAccessTokenBeforeExpiry to kill the session when\n  refreshing an access token fails; thanks @rickyepoderi\n- bump to 2.4.0rc22\n\n08/08/2019\n- no longer use the fixup handler for environment variable setting but do it as part of the authn handler\n- bump to 2.4.0rc21\n\n08/04/2019\n- avoid decoding non-form-encoded POST data; closes #443\n- bump to 2.4.0rc20\n\n08/02/2019\n- return DONE from the content handler early to prevent triggering other content handlers\n- fix `OIDCOAuthAcceptTokenAs post` so POST data is propagated and not lost; see #443\n- bump to 2.4.0rc19\n\n07/10/2019\n- fix RSA JWK \"x5c\" parsing issue (e.g. when parsing \"n\" fails): explicitly set the \"kid\" into to JWK\n- bump to 2.4.0rc18\n\n06/19/2019\n- fix regression bug that includes a HTTP 500 message after rendering content\n- bump to 2.4.0rc17\n\n06/14/2019\n- fix regression bug when no per-provider keys have been configured and private_key_jwt is used\n- bump to 2.4.0rc15\n\n06/06/2019\n- use per-provider signing keys in private_key_jwt authentication towards token endpoint\n- bump to 2.4.0rc14\n\n06/05/2019\n- avoid passing empty key set for JWT decryption (solve but introduced in 2.4.0rc12)\n- bump to 2.4.0rc13\n\n06/03/2019\n- enable per-provider signing and encryption keys; limitations:\n  - for request object signing and id_token decryption only\n  - take the first configured key, no kid specification\n  - no publishing of key information on client endpoints\n  - no userinfo JWT decryption\n  - no composite claims decryption\n  - no backchannel logout with encrypted logout token (inherent)\n- bump to 2.4.0rc12\n\n05/31/2019\n- make sure the content handler is called for every request to the configured Redirect URI so all\n  Apache processing is executed (e.g. setting headers with mod_headers) before returning the response\n  thanks Don Sengpiehl (NB: this may affect browser behavior and backwards compatibility)\n- add ability to view session info in HTML via the session info hook: <redirect_uri)?info=html\n- bump to 2.4.0rc11\n\n05/24/2019\n- fix oidc_proto_html_post auto-post-submit so it no longer results in duplicate parentheses\n  closes #440; thanks @gobreak\n- bump to 2.4.0rc10\n\n05/21/2019\n- log the original URL for expired state cookies, useful for debugging SPA/JS issues\n\n05/17/2019\n- allow removing an access token from the cache (\"remove_at_cache\") when running in OAuth 2.0 RS mode only\n- support refresh and access tokens revocation from an RFC 7009 endpoint upon OIDC session logout\n- bump to 2.4.0rc9\n\n05/03/2019\n- fix (cached) parsing of OIDCOAuthServerMetadataURL; thanks Lance Fannin\n- bump to 2.4.0rc5\n\n05/02/2019\n- correct caching for OIDCOAuthServerMetadataURL\n- bump to 2.4.0rc4\n\n04/21/2019\n- remove option to skip scrubbing request headers (thus avoiding potentionally insecure setups)\n- bump to 2.4.0rc3\n\n04/19/2019\n- add USE_URANDOM compile time option to use /dev/urandom explicitly for non-blocking random number generation\n  configure with APXS2_OPTS=\"-DUSE_URANDOM\"\n- bump to 2.4.0rc2\n\n04/15/2019\n- add debug logs in oidc_proto_generate_random_string\n- URL-encode client_id/client_secret when using client_secret_basic according to: https://tools.ietf.org/html/rfc6749#section-2.3.1\n- bump to 2.4.0rc1\n\n04/09/2019\n- deprecate the OAuth 2.0 Resource Server functionality\n- bump to 2.4.0rc0\n\n03/13/2019\n- release 2.3.11\n\n02/26/2019\n- add session expiry to session info hook response (and change inactivity timeout key)\n- bump to 2.3.11rc2\n\n02/25/2019\n- add option to dynamically pass query parameters to the authorization request; closes #401\n- bump to 2.3.11rc1\n\n01/31/2019\n- support conditional compilation of memcache support\n- bump to 2.3.11rc0\n\n01/22/2019\n- fix XSS vulnerability CSNC-2019-001 wrt. poll parameter in OIDC Session Management RP iframe; thanks Mischa Bachmann\n- release 2.3.10.2\n\n01/16/2019\n- fix bug in current URL detection where query parameters would be duplicated; see #420; thanks @jreynaert\n- release 2.3.10.1\n\n12/31/2018\n- fix warning printout in oidc_delete_oldest_state_cookies\n- release 2.3.10\n\n12/16/2018\n- fix encryption buffer tag length mismatch\n\n12/06/2018\n- retain the unparsed URL path in current/original URL determination, and thereby preserve\n  and support URL-encoded characters in paths when redirecting back to the original URL\n- add state to code exchange token requests only in multi-provider setups; see #402\n- optionally delete the oldest state cookie(s); see #399\n- bump to 2.3.10rc3\n\n11/29/2018\n- add support for refreshing an access token associated with an OIDC session using OIDCRefreshAccessTokenBeforeExpiry\n- bump to 2.3.10rc0\n\n11/15/2018\n- release 2.3.9\n\n11/13/2018\n- fix parsing of cookie name in OIDCOAuthAcceptTokenAs when the cookie option is not listed last \n- bump to 2.3.9rc7\n\n11/12/2018\n- fix OAuth 2.0 RS config check when OIDCOAuthServerMetadataURL is set; thanks @psteniusubi\n- bump to 2.3.9rc6\n\n10/24/2018\n- add support for draft https://www.ietf.org/id/draft-ietf-oauth-mtls-12.txt:\n  OAuth 2.0 Mutual TLS Client Certificate Bound Access Tokens\n  when running as an OAuth 2.0 RS, validating cnf[\"x5t#S256\"] claims.\n- bump to 2.3.9rc5\n\n10/17/2018\n- ignore/trim spaces in X-Forwarded-* headers\n- deal with forwarding proxy setups; see #395 ; thanks @archzone\n- bump to 2.3.9rc4\n\n10/02/2018\n- improve OIDC backchannel logout based on config/Discover\n  - add OIDCProviderBackChannelLogoutSupported config primitive\n  - parse/interpret `backchannel_logout_supported` in Discovery document\n- add `id_token_token_binding_cnf`: `tbh` to dynamic client registration metadata\n- bump to 2.3.9rc3\n\n10/01/2018\n- support backchannel logout according to: https://openid.net/specs/openid-connect-backchannel-1_0.html\n- bump to 2.3.9rc2\n\n10/01/2018\n- add test-cmd command to generate hashes base64urlencoded inputs (cnf/tbh claims)\n\n09/30/2018\n- support Token Binding for Access Tokens according to: https://tools.ietf.org/html/draft-ietf-oauth-token-binding\n- bump to 2.3.9rc1\n\n09/16/2018\n- support nested arrays in Require claim authorization evaluation; see #392; thanks @hpbieker\n- bump to 2.3.9rc0\n\n09/12/2018\n- fix return result FALSE when JWT payload parsing fails; see #389; thanks @amdonov\n- release 2.3.8\n\n08/30/2018\n- add LGTM code quality badges, see #385; thanks @xcorail\n- fix 3 LGTM alerts\n\n08/23/2018\n- improve auto-detection of XMLHttpRequests via Accept header; see #331\n- bump to 2.3.8rc5\n\n08/15/2018\n- initialize test_proto_authorization_request properly; see #382; thanks @jdennis\n- add sanity check on provider->auth_request_method; closes #382; thanks @jdennis\n- bump to 2.3.8rc4\n\n08/14/2018\n- allow usage with LibreSSL; closes #380; thanks @hihellobolke\n- bump to 2.3.8rc3\n\n08/04/2018\n- don't return content with 503 since it will turn the HTTP status code into a 200; see #331\n- bump to 2.3.8rc2\n\n08/03/2018\n- add option to set an upper limit to the number of concurrent state cookies via OIDCStateMaxNumberOfCookies; see #331\n- make the default maximum number of parallel state cookies 7 instead of unlimited; see #331\n- bump to 2.3.8rc1\n\n07/30/2018\n- fix using access token as endpoint auth method in introspection calls; closes #377; thanks @skauffmann\n\n07/25/2018\n- fix reading access_token form POST parameters when combined with `AuthType auth-openidc`; see #376; thanks Nicolas Salerno\n- bump to 2.3.8rc0\n\n07/06/2018\n- abort when string length for remote user name substitution is larger than 255 characters\n- release 2.3.7\n\n07/04/2018\n- fix Redis concurrency issue when used with multiple vhosts\n- bump to 2.3.7rc4 and 2.3.7rc5\n\n06/29/2018\n- add support for authorization server metadata with OIDCOAuthServerMetadataURL as in RFC 8414\n- bump to 2.3.7rc3\n\n06/23/2018\n- refactor session object creation\n- bump to 2.3.7rc2\n\n06/22/2018\n- clear session cookie and contents if cache corruption is detected\n- bump to 2.3.7rc0\n- use apr_pstrdup when setting r->user\n- reserve 255 characters in remote username substition instead of 50\n- bump to 2.3.7rc1\n\n06/15/2018\n- add check to detect session cache corruption for server-based caches and cached static metadata\n- release 2.3.6\n\n05/29/2018\n- avoid using pipelining for Redis\n- bump to 2.3.6rc4\n\n05/28/2018\n- send Basic header in OAuth www-authenticate response if that's the only accepted method; thanks @puiterwijk\n\n05/28/2018\n- refactor Redis cache backend to solve issues on AUTH errors: a) memory leak and b) redisGetReply lagging behind\n- adjust copyright year/org\n- bump to 2.3.6rc3\n\n05/23/2018\n- fix buffer overflow in shm cache key set strcpy; thanks @kyprizel\n- bump to 2.3.6rc2\n\n05/22/2018\n- turn missing session_state from warning into a debug statement\n- fix missing \"return\" on error return from the OP; see #345; thanks @gergan\n- bump to 2.3.6rc1\n\n05/19/2018\n- explicitly set encryption kid so we're compatible with cjose >= 0.6.0\n- bump to 2.3.6rc0\n\n05/18/2018\n- fix encoding of preserved POST data; see #338; thanks @timpuri\n- avoid buffer overflow in shm cache key construction; thanks @kyprizel\n- release 2.3.5\n\n05/08/2018\n- compile with with Libressl; closes #358; thanks @hihellobolke\n- bump to 2.3.5rc0\n\n04/27/2018\n- avoid crash when a relative logout URL parameter is passed in; thanks Vivien Delenne \n- release 2.3.4\n\n03/22/2018\n- interpret X-Forwarded-Host when doing XSRF protection on the after-logout URL; see #341; thanks @pepe79\n- bump to 2.3.4rc4\n\n02/06/2018\n- add support for passing an access token in a HTTP Basic authentication password; thanks @puiterwijk\n- bump to 2.3.4rc3\n\n01/26/2018\n- send session management Javascript logging to debug; thanks @kerrermanisNL\n\n01/25/2018\n- add Cache-Control no-cache header to authorization requests to avoid replays of state/nonce; see #321\n- bump to 2.3.4rc2\n\n01/23/2018\n- add explicit endpoint authentication method \"bearer_access_token\"\n\n12/29/2017\n- correct documentation on kid usage for OIDCOAuthVerifyCertFiles; closes #318\n\n12/21/2017\n- fix compiler warnings for OpenSSL 1.1.x\n- bump to 2.3.4rc1\n\n11/21/2017\n- fix bug where endpoint authentication method \"private_key_jwt\" would not co-exist with \"none\"\n- bump to 2.3.4rc0\n\n11/16/2017\n- add support for passing userinfo as a JSON object or JWT; see #311\n- release 2.3.3\n\n11/13/2017\n- add support for authentication to the introspection endpoint with a bearer token using OIDCOAuthIntrospectionClientAuthBearerToken; thanks @cristichiru\n- bump to 2.3.3rc3\n\n11/08/2017\n- address a number of static code analysis issues\n- bump to 2.3.3rc2\n\n10/10/2017\n- avoid crash when no scheme is set on OIDCProviderMetadataURL; closes #303; thanks @iconoeugen\n- bump to 2.3.3rc1\n\n10/6/2017\n- avoid crash when no OIDCOAuthClientID is set for remote access token validation\n- don't enforce \"iat\" slack checks on locally validaed JWT access tokens\n- bump to 2.3.3rc0\n\n09/18/2017\n- release 2.3.2\n\n09/11/2017\n- fix \"graceful\" restart for shm/redis cache backends; see #296\n- bump to 2.3.2rc8\n\n09/05/2017\n- optionally remove request object parameters from the authorization request URL with \"copy_and_remove_from_request\"; see #294\n- bump to 2.3.2rc7\n\n08/29/2017\n- properly support JSON boolean values in metadata .conf files\n- add regex substitution for *RemoteUserClaim; thanks @hihellobolke\n- bump to 2.3.2rc6\n\n08/27/2017\n- add issuer specific redirect URI option (\"issuer_specific_redirect_uri\") for multi-provider setups to mitigate IDP mixup\n- bump to 2.3.2rc5\n\n08/20/2017\n- fix public clients; add endpoint authentication method \"none\"\n- bump to 2.3.2rc4\n\n08/02/2017\n- update experimental token binding support to https://tools.ietf.org/html/draft-ietf-tokbind-ttrp-01\n  and use header names prefixed with \"Sec-\"; depends on mod_token_binding >= 0.3.4 now\n- bump to 2.3.2rc3\n\n08/01/2017\n- don't abort when mutex operations fail\n- printout textual descriptions of errors returned by mutex operations\n- bump to 2.3.2rc2\n\n07/28/2017\n- fix issue with the combination of shared memory (shm) cache and using encryption (OIDCCacheEncrypt On)\n  where the cache value would be corrupted after the first (successful) retrieval\n- bump to 2.3.2rc1\n\n07/27/2017\n- support paths that are relative to the Apache root dir for:\n  OIDCHTMLErrorTemplate, OIDCPublicKeyFiles, OIDCPrivateKeyFiles,\n  OIDCOAuthVerifyCertFiles, OIDCClientTokenEndpointCert, OIDCClientTokenEndpointKey,\n  OIDCOAuthIntrospectionEndpointCert and OIDCOAuthIntrospectionEndpointKey\n- bump to 2.3.2rc0\n\n07/19/2017\n- handle multiple values in X-Forwarded-* headers as to better support chains of reverse proxies in front of mod_auth_openidc\n- log request headers in oidc_util_hdr_in_get\n- release 2.3.1\n\n07/13/2017\n- remove A128GCM/A192GCM from the supported algorithms in docs/auth_openidc.conf\n  because cjose doesn't support A128GCM and A192GCM (yet)\n- bump to 2.3.1rc5\n\n07/09/2017\n- refactor oidc_get_current_url_port so that it assumes the default port when\n  X-Forwarded-Proto has been set; closes #282 and may address #278\n- bump to 2.3.1rc4\n\n07/07/2017\n- use the defined name (`Provided-Token-Binding-ID`) for the provided token binding ID HTTP header\n  see: https://tools.ietf.org/html/draft-campbell-tokbind-ttrp-00#section-2.1\n  depends on mod_token_binding >= 0.3.0 now\n- bump to 2.3.1rc3\n\n06/29/2017\n- support sending the authentication request via HTTP POST through HTML/Javascript autosubmit\n- bump to 2.3.1rc2\n\n06/28/2017\n- support private_key_jwt and client_secret_jwt as client authentication methods for token introspection\n- bump to 2.3.1rc1\n\n06/22/2017\n- fix bug where token_endpoint_auth set to private_key_jwt would fail to provide the credential if client_secret wasn't set\n- bump to 2.3.1rc0\n\n06/13/2017\n- release 2.3.0\n\n06/07/2017\n- fix file cache backend: allow caching of non-filename friendly keys such as configuration URLs and JWKs URIs\n- enable JQ-based claims expression matching when compiled from source with --with-jq=<dir>, e.g.:\n  Require claims_expr '.aud == \"ac_oic_client\" and (.scope | index(\"profile\") != null)'\n- normalize cache backend logging\n- bump to 2.3.0rc3\n\n06/06/2017\n- avoid cleaning our own state cookie twice when it is expired\n- bump to 2.3.0rc2\n\n06/02/2017\n- refactor remote user handling so it allows for postfixing with the issuer value after applying the regex\n- bump to 2.3.0rc1\n\n05/31/2017\n- add support for custom actions to take after authorization fails with OIDCUnAutzAction\n  this enables stepup authentication scenarios when combined with the following:\n- add OIDCPathAuthRequestParams that is configurable on a per-path basis and use OIDCAuthRequestParams for the static per-provider value\n- add OIDCPathScope that is configurable on a per-path basis and concatenate with OIDCScope as static per-provider value\n- support 3rd-party-init-SSO with additional authentication request params when a single static provider has been configured\n- add support for an empty OIDCClaimPrefix; can be used with OIDCWhiteListedClaims to protect selected headers\n- bump to 2.3.0rc0\n\n05/30/2017\n- support sending Authorization Request as \"request\" object in addition to \"request_uri\"; thanks @suttod\n- support nested claim matching in Require directives; thanks @suttod\n- support explicitly setting the \"kid\" of the private key in OIDCPrivateKeyFiles; thanks @suttod\n\n05/25/2017\n- fix cache fallback so it happens (when enabled) only after failure\n\n05/19/2017\n- make OIDCStripCookies work on AuthType oauth20 paths; closes #273; thanks Michele Danieli\n- bump to 2.2.1rc6\n\n05/18/2017\n- fix parse function of OIDCRequestObject configuration option; thanks @suttod \n\n05/17/2017\n- avoid crash when the X-Forwarded-Proto header is not correctly set by a reverse proxy in front of mod_auth_openidc\n\n05/14/2017\n- support JWT verification against multiple keys with no provided kid by looping over the provided keys with cjose 0.5.0\n- remove OIDC RP certification files; moved to separate repository\n\n05/04/2017\n- improve documentation for OIDCCryptoPassphrase; closes #268\n\n04/30/2017\n- fix wrong return value for cache_file_set in the file cache backend (OIDCCacheType file); thanks Ernani Joppert Pontes Martins\n- bump to 2.2.1rc5\n\n04/29/2017\n- correctly log success/failure in cache_file_set\n- avoid decoding a JSON object and logging an error when the input is NULL\n  e.g. when claims have not been resolved because userinfo endpoint is not set\n\n04/20/2017\n- support relative RedirectURIs; closes #200; thanks @moschlar\n- don't assume that having OIDCCryptPassphrase set means we should validate the config for\n  openid-connect since it can now also be used to encrypt (auth20) cache entries\n- bump to 2.2.1rc4\n\n04/08/2017\n- fix potential crash on prefork process exit when used with Redis cache backend (3x)\n- bump to 2.2.1rc3\n\n04/06/2017\n- change warn log about missing token binding ID to debug log\n\n04/05/2017\n- allow for high session inactivity timeout max value\n- improve error message in oidc_util_http_send when ap_pass_brigade fails and mention possible interference with mod_deflate\n- bump to 2.2.1rc0\n\n03/30/2017\n- merge feature branch back to master:\n  - better support for Single Page Applications, see:\n    https://github.com/zmartzone/mod_auth_openidc/wiki/Single-Page-Applications\n    - add session info hook that is configurable through OIDCInfoHook\n    - add \"AuthType auth-openidc\" option that allows both \"oauth20\" and \"openid-connect\" on the same path\n  - add encryption for all cache entries instead of just session data through OIDCCacheEncrypt\n  - add cookie SameSite flag/policy through OIDCCookieSameSite\n  - return HTTP 200 on OPTIONS requests to (unauthenticated) \"oauth20\" paths\n  - add fallback to a by-value session cookie if the primary session cache fails with OIDCSessionCacheFallbackToCookie\n  - add support for black- and/or white-listing claims with OIDCBlackListedClaims and OIDCWhiteListedClaims\n  - add prototype token binding support in conjunction with:\n    https://github.com/zmartzone/mod_token_binding:\n    - for state & session cookies, see:\n      https://github.com/TokenBinding/Internet-Drafts\n    - for ID tokens with OpenID Connect Token Bound Authentication support, see:\n      http://openid.net/specs/openid-connect-token-bound-authentication-1_0.html\n    - for Authorization Codes with OAuth 2.0 Token Binding for Authorization Codes, see:\n       https://tools.ietf.org/html/draft-ietf-oauth-token-binding\n  - refactoring:\n    - refactor session state, proto state and headers into getters/setters functions\n    - refactor PKCE support\n  - fix removing session state from cache on logout\n  - fix clearing chunked session cookies on logout; closes #246; thanks @Jharmuth\n- release 2.2.0\n\n02/20/2017\n- security fix: scrub headers for \"AuthType oauth20\"\n- release 2.1.6 \n\n02/15/2017\n- improve logging of session max duration and session inactivity timeout\n- refactor so that the call to the refresh hook also resets the session inactivity timeout and passes tokens down\n\n02/14/2017\n- treat only \"X-Requested-With: XMLHttpRequest\" header as a non-browser client; closes #228 ; thanks @mguillem\n- improve error message on state timeout; closes #226; thanks @security4java\n\n02/09/2017\n- correctly parse \"kid\" in OIDCPublicKeyFiles and OIDCOAuthVerifyCertFiles; thanks Alessandro Papacci\n- bump to 2.1.6rc2\n\n02/07/2017\n- fix parsing of mandatory/optional attribute in OIDCOAuthTokenExpiryClaim; closes #225; thanks Alessandro Papacci\n- bump to 2.1.6rc1\n\n02/06/2017\n- improve logging around the availability of session management; closes #223\n\n02/02/2017\n- interpret OIDCUnAuthAction also when the maximum session duration has been exceeded; see #220\n- bump to 2.1.6rc0\n\n01/30/2017\n- security fix: scrub headers when `OIDCUnAuthAction pass` is used for an unauthenticated user\n- release 2.1.5\n\n01/29/2017\n- fix error message about passing id_token with session type client-cookie; mentioned in #220\n- bump to 2.1.5rc0\n\n01/25/2017\n- release 2.1.4\n\n01/18/2017\n- don't echo the query parameters on the error page when an invalid request is made to the Redirect URI; closes #212; thanks @LukasReschke\n\n01/14/2017\n- use dynamic memory buffer for writing HTTP call responses; solves curl/mpm-event interference; see #207\n- bump to 2.1.4rc1\n\n01/10/2017\n- don't crash when data is POST-ed to the redirect URL, it has just 1 POST parameter and it is not \"response_mode\"\n\n01/2/2017\n- remove trailing linebreaks from input in test-cmd tool\n- bump copyright year to 2017\n\n12/14/2016\n- support Libre SSL, see #205, thanks @AliceWonderMiscreations\n- update OIDC logout support to Front-Channel Logout 1.0 draft 01: http://openid.net/specs/openid-connect-frontchannel-1_0.html\n- bump to 2.1.4rc0\n\n12/13/2016\n- release 2.1.3\n\n12/12/2016\n- don't rollover session id's and keep the same session cookie name for cache storage over session updates\n- bump to 2.1.3rc0\n\n11/19/2016\n- release 2.1.2\n\n11/18/2016\n- fix crash when searching for keys with a kid, there's no initial match and x5t values exist for the non-matching keys; closes #196\n\n11/9/2016\n- remove stale claims from session when refreshing them from the userinfo endpoint fails; addresses #194\n- release 2.1.1\n\n11/8/2016\n- log readable error messages when memcache operations fail\n\n11/6/2016\n- fix memory leak when skipping jwks_uri keys with a non-matching \"use\" value\n\n11/4/2016\n- always restore id_token/claims on sub-requests so e.g. listing claims-protected subdirectories will work\n- remove obsolete functions for storing the session in the request state\n- bump to 2.1.1rc0\n\n11/3/2016\n- remove obsolete sessions from session cache; thanks @stevedave\n\n11/1/2016\n- release version 2.1.0\n\n10/28/2016\n- don't include encryption keys from the jwks_uri when verifying a JWT and no kid has been specified\n- fix memory leaks in composite claim handling\n\n10/27/2016\n- handle aggregated and distributed claims from the userinfo endpoint\n- only pick private_key_jwt token endpoint authentication if a private key is configured; closes #189\n- bump to 2.0.1rc7\n\n10/24/2016\n- add OpenID Connect RP certification test script\n- handle non-integer exp/iat timestamps; closes #187; thanks @drdivano\n\n10/21/2016\n- bugfix: first truncate files before writing them\n- support refreshing provider metadata based on timestamp and OIDCProviderMetadataRefreshInterval\n\n10/20/2016\n- bugfix: correctly truncate encryption keys derived from client secret for algorithms that require a key size < 256 bits\n- add test/test-cmd tool\n- bugfix: return error on session cache failures; closes #185; thanks @solsson\n- bump to 2.0.1rc6\n\n10/18/2016\n- bugfix: JWTs with a header that doesn't specify a `kid` that would not validate when used with more than 1 key; closes #184; thanks @solsson\n- bump to 2.0.1rc5\n\n10/13/2016\n- urlencode provider URL cache key to fix file cache backend issue; closes #179, thanks @djahandarie\n\n10/9/2016\n- fix null pointer segfault in debug printout in oidc_util_read_form_encoded_params\n- fix OIDCOAuthAcceptTokenAs parsing flaw introduced in 2.0.0rc5\n- bump to 2.0.1rc4\n\n10/2/2016\n- support presenting the access token to the userinfo endpoint in a POST parameter\n- bump to 2.0.1rc3\n\n9/30/2016\n- support WebFinger Discovery with URL-style user identifiers\n\n9/28/2016\n- fix memory leak in oidc_jwk_to_json\n- add \"remove_at_cache\" hook; addresses #177\n- bump to 2.0.1rc2\n\n9/27/2016\n- add support for Request URI with signed and/or encrypted Request Objects\n- bump to 2.0.1rc1\n\n9/22/2016\n- refuse webfinger responses with an href value that is not on secure https\n- add userinfo JWT response verification and decryption\n\n9/20/2016\n- log the JWT header before optional decryption is applied\n\n9/19/2016\n- check that a sub claim returned from the userinfo endpoint matches the one in the id_token\n- fix issue in oidc_metadata_parse_url so that static default would not be honored\n  - this only affected server-wide OIDCClientJwksUri usage in dynamic client registration\n- non-functional changes for OIDC RP certification:\n  - explicitly log the client authentication method when calling the token endpoint\n  - log the keys that are included for token verification\n- bump to 2.0.1rc0\n\n9/9/2016\n- fix overriding provider token endpoint auth with static config when not set in .conf file\n- don't add our own cookies to the incoming headers\n- allow stripping cookies from the Cookie header sent to the application/backend with OIDCStripCookies\n- release 2.0.0\n\n9/5/2016\n- encapsulate (sub-)directory config handling and fix merging so values can be set back to default values in subdirs\n- bump to 2.0.0rc5\n\n9/2/2016\n- fix JWK creation when no client secret is set e.g. in Implicit flows; closes #168; thanks @asc1\n- bump to 2.0.0rc4\n\n9/1/2016\n- fix HTML decoding of OIDCPreservePost data; closes #165\n- limit max POST data size to 1Mb\n- allow chunked data in POST handling; revise handler\n- change preserve POST JSON data format to urlencoded for performance reasons\n\n8/31/2016\n- allow setting the token endpoint authentication method in the .conf file (for dynamic client registration that sets the .client)\n\n8/30/2016\n- pass refresh token in header/environment variable with OIDCPassRefreshToken; thanks Amit Joshi\n- fix front-channel img-style logout with newer versions of PingFederate that don't send an Accept: image/png header\n\n8/29/2016\n- preserve POST data across authentication requests and discovery with OIDCPreservePost\n- bump to 2.0.0rc3\n\n8/24/2016\n- fix parsing of OIDCOAuthAcceptTokenAs to accept options following \":\"\n- bump to 2.0.0rc2\n\n8/5/2016\n- delete the debian directory\n- rename OIDCOAuthTokenEndpointCert/Key to OIDCOAuthIntrospectionEndpointCert/Key\n- pre-release 2.0.0rc1\n\n7/30/2016\n- encrypt state/session JWT cookies and session JWT cache values for non-shm storages\n\n7/29/2016\n- use cjose - https://github.com/cisco/cjose (master) - for JOSE functions\n- use stricter input parsing functions for configuration values\n- bump to 2.0.0rc0\n\n7/21/2016\n- support TLS client authentication to token and introspection endpoints\n- bump to 1.9.0rc3\n\n7/19/2016\n- add support for chunked session cookies; closes #153; thanks @glatzert \n- bump to 1.9.0rc2\n\n7/9/2016\n- fix Elliptic Curve signature verification for corrupted input\n- support OpenSSL 1.1.x\n- bump to 1.9.0rc1\n\n7/5/2016\n- use AUTHZ_DENIED instead of HTTP_UNAUTHORIZED in oidc_authz_checker; closes #151; thanks @gwollman\n- use signed JWTs for state/session cookies\n- achieve smaller client-cookie sizes for regular cases; no id_token is stored in the session:\n  - (optional) id_token_hint no longer available in session management calls (logout/prompt=none) with \"OIDCSessionType client-cookie\"\n  - \"OIDCPassIDTokenAs serialized\" is not available with \"OIDCSessionType client-cookie\"\n- bump to 1.9.0rc0\n\n6/27/2016\n- use EVP_CIPHER_CTX_new to avoid compilation errors with OpenSSL 1.1.0\n- release 1.8.10\n\n6/22/2016\n- don't use local port setting for current URL determination when X-Forwarded-Host has been set\n- bump to 1.8.10rc4\n\n6/20/2016\n- fix memory leak in OAuth access token introspection result caching (introduced only in 1.8.10rc0)\n- fix setting private_key_jwt or client_secret_jwt with OIDCProviderTokenEndpointAuth\n- bump to 1.8.10rc3\n\n6/19/2016\n- allow setting OIDCRemoteUserClaim with values obtained from the userinfo endpoint; thanks @steve-dave\n- fix OIDCUnAuthAction pass mode for Apache 2.4 and in case `Require claim` primitives used for 2.4 and 2.2; thanks @steve-dave\n- bump to 1.8.10rc2\n\n6/15/2016\n- add support for JWT based client authentication to the token endpoint (client_secret_jwt, private_key_jwt)\n- bump to 1.8.10rc1\n\n6/9/2016\n- add per-path configurable token introspection result cache expiry with OIDCOAuthTokenIntrospectionInterval\n- bump to 1.8.10rc0\n\n6/5/2016\n- release 1.8.9\n\n5/9/2016\n- support 410 option on OIDCUnAuthAction; closes #141\n- bump to 1.8.9rc6\n\n5/1/2016\n- avoid segmentation fault on invalid OIDC configuration when OIDCRedirectURI is not set; fixes #138; thanks @brianwcook\n- bump to 1.8.9rc5\n\n4/18/2016\n- fix get_current_url (proxy) case where r->parsed_uri.path would be null\n\n4/13/2016\n- improve X-Forwarded-Host handling over Host in a) port detection and b) remove port from host value\n- bump to 1.8.9rc4\n\n4/10/2016\n- do not require OIDCClientSecret in configs; allows for Implicit grant without setting a dummy client secret; closes #130\n- allow for public clients calling the token endpoint\n- bump to 1.8.9rc3\n\n4/9/2016\n- ensure that claims from id_token are available for authz also when OIDCPassIDTokenAs does not contain \"claims\"; closes #129\n- bump to 1.8.9rc2\n\n4/3/2016\n- return WWW-Authenticate header and error messages on OAuth paths where access is not granted; closes #124; thanks @spinto\n- bump to 1.8.9rc1\n\n4/1/2016\n- apr_jwe_decrypt_content_aesgcm() null terminate string, #128, thanks @jdennis\n- bump to 1.8.9rc0\n\n3/10/2016\n- release 1.8.8\n\n3/7/2016\n- issue a warning if the \"openid\" scope is not requested\n\n3/6/2016\n- sanitize the OIDCAuthNHeader value before setting the header; thanks @rfk\n- bump to 1.8.8rc7\n\n3/5/2016\n- log exact version of OpenSSL and EC/GCM/Redis support\n- tidy up auth_openidc.conf docs\n- bump to 1.8.8rc6\n\n2/26/2016\n- add option to refresh claims from the userinfo endpoint using OIDCUserInfoRefreshInterval; see #119\n- merge id_token claims in to the set of claims used for authorization for Apache >=2.4; see #120\n- bump to 1.8.8rc5\n\n2/23/2016\n- make state cookie a session cookie and clean expired cookies on entry (merge of fix-firefox-cookie-storage)\n- fix HTML error template initialization in vhosts\n- bump to 1.8.8rc4\n\n2/22/2016\n- don't authenticate (redirect/state) when X-Requested-With header exists; as suggested in #113\n- bump to 1.8.8rc3\n\n2/18/2016\n- pass plain state to the token endpoint on code flows: https://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation-01\n- fix loose (prefix-only) matching of cookie names\n- allow passing OAuth bearer token as a cookie (OIDCOAuthAcceptTokenAs extension for PingAccess)\n- bump to 1.8.8rc2\n\n2/11/2016\n- include token_endpoint_auth_method in dynamic client registration request, set to selected method from provider\n\n2/10/2016\n- Elliptic Curve support now requires OpenSSL 1.0.1 detection\n- bump to 1.8.8rc1\n\n1/14/2016\n- add support for passing in OAuth bearer tokens as one or more of: header, post param or query param (OIDCOAuthAcceptTokenAs)\n- bump to 1.8.8rc0\n\n1/8/2016\n- release 1.8.7\n\n1/7/2016\n- update copyright year\n\n12/17/2015\n- enforce strict matching of issuer in Discovery document against the originally requested issuer\n- check iss/client_id if present in an authentication response\n- push a hash of state to the token endpoint on code flows\n- bump to 1.8.7rc4\n\n12/9/2015\n- improve debug logging around session management capabilities (i.e. enabled/disabled)\n- return 404 for op/rp iframes if session management is not enabled\n- bump to 1.8.7rc3\n\n12/4/2015\n- add support for RFC 7636 PKCE plain & S256 https://tools.ietf.org/html/rfc7636\n- bump to 1.8.7rc2\n\n12/3/2015\n- fix crash when using a custom error template and the error description is NULL\n- fix crash when target_link_uri is not a valid URI or parts are empty\n- fix memory corruption when using custom html template across different server requests; closes #106\n- bump to 1.8.7rc1\n\n11/18/2015\n- fix compiler warning on double sizeof call; close #103; thanks to @dcb314\n- bump to 1.8.7rc0\n\n10/26/2015\n- add option to make session cookie persistent; closes #97\n- release 1.8.6\n\n10/19/2015\n- add support for applying a custom HTML error template with OIDCHTMLErrorTemplate\n- bump to 1.8.6rc3\n\n10/12/2015\n- check the cookie domain that the session was created for against the configured domain\n- log a warning if the Set-Cookie value length is greater than 4093 bytes\n- include and prioritize the X-Forwarded-Host header in hostname determination\n- allow for missing Host header i.e. HTTP 1.0\n- return DONE instead of HTTP_UNAUTHORIZED with Discovery page (prevent double HTML in HTTP 1.0)\n- use apr_strnatcmp instead of strcmp in util.c and mod_auth_openidc.c\n- bump to 1.8.6rc2\n\n10/9/2015\n- support subdomain cookies in OIDCCookieDomain checks; PR #96, thanks @pfiled\n- bump to 1.8.6rc1\n\n10/6/2015\n- add key identifier (\"kid\") option to `OIDCOAuthVerifySharedKeys`, `OIDCOAuthVerifyCertFiles` and `OIDCPublicKeyFiles` configs\n- bump to 1.8.6rc0\n\n9/21/2015\n- support (non-sid-based) HTTP logout: http://openid.net/specs/openid-connect-logout-1_0.html\n- release 1.8.5\n\n9/16/2015\n- improve logging on provider/client/conf metadata parsing failures; closes #94\n- bump to 1.8.5rc7\n\n9/9/2015\n- fix parsing of OIDCOAuthTokenExpiryClaim, thanks to @bester #90\n- bump to 1.8.5rc6\n\n9/4/2015\n- add CSRF protection to external Discovery as well\n- allow browser back after authorization response, see #89\n- handle invalid (expired) authorization response state by sending the user to OIDCDefaultURL, see #86\n- bump to 1.8.5rc5\n\n8/26/2015\n- add CSRF protection to Discovery\n- bump to 1.8.5rc4\n\n8/19/2015\n- support encrypted JWTs using A192KW for key encryption and A192CBC-HS384 for content encryption\n- bump to 1.8.5rc3\n\n8/15/2015\n- support encrypted JWTs using RSA-OAEP for key encryption and A128GCM,A192GCM,A256GCM for content encryption\n- bump to 1.8.5rc2\n\n8/4/2015\n- support for OIDCUnAuthAction: how to act on unauthenticated requests (OIDCReturn401 is deprecated)\n- bump to 1.8.5rc1\n\n7/15/2015\n- add authentication option for Redis server with OIDCRedisCachePassword\n- bump to 1.8.5rc0\n\n7/3/2015\n- allow for compilation on Windows using VS 2013\n- bump to 1.8.4\n\n6/30/2015\n- improve memcache logging: don't report cache misses as an error, thanks to @scottdear\n- work around JSON timestamp print modifier issue (%lld) on some platforms, thanks to @ralphvanetten\n- bump to 1.8.4rc3\n\n6/24/2015\n- support passing claims as environment variables (OIDCPassClaimsAs)\n- bump to 1.8.4rc1\n\n6/22/2015\n- correct debug printout in oidc_util_read_form_encoded_params\n\n6/20/2015\n- avoid double free of JWT after parsing errors have been encountered\n- bump to 1.8.4rc0\n\n6/19/2015\n- make public keys for encrypted access tokens available in OAuth-only configurations; fixes #74\n- remove exceptions for accounts.google.com since Google is OpenID Connect compliant now\n- release 1.8.3\n\n6/15/2015\n- add a complete JWT sample that includes validation of \"exp\" and \"iat\" to the test suite\n\n6/10/2015\n- allow JSON string values for the \"active\" claim in access token validation responses\n- bump to 1.8.3rc4\n\n6/7/2015\n- improve error logging on non-supported JWT signing/encryption algorithms\n- bump to 1.8.3rc3\n\n5/31/2015\n- merge id_token (\"iss\"!) and user info claims for authz processing\n- bump to 1.8.3rc2\n\n5/29/2015\n- fix hash comparison when padded, thanks to @steverc as mentioned in #65\n- fix post-logout URL being set to SSO URL\n- add post-logout URL validation, thanks to @davidbernick\n- bump to 1.8.3rc1\n\n5/18/2015\n- fix OpenSSL version detection for Elliptic Curve support in apr_jwt_signature_to_jwk_type: include opensslv.h\n- fix hash length calculation for Elliptic Curve algorithms\n- release 1.8.2\n\n5/5/2015\n- release 1.8.1\n\n4/21/2015\n- allow setting OIDCDiscoverURL inside of Directory and Location directives as well\n- bump to 1.8.1rc5\n\n4/20/2015\n- allow setting OIDCCookie outside of Directory and Location directives as well\n- bump to 1.8.1rc4\n\n4/17/2015\n- add support for applying regular expressions to OIDCRemoteUserClaim and OIDCOAuthRemoteUserClaim\n- bump to 1.8.1rc3\n\n4/12/2015\n- make token expiry parsing of introspection result configurable (OIDCOAuthTokenExpiryClaim)\n- increase SHM cache key size from 255 to 512 (allows for JWT access tokens cache keys for introspection result)\n- bump to 1.8.1rc2\n\n4/1/2015\n- avoid timing attacks on symmetric key signature/hash comparisons as pointed out by @timmclean\n- bump to 1.8.1rc1\n\n3/19/2015\n- merge #57: fix build with OpenSSL <1.0 re. apr_jws_signature_is_ec (thanks to @szakharchenko)\n\n2/26/2015\n- release 1.8.0\n\n2/23/2015\n- avoid including line feeds in header values (thanks to @forkbomber and @ekanthi)\n- bump to 1.8.0rc5\n\n2/16/2015\n- fix free() crash on simple-valued error printouts\n- fix returning keys without a \"kid\"\n- fix searching for keys with a \"x5t\" thumbprint\n- refactor response type handling; more strict matching of requested response type\n- make compiled in Redis support optional\n- fix oauth.introspection_endpoint_method in initialization\n- bump to 1.8.0rc4\n\n2/15/2015\n- add support for configurable introspection HTTP method (OIDCOAuthIntrospectionEndpointMethod)\n- add preliminary support for GET-style logout\n- bump to 1.8.0rc2\n\n2/12/2015\n- add support for configuration of maximum session duration\n- bump to 1.8.0rc1\n\n2/9/2015\n- check JWT signature against all configured keys (jwks_uri) if no \"kid\" is provided, not just the first one\n- revise JOSE JWS handling part 2\n- complete support for local JWT access token validation\n- bump to 1.8.0rc0\n\n2/5/2015\n- fix symmetric key decryption of JWTs (A128CBC-HS256/A256CBC-HS512)\n- sha256 client secrets before using them as symmetric keys for decryption\n- extended decryption test coverage; avoid double printouts on error\n- refactor JWT header parsing\n- simplify JWK URI refresh handling\n- release 1.7.3\n\n2/4/2015\n- revise JOSE JWK handling part 1\n- change change target_uri parameter name to target_link_uri following draft-bradley-oauth-jwt-encoded-state-03\n- extended tests with stubs\n- refactor JWT validation (iss, exp, iat)\n- fix memory leak with RSA key conversion in apr_jwk.c - apr_jwk_rsa_bio_to_key\n- bump to 1.7.3rc4\n\n1/25/2015\n- Allow {... \"error\": null ...} in JSON responses. (@fatlotus)\n\n1/22/2015\n- fix configuration validation check where no config would be checked if OIDCProviderIssuer is set\n  but both OIDRedirectURI and OIDCCryptoPassphrase are not set\n- add preliminary support for local JWT access token validation\n- bump to 1.7.3rc1\n- sanitize set cookie syntax (get rid of extraneous \";\")\n\n1/21/2015\n- add support for OIDCOAuthIntrospectionTokenParamName (incl. Google OAuth 2.0 access token validation)\n- add a sample OAuth 2.0 config for Google access tokens to README.md\n- release 1.7.2\n\n- add APXS2_OPTS to configure.ac to accommodate RPM builds\n- bump to 1.7.3rc0\n- fix JWT timestamp (iat/exp) initialization issue\n- fix README.md on Google's scope required for returning the \"hd\" claim\n\n1/14/2015\n- add Apache function stubs to enable extending the scope of tests\n- add tests for oidc_proto_validate_access_token and oidc_proto_validate_code\n- bump to 1.7.2rc3\n\n1/12/2015\n- improve accuracy of expired/invalid session handling\n\n1/11/2015\n- add error type and return values to JOSE functions\n- fix return result on error in function that decrypts CEK\n- bump to 1.7.2rc2\n\n1/1/2015\n- update copyright to 2015\n- use json_int_t (seconds) for \"exp\" and \"iat\" fields, instead of apr_time_t (microseconds) \n- correct expiry debug printout\n- bump to 1.7.2rc1\n\n12/15/2014\n- fix Redis reconnect behavior: avoid keep reconnecting after first failure\n- bump to 1.7.2rc0\n\n12/12/2014\n- support passing cookies specified in OIDCPassCookies from browser on to OP/AS calls (for loadbalancing purposes)\n- release 1.7.1\n- document OIDCPassCookies in auth_openidc.conf\n\n12/10/2014\n- reconnect to the Redis server after I/O failure as raised in #43\n- bump to 1.7.1rc4\n\n12/8/2014\n- return http 500 when detecting requests that will loop on return\n- bump to 1.7.1rc3\n\n12/3/2014\n- require the expiring access_token on the refresh hook for XSRF protection\n- pass error codes back to the caller when the refresh hook fails\n- bump to 1.7.1rc2\n\n12/2/2014\n- improve handling of non-string (=non-compliant) error responses\n\n11/26/2014\n- make shared memory cache entry max size configurable through OIDCCacheShmEntrySizeMax\n- add OIDCReturn401 configuration primitive\n- bump to 1.7.1rc1\n\n11/11/2014\n- allow OIDCRedirectURI's with an empty path and fix crash; thanks to @CedricCabessa\n\n11/9/2014\n- support for adding configurable JSON parameters to Dynamic Client Registration requests\n\n11/5/2014\n- release 1.7.0\n\n10/30/2014\n- correct expires_in conversion\n- first stab at HTML templating and make all html HTML 4.01 Strict compliant\n- bump to 1.7.0rc4\n\n10/29/2014\n- document refresh flow\n\n10/28/2014\n- scrub all OIDC_ headers\n- add support for the refresh_token flow + hook\n- pass the expires_in as an absolute timestamp in OIDC_access_token_expires\n- use a global mutex for the Redis cache\n- bump to 1.7.0rc3\n\n10/27/2014\n- generalize support for OAuth 2.0 token introspection and conform to:\n  https://tools.ietf.org/html/draft-ietf-oauth-introspection-00\n\n10/26/2014\n- support regular expressions in Require statements\n\n10/24/2014\n- add support for Redis cache backend; there's a dependency on hiredis headers/library now\n\n10/21/2014\n- refactor nonce generation and remove base64url padding from value\n\n10/13/2014\n- add libssl-dev to Debian control build dependencies\n- release 1.6.0\n\n10/6/2014\n- apply html encoding to error display\n- bump version number to 1.6.0rc4\n\n10/2/2014\n- avoid crash when downloading metadata from OIDCProviderMetadataURL fails\n- set OIDCProviderMetadataURL retrieval interval to 24 hours\n- return error on configurations mixing OIDCProviderMetadataURL and OIDCMetadataDir\n- bump version number to 1.6.0rc3\n\n10/1/2014\n- support provider configuration from a metadata URL (OIDCProviderMetadataURL)\n- bump version number to 1.6.0rc2\n\n9/30/2014\n- be less strict about issuer validation in metadata\n- refactor metadata.c\n- improve logging about userinfo endpoint\n\n9/29/2014\n- refactor cache so it is partitioned in to sections (i.e. avoid future key collisions)\n\n9/25/2014\n- add support for \"x5c\" JWK representation\n- return JWKS on jwks_uri with content-type \"application/json\"\n\n9/17/2014\n- remove support for the X-Frame-Options as it is not needed in 302s\n- create and use log macros that printout function name\n\n9/16/2014\n- support for passing runtime determined authentication request parameters in the discovery response\n- include name/version in logs and bump to 1.6.0rc1\n- don't use the X-Frame-Options by default\n\n9/13/2014\n- add support for the X-Frame-Options header as recommended by the spec\n\n9/12/2014\n- set expiry on state cookies; don't clear session cookie after cache miss or corruption\n- fix JSON array memory leak in oauth.c\n\n9/10/2014\n- merge #34 (g10f), fix session management Javascript bug\n\n9/3/2014\n- improve error handling on hitting the redirect URI directly\n- fix set_slot functions for algorithm/url used as default for dynamic registration\n- rewording of auth_openidc.conf docs on JWK settings\n\n9/1/2014\n- add session management based on http://openid.net/specs/openid-connect-session-1_0.html (draft 21)\n\n8/29/2014\n- add configuration option to POST extra parameters to the token endpoint\n\n8/26/2014\n- correct cookie_path comparison\n- release 1.5.5\n\n8/20/2014\n- correctly error out on flows where no id_token was provided (\"token\")\n\n8/19/2014\n- fix debug printout on open redirect prevention\n- cleanup in-memory crypto context on shutdown\n- use default of \"/\" for OIDCCookiePath to simplify quickstart/simple deployments\n- disable OIDCMetadataDir in sample/default config file\n- clear session cookie after cache miss or corruption\n\n8/18/2014\n- add HttpOnly flag to cookies by default; can be disabled by config\n\n8/14/2014\n- support for passing the id_token in multiple formats (claims|payload|serialized)\n- release 1.5.4\n\n8/13/2014\n- pass the access_token in OIDC_access_token header to the application\n\n8/9/2014\n- merge #21 (Latinovic) to close #18 (big endian JWE issue)\n- merge #20 (wadahiro), support for \"none\" JWT signing algorithm\n\n8/1/2014\n- fix cache initialization/destroy leak\n- release 1.5.3\n\n7/26/2014\n- refactor http code; cleanup JSON encoding in client registration\n- refactor padding handling in base64url encoding/decoding\n\n7/20/2014\n- check for open redirect on passed target_link_uri\n- prevent JWE timing attacks on CEK; add JWE test\n- include client_id and scope values in resolved access_token\n\n7/1/2014\n- pass JSON objects in app HTTP headers as plain JSON\n- correct printout in id_token hash comparisons\n- add more tests\n- release 1.5.2\n\n6/12/2014\n- support third-party-initiated login as defined in the spec\n- release 1.5.1\n- fix PF OAuth 2.0 RS functionality after upgrading to jansson\n\n6/6/2014\n- more changes for Debian packaging (1.5-3)\n\n6/5/2014\n- do not set Secure cookies for plain HTTP\n- add warning/errors when configured hosts/domains do not match\n- release 1.5\n- changes for Debian packaging\n\n6/4/2014\n- fix passing integer claims on non-Mac OS X systems\n- fix claims-based authorization with integer values (@martinsrom)\n- fix getting the id_token from request state and error logging\n- add AUTHORS file with credits\n- migrate README to Markdown README.md\n\n6/3/2014\n- change JSON parser from https://github.com/moriyoshi/apr-json to http://www.digip.org/jansson/\n\n6/2/2014\n- handle X-Forwarded-Proto/X-Forwarded-Port when running behind a proxy/load-balancer\n- release version 1.4\n\n6/1/2014\n- compile with OpenSSL <1.0 and but then disable Elliptic Curve verification\n- fix jwks_uri setting in nested vhosts\n- use OpenSSL_add_all_digests in initialization and EVP_cleanup on shutdown\n\n5/31/2014\n- README additions/improvements\n\n5/29/2014\n- correct big endian detection\n- allow for key identification in JWKs based on thumbprint (x5t)\n\n5/24/2014\n- add cache destroy function and destroy shm cache resources on shutdown\n\n5/23/2014\n- doc corrections to auth_openidc.conf\n\n5/22/2014\n- add implementation of OP-initiated-SSO based on:\n  http://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-01\n- fix nonce caching for replay prevention\n\n5/21/2014\n- correct README on enabling Google+ APIs before applying the sample Google configs\n- fix AuthNHeader setting and allow server-wide config too\n- avoid segfault on corrupted/non- JSON/JWT input\n\n5/20/2014\n- fix URL assembly when running on non-standard port\n- release 1.3\n\n5/17/2014\n- support outgoing proxy using OIDCOutgoingProxy\n- correct sample configs in documentation for missing OIDCCookiePath\n- support OIDCCookiePath in server-wide config as well\n\n5/13/2014\n- support configurable (custom) query parameters in the authorization request\n\n5/12/2014\n- support encrypted JWTs using A128KW and A256KW for the Content Encryption Key\n- support A256CBC-HS512 encrypted JWTs\n- support custom client JWKs URI\n\n5/8/2014\n- support encrypted JWTs using RSA1_5 and A128CBC-HS256\n\n5/2/2014\n- do not use ap_get_remote_host for browser fingerprinting\n\n5/1/2014\n- split out custom client config into separate <issuer>.conf file\n- allow to override client_contact, client_name and registration_token in .conf file\n- remove OIDCRegistrationToken command for the static OP config\n\n4/29/2014\n- support JWT verification of ES256, ES384 and ES512 algorithms\n\n4/28/2014\n- support configurable response_mode (fragment, query or form_post)\n- use nonce in all flows except for OP Google and flows \"code\" or \"code token\"\n\n4/26/2014\n- make client secret optional (support self-issued OP)\n\n4/25/2014\n- support Hybrid flows\n\n4/24/2014\n- fix using Bearer token Authorization header on JSON POST calls\n- support using a Bearer token on client registration calls\n\n4/22/2014\n- match request and response type \n- check at_hash value on \"token id_token\" implicit flow\n- use shared memory caching by default\n- release 1.2\n\n4/19/2014\n- store response_type in state and make state a JSON object\n\n4/18/2014\n- support RSASSA-PSS token signing algorithms (PS256,PS384,PS512)\n\n4/17/2014\n- improve session inactivity timeout handling\n\n4/16/2014\n- set REMOTE_USER and HTTP headers on OAuth 2.0 protected paths\n\n4/15/2014\n- add session inactivity timeout\n- register all supported response_types during client registration and try\n  to pick the one that matches the configured default\n- use long timeouts on JWK retrieval calls\n- allow for non-null but empty query parameters on implicit authorization response\n- simplify azp/aud and nonce handling\n- change session_type naming (to \"server-cache\"/\"client-cookie\")\n\n4/14/2014\n- factor out JOSE related code\n\n4/3/2014\n- add configurable claim name for the REMOTE_USER variable, optionally postfixed with the  url-encoded\n  issuer value; the default for the remote username is \"sub@\" now, makeing it unique across OPs\n- some refactoring of id_token validation functions\n- add INSTALL, move auth_openidc.conf to main directory\n- release 1.1\n\n3/28/2014\n- fix Require claim name mismatch for Apache 2.4\n- fix hmac method/printout naming artifacts from earlier\nauto-search-and-replace\n- release v1.0.1\n\n3/27/2014\n- initial import named mod_auth_openidc\n- updated README\n- fix debian/changelog\n", "########################################################################################\n#\n# Common Settings\n#\n########################################################################################\n\n# (Mandatory)\n# The redirect_uri for this OpenID Connect client; this is a vanity URL\n# that must ONLY point to a path on your server protected by this module\n# but it must NOT point to any actual content that needs to be served.\n# You can use a relative URL like /protected/redirect_uri if you want to\n# support multiple vhosts that belong to the same security domain in a dynamic way\n#OIDCRedirectURI https://www.example.com/protected/redirect_uri\n\n# (Mandatory)\n# Set a password for crypto purposes, this is used for:\n# - encryption of the (temporary) state cookie\n# - encryption of cache entries, that may include the session cookie, see: OIDCCacheEncrypt and OIDCSessionType\n# Note that an encrypted cache mechanism can be shared between servers if they use the same OIDCCryptoPassphrase\n# Only for Apache >= 2.4.x:\n# If the value begins with exec: the resulting command will be executed and the\n# first line returned to standard output by the program will be used as the password.\n# The command may be absolute or relative to the web server root.\n#OIDCCryptoPassphrase [ <passphrase> | \"exec:/path/to/otherProgram arg1\" ]\n\n#\n# All other entries below this are optional though some may be required in a\n# particular setup e.g. OAuth 2.0 Resource Server vs. OpenID Connect Relying Party\n#\n\n# When using multiple OpenID Connect Providers, possibly combined with Dynamic Client\n# Registration and account-based OP Discovery.\n# Specifies the directory that holds metadata files (must be writable for the Apache process/user).\n# When not specified, it is assumed that we use a single statically configured provider as\n# described under the section \"OpenID Connect Provider\" below, most likely using OIDCProviderMetadataURL.\n#OIDCMetadataDir /var/cache/apache2/mod_auth_openidc/metadata\n\n########################################################################################\n#\n# OpenID Connect Provider\n#\n# For configuration of a single static provider, not using OpenID Connect Provider Discovery.\n#\n########################################################################################\n\n# URL where OpenID Connect Provider metadata can be found (e.g. https://accounts.google.com/.well-known/openid-configuration)\n# The obtained metadata will be cached and refreshed every 24 hours.\n# If set, individual entries below will not have to be configured but can be used to add\n# extra entries/endpoints to settings obtained from the metadata.\n# If OIDCProviderMetadataURL is not set, the entries below it will have to be configured for a single\n# static OP configuration or OIDCMetadataDir will have to be set for configuration of multiple OPs.\n#OIDCProviderMetadataURL <url>\n\n# OpenID Connect Provider issuer identifier (e.g. https://localhost:9031 or https://accounts.google.com)\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderIssuer <issuer>\n\n# OpenID Connect Provider Authorization Endpoint URL (e.g. https://localhost:9031/as/authorization.oauth2)\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderAuthorizationEndpoint <authorization_endpoint>\n\n# OpenID Connect Provider JWKS URL (e.g. https://localhost:9031/pf/JWKS)\n# i.e. the URL on which the signing keys for this OP are hosted, in JWK formatting\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderJwksUri <jwks_url>\n\n# OpenID Connect Provider Token Endpoint URL (e.g. https://localhost:9031/as/token.oauth2)\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderTokenEndpoint <token_endpoint>\n\n# Authentication method for the OpenID Connect Provider Token Endpoint.\n# When \"private_key_jwt\" is used, OIDCPrivateKeyFiles and OIDCPublicKeyFiles must have been set.\n# When not defined the default method from the specification is used, i.e. \"client_secret_basic\".\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n# NB: this can be overridden for dynamic client registration on a per-OP basis in the .conf file using the key: token_endpoint_auth\n#OIDCProviderTokenEndpointAuth [ client_secret_basic | client_secret_post | client_secret_jwt | private_key_jwt | none ]\n\n# Extra parameters that need to be passed in the POST request to the Token Endpoint.\n# Parameter names and values need to be provided in URL-encoded form.\n# When not defined no extra parameters will be passed.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: token_endpoint_params\n#OIDCProviderTokenEndpointParams <urlencoded-name1>=<urlencoded-value1>[&<urlencoded-nameN>=<urlencoded-valueN>]* \n\n# OpenID Connect Provider UserInfo Endpoint URL (e.g. https://localhost:9031/idp/userinfo.openid)\n# When not defined no claims will be resolved from such endpoint.\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderUserInfoEndpoint <user_info_endpoint>\n\n# OpenID OP Check Session iFrame URL, for Session Management purposes.\n# When not defined, no Session Management will be applied.\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderCheckSessionIFrame <url>\n\n# OpenID OP End Session Endpoint URL, for Single Logout (Session Management) purposes.\n# When not defined, no logout to the OP will be performed.\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderEndSessionEndpoint <url>\n\n# The RFC 7009 Token Revocation Endpoint URL.\n# When defined, the refresh token and access token stored in an OIDC session will be revoked on logout.\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderRevocationEndpoint <url>\n\n# Define whether the OP supports OpenID Connect Back Channel Logout.\n# According to: https://openid.net/specs/openid-connect-backchannel-1_0.html\n# Used when OIDCProviderMetadataURL is not defined or the metadata obtained from that URL does not set it.\n#OIDCProviderBackChannelLogoutSupported [On|Off]\n\n# Extra JSON parameters that need to be passed in the registration request to the Registration Endpoint.\n# This settings serves as a default value for multiple OPs only.\n# Parameter names and values need to be provided in JSON form and will be merged in to the request.\n# When not defined no extra parameters will be passed.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: registration_endpoint_params\n#OIDCProviderRegistrationEndpointJson <json-string>\n\n# Define the OpenID Connect scope that is requested from the OP (eg. \"openid email profile\").\n# When not defined, the bare minimal scope \"openid\" is used.\n# NB: multiple scope values must be enclosed in a single pair of double quotes \n# NB: this can be overridden on a per-OP basis in the .conf file using the key: scope\n#OIDCScope \"<scope(s)-separated-by-spaces-and-enclosed-in-double-quotes>\"\n\n# Extra parameters that will be sent along with the Authorization Request.\n# These must be URL-query-encoded as in: \"display=popup&prompt=consent\" or\n# specific for Google's implementation: \"approval_prompt=force\".\n# This is used against a statically configured (single) OP or serves as the default for discovered OPs.\n# As an alternative to this option, one may choose to add the parameters as\n# part of the URL set in OIDCProviderAuthorizationEndpoint or \"authorization_endpoint\"\n# in the .provider metadata (though that would not work with Discovery OPs).\n#\n# Since version 2.3.11rc1 one can pass on query parameters from the request to the authorization\n# request by adding e.g. \"foo=#\" which which will dynamically pull in the query parameter value\n# from the request query parameter and add it to the authentication request to the OP.\n#\n# The default is to not add extra parameters.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: auth_request_params\n#OIDCAuthRequestParams <query-encoded-string>\n\n# Require a valid SSL server certificate when communicating with the OP.\n# (i.e. on token endpoint, UserInfo endpoint and Dynamic Client Registration endpoint)\n# When not defined, the default value is \"On\".\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: ssl_validate_server\n#OIDCSSLValidateServer [On|Off]\n\n# Require configured issuer to match the issuer returned in id_token.\n# (Disable to support Azure AD multi-tenant applications.)\n# When not defined, the default value is \"On\".\n#OIDCValidateIssuer [On|Off]\n\n# The refresh interval in seconds for the claims obtained from the userinfo endpoint\n# When not defined the default is 0, i.e. the claims are retrieved only at session creation time.\n# If refreshing fails, it is assumed that the access token is expired and an attempt will be made\n# to refresh the access token using the refresh token grant, after which a second attempt is made\n# to obtain claims from the userinfo endpoint with the new access token.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_refresh_interval\n#OIDCUserInfoRefreshInterval <seconds>\n\n# The refresh interval in seconds for the JWKs key set obtained from the jwk_uri.\n# When not defined the default is 3600 seconds.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: jwks_refresh_interval\n#OIDCJWKSRefreshInterval <seconds>\n\n# Defines the way in which the access token will be presented to the userinfo endpoint\n# \"authz_header\" means that the token will be presented in an \"Authorization: Bearer\" header using HTTP GET\n# \"post_param\" means that the token will be presented a form-encoded POST parameter using HTTP POST\n# When not defined the default is \"authz_header\".\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_token_method\n#OIDCUserInfoTokenMethod [authz_header|post_param]\n\n# Defines the HTTP method used to pass the parameters in the Authentication Request to the Authorization Endpoint.\n# \"GET\" means that the parameters will be passed as query parameters in an HTTP GET\n# \"POST\" means that the parameters will be passed as form-post parameters in an HTTP POST\n# When not defined the default is \"GET\".\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: auth_request_method\n# OIDCProviderAuthRequestMethod [ GET | POST ]\n\n# The fully qualified names of the files that contain the PEM-formatted RSA Public key or a X.509 certificates\n# that contain the RSA public keys to be used for JWT (OP state/id_token) encryption by the OP.\n# One of these keys must correspond to the private keys defined in OIDCPrivateKeyFiles.\n# When not defined no encryption will be requested.\n# You can also prefix <filename> with a JWK key identifier to manually override the automatically\n# generated \"kid\" that will be used for this key in the JWKs derived from this certificate and\n# published at OIDCClientJwksUri.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key \"keys\" whose value is a JWK set/array (use=sign)\n#OIDCPublicKeyFiles ([<kid>#]<filename>)+\n\n# The fully qualified names of the files that contain the PEM-formatted RSA private\n# keys that can be used to decrypt content sent to us by the OP.\n# These keys must correspond to the public keys defined in OIDCPublicKeyFiles.\n# When not defined no decryption will be possible.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key \"keys\" whose value is a JWK set/array (use=enc)\n#OIDCPrivateKeyFiles ([<kid>#]<filename>)+\n\n########################################################################################\n#\n# OpenID Connect Client\n#\n# Settings used by the client in communication with the OpenID Connect Provider(s),\n# i.e. in Authorization Requests, Dynamic Client Registration and UserInfo Endpoint access.\n# These settings are used when a single static provider is configured and serve as defaults\n# when multiple providers are configured.\n#\n########################################################################################\n\n# The response type (or OpenID Connect Flow) used (this serves as default value for discovered OPs too)\n# When not defined the \"code\" response type is used.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: response_type\n#OIDCResponseType [\"code\"|\"id_token\"|\"id_token token\"|\"code id_token\"|\"code token\"|\"code id_token token\"]\n\n# The response mode used (this serves as default value for discovered OPs too)\n# When not defined the default response mode for the requested flow (OIDCResponseType) is used.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: response_mode\n#OIDCResponseMode [fragment|query|form_post]\n\n# Only used for a single static provider has been configured, see below in OpenID Connect Provider.\n# Client identifier used in calls to the statically configured OpenID Connect Provider.\n#OIDCClientID <client_id>\n\n# Only used for a single static provider has been configured, see below in OpenID Connect Provider.\n# Client secret used in calls to the statically configured OpenID Connect Provider.\n# (not used/required in the Implicit Client Profile, i.e. when OIDCResponseType is \"id_token\")\n#OIDCClientSecret <client_secret>\n\n# Filename with the PEM-formatted client certificate used to authenticate the Client in calls to the\n# token endpoint of the OAuth 2.0 Authorization server.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: token_endpoint_tls_client_cert\n#OIDCClientTokenEndpointCert <filename>\n\n# Filename with the PEM-formatted private key that belongs to the client certificate used to authenticate the\n# Client in calls to the token endpoint of the OAuth 2.0 Authorization server.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: token_endpoint_tls_client_key\n#OIDCClientTokenEndpointKey <filename>\n\n# Password for the PEM-formatted private key that belongs to the client certificate used to authenticate the\n# Client in calls to the token endpoint of the OAuth 2.0 Authorization server.\n# If the value begins with exec: the resulting command will be executed and the\n# first line returned to standard output by the program will be used as the password.\n# The command may be absolute or relative to the web server root.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: token_endpoint_tls_client_key_pwd\n#OIDCClientTokenEndpointKeyPassword [ <passphrase> | \"exec:/path/to/otherProgram arg1\" ]\n\n# The client name that the client registers in dynamic registration with the OP.\n# When not defined, no client name will be sent with the registration request.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: client_name\n#OIDCClientName <client_name>\n\n# The contacts that the client registers in dynamic registration with the OP.\n# Must be formatted as e-mail addresses by specification.\n# Single value only; when not defined, no contact e-mail address will be sent with the registration request.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: client_contact\n#OIDCClientContact <contact>\n\n# The PKCE method used (this serves as default value for discovered OPs too)\n# When not defined PKCE is not used.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: pkce_method\n#OIDCPKCEMethod [plain|S256|referred_tb]\n\n# The OpenID Connect Bound Authentication policy used,\n# see: http://openid.net/specs/openid-connect-token-bound-authentication-1_0.html\n# \"disabled\": no referred token binding will be requested from the User Agent upon redirection to the OP\n# \"optional\": referred token binding will be requested, the \"cnf[\"tbh\"]\" claim is optional on return\n# \"required\": referred token binding will be requested, the \"cnf[\"tbh\"]\" claim must be present when the Client supports Token Binding\n# \"enforced\": referred token binding will be requested, the \"cnf[\"tbh\"]\" claim must be present and the User Agent must support Token Binding\n# When not defined the default is \"optional\".\n#OIDCTokenBindingPolicy [disabled|optional|required|enforced]\n\n# (used only in dynamic client registration)\n# Define the Client JWKs URL (e.g. https://localhost/protected/?jwks=rsa)\") that will be\n# used during client registration to point to the JWK set with public keys for this client.\n# If not defined the default <redirect_uri>?jwks=rsa will be used, on which a JWK set\n# is automatically published based on the OIDCPublicKeyFiles setting so normally you don't\n# need to touch this unless this client is on a (test) host that is not reachable from the internet.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: client_jwks_uri\n#OIDCClientJwksUri <url>\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to sign the id_token.\n# When not defined the default that the OP should use by spec is RS256.\n# (ES??? algorithms only supported when using OpenSSL >= 1.0)\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: id_token_signed_response_alg\n#OIDCIDTokenSignedResponseAlg [RS256|RS384|RS512|PS256|PS384|PS512|HS256|HS384|HS512|ES256|ES384|ES512]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to encrypt the Content Encryption Key that is used to encrypt the id_token.\n# When not defined the default (by spec) is that the OP does not encrypt the id_token.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: id_token_encrypted_response_alg\n#OIDCIDTokenEncryptedResponseAlg [RSA1_5|A128KW|A256KW|RSA-OAEP]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to encrypt to the id_token with the Content Encryption Key.\n# If OIDCIDTokenEncryptedResponseAlg is specified, the default for this value is A128CBC-HS256.\n# When OIDCIDTokenEncryptedResponseEnc is included, OIDCIDTokenEncryptedResponseAlg MUST also be provided.\n# (A256GCM algorithm only supported when using OpenSSL >= 1.0.1)\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: id_token_encrypted_response_enc\n#OIDCIDTokenEncryptedResponseEnc [A128CBC-HS256|A256CBC-HS512|A256GCM]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to sign the UserInfo response\n# When not defined the default (by spec) is that the OP does not sign the response.\n# (ES??? algorithms only supported when using OpenSSL >= 1.0)\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_signed_response_alg\n#OIDCUserInfoSignedResponseAlg RS256|RS384|RS512|PS256|PS384|PS512|HS256|HS384|HS512|ES256|ES384|ES512]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to encrypt the Content Encryption Key that is used to encrypt the UserInfo response.\n# When not defined the default (by spec) is that the OP does not encrypt the response.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_encrypted_response_alg\n#OIDCUserInfoEncryptedResponseAlg [RSA1_5|A128KW|A256KW|RSA-OAEP]\n\n# (used only in dynamic client registration)\n# The algorithm that the OP should use to encrypt to encrypt the UserInfo response with the Content Encryption Key\n# If OIDCUserInfoEncryptedResponseAlg is specified, the default for this value is A128CBC-HS256.\n# When OIDCUserInfoEncryptedResponseEnc is included, OIDCUserInfoEncryptedResponseAlg MUST also be provided.\n# (A256GCM algorithm only supported when using OpenSSL >= 1.0.1)\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: userinfo_encrypted_response_enc\n#OIDCUserInfoEncryptedResponseEnc [A128CBC-HS256|A256CBC-HS512|A256GCM]\n\n########################################################################################\n#\n# WARNING:\n#\n# THE OAUTH 2.0 RESOURCE SERVER FUNCTIONALITY IS DEPRECATED NOW AND SUPERSEDED\n# BY A SEPARATE MODULE, SEE: https://github.com/zmartzone/mod_oauth2\n#\n# OAuth 2.0 Resource Server Settings\n#\n# Used when this module functions as a Resource Server against an OAuth 2.0 Authorization\n# Server, introspecting/validating bearer Access Tokens.\n#\n########################################################################################\n\n# URL where Authorization Provider Provider metadata can be found (e.g. https://example.com/.well-known/oauth-authorization-server)\n# as defined in RFC 8414. The obtained metadata will be cached and refreshed every 24 hours.\n# If set, individual entries below will not have to be configured but can be used to add\n# extra entries/endpoints to settings obtained from the metadata.\n# If OIDCOAuthServerMetadataURL is not set, the endpoint entries below it will have to be configured.\n#OIDCOAuthServerMetadataURL <url>\n\n# (Mandatory when introspecting opaque access tokens, Optional when performing local JWT access token validation)\n# OAuth 2.0 Authorization Server token introspection endpoint (e.g. https://localhost:9031/as/token.oauth2)\n#OIDCOAuthIntrospectionEndpoint <token-introspection-endpoint>\n\n# Client identifier used in token introspection calls to the OAuth 2.0 Authorization server.\n#OIDCOAuthClientID <client_id>\n\n# Client secret used in token introspection calls to the OAuth 2.0 Authorization server.\n#OIDCOAuthClientSecret <client_secret>\n\n# Authentication method for the OAuth 2.0 Authorization Server introspection endpoint,\n# Used to authenticate the client to the introspection endpoint e.g. with a client_id/client_secret\n# when OIDCOAuthClientID and OIDCOAuthClientSecret have been set and \"client_secret_basic\" or \"client_secret_post\"\n# has been configured.\n# When \"private_key_jwt\" is used, OIDCPrivateKeyFiles and OIDCPublicKeyFiles must have been set.\n# When not defined \"client_secret_basic\" is used.\n#OIDCOAuthIntrospectionEndpointAuth [ client_secret_basic | client_secret_post | client_secret_jwt | private_key_jwt | bearer_access_token | none ]\n\n# Used when \"OIDCOAuthIntrospectionEndpointAuth bearer_access_token\" is configured.\n# Specifies a static token to be used for authorizing the call to the introspection endpoint.\n# If empty, the introspected token will be used for authorization as well.\n#OIDCOAuthIntrospectionClientAuthBearerToken [ a-static-bearer-token | ]\n\n# Filename that contains the PEM-formatted client certificate used to authenticate the\n# caller in token introspection calls to the OAuth 2.0 Authorization server.\n#OIDCOAuthIntrospectionEndpointCert <filename>\n\n# Filename that contains the PEM-formatted private key that belongs to the client certificate used\n# to authenticate the caller in token introspection calls to the OAuth 2.0 Authorization server.\n#OIDCOAuthIntrospectionEndpointKey <filename>\n\n# Define the HTTP method to use for the introspection call. Must be GET or POST.\n# When not defined the default is POST.\n#OIDCOAuthIntrospectionEndpointMethod [POST|GET]\n\n# Extra parameters that need to be passed in the POST request to the Introspection Endpoint.\n# Parameter names and values need to be provided in URL-encoded form.\n# When not defined no extra parameters will be passed.\n#OIDCOAuthIntrospectionEndpointParams <urlencoded-name1>=<urlencoded-value1>[&<urlencoded-nameN>=<urlencoded-valueN>]* \n\n# Name of the parameter whose value carries the access token value in an validation request to the token introspection endpoint.\n# When not defined the default \"token\" is used.\n#OIDCOAuthIntrospectionTokenParamName <param_name>\n\n# Defines the name of the claim that contains the token expiry timestamp, whether it is absolute (seconds since\n# 1970), relative (seconds from now after which the token will expire), and whether it is optional.\n# If the claim is optional and not found in the response, the introspection result will not be cached.\n# (which means that the overall performance may suffer)\n#\n# Only applies when the \"active\" claim is not found in the introspection response, which is interpreted as\n# an introspection method that does not conform to draft-ietf-oauth-introspection, but is custom.\n#\n# When not defined the default \"expires_in\" is used, the expiry is \"relative\" and mandatory, matching\n# Google and PingFederate's introspection behavior.\n#OIDCOAuthTokenExpiryClaim <claim-name> [absolute|relative] [mandatory|optional]\n\n# Define the interval in seconds after which a cached and introspected access token needs\n# to be refreshed by introspecting (and validating) it again against the Authorization Server.\n# (can be configured on a per-path basis)\n# When not defined the value is 0, which means it only expires after the `exp` (or alternative,\n# see OIDCOAuthTokenExpiryClaim) hint as returned by the Authorization Server.\n# When set to -1, caching of the introspection results is disabled and the token will be introspected\n# on each request presenting it.\n#OIDCOAuthTokenIntrospectionInterval <seconds>\n\n# Require a valid SSL server certificate when communicating with the Authorization Server\n# on the token introspection endpoint. When not defined, the default value is \"On\".\n#OIDCOAuthSSLValidateServer [On|Off]\n\n# The symmetric shared key(s) that can be used for local JWT access token validation.\n# NB: this is one or more key tuples where a key tuple consists of:\n#  plain|b64|hex#[<key-identifier>]#<key>\n# When not defined, no access token validation with shared keys will be performed.\n# Examples:\n# - a plaintext secret and a key identifier (kid)\n#     plain#1#mysecret\n# - a base64 encoded secret, no key identifier provided\n#     b64##AF515DE==\n# - a hex encoded secret, no key identifier provided\n#     hex##ede012\n#OIDCOAuthVerifySharedKeys ([plain|b64|hex#][<kid>#]<key>)+\n\n# The fully qualified names of the files that contain the X.509 certificates with the RSA public\n# keys that can be used for local JWT access token verification.\n# NB: this is one or more key tuples where a key tuple consists of:\n#  [<key-identifier>#]<path-to-cert>\n# and the key identifier part is required when the JWT access token contains a \"kid\" in its header.\n# When not defined, no access token validation with statically configured certificates will be performed.\n#OIDCOAuthVerifyCertFiles ([<kid>#]<filename>)+\n\n# The JWKs URL on which the Authorization Server publishes the keys used to sign its JWT access tokens.\n# When not defined local validation of JWTs can still be done using statically configured keys,\n# by setting OIDCOAuthVerifyCertFiles and/or OIDCOAuthVerifySharedKeys.\n#OIDCOAuthVerifyJwksUri <jwks_url>\n\n# The claim that is used when setting the REMOTE_USER variable on OAuth 2.0 protected paths.\n# When not defined the default \"sub\" is used.\n#\n# An optional regular expression can be added as a 2nd parameter that will be applied to the\n# claim value from the 1st parameter and the first match returned from that expression will\n# be set as the REMOTE_USER. E.g. to strip a domain from an e-mail style address you'd use ^(.*)@\n#\n# An optional 3rd parameter can be added that would contain string with number backrefrences.\n# Backrefrences must be in the form $1, $2.. etc.\n# E.g. to extract username in the form DOMAIN\\userid from e-mail style address you may use\n#   ^(.*)@([^.]+)\\..+$ $2\\\\$1\n#OIDCOAuthRemoteUserClaim <claim-name> [<regular-expression>] [substitution-string]\n\n# Define the way(s) in which bearer OAuth 2.0 access tokens can be passed to this Resource Server.\n# Must be one or several of:\n# \"header\" : an \"Authorization: bearer\" header\n# \"post\" :   an HTTP Post parameter called \"access_token\"\n# \"query\" :  as an HTTP query parameter called \"access_token\"\n# \"cookie\" : as a cookie header called \"PA.global\" or using the name specified after \":\"\n# \"basic\":   as a HTTP Basic Auth (RFC2617, section 2) password, with any username\n# When not defined the default \"header\" is used.\n#OIDCOAuthAcceptTokenAs [header|post|query|cookie[:<cookie-name>|basic]+\n\n# The Token Binding policy used for OAuth 2.0 Access Tokens\n# see: https://tools.ietf.org/html/draft-ietf-oauth-token-binding\n# \"disabled\": no token binding ID will be verified in the access token, present or not\n# \"optional\": the \"cnf[\"tbh\"]\" claim is optional in the introspection result or the JWT access token, if it is present it will be verified\n# \"required\": the \"cnf[\"tbh\"]\" claim must be present when the Client supports Token Binding\n# \"enforced\": the \"cnf[\"tbh\"]\" claim must be present and the Client must support Token Binding\n# When not defined the default is \"optional\".\n#OIDCOAuthAccessTokenBindingPolicy [disabled|optional|required|enforced]\n\n\n########################################################################################\n#\n# Cookie Settings\n#\n########################################################################################\n\n# Define the cookie path for the \"state\" and \"session\" cookies.\n# When not defined the default is a server-wide \"/\".\n#OIDCCookiePath <cookie-path>\n\n# Specify the domain for which the \"state\" and \"session\" cookies will be set.\n# This must match the OIDCRedirectURI and the URL on which you host your protected\n# application. When using a relative OIDCRedirectURI this setting should most probably empty.\n# When not defined the default is the server hostname that is currently accessed.\n#OIDCCookieDomain <cookie-domain>\n\n# Define the cookie name for the session cookie.\n# When not defined the default is \"mod_auth_openidc_session\".\n#OIDCCookie <cookie-name>\n\n# OpenID Connect session cookie chunk size.\n# When using \"OIDCSessionType client-cookie\" the session cookie may become quite large if a lot of session\n# data needs to be stored, typically the size depends on the \"scopes\" of information you request. To work\n# around cookie size limitations for most web browsers (usually 4096 bytes), the \"client-cookie\" will be split\n# over a number of \"chunked\" cookies if the resulting session data is over a certain number of bytes, \n# If you want to prevent splitting the session cookie regardless of its size, set the value to 0.\n# When not defined the default chunk size is 4000 bytes\n#OIDCSessionCookieChunkSize 4000\n\n# Defines whether the HttpOnly flag will be set on cookies.\n# When not defined the default is On.\n#OIDCCookieHTTPOnly [On|Off]\n\n# Defines whether the SameSite flag will be set on cookies.\n# When On the following will apply:\n#   state cookie: Lax\n#   session cookie: first time set Lax, updates (e.g. after inactivity timeout) Strict\n#   x_csrf discovery: Strict:\n#\n# The default `SameSite=None` cookie appendix on `Set-Cookie` response headers can be \n# conditionally overridden using an environment variable in the Apache config as in:\n#   SetEnvIf User-Agent \".*IOS.*\" OIDC_SET_COOKIE_APPEND=;\n# (since version 2.4.1)\n#\n# When not defined the default is Off.\n#OIDCCookieSameSite [On|Off]\n\n# Specify the names of cookies to pickup from the browser and send along on backchannel\n# calls to the OP and AS endpoints. This can be used for load-balancing purposes.\n# When not defined, no such cookies are sent.\n#OIDCPassCookies [<cookie-name>]+\n\n# Specify the names of cookies to strip from the incoming request so they are not passed\n# on to the target application(s). This may prevent a large set of chunked session cookies to\n# be sent to the backend. In that case you'd set it to (when using the default OIDCCookie setting):\n#   mod_auth_openidc_session mod_auth_openidc_session_chunks mod_auth_openidc_session_0 mod_auth_openidc_session_1 \n# When not defined, no cookies are stripped.\n#OIDCStripCookies [<cookie-name>]+\n\n# Specify the maximum number of state cookies i.e. the maximum number of parallel outstanding\n# authentication requests. See: https://github.com/zmartzone/mod_auth_openidc/issues/331\n# Setting this to 0 means unlimited, until the browser or server gives up which is the\n# behavior of mod_auth_openidc < 2.3.8, which did not have this configuration option. \n#\n# The optional second boolean parameter if the oldest state cookie(s) will be deleted, \n# even if still valid; see #399.\n#\n# When not defined, the default is 7 and \"false\", thus the oldest cookie(s) will not be deleted.\n#OIDCStateMaxNumberOfCookies <number> [false|true]\n\n# Define the cookie prefix for the state cookie.\n# When not defined the default is \"mod_auth_openidc_state_\".\n#OIDCStateCookiePrefix <cookie-prefix>\n\n########################################################################################\n#\n# Session Settings (only relevant in an OpenID Connect Relying Party setup)\n#\n########################################################################################\n\n# Interval in seconds after which the session will be invalidated when no interaction has occurred.\n# When not defined, the default is 300 seconds.\n#OIDCSessionInactivityTimeout <seconds>\n\n# Maximum duration of the application session\n# When not defined the default is 8 hours (3600 * 8 seconds).\n# When set to 0, the session duration will be set equal to the expiry time of the ID token.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: session_max_duration\n#OIDCSessionMaxDuration <seconds>\n\n# OpenID Connect session storage type.\n# \"server-cache\" server-side caching storage.\n# \"client-cookie\" uses browser-side sessions stored in a cookie; see also OIDCSessionCookieChunkSize next\n# A suffix \":persistent\" can be added if you want to use a persistent cookie that survives browser restarts\n# instead of a session cookie that is tied to the lifetime of the browser session.\n# The \"expires\" value of the persistent cookie is controlled by the OIDCSessionInactivityTimeout setting.\n# When not defined the default \"server-cache\" is used.\n#OIDCSessionType server-cache[:persistent]|client-cookie[:persistent]\n\n# Fallback to \"OIDCSessionType client-cookie\" when \"OIDCSessionType server-cache\" is set and the primary\n# cache mechanism (e.g. memcache or redis) fails. Note that this will come at a cost of:\n#   a) performance\n#       1) since on each subsequent request the primary cache will still be polled and\n#           failback will happen as soon as the primary cache is available again\n#       2) information other than sessions cannot be cached, e.g. resolved access tokens or metadata; see: OIDCCacheType\n#   b) security, since nonce's and jti's are not cached, see: OIDCCacheType\n#   c) (prototype) functionality, since request_uri's won't work anymore\n# When not defined the default is \"Off\".\n#OIDCSessionCacheFallbackToCookie [On|Off]\n\n########################################################################################\n#\n# Cache Settings\n#\n########################################################################################\n\n# Cache type, used for temporary storage that is shared across Apache processes/servers for:\n#  a) session state\n#  b) nonce values to prevent replay attacks\n#  c) validated OAuth 2.0 tokens\n#  d) JWK sets that have been retrieved from jwk_uri's\n#  e) resolved OP metadata when using OIDCProviderMetadataUrl\n#  f) temporary state associated with Request URI's\n# must be one of \\\"shm\\\", \\\"memcache\\\", \\\"file\\\" or, if Redis support is compiled in, \\\"redis\\\" \n# When not defined, \"shm\" (shared memory) is used.\n#OIDCCacheType [shm|memcache|file[|redis]]\n\n# Indicate whether data in the cache backend should be encrypted.\n# When not defined the default is \"Off\" for the \"shm\" backend and \"On\" for all other cache backends\n#OIDCCacheEncrypt [On|Off]\n\n# When using OIDCCacheType \"shm\":\n# Specifies the maximum number of name/value pair entries that can be cached.\n# When caching a large number of entries the cache size limit may be reached and the\n# least recently used entry will be overwritten. If this happens within 1 hour, \n# errors will be displayed in the error.log and the OIDCCacheShmMax value may be increased.\n# When not specified, a default of 500 entries is used.\n# OIDCCacheShmMax <number>\n\n# When using OIDCCacheType \"shm\":\n# Specifies the maximum size for a single cache entry in bytes with a minimum of 8464 bytes.\n# When caching large values such as numbers of attributes in a session or large metadata documents the \n# entry size limit may be overrun, in which case errors will be displayed in the error.log\n# and the OIDCCacheShmEntrySizeMax value has to be increased.\n# When not specified, a default entry size of 16913 bytes (16384 value + 512 key + 17 overhead) is used.\n# OIDCCacheShmEntrySizeMax <bytes>\n\n# When using OIDCCacheType \"file\":\n# Directory that holds cache files; must be writable for the Apache process/user.\n# When not specified a system defined temporary directory (/tmp) will be used.\n#OIDCCacheDir /var/cache/apache2/mod_auth_openidc/cache\n\n# When using OIDCCacheType \"file\":\n# Cache file clean interval in seconds (only triggered on writes).\n# When not specified a default of 60 seconds is used.\n# OIDCCacheFileCleanInterval <seconds>\n\n# Required when using OIDCCacheType \"memcache\":\n# Specifies the memcache servers used for caching as a space separated list of <hostname>[:<port>] tuples.\n#OIDCMemCacheServers \"(<hostname>[:<port>])+\"\n\n# Required if Redis support is compiled in and when using OIDCCacheType \"redis\":\n# Specifies the Redis server used for caching as a <hostname>[:<port>] tuple.\n#OIDCRedisCacheServer <hostname>[:<port>]\n\n# Password to be used if the Redis server requires authentication: http://redis.io/commands/auth\n# When not specified, no authentication is performed.\n#OIDCRedisCachePassword <password>\n\n# Logical database to select on the Redis server: https://redis.io/commands/select\n# When not defined the default database 0 is used.\n#OIDCRedisCacheDatabase <number>\n\n# Timeout for connecting to the Redis servers.\n# When not defined the default connect timeout is 5 seconds.\n#OIDCRedisCacheConnectTimeout <seconds>\n\n# Timeout waiting for a response of the Redis servers after a request was sent.\n# When not defined the default timeout is 5 seconds.\n#OIDCRedisCacheTimeout <seconds>\n\n########################################################################################\n#\n# Advanced Settings\n#\n########################################################################################\n\n# Defines an external OP Discovery page. That page will be called with:\n#    <discovery-url>?oidc_callback=<callback-url>\n# additional parameters may be added, a.o. `target_link_uri`, `x_csrf` and `method`.\n#\n# An Issuer selection can be passed back to the callback URL as in:\n#    <callback-url>?iss=[${issuer}|${domain}|${e-mail-style-account-name}][parameters][&login_hint=<login-hint>][&scopes=<scopes>][&auth_request_params=<params>]\n# where the <iss> parameter contains the URL-encoded issuer value of\n# the selected Provider, or a URL-encoded account name for OpenID\n# Connect Discovery purposes (aka. e-mail style identifier), or a domain name.\n# [parameters] contains the additional parameters that were passed in on the discovery request (e.g. target_link_uri=<url>&x_csrf=<x_csrf>&method=<method>&scopes=<scopes>)\n#\n# When not defined the bare-bones internal OP Discovery page is used.\n#OIDCDiscoverURL <discovery-url>\n\n# Template used to display error messages.\n# The template must be prepared to take two strings, an error title and a more details error description,\n# both HTML encoded values, in that order and referenced by (C-style) \"%s\", e.g. <p>Message:%s</p><p>Description:%s</p>.\n# A minimal example that posts error+detail to another webpage:\n# <html><body onload=\"document.forms[0].submit()\">\n#    <form method=\"post\" action=\"http://example.org/error\">\n#      <input name=\"error\" value=\"%s\">\n#      <input name=\"description\" value=\"%s\">\n#    </form>\n#  </body></html>\n# When not defined a bare-bones internal template is used.\n#OIDCHTMLErrorTemplate <filename>\n\n# Defines a default URL to be used in case of 3rd-party-init-SSO when no explicit target_link_uri\n# has been provided. The user is also redirected to this URL in case an invalid authorization\n# response was received.\n#\n# By default, when no OIDCDefaultURL is set, an expired state cookie will lead to an HTML error page\n# being sent to the browser explaining what happened. To copy that (legacy) behaviour when OIDCDefaultURL is set,\n# so that the browser is no longer redirected to the OIDCDefaultURL in case of state cookie expiry, use:\n#   SetEnvIfExpr true OIDC_NO_DEFAULT_URL_ON_STATE_TIMEOUT=true \n#\n# The default is to not redirect the browser to any URL but return an HTTP/HTML error to the user.\n#OIDCDefaultURL <default-url>\n\n# Defines a default URL where the user is sent to after logout, which may be overridden explicitly during logout.\n# When not defined and no URL was passed explicitly, a default internal page will be shown.\n#OIDCDefaultLoggedOutURL <url>\n\n# Define the OpenID Connect scope(s) that is requested from the OP (eg. \"admin edit\")\n# on a per-path basis in addition to the per-provider configured scopes (OIDCScope).\n# NB: multiple scope values must be enclosed in a single pair of double quotes \n#OIDCPathScope \"<scope(s)-separated-by-spaces-and-enclosed-in-double-quotes>\"\n\n# Extra parameters that will be sent along with the Authorization Request.\n# These must be URL-query-encoded as in: \"display=popup&prompt=consent\".\n#\n# NB: since version 2.3.0 this can be configured on a per-path basis across all configured Providers.\n#\n# Since version 2.3.11rc1 one can pass on query parameters from the request to the authorization\n# request by adding e.g. \"foo=#\" which which will dynamically pull in the query parameter value\n# from the request query parameter and add it to the authentication request to the OP.\n#\n# The default is to not add extra parameters.\n#OIDCPathAuthRequestParams <query-encoded-string>\n\n# Acceptable offset (before and after) for checking the \\\"iat\\\" (= issued at) timestamp in the id_token.\n# When not defined the default is 600 seconds.\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: idtoken_iat_slack\n#OIDCIDTokenIatSlack <seconds>\n\n# The prefix to use when setting claims (openid-connect or oauth20) in the HTTP headers/environment variables.\n# This prefix should not be set to \"\" except when combined with OIDCWhiteListedClaims to maintain a secure setup.\n# When not defined, the default \"OIDC_CLAIM_\" is used.\n#OIDCClaimPrefix <prefix>\n\n# The delimiter to use when setting multi-valued claims (openid-connect or oauth20) in the HTTP headers/environment variables.\n# When not defined the default \",\" is used.\n#OIDCClaimDelimiter <char>\n\n# The claim that is used when setting the REMOTE_USER variable on OpenID Connect protected paths.\n# If the claim name is postfixed with a \\\"@\\\", the claim value will be post-fixed with the\n# \\\"iss\\\" value value (with leading \"https://\" stripped) to make this value unique across different OPs.\n# When not defined the default \"sub@\" is used.\n#\n# An optional regular expression can be added as a 2nd parameter that will be applied to the\n# resulting value from the 1st parameter and the first match returned from that expression will\n# be set as the REMOTE_USER. E.g. to strip a domain from an e-mail style address you'd use ^(.*)@\n#\n# An optional 3rd parameter can be added that would contain string with number backrefrences.\n# Backrefrences must be in the form $1, $2.. etc.\n# E.g. to extract username in the form DOMAIN\\userid from e-mail style address you may use\n#  ^(.*)@([^.]+)\\..+$ $2\\\\$1\n#OIDCRemoteUserClaim <claim-name>[@] [<regular-expression>] [substitution-string]\n\n# Define the way(s) in which the id_token contents are passed to the application according to OIDCPassClaimsAs.\n# Must be one or several of:\n# \"claims\" :     the claims in the id_token are passed in individual headers/environment variables\n# \"payload\" :    the payload of the id_token is passed as a JSON object in the \"OIDC_id_token_payload\" header/environment variable\n# \"serialized\" : the complete id_token is passed in compact serialized format in the \"OIDC_id_token\" header/environment variable\n# Note that when OIDCSessionType client-cookie is set, the id_token itself is not stored in the session/cookie and as such\n# the headers for the \"payload\" and \"serialized\" option will not be created.\n# When not defined the default \"claims\" is used.\n#OIDCPassIDTokenAs [claims|payload|serialized]+\n\n# Define the way(s) in which the claims resolved from the userinfo endpoint are passed to the application according to OIDCPassClaimsAs.\n# Must be one or several of:\n# \"claims\" :     the userinfo claims are passed in individual headers/environment variables\n# \"json\" :       a self-contained userinfo JSON object is passed in the \"OIDC_userinfo_json\" header/environment variable\n# \"jwt\" :        a signed/encrypted JWT (if available!) optionally resolved from the userinfo endpoint is passed in the \"OIDC_userinfo_jwt\" header/environment variable\n# When not defined the default \"claims\" is used.\n#OIDCPassUserInfoAs [claims|json|jwt]+\n\n# Define the way in which the claims and tokens are passed to the application environment:\n# \"none\": no claims/tokens are passed\n# \"environment\": claims/tokens are passed as environment variables\n# \"headers\": claims/tokens are passed in headers (also useful in reverse proxy scenario's)\n# \"both\": claims/tokens are passed as both headers as well as environment variables (default)\n#\n# Since version 2.4.6 one can specify \"base64url\" as the 2nd argument to apply base64url encoding to\n# all values passed in headers.\n#\n# When not defined the default is \"both\" and base64url encoding is not applied to the header values.\n#\n# The access token is passed in OIDC_access_token; the access token expiry is passed in OIDC_access_token_expires.\n# The refresh token is only passed in OIDC_refresh_token if enabled for that specific directory/location (see: OIDCPassRefreshToken)\n#OIDCPassClaimsAs [none|headers|environment|both] [base64url]\n\n# Specify the HTTP header variable name to set with the name of the authenticated user,\n# i.e. copy what is set in REMOTE_USER and configured in OIDCRemoteUserClaim or OIDCOAuthRemoteUserClaim.\n# When not defined no such header is added.\n# This setting can be configured for both the \"openid-connect\" and \"oauth20\" AuthType on\n# a server-wide or directory level.\n#OIDCAuthNHeader <header-name>\n\n# Timeout in seconds for long duration HTTP calls. This is used for most requests to remote endpoints/servers.\n# When not defined the default of 60 seconds is used.\n#OIDCHTTPTimeoutLong <seconds>\n\n# Timeout in seconds for short duration HTTP calls; used for Client Registration and OP Discovery requests.\n# When not defined the default of 5 seconds is used.\n#OIDCHTTPTimeoutShort <seconds>\n\n# Time to live in seconds for state parameter i.e. the interval in which the authorization request\n# and the corresponding response need to be processed. When not defined the default of 300 seconds is used.\n#OIDCStateTimeout <seconds>\n\n# Scrub user name and claim headers (as configured above) from the user's request.\n# The default is \"On\"; use \"Off\" only for testing and debugging because it renders your system insecure.\n#OIDCScrubRequestHeaders [On|Off] \n\n# Specify an outgoing proxy for your network.\n# When not defined no outgoing proxy is used.\n#OIDCOutgoingProxy <host>[:<port>]\n\n# Defines the action to be taken when an unauthenticated request is made.\n#\n# \"auth\" means that the user is redirected to the OpenID Connect Provider or Discovery page.\n# \"401\" means that HTTP 401 Unauthorized is returned.\n# \"407\" means that HTTP 407 Proxy Authentication Required is returned\n# \"410\" means that HTTP 410 Gone is returned\n# \"pass\" means that an unauthenticated request will pass but claims will still be passed when a user happens to be authenticated already\n#\n# Useful in Location/Directory/Proxy path contexts that serve AJAX/Javascript calls and for \"anonymous access\"\n#\n# When not defined the default is \"auth\" with auto-detection of XML HTTP requests, which would get \"401\".\n# The default auto-detection algorithm looks for the \"X-Requested-With: XMLHttpRequest\" header/value,\n# and/or the absence of \"Accept\" header with any of the values \"text/html\" \"application/xhtml+xml\" or \"*/*\"\n# and returns 401 for such non-browser/non-html clients. See: https://github.com/zmartzone/mod_auth_openidc/wiki/Cookies#tldr\n# \n# Only for Apache >= 2.4.x:\n# Since verson 2.4.4 a boolean Apache expression as the second parameter to specify which requests\n# need to match to return the configured value in the first parameter to override the default \"auth\".\n# See also: https://httpd.apache.org/docs/2.4/expr.html.\n# E.g.:\n#   OIDCUnAuthAction 401 \"%{HTTP_USER_AGENT} =~ /curl/\"\n# to return 401 for cURL based user agents and \"auth\" for any other browsers/user agents.\n#   OIDCUnAuthAction 401 \"%{HTTP:X-Requested-With} == 'XMLHttpRequest'\"\n# to effectively override the default XML request detection algorithm by ignoring the Accept headers\n#   OIDCUnAuthAction 401 \"%{HTTP_ACCEPT} !~ m#text/html#\"\n# to return 401 for all user agents that do not send an Accept header that includes a \"text/html\" value\n#   OIDCUnAuthAction 401 \"%{HTTP:X-Requested-With} == 'XMLHttpRequest' || ( ( %{HTTP_ACCEPT} !~ m#text/html# ) && ( %{HTTP_ACCEPT} !~ m#application/xhtml\\+xml# ) && ( %{HTTP_ACCEPT} !~ m#\\*/\\*# ) )\"\n# just as a more complex example, it equals the default XML request detection algorithm\n#   OIDCUnAuthAction auth true\n# To disable auto-detection of XML HTTP request altogether and uncondtionally return \"auth\" for all clients.\n# Note that actually *any* expression value in \"OIDCUnAuthAction auth <expr>\" will *always* render \"auth\"\n# (even when set to \"false\"...) because of the default, so using an <expr> value (other than \"true\") only\n# makes sense in combination with one of the values other than \"auth\".\n#OIDCUnAuthAction [auth|pass|401|407|410] [<expr>]\n\n# Defines the action to be taken when an unauthorized request is made i.e. the user is authenticated but\n# does not meet the `Require claim *:*` directives or similar.\n# \"401\" means that HTTP 401 Unauthorized is returned.\n# \"403\" means that HTTP 403 Forbidded is returned: NB: for Apache 2.4 this is controlled by the AuthzSendForbiddenOnFailure directive!\n# \"auth\" means that the user is redirected to the OpenID Connect Provider or Discovery page.\n# Useful in Location/Directory/Proxy path contexts that need to do stepup authentication\n# When not defined the default \"401\" is used.\n#OIDCUnAutzAction [401|403|auth]\n\n# Indicates whether POST data will be preserved across authentication requests (and discovery in case of multiple OPs).\n# This is designed to prevent data loss when a session timeout occurs in a (long) user filled HTML form.\n# It cannot handle arbitrary payloads for security (DOS) reasons, merely form-encoded user data.\n# Preservation is done via HTML 5 local storage: note that this can lead to private data exposure on shared terminals.\n# The default is \"Off\" (for security reasons). Can be configured on a per Directory/Location basis.\n#OIDCPreservePost [On|Off]\n\n# Indicates whether the refresh token will be passed to the application in a header/environment variable, according\n# to the OIDCPassClaimsAs directive.\n# Can be configured on a per Directory/Location basis. The default is \"Off\". \n#OIDCPassRefreshToken [On|Off]\n\n# Request Object/URI settings expressed as a string that is a \"double-quote-escaped\" JSON object. For example:\n# \"{ \\\"copy_from_request\\\": [ \\\"claims\\\", \\\"response_type\\\", \\\"response_mode\\\", \\\"login_hint\\\", \\\"id_token_hint\\\", \\\"nonce\\\", \\\"state\\\", \\\"redirect_uri\\\", \\\"scope\\\", \\\"client_id\\\" ], \\\"static\\\": { \\\"some\\\": \\\"value\\\", \\\"some_nested\\\": { \\\"some_array\\\": [ 1,2,3] } }, \\\"crypto\\\": { \\\"sign_alg\\\": \\\"HS256\\\", \\\"crypt_alg\\\": \\\"A256KW\\\", \\\"crypt_enc\\\": \\\"A256CBC-HS512\\\" }, \\\"url\\\": \\\"https://www.zmartzone.eu/protected/\\\", \\\"request_object_type\\\" : \\\"request\\\" }\"\n# Parameters:\n#   copy_from_request (array)            : array of query parameter names copied from request\n#   copy_and_remove_from_request (array) : array of parameter names copied from request and removed as query parameter\n#   static (object)                      : parameter value is merged to the request object\n#   crypto (object)                      : defines cryptography used to create request object\n#     sign_alg (string)                  : algorithm used to sign request object (JWS alg parameter)\n#     crypt_alg (string)                 : algorithm used to encrypt CEK of request object (JWE alg parameter)\n#     crypt_enc (string)                 : algorithm used to encrypt request object (JWE enc parameter)\n#   url (string)                         : use this url instead of redirect_uri for request_uri\n#   request_object_type (string)         : parameter used for sending authorization request object\n#                                          \"request_uri\" (default) or \"request\"\n# NB: this can be overridden on a per-OP basis in the .conf file using the key: request_object\n#OIDCRequestObject <stringified-and-double-quote-escaped-JSON-object>\n\n# Provider metadata refresh interval for the metadata in a multi-provider setup (with OIDCMetadataDir).\n# When not defined the default is 0 seconds, i.e. it is never refreshed.\n# Also used in a single provider setup with OIDCProviderMetadatURL but 0 then means the default of 1 day.\n#OIDCProviderMetadataRefreshInterval <seconds>\n\n# Define the data that will be returned upon calling the info hook.\n# The data can be JSON formatted using <redirect_uri>?info=json, or HTML formatted, using <redirect_uri>?info=html.\n#   iat (int)                  : Unix timestamp indicating when this data was created\n#   access_token (string)      : the access token\n#   access_token_expires (int) : the Unix timestamp which is a hint about when the access token will expire (as indicated by the OP)\n#   id_token (object)          : the claims presented in the ID token\n#   userinfo (object)          : the claims resolved from the UserInfo endpoint\n#   refresh_token (string)     : the refresh token (if returned by the OP)\n#   exp (int)                  : the maximum session lifetime (Unix timestamp in seconds)\n#   timeout (int)              : the session inactivity timeout (Unix timestamp in seconds)\n#   remote_user (string)       : the remote user name\n#   session (object)           : (for debugging) mod_auth_openidc specific session data such as \"remote user\", \"session expiry\", \"session id\" and a \"state\" object\n# Note that when using ProxyPass / you may have to add a proxy exception for the Redirect URI \n# for this to work, e.g. ProxyPass /redirect_uri !\n# When not defined the session hook will not return any data but a HTTP 404\n#OIDCInfoHook [iat|access_token|access_token_expires|id_token|userinfo|refresh_token|exp|timeout|remote_user|session]+\n\n# Specify claims that should be removed from the userinfo and/or id_token before storing them in the session.\n# Note that OIDCBlackListedClaims takes precedence over OIDCWhiteListedClaims\n# When not defined no claims are blacklisted and all claims are stored except when OIDCWhiteListedClaims is used.\n#OIDCBlackListedClaims [<claim>]+\n\n# Specify claims from the userinfo and/or id_token that should be stored in the session (all other claims will be discarded).\n# Note that OIDCBlackListedClaims takes precedence over OIDCWhiteListedClaims\n# When not defined no claims are whitelisted and all claims are stored except when blacklisted with OIDCBlackListedClaims.\n#OIDCWhiteListedClaims [<claim>]+\n\n# Specify the minimum time-to-live for the access token stored in the OIDC session.\n# When the access token expiry timestamp (or at tleast the hint given to that) is less than this value,\n# an attempt will be made to refresh the access token using the refresh token grant type with the OP.\n# This only has effect if a refresh token was actually returned from the OP and an \"expires_in\" hint\n# was returned as part of the authorization response (and subsequent refresh token responses).\n# When not defined no attempt is made to refresh the access token (unless implicitly with OIDCUserInfoRefreshInterval)\n# The optional logout_on_error flag makes the refresh logout the current local session if the refresh fails.\n#OIDCRefreshAccessTokenBeforeExpiry <seconds> [logout_on_error]\n\n# Defines whether the value of the User-Agent and X-Forwarded-For headers will be used as the input\n# for calculating the fingerprint of the state during authentication.\n# When not defined the default \"both\" is used.\n#OIDCStateInputHeaders [none|user-agent|x-forwarded-for|both]\n\n# Define one or more regular expressions that specify URLs (or domains) allowed for post logout and\n# other redirects such as the \"return_to\" value on refresh token requests, the \"login_uri\" value\n# on session management based logins through the OP iframe, and the \"target_link_uri\" parameter in\n# 3rd-party initiated logins, e.g.:\n#   OIDCRedirectURLsAllowed ^https://www.example.com ^https://(\\w+).example.org ^https://example.net/app\n# or:\n#   OIDCRedirectURLsAllowed ^https://www.example.com/logout$ ^https://www.example.com/app/return_to$ \n# When not defined, the default is to match the hostname in the URL redirected to against\n# the hostname in the current request.\n#OIDCRedirectURLsAllowed [<regexp>]+\n", "AC_INIT([mod_auth_openidc],[2.4.9.4],[hans.zandbelt@zmartzone.eu])\n\nAC_SUBST(NAMEVER, AC_PACKAGE_TARNAME()-AC_PACKAGE_VERSION())\n\n# This section defines the --with-apxs2 option.\nAC_ARG_WITH(\n\t[apxs2],\n\t[  --with-apxs2=PATH       Full path to the apxs2 executable.],\n\t[\n\t\tAPXS2=${withval}\n\t],)\n\n\nif test \"x$APXS2\" = \"x\"; then\n   # The user didn't specify the --with-apxs2-option.\n\n   # Search for apxs2 in the specified directories\n   AC_PATH_PROG(APXS2, apxs2,,\n\t\t/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin)\n\n   if test \"x$APXS2\" = \"x\"; then\n      # Didn't find apxs2 in any of the specified directories.\n      # Search for apxs instead.\n      AC_PATH_PROG(APXS2, apxs,,\n\t\t   /usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin)\n   fi\n\nfi\n\n# Test if $APXS2 exists and is an executable.\nif test ! -x \"$APXS2\"; then\n   # $APXS2 isn't a executable file.\n   AC_MSG_ERROR([\nCould not find apxs2. Please specify the path to apxs2\nusing the --with-apxs2=/full/path/to/apxs2 option.\nThe executable may also be named 'apxs'.\n])\nfi\n\n# Replace any occurrences of @APXS2@ with the value of $APXS2 in the Makefile.\nAC_SUBST(APXS2)\n\n# Use environment variable APXS2_OPTS to pass params to APXS2 command\nAC_ARG_VAR(APXS2_OPTS, [Additional command line options to pass to apxs2.])\n\n# We need the curl library for HTTP callouts.\nPKG_CHECK_MODULES(CURL, libcurl)\nAC_SUBST(CURL_CFLAGS)\nAC_SUBST(CURL_LIBS)\n\n# We need OpenSSL for crypto and HTTPS callouts.\nPKG_CHECK_MODULES(OPENSSL, openssl)\nAC_SUBST(OPENSSL_CFLAGS)\nAC_SUBST(OPENSSL_LIBS)\n\nPKG_CHECK_MODULES(APR, [apr-1, apr-util-1])\nAC_SUBST(APR_CFLAGS)\nAC_SUBST(APR_LIBS)\n\n# older versions of libapr may not have memcache support\nold_CPPFLAGS=$CPPFLAGS\nCPPFLAGS=\"${APR_CFLAGS} $CPPFLAGS\"\nAC_CHECK_HEADERS([apr_memcache.h], [HAVE_MEMCACHE=1], [HAVE_MEMCACHE=0])\nAC_SUBST(HAVE_MEMCACHE)\nCPPFLAGS=$old_CPPFLAGS\n\n# We need Jansson for JSON parsing.\nPKG_CHECK_MODULES(JANSSON, jansson)\nAC_SUBST(JANSSON_CFLAGS)\nAC_SUBST(JANSSON_LIBS)\n\n# cjose\nPKG_CHECK_MODULES(CJOSE, cjose)\nAC_SUBST(CJOSE_CFLAGS)\nAC_SUBST(CJOSE_LIBS)\n\n# PCRE\nPKG_CHECK_MODULES(PCRE, libpcre)\nAC_SUBST(PCRE_CFLAGS)\nAC_SUBST(PCRE_LIBS)\n\n# Redis\nAC_ARG_WITH([hiredis],\n  [AS_HELP_STRING([--with-hiredis],\n    [support Redis @<:@default=check@:>@])],\n  [],\n  [with_hiredis=yes])\nAS_CASE([\"$with_hiredis\"],\n  [yes], [if test \"$HIREDIS_LIBS\" == \"\"; then PKG_CHECK_MODULES([HIREDIS], [hiredis], [HAVE_LIBHIREDIS=1], [HAVE_LIBHIREDIS=0]) ; else [HAVE_LIBHIREDIS=1] ; fi],\n  [no], [HAVE_LIBHIREDIS=0],\n  [PKG_CHECK_MODULES([HIREDIS], [hiredis], [HAVE_LIBHIREDIS=1], [HAVE_LIBHIREDIS=0])])\nAC_SUBST(HAVE_LIBHIREDIS)\nAC_SUBST(HIREDIS_CFLAGS)\nAC_SUBST(HIREDIS_LIBS)\n\n# JQ\nHAVE_LIBJQ=0\n\nAC_ARG_WITH(jq,\n        [  --with-jq=PATH          location of your libjq installation])\n    \nif test -n \"$with_jq\"\nthen\n    JQ_CFLAGS=\"-I$with_jq/include\"\n    JQ_LIBS=\"-L$with_jq/lib -ljq\"\n\n\tCPPFLAGS=\"$JQ_CFLAGS $CPPFLAGS\"\n\tAC_CHECK_HEADERS([jq.h], , [HAVE_LIBJQ=0])\n\n\tLDFLAGS=\"$JQ_LIBS $LDFLAGS\"\n\tAC_CHECK_LIB([jq], [jq_init], [HAVE_LIBJQ=1], [HAVE_LIBJQ=0])\n\tif test \"x$have_jq\" = \"x0\" ; then\n  \t\tAC_MSG_WARN(\"cannot find library for -ljq.\")\n\tfi\nfi\n\nAC_SUBST(HAVE_LIBJQ)\nAC_SUBST(JQ_CFLAGS)\nAC_SUBST(JQ_LIBS)\n\n# Create Makefile from Makefile.in\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/***************************************************************************\n * Copyright (C) 2017-2021 ZmartZone Holding BV\n * Copyright (C) 2013-2017 Ping Identity Corporation\n * All rights reserved.\n *\n * DISCLAIMER OF WARRANTIES:\n *\n * THE SOFTWARE PROVIDED HEREUNDER IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT\n * ANY WARRANTIES OR REPRESENTATIONS EXPRESS, IMPLIED OR STATUTORY; INCLUDING,\n * WITHOUT LIMITATION, WARRANTIES OF QUALITY, PERFORMANCE, NONINFRINGEMENT,\n * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  NOR ARE THERE ANY\n * WARRANTIES CREATED BY A COURSE OR DEALING, COURSE OF PERFORMANCE OR TRADE\n * USAGE.  FURTHERMORE, THERE ARE NO WARRANTIES THAT THE SOFTWARE WILL MEET\n * YOUR NEEDS OR BE FREE FROM ERRORS, OR THAT THE OPERATION OF THE SOFTWARE\n * WILL BE UNINTERRUPTED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Initially based on mod_auth_cas.c:\n * https://github.com/Jasig/mod_auth_cas\n *\n * Other code copied/borrowed/adapted:\n * shared memory caching: mod_auth_mellon\n *\n * @Author: Hans Zandbelt - hans.zandbelt@zmartzone.eu\n *\n **************************************************************************/\n\n#include \"apr_hash.h\"\n#include \"apr_strings.h\"\n#include \"ap_config.h\"\n#include \"ap_provider.h\"\n#include \"apr_lib.h\"\n#include \"apr_file_io.h\"\n#include \"apr_sha1.h\"\n#include \"apr_base64.h\"\n\n#include \"httpd.h\"\n#include \"http_core.h\"\n#include \"http_config.h\"\n#include \"http_log.h\"\n#include \"http_protocol.h\"\n#include \"http_request.h\"\n\n#include \"mod_auth_openidc.h\"\n\n#define OIDC_REFRESH_ERROR 2\n\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url);\n\n// TODO:\n// - sort out oidc_cfg vs. oidc_dir_cfg stuff\n// - rigid input checking on discovery responses\n// - check self-issued support\n// - README.quickstart\n// - refresh metadata once-per too? (for non-signing key changes)\n\nextern module AP_MODULE_DECLARE_DATA auth_openidc_module;\n\n/*\n * clean any suspicious headers in the HTTP request sent by the user agent\n */\nstatic void oidc_scrub_request_headers(request_rec *r, const char *claim_prefix,\n\t\tapr_hash_t *scrub) {\n\n\tconst int prefix_len = claim_prefix ? strlen(claim_prefix) : 0;\n\n\t/* get an array representation of the incoming HTTP headers */\n\tconst apr_array_header_t *const h = apr_table_elts(r->headers_in);\n\n\t/* table to keep the non-suspicious headers */\n\tapr_table_t *clean_headers = apr_table_make(r->pool, h->nelts);\n\n\t/* loop over the incoming HTTP headers */\n\tconst apr_table_entry_t *const e = (const apr_table_entry_t*) h->elts;\n\tint i;\n\tfor (i = 0; i < h->nelts; i++) {\n\t\tconst char *const k = e[i].key;\n\n\t\t/* is this header's name equivalent to a header that needs scrubbing? */\n\t\tconst char *hdr =\n\t\t\t\t(k != NULL) && (scrub != NULL) ?\n\t\t\t\t\t\tapr_hash_get(scrub, k, APR_HASH_KEY_STRING) : NULL;\n\t\tconst int header_matches = (hdr != NULL)\n\t\t\t\t\t\t&& (oidc_strnenvcmp(k, hdr, -1) == 0);\n\n\t\t/*\n\t\t * would this header be interpreted as a mod_auth_openidc attribute? Note\n\t\t * that prefix_len will be zero if no attr_prefix is defined,\n\t\t * so this will always be false. Also note that we do not\n\t\t * scrub headers if the prefix is empty because every header\n\t\t * would match.\n\t\t */\n\t\tconst int prefix_matches = (k != NULL) && prefix_len\n\t\t\t\t&& (oidc_strnenvcmp(k, claim_prefix, prefix_len) == 0);\n\n\t\t/* add to the clean_headers if non-suspicious, skip and report otherwise */\n\t\tif (!prefix_matches && !header_matches) {\n\t\t\tapr_table_addn(clean_headers, k, e[i].val);\n\t\t} else {\n\t\t\toidc_warn(r, \"scrubbed suspicious request header (%s: %.32s)\", k,\n\t\t\t\t\te[i].val);\n\t\t}\n\t}\n\n\t/* overwrite the incoming headers with the cleaned result */\n\tr->headers_in = clean_headers;\n}\n\n/*\n * scrub all mod_auth_openidc related headers\n */\nvoid oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *prefix = oidc_cfg_claim_prefix(r);\n\tapr_hash_t *hdrs = apr_hash_make(r->pool);\n\n\tif (apr_strnatcmp(prefix, \"\") == 0) {\n\t\tif ((cfg->white_listed_claims != NULL)\n\t\t\t\t&& (apr_hash_count(cfg->white_listed_claims) > 0))\n\t\t\thdrs = apr_hash_overlay(r->pool, cfg->white_listed_claims, hdrs);\n\t\telse\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"both \" OIDCClaimPrefix \" and \" OIDCWhiteListedClaims \" are empty: this renders an insecure setup!\");\n\t}\n\n\tchar *authn_hdr = oidc_cfg_dir_authn_header(r);\n\tif (authn_hdr != NULL)\n\t\tapr_hash_set(hdrs, authn_hdr, APR_HASH_KEY_STRING, authn_hdr);\n\n\t/*\n\t * scrub all headers starting with OIDC_ first\n\t */\n\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX, hdrs);\n\n\t/*\n\t * then see if the claim headers need to be removed on top of that\n\t * (i.e. the prefix does not start with the default OIDC_)\n\t */\n\tif ((strstr(prefix, OIDC_DEFAULT_HEADER_PREFIX) != prefix)) {\n\t\toidc_scrub_request_headers(r, prefix, NULL);\n\t}\n}\n\n/*\n * strip the session cookie from the headers sent to the application/backend\n */\nvoid oidc_strip_cookies(request_rec *r) {\n\n\tchar *cookie, *ctx, *result = NULL;\n\tconst char *name = NULL;\n\tint i;\n\n\tapr_array_header_t *strip = oidc_dir_cfg_strip_cookies(r);\n\n\tchar *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));\n\n\tif ((cookies != NULL) && (strip != NULL)) {\n\n\t\toidc_debug(r,\n\t\t\t\t\"looking for the following cookies to strip from cookie header: %s\",\n\t\t\t\tapr_array_pstrcat(r->pool, strip, OIDC_CHAR_COMMA));\n\n\t\tcookie = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &ctx);\n\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == OIDC_CHAR_SPACE)\n\t\t\t\tcookie++;\n\n\t\t\tfor (i = 0; i < strip->nelts; i++) {\n\t\t\t\tname = ((const char**) strip->elts)[i];\n\t\t\t\tif ((strncmp(cookie, name, strlen(name)) == 0)\n\t\t\t\t\t\t&& (cookie[strlen(name)] == OIDC_CHAR_EQUAL)) {\n\t\t\t\t\toidc_debug(r, \"stripping: %s\", name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == strip->nelts) {\n\t\t\t\tresult = result ? apr_psprintf(r->pool, \"%s%s %s\", result,\n\t\t\t\t\t\tOIDC_STR_SEMI_COLON, cookie) :\n\t\t\t\t\t\tcookie;\n\t\t\t}\n\n\t\t\tcookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &ctx);\n\t\t} while (cookie != NULL);\n\n\t\toidc_util_hdr_in_cookie_set(r, result);\n\t}\n}\n\n#define OIDC_SHA1_LEN 20\n\n/*\n * calculates a hash value based on request fingerprint plus a provided nonce string.\n */\nstatic char* oidc_get_browser_state_hash(request_rec *r, oidc_cfg *c,\n\t\tconst char *nonce) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* helper to hold to header values */\n\tconst char *value = NULL;\n\t/* the hash context */\n\tapr_sha1_ctx_t sha1;\n\n\t/* Initialize the hash context */\n\tapr_sha1_init(&sha1);\n\n\tif (c->state_input_headers & OIDC_STATE_INPUT_HEADERS_X_FORWARDED_FOR) {\n\t\t/* get the X-FORWARDED-FOR header value  */\n\t\tvalue = oidc_util_hdr_in_x_forwarded_for_get(r);\n\t\t/* if we have a value for this header, concat it to the hash input */\n\t\tif (value != NULL)\n\t\t\tapr_sha1_update(&sha1, value, strlen(value));\n\t}\n\n\tif (c->state_input_headers & OIDC_STATE_INPUT_HEADERS_USER_AGENT) {\n\t\t/* get the USER-AGENT header value  */\n\t\tvalue = oidc_util_hdr_in_user_agent_get(r);\n\t\t/* if we have a value for this header, concat it to the hash input */\n\t\tif (value != NULL)\n\t\t\tapr_sha1_update(&sha1, value, strlen(value));\n\t}\n\n\t/* get the remote client IP address or host name */\n\t/*\n\t int remotehost_is_ip;\n\t value = ap_get_remote_host(r->connection, r->per_dir_config,\n\t REMOTE_NOLOOKUP, &remotehost_is_ip);\n\t apr_sha1_update(&sha1, value, strlen(value));\n\t */\n\n\t/* concat the nonce parameter to the hash input */\n\tapr_sha1_update(&sha1, nonce, strlen(nonce));\n\n\t/* concat the token binding ID if present */\n\tvalue = oidc_util_get_provided_token_binding_id(r);\n\tif (value != NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"Provided Token Binding ID environment variable found; adding its value to the state\");\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\t}\n\n\t/* finalize the hash input and calculate the resulting hash output */\n\tunsigned char hash[OIDC_SHA1_LEN];\n\tapr_sha1_final(hash, &sha1);\n\n\t/* base64url-encode the resulting hash and return it */\n\tchar *result = NULL;\n\toidc_base64url_encode(r, &result, (const char*) hash, OIDC_SHA1_LEN, TRUE);\n\treturn result;\n}\n\n/*\n * return the name for the state cookie\n */\nstatic char* oidc_get_state_cookie_name(request_rec *r, const char *state) {\n\treturn apr_psprintf(r->pool, \"%s%s\", oidc_cfg_dir_state_cookie_prefix(r),\n\t\t\tstate);\n}\n\n/*\n * return the static provider configuration, i.e. from a metadata URL or configuration primitives\n */\nstatic apr_byte_t oidc_provider_static_config(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t **provider) {\n\n\tjson_t *j_provider = NULL;\n\tchar *s_json = NULL;\n\n\t/* see if we should configure a static provider based on external (cached) metadata */\n\tif ((c->metadata_dir != NULL) || (c->provider.metadata_url == NULL)) {\n\t\t*provider = &c->provider;\n\t\treturn TRUE;\n\t}\n\n\toidc_cache_get_provider(r, c->provider.metadata_url, &s_json);\n\n\tif (s_json == NULL) {\n\n\t\tif (oidc_metadata_provider_retrieve(r, c, NULL,\n\t\t\t\tc->provider.metadata_url, &j_provider, &s_json) == FALSE) {\n\t\t\toidc_error(r, \"could not retrieve metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\toidc_cache_set_provider(r, c->provider.metadata_url, s_json,\n\t\t\t\tapr_time_now() + (c->provider_metadata_refresh_interval <= 0 ? apr_time_from_sec( OIDC_CACHE_PROVIDER_METADATA_EXPIRY_DEFAULT) : c->provider_metadata_refresh_interval));\n\n\t} else {\n\n\t\toidc_util_decode_json_object(r, s_json, &j_provider);\n\n\t\t/* check to see if it is valid metadata */\n\t\tif (oidc_metadata_provider_is_valid(r, c, j_provider, NULL) == FALSE) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"cache corruption detected: invalid metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t*provider = apr_pcalloc(r->pool, sizeof(oidc_provider_t));\n\tmemcpy(*provider, &c->provider, sizeof(oidc_provider_t));\n\n\tif (oidc_metadata_provider_parse(r, c, j_provider, *provider) == FALSE) {\n\t\toidc_error(r, \"could not parse metadata from url: %s\",\n\t\t\t\tc->provider.metadata_url);\n\t\tif (j_provider)\n\t\t\tjson_decref(j_provider);\n\t\treturn FALSE;\n\t}\n\n\tjson_decref(j_provider);\n\n\treturn TRUE;\n}\n\n/*\n * return the oidc_provider_t struct for the specified issuer\n */\nstatic oidc_provider_t* oidc_get_provider_for_issuer(request_rec *r,\n\t\toidc_cfg *c, const char *issuer, apr_byte_t allow_discovery) {\n\n\t/* by default we'll assume that we're dealing with a single statically configured OP */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\treturn NULL;\n\n\t/* unless a metadata directory was configured, so we'll try and get the provider settings from there */\n\tif (c->metadata_dir != NULL) {\n\n\t\t/* try and get metadata from the metadata directory for the OP that sent this response */\n\t\tif ((oidc_metadata_get(r, c, issuer, &provider, allow_discovery)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\n\t\t\t/* don't know nothing about this OP/issuer */\n\t\t\toidc_error(r, \"no provider metadata found for issuer \\\"%s\\\"\",\n\t\t\t\t\tissuer);\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn provider;\n}\n\n/*\n * find out whether the request is a response from an IDP discovery page\n */\nstatic apr_byte_t oidc_is_discovery_response(request_rec *r, oidc_cfg *cfg) {\n\t/*\n\t * prereq: this is a call to the configured redirect_uri, now see if:\n\t * the OIDC_DISC_OP_PARAM is present\n\t */\n\treturn oidc_util_request_has_parameter(r, OIDC_DISC_OP_PARAM)\n\t\t\t|| oidc_util_request_has_parameter(r, OIDC_DISC_USER_PARAM);\n}\n\n/*\n * return the HTTP method being called: only for POST data persistence purposes\n */\nstatic const char* oidc_original_request_method(request_rec *r, oidc_cfg *cfg,\n\t\tapr_byte_t handle_discovery_response) {\n\tconst char *method = OIDC_METHOD_GET;\n\n\tchar *m = NULL;\n\tif ((handle_discovery_response == TRUE)\n\t\t\t&& (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, cfg)))\n\t\t\t&& (oidc_is_discovery_response(r, cfg))) {\n\t\toidc_util_get_request_parameter(r, OIDC_DISC_RM_PARAM, &m);\n\t\tif (m != NULL)\n\t\t\tmethod = apr_pstrdup(r->pool, m);\n\t} else {\n\n\t\t/*\n\t\t * if POST preserve is not enabled for this location, there's no point in preserving\n\t\t * the method either which would result in POSTing empty data on return;\n\t\t * so we revert to legacy behavior\n\t\t */\n\t\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\t\treturn OIDC_METHOD_GET;\n\n\t\tconst char *content_type = oidc_util_hdr_in_content_type_get(r);\n\t\tif ((r->method_number == M_POST) && (apr_strnatcmp(content_type,\n\t\t\t\tOIDC_CONTENT_TYPE_FORM_ENCODED) == 0))\n\t\t\tmethod = OIDC_METHOD_FORM_POST;\n\t}\n\n\toidc_debug(r, \"return: %s\", method);\n\n\treturn method;\n}\n\n/*\n * send an OpenID Connect authorization request to the specified provider preserving POST parameters using HTML5 storage\n */\napr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\toidc_util_javascript_escape(r->pool, location)) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * restore POST parameters on original_url from HTML5 local storage\n */\nstatic int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}\n\ntypedef struct oidc_state_cookies_t {\n\tchar *name;\n\tapr_time_t timestamp;\n\tstruct oidc_state_cookies_t *next;\n} oidc_state_cookies_t;\n\nstatic int oidc_delete_oldest_state_cookies(request_rec *r,\n\t\tint number_of_valid_state_cookies, int max_number_of_state_cookies,\n\t\toidc_state_cookies_t *first) {\n\toidc_state_cookies_t *cur = NULL, *prev = NULL, *prev_oldest = NULL,\n\t\t\t*oldest = NULL;\n\twhile (number_of_valid_state_cookies >= max_number_of_state_cookies) {\n\t\toldest = first;\n\t\tprev_oldest = NULL;\n\t\tprev = first;\n\t\tcur = first->next;\n\t\twhile (cur) {\n\t\t\tif ((cur->timestamp < oldest->timestamp)) {\n\t\t\t\toldest = cur;\n\t\t\t\tprev_oldest = prev;\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t\toidc_warn(r,\n\t\t\t\t\"deleting oldest state cookie: %s (time until expiry %\" APR_TIME_T_FMT \" seconds)\",\n\t\t\t\toldest->name, apr_time_sec(oldest->timestamp - apr_time_now()));\n\t\toidc_util_set_cookie(r, oldest->name, \"\", 0,\n\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\t\tif (prev_oldest)\n\t\t\tprev_oldest->next = oldest->next;\n\t\telse\n\t\t\tfirst = first->next;\n\t\tnumber_of_valid_state_cookies--;\n\t}\n\treturn number_of_valid_state_cookies;\n}\n\n/*\n * clean state cookies that have expired i.e. for outstanding requests that will never return\n * successfully and return the number of remaining valid cookies/outstanding-requests while\n * doing so\n */\nstatic int oidc_clean_expired_state_cookies(request_rec *r, oidc_cfg *c,\n\t\tconst char *currentCookieName, int delete_oldest) {\n\tint number_of_valid_state_cookies = 0;\n\toidc_state_cookies_t *first = NULL, *last = NULL;\n\tchar *cookie, *tokenizerCtx = NULL;\n\tchar *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));\n\tif (cookies != NULL) {\n\t\tcookie = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &tokenizerCtx);\n\t\twhile (cookie != NULL) {\n\t\t\twhile (*cookie == OIDC_CHAR_SPACE)\n\t\t\t\tcookie++;\n\t\t\tif (strstr(cookie, oidc_cfg_dir_state_cookie_prefix(r)) == cookie) {\n\t\t\t\tchar *cookieName = cookie;\n\t\t\t\twhile (cookie != NULL && *cookie != OIDC_CHAR_EQUAL)\n\t\t\t\t\tcookie++;\n\t\t\t\tif (*cookie == OIDC_CHAR_EQUAL) {\n\t\t\t\t\t*cookie = '\\0';\n\t\t\t\t\tcookie++;\n\t\t\t\t\tif ((currentCookieName == NULL)\n\t\t\t\t\t\t\t|| (apr_strnatcmp(cookieName, currentCookieName)\n\t\t\t\t\t\t\t\t\t!= 0)) {\n\t\t\t\t\t\toidc_proto_state_t *proto_state =\n\t\t\t\t\t\t\t\toidc_proto_state_from_cookie(r, c, cookie);\n\t\t\t\t\t\tif (proto_state != NULL) {\n\t\t\t\t\t\t\tjson_int_t ts = oidc_proto_state_get_timestamp(\n\t\t\t\t\t\t\t\t\tproto_state);\n\t\t\t\t\t\t\tif (apr_time_now() > ts + apr_time_from_sec(c->state_timeout)) {\n\t\t\t\t\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\t\t\t\t\"state (%s) has expired (original_url=%s)\",\n\t\t\t\t\t\t\t\t\t\tcookieName,\n\t\t\t\t\t\t\t\t\t\toidc_proto_state_get_original_url(\n\t\t\t\t\t\t\t\t\t\t\t\tproto_state));\n\t\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0,\n\t\t\t\t\t\t\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (first == NULL) {\n\t\t\t\t\t\t\t\t\tfirst = apr_pcalloc(r->pool,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(oidc_state_cookies_t));\n\t\t\t\t\t\t\t\t\tlast = first;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlast->next = apr_pcalloc(r->pool,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(oidc_state_cookies_t));\n\t\t\t\t\t\t\t\t\tlast = last->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlast->name = cookieName;\n\t\t\t\t\t\t\t\tlast->timestamp = ts;\n\t\t\t\t\t\t\t\tlast->next = NULL;\n\t\t\t\t\t\t\t\tnumber_of_valid_state_cookies++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\t\t\t\"state cookie could not be retrieved/decoded, deleting: %s\",\n\t\t\t\t\t\t\t\t\tcookieName);\n\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0,\n\t\t\t\t\t\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &tokenizerCtx);\n\t\t}\n\t}\n\n\tif (delete_oldest > 0)\n\t\tnumber_of_valid_state_cookies = oidc_delete_oldest_state_cookies(r,\n\t\t\t\tnumber_of_valid_state_cookies, c->max_number_of_state_cookies,\n\t\t\t\tfirst);\n\n\treturn number_of_valid_state_cookies;\n}\n\n/*\n * restore the state that was maintained between authorization request and response in an encrypted cookie\n */\nstatic apr_byte_t oidc_restore_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t **proto_state) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* clean expired state cookies to avoid pollution */\n\toidc_clean_expired_state_cookies(r, c, cookieName, FALSE);\n\n\t/* get the state cookie value first */\n\tchar *cookieValue = oidc_util_get_cookie(r, cookieName);\n\tif (cookieValue == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"no \\\"%s\\\" state cookie found: check domain and samesite cookie settings\",\n\t\t\t\tcookieName);\n\t\treturn FALSE;\n\t}\n\n\t/* clear state cookie because we don't need it anymore */\n\toidc_util_set_cookie(r, cookieName, \"\", 0,\n\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\n\t*proto_state = oidc_proto_state_from_cookie(r, c, cookieValue);\n\tif (*proto_state == NULL)\n\t\treturn FALSE;\n\n\tconst char *nonce = oidc_proto_state_get_nonce(*proto_state);\n\n\t/* calculate the hash of the browser fingerprint concatenated with the nonce */\n\tchar *calc = oidc_get_browser_state_hash(r, c, nonce);\n\t/* compare the calculated hash with the value provided in the authorization response */\n\tif (apr_strnatcmp(calc, state) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"calculated state from cookie does not match state parameter passed back in URL: \\\"%s\\\" != \\\"%s\\\"\",\n\t\t\t\tstate, calc);\n\t\toidc_proto_state_destroy(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\tapr_time_t ts = oidc_proto_state_get_timestamp(*proto_state);\n\n\t/* check that the timestamp is not beyond the valid interval */\n\tif (apr_time_now() > ts + apr_time_from_sec(c->state_timeout)) {\n\t\toidc_error(r, \"state has expired\");\n\t\tif ((c->default_sso_url == NULL)\n\t\t\t\t|| (apr_table_get(r->subprocess_env, \"OIDC_NO_DEFAULT_URL_ON_STATE_TIMEOUT\") != NULL)) {\n\t\t\toidc_util_html_send_error(r, c->error_template, \"Invalid Authentication Response\", apr_psprintf(r->pool, \"This is due to a timeout; please restart your authentication session by re-entering the URL/bookmark you originally wanted to access: %s\", oidc_proto_state_get_original_url(*proto_state)),\n\t\t\t\t\t\t\t\t\t  OK);\n\t\t\t/*\n\t\t\t * a hack for Apache 2.4 to prevent it from writing its own 500/400/302 HTML document\n\t\t\t * text by making ap_send_error_response in http_protocol.c return early...\n\t\t\t */\n\t\t\tr->header_only = 1;\n\t\t}\n\t\toidc_proto_state_destroy(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\t/* add the state */\n\toidc_proto_state_set_state(*proto_state, state);\n\n\t/* log the restored state object */\n\toidc_debug(r, \"restored state: %s\",\n\t\t\toidc_proto_state_to_string(r, *proto_state));\n\n\t/* we've made it */\n\treturn TRUE;\n}\n\n/*\n * set the state that is maintained between an authorization request and an authorization response\n * in a cookie in the browser that is cryptographically bound to that state\n */\nstatic int oidc_authorization_request_set_cookie(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t *proto_state) {\n\t/*\n\t * create a cookie consisting of 8 elements:\n\t * random value, original URL, original method, issuer, response_type, response_mod, prompt and timestamp\n\t * encoded as JSON, encrypting the resulting JSON value\n\t */\n\tchar *cookieValue = oidc_proto_state_to_cookie(r, c, proto_state);\n\tif (cookieValue == NULL)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/*\n\t * clean expired state cookies to avoid pollution and optionally\n\t * try to avoid the number of state cookies exceeding a max\n\t */\n\tint number_of_cookies = oidc_clean_expired_state_cookies(r, c, NULL,\n\t\t\toidc_cfg_delete_oldest_state_cookies(c));\n\tint max_number_of_cookies = oidc_cfg_max_number_of_state_cookies(c);\n\tif ((max_number_of_cookies > 0)\n\t\t\t&& (number_of_cookies >= max_number_of_cookies)) {\n\n\t\toidc_warn(r,\n\t\t\t\t\"the number of existing, valid state cookies (%d) has exceeded the limit (%d), no additional authorization request + state cookie can be generated, aborting the request\",\n\t\t\t\tnumber_of_cookies, max_number_of_cookies);\n\t\t/*\n\t\t * TODO: the html_send code below caters for the case that there's a user behind a\n\t\t * browser generating this request, rather than a piece of XHR code; how would an\n\t\t * XHR client handle this?\n\t\t */\n\n\t\t/*\n\t\t * it appears that sending content with a 503 turns the HTTP status code\n\t\t * into a 200 so we'll avoid that for now: the user will see Apache specific\n\t\t * readable text anyway\n\t\t *\n\t\t return oidc_util_html_send_error(r, c->error_template,\n\t\t \"Too Many Outstanding Requests\",\n\t\t apr_psprintf(r->pool,\n\t\t \"No authentication request could be generated since there are too many outstanding authentication requests already; you may have to wait up to %d seconds to be able to create a new request\",\n\t\t c->state_timeout),\n\t\t HTTP_SERVICE_UNAVAILABLE);\n\t\t */\n\n\t\treturn HTTP_SERVICE_UNAVAILABLE;\n\t}\n\n\t/* assemble the cookie name for the state cookie */\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* set it as a cookie */\n\toidc_util_set_cookie(r, cookieName, cookieValue, -1,\n\t\t\tOIDC_COOKIE_SAMESITE_LAX(c, r));\n\n\treturn OK;\n}\n\n/*\n * get the mod_auth_openidc related context from the (userdata in the) request\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nstatic apr_table_t* oidc_request_state(request_rec *rr) {\n\n\t/* our state is always stored in the main request */\n\trequest_rec *r = (rr->main != NULL) ? rr->main : rr;\n\n\t/* our state is a table, get it */\n\tapr_table_t *state = NULL;\n\tapr_pool_userdata_get((void**) &state, OIDC_USERDATA_KEY, r->pool);\n\n\t/* if it does not exist, we'll create a new table */\n\tif (state == NULL) {\n\t\tstate = apr_table_make(r->pool, 5);\n\t\tapr_pool_userdata_set(state, OIDC_USERDATA_KEY, NULL, r->pool);\n\t}\n\n\t/* return the resulting table, always non-null now */\n\treturn state;\n}\n\n/*\n * set a name/value pair in the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nvoid oidc_request_state_set(request_rec *r, const char *key, const char *value) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* put the name/value pair in that table */\n\tapr_table_set(state, key, value);\n}\n\n/*\n * get a name/value pair from the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nconst char* oidc_request_state_get(request_rec *r, const char *key) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* return the value from the table */\n\treturn apr_table_get(state, key);\n}\n\n/*\n * set the claims from a JSON object (c.q. id_token or user_info response) stored\n * in the session in to HTTP headers passed on to the application\n */\nstatic apr_byte_t oidc_set_app_claims(request_rec *r, const oidc_cfg *const cfg,\n\t\toidc_session_t *session, const char *s_claims) {\n\n\tjson_t *j_claims = NULL;\n\n\t/* decode the string-encoded attributes in to a JSON structure */\n\tif (s_claims != NULL) {\n\t\tif (oidc_util_decode_json_object(r, s_claims, &j_claims) == FALSE)\n\t\t\treturn FALSE;\n\t}\n\n\t/* set the resolved claims a HTTP headers for the application */\n\tif (j_claims != NULL) {\n\t\toidc_util_set_app_infos(r, j_claims, oidc_cfg_claim_prefix(r),\n\t\t\t\tcfg->claim_delimiter, oidc_cfg_dir_pass_info_in_headers(r),\n\t\t\t\toidc_cfg_dir_pass_info_in_envvars(r),\n\t\t\t\toidc_cfg_dir_pass_info_base64url(r));\n\n\t\t/* release resources */\n\t\tjson_decref(j_claims);\n\t}\n\n\treturn TRUE;\n}\n\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params, const char *path_scope);\n\n/*\n * log message about max session duration\n */\nstatic void oidc_log_session_expires(request_rec *r, const char *msg,\n\t\tapr_time_t session_expires) {\n\tchar buf[APR_RFC822_DATE_LEN + 1];\n\tapr_rfc822_date(buf, session_expires);\n\toidc_debug(r, \"%s: %s (in %\" APR_TIME_T_FMT \" secs from now)\", msg, buf,\n\t\t\tapr_time_sec(session_expires - apr_time_now()));\n}\n\n/*\n * see if this is a non-browser request\n */\nstatic apr_byte_t oidc_is_xml_http_request(request_rec *r) {\n\n\tif ((oidc_util_hdr_in_x_requested_with_get(r) != NULL)\n\t\t\t&& (apr_strnatcasecmp(oidc_util_hdr_in_x_requested_with_get(r),\n\t\t\t\t\tOIDC_HTTP_HDR_VAL_XML_HTTP_REQUEST) == 0))\n\t\treturn TRUE;\n\n\tif ((oidc_util_hdr_in_accept_contains(r, OIDC_CONTENT_TYPE_TEXT_HTML)\n\t\t\t== FALSE) && (oidc_util_hdr_in_accept_contains(r,\n\t\t\t\t\tOIDC_CONTENT_TYPE_APP_XHTML_XML) == FALSE)\n\t\t\t\t\t&& (oidc_util_hdr_in_accept_contains(r,\n\t\t\t\t\t\t\tOIDC_CONTENT_TYPE_ANY) == FALSE))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\n/*\n * find out which action we need to take when encountering an unauthenticated request\n */\nstatic int oidc_handle_unauthenticated_user(request_rec *r, oidc_cfg *c) {\n\n\t/* see if we've configured OIDCUnAuthAction for this path */\n\tswitch (oidc_dir_cfg_unauth_action(r)) {\n\tcase OIDC_UNAUTH_RETURN410:\n\t\treturn HTTP_GONE;\n\tcase OIDC_UNAUTH_RETURN407:\n\t\treturn HTTP_PROXY_AUTHENTICATION_REQUIRED;\n\tcase OIDC_UNAUTH_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTH_PASS:\n\t\tr->user = \"\";\n\n\t\t/*\n\t\t * we're not going to pass information about an authenticated user to the application,\n\t\t * but we do need to scrub the headers that mod_auth_openidc would set for security reasons\n\t\t */\n\t\toidc_scrub_headers(r);\n\n\t\treturn OK;\n\n\tcase OIDC_UNAUTH_AUTHENTICATE:\n\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif ((oidc_dir_cfg_unauth_expr_is_set(r) == FALSE)\n\t\t\t\t&& (oidc_is_xml_http_request(r) == TRUE))\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/*\n\t * else: no session (regardless of whether it is main or sub-request),\n\t * and we need to authenticate the user\n\t */\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r),\n\t\t\toidc_dir_cfg_path_scope(r));\n}\n\n/*\n * check if maximum session duration was exceeded\n */\nstatic int oidc_check_max_session_duration(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\t/* get the session expiry from the session data */\n\tapr_time_t session_expires = oidc_session_get_session_expires(r, session);\n\n\t/* check the expire timestamp against the current time */\n\tif (apr_time_now() > session_expires) {\n\t\toidc_warn(r, \"maximum session duration exceeded for user: %s\",\n\t\t\t\tsession->remote_user);\n\t\toidc_session_kill(r, session);\n\t\treturn oidc_handle_unauthenticated_user(r, cfg);\n\t}\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\n\treturn OK;\n}\n\n/*\n * validate received session cookie against the domain it was issued for:\n *\n * this handles the case where the cache configured is a the same single memcache, Redis, or file\n * backend for different (virtual) hosts, or a client-side cookie protected with the same secret\n *\n * it also handles the case that a cookie is unexpectedly shared across multiple hosts in\n * name-based virtual hosting even though the OP(s) would be the same\n */\nstatic apr_byte_t oidc_check_cookie_domain(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tconst char *c_cookie_domain =\n\t\t\tcfg->cookie_domain ?\n\t\t\t\t\tcfg->cookie_domain : oidc_get_current_url_host(r);\n\tconst char *s_cookie_domain = oidc_session_get_cookie_domain(r, session);\n\tif ((s_cookie_domain == NULL)\n\t\t\t|| (apr_strnatcmp(c_cookie_domain, s_cookie_domain) != 0)) {\n\t\toidc_warn(r,\n\t\t\t\t\"aborting: detected attempt to play cookie against a different domain/host than issued for! (issued=%s, current=%s)\",\n\t\t\t\ts_cookie_domain, c_cookie_domain);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * get a handle to the provider configuration via the \"issuer\" stored in the session\n */\napr_byte_t oidc_get_provider_from_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t **provider) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the issuer value from the session state */\n\tconst char *issuer = oidc_session_get_issuer(r, session);\n\tif (issuer == NULL) {\n\t\toidc_warn(r, \"empty or invalid session: no issuer found\");\n\t\treturn FALSE;\n\t}\n\n\t/* get the provider info associated with the issuer value */\n\toidc_provider_t *p = oidc_get_provider_for_issuer(r, c, issuer, FALSE);\n\tif (p == NULL) {\n\t\toidc_error(r, \"session corrupted: no provider found for issuer: %s\",\n\t\t\t\tissuer);\n\t\treturn FALSE;\n\t}\n\n\t*provider = p;\n\n\treturn TRUE;\n}\n\n/*\n * store claims resolved from the userinfo endpoint in the session\n */\nstatic void oidc_store_userinfo_claims(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider, const char *claims,\n\t\tconst char *userinfo_jwt) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* see if we've resolved any claims */\n\tif (claims != NULL) {\n\t\t/*\n\t\t * Successfully decoded a set claims from the response so we can store them\n\t\t * (well actually the stringified representation in the response)\n\t\t * in the session context safely now\n\t\t */\n\t\toidc_session_set_userinfo_claims(r, session, claims);\n\n\t\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* this will also clear the entry if a JWT was not returned at this point */\n\t\t\toidc_session_set_userinfo_jwt(r, session, userinfo_jwt);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * clear the existing claims because we could not refresh them\n\t\t */\n\t\toidc_session_set_userinfo_claims(r, session, NULL);\n\n\t\toidc_session_set_userinfo_jwt(r, session, NULL);\n\t}\n\n\t/* store the last refresh time if we've configured a userinfo refresh interval */\n\tif (provider->userinfo_refresh_interval > 0)\n\t\toidc_session_reset_userinfo_last_refresh(r, session);\n}\n\n/*\n * execute refresh token grant to refresh the existing access token\n */\nstatic apr_byte_t oidc_refresh_access_token(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tchar **new_access_token) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the refresh token that was stored in the session */\n\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\tif (refresh_token == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"refresh token routine called but no refresh_token found in the session\");\n\t\treturn FALSE;\n\t}\n\n\t/* elements returned in the refresh response */\n\tchar *s_id_token = NULL;\n\tint expires_in = -1;\n\tchar *s_token_type = NULL;\n\tchar *s_access_token = NULL;\n\tchar *s_refresh_token = NULL;\n\n\t/* refresh the tokens by calling the token endpoint */\n\tif (oidc_proto_refresh_request(r, c, provider, refresh_token, &s_id_token,\n\t\t\t&s_access_token, &s_token_type, &expires_in, &s_refresh_token)\n\t\t\t== FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\treturn FALSE;\n\t}\n\n\t/* store the new access_token in the session and discard the old one */\n\toidc_session_set_access_token(r, session, s_access_token);\n\toidc_session_set_access_token_expires(r, session, expires_in);\n\n\t/* reset the access token refresh timestamp */\n\toidc_session_reset_access_token_last_refresh(r, session);\n\n\t/* see if we need to return it as a parameter */\n\tif (new_access_token != NULL)\n\t\t*new_access_token = s_access_token;\n\n\t/* if we have a new refresh token (rolling refresh), store it in the session and overwrite the old one */\n\tif (s_refresh_token != NULL)\n\t\toidc_session_set_refresh_token(r, session, s_refresh_token);\n\n\t/* if we have a new id_token, store it in the session and update the session max lifetime if required */\n\tif (s_id_token != NULL) {\n\t\t/* only store the serialized representation when client cookie based session tracking is not in use */\n\t\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) \n\t\t\toidc_session_set_idtoken(r, session, s_id_token);\n\t\t\n\t\toidc_jwt_t *id_token_jwt = NULL;\n\t\toidc_jose_error_t err;\n\t\tif (oidc_jwt_parse(r->pool, s_id_token, &id_token_jwt, NULL, &err) == TRUE) {\n\n\t\t\t/* store the claims payload in the id_token for later reference */\n\t\t\toidc_session_set_idtoken_claims(r, session,\n\t\t\t\tid_token_jwt->payload.value.str);\n\n\t\t\tif (provider->session_max_duration == 0) {\n\t\t\t\t/* update the session expiry to match the expiry of the id_token */\n\t\t\t\tapr_time_t session_expires = apr_time_from_sec(id_token_jwt->payload.exp);\n\t\t\t\toidc_session_set_session_expires(r, session, session_expires);\n\n\t\t\t\t/* log message about the updated max session duration */\n\t\t\t\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\t\t\t}\t\t\n\t\t} else { \n\t\t\toidc_warn(r, \"parsing of id_token failed\");\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * retrieve claims from the userinfo endpoint and return the stringified response\n */\nstatic const char* oidc_retrieve_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *c, oidc_provider_t *provider, const char *access_token,\n\t\toidc_session_t *session, char *id_token_sub, char **userinfo_jwt) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *result = NULL;\n\tchar *refreshed_access_token = NULL;\n\n\t/* see if a userinfo endpoint is set, otherwise there's nothing to do for us */\n\tif (provider->userinfo_endpoint_url == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because userinfo_endpoint is not set\");\n\t\treturn NULL;\n\t}\n\n\t/* see if there's an access token, otherwise we can't call the userinfo endpoint at all */\n\tif (access_token == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because access_token is not provided\");\n\t\treturn NULL;\n\t}\n\n\tif ((id_token_sub == NULL) && (session != NULL)) {\n\n\t\t// when refreshing claims from the userinfo endpoint\n\t\tjson_t *id_token_claims = oidc_session_get_idtoken_claims_json(r,\n\t\t\t\tsession);\n\t\tif (id_token_claims == NULL) {\n\t\t\toidc_error(r, \"no id_token_claims found in session\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\toidc_jose_get_string(r->pool, id_token_claims, OIDC_CLAIM_SUB, FALSE,\n\t\t\t\t&id_token_sub, NULL);\n\t}\n\n\t// TODO: return code should indicate whether the token expired or some other error occurred\n\t// TODO: long-term: session storage should be JSON (with explicit types and less conversion, using standard routines)\n\n\t/* try to get claims from the userinfo endpoint using the provided access token */\n\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,\n\t\t\t&result, userinfo_jwt) == FALSE) {\n\n\t\t/* see if we have an existing session and we are refreshing the user info claims */\n\t\tif (session != NULL) {\n\n\t\t\t/* first call to user info endpoint failed, but the access token may have just expired, so refresh it */\n\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t&refreshed_access_token) == TRUE) {\n\n\t\t\t\t/* try again with the new access token */\n\t\t\t\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub,\n\t\t\t\t\t\trefreshed_access_token, &result, userinfo_jwt)\n\t\t\t\t\t\t== FALSE) {\n\n\t\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\t\"resolving user info claims with the refreshed access token failed, nothing will be stored in the session\");\n\t\t\t\t\tresult = NULL;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"refreshing access token failed, claims will not be retrieved/refreshed from the userinfo endpoint\");\n\t\t\t\tresult = NULL;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toidc_error(r,\n\t\t\t\t\t\"resolving user info claims with the existing/provided access token failed, nothing will be stored in the session\");\n\t\t\tresult = NULL;\n\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*\n * get (new) claims from the userinfo endpoint\n */\nstatic apr_byte_t oidc_refresh_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\tconst char *claims = NULL;\n\tconst char *access_token = NULL;\n\tchar *userinfo_jwt = NULL;\n\n\t/* get the current provider info */\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\t/* see if we can do anything here, i.e. we have a userinfo endpoint and a refresh interval is configured */\n\tapr_time_t interval = apr_time_from_sec(\n\t\t\tprovider->userinfo_refresh_interval);\n\n\toidc_debug(r, \"userinfo_endpoint=%s, interval=%d\",\n\t\t\tprovider->userinfo_endpoint_url,\n\t\t\tprovider->userinfo_refresh_interval);\n\n\tif ((provider->userinfo_endpoint_url != NULL) && (interval > 0)) {\n\n\t\t/* get the last refresh timestamp from the session info */\n\t\tapr_time_t last_refresh = oidc_session_get_userinfo_last_refresh(r,\n\t\t\t\tsession);\n\n\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\tapr_time_sec(last_refresh + interval - apr_time_now()));\n\n\t\t/* see if we need to refresh again */\n\t\tif (last_refresh + interval < apr_time_now()) {\n\n\t\t\t/* get the current access token */\n\t\t\taccess_token = oidc_session_get_access_token(r, session);\n\n\t\t\t/* retrieve the current claims */\n\t\t\tclaims = oidc_retrieve_claims_from_userinfo_endpoint(r, cfg,\n\t\t\t\t\tprovider, access_token, session, NULL, &userinfo_jwt);\n\n\t\t\t/* store claims resolved from userinfo endpoint */\n\t\t\toidc_store_userinfo_claims(r, cfg, session, provider, claims,\n\t\t\t\t\tuserinfo_jwt);\n\n\t\t\t/* indicated something changed */\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*\n * copy the claims and id_token from the session to the request state and optionally return them\n */\nstatic void oidc_copy_tokens_to_request_state(request_rec *r,\n\t\toidc_session_t *session, const char **s_id_token, const char **s_claims) {\n\n\tconst char *id_token = oidc_session_get_idtoken_claims(r, session);\n\tconst char *claims = oidc_session_get_userinfo_claims(r, session);\n\n\toidc_debug(r, \"id_token=%s claims=%s\", id_token, claims);\n\n\tif (id_token != NULL) {\n\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_IDTOKEN, id_token);\n\t\tif (s_id_token != NULL)\n\t\t\t*s_id_token = id_token;\n\t}\n\n\tif (claims != NULL) {\n\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_CLAIMS, claims);\n\t\tif (s_claims != NULL)\n\t\t\t*s_claims = claims;\n\t}\n}\n\n/*\n * pass refresh_token, access_token and access_token_expires as headers/environment variables to the application\n */\nstatic apr_byte_t oidc_session_pass_tokens(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session, apr_byte_t *needs_save) {\n\n\tapr_byte_t pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tapr_byte_t pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\tapr_byte_t pass_base64url = oidc_cfg_dir_pass_info_base64url(r);\n\n\t/* set the refresh_token in the app headers/variables, if enabled for this location/directory */\n\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\tif ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_REFRESH_TOKEN, refresh_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars, pass_base64url);\n\t}\n\n\t/* set the access_token in the app headers/variables */\n\tconst char *access_token = oidc_session_get_access_token(r, session);\n\tif (access_token != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN, access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars, pass_base64url);\n\t}\n\n\t/* set the expiry timestamp in the app headers/variables */\n\tconst char *access_token_expires = oidc_session_get_access_token_expires(r,\n\t\t\tsession);\n\tif (access_token_expires != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN_EXP,\n\t\t\t\taccess_token_expires,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars,\n\t\t\t\tpass_base64url);\n\t}\n\n\t/*\n\t * reset the session inactivity timer\n\t * but only do this once per 10% of the inactivity timeout interval (with a max to 60 seconds)\n\t * for performance reasons\n\t *\n\t * now there's a small chance that the session ends 10% (or a minute) earlier than configured/expected\n\t * cq. when there's a request after a recent save (so no update) and then no activity happens until\n\t * a request comes in just before the session should expire\n\t * (\"recent\" and \"just before\" refer to 10%-with-a-max-of-60-seconds of the inactivity interval after\n\t * the start/last-update and before the expiry of the session respectively)\n\t *\n\t * this is be deemed acceptable here because of performance gain\n\t */\n\tapr_time_t interval = apr_time_from_sec(cfg->session_inactivity_timeout);\n\tapr_time_t now = apr_time_now();\n\tapr_time_t slack = interval / 10;\n\tif (slack > apr_time_from_sec(60))\n\t\tslack = apr_time_from_sec(60);\n\tif (session->expiry - now < interval - slack) {\n\t\tsession->expiry = now + interval;\n\t\t*needs_save = TRUE;\n\t}\n\n\t/* log message about session expiry */\n\toidc_log_session_expires(r, \"session inactivity timeout\", session->expiry);\n\n\treturn TRUE;\n}\n\nstatic apr_byte_t oidc_refresh_access_token_before_expiry(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session, int ttl_minimum,\n\t\tint logout_on_error) {\n\n\tconst char *s_access_token_expires = NULL;\n\tapr_time_t t_expires = -1;\n\toidc_provider_t *provider = NULL;\n\n\toidc_debug(r, \"ttl_minimum=%d\", ttl_minimum);\n\n\tif (ttl_minimum < 0)\n\t\treturn FALSE;\n\n\ts_access_token_expires = oidc_session_get_access_token_expires(r, session);\n\tif (s_access_token_expires == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"no access token expires_in stored in the session (i.e. returned from in the authorization response), so cannot refresh the access token based on TTL requirement\");\n\t\treturn FALSE;\n\t}\n\n\tif (oidc_session_get_refresh_token(r, session) == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"no refresh token stored in the session, so cannot refresh the access token based on TTL requirement\");\n\t\treturn FALSE;\n\t}\n\n\tif (sscanf(s_access_token_expires, \"%\" APR_TIME_T_FMT, &t_expires) != 1) {\n\t\toidc_error(r, \"could not parse s_access_token_expires %s\",\n\t\t\t\ts_access_token_expires);\n\t\treturn FALSE;\n\t}\n\n\tt_expires = apr_time_from_sec(t_expires - ttl_minimum);\n\n\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\tapr_time_sec(t_expires - apr_time_now()));\n\n\tif (t_expires > apr_time_now())\n\t\treturn FALSE;\n\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\tif (oidc_refresh_access_token(r, cfg, session, provider,\n\t\t\tNULL) == FALSE) {\n\t\toidc_warn(r, \"access_token could not be refreshed, logout=%d\",\n\t\t\t\tlogout_on_error & OIDC_LOGOUT_ON_ERROR_REFRESH);\n\t\tif (logout_on_error & OIDC_LOGOUT_ON_ERROR_REFRESH)\n\t\t\treturn OIDC_REFRESH_ERROR;\n\t\telse\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * handle the case where we have identified an existing authentication session for a user\n */\nstatic int oidc_handle_existing_session(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session, apr_byte_t *needs_save) {\n\n\tapr_byte_t rv = FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\t/* set the user in the main request for further (incl. sub-request) processing */\n\tr->user = apr_pstrdup(r->pool, session->remote_user);\n\toidc_debug(r, \"set remote_user to \\\"%s\\\"\", r->user);\n\n\t/* get the header name in which the remote user name needs to be passed */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tapr_byte_t pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tapr_byte_t pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\tapr_byte_t pass_base64url = oidc_cfg_dir_pass_info_base64url(r);\n\n\t/* verify current cookie domain against issued cookie domain */\n\tif (oidc_check_cookie_domain(r, cfg, session) == FALSE)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* check if the maximum session duration was exceeded */\n\tint rc = oidc_check_max_session_duration(r, cfg, session);\n\tif (rc != OK)\n\t\treturn rc;\n\n\t/* if needed, refresh the access token */\n\trv = oidc_refresh_access_token_before_expiry(r, cfg, session,\n\t\t\toidc_cfg_dir_refresh_access_token_before_expiry(r),\n\t\t\toidc_cfg_dir_logout_on_error_refresh(r));\n\n\tif (rv == OIDC_REFRESH_ERROR) {\n\t\t*needs_save = FALSE;\n\t\treturn oidc_handle_logout_request(r, cfg, session, cfg->default_slo_url);\n\t}\n\n\t*needs_save |= rv;\n\n\t/* if needed, refresh claims from the user info endpoint */\n\tif (oidc_refresh_claims_from_userinfo_endpoint(r, cfg, session) == TRUE)\n\t\t*needs_save = TRUE;\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\toidc_scrub_headers(r);\n\n\t/* set the user authentication HTTP header if set and required */\n\tif ((r->user != NULL) && (authn_header != NULL))\n\t\toidc_util_hdr_in_set(r, authn_header, r->user);\n\n\tconst char *s_claims = NULL;\n\tconst char *s_id_token = NULL;\n\n\t/* copy id_token and claims from session to request state and obtain their values */\n\toidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_CLAIMS)) {\n\t\t/* set the userinfo claims in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JSON_OBJECT)) {\n\t\t/* pass the userinfo JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JSON, s_claims,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars, pass_base64url);\n\t}\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JWT)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\tconst char *s_userinfo_jwt = oidc_session_get_userinfo_jwt(r,\n\t\t\t\t\tsession);\n\t\t\tif (s_userinfo_jwt != NULL) {\n\t\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\t\toidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JWT,\n\t\t\t\t\t\ts_userinfo_jwt,\n\t\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars,\n\t\t\t\t\t\tpass_base64url);\n\t\t\t} else {\n\t\t\t\toidc_debug(r,\n\t\t\t\t\t\t\"configured to pass userinfo in a JWT, but no such JWT was found in the session (probably no such JWT was returned from the userinfo endpoint)\");\n\t\t\t}\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing a userinfo JWT; use \\\"\" OIDCSessionType \" server-cache\\\" for that\");\n\t\t}\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {\n\t\t/* set the id_token in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {\n\t\t/* pass the id_token JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN_PAYLOAD, s_id_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars, pass_base64url);\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\tconst char *s_id_token = oidc_session_get_idtoken(r, session);\n\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN, s_id_token,\n\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars,\n\t\t\t\t\tpass_base64url);\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing the id_token; use \\\"\" OIDCSessionType \" server-cache\\\" for that\");\n\t\t}\n\t}\n\n\t/* pass the at, rt and at expiry to the application, possibly update the session expiry */\n\tif (oidc_session_pass_tokens(r, cfg, session, needs_save) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/* return \"user authenticated\" status */\n\treturn OK;\n}\n\n/*\n * helper function for basic/implicit client flows upon receiving an authorization response:\n * check that it matches the state stored in the browser and return the variables associated\n * with the state, such as original_url and OP oidc_provider_t pointer.\n */\nstatic apr_byte_t oidc_authorization_response_match_state(request_rec *r,\n\t\toidc_cfg *c, const char *state, struct oidc_provider_t **provider,\n\t\toidc_proto_state_t **proto_state) {\n\n\toidc_debug(r, \"enter (state=%s)\", state);\n\n\tif ((state == NULL) || (apr_strnatcmp(state, \"\") == 0)) {\n\t\toidc_error(r, \"state parameter is not set\");\n\t\treturn FALSE;\n\t}\n\n\t/* check the state parameter against what we stored in a cookie */\n\tif (oidc_restore_proto_state(r, c, state, proto_state) == FALSE) {\n\t\toidc_error(r, \"unable to restore state\");\n\t\treturn FALSE;\n\t}\n\n\t*provider = oidc_get_provider_for_issuer(r, c,\n\t\t\toidc_proto_state_get_issuer(*proto_state), FALSE);\n\n\tif (*provider == NULL) {\n\t\toidc_proto_state_destroy(*proto_state);\n\t\t*proto_state = NULL;\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * redirect the browser to the session logout endpoint\n */\nstatic int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_util_javascript_escape(r->pool, oidc_get_redirect_uri(r, c)));\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}\n\n/*\n * handle an error returned by the OP\n */\nstatic int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,\n\t\toidc_proto_state_t *proto_state, const char *error,\n\t\tconst char *error_description) {\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\tif (prompt != NULL)\n\t\tprompt = apr_pstrdup(r->pool, prompt);\n\toidc_proto_state_destroy(proto_state);\n\tif ((prompt != NULL)\n\t\t\t&& (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\tapr_psprintf(r->pool, \"OpenID Connect Provider error: %s\", error),\n\t\t\terror_description, OK);\n}\n\n/*\n * get the r->user for this request based on the configuration for OIDC/OAuth\n */\napr_byte_t oidc_get_remote_user(request_rec *r, const char *claim_name,\n\t\tconst char *reg_exp, const char *replace, json_t *json,\n\t\tchar **request_user) {\n\n\t/* get the claim value from the JSON object */\n\tjson_t *username = json_object_get(json, claim_name);\n\tif ((username == NULL) || (!json_is_string(username))) {\n\t\toidc_warn(r, \"JSON object did not contain a \\\"%s\\\" string\", claim_name);\n\t\treturn FALSE;\n\t}\n\n\t*request_user = apr_pstrdup(r->pool, json_string_value(username));\n\n\tif (reg_exp != NULL) {\n\n\t\tchar *error_str = NULL;\n\n\t\tif (replace == NULL) {\n\n\t\t\tif (oidc_util_regexp_first_match(r->pool, *request_user, reg_exp,\n\t\t\t\t\trequest_user, &error_str) == FALSE) {\n\t\t\t\toidc_error(r, \"oidc_util_regexp_first_match failed: %s\",\n\t\t\t\t\t\terror_str);\n\t\t\t\t*request_user = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t} else if (oidc_util_regexp_substitute(r->pool, *request_user, reg_exp,\n\t\t\t\treplace, request_user, &error_str) == FALSE) {\n\n\t\t\toidc_error(r, \"oidc_util_regexp_substitute failed: %s\", error_str);\n\t\t\t*request_user = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * set the unique user identifier that will be propagated in the Apache r->user and REMOTE_USER variables\n */\nstatic apr_byte_t oidc_set_request_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, oidc_jwt_t *jwt, const char *s_claims) {\n\n\tchar *issuer = provider->issuer;\n\tchar *claim_name = apr_pstrdup(r->pool, c->remote_user_claim.claim_name);\n\tint n = strlen(claim_name);\n\tapr_byte_t post_fix_with_issuer = (claim_name[n - 1] == OIDC_CHAR_AT);\n\tif (post_fix_with_issuer == TRUE) {\n\t\tclaim_name[n - 1] = '\\0';\n\t\tissuer =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\t}\n\n\t/* extract the username claim (default: \"sub\") from the id_token payload or user claims */\n\tapr_byte_t rc = FALSE;\n\tchar *remote_user = NULL;\n\tjson_t *claims = NULL;\n\toidc_util_decode_json_object(r, s_claims, &claims);\n\tif (claims == NULL) {\n\t\trc = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,\n\t\t\t\tc->remote_user_claim.replace, jwt->payload.value.json,\n\t\t\t\t&remote_user);\n\t} else {\n\t\toidc_util_json_merge(r, jwt->payload.value.json, claims);\n\t\trc = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,\n\t\t\t\tc->remote_user_claim.replace, claims, &remote_user);\n\t\tjson_decref(claims);\n\t}\n\n\tif ((rc == FALSE) || (remote_user == NULL)) {\n\t\toidc_error(r,\n\t\t\t\t\"\" OIDCRemoteUserClaim \"is set to \\\"%s\\\", but could not set the remote user based on the requested claim \\\"%s\\\" and the available claims for the user\",\n\t\t\t\tc->remote_user_claim.claim_name, claim_name);\n\t\treturn FALSE;\n\t}\n\n\tif (post_fix_with_issuer == TRUE)\n\t\tremote_user = apr_psprintf(r->pool, \"%s%s%s\", remote_user, OIDC_STR_AT,\n\t\t\t\tissuer);\n\n\tr->user = apr_pstrdup(r->pool, remote_user);\n\n\toidc_debug(r, \"set remote_user to \\\"%s\\\" based on claim: \\\"%s\\\"%s\", r->user,\n\t\t\tc->remote_user_claim.claim_name,\n\t\t\tc->remote_user_claim.reg_exp ?\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\" and expression: \\\"%s\\\" and replace string: \\\"%s\\\"\",\n\t\t\t\t\t\t\tc->remote_user_claim.reg_exp,\n\t\t\t\t\t\t\tc->remote_user_claim.replace) :\n\t\t\t\t\t\t\t\"\");\n\n\treturn TRUE;\n}\n\nstatic char* oidc_make_sid_iss_unique(request_rec *r, const char *sid,\n\t\tconst char *issuer) {\n\treturn apr_psprintf(r->pool, \"%s@%s\", sid, issuer);\n}\n\n/*\n * store resolved information in the session\n */\nstatic apr_byte_t oidc_save_in_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tconst char *remoteUser, const char *id_token, oidc_jwt_t *id_token_jwt,\n\t\tconst char *claims, const char *access_token, const int expires_in,\n\t\tconst char *refresh_token, const char *session_state, const char *state,\n\t\tconst char *original_url, const char *userinfo_jwt) {\n\n\t/* store the user in the session */\n\tsession->remote_user = remoteUser;\n\n\t/* set the session expiry to the inactivity timeout */\n\tsession->expiry =\n\t\t\tapr_time_now() + apr_time_from_sec(c->session_inactivity_timeout);\n\n\t/* store the claims payload in the id_token for later reference */\n\toidc_session_set_idtoken_claims(r, session,\n\t\t\tid_token_jwt->payload.value.str);\n\n\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t/* store the compact serialized representation of the id_token for later reference  */\n\t\toidc_session_set_idtoken(r, session, id_token);\n\t}\n\n\t/* store the issuer in the session (at least needed for session mgmt and token refresh */\n\toidc_session_set_issuer(r, session, provider->issuer);\n\n\t/* store the state and original URL in the session for handling browser-back more elegantly */\n\toidc_session_set_request_state(r, session, state);\n\toidc_session_set_original_url(r, session, original_url);\n\n\tif ((session_state != NULL) && (provider->check_session_iframe != NULL)) {\n\t\t/* store the session state and required parameters session management  */\n\t\toidc_session_set_session_state(r, session, session_state);\n\t\toidc_debug(r,\n\t\t\t\t\"session management enabled: stored session_state (%s), check_session_iframe (%s) and client_id (%s) in the session\",\n\t\t\t\tsession_state, provider->check_session_iframe,\n\t\t\t\tprovider->client_id);\n\t} else if (provider->check_session_iframe == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: \\\"check_session_iframe\\\" is not set in provider configuration\");\n\t} else {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: no \\\"session_state\\\" value is provided in the authentication response even though \\\"check_session_iframe\\\" (%s) is set in the provider configuration\",\n\t\t\t\tprovider->check_session_iframe);\n\t}\n\n\t/* store claims resolved from userinfo endpoint */\n\toidc_store_userinfo_claims(r, c, session, provider, claims, userinfo_jwt);\n\n\t/* see if we have an access_token */\n\tif (access_token != NULL) {\n\t\t/* store the access_token in the session context */\n\t\toidc_session_set_access_token(r, session, access_token);\n\t\t/* store the associated expires_in value */\n\t\toidc_session_set_access_token_expires(r, session, expires_in);\n\t\t/* reset the access token refresh timestamp */\n\t\toidc_session_reset_access_token_last_refresh(r, session);\n\t}\n\n\t/* see if we have a refresh_token */\n\tif (refresh_token != NULL) {\n\t\t/* store the refresh_token in the session context */\n\t\toidc_session_set_refresh_token(r, session, refresh_token);\n\t}\n\n\t/* store max session duration in the session as a hard cut-off expiry timestamp */\n\tapr_time_t session_expires =\n\t\t\t(provider->session_max_duration == 0) ?\n\t\t\t\t\tapr_time_from_sec(id_token_jwt->payload.exp) :\n\t\t\t\t\t(apr_time_now()\n\t\t\t\t\t\t\t+ apr_time_from_sec(provider->session_max_duration));\n\toidc_session_set_session_expires(r, session, session_expires);\n\n\toidc_debug(r,\n\t\t\t\"provider->session_max_duration = %d, session_expires=%\" APR_TIME_T_FMT,\n\t\t\tprovider->session_max_duration, session_expires);\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\n\t/* store the domain for which this session is valid */\n\toidc_session_set_cookie_domain(r, session,\n\t\t\tc->cookie_domain ? c->cookie_domain : oidc_get_current_url_host(r));\n\n\tchar *sid = NULL;\n\toidc_debug(r, \"provider->backchannel_logout_supported=%d\",\n\t\t\tprovider->backchannel_logout_supported);\n\tif (provider->backchannel_logout_supported > 0) {\n\t\toidc_jose_get_string(r->pool, id_token_jwt->payload.value.json,\n\t\t\t\tOIDC_CLAIM_SID, FALSE, &sid, NULL);\n\t\tif (sid == NULL)\n\t\t\tsid = id_token_jwt->payload.sub;\n\t\tsession->sid = oidc_make_sid_iss_unique(r, sid, provider->issuer);\n\t}\n\n\t/* store the session */\n\treturn oidc_session_save(r, session, TRUE);\n}\n\n/*\n * parse the expiry for the access token\n */\nstatic int oidc_parse_expires_in(request_rec *r, const char *expires_in) {\n\tif (expires_in != NULL) {\n\t\tchar *ptr = NULL;\n\t\tlong number = strtol(expires_in, &ptr, 10);\n\t\tif (number <= 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"could not convert \\\"expires_in\\\" value (%s) to a number\",\n\t\t\t\t\texpires_in);\n\t\t\treturn -1;\n\t\t}\n\t\treturn number;\n\t}\n\treturn -1;\n}\n\n/*\n * handle the different flows (hybrid, implicit, Authorization Code)\n */\nstatic apr_byte_t oidc_handle_flows(request_rec *r, oidc_cfg *c,\n\t\toidc_proto_state_t *proto_state, oidc_provider_t *provider,\n\t\tapr_table_t *params, const char *response_mode, oidc_jwt_t **jwt) {\n\n\tapr_byte_t rc = FALSE;\n\n\tconst char *requested_response_type = oidc_proto_state_get_response_type(\n\t\t\tproto_state);\n\n\t/* handle the requested response type/mode */\n\tif (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN_TOKEN)) {\n\t\trc = oidc_proto_authorization_response_code_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN)) {\n\t\trc = oidc_proto_authorization_response_code_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_TOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_code_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE)) {\n\t\trc = oidc_proto_handle_authorization_response_code(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_IDTOKEN_TOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_IDTOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else {\n\t\toidc_error(r, \"unsupported response type: \\\"%s\\\"\",\n\t\t\t\trequested_response_type);\n\t}\n\n\tif ((rc == FALSE) && (*jwt != NULL)) {\n\t\toidc_jwt_destroy(*jwt);\n\t\t*jwt = NULL;\n\t}\n\n\treturn rc;\n}\n\n/* handle the browser back on an authorization response */\nstatic apr_byte_t oidc_handle_browser_back(request_rec *r, const char *r_state,\n\t\toidc_session_t *session) {\n\n\t/*  see if we have an existing session and browser-back was used */\n\tconst char *s_state = NULL, *o_url = NULL;\n\n\tif (session->remote_user != NULL) {\n\n\t\ts_state = oidc_session_get_request_state(r, session);\n\t\to_url = oidc_session_get_original_url(r, session);\n\n\t\tif ((r_state != NULL) && (s_state != NULL)\n\t\t\t\t&& (apr_strnatcmp(r_state, s_state) == 0)) {\n\n\t\t\t/* log the browser back event detection */\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"browser back detected, redirecting to original URL: %s\",\n\t\t\t\t\to_url);\n\n\t\t\t/* go back to the URL that he originally tried to access */\n\t\t\toidc_util_hdr_out_location_set(r, o_url);\n\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n/*\n * complete the handling of an authorization response by obtaining, parsing and verifying the\n * id_token and storing the authenticated user state in the session\n */\nstatic int oidc_handle_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, apr_table_t *params, const char *response_mode) {\n\n\toidc_debug(r, \"enter, response_mode=%s\", response_mode);\n\n\toidc_provider_t *provider = NULL;\n\toidc_proto_state_t *proto_state = NULL;\n\toidc_jwt_t *jwt = NULL;\n\n\t/* see if this response came from a browser-back event */\n\tif (oidc_handle_browser_back(r, apr_table_get(params, OIDC_PROTO_STATE),\n\t\t\tsession) == TRUE)\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\n\t/* match the returned state parameter against the state stored in the browser */\n\tif (oidc_authorization_response_match_state(r, c,\n\t\t\tapr_table_get(params, OIDC_PROTO_STATE), &provider, &proto_state)\n\t\t\t== FALSE) {\n\t\tif (c->default_sso_url != NULL) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"invalid authorization response state; a default SSO URL is set, sending the user there: %s\",\n\t\t\t\t\tc->default_sso_url);\n\t\t\toidc_util_hdr_out_location_set(r, c->default_sso_url);\n\t\t\t//oidc_util_hdr_err_out_add(r, \"Location\", c->default_sso_url));\n\t\t\treturn HTTP_MOVED_TEMPORARILY;\n\t\t}\n\t\toidc_error(r,\n\t\t\t\t\"invalid authorization response state and no default SSO URL is set, sending an error...\");\n\t\t// if content was already returned via html/http send then don't return 500\n\t\t// but send 200 to avoid extraneous internal error document text to be sent\n\t\treturn ((r->user) && (strncmp(r->user, \"\", 1) == 0)) ?\n\t\t\t\tOK :\n\t\t\t\tHTTP_BAD_REQUEST;\n\t}\n\n\t/* see if the response is an error response */\n\tif (apr_table_get(params, OIDC_PROTO_ERROR) != NULL)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ERROR),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ERROR_DESCRIPTION));\n\n\t/* handle the code, implicit or hybrid flow */\n\tif (oidc_handle_flows(r, c, proto_state, provider, params, response_mode,\n\t\t\t&jwt) == FALSE)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Error in handling response type.\", NULL);\n\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no id_token was provided\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"No id_token was provided.\", NULL);\n\t}\n\n\tint expires_in = oidc_parse_expires_in(r,\n\t\t\tapr_table_get(params, OIDC_PROTO_EXPIRES_IN));\n\tchar *userinfo_jwt = NULL;\n\n\t/*\n\t * optionally resolve additional claims against the userinfo endpoint\n\t * parsed claims are not actually used here but need to be parsed anyway for error checking purposes\n\t */\n\tconst char *claims = oidc_retrieve_claims_from_userinfo_endpoint(r, c,\n\t\t\tprovider, apr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), NULL,\n\t\t\tjwt->payload.sub, &userinfo_jwt);\n\n\t/* restore the original protected URL that the user was trying to access */\n\tconst char *original_url = oidc_proto_state_get_original_url(proto_state);\n\tif (original_url != NULL)\n\t\toriginal_url = apr_pstrdup(r->pool, original_url);\n\tconst char *original_method = oidc_proto_state_get_original_method(\n\t\t\tproto_state);\n\tif (original_method != NULL)\n\t\toriginal_method = apr_pstrdup(r->pool, original_method);\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\n\t/* set the user */\n\tif (oidc_set_request_user(r, c, provider, jwt, claims) == TRUE) {\n\n\t\t/* session management: if the user in the new response is not equal to the old one, error out */\n\t\tif ((prompt != NULL)\n\t\t\t\t&& (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {\n\t\t\t// TOOD: actually need to compare sub? (need to store it in the session separately then\n\t\t\t//const char *sub = NULL;\n\t\t\t//oidc_session_get(r, session, \"sub\", &sub);\n\t\t\t//if (apr_strnatcmp(sub, jwt->payload.sub) != 0) {\n\t\t\tif (apr_strnatcmp(session->remote_user, r->user) != 0) {\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"user set from new id_token is different from current one\");\n\t\t\t\toidc_jwt_destroy(jwt);\n\t\t\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\t\t\"User changed!\", NULL);\n\t\t\t}\n\t\t}\n\n\t\t/* store resolved information in the session */\n\t\tif (oidc_save_in_session(r, c, session, provider, r->user,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ID_TOKEN), jwt, claims,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), expires_in,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_REFRESH_TOKEN),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_SESSION_STATE),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_STATE), original_url,\n\t\t\t\tuserinfo_jwt) == FALSE) {\n\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\n\t} else {\n\t\toidc_error(r, \"remote user could not be set\");\n\t\toidc_jwt_destroy(jwt);\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Remote user could not be set: contact the website administrator\",\n\t\t\t\tNULL);\n\t}\n\n\t/* cleanup */\n\toidc_proto_state_destroy(proto_state);\n\toidc_jwt_destroy(jwt);\n\n\t/* check that we've actually authenticated a user; functions as error handling for oidc_get_remote_user */\n\tif (r->user == NULL)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* log the successful response */\n\toidc_debug(r,\n\t\t\t\"session created and stored, returning to original URL: %s, original method: %s\",\n\t\t\toriginal_url, original_method);\n\n\t/* check whether form post data was preserved; if so restore it */\n\tif (apr_strnatcmp(original_method, OIDC_METHOD_FORM_POST) == 0) {\n\t\treturn oidc_request_post_preserved_restore(r, original_url);\n\t}\n\n\t/* now we've authenticated the user so go back to the URL that he originally tried to access */\n\toidc_util_hdr_out_location_set(r, original_url);\n\n\t/* do the actual redirect to the original URL */\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the POST (+fragment->POST) response_mode\n */\nstatic int oidc_handle_post_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* initialize local variables */\n\tchar *response_mode = NULL;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if we've got any POST-ed data at all */\n\tif ((apr_table_elts(params)->nelts < 1)\n\t\t\t|| ((apr_table_elts(params)->nelts == 1)\n\t\t\t\t\t&& apr_table_get(params, OIDC_PROTO_RESPONSE_MODE)\n\t\t\t\t\t&& (apr_strnatcmp(\n\t\t\t\t\t\t\tapr_table_get(params, OIDC_PROTO_RESPONSE_MODE),\n\t\t\t\t\t\t\tOIDC_PROTO_RESPONSE_MODE_FRAGMENT) == 0))) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"You've hit an OpenID Connect Redirect URI with no parameters, this is an invalid request; you should not open this URL in your browser directly, or have the server administrator use a different \" OIDCRedirectURI \" setting.\",\n\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t}\n\n\t/* get the parameters */\n\tresponse_mode = (char*) apr_table_get(params, OIDC_PROTO_RESPONSE_MODE);\n\n\t/* do the actual implicit work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tresponse_mode ? response_mode : OIDC_PROTO_RESPONSE_MODE_FORM_POST);\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the redirect response_mode\n */\nstatic int oidc_handle_redirect_authorization_response(request_rec *r,\n\t\toidc_cfg *c, oidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* read the parameters from the query string */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\toidc_util_read_form_encoded_params(r, params, r->args);\n\n\t/* do the actual work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tOIDC_PROTO_RESPONSE_MODE_QUERY);\n}\n\n/*\n * present the user with an OP selection screen\n */\nstatic int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *path_scopes = oidc_dir_cfg_path_scope(r);\n\tchar *path_auth_request_params = oidc_dir_cfg_path_auth_request_params(r);\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \"%s%s%s=%s&%s=%s&%s=%s&%s=%s\",\n\t\t\t\tdiscover_url,\n\t\t\t\tstrchr(discover_url, OIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, oidc_get_redirect_uri(r, cfg)),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\tif (path_scopes != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_SC_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \"redirecting to external discovery page: %s\", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\t\tOIDC_COOKIE_SAMESITE_STRICT(cfg, r));\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn OK;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\toidc_util_hdr_out_location_set(r, url);\n\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\"Configuration Error\",\n\t\t\t\t\"No configured providers found, contact your administrator\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \"\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\t\t// TODO: html escape (especially & character)\n\n\t\tchar *href = apr_psprintf(r->pool,\n\t\t\t\t\"%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\",\n\t\t\t\toidc_get_redirect_uri(r, cfg), OIDC_DISC_OP_PARAM,\n\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\tOIDC_CSRF_NAME, csrf);\n\n\t\tif (path_scopes != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_SC_PARAM, oidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\n\t\t/* strip port number */\n\t\t//char *p = strstr(display, \":\");\n\t\t//if (p != NULL) *p = '\\0';\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts = apr_psprintf(r->pool, \"%s<p><a href=\\\"%s\\\">%s</a></p>\\n\", s, href,\n\t\t\t\tdisplay);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \"%s<form method=\\\"get\\\" action=\\\"%s\\\">\\n\", s,\n\t\t\toidc_get_redirect_uri(r, cfg));\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\n\tif (path_scopes != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_SC_PARAM, path_scopes);\n\tif (path_auth_request_params != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_AR_PARAM, path_auth_request_params);\n\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"text\\\" name=\\\"%s\\\" value=\\\"%s\\\"></p>\\n\", s,\n\t\t\tOIDC_DISC_OP_PARAM, \"\");\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"submit\\\" value=\\\"Submit\\\"></p>\\n\", s);\n\ts = apr_psprintf(r->pool, \"%s</form>\\n\", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\tOIDC_COOKIE_SAMESITE_STRICT(cfg, r));\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\"<style type=\\\"text/css\\\">body {text-align: center}</style>\";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript, &javascript_method)\n\t\t\t== TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \"%s%s\", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \"OpenID Connect Provider Discovery\",\n\t\t\thtml_head, javascript_method, s, OK);\n}\n\n/*\n * authenticate the user to the selected OP, if the OP is not selected yet perform discovery first\n */\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params, const char *path_scope) {\n\n\toidc_debug(r, \"enter\");\n\n\tif (provider == NULL) {\n\n\t\t// TODO: should we use an explicit redirect to the discovery endpoint (maybe a \"discovery\" param to the redirect_uri)?\n\t\tif (c->metadata_dir != NULL) {\n\t\t\t/*\n\t\t\t * Will be handled in the content handler; avoid:\n\t\t\t * No authentication done but request not allowed without authentication\n\t\t\t * by setting r->user\n\t\t\t */\n\t\t\toidc_debug(r, \"defer discovery to the content handler\");\n\t\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_DISCOVERY, \"\");\n\t\t\tr->user = \"\";\n\t\t\treturn OK;\n\t\t}\n\n\t\t/* we're not using multiple OP's configured in a metadata directory, pick the statically configured OP */\n\t\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* generate the random nonce value that correlates requests and responses */\n\tchar *nonce = NULL;\n\tif (oidc_proto_generate_nonce(r, &nonce, OIDC_PROTO_NONCE_LENGTH) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *pkce_state = NULL;\n\tchar *code_challenge = NULL;\n\n\tif ((oidc_util_spaced_string_contains(r->pool, provider->response_type,\n\t\t\tOIDC_PROTO_CODE) == TRUE) && (provider->pkce != NULL)) {\n\n\t\t/* generate the code verifier value that correlates authorization requests and code exchange requests */\n\t\tif (provider->pkce->state(r, &pkce_state) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t/* generate the PKCE code challenge */\n\t\tif (provider->pkce->challenge(r, pkce_state, &code_challenge) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* create the state between request/response */\n\toidc_proto_state_t *proto_state = oidc_proto_state_new();\n\toidc_proto_state_set_original_url(proto_state, original_url);\n\toidc_proto_state_set_original_method(proto_state,\n\t\t\toidc_original_request_method(r, c, TRUE));\n\toidc_proto_state_set_issuer(proto_state, provider->issuer);\n\toidc_proto_state_set_response_type(proto_state, provider->response_type);\n\toidc_proto_state_set_nonce(proto_state, nonce);\n\toidc_proto_state_set_timestamp_now(proto_state);\n\tif (provider->response_mode)\n\t\toidc_proto_state_set_response_mode(proto_state,\n\t\t\t\tprovider->response_mode);\n\tif (prompt)\n\t\toidc_proto_state_set_prompt(proto_state, prompt);\n\tif (pkce_state)\n\t\toidc_proto_state_set_pkce_state(proto_state, pkce_state);\n\n\t/* get a hash value that fingerprints the browser concatenated with the random input */\n\tchar *state = oidc_get_browser_state_hash(r, c, nonce);\n\n\t/*\n\t * create state that restores the context when the authorization response comes in\n\t * and cryptographically bind it to the browser\n\t */\n\tint rc = oidc_authorization_request_set_cookie(r, c, state, proto_state);\n\tif (rc != OK) {\n\t\toidc_proto_state_destroy(proto_state);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * printout errors if Cookie settings are not going to work\n\t * TODO: separate this code out into its own function\n\t */\n\tapr_uri_t o_uri;\n\tmemset(&o_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_t r_uri;\n\tmemset(&r_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_parse(r->pool, original_url, &o_uri);\n\tapr_uri_parse(r->pool, oidc_get_redirect_uri(r, c), &r_uri);\n\tif ((apr_strnatcmp(o_uri.scheme, r_uri.scheme) != 0)\n\t\t\t&& (apr_strnatcmp(r_uri.scheme, \"https\") == 0)) {\n\t\toidc_error(r,\n\t\t\t\t\"the URL scheme (%s) of the configured \" OIDCRedirectURI \" does not match the URL scheme of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\tr_uri.scheme, o_uri.scheme);\n\t\toidc_proto_state_destroy(proto_state);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (c->cookie_domain == NULL) {\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured \" OIDCRedirectURI \" does not match the URL hostname of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!oidc_util_cookie_domain_valid(r_uri.hostname, c->cookie_domain)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in \" OIDCCookieDomain \" does not match the URL hostname (%s) of the URL being accessed (%s): setting \\\"state\\\" and \\\"session\\\" cookies will not work!!\",\n\t\t\t\t\tc->cookie_domain, o_uri.hostname, original_url);\n\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n\n\t/* send off to the OpenID Connect Provider */\n\t// TODO: maybe show intermediate/progress screen \"redirecting to\"\n\treturn oidc_proto_authorization_request(r, provider, login_hint,\n\t\t\toidc_get_redirect_uri_iss(r, c, provider), state, proto_state,\n\t\t\tid_token_hint, code_challenge, auth_request_params, path_scope);\n}\n\n/*\n * check if the target_link_uri matches to configuration settings to prevent an open redirect\n */\nstatic int oidc_target_link_uri_matches_configuration(request_rec *r,\n\t\toidc_cfg *cfg, const char *target_link_uri) {\n\n\tapr_uri_t o_uri;\n\tapr_uri_parse(r->pool, target_link_uri, &o_uri);\n\tif (o_uri.hostname == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse the \\\"target_link_uri\\\" (%s) in to a valid URL: aborting.\",\n\t\t\t\ttarget_link_uri);\n\t\treturn FALSE;\n\t}\n\n\tapr_uri_t r_uri;\n\tapr_uri_parse(r->pool, oidc_get_redirect_uri(r, cfg), &r_uri);\n\n\tif (cfg->cookie_domain == NULL) {\n\t\t/* cookie_domain set: see if the target_link_uri matches the redirect_uri host (because the session cookie will be set host-wide) */\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured \" OIDCRedirectURI \" does not match the URL hostname of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* cookie_domain set: see if the target_link_uri is within the cookie_domain */\n\t\tchar *p = strstr(o_uri.hostname, cfg->cookie_domain);\n\t\tif ((p == NULL) || (apr_strnatcmp(cfg->cookie_domain, p) != 0)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in \" OIDCCookieDomain \" does not match the URL hostname (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.hostname, target_link_uri);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* see if the cookie_path setting matches the target_link_uri path */\n\tchar *cookie_path = oidc_cfg_dir_cookie_path(r);\n\tif (cookie_path != NULL) {\n\t\tchar *p = (o_uri.path != NULL) ? strstr(o_uri.path, cookie_path) : NULL;\n\t\tif ((p == NULL) || (p != o_uri.path)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the path (%s) configured in \" OIDCCookiePath \" does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\treturn FALSE;\n\t\t} else if (strlen(o_uri.path) > strlen(cookie_path)) {\n\t\t\tint n = strlen(cookie_path);\n\t\t\tif (cookie_path[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\t\t\tn--;\n\t\t\tif (o_uri.path[n] != OIDC_CHAR_FORWARD_SLASH) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the path (%s) configured in \" OIDCCookiePath \" does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n#define OIDC_MAX_URL_LENGTH 8192 * 2\n\nstatic apr_byte_t oidc_validate_redirect_url(request_rec *r, oidc_cfg *c,\n\t\tconst char *redirect_to_url, apr_byte_t restrict_to_host, char **err_str,\n\t\tchar **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\tapr_hash_index_t *hi = NULL;\n\tsize_t i = 0;\n\tchar *url = apr_pstrndup(r->pool, redirect_to_url, OIDC_MAX_URL_LENGTH);\n\n\t// replace potentially harmful backslashes with forward slashes\n\tfor (i = 0; i < strlen(url); i++)\n\t\tif (url[i] == '\\\\')\n\t\t\turl[i] = '/';\n\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"not a valid URL value: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\tif (c->redirect_urls_allowed != NULL) {\n\t\tfor (hi = apr_hash_first(NULL, c->redirect_urls_allowed); hi; hi =\n\t\t\t\tapr_hash_next(hi)) {\n\t\t\tapr_hash_this(hi, (const void**) &c_host, NULL, NULL);\n\t\t\tif (oidc_util_regexp_first_match(r->pool, url, c_host,\n\t\t\t\t\tNULL, err_str) == TRUE)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (hi == NULL) {\n\t\t\t*err_str = apr_pstrdup(r->pool, \"URL not allowed\");\n\t\t\t*err_desc =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"value does not match the list of allowed redirect URLs: %s\",\n\t\t\t\t\t\t\turl);\n\t\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\t\treturn FALSE;\n\t\t}\n\t} else if ((uri.hostname != NULL) && (restrict_to_host == TRUE)) {\n\t\tc_host = oidc_get_current_url_host(r);\n\t\tif ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL)) {\n\t\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t\t*err_desc =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"URL value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"//\") == url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool,\n\t\t\t\t\"No hostname was parsed and starting with '//': %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\\\\\") == url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool,\n\t\t\t\t\"No hostname was parsed and starting with '/\\\\': %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the URL to prevent HTTP header splitting */\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"URL value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * handle a response from an IDP discovery page and/or handle 3rd-party initiated SSO\n */\nstatic int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL, *path_scopes;\n\toidc_provider_t *provider = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_SC_PARAM, &path_scopes);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0,\n\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because \" OIDCDefaultURL \" is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention, step 1 */\n\tif (oidc_target_link_uri_matches_configuration(r, c, target_link_uri)\n\t\t\t== FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* do input validation on the target_link_uri parameter value, step 2 */\n\tif (oidc_validate_redirect_url(r, c, target_link_uri, TRUE, &error_str,\n\t\t\t&error_description) == FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\terror_description,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* see if this is a static setup */\n\tif (c->metadata_dir == NULL) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == TRUE)\n\t\t\t\t&& (issuer != NULL)) {\n\t\t\tif (apr_strnatcmp(provider->issuer, issuer) != 0) {\n\t\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\t\"The \\\"iss\\\" value must match the configured providers' one (%s != %s).\",\n\t\t\t\t\t\t\t\tissuer, c->provider.issuer),\n\t\t\t\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t\treturn oidc_authenticate_user(r, c, NULL, target_link_uri, login_hint,\n\t\t\t\tNULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, OIDC_STR_AT) != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, OIDC_STR_AT);\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer)\n\t\t\t\t== FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}\n\nstatic apr_uint32_t oidc_transparent_pixel[17] = { 0x474e5089, 0x0a1a0a0d,\n\t\t0x0d000000, 0x52444849, 0x01000000, 0x01000000, 0x00000408, 0x0c1cb500,\n\t\t0x00000002, 0x4144490b, 0x639c7854, 0x0000cffa, 0x02010702, 0x71311c9a,\n\t\t0x00000000, 0x444e4549, 0x826042ae };\n\nstatic apr_byte_t oidc_is_front_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL)\n\t\t\t&& ((apr_strnatcmp(logout_param_value,\n\t\t\t\t\tOIDC_GET_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t\t|| (apr_strnatcmp(logout_param_value,\n\t\t\t\t\t\t\tOIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)));\n}\n\nstatic apr_byte_t oidc_is_back_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL) && (apr_strnatcmp(logout_param_value,\n\t\t\tOIDC_BACKCHANNEL_STYLE_LOGOUT_PARAM_VALUE) == 0));\n}\n\n/*\n * revoke refresh token and access token stored in the session if the\n * OP has an RFC 7009 compliant token revocation endpoint\n */\nstatic void oidc_revoke_tokens(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *response = NULL;\n\tchar *basic_auth = NULL;\n\tchar *bearer_auth = NULL;\n\tapr_table_t *params = NULL;\n\tconst char *token = NULL;\n\toidc_provider_t *provider = NULL;\n\n\toidc_debug(r, \"enter\");\n\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE)\n\t\tgoto out;\n\n\toidc_debug(r, \"revocation_endpoint=%s\",\n\t\t\tprovider->revocation_endpoint_url ?\n\t\t\t\t\tprovider->revocation_endpoint_url : \"(null)\");\n\n\tif (provider->revocation_endpoint_url == NULL)\n\t\tgoto out;\n\n\tparams = apr_table_make(r->pool, 4);\n\n\t// add the token endpoint authentication credentials to the revocation endpoint call...\n\tif (oidc_proto_token_endpoint_auth(r, c, provider->token_endpoint_auth,\n\t\t\tprovider->client_id, provider->client_secret,\n\t\t\tprovider->client_signing_keys, provider->token_endpoint_url, params,\n\t\t\tNULL, &basic_auth, &bearer_auth) == FALSE)\n\t\tgoto out;\n\n\t// TODO: use oauth.ssl_validate_server ...\n\ttoken = oidc_session_get_refresh_token(r, session);\n\tif (token != NULL) {\n\t\tapr_table_setn(params, OIDC_PROTO_TOKEN_TYPE_HINT, OIDC_PROTO_REFRESH_TOKEN);\n\t\tapr_table_setn(params, OIDC_PROTO_TOKEN, token);\n\n\t\tif (oidc_util_http_post_form(r, provider->revocation_endpoint_url,\n\t\t\t\tparams, basic_auth, bearer_auth, c->oauth.ssl_validate_server,\n\t\t\t\t&response, c->http_timeout_long, c->outgoing_proxy,\n\t\t\t\toidc_dir_cfg_pass_cookies(r), NULL,\n\t\t\t\tNULL, NULL) == FALSE) {\n\t\t\toidc_warn(r, \"revoking refresh token failed\");\n\t\t}\n\t\tapr_table_unset(params, OIDC_PROTO_TOKEN_TYPE_HINT);\n\t\tapr_table_unset(params, OIDC_PROTO_TOKEN);\n\t}\n\n\ttoken = oidc_session_get_access_token(r, session);\n\tif (token != NULL) {\n\t\tapr_table_setn(params, OIDC_PROTO_TOKEN_TYPE_HINT, OIDC_PROTO_ACCESS_TOKEN);\n\t\tapr_table_setn(params, OIDC_PROTO_TOKEN, token);\n\n\t\tif (oidc_util_http_post_form(r, provider->revocation_endpoint_url,\n\t\t\t\tparams, basic_auth, bearer_auth, c->oauth.ssl_validate_server,\n\t\t\t\t&response, c->http_timeout_long, c->outgoing_proxy,\n\t\t\t\toidc_dir_cfg_pass_cookies(r), NULL,\n\t\t\t\tNULL, NULL) == FALSE) {\n\t\t\toidc_warn(r, \"revoking access token failed\");\n\t\t}\n\t}\n\nout:\n\n\toidc_debug(r, \"leave\");\n}\n\n/*\n * handle a local logout\n */\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url) {\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\t/* if there's no remote_user then there's no (stored) session to kill */\n\tif (session->remote_user != NULL)\n\t\toidc_revoke_tokens(r, c, session);\n\n\t/*\n\t * remove session state (cq. cache entry and cookie)\n\t * always clear the session cookie because the cookie may be not sent (but still in the browser)\n\t * due to SameSite policies\n\t */\n\toidc_session_kill(r, session);\n\n\t/* see if this is the OP calling us */\n\tif (oidc_is_front_channel_logout(url)) {\n\n\t\t/* set recommended cache control headers */\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,\n\t\t\t\t\"no-cache, no-store\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_PRAGMA, \"no-cache\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_P3P, \"CAO PSA OUR\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_EXPIRES, \"0\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_X_FRAME_OPTIONS, \"DENY\");\n\n\t\t/* see if this is PF-PA style logout in which case we return a transparent pixel */\n\t\tconst char *accept = oidc_util_hdr_in_accept_get(r);\n\t\tif ((apr_strnatcmp(url, OIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t|| ((accept) && strstr(accept, OIDC_CONTENT_TYPE_IMAGE_PNG))) {\n\t\t\treturn oidc_util_http_send(r, (const char*) &oidc_transparent_pixel,\n\t\t\t\t\tsizeof(oidc_transparent_pixel), OIDC_CONTENT_TYPE_IMAGE_PNG,\n\t\t\t\t\tOK);\n\t\t}\n\n\t\t/* standard HTTP based logout: should be called in an iframe from the OP */\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", OK);\n\t}\n\n\t/* see if we don't need to go somewhere special after killing the session locally */\n\tif (url == NULL)\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", OK);\n\n\t/* send the user to the specified where-to-go-after-logout URL */\n\toidc_util_hdr_out_location_set(r, url);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle a backchannel logout\n */\n#define OIDC_EVENTS_BLOGOUT_KEY \"http://schemas.openid.net/event/backchannel-logout\"\n\nstatic int oidc_handle_logout_backchannel(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *logout_token = NULL;\n\toidc_jwt_t *jwt = NULL;\n\toidc_jose_error_t err;\n\toidc_jwk_t *jwk = NULL;\n\toidc_provider_t *provider = NULL;\n\tchar *sid = NULL, *uuid = NULL;\n\toidc_session_t session;\n\tint rc = HTTP_BAD_REQUEST;\n\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"could not read POST-ed parameters to the logout endpoint\");\n\t\tgoto out;\n\t}\n\n\tlogout_token = apr_table_get(params, OIDC_PROTO_LOGOUT_TOKEN);\n\tif (logout_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"backchannel lggout endpoint was called but could not find a parameter named \\\"%s\\\"\",\n\t\t\t\tOIDC_PROTO_LOGOUT_TOKEN);\n\t\tgoto out;\n\t}\n\n\t// TODO: jwk symmetric key based on provider\n\n\tif (oidc_jwt_parse(r->pool, logout_token, &jwt,\n\t\t\toidc_util_merge_symmetric_key(r->pool, cfg->private_keys, NULL),\n\t\t\t&err) == FALSE) {\n\t\toidc_error(r, \"oidc_jwt_parse failed: %s\", oidc_jose_e2s(r->pool, err));\n\t\tgoto out;\n\t}\n\n\tif ((jwt->header.alg == NULL) || (strcmp(jwt->header.alg, \"none\") == 0)) {\n\t\toidc_error(r, \"logout token is not signed\");\n\t\tgoto out;\n\t}\n\n\tprovider = oidc_get_provider_for_issuer(r, cfg, jwt->payload.iss, FALSE);\n\tif (provider == NULL) {\n\t\toidc_error(r, \"no provider found for issuer: %s\", jwt->payload.iss);\n\t\tgoto out;\n\t}\n\n\t// TODO: destroy the JWK used for decryption\n\n\tjwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, provider->client_secret, 0,\n\t\t\tNULL, TRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwks_uri_t jwks_uri = { provider->jwks_uri,\n\t\t\tprovider->jwks_refresh_interval, provider->ssl_validate_server };\n\tif (oidc_proto_jwt_verify(r, cfg, jwt, &jwks_uri,\n\t\t\toidc_util_merge_symmetric_key(r->pool, NULL, jwk),\n\t\t\tprovider->id_token_signed_response_alg) == FALSE) {\n\n\t\toidc_error(r, \"id_token signature could not be validated, aborting\");\n\t\tgoto out;\n\t}\n\n\t// oidc_proto_validate_idtoken would try and require a token binding cnf\n\t// if the policy is set to \"required\", so don't use that here\n\tif (oidc_proto_validate_jwt(r, jwt,\n\t\t\tprovider->validate_issuer ? provider->issuer : NULL, FALSE, FALSE,\n\t\t\t\t\tprovider->idtoken_iat_slack,\n\t\t\t\t\tOIDC_TOKEN_BINDING_POLICY_DISABLED) == FALSE)\n\t\tgoto out;\n\n\t/* verify the \"aud\" and \"azp\" values */\n\tif (oidc_proto_validate_aud_and_azp(r, cfg, provider, &jwt->payload)\n\t\t\t== FALSE)\n\t\tgoto out;\n\n\tjson_t *events = json_object_get(jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_EVENTS);\n\tif (events == NULL) {\n\t\toidc_error(r, \"\\\"%s\\\" claim could not be found in logout token\",\n\t\t\t\tOIDC_CLAIM_EVENTS);\n\t\tgoto out;\n\t}\n\n\tjson_t *blogout = json_object_get(events, OIDC_EVENTS_BLOGOUT_KEY);\n\tif (!json_is_object(blogout)) {\n\t\toidc_error(r, \"\\\"%s\\\" object could not be found in \\\"%s\\\" claim\",\n\t\t\t\tOIDC_EVENTS_BLOGOUT_KEY, OIDC_CLAIM_EVENTS);\n\t\tgoto out;\n\t}\n\n\tchar *nonce = NULL;\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_NONCE, &nonce, NULL);\n\tif (nonce != NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"rejecting logout request/token since it contains a \\\"%s\\\" claim\",\n\t\t\t\tOIDC_CLAIM_NONCE);\n\t\tgoto out;\n\t}\n\n\tchar *jti = NULL;\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_JTI, &jti, NULL);\n\tif (jti != NULL) {\n\t\tchar *replay = NULL;\n\t\toidc_cache_get_jti(r, jti, &replay);\n\t\tif (replay != NULL) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the \\\"%s\\\" value (%s) passed in logout token was found in the cache already; possible replay attack!?\",\n\t\t\t\t\tOIDC_CLAIM_JTI, jti);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* jti cache duration is the configured replay prevention window for token issuance plus 10 seconds for safety */\n\tapr_time_t jti_cache_duration = apr_time_from_sec(\n\t\t\tprovider->idtoken_iat_slack * 2 + 10);\n\n\t/* store it in the cache for the calculated duration */\n\toidc_cache_set_jti(r, jti, jti, apr_time_now() + jti_cache_duration);\n\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_EVENTS, &sid, NULL);\n\n\t// TODO: by-spec we should cater for the fact that \"sid\" has been provided\n\t//       in the id_token returned in the authentication request, but \"sub\"\n\t//       is used in the logout token but that requires a 2nd entry in the\n\t//       cache and a separate session \"sub\" member, ugh; we'll just assume\n\t//       that is \"sid\" is specified in the id_token, the OP will actually use\n\t//       this for logout\n\t//       (and probably call us multiple times or the same sub if needed)\n\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_SID, &sid, NULL);\n\tif (sid == NULL)\n\t\tsid = jwt->payload.sub;\n\n\tif (sid == NULL) {\n\t\toidc_error(r, \"no \\\"sub\\\" and no \\\"sid\\\" claim found in logout token\");\n\t\tgoto out;\n\t}\n\n\t// TODO: when dealing with sub instead of a true sid, we'll be killing all sessions for\n\t//       a specific user, across hosts that share the *same* cache backend\n\t//       if those hosts haven't been configured with a different OIDCCryptoPassphrase\n\t//       - perhaps that's even acceptable since non-memory caching is encrypted by default\n\t//         and memory-based caching doesn't suffer from this (different shm segments)?\n\t//       - it will result in 400 errors returned from backchannel logout calls to the other hosts...\n\n\tsid = oidc_make_sid_iss_unique(r, sid, provider->issuer);\n\toidc_cache_get_sid(r, sid, &uuid);\n\tif (uuid == NULL) {\n\t\t// this may happen when we are the caller\n\t\toidc_warn(r,\n\t\t\t\t\"could not (or no longer) find a session based on sid/sub provided in logout token: %s\",\n\t\t\t\tsid);\n\t\tr->user = \"\";\n\t\trc = OK;\n\t\tgoto out;\n\t}\n\n\t// revoke tokens if we can get a handle on those\n\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\tif (oidc_session_load_cache_by_uuid(r, cfg, uuid, &session) != FALSE)\n\t\t\tif (oidc_session_extract(r, &session) != FALSE)\n\t\t\t\toidc_revoke_tokens(r, cfg, &session);\n\t}\n\n\t// clear the session cache\n\toidc_cache_set_sid(r, sid, NULL, 0);\n\toidc_cache_set_session(r, uuid, NULL, 0);\n\n\tr->user = \"\";\n\trc = OK;\n\nout:\n\n\tif (jwk != NULL) {\n\t\toidc_jwk_destroy(jwk);\n\t\tjwk = NULL;\n\n\t}\n\tif (jwt != NULL) {\n\t\toidc_jwt_destroy(jwt);\n\t\tjwt = NULL;\n\t}\n\n\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,\n\t\t\t\"no-cache, no-store\");\n\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_PRAGMA, \"no-cache\");\n\n\treturn rc;\n}\n\n\n/*\n * perform (single) logout\n */\nstatic int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\t\tif (oidc_validate_redirect_url(r, c, url, TRUE, &error_str,\n\t\t\t\t&error_description) == FALSE) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\t\terror_description,\n\t\t\t\t\tHTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\t//char *state = NULL;\n\t\t//oidc_proto_generate_nonce(r, &state, 8);\n\t\t//url = apr_psprintf(r->pool, \"%s&state=%s\", logout_request, state);\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}\n\n/*\n * handle request for JWKs\n */\nint oidc_handle_jwks(request_rec *r, oidc_cfg *c) {\n\n\t/* pickup requested JWKs type */\n\t//\tchar *jwks_type = NULL;\n\t//\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_JWKS, &jwks_type);\n\tchar *jwks = apr_pstrdup(r->pool, \"{ \\\"keys\\\" : [\");\n\tint i = 0;\n\tapr_byte_t first = TRUE;\n\toidc_jose_error_t err;\n\n\tif (c->public_keys != NULL) {\n\n\t\t/* loop over the RSA public keys */\n\t\tfor (i = 0; i < c->public_keys->nelts; i++) {\n\t\t\tconst oidc_jwk_t *jwk =\n\t\t\t\t\t((const oidc_jwk_t**) c->public_keys->elts)[i];\n\t\t\tchar *s_json = NULL;\n\n\t\t\tif (oidc_jwk_to_json(r->pool, jwk, &s_json, &err) == TRUE) {\n\t\t\t\tjwks = apr_psprintf(r->pool, \"%s%s %s \", jwks, first ? \"\" : \",\",\n\t\t\t\t\t\ts_json);\n\t\t\t\tfirst = FALSE;\n\t\t\t} else {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"could not convert RSA JWK to JSON using oidc_jwk_to_json: %s\",\n\t\t\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: send stuff if first == FALSE?\n\tjwks = apr_psprintf(r->pool, \"%s ] }\", jwks);\n\n\treturn oidc_util_http_send(r, jwks, strlen(jwks), OIDC_CONTENT_TYPE_JSON,\n\t\t\tOK);\n}\n\nstatic int oidc_handle_session_management_iframe_op(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *check_session_iframe) {\n\toidc_debug(r, \"enter\");\n\toidc_util_hdr_out_location_set(r, check_session_iframe);\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\nstatic int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var clientId  = '%s';\\n\"\n\t\t\t\"      var sessionId  = '%s';\\n\"\n\t\t\t\"      var loginUrl  = '%s';\\n\"\n\t\t\t\"      var message = clientId + ' ' + sessionId;\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %d);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed' && sessionId == '' ) {\\n\"\n\t\t\t\"\t\t\t // 'changed' + no session: enforce a login (if we have a login url...)\\n\"\n\t\t\t\"            if (loginUrl != '') {\\n\"\n\t\t\t\"              window.top.location.replace(loginUrl);\\n\"\n\t\t\t\"            }\\n\"\n\t\t\t\"\t\t   } else {\\n\"\n\t\t\t\"              // either 'changed' + active session, or 'error': enforce a logout\\n\"\n\t\t\t\"              window.top.location.replace('%s?logout=' + encodeURIComponent(window.top.location.href));\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\t//return OK;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;\n\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))\n\t\tpoll_interval = 3000;\n\n\tchar *login_uri = NULL, *error_str = NULL, *error_description = NULL;\n\toidc_util_get_request_parameter(r, \"login_uri\", &login_uri);\n\tif ((login_uri != NULL)\n\t\t\t&& (oidc_validate_redirect_url(r, c, login_uri, FALSE, &error_str,\n\t\t\t\t\t&error_description) == FALSE)) {\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state ? session_state : \"\", login_uri ? login_uri : \"\",\n\t\t\t\t\top_iframe_id, poll_interval, redirect_uri, redirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, OK);\n}\n\n/*\n * handle session management request\n */\nstatic int oidc_handle_session_management(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tchar *cmd = NULL;\n\tconst char *id_token_hint = NULL;\n\toidc_provider_t *provider = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_SESSION, &cmd);\n\tif (cmd == NULL) {\n\t\toidc_error(r, \"session management handler called with no command\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if this is a local logout during session management */\n\tif (apr_strnatcmp(\"logout\", cmd) == 0) {\n\t\toidc_debug(r,\n\t\t\t\t\"[session=logout] calling oidc_handle_logout_request because of session mgmt local logout call.\");\n\t\treturn oidc_handle_logout_request(r, c, session, c->default_slo_url);\n\t}\n\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\t\t\t|| (provider == NULL))\n\t\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the OP iframe */\n\tif (apr_strnatcmp(\"iframe_op\", cmd) == 0) {\n\t\tif (provider->check_session_iframe != NULL) {\n\t\t\treturn oidc_handle_session_management_iframe_op(r, c, session,\n\t\t\t\t\tprovider->check_session_iframe);\n\t\t}\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the RP iframe */\n\tif (apr_strnatcmp(\"iframe_rp\", cmd) == 0) {\n\t\tif ((provider->client_id != NULL)\n\t\t\t\t&& (provider->check_session_iframe != NULL)) {\n\t\t\treturn oidc_handle_session_management_iframe_rp(r, c, session,\n\t\t\t\t\tprovider->client_id, provider->check_session_iframe);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"iframe_rp command issued but no client (%s) and/or no check_session_iframe (%s) set\",\n\t\t\t\tprovider->client_id, provider->check_session_iframe);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request check the login state with the OP */\n\tif (apr_strnatcmp(\"check\", cmd) == 0) {\n\t\tid_token_hint = oidc_session_get_idtoken(r, session);\n\t\t/*\n\t\t * TODO: this doesn't work with per-path provided auth_request_params and scopes\n\t\t *       as oidc_dir_cfg_path_auth_request_params and oidc_dir_cfg_path_scope will pick\n\t\t *       those for the redirect_uri itself; do we need to store those as part of the\n\t\t *       session now?\n\t\t */\n\t\treturn oidc_authenticate_user(r, c, provider,\n\t\t\t\tapr_psprintf(r->pool, \"%s?session=iframe_rp\",\n\t\t\t\t\t\toidc_get_redirect_uri_iss(r, c, provider)), NULL,\n\t\t\t\t\t\tid_token_hint, \"none\", oidc_dir_cfg_path_auth_request_params(r),\n\t\t\t\t\t\toidc_dir_cfg_path_scope(r));\n\t}\n\n\t/* handle failure in fallthrough */\n\toidc_error(r, \"unknown command: %s\", cmd);\n\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n}\n\n/*\n * handle refresh token request\n */\nstatic int oidc_handle_refresh_token_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *return_to = NULL;\n\tchar *r_access_token = NULL;\n\tchar *error_code = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\tapr_byte_t needs_save = TRUE;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REFRESH,\n\t\t\t&return_to);\n\toidc_util_get_request_parameter(r, OIDC_PROTO_ACCESS_TOKEN,\n\t\t\t&r_access_token);\n\n\t/* check the input parameters */\n\tif (return_to == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no URL to return to\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* do input validation on the return to parameter value */\n\tif (oidc_validate_redirect_url(r, c, return_to, TRUE, &error_str,\n\t\t\t&error_description) == FALSE) {\n\t\toidc_error(r, \"return_to URL validation failed: %s: %s\", error_str,\n\t\t\t\terror_description);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (r_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no access_token parameter\");\n\t\terror_code = \"no_access_token\";\n\t\tgoto end;\n\t}\n\n\tconst char *s_access_token = oidc_session_get_access_token(r, session);\n\tif (s_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"no existing access_token found in the session, nothing to refresh\");\n\t\terror_code = \"no_access_token_exists\";\n\t\tgoto end;\n\t}\n\n\t/* compare the access_token parameter used for XSRF protection */\n\tif (apr_strnatcmp(s_access_token, r_access_token) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"access_token passed in refresh request does not match the one stored in the session\");\n\t\terror_code = \"no_access_token_match\";\n\t\tgoto end;\n\t}\n\n\t/* get a handle to the provider configuration */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\n\t/* execute the actual refresh grant */\n\tif (oidc_refresh_access_token(r, c, session, provider, NULL) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\terror_code = \"refresh_failed\";\n\t\tgoto end;\n\t}\n\n\t/* pass the tokens to the application, possibly updating the expiry */\n\tif (oidc_session_pass_tokens(r, c, session, &needs_save) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\n\tif (oidc_session_save(r, session, FALSE) == FALSE) {\n\t\terror_code = \"error saving session\";\n\t\tgoto end;\n\t}\n\nend:\n\n\t/* pass optional error message to the return URL */\n\tif (error_code != NULL)\n\t\treturn_to = apr_psprintf(r->pool, \"%s%serror_code=%s\", return_to,\n\t\t\t\tstrchr(return_to ? return_to : \"\", OIDC_CHAR_QUERY) ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY, oidc_util_escape_string(r, error_code));\n\n\t/* add the redirect location header */\n\toidc_util_hdr_out_location_set(r, return_to);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle request object by reference request\n */\nstatic int oidc_handle_request_uri(request_rec *r, oidc_cfg *c) {\n\n\tchar *request_ref = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REQUEST_URI,\n\t\t\t&request_ref);\n\tif (request_ref == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" parameter found\",\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI);\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\n\tchar *jwt = NULL;\n\toidc_cache_get_request_uri(r, request_ref, &jwt);\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no cached JWT found for %s reference: %s\",\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI, request_ref);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\toidc_cache_set_request_uri(r, request_ref, NULL, 0);\n\n\treturn oidc_util_http_send(r, jwt, strlen(jwt), OIDC_CONTENT_TYPE_JWT, OK);\n}\n\n/*\n * handle a request to invalidate a cached access token introspection result\n */\nint oidc_handle_remove_at_cache(request_rec *r, oidc_cfg *c) {\n\tchar *access_token = NULL;\n\toidc_util_get_request_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE, &access_token);\n\n\tchar *cache_entry = NULL;\n\toidc_cache_get_access_token(r, access_token, &cache_entry);\n\tif (cache_entry == NULL) {\n\t\toidc_error(r, \"no cached access token found for value: %s\",\n\t\t\t\taccess_token);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\toidc_cache_set_access_token(r, access_token, NULL, 0);\n\n\treturn OK;\n}\n\n#define OIDC_INFO_PARAM_ACCESS_TOKEN_REFRESH_INTERVAL \"access_token_refresh_interval\"\n\n/*\n * handle request for session info\n */\nstatic int oidc_handle_info_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, apr_byte_t needs_save) {\n\tint rc = HTTP_UNAUTHORIZED;\n\tchar *s_format = NULL, *s_interval = NULL, *r_value = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_INFO,\n\t\t\t&s_format);\n\toidc_util_get_request_parameter(r,\n\t\t\tOIDC_INFO_PARAM_ACCESS_TOKEN_REFRESH_INTERVAL, &s_interval);\n\n\t/* see if this is a request for a format that is supported */\n\tif ((apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) != 0)\n\t\t\t&& (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_HTML, s_format) != 0)) {\n\t\toidc_warn(r, \"request for unknown format: %s\", s_format);\n\t\treturn HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t}\n\n\t/* check that we actually have a user session and this is someone calling with a proper session cookie */\n\tif (session->remote_user == NULL) {\n\t\toidc_warn(r, \"no user session found\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/* set the user in the main request for further (incl. sub-request and authz) processing */\n\tr->user = apr_pstrdup(r->pool, session->remote_user);\n\n\tif (c->info_hook_data == NULL) {\n\t\toidc_warn(r, \"no data configured to return in \" OIDCInfoHook);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if we can and need to refresh the access token */\n\tif ((s_interval != NULL)\n\t\t\t&& (oidc_session_get_refresh_token(r, session) != NULL)) {\n\n\t\tapr_time_t t_interval;\n\t\tif (sscanf(s_interval, \"%\" APR_TIME_T_FMT, &t_interval) == 1) {\n\t\t\tt_interval = apr_time_from_sec(t_interval);\n\n\t\t\t/* get the last refresh timestamp from the session info */\n\t\t\tapr_time_t last_refresh =\n\t\t\t\t\toidc_session_get_access_token_last_refresh(r, session);\n\n\t\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\t\tapr_time_sec(last_refresh + t_interval - apr_time_now()));\n\n\t\t\t/* see if we need to refresh again */\n\t\t\tif (last_refresh + t_interval < apr_time_now()) {\n\n\t\t\t\t/* get the current provider info */\n\t\t\t\toidc_provider_t *provider = NULL;\n\t\t\t\tif (oidc_get_provider_from_session(r, c, session, &provider)\n\t\t\t\t\t\t== FALSE)\n\t\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t\t\t/* execute the actual refresh grant */\n\t\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t\tNULL) == FALSE)\n\t\t\t\t\toidc_warn(r, \"access_token could not be refreshed\");\n\t\t\t\telse\n\t\t\t\t\tneeds_save = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* create the JSON object */\n\tjson_t *json = json_object();\n\n\t/* add a timestamp of creation in there for the caller */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_TIMESTAMP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_TIMESTAMP,\n\t\t\t\tjson_integer(apr_time_sec(apr_time_now())));\n\t}\n\n\t/*\n\t * refresh the claims from the userinfo endpoint\n\t * side-effect is that this may refresh the access token if not already done\n\t * note that OIDCUserInfoRefreshInterval should be set to control the refresh policy\n\t */\n\tneeds_save |= oidc_refresh_claims_from_userinfo_endpoint(r, c, session);\n\n\t/* include the access token in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tconst char *access_token = oidc_session_get_access_token(r, session);\n\t\tif (access_token != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN,\n\t\t\t\t\tjson_string(access_token));\n\t}\n\n\t/* include the access token expiry timestamp in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tconst char *access_token_expires =\n\t\t\t\toidc_session_get_access_token_expires(r, session);\n\t\tif (access_token_expires != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,\n\t\t\t\t\tjson_string(access_token_expires));\n\t}\n\n\t/* include the id_token claims in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ID_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_t *id_token = oidc_session_get_idtoken_claims_json(r, session);\n\t\tif (id_token)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ID_TOKEN, id_token);\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_USER_INFO,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\t/* include the claims from the userinfo endpoint the session info */\n\t\tjson_t *claims = oidc_session_get_userinfo_claims_json(r, session);\n\t\tif (claims)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_USER_INFO, claims);\n\t}\n\n\t/* include the maximum session lifetime in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION_EXP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tapr_time_t session_expires = oidc_session_get_session_expires(r,\n\t\t\t\tsession);\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION_EXP,\n\t\t\t\tjson_integer(apr_time_sec(session_expires)));\n\t}\n\n\t/* include the inactivity timeout in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION_TIMEOUT,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION_TIMEOUT,\n\t\t\t\tjson_integer(apr_time_sec(session->expiry)));\n\t}\n\n\t/* include the remote_user in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION_REMOTE_USER,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION_REMOTE_USER,\n\t\t\t\tjson_string(session->remote_user));\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_t *j_session = json_object();\n\t\tjson_object_set(j_session, OIDC_HOOK_INFO_SESSION_STATE,\n\t\t\t\tsession->state);\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_UUID,\n\t\t\t\tjson_string(session->uuid));\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION, j_session);\n\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_REFRESH_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\t/* include the refresh token in the session info */\n\t\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\t\tif (refresh_token != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_REFRESH_TOKEN,\n\t\t\t\t\tjson_string(refresh_token));\n\t}\n\n\t/* pass the tokens to the application and save the session, possibly updating the expiry */\n\tif (oidc_session_pass_tokens(r, c, session, &needs_save) == FALSE)\n\t\toidc_warn(r, \"error passing tokens\");\n\n\t/* check if something was updated in the session and we need to save it again */\n\tif (needs_save) {\n\t\tif (oidc_session_save(r, session, FALSE) == FALSE) {\n\t\t\toidc_warn(r, \"error saving session\");\n\t\t\trc = HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n\n\tif (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) == 0) {\n\t\t/* JSON-encode the result */\n\t\tr_value = oidc_util_encode_json_object(r, json, 0);\n\t\t/* return the stringified JSON result */\n\t\trc = oidc_util_http_send(r, r_value, strlen(r_value),\n\t\t\t\tOIDC_CONTENT_TYPE_JSON, OK);\n\t} else if (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_HTML, s_format) == 0) {\n\t\t/* JSON-encode the result */\n\t\tr_value = oidc_util_encode_json_object(r, json, JSON_INDENT(2));\n\t\trc = oidc_util_html_send(r, \"Session Info\", NULL, NULL,\n\t\t\t\tapr_psprintf(r->pool, \"<pre>%s</pre>\", r_value), OK);\n\t}\n\n\t/* free the allocated resources */\n\tjson_decref(json);\n\n\treturn rc;\n}\n\n/*\n * handle all requests to the redirect_uri\n */\nint oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response from the OP using the Basic Client profile or a Hybrid flow*/\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t\t/*\n\t\t *\n\t\t * Note that we are checking for logout *before* checking for a POST authorization response\n\t\t * to handle backchannel POST-based logout\n\t\t *\n\t\t * so any POST to the Redirect URI that does not have a logout query parameter will be handled\n\t\t * as an authorization response; alternatively we could assume that a POST response has no\n\t\t * parameters\n\t\t */\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_LOGOUT)) {\n\t\t/* handle logout */\n\t\treturn oidc_handle_logout(r, c, session);\n\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response using the fragment(+POST) response_mode with the Implicit Client profile */\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\n\t} else if (oidc_is_discovery_response(r, c)) {\n\n\t\t/* this is response from the OP discovery page */\n\t\treturn oidc_handle_discovery_response(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_JWKS)) {\n\t\t/*\n\t\t * Will be handled in the content handler; avoid:\n\t\t * No authentication done but request not allowed without authentication\n\t\t * by setting r->user\n\t\t */\n\t\tr->user = \"\";\n\t\treturn OK;\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_SESSION)) {\n\n\t\t/* handle session management request */\n\t\treturn oidc_handle_session_management(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REFRESH)) {\n\n\t\t/* handle refresh token request */\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI)) {\n\n\t\t/* handle request object by reference request */\n\t\treturn oidc_handle_request_uri(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE)) {\n\n\t\t/* handle request to invalidate access token cache */\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_INFO)) {\n\n\t\tif (session->remote_user == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\n\t\t/*\n\t\t * Will be handled in the content handler; avoid:\n\t\t * No authentication done but request not allowed without authentication\n\t\t * by setting r->user\n\t\t */\n\t\tr->user = \"\";\n\t\treturn OK;\n\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\n\t\t/* this is a \"bare\" request to the redirect URI, indicating implicit flow using the fragment response_mode */\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\n\t/* this is not an authorization response or logout request */\n\n\t/* check for \"error\" response */\n\tif (oidc_util_request_has_parameter(r, OIDC_PROTO_ERROR)) {\n\n\t\t//\t\tchar *error = NULL, *descr = NULL;\n\t\t//\t\toidc_util_get_request_parameter(r, \"error\", &error);\n\t\t//\t\toidc_util_get_request_parameter(r, \"error_description\", &descr);\n\t\t//\n\t\t//\t\t/* send user facing error to browser */\n\t\t//\t\treturn oidc_util_html_send_error(r, error, descr, OK);\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\n\toidc_error(r,\n\t\t\t\"The OpenID Connect callback URL received an invalid request: %s; returning HTTP_INTERNAL_SERVER_ERROR\",\n\t\t\tr->args);\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request\"),\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n}\n\n#define OIDC_AUTH_TYPE_OPENID_CONNECT \"openid-connect\"\n#define OIDC_AUTH_TYPE_OPENID_OAUTH20 \"oauth20\"\n#define OIDC_AUTH_TYPE_OPENID_BOTH    \"auth-openidc\"\n\n/*\n * main routine: handle OpenID Connect authentication\n */\nstatic int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (oidc_get_redirect_uri(r, c) == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"\" OIDC_AUTH_TYPE_OPENID_CONNECT \"\\\" but \" OIDCRedirectURI \" has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (!ap_is_initial_req(r)) {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * try to load a new session as if this were the initial request\n\t\t */\n\t}\n\n\tint rc = OK;\n\tapr_byte_t needs_save = FALSE;\n\n\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\toidc_session_t *session = NULL;\n\toidc_session_load(r, &session);\n\n\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\tif (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c))) {\n\n\t\t/* handle request to the redirect_uri */\n\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\treturn rc;\n\n\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t} else if (session->remote_user != NULL) {\n\n\t\t/* this is initial request and we already have a session */\n\t\trc = oidc_handle_existing_session(r, c, session, &needs_save);\n\t\tif (rc == OK) {\n\n\t\t\t/* check if something was updated in the session and we need to save it again */\n\t\t\tif (needs_save) {\n\t\t\t\tif (oidc_session_save(r, session, FALSE) == FALSE) {\n\t\t\t\t\toidc_warn(r, \"error saving session\");\n\t\t\t\t\trc = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/* strip any cookies that we need to */\n\t\toidc_strip_cookies(r);\n\n\t\treturn rc;\n\t}\n\n\t/* free resources allocated for the session */\n\toidc_session_free(r, session);\n\n\t/*\n\t * else: we have no session and it is not an authorization or\n\t *       discovery response: just hit the default flow for unauthenticated users\n\t */\n\n\treturn oidc_handle_unauthenticated_user(r, c);\n}\n\n/*\n * main routine: handle \"mixed\" OIDC/OAuth authentication\n */\nstatic int oidc_check_mixed_userid_oauth(request_rec *r, oidc_cfg *c) {\n\n\t/* get the bearer access token from the Authorization header */\n\tconst char *access_token = NULL;\n\tif (oidc_oauth_get_bearer_token(r, &access_token) == TRUE) {\n\n\t\tr->ap_auth_type = apr_pstrdup(r->pool, OIDC_AUTH_TYPE_OPENID_OAUTH20);\n\t\treturn oidc_oauth_check_userid(r, c, access_token);\n\t}\n\n\t/* no bearer token found: then treat this as a regular OIDC browser request */\n\tr->ap_auth_type = apr_pstrdup(r->pool, OIDC_AUTH_TYPE_OPENID_CONNECT);\n\treturn oidc_check_userid_openidc(r, c);\n}\n\n/*\n * generic Apache authentication hook for this module: dispatches to OpenID Connect or OAuth 2.0 specific routines\n */\nint oidc_check_user_id(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\t/* log some stuff about the incoming HTTP request */\n\toidc_debug(r, \"incoming request: \\\"%s?%s\\\", ap_is_initial_req(r)=%d\",\n\t\t\tr->parsed_uri.path, r->args, ap_is_initial_req(r));\n\n\t/* see if any authentication has been defined at all */\n\tconst char *current_auth = ap_auth_type(r);\n\tif (current_auth == NULL)\n\t\treturn DECLINED;\n\n\t/* see if we've configured OpenID Connect user authentication for this request */\n\tif (strcasecmp(current_auth, OIDC_AUTH_TYPE_OPENID_CONNECT) == 0) {\n\n\t\tr->ap_auth_type = (char*) current_auth;\n\t\treturn oidc_check_userid_openidc(r, c);\n\t}\n\n\t/* see if we've configured OAuth 2.0 access control for this request */\n\tif (strcasecmp(current_auth, OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\n\t\tr->ap_auth_type = (char*) current_auth;\n\t\treturn oidc_oauth_check_userid(r, c, NULL);\n\t}\n\n\t/* see if we've configured \"mixed mode\" for this request */\n\tif (strcasecmp(current_auth, OIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn oidc_check_mixed_userid_oauth(r, c);\n\n\t/* this is not for us but for some other handler */\n\treturn DECLINED;\n}\n\n/*\n * get the claims and id_token from request state\n */\nstatic void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}\n\n#if MODULE_MAGIC_NUMBER_MAJOR >= 20100714\n\n#define OIDC_OAUTH_BEARER_SCOPE_ERROR \"OIDC_OAUTH_BEARER_SCOPE_ERROR\"\n#define OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE \"Bearer error=\\\"insufficient_scope\\\", error_description=\\\"Different scope(s) or other claims required\\\"\"\n\n/*\n * find out which action we need to take when encountering an unauthorized request\n */\nstatic authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\n\t/* see if we've configured OIDCUnAutzAction for this path */\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\t// TODO: document that AuthzSendForbiddenOnFailure is required to return 403 FORBIDDEN\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\t/*\n\t\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t\t */\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\n\tif (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_DISCOVERY) != NULL)\n\t\treturn AUTHZ_GRANTED;\n\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\t/*\n\t\t * a hack for Apache 2.4 to prevent it from writing its own 401 HTML document\n\t\t * text by making ap_send_error_response in http_protocol.c return early...\n\t\t */\n\t\tr->header_only = 1;\n\t}\n\n\treturn AUTHZ_DENIED;\n}\n\n/*\n * generic Apache >=2.4 authorization hook for this module\n * handles both OpenID Connect or OAuth 2.0 in the same way, based on the claims stored in the session\n */\nauthz_status oidc_authz_checker(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args,\n\t\toidc_authz_match_claim_fn_type match_claim_fn) {\n\n\toidc_debug(r, \"enter: require_args=\\\"%s\\\"\", require_args);\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn AUTHZ_GRANTED;\n\t\tif (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_DISCOVERY) != NULL)\n\t\t\treturn AUTHZ_GRANTED;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(r, id_token, claims);\n\n\t/* dispatch to the >=2.4 specific authz routine */\n\tauthz_status rc = oidc_authz_worker24(r, claims ? claims : id_token,\n\t\t\trequire_args, parsed_require_args, match_claim_fn);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == AUTHZ_DENIED) && ap_auth_type(r))\n\t\trc = oidc_handle_unauthorized_user24(r);\n\n\treturn rc;\n}\n\nauthz_status oidc_authz_checker_claim(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args,\n\t\t\toidc_authz_match_claim);\n}\n\n#ifdef USE_LIBJQ\nauthz_status oidc_authz_checker_claims_expr(request_rec *r, const char *require_args, const void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args, oidc_authz_match_claims_expr);\n}\n#endif\n\n#else\n\n/*\n * find out which action we need to take when encountering an unauthorized request\n */\nstatic int oidc_handle_unauthorized_user22(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\", \"Different scope(s) or other claims required\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/* see if we've configured OIDCUnAutzAction for this path */\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\tcase OIDC_UNAUTZ_RETURN403:\n\t\treturn HTTP_FORBIDDEN;\n\tcase OIDC_UNAUTZ_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n}\n\n/*\n * generic Apache <2.4 authorization hook for this module\n * handles both OpenID Connect and OAuth 2.0 in the same way, based on the claims stored in the request context\n */\nint oidc_auth_checker(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn OK;\n\t\tif if (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_DISCOVERY) != NULL)\n\t\t\treturn OK;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* get the Require statements */\n\tconst apr_array_header_t * const reqs_arr = ap_requires(r);\n\n\t/* see if we have any */\n\tconst require_line * const reqs =\n\t\t\treqs_arr ? (require_line *) reqs_arr->elts : NULL;\n\tif (!reqs_arr) {\n\t\toidc_debug(r,\n\t\t\t\t\"no require statements found, so declining to perform authorization.\");\n\t\treturn DECLINED;\n\t}\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(r, id_token, claims);\n\n\t/* dispatch to the <2.4 specific authz routine */\n\tint rc = oidc_authz_worker22(r, claims ? claims : id_token, reqs,\n\t\t\treqs_arr->nelts);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == HTTP_UNAUTHORIZED) && ap_auth_type(r))\n\t\trc = oidc_handle_unauthorized_user22(r);\n\n\treturn rc;\n}\n\n#endif\n\napr_byte_t oidc_enabled(request_rec *r) {\n\tif (ap_auth_type(r) == NULL)\n\t\treturn FALSE;\n\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn TRUE;\n\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn TRUE;\n\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n/*\n * handle content generating requests\n */\nint oidc_content_handler(request_rec *r) {\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint rc = DECLINED;\n\t/* track if the session needs to be updated/saved into the cache */\n\tapr_byte_t needs_save = FALSE;\n\toidc_session_t *session = NULL;\n\n\tif (oidc_enabled(r) == TRUE) {\n\n\t\tif (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c)) == TRUE) {\n\n\t\t\tif (oidc_util_request_has_parameter(r,\n\t\t\t\t\tOIDC_REDIRECT_URI_REQUEST_INFO)) {\n\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\trc = oidc_handle_existing_session(r, c, session, &needs_save);\n\t\t\t\tif (rc == OK)\n\t\t\t\t\t/* handle request for session info */\n\t\t\t\t\trc = oidc_handle_info_request(r, c, session, needs_save);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\n\t\t\t} else if (oidc_util_request_has_parameter(r,\n\t\t\t\t\tOIDC_REDIRECT_URI_REQUEST_JWKS)) {\n\n\t\t\t\t/* handle JWKs request */\n\t\t\t\trc = oidc_handle_jwks(r, c);\n\n\t\t\t} else {\n\n\t\t\t\trc = OK;\n\n\t\t\t}\n\n\t\t} else if (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_DISCOVERY) != NULL) {\n\n\t\t\trc = oidc_discovery(r, c);\n\n\t\t} else if (oidc_request_state_get(r, OIDC_REQUEST_STATE_KEY_AUTHN) != NULL) {\n\n\t\t\trc = OK;\n\n\t\t}\n\n\t}\n\n\treturn rc;\n}\n\nextern const command_rec oidc_config_cmds[];\n\nmodule AP_MODULE_DECLARE_DATA auth_openidc_module = {\n\t\tSTANDARD20_MODULE_STUFF,\n\t\toidc_create_dir_config,\n\t\toidc_merge_dir_config,\n\t\toidc_create_server_config,\n\t\toidc_merge_server_config,\n\t\toidc_config_cmds,\n\t\toidc_register_hooks\n};\n"], "filenames": ["AUTHORS", "ChangeLog", "auth_openidc.conf", "configure.ac", "src/mod_auth_openidc.c"], "buggy_code_start_loc": [75, 2, 921, 1, 2460], "buggy_code_end_loc": [77, 2, 923, 2, 3038], "fixing_code_start_loc": [76, 3, 921, 1, 2459], "fixing_code_end_loc": [80, 5, 924, 2, 3050], "type": "CWE-601", "message": "mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In versions prior to 2.4.9.4, the 3rd-party init SSO functionality of mod_auth_openidc was reported to be vulnerable to an open redirect attack by supplying a crafted URL in the `target_link_uri` parameter. A patch in version 2.4.9.4 made it so that the `OIDCRedirectURLsAllowed` setting must be applied to the `target_link_uri` parameter. There are no known workarounds aside from upgrading to a patched version.", "other": {"cve": {"id": "CVE-2021-39191", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-03T14:15:07.210", "lastModified": "2023-05-25T20:18:46.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In versions prior to 2.4.9.4, the 3rd-party init SSO functionality of mod_auth_openidc was reported to be vulnerable to an open redirect attack by supplying a crafted URL in the `target_link_uri` parameter. A patch in version 2.4.9.4 made it so that the `OIDCRedirectURLsAllowed` setting must be applied to the `target_link_uri` parameter. There are no known workarounds aside from upgrading to a patched version."}, {"lang": "es", "value": "mod_auth_openidc es un m\u00f3dulo de autenticaci\u00f3n/autorizaci\u00f3n para el servidor HTTP Apache versi\u00f3n 2.x, que funciona como OpenID Connect Relying Party, autenticando a usuarios contra un proveedor de OpenID Connect. En las versiones anteriores a 2.4.9.4, la funcionalidad de SSO init de terceros de mod_auth_openidc era vulnerable a un ataque de redirecci\u00f3n abierta mediante el suministro de una URL dise\u00f1ada en el par\u00e1metro \"target_link_uri\". Un parche en la versi\u00f3n 2.4.9.4 hizo que la configuraci\u00f3n \"OIDCRedirectURLsAllowed\" se aplicara al par\u00e1metro \"target_link_uri\". No se conocen soluciones aparte de la actualizaci\u00f3n a una versi\u00f3n parcheada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openidc:mod_auth_openidc:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.9.4", "matchCriteriaId": "93E4D476-0087-4EBC-82E8-6B233FCC291A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/zmartzone/mod_auth_openidc/commit/03e6bfb446f4e3f27c003d30d6a433e5dd8e2b3d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zmartzone/mod_auth_openidc/issues/672", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/zmartzone/mod_auth_openidc/releases/tag/v2.4.9.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/zmartzone/mod_auth_openidc/security/advisories/GHSA-2pgf-8h6h-gqg2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/32RGPW5LZDLDTB7MKZIGAHPSLFOUNWR5/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RHXO4O4G2UQS7X6OQJCVZKHZAQ7SAIFB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zmartzone/mod_auth_openidc/commit/03e6bfb446f4e3f27c003d30d6a433e5dd8e2b3d"}}