{"buggy_code": ["/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <netinet/in.h>\n\n#include <ctype.h>\n#include <resolv.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Based on the description by Paul Williams at:\n *\n * https://vt100.net/emu/dec_ansi_parser\n *\n * With the following changes:\n *\n * - 7-bit only.\n *\n * - Support for UTF-8.\n *\n * - OSC (but not APC) may be terminated by \\007 as well as ST.\n *\n * - A state for APC similar to OSC. Some terminals appear to use this to set\n *   the title.\n *\n * - A state for the screen \\033k...\\033\\\\ sequence to rename a window. This is\n *   pretty stupid but not supporting it is more trouble than it is worth.\n *\n * - Special handling for ESC inside a DCS to allow arbitrary byte sequences to\n *   be passed to the underlying terminals.\n */\n\n/* Input parser cell. */\nstruct input_cell {\n\tstruct grid_cell\tcell;\n\tint\t\t\tset;\n\tint\t\t\tg0set;\t/* 1 if ACS */\n\tint\t\t\tg1set;\t/* 1 if ACS */\n};\n\n/* Input parser argument. */\nstruct input_param {\n\tenum {\n\t\tINPUT_MISSING,\n\t\tINPUT_NUMBER,\n\t\tINPUT_STRING\n\t}\t\t\ttype;\n\tunion {\n\t\tint\t\tnum;\n\t\tchar\t       *str;\n\t};\n};\n\n/* Input parser context. */\nstruct input_ctx {\n\tstruct window_pane     *wp;\n\tstruct bufferevent     *event;\n\tstruct screen_write_ctx ctx;\n\n\tstruct input_cell\tcell;\n\n\tstruct input_cell\told_cell;\n\tu_int\t\t\told_cx;\n\tu_int\t\t\told_cy;\n\tint\t\t\told_mode;\n\n\tu_char\t\t\tinterm_buf[4];\n\tsize_t\t\t\tinterm_len;\n\n\tu_char\t\t\tparam_buf[64];\n\tsize_t\t\t\tparam_len;\n\n#define INPUT_BUF_START 32\n#define INPUT_BUF_LIMIT 1048576\n\tu_char\t\t       *input_buf;\n\tsize_t\t\t\tinput_len;\n\tsize_t\t\t\tinput_space;\n\tenum {\n\t\tINPUT_END_ST,\n\t\tINPUT_END_BEL\n\t}\t\t\tinput_end;\n\n\tstruct input_param\tparam_list[24];\n\tu_int\t\t\tparam_list_len;\n\n\tstruct utf8_data\tutf8data;\n\tint\t\t\tutf8started;\n\n\tint\t\t\tch;\n\tint\t\t\tlast;\n\n\tint\t\t\tflags;\n#define INPUT_DISCARD 0x1\n\n\tconst struct input_state *state;\n\n\tstruct event\t\ttimer;\n\n\t/*\n\t * All input received since we were last in the ground state. Sent to\n\t * control clients on connection.\n\t */\n\tstruct evbuffer\t\t*since_ground;\n};\n\n/* Helper functions. */\nstruct input_transition;\nstatic int\tinput_split(struct input_ctx *);\nstatic int\tinput_get(struct input_ctx *, u_int, int, int);\nstatic void printflike(2, 3) input_reply(struct input_ctx *, const char *, ...);\nstatic void\tinput_set_state(struct input_ctx *,\n\t\t    const struct input_transition *);\nstatic void\tinput_reset_cell(struct input_ctx *);\n\nstatic void\tinput_osc_4(struct input_ctx *, const char *);\nstatic void\tinput_osc_10(struct input_ctx *, const char *);\nstatic void\tinput_osc_11(struct input_ctx *, const char *);\nstatic void\tinput_osc_52(struct input_ctx *, const char *);\nstatic void\tinput_osc_104(struct input_ctx *, const char *);\n\n/* Transition entry/exit handlers. */\nstatic void\tinput_clear(struct input_ctx *);\nstatic void\tinput_ground(struct input_ctx *);\nstatic void\tinput_enter_dcs(struct input_ctx *);\nstatic void\tinput_enter_osc(struct input_ctx *);\nstatic void\tinput_exit_osc(struct input_ctx *);\nstatic void\tinput_enter_apc(struct input_ctx *);\nstatic void\tinput_exit_apc(struct input_ctx *);\nstatic void\tinput_enter_rename(struct input_ctx *);\nstatic void\tinput_exit_rename(struct input_ctx *);\n\n/* Input state handlers. */\nstatic int\tinput_print(struct input_ctx *);\nstatic int\tinput_intermediate(struct input_ctx *);\nstatic int\tinput_parameter(struct input_ctx *);\nstatic int\tinput_input(struct input_ctx *);\nstatic int\tinput_c0_dispatch(struct input_ctx *);\nstatic int\tinput_esc_dispatch(struct input_ctx *);\nstatic int\tinput_csi_dispatch(struct input_ctx *);\nstatic void\tinput_csi_dispatch_rm(struct input_ctx *);\nstatic void\tinput_csi_dispatch_rm_private(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sm(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sm_private(struct input_ctx *);\nstatic void\tinput_csi_dispatch_winops(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sgr_256(struct input_ctx *, int, u_int *);\nstatic void\tinput_csi_dispatch_sgr_rgb(struct input_ctx *, int, u_int *);\nstatic void\tinput_csi_dispatch_sgr(struct input_ctx *);\nstatic int\tinput_dcs_dispatch(struct input_ctx *);\nstatic int\tinput_top_bit_set(struct input_ctx *);\nstatic int\tinput_end_bel(struct input_ctx *);\n\n/* Command table comparison function. */\nstatic int\tinput_table_compare(const void *, const void *);\n\n/* Command table entry. */\nstruct input_table_entry {\n\tint\t\tch;\n\tconst char     *interm;\n\tint\t\ttype;\n};\n\n/* Escape commands. */\nenum input_esc_type {\n\tINPUT_ESC_DECALN,\n\tINPUT_ESC_DECKPAM,\n\tINPUT_ESC_DECKPNM,\n\tINPUT_ESC_DECRC,\n\tINPUT_ESC_DECSC,\n\tINPUT_ESC_HTS,\n\tINPUT_ESC_IND,\n\tINPUT_ESC_NEL,\n\tINPUT_ESC_RI,\n\tINPUT_ESC_RIS,\n\tINPUT_ESC_SCSG0_OFF,\n\tINPUT_ESC_SCSG0_ON,\n\tINPUT_ESC_SCSG1_OFF,\n\tINPUT_ESC_SCSG1_ON,\n\tINPUT_ESC_ST,\n};\n\n/* Escape command table. */\nstatic const struct input_table_entry input_esc_table[] = {\n\t{ '0', \"(\", INPUT_ESC_SCSG0_ON },\n\t{ '0', \")\", INPUT_ESC_SCSG1_ON },\n\t{ '7', \"\",  INPUT_ESC_DECSC },\n\t{ '8', \"\",  INPUT_ESC_DECRC },\n\t{ '8', \"#\", INPUT_ESC_DECALN },\n\t{ '=', \"\",  INPUT_ESC_DECKPAM },\n\t{ '>', \"\",  INPUT_ESC_DECKPNM },\n\t{ 'B', \"(\", INPUT_ESC_SCSG0_OFF },\n\t{ 'B', \")\", INPUT_ESC_SCSG1_OFF },\n\t{ 'D', \"\",  INPUT_ESC_IND },\n\t{ 'E', \"\",  INPUT_ESC_NEL },\n\t{ 'H', \"\",  INPUT_ESC_HTS },\n\t{ 'M', \"\",  INPUT_ESC_RI },\n\t{ '\\\\', \"\", INPUT_ESC_ST },\n\t{ 'c', \"\",  INPUT_ESC_RIS },\n};\n\n/* Control (CSI) commands. */\nenum input_csi_type {\n\tINPUT_CSI_CBT,\n\tINPUT_CSI_CNL,\n\tINPUT_CSI_CPL,\n\tINPUT_CSI_CUB,\n\tINPUT_CSI_CUD,\n\tINPUT_CSI_CUF,\n\tINPUT_CSI_CUP,\n\tINPUT_CSI_CUU,\n\tINPUT_CSI_DA,\n\tINPUT_CSI_DA_TWO,\n\tINPUT_CSI_DCH,\n\tINPUT_CSI_DECSCUSR,\n\tINPUT_CSI_DECSTBM,\n\tINPUT_CSI_DL,\n\tINPUT_CSI_DSR,\n\tINPUT_CSI_ECH,\n\tINPUT_CSI_ED,\n\tINPUT_CSI_EL,\n\tINPUT_CSI_HPA,\n\tINPUT_CSI_ICH,\n\tINPUT_CSI_IL,\n\tINPUT_CSI_MODOFF,\n\tINPUT_CSI_MODSET,\n\tINPUT_CSI_RCP,\n\tINPUT_CSI_REP,\n\tINPUT_CSI_RM,\n\tINPUT_CSI_RM_PRIVATE,\n\tINPUT_CSI_SCP,\n\tINPUT_CSI_SD,\n\tINPUT_CSI_SGR,\n\tINPUT_CSI_SM,\n\tINPUT_CSI_SM_PRIVATE,\n\tINPUT_CSI_SU,\n\tINPUT_CSI_TBC,\n\tINPUT_CSI_VPA,\n\tINPUT_CSI_WINOPS,\n\tINPUT_CSI_XDA,\n};\n\n/* Control (CSI) command table. */\nstatic const struct input_table_entry input_csi_table[] = {\n\t{ '@', \"\",  INPUT_CSI_ICH },\n\t{ 'A', \"\",  INPUT_CSI_CUU },\n\t{ 'B', \"\",  INPUT_CSI_CUD },\n\t{ 'C', \"\",  INPUT_CSI_CUF },\n\t{ 'D', \"\",  INPUT_CSI_CUB },\n\t{ 'E', \"\",  INPUT_CSI_CNL },\n\t{ 'F', \"\",  INPUT_CSI_CPL },\n\t{ 'G', \"\",  INPUT_CSI_HPA },\n\t{ 'H', \"\",  INPUT_CSI_CUP },\n\t{ 'J', \"\",  INPUT_CSI_ED },\n\t{ 'K', \"\",  INPUT_CSI_EL },\n\t{ 'L', \"\",  INPUT_CSI_IL },\n\t{ 'M', \"\",  INPUT_CSI_DL },\n\t{ 'P', \"\",  INPUT_CSI_DCH },\n\t{ 'S', \"\",  INPUT_CSI_SU },\n\t{ 'T', \"\",  INPUT_CSI_SD },\n\t{ 'X', \"\",  INPUT_CSI_ECH },\n\t{ 'Z', \"\",  INPUT_CSI_CBT },\n\t{ '`', \"\",  INPUT_CSI_HPA },\n\t{ 'b', \"\",  INPUT_CSI_REP },\n\t{ 'c', \"\",  INPUT_CSI_DA },\n\t{ 'c', \">\", INPUT_CSI_DA_TWO },\n\t{ 'd', \"\",  INPUT_CSI_VPA },\n\t{ 'f', \"\",  INPUT_CSI_CUP },\n\t{ 'g', \"\",  INPUT_CSI_TBC },\n\t{ 'h', \"\",  INPUT_CSI_SM },\n\t{ 'h', \"?\", INPUT_CSI_SM_PRIVATE },\n\t{ 'l', \"\",  INPUT_CSI_RM },\n\t{ 'l', \"?\", INPUT_CSI_RM_PRIVATE },\n\t{ 'm', \"\",  INPUT_CSI_SGR },\n\t{ 'm', \">\", INPUT_CSI_MODSET },\n\t{ 'n', \"\",  INPUT_CSI_DSR },\n\t{ 'n', \">\", INPUT_CSI_MODOFF },\n\t{ 'q', \" \", INPUT_CSI_DECSCUSR },\n\t{ 'q', \">\", INPUT_CSI_XDA },\n\t{ 'r', \"\",  INPUT_CSI_DECSTBM },\n\t{ 's', \"\",  INPUT_CSI_SCP },\n\t{ 't', \"\",  INPUT_CSI_WINOPS },\n\t{ 'u', \"\",  INPUT_CSI_RCP },\n};\n\n/* Input transition. */\nstruct input_transition {\n\tint\t\t\t\tfirst;\n\tint\t\t\t\tlast;\n\n\tint\t\t\t\t(*handler)(struct input_ctx *);\n\tconst struct input_state       *state;\n};\n\n/* Input state. */\nstruct input_state {\n\tconst char\t\t\t*name;\n\tvoid\t\t\t\t(*enter)(struct input_ctx *);\n\tvoid\t\t\t\t(*exit)(struct input_ctx *);\n\tconst struct input_transition\t*transitions;\n};\n\n/* State transitions available from all states. */\n#define INPUT_STATE_ANYWHERE \\\n\t{ 0x18, 0x18, input_c0_dispatch, &input_state_ground }, \\\n\t{ 0x1a, 0x1a, input_c0_dispatch, &input_state_ground }, \\\n\t{ 0x1b, 0x1b, NULL,\t\t &input_state_esc_enter }\n\n/* Forward declarations of state tables. */\nstatic const struct input_transition input_state_ground_table[];\nstatic const struct input_transition input_state_esc_enter_table[];\nstatic const struct input_transition input_state_esc_intermediate_table[];\nstatic const struct input_transition input_state_csi_enter_table[];\nstatic const struct input_transition input_state_csi_parameter_table[];\nstatic const struct input_transition input_state_csi_intermediate_table[];\nstatic const struct input_transition input_state_csi_ignore_table[];\nstatic const struct input_transition input_state_dcs_enter_table[];\nstatic const struct input_transition input_state_dcs_parameter_table[];\nstatic const struct input_transition input_state_dcs_intermediate_table[];\nstatic const struct input_transition input_state_dcs_handler_table[];\nstatic const struct input_transition input_state_dcs_escape_table[];\nstatic const struct input_transition input_state_dcs_ignore_table[];\nstatic const struct input_transition input_state_osc_string_table[];\nstatic const struct input_transition input_state_apc_string_table[];\nstatic const struct input_transition input_state_rename_string_table[];\nstatic const struct input_transition input_state_consume_st_table[];\n\n/* ground state definition. */\nstatic const struct input_state input_state_ground = {\n\t\"ground\",\n\tinput_ground, NULL,\n\tinput_state_ground_table\n};\n\n/* esc_enter state definition. */\nstatic const struct input_state input_state_esc_enter = {\n\t\"esc_enter\",\n\tinput_clear, NULL,\n\tinput_state_esc_enter_table\n};\n\n/* esc_intermediate state definition. */\nstatic const struct input_state input_state_esc_intermediate = {\n\t\"esc_intermediate\",\n\tNULL, NULL,\n\tinput_state_esc_intermediate_table\n};\n\n/* csi_enter state definition. */\nstatic const struct input_state input_state_csi_enter = {\n\t\"csi_enter\",\n\tinput_clear, NULL,\n\tinput_state_csi_enter_table\n};\n\n/* csi_parameter state definition. */\nstatic const struct input_state input_state_csi_parameter = {\n\t\"csi_parameter\",\n\tNULL, NULL,\n\tinput_state_csi_parameter_table\n};\n\n/* csi_intermediate state definition. */\nstatic const struct input_state input_state_csi_intermediate = {\n\t\"csi_intermediate\",\n\tNULL, NULL,\n\tinput_state_csi_intermediate_table\n};\n\n/* csi_ignore state definition. */\nstatic const struct input_state input_state_csi_ignore = {\n\t\"csi_ignore\",\n\tNULL, NULL,\n\tinput_state_csi_ignore_table\n};\n\n/* dcs_enter state definition. */\nstatic const struct input_state input_state_dcs_enter = {\n\t\"dcs_enter\",\n\tinput_enter_dcs, NULL,\n\tinput_state_dcs_enter_table\n};\n\n/* dcs_parameter state definition. */\nstatic const struct input_state input_state_dcs_parameter = {\n\t\"dcs_parameter\",\n\tNULL, NULL,\n\tinput_state_dcs_parameter_table\n};\n\n/* dcs_intermediate state definition. */\nstatic const struct input_state input_state_dcs_intermediate = {\n\t\"dcs_intermediate\",\n\tNULL, NULL,\n\tinput_state_dcs_intermediate_table\n};\n\n/* dcs_handler state definition. */\nstatic const struct input_state input_state_dcs_handler = {\n\t\"dcs_handler\",\n\tNULL, NULL,\n\tinput_state_dcs_handler_table\n};\n\n/* dcs_escape state definition. */\nstatic const struct input_state input_state_dcs_escape = {\n\t\"dcs_escape\",\n\tNULL, NULL,\n\tinput_state_dcs_escape_table\n};\n\n/* dcs_ignore state definition. */\nstatic const struct input_state input_state_dcs_ignore = {\n\t\"dcs_ignore\",\n\tNULL, NULL,\n\tinput_state_dcs_ignore_table\n};\n\n/* osc_string state definition. */\nstatic const struct input_state input_state_osc_string = {\n\t\"osc_string\",\n\tinput_enter_osc, input_exit_osc,\n\tinput_state_osc_string_table\n};\n\n/* apc_string state definition. */\nstatic const struct input_state input_state_apc_string = {\n\t\"apc_string\",\n\tinput_enter_apc, input_exit_apc,\n\tinput_state_apc_string_table\n};\n\n/* rename_string state definition. */\nstatic const struct input_state input_state_rename_string = {\n\t\"rename_string\",\n\tinput_enter_rename, input_exit_rename,\n\tinput_state_rename_string_table\n};\n\n/* consume_st state definition. */\nstatic const struct input_state input_state_consume_st = {\n\t\"consume_st\",\n\tinput_enter_rename, NULL, /* rename also waits for ST */\n\tinput_state_consume_st_table\n};\n\n/* ground state table. */\nstatic const struct input_transition input_state_ground_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch, NULL },\n\t{ 0x19, 0x19, input_c0_dispatch, NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch, NULL },\n\t{ 0x20, 0x7e, input_print,\t NULL },\n\t{ 0x7f, 0x7f, NULL,\t\t NULL },\n\t{ 0x80, 0xff, input_top_bit_set, NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* esc_enter state table. */\nstatic const struct input_transition input_state_esc_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_esc_intermediate },\n\t{ 0x30, 0x4f, input_esc_dispatch, &input_state_ground },\n\t{ 0x50, 0x50, NULL,\t\t  &input_state_dcs_enter },\n\t{ 0x51, 0x57, input_esc_dispatch, &input_state_ground },\n\t{ 0x58, 0x58, NULL,\t\t  &input_state_consume_st },\n\t{ 0x59, 0x59, input_esc_dispatch, &input_state_ground },\n\t{ 0x5a, 0x5a, input_esc_dispatch, &input_state_ground },\n\t{ 0x5b, 0x5b, NULL,\t\t  &input_state_csi_enter },\n\t{ 0x5c, 0x5c, input_esc_dispatch, &input_state_ground },\n\t{ 0x5d, 0x5d, NULL,\t\t  &input_state_osc_string },\n\t{ 0x5e, 0x5e, NULL,\t\t  &input_state_consume_st },\n\t{ 0x5f, 0x5f, NULL,\t\t  &input_state_apc_string },\n\t{ 0x60, 0x6a, input_esc_dispatch, &input_state_ground },\n\t{ 0x6b, 0x6b, NULL,\t\t  &input_state_rename_string },\n\t{ 0x6c, 0x7e, input_esc_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* esc_intermediate state table. */\nstatic const struct input_transition input_state_esc_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x7e, input_esc_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_enter state table. */\nstatic const struct input_transition input_state_csi_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3a, 0x3a, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3b, 0x3b, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3c, 0x3f, input_intermediate, &input_state_csi_parameter },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_parameter state table. */\nstatic const struct input_transition input_state_csi_parameter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  NULL },\n\t{ 0x3a, 0x3a, input_parameter,\t  NULL },\n\t{ 0x3b, 0x3b, input_parameter,\t  NULL },\n\t{ 0x3c, 0x3f, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_intermediate state table. */\nstatic const struct input_transition input_state_csi_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x3f, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_ignore state table. */\nstatic const struct input_transition input_state_csi_ignore_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch, NULL },\n\t{ 0x19, 0x19, input_c0_dispatch, NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch, NULL },\n\t{ 0x20, 0x3f, NULL,\t\t NULL },\n\t{ 0x40, 0x7e, NULL,\t\t &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_enter state table. */\nstatic const struct input_transition input_state_dcs_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  &input_state_dcs_parameter },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  &input_state_dcs_parameter },\n\t{ 0x3c, 0x3f, input_intermediate, &input_state_dcs_parameter },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_parameter state table. */\nstatic const struct input_transition input_state_dcs_parameter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  NULL },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  NULL },\n\t{ 0x3c, 0x3f, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_intermediate state table. */\nstatic const struct input_transition input_state_dcs_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x3f, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_handler state table. */\nstatic const struct input_transition input_state_dcs_handler_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x1a, input_input,  NULL },\n\t{ 0x1b, 0x1b, NULL,\t    &input_state_dcs_escape },\n\t{ 0x1c, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_escape state table. */\nstatic const struct input_transition input_state_dcs_escape_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x5b, input_input,\t  &input_state_dcs_handler },\n\t{ 0x5c, 0x5c, input_dcs_dispatch, &input_state_ground },\n\t{ 0x5d, 0xff, input_input,\t  &input_state_dcs_handler },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_ignore state table. */\nstatic const struct input_transition input_state_dcs_ignore_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, NULL,\t    NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* osc_string state table. */\nstatic const struct input_transition input_state_osc_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x06, NULL,\t     NULL },\n\t{ 0x07, 0x07, input_end_bel, &input_state_ground },\n\t{ 0x08, 0x17, NULL,\t     NULL },\n\t{ 0x19, 0x19, NULL,\t     NULL },\n\t{ 0x1c, 0x1f, NULL,\t     NULL },\n\t{ 0x20, 0xff, input_input,   NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* apc_string state table. */\nstatic const struct input_transition input_state_apc_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* rename_string state table. */\nstatic const struct input_transition input_state_rename_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* consume_st state table. */\nstatic const struct input_transition input_state_consume_st_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, NULL,\t    NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* Input table compare. */\nstatic int\ninput_table_compare(const void *key, const void *value)\n{\n\tconst struct input_ctx\t\t*ictx = key;\n\tconst struct input_table_entry\t*entry = value;\n\n\tif (ictx->ch != entry->ch)\n\t\treturn (ictx->ch - entry->ch);\n\treturn (strcmp(ictx->interm_buf, entry->interm));\n}\n\n/*\n * Timer - if this expires then have been waiting for a terminator for too\n * long, so reset to ground.\n */\nstatic void\ninput_timer_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct input_ctx\t*ictx = arg;\n\n\tlog_debug(\"%s: %s expired\" , __func__, ictx->state->name);\n\tinput_reset(ictx, 0);\n}\n\n/* Start the timer. */\nstatic void\ninput_start_timer(struct input_ctx *ictx)\n{\n\tstruct timeval\ttv = { .tv_sec = 5, .tv_usec = 0 };\n\n\tevent_del(&ictx->timer);\n\tevent_add(&ictx->timer, &tv);\n}\n\n/* Reset cell state to default. */\nstatic void\ninput_reset_cell(struct input_ctx *ictx)\n{\n\tmemcpy(&ictx->cell.cell, &grid_default_cell, sizeof ictx->cell.cell);\n\tictx->cell.set = 0;\n\tictx->cell.g0set = ictx->cell.g1set = 0;\n\n\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\tictx->old_cx = 0;\n\tictx->old_cy = 0;\n}\n\n/* Save screen state. */\nstatic void\ninput_save_state(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct screen\t\t*s = sctx->s;\n\n\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\tictx->old_cx = s->cx;\n\tictx->old_cy = s->cy;\n\tictx->old_mode = s->mode;\n}\n\n/* Restore screen state. */\nstatic void\ninput_restore_state(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tmemcpy(&ictx->cell, &ictx->old_cell, sizeof ictx->cell);\n\tif (ictx->old_mode & MODE_ORIGIN)\n\t\tscreen_write_mode_set(sctx, MODE_ORIGIN);\n\telse\n\t\tscreen_write_mode_clear(sctx, MODE_ORIGIN);\n\tscreen_write_cursormove(sctx, ictx->old_cx, ictx->old_cy, 0);\n}\n\n/* Initialise input parser. */\nstruct input_ctx *\ninput_init(struct window_pane *wp, struct bufferevent *bev)\n{\n\tstruct input_ctx\t*ictx;\n\n\tictx = xcalloc(1, sizeof *ictx);\n\tictx->wp = wp;\n\tictx->event = bev;\n\n\tictx->input_space = INPUT_BUF_START;\n\tictx->input_buf = xmalloc(INPUT_BUF_START);\n\n\tictx->since_ground = evbuffer_new();\n\tif (ictx->since_ground == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tevtimer_set(&ictx->timer, input_timer_callback, ictx);\n\n\tinput_reset(ictx, 0);\n\treturn (ictx);\n}\n\n/* Destroy input parser. */\nvoid\ninput_free(struct input_ctx *ictx)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING)\n\t\t\tfree(ictx->param_list[i].str);\n\t}\n\n\tevent_del(&ictx->timer);\n\n\tfree(ictx->input_buf);\n\tevbuffer_free(ictx->since_ground);\n\n\tfree(ictx);\n}\n\n/* Reset input state and clear screen. */\nvoid\ninput_reset(struct input_ctx *ictx, int clear)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\n\tinput_reset_cell(ictx);\n\n\tif (clear && wp != NULL) {\n\t\tif (TAILQ_EMPTY(&wp->modes))\n\t\t\tscreen_write_start_pane(sctx, wp, &wp->base);\n\t\telse\n\t\t\tscreen_write_start(sctx, &wp->base);\n\t\tscreen_write_reset(sctx);\n\t\tscreen_write_stop(sctx);\n\t}\n\n\tinput_clear(ictx);\n\n\tictx->last = -1;\n\n\tictx->state = &input_state_ground;\n\tictx->flags = 0;\n}\n\n/* Return pending data. */\nstruct evbuffer *\ninput_pending(struct input_ctx *ictx)\n{\n\treturn (ictx->since_ground);\n}\n\n/* Change input state. */\nstatic void\ninput_set_state(struct input_ctx *ictx, const struct input_transition *itr)\n{\n\tif (ictx->state->exit != NULL)\n\t\tictx->state->exit(ictx);\n\tictx->state = itr->state;\n\tif (ictx->state->enter != NULL)\n\t\tictx->state->enter(ictx);\n}\n\n/* Parse data. */\nstatic void\ninput_parse(struct input_ctx *ictx, u_char *buf, size_t len)\n{\n\tstruct screen_write_ctx\t\t*sctx = &ictx->ctx;\n\tconst struct input_state\t*state = NULL;\n\tconst struct input_transition\t*itr = NULL;\n\tsize_t\t\t\t\t off = 0;\n\n\t/* Parse the input. */\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\n\t\t/* Find the transition. */\n\t\tif (ictx->state != state ||\n\t\t    itr == NULL ||\n\t\t    ictx->ch < itr->first ||\n\t\t    ictx->ch > itr->last) {\n\t\t\titr = ictx->state->transitions;\n\t\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\t\tif (ictx->ch >= itr->first &&\n\t\t\t\t    ictx->ch <= itr->last)\n\t\t\t\t\tbreak;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\t\t/* No transition? Eh? */\n\t\t\t\tfatalx(\"no transition from state\");\n\t\t\t}\n\t\t}\n\t\tstate = ictx->state;\n\n\t\t/*\n\t\t * Any state except print stops the current collection. This is\n\t\t * an optimization to avoid checking if the attributes have\n\t\t * changed for every character. It will stop unnecessarily for\n\t\t * sequences that don't make a terminal change, but they should\n\t\t * be the minority.\n\t\t */\n\t\tif (itr->handler != input_print)\n\t\t\tscreen_write_collect_end(sctx);\n\n\t\t/*\n\t\t * Execute the handler, if any. Don't switch state if it\n\t\t * returns non-zero.\n\t\t */\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\n\t\t/* And switch state, if necessary. */\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(ictx, itr);\n\n\t\t/* If not in ground state, save input. */\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n}\n\n/* Parse input from pane. */\nvoid\ninput_parse_pane(struct window_pane *wp)\n{\n\tvoid\t*new_data;\n\tsize_t\t new_size;\n\n\tnew_data = window_pane_get_new_data(wp, &wp->offset, &new_size);\n\tinput_parse_buffer(wp, new_data, new_size);\n\twindow_pane_update_used_data(wp, &wp->offset, new_size);\n}\n\n/* Parse given input. */\nvoid\ninput_parse_buffer(struct window_pane *wp, u_char *buf, size_t len)\n{\n\tstruct input_ctx\t*ictx = wp->ictx;\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tif (len == 0)\n\t\treturn;\n\n\twindow_update_activity(wp->window);\n\twp->flags |= PANE_CHANGED;\n\n\t/* NULL wp if there is a mode set as don't want to update the tty. */\n\tif (TAILQ_EMPTY(&wp->modes))\n\t\tscreen_write_start_pane(sctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(sctx, &wp->base);\n\n\tlog_debug(\"%s: %%%u %s, %zu bytes: %.*s\", __func__, wp->id,\n\t    ictx->state->name, len, (int)len, buf);\n\n\tinput_parse(ictx, buf, len);\n\tscreen_write_stop(sctx);\n}\n\n/* Parse given input for screen. */\nvoid\ninput_parse_screen(struct input_ctx *ictx, struct screen *s,\n    screen_write_init_ctx_cb cb, void *arg, u_char *buf, size_t len)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tif (len == 0)\n\t\treturn;\n\n\tscreen_write_start_callback(sctx, s, cb, arg);\n\tinput_parse(ictx, buf, len);\n\tscreen_write_stop(sctx);\n}\n\n/* Split the parameter list (if any). */\nstatic int\ninput_split(struct input_ctx *ictx)\n{\n\tconst char\t\t*errstr;\n\tchar\t\t\t*ptr, *out;\n\tstruct input_param\t*ip;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING)\n\t\t\tfree(ictx->param_list[i].str);\n\t}\n\tictx->param_list_len = 0;\n\n\tif (ictx->param_len == 0)\n\t\treturn (0);\n\tip = &ictx->param_list[0];\n\n\tptr = ictx->param_buf;\n\twhile ((out = strsep(&ptr, \";\")) != NULL) {\n\t\tif (*out == '\\0')\n\t\t\tip->type = INPUT_MISSING;\n\t\telse {\n\t\t\tif (strchr(out, ':') != NULL) {\n\t\t\t\tip->type = INPUT_STRING;\n\t\t\t\tip->str = xstrdup(out);\n\t\t\t} else {\n\t\t\t\tip->type = INPUT_NUMBER;\n\t\t\t\tip->num = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t\tip = &ictx->param_list[++ictx->param_list_len];\n\t\tif (ictx->param_list_len == nitems(ictx->param_list))\n\t\t\treturn (-1);\n\t}\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tip = &ictx->param_list[i];\n\t\tif (ip->type == INPUT_MISSING)\n\t\t\tlog_debug(\"parameter %u: missing\", i);\n\t\telse if (ip->type == INPUT_STRING)\n\t\t\tlog_debug(\"parameter %u: string %s\", i, ip->str);\n\t\telse if (ip->type == INPUT_NUMBER)\n\t\t\tlog_debug(\"parameter %u: number %d\", i, ip->num);\n\t}\n\n\treturn (0);\n}\n\n/* Get an argument or return default value. */\nstatic int\ninput_get(struct input_ctx *ictx, u_int validx, int minval, int defval)\n{\n\tstruct input_param\t*ip;\n\tint\t\t\t retval;\n\n\tif (validx >= ictx->param_list_len)\n\t    return (defval);\n\tip = &ictx->param_list[validx];\n\tif (ip->type == INPUT_MISSING)\n\t\treturn (defval);\n\tif (ip->type == INPUT_STRING)\n\t\treturn (-1);\n\tretval = ip->num;\n\tif (retval < minval)\n\t\treturn (minval);\n\treturn (retval);\n}\n\n/* Reply to terminal query. */\nstatic void\ninput_reply(struct input_ctx *ictx, const char *fmt, ...)\n{\n\tstruct bufferevent\t*bev = ictx->event;\n\tva_list\t\t\t ap;\n\tchar\t\t\t*reply;\n\n\tva_start(ap, fmt);\n\txvasprintf(&reply, fmt, ap);\n\tva_end(ap);\n\n\tbufferevent_write(bev, reply, strlen(reply));\n\tfree(reply);\n}\n\n/* Clear saved state. */\nstatic void\ninput_clear(struct input_ctx *ictx)\n{\n\tevent_del(&ictx->timer);\n\n\t*ictx->interm_buf = '\\0';\n\tictx->interm_len = 0;\n\n\t*ictx->param_buf = '\\0';\n\tictx->param_len = 0;\n\n\t*ictx->input_buf = '\\0';\n\tictx->input_len = 0;\n\n\tictx->input_end = INPUT_END_ST;\n\n\tictx->flags &= ~INPUT_DISCARD;\n}\n\n/* Reset for ground state. */\nstatic void\ninput_ground(struct input_ctx *ictx)\n{\n\tevent_del(&ictx->timer);\n\tevbuffer_drain(ictx->since_ground, EVBUFFER_LENGTH(ictx->since_ground));\n\n\tif (ictx->input_space > INPUT_BUF_START) {\n\t\tictx->input_space = INPUT_BUF_START;\n\t\tictx->input_buf = xrealloc(ictx->input_buf, INPUT_BUF_START);\n\t}\n}\n\n/* Output this character to the screen. */\nstatic int\ninput_print(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tint\t\t\t set;\n\n\tictx->utf8started = 0; /* can't be valid UTF-8 */\n\n\tset = ictx->cell.set == 0 ? ictx->cell.g0set : ictx->cell.g1set;\n\tif (set == 1)\n\t\tictx->cell.cell.attr |= GRID_ATTR_CHARSET;\n\telse\n\t\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\n\tutf8_set(&ictx->cell.cell.data, ictx->ch);\n\tscreen_write_collect_add(sctx, &ictx->cell.cell);\n\tictx->last = ictx->ch;\n\n\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\n\treturn (0);\n}\n\n/* Collect intermediate string. */\nstatic int\ninput_intermediate(struct input_ctx *ictx)\n{\n\tif (ictx->interm_len == (sizeof ictx->interm_buf) - 1)\n\t\tictx->flags |= INPUT_DISCARD;\n\telse {\n\t\tictx->interm_buf[ictx->interm_len++] = ictx->ch;\n\t\tictx->interm_buf[ictx->interm_len] = '\\0';\n\t}\n\n\treturn (0);\n}\n\n/* Collect parameter string. */\nstatic int\ninput_parameter(struct input_ctx *ictx)\n{\n\tif (ictx->param_len == (sizeof ictx->param_buf) - 1)\n\t\tictx->flags |= INPUT_DISCARD;\n\telse {\n\t\tictx->param_buf[ictx->param_len++] = ictx->ch;\n\t\tictx->param_buf[ictx->param_len] = '\\0';\n\t}\n\n\treturn (0);\n}\n\n/* Collect input string. */\nstatic int\ninput_input(struct input_ctx *ictx)\n{\n\tsize_t available;\n\n\tavailable = ictx->input_space;\n\twhile (ictx->input_len + 1 >= available) {\n\t\tavailable *= 2;\n\t\tif (available > INPUT_BUF_LIMIT) {\n\t\t\tictx->flags |= INPUT_DISCARD;\n\t\t\treturn (0);\n\t\t}\n\t\tictx->input_buf = xrealloc(ictx->input_buf, available);\n\t\tictx->input_space = available;\n\t}\n\tictx->input_buf[ictx->input_len++] = ictx->ch;\n\tictx->input_buf[ictx->input_len] = '\\0';\n\n\treturn (0);\n}\n\n/* Execute C0 control sequence. */\nstatic int\ninput_c0_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct screen\t\t*s = sctx->s;\n\n\tictx->utf8started = 0; /* can't be valid UTF-8 */\n\n\tlog_debug(\"%s: '%c'\", __func__, ictx->ch);\n\n\tswitch (ictx->ch) {\n\tcase '\\000':\t/* NUL */\n\t\tbreak;\n\tcase '\\007':\t/* BEL */\n\t\tif (wp != NULL)\n\t\t\talerts_queue(wp->window, WINDOW_BELL);\n\t\tbreak;\n\tcase '\\010':\t/* BS */\n\t\tscreen_write_backspace(sctx);\n\t\tbreak;\n\tcase '\\011':\t/* HT */\n\t\t/* Don't tab beyond the end of the line. */\n\t\tif (s->cx >= screen_size_x(s) - 1)\n\t\t\tbreak;\n\n\t\t/* Find the next tab point, or use the last column if none. */\n\t\tdo {\n\t\t\ts->cx++;\n\t\t\tif (bit_test(s->tabs, s->cx))\n\t\t\t\tbreak;\n\t\t} while (s->cx < screen_size_x(s) - 1);\n\t\tbreak;\n\tcase '\\012':\t/* LF */\n\tcase '\\013':\t/* VT */\n\tcase '\\014':\t/* FF */\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tif (s->mode & MODE_CRLF)\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\tbreak;\n\tcase '\\015':\t/* CR */\n\t\tscreen_write_carriagereturn(sctx);\n\t\tbreak;\n\tcase '\\016':\t/* SO */\n\t\tictx->cell.set = 1;\n\t\tbreak;\n\tcase '\\017':\t/* SI */\n\t\tictx->cell.set = 0;\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\tbreak;\n\t}\n\n\tictx->last = -1;\n\treturn (0);\n}\n\n/* Execute escape sequence. */\nstatic int\ninput_esc_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t\t*sctx = &ictx->ctx;\n\tstruct window_pane\t\t*wp = ictx->wp;\n\tstruct screen\t\t\t*s = sctx->s;\n\tstruct input_table_entry\t*entry;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\tlog_debug(\"%s: '%c', %s\", __func__, ictx->ch, ictx->interm_buf);\n\n\tentry = bsearch(ictx, input_esc_table, nitems(input_esc_table),\n\t    sizeof input_esc_table[0], input_table_compare);\n\tif (entry == NULL) {\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\treturn (0);\n\t}\n\n\tswitch (entry->type) {\n\tcase INPUT_ESC_RIS:\n\t\tif (wp != NULL)\n\t\t\twindow_pane_reset_palette(wp);\n\t\tinput_reset_cell(ictx);\n\t\tscreen_write_reset(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_IND:\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_NEL:\n\t\tscreen_write_carriagereturn(sctx);\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_HTS:\n\t\tif (s->cx < screen_size_x(s))\n\t\t\tbit_set(s->tabs, s->cx);\n\t\tbreak;\n\tcase INPUT_ESC_RI:\n\t\tscreen_write_reverseindex(sctx, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_DECKPAM:\n\t\tscreen_write_mode_set(sctx, MODE_KKEYPAD);\n\t\tbreak;\n\tcase INPUT_ESC_DECKPNM:\n\t\tscreen_write_mode_clear(sctx, MODE_KKEYPAD);\n\t\tbreak;\n\tcase INPUT_ESC_DECSC:\n\t\tinput_save_state(ictx);\n\t\tbreak;\n\tcase INPUT_ESC_DECRC:\n\t\tinput_restore_state(ictx);\n\t\tbreak;\n\tcase INPUT_ESC_DECALN:\n\t\tscreen_write_alignmenttest(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_SCSG0_ON:\n\t\tictx->cell.g0set = 1;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG0_OFF:\n\t\tictx->cell.g0set = 0;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG1_ON:\n\t\tictx->cell.g1set = 1;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG1_OFF:\n\t\tictx->cell.g1set = 0;\n\t\tbreak;\n\tcase INPUT_ESC_ST:\n\t\t/* ST terminates OSC but the state transition already did it. */\n\t\tbreak;\n\t}\n\n\tictx->last = -1;\n\treturn (0);\n}\n\n/* Execute control sequence. */\nstatic int\ninput_csi_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t       *sctx = &ictx->ctx;\n\tstruct screen\t\t       *s = sctx->s;\n\tstruct input_table_entry       *entry;\n\tint\t\t\t\ti, n, m;\n\tu_int\t\t\t\tcx, bg = ictx->cell.cell.bg;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\n\tlog_debug(\"%s: '%c' \\\"%s\\\" \\\"%s\\\"\",\n\t    __func__, ictx->ch, ictx->interm_buf, ictx->param_buf);\n\n\tif (input_split(ictx) != 0)\n\t\treturn (0);\n\n\tentry = bsearch(ictx, input_csi_table, nitems(input_csi_table),\n\t    sizeof input_csi_table[0], input_table_compare);\n\tif (entry == NULL) {\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\treturn (0);\n\t}\n\n\tswitch (entry->type) {\n\tcase INPUT_CSI_CBT:\n\t\t/* Find the previous tab point, n times. */\n\t\tcx = s->cx;\n\t\tif (cx > screen_size_x(s) - 1)\n\t\t\tcx = screen_size_x(s) - 1;\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n == -1)\n\t\t\tbreak;\n\t\twhile (cx > 0 && n-- > 0) {\n\t\t\tdo\n\t\t\t\tcx--;\n\t\t\twhile (cx > 0 && !bit_test(s->tabs, cx));\n\t\t}\n\t\ts->cx = cx;\n\t\tbreak;\n\tcase INPUT_CSI_CUB:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorleft(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUD:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursordown(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUF:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorright(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUP:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tm = input_get(ictx, 1, 1, 1);\n\t\tif (n != -1 && m != -1)\n\t\t\tscreen_write_cursormove(sctx, m - 1, n - 1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_MODSET:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tm = input_get(ictx, 1, 0, 0);\n\t\tif (n == 0 || (n == 4 && m == 0))\n\t\t\tscreen_write_mode_clear(sctx, MODE_KEXTENDED);\n\t\telse if (n == 4 && (m == 1 || m == 2))\n\t\t\tscreen_write_mode_set(sctx, MODE_KEXTENDED);\n\t\tbreak;\n\tcase INPUT_CSI_MODOFF:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n == 4)\n\t\t\tscreen_write_mode_clear(sctx, MODE_KEXTENDED);\n\t\tbreak;\n\tcase INPUT_CSI_WINOPS:\n\t\tinput_csi_dispatch_winops(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_CUU:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorup(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CNL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1) {\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\t\tscreen_write_cursordown(sctx, n);\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_CPL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1) {\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\t\tscreen_write_cursorup(sctx, n);\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_DA:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tinput_reply(ictx, \"\\033[?1;2c\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_DA_TWO:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tinput_reply(ictx, \"\\033[>84;0;0c\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_ECH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_clearcharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DCH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_deletecharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DECSTBM:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tm = input_get(ictx, 1, 1, screen_size_y(s));\n\t\tif (n != -1 && m != -1)\n\t\t\tscreen_write_scrollregion(sctx, n - 1, m - 1);\n\t\tbreak;\n\tcase INPUT_CSI_DL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_deleteline(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DSR:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tinput_reply(ictx, \"\\033[0n\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tinput_reply(ictx, \"\\033[%u;%uR\", s->cy + 1, s->cx + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_ED:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tscreen_write_clearendofscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreen_write_clearstartofscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreen_write_clearscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (input_get(ictx, 1, 0, 0) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Linux console extension to clear history\n\t\t\t\t * (for example before locking the screen).\n\t\t\t\t */\n\t\t\t\tscreen_write_clearhistory(sctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_EL:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tscreen_write_clearendofline(sctx, bg);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreen_write_clearstartofline(sctx, bg);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreen_write_clearline(sctx, bg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_HPA:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursormove(sctx, n - 1, -1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_ICH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_insertcharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_IL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_insertline(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_REP:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n == -1)\n\t\t\tbreak;\n\n\t\tif (ictx->last == -1)\n\t\t\tbreak;\n\t\tictx->ch = ictx->last;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tinput_print(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RCP:\n\t\tinput_restore_state(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RM:\n\t\tinput_csi_dispatch_rm(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RM_PRIVATE:\n\t\tinput_csi_dispatch_rm_private(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SCP:\n\t\tinput_save_state(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SGR:\n\t\tinput_csi_dispatch_sgr(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM:\n\t\tinput_csi_dispatch_sm(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM_PRIVATE:\n\t\tinput_csi_dispatch_sm_private(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SU:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_scrollup(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_SD:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_scrolldown(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_TBC:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (s->cx < screen_size_x(s))\n\t\t\t\tbit_clear(s->tabs, s->cx);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_nclear(s->tabs, 0, screen_size_x(s) - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_VPA:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursormove(sctx, -1, n - 1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_DECSCUSR:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n != -1)\n\t\t\tscreen_set_cursor_style(s, n);\n\t\tbreak;\n\tcase INPUT_CSI_XDA:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n == 0)\n\t\t\tinput_reply(ictx, \"\\033P>|tmux %s\\033\\\\\", getversion());\n\t\tbreak;\n\n\t}\n\n\tictx->last = -1;\n\treturn (0);\n}\n\n/* Handle CSI RM. */\nstatic void\ninput_csi_dispatch_rm(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_set(sctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI private RM. */\nstatic void\ninput_csi_dispatch_rm_private(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 1:\t\t/* DECCKM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_KCURSOR);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* DECCOLM */\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tscreen_write_clearscreen(sctx, gc->bg);\n\t\t\tbreak;\n\t\tcase 6:\t\t/* DECOM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_ORIGIN);\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* DECAWM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_WRAP);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tscreen_write_mode_clear(sctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tcase 25:\t/* TCEM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_CURSOR);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\tcase 1001:\n\t\tcase 1002:\n\t\tcase 1003:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tbreak;\n\t\tcase 1004:\n\t\t\tscreen_write_mode_clear(sctx, MODE_FOCUSON);\n\t\t\tbreak;\n\t\tcase 1005:\n\t\t\tscreen_write_mode_clear(sctx, MODE_MOUSE_UTF8);\n\t\t\tbreak;\n\t\tcase 1006:\n\t\t\tscreen_write_mode_clear(sctx, MODE_MOUSE_SGR);\n\t\t\tbreak;\n\t\tcase 47:\n\t\tcase 1047:\n\t\t\tscreen_write_alternateoff(sctx, gc, 0);\n\t\t\tbreak;\n\t\tcase 1049:\n\t\t\tscreen_write_alternateoff(sctx, gc, 1);\n\t\t\tbreak;\n\t\tcase 2004:\n\t\t\tscreen_write_mode_clear(sctx, MODE_BRACKETPASTE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI SM. */\nstatic void\ninput_csi_dispatch_sm(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_set(sctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_clear(sctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI private SM. */\nstatic void\ninput_csi_dispatch_sm_private(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 1:\t\t/* DECCKM */\n\t\t\tscreen_write_mode_set(sctx, MODE_KCURSOR);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* DECCOLM */\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tscreen_write_clearscreen(sctx, ictx->cell.cell.bg);\n\t\t\tbreak;\n\t\tcase 6:\t\t/* DECOM */\n\t\t\tscreen_write_mode_set(sctx, MODE_ORIGIN);\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* DECAWM */\n\t\t\tscreen_write_mode_set(sctx, MODE_WRAP);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tscreen_write_mode_set(sctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tcase 25:\t/* TCEM */\n\t\t\tscreen_write_mode_set(sctx, MODE_CURSOR);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_STANDARD);\n\t\t\tbreak;\n\t\tcase 1002:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_BUTTON);\n\t\t\tbreak;\n\t\tcase 1003:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_ALL);\n\t\t\tbreak;\n\t\tcase 1004:\n\t\t\tif (sctx->s->mode & MODE_FOCUSON)\n\t\t\t\tbreak;\n\t\t\tscreen_write_mode_set(sctx, MODE_FOCUSON);\n\t\t\tif (wp != NULL)\n\t\t\t\twp->flags |= PANE_FOCUSPUSH; /* force update */\n\t\t\tbreak;\n\t\tcase 1005:\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_UTF8);\n\t\t\tbreak;\n\t\tcase 1006:\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_SGR);\n\t\t\tbreak;\n\t\tcase 47:\n\t\tcase 1047:\n\t\t\tscreen_write_alternateon(sctx, gc, 0);\n\t\t\tbreak;\n\t\tcase 1049:\n\t\t\tscreen_write_alternateon(sctx, gc, 1);\n\t\t\tbreak;\n\t\tcase 2004:\n\t\t\tscreen_write_mode_set(sctx, MODE_BRACKETPASTE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI window operations. */\nstatic void\ninput_csi_dispatch_winops(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct screen\t\t*s = sctx->s;\n\tstruct window_pane\t*wp = ictx->wp;\n\tu_int\t\t\t x = screen_size_x(s), y = screen_size_y(s);\n\tint\t\t\t n, m;\n\n\tm = 0;\n\twhile ((n = input_get(ictx, m, 0, -1)) != -1) {\n\t\tswitch (n) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 11:\n\t\tcase 13:\n\t\tcase 14:\n\t\tcase 19:\n\t\tcase 20:\n\t\tcase 21:\n\t\tcase 24:\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tm++;\n\t\t\tif (input_get(ictx, m, 0, -1) == -1)\n\t\t\t\treturn;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 9:\n\t\tcase 10:\n\t\t\tm++;\n\t\t\tif (input_get(ictx, m, 0, -1) == -1)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tm++;\n\t\t\tswitch (input_get(ictx, m, 0, -1)) {\n\t\t\tcase -1:\n\t\t\t\treturn;\n\t\t\tcase 0:\n\t\t\tcase 2:\n\t\t\t\tscreen_push_title(sctx->s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tm++;\n\t\t\tswitch (input_get(ictx, m, 0, -1)) {\n\t\t\tcase -1:\n\t\t\t\treturn;\n\t\t\tcase 0:\n\t\t\tcase 2:\n\t\t\t\tscreen_pop_title(sctx->s);\n\t\t\t\tif (wp != NULL) {\n\t\t\t\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\t\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\t\t\tserver_status_window(wp->window);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tinput_reply(ictx, \"\\033[8;%u;%ut\", x, y);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tm++;\n\t}\n}\n\n/* Helper for 256 colour SGR. */\nstatic int\ninput_csi_dispatch_sgr_256_do(struct input_ctx *ictx, int fgbg, int c)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\n\tif (c == -1 || c > 255) {\n\t\tif (fgbg == 38)\n\t\t\tgc->fg = 8;\n\t\telse if (fgbg == 48)\n\t\t\tgc->bg = 8;\n\t} else {\n\t\tif (fgbg == 38)\n\t\t\tgc->fg = c | COLOUR_FLAG_256;\n\t\telse if (fgbg == 48)\n\t\t\tgc->bg = c | COLOUR_FLAG_256;\n\t\telse if (fgbg == 58)\n\t\t\tgc->us = c | COLOUR_FLAG_256;\n\t}\n\treturn (1);\n}\n\n/* Handle CSI SGR for 256 colours. */\nstatic void\ninput_csi_dispatch_sgr_256(struct input_ctx *ictx, int fgbg, u_int *i)\n{\n\tint\tc;\n\n\tc = input_get(ictx, (*i) + 1, 0, -1);\n\tif (input_csi_dispatch_sgr_256_do(ictx, fgbg, c))\n\t\t(*i)++;\n}\n\n/* Helper for RGB colour SGR. */\nstatic int\ninput_csi_dispatch_sgr_rgb_do(struct input_ctx *ictx, int fgbg, int r, int g,\n    int b)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\n\tif (r == -1 || r > 255)\n\t\treturn (0);\n\tif (g == -1 || g > 255)\n\t\treturn (0);\n\tif (b == -1 || b > 255)\n\t\treturn (0);\n\n\tif (fgbg == 38)\n\t\tgc->fg = colour_join_rgb(r, g, b);\n\telse if (fgbg == 48)\n\t\tgc->bg = colour_join_rgb(r, g, b);\n\telse if (fgbg == 58)\n\t\tgc->us = colour_join_rgb(r, g, b);\n\treturn (1);\n}\n\n/* Handle CSI SGR for RGB colours. */\nstatic void\ninput_csi_dispatch_sgr_rgb(struct input_ctx *ictx, int fgbg, u_int *i)\n{\n\tint\tr, g, b;\n\n\tr = input_get(ictx, (*i) + 1, 0, -1);\n\tg = input_get(ictx, (*i) + 2, 0, -1);\n\tb = input_get(ictx, (*i) + 3, 0, -1);\n\tif (input_csi_dispatch_sgr_rgb_do(ictx, fgbg, r, g, b))\n\t\t(*i) += 3;\n}\n\n/* Handle CSI SGR with a ISO parameter. */\nstatic void\ninput_csi_dispatch_sgr_colon(struct input_ctx *ictx, u_int i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tchar\t\t\t*s = ictx->param_list[i].str, *copy, *ptr, *out;\n\tint\t\t\t p[8];\n\tu_int\t\t\t n;\n\tconst char\t\t*errstr;\n\n\tfor (n = 0; n < nitems(p); n++)\n\t\tp[n] = -1;\n\tn = 0;\n\n\tptr = copy = xstrdup(s);\n\twhile ((out = strsep(&ptr, \":\")) != NULL) {\n\t\tif (*out != '\\0') {\n\t\t\tp[n++] = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\tif (errstr != NULL || n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else\n\t\t\tn++;\n\t\tlog_debug(\"%s: %u = %d\", __func__, n - 1, p[n - 1]);\n\t}\n\tfree(copy);\n\n\tif (n == 0)\n\t\treturn;\n\tif (p[0] == 4) {\n\t\tif (n != 2)\n\t\t\treturn;\n\t\tswitch (p[1]) {\n\t\tcase 0:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_5;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (n < 2 || (p[0] != 38 && p[0] != 48 && p[0] != 58))\n\t\treturn;\n\tswitch (p[1]) {\n\tcase 2:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tif (n == 5)\n\t\t\ti = 2;\n\t\telse\n\t\t\ti = 3;\n\t\tif (n < i + 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_rgb_do(ictx, p[0], p[i], p[i + 1],\n\t\t    p[i + 2]);\n\t\tbreak;\n\tcase 5:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_256_do(ictx, p[0], p[2]);\n\t\tbreak;\n\t}\n}\n\n/* Handle CSI SGR. */\nstatic void\ninput_csi_dispatch_sgr(struct input_ctx *ictx)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\tint\t\t\t n;\n\n\tif (ictx->param_list_len == 0) {\n\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING) {\n\t\t\tinput_csi_dispatch_sgr_colon(ictx, i);\n\t\t\tcontinue;\n\t\t}\n\t\tn = input_get(ictx, i, 0, 0);\n\t\tif (n == -1)\n\t\t\tcontinue;\n\n\t\tif (n == 38 || n == 48 || n == 58) {\n\t\t\ti++;\n\t\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\t\tcase 2:\n\t\t\t\tinput_csi_dispatch_sgr_rgb(ictx, n, &i);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tinput_csi_dispatch_sgr_256(ictx, n, &i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (n) {\n\t\tcase 0:\n\t\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr |= GRID_ATTR_BRIGHT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr |= GRID_ATTR_DIM;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr |= GRID_ATTR_ITALICS;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr |= GRID_ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tgc->attr |= GRID_ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tgc->attr |= GRID_ATTR_HIDDEN;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tgc->attr |= GRID_ATTR_STRIKETHROUGH;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tgc->attr &= ~(GRID_ATTR_BRIGHT|GRID_ATTR_DIM);\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tgc->attr &= ~GRID_ATTR_ITALICS;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\tgc->attr &= ~GRID_ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 27:\n\t\t\tgc->attr &= ~GRID_ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 28:\n\t\t\tgc->attr &= ~GRID_ATTR_HIDDEN;\n\t\t\tbreak;\n\t\tcase 29:\n\t\t\tgc->attr &= ~GRID_ATTR_STRIKETHROUGH;\n\t\t\tbreak;\n\t\tcase 30:\n\t\tcase 31:\n\t\tcase 32:\n\t\tcase 33:\n\t\tcase 34:\n\t\tcase 35:\n\t\tcase 36:\n\t\tcase 37:\n\t\t\tgc->fg = n - 30;\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tgc->fg = 8;\n\t\t\tbreak;\n\t\tcase 40:\n\t\tcase 41:\n\t\tcase 42:\n\t\tcase 43:\n\t\tcase 44:\n\t\tcase 45:\n\t\tcase 46:\n\t\tcase 47:\n\t\t\tgc->bg = n - 40;\n\t\t\tbreak;\n\t\tcase 49:\n\t\t\tgc->bg = 8;\n\t\t\tbreak;\n\t\tcase 53:\n\t\t\tgc->attr |= GRID_ATTR_OVERLINE;\n\t\t\tbreak;\n\t\tcase 55:\n\t\t\tgc->attr &= ~GRID_ATTR_OVERLINE;\n\t\t\tbreak;\n\t\tcase 59:\n\t\t\tgc->us = 0;\n\t\t\tbreak;\n\t\tcase 90:\n\t\tcase 91:\n\t\tcase 92:\n\t\tcase 93:\n\t\tcase 94:\n\t\tcase 95:\n\t\tcase 96:\n\t\tcase 97:\n\t\t\tgc->fg = n;\n\t\t\tbreak;\n\t\tcase 100:\n\t\tcase 101:\n\t\tcase 102:\n\t\tcase 103:\n\t\tcase 104:\n\t\tcase 105:\n\t\tcase 106:\n\t\tcase 107:\n\t\t\tgc->bg = n - 10;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* End of input with BEL. */\nstatic int\ninput_end_bel(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tictx->input_end = INPUT_END_BEL;\n\n\treturn (0);\n}\n\n/* DCS string started. */\nstatic void\ninput_enter_dcs(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->last = -1;\n}\n\n/* DCS terminator (ST) received. */\nstatic int\ninput_dcs_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_char\t\t\t*buf = ictx->input_buf;\n\tsize_t\t\t\t len = ictx->input_len;\n\tconst char\t\t prefix[] = \"tmux;\";\n\tconst u_int\t\t prefixlen = (sizeof prefix) - 1;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, buf);\n\n\tif (len >= prefixlen && strncmp(buf, prefix, prefixlen) == 0)\n\t\tscreen_write_rawstring(sctx, buf + prefixlen, len - prefixlen);\n\n\treturn (0);\n}\n\n/* OSC string started. */\nstatic void\ninput_enter_osc(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->last = -1;\n}\n\n/* OSC terminator (ST) received. */\nstatic void\ninput_exit_osc(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tu_char\t\t\t*p = ictx->input_buf;\n\tu_int\t\t\t option;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (ictx->input_len < 1 || *p < '0' || *p > '9')\n\t\treturn;\n\n\tlog_debug(\"%s: \\\"%s\\\" (end %s)\", __func__, p,\n\t    ictx->input_end == INPUT_END_ST ? \"ST\" : \"BEL\");\n\n\toption = 0;\n\twhile (*p >= '0' && *p <= '9')\n\t\toption = option * 10 + *p++ - '0';\n\tif (*p == ';')\n\t\tp++;\n\n\tswitch (option) {\n\tcase 0:\n\tcase 2:\n\t\tif (screen_set_title(sctx->s, p) && wp != NULL) {\n\t\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\tserver_status_window(wp->window);\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tinput_osc_4(ictx, p);\n\t\tbreak;\n\tcase 7:\n\t\tif (utf8_isvalid(p)) {\n\t\t\tscreen_set_path(sctx->s, p);\n\t\t\tif (wp != NULL) {\n\t\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\t\tserver_status_window(wp->window);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tinput_osc_10(ictx, p);\n\t\tbreak;\n\tcase 11:\n\t\tinput_osc_11(ictx, p);\n\t\tbreak;\n\tcase 12:\n\t\tif (utf8_isvalid(p) && *p != '?') /* ? is colour request */\n\t\t\tscreen_set_cursor_colour(sctx->s, p);\n\t\tbreak;\n\tcase 52:\n\t\tinput_osc_52(ictx, p);\n\t\tbreak;\n\tcase 104:\n\t\tinput_osc_104(ictx, p);\n\t\tbreak;\n\tcase 112:\n\t\tif (*p == '\\0') /* no arguments allowed */\n\t\t\tscreen_set_cursor_colour(sctx->s, \"\");\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%u'\", __func__, option);\n\t\tbreak;\n\t}\n}\n\n/* APC string started. */\nstatic void\ninput_enter_apc(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->last = -1;\n}\n\n/* APC terminator (ST) received. */\nstatic void\ninput_exit_apc(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\tif (screen_set_title(sctx->s, ictx->input_buf) && wp != NULL) {\n\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\tserver_redraw_window_borders(wp->window);\n\t\tserver_status_window(wp->window);\n\t}\n}\n\n/* Rename string started. */\nstatic void\ninput_enter_rename(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->last = -1;\n}\n\n/* Rename terminator (ST) received. */\nstatic void\ninput_exit_rename(struct input_ctx *ictx)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct options_entry\t*o;\n\n\tif (wp == NULL)\n\t\treturn;\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (!options_get_number(ictx->wp->options, \"allow-rename\"))\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\tif (!utf8_isvalid(ictx->input_buf))\n\t\treturn;\n\n\tif (ictx->input_len == 0) {\n\t\to = options_get_only(wp->window->options, \"automatic-rename\");\n\t\tif (o != NULL)\n\t\t\toptions_remove_or_default(o, -1, NULL);\n\t\treturn;\n\t}\n\twindow_set_name(wp->window, ictx->input_buf);\n\toptions_set_number(wp->window->options, \"automatic-rename\", 0);\n\tserver_redraw_window_borders(wp->window);\n\tserver_status_window(wp->window);\n}\n\n/* Open UTF-8 character. */\nstatic int\ninput_top_bit_set(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct utf8_data\t*ud = &ictx->utf8data;\n\n\tictx->last = -1;\n\n\tif (!ictx->utf8started) {\n\t\tif (utf8_open(ud, ictx->ch) != UTF8_MORE)\n\t\t\treturn (0);\n\t\tictx->utf8started = 1;\n\t\treturn (0);\n\t}\n\n\tswitch (utf8_append(ud, ictx->ch)) {\n\tcase UTF8_MORE:\n\t\treturn (0);\n\tcase UTF8_ERROR:\n\t\tictx->utf8started = 0;\n\t\treturn (0);\n\tcase UTF8_DONE:\n\t\tbreak;\n\t}\n\tictx->utf8started = 0;\n\n\tlog_debug(\"%s %hhu '%*s' (width %hhu)\", __func__, ud->size,\n\t    (int)ud->size, ud->data, ud->width);\n\n\tutf8_copy(&ictx->cell.cell.data, ud);\n\tscreen_write_collect_add(sctx, &ictx->cell.cell);\n\n\treturn (0);\n}\n\n/* Parse colour from OSC. */\nstatic int\ninput_osc_parse_colour(const char *p, u_int *r, u_int *g, u_int *b)\n{\n\tu_int\t\t rsize, gsize, bsize;\n\tconst char\t*cp, *s = p;\n\n\tif (sscanf(p, \"rgb:%x/%x/%x\", r, g, b) != 3)\n\t\treturn (0);\n\tp += 4;\n\n\tcp = strchr(p, '/');\n\trsize = cp - p;\n\tif (rsize == 1)\n\t\t(*r) = (*r) | ((*r) << 4);\n\telse if (rsize == 3)\n\t\t(*r) >>= 4;\n\telse if (rsize == 4)\n\t\t(*r) >>= 8;\n\telse if (rsize != 2)\n\t\treturn (0);\n\n\tp = cp + 1;\n\tcp = strchr(p, '/');\n\tgsize = cp - p;\n\tif (gsize == 1)\n\t\t(*g) = (*g) | ((*g) << 4);\n\telse if (gsize == 3)\n\t\t(*g) >>= 4;\n\telse if (gsize == 4)\n\t\t(*g) >>= 8;\n\telse if (gsize != 2)\n\t\treturn (0);\n\n\tbsize = strlen(cp + 1);\n\tif (bsize == 1)\n\t\t(*b) = (*b) | ((*b) << 4);\n\telse if (bsize == 3)\n\t\t(*b) >>= 4;\n\telse if (bsize == 4)\n\t\t(*b) >>= 8;\n\telse if (bsize != 2)\n\t\treturn (0);\n\n\tlog_debug(\"%s: %s = %02x%02x%02x\", __func__, s, *r, *g, *b);\n\treturn (1);\n}\n\n/* Reply to a colour request. */\nstatic void\ninput_osc_colour_reply(struct input_ctx *ictx, u_int n, int c)\n{\n    u_char\t r, g, b;\n    const char\t*end;\n\n    if (c == 8 || (~c & COLOUR_FLAG_RGB))\n\t    return;\n    colour_split_rgb(c, &r, &g, &b);\n\n    if (ictx->input_end == INPUT_END_BEL)\n\t    end = \"\\007\";\n    else\n\t    end = \"\\033\\\\\";\n    input_reply(ictx, \"\\033]%u;rgb:%02hhx/%02hhx/%02hhx%s\", n, r, g, b, end);\n}\n\n/* Handle the OSC 4 sequence for setting (multiple) palette entries. */\nstatic void\ninput_osc_4(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tchar\t\t\t*copy, *s, *next = NULL;\n\tlong\t\t\t idx;\n\tu_int\t\t\t r, g, b;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tcopy = s = xstrdup(p);\n\twhile (s != NULL && *s != '\\0') {\n\t\tidx = strtol(s, &next, 10);\n\t\tif (*next++ != ';')\n\t\t\tgoto bad;\n\t\tif (idx < 0 || idx >= 0x100)\n\t\t\tgoto bad;\n\n\t\ts = strsep(&next, \";\");\n\t\tif (!input_osc_parse_colour(s, &r, &g, &b)) {\n\t\t\ts = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\twindow_pane_set_palette(wp, idx, colour_join_rgb(r, g, b));\n\t\ts = next;\n\t}\n\n\tfree(copy);\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 4: %s\", p);\n\tfree(copy);\n}\n\n/* Handle the OSC 10 sequence for setting and querying foreground colour. */\nstatic void\ninput_osc_10(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct grid_cell\t defaults;\n\tu_int\t\t\t r, g, b;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tif (strcmp(p, \"?\") == 0) {\n\t\ttty_default_colours(&defaults, wp);\n\t\tinput_osc_colour_reply(ictx, 10, defaults.fg);\n\t\treturn;\n\t}\n\n\tif (!input_osc_parse_colour(p, &r, &g, &b))\n\t\tgoto bad;\n\twp->fg = colour_join_rgb(r, g, b);\n\twp->flags |= (PANE_REDRAW|PANE_STYLECHANGED);\n\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 10: %s\", p);\n}\n\n/* Handle the OSC 11 sequence for setting and querying background colour. */\nstatic void\ninput_osc_11(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct grid_cell\t defaults;\n\tu_int\t\t\t r, g, b;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tif (strcmp(p, \"?\") == 0) {\n\t\ttty_default_colours(&defaults, wp);\n\t\tinput_osc_colour_reply(ictx, 11, defaults.bg);\n\t\treturn;\n\t}\n\n\tif (!input_osc_parse_colour(p, &r, &g, &b))\n\t    goto bad;\n\twp->bg = colour_join_rgb(r, g, b);\n\twp->flags |= (PANE_REDRAW|PANE_STYLECHANGED);\n\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 11: %s\", p);\n}\n\n/* Handle the OSC 52 sequence for setting the clipboard. */\nstatic void\ninput_osc_52(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tchar\t\t\t*end;\n\tconst char\t\t*buf;\n\tsize_t\t\t\t len;\n\tu_char\t\t\t*out;\n\tint\t\t\t outlen, state;\n\tstruct screen_write_ctx\t ctx;\n\tstruct paste_buffer\t*pb;\n\n\tif (wp == NULL)\n\t\treturn;\n\tstate = options_get_number(global_options, \"set-clipboard\");\n\tif (state != 2)\n\t\treturn;\n\n\tif ((end = strchr(p, ';')) == NULL)\n\t\treturn;\n\tend++;\n\tif (*end == '\\0')\n\t\treturn;\n\tlog_debug(\"%s: %s\", __func__, end);\n\n\tif (strcmp(end, \"?\") == 0) {\n\t\tif ((pb = paste_get_top(NULL)) != NULL) {\n\t\t\tbuf = paste_buffer_data(pb, &len);\n\t\t\toutlen = 4 * ((len + 2) / 3) + 1;\n\t\t\tout = xmalloc(outlen);\n\t\t\tif ((outlen = b64_ntop(buf, len, out, outlen)) == -1) {\n\t\t\t\tfree(out);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\toutlen = 0;\n\t\t\tout = NULL;\n\t\t}\n\t\tbufferevent_write(ictx->event, \"\\033]52;;\", 6);\n\t\tif (outlen != 0)\n\t\t\tbufferevent_write(ictx->event, out, outlen);\n\t\tif (ictx->input_end == INPUT_END_BEL)\n\t\t\tbufferevent_write(ictx->event, \"\\007\", 1);\n\t\telse\n\t\t\tbufferevent_write(ictx->event, \"\\033\\\\\", 2);\n\t\tfree(out);\n\t\treturn;\n\t}\n\n\tlen = (strlen(end) / 4) * 3;\n\tif (len == 0)\n\t\treturn;\n\n\tout = xmalloc(len);\n\tif ((outlen = b64_pton(end, out, len)) == -1) {\n\t\tfree(out);\n\t\treturn;\n\t}\n\n\tscreen_write_start_pane(&ctx, wp, NULL);\n\tscreen_write_setselection(&ctx, out, outlen);\n\tscreen_write_stop(&ctx);\n\tnotify_pane(\"pane-set-clipboard\", wp);\n\n\tpaste_add(NULL, out, outlen);\n}\n\n/* Handle the OSC 104 sequence for unsetting (multiple) palette entries. */\nstatic void\ninput_osc_104(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tchar\t\t\t*copy, *s;\n\tlong\t\t\t idx;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tif (*p == '\\0') {\n\t\twindow_pane_reset_palette(wp);\n\t\treturn;\n\t}\n\n\tcopy = s = xstrdup(p);\n\twhile (*s != '\\0') {\n\t\tidx = strtol(s, &s, 10);\n\t\tif (*s != '\\0' && *s != ';')\n\t\t\tgoto bad;\n\t\tif (idx < 0 || idx >= 0x100)\n\t\t\tgoto bad;\n\n\t\twindow_pane_unset_palette(wp, idx);\n\t\tif (*s == ';')\n\t\t\ts++;\n\t}\n\tfree(copy);\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 104: %s\", p);\n\tfree(copy);\n}\n"], "fixing_code": ["/* $OpenBSD$ */\n\n/*\n * Copyright (c) 2007 Nicholas Marriott <nicholas.marriott@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER\n * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/types.h>\n\n#include <netinet/in.h>\n\n#include <ctype.h>\n#include <resolv.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"tmux.h\"\n\n/*\n * Based on the description by Paul Williams at:\n *\n * https://vt100.net/emu/dec_ansi_parser\n *\n * With the following changes:\n *\n * - 7-bit only.\n *\n * - Support for UTF-8.\n *\n * - OSC (but not APC) may be terminated by \\007 as well as ST.\n *\n * - A state for APC similar to OSC. Some terminals appear to use this to set\n *   the title.\n *\n * - A state for the screen \\033k...\\033\\\\ sequence to rename a window. This is\n *   pretty stupid but not supporting it is more trouble than it is worth.\n *\n * - Special handling for ESC inside a DCS to allow arbitrary byte sequences to\n *   be passed to the underlying terminals.\n */\n\n/* Input parser cell. */\nstruct input_cell {\n\tstruct grid_cell\tcell;\n\tint\t\t\tset;\n\tint\t\t\tg0set;\t/* 1 if ACS */\n\tint\t\t\tg1set;\t/* 1 if ACS */\n};\n\n/* Input parser argument. */\nstruct input_param {\n\tenum {\n\t\tINPUT_MISSING,\n\t\tINPUT_NUMBER,\n\t\tINPUT_STRING\n\t}\t\t\ttype;\n\tunion {\n\t\tint\t\tnum;\n\t\tchar\t       *str;\n\t};\n};\n\n/* Input parser context. */\nstruct input_ctx {\n\tstruct window_pane     *wp;\n\tstruct bufferevent     *event;\n\tstruct screen_write_ctx ctx;\n\n\tstruct input_cell\tcell;\n\n\tstruct input_cell\told_cell;\n\tu_int\t\t\told_cx;\n\tu_int\t\t\told_cy;\n\tint\t\t\told_mode;\n\n\tu_char\t\t\tinterm_buf[4];\n\tsize_t\t\t\tinterm_len;\n\n\tu_char\t\t\tparam_buf[64];\n\tsize_t\t\t\tparam_len;\n\n#define INPUT_BUF_START 32\n#define INPUT_BUF_LIMIT 1048576\n\tu_char\t\t       *input_buf;\n\tsize_t\t\t\tinput_len;\n\tsize_t\t\t\tinput_space;\n\tenum {\n\t\tINPUT_END_ST,\n\t\tINPUT_END_BEL\n\t}\t\t\tinput_end;\n\n\tstruct input_param\tparam_list[24];\n\tu_int\t\t\tparam_list_len;\n\n\tstruct utf8_data\tutf8data;\n\tint\t\t\tutf8started;\n\n\tint\t\t\tch;\n\tint\t\t\tlast;\n\n\tint\t\t\tflags;\n#define INPUT_DISCARD 0x1\n\n\tconst struct input_state *state;\n\n\tstruct event\t\ttimer;\n\n\t/*\n\t * All input received since we were last in the ground state. Sent to\n\t * control clients on connection.\n\t */\n\tstruct evbuffer\t\t*since_ground;\n};\n\n/* Helper functions. */\nstruct input_transition;\nstatic int\tinput_split(struct input_ctx *);\nstatic int\tinput_get(struct input_ctx *, u_int, int, int);\nstatic void printflike(2, 3) input_reply(struct input_ctx *, const char *, ...);\nstatic void\tinput_set_state(struct input_ctx *,\n\t\t    const struct input_transition *);\nstatic void\tinput_reset_cell(struct input_ctx *);\n\nstatic void\tinput_osc_4(struct input_ctx *, const char *);\nstatic void\tinput_osc_10(struct input_ctx *, const char *);\nstatic void\tinput_osc_11(struct input_ctx *, const char *);\nstatic void\tinput_osc_52(struct input_ctx *, const char *);\nstatic void\tinput_osc_104(struct input_ctx *, const char *);\n\n/* Transition entry/exit handlers. */\nstatic void\tinput_clear(struct input_ctx *);\nstatic void\tinput_ground(struct input_ctx *);\nstatic void\tinput_enter_dcs(struct input_ctx *);\nstatic void\tinput_enter_osc(struct input_ctx *);\nstatic void\tinput_exit_osc(struct input_ctx *);\nstatic void\tinput_enter_apc(struct input_ctx *);\nstatic void\tinput_exit_apc(struct input_ctx *);\nstatic void\tinput_enter_rename(struct input_ctx *);\nstatic void\tinput_exit_rename(struct input_ctx *);\n\n/* Input state handlers. */\nstatic int\tinput_print(struct input_ctx *);\nstatic int\tinput_intermediate(struct input_ctx *);\nstatic int\tinput_parameter(struct input_ctx *);\nstatic int\tinput_input(struct input_ctx *);\nstatic int\tinput_c0_dispatch(struct input_ctx *);\nstatic int\tinput_esc_dispatch(struct input_ctx *);\nstatic int\tinput_csi_dispatch(struct input_ctx *);\nstatic void\tinput_csi_dispatch_rm(struct input_ctx *);\nstatic void\tinput_csi_dispatch_rm_private(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sm(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sm_private(struct input_ctx *);\nstatic void\tinput_csi_dispatch_winops(struct input_ctx *);\nstatic void\tinput_csi_dispatch_sgr_256(struct input_ctx *, int, u_int *);\nstatic void\tinput_csi_dispatch_sgr_rgb(struct input_ctx *, int, u_int *);\nstatic void\tinput_csi_dispatch_sgr(struct input_ctx *);\nstatic int\tinput_dcs_dispatch(struct input_ctx *);\nstatic int\tinput_top_bit_set(struct input_ctx *);\nstatic int\tinput_end_bel(struct input_ctx *);\n\n/* Command table comparison function. */\nstatic int\tinput_table_compare(const void *, const void *);\n\n/* Command table entry. */\nstruct input_table_entry {\n\tint\t\tch;\n\tconst char     *interm;\n\tint\t\ttype;\n};\n\n/* Escape commands. */\nenum input_esc_type {\n\tINPUT_ESC_DECALN,\n\tINPUT_ESC_DECKPAM,\n\tINPUT_ESC_DECKPNM,\n\tINPUT_ESC_DECRC,\n\tINPUT_ESC_DECSC,\n\tINPUT_ESC_HTS,\n\tINPUT_ESC_IND,\n\tINPUT_ESC_NEL,\n\tINPUT_ESC_RI,\n\tINPUT_ESC_RIS,\n\tINPUT_ESC_SCSG0_OFF,\n\tINPUT_ESC_SCSG0_ON,\n\tINPUT_ESC_SCSG1_OFF,\n\tINPUT_ESC_SCSG1_ON,\n\tINPUT_ESC_ST,\n};\n\n/* Escape command table. */\nstatic const struct input_table_entry input_esc_table[] = {\n\t{ '0', \"(\", INPUT_ESC_SCSG0_ON },\n\t{ '0', \")\", INPUT_ESC_SCSG1_ON },\n\t{ '7', \"\",  INPUT_ESC_DECSC },\n\t{ '8', \"\",  INPUT_ESC_DECRC },\n\t{ '8', \"#\", INPUT_ESC_DECALN },\n\t{ '=', \"\",  INPUT_ESC_DECKPAM },\n\t{ '>', \"\",  INPUT_ESC_DECKPNM },\n\t{ 'B', \"(\", INPUT_ESC_SCSG0_OFF },\n\t{ 'B', \")\", INPUT_ESC_SCSG1_OFF },\n\t{ 'D', \"\",  INPUT_ESC_IND },\n\t{ 'E', \"\",  INPUT_ESC_NEL },\n\t{ 'H', \"\",  INPUT_ESC_HTS },\n\t{ 'M', \"\",  INPUT_ESC_RI },\n\t{ '\\\\', \"\", INPUT_ESC_ST },\n\t{ 'c', \"\",  INPUT_ESC_RIS },\n};\n\n/* Control (CSI) commands. */\nenum input_csi_type {\n\tINPUT_CSI_CBT,\n\tINPUT_CSI_CNL,\n\tINPUT_CSI_CPL,\n\tINPUT_CSI_CUB,\n\tINPUT_CSI_CUD,\n\tINPUT_CSI_CUF,\n\tINPUT_CSI_CUP,\n\tINPUT_CSI_CUU,\n\tINPUT_CSI_DA,\n\tINPUT_CSI_DA_TWO,\n\tINPUT_CSI_DCH,\n\tINPUT_CSI_DECSCUSR,\n\tINPUT_CSI_DECSTBM,\n\tINPUT_CSI_DL,\n\tINPUT_CSI_DSR,\n\tINPUT_CSI_ECH,\n\tINPUT_CSI_ED,\n\tINPUT_CSI_EL,\n\tINPUT_CSI_HPA,\n\tINPUT_CSI_ICH,\n\tINPUT_CSI_IL,\n\tINPUT_CSI_MODOFF,\n\tINPUT_CSI_MODSET,\n\tINPUT_CSI_RCP,\n\tINPUT_CSI_REP,\n\tINPUT_CSI_RM,\n\tINPUT_CSI_RM_PRIVATE,\n\tINPUT_CSI_SCP,\n\tINPUT_CSI_SD,\n\tINPUT_CSI_SGR,\n\tINPUT_CSI_SM,\n\tINPUT_CSI_SM_PRIVATE,\n\tINPUT_CSI_SU,\n\tINPUT_CSI_TBC,\n\tINPUT_CSI_VPA,\n\tINPUT_CSI_WINOPS,\n\tINPUT_CSI_XDA,\n};\n\n/* Control (CSI) command table. */\nstatic const struct input_table_entry input_csi_table[] = {\n\t{ '@', \"\",  INPUT_CSI_ICH },\n\t{ 'A', \"\",  INPUT_CSI_CUU },\n\t{ 'B', \"\",  INPUT_CSI_CUD },\n\t{ 'C', \"\",  INPUT_CSI_CUF },\n\t{ 'D', \"\",  INPUT_CSI_CUB },\n\t{ 'E', \"\",  INPUT_CSI_CNL },\n\t{ 'F', \"\",  INPUT_CSI_CPL },\n\t{ 'G', \"\",  INPUT_CSI_HPA },\n\t{ 'H', \"\",  INPUT_CSI_CUP },\n\t{ 'J', \"\",  INPUT_CSI_ED },\n\t{ 'K', \"\",  INPUT_CSI_EL },\n\t{ 'L', \"\",  INPUT_CSI_IL },\n\t{ 'M', \"\",  INPUT_CSI_DL },\n\t{ 'P', \"\",  INPUT_CSI_DCH },\n\t{ 'S', \"\",  INPUT_CSI_SU },\n\t{ 'T', \"\",  INPUT_CSI_SD },\n\t{ 'X', \"\",  INPUT_CSI_ECH },\n\t{ 'Z', \"\",  INPUT_CSI_CBT },\n\t{ '`', \"\",  INPUT_CSI_HPA },\n\t{ 'b', \"\",  INPUT_CSI_REP },\n\t{ 'c', \"\",  INPUT_CSI_DA },\n\t{ 'c', \">\", INPUT_CSI_DA_TWO },\n\t{ 'd', \"\",  INPUT_CSI_VPA },\n\t{ 'f', \"\",  INPUT_CSI_CUP },\n\t{ 'g', \"\",  INPUT_CSI_TBC },\n\t{ 'h', \"\",  INPUT_CSI_SM },\n\t{ 'h', \"?\", INPUT_CSI_SM_PRIVATE },\n\t{ 'l', \"\",  INPUT_CSI_RM },\n\t{ 'l', \"?\", INPUT_CSI_RM_PRIVATE },\n\t{ 'm', \"\",  INPUT_CSI_SGR },\n\t{ 'm', \">\", INPUT_CSI_MODSET },\n\t{ 'n', \"\",  INPUT_CSI_DSR },\n\t{ 'n', \">\", INPUT_CSI_MODOFF },\n\t{ 'q', \" \", INPUT_CSI_DECSCUSR },\n\t{ 'q', \">\", INPUT_CSI_XDA },\n\t{ 'r', \"\",  INPUT_CSI_DECSTBM },\n\t{ 's', \"\",  INPUT_CSI_SCP },\n\t{ 't', \"\",  INPUT_CSI_WINOPS },\n\t{ 'u', \"\",  INPUT_CSI_RCP },\n};\n\n/* Input transition. */\nstruct input_transition {\n\tint\t\t\t\tfirst;\n\tint\t\t\t\tlast;\n\n\tint\t\t\t\t(*handler)(struct input_ctx *);\n\tconst struct input_state       *state;\n};\n\n/* Input state. */\nstruct input_state {\n\tconst char\t\t\t*name;\n\tvoid\t\t\t\t(*enter)(struct input_ctx *);\n\tvoid\t\t\t\t(*exit)(struct input_ctx *);\n\tconst struct input_transition\t*transitions;\n};\n\n/* State transitions available from all states. */\n#define INPUT_STATE_ANYWHERE \\\n\t{ 0x18, 0x18, input_c0_dispatch, &input_state_ground }, \\\n\t{ 0x1a, 0x1a, input_c0_dispatch, &input_state_ground }, \\\n\t{ 0x1b, 0x1b, NULL,\t\t &input_state_esc_enter }\n\n/* Forward declarations of state tables. */\nstatic const struct input_transition input_state_ground_table[];\nstatic const struct input_transition input_state_esc_enter_table[];\nstatic const struct input_transition input_state_esc_intermediate_table[];\nstatic const struct input_transition input_state_csi_enter_table[];\nstatic const struct input_transition input_state_csi_parameter_table[];\nstatic const struct input_transition input_state_csi_intermediate_table[];\nstatic const struct input_transition input_state_csi_ignore_table[];\nstatic const struct input_transition input_state_dcs_enter_table[];\nstatic const struct input_transition input_state_dcs_parameter_table[];\nstatic const struct input_transition input_state_dcs_intermediate_table[];\nstatic const struct input_transition input_state_dcs_handler_table[];\nstatic const struct input_transition input_state_dcs_escape_table[];\nstatic const struct input_transition input_state_dcs_ignore_table[];\nstatic const struct input_transition input_state_osc_string_table[];\nstatic const struct input_transition input_state_apc_string_table[];\nstatic const struct input_transition input_state_rename_string_table[];\nstatic const struct input_transition input_state_consume_st_table[];\n\n/* ground state definition. */\nstatic const struct input_state input_state_ground = {\n\t\"ground\",\n\tinput_ground, NULL,\n\tinput_state_ground_table\n};\n\n/* esc_enter state definition. */\nstatic const struct input_state input_state_esc_enter = {\n\t\"esc_enter\",\n\tinput_clear, NULL,\n\tinput_state_esc_enter_table\n};\n\n/* esc_intermediate state definition. */\nstatic const struct input_state input_state_esc_intermediate = {\n\t\"esc_intermediate\",\n\tNULL, NULL,\n\tinput_state_esc_intermediate_table\n};\n\n/* csi_enter state definition. */\nstatic const struct input_state input_state_csi_enter = {\n\t\"csi_enter\",\n\tinput_clear, NULL,\n\tinput_state_csi_enter_table\n};\n\n/* csi_parameter state definition. */\nstatic const struct input_state input_state_csi_parameter = {\n\t\"csi_parameter\",\n\tNULL, NULL,\n\tinput_state_csi_parameter_table\n};\n\n/* csi_intermediate state definition. */\nstatic const struct input_state input_state_csi_intermediate = {\n\t\"csi_intermediate\",\n\tNULL, NULL,\n\tinput_state_csi_intermediate_table\n};\n\n/* csi_ignore state definition. */\nstatic const struct input_state input_state_csi_ignore = {\n\t\"csi_ignore\",\n\tNULL, NULL,\n\tinput_state_csi_ignore_table\n};\n\n/* dcs_enter state definition. */\nstatic const struct input_state input_state_dcs_enter = {\n\t\"dcs_enter\",\n\tinput_enter_dcs, NULL,\n\tinput_state_dcs_enter_table\n};\n\n/* dcs_parameter state definition. */\nstatic const struct input_state input_state_dcs_parameter = {\n\t\"dcs_parameter\",\n\tNULL, NULL,\n\tinput_state_dcs_parameter_table\n};\n\n/* dcs_intermediate state definition. */\nstatic const struct input_state input_state_dcs_intermediate = {\n\t\"dcs_intermediate\",\n\tNULL, NULL,\n\tinput_state_dcs_intermediate_table\n};\n\n/* dcs_handler state definition. */\nstatic const struct input_state input_state_dcs_handler = {\n\t\"dcs_handler\",\n\tNULL, NULL,\n\tinput_state_dcs_handler_table\n};\n\n/* dcs_escape state definition. */\nstatic const struct input_state input_state_dcs_escape = {\n\t\"dcs_escape\",\n\tNULL, NULL,\n\tinput_state_dcs_escape_table\n};\n\n/* dcs_ignore state definition. */\nstatic const struct input_state input_state_dcs_ignore = {\n\t\"dcs_ignore\",\n\tNULL, NULL,\n\tinput_state_dcs_ignore_table\n};\n\n/* osc_string state definition. */\nstatic const struct input_state input_state_osc_string = {\n\t\"osc_string\",\n\tinput_enter_osc, input_exit_osc,\n\tinput_state_osc_string_table\n};\n\n/* apc_string state definition. */\nstatic const struct input_state input_state_apc_string = {\n\t\"apc_string\",\n\tinput_enter_apc, input_exit_apc,\n\tinput_state_apc_string_table\n};\n\n/* rename_string state definition. */\nstatic const struct input_state input_state_rename_string = {\n\t\"rename_string\",\n\tinput_enter_rename, input_exit_rename,\n\tinput_state_rename_string_table\n};\n\n/* consume_st state definition. */\nstatic const struct input_state input_state_consume_st = {\n\t\"consume_st\",\n\tinput_enter_rename, NULL, /* rename also waits for ST */\n\tinput_state_consume_st_table\n};\n\n/* ground state table. */\nstatic const struct input_transition input_state_ground_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch, NULL },\n\t{ 0x19, 0x19, input_c0_dispatch, NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch, NULL },\n\t{ 0x20, 0x7e, input_print,\t NULL },\n\t{ 0x7f, 0x7f, NULL,\t\t NULL },\n\t{ 0x80, 0xff, input_top_bit_set, NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* esc_enter state table. */\nstatic const struct input_transition input_state_esc_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_esc_intermediate },\n\t{ 0x30, 0x4f, input_esc_dispatch, &input_state_ground },\n\t{ 0x50, 0x50, NULL,\t\t  &input_state_dcs_enter },\n\t{ 0x51, 0x57, input_esc_dispatch, &input_state_ground },\n\t{ 0x58, 0x58, NULL,\t\t  &input_state_consume_st },\n\t{ 0x59, 0x59, input_esc_dispatch, &input_state_ground },\n\t{ 0x5a, 0x5a, input_esc_dispatch, &input_state_ground },\n\t{ 0x5b, 0x5b, NULL,\t\t  &input_state_csi_enter },\n\t{ 0x5c, 0x5c, input_esc_dispatch, &input_state_ground },\n\t{ 0x5d, 0x5d, NULL,\t\t  &input_state_osc_string },\n\t{ 0x5e, 0x5e, NULL,\t\t  &input_state_consume_st },\n\t{ 0x5f, 0x5f, NULL,\t\t  &input_state_apc_string },\n\t{ 0x60, 0x6a, input_esc_dispatch, &input_state_ground },\n\t{ 0x6b, 0x6b, NULL,\t\t  &input_state_rename_string },\n\t{ 0x6c, 0x7e, input_esc_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* esc_intermediate state table. */\nstatic const struct input_transition input_state_esc_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x7e, input_esc_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_enter state table. */\nstatic const struct input_transition input_state_csi_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3a, 0x3a, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3b, 0x3b, input_parameter,\t  &input_state_csi_parameter },\n\t{ 0x3c, 0x3f, input_intermediate, &input_state_csi_parameter },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_parameter state table. */\nstatic const struct input_transition input_state_csi_parameter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_csi_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  NULL },\n\t{ 0x3a, 0x3a, input_parameter,\t  NULL },\n\t{ 0x3b, 0x3b, input_parameter,\t  NULL },\n\t{ 0x3c, 0x3f, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_intermediate state table. */\nstatic const struct input_transition input_state_csi_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch,  NULL },\n\t{ 0x19, 0x19, input_c0_dispatch,  NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch,  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x3f, NULL,\t\t  &input_state_csi_ignore },\n\t{ 0x40, 0x7e, input_csi_dispatch, &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* csi_ignore state table. */\nstatic const struct input_transition input_state_csi_ignore_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, input_c0_dispatch, NULL },\n\t{ 0x19, 0x19, input_c0_dispatch, NULL },\n\t{ 0x1c, 0x1f, input_c0_dispatch, NULL },\n\t{ 0x20, 0x3f, NULL,\t\t NULL },\n\t{ 0x40, 0x7e, NULL,\t\t &input_state_ground },\n\t{ 0x7f, 0xff, NULL,\t\t NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_enter state table. */\nstatic const struct input_transition input_state_dcs_enter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  &input_state_dcs_parameter },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  &input_state_dcs_parameter },\n\t{ 0x3c, 0x3f, input_intermediate, &input_state_dcs_parameter },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_parameter state table. */\nstatic const struct input_transition input_state_dcs_parameter_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, &input_state_dcs_intermediate },\n\t{ 0x30, 0x39, input_parameter,\t  NULL },\n\t{ 0x3a, 0x3a, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x3b, 0x3b, input_parameter,\t  NULL },\n\t{ 0x3c, 0x3f, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_intermediate state table. */\nstatic const struct input_transition input_state_dcs_intermediate_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t\t  NULL },\n\t{ 0x19, 0x19, NULL,\t\t  NULL },\n\t{ 0x1c, 0x1f, NULL,\t\t  NULL },\n\t{ 0x20, 0x2f, input_intermediate, NULL },\n\t{ 0x30, 0x3f, NULL,\t\t  &input_state_dcs_ignore },\n\t{ 0x40, 0x7e, input_input,\t  &input_state_dcs_handler },\n\t{ 0x7f, 0xff, NULL,\t\t  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_handler state table. */\nstatic const struct input_transition input_state_dcs_handler_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x1a, input_input,  NULL },\n\t{ 0x1b, 0x1b, NULL,\t    &input_state_dcs_escape },\n\t{ 0x1c, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_escape state table. */\nstatic const struct input_transition input_state_dcs_escape_table[] = {\n\t/* No INPUT_STATE_ANYWHERE */\n\n\t{ 0x00, 0x5b, input_input,\t  &input_state_dcs_handler },\n\t{ 0x5c, 0x5c, input_dcs_dispatch, &input_state_ground },\n\t{ 0x5d, 0xff, input_input,\t  &input_state_dcs_handler },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* dcs_ignore state table. */\nstatic const struct input_transition input_state_dcs_ignore_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, NULL,\t    NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* osc_string state table. */\nstatic const struct input_transition input_state_osc_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x06, NULL,\t     NULL },\n\t{ 0x07, 0x07, input_end_bel, &input_state_ground },\n\t{ 0x08, 0x17, NULL,\t     NULL },\n\t{ 0x19, 0x19, NULL,\t     NULL },\n\t{ 0x1c, 0x1f, NULL,\t     NULL },\n\t{ 0x20, 0xff, input_input,   NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* apc_string state table. */\nstatic const struct input_transition input_state_apc_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* rename_string state table. */\nstatic const struct input_transition input_state_rename_string_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, input_input,  NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* consume_st state table. */\nstatic const struct input_transition input_state_consume_st_table[] = {\n\tINPUT_STATE_ANYWHERE,\n\n\t{ 0x00, 0x17, NULL,\t    NULL },\n\t{ 0x19, 0x19, NULL,\t    NULL },\n\t{ 0x1c, 0x1f, NULL,\t    NULL },\n\t{ 0x20, 0xff, NULL,\t    NULL },\n\n\t{ -1, -1, NULL, NULL }\n};\n\n/* Input table compare. */\nstatic int\ninput_table_compare(const void *key, const void *value)\n{\n\tconst struct input_ctx\t\t*ictx = key;\n\tconst struct input_table_entry\t*entry = value;\n\n\tif (ictx->ch != entry->ch)\n\t\treturn (ictx->ch - entry->ch);\n\treturn (strcmp(ictx->interm_buf, entry->interm));\n}\n\n/*\n * Timer - if this expires then have been waiting for a terminator for too\n * long, so reset to ground.\n */\nstatic void\ninput_timer_callback(__unused int fd, __unused short events, void *arg)\n{\n\tstruct input_ctx\t*ictx = arg;\n\n\tlog_debug(\"%s: %s expired\" , __func__, ictx->state->name);\n\tinput_reset(ictx, 0);\n}\n\n/* Start the timer. */\nstatic void\ninput_start_timer(struct input_ctx *ictx)\n{\n\tstruct timeval\ttv = { .tv_sec = 5, .tv_usec = 0 };\n\n\tevent_del(&ictx->timer);\n\tevent_add(&ictx->timer, &tv);\n}\n\n/* Reset cell state to default. */\nstatic void\ninput_reset_cell(struct input_ctx *ictx)\n{\n\tmemcpy(&ictx->cell.cell, &grid_default_cell, sizeof ictx->cell.cell);\n\tictx->cell.set = 0;\n\tictx->cell.g0set = ictx->cell.g1set = 0;\n\n\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\tictx->old_cx = 0;\n\tictx->old_cy = 0;\n}\n\n/* Save screen state. */\nstatic void\ninput_save_state(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct screen\t\t*s = sctx->s;\n\n\tmemcpy(&ictx->old_cell, &ictx->cell, sizeof ictx->old_cell);\n\tictx->old_cx = s->cx;\n\tictx->old_cy = s->cy;\n\tictx->old_mode = s->mode;\n}\n\n/* Restore screen state. */\nstatic void\ninput_restore_state(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tmemcpy(&ictx->cell, &ictx->old_cell, sizeof ictx->cell);\n\tif (ictx->old_mode & MODE_ORIGIN)\n\t\tscreen_write_mode_set(sctx, MODE_ORIGIN);\n\telse\n\t\tscreen_write_mode_clear(sctx, MODE_ORIGIN);\n\tscreen_write_cursormove(sctx, ictx->old_cx, ictx->old_cy, 0);\n}\n\n/* Initialise input parser. */\nstruct input_ctx *\ninput_init(struct window_pane *wp, struct bufferevent *bev)\n{\n\tstruct input_ctx\t*ictx;\n\n\tictx = xcalloc(1, sizeof *ictx);\n\tictx->wp = wp;\n\tictx->event = bev;\n\n\tictx->input_space = INPUT_BUF_START;\n\tictx->input_buf = xmalloc(INPUT_BUF_START);\n\n\tictx->since_ground = evbuffer_new();\n\tif (ictx->since_ground == NULL)\n\t\tfatalx(\"out of memory\");\n\n\tevtimer_set(&ictx->timer, input_timer_callback, ictx);\n\n\tinput_reset(ictx, 0);\n\treturn (ictx);\n}\n\n/* Destroy input parser. */\nvoid\ninput_free(struct input_ctx *ictx)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING)\n\t\t\tfree(ictx->param_list[i].str);\n\t}\n\n\tevent_del(&ictx->timer);\n\n\tfree(ictx->input_buf);\n\tevbuffer_free(ictx->since_ground);\n\n\tfree(ictx);\n}\n\n/* Reset input state and clear screen. */\nvoid\ninput_reset(struct input_ctx *ictx, int clear)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\n\tinput_reset_cell(ictx);\n\n\tif (clear && wp != NULL) {\n\t\tif (TAILQ_EMPTY(&wp->modes))\n\t\t\tscreen_write_start_pane(sctx, wp, &wp->base);\n\t\telse\n\t\t\tscreen_write_start(sctx, &wp->base);\n\t\tscreen_write_reset(sctx);\n\t\tscreen_write_stop(sctx);\n\t}\n\n\tinput_clear(ictx);\n\n\tictx->last = -1;\n\n\tictx->state = &input_state_ground;\n\tictx->flags = 0;\n}\n\n/* Return pending data. */\nstruct evbuffer *\ninput_pending(struct input_ctx *ictx)\n{\n\treturn (ictx->since_ground);\n}\n\n/* Change input state. */\nstatic void\ninput_set_state(struct input_ctx *ictx, const struct input_transition *itr)\n{\n\tif (ictx->state->exit != NULL)\n\t\tictx->state->exit(ictx);\n\tictx->state = itr->state;\n\tif (ictx->state->enter != NULL)\n\t\tictx->state->enter(ictx);\n}\n\n/* Parse data. */\nstatic void\ninput_parse(struct input_ctx *ictx, u_char *buf, size_t len)\n{\n\tstruct screen_write_ctx\t\t*sctx = &ictx->ctx;\n\tconst struct input_state\t*state = NULL;\n\tconst struct input_transition\t*itr = NULL;\n\tsize_t\t\t\t\t off = 0;\n\n\t/* Parse the input. */\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\n\t\t/* Find the transition. */\n\t\tif (ictx->state != state ||\n\t\t    itr == NULL ||\n\t\t    ictx->ch < itr->first ||\n\t\t    ictx->ch > itr->last) {\n\t\t\titr = ictx->state->transitions;\n\t\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\t\tif (ictx->ch >= itr->first &&\n\t\t\t\t    ictx->ch <= itr->last)\n\t\t\t\t\tbreak;\n\t\t\t\titr++;\n\t\t\t}\n\t\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\t\t/* No transition? Eh? */\n\t\t\t\tfatalx(\"no transition from state\");\n\t\t\t}\n\t\t}\n\t\tstate = ictx->state;\n\n\t\t/*\n\t\t * Any state except print stops the current collection. This is\n\t\t * an optimization to avoid checking if the attributes have\n\t\t * changed for every character. It will stop unnecessarily for\n\t\t * sequences that don't make a terminal change, but they should\n\t\t * be the minority.\n\t\t */\n\t\tif (itr->handler != input_print)\n\t\t\tscreen_write_collect_end(sctx);\n\n\t\t/*\n\t\t * Execute the handler, if any. Don't switch state if it\n\t\t * returns non-zero.\n\t\t */\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\n\t\t/* And switch state, if necessary. */\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(ictx, itr);\n\n\t\t/* If not in ground state, save input. */\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n}\n\n/* Parse input from pane. */\nvoid\ninput_parse_pane(struct window_pane *wp)\n{\n\tvoid\t*new_data;\n\tsize_t\t new_size;\n\n\tnew_data = window_pane_get_new_data(wp, &wp->offset, &new_size);\n\tinput_parse_buffer(wp, new_data, new_size);\n\twindow_pane_update_used_data(wp, &wp->offset, new_size);\n}\n\n/* Parse given input. */\nvoid\ninput_parse_buffer(struct window_pane *wp, u_char *buf, size_t len)\n{\n\tstruct input_ctx\t*ictx = wp->ictx;\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tif (len == 0)\n\t\treturn;\n\n\twindow_update_activity(wp->window);\n\twp->flags |= PANE_CHANGED;\n\n\t/* NULL wp if there is a mode set as don't want to update the tty. */\n\tif (TAILQ_EMPTY(&wp->modes))\n\t\tscreen_write_start_pane(sctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(sctx, &wp->base);\n\n\tlog_debug(\"%s: %%%u %s, %zu bytes: %.*s\", __func__, wp->id,\n\t    ictx->state->name, len, (int)len, buf);\n\n\tinput_parse(ictx, buf, len);\n\tscreen_write_stop(sctx);\n}\n\n/* Parse given input for screen. */\nvoid\ninput_parse_screen(struct input_ctx *ictx, struct screen *s,\n    screen_write_init_ctx_cb cb, void *arg, u_char *buf, size_t len)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\n\tif (len == 0)\n\t\treturn;\n\n\tscreen_write_start_callback(sctx, s, cb, arg);\n\tinput_parse(ictx, buf, len);\n\tscreen_write_stop(sctx);\n}\n\n/* Split the parameter list (if any). */\nstatic int\ninput_split(struct input_ctx *ictx)\n{\n\tconst char\t\t*errstr;\n\tchar\t\t\t*ptr, *out;\n\tstruct input_param\t*ip;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING)\n\t\t\tfree(ictx->param_list[i].str);\n\t}\n\tictx->param_list_len = 0;\n\n\tif (ictx->param_len == 0)\n\t\treturn (0);\n\tip = &ictx->param_list[0];\n\n\tptr = ictx->param_buf;\n\twhile ((out = strsep(&ptr, \";\")) != NULL) {\n\t\tif (*out == '\\0')\n\t\t\tip->type = INPUT_MISSING;\n\t\telse {\n\t\t\tif (strchr(out, ':') != NULL) {\n\t\t\t\tip->type = INPUT_STRING;\n\t\t\t\tip->str = xstrdup(out);\n\t\t\t} else {\n\t\t\t\tip->type = INPUT_NUMBER;\n\t\t\t\tip->num = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\t\tif (errstr != NULL)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t\tip = &ictx->param_list[++ictx->param_list_len];\n\t\tif (ictx->param_list_len == nitems(ictx->param_list))\n\t\t\treturn (-1);\n\t}\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tip = &ictx->param_list[i];\n\t\tif (ip->type == INPUT_MISSING)\n\t\t\tlog_debug(\"parameter %u: missing\", i);\n\t\telse if (ip->type == INPUT_STRING)\n\t\t\tlog_debug(\"parameter %u: string %s\", i, ip->str);\n\t\telse if (ip->type == INPUT_NUMBER)\n\t\t\tlog_debug(\"parameter %u: number %d\", i, ip->num);\n\t}\n\n\treturn (0);\n}\n\n/* Get an argument or return default value. */\nstatic int\ninput_get(struct input_ctx *ictx, u_int validx, int minval, int defval)\n{\n\tstruct input_param\t*ip;\n\tint\t\t\t retval;\n\n\tif (validx >= ictx->param_list_len)\n\t    return (defval);\n\tip = &ictx->param_list[validx];\n\tif (ip->type == INPUT_MISSING)\n\t\treturn (defval);\n\tif (ip->type == INPUT_STRING)\n\t\treturn (-1);\n\tretval = ip->num;\n\tif (retval < minval)\n\t\treturn (minval);\n\treturn (retval);\n}\n\n/* Reply to terminal query. */\nstatic void\ninput_reply(struct input_ctx *ictx, const char *fmt, ...)\n{\n\tstruct bufferevent\t*bev = ictx->event;\n\tva_list\t\t\t ap;\n\tchar\t\t\t*reply;\n\n\tva_start(ap, fmt);\n\txvasprintf(&reply, fmt, ap);\n\tva_end(ap);\n\n\tbufferevent_write(bev, reply, strlen(reply));\n\tfree(reply);\n}\n\n/* Clear saved state. */\nstatic void\ninput_clear(struct input_ctx *ictx)\n{\n\tevent_del(&ictx->timer);\n\n\t*ictx->interm_buf = '\\0';\n\tictx->interm_len = 0;\n\n\t*ictx->param_buf = '\\0';\n\tictx->param_len = 0;\n\n\t*ictx->input_buf = '\\0';\n\tictx->input_len = 0;\n\n\tictx->input_end = INPUT_END_ST;\n\n\tictx->flags &= ~INPUT_DISCARD;\n}\n\n/* Reset for ground state. */\nstatic void\ninput_ground(struct input_ctx *ictx)\n{\n\tevent_del(&ictx->timer);\n\tevbuffer_drain(ictx->since_ground, EVBUFFER_LENGTH(ictx->since_ground));\n\n\tif (ictx->input_space > INPUT_BUF_START) {\n\t\tictx->input_space = INPUT_BUF_START;\n\t\tictx->input_buf = xrealloc(ictx->input_buf, INPUT_BUF_START);\n\t}\n}\n\n/* Output this character to the screen. */\nstatic int\ninput_print(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tint\t\t\t set;\n\n\tictx->utf8started = 0; /* can't be valid UTF-8 */\n\n\tset = ictx->cell.set == 0 ? ictx->cell.g0set : ictx->cell.g1set;\n\tif (set == 1)\n\t\tictx->cell.cell.attr |= GRID_ATTR_CHARSET;\n\telse\n\t\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\n\tutf8_set(&ictx->cell.cell.data, ictx->ch);\n\tscreen_write_collect_add(sctx, &ictx->cell.cell);\n\tictx->last = ictx->ch;\n\n\tictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;\n\n\treturn (0);\n}\n\n/* Collect intermediate string. */\nstatic int\ninput_intermediate(struct input_ctx *ictx)\n{\n\tif (ictx->interm_len == (sizeof ictx->interm_buf) - 1)\n\t\tictx->flags |= INPUT_DISCARD;\n\telse {\n\t\tictx->interm_buf[ictx->interm_len++] = ictx->ch;\n\t\tictx->interm_buf[ictx->interm_len] = '\\0';\n\t}\n\n\treturn (0);\n}\n\n/* Collect parameter string. */\nstatic int\ninput_parameter(struct input_ctx *ictx)\n{\n\tif (ictx->param_len == (sizeof ictx->param_buf) - 1)\n\t\tictx->flags |= INPUT_DISCARD;\n\telse {\n\t\tictx->param_buf[ictx->param_len++] = ictx->ch;\n\t\tictx->param_buf[ictx->param_len] = '\\0';\n\t}\n\n\treturn (0);\n}\n\n/* Collect input string. */\nstatic int\ninput_input(struct input_ctx *ictx)\n{\n\tsize_t available;\n\n\tavailable = ictx->input_space;\n\twhile (ictx->input_len + 1 >= available) {\n\t\tavailable *= 2;\n\t\tif (available > INPUT_BUF_LIMIT) {\n\t\t\tictx->flags |= INPUT_DISCARD;\n\t\t\treturn (0);\n\t\t}\n\t\tictx->input_buf = xrealloc(ictx->input_buf, available);\n\t\tictx->input_space = available;\n\t}\n\tictx->input_buf[ictx->input_len++] = ictx->ch;\n\tictx->input_buf[ictx->input_len] = '\\0';\n\n\treturn (0);\n}\n\n/* Execute C0 control sequence. */\nstatic int\ninput_c0_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct screen\t\t*s = sctx->s;\n\n\tictx->utf8started = 0; /* can't be valid UTF-8 */\n\n\tlog_debug(\"%s: '%c'\", __func__, ictx->ch);\n\n\tswitch (ictx->ch) {\n\tcase '\\000':\t/* NUL */\n\t\tbreak;\n\tcase '\\007':\t/* BEL */\n\t\tif (wp != NULL)\n\t\t\talerts_queue(wp->window, WINDOW_BELL);\n\t\tbreak;\n\tcase '\\010':\t/* BS */\n\t\tscreen_write_backspace(sctx);\n\t\tbreak;\n\tcase '\\011':\t/* HT */\n\t\t/* Don't tab beyond the end of the line. */\n\t\tif (s->cx >= screen_size_x(s) - 1)\n\t\t\tbreak;\n\n\t\t/* Find the next tab point, or use the last column if none. */\n\t\tdo {\n\t\t\ts->cx++;\n\t\t\tif (bit_test(s->tabs, s->cx))\n\t\t\t\tbreak;\n\t\t} while (s->cx < screen_size_x(s) - 1);\n\t\tbreak;\n\tcase '\\012':\t/* LF */\n\tcase '\\013':\t/* VT */\n\tcase '\\014':\t/* FF */\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tif (s->mode & MODE_CRLF)\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\tbreak;\n\tcase '\\015':\t/* CR */\n\t\tscreen_write_carriagereturn(sctx);\n\t\tbreak;\n\tcase '\\016':\t/* SO */\n\t\tictx->cell.set = 1;\n\t\tbreak;\n\tcase '\\017':\t/* SI */\n\t\tictx->cell.set = 0;\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\tbreak;\n\t}\n\n\tictx->last = -1;\n\treturn (0);\n}\n\n/* Execute escape sequence. */\nstatic int\ninput_esc_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t\t*sctx = &ictx->ctx;\n\tstruct window_pane\t\t*wp = ictx->wp;\n\tstruct screen\t\t\t*s = sctx->s;\n\tstruct input_table_entry\t*entry;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\tlog_debug(\"%s: '%c', %s\", __func__, ictx->ch, ictx->interm_buf);\n\n\tentry = bsearch(ictx, input_esc_table, nitems(input_esc_table),\n\t    sizeof input_esc_table[0], input_table_compare);\n\tif (entry == NULL) {\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\treturn (0);\n\t}\n\n\tswitch (entry->type) {\n\tcase INPUT_ESC_RIS:\n\t\tif (wp != NULL)\n\t\t\twindow_pane_reset_palette(wp);\n\t\tinput_reset_cell(ictx);\n\t\tscreen_write_reset(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_IND:\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_NEL:\n\t\tscreen_write_carriagereturn(sctx);\n\t\tscreen_write_linefeed(sctx, 0, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_HTS:\n\t\tif (s->cx < screen_size_x(s))\n\t\t\tbit_set(s->tabs, s->cx);\n\t\tbreak;\n\tcase INPUT_ESC_RI:\n\t\tscreen_write_reverseindex(sctx, ictx->cell.cell.bg);\n\t\tbreak;\n\tcase INPUT_ESC_DECKPAM:\n\t\tscreen_write_mode_set(sctx, MODE_KKEYPAD);\n\t\tbreak;\n\tcase INPUT_ESC_DECKPNM:\n\t\tscreen_write_mode_clear(sctx, MODE_KKEYPAD);\n\t\tbreak;\n\tcase INPUT_ESC_DECSC:\n\t\tinput_save_state(ictx);\n\t\tbreak;\n\tcase INPUT_ESC_DECRC:\n\t\tinput_restore_state(ictx);\n\t\tbreak;\n\tcase INPUT_ESC_DECALN:\n\t\tscreen_write_alignmenttest(sctx);\n\t\tbreak;\n\tcase INPUT_ESC_SCSG0_ON:\n\t\tictx->cell.g0set = 1;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG0_OFF:\n\t\tictx->cell.g0set = 0;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG1_ON:\n\t\tictx->cell.g1set = 1;\n\t\tbreak;\n\tcase INPUT_ESC_SCSG1_OFF:\n\t\tictx->cell.g1set = 0;\n\t\tbreak;\n\tcase INPUT_ESC_ST:\n\t\t/* ST terminates OSC but the state transition already did it. */\n\t\tbreak;\n\t}\n\n\tictx->last = -1;\n\treturn (0);\n}\n\n/* Execute control sequence. */\nstatic int\ninput_csi_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t       *sctx = &ictx->ctx;\n\tstruct screen\t\t       *s = sctx->s;\n\tstruct input_table_entry       *entry;\n\tint\t\t\t\ti, n, m;\n\tu_int\t\t\t\tcx, bg = ictx->cell.cell.bg;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\n\tlog_debug(\"%s: '%c' \\\"%s\\\" \\\"%s\\\"\",\n\t    __func__, ictx->ch, ictx->interm_buf, ictx->param_buf);\n\n\tif (input_split(ictx) != 0)\n\t\treturn (0);\n\n\tentry = bsearch(ictx, input_csi_table, nitems(input_csi_table),\n\t    sizeof input_csi_table[0], input_table_compare);\n\tif (entry == NULL) {\n\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\treturn (0);\n\t}\n\n\tswitch (entry->type) {\n\tcase INPUT_CSI_CBT:\n\t\t/* Find the previous tab point, n times. */\n\t\tcx = s->cx;\n\t\tif (cx > screen_size_x(s) - 1)\n\t\t\tcx = screen_size_x(s) - 1;\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n == -1)\n\t\t\tbreak;\n\t\twhile (cx > 0 && n-- > 0) {\n\t\t\tdo\n\t\t\t\tcx--;\n\t\t\twhile (cx > 0 && !bit_test(s->tabs, cx));\n\t\t}\n\t\ts->cx = cx;\n\t\tbreak;\n\tcase INPUT_CSI_CUB:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorleft(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUD:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursordown(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUF:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorright(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CUP:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tm = input_get(ictx, 1, 1, 1);\n\t\tif (n != -1 && m != -1)\n\t\t\tscreen_write_cursormove(sctx, m - 1, n - 1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_MODSET:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tm = input_get(ictx, 1, 0, 0);\n\t\tif (n == 0 || (n == 4 && m == 0))\n\t\t\tscreen_write_mode_clear(sctx, MODE_KEXTENDED);\n\t\telse if (n == 4 && (m == 1 || m == 2))\n\t\t\tscreen_write_mode_set(sctx, MODE_KEXTENDED);\n\t\tbreak;\n\tcase INPUT_CSI_MODOFF:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n == 4)\n\t\t\tscreen_write_mode_clear(sctx, MODE_KEXTENDED);\n\t\tbreak;\n\tcase INPUT_CSI_WINOPS:\n\t\tinput_csi_dispatch_winops(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_CUU:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursorup(sctx, n);\n\t\tbreak;\n\tcase INPUT_CSI_CNL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1) {\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\t\tscreen_write_cursordown(sctx, n);\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_CPL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1) {\n\t\t\tscreen_write_carriagereturn(sctx);\n\t\t\tscreen_write_cursorup(sctx, n);\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_DA:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tinput_reply(ictx, \"\\033[?1;2c\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_DA_TWO:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tinput_reply(ictx, \"\\033[>84;0;0c\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_ECH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_clearcharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DCH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_deletecharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DECSTBM:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tm = input_get(ictx, 1, 1, screen_size_y(s));\n\t\tif (n != -1 && m != -1)\n\t\t\tscreen_write_scrollregion(sctx, n - 1, m - 1);\n\t\tbreak;\n\tcase INPUT_CSI_DL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_deleteline(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_DSR:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tinput_reply(ictx, \"\\033[0n\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tinput_reply(ictx, \"\\033[%u;%uR\", s->cy + 1, s->cx + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_ED:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tscreen_write_clearendofscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreen_write_clearstartofscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreen_write_clearscreen(sctx, bg);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (input_get(ictx, 1, 0, 0) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Linux console extension to clear history\n\t\t\t\t * (for example before locking the screen).\n\t\t\t\t */\n\t\t\t\tscreen_write_clearhistory(sctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_EL:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tscreen_write_clearendofline(sctx, bg);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tscreen_write_clearstartofline(sctx, bg);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tscreen_write_clearline(sctx, bg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_HPA:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursormove(sctx, n - 1, -1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_ICH:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_insertcharacter(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_IL:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_insertline(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_REP:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n == -1)\n\t\t\tbreak;\n\n\t\tif (ictx->last == -1)\n\t\t\tbreak;\n\t\tictx->ch = ictx->last;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tinput_print(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RCP:\n\t\tinput_restore_state(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RM:\n\t\tinput_csi_dispatch_rm(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_RM_PRIVATE:\n\t\tinput_csi_dispatch_rm_private(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SCP:\n\t\tinput_save_state(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SGR:\n\t\tinput_csi_dispatch_sgr(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM:\n\t\tinput_csi_dispatch_sm(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SM_PRIVATE:\n\t\tinput_csi_dispatch_sm_private(ictx);\n\t\tbreak;\n\tcase INPUT_CSI_SU:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_scrollup(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_SD:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_scrolldown(sctx, n, bg);\n\t\tbreak;\n\tcase INPUT_CSI_TBC:\n\t\tswitch (input_get(ictx, 0, 0, 0)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (s->cx < screen_size_x(s))\n\t\t\t\tbit_clear(s->tabs, s->cx);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_nclear(s->tabs, 0, screen_size_x(s) - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase INPUT_CSI_VPA:\n\t\tn = input_get(ictx, 0, 1, 1);\n\t\tif (n != -1)\n\t\t\tscreen_write_cursormove(sctx, -1, n - 1, 1);\n\t\tbreak;\n\tcase INPUT_CSI_DECSCUSR:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n != -1)\n\t\t\tscreen_set_cursor_style(s, n);\n\t\tbreak;\n\tcase INPUT_CSI_XDA:\n\t\tn = input_get(ictx, 0, 0, 0);\n\t\tif (n == 0)\n\t\t\tinput_reply(ictx, \"\\033P>|tmux %s\\033\\\\\", getversion());\n\t\tbreak;\n\n\t}\n\n\tictx->last = -1;\n\treturn (0);\n}\n\n/* Handle CSI RM. */\nstatic void\ninput_csi_dispatch_rm(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_set(sctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI private RM. */\nstatic void\ninput_csi_dispatch_rm_private(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 1:\t\t/* DECCKM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_KCURSOR);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* DECCOLM */\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tscreen_write_clearscreen(sctx, gc->bg);\n\t\t\tbreak;\n\t\tcase 6:\t\t/* DECOM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_ORIGIN);\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* DECAWM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_WRAP);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tscreen_write_mode_clear(sctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tcase 25:\t/* TCEM */\n\t\t\tscreen_write_mode_clear(sctx, MODE_CURSOR);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\tcase 1001:\n\t\tcase 1002:\n\t\tcase 1003:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tbreak;\n\t\tcase 1004:\n\t\t\tscreen_write_mode_clear(sctx, MODE_FOCUSON);\n\t\t\tbreak;\n\t\tcase 1005:\n\t\t\tscreen_write_mode_clear(sctx, MODE_MOUSE_UTF8);\n\t\t\tbreak;\n\t\tcase 1006:\n\t\t\tscreen_write_mode_clear(sctx, MODE_MOUSE_SGR);\n\t\t\tbreak;\n\t\tcase 47:\n\t\tcase 1047:\n\t\t\tscreen_write_alternateoff(sctx, gc, 0);\n\t\t\tbreak;\n\t\tcase 1049:\n\t\t\tscreen_write_alternateoff(sctx, gc, 1);\n\t\t\tbreak;\n\t\tcase 2004:\n\t\t\tscreen_write_mode_clear(sctx, MODE_BRACKETPASTE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI SM. */\nstatic void\ninput_csi_dispatch_sm(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 4:\t\t/* IRM */\n\t\t\tscreen_write_mode_set(sctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_clear(sctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI private SM. */\nstatic void\ninput_csi_dispatch_sm_private(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 1:\t\t/* DECCKM */\n\t\t\tscreen_write_mode_set(sctx, MODE_KCURSOR);\n\t\t\tbreak;\n\t\tcase 3:\t\t/* DECCOLM */\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tscreen_write_clearscreen(sctx, ictx->cell.cell.bg);\n\t\t\tbreak;\n\t\tcase 6:\t\t/* DECOM */\n\t\t\tscreen_write_mode_set(sctx, MODE_ORIGIN);\n\t\t\tscreen_write_cursormove(sctx, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase 7:\t\t/* DECAWM */\n\t\t\tscreen_write_mode_set(sctx, MODE_WRAP);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tscreen_write_mode_set(sctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tcase 25:\t/* TCEM */\n\t\t\tscreen_write_mode_set(sctx, MODE_CURSOR);\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_STANDARD);\n\t\t\tbreak;\n\t\tcase 1002:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_BUTTON);\n\t\t\tbreak;\n\t\tcase 1003:\n\t\t\tscreen_write_mode_clear(sctx, ALL_MOUSE_MODES);\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_ALL);\n\t\t\tbreak;\n\t\tcase 1004:\n\t\t\tif (sctx->s->mode & MODE_FOCUSON)\n\t\t\t\tbreak;\n\t\t\tscreen_write_mode_set(sctx, MODE_FOCUSON);\n\t\t\tif (wp != NULL)\n\t\t\t\twp->flags |= PANE_FOCUSPUSH; /* force update */\n\t\t\tbreak;\n\t\tcase 1005:\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_UTF8);\n\t\t\tbreak;\n\t\tcase 1006:\n\t\t\tscreen_write_mode_set(sctx, MODE_MOUSE_SGR);\n\t\t\tbreak;\n\t\tcase 47:\n\t\tcase 1047:\n\t\t\tscreen_write_alternateon(sctx, gc, 0);\n\t\t\tbreak;\n\t\tcase 1049:\n\t\t\tscreen_write_alternateon(sctx, gc, 1);\n\t\t\tbreak;\n\t\tcase 2004:\n\t\t\tscreen_write_mode_set(sctx, MODE_BRACKETPASTE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* Handle CSI window operations. */\nstatic void\ninput_csi_dispatch_winops(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct screen\t\t*s = sctx->s;\n\tstruct window_pane\t*wp = ictx->wp;\n\tu_int\t\t\t x = screen_size_x(s), y = screen_size_y(s);\n\tint\t\t\t n, m;\n\n\tm = 0;\n\twhile ((n = input_get(ictx, m, 0, -1)) != -1) {\n\t\tswitch (n) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 11:\n\t\tcase 13:\n\t\tcase 14:\n\t\tcase 19:\n\t\tcase 20:\n\t\tcase 21:\n\t\tcase 24:\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tm++;\n\t\t\tif (input_get(ictx, m, 0, -1) == -1)\n\t\t\t\treturn;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 9:\n\t\tcase 10:\n\t\t\tm++;\n\t\t\tif (input_get(ictx, m, 0, -1) == -1)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tm++;\n\t\t\tswitch (input_get(ictx, m, 0, -1)) {\n\t\t\tcase -1:\n\t\t\t\treturn;\n\t\t\tcase 0:\n\t\t\tcase 2:\n\t\t\t\tscreen_push_title(sctx->s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tm++;\n\t\t\tswitch (input_get(ictx, m, 0, -1)) {\n\t\t\tcase -1:\n\t\t\t\treturn;\n\t\t\tcase 0:\n\t\t\tcase 2:\n\t\t\t\tscreen_pop_title(sctx->s);\n\t\t\t\tif (wp != NULL) {\n\t\t\t\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\t\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\t\t\tserver_status_window(wp->window);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tinput_reply(ictx, \"\\033[8;%u;%ut\", x, y);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"%s: unknown '%c'\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t\tm++;\n\t}\n}\n\n/* Helper for 256 colour SGR. */\nstatic int\ninput_csi_dispatch_sgr_256_do(struct input_ctx *ictx, int fgbg, int c)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\n\tif (c == -1 || c > 255) {\n\t\tif (fgbg == 38)\n\t\t\tgc->fg = 8;\n\t\telse if (fgbg == 48)\n\t\t\tgc->bg = 8;\n\t} else {\n\t\tif (fgbg == 38)\n\t\t\tgc->fg = c | COLOUR_FLAG_256;\n\t\telse if (fgbg == 48)\n\t\t\tgc->bg = c | COLOUR_FLAG_256;\n\t\telse if (fgbg == 58)\n\t\t\tgc->us = c | COLOUR_FLAG_256;\n\t}\n\treturn (1);\n}\n\n/* Handle CSI SGR for 256 colours. */\nstatic void\ninput_csi_dispatch_sgr_256(struct input_ctx *ictx, int fgbg, u_int *i)\n{\n\tint\tc;\n\n\tc = input_get(ictx, (*i) + 1, 0, -1);\n\tif (input_csi_dispatch_sgr_256_do(ictx, fgbg, c))\n\t\t(*i)++;\n}\n\n/* Helper for RGB colour SGR. */\nstatic int\ninput_csi_dispatch_sgr_rgb_do(struct input_ctx *ictx, int fgbg, int r, int g,\n    int b)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\n\tif (r == -1 || r > 255)\n\t\treturn (0);\n\tif (g == -1 || g > 255)\n\t\treturn (0);\n\tif (b == -1 || b > 255)\n\t\treturn (0);\n\n\tif (fgbg == 38)\n\t\tgc->fg = colour_join_rgb(r, g, b);\n\telse if (fgbg == 48)\n\t\tgc->bg = colour_join_rgb(r, g, b);\n\telse if (fgbg == 58)\n\t\tgc->us = colour_join_rgb(r, g, b);\n\treturn (1);\n}\n\n/* Handle CSI SGR for RGB colours. */\nstatic void\ninput_csi_dispatch_sgr_rgb(struct input_ctx *ictx, int fgbg, u_int *i)\n{\n\tint\tr, g, b;\n\n\tr = input_get(ictx, (*i) + 1, 0, -1);\n\tg = input_get(ictx, (*i) + 2, 0, -1);\n\tb = input_get(ictx, (*i) + 3, 0, -1);\n\tif (input_csi_dispatch_sgr_rgb_do(ictx, fgbg, r, g, b))\n\t\t(*i) += 3;\n}\n\n/* Handle CSI SGR with a ISO parameter. */\nstatic void\ninput_csi_dispatch_sgr_colon(struct input_ctx *ictx, u_int i)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tchar\t\t\t*s = ictx->param_list[i].str, *copy, *ptr, *out;\n\tint\t\t\t p[8];\n\tu_int\t\t\t n;\n\tconst char\t\t*errstr;\n\n\tfor (n = 0; n < nitems(p); n++)\n\t\tp[n] = -1;\n\tn = 0;\n\n\tptr = copy = xstrdup(s);\n\twhile ((out = strsep(&ptr, \":\")) != NULL) {\n\t\tif (*out != '\\0') {\n\t\t\tp[n++] = strtonum(out, 0, INT_MAX, &errstr);\n\t\t\tif (errstr != NULL || n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tn++;\n\t\t\tif (n == nitems(p)) {\n\t\t\t\tfree(copy);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlog_debug(\"%s: %u = %d\", __func__, n - 1, p[n - 1]);\n\t}\n\tfree(copy);\n\n\tif (n == 0)\n\t\treturn;\n\tif (p[0] == 4) {\n\t\tif (n != 2)\n\t\t\treturn;\n\t\tswitch (p[1]) {\n\t\tcase 0:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE_5;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\tif (n < 2 || (p[0] != 38 && p[0] != 48 && p[0] != 58))\n\t\treturn;\n\tswitch (p[1]) {\n\tcase 2:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tif (n == 5)\n\t\t\ti = 2;\n\t\telse\n\t\t\ti = 3;\n\t\tif (n < i + 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_rgb_do(ictx, p[0], p[i], p[i + 1],\n\t\t    p[i + 2]);\n\t\tbreak;\n\tcase 5:\n\t\tif (n < 3)\n\t\t\tbreak;\n\t\tinput_csi_dispatch_sgr_256_do(ictx, p[0], p[2]);\n\t\tbreak;\n\t}\n}\n\n/* Handle CSI SGR. */\nstatic void\ninput_csi_dispatch_sgr(struct input_ctx *ictx)\n{\n\tstruct grid_cell\t*gc = &ictx->cell.cell;\n\tu_int\t\t\t i;\n\tint\t\t\t n;\n\n\tif (ictx->param_list_len == 0) {\n\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tif (ictx->param_list[i].type == INPUT_STRING) {\n\t\t\tinput_csi_dispatch_sgr_colon(ictx, i);\n\t\t\tcontinue;\n\t\t}\n\t\tn = input_get(ictx, i, 0, 0);\n\t\tif (n == -1)\n\t\t\tcontinue;\n\n\t\tif (n == 38 || n == 48 || n == 58) {\n\t\t\ti++;\n\t\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\t\tcase 2:\n\t\t\t\tinput_csi_dispatch_sgr_rgb(ictx, n, &i);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tinput_csi_dispatch_sgr_256(ictx, n, &i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (n) {\n\t\tcase 0:\n\t\t\tmemcpy(gc, &grid_default_cell, sizeof *gc);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgc->attr |= GRID_ATTR_BRIGHT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgc->attr |= GRID_ATTR_DIM;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgc->attr |= GRID_ATTR_ITALICS;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tgc->attr |= GRID_ATTR_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tgc->attr |= GRID_ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tgc->attr |= GRID_ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tgc->attr |= GRID_ATTR_HIDDEN;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tgc->attr |= GRID_ATTR_STRIKETHROUGH;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tgc->attr &= ~(GRID_ATTR_BRIGHT|GRID_ATTR_DIM);\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tgc->attr &= ~GRID_ATTR_ITALICS;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tgc->attr &= ~GRID_ATTR_ALL_UNDERSCORE;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\tgc->attr &= ~GRID_ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 27:\n\t\t\tgc->attr &= ~GRID_ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 28:\n\t\t\tgc->attr &= ~GRID_ATTR_HIDDEN;\n\t\t\tbreak;\n\t\tcase 29:\n\t\t\tgc->attr &= ~GRID_ATTR_STRIKETHROUGH;\n\t\t\tbreak;\n\t\tcase 30:\n\t\tcase 31:\n\t\tcase 32:\n\t\tcase 33:\n\t\tcase 34:\n\t\tcase 35:\n\t\tcase 36:\n\t\tcase 37:\n\t\t\tgc->fg = n - 30;\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tgc->fg = 8;\n\t\t\tbreak;\n\t\tcase 40:\n\t\tcase 41:\n\t\tcase 42:\n\t\tcase 43:\n\t\tcase 44:\n\t\tcase 45:\n\t\tcase 46:\n\t\tcase 47:\n\t\t\tgc->bg = n - 40;\n\t\t\tbreak;\n\t\tcase 49:\n\t\t\tgc->bg = 8;\n\t\t\tbreak;\n\t\tcase 53:\n\t\t\tgc->attr |= GRID_ATTR_OVERLINE;\n\t\t\tbreak;\n\t\tcase 55:\n\t\t\tgc->attr &= ~GRID_ATTR_OVERLINE;\n\t\t\tbreak;\n\t\tcase 59:\n\t\t\tgc->us = 0;\n\t\t\tbreak;\n\t\tcase 90:\n\t\tcase 91:\n\t\tcase 92:\n\t\tcase 93:\n\t\tcase 94:\n\t\tcase 95:\n\t\tcase 96:\n\t\tcase 97:\n\t\t\tgc->fg = n;\n\t\t\tbreak;\n\t\tcase 100:\n\t\tcase 101:\n\t\tcase 102:\n\t\tcase 103:\n\t\tcase 104:\n\t\tcase 105:\n\t\tcase 106:\n\t\tcase 107:\n\t\t\tgc->bg = n - 10;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* End of input with BEL. */\nstatic int\ninput_end_bel(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tictx->input_end = INPUT_END_BEL;\n\n\treturn (0);\n}\n\n/* DCS string started. */\nstatic void\ninput_enter_dcs(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->last = -1;\n}\n\n/* DCS terminator (ST) received. */\nstatic int\ninput_dcs_dispatch(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tu_char\t\t\t*buf = ictx->input_buf;\n\tsize_t\t\t\t len = ictx->input_len;\n\tconst char\t\t prefix[] = \"tmux;\";\n\tconst u_int\t\t prefixlen = (sizeof prefix) - 1;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn (0);\n\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, buf);\n\n\tif (len >= prefixlen && strncmp(buf, prefix, prefixlen) == 0)\n\t\tscreen_write_rawstring(sctx, buf + prefixlen, len - prefixlen);\n\n\treturn (0);\n}\n\n/* OSC string started. */\nstatic void\ninput_enter_osc(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->last = -1;\n}\n\n/* OSC terminator (ST) received. */\nstatic void\ninput_exit_osc(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\tu_char\t\t\t*p = ictx->input_buf;\n\tu_int\t\t\t option;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (ictx->input_len < 1 || *p < '0' || *p > '9')\n\t\treturn;\n\n\tlog_debug(\"%s: \\\"%s\\\" (end %s)\", __func__, p,\n\t    ictx->input_end == INPUT_END_ST ? \"ST\" : \"BEL\");\n\n\toption = 0;\n\twhile (*p >= '0' && *p <= '9')\n\t\toption = option * 10 + *p++ - '0';\n\tif (*p == ';')\n\t\tp++;\n\n\tswitch (option) {\n\tcase 0:\n\tcase 2:\n\t\tif (screen_set_title(sctx->s, p) && wp != NULL) {\n\t\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\tserver_status_window(wp->window);\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tinput_osc_4(ictx, p);\n\t\tbreak;\n\tcase 7:\n\t\tif (utf8_isvalid(p)) {\n\t\t\tscreen_set_path(sctx->s, p);\n\t\t\tif (wp != NULL) {\n\t\t\t\tserver_redraw_window_borders(wp->window);\n\t\t\t\tserver_status_window(wp->window);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tinput_osc_10(ictx, p);\n\t\tbreak;\n\tcase 11:\n\t\tinput_osc_11(ictx, p);\n\t\tbreak;\n\tcase 12:\n\t\tif (utf8_isvalid(p) && *p != '?') /* ? is colour request */\n\t\t\tscreen_set_cursor_colour(sctx->s, p);\n\t\tbreak;\n\tcase 52:\n\t\tinput_osc_52(ictx, p);\n\t\tbreak;\n\tcase 104:\n\t\tinput_osc_104(ictx, p);\n\t\tbreak;\n\tcase 112:\n\t\tif (*p == '\\0') /* no arguments allowed */\n\t\t\tscreen_set_cursor_colour(sctx->s, \"\");\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%u'\", __func__, option);\n\t\tbreak;\n\t}\n}\n\n/* APC string started. */\nstatic void\ninput_enter_apc(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->last = -1;\n}\n\n/* APC terminator (ST) received. */\nstatic void\ninput_exit_apc(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct window_pane\t*wp = ictx->wp;\n\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\tif (screen_set_title(sctx->s, ictx->input_buf) && wp != NULL) {\n\t\tnotify_pane(\"pane-title-changed\", wp);\n\t\tserver_redraw_window_borders(wp->window);\n\t\tserver_status_window(wp->window);\n\t}\n}\n\n/* Rename string started. */\nstatic void\ninput_enter_rename(struct input_ctx *ictx)\n{\n\tlog_debug(\"%s\", __func__);\n\n\tinput_clear(ictx);\n\tinput_start_timer(ictx);\n\tictx->last = -1;\n}\n\n/* Rename terminator (ST) received. */\nstatic void\ninput_exit_rename(struct input_ctx *ictx)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct options_entry\t*o;\n\n\tif (wp == NULL)\n\t\treturn;\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (!options_get_number(ictx->wp->options, \"allow-rename\"))\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, ictx->input_buf);\n\n\tif (!utf8_isvalid(ictx->input_buf))\n\t\treturn;\n\n\tif (ictx->input_len == 0) {\n\t\to = options_get_only(wp->window->options, \"automatic-rename\");\n\t\tif (o != NULL)\n\t\t\toptions_remove_or_default(o, -1, NULL);\n\t\treturn;\n\t}\n\twindow_set_name(wp->window, ictx->input_buf);\n\toptions_set_number(wp->window->options, \"automatic-rename\", 0);\n\tserver_redraw_window_borders(wp->window);\n\tserver_status_window(wp->window);\n}\n\n/* Open UTF-8 character. */\nstatic int\ninput_top_bit_set(struct input_ctx *ictx)\n{\n\tstruct screen_write_ctx\t*sctx = &ictx->ctx;\n\tstruct utf8_data\t*ud = &ictx->utf8data;\n\n\tictx->last = -1;\n\n\tif (!ictx->utf8started) {\n\t\tif (utf8_open(ud, ictx->ch) != UTF8_MORE)\n\t\t\treturn (0);\n\t\tictx->utf8started = 1;\n\t\treturn (0);\n\t}\n\n\tswitch (utf8_append(ud, ictx->ch)) {\n\tcase UTF8_MORE:\n\t\treturn (0);\n\tcase UTF8_ERROR:\n\t\tictx->utf8started = 0;\n\t\treturn (0);\n\tcase UTF8_DONE:\n\t\tbreak;\n\t}\n\tictx->utf8started = 0;\n\n\tlog_debug(\"%s %hhu '%*s' (width %hhu)\", __func__, ud->size,\n\t    (int)ud->size, ud->data, ud->width);\n\n\tutf8_copy(&ictx->cell.cell.data, ud);\n\tscreen_write_collect_add(sctx, &ictx->cell.cell);\n\n\treturn (0);\n}\n\n/* Parse colour from OSC. */\nstatic int\ninput_osc_parse_colour(const char *p, u_int *r, u_int *g, u_int *b)\n{\n\tu_int\t\t rsize, gsize, bsize;\n\tconst char\t*cp, *s = p;\n\n\tif (sscanf(p, \"rgb:%x/%x/%x\", r, g, b) != 3)\n\t\treturn (0);\n\tp += 4;\n\n\tcp = strchr(p, '/');\n\trsize = cp - p;\n\tif (rsize == 1)\n\t\t(*r) = (*r) | ((*r) << 4);\n\telse if (rsize == 3)\n\t\t(*r) >>= 4;\n\telse if (rsize == 4)\n\t\t(*r) >>= 8;\n\telse if (rsize != 2)\n\t\treturn (0);\n\n\tp = cp + 1;\n\tcp = strchr(p, '/');\n\tgsize = cp - p;\n\tif (gsize == 1)\n\t\t(*g) = (*g) | ((*g) << 4);\n\telse if (gsize == 3)\n\t\t(*g) >>= 4;\n\telse if (gsize == 4)\n\t\t(*g) >>= 8;\n\telse if (gsize != 2)\n\t\treturn (0);\n\n\tbsize = strlen(cp + 1);\n\tif (bsize == 1)\n\t\t(*b) = (*b) | ((*b) << 4);\n\telse if (bsize == 3)\n\t\t(*b) >>= 4;\n\telse if (bsize == 4)\n\t\t(*b) >>= 8;\n\telse if (bsize != 2)\n\t\treturn (0);\n\n\tlog_debug(\"%s: %s = %02x%02x%02x\", __func__, s, *r, *g, *b);\n\treturn (1);\n}\n\n/* Reply to a colour request. */\nstatic void\ninput_osc_colour_reply(struct input_ctx *ictx, u_int n, int c)\n{\n    u_char\t r, g, b;\n    const char\t*end;\n\n    if (c == 8 || (~c & COLOUR_FLAG_RGB))\n\t    return;\n    colour_split_rgb(c, &r, &g, &b);\n\n    if (ictx->input_end == INPUT_END_BEL)\n\t    end = \"\\007\";\n    else\n\t    end = \"\\033\\\\\";\n    input_reply(ictx, \"\\033]%u;rgb:%02hhx/%02hhx/%02hhx%s\", n, r, g, b, end);\n}\n\n/* Handle the OSC 4 sequence for setting (multiple) palette entries. */\nstatic void\ninput_osc_4(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tchar\t\t\t*copy, *s, *next = NULL;\n\tlong\t\t\t idx;\n\tu_int\t\t\t r, g, b;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tcopy = s = xstrdup(p);\n\twhile (s != NULL && *s != '\\0') {\n\t\tidx = strtol(s, &next, 10);\n\t\tif (*next++ != ';')\n\t\t\tgoto bad;\n\t\tif (idx < 0 || idx >= 0x100)\n\t\t\tgoto bad;\n\n\t\ts = strsep(&next, \";\");\n\t\tif (!input_osc_parse_colour(s, &r, &g, &b)) {\n\t\t\ts = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\twindow_pane_set_palette(wp, idx, colour_join_rgb(r, g, b));\n\t\ts = next;\n\t}\n\n\tfree(copy);\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 4: %s\", p);\n\tfree(copy);\n}\n\n/* Handle the OSC 10 sequence for setting and querying foreground colour. */\nstatic void\ninput_osc_10(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct grid_cell\t defaults;\n\tu_int\t\t\t r, g, b;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tif (strcmp(p, \"?\") == 0) {\n\t\ttty_default_colours(&defaults, wp);\n\t\tinput_osc_colour_reply(ictx, 10, defaults.fg);\n\t\treturn;\n\t}\n\n\tif (!input_osc_parse_colour(p, &r, &g, &b))\n\t\tgoto bad;\n\twp->fg = colour_join_rgb(r, g, b);\n\twp->flags |= (PANE_REDRAW|PANE_STYLECHANGED);\n\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 10: %s\", p);\n}\n\n/* Handle the OSC 11 sequence for setting and querying background colour. */\nstatic void\ninput_osc_11(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tstruct grid_cell\t defaults;\n\tu_int\t\t\t r, g, b;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tif (strcmp(p, \"?\") == 0) {\n\t\ttty_default_colours(&defaults, wp);\n\t\tinput_osc_colour_reply(ictx, 11, defaults.bg);\n\t\treturn;\n\t}\n\n\tif (!input_osc_parse_colour(p, &r, &g, &b))\n\t    goto bad;\n\twp->bg = colour_join_rgb(r, g, b);\n\twp->flags |= (PANE_REDRAW|PANE_STYLECHANGED);\n\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 11: %s\", p);\n}\n\n/* Handle the OSC 52 sequence for setting the clipboard. */\nstatic void\ninput_osc_52(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tchar\t\t\t*end;\n\tconst char\t\t*buf;\n\tsize_t\t\t\t len;\n\tu_char\t\t\t*out;\n\tint\t\t\t outlen, state;\n\tstruct screen_write_ctx\t ctx;\n\tstruct paste_buffer\t*pb;\n\n\tif (wp == NULL)\n\t\treturn;\n\tstate = options_get_number(global_options, \"set-clipboard\");\n\tif (state != 2)\n\t\treturn;\n\n\tif ((end = strchr(p, ';')) == NULL)\n\t\treturn;\n\tend++;\n\tif (*end == '\\0')\n\t\treturn;\n\tlog_debug(\"%s: %s\", __func__, end);\n\n\tif (strcmp(end, \"?\") == 0) {\n\t\tif ((pb = paste_get_top(NULL)) != NULL) {\n\t\t\tbuf = paste_buffer_data(pb, &len);\n\t\t\toutlen = 4 * ((len + 2) / 3) + 1;\n\t\t\tout = xmalloc(outlen);\n\t\t\tif ((outlen = b64_ntop(buf, len, out, outlen)) == -1) {\n\t\t\t\tfree(out);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\toutlen = 0;\n\t\t\tout = NULL;\n\t\t}\n\t\tbufferevent_write(ictx->event, \"\\033]52;;\", 6);\n\t\tif (outlen != 0)\n\t\t\tbufferevent_write(ictx->event, out, outlen);\n\t\tif (ictx->input_end == INPUT_END_BEL)\n\t\t\tbufferevent_write(ictx->event, \"\\007\", 1);\n\t\telse\n\t\t\tbufferevent_write(ictx->event, \"\\033\\\\\", 2);\n\t\tfree(out);\n\t\treturn;\n\t}\n\n\tlen = (strlen(end) / 4) * 3;\n\tif (len == 0)\n\t\treturn;\n\n\tout = xmalloc(len);\n\tif ((outlen = b64_pton(end, out, len)) == -1) {\n\t\tfree(out);\n\t\treturn;\n\t}\n\n\tscreen_write_start_pane(&ctx, wp, NULL);\n\tscreen_write_setselection(&ctx, out, outlen);\n\tscreen_write_stop(&ctx);\n\tnotify_pane(\"pane-set-clipboard\", wp);\n\n\tpaste_add(NULL, out, outlen);\n}\n\n/* Handle the OSC 104 sequence for unsetting (multiple) palette entries. */\nstatic void\ninput_osc_104(struct input_ctx *ictx, const char *p)\n{\n\tstruct window_pane\t*wp = ictx->wp;\n\tchar\t\t\t*copy, *s;\n\tlong\t\t\t idx;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tif (*p == '\\0') {\n\t\twindow_pane_reset_palette(wp);\n\t\treturn;\n\t}\n\n\tcopy = s = xstrdup(p);\n\twhile (*s != '\\0') {\n\t\tidx = strtol(s, &s, 10);\n\t\tif (*s != '\\0' && *s != ';')\n\t\t\tgoto bad;\n\t\tif (idx < 0 || idx >= 0x100)\n\t\t\tgoto bad;\n\n\t\twindow_pane_unset_palette(wp, idx);\n\t\tif (*s == ';')\n\t\t\ts++;\n\t}\n\tfree(copy);\n\treturn;\n\nbad:\n\tlog_debug(\"bad OSC 104: %s\", p);\n\tfree(copy);\n}\n"], "filenames": ["input.c"], "buggy_code_start_loc": [1979], "buggy_code_end_loc": [1980], "fixing_code_start_loc": [1979], "fixing_code_end_loc": [1986], "type": "CWE-787", "message": "In tmux before version 3.1c the function input_csi_dispatch_sgr_colon() in file input.c contained a stack-based buffer-overflow that can be exploited by terminal output.", "other": {"cve": {"id": "CVE-2020-27347", "sourceIdentifier": "security@ubuntu.com", "published": "2020-11-06T03:15:17.137", "lastModified": "2022-10-18T20:05:59.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In tmux before version 3.1c the function input_csi_dispatch_sgr_colon() in file input.c contained a stack-based buffer-overflow that can be exploited by terminal output."}, {"lang": "es", "value": "En tmux anterior a la versi\u00f3n 3.1c la funci\u00f3n input_csi_dispatch_sgr_colon() en el archivo input.c conten\u00eda un desbordamiento de b\u00fafer en la regi\u00f3n stack de la memoria que puede ser explotado mediante la salida del terminal"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security@ubuntu.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@ubuntu.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tmux_project:tmux:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9", "versionEndIncluding": "3.1b", "matchCriteriaId": "604BA314-EFDC-4F3A-9C98-8A9119D57196"}]}]}], "references": [{"url": "https://github.com/tmux/tmux/commit/a868bacb46e3c900530bed47a1c6f85b0fbe701c", "source": "security@ubuntu.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://raw.githubusercontent.com/tmux/tmux/3.1c/CHANGES", "source": "security@ubuntu.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202011-10", "source": "security@ubuntu.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2020/11/05/3", "source": "security@ubuntu.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tmux/tmux/commit/a868bacb46e3c900530bed47a1c6f85b0fbe701c"}}