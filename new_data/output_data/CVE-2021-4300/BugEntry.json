{"buggy_code": ["// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include \"alert.h\"\n#include \"checkpoints.h\"\n#include \"db.h\"\n#include \"txdb.h\"\n#include \"net.h\"\n#include \"init.h\"\n#include \"ui_interface.h\"\n#include \"kernel.h\"\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/fstream.hpp>\n\n\nusing namespace std;\nusing namespace boost;\n\n//\n// Global state\n//\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nCCriticalSection cs_main;\n\nCTxMemPool mempool;\nunsigned int nTransactionsUpdated = 0;\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\n\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\n\n/* The PoW difficulty after switching to NeoScrypt (0.25) */\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\n\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\n/* Positive time weight after 12 hours for livenet */\nuint nStakeMinAge = 60 * 60 * 12;\n/* That's a bug: -60 * 60 * 24 * 7 */\nuint nStakeMaxAgeOne = 4294362496;\n/* The time weight limit is 7 days after the min. age for livenet */\nuint nStakeMaxAgeTwo = 7 * 24 * 60 * 60;\n/* Interval of 10 minutes between stake modifiers for livenet */\nuint nModifierInterval = 10 * 60;\n\n/* Try to combine inputs while staking up to this limit */\nint64_t nCombineThreshold = 100 * COIN;\n/* Don't split outputs while staking below this limit */\nint64_t nSplitThreshold = 200 * COIN;\n\n/* The base time unit is 30 seconds */\nconst uint nBaseTargetSpacing = 30;\n\nint nCoinbaseMaturity = 50;\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\n\nuint256 nBestChainTrust = 0;\nuint256 nBestInvalidTrust = 0;\n\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64_t nTimeBestReceived = 0;\n\nCMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\nset<pair<COutPoint, unsigned int> > setStakeSeenOrphan;\n\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n\n// Constant stuff for coinbase transactions we create:\nCScript COINBASE_FLAGS;\n\nconst string strMessageMagic = \"Halcyon Signed Message:\\n\";\n\n// Settings\nint64_t nTransactionFee = MIN_TX_FEE;\nint64_t nReserveBalance = 0;\nint64_t nMinimumInputValue = 0;\n\nextern enum Checkpoints::CPMode CheckpointsMode;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// dispatching functions\n//\n\n// These functions dispatch to one or all registered wallets\n\n\nvoid RegisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}\n\nvoid UnregisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}\n\n// check whether the passed transaction is from us\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}\n\n// get the wallet transaction with the given hash (if it exists)\nbool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}\n\n// erases transaction with the given hash from all wallets\nvoid static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}\n\n// make sure all wallets know about the given transaction, in the given block\nvoid SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fConnect)\n{\n    if (!fConnect)\n    {\n        // ppcoin: wallets need to refund inputs when disconnecting coinstake\n        if (tx.IsCoinStake())\n        {\n            BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n                if (pwallet->IsFromMe(tx))\n                    pwallet->DisableTransaction(tx);\n        }\n        return;\n    }\n\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}\n\n// notify wallets about a new best chain\nvoid static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}\n\n// notify wallets about an updated transaction\nvoid static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}\n\n// dump all wallets\nvoid static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}\n\n// notify wallets about an incoming inventory (for request counts)\nvoid static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}\n\n// ask wallets to resend their transactions\nvoid ResendWalletTransactions(bool fForce)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions(fForce);\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// mapOrphanTransactions\n//\n\nbool AddOrphanTx(const CTransaction& tx)\n{\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return false;\n\n    // Ignore big transactions, to avoid a\n    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n    // large transaction with a missing parent then we assume\n    // it will rebroadcast it later, after the parent transaction(s)\n    // have been mined or received.\n    // 10,000 orphans, each of which is at most 5,000 bytes big is\n    // at most 500 megabytes of orphans:\n\n    size_t nSize = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n\n    if (nSize > 5000)\n    {\n        printf(\"ignoring large orphan tx (size: %\"PRIszu\", hash: %s)\\n\", nSize, hash.ToString().substr(0,10).c_str());\n        return false;\n    }\n\n    mapOrphanTransactions[hash] = tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n\n    printf(\"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString().substr(0,10).c_str(),\n        mapOrphanTransactions.size());\n    return true;\n}\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CTransaction& tx = mapOrphanTransactions[hash];\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    mapOrphanTransactions.erase(hash);\n}\n\nunsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n{\n    unsigned int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        uint256 randomhash = GetRandHash();\n        map<uint256, CTransaction>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CTransaction and CTxIndex\n//\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n{\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::IsStandard() const\n{\n    if (nVersion > CTransaction::CURRENT_VERSION)\n        return false;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n        // ~65-byte public keys, plus a few script ops.\n        if (txin.scriptSig.size() > 500)\n            return false;\n        if (!txin.scriptSig.IsPushOnly())\n            return false;\n        if (fEnforceCanonical && !txin.scriptSig.HasCanonicalPushes()) {\n            return false;\n        }\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout) {\n        if (!::IsStandard(txout.scriptPubKey))\n            return false;\n        if (txout.nValue == 0)\n            return false;\n        if (fEnforceCanonical && !txout.scriptPubKey.HasCanonicalPushes()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//\n// Check transaction inputs, and make sure any\n// pay-to-script-hash transactions are evaluating IsStandard scripts\n//\n// Why bother? To avoid denial-of-service attacks; an attacker\n// can submit a standard HASH... OP_EQUAL transaction,\n// which will get accepted into blocks. The redemption\n// script can be anything; an attacker could use a very\n// expensive-to-check-upon-redemption script like:\n//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n//\nbool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n{\n    if (IsCoinBase())\n        return true; // Coinbases don't use vin normally\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n\n        vector<vector<unsigned char> > vSolutions;\n        txnouttype whichType;\n        // get the scriptPubKey corresponding to this input:\n        const CScript& prevScript = prev.scriptPubKey;\n        if (!Solver(prevScript, whichType, vSolutions))\n            return false;\n        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n        if (nArgsExpected < 0)\n            return false;\n\n        // Transactions with extra stuff in their scriptSigs are\n        // non-standard. Note that this EvalScript() call will\n        // be quick, because if there are any operations\n        // beside \"push data\" in the scriptSig the\n        // IsStandard() call returns false\n        vector<vector<unsigned char> > stack;\n        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n            return false;\n\n        if (whichType == TX_SCRIPTHASH)\n        {\n            if (stack.empty())\n                return false;\n            CScript subscript(stack.back().begin(), stack.back().end());\n            vector<vector<unsigned char> > vSolutions2;\n            txnouttype whichType2;\n            if (!Solver(subscript, whichType2, vSolutions2))\n                return false;\n            if (whichType2 == TX_SCRIPTHASH)\n                return false;\n\n            int tmpExpected;\n            tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n            if (tmpExpected < 0)\n                return false;\n            nArgsExpected += tmpExpected;\n        }\n\n        if (stack.size() != (unsigned int)nArgsExpected)\n            return false;\n    }\n\n    return true;\n}\n\nunsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}\n\n\nint CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n{\n    if (fClient)\n    {\n        if (hashBlock == 0)\n            return 0;\n    }\n    else\n    {\n        CBlock blockTmp;\n        if (pblock == NULL)\n        {\n            // Load the block this tx is in\n            CTxIndex txindex;\n            if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                return 0;\n            if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n                return 0;\n            pblock = &blockTmp;\n        }\n\n        // Update the tx's hashBlock\n        hashBlock = pblock->GetHash();\n\n        // Locate the transaction\n        for (nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)\n            if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                break;\n        if (nIndex == (int)pblock->vtx.size())\n        {\n            vMerkleBranch.clear();\n            nIndex = -1;\n            printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n            return 0;\n        }\n\n        // Fill in merkle branch\n        vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n    }\n\n    // Is the tx in a block that's in the main chain\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}\n\n\n\n\n\n\n\nbool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}\n\nint64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const\n{\n    // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n    int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n\n    unsigned int nNewBlockSize = nBlockSize + nBytes;\n    int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n\n    // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01\n    if (nMinFee < nBaseFee)\n    {\n        BOOST_FOREACH(const CTxOut& txout, vout)\n            if (txout.nValue < CENT)\n                nMinFee = nBaseFee;\n    }\n\n    // Raise the price as the block approaches full\n    if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n    {\n        if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n            return MAX_MONEY;\n        nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n    }\n\n    if (!MoneyRange(nMinFee))\n        nMinFee = MAX_MONEY;\n    return nMinFee;\n}\n\n\nbool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                        bool* pfMissingInputs)\n{\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!tx.CheckTransaction())\n        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (tx.IsCoinBase())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n\n    // ppcoin: coinstake is also only valid in a block, not as a loose transaction\n    if (tx.IsCoinStake())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinstake as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64_t)tx.nLockTime > std::numeric_limits<int>::max())\n        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !tx.IsStandard())\n        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs);\n        if (mapTx.count(hash))\n            return false;\n    }\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (unsigned int i = 0; i < tx.vin.size(); i++)\n    {\n        COutPoint outpoint = tx.vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!tx.IsNewerThan(*ptxOld))\n                return false;\n            for (unsigned int i = 0; i < tx.vin.size(); i++)\n            {\n                COutPoint outpoint = tx.vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return false;\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64_t nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n        // Don't accept it if it can't get into a block\n        int64_t txMinFee = tx.GetMinFee(1000, GMF_RELAY, nSize);\n        if (nFees < txMinFee)\n            return error(\"CTxMemPool::accept() : not enough fees %s, %\"PRId64\" < %\"PRId64,\n                         hash.ToString().c_str(),\n                         nFees, txMinFee);\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make others' transactions take longer to confirm.\n        if (nFees < MIN_RELAY_TX_FEE)\n        {\n            static CCriticalSection cs;\n            static double dFreeCount;\n            static int64_t nLastTime;\n            int64_t nNow = GetTime();\n\n            {\n                LOCK(cs);\n                // Use an exponentially decaying ~10-minute window:\n                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                nLastTime = nNow;\n                // -limitfreerelay unit is thousand-bytes-per-minute\n                // At default rate it would take over a month to fill 1GB\n                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                if (fDebug)\n                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                dFreeCount += nSize;\n            }\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!tx.ConnectInputs(txdb, mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    {\n        LOCK(cs);\n        if (ptxOld)\n        {\n            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            remove(*ptxOld);\n        }\n        addUnchecked(hash, tx);\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"CTxMemPool::accept() : accepted %s (poolsz %\"PRIszu\")\\n\",\n           hash.ToString().substr(0,10).c_str(),\n           mapTx.size());\n    return true;\n}\n\nbool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}\n\nbool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n{\n    // Add to memory pool without checking anything.  Don't call this directly,\n    // call CTxMemPool::accept to properly check the transaction first.\n    {\n        mapTx[hash] = tx;\n        for (unsigned int i = 0; i < tx.vin.size(); i++)\n            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n        nTransactionsUpdated++;\n    }\n    return true;\n}\n\n\nbool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n{\n    // Remove transaction from memory pool\n    {\n        LOCK(cs);\n        uint256 hash = tx.GetHash();\n        if (mapTx.count(hash))\n        {\n            if (fRecursive) {\n                for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                    if (it != mapNextTx.end())\n                        remove(*it->second.ptx, true);\n                }\n            }\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                mapNextTx.erase(txin.prevout);\n            mapTx.erase(hash);\n            nTransactionsUpdated++;\n        }\n    }\n    return true;\n}\n\nbool CTxMemPool::removeConflicts(const CTransaction &tx)\n{\n    // Remove transactions which depend on inputs of tx, recursively\n    LOCK(cs);\n    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n        if (it != mapNextTx.end()) {\n            const CTransaction &txConflict = *it->second.ptx;\n            if (txConflict != tx)\n                remove(txConflict, true);\n        }\n    }\n    return true;\n}\n\nvoid CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}\n\nvoid CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n{\n    vtxid.clear();\n\n    LOCK(cs);\n    vtxid.reserve(mapTx.size());\n    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n        vtxid.push_back((*mi).first);\n}\n\n\n/* Returns a transaction depth in the main chain or\n *  0 = in the memory pool, not yet in the main chain\n * -1 = failed transaction */\nint CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const {\n    bool fTxMempool = mempool.exists(GetHash());\n\n    if((hashBlock == 0) || (nIndex == -1))\n      return(fTxMempool ? 0 : -1);\n\n    // Find the block it claims to be in\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if(mi == mapBlockIndex.end())\n      return(fTxMempool ? 0 : -1);\n\n    CBlockIndex* pindex = (*mi).second;\n    if(!pindex || !pindex->IsInMainChain())\n      return(fTxMempool ? 0 : -1);\n\n    // Make sure the merkle branch connects to this block\n    if(!fMerkleVerified) {\n        if(CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n          return(fTxMempool ? 0 : -1);\n        fMerkleVerified = true;\n    }\n\n    pindexRet = pindex;\n    return(pindexBest->nHeight - pindex->nHeight + 1);\n}\n\n\nint CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!(IsCoinBase() || IsCoinStake()))\n        return 0;\n    return max(0, (nCoinbaseMaturity+10) - GetDepthInMainChain());\n}\n\n\nbool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n{\n    if (fClient)\n    {\n        if (!IsInMainChain() && !ClientConnectInputs())\n            return false;\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    else\n    {\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n}\n\nbool CMerkleTx::AcceptToMemoryPool()\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb);\n}\n\n\n\nbool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n\n    {\n        LOCK(mempool.cs);\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}\n\nbool CWalletTx::AcceptWalletTransaction()\n{\n    CTxDB txdb(\"r\");\n    return AcceptWalletTransaction(txdb);\n}\n\nint CTxIndex::GetDepthInMainChain() const\n{\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n        return 0;\n    // Find the block in the index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n    return 1 + nBestHeight - pindex->nHeight;\n}\n\n// Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CBlock and CBlockIndex\n//\n\nstatic CBlockIndex* pblockindexFBBHLast;\nCBlockIndex* FindBlockByHeight(int nHeight)\n{\n    CBlockIndex *pblockindex;\n    if (nHeight < nBestHeight / 2)\n        pblockindex = pindexGenesisBlock;\n    else\n        pblockindex = pindexBest;\n    if (pblockindexFBBHLast && abs(nHeight - pblockindex->nHeight) > abs(nHeight - pblockindexFBBHLast->nHeight))\n        pblockindex = pblockindexFBBHLast;\n    while (pblockindex->nHeight > nHeight)\n        pblockindex = pblockindex->pprev;\n    while (pblockindex->nHeight < nHeight)\n        pblockindex = pblockindex->pnext;\n    pblockindexFBBHLast = pblockindex;\n    return pblockindex;\n}\n\nbool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n{\n    if (!fReadTransactions)\n    {\n        *this = pindex->GetBlockHeader();\n        return true;\n    }\n    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n        return false;\n    if (GetHash() != pindex->GetBlockHash())\n        return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n    return true;\n}\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}\n\n// ppcoin: find block wanted by given orphan block\nuint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}\n\nint64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}\n\nint64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}\n\n// ppcoin: find last block index up to pindex\nconst CBlockIndex* GetLastBlockIndex(const CBlockIndex* pindex, bool fProofOfStake)\n{\n    while (pindex && pindex->pprev && (pindex->IsProofOfStake() != fProofOfStake))\n        pindex = pindex->pprev;\n    return pindex;\n}\n\nuint GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake,\n  bool fPrettyPrint) {\n    CBigNum bnTargetLimit, bnNew;\n\n    /* Separate range limits */\n    if(fTestNet) {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimitTestNet;\n        else bnTargetLimit = bnProofOfWorkLimitTestNet;\n    } else {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimit;\n        else bnTargetLimit = bnProofOfWorkLimit;\n    }\n\n    /* The genesis block */\n    if(pindexLast == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);\n    /* The 1st block */\n    if(pindexPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev->pprev, fProofOfStake);\n    /* The 2nd block */\n    if(pindexPrevPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    /* The next block */\n    int nHeight = pindexLast->nHeight + 1;\n\n    if(!fTestNet && (nHeight < nForkOne)) {\n\n        /* Legacy every block retargets of the PPC style */\n\n        int64 nTargetTimespan = 20 * 60;\n        int64 nTargetSpacing = 2 * nBaseTargetSpacing;\n        int64 nInterval, nActualSpacing;\n\n        nActualSpacing = (int64)pindexPrev->nTime - (int64)pindexPrevPrev->nTime;\n        if(nActualSpacing < 0)\n          nActualSpacing = nTargetSpacing;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: pindexLast = %d, pindexPrev = %d, pindexPrevPrev = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexPrevPrev->nHeight);\n            printf(\"RETARGET time stamps: pindexLast = %u, pindexPrev = %u, pindexPrevPrev = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexPrevPrev->nTime);\n        }\n\n        nInterval = nTargetTimespan / nTargetSpacing;\n\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);\n        bnNew /= ((nInterval + 1) * nTargetSpacing);\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nTargetSpacing = %\"PRI64d\", \"\n            \"nInterval = %\"PRI64d\"\\n\", nTargetTimespan, nTargetSpacing, nInterval);\n\n    } else {\n\n        if(!fTestNet) {\n            /* The hard fork to NeoScrypt */\n            if(!fNeoScrypt) fNeoScrypt = true;\n            /* PoW difficulty reset after the switch */\n            if(!fProofOfStake && (pindexPrev->nHeight < nForkOne))\n              return(bnNeoScryptSwitch.GetCompact());\n        }\n\n        /* Orbitcoin Super Shield (OSS);\n         * retargets every block using two averaging windows of 5 and 20 blocks,\n         * 0.25 damping and +1% to -2% limiting */\n\n        int64 nIntervalShort = 5, nIntervalLong = 20, nTargetSpacing, nTargetTimespan,\n              nActualTimespan, nActualTimespanShort, nActualTimespanLong, nActualTimespanAvg,\n              nActualTimespanMax, nActualTimespanMin;\n        uint i;\n\n        if(fProofOfStake)\n          nTargetSpacing = 5 * nBaseTargetSpacing;\n        else\n          nTargetSpacing = 20 * nBaseTargetSpacing;\n\n        nTargetTimespan = nTargetSpacing * nIntervalLong;\n\n        /* The short averaging window */\n        const CBlockIndex* pindexShort = pindexPrev;\n        for(i = 0; i < nIntervalShort; i++) {\n            if(pindexShort->pprev)\n              pindexShort = GetLastBlockIndex(pindexShort->pprev, fProofOfStake);\n            else\n              return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanShort = (int64)pindexPrev->nTime - (int64)pindexShort->nTime;\n\n        /* The long averaging window */\n        const CBlockIndex* pindexLong = pindexShort;\n        for(i = 0; i < (nIntervalLong - nIntervalShort); i++) {\n           if(pindexLong->pprev)\n             pindexLong = GetLastBlockIndex(pindexLong->pprev, fProofOfStake);\n           else\n             return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanLong = (int64)pindexPrev->nTime - (int64)pindexLong->nTime;\n\n        /* Time warp protection */\n        nActualTimespanShort = max(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 3 / 4));\n        nActualTimespanShort = min(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 4 / 3));\n        nActualTimespanLong  = max(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 3 / 4));\n        nActualTimespanLong  = min(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 4 / 3));\n\n        /* The average of both windows */\n        nActualTimespanAvg = (nActualTimespanShort * (nIntervalLong / nIntervalShort) + nActualTimespanLong) / 2;\n\n        /* 0.25 damping */\n        nActualTimespan = nActualTimespanAvg + 3 * nTargetTimespan;\n        nActualTimespan /= 4;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: Last = %d, Prev = %d, Short = %d, Long = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexShort->nHeight, pindexLong->nHeight);\n            printf(\"RETARGET time stamps: Last = %u, Prev = %u, Short = %u, Long = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexShort->nTime, pindexLong->nTime);\n            printf(\"RETARGET windows: short = %\"PRI64d\" (%\"PRI64d\"), long = %\"PRI64d\", \"\n              \"average = %\"PRI64d\", damped = %\"PRI64d\"\\n\",\n              nActualTimespanShort, nActualTimespanShort * (nIntervalLong / nIntervalShort),\n              nActualTimespanLong, nActualTimespanAvg, nActualTimespan);\n        }\n\n        /* Difficulty limiters */\n        nActualTimespanMax = nTargetTimespan * 102 / 100;\n        nActualTimespanMin = nTargetTimespan * 100 / 101;\n        if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;\n        if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;\n\n        /* Retarget */\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= nActualTimespan;\n        bnNew /= nTargetTimespan;\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nActualTimespan = %\"PRI64d\", \"\n            \"nTargetTimespan / nActualTimespan = %.4f\\n\",\n            nTargetTimespan, nActualTimespan, (float)nTargetTimespan / (float)nActualTimespan);\n\n    }\n\n    if(fPrettyPrint) {\n        printf(\"Before: %08x  %s\\n\", pindexPrev->nBits,\n          CBigNum().SetCompact(pindexPrev->nBits).getuint256().ToString().c_str());\n        printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n    }\n\n    return(bnNew.GetCompact());\n}\n\n\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}\n\n// Return maximum amount of blocks that other nodes claim to have\nint GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->nChainTrust > nBestInvalidTrust)\n    {\n        nBestInvalidTrust = pindexNew->nChainTrust;\n        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));\n        uiInterface.NotifyBlocksChanged();\n    }\n\n    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(pindexBest->nChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n}\n\n\nvoid CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max(GetBlockTime(), GetAdjustedTime());\n}\n\n\n\n\n\n\n\n\n\n\n\nbool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anyway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}\n\n\nbool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n indexes are valid:\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))\n                return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n        }\n    }\n\n    return true;\n}\n\n\nbool CTransaction::ClientConnectInputs()\n{\n    if (IsCoinBase())\n        return false;\n\n    // Take over previous transactions' spent pointers\n    {\n        LOCK(mempool.cs);\n        int64_t nValueIn = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            // Get prev tx from single transactions in memory\n            COutPoint prevout = vin[i].prevout;\n            if (!mempool.exists(prevout.hash))\n                return false;\n            CTransaction& txPrev = mempool.lookup(prevout.hash);\n\n            if (prevout.n >= txPrev.vout.size())\n                return false;\n\n            // Verify signature\n            if (!VerifySignature(txPrev, *this, i, 0))\n                return error(\"ConnectInputs() : VerifySignature failed\");\n\n            ///// this is redundant with the mempool.mapNextTx stuff,\n            ///// not sure which I want to get rid of\n            ///// this has to go away now that posNext is gone\n            // // Check for conflicts\n            // if (!txPrev.vout[prevout.n].posNext.IsNull())\n            //     return error(\"ConnectInputs() : prev tx already used\");\n            //\n            // // Flag outpoints as used\n            // txPrev.vout[prevout.n].posNext = posThisTx;\n\n            nValueIn += txPrev.vout[prevout.n].nValue;\n\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return error(\"ClientConnectInputs() : txin values out of range\");\n        }\n        if (GetValueOut() > nValueIn)\n            return false;\n    }\n\n    return true;\n}\n\n\n\n\nbool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Disconnect in reverse order\n    for (int i = vtx.size()-1; i >= 0; i--)\n        if (!vtx[i].DisconnectInputs(txdb))\n            return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = 0;\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // ppcoin: clean up wallet after disconnecting coinstake\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, false, false);\n\n    return true;\n}\n\n\nbool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex) {\n\n    /* One more merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(error(\"ConnectBlock() : merkle root verification failed\"));\n\n    //// issue here: it doesn't know the version\n    uint nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION)\n      - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64_t nFees = 0;\n    int64_t nValueIn = 0;\n    int64_t nValueOut = 0;\n    int64_t nStakeReward = 0;\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        uint256 hashTx = tx.GetHash();\n\n        // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n        // unless those are already completely spent.\n        // If such overwrites are allowed, coinbases and transactions depending upon those\n        // can be duplicated to remove the ability to spend the first instance -- even after\n        // being sent to another address.\n        // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n        // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n        // already refuses previously-known transaction ids entirely.\n        // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.\n        // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n        // two in the chain that violate it. This prevents exploiting the issue against nodes in their\n        // initial block download.\n        CTxIndex txindexOld;\n        if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n            BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                if (pos.IsNull())\n                    return false;\n        }\n\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n\n        MapPrevTx mapInputs;\n        if (tx.IsCoinBase())\n            nValueOut += tx.GetValueOut();\n        else\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            // Add in sigops done by pay-to-script-hash inputs;\n            // this is to prevent a \"rogue miner\" from creating\n            // an incredibly-expensive-to-validate block.\n            nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nSigOps > MAX_BLOCK_SIGOPS)\n                return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n            int64_t nTxValueIn = tx.GetValueIn(mapInputs);\n            int64_t nTxValueOut = tx.GetValueOut();\n            nValueIn += nTxValueIn;\n            nValueOut += nTxValueOut;\n            if (!tx.IsCoinStake())\n                nFees += nTxValueIn - nTxValueOut;\n            if (tx.IsCoinStake())\n                nStakeReward = nTxValueOut - nTxValueIn;\n\n            if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n                return false;\n        }\n\n        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    if (IsProofOfWork())\n    {\n        int64_t nReward = GetProofOfWorkReward(pindex->nHeight, nFees);\n        // Check coinbase reward\n        if (vtx[0].GetValueOut() > nReward)\n            return DoS(50, error(\"ConnectBlock() : coinbase reward exceeded (actual=%\"PRId64\" vs calculated=%\"PRId64\")\",\n                   vtx[0].GetValueOut(),\n                   nReward));\n    }\n    if (IsProofOfStake())\n    {\n        // ppcoin: coin stake tx earns reward instead of paying fee\n        uint64_t nCoinAge;\n        if (!vtx[1].GetCoinAge(txdb, nCoinAge))\n            return error(\"ConnectBlock() : %s unable to get coin age for coinstake\", vtx[1].GetHash().ToString().substr(0,10).c_str());\n\n        int64_t nCalculatedStakeReward = GetProofOfStakeReward(pindex->nHeight, nCoinAge, nFees);\n\n        if (nStakeReward > nCalculatedStakeReward)\n            return DoS(100, error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward));\n    }\n\n    // ppcoin: track money supply and mint amount info\n    pindex->nMint = nValueOut - nValueIn + nFees;\n    pindex->nMoneySupply = (pindex->pprev? pindex->pprev->nMoneySupply : 0) + nValueOut - nValueIn;\n    if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))\n        return error(\"Connect() : WriteBlockIndex for pindex failed\");\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}\n\nbool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction& tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}\n\n\n// Called from inside SetBestChain: attaches a block to the new best chain being built\nbool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n{\n    uint256 hash = GetHash();\n\n    // Adding to current best branch\n    if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n    {\n        txdb.TxnAbort();\n        InvalidChainFound(pindexNew);\n        return false;\n    }\n    if (!txdb.TxnCommit())\n        return error(\"SetBestChain() : TxnCommit failed\");\n\n    // Add to current best branch\n    pindexNew->pprev->pnext = pindexNew;\n\n    // Delete redundant memory transactions\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        mempool.remove(tx);\n\n    return true;\n}\n\nbool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect further blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    pblockindexFBBHLast = NULL;\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexNew->nChainTrust;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(nBestChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}\n\n// ppcoin: total coin age spent in transaction, in the unit of coin-days.\n// Only those coins meeting minimum age requirement counts. As those\n// transactions not in main chain are not currently indexed so we\n// might not find out about their coin age. Older transactions are \n// guaranteed to be in main chain by sync-checkpoint. This rule is\n// introduced to help nodes establish a consistent view of the coin\n// age (trust score) of competing branches.\nbool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n{\n    CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n    nCoinAge = 0;\n\n    if (IsCoinBase())\n        return true;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // First try finding the previous transaction in database\n        CTransaction txPrev;\n        CTxIndex txindex;\n        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n            continue;  // previous transaction not in main chain\n        if (nTime < txPrev.nTime)\n            return false;  // Transaction timestamp violation\n\n        // Read block header\n        CBlock block;\n        if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n            return false; // unable to read block of previous transaction\n        if (block.GetBlockTime() + nStakeMinAge > nTime)\n            continue; // only count coins meeting min age requirement\n\n        int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n        bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n\n        if(fDebug && GetBoolArg(\"-printcoinage\"))\n          printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n            nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n    }\n\n    CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n    nCoinAge = bnCoinDay.getuint64();\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}\n\n// ppcoin: total coin age spent in block, in the unit of coin-days.\nbool CBlock::GetCoinAge(uint64_t& nCoinAge) const\n{\n    nCoinAge = 0;\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        uint64_t nTxCoinAge;\n        if (tx.GetCoinAge(txdb, nTxCoinAge))\n            nCoinAge += nTxCoinAge;\n        else\n            return false;\n    }\n\n    if (nCoinAge == 0) // block coin age minimum 1 coin-day\n        nCoinAge = 1;\n\n    /* Might overflow */\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"block nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}\n\nbool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProofOfStake)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    pindexNew->phashBlock = &hash;\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n\n    // ppcoin: compute chain trust score\n    pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();\n\n    // ppcoin: compute stake entropy bit for stake modifier\n    if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))\n        return error(\"AddToBlockIndex() : SetStakeEntropyBit() failed\");\n\n    // ppcoin: record proof-of-stake hash value\n    pindexNew->hashProofOfStake = hashProofOfStake;\n\n    // ppcoin: compute stake modifier\n    uint64_t nStakeModifier = 0;\n    bool fGeneratedStakeModifier = false;\n    if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))\n        return error(\"AddToBlockIndex() : ComputeNextStakeModifier() failed\");\n    pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);\n    pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);\n    if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))\n        return error(\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindexNew->nHeight, nStakeModifier);\n\n    // Add to mapBlockIndex\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    if (pindexNew->IsProofOfStake())\n        setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n    pindexNew->phashBlock = &((*mi).first);\n\n    // Write to disk block index\n    CTxDB txdb;\n    if (!txdb.TxnBegin())\n        return false;\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->nChainTrust > nBestChainTrust)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    uiInterface.NotifyBlocksChanged();\n    return true;\n}\n\n\n\n\nbool CBlock::CheckBlock() const {\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    if(IsProofOfWork()) {\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n    }\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for (unsigned int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n\n    if (IsProofOfStake())\n    {\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n        for (unsigned int i = 2; i < vtx.size(); i++)\n            if (vtx[i].IsCoinStake())\n                return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    return(true);\n}\n\nbool CBlock::AcceptBlock()\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n\n    // Get prev block index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n    if (mi == mapBlockIndex.end())\n        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n    CBlockIndex* pindexPrev = (*mi).second;\n    int nHeight = pindexPrev->nHeight+1;\n\n    if(!fTestNet && IsProofOfWork()) {\n      if((nHeight > 20000) && (nHeight < nForkOne))\n        return DoS(100, error(\"AcceptBlock() : reject proof-of-work at height %d\", nHeight));\n    }\n\n    // Check proof-of-work or proof-of-stake\n    if(nBits != GetNextTargetRequired(pindexPrev, IsProofOfStake(), false))\n      return(DoS(100, error(\"AcceptBlock() : incorrect proof-of-%s difficulty\",\n        IsProofOfWork() ? \"work\" : \"stake\")));\n\n    uint nOurTime = (uint)GetAdjustedTime();\n\n    /* Check for time stamp (past limit #1) */\n    if(nTime <= (uint)pindexPrev->GetMedianTimePast())\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp behind the median\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    if(fTestNet || (!fTestNet && (nHeight > nForkOne))) {\n\n        /* Check for time stamp (future limit) */\n        if(nTime > (nOurTime + 5 * 60))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the future\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Basic block limiter */\n        if(nTime <= ((uint)pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the block limiter\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Future travel detector for the block limiter */\n        if((nTime > (nOurTime + 120)) &&\n          ((pindexPrev->GetAverageTimePast(5, 40) + BLOCK_LIMITER_TIME) > nOurTime))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the future travel detector\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    }\n\n    /* Check for time stamp (past limit #2) */\n    if(nTime <= (pindexPrev->nTime - 10 * 60))\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the past\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    // Check that all transactions are finalized\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.IsFinal(nHeight, GetBlockTime()))\n            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n\n    // Check that the block chain matches the known block chain up to a checkpoint\n    if (!Checkpoints::CheckHardened(nHeight, hash))\n        return DoS(100, error(\"AcceptBlock() : rejected by hardened checkpoint lock-in at %d\", nHeight));\n\n    // Verify hash target and signature of coinstake tx\n    uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n    if (IsProofOfStake())\n    {\n        if (!CheckProofOfStake(vtx[1], nBits, hashProofOfStake, targetProofOfStake))\n        {\n            printf(\"WARNING: ProcessBlock(): check proof-of-stake failed for block %s\\n\", hash.ToString().c_str());\n            return false; // do not error here as we expect this during initial block download\n        }\n    }\n\n    bool cpSatisfies = Checkpoints::CheckSync(hash, pindexPrev);\n\n    // Check that the block satisfies synchronized checkpoint\n    if (CheckpointsMode == Checkpoints::STRICT && !cpSatisfies)\n        return error(\"AcceptBlock() : rejected by synchronized checkpoint\");\n\n    if (CheckpointsMode == Checkpoints::ADVISORY && !cpSatisfies)\n        strMiscWarning = _(\"WARNING: syncronized checkpoint violation detected, but skipped!\");\n\n    // Enforce rule that the coinbase starts with serialized block height\n    CScript expect = CScript() << nHeight;\n    if (vtx[0].vin[0].scriptSig.size() < expect.size() ||\n        !std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n        return DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n\n    /* Don't accept blocks with bogus version numbers after this point */\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne))) {\n        if(nVersion != 2)\n          return(DoS(100, error(\"AcceptBlock() : incorrect block version %u\", nVersion)));\n    }\n\n    // Write block to history file\n    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n        return error(\"AcceptBlock() : out of disk space\");\n    unsigned int nFile = -1;\n    unsigned int nBlockPos = 0;\n    if (!WriteToDisk(nFile, nBlockPos))\n        return error(\"AcceptBlock() : WriteToDisk failed\");\n    if (!AddToBlockIndex(nFile, nBlockPos, hashProofOfStake))\n        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n\n    // Relay inventory, but don't relay old inventory during initial block download\n    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n    if (hashBestChain == hash)\n    {\n        LOCK(cs_vNodes);\n        BOOST_FOREACH(CNode* pnode, vNodes)\n            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n    }\n\n    // ppcoin: check pending sync-checkpoint\n    Checkpoints::AcceptPendingSyncCheckpoint();\n\n    return true;\n}\n\n\n/* Calculates trust score for a block given */\nuint256 CBlockIndex::GetBlockTrust() const {\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    if(bnTarget <= 0) return(0);\n\n    /* Old protocol */\n\n    if(!fTestNet && (nHeight < nForkOne))\n      return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());\n\n    /* New protocol: 80% PoS, 20% PoW */\n\n    uint256 nBlockTrust = 1;\n\n    if(IsProofOfWork()) {\n\n        uint256 nPoWBase  = uint256(\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\");\n        uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();\n\n        /* The minimal PoW trust score prior to correction */\n        if(nPoWTrust < 4) nPoWTrust = 4;\n\n        /* Fixed trust for the first 10 blocks */\n        if((pprev == NULL) || (pprev->nHeight < 10))\n          return(nPoWTrust);\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n\n        if(pindexP1->IsProofOfStake()) {\n            /* 100% trust for PoW following PoS */\n            nBlockTrust = nPoWTrust;\n        } else {\n            if(pindexP2->IsProofOfStake()) {\n                /* 50% trust for PoS->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 1);\n            } else {\n                /* 25% trust for PoW->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 2);\n            }\n        }\n\n    } else {\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n        const CBlockIndex* pindexP3 = pindexP2->pprev;\n\n        /* PoS difficulty is very low and of little use for trust scoring;\n         * use full trust of the previous PoW block as a basis instead */\n        uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;\n\n        if(pindexP1->IsProofOfWork()) {\n            /* 200% trust for PoS following PoW */\n            if(pindexP2->IsProofOfStake()) {\n                /* PoS->PoW->PoS: 100% to 200% */\n                nBlockTrust = (nPrevTrust << 1);\n            } else {\n                if(pindexP3->IsProofOfStake()) {\n                    /* PoS->PoW->PoW->PoS: 50% to 200% */\n                    nBlockTrust = (nPrevTrust << 2);\n                } else {\n                    /* PoW->PoW->PoW->PoS: 25% to 200% */\n                    nBlockTrust = (nPrevTrust << 3);\n                }\n            }\n        } else {\n            if(pindexP2->IsProofOfWork()) {\n                /* 150% of trust for PoW->PoS->PoS */\n                nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();\n            } else {\n                if(pindexP3->IsProofOfWork()) {\n                    /* 120% of trust for PoW->PoS->PoS->PoS */\n                    nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();\n                } else {\n                    const CBlockIndex* pindexP4 = pindexP3->pprev;\n                    if(pindexP4->IsProofOfWork()) {\n                        /* 100% of trust for PoW->PoS->PoS->PoS->PoS */\n                        nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();\n                    } else {\n                        const CBlockIndex* pindexP5 = pindexP4->pprev;\n                        if(pindexP5->IsProofOfWork()) {\n                            /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = (nPrevTrust >> 1);\n                        } else {\n                            /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = nPrevTrust;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    return(nBlockTrust);\n}\n\nbool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned int nRequired, unsigned int nToCheck)\n{\n    unsigned int nFound = 0;\n    for (unsigned int i = 0; i < nToCheck && nFound < nRequired && pstart != NULL; i++)\n    {\n        if (pstart->nVersion >= minVersion)\n            ++nFound;\n        pstart = pstart->pprev;\n    }\n    return (nFound >= nRequired);\n}\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}\n\n// novacoin: attempt to generate suitable proof-of-stake\nbool CBlock::SignBlock(CWallet& wallet, int64_t nFees)\n{\n    // if we are trying to sign\n    //    something except proof-of-stake block template\n    if (!vtx[0].vout[0].IsEmpty())\n        return false;\n\n    // if we are trying to sign\n    //    a complete proof-of-stake block\n    if (IsProofOfStake())\n        return true;\n\n    static int64_t nLastCoinStakeSearchTime = GetAdjustedTime(); // startup timestamp\n\n    CKey key;\n    CTransaction txCoinStake;\n    int64_t nSearchTime = txCoinStake.nTime; // search to current time\n\n    if (nSearchTime > nLastCoinStakeSearchTime)\n    {\n        if (wallet.CreateCoinStake(wallet, nBits, nSearchTime-nLastCoinStakeSearchTime, nFees, txCoinStake, key))\n        {\n            if(txCoinStake.nTime >= max((pindexBest->GetMedianTimePast() + BLOCK_LIMITER_TIME + 1),\n              PastDrift(pindexBest->GetBlockTime()))) {\n\n                // make sure coinstake would meet timestamp protocol\n                //    as it would be the same as the block timestamp\n                vtx[0].nTime = nTime = txCoinStake.nTime;\n                nTime = max(pindexBest->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1, GetMaxTransactionTime());\n                nTime = max(GetBlockTime(), PastDrift(pindexBest->GetBlockTime()));\n\n                // we have to make sure that we have no future timestamps in\n                //    our transactions set\n                for (vector<CTransaction>::iterator it = vtx.begin(); it != vtx.end();)\n                    if (it->nTime > nTime) { it = vtx.erase(it); } else { ++it; }\n\n                vtx.insert(vtx.begin() + 1, txCoinStake);\n                hashMerkleRoot = BuildMerkleTree();\n\n                // append a signature to our block\n                return key.Sign(GetHash(), vchBlockSig);\n            }\n        }\n        nLastCoinStakeSearchInterval = nSearchTime - nLastCoinStakeSearchTime;\n        nLastCoinStakeSearchTime = nSearchTime;\n    }\n\n    return false;\n}\n\nbool CBlock::CheckBlockSignature() const\n{\n    if (IsProofOfWork())\n        return vchBlockSig.empty();\n\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n\n    const CTxOut& txout = vtx[1].vout[1];\n\n    if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        valtype& vchPubKey = vSolutions[0];\n        CKey key;\n        if (!key.SetPubKey(vchPubKey))\n            return false;\n        if (vchBlockSig.empty())\n            return false;\n        return key.Verify(GetHash(), vchBlockSig);\n    }\n\n    return false;\n}\n\nbool CheckDiskSpace(uint64_t nAdditionalBytes)\n{\n    uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for nMinDiskSpace bytes (currently 50MB)\n    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low!\");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        uiInterface.ThreadSafeMessageBox(strMessage, \"Halcyon\", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        StartShutdown();\n        return false;\n    }\n    return true;\n}\n\nstatic filesystem::path BlockFilePath(unsigned int nFile)\n{\n    string strBlockFn = strprintf(\"blk%04u.dat\", nFile);\n    return GetDataDir() / strBlockFn;\n}\n\nFILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)\n{\n    if ((nFile < 1) || (nFile == (unsigned int) -1))\n        return NULL;\n    FILE* file = fopen(BlockFilePath(nFile).string().c_str(), pszMode);\n    if (!file)\n        return NULL;\n    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))\n    {\n        if (fseek(file, nBlockPos, SEEK_SET) != 0)\n        {\n            fclose(file);\n            return NULL;\n        }\n    }\n    return file;\n}\n\nstatic unsigned int nCurrentBlockFile = 1;\n\nFILE* AppendBlockFile(unsigned int& nFileRet)\n{\n    nFileRet = 0;\n    while (true)\n    {\n        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, \"ab\");\n        if (!file)\n            return NULL;\n        if (fseek(file, 0, SEEK_END) != 0)\n            return NULL;\n        // FAT32 file size max 4GB, fseek and ftell max 2GB, so we must stay under 2GB\n        if (ftell(file) < (long)(0x7F000000 - MAX_SIZE))\n        {\n            nFileRet = nCurrentBlockFile;\n            return file;\n        }\n        fclose(file);\n        nCurrentBlockFile++;\n    }\n}\n\nbool LoadBlockIndex(bool fAllowNew) {\n\n    if(fTestNet) {\n        pchMessageStart[0] = 0xfd;\n        pchMessageStart[1] = 0xf2;\n        pchMessageStart[2] = 0xf0;\n        pchMessageStart[3] = 0xdf;\n\n        bnProofOfStakeLimit = bnProofOfStakeLimitTestNet;\n        bnProofOfWorkLimit  = bnProofOfWorkLimitTestNet;\n\n        /* Positive time weight after 20 minutes */\n        nStakeMinAge = 20 * 60;\n        /* Full time weight at 20 hours (+20 minutes) */\n        nStakeMaxAgeOne = 20 * 60 * 60;\n        nStakeMaxAgeTwo = 20 * 60 * 60;\n        /* Interval of 1 minute between stake modifiers */\n        nModifierInterval = 60;\n        /* Coin base and stake maturity */\n        nCoinbaseMaturity = 10;\n        /* NeoScrypt enabled always */\n        fNeoScrypt = true;\n    }\n\n    //\n    // Init with genesis block\n    //\n    CTxDB txdb(\"cr+\");\n    if(!txdb.LoadBlockIndex())\n        return false;\n\n    // Init with genesis block\n    if(mapBlockIndex.empty()) {\n\n        if(!fAllowNew) return false;\n\n        CTransaction txNew;\n        CBlock block;\n\n        if(!fTestNet) {\n\n            /* The Halcyon livenet genesis block */\n\n            const char* pszTimestamp = \"The ancient Greek myth of Halcyon is a tender story of love and commitment\";\n            txNew.nTime = 1408182502;\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].SetEmpty();\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1408182502;\n            block.nBits    = bnProofOfWorkLimit.GetCompact();\n            block.nNonce   = 899198;\n\n        } else {\n\n/* The Halcyon testnet genesis block:\n * CBlock(hash=9a9e20c1cc8dc1297fc4842e1b358a576db6c985f6dc4a6b8cf16f36f69aa54d, ver=1, hashPrevBlock=0000000000000000000000000000000000000000000000000000000000000000, hashMerkleRoot=bef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362, nTime=1418677200, nBits=1f00ffff, nNonce=28699, vtx=1, vchBlockSig=)\n *   Coinbase(hash=bef44c6f33, nTime=1418677200, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n *     CTxIn(COutPoint(0000000000, 4294967295), coinbase 00012a4c6d546865207465726d2048616c63796f6e206f726967696e617465732066726f6d2074686520477265656b206d797468206f6620416c63796f6e6520616e64206d65616e7320676f6c64656e206f72206d61726b656420627920706561636520616e642070726f73706572697479)\n *     CTxOut(empty)\n *   vMerkleTree: bef44c6f33 */\n\n            const char* pszTimestamp = \"The term Halcyon originates from the Greek myth of Alcyone and means golden or marked by peace and prosperity\";\n            txNew.nTime = 1418677200;\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].SetEmpty();\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1418677200;\n            block.nBits    = bnProofOfWorkLimitTestNet.GetCompact();\n            block.nNonce   = 28699;\n\n        }\n\n        //// debug print\n        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n        printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n\n        if(!fTestNet) assert(block.hashMerkleRoot ==\n          uint256(\"0xb761dad6c210bae0a6c1abeec2d7cb83624e34702d3912acba8bef58a932183b\"));\n        else assert(block.hashMerkleRoot ==\n          uint256(\"0xbef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362\"));\n\n        // If no match on genesis block hash, then generate one\n        if(false && ((fTestNet && (block.GetHash() != hashGenesisBlockTestNet)) ||\n                    (!fTestNet && (block.GetHash() != hashGenesisBlock)))) {\n\n            printf(\"Genesis block mining...\\n\");\n\n            uint profile = 0x0;\n            uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();\n            uint256 hash;\n\n            while(true) {\n                neoscrypt((uchar *) &block.nVersion, (uchar *) &hash, profile);\n                if(hash <= hashTarget) break;\n                if(!(block.nNonce & 0xFFF))\n                  printf(\"nonce %08X: hash = %s (target = %s)\\n\",\n                    block.nNonce, hash.ToString().c_str(),\n                    hashTarget.ToString().c_str());\n                ++block.nNonce;\n                if(!block.nNonce) {\n                    printf(\"nonce limit reached, incrementing time\\n\");\n                    ++block.nTime;\n                }\n            }\n            printf(\"block.nTime = %u \\n\", block.nTime);\n            printf(\"block.nNonce = %u \\n\", block.nNonce);\n            printf(\"block.GetHash = %s\\n\", block.GetHash().ToString().c_str());\n            printf(\"block.GetHashPoW = %s\\n\", block.GetHashPoW().ToString().c_str());\n        }\n\n        block.print();\n        if(!fTestNet) assert(block.GetHash() == hashGenesisBlock);\n        else assert(block.GetHash() == hashGenesisBlockTestNet);\n\n        // Start new block file\n        unsigned int nFile;\n        unsigned int nBlockPos;\n        if (!block.WriteToDisk(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n        if (!block.AddToBlockIndex(nFile, nBlockPos, 0))\n            return error(\"LoadBlockIndex() : genesis block not accepted\");\n\n        // ppcoin: initialize synchronized checkpoint\n        if (!Checkpoints::WriteSyncCheckpoint((!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet)))\n            return error(\"LoadBlockIndex() : failed to init sync checkpoint\");\n    }\n\n    string strPubKey = \"\";\n\n    // if checkpoint master key changed must reset sync-checkpoint\n    if (!txdb.ReadCheckpointPubKey(strPubKey) || strPubKey != CSyncCheckpoint::strMasterPubKey)\n    {\n        // write checkpoint master key to db\n        txdb.TxnBegin();\n        if (!txdb.WriteCheckpointPubKey(CSyncCheckpoint::strMasterPubKey))\n            return error(\"LoadBlockIndex() : failed to write new checkpoint master key to db\");\n        if (!txdb.TxnCommit())\n            return error(\"LoadBlockIndex() : failed to commit new checkpoint master key to db\");\n        if ((!fTestNet) && !Checkpoints::ResetSyncCheckpoint())\n            return error(\"LoadBlockIndex() : failed to reset sync-checkpoint\");\n    }\n\n    return true;\n}\n\n\n\nvoid PrintBlockTree()\n{\n    // pre-compute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %08x  %s  mint %7s  tx %\"PRIszu\"\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().c_str(),\n            block.nBits,\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            FormatMoney(pindex->nMint).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main time-chain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (unsigned int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (unsigned int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}\n\nbool LoadExternalBlockFile(FILE* fileIn)\n{\n    int64_t nStart = GetTimeMillis();\n\n    int nLoaded = 0;\n    {\n        LOCK(cs_main);\n        try {\n            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n            unsigned int nPos = 0;\n            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n            {\n                unsigned char pchData[65536];\n                do {\n                    fseek(blkdat, nPos, SEEK_SET);\n                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n                    if (nRead <= 8)\n                    {\n                        nPos = (unsigned int)-1;\n                        break;\n                    }\n                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n                    if (nFind)\n                    {\n                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n                        {\n                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n                            break;\n                        }\n                        nPos += ((unsigned char*)nFind - pchData) + 1;\n                    }\n                    else\n                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n                } while(!fRequestShutdown);\n                if (nPos == (unsigned int)-1)\n                    break;\n                fseek(blkdat, nPos, SEEK_SET);\n                unsigned int nSize;\n                blkdat >> nSize;\n                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n                {\n                    CBlock block;\n                    blkdat >> block;\n                    if (ProcessBlock(NULL,&block))\n                    {\n                        nLoaded++;\n                        nPos += 4 + nSize;\n                    }\n                }\n            }\n        }\n        catch (std::exception &e) {\n            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n                   __PRETTY_FUNCTION__);\n        }\n    }\n    printf(\"Loaded %i blocks from external file in %\"PRId64\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n    return nLoaded > 0;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CAlert\n//\n\nextern map<uint256, CAlert> mapAlerts;\nextern CCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // if detected invalid checkpoint enter safe mode\n    if (Checkpoints::hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = _(\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\");\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n                if (nPriority > 1000)\n                    strRPC = strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Messages\n//\n\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}\n\n\n\n\n// The message start string is designed to be unlikely to occur in normal data.\n// The characters are rarely used upper ASCII, not valid as UTF-8, and produce\n// a large 4-byte int at any alignment.\nunsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };\n\nbool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%\"PRIszu\" bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n    if (strCommand == \"version\")\n    {\n        // Each connection can only send one version message\n        if (pfrom->nVersion != 0)\n        {\n            pfrom->Misbehaving(1);\n            return false;\n        }\n\n        int64_t nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64_t nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n        if (pfrom->nVersion < MIN_PROTO_VERSION)\n        {\n            // Since February 20, 2012, the protocol is initiated at version 209,\n            // and earlier versions are no longer supported\n            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (pfrom->nVersion == 10300)\n            pfrom->nVersion = 300;\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        /* Disconnect all obsolete clients */\n        uint nAdjTime = GetAdjustedTime();\n        if(nAdjTime > nStakeMaxAgeForkTime) {\n            if(pfrom->nVersion < MIN_PROTOCOL_VERSION) {\n                printf(\"obsolete node %s with client %d, disconnecting\\n\",\n                  pfrom->addr.ToString().c_str(), pfrom->nVersion);\n                pfrom->fDisconnect = true;\n                return(true);\n            }\n        }\n\n        // record my external IP reported by peer\n        if (addrFrom.IsRoutable() && addrMe.IsRoutable())\n            addrSeenByPeer = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        if (GetBoolArg(\"-synctime\", true))\n            AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n            {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            addrman.Good(pfrom->addr);\n        } else {\n            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n            {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nStartingHeight > (nBestHeight - 144)) &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay sync-checkpoint\n        {\n            LOCK(Checkpoints::cs_hashSyncCheckpoint);\n            if (!Checkpoints::checkpointMessage.IsNull())\n                Checkpoints::checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // ppcoin: ask for pending sync-checkpoint if any\n        if (!IsInitialBlockDownload())\n            Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        // Don't want addr from older versions unless seeding\n        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n            return true;\n        if (vAddr.size() > 1000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message addr size() = %\"PRIszu\"\", vAddr.size());\n        }\n\n        // Store the new addresses\n        vector<CAddress> vAddrOk;\n        int64_t nNow = GetAdjustedTime();\n        int64_t nSince = nNow - 10 * 60;\n        BOOST_FOREACH(CAddress& addr, vAddr)\n        {\n            if (fShutdown)\n                return true;\n            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                addr.nTime = nNow - 5 * 24 * 60 * 60;\n            pfrom->AddAddressKnown(addr);\n            bool fReachable = IsReachable(addr);\n            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n            {\n                // Relay to a limited number of other nodes\n                {\n                    LOCK(cs_vNodes);\n                    // Use deterministic randomness to send to the same nodes for 24 hours\n                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint64_t hashAddr = addr.GetHash();\n                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    multimap<uint256, CNode*> mapMix;\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                    {\n                        if (pnode->nVersion < CADDR_TIME_VERSION)\n                            continue;\n                        unsigned int nPointer;\n                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n                        uint256 hashKey = hashRand ^ nPointer;\n                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n                        mapMix.insert(make_pair(hashKey, pnode));\n                    }\n                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n                        ((*mi).second)->PushAddress(addr);\n                }\n            }\n            // Do not store addresses outside our network\n            if (fReachable)\n                vAddrOk.push_back(addr);\n        }\n        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n        if (vAddr.size() < 1000)\n            pfrom->fGetAddr = false;\n        if (pfrom->fOneShot)\n            pfrom->fDisconnect = true;\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%\"PRIszu\" invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // ppcoin: send latest proof-of-work block to allow the\n                        // download node to accept as orphan (proof-of-stake \n                        // block might be rejected by stake connection check)\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, GetLastBlockIndex(pindexBest, false)->GetBlockHash()));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                bool pushed = false;\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end()) {\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                        pushed = true;\n                    }\n                }\n                if (!pushed && inv.type == MSG_TX) {\n                    LOCK(mempool.cs);\n                    if (mempool.exists(inv.hash)) {\n                        CTransaction tx = mempool.lookup(inv.hash);\n                        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                        ss.reserve(1000);\n                        ss << tx;\n                        pfrom->PushMessage(\"tx\", ss);\n                    }\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 500;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                // ppcoin: tell downloading node about the latest block if it's\n                // without risk being rejected due to stake connection check\n                if (hashStop != hashBestChain && pindex->GetBlockTime() + nStakeMinAge > pindexBest->GetBlockTime())\n                    pfrom->PushInventory(CInv(MSG_BLOCK, hashBestChain));\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n    else if (strCommand == \"checkpoint\")\n    {\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayTransaction(tx, inv.hash);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (set<uint256>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const uint256& orphanTxHash = *mi;\n                    CTransaction& orphanTx = mapOrphanTransactions[orphanTxHash];\n                    bool fMissingInputs2 = false;\n\n                    if (orphanTx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayTransaction(orphanTx, orphanTxHash);\n                        mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanTxHash));\n                        vWorkQueue.push_back(orphanTxHash);\n                        vEraseQueue.push_back(orphanTxHash);\n                    }\n                    else if (!fMissingInputs2)\n                    {\n                        // invalid orphan\n                        vEraseQueue.push_back(orphanTxHash);\n                        printf(\"   removed invalid orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(tx);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n\n        printf(\"received block %s\\n\", hashBlock.ToString().substr(0,20).c_str());\n        // block.print();\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if (ProcessBlock(pfrom, &block))\n            mapAlreadyAskedFor.erase(inv);\n        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        // Don't return addresses older than nCutOff timestamp\n        int64_t nCutOff = GetTime() - (nNodeLifespan * 24 * 60 * 60);\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            if(addr.nTime > nCutOff)\n                pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"mempool\")\n    {\n        std::vector<uint256> vtxid;\n        mempool.queryHashes(vtxid);\n        vector<CInv> vInv;\n        for (unsigned int i = 0; i < vtxid.size(); i++) {\n            CInv inv(MSG_TX, vtxid[i]);\n            vInv.push_back(inv);\n            if (i == (MAX_INV_SZ - 1))\n                    break;\n        }\n        if (vInv.size() > 0)\n            pfrom->PushMessage(\"inv\", vInv);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64_t nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        CAlert alert;\n        vRecv >> alert;\n\n        uint256 alertHash = alert.GetHash();\n        if (pfrom->setKnown.count(alertHash) == 0)\n        {\n            if (alert.ProcessAlert())\n            {\n                // Relay\n                pfrom->setKnown.insert(alertHash);\n                {\n                    LOCK(cs_vNodes);\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                        alert.RelayTo(pnode);\n                }\n            }\n            else {\n                // Small DoS penalty so peers that send us lots of\n                // duplicate/expired/invalid-signature/whatever alerts\n                // eventually get banned.\n                // This isn't a Misbehaving(100) (immediate ban) because the\n                // peer might be an older or different implementation with\n                // a different signature key, etc.\n                pfrom->Misbehaving(10);\n            }\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}\n\nbool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    while (true)\n    {\n        // Don't bother if send buffer is too full to respond anyway\n        if (pfrom->vSend.size() >= SendBufferSize())\n            break;\n\n        // Scan for message start\n        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if ((int)vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %\"PRIpdd\" BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if (!hdr.IsValid())\n        {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            {\n                LOCK(cs_main);\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            }\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from under-length message on vRecv\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from over-long size\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessages()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessages()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}\n\n\nbool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    TRY_LOCK(cs_main, lockMain);\n    if (lockMain) {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n        // right now.\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n            uint64_t nonce = 0;\n            if (pto->nVersion > BIP0031_VERSION)\n                pto->PushMessage(\"ping\", nonce);\n            else\n                pto->PushMessage(\"ping\");\n        }\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions();\n\n        // Address refresh broadcast\n        static int64_t nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen)\n                    {\n                        CAddress addr = GetLocalAddress(&pnode->addr);\n                        if (addr.IsRoutable())\n                            pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        {\n            LOCK(pto->cs_inventory);\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64_t nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                if (fDebugNet)\n                    printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n                mapAlreadyAskedFor[inv] = nNow;\n            }\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}\n"], "fixing_code": ["// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include \"alert.h\"\n#include \"checkpoints.h\"\n#include \"db.h\"\n#include \"txdb.h\"\n#include \"net.h\"\n#include \"init.h\"\n#include \"ui_interface.h\"\n#include \"kernel.h\"\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/fstream.hpp>\n\n\nusing namespace std;\nusing namespace boost;\n\n//\n// Global state\n//\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nCCriticalSection cs_main;\n\nCTxMemPool mempool;\nunsigned int nTransactionsUpdated = 0;\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\n\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\n\n/* The PoW difficulty after switching to NeoScrypt (0.25) */\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\n\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\n/* Positive time weight after 12 hours for livenet */\nuint nStakeMinAge = 60 * 60 * 12;\n/* That's a bug: -60 * 60 * 24 * 7 */\nuint nStakeMaxAgeOne = 4294362496;\n/* The time weight limit is 7 days after the min. age for livenet */\nuint nStakeMaxAgeTwo = 7 * 24 * 60 * 60;\n/* Interval of 10 minutes between stake modifiers for livenet */\nuint nModifierInterval = 10 * 60;\n\n/* Try to combine inputs while staking up to this limit */\nint64_t nCombineThreshold = 100 * COIN;\n/* Don't split outputs while staking below this limit */\nint64_t nSplitThreshold = 200 * COIN;\n\n/* The base time unit is 30 seconds */\nconst uint nBaseTargetSpacing = 30;\n\nint nCoinbaseMaturity = 50;\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\n\nuint256 nBestChainTrust = 0;\nuint256 nBestInvalidTrust = 0;\n\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64_t nTimeBestReceived = 0;\n\nCMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\nset<pair<COutPoint, unsigned int> > setStakeSeenOrphan;\n\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n\n// Constant stuff for coinbase transactions we create:\nCScript COINBASE_FLAGS;\n\nconst string strMessageMagic = \"Halcyon Signed Message:\\n\";\n\n// Settings\nint64_t nTransactionFee = MIN_TX_FEE;\nint64_t nReserveBalance = 0;\nint64_t nMinimumInputValue = 0;\n\nextern enum Checkpoints::CPMode CheckpointsMode;\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// dispatching functions\n//\n\n// These functions dispatch to one or all registered wallets\n\n\nvoid RegisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}\n\nvoid UnregisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}\n\n// check whether the passed transaction is from us\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}\n\n// get the wallet transaction with the given hash (if it exists)\nbool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}\n\n// erases transaction with the given hash from all wallets\nvoid static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}\n\n// make sure all wallets know about the given transaction, in the given block\nvoid SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fConnect)\n{\n    if (!fConnect)\n    {\n        // ppcoin: wallets need to refund inputs when disconnecting coinstake\n        if (tx.IsCoinStake())\n        {\n            BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n                if (pwallet->IsFromMe(tx))\n                    pwallet->DisableTransaction(tx);\n        }\n        return;\n    }\n\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}\n\n// notify wallets about a new best chain\nvoid static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}\n\n// notify wallets about an updated transaction\nvoid static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}\n\n// dump all wallets\nvoid static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}\n\n// notify wallets about an incoming inventory (for request counts)\nvoid static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}\n\n// ask wallets to resend their transactions\nvoid ResendWalletTransactions(bool fForce)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions(fForce);\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// mapOrphanTransactions\n//\n\nbool AddOrphanTx(const CTransaction& tx)\n{\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return false;\n\n    // Ignore big transactions, to avoid a\n    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n    // large transaction with a missing parent then we assume\n    // it will rebroadcast it later, after the parent transaction(s)\n    // have been mined or received.\n    // 10,000 orphans, each of which is at most 5,000 bytes big is\n    // at most 500 megabytes of orphans:\n\n    size_t nSize = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n\n    if (nSize > 5000)\n    {\n        printf(\"ignoring large orphan tx (size: %\"PRIszu\", hash: %s)\\n\", nSize, hash.ToString().substr(0,10).c_str());\n        return false;\n    }\n\n    mapOrphanTransactions[hash] = tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n\n    printf(\"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString().substr(0,10).c_str(),\n        mapOrphanTransactions.size());\n    return true;\n}\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CTransaction& tx = mapOrphanTransactions[hash];\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    mapOrphanTransactions.erase(hash);\n}\n\nunsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n{\n    unsigned int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        uint256 randomhash = GetRandHash();\n        map<uint256, CTransaction>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CTransaction and CTxIndex\n//\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n{\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::IsStandard() const\n{\n    if (nVersion > CTransaction::CURRENT_VERSION)\n        return false;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n        // ~65-byte public keys, plus a few script ops.\n        if (txin.scriptSig.size() > 500)\n            return false;\n        if (!txin.scriptSig.IsPushOnly())\n            return false;\n        if (fEnforceCanonical && !txin.scriptSig.HasCanonicalPushes()) {\n            return false;\n        }\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout) {\n        if (!::IsStandard(txout.scriptPubKey))\n            return false;\n        if (txout.nValue == 0)\n            return false;\n        if (fEnforceCanonical && !txout.scriptPubKey.HasCanonicalPushes()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//\n// Check transaction inputs, and make sure any\n// pay-to-script-hash transactions are evaluating IsStandard scripts\n//\n// Why bother? To avoid denial-of-service attacks; an attacker\n// can submit a standard HASH... OP_EQUAL transaction,\n// which will get accepted into blocks. The redemption\n// script can be anything; an attacker could use a very\n// expensive-to-check-upon-redemption script like:\n//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n//\nbool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n{\n    if (IsCoinBase())\n        return true; // Coinbases don't use vin normally\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n\n        vector<vector<unsigned char> > vSolutions;\n        txnouttype whichType;\n        // get the scriptPubKey corresponding to this input:\n        const CScript& prevScript = prev.scriptPubKey;\n        if (!Solver(prevScript, whichType, vSolutions))\n            return false;\n        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n        if (nArgsExpected < 0)\n            return false;\n\n        // Transactions with extra stuff in their scriptSigs are\n        // non-standard. Note that this EvalScript() call will\n        // be quick, because if there are any operations\n        // beside \"push data\" in the scriptSig the\n        // IsStandard() call returns false\n        vector<vector<unsigned char> > stack;\n        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n            return false;\n\n        if (whichType == TX_SCRIPTHASH)\n        {\n            if (stack.empty())\n                return false;\n            CScript subscript(stack.back().begin(), stack.back().end());\n            vector<vector<unsigned char> > vSolutions2;\n            txnouttype whichType2;\n            if (!Solver(subscript, whichType2, vSolutions2))\n                return false;\n            if (whichType2 == TX_SCRIPTHASH)\n                return false;\n\n            int tmpExpected;\n            tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n            if (tmpExpected < 0)\n                return false;\n            nArgsExpected += tmpExpected;\n        }\n\n        if (stack.size() != (unsigned int)nArgsExpected)\n            return false;\n    }\n\n    return true;\n}\n\nunsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}\n\n\nint CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n{\n    if (fClient)\n    {\n        if (hashBlock == 0)\n            return 0;\n    }\n    else\n    {\n        CBlock blockTmp;\n        if (pblock == NULL)\n        {\n            // Load the block this tx is in\n            CTxIndex txindex;\n            if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                return 0;\n            if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n                return 0;\n            pblock = &blockTmp;\n        }\n\n        // Update the tx's hashBlock\n        hashBlock = pblock->GetHash();\n\n        // Locate the transaction\n        for (nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)\n            if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                break;\n        if (nIndex == (int)pblock->vtx.size())\n        {\n            vMerkleBranch.clear();\n            nIndex = -1;\n            printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n            return 0;\n        }\n\n        // Fill in merkle branch\n        vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n    }\n\n    // Is the tx in a block that's in the main chain\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}\n\n\n\n\n\n\n\nbool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}\n\nint64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const\n{\n    // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n    int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n\n    unsigned int nNewBlockSize = nBlockSize + nBytes;\n    int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n\n    // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01\n    if (nMinFee < nBaseFee)\n    {\n        BOOST_FOREACH(const CTxOut& txout, vout)\n            if (txout.nValue < CENT)\n                nMinFee = nBaseFee;\n    }\n\n    // Raise the price as the block approaches full\n    if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n    {\n        if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n            return MAX_MONEY;\n        nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n    }\n\n    if (!MoneyRange(nMinFee))\n        nMinFee = MAX_MONEY;\n    return nMinFee;\n}\n\n\nbool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                        bool* pfMissingInputs)\n{\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!tx.CheckTransaction())\n        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (tx.IsCoinBase())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n\n    // ppcoin: coinstake is also only valid in a block, not as a loose transaction\n    if (tx.IsCoinStake())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinstake as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64_t)tx.nLockTime > std::numeric_limits<int>::max())\n        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !tx.IsStandard())\n        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs);\n        if (mapTx.count(hash))\n            return false;\n    }\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (unsigned int i = 0; i < tx.vin.size(); i++)\n    {\n        COutPoint outpoint = tx.vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!tx.IsNewerThan(*ptxOld))\n                return false;\n            for (unsigned int i = 0; i < tx.vin.size(); i++)\n            {\n                COutPoint outpoint = tx.vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return false;\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64_t nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n        // Don't accept it if it can't get into a block\n        int64_t txMinFee = tx.GetMinFee(1000, GMF_RELAY, nSize);\n        if (nFees < txMinFee)\n            return error(\"CTxMemPool::accept() : not enough fees %s, %\"PRId64\" < %\"PRId64,\n                         hash.ToString().c_str(),\n                         nFees, txMinFee);\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make others' transactions take longer to confirm.\n        if (nFees < MIN_RELAY_TX_FEE)\n        {\n            static CCriticalSection cs;\n            static double dFreeCount;\n            static int64_t nLastTime;\n            int64_t nNow = GetTime();\n\n            {\n                LOCK(cs);\n                // Use an exponentially decaying ~10-minute window:\n                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                nLastTime = nNow;\n                // -limitfreerelay unit is thousand-bytes-per-minute\n                // At default rate it would take over a month to fill 1GB\n                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                if (fDebug)\n                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                dFreeCount += nSize;\n            }\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!tx.ConnectInputs(txdb, mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    {\n        LOCK(cs);\n        if (ptxOld)\n        {\n            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            remove(*ptxOld);\n        }\n        addUnchecked(hash, tx);\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"CTxMemPool::accept() : accepted %s (poolsz %\"PRIszu\")\\n\",\n           hash.ToString().substr(0,10).c_str(),\n           mapTx.size());\n    return true;\n}\n\nbool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}\n\nbool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n{\n    // Add to memory pool without checking anything.  Don't call this directly,\n    // call CTxMemPool::accept to properly check the transaction first.\n    {\n        mapTx[hash] = tx;\n        for (unsigned int i = 0; i < tx.vin.size(); i++)\n            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n        nTransactionsUpdated++;\n    }\n    return true;\n}\n\n\nbool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n{\n    // Remove transaction from memory pool\n    {\n        LOCK(cs);\n        uint256 hash = tx.GetHash();\n        if (mapTx.count(hash))\n        {\n            if (fRecursive) {\n                for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                    if (it != mapNextTx.end())\n                        remove(*it->second.ptx, true);\n                }\n            }\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                mapNextTx.erase(txin.prevout);\n            mapTx.erase(hash);\n            nTransactionsUpdated++;\n        }\n    }\n    return true;\n}\n\nbool CTxMemPool::removeConflicts(const CTransaction &tx)\n{\n    // Remove transactions which depend on inputs of tx, recursively\n    LOCK(cs);\n    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n        if (it != mapNextTx.end()) {\n            const CTransaction &txConflict = *it->second.ptx;\n            if (txConflict != tx)\n                remove(txConflict, true);\n        }\n    }\n    return true;\n}\n\nvoid CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}\n\nvoid CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n{\n    vtxid.clear();\n\n    LOCK(cs);\n    vtxid.reserve(mapTx.size());\n    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n        vtxid.push_back((*mi).first);\n}\n\n\n/* Returns a transaction depth in the main chain or\n *  0 = in the memory pool, not yet in the main chain\n * -1 = failed transaction */\nint CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const {\n    bool fTxMempool = mempool.exists(GetHash());\n\n    if((hashBlock == 0) || (nIndex == -1))\n      return(fTxMempool ? 0 : -1);\n\n    // Find the block it claims to be in\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if(mi == mapBlockIndex.end())\n      return(fTxMempool ? 0 : -1);\n\n    CBlockIndex* pindex = (*mi).second;\n    if(!pindex || !pindex->IsInMainChain())\n      return(fTxMempool ? 0 : -1);\n\n    // Make sure the merkle branch connects to this block\n    if(!fMerkleVerified) {\n        if(CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n          return(fTxMempool ? 0 : -1);\n        fMerkleVerified = true;\n    }\n\n    pindexRet = pindex;\n    return(pindexBest->nHeight - pindex->nHeight + 1);\n}\n\n\nint CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!(IsCoinBase() || IsCoinStake()))\n        return 0;\n    return max(0, (nCoinbaseMaturity+10) - GetDepthInMainChain());\n}\n\n\nbool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n{\n    if (fClient)\n    {\n        if (!IsInMainChain() && !ClientConnectInputs())\n            return false;\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    else\n    {\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n}\n\nbool CMerkleTx::AcceptToMemoryPool()\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb);\n}\n\n\n\nbool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n\n    {\n        LOCK(mempool.cs);\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}\n\nbool CWalletTx::AcceptWalletTransaction()\n{\n    CTxDB txdb(\"r\");\n    return AcceptWalletTransaction(txdb);\n}\n\nint CTxIndex::GetDepthInMainChain() const\n{\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n        return 0;\n    // Find the block in the index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n    return 1 + nBestHeight - pindex->nHeight;\n}\n\n// Return transaction in tx, and if it was found inside a block, its hash is placed in hashBlock\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CBlock and CBlockIndex\n//\n\nstatic CBlockIndex* pblockindexFBBHLast;\nCBlockIndex* FindBlockByHeight(int nHeight)\n{\n    CBlockIndex *pblockindex;\n    if (nHeight < nBestHeight / 2)\n        pblockindex = pindexGenesisBlock;\n    else\n        pblockindex = pindexBest;\n    if (pblockindexFBBHLast && abs(nHeight - pblockindex->nHeight) > abs(nHeight - pblockindexFBBHLast->nHeight))\n        pblockindex = pblockindexFBBHLast;\n    while (pblockindex->nHeight > nHeight)\n        pblockindex = pblockindex->pprev;\n    while (pblockindex->nHeight < nHeight)\n        pblockindex = pblockindex->pnext;\n    pblockindexFBBHLast = pblockindex;\n    return pblockindex;\n}\n\nbool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n{\n    if (!fReadTransactions)\n    {\n        *this = pindex->GetBlockHeader();\n        return true;\n    }\n    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n        return false;\n    if (GetHash() != pindex->GetBlockHash())\n        return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n    return true;\n}\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}\n\n// ppcoin: find block wanted by given orphan block\nuint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}\n\nint64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}\n\nint64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}\n\n// ppcoin: find last block index up to pindex\nconst CBlockIndex* GetLastBlockIndex(const CBlockIndex* pindex, bool fProofOfStake)\n{\n    while (pindex && pindex->pprev && (pindex->IsProofOfStake() != fProofOfStake))\n        pindex = pindex->pprev;\n    return pindex;\n}\n\nuint GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake,\n  bool fPrettyPrint) {\n    CBigNum bnTargetLimit, bnNew;\n\n    /* Separate range limits */\n    if(fTestNet) {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimitTestNet;\n        else bnTargetLimit = bnProofOfWorkLimitTestNet;\n    } else {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimit;\n        else bnTargetLimit = bnProofOfWorkLimit;\n    }\n\n    /* The genesis block */\n    if(pindexLast == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);\n    /* The 1st block */\n    if(pindexPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev->pprev, fProofOfStake);\n    /* The 2nd block */\n    if(pindexPrevPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    /* The next block */\n    int nHeight = pindexLast->nHeight + 1;\n\n    if(!fTestNet && (nHeight < nForkOne)) {\n\n        /* Legacy every block retargets of the PPC style */\n\n        int64 nTargetTimespan = 20 * 60;\n        int64 nTargetSpacing = 2 * nBaseTargetSpacing;\n        int64 nInterval, nActualSpacing;\n\n        nActualSpacing = (int64)pindexPrev->nTime - (int64)pindexPrevPrev->nTime;\n        if(nActualSpacing < 0)\n          nActualSpacing = nTargetSpacing;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: pindexLast = %d, pindexPrev = %d, pindexPrevPrev = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexPrevPrev->nHeight);\n            printf(\"RETARGET time stamps: pindexLast = %u, pindexPrev = %u, pindexPrevPrev = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexPrevPrev->nTime);\n        }\n\n        nInterval = nTargetTimespan / nTargetSpacing;\n\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);\n        bnNew /= ((nInterval + 1) * nTargetSpacing);\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nTargetSpacing = %\"PRI64d\", \"\n            \"nInterval = %\"PRI64d\"\\n\", nTargetTimespan, nTargetSpacing, nInterval);\n\n    } else {\n\n        if(!fTestNet) {\n            /* The hard fork to NeoScrypt */\n            if(!fNeoScrypt) fNeoScrypt = true;\n            /* PoW difficulty reset after the switch */\n            if(!fProofOfStake && (pindexPrev->nHeight < nForkOne))\n              return(bnNeoScryptSwitch.GetCompact());\n        }\n\n        /* Orbitcoin Super Shield (OSS);\n         * retargets every block using two averaging windows of 5 and 20 blocks,\n         * 0.25 damping and +1% to -2% limiting */\n\n        int64 nIntervalShort = 5, nIntervalLong = 20, nTargetSpacing, nTargetTimespan,\n              nActualTimespan, nActualTimespanShort, nActualTimespanLong, nActualTimespanAvg,\n              nActualTimespanMax, nActualTimespanMin;\n        uint i;\n\n        if(fProofOfStake)\n          nTargetSpacing = 5 * nBaseTargetSpacing;\n        else\n          nTargetSpacing = 20 * nBaseTargetSpacing;\n\n        nTargetTimespan = nTargetSpacing * nIntervalLong;\n\n        /* The short averaging window */\n        const CBlockIndex* pindexShort = pindexPrev;\n        for(i = 0; i < nIntervalShort; i++) {\n            if(pindexShort->pprev)\n              pindexShort = GetLastBlockIndex(pindexShort->pprev, fProofOfStake);\n            else\n              return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanShort = (int64)pindexPrev->nTime - (int64)pindexShort->nTime;\n\n        /* The long averaging window */\n        const CBlockIndex* pindexLong = pindexShort;\n        for(i = 0; i < (nIntervalLong - nIntervalShort); i++) {\n           if(pindexLong->pprev)\n             pindexLong = GetLastBlockIndex(pindexLong->pprev, fProofOfStake);\n           else\n             return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanLong = (int64)pindexPrev->nTime - (int64)pindexLong->nTime;\n\n        /* Time warp protection */\n        nActualTimespanShort = max(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 3 / 4));\n        nActualTimespanShort = min(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 4 / 3));\n        nActualTimespanLong  = max(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 3 / 4));\n        nActualTimespanLong  = min(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 4 / 3));\n\n        /* The average of both windows */\n        nActualTimespanAvg = (nActualTimespanShort * (nIntervalLong / nIntervalShort) + nActualTimespanLong) / 2;\n\n        /* 0.25 damping */\n        nActualTimespan = nActualTimespanAvg + 3 * nTargetTimespan;\n        nActualTimespan /= 4;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: Last = %d, Prev = %d, Short = %d, Long = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexShort->nHeight, pindexLong->nHeight);\n            printf(\"RETARGET time stamps: Last = %u, Prev = %u, Short = %u, Long = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexShort->nTime, pindexLong->nTime);\n            printf(\"RETARGET windows: short = %\"PRI64d\" (%\"PRI64d\"), long = %\"PRI64d\", \"\n              \"average = %\"PRI64d\", damped = %\"PRI64d\"\\n\",\n              nActualTimespanShort, nActualTimespanShort * (nIntervalLong / nIntervalShort),\n              nActualTimespanLong, nActualTimespanAvg, nActualTimespan);\n        }\n\n        /* Difficulty limiters */\n        nActualTimespanMax = nTargetTimespan * 102 / 100;\n        nActualTimespanMin = nTargetTimespan * 100 / 101;\n        if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;\n        if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;\n\n        /* Retarget */\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= nActualTimespan;\n        bnNew /= nTargetTimespan;\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nActualTimespan = %\"PRI64d\", \"\n            \"nTargetTimespan / nActualTimespan = %.4f\\n\",\n            nTargetTimespan, nActualTimespan, (float)nTargetTimespan / (float)nActualTimespan);\n\n    }\n\n    if(fPrettyPrint) {\n        printf(\"Before: %08x  %s\\n\", pindexPrev->nBits,\n          CBigNum().SetCompact(pindexPrev->nBits).getuint256().ToString().c_str());\n        printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n    }\n\n    return(bnNew.GetCompact());\n}\n\n\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}\n\n// Return maximum amount of blocks that other nodes claim to have\nint GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->nChainTrust > nBestInvalidTrust)\n    {\n        nBestInvalidTrust = pindexNew->nChainTrust;\n        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));\n        uiInterface.NotifyBlocksChanged();\n    }\n\n    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(pindexBest->nChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n}\n\n\nvoid CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max(GetBlockTime(), GetAdjustedTime());\n}\n\n\n\n\n\n\n\n\n\n\n\nbool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anyway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}\n\n\nbool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n indexes are valid:\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))\n                return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n        }\n    }\n\n    return true;\n}\n\n\nbool CTransaction::ClientConnectInputs()\n{\n    if (IsCoinBase())\n        return false;\n\n    // Take over previous transactions' spent pointers\n    {\n        LOCK(mempool.cs);\n        int64_t nValueIn = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            // Get prev tx from single transactions in memory\n            COutPoint prevout = vin[i].prevout;\n            if (!mempool.exists(prevout.hash))\n                return false;\n            CTransaction& txPrev = mempool.lookup(prevout.hash);\n\n            if (prevout.n >= txPrev.vout.size())\n                return false;\n\n            // Verify signature\n            if (!VerifySignature(txPrev, *this, i, 0))\n                return error(\"ConnectInputs() : VerifySignature failed\");\n\n            ///// this is redundant with the mempool.mapNextTx stuff,\n            ///// not sure which I want to get rid of\n            ///// this has to go away now that posNext is gone\n            // // Check for conflicts\n            // if (!txPrev.vout[prevout.n].posNext.IsNull())\n            //     return error(\"ConnectInputs() : prev tx already used\");\n            //\n            // // Flag outpoints as used\n            // txPrev.vout[prevout.n].posNext = posThisTx;\n\n            nValueIn += txPrev.vout[prevout.n].nValue;\n\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return error(\"ClientConnectInputs() : txin values out of range\");\n        }\n        if (GetValueOut() > nValueIn)\n            return false;\n    }\n\n    return true;\n}\n\n\n\n\nbool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Disconnect in reverse order\n    for (int i = vtx.size()-1; i >= 0; i--)\n        if (!vtx[i].DisconnectInputs(txdb))\n            return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = 0;\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // ppcoin: clean up wallet after disconnecting coinstake\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, false, false);\n\n    return true;\n}\n\n\nbool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex) {\n\n    /* One more merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(error(\"ConnectBlock() : merkle root verification failed\"));\n\n    //// issue here: it doesn't know the version\n    uint nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION)\n      - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64_t nFees = 0;\n    int64_t nValueIn = 0;\n    int64_t nValueOut = 0;\n    int64_t nStakeReward = 0;\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        uint256 hashTx = tx.GetHash();\n\n        // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n        // unless those are already completely spent.\n        // If such overwrites are allowed, coinbases and transactions depending upon those\n        // can be duplicated to remove the ability to spend the first instance -- even after\n        // being sent to another address.\n        // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n        // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n        // already refuses previously-known transaction ids entirely.\n        // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.\n        // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n        // two in the chain that violate it. This prevents exploiting the issue against nodes in their\n        // initial block download.\n        CTxIndex txindexOld;\n        if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n            BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                if (pos.IsNull())\n                    return false;\n        }\n\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n\n        MapPrevTx mapInputs;\n        if (tx.IsCoinBase())\n            nValueOut += tx.GetValueOut();\n        else\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            // Add in sigops done by pay-to-script-hash inputs;\n            // this is to prevent a \"rogue miner\" from creating\n            // an incredibly-expensive-to-validate block.\n            nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nSigOps > MAX_BLOCK_SIGOPS)\n                return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n            int64_t nTxValueIn = tx.GetValueIn(mapInputs);\n            int64_t nTxValueOut = tx.GetValueOut();\n            nValueIn += nTxValueIn;\n            nValueOut += nTxValueOut;\n            if (!tx.IsCoinStake())\n                nFees += nTxValueIn - nTxValueOut;\n            if (tx.IsCoinStake())\n                nStakeReward = nTxValueOut - nTxValueIn;\n\n            if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n                return false;\n        }\n\n        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    if (IsProofOfWork())\n    {\n        int64_t nReward = GetProofOfWorkReward(pindex->nHeight, nFees);\n        // Check coinbase reward\n        if (vtx[0].GetValueOut() > nReward)\n            return DoS(50, error(\"ConnectBlock() : coinbase reward exceeded (actual=%\"PRId64\" vs calculated=%\"PRId64\")\",\n                   vtx[0].GetValueOut(),\n                   nReward));\n    }\n    if (IsProofOfStake())\n    {\n        // ppcoin: coin stake tx earns reward instead of paying fee\n        uint64_t nCoinAge;\n        if (!vtx[1].GetCoinAge(txdb, nCoinAge))\n            return error(\"ConnectBlock() : %s unable to get coin age for coinstake\", vtx[1].GetHash().ToString().substr(0,10).c_str());\n\n        int64_t nCalculatedStakeReward = GetProofOfStakeReward(pindex->nHeight, nCoinAge, nFees);\n\n        if (nStakeReward > nCalculatedStakeReward)\n            return DoS(100, error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward));\n    }\n\n    // ppcoin: track money supply and mint amount info\n    pindex->nMint = nValueOut - nValueIn + nFees;\n    pindex->nMoneySupply = (pindex->pprev? pindex->pprev->nMoneySupply : 0) + nValueOut - nValueIn;\n    if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))\n        return error(\"Connect() : WriteBlockIndex for pindex failed\");\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}\n\nbool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction& tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}\n\n\n// Called from inside SetBestChain: attaches a block to the new best chain being built\nbool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n{\n    uint256 hash = GetHash();\n\n    // Adding to current best branch\n    if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n    {\n        txdb.TxnAbort();\n        InvalidChainFound(pindexNew);\n        return false;\n    }\n    if (!txdb.TxnCommit())\n        return error(\"SetBestChain() : TxnCommit failed\");\n\n    // Add to current best branch\n    pindexNew->pprev->pnext = pindexNew;\n\n    // Delete redundant memory transactions\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        mempool.remove(tx);\n\n    return true;\n}\n\nbool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect further blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    pblockindexFBBHLast = NULL;\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexNew->nChainTrust;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(nBestChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}\n\n// ppcoin: total coin age spent in transaction, in the unit of coin-days.\n// Only those coins meeting minimum age requirement counts. As those\n// transactions not in main chain are not currently indexed so we\n// might not find out about their coin age. Older transactions are \n// guaranteed to be in main chain by sync-checkpoint. This rule is\n// introduced to help nodes establish a consistent view of the coin\n// age (trust score) of competing branches.\nbool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n{\n    CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n    nCoinAge = 0;\n\n    if (IsCoinBase())\n        return true;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // First try finding the previous transaction in database\n        CTransaction txPrev;\n        CTxIndex txindex;\n        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n            continue;  // previous transaction not in main chain\n        if (nTime < txPrev.nTime)\n            return false;  // Transaction timestamp violation\n\n        // Read block header\n        CBlock block;\n        if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n            return false; // unable to read block of previous transaction\n        if (block.GetBlockTime() + nStakeMinAge > nTime)\n            continue; // only count coins meeting min age requirement\n\n        int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n        bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n\n        if(fDebug && GetBoolArg(\"-printcoinage\"))\n          printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n            nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n    }\n\n    CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n    nCoinAge = bnCoinDay.getuint64();\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}\n\n// ppcoin: total coin age spent in block, in the unit of coin-days.\nbool CBlock::GetCoinAge(uint64_t& nCoinAge) const\n{\n    nCoinAge = 0;\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        uint64_t nTxCoinAge;\n        if (tx.GetCoinAge(txdb, nTxCoinAge))\n            nCoinAge += nTxCoinAge;\n        else\n            return false;\n    }\n\n    if (nCoinAge == 0) // block coin age minimum 1 coin-day\n        nCoinAge = 1;\n\n    /* Might overflow */\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"block nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}\n\nbool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProofOfStake)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    pindexNew->phashBlock = &hash;\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n\n    // ppcoin: compute chain trust score\n    pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();\n\n    // ppcoin: compute stake entropy bit for stake modifier\n    if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))\n        return error(\"AddToBlockIndex() : SetStakeEntropyBit() failed\");\n\n    // ppcoin: record proof-of-stake hash value\n    pindexNew->hashProofOfStake = hashProofOfStake;\n\n    // ppcoin: compute stake modifier\n    uint64_t nStakeModifier = 0;\n    bool fGeneratedStakeModifier = false;\n    if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))\n        return error(\"AddToBlockIndex() : ComputeNextStakeModifier() failed\");\n    pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);\n    pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);\n    if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))\n        return error(\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindexNew->nHeight, nStakeModifier);\n\n    // Add to mapBlockIndex\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    if (pindexNew->IsProofOfStake())\n        setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n    pindexNew->phashBlock = &((*mi).first);\n\n    // Write to disk block index\n    CTxDB txdb;\n    if (!txdb.TxnBegin())\n        return false;\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->nChainTrust > nBestChainTrust)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    uiInterface.NotifyBlocksChanged();\n    return true;\n}\n\n\n\n\nbool CBlock::CheckBlock() const {\n    uint i;\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for(i = 1; i < vtx.size(); i++) {\n        if(vtx[i].IsCoinBase())\n          return(DoS(100, error(\"CheckBlock() : more than one coin base\")));\n    }\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n\n    if(IsProofOfStake()) {\n\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n        for(i = 2; i < vtx.size(); i++) {\n            if(vtx[i].IsCoinStake())\n              return(DoS(100, error(\"CheckBlock() : more than one coin stake\")));\n        }\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n\n    } else {\n\n        /* No coin stakes in PoW blocks */\n        for(i = 1; i < vtx.size(); i++) {\n            if(vtx[i].IsCoinStake() && (vtx[i].nTime > 1626307200))\n              return(DoS(100, error(\"CheckBlock() : rogue coin stake\")));\n        }\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    return(true);\n}\n\nbool CBlock::AcceptBlock()\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n\n    // Get prev block index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n    if (mi == mapBlockIndex.end())\n        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n    CBlockIndex* pindexPrev = (*mi).second;\n    int nHeight = pindexPrev->nHeight+1;\n\n    if(!fTestNet && IsProofOfWork()) {\n      if((nHeight > 20000) && (nHeight < nForkOne))\n        return DoS(100, error(\"AcceptBlock() : reject proof-of-work at height %d\", nHeight));\n    }\n\n    // Check proof-of-work or proof-of-stake\n    if(nBits != GetNextTargetRequired(pindexPrev, IsProofOfStake(), false))\n      return(DoS(100, error(\"AcceptBlock() : incorrect proof-of-%s difficulty\",\n        IsProofOfWork() ? \"work\" : \"stake\")));\n\n    uint nOurTime = (uint)GetAdjustedTime();\n\n    /* Check for time stamp (past limit #1) */\n    if(nTime <= (uint)pindexPrev->GetMedianTimePast())\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp behind the median\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    if(fTestNet || (!fTestNet && (nHeight > nForkOne))) {\n\n        /* Check for time stamp (future limit) */\n        if(nTime > (nOurTime + 5 * 60))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the future\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Basic block limiter */\n        if(nTime <= ((uint)pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the block limiter\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Future travel detector for the block limiter */\n        if((nTime > (nOurTime + 120)) &&\n          ((pindexPrev->GetAverageTimePast(5, 40) + BLOCK_LIMITER_TIME) > nOurTime))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the future travel detector\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    }\n\n    /* Check for time stamp (past limit #2) */\n    if(nTime <= (pindexPrev->nTime - 10 * 60))\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the past\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    // Check that all transactions are finalized\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.IsFinal(nHeight, GetBlockTime()))\n            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n\n    // Check that the block chain matches the known block chain up to a checkpoint\n    if (!Checkpoints::CheckHardened(nHeight, hash))\n        return DoS(100, error(\"AcceptBlock() : rejected by hardened checkpoint lock-in at %d\", nHeight));\n\n    // Verify hash target and signature of coinstake tx\n    uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n    if (IsProofOfStake())\n    {\n        if (!CheckProofOfStake(vtx[1], nBits, hashProofOfStake, targetProofOfStake))\n        {\n            printf(\"WARNING: ProcessBlock(): check proof-of-stake failed for block %s\\n\", hash.ToString().c_str());\n            return false; // do not error here as we expect this during initial block download\n        }\n    }\n\n    bool cpSatisfies = Checkpoints::CheckSync(hash, pindexPrev);\n\n    // Check that the block satisfies synchronized checkpoint\n    if (CheckpointsMode == Checkpoints::STRICT && !cpSatisfies)\n        return error(\"AcceptBlock() : rejected by synchronized checkpoint\");\n\n    if (CheckpointsMode == Checkpoints::ADVISORY && !cpSatisfies)\n        strMiscWarning = _(\"WARNING: syncronized checkpoint violation detected, but skipped!\");\n\n    // Enforce rule that the coinbase starts with serialized block height\n    CScript expect = CScript() << nHeight;\n    if (vtx[0].vin[0].scriptSig.size() < expect.size() ||\n        !std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n        return DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n\n    /* Don't accept blocks with bogus version numbers after this point */\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne))) {\n        if(nVersion != 2)\n          return(DoS(100, error(\"AcceptBlock() : incorrect block version %u\", nVersion)));\n    }\n\n    // Write block to history file\n    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n        return error(\"AcceptBlock() : out of disk space\");\n    unsigned int nFile = -1;\n    unsigned int nBlockPos = 0;\n    if (!WriteToDisk(nFile, nBlockPos))\n        return error(\"AcceptBlock() : WriteToDisk failed\");\n    if (!AddToBlockIndex(nFile, nBlockPos, hashProofOfStake))\n        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n\n    // Relay inventory, but don't relay old inventory during initial block download\n    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n    if (hashBestChain == hash)\n    {\n        LOCK(cs_vNodes);\n        BOOST_FOREACH(CNode* pnode, vNodes)\n            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n    }\n\n    // ppcoin: check pending sync-checkpoint\n    Checkpoints::AcceptPendingSyncCheckpoint();\n\n    return true;\n}\n\n\n/* Calculates trust score for a block given */\nuint256 CBlockIndex::GetBlockTrust() const {\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    if(bnTarget <= 0) return(0);\n\n    /* Old protocol */\n\n    if(!fTestNet && (nHeight < nForkOne))\n      return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());\n\n    /* New protocol: 80% PoS, 20% PoW */\n\n    uint256 nBlockTrust = 1;\n\n    if(IsProofOfWork()) {\n\n        uint256 nPoWBase  = uint256(\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\");\n        uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();\n\n        /* The minimal PoW trust score prior to correction */\n        if(nPoWTrust < 4) nPoWTrust = 4;\n\n        /* Fixed trust for the first 10 blocks */\n        if((pprev == NULL) || (pprev->nHeight < 10))\n          return(nPoWTrust);\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n\n        if(pindexP1->IsProofOfStake()) {\n            /* 100% trust for PoW following PoS */\n            nBlockTrust = nPoWTrust;\n        } else {\n            if(pindexP2->IsProofOfStake()) {\n                /* 50% trust for PoS->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 1);\n            } else {\n                /* 25% trust for PoW->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 2);\n            }\n        }\n\n    } else {\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n        const CBlockIndex* pindexP3 = pindexP2->pprev;\n\n        /* PoS difficulty is very low and of little use for trust scoring;\n         * use full trust of the previous PoW block as a basis instead */\n        uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;\n\n        if(pindexP1->IsProofOfWork()) {\n            /* 200% trust for PoS following PoW */\n            if(pindexP2->IsProofOfStake()) {\n                /* PoS->PoW->PoS: 100% to 200% */\n                nBlockTrust = (nPrevTrust << 1);\n            } else {\n                if(pindexP3->IsProofOfStake()) {\n                    /* PoS->PoW->PoW->PoS: 50% to 200% */\n                    nBlockTrust = (nPrevTrust << 2);\n                } else {\n                    /* PoW->PoW->PoW->PoS: 25% to 200% */\n                    nBlockTrust = (nPrevTrust << 3);\n                }\n            }\n        } else {\n            if(pindexP2->IsProofOfWork()) {\n                /* 150% of trust for PoW->PoS->PoS */\n                nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();\n            } else {\n                if(pindexP3->IsProofOfWork()) {\n                    /* 120% of trust for PoW->PoS->PoS->PoS */\n                    nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();\n                } else {\n                    const CBlockIndex* pindexP4 = pindexP3->pprev;\n                    if(pindexP4->IsProofOfWork()) {\n                        /* 100% of trust for PoW->PoS->PoS->PoS->PoS */\n                        nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();\n                    } else {\n                        const CBlockIndex* pindexP5 = pindexP4->pprev;\n                        if(pindexP5->IsProofOfWork()) {\n                            /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = (nPrevTrust >> 1);\n                        } else {\n                            /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = nPrevTrust;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    return(nBlockTrust);\n}\n\nbool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned int nRequired, unsigned int nToCheck)\n{\n    unsigned int nFound = 0;\n    for (unsigned int i = 0; i < nToCheck && nFound < nRequired && pstart != NULL; i++)\n    {\n        if (pstart->nVersion >= minVersion)\n            ++nFound;\n        pstart = pstart->pprev;\n    }\n    return (nFound >= nRequired);\n}\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}\n\n// novacoin: attempt to generate suitable proof-of-stake\nbool CBlock::SignBlock(CWallet& wallet, int64_t nFees)\n{\n    // if we are trying to sign\n    //    something except proof-of-stake block template\n    if (!vtx[0].vout[0].IsEmpty())\n        return false;\n\n    // if we are trying to sign\n    //    a complete proof-of-stake block\n    if (IsProofOfStake())\n        return true;\n\n    static int64_t nLastCoinStakeSearchTime = GetAdjustedTime(); // startup timestamp\n\n    CKey key;\n    CTransaction txCoinStake;\n    int64_t nSearchTime = txCoinStake.nTime; // search to current time\n\n    if (nSearchTime > nLastCoinStakeSearchTime)\n    {\n        if (wallet.CreateCoinStake(wallet, nBits, nSearchTime-nLastCoinStakeSearchTime, nFees, txCoinStake, key))\n        {\n            if(txCoinStake.nTime >= max((pindexBest->GetMedianTimePast() + BLOCK_LIMITER_TIME + 1),\n              PastDrift(pindexBest->GetBlockTime()))) {\n\n                // make sure coinstake would meet timestamp protocol\n                //    as it would be the same as the block timestamp\n                vtx[0].nTime = nTime = txCoinStake.nTime;\n                nTime = max(pindexBest->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1, GetMaxTransactionTime());\n                nTime = max(GetBlockTime(), PastDrift(pindexBest->GetBlockTime()));\n\n                // we have to make sure that we have no future timestamps in\n                //    our transactions set\n                for (vector<CTransaction>::iterator it = vtx.begin(); it != vtx.end();)\n                    if (it->nTime > nTime) { it = vtx.erase(it); } else { ++it; }\n\n                vtx.insert(vtx.begin() + 1, txCoinStake);\n                hashMerkleRoot = BuildMerkleTree();\n\n                // append a signature to our block\n                return key.Sign(GetHash(), vchBlockSig);\n            }\n        }\n        nLastCoinStakeSearchInterval = nSearchTime - nLastCoinStakeSearchTime;\n        nLastCoinStakeSearchTime = nSearchTime;\n    }\n\n    return false;\n}\n\nbool CBlock::CheckBlockSignature() const\n{\n    if (IsProofOfWork())\n        return vchBlockSig.empty();\n\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n\n    const CTxOut& txout = vtx[1].vout[1];\n\n    if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        valtype& vchPubKey = vSolutions[0];\n        CKey key;\n        if (!key.SetPubKey(vchPubKey))\n            return false;\n        if (vchBlockSig.empty())\n            return false;\n        return key.Verify(GetHash(), vchBlockSig);\n    }\n\n    return false;\n}\n\nbool CheckDiskSpace(uint64_t nAdditionalBytes)\n{\n    uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for nMinDiskSpace bytes (currently 50MB)\n    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low!\");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        uiInterface.ThreadSafeMessageBox(strMessage, \"Halcyon\", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        StartShutdown();\n        return false;\n    }\n    return true;\n}\n\nstatic filesystem::path BlockFilePath(unsigned int nFile)\n{\n    string strBlockFn = strprintf(\"blk%04u.dat\", nFile);\n    return GetDataDir() / strBlockFn;\n}\n\nFILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)\n{\n    if ((nFile < 1) || (nFile == (unsigned int) -1))\n        return NULL;\n    FILE* file = fopen(BlockFilePath(nFile).string().c_str(), pszMode);\n    if (!file)\n        return NULL;\n    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))\n    {\n        if (fseek(file, nBlockPos, SEEK_SET) != 0)\n        {\n            fclose(file);\n            return NULL;\n        }\n    }\n    return file;\n}\n\nstatic unsigned int nCurrentBlockFile = 1;\n\nFILE* AppendBlockFile(unsigned int& nFileRet)\n{\n    nFileRet = 0;\n    while (true)\n    {\n        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, \"ab\");\n        if (!file)\n            return NULL;\n        if (fseek(file, 0, SEEK_END) != 0)\n            return NULL;\n        // FAT32 file size max 4GB, fseek and ftell max 2GB, so we must stay under 2GB\n        if (ftell(file) < (long)(0x7F000000 - MAX_SIZE))\n        {\n            nFileRet = nCurrentBlockFile;\n            return file;\n        }\n        fclose(file);\n        nCurrentBlockFile++;\n    }\n}\n\nbool LoadBlockIndex(bool fAllowNew) {\n\n    if(fTestNet) {\n        pchMessageStart[0] = 0xfd;\n        pchMessageStart[1] = 0xf2;\n        pchMessageStart[2] = 0xf0;\n        pchMessageStart[3] = 0xdf;\n\n        bnProofOfStakeLimit = bnProofOfStakeLimitTestNet;\n        bnProofOfWorkLimit  = bnProofOfWorkLimitTestNet;\n\n        /* Positive time weight after 20 minutes */\n        nStakeMinAge = 20 * 60;\n        /* Full time weight at 20 hours (+20 minutes) */\n        nStakeMaxAgeOne = 20 * 60 * 60;\n        nStakeMaxAgeTwo = 20 * 60 * 60;\n        /* Interval of 1 minute between stake modifiers */\n        nModifierInterval = 60;\n        /* Coin base and stake maturity */\n        nCoinbaseMaturity = 10;\n        /* NeoScrypt enabled always */\n        fNeoScrypt = true;\n    }\n\n    //\n    // Init with genesis block\n    //\n    CTxDB txdb(\"cr+\");\n    if(!txdb.LoadBlockIndex())\n        return false;\n\n    // Init with genesis block\n    if(mapBlockIndex.empty()) {\n\n        if(!fAllowNew) return false;\n\n        CTransaction txNew;\n        CBlock block;\n\n        if(!fTestNet) {\n\n            /* The Halcyon livenet genesis block */\n\n            const char* pszTimestamp = \"The ancient Greek myth of Halcyon is a tender story of love and commitment\";\n            txNew.nTime = 1408182502;\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].SetEmpty();\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1408182502;\n            block.nBits    = bnProofOfWorkLimit.GetCompact();\n            block.nNonce   = 899198;\n\n        } else {\n\n/* The Halcyon testnet genesis block:\n * CBlock(hash=9a9e20c1cc8dc1297fc4842e1b358a576db6c985f6dc4a6b8cf16f36f69aa54d, ver=1, hashPrevBlock=0000000000000000000000000000000000000000000000000000000000000000, hashMerkleRoot=bef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362, nTime=1418677200, nBits=1f00ffff, nNonce=28699, vtx=1, vchBlockSig=)\n *   Coinbase(hash=bef44c6f33, nTime=1418677200, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n *     CTxIn(COutPoint(0000000000, 4294967295), coinbase 00012a4c6d546865207465726d2048616c63796f6e206f726967696e617465732066726f6d2074686520477265656b206d797468206f6620416c63796f6e6520616e64206d65616e7320676f6c64656e206f72206d61726b656420627920706561636520616e642070726f73706572697479)\n *     CTxOut(empty)\n *   vMerkleTree: bef44c6f33 */\n\n            const char* pszTimestamp = \"The term Halcyon originates from the Greek myth of Alcyone and means golden or marked by peace and prosperity\";\n            txNew.nTime = 1418677200;\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].SetEmpty();\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1418677200;\n            block.nBits    = bnProofOfWorkLimitTestNet.GetCompact();\n            block.nNonce   = 28699;\n\n        }\n\n        //// debug print\n        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n        printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n\n        if(!fTestNet) assert(block.hashMerkleRoot ==\n          uint256(\"0xb761dad6c210bae0a6c1abeec2d7cb83624e34702d3912acba8bef58a932183b\"));\n        else assert(block.hashMerkleRoot ==\n          uint256(\"0xbef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362\"));\n\n        // If no match on genesis block hash, then generate one\n        if(false && ((fTestNet && (block.GetHash() != hashGenesisBlockTestNet)) ||\n                    (!fTestNet && (block.GetHash() != hashGenesisBlock)))) {\n\n            printf(\"Genesis block mining...\\n\");\n\n            uint profile = 0x0;\n            uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();\n            uint256 hash;\n\n            while(true) {\n                neoscrypt((uchar *) &block.nVersion, (uchar *) &hash, profile);\n                if(hash <= hashTarget) break;\n                if(!(block.nNonce & 0xFFF))\n                  printf(\"nonce %08X: hash = %s (target = %s)\\n\",\n                    block.nNonce, hash.ToString().c_str(),\n                    hashTarget.ToString().c_str());\n                ++block.nNonce;\n                if(!block.nNonce) {\n                    printf(\"nonce limit reached, incrementing time\\n\");\n                    ++block.nTime;\n                }\n            }\n            printf(\"block.nTime = %u \\n\", block.nTime);\n            printf(\"block.nNonce = %u \\n\", block.nNonce);\n            printf(\"block.GetHash = %s\\n\", block.GetHash().ToString().c_str());\n            printf(\"block.GetHashPoW = %s\\n\", block.GetHashPoW().ToString().c_str());\n        }\n\n        block.print();\n        if(!fTestNet) assert(block.GetHash() == hashGenesisBlock);\n        else assert(block.GetHash() == hashGenesisBlockTestNet);\n\n        // Start new block file\n        unsigned int nFile;\n        unsigned int nBlockPos;\n        if (!block.WriteToDisk(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n        if (!block.AddToBlockIndex(nFile, nBlockPos, 0))\n            return error(\"LoadBlockIndex() : genesis block not accepted\");\n\n        // ppcoin: initialize synchronized checkpoint\n        if (!Checkpoints::WriteSyncCheckpoint((!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet)))\n            return error(\"LoadBlockIndex() : failed to init sync checkpoint\");\n    }\n\n    string strPubKey = \"\";\n\n    // if checkpoint master key changed must reset sync-checkpoint\n    if (!txdb.ReadCheckpointPubKey(strPubKey) || strPubKey != CSyncCheckpoint::strMasterPubKey)\n    {\n        // write checkpoint master key to db\n        txdb.TxnBegin();\n        if (!txdb.WriteCheckpointPubKey(CSyncCheckpoint::strMasterPubKey))\n            return error(\"LoadBlockIndex() : failed to write new checkpoint master key to db\");\n        if (!txdb.TxnCommit())\n            return error(\"LoadBlockIndex() : failed to commit new checkpoint master key to db\");\n        if ((!fTestNet) && !Checkpoints::ResetSyncCheckpoint())\n            return error(\"LoadBlockIndex() : failed to reset sync-checkpoint\");\n    }\n\n    return true;\n}\n\n\n\nvoid PrintBlockTree()\n{\n    // pre-compute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %08x  %s  mint %7s  tx %\"PRIszu\"\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().c_str(),\n            block.nBits,\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            FormatMoney(pindex->nMint).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main time-chain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (unsigned int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (unsigned int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}\n\nbool LoadExternalBlockFile(FILE* fileIn)\n{\n    int64_t nStart = GetTimeMillis();\n\n    int nLoaded = 0;\n    {\n        LOCK(cs_main);\n        try {\n            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n            unsigned int nPos = 0;\n            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n            {\n                unsigned char pchData[65536];\n                do {\n                    fseek(blkdat, nPos, SEEK_SET);\n                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n                    if (nRead <= 8)\n                    {\n                        nPos = (unsigned int)-1;\n                        break;\n                    }\n                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n                    if (nFind)\n                    {\n                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n                        {\n                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n                            break;\n                        }\n                        nPos += ((unsigned char*)nFind - pchData) + 1;\n                    }\n                    else\n                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n                } while(!fRequestShutdown);\n                if (nPos == (unsigned int)-1)\n                    break;\n                fseek(blkdat, nPos, SEEK_SET);\n                unsigned int nSize;\n                blkdat >> nSize;\n                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n                {\n                    CBlock block;\n                    blkdat >> block;\n                    if (ProcessBlock(NULL,&block))\n                    {\n                        nLoaded++;\n                        nPos += 4 + nSize;\n                    }\n                }\n            }\n        }\n        catch (std::exception &e) {\n            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n                   __PRETTY_FUNCTION__);\n        }\n    }\n    printf(\"Loaded %i blocks from external file in %\"PRId64\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n    return nLoaded > 0;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CAlert\n//\n\nextern map<uint256, CAlert> mapAlerts;\nextern CCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // if detected invalid checkpoint enter safe mode\n    if (Checkpoints::hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = _(\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\");\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n                if (nPriority > 1000)\n                    strRPC = strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Messages\n//\n\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}\n\n\n\n\n// The message start string is designed to be unlikely to occur in normal data.\n// The characters are rarely used upper ASCII, not valid as UTF-8, and produce\n// a large 4-byte int at any alignment.\nunsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };\n\nbool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%\"PRIszu\" bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n    if (strCommand == \"version\")\n    {\n        // Each connection can only send one version message\n        if (pfrom->nVersion != 0)\n        {\n            pfrom->Misbehaving(1);\n            return false;\n        }\n\n        int64_t nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64_t nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n        if (pfrom->nVersion < MIN_PROTO_VERSION)\n        {\n            // Since February 20, 2012, the protocol is initiated at version 209,\n            // and earlier versions are no longer supported\n            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (pfrom->nVersion == 10300)\n            pfrom->nVersion = 300;\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        /* Disconnect all obsolete clients */\n        uint nAdjTime = GetAdjustedTime();\n        if(nAdjTime > nStakeMaxAgeForkTime) {\n            if(pfrom->nVersion < MIN_PROTOCOL_VERSION) {\n                printf(\"obsolete node %s with client %d, disconnecting\\n\",\n                  pfrom->addr.ToString().c_str(), pfrom->nVersion);\n                pfrom->fDisconnect = true;\n                return(true);\n            }\n        }\n\n        // record my external IP reported by peer\n        if (addrFrom.IsRoutable() && addrMe.IsRoutable())\n            addrSeenByPeer = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        if (GetBoolArg(\"-synctime\", true))\n            AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n            {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            addrman.Good(pfrom->addr);\n        } else {\n            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n            {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nStartingHeight > (nBestHeight - 144)) &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay sync-checkpoint\n        {\n            LOCK(Checkpoints::cs_hashSyncCheckpoint);\n            if (!Checkpoints::checkpointMessage.IsNull())\n                Checkpoints::checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // ppcoin: ask for pending sync-checkpoint if any\n        if (!IsInitialBlockDownload())\n            Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        // Don't want addr from older versions unless seeding\n        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n            return true;\n        if (vAddr.size() > 1000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message addr size() = %\"PRIszu\"\", vAddr.size());\n        }\n\n        // Store the new addresses\n        vector<CAddress> vAddrOk;\n        int64_t nNow = GetAdjustedTime();\n        int64_t nSince = nNow - 10 * 60;\n        BOOST_FOREACH(CAddress& addr, vAddr)\n        {\n            if (fShutdown)\n                return true;\n            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                addr.nTime = nNow - 5 * 24 * 60 * 60;\n            pfrom->AddAddressKnown(addr);\n            bool fReachable = IsReachable(addr);\n            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n            {\n                // Relay to a limited number of other nodes\n                {\n                    LOCK(cs_vNodes);\n                    // Use deterministic randomness to send to the same nodes for 24 hours\n                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint64_t hashAddr = addr.GetHash();\n                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    multimap<uint256, CNode*> mapMix;\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                    {\n                        if (pnode->nVersion < CADDR_TIME_VERSION)\n                            continue;\n                        unsigned int nPointer;\n                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n                        uint256 hashKey = hashRand ^ nPointer;\n                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n                        mapMix.insert(make_pair(hashKey, pnode));\n                    }\n                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n                        ((*mi).second)->PushAddress(addr);\n                }\n            }\n            // Do not store addresses outside our network\n            if (fReachable)\n                vAddrOk.push_back(addr);\n        }\n        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n        if (vAddr.size() < 1000)\n            pfrom->fGetAddr = false;\n        if (pfrom->fOneShot)\n            pfrom->fDisconnect = true;\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%\"PRIszu\" invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // ppcoin: send latest proof-of-work block to allow the\n                        // download node to accept as orphan (proof-of-stake \n                        // block might be rejected by stake connection check)\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, GetLastBlockIndex(pindexBest, false)->GetBlockHash()));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                bool pushed = false;\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end()) {\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                        pushed = true;\n                    }\n                }\n                if (!pushed && inv.type == MSG_TX) {\n                    LOCK(mempool.cs);\n                    if (mempool.exists(inv.hash)) {\n                        CTransaction tx = mempool.lookup(inv.hash);\n                        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                        ss.reserve(1000);\n                        ss << tx;\n                        pfrom->PushMessage(\"tx\", ss);\n                    }\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 500;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                // ppcoin: tell downloading node about the latest block if it's\n                // without risk being rejected due to stake connection check\n                if (hashStop != hashBestChain && pindex->GetBlockTime() + nStakeMinAge > pindexBest->GetBlockTime())\n                    pfrom->PushInventory(CInv(MSG_BLOCK, hashBestChain));\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n    else if (strCommand == \"checkpoint\")\n    {\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayTransaction(tx, inv.hash);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (set<uint256>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const uint256& orphanTxHash = *mi;\n                    CTransaction& orphanTx = mapOrphanTransactions[orphanTxHash];\n                    bool fMissingInputs2 = false;\n\n                    if (orphanTx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayTransaction(orphanTx, orphanTxHash);\n                        mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanTxHash));\n                        vWorkQueue.push_back(orphanTxHash);\n                        vEraseQueue.push_back(orphanTxHash);\n                    }\n                    else if (!fMissingInputs2)\n                    {\n                        // invalid orphan\n                        vEraseQueue.push_back(orphanTxHash);\n                        printf(\"   removed invalid orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(tx);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n\n        printf(\"received block %s\\n\", hashBlock.ToString().substr(0,20).c_str());\n        // block.print();\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if (ProcessBlock(pfrom, &block))\n            mapAlreadyAskedFor.erase(inv);\n        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        // Don't return addresses older than nCutOff timestamp\n        int64_t nCutOff = GetTime() - (nNodeLifespan * 24 * 60 * 60);\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            if(addr.nTime > nCutOff)\n                pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"mempool\")\n    {\n        std::vector<uint256> vtxid;\n        mempool.queryHashes(vtxid);\n        vector<CInv> vInv;\n        for (unsigned int i = 0; i < vtxid.size(); i++) {\n            CInv inv(MSG_TX, vtxid[i]);\n            vInv.push_back(inv);\n            if (i == (MAX_INV_SZ - 1))\n                    break;\n        }\n        if (vInv.size() > 0)\n            pfrom->PushMessage(\"inv\", vInv);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64_t nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        CAlert alert;\n        vRecv >> alert;\n\n        uint256 alertHash = alert.GetHash();\n        if (pfrom->setKnown.count(alertHash) == 0)\n        {\n            if (alert.ProcessAlert())\n            {\n                // Relay\n                pfrom->setKnown.insert(alertHash);\n                {\n                    LOCK(cs_vNodes);\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                        alert.RelayTo(pnode);\n                }\n            }\n            else {\n                // Small DoS penalty so peers that send us lots of\n                // duplicate/expired/invalid-signature/whatever alerts\n                // eventually get banned.\n                // This isn't a Misbehaving(100) (immediate ban) because the\n                // peer might be an older or different implementation with\n                // a different signature key, etc.\n                pfrom->Misbehaving(10);\n            }\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}\n\nbool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    while (true)\n    {\n        // Don't bother if send buffer is too full to respond anyway\n        if (pfrom->vSend.size() >= SendBufferSize())\n            break;\n\n        // Scan for message start\n        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if ((int)vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %\"PRIpdd\" BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if (!hdr.IsValid())\n        {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            {\n                LOCK(cs_main);\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            }\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from under-length message on vRecv\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from over-long size\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessages()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessages()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}\n\n\nbool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    TRY_LOCK(cs_main, lockMain);\n    if (lockMain) {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n        // right now.\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n            uint64_t nonce = 0;\n            if (pto->nVersion > BIP0031_VERSION)\n                pto->PushMessage(\"ping\", nonce);\n            else\n                pto->PushMessage(\"ping\");\n        }\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions();\n\n        // Address refresh broadcast\n        static int64_t nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen)\n                    {\n                        CAddress addr = GetLocalAddress(&pnode->addr);\n                        if (addr.IsRoutable())\n                            pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        {\n            LOCK(pto->cs_inventory);\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64_t nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                if (fDebugNet)\n                    printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n                mapAlreadyAskedFor[inv] = nNow;\n            }\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}\n"], "filenames": ["src/main.cpp"], "buggy_code_start_loc": [2101], "buggy_code_end_loc": [2156], "fixing_code_start_loc": [2102], "fixing_code_end_loc": [2163], "type": "NVD-CWE-Other", "message": "A vulnerability has been found in ghostlander Halcyon and classified as critical. Affected by this vulnerability is the function CBlock::AddToBlockIndex of the file src/main.cpp of the component Block Verification. The manipulation leads to improper access controls. The attack can be launched remotely. Upgrading to version 1.1.1.0-hal is able to address this issue. The name of the patch is 0675b25ae9cc10b5fdc8ea3a32c642979762d45e. It is recommended to upgrade the affected component. The identifier VDB-217417 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2021-4300", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-04T22:15:08.903", "lastModified": "2023-01-11T01:40:32.733", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in ghostlander Halcyon and classified as critical. Affected by this vulnerability is the function CBlock::AddToBlockIndex of the file src/main.cpp of the component Block Verification. The manipulation leads to improper access controls. The attack can be launched remotely. Upgrading to version 1.1.1.0-hal is able to address this issue. The name of the patch is 0675b25ae9cc10b5fdc8ea3a32c642979762d45e. It is recommended to upgrade the affected component. The identifier VDB-217417 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:halcyon_project:halcyon:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.1.0", "matchCriteriaId": "FD1553FD-C96D-4F32-B93F-E785D7CC4329"}]}]}], "references": [{"url": "https://github.com/ghostlander/Halcyon/commit/0675b25ae9cc10b5fdc8ea3a32c642979762d45e", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ghostlander/Halcyon/releases/tag/v1.1.1.0-hal", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217417", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217417", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ghostlander/Halcyon/commit/0675b25ae9cc10b5fdc8ea3a32c642979762d45e"}}