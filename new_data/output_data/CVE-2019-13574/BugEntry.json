{"buggy_code": ["require 'tempfile'\nrequire 'stringio'\nrequire 'pathname'\nrequire 'uri'\nrequire 'open-uri'\n\nrequire 'mini_magick/image/info'\nrequire 'mini_magick/utilities'\n\nmodule MiniMagick\n  class Image\n\n    ##\n    # This is the primary loading method used by all of the other class\n    # methods.\n    #\n    # Use this to pass in a stream object. Must respond to #read(size) or be a\n    # binary string object (BLOBBBB)\n    #\n    # Probably easier to use the {.open} method if you want to open a file or a\n    # URL.\n    #\n    # @param stream [#read, String] Some kind of stream object that needs\n    #   to be read or is a binary String blob\n    # @param ext [String] A manual extension to use for reading the file. Not\n    #   required, but if you are having issues, give this a try.\n    # @return [MiniMagick::Image]\n    #\n    def self.read(stream, ext = nil)\n      if stream.is_a?(String)\n        stream = StringIO.new(stream)\n      end\n\n      create(ext) { |file| IO.copy_stream(stream, file) }\n    end\n\n    ##\n    # Creates an image object from a binary string blob which contains raw\n    # pixel data (i.e. no header data).\n    #\n    # @param blob [String] Binary string blob containing raw pixel data.\n    # @param columns [Integer] Number of columns.\n    # @param rows [Integer] Number of rows.\n    # @param depth [Integer] Bit depth of the encoded pixel data.\n    # @param map [String] A code for the mapping of the pixel data. Example:\n    #   'gray' or 'rgb'.\n    # @param format [String] The file extension of the image format to be\n    #   used when creating the image object.\n    # Defaults to 'png'.\n    # @return [MiniMagick::Image] The loaded image.\n    #\n    def self.import_pixels(blob, columns, rows, depth, map, format = 'png')\n      # Create an image object with the raw pixel data string:\n      create(\".dat\", false) { |f| f.write(blob) }.tap do |image|\n        output_path = image.path.sub(/\\.\\w+$/, \".#{format}\")\n        # Use ImageMagick to convert the raw data file to an image file of the\n        # desired format:\n        MiniMagick::Tool::Convert.new do |convert|\n          convert.size \"#{columns}x#{rows}\"\n          convert.depth depth\n          convert << \"#{map}:#{image.path}\"\n          convert << output_path\n        end\n\n        image.path.replace output_path\n      end\n    end\n\n    ##\n    # Opens a specific image file either on the local file system or at a URI.\n    # Use this if you don't want to overwrite the image file.\n    #\n    # Extension is either guessed from the path or you can specify it as a\n    # second parameter.\n    #\n    # @param path_or_url [String] Either a local file path or a URL that\n    #   open-uri can read\n    # @param ext [String] Specify the extension you want to read it as\n    # @param options [Hash] Specify options for the open method\n    # @return [MiniMagick::Image] The loaded image\n    #\n    def self.open(path_or_url, ext = nil, options = {})\n      options, ext = ext, nil if ext.is_a?(Hash)\n\n      ext ||=\n        if File.exist?(path_or_url)\n          File.extname(path_or_url)\n        else\n          File.extname(URI(path_or_url).path)\n        end\n\n      ext.sub!(/:.*/, '') # hack for filenames or URLs that include a colon\n\n      Kernel.open(path_or_url, \"rb\", options) do |file|\n        read(file, ext)\n      end\n    end\n\n    ##\n    # Used to create a new Image object data-copy. Not used to \"paint\" or\n    # that kind of thing.\n    #\n    # Takes an extension in a block and can be used to build a new Image\n    # object. Used by both {.open} and {.read} to create a new object. Ensures\n    # we have a good tempfile.\n    #\n    # @param ext [String] Specify the extension you want to read it as\n    # @param validate [Boolean] If false, skips validation of the created\n    #   image. Defaults to true.\n    # @yield [Tempfile] You can #write bits to this object to create the new\n    #   Image\n    # @return [MiniMagick::Image] The created image\n    #\n    def self.create(ext = nil, validate = MiniMagick.validate_on_create, &block)\n      tempfile = MiniMagick::Utilities.tempfile(ext.to_s.downcase, &block)\n\n      new(tempfile.path, tempfile).tap do |image|\n        image.validate! if validate\n      end\n    end\n\n    ##\n    # @private\n    # @!macro [attach] attribute\n    #   @!attribute [r] $1\n    #\n    def self.attribute(name, key = name.to_s)\n      define_method(name) do |*args|\n        if args.any? && name != :resolution\n          mogrify { |b| b.send(name, *args) }\n        else\n          @info[key, *args]\n        end\n      end\n    end\n\n    ##\n    # @return [String] The location of the current working file\n    #\n    attr_reader :path\n    ##\n    # @return [Tempfile] The underlying temporary file\n    #\n    attr_reader :tempfile\n\n    ##\n    # Create a new {MiniMagick::Image} object.\n    #\n    # _DANGER_: The file location passed in here is the *working copy*. That\n    # is, it gets *modified*. You can either copy it yourself or use {.open}\n    # which creates a temporary file for you and protects your original.\n    #\n    # @param input_path [String, Pathname] The location of an image file\n    # @yield [MiniMagick::Tool::Mogrify] If block is given, {#combine_options}\n    #   is called.\n    #\n    def initialize(input_path, tempfile = nil, &block)\n      @path = input_path.to_s\n      @tempfile = tempfile\n      @info = MiniMagick::Image::Info.new(@path)\n\n      combine_options(&block) if block\n    end\n\n    def ==(other)\n      self.class == other.class && signature == other.signature\n    end\n    alias eql? ==\n\n    def hash\n      signature.hash\n    end\n\n    ##\n    # Returns raw image data.\n    #\n    # @return [String] Binary string\n    #\n    def to_blob\n      File.binread(path)\n    end\n\n    ##\n    # Checks to make sure that MiniMagick can read the file and understand it.\n    #\n    # This uses the 'identify' command line utility to check the file. If you\n    # are having issues with this, then please work directly with the\n    # 'identify' command and see if you can figure out what the issue is.\n    #\n    # @return [Boolean]\n    #\n    def valid?\n      validate!\n      true\n    rescue MiniMagick::Invalid\n      false\n    end\n\n    ##\n    # Runs `identify` on the current image, and raises an error if it doesn't\n    # pass.\n    #\n    # @raise [MiniMagick::Invalid]\n    #\n    def validate!\n      identify\n    rescue MiniMagick::Error => error\n      raise MiniMagick::Invalid, error.message\n    end\n\n    ##\n    # Returns the image format (e.g. \"JPEG\", \"GIF\").\n    #\n    # @return [String]\n    #\n    attribute :type, \"format\"\n    ##\n    # @return [String]\n    #\n    attribute :mime_type\n    ##\n    # @return [Integer]\n    #\n    attribute :width\n    ##\n    # @return [Integer]\n    #\n    attribute :height\n    ##\n    # @return [Array<Integer>]\n    #\n    attribute :dimensions\n    ##\n    # Returns the file size of the image (in bytes).\n    #\n    # @return [Integer]\n    #\n    attribute :size\n    ##\n    # Returns the file size in a human readable format.\n    #\n    # @return [String]\n    #\n    attribute :human_size\n    ##\n    # @return [String]\n    #\n    attribute :colorspace\n    ##\n    # @return [Hash]\n    #\n    attribute :exif\n    ##\n    # Returns the resolution of the photo. You can optionally specify the\n    # units measurement.\n    #\n    # @example\n    #   image.resolution(\"PixelsPerInch\") #=> [250, 250]\n    # @see http://www.imagemagick.org/script/command-line-options.php#units\n    # @return [Array<Integer>]\n    #\n    attribute :resolution\n    ##\n    # Returns the message digest of this image as a SHA-256, hexidecimal\n    # encoded string. This signature uniquely identifies the image and is\n    # convenient for determining if an image has been modified or whether two\n    # images are identical.\n    #\n    # @example\n    #   image.signature #=> \"60a7848c4ca6e36b8e2c5dea632ecdc29e9637791d2c59ebf7a54c0c6a74ef7e\"\n    # @see http://www.imagemagick.org/api/signature.php\n    # @return [String]\n    #\n    attribute :signature\n    ##\n    # Returns the information from `identify -verbose` in a Hash format, for\n    # ImageMagick.\n    #\n    # @return [Hash]\n    attribute :data\n    ##\n    # Returns the information from `identify -verbose` in a Hash format, for\n    # GraphicsMagick.\n    #\n    # @return [Hash]\n    attribute :details\n\n    ##\n    # Use this method if you want to access raw Identify's format API.\n    #\n    # @example\n    #    image[\"%w %h\"]       #=> \"250 450\"\n    #    image[\"%r\"]          #=> \"DirectClass sRGB\"\n    #\n    # @param value [String]\n    # @see http://www.imagemagick.org/script/escape.php\n    # @return [String]\n    #\n    def [](value)\n      @info[value.to_s]\n    end\n    alias info []\n\n    ##\n    # Returns layers of the image. For example, JPEGs are 1-layered, but\n    # formats like PSDs, GIFs and PDFs can have multiple layers/frames/pages.\n    #\n    # @example\n    #   image = MiniMagick::Image.new(\"document.pdf\")\n    #   image.pages.each_with_index do |page, idx|\n    #     page.write(\"page#{idx}.pdf\")\n    #   end\n    # @return [Array<MiniMagick::Image>]\n    #\n    def layers\n      layers_count = identify.lines.count\n      layers_count.times.map do |idx|\n        MiniMagick::Image.new(\"#{path}[#{idx}]\")\n      end\n    end\n    alias pages layers\n    alias frames layers\n\n    ##\n    # Returns a matrix of pixels from the image. The matrix is constructed as\n    # an array (1) of arrays (2) of arrays (3) of unsigned integers:\n    #\n    # 1) one for each row of pixels\n    # 2) one for each column of pixels\n    # 3) three elements in the range 0-255, one for each of the RGB color channels\n    #\n    # @example\n    #   img = MiniMagick::Image.open 'image.jpg'\n    #   pixels = img.get_pixels\n    #   pixels[3][2][1] # the green channel value from the 4th-row, 3rd-column pixel\n    #\n    # It can also be called after applying transformations:\n    #\n    # @example\n    #   img = MiniMagick::Image.open 'image.jpg'\n    #   img.crop '20x30+10+5'\n    #   img.colorspace 'Gray'\n    #   pixels = img.get_pixels\n    #\n    # In this example, all pixels in pix should now have equal R, G, and B values.\n    #\n    # @return [Array] Matrix of each color of each pixel\n    def get_pixels\n      convert = MiniMagick::Tool::Convert.new\n      convert << path\n      convert.depth(8)\n      convert << \"RGB:-\"\n\n      # Do not use `convert.call` here. We need the whole binary (unstripped) output here.\n      shell = MiniMagick::Shell.new\n      output, * = shell.run(convert.command)\n\n      pixels_array = output.unpack(\"C*\")\n      pixels = pixels_array.each_slice(3).each_slice(width).to_a\n\n      # deallocate large intermediary objects\n      output.clear\n      pixels_array.clear\n\n      pixels\n    end\n\n    ##\n    # This is used to change the format of the image. That is, from \"tiff to\n    # jpg\" or something like that. Once you run it, the instance is pointing to\n    # a new file with a new extension!\n    #\n    # *DANGER*: This renames the file that the instance is pointing to. So, if\n    # you manually opened the file with Image.new(file_path)... Then that file\n    # is DELETED! If you used Image.open(file) then you are OK. The original\n    # file will still be there. But, any changes to it might not be...\n    #\n    # Formatting an animation into a non-animated type will result in\n    # ImageMagick creating multiple pages (starting with 0).  You can choose\n    # which page you want to manipulate.  We default to the first page.\n    #\n    # If you would like to convert between animated formats, pass nil as your\n    # page and ImageMagick will copy all of the pages.\n    #\n    # @param format [String] The target format... Like 'jpg', 'gif', 'tiff' etc.\n    # @param page [Integer] If this is an animated gif, say which 'page' you\n    #   want with an integer. Default 0 will convert only the first page; 'nil'\n    #   will convert all pages.\n    # @param read_opts [Hash] Any read options to be passed to ImageMagick\n    #   for example: image.format('jpg', page, {density: '300'})\n    # @yield [MiniMagick::Tool::Convert] It optionally yields the command,\n    #   if you want to add something.\n    # @return [self]\n    #\n    def format(format, page = 0, read_opts={})\n      if @tempfile\n        new_tempfile = MiniMagick::Utilities.tempfile(\".#{format}\")\n        new_path = new_tempfile.path\n      else\n        new_path = Pathname(path).sub_ext(\".#{format}\").to_s\n      end\n\n      input_path = path.dup\n      input_path << \"[#{page}]\" if page && !layer?\n\n      MiniMagick::Tool::Convert.new do |convert|\n        read_opts.each do |opt, val|\n          convert.send(opt.to_s, val)\n        end\n        convert << input_path\n        yield convert if block_given?\n        convert << new_path\n      end\n\n      if @tempfile\n        destroy!\n        @tempfile = new_tempfile\n      else\n        File.delete(path) unless path == new_path || layer?\n      end\n\n      path.replace new_path\n      @info.clear\n\n      self\n    end\n\n    ##\n    # You can use multiple commands together using this method. Very easy to\n    # use!\n    #\n    # @example\n    #   image.combine_options do |c|\n    #     c.draw \"image Over 0,0 10,10 '#{MINUS_IMAGE_PATH}'\"\n    #     c.thumbnail \"300x500>\"\n    #     c.background \"blue\"\n    #   end\n    #\n    # @yield [MiniMagick::Tool::Mogrify]\n    # @see http://www.imagemagick.org/script/mogrify.php\n    # @return [self]\n    #\n    def combine_options(&block)\n      mogrify(&block)\n    end\n\n    ##\n    # If an unknown method is called then it is sent through the mogrify\n    # program.\n    #\n    # @see http://www.imagemagick.org/script/mogrify.php\n    # @return [self]\n    #\n    def method_missing(name, *args)\n      mogrify do |builder|\n        builder.send(name, *args)\n      end\n    end\n\n    def respond_to_missing?(method_name, include_private = false)\n      MiniMagick::Tool::Mogrify.option_methods.include?(method_name.to_s)\n    end\n\n    ##\n    # Writes the temporary file out to either a file location (by passing in a\n    # String) or by passing in a Stream that you can #write(chunk) to\n    # repeatedly\n    #\n    # @param output_to [String, Pathname, #read] Some kind of stream object\n    #   that needs to be read or a file path as a String\n    #\n    def write(output_to)\n      case output_to\n      when String, Pathname\n        if layer?\n          MiniMagick::Tool::Convert.new do |builder|\n            builder << path\n            builder << output_to\n          end\n        else\n          FileUtils.copy_file path, output_to unless path == output_to.to_s\n        end\n      else\n        IO.copy_stream File.open(path, \"rb\"), output_to\n      end\n    end\n\n    ##\n    # @example\n    #  first_image = MiniMagick::Image.open \"first.jpg\"\n    #  second_image = MiniMagick::Image.open \"second.jpg\"\n    #  result = first_image.composite(second_image) do |c|\n    #    c.compose \"Over\" # OverCompositeOp\n    #    c.geometry \"+20+20\" # copy second_image onto first_image from (20, 20)\n    #  end\n    #  result.write \"output.jpg\"\n    #\n    # @see http://www.imagemagick.org/script/composite.php\n    #\n    def composite(other_image, output_extension = type.downcase, mask = nil)\n      output_tempfile = MiniMagick::Utilities.tempfile(\".#{output_extension}\")\n\n      MiniMagick::Tool::Composite.new do |composite|\n        yield composite if block_given?\n        composite << other_image.path\n        composite << path\n        composite << mask.path if mask\n        composite << output_tempfile.path\n      end\n\n      Image.new(output_tempfile.path, output_tempfile)\n    end\n\n    ##\n    # Collapse images with sequences to the first frame (i.e. animated gifs) and\n    # preserve quality.\n    #\n    # @param frame [Integer] The frame to which to collapse to, defaults to `0`.\n    # @return [self]\n    #\n    def collapse!(frame = 0)\n      mogrify(frame) { |builder| builder.quality(100) }\n    end\n\n    ##\n    # Destroys the tempfile (created by {.open}) if it exists.\n    #\n    def destroy!\n      if @tempfile\n        FileUtils.rm_f @tempfile.path.sub(/mpc$/, \"cache\") if @tempfile.path.end_with?(\".mpc\")\n        @tempfile.unlink\n      end\n    end\n\n    ##\n    # Runs `identify` on itself. Accepts an optional block for adding more\n    # options to `identify`.\n    #\n    # @example\n    #   image = MiniMagick::Image.open(\"image.jpg\")\n    #   image.identify do |b|\n    #     b.verbose\n    #   end # runs `identify -verbose image.jpg`\n    # @return [String] Output from `identify`\n    # @yield [MiniMagick::Tool::Identify]\n    #\n    def identify\n      MiniMagick::Tool::Identify.new do |builder|\n        yield builder if block_given?\n        builder << path\n      end\n    end\n\n    # @private\n    def run_command(tool_name, *args)\n      MiniMagick::Tool.const_get(tool_name.capitalize).new do |builder|\n        args.each do |arg|\n          builder << arg\n        end\n      end\n    end\n\n    def mogrify(page = nil)\n      MiniMagick::Tool::MogrifyRestricted.new do |builder|\n        yield builder if block_given?\n        builder << (page ? \"#{path}[#{page}]\" : path)\n      end\n\n      @info.clear\n\n      self\n    end\n\n    def layer?\n      path =~ /\\[\\d+\\]$/\n    end\n  end\nend\n", "require \"spec_helper\"\nrequire \"pathname\"\nrequire \"tempfile\"\nrequire \"fileutils\"\nrequire \"stringio\"\nrequire \"webmock/rspec\"\n\n[\"ImageMagick\", \"GraphicsMagick\"].each do |cli|\n  RSpec.context \"With #{cli}\", cli: cli.downcase.to_sym do\n    describe MiniMagick::Image do\n      subject { described_class.open(image_path) }\n\n      describe \".read\" do\n        it \"reads image from String\" do\n          string = File.binread(image_path)\n          image = described_class.read(string)\n          expect(image).to be_valid\n        end\n\n        it \"reads image from StringIO\" do\n          stringio = StringIO.new(File.binread(image_path))\n          image = described_class.read(stringio)\n          expect(image).to be_valid\n        end\n\n        it \"reads image from tempfile\" do\n          tempfile = Tempfile.open('magick')\n          FileUtils.cp image_path, tempfile.path\n          image = described_class.read(tempfile)\n          expect(image).to be_valid\n        end\n      end\n\n      describe \".import_pixels\" do\n        let(:dimensions) { [325, 200] }\n        let(:depth)      { 16 } # 16 bits (2 bytes) per pixel\n        let(:map)        { 'gray' }\n        let(:pixels)     { Array.new(dimensions.inject(:*)) { |i| i } }\n        let(:blob)       { pixels.pack('S*') } # unsigned short, native byte order\n\n        it \"can import pixels with default format\" do\n          image = described_class.import_pixels(blob, *dimensions, depth, map)\n\n          expect(image).to be_valid\n          expect(image.type).to eq 'PNG'\n          expect(image.dimensions).to eq dimensions\n        end\n\n        it \"can import pixels with custom format\" do\n          image = described_class.import_pixels(blob, *dimensions, depth, map, 'jpeg')\n\n          expect(image).to be_valid\n          expect(image.type).to eq 'JPEG'\n          expect(image.dimensions).to eq dimensions\n        end\n      end\n\n      describe \".open\" do\n        it \"makes a copy of the image\" do\n          image = described_class.open(image_path)\n          expect(image.path).not_to eq image_path\n          expect(image).to be_valid\n          expect(File.extname(image.path)).to eq File.extname(image_path)\n        end\n\n        it \"accepts a Pathname\" do\n          image = described_class.open(Pathname(image_path))\n          expect(image).to be_valid\n        end\n\n        it \"loads a remote image\" do\n          stub_request(:get, \"http://example.com/image.jpg\")\n            .to_return(body: File.read(image_path))\n          image = described_class.open(\"http://example.com/image.jpg\")\n          expect(image).to be_valid\n          expect(File.extname(image.path)).to eq \".jpg\"\n        end\n\n        it \"accepts open-uri options\" do\n          stub_request(:get, \"http://example.com/image.jpg\")\n            .with(headers: {\"Foo\" => \"Bar\"})\n            .to_return(body: File.read(image_path))\n          described_class.open(\"http://example.com/image.jpg\", {\"Foo\" => \"Bar\"})\n          described_class.open(\"http://example.com/image.jpg\", \".jpg\", {\"Foo\" => \"Bar\"})\n        end\n\n        it \"strips out colons from URL\" do\n          stub_request(:get, \"http://example.com/image.jpg:large\")\n            .to_return(body: File.read(image_path))\n          image = described_class.open(\"http://example.com/image.jpg:large\")\n          expect(File.extname(image.path)).to eq \".jpg\"\n        end\n\n        it \"validates the image\" do\n          expect { described_class.open(image_path(:not)) }\n            .to raise_error(MiniMagick::Invalid)\n        end\n\n        it \"does not mistake a path with a colon for a URI schema\" do\n          expect { described_class.open(image_path(:colon)) }\n            .not_to raise_error\n        end\n      end\n\n      describe \".create\" do\n        def create(path = image_path)\n          described_class.create do |f|\n            f.write(File.binread(path))\n          end\n        end\n\n        it \"creates an image\" do\n          image = create\n          expect(File.exists?(image.path)).to eq true\n        end\n\n        it \"validates the image if validation is set\" do\n          allow(MiniMagick).to receive(:validate_on_create).and_return(true)\n          expect { create(image_path(:not)) }\n            .to raise_error(MiniMagick::Invalid)\n        end\n\n        it \"doesn't validate image if validation is disabled\" do\n          allow(MiniMagick).to receive(:validate_on_create).and_return(false)\n          expect { create(image_path(:not)) }\n            .not_to raise_error\n        end\n      end\n\n      describe \"#initialize\" do\n        it \"initializes a new image\" do\n          image = described_class.new(image_path)\n          expect(image).to be_valid\n        end\n\n        it \"accepts a Pathname\" do\n          image = described_class.new(Pathname(image_path))\n          expect(image.path).to be_a(String)\n        end\n\n        it \"accepts a block which it passes on to #combine_options\" do\n          image = described_class.new(subject.path) do |b|\n            b.resize \"100x100!\"\n          end\n          expect(image.dimensions).to eq [100, 100]\n        end\n      end\n\n      describe \"equivalence\" do\n        subject(:image) { described_class.new(image_path) }\n        let(:same_image) { described_class.new(image_path) }\n        let(:other_image) { described_class.new(image_path(:exif)) }\n\n        it \"is #== and #eql? to itself\" do\n          expect(image).to eq(image)\n          expect(image).to eql(image)\n        end\n\n        it \"is #== and #eql? to an instance of the same image\" do\n          expect(image).to eq(same_image)\n          expect(image).to eql(same_image)\n        end\n\n        it \"is not #== nor #eql? to an instance of a different image\" do\n          expect(image).not_to eq(other_image)\n          expect(image).not_to eql(other_image)\n        end\n\n        it \"generates the same hash code for an instance of the same image\" do\n          expect(image.hash).to eq(same_image.hash)\n        end\n\n        it \"generates different same hash codes for a different image\" do\n          expect(image.hash).not_to eq(other_image.hash)\n        end\n      end\n\n      describe \"#tempfile\" do\n        it \"returns the underlying temporary file\" do\n          image = described_class.open(image_path)\n\n          expect(image.tempfile).to be_a(Tempfile)\n        end\n      end\n\n      describe \"#format\" do\n        subject { described_class.open(image_path(:jpg)) }\n\n        it \"changes the format of the photo\" do\n          expect { subject.format(\"png\") }\n            .to change { subject.type }\n        end\n\n        it \"reformats an image with a given extension\" do\n          expect { subject.format('png') }\n            .to change { File.extname(subject.path) }.to \".png\"\n        end\n\n        it \"creates the file with new extension\" do\n          subject.format('png')\n          expect(File.exist?(subject.path)).to eq true\n        end\n\n        it \"accepts a block of additional commands\" do\n          expect {\n            subject.format(\"png\") do |b|\n              b.resize(\"100x100!\")\n            end\n          }.to change { subject.dimensions }.to [100, 100]\n        end\n\n        it \"works without an extension with .open\" do\n          subject = described_class.open(image_path(:jpg_without_extension))\n          subject.format(\"png\")\n\n          expect(File.extname(subject.path)).to eq \".png\"\n          expect(subject.type).to eq \"PNG\"\n        end\n\n        it \"works without an extension with .new\" do\n          subject = described_class.new(image_path(:jpg_without_extension))\n          subject.format(\"png\")\n\n          expect(File.extname(subject.path)).to eq \".png\"\n          expect(subject.type).to eq \"PNG\"\n        end\n\n        it \"deletes the previous tempfile\" do\n          old_path = subject.path.dup\n          subject.format('png')\n          expect(File.exist?(old_path)).to eq false\n        end\n\n        it \"deletes *.cache files generated from .mpc\" do\n          image = described_class.open(image_path)\n          image.format(\"mpc\")\n          cache_path = image.path.sub(/mpc$/, \"cache\")\n          image.format(\"png\")\n\n          expect(File.exists?(cache_path)).to eq false\n        end\n\n        it \"doesn't delete itself when formatted to the same format\" do\n          subject.format(subject.type.downcase)\n          expect(File.exists?(subject.path)).to eq true\n        end\n\n        it \"reformats multi-image formats to multiple images\" do\n          subject = described_class.open(image_path(:animation))\n          subject.format('jpg', nil)\n          expect(Dir[subject.path.sub('.', '*.')]).not_to be_empty\n        end\n\n        it \"reformats multi-image formats to a single image\" do\n          subject = described_class.open(image_path(:animation))\n          subject.format('jpg')\n          expect(subject).to be_valid\n        end\n\n        it \"reformats a layer\" do\n          subject = described_class.open(image_path(:animation))\n          layer = subject.layers.first\n          layer.format('jpg')\n          expect(layer).to be_valid\n          expect(layer.path[/\\..+$/]).to eq \".jpg\"\n          expect(File.exist?(layer.path)).to eq true\n        end\n\n        it \"clears the info only at the end\" do\n          subject.format('png') { subject.type }\n          expect(subject.type).to eq \"PNG\"\n        end\n\n        it \"returns self\" do\n          expect(subject.format('png')).to eq subject\n        end\n\n        it \"reads read_opts from passed arguments\" do\n          subject = described_class.open(image_path(:animation))\n          layer = subject.layers.first\n          layer.format('jpg', nil, {density: '300'})\n          expect(layer).to be_valid\n\n        end\n      end\n\n      describe \"#write\" do\n        it \"writes the image\" do\n          output_path = random_path(\"test output\")\n          subject.write(output_path)\n          expect(described_class.new(output_path)).to be_valid\n        end\n\n        it \"writes an image with stream\" do\n          output_stream = StringIO.new\n          subject.write(output_stream)\n          expect(described_class.read(output_stream.string)).to be_valid\n        end\n\n        it \"writes layers\" do\n          output_path = random_path([\"\", \".#{subject.type.downcase}\"])\n          subject = described_class.new(image_path(:gif))\n          subject.frames.first.write(output_path)\n          expect(described_class.new(output_path)).to be_valid\n        end\n\n        it \"accepts a Pathname\" do\n          output_path = Pathname(random_path)\n          subject.write(output_path)\n          expect(described_class.new(output_path.to_s)).to be_valid\n        end\n\n        it \"works when writing to the same path\" do\n          subject.write(subject.path)\n          expect(File.read(subject.path)).not_to be_empty\n        end\n      end\n\n      describe \"#valid?\" do\n        it \"returns true when image is valid\" do\n          image = described_class.new(image_path)\n          expect(image).to be_valid\n        end\n\n        it \"returns false when image is not valid\" do\n          image = described_class.new(image_path(:not))\n          expect(image).not_to be_valid\n        end\n      end\n\n      describe \"#[]\" do\n        it \"inspects image meta info\" do\n          expect(subject[:width]).to be_a(Integer)\n          expect(subject[:height]).to be_a(Integer)\n          expect(subject[:dimensions]).to all(be_a(Integer))\n          expect(subject[:colorspace]).to be_a(String)\n          expect(subject[:format]).to match(/[A-Z]/)\n          expect(subject[:signature]).to match(/[[:alnum:]]{64}/)\n        end\n\n        it \"supports string keys\" do\n          expect(subject[\"width\"]).to be_a(Integer)\n          expect(subject[\"height\"]).to be_a(Integer)\n          expect(subject[\"dimensions\"]).to all(be_a(Integer))\n          expect(subject[\"colorspace\"]).to be_a(String)\n          expect(subject[\"format\"]).to match(/[A-Z]/)\n          expect(subject['signature']).to match(/[[:alnum:]]{64}/)\n        end\n\n        it \"reads exif\" do\n          subject = described_class.new(image_path(:exif))\n          expect(subject[\"EXIF:Flash\"]).to eq \"0\"\n        end\n\n        it \"passes unknown values directly to -format\" do\n          expect(subject[\"%w %h\"].split.map(&:to_i)).to eq [subject[:width], subject[:height]]\n        end\n      end\n\n      it \"has attributes\" do\n        expect(subject.type).to match(/^[A-Z]+$/)\n        expect(subject.mime_type).to match(/^image\\/[a-z]+$/)\n        expect(subject.width).to be_a(Integer).and be_nonzero\n        expect(subject.height).to be_a(Integer).and be_nonzero\n        expect(subject.dimensions).to all(be_a(Integer))\n        expect(subject.size).to be_a(Integer).and be_nonzero\n        expect(subject.human_size).to be_a(String).and be_nonempty\n        expect(subject.colorspace).to be_a(String)\n        expect(subject.resolution).to all(be_a(Integer))\n        expect(subject.signature).to match(/[[:alnum:]]{64}/)\n      end\n\n      it \"generates attributes of layers\" do\n        expect(subject.layers[0].type).to match(/^[A-Z]+$/)\n        expect(subject.layers[0].size).to be > 0\n      end\n\n      it \"changes colorspace when called with an argument\" do\n        expect_any_instance_of(MiniMagick::Tool::Mogrify).to receive(:call)\n        subject.colorspace(\"Gray\")\n      end\n\n      it \"changes size when called with an argument\" do\n        expect_any_instance_of(MiniMagick::Tool::Mogrify).to receive(:call)\n        subject.size(\"20x20\")\n      end\n\n      describe \"#exif\" do\n        it \"returns a hash of EXIF data\" do\n          subject = described_class.new(image_path(:exif))\n          expect(subject.exif[\"DateTimeOriginal\"]).to be_a(String)\n        end\n\n        it \"decodes the ExifVersion\" do\n          subject = described_class.new(image_path(:exif))\n          expect(subject.exif[\"ExifVersion\"]).to eq(\"0220\")\n        end unless ENV[\"CI\"]\n\n        it \"handles no EXIF data\" do\n          subject = described_class.new(image_path(:no_exif))\n          expect(subject.exif).to eq({})\n        end\n      end\n\n      describe \"#resolution\" do\n        it \"accepts units\", skip_cli: :graphicsmagick do\n          expect(subject.resolution(\"PixelsPerCentimeter\"))\n            .not_to eq subject.resolution(\"PixelsPerInch\")\n        end\n      end\n\n      describe \"#mime_type\" do\n        it \"returns the correct mime type\" do\n          jpg = described_class.new(image_path(:jpg))\n          expect(jpg.mime_type).to eq 'image/jpeg'\n        end\n      end\n\n      describe \"#details\" do\n        it \"returns a hash of verbose information\" do\n          expect(subject.details[\"Format\"]).to match /^JPEG/\n          if MiniMagick.cli == :imagemagick\n            if Gem::Version.new(MiniMagick.cli_version) < Gem::Version.new('7.0.0')\n              expect(subject.details[\"Channel depth\"][\"red\"]).to eq \"8-bit\"\n            else\n              expect(subject.details[\"Channel depth\"][\"Red\"]).to eq \"8-bit\"\n            end\n\n            expect(subject.details).to have_key(\"Background color\")\n            expect(subject.details[\"Properties\"]).to have_key(\"date:create\")\n          else\n            expect(subject.details[\"Channel Depths\"][\"Red\"]).to eq \"8 bits\"\n            expect(subject.details).to have_key(\"Resolution\")\n          end\n        end\n\n        context \"when verbose information includes an empty line\" do\n          subject { described_class.new(image_path(:empty_identify_line)) }\n\n          it \"skips the empty line\" do\n            if MiniMagick.cli == :imagemagick\n              expect(subject.details[\"Properties\"]).to have_key(\"date:create\")\n            else\n              expect(subject.details).to have_key(\"Date:create\")\n            end\n          end\n        end\n\n        context \"when verbose information includes a badly encoded line do\", skip_cli: :graphicsmagick do\n          subject { described_class.new(image_path(:badly_encoded_line)) }\n\n          it \"skips the badly encoded line\" do\n            expect(subject.details).not_to have_key(\"Software\")\n          end\n        end\n\n        # GraphicsMagick does not output the clipping path\n        context \"when verbose information includes a clipping path\", skip_cli: :graphicsmagick do\n          subject { described_class.new(image_path(:clipping_path)) }\n\n          it \"does not hang when parsing verbose data\" do\n            # Retrieving .details should happen very quickly but as of v4.3.6\n            # will hang indefinitely without the timeout\n            Timeout::timeout(10) do\n              expect(subject.details['Clipping path'][0..4]).to eq \"<?xml\"\n            end\n          end\n        end\n      end\n\n      describe \"#data\" do\n        describe \"when the data return is not an array\" do\n          subject { described_class.new(image_path(:jpg)) }\n\n          it \"returns image JSON data\", skip_cli: :graphicsmagick do\n            expect(subject.data[\"format\"]).to eq \"JPEG\"\n            expect(subject.data[\"colorspace\"]).to eq \"sRGB\"\n          end\n        end\n\n        describe \"when the data return is an array (ex png)\" do\n          subject { described_class.new(image_path(:png)) }\n\n          it \"returns image JSON data\", skip_cli: :graphicsmagick do\n            expect(subject.data[\"format\"]).to eq \"PNG\"\n            expect(subject.data[\"colorspace\"]).to eq \"sRGB\"\n          end\n        end\n      end unless ENV[\"CI\"] # problems installing newer ImageMagick versions on CI\n\n      describe \"#layers\" do\n        it \"returns a list of images\" do\n          expect(subject.layers).to all(be_a(MiniMagick::Image))\n          expect(subject.layers.first).to be_valid\n        end\n\n        it \"returns multiple images for GIFs, PDFs and PSDs\" do\n          gif = described_class.new(image_path(:gif))\n\n          expect(gif.layers.count).to be > 1\n          expect(gif.frames.count).to be > 1\n          expect(gif.pages.count).to be > 1\n        end\n\n        it \"returns one image for other formats\" do\n          jpg = described_class.new(image_path(:jpg))\n\n          expect(jpg.layers.count).to eq 1\n        end\n      end\n\n      describe \"#get_pixels\" do\n        let(:magenta) { [255,   0, 255] }\n        let(:gray)    { [128, 128, 128] }\n        let(:green)   { [  0, 255,   0] }\n        let(:cyan)    { [  0, 255, 255] }\n        let(:pix)     { subject.get_pixels }\n\n        subject { described_class.open(image_path(:rgb)) }\n\n        context \"without modifications\" do\n          it \"returns a width-by-height matrix\" do\n            pix.each do |row|\n              expect(row.length).to eq(subject.width)\n            end\n          end\n\n          it(\"returns a magenta pixel\") { expect(pix[3][3]  ).to eq(magenta) }\n          it(\"returns a gray pixel\")    { expect(pix[-4][-4]).to eq(gray)    }\n          it(\"returns a green pixel\")   { expect(pix[3][-4] ).to eq(green)   }\n          it(\"returns a cyan pixel\")    { expect(pix[-4][3] ).to eq(cyan)    }\n        end\n\n        context \"after cropping\" do\n          let(:cols)    { 10 }\n          let(:rows)    {  6 }\n\n          before { subject.crop \"#{cols}x#{rows}+3+3\" }\n\n          it \"returns a matrix of the requested height\" do\n            expect(pix.length).to eq(rows)\n          end\n\n          it \"returns a matrix of the requested width\" do\n            pix.each do |x|\n              expect(x.length).to eq(cols)\n            end\n          end\n\n          it(\"returns a magenta pixel\") { expect(pix[0][0]  ).to eq(magenta)}\n          it(\"returns a gray pixel\")    { expect(pix[-1][-1]).to eq(gray)   }\n          it(\"returns a cyan pixel\")    { expect(pix[-1][0] ).to eq(cyan)   }\n          it(\"returns a green pixel\")   { expect(pix[0][-1] ).to eq(green)  }\n        end\n\n        context \"after resizing and desaturating\" do\n          let(:cols) { 8 }\n          let(:rows) { 6 }\n\n          before {\n            subject.resize \"50%\"\n            subject.colorspace \"Gray\"\n          }\n\n          it \"returns a matrix of the requested height\" do\n            expect(pix.length).to eq(rows)\n          end\n\n          it \"returns a matrix of the requested width\" do\n            pix.each do |x|\n              expect(x.length).to eq(cols)\n            end\n          end\n\n          it \"returns gray pixels\" do\n            pix.each do |row|\n              row.each do |px|\n                expect(px[0]).to eq px[1]\n                expect(px[0]).to eq px[2]\n              end\n            end\n          end\n        end\n\n        context \"when first or last byte could be interpreted as control characters\" do\n          subject { described_class.open(image_path(:get_pixels)) }\n\n          it \"returns a matrix where all pixel has 3 values\" do\n            pix.each do |row|\n              row.each do |px|\n                expect(px.length).to eq(3)\n              end\n            end\n          end\n        end\n      end\n\n      describe \"missing methods\" do\n        context \"for a known method\" do\n          it \"is executed by #method_missing\" do\n            expect { subject.resize '20x30!' }\n              .to change { subject.dimensions }.to [20, 30]\n          end\n\n          it \"returns self\" do\n            expect(subject.resize('20x30!')).to eq subject\n          end\n\n          it \"can be responded to\" do\n            expect(subject.respond_to?(:gravity)).to eq true\n            expect(subject.respond_to?(:bla)).to eq false\n          end\n        end\n      end\n\n      describe \"#combine_options\" do\n        it \"chains multiple options and executes them in one command\" do\n          expect {\n            subject.combine_options { |c| c.resize '20x30!' }\n          }.to change { subject.dimensions }.to [20, 30]\n        end\n\n        it \"doesn't allow calling of #format\" do\n          expect { subject.combine_options { |c| c.format(\"png\") } }\n            .to raise_error(NoMethodError)\n        end\n\n        it \"clears the info only at the end\" do\n          subject.combine_options { |c| c.resize('20x30!'); subject.width }\n          expect(subject.dimensions).to eq [20, 30]\n        end\n\n        it \"returns self\" do\n          expect(subject.combine_options {}).to eq subject\n        end\n      end\n\n      describe \"#composite\" do\n        let(:other_image) { described_class.open(image_path) }\n        let(:mask) { described_class.open(image_path) }\n\n        it \"creates a composite of two images\" do\n          image = subject.composite(other_image)\n          expect(image).to be_valid\n        end\n\n        it \"creates a composite of two images with mask\" do\n          image = subject.composite(other_image, 'jpg', mask)\n          expect(image).to be_valid\n        end\n\n        it \"yields an optional block\" do\n          expect { |b| subject.composite(other_image, &b) }\n            .to yield_with_args(an_instance_of(MiniMagick::Tool::Composite))\n        end\n\n        it \"makes the composited image with the provided extension\" do\n          result = subject.composite(other_image, 'png')\n          expect(result.path).to end_with \".png\"\n        end\n\n        it \"defaults the extension to the extension of the base image\" do\n          subject = described_class.open(image_path(:jpg))\n          result = subject.composite(other_image)\n          expect(result.path).to end_with \".jpeg\"\n\n          subject = described_class.open(image_path(:gif))\n          result = subject.composite(other_image)\n          expect(result.path).to end_with \".gif\"\n        end\n      end\n\n      describe \"#collapse!\" do\n        subject { described_class.open(image_path(:animation)) }\n\n        it \"collapses the image to one frame\" do\n          subject.collapse!\n          expect(subject.identify.lines.count).to eq 1\n        end\n\n        it \"keeps the extension\" do\n          expect { subject.collapse! }\n            .not_to change { subject.type }\n        end\n\n        it \"clears the info\" do\n          expect { subject.collapse! }\n            .to change { subject.size }\n        end\n\n        it \"returns self\" do\n          expect(subject.collapse!).to eq subject\n        end\n      end\n\n      describe \"#destroy!\" do\n        it \"deletes the underlying tempfile\" do\n          image = described_class.open(image_path)\n          image.destroy!\n\n          expect(File.exists?(image.path)).to eq false\n        end\n\n        it \"doesn't delete when there is no tempfile\" do\n          image = described_class.new(image_path)\n          image.destroy!\n\n          expect(File.exists?(image.path)).to eq true\n        end\n\n        it \"deletes .cache files generated by handling .mpc files\" do\n          image = described_class.open(image_path)\n          image.format(\"mpc\")\n          image.destroy!\n\n          expect(File.exists?(image.path.sub(/mpc$/, \"cache\"))).to eq false\n        end\n      end\n\n      describe \"#identify\" do\n        it \"returns the output of identify\" do\n          expect(subject.identify).to match(subject.type)\n        end\n\n        it \"yields an optional block\" do\n          output = subject.identify do |b|\n            b.verbose\n          end\n          expect(output).to match(\"Format:\")\n        end\n      end\n\n      describe \"#run_command\" do\n        it \"runs the given command\" do\n          output = subject.run_command(\"identify\", \"-format\", \"%w\", subject.path)\n          expect(output).to eq subject.width.to_s\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["require 'tempfile'\nrequire 'stringio'\nrequire 'pathname'\nrequire 'uri'\nrequire 'open-uri'\n\nrequire 'mini_magick/image/info'\nrequire 'mini_magick/utilities'\n\nmodule MiniMagick\n  class Image\n\n    ##\n    # This is the primary loading method used by all of the other class\n    # methods.\n    #\n    # Use this to pass in a stream object. Must respond to #read(size) or be a\n    # binary string object (BLOBBBB)\n    #\n    # Probably easier to use the {.open} method if you want to open a file or a\n    # URL.\n    #\n    # @param stream [#read, String] Some kind of stream object that needs\n    #   to be read or is a binary String blob\n    # @param ext [String] A manual extension to use for reading the file. Not\n    #   required, but if you are having issues, give this a try.\n    # @return [MiniMagick::Image]\n    #\n    def self.read(stream, ext = nil)\n      if stream.is_a?(String)\n        stream = StringIO.new(stream)\n      end\n\n      create(ext) { |file| IO.copy_stream(stream, file) }\n    end\n\n    ##\n    # Creates an image object from a binary string blob which contains raw\n    # pixel data (i.e. no header data).\n    #\n    # @param blob [String] Binary string blob containing raw pixel data.\n    # @param columns [Integer] Number of columns.\n    # @param rows [Integer] Number of rows.\n    # @param depth [Integer] Bit depth of the encoded pixel data.\n    # @param map [String] A code for the mapping of the pixel data. Example:\n    #   'gray' or 'rgb'.\n    # @param format [String] The file extension of the image format to be\n    #   used when creating the image object.\n    # Defaults to 'png'.\n    # @return [MiniMagick::Image] The loaded image.\n    #\n    def self.import_pixels(blob, columns, rows, depth, map, format = 'png')\n      # Create an image object with the raw pixel data string:\n      create(\".dat\", false) { |f| f.write(blob) }.tap do |image|\n        output_path = image.path.sub(/\\.\\w+$/, \".#{format}\")\n        # Use ImageMagick to convert the raw data file to an image file of the\n        # desired format:\n        MiniMagick::Tool::Convert.new do |convert|\n          convert.size \"#{columns}x#{rows}\"\n          convert.depth depth\n          convert << \"#{map}:#{image.path}\"\n          convert << output_path\n        end\n\n        image.path.replace output_path\n      end\n    end\n\n    ##\n    # Opens a specific image file either on the local file system or at a URI.\n    # Use this if you don't want to overwrite the image file.\n    #\n    # Extension is either guessed from the path or you can specify it as a\n    # second parameter.\n    #\n    # @param path_or_url [String] Either a local file path or a URL that\n    #   open-uri can read\n    # @param ext [String] Specify the extension you want to read it as\n    # @param options [Hash] Specify options for the open method\n    # @return [MiniMagick::Image] The loaded image\n    #\n    def self.open(path_or_url, ext = nil, options = {})\n      options, ext = ext, nil if ext.is_a?(Hash)\n\n      uri = URI(path_or_url.to_s)\n\n      ext ||= File.extname(uri.path)\n      ext.sub!(/:.*/, '') # hack for filenames or URLs that include a colon\n\n      if uri.is_a?(URI::HTTP) || uri.is_a?(URI::FTP)\n        uri.open(options) { |file| read(file, ext) }\n      else\n        File.open(uri.to_s, \"rb\", options) { |file| read(file, ext) }\n      end\n    end\n\n    ##\n    # Used to create a new Image object data-copy. Not used to \"paint\" or\n    # that kind of thing.\n    #\n    # Takes an extension in a block and can be used to build a new Image\n    # object. Used by both {.open} and {.read} to create a new object. Ensures\n    # we have a good tempfile.\n    #\n    # @param ext [String] Specify the extension you want to read it as\n    # @param validate [Boolean] If false, skips validation of the created\n    #   image. Defaults to true.\n    # @yield [Tempfile] You can #write bits to this object to create the new\n    #   Image\n    # @return [MiniMagick::Image] The created image\n    #\n    def self.create(ext = nil, validate = MiniMagick.validate_on_create, &block)\n      tempfile = MiniMagick::Utilities.tempfile(ext.to_s.downcase, &block)\n\n      new(tempfile.path, tempfile).tap do |image|\n        image.validate! if validate\n      end\n    end\n\n    ##\n    # @private\n    # @!macro [attach] attribute\n    #   @!attribute [r] $1\n    #\n    def self.attribute(name, key = name.to_s)\n      define_method(name) do |*args|\n        if args.any? && name != :resolution\n          mogrify { |b| b.send(name, *args) }\n        else\n          @info[key, *args]\n        end\n      end\n    end\n\n    ##\n    # @return [String] The location of the current working file\n    #\n    attr_reader :path\n    ##\n    # @return [Tempfile] The underlying temporary file\n    #\n    attr_reader :tempfile\n\n    ##\n    # Create a new {MiniMagick::Image} object.\n    #\n    # _DANGER_: The file location passed in here is the *working copy*. That\n    # is, it gets *modified*. You can either copy it yourself or use {.open}\n    # which creates a temporary file for you and protects your original.\n    #\n    # @param input_path [String, Pathname] The location of an image file\n    # @yield [MiniMagick::Tool::Mogrify] If block is given, {#combine_options}\n    #   is called.\n    #\n    def initialize(input_path, tempfile = nil, &block)\n      @path = input_path.to_s\n      @tempfile = tempfile\n      @info = MiniMagick::Image::Info.new(@path)\n\n      combine_options(&block) if block\n    end\n\n    def ==(other)\n      self.class == other.class && signature == other.signature\n    end\n    alias eql? ==\n\n    def hash\n      signature.hash\n    end\n\n    ##\n    # Returns raw image data.\n    #\n    # @return [String] Binary string\n    #\n    def to_blob\n      File.binread(path)\n    end\n\n    ##\n    # Checks to make sure that MiniMagick can read the file and understand it.\n    #\n    # This uses the 'identify' command line utility to check the file. If you\n    # are having issues with this, then please work directly with the\n    # 'identify' command and see if you can figure out what the issue is.\n    #\n    # @return [Boolean]\n    #\n    def valid?\n      validate!\n      true\n    rescue MiniMagick::Invalid\n      false\n    end\n\n    ##\n    # Runs `identify` on the current image, and raises an error if it doesn't\n    # pass.\n    #\n    # @raise [MiniMagick::Invalid]\n    #\n    def validate!\n      identify\n    rescue MiniMagick::Error => error\n      raise MiniMagick::Invalid, error.message\n    end\n\n    ##\n    # Returns the image format (e.g. \"JPEG\", \"GIF\").\n    #\n    # @return [String]\n    #\n    attribute :type, \"format\"\n    ##\n    # @return [String]\n    #\n    attribute :mime_type\n    ##\n    # @return [Integer]\n    #\n    attribute :width\n    ##\n    # @return [Integer]\n    #\n    attribute :height\n    ##\n    # @return [Array<Integer>]\n    #\n    attribute :dimensions\n    ##\n    # Returns the file size of the image (in bytes).\n    #\n    # @return [Integer]\n    #\n    attribute :size\n    ##\n    # Returns the file size in a human readable format.\n    #\n    # @return [String]\n    #\n    attribute :human_size\n    ##\n    # @return [String]\n    #\n    attribute :colorspace\n    ##\n    # @return [Hash]\n    #\n    attribute :exif\n    ##\n    # Returns the resolution of the photo. You can optionally specify the\n    # units measurement.\n    #\n    # @example\n    #   image.resolution(\"PixelsPerInch\") #=> [250, 250]\n    # @see http://www.imagemagick.org/script/command-line-options.php#units\n    # @return [Array<Integer>]\n    #\n    attribute :resolution\n    ##\n    # Returns the message digest of this image as a SHA-256, hexidecimal\n    # encoded string. This signature uniquely identifies the image and is\n    # convenient for determining if an image has been modified or whether two\n    # images are identical.\n    #\n    # @example\n    #   image.signature #=> \"60a7848c4ca6e36b8e2c5dea632ecdc29e9637791d2c59ebf7a54c0c6a74ef7e\"\n    # @see http://www.imagemagick.org/api/signature.php\n    # @return [String]\n    #\n    attribute :signature\n    ##\n    # Returns the information from `identify -verbose` in a Hash format, for\n    # ImageMagick.\n    #\n    # @return [Hash]\n    attribute :data\n    ##\n    # Returns the information from `identify -verbose` in a Hash format, for\n    # GraphicsMagick.\n    #\n    # @return [Hash]\n    attribute :details\n\n    ##\n    # Use this method if you want to access raw Identify's format API.\n    #\n    # @example\n    #    image[\"%w %h\"]       #=> \"250 450\"\n    #    image[\"%r\"]          #=> \"DirectClass sRGB\"\n    #\n    # @param value [String]\n    # @see http://www.imagemagick.org/script/escape.php\n    # @return [String]\n    #\n    def [](value)\n      @info[value.to_s]\n    end\n    alias info []\n\n    ##\n    # Returns layers of the image. For example, JPEGs are 1-layered, but\n    # formats like PSDs, GIFs and PDFs can have multiple layers/frames/pages.\n    #\n    # @example\n    #   image = MiniMagick::Image.new(\"document.pdf\")\n    #   image.pages.each_with_index do |page, idx|\n    #     page.write(\"page#{idx}.pdf\")\n    #   end\n    # @return [Array<MiniMagick::Image>]\n    #\n    def layers\n      layers_count = identify.lines.count\n      layers_count.times.map do |idx|\n        MiniMagick::Image.new(\"#{path}[#{idx}]\")\n      end\n    end\n    alias pages layers\n    alias frames layers\n\n    ##\n    # Returns a matrix of pixels from the image. The matrix is constructed as\n    # an array (1) of arrays (2) of arrays (3) of unsigned integers:\n    #\n    # 1) one for each row of pixels\n    # 2) one for each column of pixels\n    # 3) three elements in the range 0-255, one for each of the RGB color channels\n    #\n    # @example\n    #   img = MiniMagick::Image.open 'image.jpg'\n    #   pixels = img.get_pixels\n    #   pixels[3][2][1] # the green channel value from the 4th-row, 3rd-column pixel\n    #\n    # It can also be called after applying transformations:\n    #\n    # @example\n    #   img = MiniMagick::Image.open 'image.jpg'\n    #   img.crop '20x30+10+5'\n    #   img.colorspace 'Gray'\n    #   pixels = img.get_pixels\n    #\n    # In this example, all pixels in pix should now have equal R, G, and B values.\n    #\n    # @return [Array] Matrix of each color of each pixel\n    def get_pixels\n      convert = MiniMagick::Tool::Convert.new\n      convert << path\n      convert.depth(8)\n      convert << \"RGB:-\"\n\n      # Do not use `convert.call` here. We need the whole binary (unstripped) output here.\n      shell = MiniMagick::Shell.new\n      output, * = shell.run(convert.command)\n\n      pixels_array = output.unpack(\"C*\")\n      pixels = pixels_array.each_slice(3).each_slice(width).to_a\n\n      # deallocate large intermediary objects\n      output.clear\n      pixels_array.clear\n\n      pixels\n    end\n\n    ##\n    # This is used to change the format of the image. That is, from \"tiff to\n    # jpg\" or something like that. Once you run it, the instance is pointing to\n    # a new file with a new extension!\n    #\n    # *DANGER*: This renames the file that the instance is pointing to. So, if\n    # you manually opened the file with Image.new(file_path)... Then that file\n    # is DELETED! If you used Image.open(file) then you are OK. The original\n    # file will still be there. But, any changes to it might not be...\n    #\n    # Formatting an animation into a non-animated type will result in\n    # ImageMagick creating multiple pages (starting with 0).  You can choose\n    # which page you want to manipulate.  We default to the first page.\n    #\n    # If you would like to convert between animated formats, pass nil as your\n    # page and ImageMagick will copy all of the pages.\n    #\n    # @param format [String] The target format... Like 'jpg', 'gif', 'tiff' etc.\n    # @param page [Integer] If this is an animated gif, say which 'page' you\n    #   want with an integer. Default 0 will convert only the first page; 'nil'\n    #   will convert all pages.\n    # @param read_opts [Hash] Any read options to be passed to ImageMagick\n    #   for example: image.format('jpg', page, {density: '300'})\n    # @yield [MiniMagick::Tool::Convert] It optionally yields the command,\n    #   if you want to add something.\n    # @return [self]\n    #\n    def format(format, page = 0, read_opts={})\n      if @tempfile\n        new_tempfile = MiniMagick::Utilities.tempfile(\".#{format}\")\n        new_path = new_tempfile.path\n      else\n        new_path = Pathname(path).sub_ext(\".#{format}\").to_s\n      end\n\n      input_path = path.dup\n      input_path << \"[#{page}]\" if page && !layer?\n\n      MiniMagick::Tool::Convert.new do |convert|\n        read_opts.each do |opt, val|\n          convert.send(opt.to_s, val)\n        end\n        convert << input_path\n        yield convert if block_given?\n        convert << new_path\n      end\n\n      if @tempfile\n        destroy!\n        @tempfile = new_tempfile\n      else\n        File.delete(path) unless path == new_path || layer?\n      end\n\n      path.replace new_path\n      @info.clear\n\n      self\n    end\n\n    ##\n    # You can use multiple commands together using this method. Very easy to\n    # use!\n    #\n    # @example\n    #   image.combine_options do |c|\n    #     c.draw \"image Over 0,0 10,10 '#{MINUS_IMAGE_PATH}'\"\n    #     c.thumbnail \"300x500>\"\n    #     c.background \"blue\"\n    #   end\n    #\n    # @yield [MiniMagick::Tool::Mogrify]\n    # @see http://www.imagemagick.org/script/mogrify.php\n    # @return [self]\n    #\n    def combine_options(&block)\n      mogrify(&block)\n    end\n\n    ##\n    # If an unknown method is called then it is sent through the mogrify\n    # program.\n    #\n    # @see http://www.imagemagick.org/script/mogrify.php\n    # @return [self]\n    #\n    def method_missing(name, *args)\n      mogrify do |builder|\n        builder.send(name, *args)\n      end\n    end\n\n    def respond_to_missing?(method_name, include_private = false)\n      MiniMagick::Tool::Mogrify.option_methods.include?(method_name.to_s)\n    end\n\n    ##\n    # Writes the temporary file out to either a file location (by passing in a\n    # String) or by passing in a Stream that you can #write(chunk) to\n    # repeatedly\n    #\n    # @param output_to [String, Pathname, #read] Some kind of stream object\n    #   that needs to be read or a file path as a String\n    #\n    def write(output_to)\n      case output_to\n      when String, Pathname\n        if layer?\n          MiniMagick::Tool::Convert.new do |builder|\n            builder << path\n            builder << output_to\n          end\n        else\n          FileUtils.copy_file path, output_to unless path == output_to.to_s\n        end\n      else\n        IO.copy_stream File.open(path, \"rb\"), output_to\n      end\n    end\n\n    ##\n    # @example\n    #  first_image = MiniMagick::Image.open \"first.jpg\"\n    #  second_image = MiniMagick::Image.open \"second.jpg\"\n    #  result = first_image.composite(second_image) do |c|\n    #    c.compose \"Over\" # OverCompositeOp\n    #    c.geometry \"+20+20\" # copy second_image onto first_image from (20, 20)\n    #  end\n    #  result.write \"output.jpg\"\n    #\n    # @see http://www.imagemagick.org/script/composite.php\n    #\n    def composite(other_image, output_extension = type.downcase, mask = nil)\n      output_tempfile = MiniMagick::Utilities.tempfile(\".#{output_extension}\")\n\n      MiniMagick::Tool::Composite.new do |composite|\n        yield composite if block_given?\n        composite << other_image.path\n        composite << path\n        composite << mask.path if mask\n        composite << output_tempfile.path\n      end\n\n      Image.new(output_tempfile.path, output_tempfile)\n    end\n\n    ##\n    # Collapse images with sequences to the first frame (i.e. animated gifs) and\n    # preserve quality.\n    #\n    # @param frame [Integer] The frame to which to collapse to, defaults to `0`.\n    # @return [self]\n    #\n    def collapse!(frame = 0)\n      mogrify(frame) { |builder| builder.quality(100) }\n    end\n\n    ##\n    # Destroys the tempfile (created by {.open}) if it exists.\n    #\n    def destroy!\n      if @tempfile\n        FileUtils.rm_f @tempfile.path.sub(/mpc$/, \"cache\") if @tempfile.path.end_with?(\".mpc\")\n        @tempfile.unlink\n      end\n    end\n\n    ##\n    # Runs `identify` on itself. Accepts an optional block for adding more\n    # options to `identify`.\n    #\n    # @example\n    #   image = MiniMagick::Image.open(\"image.jpg\")\n    #   image.identify do |b|\n    #     b.verbose\n    #   end # runs `identify -verbose image.jpg`\n    # @return [String] Output from `identify`\n    # @yield [MiniMagick::Tool::Identify]\n    #\n    def identify\n      MiniMagick::Tool::Identify.new do |builder|\n        yield builder if block_given?\n        builder << path\n      end\n    end\n\n    # @private\n    def run_command(tool_name, *args)\n      MiniMagick::Tool.const_get(tool_name.capitalize).new do |builder|\n        args.each do |arg|\n          builder << arg\n        end\n      end\n    end\n\n    def mogrify(page = nil)\n      MiniMagick::Tool::MogrifyRestricted.new do |builder|\n        yield builder if block_given?\n        builder << (page ? \"#{path}[#{page}]\" : path)\n      end\n\n      @info.clear\n\n      self\n    end\n\n    def layer?\n      path =~ /\\[\\d+\\]$/\n    end\n  end\nend\n", "require \"spec_helper\"\nrequire \"pathname\"\nrequire \"tempfile\"\nrequire \"fileutils\"\nrequire \"stringio\"\nrequire \"webmock/rspec\"\n\n[\"ImageMagick\", \"GraphicsMagick\"].each do |cli|\n  RSpec.context \"With #{cli}\", cli: cli.downcase.to_sym do\n    describe MiniMagick::Image do\n      subject { described_class.open(image_path) }\n\n      describe \".read\" do\n        it \"reads image from String\" do\n          string = File.binread(image_path)\n          image = described_class.read(string)\n          expect(image).to be_valid\n        end\n\n        it \"reads image from StringIO\" do\n          stringio = StringIO.new(File.binread(image_path))\n          image = described_class.read(stringio)\n          expect(image).to be_valid\n        end\n\n        it \"reads image from tempfile\" do\n          tempfile = Tempfile.open('magick')\n          FileUtils.cp image_path, tempfile.path\n          image = described_class.read(tempfile)\n          expect(image).to be_valid\n        end\n      end\n\n      describe \".import_pixels\" do\n        let(:dimensions) { [325, 200] }\n        let(:depth)      { 16 } # 16 bits (2 bytes) per pixel\n        let(:map)        { 'gray' }\n        let(:pixels)     { Array.new(dimensions.inject(:*)) { |i| i } }\n        let(:blob)       { pixels.pack('S*') } # unsigned short, native byte order\n\n        it \"can import pixels with default format\" do\n          image = described_class.import_pixels(blob, *dimensions, depth, map)\n\n          expect(image).to be_valid\n          expect(image.type).to eq 'PNG'\n          expect(image.dimensions).to eq dimensions\n        end\n\n        it \"can import pixels with custom format\" do\n          image = described_class.import_pixels(blob, *dimensions, depth, map, 'jpeg')\n\n          expect(image).to be_valid\n          expect(image.type).to eq 'JPEG'\n          expect(image.dimensions).to eq dimensions\n        end\n      end\n\n      describe \".open\" do\n        it \"makes a copy of the image\" do\n          image = described_class.open(image_path)\n          expect(image.path).not_to eq image_path\n          expect(image).to be_valid\n          expect(File.extname(image.path)).to eq File.extname(image_path)\n        end\n\n        it \"accepts a Pathname\" do\n          image = described_class.open(Pathname(image_path))\n          expect(image).to be_valid\n        end\n\n        it \"loads a remote image\" do\n          stub_request(:get, \"http://example.com/image.jpg\")\n            .to_return(body: File.read(image_path))\n          image = described_class.open(\"http://example.com/image.jpg\")\n          expect(image).to be_valid\n          expect(File.extname(image.path)).to eq \".jpg\"\n        end\n\n        it \"doesn't allow remote shell execution\" do\n          expect {\n            described_class.open(\"| touch file.txt\") # Kernel#open accepts this\n          }.to raise_error(URI::InvalidURIError)\n\n          expect(File.exist?(\"file.txt\")).to eq(false)\n        end\n\n        it \"accepts open-uri options\" do\n          stub_request(:get, \"http://example.com/image.jpg\")\n            .with(headers: {\"Foo\" => \"Bar\"})\n            .to_return(body: File.read(image_path))\n          described_class.open(\"http://example.com/image.jpg\", {\"Foo\" => \"Bar\"})\n          described_class.open(\"http://example.com/image.jpg\", \".jpg\", {\"Foo\" => \"Bar\"})\n        end\n\n        it \"strips out colons from URL\" do\n          stub_request(:get, \"http://example.com/image.jpg:large\")\n            .to_return(body: File.read(image_path))\n          image = described_class.open(\"http://example.com/image.jpg:large\")\n          expect(File.extname(image.path)).to eq \".jpg\"\n        end\n\n        it \"validates the image\" do\n          expect { described_class.open(image_path(:not)) }\n            .to raise_error(MiniMagick::Invalid)\n        end\n\n        it \"does not mistake a path with a colon for a URI schema\" do\n          expect { described_class.open(image_path(:colon)) }\n            .not_to raise_error\n        end\n      end\n\n      describe \".create\" do\n        def create(path = image_path)\n          described_class.create do |f|\n            f.write(File.binread(path))\n          end\n        end\n\n        it \"creates an image\" do\n          image = create\n          expect(File.exists?(image.path)).to eq true\n        end\n\n        it \"validates the image if validation is set\" do\n          allow(MiniMagick).to receive(:validate_on_create).and_return(true)\n          expect { create(image_path(:not)) }\n            .to raise_error(MiniMagick::Invalid)\n        end\n\n        it \"doesn't validate image if validation is disabled\" do\n          allow(MiniMagick).to receive(:validate_on_create).and_return(false)\n          expect { create(image_path(:not)) }\n            .not_to raise_error\n        end\n      end\n\n      describe \"#initialize\" do\n        it \"initializes a new image\" do\n          image = described_class.new(image_path)\n          expect(image).to be_valid\n        end\n\n        it \"accepts a Pathname\" do\n          image = described_class.new(Pathname(image_path))\n          expect(image.path).to be_a(String)\n        end\n\n        it \"accepts a block which it passes on to #combine_options\" do\n          image = described_class.new(subject.path) do |b|\n            b.resize \"100x100!\"\n          end\n          expect(image.dimensions).to eq [100, 100]\n        end\n      end\n\n      describe \"equivalence\" do\n        subject(:image) { described_class.new(image_path) }\n        let(:same_image) { described_class.new(image_path) }\n        let(:other_image) { described_class.new(image_path(:exif)) }\n\n        it \"is #== and #eql? to itself\" do\n          expect(image).to eq(image)\n          expect(image).to eql(image)\n        end\n\n        it \"is #== and #eql? to an instance of the same image\" do\n          expect(image).to eq(same_image)\n          expect(image).to eql(same_image)\n        end\n\n        it \"is not #== nor #eql? to an instance of a different image\" do\n          expect(image).not_to eq(other_image)\n          expect(image).not_to eql(other_image)\n        end\n\n        it \"generates the same hash code for an instance of the same image\" do\n          expect(image.hash).to eq(same_image.hash)\n        end\n\n        it \"generates different same hash codes for a different image\" do\n          expect(image.hash).not_to eq(other_image.hash)\n        end\n      end\n\n      describe \"#tempfile\" do\n        it \"returns the underlying temporary file\" do\n          image = described_class.open(image_path)\n\n          expect(image.tempfile).to be_a(Tempfile)\n        end\n      end\n\n      describe \"#format\" do\n        subject { described_class.open(image_path(:jpg)) }\n\n        it \"changes the format of the photo\" do\n          expect { subject.format(\"png\") }\n            .to change { subject.type }\n        end\n\n        it \"reformats an image with a given extension\" do\n          expect { subject.format('png') }\n            .to change { File.extname(subject.path) }.to \".png\"\n        end\n\n        it \"creates the file with new extension\" do\n          subject.format('png')\n          expect(File.exist?(subject.path)).to eq true\n        end\n\n        it \"accepts a block of additional commands\" do\n          expect {\n            subject.format(\"png\") do |b|\n              b.resize(\"100x100!\")\n            end\n          }.to change { subject.dimensions }.to [100, 100]\n        end\n\n        it \"works without an extension with .open\" do\n          subject = described_class.open(image_path(:jpg_without_extension))\n          subject.format(\"png\")\n\n          expect(File.extname(subject.path)).to eq \".png\"\n          expect(subject.type).to eq \"PNG\"\n        end\n\n        it \"works without an extension with .new\" do\n          subject = described_class.new(image_path(:jpg_without_extension))\n          subject.format(\"png\")\n\n          expect(File.extname(subject.path)).to eq \".png\"\n          expect(subject.type).to eq \"PNG\"\n        end\n\n        it \"deletes the previous tempfile\" do\n          old_path = subject.path.dup\n          subject.format('png')\n          expect(File.exist?(old_path)).to eq false\n        end\n\n        it \"deletes *.cache files generated from .mpc\" do\n          image = described_class.open(image_path)\n          image.format(\"mpc\")\n          cache_path = image.path.sub(/mpc$/, \"cache\")\n          image.format(\"png\")\n\n          expect(File.exists?(cache_path)).to eq false\n        end\n\n        it \"doesn't delete itself when formatted to the same format\" do\n          subject.format(subject.type.downcase)\n          expect(File.exists?(subject.path)).to eq true\n        end\n\n        it \"reformats multi-image formats to multiple images\" do\n          subject = described_class.open(image_path(:animation))\n          subject.format('jpg', nil)\n          expect(Dir[subject.path.sub('.', '*.')]).not_to be_empty\n        end\n\n        it \"reformats multi-image formats to a single image\" do\n          subject = described_class.open(image_path(:animation))\n          subject.format('jpg')\n          expect(subject).to be_valid\n        end\n\n        it \"reformats a layer\" do\n          subject = described_class.open(image_path(:animation))\n          layer = subject.layers.first\n          layer.format('jpg')\n          expect(layer).to be_valid\n          expect(layer.path[/\\..+$/]).to eq \".jpg\"\n          expect(File.exist?(layer.path)).to eq true\n        end\n\n        it \"clears the info only at the end\" do\n          subject.format('png') { subject.type }\n          expect(subject.type).to eq \"PNG\"\n        end\n\n        it \"returns self\" do\n          expect(subject.format('png')).to eq subject\n        end\n\n        it \"reads read_opts from passed arguments\" do\n          subject = described_class.open(image_path(:animation))\n          layer = subject.layers.first\n          layer.format('jpg', nil, {density: '300'})\n          expect(layer).to be_valid\n\n        end\n      end\n\n      describe \"#write\" do\n        it \"writes the image\" do\n          output_path = random_path(\"test output\")\n          subject.write(output_path)\n          expect(described_class.new(output_path)).to be_valid\n        end\n\n        it \"writes an image with stream\" do\n          output_stream = StringIO.new\n          subject.write(output_stream)\n          expect(described_class.read(output_stream.string)).to be_valid\n        end\n\n        it \"writes layers\" do\n          output_path = random_path([\"\", \".#{subject.type.downcase}\"])\n          subject = described_class.new(image_path(:gif))\n          subject.frames.first.write(output_path)\n          expect(described_class.new(output_path)).to be_valid\n        end\n\n        it \"accepts a Pathname\" do\n          output_path = Pathname(random_path)\n          subject.write(output_path)\n          expect(described_class.new(output_path.to_s)).to be_valid\n        end\n\n        it \"works when writing to the same path\" do\n          subject.write(subject.path)\n          expect(File.read(subject.path)).not_to be_empty\n        end\n      end\n\n      describe \"#valid?\" do\n        it \"returns true when image is valid\" do\n          image = described_class.new(image_path)\n          expect(image).to be_valid\n        end\n\n        it \"returns false when image is not valid\" do\n          image = described_class.new(image_path(:not))\n          expect(image).not_to be_valid\n        end\n      end\n\n      describe \"#[]\" do\n        it \"inspects image meta info\" do\n          expect(subject[:width]).to be_a(Integer)\n          expect(subject[:height]).to be_a(Integer)\n          expect(subject[:dimensions]).to all(be_a(Integer))\n          expect(subject[:colorspace]).to be_a(String)\n          expect(subject[:format]).to match(/[A-Z]/)\n          expect(subject[:signature]).to match(/[[:alnum:]]{64}/)\n        end\n\n        it \"supports string keys\" do\n          expect(subject[\"width\"]).to be_a(Integer)\n          expect(subject[\"height\"]).to be_a(Integer)\n          expect(subject[\"dimensions\"]).to all(be_a(Integer))\n          expect(subject[\"colorspace\"]).to be_a(String)\n          expect(subject[\"format\"]).to match(/[A-Z]/)\n          expect(subject['signature']).to match(/[[:alnum:]]{64}/)\n        end\n\n        it \"reads exif\" do\n          subject = described_class.new(image_path(:exif))\n          expect(subject[\"EXIF:Flash\"]).to eq \"0\"\n        end\n\n        it \"passes unknown values directly to -format\" do\n          expect(subject[\"%w %h\"].split.map(&:to_i)).to eq [subject[:width], subject[:height]]\n        end\n      end\n\n      it \"has attributes\" do\n        expect(subject.type).to match(/^[A-Z]+$/)\n        expect(subject.mime_type).to match(/^image\\/[a-z]+$/)\n        expect(subject.width).to be_a(Integer).and be_nonzero\n        expect(subject.height).to be_a(Integer).and be_nonzero\n        expect(subject.dimensions).to all(be_a(Integer))\n        expect(subject.size).to be_a(Integer).and be_nonzero\n        expect(subject.human_size).to be_a(String).and be_nonempty\n        expect(subject.colorspace).to be_a(String)\n        expect(subject.resolution).to all(be_a(Integer))\n        expect(subject.signature).to match(/[[:alnum:]]{64}/)\n      end\n\n      it \"generates attributes of layers\" do\n        expect(subject.layers[0].type).to match(/^[A-Z]+$/)\n        expect(subject.layers[0].size).to be > 0\n      end\n\n      it \"changes colorspace when called with an argument\" do\n        expect_any_instance_of(MiniMagick::Tool::Mogrify).to receive(:call)\n        subject.colorspace(\"Gray\")\n      end\n\n      it \"changes size when called with an argument\" do\n        expect_any_instance_of(MiniMagick::Tool::Mogrify).to receive(:call)\n        subject.size(\"20x20\")\n      end\n\n      describe \"#exif\" do\n        it \"returns a hash of EXIF data\" do\n          subject = described_class.new(image_path(:exif))\n          expect(subject.exif[\"DateTimeOriginal\"]).to be_a(String)\n        end\n\n        it \"decodes the ExifVersion\" do\n          subject = described_class.new(image_path(:exif))\n          expect(subject.exif[\"ExifVersion\"]).to eq(\"0220\")\n        end unless ENV[\"CI\"]\n\n        it \"handles no EXIF data\" do\n          subject = described_class.new(image_path(:no_exif))\n          expect(subject.exif).to eq({})\n        end\n      end\n\n      describe \"#resolution\" do\n        it \"accepts units\", skip_cli: :graphicsmagick do\n          expect(subject.resolution(\"PixelsPerCentimeter\"))\n            .not_to eq subject.resolution(\"PixelsPerInch\")\n        end\n      end\n\n      describe \"#mime_type\" do\n        it \"returns the correct mime type\" do\n          jpg = described_class.new(image_path(:jpg))\n          expect(jpg.mime_type).to eq 'image/jpeg'\n        end\n      end\n\n      describe \"#details\" do\n        it \"returns a hash of verbose information\" do\n          expect(subject.details[\"Format\"]).to match /^JPEG/\n          if MiniMagick.cli == :imagemagick\n            if Gem::Version.new(MiniMagick.cli_version) < Gem::Version.new('7.0.0')\n              expect(subject.details[\"Channel depth\"][\"red\"]).to eq \"8-bit\"\n            else\n              expect(subject.details[\"Channel depth\"][\"Red\"]).to eq \"8-bit\"\n            end\n\n            expect(subject.details).to have_key(\"Background color\")\n            expect(subject.details[\"Properties\"]).to have_key(\"date:create\")\n          else\n            expect(subject.details[\"Channel Depths\"][\"Red\"]).to eq \"8 bits\"\n            expect(subject.details).to have_key(\"Resolution\")\n          end\n        end\n\n        context \"when verbose information includes an empty line\" do\n          subject { described_class.new(image_path(:empty_identify_line)) }\n\n          it \"skips the empty line\" do\n            if MiniMagick.cli == :imagemagick\n              expect(subject.details[\"Properties\"]).to have_key(\"date:create\")\n            else\n              expect(subject.details).to have_key(\"Date:create\")\n            end\n          end\n        end\n\n        context \"when verbose information includes a badly encoded line do\", skip_cli: :graphicsmagick do\n          subject { described_class.new(image_path(:badly_encoded_line)) }\n\n          it \"skips the badly encoded line\" do\n            expect(subject.details).not_to have_key(\"Software\")\n          end\n        end\n\n        # GraphicsMagick does not output the clipping path\n        context \"when verbose information includes a clipping path\", skip_cli: :graphicsmagick do\n          subject { described_class.new(image_path(:clipping_path)) }\n\n          it \"does not hang when parsing verbose data\" do\n            # Retrieving .details should happen very quickly but as of v4.3.6\n            # will hang indefinitely without the timeout\n            Timeout::timeout(10) do\n              expect(subject.details['Clipping path'][0..4]).to eq \"<?xml\"\n            end\n          end\n        end\n      end\n\n      describe \"#data\" do\n        describe \"when the data return is not an array\" do\n          subject { described_class.new(image_path(:jpg)) }\n\n          it \"returns image JSON data\", skip_cli: :graphicsmagick do\n            expect(subject.data[\"format\"]).to eq \"JPEG\"\n            expect(subject.data[\"colorspace\"]).to eq \"sRGB\"\n          end\n        end\n\n        describe \"when the data return is an array (ex png)\" do\n          subject { described_class.new(image_path(:png)) }\n\n          it \"returns image JSON data\", skip_cli: :graphicsmagick do\n            expect(subject.data[\"format\"]).to eq \"PNG\"\n            expect(subject.data[\"colorspace\"]).to eq \"sRGB\"\n          end\n        end\n      end unless ENV[\"CI\"] # problems installing newer ImageMagick versions on CI\n\n      describe \"#layers\" do\n        it \"returns a list of images\" do\n          expect(subject.layers).to all(be_a(MiniMagick::Image))\n          expect(subject.layers.first).to be_valid\n        end\n\n        it \"returns multiple images for GIFs, PDFs and PSDs\" do\n          gif = described_class.new(image_path(:gif))\n\n          expect(gif.layers.count).to be > 1\n          expect(gif.frames.count).to be > 1\n          expect(gif.pages.count).to be > 1\n        end\n\n        it \"returns one image for other formats\" do\n          jpg = described_class.new(image_path(:jpg))\n\n          expect(jpg.layers.count).to eq 1\n        end\n      end\n\n      describe \"#get_pixels\" do\n        let(:magenta) { [255,   0, 255] }\n        let(:gray)    { [128, 128, 128] }\n        let(:green)   { [  0, 255,   0] }\n        let(:cyan)    { [  0, 255, 255] }\n        let(:pix)     { subject.get_pixels }\n\n        subject { described_class.open(image_path(:rgb)) }\n\n        context \"without modifications\" do\n          it \"returns a width-by-height matrix\" do\n            pix.each do |row|\n              expect(row.length).to eq(subject.width)\n            end\n          end\n\n          it(\"returns a magenta pixel\") { expect(pix[3][3]  ).to eq(magenta) }\n          it(\"returns a gray pixel\")    { expect(pix[-4][-4]).to eq(gray)    }\n          it(\"returns a green pixel\")   { expect(pix[3][-4] ).to eq(green)   }\n          it(\"returns a cyan pixel\")    { expect(pix[-4][3] ).to eq(cyan)    }\n        end\n\n        context \"after cropping\" do\n          let(:cols)    { 10 }\n          let(:rows)    {  6 }\n\n          before { subject.crop \"#{cols}x#{rows}+3+3\" }\n\n          it \"returns a matrix of the requested height\" do\n            expect(pix.length).to eq(rows)\n          end\n\n          it \"returns a matrix of the requested width\" do\n            pix.each do |x|\n              expect(x.length).to eq(cols)\n            end\n          end\n\n          it(\"returns a magenta pixel\") { expect(pix[0][0]  ).to eq(magenta)}\n          it(\"returns a gray pixel\")    { expect(pix[-1][-1]).to eq(gray)   }\n          it(\"returns a cyan pixel\")    { expect(pix[-1][0] ).to eq(cyan)   }\n          it(\"returns a green pixel\")   { expect(pix[0][-1] ).to eq(green)  }\n        end\n\n        context \"after resizing and desaturating\" do\n          let(:cols) { 8 }\n          let(:rows) { 6 }\n\n          before {\n            subject.resize \"50%\"\n            subject.colorspace \"Gray\"\n          }\n\n          it \"returns a matrix of the requested height\" do\n            expect(pix.length).to eq(rows)\n          end\n\n          it \"returns a matrix of the requested width\" do\n            pix.each do |x|\n              expect(x.length).to eq(cols)\n            end\n          end\n\n          it \"returns gray pixels\" do\n            pix.each do |row|\n              row.each do |px|\n                expect(px[0]).to eq px[1]\n                expect(px[0]).to eq px[2]\n              end\n            end\n          end\n        end\n\n        context \"when first or last byte could be interpreted as control characters\" do\n          subject { described_class.open(image_path(:get_pixels)) }\n\n          it \"returns a matrix where all pixel has 3 values\" do\n            pix.each do |row|\n              row.each do |px|\n                expect(px.length).to eq(3)\n              end\n            end\n          end\n        end\n      end\n\n      describe \"missing methods\" do\n        context \"for a known method\" do\n          it \"is executed by #method_missing\" do\n            expect { subject.resize '20x30!' }\n              .to change { subject.dimensions }.to [20, 30]\n          end\n\n          it \"returns self\" do\n            expect(subject.resize('20x30!')).to eq subject\n          end\n\n          it \"can be responded to\" do\n            expect(subject.respond_to?(:gravity)).to eq true\n            expect(subject.respond_to?(:bla)).to eq false\n          end\n        end\n      end\n\n      describe \"#combine_options\" do\n        it \"chains multiple options and executes them in one command\" do\n          expect {\n            subject.combine_options { |c| c.resize '20x30!' }\n          }.to change { subject.dimensions }.to [20, 30]\n        end\n\n        it \"doesn't allow calling of #format\" do\n          expect { subject.combine_options { |c| c.format(\"png\") } }\n            .to raise_error(NoMethodError)\n        end\n\n        it \"clears the info only at the end\" do\n          subject.combine_options { |c| c.resize('20x30!'); subject.width }\n          expect(subject.dimensions).to eq [20, 30]\n        end\n\n        it \"returns self\" do\n          expect(subject.combine_options {}).to eq subject\n        end\n      end\n\n      describe \"#composite\" do\n        let(:other_image) { described_class.open(image_path) }\n        let(:mask) { described_class.open(image_path) }\n\n        it \"creates a composite of two images\" do\n          image = subject.composite(other_image)\n          expect(image).to be_valid\n        end\n\n        it \"creates a composite of two images with mask\" do\n          image = subject.composite(other_image, 'jpg', mask)\n          expect(image).to be_valid\n        end\n\n        it \"yields an optional block\" do\n          expect { |b| subject.composite(other_image, &b) }\n            .to yield_with_args(an_instance_of(MiniMagick::Tool::Composite))\n        end\n\n        it \"makes the composited image with the provided extension\" do\n          result = subject.composite(other_image, 'png')\n          expect(result.path).to end_with \".png\"\n        end\n\n        it \"defaults the extension to the extension of the base image\" do\n          subject = described_class.open(image_path(:jpg))\n          result = subject.composite(other_image)\n          expect(result.path).to end_with \".jpeg\"\n\n          subject = described_class.open(image_path(:gif))\n          result = subject.composite(other_image)\n          expect(result.path).to end_with \".gif\"\n        end\n      end\n\n      describe \"#collapse!\" do\n        subject { described_class.open(image_path(:animation)) }\n\n        it \"collapses the image to one frame\" do\n          subject.collapse!\n          expect(subject.identify.lines.count).to eq 1\n        end\n\n        it \"keeps the extension\" do\n          expect { subject.collapse! }\n            .not_to change { subject.type }\n        end\n\n        it \"clears the info\" do\n          expect { subject.collapse! }\n            .to change { subject.size }\n        end\n\n        it \"returns self\" do\n          expect(subject.collapse!).to eq subject\n        end\n      end\n\n      describe \"#destroy!\" do\n        it \"deletes the underlying tempfile\" do\n          image = described_class.open(image_path)\n          image.destroy!\n\n          expect(File.exists?(image.path)).to eq false\n        end\n\n        it \"doesn't delete when there is no tempfile\" do\n          image = described_class.new(image_path)\n          image.destroy!\n\n          expect(File.exists?(image.path)).to eq true\n        end\n\n        it \"deletes .cache files generated by handling .mpc files\" do\n          image = described_class.open(image_path)\n          image.format(\"mpc\")\n          image.destroy!\n\n          expect(File.exists?(image.path.sub(/mpc$/, \"cache\"))).to eq false\n        end\n      end\n\n      describe \"#identify\" do\n        it \"returns the output of identify\" do\n          expect(subject.identify).to match(subject.type)\n        end\n\n        it \"yields an optional block\" do\n          output = subject.identify do |b|\n            b.verbose\n          end\n          expect(output).to match(\"Format:\")\n        end\n      end\n\n      describe \"#run_command\" do\n        it \"runs the given command\" do\n          output = subject.run_command(\"identify\", \"-format\", \"%w\", subject.path)\n          expect(output).to eq subject.width.to_s\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["lib/mini_magick/image.rb", "spec/lib/mini_magick/image_spec.rb"], "buggy_code_start_loc": [85, 76], "buggy_code_end_loc": [96, 76], "fixing_code_start_loc": [85, 77], "fixing_code_end_loc": [94, 85], "type": "CWE-78", "message": "In lib/mini_magick/image.rb in MiniMagick before 4.9.4, a fetched remote image filename could cause remote command execution because Image.open input is directly passed to Kernel#open, which accepts a '|' character followed by a command.", "other": {"cve": {"id": "CVE-2019-13574", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-12T03:15:10.467", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In lib/mini_magick/image.rb in MiniMagick before 4.9.4, a fetched remote image filename could cause remote command execution because Image.open input is directly passed to Kernel#open, which accepts a '|' character followed by a command."}, {"lang": "es", "value": "En la biblioteca lib/mini_magick/image.rb en MiniMagick anterior a versi\u00f3n 4.9.4, un nombre de archivo de imagen remoto recuperado podr\u00eda causar la ejecuci\u00f3n de comandos remota porque la entrada Image.open es pasada directamente al Kernel#open, que acepta un car\u00e1cter '|' seguido de un comando."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minimagick_project:minimagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.4", "matchCriteriaId": "EC2DA186-D797-461A-B135-F8CDC7410CBF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://benjamin-bouchet.com/blog/vulnerabilite-dans-la-gem-mini_magick-version-4-9-4/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/minimagick/minimagick/commit/4cd5081e58810d3394d27a67219e8e4e0445d851", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minimagick/minimagick/compare/d484786...293f9bb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minimagick/minimagick/releases/tag/v4.9.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00007.html", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Jul/20", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4481", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minimagick/minimagick/commit/4cd5081e58810d3394d27a67219e8e4e0445d851"}}