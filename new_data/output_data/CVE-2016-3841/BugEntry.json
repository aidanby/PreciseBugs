{"buggy_code": ["#ifndef _IPV6_H\n#define _IPV6_H\n\n#include <uapi/linux/ipv6.h>\n\n#define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)\n#define ipv6_authlen(p) (((p)->hdrlen+2) << 2)\n/*\n * This structure contains configuration options per IPv6 link.\n */\nstruct ipv6_devconf {\n\t__s32\t\tforwarding;\n\t__s32\t\thop_limit;\n\t__s32\t\tmtu6;\n\t__s32\t\taccept_ra;\n\t__s32\t\taccept_redirects;\n\t__s32\t\tautoconf;\n\t__s32\t\tdad_transmits;\n\t__s32\t\trtr_solicits;\n\t__s32\t\trtr_solicit_interval;\n\t__s32\t\trtr_solicit_delay;\n\t__s32\t\tforce_mld_version;\n\t__s32\t\tmldv1_unsolicited_report_interval;\n\t__s32\t\tmldv2_unsolicited_report_interval;\n\t__s32\t\tuse_tempaddr;\n\t__s32\t\ttemp_valid_lft;\n\t__s32\t\ttemp_prefered_lft;\n\t__s32\t\tregen_max_retry;\n\t__s32\t\tmax_desync_factor;\n\t__s32\t\tmax_addresses;\n\t__s32\t\taccept_ra_defrtr;\n\t__s32\t\taccept_ra_min_hop_limit;\n\t__s32\t\taccept_ra_pinfo;\n\t__s32\t\tignore_routes_with_linkdown;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\t__s32\t\taccept_ra_rtr_pref;\n\t__s32\t\trtr_probe_interval;\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\t__s32\t\taccept_ra_rt_info_max_plen;\n#endif\n#endif\n\t__s32\t\tproxy_ndp;\n\t__s32\t\taccept_source_route;\n\t__s32\t\taccept_ra_from_local;\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t__s32\t\toptimistic_dad;\n\t__s32\t\tuse_optimistic;\n#endif\n#ifdef CONFIG_IPV6_MROUTE\n\t__s32\t\tmc_forwarding;\n#endif\n\t__s32\t\tdisable_ipv6;\n\t__s32\t\taccept_dad;\n\t__s32\t\tforce_tllao;\n\t__s32           ndisc_notify;\n\t__s32\t\tsuppress_frag_ndisc;\n\t__s32\t\taccept_ra_mtu;\n\tstruct ipv6_stable_secret {\n\t\tbool initialized;\n\t\tstruct in6_addr secret;\n\t} stable_secret;\n\t__s32\t\tuse_oif_addrs_only;\n\tvoid\t\t*sysctl;\n};\n\nstruct ipv6_params {\n\t__s32 disable_ipv6;\n\t__s32 autoconf;\n};\nextern struct ipv6_params ipv6_defaults;\n#include <linux/icmpv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n\n#include <net/inet_sock.h>\n\nstatic inline struct ipv6hdr *ipv6_hdr(const struct sk_buff *skb)\n{\n\treturn (struct ipv6hdr *)skb_network_header(skb);\n}\n\nstatic inline struct ipv6hdr *inner_ipv6_hdr(const struct sk_buff *skb)\n{\n\treturn (struct ipv6hdr *)skb_inner_network_header(skb);\n}\n\nstatic inline struct ipv6hdr *ipipv6_hdr(const struct sk_buff *skb)\n{\n\treturn (struct ipv6hdr *)skb_transport_header(skb);\n}\n\n/* \n   This structure contains results of exthdrs parsing\n   as offsets from skb->nh.\n */\n\nstruct inet6_skb_parm {\n\tint\t\t\tiif;\n\t__be16\t\t\tra;\n\t__u16\t\t\tdst0;\n\t__u16\t\t\tsrcrt;\n\t__u16\t\t\tdst1;\n\t__u16\t\t\tlastopt;\n\t__u16\t\t\tnhoff;\n\t__u16\t\t\tflags;\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\n\t__u16\t\t\tdsthao;\n#endif\n\t__u16\t\t\tfrag_max_size;\n\n#define IP6SKB_XFRM_TRANSFORMED\t1\n#define IP6SKB_FORWARDED\t2\n#define IP6SKB_REROUTED\t\t4\n#define IP6SKB_ROUTERALERT\t8\n#define IP6SKB_FRAGMENTED      16\n#define IP6SKB_HOPBYHOP        32\n};\n\n#define IP6CB(skb)\t((struct inet6_skb_parm*)((skb)->cb))\n#define IP6CBMTU(skb)\t((struct ip6_mtuinfo *)((skb)->cb))\n\nstatic inline int inet6_iif(const struct sk_buff *skb)\n{\n\treturn IP6CB(skb)->iif;\n}\n\nstruct tcp6_request_sock {\n\tstruct tcp_request_sock\t  tcp6rsk_tcp;\n};\n\nstruct ipv6_mc_socklist;\nstruct ipv6_ac_socklist;\nstruct ipv6_fl_socklist;\n\nstruct inet6_cork {\n\tstruct ipv6_txoptions *opt;\n\tu8 hop_limit;\n\tu8 tclass;\n};\n\n/**\n * struct ipv6_pinfo - ipv6 private area\n *\n * In the struct sock hierarchy (tcp6_sock, upd6_sock, etc)\n * this _must_ be the last member, so that inet6_sk_generic\n * is able to calculate its offset from the base struct sock\n * by using the struct proto->slab_obj_size member. -acme\n */\nstruct ipv6_pinfo {\n\tstruct in6_addr \tsaddr;\n\tstruct in6_pktinfo\tsticky_pktinfo;\n\tconst struct in6_addr\t\t*daddr_cache;\n#ifdef CONFIG_IPV6_SUBTREES\n\tconst struct in6_addr\t\t*saddr_cache;\n#endif\n\n\t__be32\t\t\tflow_label;\n\t__u32\t\t\tfrag_size;\n\n\t/*\n\t * Packed in 16bits.\n\t * Omit one shift by by putting the signed field at MSB.\n\t */\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__s16\t\t\thop_limit:9;\n\t__u16\t\t\t__unused_1:7;\n#else\n\t__u16\t\t\t__unused_1:7;\n\t__s16\t\t\thop_limit:9;\n#endif\n\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t/* Packed in 16bits. */\n\t__s16\t\t\tmcast_hops:9;\n\t__u16\t\t\t__unused_2:6,\n\t\t\t\tmc_loop:1;\n#else\n\t__u16\t\t\tmc_loop:1,\n\t\t\t\t__unused_2:6;\n\t__s16\t\t\tmcast_hops:9;\n#endif\n\tint\t\t\tucast_oif;\n\tint\t\t\tmcast_oif;\n\n\t/* pktoption flags */\n\tunion {\n\t\tstruct {\n\t\t\t__u16\tsrcrt:1,\n\t\t\t\tosrcrt:1,\n\t\t\t        rxinfo:1,\n\t\t\t        rxoinfo:1,\n\t\t\t\trxhlim:1,\n\t\t\t\trxohlim:1,\n\t\t\t\thopopts:1,\n\t\t\t\tohopopts:1,\n\t\t\t\tdstopts:1,\n\t\t\t\todstopts:1,\n                                rxflow:1,\n\t\t\t\trxtclass:1,\n\t\t\t\trxpmtu:1,\n\t\t\t\trxorigdstaddr:1;\n\t\t\t\t/* 2 bits hole */\n\t\t} bits;\n\t\t__u16\t\tall;\n\t} rxopt;\n\n\t/* sockopt flags */\n\t__u16\t\t\trecverr:1,\n\t                        sndflow:1,\n\t\t\t\trepflow:1,\n\t\t\t\tpmtudisc:3,\n\t\t\t\tpadding:1,\t/* 1 bit hole */\n\t\t\t\tsrcprefs:3,\t/* 001: prefer temporary address\n\t\t\t\t\t\t * 010: prefer public address\n\t\t\t\t\t\t * 100: prefer care-of address\n\t\t\t\t\t\t */\n\t\t\t\tdontfrag:1,\n\t\t\t\tautoflowlabel:1;\n\t__u8\t\t\tmin_hopcount;\n\t__u8\t\t\ttclass;\n\t__be32\t\t\trcv_flowinfo;\n\n\t__u32\t\t\tdst_cookie;\n\t__u32\t\t\trx_dst_cookie;\n\n\tstruct ipv6_mc_socklist\t__rcu *ipv6_mc_list;\n\tstruct ipv6_ac_socklist\t*ipv6_ac_list;\n\tstruct ipv6_fl_socklist __rcu *ipv6_fl_list;\n\n\tstruct ipv6_txoptions\t*opt;\n\tstruct sk_buff\t\t*pktoptions;\n\tstruct sk_buff\t\t*rxpmtu;\n\tstruct inet6_cork\tcork;\n};\n\n/* WARNING: don't change the layout of the members in {raw,udp,tcp}6_sock! */\nstruct raw6_sock {\n\t/* inet_sock has to be the first member of raw6_sock */\n\tstruct inet_sock\tinet;\n\t__u32\t\t\tchecksum;\t/* perform checksum */\n\t__u32\t\t\toffset;\t\t/* checksum offset  */\n\tstruct icmp6_filter\tfilter;\n\t__u32\t\t\tip6mr_table;\n\t/* ipv6_pinfo has to be the last member of raw6_sock, see inet6_sk_generic */\n\tstruct ipv6_pinfo\tinet6;\n};\n\nstruct udp6_sock {\n\tstruct udp_sock\t  udp;\n\t/* ipv6_pinfo has to be the last member of udp6_sock, see inet6_sk_generic */\n\tstruct ipv6_pinfo inet6;\n};\n\nstruct tcp6_sock {\n\tstruct tcp_sock\t  tcp;\n\t/* ipv6_pinfo has to be the last member of tcp6_sock, see inet6_sk_generic */\n\tstruct ipv6_pinfo inet6;\n};\n\nextern int inet6_sk_rebuild_header(struct sock *sk);\n\nstruct tcp6_timewait_sock {\n\tstruct tcp_timewait_sock   tcp6tw_tcp;\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline struct ipv6_pinfo *inet6_sk(const struct sock *__sk)\n{\n\treturn sk_fullsock(__sk) ? inet_sk(__sk)->pinet6 : NULL;\n}\n\nstatic inline struct raw6_sock *raw6_sk(const struct sock *sk)\n{\n\treturn (struct raw6_sock *)sk;\n}\n\nstatic inline void inet_sk_copy_descendant(struct sock *sk_to,\n\t\t\t\t\t   const struct sock *sk_from)\n{\n\tint ancestor_size = sizeof(struct inet_sock);\n\n\tif (sk_from->sk_family == PF_INET6)\n\t\tancestor_size += sizeof(struct ipv6_pinfo);\n\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}\n\n#define __ipv6_only_sock(sk)\t(sk->sk_ipv6only)\n#define ipv6_only_sock(sk)\t(__ipv6_only_sock(sk))\n#define ipv6_sk_rxinfo(sk)\t((sk)->sk_family == PF_INET6 && \\\n\t\t\t\t inet6_sk(sk)->rxopt.bits.rxinfo)\n\nstatic inline const struct in6_addr *inet6_rcv_saddr(const struct sock *sk)\n{\n\tif (sk->sk_family == AF_INET6)\n\t\treturn &sk->sk_v6_rcv_saddr;\n\treturn NULL;\n}\n\nstatic inline int inet_v6_ipv6only(const struct sock *sk)\n{\n\t/* ipv6only field is at same position for timewait and other sockets */\n\treturn ipv6_only_sock(sk);\n}\n#else\n#define __ipv6_only_sock(sk)\t0\n#define ipv6_only_sock(sk)\t0\n#define ipv6_sk_rxinfo(sk)\t0\n\nstatic inline struct ipv6_pinfo * inet6_sk(const struct sock *__sk)\n{\n\treturn NULL;\n}\n\nstatic inline struct inet6_request_sock *\n\t\t\tinet6_rsk(const struct request_sock *rsk)\n{\n\treturn NULL;\n}\n\nstatic inline struct raw6_sock *raw6_sk(const struct sock *sk)\n{\n\treturn NULL;\n}\n\n#define inet6_rcv_saddr(__sk)\tNULL\n#define tcp_twsk_ipv6only(__sk)\t\t0\n#define inet_v6_ipv6only(__sk)\t\t0\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n#endif /* _IPV6_H */\n", "/*\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#ifndef _NET_IPV6_H\n#define _NET_IPV6_H\n\n#include <linux/ipv6.h>\n#include <linux/hardirq.h>\n#include <linux/jhash.h>\n#include <net/if_inet6.h>\n#include <net/ndisc.h>\n#include <net/flow.h>\n#include <net/flow_dissector.h>\n#include <net/snmp.h>\n\n#define SIN6_LEN_RFC2133\t24\n\n#define IPV6_MAXPLEN\t\t65535\n\n/*\n *\tNextHeader field of IPv6 header\n */\n\n#define NEXTHDR_HOP\t\t0\t/* Hop-by-hop option header. */\n#define NEXTHDR_TCP\t\t6\t/* TCP segment. */\n#define NEXTHDR_UDP\t\t17\t/* UDP message. */\n#define NEXTHDR_IPV6\t\t41\t/* IPv6 in IPv6 */\n#define NEXTHDR_ROUTING\t\t43\t/* Routing header. */\n#define NEXTHDR_FRAGMENT\t44\t/* Fragmentation/reassembly header. */\n#define NEXTHDR_GRE\t\t47\t/* GRE header. */\n#define NEXTHDR_ESP\t\t50\t/* Encapsulating security payload. */\n#define NEXTHDR_AUTH\t\t51\t/* Authentication header. */\n#define NEXTHDR_ICMP\t\t58\t/* ICMP for IPv6. */\n#define NEXTHDR_NONE\t\t59\t/* No next header */\n#define NEXTHDR_DEST\t\t60\t/* Destination options header. */\n#define NEXTHDR_SCTP\t\t132\t/* SCTP message. */\n#define NEXTHDR_MOBILITY\t135\t/* Mobility header. */\n\n#define NEXTHDR_MAX\t\t255\n\n#define IPV6_DEFAULT_HOPLIMIT   64\n#define IPV6_DEFAULT_MCASTHOPS\t1\n\n/*\n *\tAddr type\n *\t\n *\ttype\t-\tunicast | multicast\n *\tscope\t-\tlocal\t| site\t    | global\n *\tv4\t-\tcompat\n *\tv4mapped\n *\tany\n *\tloopback\n */\n\n#define IPV6_ADDR_ANY\t\t0x0000U\n\n#define IPV6_ADDR_UNICAST      \t0x0001U\t\n#define IPV6_ADDR_MULTICAST    \t0x0002U\t\n\n#define IPV6_ADDR_LOOPBACK\t0x0010U\n#define IPV6_ADDR_LINKLOCAL\t0x0020U\n#define IPV6_ADDR_SITELOCAL\t0x0040U\n\n#define IPV6_ADDR_COMPATv4\t0x0080U\n\n#define IPV6_ADDR_SCOPE_MASK\t0x00f0U\n\n#define IPV6_ADDR_MAPPED\t0x1000U\n\n/*\n *\tAddr scopes\n */\n#define IPV6_ADDR_MC_SCOPE(a)\t\\\n\t((a)->s6_addr[1] & 0x0f)\t/* nonstandard */\n#define __IPV6_ADDR_SCOPE_INVALID\t-1\n#define IPV6_ADDR_SCOPE_NODELOCAL\t0x01\n#define IPV6_ADDR_SCOPE_LINKLOCAL\t0x02\n#define IPV6_ADDR_SCOPE_SITELOCAL\t0x05\n#define IPV6_ADDR_SCOPE_ORGLOCAL\t0x08\n#define IPV6_ADDR_SCOPE_GLOBAL\t\t0x0e\n\n/*\n *\tAddr flags\n */\n#define IPV6_ADDR_MC_FLAG_TRANSIENT(a)\t\\\n\t((a)->s6_addr[1] & 0x10)\n#define IPV6_ADDR_MC_FLAG_PREFIX(a)\t\\\n\t((a)->s6_addr[1] & 0x20)\n#define IPV6_ADDR_MC_FLAG_RENDEZVOUS(a)\t\\\n\t((a)->s6_addr[1] & 0x40)\n\n/*\n *\tfragmentation header\n */\n\nstruct frag_hdr {\n\t__u8\tnexthdr;\n\t__u8\treserved;\n\t__be16\tfrag_off;\n\t__be32\tidentification;\n};\n\n#define\tIP6_MF\t\t0x0001\n#define\tIP6_OFFSET\t0xFFF8\n\n#define IP6_REPLY_MARK(net, mark) \\\n\t((net)->ipv6.sysctl.fwmark_reflect ? (mark) : 0)\n\n#include <net/sock.h>\n\n/* sysctls */\nextern int sysctl_mld_max_msf;\nextern int sysctl_mld_qrv;\n\n#define _DEVINC(net, statname, modifier, idev, field)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_INC_STATS##modifier((_idev)->stats.statname, (field)); \\\n\tSNMP_INC_STATS##modifier((net)->mib.statname##_statistics, (field));\\\n})\n\n/* per device counters are atomic_long_t */\n#define _DEVINCATOMIC(net, statname, modifier, idev, field)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_INC_STATS_ATOMIC_LONG((_idev)->stats.statname##dev, (field)); \\\n\tSNMP_INC_STATS##modifier((net)->mib.statname##_statistics, (field));\\\n})\n\n/* per device and per net counters are atomic_long_t */\n#define _DEVINC_ATOMIC_ATOMIC(net, statname, idev, field)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_INC_STATS_ATOMIC_LONG((_idev)->stats.statname##dev, (field)); \\\n\tSNMP_INC_STATS_ATOMIC_LONG((net)->mib.statname##_statistics, (field));\\\n})\n\n#define _DEVADD(net, statname, modifier, idev, field, val)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_ADD_STATS##modifier((_idev)->stats.statname, (field), (val)); \\\n\tSNMP_ADD_STATS##modifier((net)->mib.statname##_statistics, (field), (val));\\\n})\n\n#define _DEVUPD(net, statname, modifier, idev, field, val)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_UPD_PO_STATS##modifier((_idev)->stats.statname, field, (val)); \\\n\tSNMP_UPD_PO_STATS##modifier((net)->mib.statname##_statistics, field, (val));\\\n})\n\n/* MIBs */\n\n#define IP6_INC_STATS(net, idev,field)\t\t\\\n\t\t_DEVINC(net, ipv6, 64, idev, field)\n#define IP6_INC_STATS_BH(net, idev,field)\t\\\n\t\t_DEVINC(net, ipv6, 64_BH, idev, field)\n#define IP6_ADD_STATS(net, idev,field,val)\t\\\n\t\t_DEVADD(net, ipv6, 64, idev, field, val)\n#define IP6_ADD_STATS_BH(net, idev,field,val)\t\\\n\t\t_DEVADD(net, ipv6, 64_BH, idev, field, val)\n#define IP6_UPD_PO_STATS(net, idev,field,val)   \\\n\t\t_DEVUPD(net, ipv6, 64, idev, field, val)\n#define IP6_UPD_PO_STATS_BH(net, idev,field,val)   \\\n\t\t_DEVUPD(net, ipv6, 64_BH, idev, field, val)\n#define ICMP6_INC_STATS(net, idev, field)\t\\\n\t\t_DEVINCATOMIC(net, icmpv6, , idev, field)\n#define ICMP6_INC_STATS_BH(net, idev, field)\t\\\n\t\t_DEVINCATOMIC(net, icmpv6, _BH, idev, field)\n\n#define ICMP6MSGOUT_INC_STATS(net, idev, field)\t\t\\\n\t_DEVINC_ATOMIC_ATOMIC(net, icmpv6msg, idev, field +256)\n#define ICMP6MSGOUT_INC_STATS_BH(net, idev, field)\t\\\n\t_DEVINC_ATOMIC_ATOMIC(net, icmpv6msg, idev, field +256)\n#define ICMP6MSGIN_INC_STATS_BH(net, idev, field)\t\\\n\t_DEVINC_ATOMIC_ATOMIC(net, icmpv6msg, idev, field)\n\nstruct ip6_ra_chain {\n\tstruct ip6_ra_chain\t*next;\n\tstruct sock\t\t*sk;\n\tint\t\t\tsel;\n\tvoid\t\t\t(*destructor)(struct sock *);\n};\n\nextern struct ip6_ra_chain\t*ip6_ra_chain;\nextern rwlock_t ip6_ra_lock;\n\n/*\n   This structure is prepared by protocol, when parsing\n   ancillary data and passed to IPv6.\n */\n\nstruct ipv6_txoptions {\n\t/* Length of this structure */\n\tint\t\t\ttot_len;\n\n\t/* length of extension headers   */\n\n\t__u16\t\t\topt_flen;\t/* after fragment hdr */\n\t__u16\t\t\topt_nflen;\t/* before fragment hdr */\n\n\tstruct ipv6_opt_hdr\t*hopopt;\n\tstruct ipv6_opt_hdr\t*dst0opt;\n\tstruct ipv6_rt_hdr\t*srcrt;\t/* Routing Header */\n\tstruct ipv6_opt_hdr\t*dst1opt;\n\n\t/* Option buffer, as read by IPV6_PKTOPTIONS, starts here. */\n};\n\nstruct ip6_flowlabel {\n\tstruct ip6_flowlabel __rcu *next;\n\t__be32\t\t\tlabel;\n\tatomic_t\t\tusers;\n\tstruct in6_addr\t\tdst;\n\tstruct ipv6_txoptions\t*opt;\n\tunsigned long\t\tlinger;\n\tstruct rcu_head\t\trcu;\n\tu8\t\t\tshare;\n\tunion {\n\t\tstruct pid *pid;\n\t\tkuid_t uid;\n\t} owner;\n\tunsigned long\t\tlastuse;\n\tunsigned long\t\texpires;\n\tstruct net\t\t*fl_net;\n};\n\n#define IPV6_FLOWINFO_MASK\t\tcpu_to_be32(0x0FFFFFFF)\n#define IPV6_FLOWLABEL_MASK\t\tcpu_to_be32(0x000FFFFF)\n#define IPV6_FLOWLABEL_STATELESS_FLAG\tcpu_to_be32(0x00080000)\n\n#define IPV6_TCLASS_MASK (IPV6_FLOWINFO_MASK & ~IPV6_FLOWLABEL_MASK)\n#define IPV6_TCLASS_SHIFT\t20\n\nstruct ipv6_fl_socklist {\n\tstruct ipv6_fl_socklist\t__rcu\t*next;\n\tstruct ip6_flowlabel\t\t*fl;\n\tstruct rcu_head\t\t\trcu;\n};\n\nstruct ip6_flowlabel *fl6_sock_lookup(struct sock *sk, __be32 label);\nstruct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t struct ip6_flowlabel *fl,\n\t\t\t\t\t struct ipv6_txoptions *fopt);\nvoid fl6_free_socklist(struct sock *sk);\nint ipv6_flowlabel_opt(struct sock *sk, char __user *optval, int optlen);\nint ipv6_flowlabel_opt_get(struct sock *sk, struct in6_flowlabel_req *freq,\n\t\t\t   int flags);\nint ip6_flowlabel_init(void);\nvoid ip6_flowlabel_cleanup(void);\n\nstatic inline void fl6_sock_release(struct ip6_flowlabel *fl)\n{\n\tif (fl)\n\t\tatomic_dec(&fl->users);\n}\n\nvoid icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info);\n\nint icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t       struct icmp6hdr *thdr, int len);\n\nint ip6_ra_control(struct sock *sk, int sel);\n\nint ipv6_parse_hopopts(struct sk_buff *skb);\n\nstruct ipv6_txoptions *ipv6_dup_options(struct sock *sk,\n\t\t\t\t\tstruct ipv6_txoptions *opt);\nstruct ipv6_txoptions *ipv6_renew_options(struct sock *sk,\n\t\t\t\t\t  struct ipv6_txoptions *opt,\n\t\t\t\t\t  int newtype,\n\t\t\t\t\t  struct ipv6_opt_hdr __user *newopt,\n\t\t\t\t\t  int newoptlen);\nstruct ipv6_txoptions *ipv6_fixup_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t  struct ipv6_txoptions *opt);\n\nbool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb,\n\t\t       const struct inet6_skb_parm *opt);\n\nstatic inline bool ipv6_accept_ra(struct inet6_dev *idev)\n{\n\t/* If forwarding is enabled, RA are not accepted unless the special\n\t * hybrid mode (accept_ra=2) is enabled.\n\t */\n\treturn idev->cnf.forwarding ? idev->cnf.accept_ra == 2 :\n\t    idev->cnf.accept_ra;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int ip6_frag_mem(struct net *net)\n{\n\treturn sum_frag_mem_limit(&net->ipv6.frags);\n}\n#endif\n\n#define IPV6_FRAG_HIGH_THRESH\t(4 * 1024*1024)\t/* 4194304 */\n#define IPV6_FRAG_LOW_THRESH\t(3 * 1024*1024)\t/* 3145728 */\n#define IPV6_FRAG_TIMEOUT\t(60 * HZ)\t/* 60 seconds */\n\nint __ipv6_addr_type(const struct in6_addr *addr);\nstatic inline int ipv6_addr_type(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_type(addr) & 0xffff;\n}\n\nstatic inline int ipv6_addr_scope(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_type(addr) & IPV6_ADDR_SCOPE_MASK;\n}\n\nstatic inline int __ipv6_addr_src_scope(int type)\n{\n\treturn (type == IPV6_ADDR_ANY) ? __IPV6_ADDR_SCOPE_INVALID : (type >> 16);\n}\n\nstatic inline int ipv6_addr_src_scope(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_src_scope(__ipv6_addr_type(addr));\n}\n\nstatic inline bool __ipv6_addr_needs_scope_id(int type)\n{\n\treturn type & IPV6_ADDR_LINKLOCAL ||\n\t       (type & IPV6_ADDR_MULTICAST &&\n\t\t(type & (IPV6_ADDR_LOOPBACK|IPV6_ADDR_LINKLOCAL)));\n}\n\nstatic inline __u32 ipv6_iface_scope_id(const struct in6_addr *addr, int iface)\n{\n\treturn __ipv6_addr_needs_scope_id(__ipv6_addr_type(addr)) ? iface : 0;\n}\n\nstatic inline int ipv6_addr_cmp(const struct in6_addr *a1, const struct in6_addr *a2)\n{\n\treturn memcmp(a1, a2, sizeof(struct in6_addr));\n}\n\nstatic inline bool\nipv6_masked_addr_cmp(const struct in6_addr *a1, const struct in6_addr *m,\n\t\t     const struct in6_addr *a2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul1 = (const unsigned long *)a1;\n\tconst unsigned long *ulm = (const unsigned long *)m;\n\tconst unsigned long *ul2 = (const unsigned long *)a2;\n\n\treturn !!(((ul1[0] ^ ul2[0]) & ulm[0]) |\n\t\t  ((ul1[1] ^ ul2[1]) & ulm[1]));\n#else\n\treturn !!(((a1->s6_addr32[0] ^ a2->s6_addr32[0]) & m->s6_addr32[0]) |\n\t\t  ((a1->s6_addr32[1] ^ a2->s6_addr32[1]) & m->s6_addr32[1]) |\n\t\t  ((a1->s6_addr32[2] ^ a2->s6_addr32[2]) & m->s6_addr32[2]) |\n\t\t  ((a1->s6_addr32[3] ^ a2->s6_addr32[3]) & m->s6_addr32[3]));\n#endif\n}\n\nstatic inline void ipv6_addr_prefix(struct in6_addr *pfx, \n\t\t\t\t    const struct in6_addr *addr,\n\t\t\t\t    int plen)\n{\n\t/* caller must guarantee 0 <= plen <= 128 */\n\tint o = plen >> 3,\n\t    b = plen & 0x7;\n\n\tmemset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));\n\tmemcpy(pfx->s6_addr, addr, o);\n\tif (b != 0)\n\t\tpfx->s6_addr[o] = addr->s6_addr[o] & (0xff00 >> b);\n}\n\nstatic inline void __ipv6_addr_set_half(__be32 *addr,\n\t\t\t\t\t__be32 wh, __be32 wl)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n#if defined(__BIG_ENDIAN)\n\tif (__builtin_constant_p(wh) && __builtin_constant_p(wl)) {\n\t\t*(__force u64 *)addr = ((__force u64)(wh) << 32 | (__force u64)(wl));\n\t\treturn;\n\t}\n#elif defined(__LITTLE_ENDIAN)\n\tif (__builtin_constant_p(wl) && __builtin_constant_p(wh)) {\n\t\t*(__force u64 *)addr = ((__force u64)(wl) << 32 | (__force u64)(wh));\n\t\treturn;\n\t}\n#endif\n#endif\n\taddr[0] = wh;\n\taddr[1] = wl;\n}\n\nstatic inline void ipv6_addr_set(struct in6_addr *addr, \n\t\t\t\t     __be32 w1, __be32 w2,\n\t\t\t\t     __be32 w3, __be32 w4)\n{\n\t__ipv6_addr_set_half(&addr->s6_addr32[0], w1, w2);\n\t__ipv6_addr_set_half(&addr->s6_addr32[2], w3, w4);\n}\n\nstatic inline bool ipv6_addr_equal(const struct in6_addr *a1,\n\t\t\t\t   const struct in6_addr *a2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul1 = (const unsigned long *)a1;\n\tconst unsigned long *ul2 = (const unsigned long *)a2;\n\n\treturn ((ul1[0] ^ ul2[0]) | (ul1[1] ^ ul2[1])) == 0UL;\n#else\n\treturn ((a1->s6_addr32[0] ^ a2->s6_addr32[0]) |\n\t\t(a1->s6_addr32[1] ^ a2->s6_addr32[1]) |\n\t\t(a1->s6_addr32[2] ^ a2->s6_addr32[2]) |\n\t\t(a1->s6_addr32[3] ^ a2->s6_addr32[3])) == 0;\n#endif\n}\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\nstatic inline bool __ipv6_prefix_equal64_half(const __be64 *a1,\n\t\t\t\t\t      const __be64 *a2,\n\t\t\t\t\t      unsigned int len)\n{\n\tif (len && ((*a1 ^ *a2) & cpu_to_be64((~0UL) << (64 - len))))\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline bool ipv6_prefix_equal(const struct in6_addr *addr1,\n\t\t\t\t     const struct in6_addr *addr2,\n\t\t\t\t     unsigned int prefixlen)\n{\n\tconst __be64 *a1 = (const __be64 *)addr1;\n\tconst __be64 *a2 = (const __be64 *)addr2;\n\n\tif (prefixlen >= 64) {\n\t\tif (a1[0] ^ a2[0])\n\t\t\treturn false;\n\t\treturn __ipv6_prefix_equal64_half(a1 + 1, a2 + 1, prefixlen - 64);\n\t}\n\treturn __ipv6_prefix_equal64_half(a1, a2, prefixlen);\n}\n#else\nstatic inline bool ipv6_prefix_equal(const struct in6_addr *addr1,\n\t\t\t\t     const struct in6_addr *addr2,\n\t\t\t\t     unsigned int prefixlen)\n{\n\tconst __be32 *a1 = addr1->s6_addr32;\n\tconst __be32 *a2 = addr2->s6_addr32;\n\tunsigned int pdw, pbi;\n\n\t/* check complete u32 in prefix */\n\tpdw = prefixlen >> 5;\n\tif (pdw && memcmp(a1, a2, pdw << 2))\n\t\treturn false;\n\n\t/* check incomplete u32 in prefix */\n\tpbi = prefixlen & 0x1f;\n\tif (pbi && ((a1[pdw] ^ a2[pdw]) & htonl((0xffffffff) << (32 - pbi))))\n\t\treturn false;\n\n\treturn true;\n}\n#endif\n\nstruct inet_frag_queue;\n\nenum ip6_defrag_users {\n\tIP6_DEFRAG_LOCAL_DELIVER,\n\tIP6_DEFRAG_CONNTRACK_IN,\n\t__IP6_DEFRAG_CONNTRACK_IN\t= IP6_DEFRAG_CONNTRACK_IN + USHRT_MAX,\n\tIP6_DEFRAG_CONNTRACK_OUT,\n\t__IP6_DEFRAG_CONNTRACK_OUT\t= IP6_DEFRAG_CONNTRACK_OUT + USHRT_MAX,\n\tIP6_DEFRAG_CONNTRACK_BRIDGE_IN,\n\t__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = IP6_DEFRAG_CONNTRACK_BRIDGE_IN + USHRT_MAX,\n};\n\nstruct ip6_create_arg {\n\t__be32 id;\n\tu32 user;\n\tconst struct in6_addr *src;\n\tconst struct in6_addr *dst;\n\tint iif;\n\tu8 ecn;\n};\n\nvoid ip6_frag_init(struct inet_frag_queue *q, const void *a);\nbool ip6_frag_match(const struct inet_frag_queue *q, const void *a);\n\n/*\n *\tEquivalent of ipv4 struct ip\n */\nstruct frag_queue {\n\tstruct inet_frag_queue\tq;\n\n\t__be32\t\t\tid;\t\t/* fragment id\t\t*/\n\tu32\t\t\tuser;\n\tstruct in6_addr\t\tsaddr;\n\tstruct in6_addr\t\tdaddr;\n\n\tint\t\t\tiif;\n\tunsigned int\t\tcsum;\n\t__u16\t\t\tnhoffset;\n\tu8\t\t\tecn;\n};\n\nvoid ip6_expire_frag_queue(struct net *net, struct frag_queue *fq,\n\t\t\t   struct inet_frags *frags);\n\nstatic inline bool ipv6_addr_any(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul = (const unsigned long *)a;\n\n\treturn (ul[0] | ul[1]) == 0UL;\n#else\n\treturn (a->s6_addr32[0] | a->s6_addr32[1] |\n\t\ta->s6_addr32[2] | a->s6_addr32[3]) == 0;\n#endif\n}\n\nstatic inline u32 ipv6_addr_hash(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul = (const unsigned long *)a;\n\tunsigned long x = ul[0] ^ ul[1];\n\n\treturn (u32)(x ^ (x >> 32));\n#else\n\treturn (__force u32)(a->s6_addr32[0] ^ a->s6_addr32[1] ^\n\t\t\t     a->s6_addr32[2] ^ a->s6_addr32[3]);\n#endif\n}\n\n/* more secured version of ipv6_addr_hash() */\nstatic inline u32 __ipv6_addr_jhash(const struct in6_addr *a, const u32 initval)\n{\n\tu32 v = (__force u32)a->s6_addr32[0] ^ (__force u32)a->s6_addr32[1];\n\n\treturn jhash_3words(v,\n\t\t\t    (__force u32)a->s6_addr32[2],\n\t\t\t    (__force u32)a->s6_addr32[3],\n\t\t\t    initval);\n}\n\nstatic inline bool ipv6_addr_loopback(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst __be64 *be = (const __be64 *)a;\n\n\treturn (be[0] | (be[1] ^ cpu_to_be64(1))) == 0UL;\n#else\n\treturn (a->s6_addr32[0] | a->s6_addr32[1] |\n\t\ta->s6_addr32[2] | (a->s6_addr32[3] ^ cpu_to_be32(1))) == 0;\n#endif\n}\n\n/*\n * Note that we must __force cast these to unsigned long to make sparse happy,\n * since all of the endian-annotated types are fixed size regardless of arch.\n */\nstatic inline bool ipv6_addr_v4mapped(const struct in6_addr *a)\n{\n\treturn (\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\t\t*(unsigned long *)a |\n#else\n\t\t(__force unsigned long)(a->s6_addr32[0] | a->s6_addr32[1]) |\n#endif\n\t\t(__force unsigned long)(a->s6_addr32[2] ^\n\t\t\t\t\tcpu_to_be32(0x0000ffff))) == 0UL;\n}\n\n/*\n * Check for a RFC 4843 ORCHID address\n * (Overlay Routable Cryptographic Hash Identifiers)\n */\nstatic inline bool ipv6_addr_orchid(const struct in6_addr *a)\n{\n\treturn (a->s6_addr32[0] & htonl(0xfffffff0)) == htonl(0x20010010);\n}\n\nstatic inline bool ipv6_addr_is_multicast(const struct in6_addr *addr)\n{\n\treturn (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);\n}\n\nstatic inline void ipv6_addr_set_v4mapped(const __be32 addr,\n\t\t\t\t\t  struct in6_addr *v4mapped)\n{\n\tipv6_addr_set(v4mapped,\n\t\t\t0, 0,\n\t\t\thtonl(0x0000FFFF),\n\t\t\taddr);\n}\n\n/*\n * find the first different bit between two addresses\n * length of address must be a multiple of 32bits\n */\nstatic inline int __ipv6_addr_diff32(const void *token1, const void *token2, int addrlen)\n{\n\tconst __be32 *a1 = token1, *a2 = token2;\n\tint i;\n\n\taddrlen >>= 2;\n\n\tfor (i = 0; i < addrlen; i++) {\n\t\t__be32 xb = a1[i] ^ a2[i];\n\t\tif (xb)\n\t\t\treturn i * 32 + 31 - __fls(ntohl(xb));\n\t}\n\n\t/*\n\t *\twe should *never* get to this point since that \n\t *\twould mean the addrs are equal\n\t *\n\t *\tHowever, we do get to it 8) And exacly, when\n\t *\taddresses are equal 8)\n\t *\n\t *\tip route add 1111::/128 via ...\n\t *\tip route add 1111::/64 via ...\n\t *\tand we are here.\n\t *\n\t *\tIdeally, this function should stop comparison\n\t *\tat prefix length. It does not, but it is still OK,\n\t *\tif returned value is greater than prefix length.\n\t *\t\t\t\t\t--ANK (980803)\n\t */\n\treturn addrlen << 5;\n}\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\nstatic inline int __ipv6_addr_diff64(const void *token1, const void *token2, int addrlen)\n{\n\tconst __be64 *a1 = token1, *a2 = token2;\n\tint i;\n\n\taddrlen >>= 3;\n\n\tfor (i = 0; i < addrlen; i++) {\n\t\t__be64 xb = a1[i] ^ a2[i];\n\t\tif (xb)\n\t\t\treturn i * 64 + 63 - __fls(be64_to_cpu(xb));\n\t}\n\n\treturn addrlen << 6;\n}\n#endif\n\nstatic inline int __ipv6_addr_diff(const void *token1, const void *token2, int addrlen)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tif (__builtin_constant_p(addrlen) && !(addrlen & 7))\n\t\treturn __ipv6_addr_diff64(token1, token2, addrlen);\n#endif\n\treturn __ipv6_addr_diff32(token1, token2, addrlen);\n}\n\nstatic inline int ipv6_addr_diff(const struct in6_addr *a1, const struct in6_addr *a2)\n{\n\treturn __ipv6_addr_diff(a1, a2, sizeof(struct in6_addr));\n}\n\n__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr);\nvoid ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb);\n\nint ip6_dst_hoplimit(struct dst_entry *dst);\n\nstatic inline int ip6_sk_dst_hoplimit(struct ipv6_pinfo *np, struct flowi6 *fl6,\n\t\t\t\t      struct dst_entry *dst)\n{\n\tint hlimit;\n\n\tif (ipv6_addr_is_multicast(&fl6->daddr))\n\t\thlimit = np->mcast_hops;\n\telse\n\t\thlimit = np->hop_limit;\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\treturn hlimit;\n}\n\n/* copy IPv6 saddr & daddr to flow_keys, possibly using 64bit load/store\n * Equivalent to :\tflow->v6addrs.src = iph->saddr;\n *\t\t\tflow->v6addrs.dst = iph->daddr;\n */\nstatic inline void iph_to_flow_copy_v6addrs(struct flow_keys *flow,\n\t\t\t\t\t    const struct ipv6hdr *iph)\n{\n\tBUILD_BUG_ON(offsetof(typeof(flow->addrs), v6addrs.dst) !=\n\t\t     offsetof(typeof(flow->addrs), v6addrs.src) +\n\t\t     sizeof(flow->addrs.v6addrs.src));\n\tmemcpy(&flow->addrs.v6addrs, &iph->saddr, sizeof(flow->addrs.v6addrs));\n\tflow->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\n/* Sysctl settings for net ipv6.auto_flowlabels */\n#define IP6_AUTO_FLOW_LABEL_OFF\t\t0\n#define IP6_AUTO_FLOW_LABEL_OPTOUT\t1\n#define IP6_AUTO_FLOW_LABEL_OPTIN\t2\n#define IP6_AUTO_FLOW_LABEL_FORCED\t3\n\n#define IP6_AUTO_FLOW_LABEL_MAX\t\tIP6_AUTO_FLOW_LABEL_FORCED\n\n#define IP6_DEFAULT_AUTO_FLOW_LABELS\tIP6_AUTO_FLOW_LABEL_OPTOUT\n\nstatic inline __be32 ip6_make_flowlabel(struct net *net, struct sk_buff *skb,\n\t\t\t\t\t__be32 flowlabel, bool autolabel,\n\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tu32 hash;\n\n\tif (flowlabel ||\n\t    net->ipv6.sysctl.auto_flowlabels == IP6_AUTO_FLOW_LABEL_OFF ||\n\t    (!autolabel &&\n\t     net->ipv6.sysctl.auto_flowlabels != IP6_AUTO_FLOW_LABEL_FORCED))\n\t\treturn flowlabel;\n\n\thash = skb_get_hash_flowi6(skb, fl6);\n\n\t/* Since this is being sent on the wire obfuscate hash a bit\n\t * to minimize possbility that any useful information to an\n\t * attacker is leaked. Only lower 20 bits are relevant.\n\t */\n\trol32(hash, 16);\n\n\tflowlabel = (__force __be32)hash & IPV6_FLOWLABEL_MASK;\n\n\tif (net->ipv6.sysctl.flowlabel_state_ranges)\n\t\tflowlabel |= IPV6_FLOWLABEL_STATELESS_FLAG;\n\n\treturn flowlabel;\n}\n\nstatic inline int ip6_default_np_autolabel(struct net *net)\n{\n\tswitch (net->ipv6.sysctl.auto_flowlabels) {\n\tcase IP6_AUTO_FLOW_LABEL_OFF:\n\tcase IP6_AUTO_FLOW_LABEL_OPTIN:\n\tdefault:\n\t\treturn 0;\n\tcase IP6_AUTO_FLOW_LABEL_OPTOUT:\n\tcase IP6_AUTO_FLOW_LABEL_FORCED:\n\t\treturn 1;\n\t}\n}\n#else\nstatic inline void ip6_set_txhash(struct sock *sk) { }\nstatic inline __be32 ip6_make_flowlabel(struct net *net, struct sk_buff *skb,\n\t\t\t\t\t__be32 flowlabel, bool autolabel,\n\t\t\t\t\tstruct flowi6 *fl6)\n{\n\treturn flowlabel;\n}\nstatic inline int ip6_default_np_autolabel(struct net *net)\n{\n\treturn 0;\n}\n#endif\n\n\n/*\n *\tHeader manipulation\n */\nstatic inline void ip6_flow_hdr(struct ipv6hdr *hdr, unsigned int tclass,\n\t\t\t\t__be32 flowlabel)\n{\n\t*(__be32 *)hdr = htonl(0x60000000 | (tclass << 20)) | flowlabel;\n}\n\nstatic inline __be32 ip6_flowinfo(const struct ipv6hdr *hdr)\n{\n\treturn *(__be32 *)hdr & IPV6_FLOWINFO_MASK;\n}\n\nstatic inline __be32 ip6_flowlabel(const struct ipv6hdr *hdr)\n{\n\treturn *(__be32 *)hdr & IPV6_FLOWLABEL_MASK;\n}\n\nstatic inline u8 ip6_tclass(__be32 flowinfo)\n{\n\treturn ntohl(flowinfo & IPV6_TCLASS_MASK) >> IPV6_TCLASS_SHIFT;\n}\n/*\n *\tPrototypes exported by ipv6\n */\n\n/*\n *\trcv function (called from netdevice level)\n */\n\nint ipv6_rcv(struct sk_buff *skb, struct net_device *dev,\n\t     struct packet_type *pt, struct net_device *orig_dev);\n\nint ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb);\n\n/*\n *\tupper-layer output functions\n */\nint ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     struct ipv6_txoptions *opt, int tclass);\n\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr);\n\nint ip6_append_data(struct sock *sk,\n\t\t    int getfrag(void *from, char *to, int offset, int len,\n\t\t\t\tint odd, struct sk_buff *skb),\n\t\t    void *from, int length, int transhdrlen, int hlimit,\n\t\t    int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\t\t    struct rt6_info *rt, unsigned int flags, int dontfrag);\n\nint ip6_push_pending_frames(struct sock *sk);\n\nvoid ip6_flush_pending_frames(struct sock *sk);\n\nint ip6_send_skb(struct sk_buff *skb);\n\nstruct sk_buff *__ip6_make_skb(struct sock *sk, struct sk_buff_head *queue,\n\t\t\t       struct inet_cork_full *cork,\n\t\t\t       struct inet6_cork *v6_cork);\nstruct sk_buff *ip6_make_skb(struct sock *sk,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, int length, int transhdrlen,\n\t\t\t     int hlimit, int tclass, struct ipv6_txoptions *opt,\n\t\t\t     struct flowi6 *fl6, struct rt6_info *rt,\n\t\t\t     unsigned int flags, int dontfrag);\n\nstatic inline struct sk_buff *ip6_finish_skb(struct sock *sk)\n{\n\treturn __ip6_make_skb(sk, &sk->sk_write_queue, &inet_sk(sk)->cork,\n\t\t\t      &inet6_sk(sk)->cork);\n}\n\nint ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,\n\t\t   struct flowi6 *fl6);\nstruct dst_entry *ip6_dst_lookup_flow(const struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t      const struct in6_addr *final_dst);\nstruct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t\t const struct in6_addr *final_dst);\nstruct dst_entry *ip6_blackhole_route(struct net *net,\n\t\t\t\t      struct dst_entry *orig_dst);\n\n/*\n *\tskb processing functions\n */\n\nint ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb);\nint ip6_forward(struct sk_buff *skb);\nint ip6_input(struct sk_buff *skb);\nint ip6_mc_input(struct sk_buff *skb);\n\nint __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);\nint ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);\n\n/*\n *\tExtension header (options) processing\n */\n\nvoid ipv6_push_nfrag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t  u8 *proto, struct in6_addr **daddr_p);\nvoid ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t u8 *proto);\n\nint ipv6_skip_exthdr(const struct sk_buff *, int start, u8 *nexthdrp,\n\t\t     __be16 *frag_offp);\n\nbool ipv6_ext_hdr(u8 nexthdr);\n\nenum {\n\tIP6_FH_F_FRAG\t\t= (1 << 0),\n\tIP6_FH_F_AUTH\t\t= (1 << 1),\n\tIP6_FH_F_SKIP_RH\t= (1 << 2),\n};\n\n/* find specified header and get offset to it */\nint ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset, int target,\n\t\t  unsigned short *fragoff, int *fragflg);\n\nint ipv6_find_tlv(struct sk_buff *skb, int offset, int type);\n\nstruct in6_addr *fl6_update_dst(struct flowi6 *fl6,\n\t\t\t\tconst struct ipv6_txoptions *opt,\n\t\t\t\tstruct in6_addr *orig);\n\n/*\n *\tsocket options (ipv6_sockglue.c)\n */\n\nint ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen);\nint ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen);\nint compat_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen);\nint compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen);\n\nint ip6_datagram_connect(struct sock *sk, struct sockaddr *addr, int addr_len);\nint ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *addr,\n\t\t\t\t int addr_len);\n\nint ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,\n\t\t    int *addr_len);\nint ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,\n\t\t     int *addr_len);\nvoid ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,\n\t\t     u32 info, u8 *payload);\nvoid ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info);\nvoid ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu);\n\nint inet6_release(struct socket *sock);\nint inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len);\nint inet6_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len,\n\t\t  int peer);\nint inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);\n\nint inet6_hash_connect(struct inet_timewait_death_row *death_row,\n\t\t\t      struct sock *sk);\n\n/*\n * reassembly.c\n */\nextern const struct proto_ops inet6_stream_ops;\nextern const struct proto_ops inet6_dgram_ops;\n\nstruct group_source_req;\nstruct group_filter;\n\nint ip6_mc_source(int add, int omode, struct sock *sk,\n\t\t  struct group_source_req *pgsr);\nint ip6_mc_msfilter(struct sock *sk, struct group_filter *gsf);\nint ip6_mc_msfget(struct sock *sk, struct group_filter *gsf,\n\t\t  struct group_filter __user *optval, int __user *optlen);\n\n#ifdef CONFIG_PROC_FS\nint ac6_proc_init(struct net *net);\nvoid ac6_proc_exit(struct net *net);\nint raw6_proc_init(void);\nvoid raw6_proc_exit(void);\nint tcp6_proc_init(struct net *net);\nvoid tcp6_proc_exit(struct net *net);\nint udp6_proc_init(struct net *net);\nvoid udp6_proc_exit(struct net *net);\nint udplite6_proc_init(void);\nvoid udplite6_proc_exit(void);\nint ipv6_misc_proc_init(void);\nvoid ipv6_misc_proc_exit(void);\nint snmp6_register_dev(struct inet6_dev *idev);\nint snmp6_unregister_dev(struct inet6_dev *idev);\n\n#else\nstatic inline int ac6_proc_init(struct net *net) { return 0; }\nstatic inline void ac6_proc_exit(struct net *net) { }\nstatic inline int snmp6_register_dev(struct inet6_dev *idev) { return 0; }\nstatic inline int snmp6_unregister_dev(struct inet6_dev *idev) { return 0; }\n#endif\n\n#ifdef CONFIG_SYSCTL\nextern struct ctl_table ipv6_route_table_template[];\n\nstruct ctl_table *ipv6_icmp_sysctl_init(struct net *net);\nstruct ctl_table *ipv6_route_sysctl_init(struct net *net);\nint ipv6_sysctl_register(void);\nvoid ipv6_sysctl_unregister(void);\n#endif\n\nint ipv6_sock_mc_join(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\nint ipv6_sock_mc_drop(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\n#endif /* _NET_IPV6_H */\n", "/*\n *\tDCCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tBased on net/dccp6/ipv6.c\n *\n *\tArnaldo Carvalho de Melo <acme@ghostprotocols.net>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/xfrm.h>\n\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/inet_sock.h>\n#include <net/inet6_connection_sock.h>\n#include <net/inet6_hashtables.h>\n#include <net/ip6_route.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n#include <net/secure_seq.h>\n\n#include \"dccp.h\"\n#include \"ipv6.h\"\n#include \"feat.h\"\n\n/* The per-net dccp.v6_ctl_sk is used for sending RSTs and ACKs */\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops;\n\n/* add pseudo-header to DCCP checksum stored in skb->csum */\nstatic inline __sum16 dccp_v6_csum_finish(struct sk_buff *skb,\n\t\t\t\t      const struct in6_addr *saddr,\n\t\t\t\t      const struct in6_addr *daddr)\n{\n\treturn csum_ipv6_magic(saddr, daddr, skb->len, IPPROTO_DCCP, skb->csum);\n}\n\nstatic inline void dccp_v6_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\tdccp_csum_outgoing(skb);\n\tdh->dccph_checksum = dccp_v6_csum_finish(skb, &np->saddr, &sk->sk_v6_daddr);\n}\n\nstatic inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n\n}\n\nstatic void dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct dccp_hdr *dh = (struct dccp_hdr *)(skb->data + offset);\n\tstruct dccp_sock *dp;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tint err;\n\t__u64 seq;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->len < offset + sizeof(*dh) ||\n\t    skb->len < offset + __dccp_basic_hdr_len(dh)) {\n\t\tICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\n\t\t\t\t   ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tsk = __inet6_lookup_established(net, &dccp_hashinfo,\n\t\t\t\t\t&hdr->daddr, dh->dccph_dport,\n\t\t\t\t\t&hdr->saddr, ntohs(dh->dccph_sport),\n\t\t\t\t\tinet6_iif(skb));\n\n\tif (!sk) {\n\t\tICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\n\t\t\t\t   ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = dccp_hdr_seq(dh);\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV)\n\t\treturn dccp_req_err(sk, seq);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk))\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == DCCP_CLOSED)\n\t\tgoto out;\n\n\tdp = dccp_sk(sk);\n\tif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_LISTEN) &&\n\t    !between48(seq, dp->dccps_awl, dp->dccps_awh)) {\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\tif (dst)\n\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tstruct dst_entry *dst = NULL;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\tif (sock_owned_by_user(sk))\n\t\t\tgoto out;\n\t\tif ((1 << sk->sk_state) & (DCCPF_LISTEN | DCCPF_CLOSED))\n\t\t\tgoto out;\n\n\t\tdst = inet6_csk_update_pmtu(sk, ntohl(info));\n\t\tif (!dst)\n\t\t\tgoto out;\n\n\t\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst))\n\t\t\tdccp_sync_mss(sk, dst_mtu(dst));\n\t\tgoto out;\n\t}\n\n\ticmpv6_err_convert(type, code, &err);\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\tcase DCCP_RESPOND:  /* Cannot happen.\n\t\t\t       It can, it SYNs are crossed. --ANK */\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tDCCP_INC_STATS_BH(DCCP_MIB_ATTEMPTFAILS);\n\t\t\tsk->sk_err = err;\n\t\t\t/*\n\t\t\t * Wake people up to see the error\n\t\t\t * (see connect in sock.c)\n\t\t\t */\n\t\t\tsk->sk_error_report(sk);\n\t\t\tdccp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\n\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\terr = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic void dccp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tdccp_feat_list_purge(&dccp_rsk(req)->dreq_featneg);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\nstatic void dccp_v6_ctl_send_reset(const struct sock *sk, struct sk_buff *rxskb)\n{\n\tconst struct ipv6hdr *rxip6h;\n\tstruct sk_buff *skb;\n\tstruct flowi6 fl6;\n\tstruct net *net = dev_net(skb_dst(rxskb)->dev);\n\tstruct sock *ctl_sk = net->dccp.v6_ctl_sk;\n\tstruct dst_entry *dst;\n\n\tif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\n\t\treturn;\n\n\tif (!ipv6_unicast_destination(rxskb))\n\t\treturn;\n\n\tskb = dccp_ctl_make_reset(ctl_sk, rxskb);\n\tif (skb == NULL)\n\t\treturn;\n\n\trxip6h = ipv6_hdr(rxskb);\n\tdccp_hdr(skb)->dccph_checksum = dccp_v6_csum_finish(skb, &rxip6h->saddr,\n\t\t\t\t\t\t\t    &rxip6h->daddr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = rxip6h->saddr;\n\tfl6.saddr = rxip6h->daddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.flowi6_oif = inet6_iif(rxskb);\n\tfl6.fl6_dport = dccp_hdr(skb)->dccph_dport;\n\tfl6.fl6_sport = dccp_hdr(skb)->dccph_sport;\n\tsecurity_skb_classify_flow(rxskb, flowi6_to_flowi(&fl6));\n\n\t/* sk = NULL, but it is safe for now. RST socket required. */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(skb, dst);\n\t\tip6_xmit(ctl_sk, skb, &fl6, NULL, 0);\n\t\tDCCP_INC_STATS_BH(DCCP_MIB_OUTSEGS);\n\t\tDCCP_INC_STATS_BH(DCCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic struct request_sock_ops dccp6_request_sock_ops = {\n\t.family\t\t= AF_INET6,\n\t.obj_size\t= sizeof(struct dccp6_request_sock),\n\t.rtx_syn_ack\t= dccp_v6_send_response,\n\t.send_ack\t= dccp_reqsk_send_ack,\n\t.destructor\t= dccp_v6_reqsk_destructor,\n\t.send_reset\t= dccp_v6_ctl_send_reset,\n\t.syn_ack_timeout = dccp_syn_ack_timeout,\n};\n\nstatic int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct request_sock *req;\n\tstruct dccp_request_sock *dreq;\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tconst __be32 service = dccp_hdr_request(skb)->dccph_req_service;\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\treturn 0;\t/* discard, don't send a reset here */\n\n\tif (dccp_bad_service_code(sk, service)) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_BAD_SERVICE_CODE;\n\t\tgoto drop;\n\t}\n\t/*\n\t * There are no SYN attacks on IPv6, yet...\n\t */\n\tdcb->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\n\tif (inet_csk_reqsk_queue_is_full(sk))\n\t\tgoto drop;\n\n\tif (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1)\n\t\tgoto drop;\n\n\treq = inet_reqsk_alloc(&dccp6_request_sock_ops, sk, true);\n\tif (req == NULL)\n\t\tgoto drop;\n\n\tif (dccp_reqsk_init(req, dccp_sk(sk), skb))\n\t\tgoto drop_and_free;\n\n\tdreq = dccp_rsk(req);\n\tif (dccp_parse_options(sk, dreq, skb))\n\t\tgoto drop_and_free;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\tireq = inet_rsk(req);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tireq->ireq_family = AF_INET6;\n\n\tif (ipv6_opt_accepted(sk, skb, IP6CB(skb)) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = inet6_iif(skb);\n\n\t/*\n\t * Step 3: Process LISTEN state\n\t *\n\t *   Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookie\n\t *\n\t * Setting S.SWL/S.SWH to is deferred to dccp_create_openreq_child().\n\t */\n\tdreq->dreq_isr\t   = dcb->dccpd_seq;\n\tdreq->dreq_gsr     = dreq->dreq_isr;\n\tdreq->dreq_iss\t   = dccp_v6_init_sequence(skb);\n\tdreq->dreq_gss     = dreq->dreq_iss;\n\tdreq->dreq_service = service;\n\n\tif (dccp_v6_send_response(sk, req))\n\t\tgoto drop_and_free;\n\n\tinet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);\n\treturn 0;\n\ndrop_and_free:\n\treqsk_free(req);\ndrop:\n\tDCCP_INC_STATS_BH(DCCP_MIB_ATTEMPTFAILS);\n\treturn -1;\n}\n\nstatic struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst,\n\t\t\t\t\t      struct request_sock *req_unhash,\n\t\t\t\t\t      bool *own_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t  req_unhash, own_req);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;\n\tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if\t= ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\tif (np->opt != NULL)\n\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt != NULL)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\tdccp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\t/* Clone pktoptions received with SYN, if we own the req */\n\tif (*own_req && ireq->pktopts) {\n\t\tnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);\n\t\tconsume_skb(ireq->pktopts);\n\t\tireq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n\n/* The socket must have it's spinlock held when we get\n * here.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, dccp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   dccp_v6_hnd_req and dccp_v6_ctl_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t * socket locking is here for SMP purposes as backlog rcv is currently\n\t * called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t/*\n\t * FIXME: Add handling of IPV6_PKTOPTIONS skb. See the comments below\n\t *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.\n\t */\n\t\topt_skb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (sk->sk_state == DCCP_OPEN) { /* Fast path */\n\t\tif (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))\n\t\t\tgoto reset;\n\t\tif (opt_skb) {\n\t\t\t/* XXX This is where we would goto ipv6_pktoptions. */\n\t\t\t__kfree_skb(opt_skb);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies\n\t *\t      Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t *\n\t * NOTE: the check for the packet types is done in\n\t *\t dccp_rcv_state_process\n\t */\n\n\tif (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))\n\t\tgoto reset;\n\tif (opt_skb) {\n\t\t/* XXX This is where we would goto ipv6_pktoptions. */\n\t\t__kfree_skb(opt_skb);\n\t}\n\treturn 0;\n\nreset:\n\tdccp_v6_ctl_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb != NULL)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int dccp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t/* Step 1: Check header basics */\n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\t/* Step 1: If header checksum is incorrect, drop packet and return. */\n\tif (dccp_v6_csum_finish(skb, &ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr)) {\n\t\tDCCP_WARN(\"dropped packet with invalid checksum\\n\");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tif (dccp_packet_without_ack(skb))\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\telse\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&dccp_hashinfo, skb,\n\t\t\t        dh->dccph_sport, dh->dccph_dport,\n\t\t\t\tinet6_iif(skb));\n\tif (!sk) {\n\t\tdccp_pr_debug(\"failed to look up flow ID in table and \"\n\t\t\t      \"get corresponding socket\\n\");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t/*\n\t * Step 2:\n\t *\t... or S.state == TIMEWAIT,\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug(\"sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n\");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk = NULL;\n\n\t\tsk = req->rsk_listener;\n\t\tif (likely(sk->sk_state == DCCP_LISTEN)) {\n\t\t\tnsk = dccp_check_req(sk, skb, req);\n\t\t} else {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\tsock_hold(sk);\n\t\t\treqsk_put(req);\n\t\t} else if (dccp_child_process(sk, nsk, skb)) {\n\t\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t\t\tgoto discard_it;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * RFC 4340, sec. 9.2.1: Minimum Checksum Coverage\n\t *\to if MinCsCov = 0, only packets with CsCov = 0 are accepted\n\t *\to if MinCsCov > 0, also accept packets with CsCov >= MinCsCov\n\t */\n\tmin_cov = dccp_sk(sk)->dccps_pcrlen;\n\tif (dh->dccph_cscov  &&  (min_cov == 0 || dh->dccph_cscov < min_cov))  {\n\t\tdccp_pr_debug(\"Packet CsCov %d does not satisfy MinCsCov %d\\n\",\n\t\t\t      dh->dccph_cscov, min_cov);\n\t\t/* FIXME: send Data Dropped option (see also dccp_v4_rcv) */\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\treturn sk_receive_skb(sk, skb, 1) ? -1 : 0;\n\nno_dccp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\t/*\n\t * Step 2:\n\t *\tIf no socket ...\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type != DCCP_PKT_RESET) {\n\t\tDCCP_SKB_CB(skb)->dccpd_reset_code =\n\t\t\t\t\tDCCP_RESET_CODE_NO_CONNECTION;\n\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsock_put(sk);\n\tgoto discard_it;\n}\n\nstatic int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t   int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *)uaddr;\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\t/*\n\t * connect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t * DCCP over IPv4\n\t */\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\n\t\terr = dccp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &dccp_ipv6_af_ops;\n\t\t\tsk->sk_backlog_rcv = dccp_v6_do_rcv;\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (saddr == NULL) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\t__ip6_dst_store(sk, dst, NULL, NULL);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (np->opt != NULL)\n\t\ticsk->icsk_ext_hdr_len = (np->opt->opt_flen +\n\t\t\t\t\t  np->opt->opt_nflen);\n\n\tinet->inet_dport = usin->sin6_port;\n\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet6_hash_connect(&dccp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tdp->dccps_iss = secure_dccpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t      sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t      inet->inet_sport,\n\t\t\t\t\t\t      inet->inet_dport);\n\terr = dccp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\tdccp_set_state(sk, DCCP_CLOSED);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = dccp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\n/*\n *\tDCCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = dccp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int dccp_v6_init_sock(struct sock *sk)\n{\n\tstatic __u8 dccp_v6_ctl_sock_initialized;\n\tint err = dccp_init_sock(sk, dccp_v6_ctl_sock_initialized);\n\n\tif (err == 0) {\n\t\tif (unlikely(!dccp_v6_ctl_sock_initialized))\n\t\t\tdccp_v6_ctl_sock_initialized = 1;\n\t\tinet_csk(sk)->icsk_af_ops = &dccp_ipv6_af_ops;\n\t}\n\n\treturn err;\n}\n\nstatic void dccp_v6_destroy_sock(struct sock *sk)\n{\n\tdccp_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\nstatic struct timewait_sock_ops dccp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct dccp6_timewait_sock),\n};\n\nstatic struct proto dccp_v6_prot = {\n\t.name\t\t   = \"DCCPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = dccp_close,\n\t.connect\t   = dccp_v6_connect,\n\t.disconnect\t   = dccp_disconnect,\n\t.ioctl\t\t   = dccp_ioctl,\n\t.init\t\t   = dccp_v6_init_sock,\n\t.setsockopt\t   = dccp_setsockopt,\n\t.getsockopt\t   = dccp_getsockopt,\n\t.sendmsg\t   = dccp_sendmsg,\n\t.recvmsg\t   = dccp_recvmsg,\n\t.backlog_rcv\t   = dccp_v6_do_rcv,\n\t.hash\t\t   = inet_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.accept\t\t   = inet_csk_accept,\n\t.get_port\t   = inet_csk_get_port,\n\t.shutdown\t   = dccp_shutdown,\n\t.destroy\t   = dccp_v6_destroy_sock,\n\t.orphan_count\t   = &dccp_orphan_count,\n\t.max_header\t   = MAX_DCCP_HEADER,\n\t.obj_size\t   = sizeof(struct dccp6_sock),\n\t.slab_flags\t   = SLAB_DESTROY_BY_RCU,\n\t.rsk_prot\t   = &dccp6_request_sock_ops,\n\t.twsk_prot\t   = &dccp6_timewait_sock_ops,\n\t.h.hashinfo\t   = &dccp_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_dccp_setsockopt,\n\t.compat_getsockopt = compat_dccp_getsockopt,\n#endif\n};\n\nstatic const struct inet6_protocol dccp_v6_protocol = {\n\t.handler\t= dccp_v6_rcv,\n\t.err_handler\t= dccp_v6_err,\n\t.flags\t\t= INET6_PROTO_NOPOLICY | INET6_PROTO_FINAL,\n};\n\nstatic const struct proto_ops inet6_dccp_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = dccp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = inet_dccp_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw dccp_v6_protosw = {\n\t.type\t\t= SOCK_DCCP,\n\t.protocol\t= IPPROTO_DCCP,\n\t.prot\t\t= &dccp_v6_prot,\n\t.ops\t\t= &inet6_dccp_ops,\n\t.flags\t\t= INET_PROTOSW_ICSK,\n};\n\nstatic int __net_init dccp_v6_init_net(struct net *net)\n{\n\tif (dccp_hashinfo.bhash == NULL)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\treturn inet_ctl_sock_create(&net->dccp.v6_ctl_sk, PF_INET6,\n\t\t\t\t    SOCK_DCCP, IPPROTO_DCCP, net);\n}\n\nstatic void __net_exit dccp_v6_exit_net(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->dccp.v6_ctl_sk);\n}\n\nstatic struct pernet_operations dccp_v6_ops = {\n\t.init   = dccp_v6_init_net,\n\t.exit   = dccp_v6_exit_net,\n};\n\nstatic int __init dccp_v6_init(void)\n{\n\tint err = proto_register(&dccp_v6_prot, 1);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tif (err != 0)\n\t\tgoto out_unregister_proto;\n\n\tinet6_register_protosw(&dccp_v6_protosw);\n\n\terr = register_pernet_subsys(&dccp_v6_ops);\n\tif (err != 0)\n\t\tgoto out_destroy_ctl_sock;\nout:\n\treturn err;\n\nout_destroy_ctl_sock:\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\nout_unregister_proto:\n\tproto_unregister(&dccp_v6_prot);\n\tgoto out;\n}\n\nstatic void __exit dccp_v6_exit(void)\n{\n\tunregister_pernet_subsys(&dccp_v6_ops);\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\n\tproto_unregister(&dccp_v6_prot);\n}\n\nmodule_init(dccp_v6_init);\nmodule_exit(dccp_v6_exit);\n\n/*\n * __stringify doesn't likes enums, so use SOCK_DCCP (6) and IPPROTO_DCCP (33)\n * values directly, Also cover the case where the protocol is not specified,\n * i.e. net-pf-PF_INET6-proto-0-type-SOCK_DCCP\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 33, 6);\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 0, 6);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arnaldo Carvalho de Melo <acme@mandriva.com>\");\nMODULE_DESCRIPTION(\"DCCPv6 - Datagram Congestion Controlled Protocol\");\n", "/*\n *\tPF_INET6 socket protocol family\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tAdapted from linux/net/ipv4/af_inet.c\n *\n *\tFixes:\n *\tpiggy, Karl Knutson\t:\tSocket protocol table\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tArnaldo Melo\t\t:\tcheck proc_net_create return, cleanups\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/icmpv6.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <net/tcp.h>\n#include <net/ping.h>\n#include <net/protocol.h>\n#include <net/inet_common.h>\n#include <net/route.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/ndisc.h>\n#ifdef CONFIG_IPV6_TUNNEL\n#include <net/ip6_tunnel.h>\n#endif\n\n#include <asm/uaccess.h>\n#include <linux/mroute6.h>\n\nMODULE_AUTHOR(\"Cast of dozens\");\nMODULE_DESCRIPTION(\"IPv6 protocol stack for Linux\");\nMODULE_LICENSE(\"GPL\");\n\n/* The inetsw6 table contains everything that inet6_create needs to\n * build a new socket.\n */\nstatic struct list_head inetsw6[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw6_lock);\n\nstruct ipv6_params ipv6_defaults = {\n\t.disable_ipv6 = 0,\n\t.autoconf = 1,\n};\n\nstatic int disable_ipv6_mod;\n\nmodule_param_named(disable, disable_ipv6_mod, int, 0444);\nMODULE_PARM_DESC(disable, \"Disable IPv6 module such that it is non-functional\");\n\nmodule_param_named(disable_ipv6, ipv6_defaults.disable_ipv6, int, 0444);\nMODULE_PARM_DESC(disable_ipv6, \"Disable IPv6 on all interfaces\");\n\nmodule_param_named(autoconf, ipv6_defaults.autoconf, int, 0444);\nMODULE_PARM_DESC(autoconf, \"Enable IPv6 address autoconfiguration on all interfaces\");\n\nstatic __inline__ struct ipv6_pinfo *inet6_sk_generic(struct sock *sk)\n{\n\tconst int offset = sk->sk_prot->obj_size - sizeof(struct ipv6_pinfo);\n\n\treturn (struct ipv6_pinfo *)(((u8 *)sk) + offset);\n}\n\nstatic int inet6_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct inet_sock *inet;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tstruct inet_protosw *answer;\n\tstruct proto *answer_prot;\n\tunsigned char answer_flags;\n\tint try_loading_module = 0;\n\tint err;\n\n\t/* Look for the requested type/protocol pair. */\nlookup_protocol:\n\terr = -ESOCKTNOSUPPORT;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(answer, &inetsw6[sock->type], list) {\n\n\t\terr = 0;\n\t\t/* Check the non-wild match. */\n\t\tif (protocol == answer->protocol) {\n\t\t\tif (protocol != IPPROTO_IP)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Check for the two wild cases. */\n\t\t\tif (IPPROTO_IP == protocol) {\n\t\t\t\tprotocol = answer->protocol;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IPPROTO_IP == answer->protocol)\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\n\tif (err) {\n\t\tif (try_loading_module < 2) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * Be more specific, e.g. net-pf-10-proto-132-type-1\n\t\t\t * (net-pf-PF_INET6-proto-IPPROTO_SCTP-type-SOCK_STREAM)\n\t\t\t */\n\t\t\tif (++try_loading_module == 1)\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",\n\t\t\t\t\t\tPF_INET6, protocol, sock->type);\n\t\t\t/*\n\t\t\t * Fall back to generic, e.g. net-pf-10-proto-132\n\t\t\t * (net-pf-PF_INET6-proto-IPPROTO_SCTP)\n\t\t\t */\n\t\t\telse\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",\n\t\t\t\t\t\tPF_INET6, protocol);\n\t\t\tgoto lookup_protocol;\n\t\t} else\n\t\t\tgoto out_rcu_unlock;\n\t}\n\n\terr = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern &&\n\t    !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\tgoto out_rcu_unlock;\n\n\tsock->ops = answer->ops;\n\tanswer_prot = answer->prot;\n\tanswer_flags = answer->flags;\n\trcu_read_unlock();\n\n\tWARN_ON(!answer_prot->slab);\n\n\terr = -ENOBUFS;\n\tsk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\terr = 0;\n\tif (INET_PROTOSW_REUSE & answer_flags)\n\t\tsk->sk_reuse = SK_CAN_REUSE;\n\n\tinet = inet_sk(sk);\n\tinet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;\n\n\tif (SOCK_RAW == sock->type) {\n\t\tinet->inet_num = protocol;\n\t\tif (IPPROTO_RAW == protocol)\n\t\t\tinet->hdrincl = 1;\n\t}\n\n\tsk->sk_destruct\t\t= inet_sock_destruct;\n\tsk->sk_family\t\t= PF_INET6;\n\tsk->sk_protocol\t\t= protocol;\n\n\tsk->sk_backlog_rcv\t= answer->prot->backlog_rcv;\n\n\tinet_sk(sk)->pinet6 = np = inet6_sk_generic(sk);\n\tnp->hop_limit\t= -1;\n\tnp->mcast_hops\t= IPV6_DEFAULT_MCASTHOPS;\n\tnp->mc_loop\t= 1;\n\tnp->pmtudisc\t= IPV6_PMTUDISC_WANT;\n\tnp->autoflowlabel = ip6_default_np_autolabel(sock_net(sk));\n\tsk->sk_ipv6only\t= net->ipv6.sysctl.bindv6only;\n\n\t/* Init the ipv4 part of the socket since we can have sockets\n\t * using v6 API for ipv4.\n\t */\n\tinet->uc_ttl\t= -1;\n\n\tinet->mc_loop\t= 1;\n\tinet->mc_ttl\t= 1;\n\tinet->mc_index\t= 0;\n\tinet->mc_list\t= NULL;\n\tinet->rcv_tos\t= 0;\n\n\tif (net->ipv4.sysctl_ip_no_pmtu_disc)\n\t\tinet->pmtudisc = IP_PMTUDISC_DONT;\n\telse\n\t\tinet->pmtudisc = IP_PMTUDISC_WANT;\n\t/*\n\t * Increment only the relevant sk_prot->socks debug field, this changes\n\t * the previous behaviour of incrementing both the equivalent to\n\t * answer->prot->socks (inet6_sock_nr) and inet_sock_nr.\n\t *\n\t * This allows better debug granularity as we'll know exactly how many\n\t * UDPv6, TCPv6, etc socks were allocated, not the sum of all IPv6\n\t * transport protocol socks. -acme\n\t */\n\tsk_refcnt_debug_inc(sk);\n\n\tif (inet->inet_num) {\n\t\t/* It assumes that any protocol which allows\n\t\t * the user to assign a number at socket\n\t\t * creation time automatically shares.\n\t\t */\n\t\tinet->inet_sport = htons(inet->inet_num);\n\t\tsk->sk_prot->hash(sk);\n\t}\n\tif (sk->sk_prot->init) {\n\t\terr = sk->sk_prot->init(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn err;\nout_rcu_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\n\n\n/* bind for INET6 API */\nint inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tunsigned short snum;\n\tint addr_type = 0;\n\tint err = 0;\n\n\t/* If the socket has its own bind function then use it. */\n\tif (sk->sk_prot->bind)\n\t\treturn sk->sk_prot->bind(sk, uaddr, addr_len);\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (addr->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\tif ((addr_type & IPV6_ADDR_MULTICAST) && sock->type == SOCK_STREAM)\n\t\treturn -EINVAL;\n\n\tsnum = ntohs(addr->sin6_port);\n\tif (snum && snum < PROT_SOCK && !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\tlock_sock(sk);\n\n\t/* Check these errors (active socket, double bind). */\n\tif (sk->sk_state != TCP_CLOSE || inet->inet_num) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if the address belongs to the host. */\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tint chk_addr_ret;\n\n\t\t/* Binding to v4-mapped address on a v6-only socket\n\t\t * makes no sense\n\t\t */\n\t\tif (sk->sk_ipv6only) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Reproduce AF_INET checks to make the bindings consistent */\n\t\tv4addr = addr->sin6_addr.s6_addr32[3];\n\t\tchk_addr_ret = inet_addr_type(net, v4addr);\n\t\tif (!net->ipv4.sysctl_ip_nonlocal_bind &&\n\t\t    !(inet->freebind || inet->transparent) &&\n\t\t    v4addr != htonl(INADDR_ANY) &&\n\t\t    chk_addr_ret != RTN_LOCAL &&\n\t\t    chk_addr_ret != RTN_MULTICAST &&\n\t\t    chk_addr_ret != RTN_BROADCAST) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (addr_type != IPV6_ADDR_ANY) {\n\t\t\tstruct net_device *dev = NULL;\n\n\t\t\trcu_read_lock();\n\t\t\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t\t    addr->sin6_scope_id) {\n\t\t\t\t\t/* Override any existing binding, if another one\n\t\t\t\t\t * is supplied by user.\n\t\t\t\t\t */\n\t\t\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n\t\t\t\t}\n\n\t\t\t\t/* Binding to link-local address requires an interface */\n\t\t\t\tif (!sk->sk_bound_dev_if) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tdev = dev_get_by_index_rcu(net, sk->sk_bound_dev_if);\n\t\t\t\tif (!dev) {\n\t\t\t\t\terr = -ENODEV;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t\t */\n\t\t\tv4addr = LOOPBACK4_IPV6;\n\t\t\tif (!(addr_type & IPV6_ADDR_MULTICAST))\t{\n\t\t\t\tif (!net->ipv6.sysctl.ip_nonlocal_bind &&\n\t\t\t\t    !(inet->freebind || inet->transparent) &&\n\t\t\t\t    !ipv6_chk_addr(net, &addr->sin6_addr,\n\t\t\t\t\t\t   dev, 0)) {\n\t\t\t\t\terr = -EADDRNOTAVAIL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n\n\tinet->inet_rcv_saddr = v4addr;\n\tinet->inet_saddr = v4addr;\n\n\tsk->sk_v6_rcv_saddr = addr->sin6_addr;\n\n\tif (!(addr_type & IPV6_ADDR_MULTICAST))\n\t\tnp->saddr = addr->sin6_addr;\n\n\t/* Make sure we are allowed to bind here. */\n\tif ((snum || !inet->bind_address_no_port) &&\n\t    sk->sk_prot->get_port(sk, snum)) {\n\t\tinet_reset_saddr(sk);\n\t\terr = -EADDRINUSE;\n\t\tgoto out;\n\t}\n\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n\t\tif (addr_type != IPV6_ADDR_MAPPED)\n\t\t\tsk->sk_ipv6only = 1;\n\t}\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tinet->inet_sport = htons(inet->inet_num);\n\tinet->inet_dport = 0;\n\tinet->inet_daddr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\nout_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\nEXPORT_SYMBOL(inet6_bind);\n\nint inet6_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\treturn -EINVAL;\n\n\t/* Free mc lists */\n\tipv6_sock_mc_close(sk);\n\n\t/* Free ac lists */\n\tipv6_sock_ac_close(sk);\n\n\treturn inet_release(sock);\n}\nEXPORT_SYMBOL(inet6_release);\n\nvoid inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\t/* Release rx options */\n\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\t/* Free flowlabels */\n\tfl6_free_socklist(sk);\n\n\t/* Free tx options */\n\n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n}\nEXPORT_SYMBOL_GPL(inet6_destroy_sock);\n\n/*\n *\tThis does both peername and sockname.\n */\n\nint inet6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_in6 *sin = (struct sockaddr_in6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\tsin->sin6_family = AF_INET6;\n\tsin->sin6_flowinfo = 0;\n\tsin->sin6_scope_id = 0;\n\tif (peer) {\n\t\tif (!inet->inet_dport)\n\t\t\treturn -ENOTCONN;\n\t\tif (((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_SYN_SENT)) &&\n\t\t    peer == 1)\n\t\t\treturn -ENOTCONN;\n\t\tsin->sin6_port = inet->inet_dport;\n\t\tsin->sin6_addr = sk->sk_v6_daddr;\n\t\tif (np->sndflow)\n\t\t\tsin->sin6_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\tsin->sin6_addr = np->saddr;\n\t\telse\n\t\t\tsin->sin6_addr = sk->sk_v6_rcv_saddr;\n\n\t\tsin->sin6_port = inet->inet_sport;\n\t}\n\tsin->sin6_scope_id = ipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t sk->sk_bound_dev_if);\n\t*uaddr_len = sizeof(*sin);\n\treturn 0;\n}\nEXPORT_SYMBOL(inet6_getname);\n\nint inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tswitch (cmd) {\n\tcase SIOCGSTAMP:\n\t\treturn sock_get_timestamp(sk, (struct timeval __user *)arg);\n\n\tcase SIOCGSTAMPNS:\n\t\treturn sock_get_timestampns(sk, (struct timespec __user *)arg);\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\n\t\treturn ipv6_route_ioctl(net, cmd, (void __user *)arg);\n\n\tcase SIOCSIFADDR:\n\t\treturn addrconf_add_ifaddr(net, (void __user *) arg);\n\tcase SIOCDIFADDR:\n\t\treturn addrconf_del_ifaddr(net, (void __user *) arg);\n\tcase SIOCSIFDSTADDR:\n\t\treturn addrconf_set_dstaddr(net, (void __user *) arg);\n\tdefault:\n\t\tif (!sk->sk_prot->ioctl)\n\t\t\treturn -ENOIOCTLCMD;\n\t\treturn sk->sk_prot->ioctl(sk, cmd, arg);\n\t}\n\t/*NOTREACHED*/\n\treturn 0;\n}\nEXPORT_SYMBOL(inet6_ioctl);\n\nconst struct proto_ops inet6_stream_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_stream_connect,\t/* ok\t\t*/\n\t.socketpair\t   = sock_no_socketpair,\t/* a do nothing\t*/\n\t.accept\t\t   = inet_accept,\t\t/* ok\t\t*/\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = tcp_poll,\t\t\t/* ok\t\t*/\n\t.ioctl\t\t   = inet6_ioctl,\t\t/* must change  */\n\t.listen\t\t   = inet_listen,\t\t/* ok\t\t*/\n\t.shutdown\t   = inet_shutdown,\t\t/* ok\t\t*/\n\t.setsockopt\t   = sock_common_setsockopt,\t/* ok\t\t*/\n\t.getsockopt\t   = sock_common_getsockopt,\t/* ok\t\t*/\n\t.sendmsg\t   = inet_sendmsg,\t\t/* ok\t\t*/\n\t.recvmsg\t   = inet_recvmsg,\t\t/* ok\t\t*/\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = inet_sendpage,\n\t.splice_read\t   = tcp_splice_read,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nconst struct proto_ops inet6_dgram_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\t/* ok\t\t*/\n\t.socketpair\t   = sock_no_socketpair,\t/* a do nothing\t*/\n\t.accept\t\t   = sock_no_accept,\t\t/* a do nothing\t*/\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = udp_poll,\t\t\t/* ok\t\t*/\n\t.ioctl\t\t   = inet6_ioctl,\t\t/* must change  */\n\t.listen\t\t   = sock_no_listen,\t\t/* ok\t\t*/\n\t.shutdown\t   = inet_shutdown,\t\t/* ok\t\t*/\n\t.setsockopt\t   = sock_common_setsockopt,\t/* ok\t\t*/\n\t.getsockopt\t   = sock_common_getsockopt,\t/* ok\t\t*/\n\t.sendmsg\t   = inet_sendmsg,\t\t/* ok\t\t*/\n\t.recvmsg\t   = inet_recvmsg,\t\t/* ok\t\t*/\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic const struct net_proto_family inet6_family_ops = {\n\t.family = PF_INET6,\n\t.create = inet6_create,\n\t.owner\t= THIS_MODULE,\n};\n\nint inet6_register_protosw(struct inet_protosw *p)\n{\n\tstruct list_head *lh;\n\tstruct inet_protosw *answer;\n\tstruct list_head *last_perm;\n\tint protocol = p->protocol;\n\tint ret;\n\n\tspin_lock_bh(&inetsw6_lock);\n\n\tret = -EINVAL;\n\tif (p->type >= SOCK_MAX)\n\t\tgoto out_illegal;\n\n\t/* If we are trying to override a permanent protocol, bail. */\n\tanswer = NULL;\n\tret = -EPERM;\n\tlast_perm = &inetsw6[p->type];\n\tlist_for_each(lh, &inetsw6[p->type]) {\n\t\tanswer = list_entry(lh, struct inet_protosw, list);\n\n\t\t/* Check only the non-wild match. */\n\t\tif (INET_PROTOSW_PERMANENT & answer->flags) {\n\t\t\tif (protocol == answer->protocol)\n\t\t\t\tbreak;\n\t\t\tlast_perm = lh;\n\t\t}\n\n\t\tanswer = NULL;\n\t}\n\tif (answer)\n\t\tgoto out_permanent;\n\n\t/* Add the new entry after the last permanent entry if any, so that\n\t * the new entry does not override a permanent entry when matched with\n\t * a wild-card protocol. But it is allowed to override any existing\n\t * non-permanent entry.  This means that when we remove this entry, the\n\t * system automatically returns to the old behavior.\n\t */\n\tlist_add_rcu(&p->list, last_perm);\n\tret = 0;\nout:\n\tspin_unlock_bh(&inetsw6_lock);\n\treturn ret;\n\nout_permanent:\n\tpr_err(\"Attempt to override permanent protocol %d\\n\", protocol);\n\tgoto out;\n\nout_illegal:\n\tpr_err(\"Ignoring attempt to register invalid socket type %d\\n\",\n\t       p->type);\n\tgoto out;\n}\nEXPORT_SYMBOL(inet6_register_protosw);\n\nvoid\ninet6_unregister_protosw(struct inet_protosw *p)\n{\n\tif (INET_PROTOSW_PERMANENT & p->flags) {\n\t\tpr_err(\"Attempt to unregister permanent protocol %d\\n\",\n\t\t       p->protocol);\n\t} else {\n\t\tspin_lock_bh(&inetsw6_lock);\n\t\tlist_del_rcu(&p->list);\n\t\tspin_unlock_bh(&inetsw6_lock);\n\n\t\tsynchronize_net();\n\t}\n}\nEXPORT_SYMBOL(inet6_unregister_protosw);\n\nint inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tfl6.fl6_sport = inet->inet_sport;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\n\t\t__ip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(inet6_sk_rebuild_header);\n\nbool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb,\n\t\t       const struct inet6_skb_parm *opt)\n{\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\n\tif (np->rxopt.all) {\n\t\tif (((opt->flags & IP6SKB_HOPBYHOP) &&\n\t\t     (np->rxopt.bits.hopopts || np->rxopt.bits.ohopopts)) ||\n\t\t    (ip6_flowinfo((struct ipv6hdr *) skb_network_header(skb)) &&\n\t\t     np->rxopt.bits.rxflow) ||\n\t\t    (opt->srcrt && (np->rxopt.bits.srcrt ||\n\t\t     np->rxopt.bits.osrcrt)) ||\n\t\t    ((opt->dst1 || opt->dst0) &&\n\t\t     (np->rxopt.bits.dstopts || np->rxopt.bits.odstopts)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(ipv6_opt_accepted);\n\nstatic struct packet_type ipv6_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_IPV6),\n\t.func = ipv6_rcv,\n};\n\nstatic int __init ipv6_packet_init(void)\n{\n\tdev_add_pack(&ipv6_packet_type);\n\treturn 0;\n}\n\nstatic void ipv6_packet_cleanup(void)\n{\n\tdev_remove_pack(&ipv6_packet_type);\n}\n\nstatic int __net_init ipv6_init_mibs(struct net *net)\n{\n\tint i;\n\n\tnet->mib.udp_stats_in6 = alloc_percpu(struct udp_mib);\n\tif (!net->mib.udp_stats_in6)\n\t\treturn -ENOMEM;\n\tnet->mib.udplite_stats_in6 = alloc_percpu(struct udp_mib);\n\tif (!net->mib.udplite_stats_in6)\n\t\tgoto err_udplite_mib;\n\tnet->mib.ipv6_statistics = alloc_percpu(struct ipstats_mib);\n\tif (!net->mib.ipv6_statistics)\n\t\tgoto err_ip_mib;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct ipstats_mib *af_inet6_stats;\n\t\taf_inet6_stats = per_cpu_ptr(net->mib.ipv6_statistics, i);\n\t\tu64_stats_init(&af_inet6_stats->syncp);\n\t}\n\n\n\tnet->mib.icmpv6_statistics = alloc_percpu(struct icmpv6_mib);\n\tif (!net->mib.icmpv6_statistics)\n\t\tgoto err_icmp_mib;\n\tnet->mib.icmpv6msg_statistics = kzalloc(sizeof(struct icmpv6msg_mib),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!net->mib.icmpv6msg_statistics)\n\t\tgoto err_icmpmsg_mib;\n\treturn 0;\n\nerr_icmpmsg_mib:\n\tfree_percpu(net->mib.icmpv6_statistics);\nerr_icmp_mib:\n\tfree_percpu(net->mib.ipv6_statistics);\nerr_ip_mib:\n\tfree_percpu(net->mib.udplite_stats_in6);\nerr_udplite_mib:\n\tfree_percpu(net->mib.udp_stats_in6);\n\treturn -ENOMEM;\n}\n\nstatic void ipv6_cleanup_mibs(struct net *net)\n{\n\tfree_percpu(net->mib.udp_stats_in6);\n\tfree_percpu(net->mib.udplite_stats_in6);\n\tfree_percpu(net->mib.ipv6_statistics);\n\tfree_percpu(net->mib.icmpv6_statistics);\n\tkfree(net->mib.icmpv6msg_statistics);\n}\n\nstatic int __net_init inet6_net_init(struct net *net)\n{\n\tint err = 0;\n\n\tnet->ipv6.sysctl.bindv6only = 0;\n\tnet->ipv6.sysctl.icmpv6_time = 1*HZ;\n\tnet->ipv6.sysctl.flowlabel_consistency = 1;\n\tnet->ipv6.sysctl.auto_flowlabels = IP6_DEFAULT_AUTO_FLOW_LABELS;\n\tnet->ipv6.sysctl.idgen_retries = 3;\n\tnet->ipv6.sysctl.idgen_delay = 1 * HZ;\n\tnet->ipv6.sysctl.flowlabel_state_ranges = 0;\n\tatomic_set(&net->ipv6.fib6_sernum, 1);\n\n\terr = ipv6_init_mibs(net);\n\tif (err)\n\t\treturn err;\n#ifdef CONFIG_PROC_FS\n\terr = udp6_proc_init(net);\n\tif (err)\n\t\tgoto out;\n\terr = tcp6_proc_init(net);\n\tif (err)\n\t\tgoto proc_tcp6_fail;\n\terr = ac6_proc_init(net);\n\tif (err)\n\t\tgoto proc_ac6_fail;\n#endif\n\treturn err;\n\n#ifdef CONFIG_PROC_FS\nproc_ac6_fail:\n\ttcp6_proc_exit(net);\nproc_tcp6_fail:\n\tudp6_proc_exit(net);\nout:\n\tipv6_cleanup_mibs(net);\n\treturn err;\n#endif\n}\n\nstatic void __net_exit inet6_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tudp6_proc_exit(net);\n\ttcp6_proc_exit(net);\n\tac6_proc_exit(net);\n#endif\n\tipv6_cleanup_mibs(net);\n}\n\nstatic struct pernet_operations inet6_net_ops = {\n\t.init = inet6_net_init,\n\t.exit = inet6_net_exit,\n};\n\nstatic const struct ipv6_stub ipv6_stub_impl = {\n\t.ipv6_sock_mc_join = ipv6_sock_mc_join,\n\t.ipv6_sock_mc_drop = ipv6_sock_mc_drop,\n\t.ipv6_dst_lookup = ip6_dst_lookup,\n\t.udpv6_encap_enable = udpv6_encap_enable,\n\t.ndisc_send_na = ndisc_send_na,\n\t.nd_tbl\t= &nd_tbl,\n};\n\nstatic int __init inet6_init(void)\n{\n\tstruct list_head *r;\n\tint err = 0;\n\n\tsock_skb_cb_check_size(sizeof(struct inet6_skb_parm));\n\n\t/* Register the socket-side information for inet6_create.  */\n\tfor (r = &inetsw6[0]; r < &inetsw6[SOCK_MAX]; ++r)\n\t\tINIT_LIST_HEAD(r);\n\n\tif (disable_ipv6_mod) {\n\t\tpr_info(\"Loaded, but administratively disabled, reboot required to enable\\n\");\n\t\tgoto out;\n\t}\n\n\terr = proto_register(&tcpv6_prot, 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = proto_register(&udpv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_tcp_proto;\n\n\terr = proto_register(&udplitev6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_udp_proto;\n\n\terr = proto_register(&rawv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_udplite_proto;\n\n\terr = proto_register(&pingv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_ping_proto;\n\n\t/* We MUST register RAW sockets before we create the ICMP6,\n\t * IGMP6, or NDISC control sockets.\n\t */\n\terr = rawv6_init();\n\tif (err)\n\t\tgoto out_unregister_raw_proto;\n\n\t/* Register the family here so that the init calls below will\n\t * be able to create sockets. (?? is this dangerous ??)\n\t */\n\terr = sock_register(&inet6_family_ops);\n\tif (err)\n\t\tgoto out_sock_register_fail;\n\n\t/*\n\t *\tipngwg API draft makes clear that the correct semantics\n\t *\tfor TCP and UDP is to consider one TCP and UDP instance\n\t *\tin a host available by both INET and INET6 APIs and\n\t *\table to communicate via both network protocols.\n\t */\n\n\terr = register_pernet_subsys(&inet6_net_ops);\n\tif (err)\n\t\tgoto register_pernet_fail;\n\terr = icmpv6_init();\n\tif (err)\n\t\tgoto icmp_fail;\n\terr = ip6_mr_init();\n\tif (err)\n\t\tgoto ipmr_fail;\n\terr = ndisc_init();\n\tif (err)\n\t\tgoto ndisc_fail;\n\terr = igmp6_init();\n\tif (err)\n\t\tgoto igmp_fail;\n\n\tipv6_stub = &ipv6_stub_impl;\n\n\terr = ipv6_netfilter_init();\n\tif (err)\n\t\tgoto netfilter_fail;\n\t/* Create /proc/foo6 entries. */\n#ifdef CONFIG_PROC_FS\n\terr = -ENOMEM;\n\tif (raw6_proc_init())\n\t\tgoto proc_raw6_fail;\n\tif (udplite6_proc_init())\n\t\tgoto proc_udplite6_fail;\n\tif (ipv6_misc_proc_init())\n\t\tgoto proc_misc6_fail;\n\tif (if6_proc_init())\n\t\tgoto proc_if6_fail;\n#endif\n\terr = ip6_route_init();\n\tif (err)\n\t\tgoto ip6_route_fail;\n\terr = ndisc_late_init();\n\tif (err)\n\t\tgoto ndisc_late_fail;\n\terr = ip6_flowlabel_init();\n\tif (err)\n\t\tgoto ip6_flowlabel_fail;\n\terr = addrconf_init();\n\tif (err)\n\t\tgoto addrconf_fail;\n\n\t/* Init v6 extension headers. */\n\terr = ipv6_exthdrs_init();\n\tif (err)\n\t\tgoto ipv6_exthdrs_fail;\n\n\terr = ipv6_frag_init();\n\tif (err)\n\t\tgoto ipv6_frag_fail;\n\n\t/* Init v6 transport protocols. */\n\terr = udpv6_init();\n\tif (err)\n\t\tgoto udpv6_fail;\n\n\terr = udplitev6_init();\n\tif (err)\n\t\tgoto udplitev6_fail;\n\n\terr = tcpv6_init();\n\tif (err)\n\t\tgoto tcpv6_fail;\n\n\terr = ipv6_packet_init();\n\tif (err)\n\t\tgoto ipv6_packet_fail;\n\n\terr = pingv6_init();\n\tif (err)\n\t\tgoto pingv6_fail;\n\n#ifdef CONFIG_SYSCTL\n\terr = ipv6_sysctl_register();\n\tif (err)\n\t\tgoto sysctl_fail;\n#endif\nout:\n\treturn err;\n\n#ifdef CONFIG_SYSCTL\nsysctl_fail:\n\tpingv6_exit();\n#endif\npingv6_fail:\n\tipv6_packet_cleanup();\nipv6_packet_fail:\n\ttcpv6_exit();\ntcpv6_fail:\n\tudplitev6_exit();\nudplitev6_fail:\n\tudpv6_exit();\nudpv6_fail:\n\tipv6_frag_exit();\nipv6_frag_fail:\n\tipv6_exthdrs_exit();\nipv6_exthdrs_fail:\n\taddrconf_cleanup();\naddrconf_fail:\n\tip6_flowlabel_cleanup();\nip6_flowlabel_fail:\n\tndisc_late_cleanup();\nndisc_late_fail:\n\tip6_route_cleanup();\nip6_route_fail:\n#ifdef CONFIG_PROC_FS\n\tif6_proc_exit();\nproc_if6_fail:\n\tipv6_misc_proc_exit();\nproc_misc6_fail:\n\tudplite6_proc_exit();\nproc_udplite6_fail:\n\traw6_proc_exit();\nproc_raw6_fail:\n#endif\n\tipv6_netfilter_fini();\nnetfilter_fail:\n\tigmp6_cleanup();\nigmp_fail:\n\tndisc_cleanup();\nndisc_fail:\n\tip6_mr_cleanup();\nipmr_fail:\n\ticmpv6_cleanup();\nicmp_fail:\n\tunregister_pernet_subsys(&inet6_net_ops);\nregister_pernet_fail:\n\tsock_unregister(PF_INET6);\n\trtnl_unregister_all(PF_INET6);\nout_sock_register_fail:\n\trawv6_exit();\nout_unregister_ping_proto:\n\tproto_unregister(&pingv6_prot);\nout_unregister_raw_proto:\n\tproto_unregister(&rawv6_prot);\nout_unregister_udplite_proto:\n\tproto_unregister(&udplitev6_prot);\nout_unregister_udp_proto:\n\tproto_unregister(&udpv6_prot);\nout_unregister_tcp_proto:\n\tproto_unregister(&tcpv6_prot);\n\tgoto out;\n}\nmodule_init(inet6_init);\n\nMODULE_ALIAS_NETPROTO(PF_INET6);\n", "/*\n *\tcommon UDP/RAW code\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/route.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/tcp_states.h>\n#include <net/dsfield.h>\n\n#include <linux/errqueue.h>\n#include <asm/uaccess.h>\n\nstatic bool ipv6_mapped_addr_any(const struct in6_addr *a)\n{\n\treturn ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);\n}\n\nstatic int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock\t*inet = inet_sk(sk);\n\tstruct ipv6_pinfo\t*np = inet6_sk(sk);\n\tstruct in6_addr\t*daddr, *final_p, final;\n\tstruct dst_entry\t*dst;\n\tstruct flowi6\t\tfl6;\n\tstruct ip6_flowlabel\t*flowlabel = NULL;\n\tstruct ipv6_txoptions\t*opt;\n\tint\t\t\taddr_type;\n\tint\t\t\terr;\n\n\tif (usin->sin6_family == AF_INET) {\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -EAFNOSUPPORT;\n\t\terr = __ip4_datagram_connect(sk, uaddr, addr_len);\n\t\tgoto ipv4_connected;\n\t}\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t/*\n\t\t *\tconnect to self\n\t\t */\n\t\tusin->sin6_addr.s6_addr[15] = 0x01;\n\t}\n\n\tdaddr = &usin->sin6_addr;\n\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tstruct sockaddr_in sin;\n\n\t\tif (__ipv6_only_sock(sk)) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out;\n\t\t}\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\tsin.sin_port = usin->sin6_port;\n\n\t\terr = __ip4_datagram_connect(sk,\n\t\t\t\t\t     (struct sockaddr *) &sin,\n\t\t\t\t\t     sizeof(sin));\n\nipv4_connected:\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tipv6_addr_set_v4mapped(inet->inet_daddr, &sk->sk_v6_daddr);\n\n\t\tif (ipv6_addr_any(&np->saddr) ||\n\t\t    ipv6_mapped_addr_any(&np->saddr))\n\t\t\tipv6_addr_set_v4mapped(inet->inet_saddr, &np->saddr);\n\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr) ||\n\t\t    ipv6_mapped_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\t\tipv6_addr_set_v4mapped(inet->inet_rcv_saddr,\n\t\t\t\t\t       &sk->sk_v6_rcv_saddr);\n\t\t\tif (sk->sk_prot->rehash)\n\t\t\t\tsk->sk_prot->rehash(sk);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\tif (!sk->sk_bound_dev_if && (addr_type & IPV6_ADDR_MULTICAST))\n\t\t\tsk->sk_bound_dev_if = np->mcast_oif;\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk->sk_v6_daddr = *daddr;\n\tnp->flow_label = fl6.flowlabel;\n\n\tinet->inet_dport = usin->sin6_port;\n\n\t/*\n\t *\tCheck for a route to destination an obtain the\n\t *\tdestination cache for it.\n\t */\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = inet->inet_dport;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\tif (!fl6.flowi6_oif && (addr_type&IPV6_ADDR_MULTICAST))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\topt = flowlabel ? flowlabel->opt : np->opt;\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\terr = 0;\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\n\t/* source address lookup done in ip6_dst_lookup */\n\n\tif (ipv6_addr_any(&np->saddr))\n\t\tnp->saddr = fl6.saddr;\n\n\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\tsk->sk_v6_rcv_saddr = fl6.saddr;\n\t\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\t\tif (sk->sk_prot->rehash)\n\t\t\tsk->sk_prot->rehash(sk);\n\t}\n\n\tip6_dst_store(sk, dst,\n\t\t      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?\n\t\t      &sk->sk_v6_daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?\n\t\t      &np->saddr :\n#endif\n\t\t      NULL);\n\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk_set_txhash(sk);\nout:\n\tfl6_sock_release(flowlabel);\n\treturn err;\n}\n\nint ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tint res;\n\n\tlock_sock(sk);\n\tres = __ip6_datagram_connect(sk, uaddr, addr_len);\n\trelease_sock(sk);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_connect);\n\nint ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t\t int addr_len)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, uaddr);\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\treturn ip6_datagram_connect(sk, uaddr, addr_len);\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_connect_v6_only);\n\nvoid ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\n\t\t     __be16 port, u32 info, u8 *payload)\n{\n\tstruct ipv6_pinfo *np  = inet6_sk(sk);\n\tstruct icmp6hdr *icmph = icmp6_hdr(skb);\n\tstruct sock_exterr_skb *serr;\n\n\tif (!np->recverr)\n\t\treturn;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_ICMP6;\n\tserr->ee.ee_type = icmph->icmp6_type;\n\tserr->ee.ee_code = icmph->icmp6_code;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&(((struct ipv6hdr *)(icmph + 1))->daddr) -\n\t\t\t\t  skb_network_header(skb);\n\tserr->port = port;\n\n\t__skb_pull(skb, payload - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\nvoid ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info)\n{\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sock_exterr_skb *serr;\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\n\tif (!np->recverr)\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\tiph->daddr = fl6->daddr;\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\tserr->ee.ee_type = 0;\n\tserr->ee.ee_code = 0;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\n\tserr->port = fl6->fl6_dport;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\nvoid ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\tstruct ip6_mtuinfo *mtu_info;\n\n\tif (!np->rxopt.bits.rxpmtu)\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\tiph->daddr = fl6->daddr;\n\n\tmtu_info = IP6CBMTU(skb);\n\n\tmtu_info->ip6m_mtu = mtu;\n\tmtu_info->ip6m_addr.sin6_family = AF_INET6;\n\tmtu_info->ip6m_addr.sin6_port = 0;\n\tmtu_info->ip6m_addr.sin6_flowinfo = 0;\n\tmtu_info->ip6m_addr.sin6_scope_id = fl6->flowi6_oif;\n\tmtu_info->ip6m_addr.sin6_addr = ipv6_hdr(skb)->daddr;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tskb = xchg(&np->rxpmtu, skb);\n\tkfree_skb(skb);\n}\n\n/* For some errors we have valid addr_offset even with zero payload and\n * zero port. Also, addr_offset should be supported if port is set.\n */\nstatic inline bool ipv6_datagram_support_addr(struct sock_exterr_skb *serr)\n{\n\treturn serr->ee.ee_origin == SO_EE_ORIGIN_ICMP6 ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL || serr->port;\n}\n\n/* IPv6 supports cmsg on all origins aside from SO_EE_ORIGIN_LOCAL.\n *\n * At one point, excluding local errors was a quick test to identify icmp/icmp6\n * errors. This is no longer true, but the test remained, so the v6 stack,\n * unlike v4, also honors cmsg requests on all wifi and timestamp errors.\n *\n * Timestamp code paths do not initialize the fields expected by cmsg:\n * the PKTINFO fields in skb->cb[]. Fill those in here.\n */\nstatic bool ip6_datagram_support_cmsg(struct sk_buff *skb,\n\t\t\t\t      struct sock_exterr_skb *serr)\n{\n\tif (serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t    serr->ee.ee_origin == SO_EE_ORIGIN_ICMP6)\n\t\treturn true;\n\n\tif (serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL)\n\t\treturn false;\n\n\tif (!skb->dev)\n\t\treturn false;\n\n\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\tIP6CB(skb)->iif = skb->dev->ifindex;\n\telse\n\t\tPKTINFO_SKB_CB(skb)->ipi_ifindex = skb->dev->ifindex;\n\n\treturn true;\n}\n\n/*\n *\tHandle MSG_ERRQUEUE\n */\nint ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin, msg->msg_name);\n\tstruct {\n\t\tstruct sock_extended_err ee;\n\t\tstruct sockaddr_in6\t offender;\n\t} errhdr;\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = sock_dequeue_err_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tserr = SKB_EXT_ERR(skb);\n\n\tif (sin && ipv6_datagram_support_addr(serr)) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tsin->sin6_family = AF_INET6;\n\t\tsin->sin6_flowinfo = 0;\n\t\tsin->sin6_port = serr->port;\n\t\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tconst struct ipv6hdr *ip6h = container_of((struct in6_addr *)(nh + serr->addr_offset),\n\t\t\t\t\t\t\t\t  struct ipv6hdr, daddr);\n\t\t\tsin->sin6_addr = ip6h->daddr;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin->sin6_flowinfo = ip6_flowinfo(ip6h);\n\t\t\tsin->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t} else {\n\t\t\tipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),\n\t\t\t\t\t       &sin->sin6_addr);\n\t\t\tsin->sin6_scope_id = 0;\n\t\t}\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\n\tsin = &errhdr.offender;\n\tmemset(sin, 0, sizeof(*sin));\n\n\tif (ip6_datagram_support_cmsg(skb, serr)) {\n\t\tsin->sin6_family = AF_INET6;\n\t\tif (np->rxopt.all)\n\t\t\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\t\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tsin->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\t\tif (np->rxopt.all)\n\t\t\t\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n\t\t\tsin->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t} else {\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin->sin6_addr);\n\t\t\tif (inet_sk(sk)->cmsg_flags)\n\t\t\t\tip_cmsg_recv(msg, skb);\n\t\t}\n\t}\n\n\tput_cmsg(msg, SOL_IPV6, IPV6_RECVERR, sizeof(errhdr), &errhdr);\n\n\t/* Now we could try to dump offended packet options */\n\n\tmsg->msg_flags |= MSG_ERRQUEUE;\n\terr = copied;\n\nout_free_skb:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ipv6_recv_error);\n\n/*\n *\tHandle IPV6_RECVPATHMTU\n */\nint ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,\n\t\t     int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ip6_mtuinfo mtu_info;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin, msg->msg_name);\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tmemcpy(&mtu_info, IP6CBMTU(skb), sizeof(mtu_info));\n\n\tif (sin) {\n\t\tsin->sin6_family = AF_INET6;\n\t\tsin->sin6_flowinfo = 0;\n\t\tsin->sin6_port = 0;\n\t\tsin->sin6_scope_id = mtu_info.ip6m_addr.sin6_scope_id;\n\t\tsin->sin6_addr = mtu_info.ip6m_addr.sin6_addr;\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tput_cmsg(msg, SOL_IPV6, IPV6_PATHMTU, sizeof(mtu_info), &mtu_info);\n\n\terr = copied;\n\nout_free_skb:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}\n\n\nvoid ip6_datagram_recv_common_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tbool is_ipv6 = skb->protocol == htons(ETH_P_IPV6);\n\n\tif (np->rxopt.bits.rxinfo) {\n\t\tstruct in6_pktinfo src_info;\n\n\t\tif (is_ipv6) {\n\t\t\tsrc_info.ipi6_ifindex = IP6CB(skb)->iif;\n\t\t\tsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\n\t\t} else {\n\t\t\tsrc_info.ipi6_ifindex =\n\t\t\t\tPKTINFO_SKB_CB(skb)->ipi_ifindex;\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->daddr,\n\t\t\t\t\t       &src_info.ipi6_addr);\n\t\t}\n\n\t\tif (src_info.ipi6_ifindex >= 0)\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_PKTINFO,\n\t\t\t\t sizeof(src_info), &src_info);\n\t}\n}\n\nvoid ip6_datagram_recv_specific_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tunsigned char *nh = skb_network_header(skb);\n\n\tif (np->rxopt.bits.rxhlim) {\n\t\tint hlim = ipv6_hdr(skb)->hop_limit;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\n\t}\n\n\tif (np->rxopt.bits.rxtclass) {\n\t\tint tclass = ipv6_get_dsfield(ipv6_hdr(skb));\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\n\t}\n\n\tif (np->rxopt.bits.rxflow) {\n\t\t__be32 flowinfo = ip6_flowinfo((struct ipv6hdr *)nh);\n\t\tif (flowinfo)\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);\n\t}\n\n\t/* HbH is allowed only once */\n\tif (np->rxopt.bits.hopopts && (opt->flags & IP6SKB_HOPBYHOP)) {\n\t\tu8 *ptr = nh + sizeof(struct ipv6hdr);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_HOPOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\n\tif (opt->lastopt &&\n\t    (np->rxopt.bits.dstopts || np->rxopt.bits.srcrt)) {\n\t\t/*\n\t\t * Silly enough, but we need to reparse in order to\n\t\t * report extension headers (except for HbH)\n\t\t * in order.\n\t\t *\n\t\t * Also note that IPV6_RECVRTHDRDSTOPTS is NOT\n\t\t * (and WILL NOT be) defined because\n\t\t * IPV6_RECVDSTOPTS is more generic. --yoshfuji\n\t\t */\n\t\tunsigned int off = sizeof(struct ipv6hdr);\n\t\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\n\t\twhile (off <= opt->lastopt) {\n\t\t\tunsigned int len;\n\t\t\tu8 *ptr = nh + off;\n\n\t\t\tswitch (nexthdr) {\n\t\t\tcase IPPROTO_DSTOPTS:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tif (np->rxopt.bits.dstopts)\n\t\t\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_DSTOPTS, len, ptr);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_ROUTING:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tif (np->rxopt.bits.srcrt)\n\t\t\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_RTHDR, len, ptr);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_AH:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 2) << 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toff += len;\n\t\t}\n\t}\n\n\t/* socket options in old style */\n\tif (np->rxopt.bits.rxoinfo) {\n\t\tstruct in6_pktinfo src_info;\n\n\t\tsrc_info.ipi6_ifindex = opt->iif;\n\t\tsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\n\t}\n\tif (np->rxopt.bits.rxohlim) {\n\t\tint hlim = ipv6_hdr(skb)->hop_limit;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\n\t}\n\tif (np->rxopt.bits.ohopopts && (opt->flags & IP6SKB_HOPBYHOP)) {\n\t\tu8 *ptr = nh + sizeof(struct ipv6hdr);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292HOPOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.odstopts && opt->dst0) {\n\t\tu8 *ptr = nh + opt->dst0;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.osrcrt && opt->srcrt) {\n\t\tstruct ipv6_rt_hdr *rthdr = (struct ipv6_rt_hdr *)(nh + opt->srcrt);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292RTHDR, (rthdr->hdrlen+1) << 3, rthdr);\n\t}\n\tif (np->rxopt.bits.odstopts && opt->dst1) {\n\t\tu8 *ptr = nh + opt->dst1;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.rxorigdstaddr) {\n\t\tstruct sockaddr_in6 sin6;\n\t\t__be16 *ports = (__be16 *) skb_transport_header(skb);\n\n\t\tif (skb_transport_offset(skb) + 4 <= skb->len) {\n\t\t\t/* All current transport protocols have the port numbers in the\n\t\t\t * first four bytes of the transport header and this function is\n\t\t\t * written with this assumption in mind.\n\t\t\t */\n\n\t\t\tsin6.sin6_family = AF_INET6;\n\t\t\tsin6.sin6_addr = ipv6_hdr(skb)->daddr;\n\t\t\tsin6.sin6_port = ports[1];\n\t\t\tsin6.sin6_flowinfo = 0;\n\t\t\tsin6.sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t    opt->iif);\n\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_ORIGDSTADDR, sizeof(sin6), &sin6);\n\t\t}\n\t}\n}\n\nvoid ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_recv_ctl);\n\nint ip6_datagram_send_ctl(struct net *net, struct sock *sk,\n\t\t\t  struct msghdr *msg, struct flowi6 *fl6,\n\t\t\t  struct ipv6_txoptions *opt,\n\t\t\t  int *hlimit, int *tclass, int *dontfrag)\n{\n\tstruct in6_pktinfo *src_info;\n\tstruct cmsghdr *cmsg;\n\tstruct ipv6_rt_hdr *rthdr;\n\tstruct ipv6_opt_hdr *hdr;\n\tint len;\n\tint err = 0;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tint addr_type;\n\n\t\tif (!CMSG_OK(msg, cmsg)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_f;\n\t\t}\n\n\t\tif (cmsg->cmsg_level != SOL_IPV6)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase IPV6_PKTINFO:\n\t\tcase IPV6_2292PKTINFO:\n\t\t    {\n\t\t\tstruct net_device *dev = NULL;\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\n\n\t\t\tif (src_info->ipi6_ifindex) {\n\t\t\t\tif (fl6->flowi6_oif &&\n\t\t\t\t    src_info->ipi6_ifindex != fl6->flowi6_oif)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tfl6->flowi6_oif = src_info->ipi6_ifindex;\n\t\t\t}\n\n\t\t\taddr_type = __ipv6_addr_type(&src_info->ipi6_addr);\n\n\t\t\trcu_read_lock();\n\t\t\tif (fl6->flowi6_oif) {\n\t\t\t\tdev = dev_get_by_index_rcu(net, fl6->flowi6_oif);\n\t\t\t\tif (!dev) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (addr_type != IPV6_ADDR_ANY) {\n\t\t\t\tint strict = __ipv6_addr_src_scope(addr_type) <= IPV6_ADDR_SCOPE_LINKLOCAL;\n\t\t\t\tif (!(inet_sk(sk)->freebind || inet_sk(sk)->transparent) &&\n\t\t\t\t    !ipv6_chk_addr(net, &src_info->ipi6_addr,\n\t\t\t\t\t\t   strict ? dev : NULL, 0) &&\n\t\t\t\t    !ipv6_chk_acast_addr_src(net, dev,\n\t\t\t\t\t\t\t     &src_info->ipi6_addr))\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tfl6->saddr = src_info->ipi6_addr;\n\t\t\t}\n\n\t\t\trcu_read_unlock();\n\n\t\t\tif (err)\n\t\t\t\tgoto exit_f;\n\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase IPV6_FLOWINFO:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(4)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tif (fl6->flowlabel&IPV6_FLOWINFO_MASK) {\n\t\t\t\tif ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit_f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase IPV6_2292HOPOPTS:\n\t\tcase IPV6_HOPOPTS:\n\t\t\tif (opt->hopopt || cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\topt->opt_nflen += len;\n\t\t\topt->hopopt = hdr;\n\t\t\tbreak;\n\n\t\tcase IPV6_2292DSTOPTS:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (opt->dst1opt) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\topt->opt_flen += len;\n\t\t\topt->dst1opt = hdr;\n\t\t\tbreak;\n\n\t\tcase IPV6_DSTOPTS:\n\t\tcase IPV6_RTHDRDSTOPTS:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (cmsg->cmsg_type == IPV6_DSTOPTS) {\n\t\t\t\topt->opt_flen += len;\n\t\t\t\topt->dst1opt = hdr;\n\t\t\t} else {\n\t\t\t\topt->opt_nflen += len;\n\t\t\t\topt->dst0opt = hdr;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IPV6_2292RTHDR:\n\t\tcase IPV6_RTHDR:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_rt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\trthdr = (struct ipv6_rt_hdr *)CMSG_DATA(cmsg);\n\n\t\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t\tif (rthdr->hdrlen != 2 ||\n\t\t\t\t    rthdr->segments_left != 1) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit_f;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tlen = ((rthdr->hdrlen + 1) << 3);\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\t/* segments left must also match */\n\t\t\tif ((rthdr->hdrlen >> 1) != rthdr->segments_left) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\topt->opt_nflen += len;\n\t\t\topt->srcrt = rthdr;\n\n\t\t\tif (cmsg->cmsg_type == IPV6_2292RTHDR && opt->dst1opt) {\n\t\t\t\tint dsthdrlen = ((opt->dst1opt->hdrlen+1)<<3);\n\n\t\t\t\topt->opt_nflen += dsthdrlen;\n\t\t\t\topt->dst0opt = opt->dst1opt;\n\t\t\t\topt->dst1opt = NULL;\n\t\t\t\topt->opt_flen -= dsthdrlen;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IPV6_2292HOPLIMIT:\n\t\tcase IPV6_HOPLIMIT:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\t*hlimit = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (*hlimit < -1 || *hlimit > 0xff) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IPV6_TCLASS:\n\t\t    {\n\t\t\tint tc;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\tgoto exit_f;\n\n\t\t\ttc = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (tc < -1 || tc > 0xff)\n\t\t\t\tgoto exit_f;\n\n\t\t\terr = 0;\n\t\t\t*tclass = tc;\n\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase IPV6_DONTFRAG:\n\t\t    {\n\t\t\tint df;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\tgoto exit_f;\n\n\t\t\tdf = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (df < 0 || df > 1)\n\t\t\t\tgoto exit_f;\n\n\t\t\terr = 0;\n\t\t\t*dontfrag = df;\n\n\t\t\tbreak;\n\t\t    }\n\t\tdefault:\n\t\t\tnet_dbg_ratelimited(\"invalid cmsg type: %d\\n\",\n\t\t\t\t\t    cmsg->cmsg_type);\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_f;\n\t\t}\n\t}\n\nexit_f:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_send_ctl);\n\nvoid ip6_dgram_sock_seq_show(struct seq_file *seq, struct sock *sp,\n\t\t\t     __u16 srcp, __u16 destp, int bucket)\n{\n\tconst struct in6_addr *dest, *src;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tseq_printf(seq,\n\t\t   \"%5d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %d\\n\",\n\t\t   bucket,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   sp->sk_state,\n\t\t   sk_wmem_alloc_get(sp),\n\t\t   sk_rmem_alloc_get(sp),\n\t\t   0, 0L, 0,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   0,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   atomic_read(&sp->sk_drops));\n}\n", "/*\n *\tExtension Header handling for IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\tAndi Kleen\t\t<ak@muc.de>\n *\tAlexey Kuznetsov\t<kuznet@ms2.inr.ac.ru>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/* Changes:\n *\tyoshfuji\t\t: ensure not to overrun while parsing\n *\t\t\t\t  tlv options.\n *\tMitsuru KANDA @USAGI and: Remove ipv6_parse_exthdrs().\n *\tYOSHIFUJI Hideaki @USAGI  Register inbound extension header\n *\t\t\t\t  handlers as inet6_protocol{}.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <net/dst.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n#include <net/xfrm.h>\n#endif\n\n#include <linux/uaccess.h>\n\n/*\n *\tParsing tlv encoded headers.\n *\n *\tParsing function \"func\" returns true, if parsing succeed\n *\tand false, if it failed.\n *\tIt MUST NOT touch skb->h.\n */\n\nstruct tlvtype_proc {\n\tint\ttype;\n\tbool\t(*func)(struct sk_buff *skb, int offset);\n};\n\n/*********************\n  Generic functions\n *********************/\n\n/* An unknown option is detected, decide what to do */\n\nstatic bool ip6_tlvopt_unknown(struct sk_buff *skb, int optoff)\n{\n\tswitch ((skb_network_header(skb)[optoff] & 0xC0) >> 6) {\n\tcase 0: /* ignore */\n\t\treturn true;\n\n\tcase 1: /* drop packet */\n\t\tbreak;\n\n\tcase 3: /* Send ICMP if not a multicast address and drop packet */\n\t\t/* Actually, it is redundant check. icmp_send\n\t\t   will recheck in any case.\n\t\t */\n\t\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr))\n\t\t\tbreak;\n\tcase 2: /* send ICMP PARM PROB regardless and drop packet */\n\t\ticmpv6_param_prob(skb, ICMPV6_UNK_OPTION, optoff);\n\t\treturn false;\n\t}\n\n\tkfree_skb(skb);\n\treturn false;\n}\n\n/* Parse tlv encoded option header (hop-by-hop or destination) */\n\nstatic bool ip6_parse_tlv(const struct tlvtype_proc *procs, struct sk_buff *skb)\n{\n\tconst struct tlvtype_proc *curr;\n\tconst unsigned char *nh = skb_network_header(skb);\n\tint off = skb_network_header_len(skb);\n\tint len = (skb_transport_header(skb)[1] + 1) << 3;\n\tint padlen = 0;\n\n\tif (skb_transport_offset(skb) + len > skb_headlen(skb))\n\t\tgoto bad;\n\n\toff += 2;\n\tlen -= 2;\n\n\twhile (len > 0) {\n\t\tint optlen = nh[off + 1] + 2;\n\t\tint i;\n\n\t\tswitch (nh[off]) {\n\t\tcase IPV6_TLV_PAD1:\n\t\t\toptlen = 1;\n\t\t\tpadlen++;\n\t\t\tif (padlen > 7)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\n\t\tcase IPV6_TLV_PADN:\n\t\t\t/* RFC 2460 states that the purpose of PadN is\n\t\t\t * to align the containing header to multiples\n\t\t\t * of 8. 7 is therefore the highest valid value.\n\t\t\t * See also RFC 4942, Section 2.1.9.5.\n\t\t\t */\n\t\t\tpadlen += optlen;\n\t\t\tif (padlen > 7)\n\t\t\t\tgoto bad;\n\t\t\t/* RFC 4942 recommends receiving hosts to\n\t\t\t * actively check PadN payload to contain\n\t\t\t * only zeroes.\n\t\t\t */\n\t\t\tfor (i = 2; i < optlen; i++) {\n\t\t\t\tif (nh[off + i] != 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: /* Other TLV code so scan list */\n\t\t\tif (optlen > len)\n\t\t\t\tgoto bad;\n\t\t\tfor (curr = procs; curr->type >= 0; curr++) {\n\t\t\t\tif (curr->type == nh[off]) {\n\t\t\t\t\t/* type specific length/alignment\n\t\t\t\t\t   checks will be performed in the\n\t\t\t\t\t   func(). */\n\t\t\t\t\tif (curr->func(skb, off) == false)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curr->type < 0) {\n\t\t\t\tif (ip6_tlvopt_unknown(skb, off) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpadlen = 0;\n\t\t\tbreak;\n\t\t}\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\n\tif (len == 0)\n\t\treturn true;\nbad:\n\tkfree_skb(skb);\n\treturn false;\n}\n\n/*****************************\n  Destination options header.\n *****************************/\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nstatic bool ipv6_dest_hao(struct sk_buff *skb, int optoff)\n{\n\tstruct ipv6_destopt_hao *hao;\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tstruct in6_addr tmp_addr;\n\tint ret;\n\n\tif (opt->dsthao) {\n\t\tnet_dbg_ratelimited(\"hao duplicated\\n\");\n\t\tgoto discard;\n\t}\n\topt->dsthao = opt->dst1;\n\topt->dst1 = 0;\n\n\thao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);\n\n\tif (hao->length != 16) {\n\t\tnet_dbg_ratelimited(\"hao invalid option length = %d\\n\",\n\t\t\t\t    hao->length);\n\t\tgoto discard;\n\t}\n\n\tif (!(ipv6_addr_type(&hao->addr) & IPV6_ADDR_UNICAST)) {\n\t\tnet_dbg_ratelimited(\"hao is not an unicast addr: %pI6\\n\",\n\t\t\t\t    &hao->addr);\n\t\tgoto discard;\n\t}\n\n\tret = xfrm6_input_addr(skb, (xfrm_address_t *)&ipv6h->daddr,\n\t\t\t       (xfrm_address_t *)&hao->addr, IPPROTO_DSTOPTS);\n\tif (unlikely(ret < 0))\n\t\tgoto discard;\n\n\tif (skb_cloned(skb)) {\n\t\tif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC))\n\t\t\tgoto discard;\n\n\t\t/* update all variable using below by copied skbuff */\n\t\thao = (struct ipv6_destopt_hao *)(skb_network_header(skb) +\n\t\t\t\t\t\t  optoff);\n\t\tipv6h = ipv6_hdr(skb);\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\ttmp_addr = ipv6h->saddr;\n\tipv6h->saddr = hao->addr;\n\thao->addr = tmp_addr;\n\n\tif (skb->tstamp.tv64 == 0)\n\t\t__net_timestamp(skb);\n\n\treturn true;\n\n discard:\n\tkfree_skb(skb);\n\treturn false;\n}\n#endif\n\nstatic const struct tlvtype_proc tlvprocdestopt_lst[] = {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t{\n\t\t.type\t= IPV6_TLV_HAO,\n\t\t.func\t= ipv6_dest_hao,\n\t},\n#endif\n\t{-1,\t\t\tNULL}\n};\n\nstatic int ipv6_destopt_rcv(struct sk_buff *skb)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t__u16 dstbuf;\n#endif\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) ||\n\t    !pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\n\t\tIP6_INC_STATS_BH(dev_net(dst->dev), ip6_dst_idev(dst),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\topt->lastopt = opt->dst1 = skb_network_header_len(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tdstbuf = opt->dst1;\n#endif\n\n\tif (ip6_parse_tlv(tlvprocdestopt_lst, skb)) {\n\t\tskb->transport_header += (skb_transport_header(skb)[1] + 1) << 3;\n\t\topt = IP6CB(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\topt->nhoff = dstbuf;\n#else\n\t\topt->nhoff = opt->dst1;\n#endif\n\t\treturn 1;\n\t}\n\n\tIP6_INC_STATS_BH(dev_net(dst->dev),\n\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);\n\treturn -1;\n}\n\n/********************************\n  Routing header.\n ********************************/\n\n/* called with rcu_read_lock() */\nstatic int ipv6_rthdr_rcv(struct sk_buff *skb)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct in6_addr *addr = NULL;\n\tstruct in6_addr daddr;\n\tstruct inet6_dev *idev;\n\tint n, i;\n\tstruct ipv6_rt_hdr *hdr;\n\tstruct rt0_hdr *rthdr;\n\tstruct net *net = dev_net(skb->dev);\n\tint accept_source_route = net->ipv6.devconf_all->accept_source_route;\n\n\tidev = __in6_dev_get(skb->dev);\n\tif (idev && accept_source_route > idev->cnf.accept_source_route)\n\t\taccept_source_route = idev->cnf.accept_source_route;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) ||\n\t    !pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\thdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);\n\n\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) ||\n\t    skb->pkt_type != PACKET_HOST) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\nlooped_back:\n\tif (hdr->segments_left == 0) {\n\t\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t/* Silently discard type 2 header unless it was\n\t\t\t * processed by own\n\t\t\t */\n\t\t\tif (!addr) {\n\t\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\topt->lastopt = opt->srcrt = skb_network_header_len(skb);\n\t\tskb->transport_header += (hdr->hdrlen + 1) << 3;\n\t\topt->dst0 = opt->dst1;\n\t\topt->dst1 = 0;\n\t\topt->nhoff = (&hdr->nexthdr) - skb_network_header(skb);\n\t\treturn 1;\n\t}\n\n\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase IPV6_SRCRT_TYPE_2:\n\t\tif (accept_source_route < 0)\n\t\t\tgoto unknown_rh;\n\t\t/* Silently discard invalid RTH type 2 */\n\t\tif (hdr->hdrlen != 2 || hdr->segments_left != 1) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tgoto unknown_rh;\n\t}\n\n\t/*\n\t *\tThis is the routing header forwarding algorithm from\n\t *\tRFC 2460, page 16.\n\t */\n\n\tn = hdr->hdrlen >> 1;\n\n\tif (hdr->segments_left > n) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((&hdr->segments_left) -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\t/* We are about to mangle packet header. Be careful!\n\t   Do not damage packets queued somewhere.\n\t */\n\tif (skb_cloned(skb)) {\n\t\t/* the copy is a forwarded packet */\n\t\tif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_OUTDISCARDS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\thdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\ti = n - --hdr->segments_left;\n\n\trthdr = (struct rt0_hdr *) hdr;\n\taddr = rthdr->addr;\n\taddr += i - 1;\n\n\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase IPV6_SRCRT_TYPE_2:\n\t\tif (xfrm6_input_addr(skb, (xfrm_address_t *)addr,\n\t\t\t\t     (xfrm_address_t *)&ipv6_hdr(skb)->saddr,\n\t\t\t\t     IPPROTO_ROUTING) < 0) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!ipv6_chk_home_addr(dev_net(skb_dst(skb)->dev), addr)) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ipv6_addr_is_multicast(addr)) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tdaddr = *addr;\n\t*addr = ipv6_hdr(skb)->daddr;\n\tipv6_hdr(skb)->daddr = daddr;\n\n\tskb_dst_drop(skb);\n\tip6_route_input(skb);\n\tif (skb_dst(skb)->error) {\n\t\tskb_push(skb, skb->data - skb_network_header(skb));\n\t\tdst_input(skb);\n\t\treturn -1;\n\t}\n\n\tif (skb_dst(skb)->dev->flags&IFF_LOOPBACK) {\n\t\tif (ipv6_hdr(skb)->hop_limit <= 1) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT,\n\t\t\t\t    0);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tipv6_hdr(skb)->hop_limit--;\n\t\tgoto looped_back;\n\t}\n\n\tskb_push(skb, skb->data - skb_network_header(skb));\n\tdst_input(skb);\n\treturn -1;\n\nunknown_rh:\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_INHDRERRORS);\n\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t  (&hdr->type) - skb_network_header(skb));\n\treturn -1;\n}\n\nstatic const struct inet6_protocol rthdr_protocol = {\n\t.handler\t=\tipv6_rthdr_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct inet6_protocol destopt_protocol = {\n\t.handler\t=\tipv6_destopt_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct inet6_protocol nodata_protocol = {\n\t.handler\t=\tdst_discard,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nint __init ipv6_exthdrs_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_add_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\n\tif (ret)\n\t\tgoto out_rthdr;\n\n\tret = inet6_add_protocol(&nodata_protocol, IPPROTO_NONE);\n\tif (ret)\n\t\tgoto out_destopt;\n\nout:\n\treturn ret;\nout_destopt:\n\tinet6_del_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\nout_rthdr:\n\tinet6_del_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n\tgoto out;\n};\n\nvoid ipv6_exthdrs_exit(void)\n{\n\tinet6_del_protocol(&nodata_protocol, IPPROTO_NONE);\n\tinet6_del_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\n\tinet6_del_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n}\n\n/**********************************\n  Hop-by-hop options.\n **********************************/\n\n/*\n * Note: we cannot rely on skb_dst(skb) before we assign it in ip6_route_input().\n */\nstatic inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)\n{\n\treturn skb_dst(skb) ? ip6_dst_idev(skb_dst(skb)) : __in6_dev_get(skb->dev);\n}\n\nstatic inline struct net *ipv6_skb_net(struct sk_buff *skb)\n{\n\treturn skb_dst(skb) ? dev_net(skb_dst(skb)->dev) : dev_net(skb->dev);\n}\n\n/* Router Alert as of RFC 2711 */\n\nstatic bool ipv6_hop_ra(struct sk_buff *skb, int optoff)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\n\tif (nh[optoff + 1] == 2) {\n\t\tIP6CB(skb)->flags |= IP6SKB_ROUTERALERT;\n\t\tmemcpy(&IP6CB(skb)->ra, nh + optoff + 2, sizeof(IP6CB(skb)->ra));\n\t\treturn true;\n\t}\n\tnet_dbg_ratelimited(\"ipv6_hop_ra: wrong RA length %d\\n\",\n\t\t\t    nh[optoff + 1]);\n\tkfree_skb(skb);\n\treturn false;\n}\n\n/* Jumbo payload */\n\nstatic bool ipv6_hop_jumbo(struct sk_buff *skb, int optoff)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\tstruct net *net = ipv6_skb_net(skb);\n\tu32 pkt_len;\n\n\tif (nh[optoff + 1] != 4 || (optoff & 3) != 2) {\n\t\tnet_dbg_ratelimited(\"ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\\n\",\n\t\t\t\t    nh[optoff+1]);\n\t\tIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\tgoto drop;\n\t}\n\n\tpkt_len = ntohl(*(__be32 *)(nh + optoff + 2));\n\tif (pkt_len <= IPV6_MAXPLEN) {\n\t\tIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff+2);\n\t\treturn false;\n\t}\n\tif (ipv6_hdr(skb)->payload_len) {\n\t\tIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff);\n\t\treturn false;\n\t}\n\n\tif (pkt_len > skb->len - sizeof(struct ipv6hdr)) {\n\t\tIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\n\t\t\t\t IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t}\n\n\tif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n\treturn true;\n\ndrop:\n\tkfree_skb(skb);\n\treturn false;\n}\n\nstatic const struct tlvtype_proc tlvprochopopt_lst[] = {\n\t{\n\t\t.type\t= IPV6_TLV_ROUTERALERT,\n\t\t.func\t= ipv6_hop_ra,\n\t},\n\t{\n\t\t.type\t= IPV6_TLV_JUMBO,\n\t\t.func\t= ipv6_hop_jumbo,\n\t},\n\t{ -1, }\n};\n\nint ipv6_parse_hopopts(struct sk_buff *skb)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\n\t/*\n\t * skb_network_header(skb) is equal to skb->data, and\n\t * skb_network_header_len(skb) is always equal to\n\t * sizeof(struct ipv6hdr) by definition of\n\t * hop-by-hop options.\n\t */\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr) + 8) ||\n\t    !pskb_may_pull(skb, (sizeof(struct ipv6hdr) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\topt->flags |= IP6SKB_HOPBYHOP;\n\tif (ip6_parse_tlv(tlvprochopopt_lst, skb)) {\n\t\tskb->transport_header += (skb_transport_header(skb)[1] + 1) << 3;\n\t\topt = IP6CB(skb);\n\t\topt->nhoff = sizeof(struct ipv6hdr);\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\n/*\n *\tCreating outbound headers.\n *\n *\t\"build\" functions work when skb is filled from head to tail (datagram)\n *\t\"push\"\tfunctions work when headers are added from tail to head (tcp)\n *\n *\tIn both cases we assume, that caller reserved enough room\n *\tfor headers.\n */\n\nstatic void ipv6_push_rthdr(struct sk_buff *skb, u8 *proto,\n\t\t\t    struct ipv6_rt_hdr *opt,\n\t\t\t    struct in6_addr **addr_p)\n{\n\tstruct rt0_hdr *phdr, *ihdr;\n\tint hops;\n\n\tihdr = (struct rt0_hdr *) opt;\n\n\tphdr = (struct rt0_hdr *) skb_push(skb, (ihdr->rt_hdr.hdrlen + 1) << 3);\n\tmemcpy(phdr, ihdr, sizeof(struct rt0_hdr));\n\n\thops = ihdr->rt_hdr.hdrlen >> 1;\n\n\tif (hops > 1)\n\t\tmemcpy(phdr->addr, ihdr->addr + 1,\n\t\t       (hops - 1) * sizeof(struct in6_addr));\n\n\tphdr->addr[hops - 1] = **addr_p;\n\t*addr_p = ihdr->addr;\n\n\tphdr->rt_hdr.nexthdr = *proto;\n\t*proto = NEXTHDR_ROUTING;\n}\n\nstatic void ipv6_push_exthdr(struct sk_buff *skb, u8 *proto, u8 type, struct ipv6_opt_hdr *opt)\n{\n\tstruct ipv6_opt_hdr *h = (struct ipv6_opt_hdr *)skb_push(skb, ipv6_optlen(opt));\n\n\tmemcpy(h, opt, ipv6_optlen(opt));\n\th->nexthdr = *proto;\n\t*proto = type;\n}\n\nvoid ipv6_push_nfrag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t  u8 *proto,\n\t\t\t  struct in6_addr **daddr)\n{\n\tif (opt->srcrt) {\n\t\tipv6_push_rthdr(skb, proto, opt->srcrt, daddr);\n\t\t/*\n\t\t * IPV6_RTHDRDSTOPTS is ignored\n\t\t * unless IPV6_RTHDR is set (RFC3542).\n\t\t */\n\t\tif (opt->dst0opt)\n\t\t\tipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst0opt);\n\t}\n\tif (opt->hopopt)\n\t\tipv6_push_exthdr(skb, proto, NEXTHDR_HOP, opt->hopopt);\n}\nEXPORT_SYMBOL(ipv6_push_nfrag_opts);\n\nvoid ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt, u8 *proto)\n{\n\tif (opt->dst1opt)\n\t\tipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst1opt);\n}\n\nstruct ipv6_txoptions *\nipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n\t\t\t*((char **)&opt2->dst1opt) += dif;\n\t\tif (opt2->srcrt)\n\t\t\t*((char **)&opt2->srcrt) += dif;\n\t}\n\treturn opt2;\n}\nEXPORT_SYMBOL_GPL(ipv6_dup_options);\n\nstatic int ipv6_renew_option(void *ohdr,\n\t\t\t     struct ipv6_opt_hdr __user *newopt, int newoptlen,\n\t\t\t     int inherit,\n\t\t\t     struct ipv6_opt_hdr **hdr,\n\t\t\t     char **p)\n{\n\tif (inherit) {\n\t\tif (ohdr) {\n\t\t\tmemcpy(*p, ohdr, ipv6_optlen((struct ipv6_opt_hdr *)ohdr));\n\t\t\t*hdr = (struct ipv6_opt_hdr *)*p;\n\t\t\t*p += CMSG_ALIGN(ipv6_optlen(*hdr));\n\t\t}\n\t} else {\n\t\tif (newopt) {\n\t\t\tif (copy_from_user(*p, newopt, newoptlen))\n\t\t\t\treturn -EFAULT;\n\t\t\t*hdr = (struct ipv6_opt_hdr *)*p;\n\t\t\tif (ipv6_optlen(*hdr) > newoptlen)\n\t\t\t\treturn -EINVAL;\n\t\t\t*p += CMSG_ALIGN(newoptlen);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstruct ipv6_txoptions *\nipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,\n\t\t   int newtype,\n\t\t   struct ipv6_opt_hdr __user *newopt, int newoptlen)\n{\n\tint tot_len = 0;\n\tchar *p;\n\tstruct ipv6_txoptions *opt2;\n\tint err;\n\n\tif (opt) {\n\t\tif (newtype != IPV6_HOPOPTS && opt->hopopt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->hopopt));\n\t\tif (newtype != IPV6_RTHDRDSTOPTS && opt->dst0opt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst0opt));\n\t\tif (newtype != IPV6_RTHDR && opt->srcrt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->srcrt));\n\t\tif (newtype != IPV6_DSTOPTS && opt->dst1opt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst1opt));\n\t}\n\n\tif (newopt && newoptlen)\n\t\ttot_len += CMSG_ALIGN(newoptlen);\n\n\tif (!tot_len)\n\t\treturn NULL;\n\n\ttot_len += sizeof(*opt2);\n\topt2 = sock_kmalloc(sk, tot_len, GFP_ATOMIC);\n\tif (!opt2)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\tmemset(opt2, 0, tot_len);\n\n\topt2->tot_len = tot_len;\n\tp = (char *)(opt2 + 1);\n\n\terr = ipv6_renew_option(opt ? opt->hopopt : NULL, newopt, newoptlen,\n\t\t\t\tnewtype != IPV6_HOPOPTS,\n\t\t\t\t&opt2->hopopt, &p);\n\tif (err)\n\t\tgoto out;\n\n\terr = ipv6_renew_option(opt ? opt->dst0opt : NULL, newopt, newoptlen,\n\t\t\t\tnewtype != IPV6_RTHDRDSTOPTS,\n\t\t\t\t&opt2->dst0opt, &p);\n\tif (err)\n\t\tgoto out;\n\n\terr = ipv6_renew_option(opt ? opt->srcrt : NULL, newopt, newoptlen,\n\t\t\t\tnewtype != IPV6_RTHDR,\n\t\t\t\t(struct ipv6_opt_hdr **)&opt2->srcrt, &p);\n\tif (err)\n\t\tgoto out;\n\n\terr = ipv6_renew_option(opt ? opt->dst1opt : NULL, newopt, newoptlen,\n\t\t\t\tnewtype != IPV6_DSTOPTS,\n\t\t\t\t&opt2->dst1opt, &p);\n\tif (err)\n\t\tgoto out;\n\n\topt2->opt_nflen = (opt2->hopopt ? ipv6_optlen(opt2->hopopt) : 0) +\n\t\t\t  (opt2->dst0opt ? ipv6_optlen(opt2->dst0opt) : 0) +\n\t\t\t  (opt2->srcrt ? ipv6_optlen(opt2->srcrt) : 0);\n\topt2->opt_flen = (opt2->dst1opt ? ipv6_optlen(opt2->dst1opt) : 0);\n\n\treturn opt2;\nout:\n\tsock_kfree_s(sk, opt2, opt2->tot_len);\n\treturn ERR_PTR(err);\n}\n\nstruct ipv6_txoptions *ipv6_fixup_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t  struct ipv6_txoptions *opt)\n{\n\t/*\n\t * ignore the dest before srcrt unless srcrt is being included.\n\t * --yoshfuji\n\t */\n\tif (opt && opt->dst0opt && !opt->srcrt) {\n\t\tif (opt_space != opt) {\n\t\t\tmemcpy(opt_space, opt, sizeof(*opt_space));\n\t\t\topt = opt_space;\n\t\t}\n\t\topt->opt_nflen -= ipv6_optlen(opt->dst0opt);\n\t\topt->dst0opt = NULL;\n\t}\n\n\treturn opt;\n}\nEXPORT_SYMBOL_GPL(ipv6_fixup_options);\n\n/**\n * fl6_update_dst - update flowi destination address with info given\n *                  by srcrt option, if any.\n *\n * @fl6: flowi6 for which daddr is to be updated\n * @opt: struct ipv6_txoptions in which to look for srcrt opt\n * @orig: copy of original daddr address if modified\n *\n * Returns NULL if no txoptions or no srcrt, otherwise returns orig\n * and initial value of fl6->daddr set in orig\n */\nstruct in6_addr *fl6_update_dst(struct flowi6 *fl6,\n\t\t\t\tconst struct ipv6_txoptions *opt,\n\t\t\t\tstruct in6_addr *orig)\n{\n\tif (!opt || !opt->srcrt)\n\t\treturn NULL;\n\n\t*orig = fl6->daddr;\n\tfl6->daddr = *((struct rt0_hdr *)opt->srcrt)->addr;\n\treturn orig;\n}\nEXPORT_SYMBOL_GPL(fl6_update_dst);\n", "/*\n * INET        An implementation of the TCP/IP protocol suite for the LINUX\n *             operating system.  INET is implemented using the  BSD Socket\n *             interface as the means of communication with the user level.\n *\n *             Support for INET6 connection oriented protocols.\n *\n * Authors:    See the TCPv6 sources\n *\n *             This program is free software; you can redistribute it and/or\n *             modify it under the terms of the GNU General Public License\n *             as published by the Free Software Foundation; either version\n *             2 of the License, or(at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/jhash.h>\n#include <linux/slab.h>\n\n#include <net/addrconf.h>\n#include <net/inet_connection_sock.h>\n#include <net/inet_ecn.h>\n#include <net/inet_hashtables.h>\n#include <net/ip6_route.h>\n#include <net/sock.h>\n#include <net/inet6_connection_sock.h>\n\nint inet6_csk_bind_conflict(const struct sock *sk,\n\t\t\t    const struct inet_bind_bucket *tb, bool relax)\n{\n\tconst struct sock *sk2;\n\tint reuse = sk->sk_reuse;\n\tint reuseport = sk->sk_reuseport;\n\tkuid_t uid = sock_i_uid((struct sock *)sk);\n\n\t/* We must walk the whole port owner list in this case. -DaveM */\n\t/*\n\t * See comment in inet_csk_bind_conflict about sock lookup\n\t * vs net namespaces issues.\n\t */\n\tsk_for_each_bound(sk2, &tb->owners) {\n\t\tif (sk != sk2 &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     !sk2->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == sk2->sk_bound_dev_if)) {\n\t\t\tif ((!reuse || !sk2->sk_reuse ||\n\t\t\t     sk2->sk_state == TCP_LISTEN) &&\n\t\t\t    (!reuseport || !sk2->sk_reuseport ||\n\t\t\t     (sk2->sk_state != TCP_TIME_WAIT &&\n\t\t\t      !uid_eq(uid,\n\t\t\t\t      sock_i_uid((struct sock *)sk2))))) {\n\t\t\t\tif (ipv6_rcv_saddr_equal(sk, sk2))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!relax && reuse && sk2->sk_reuse &&\n\t\t\t    sk2->sk_state != TCP_LISTEN &&\n\t\t\t    ipv6_rcv_saddr_equal(sk, sk2))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sk2 != NULL;\n}\nEXPORT_SYMBOL_GPL(inet6_csk_bind_conflict);\n\nstruct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\n\treturn dst;\n}\nEXPORT_SYMBOL(inet6_csk_route_req);\n\nvoid inet6_csk_addr2sockaddr(struct sock *sk, struct sockaddr *uaddr)\n{\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) uaddr;\n\n\tsin6->sin6_family = AF_INET6;\n\tsin6->sin6_addr = sk->sk_v6_daddr;\n\tsin6->sin6_port\t= inet_sk(sk)->inet_dport;\n\t/* We do not store received flowlabel for TCP */\n\tsin6->sin6_flowinfo = 0;\n\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t  sk->sk_bound_dev_if);\n}\nEXPORT_SYMBOL_GPL(inet6_csk_addr2sockaddr);\n\nstatic inline\nvoid __inet6_csk_dst_store(struct sock *sk, struct dst_entry *dst,\n\t\t\t   const struct in6_addr *daddr,\n\t\t\t   const struct in6_addr *saddr)\n{\n\t__ip6_dst_store(sk, dst, daddr, saddr);\n}\n\nstatic inline\nstruct dst_entry *__inet6_csk_dst_check(struct sock *sk, u32 cookie)\n{\n\treturn __sk_dst_check(sk, cookie);\n}\n\nstatic struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}\n\nint inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\n\t/* Restore final destination back after routing done */\n\tfl6.daddr = sk->sk_v6_daddr;\n\n\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(inet6_csk_xmit);\n\nstruct dst_entry *inet6_csk_update_pmtu(struct sock *sk, u32 mtu)\n{\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst = inet6_csk_route_socket(sk, &fl6);\n\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\tdst->ops->update_pmtu(dst, sk, NULL, mtu);\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\treturn IS_ERR(dst) ? NULL : dst;\n}\nEXPORT_SYMBOL_GPL(inet6_csk_update_pmtu);\n", "/*\n *\tIPv6 BSD socket options interface\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/net/ipv4/ip_sockglue.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *\tFIXME: Make the setsockopt code POSIX compliant: That is\n *\n *\to\tTruncate getsockopt returns\n *\to\tReturn an optlen of the truncated length if need be\n *\n *\tChanges:\n *\tDavid L Stevens <dlstevens@us.ibm.com>:\n *\t\t- added multicast source filtering API for MLDv2\n */\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/mroute6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <net/xfrm.h>\n#include <net/compat.h>\n\n#include <asm/uaccess.h>\n\nstruct ip6_ra_chain *ip6_ra_chain;\nDEFINE_RWLOCK(ip6_ra_lock);\n\nint ip6_ra_control(struct sock *sk, int sel)\n{\n\tstruct ip6_ra_chain *ra, *new_ra, **rap;\n\n\t/* RA packet may be delivered ONLY to IPPROTO_RAW socket */\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num != IPPROTO_RAW)\n\t\treturn -ENOPROTOOPT;\n\n\tnew_ra = (sel >= 0) ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\n\twrite_lock_bh(&ip6_ra_lock);\n\tfor (rap = &ip6_ra_chain; (ra = *rap) != NULL; rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (sel >= 0) {\n\t\t\t\twrite_unlock_bh(&ip6_ra_lock);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\n\t\t\t*rap = ra->next;\n\t\t\twrite_unlock_bh(&ip6_ra_lock);\n\n\t\t\tsock_put(sk);\n\t\t\tkfree(ra);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\twrite_unlock_bh(&ip6_ra_lock);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->sel = sel;\n\tnew_ra->next = ra;\n\t*rap = new_ra;\n\tsock_hold(sk);\n\twrite_unlock_bh(&ip6_ra_lock);\n\treturn 0;\n}\n\nstatic\nstruct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\n\treturn opt;\n}\n\nstatic bool setsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\tcase MCAST_MSFILTER:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val, valbool;\n\tint retv = -ENOPROTOOPT;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tif (!optval)\n\t\tval = 0;\n\telse {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\tval = 0;\n\t}\n\n\tvalbool = (val != 0);\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_setsockopt(sk, optname, optval, optlen);\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase IPV6_ADDRFORM:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val == PF_INET) {\n\t\t\tstruct ipv6_txoptions *opt;\n\t\t\tstruct sk_buff *pktopt;\n\n\t\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t    sk->sk_protocol == IPPROTO_UDPLITE) {\n\t\t\t\tstruct udp_sock *up = udp_sk(sk);\n\t\t\t\tif (up->pending == AF_INET6) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (sk->sk_protocol != IPPROTO_TCP)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\t\tretv = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ipv6_only_sock(sk) ||\n\t\t\t    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {\n\t\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfl6_free_socklist(sk);\n\t\t\tipv6_sock_mc_close(sk);\n\n\t\t\t/*\n\t\t\t * Sock is moving from IPv6 to IPv4 (sk_prot), so\n\t\t\t * remove it from the refcnt debug socks count in the\n\t\t\t * original family...\n\t\t\t */\n\t\t\tsk_refcnt_debug_dec(sk);\n\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, &tcp_prot, 1);\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tsk->sk_prot = &tcp_prot;\n\t\t\t\ticsk->icsk_af_ops = &ipv4_specific;\n\t\t\t\tsk->sk_socket->ops = &inet_stream_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t\t} else {\n\t\t\t\tstruct proto *prot = &udp_prot;\n\n\t\t\t\tif (sk->sk_protocol == IPPROTO_UDPLITE)\n\t\t\t\t\tprot = &udplite_prot;\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, prot, 1);\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tsk->sk_prot = prot;\n\t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t}\n\t\t\topt = xchg(&np->opt, NULL);\n\t\t\tif (opt)\n\t\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t\t\tpktopt = xchg(&np->pktoptions, NULL);\n\t\t\tkfree_skb(pktopt);\n\n\t\t\tsk->sk_destruct = inet_sock_destruct;\n\t\t\t/*\n\t\t\t * ... and add it to the refcnt debug socks count\n\t\t\t * in the new family. -acme\n\t\t\t */\n\t\t\tsk_refcnt_debug_inc(sk);\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgoto e_inval;\n\n\tcase IPV6_V6ONLY:\n\t\tif (optlen < sizeof(int) ||\n\t\t    inet_sk(sk)->inet_num)\n\t\t\tgoto e_inval;\n\t\tsk->sk_ipv6only = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxoinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxhlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxohlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.srcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.osrcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.hopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.ohopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.dstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.odstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < -1 || val > 0xff)\n\t\t\tgoto e_inval;\n\t\t/* RFC 3542, 6.5: default traffic class of 0x0 */\n\t\tif (val == -1)\n\t\t\tval = 0;\n\t\tnp->tclass = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxtclass = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxpmtu = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TRANSPARENT:\n\t\tif (valbool && !ns_capable(net->user_ns, CAP_NET_ADMIN) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\tretv = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t/* we don't have a separate transparent bit for IPV6 we use the one in the IPv4 socket */\n\t\tinet_sk(sk)->transparent = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxorigdstaddr = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\t\tstruct ipv6_txoptions *opt;\n\n\t\t/* remove any sticky options header with a zero option\n\t\t * length, per RFC3542.\n\t\t */\n\t\tif (optlen == 0)\n\t\t\toptval = NULL;\n\t\telse if (!optval)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct ipv6_opt_hdr) ||\n\t\t\t optlen & 0x7 || optlen > 8 * 255)\n\t\t\tgoto e_inval;\n\n\t\t/* hop-by-hop / destination options are privileged option */\n\t\tretv = -EPERM;\n\t\tif (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\t\tbreak;\n\n\t\topt = ipv6_renew_options(sk, np->opt, optname,\n\t\t\t\t\t (struct ipv6_opt_hdr __user *)optval,\n\t\t\t\t\t optlen);\n\t\tif (IS_ERR(opt)) {\n\t\t\tretv = PTR_ERR(opt);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* routing header option needs extra check */\n\t\tretv = -EINVAL;\n\t\tif (optname == IPV6_RTHDR && opt && opt->srcrt) {\n\t\t\tstruct ipv6_rt_hdr *rthdr = opt->srcrt;\n\t\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t\tif (rthdr->hdrlen != 2 ||\n\t\t\t\t    rthdr->segments_left != 1)\n\t\t\t\t\tgoto sticky_done;\n\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tgoto sticky_done;\n\t\t\t}\n\t\t}\n\n\t\tretv = 0;\n\t\topt = ipv6_update_options(sk, opt);\nsticky_done:\n\t\tif (opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t\tbreak;\n\t}\n\n\tcase IPV6_PKTINFO:\n\t{\n\t\tstruct in6_pktinfo pkt;\n\n\t\tif (optlen == 0)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct in6_pktinfo) || !optval)\n\t\t\tgoto e_inval;\n\n\t\tif (copy_from_user(&pkt, optval, sizeof(struct in6_pktinfo))) {\n\t\t\t\tretv = -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (sk->sk_bound_dev_if && pkt.ipi6_ifindex != sk->sk_bound_dev_if)\n\t\t\tgoto e_inval;\n\n\t\tnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;\n\t\tnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct ipv6_txoptions *opt = NULL;\n\t\tstruct msghdr msg;\n\t\tstruct flowi6 fl6;\n\t\tint junk;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\n\t\tif (optlen == 0)\n\t\t\tgoto update;\n\n\t\t/* 1K is probably excessive\n\t\t * 1K is surely not enough, 2K per standard header is 16K.\n\t\t */\n\t\tretv = -EINVAL;\n\t\tif (optlen > 64*1024)\n\t\t\tbreak;\n\n\t\topt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);\n\t\tretv = -ENOBUFS;\n\t\tif (!opt)\n\t\t\tbreak;\n\n\t\tmemset(opt, 0, sizeof(*opt));\n\t\topt->tot_len = sizeof(*opt) + optlen;\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(opt+1, optval, optlen))\n\t\t\tgoto done;\n\n\t\tmsg.msg_controllen = optlen;\n\t\tmsg.msg_control = (void *)(opt+1);\n\n\t\tretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, opt, &junk,\n\t\t\t\t\t     &junk, &junk);\n\t\tif (retv)\n\t\t\tgoto done;\nupdate:\n\t\tretv = 0;\n\t\topt = ipv6_update_options(sk, opt);\ndone:\n\t\tif (opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\t\tbreak;\n\t}\n\tcase IPV6_UNICAST_HOPS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->hop_limit = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_HOPS:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val != valbool)\n\t\t\tgoto e_inval;\n\t\tnp->mc_loop = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tnp->ucast_oif = 0;\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(net, ifindex);\n\t\tretv = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\tretv = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tnp->ucast_oif = ifindex;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_IF:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tif (val) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != val)\n\t\t\t\tgoto e_inval;\n\n\t\t\tdev = dev_get_by_index(net, val);\n\t\t\tif (!dev) {\n\t\t\t\tretv = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_put(dev);\n\t\t}\n\t\tnp->mcast_oif = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_ADD_MEMBERSHIP)\n\t\t\tretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_JOIN_ANYCAST)\n\t\t\tretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in6 *psin6;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(struct group_req)))\n\t\t\tbreak;\n\t\tif (greq.gr_group.ss_family != AF_INET6) {\n\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin6 = (struct sockaddr_in6 *)&greq.gr_group;\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\tretv = ipv6_sock_mc_join(sk, greq.gr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, greq.gr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tint omode, add;\n\n\t\tif (optlen < sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\tretv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET6 ||\n\t\t    greqs.gsr_source.ss_family != AF_INET6) {\n\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct sockaddr_in6 *psin6;\n\n\t\t\tpsin6 = (struct sockaddr_in6 *)&greqs.gsr_group;\n\t\t\tretv = ipv6_sock_mc_join(sk, greqs.gsr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\t\t/* prior join w/ different source is ok */\n\t\t\tif (retv && retv != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\tretv = ip6_mc_source(add, omode, sk, &greqs);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter *gsf;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen)) {\n\t\t\tkfree(gsf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffffU ||\n\t\t    gsf->gf_numsrc > sysctl_mld_max_msf) {\n\t\t\tkfree(gsf);\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\tkfree(gsf);\n\t\t\tretv = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tretv = ip6_mc_msfilter(sk, gsf);\n\t\tkfree(gsf);\n\n\t\tbreak;\n\t}\n\tcase IPV6_ROUTER_ALERT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = ip6_ra_control(sk, val);\n\t\tbreak;\n\tcase IPV6_MTU_DISCOVER:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tnp->pmtudisc = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val && val < IPV6_MIN_MTU)\n\t\t\tgoto e_inval;\n\t\tnp->frag_size = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->recverr = valbool;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWINFO_SEND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->sndflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWLABEL_MGR:\n\t\tretv = ipv6_flowlabel_opt(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_IPSEC_POLICY:\n\tcase IPV6_XFRM_POLICY:\n\t\tretv = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tretv = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t    {\n\t\tunsigned int pref = 0;\n\t\tunsigned int prefmask = ~0;\n\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EINVAL;\n\n\t\t/* check PUBLIC/TMP/PUBTMP_DEFAULT conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_PUBLIC|\n\t\t\t       IPV6_PREFER_SRC_TMP|\n\t\t\t       IPV6_PREFER_SRC_PUBTMP_DEFAULT)) {\n\t\tcase IPV6_PREFER_SRC_PUBLIC:\n\t\t\tpref |= IPV6_PREFER_SRC_PUBLIC;\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_TMP:\n\t\t\tpref |= IPV6_PREFER_SRC_TMP;\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_PUBTMP_DEFAULT:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tgoto pref_skip_pubtmp;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tprefmask &= ~(IPV6_PREFER_SRC_PUBLIC|\n\t\t\t      IPV6_PREFER_SRC_TMP);\npref_skip_pubtmp:\n\n\t\t/* check HOME/COA conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_HOME|IPV6_PREFER_SRC_COA)) {\n\t\tcase IPV6_PREFER_SRC_HOME:\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_COA:\n\t\t\tpref |= IPV6_PREFER_SRC_COA;\n\t\tcase 0:\n\t\t\tgoto pref_skip_coa;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tprefmask &= ~IPV6_PREFER_SRC_COA;\npref_skip_coa:\n\n\t\t/* check CGA/NONCGA conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_CGA|IPV6_PREFER_SRC_NONCGA)) {\n\t\tcase IPV6_PREFER_SRC_CGA:\n\t\tcase IPV6_PREFER_SRC_NONCGA:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tnp->srcprefs = (np->srcprefs & prefmask) | pref;\n\t\tretv = 0;\n\n\t\tbreak;\n\t    }\n\tcase IPV6_MINHOPCOUNT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tnp->min_hopcount = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_DONTFRAG:\n\t\tnp->dontfrag = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tnp->autoflowlabel = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\n\treturn retv;\n\ne_inval:\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}\n\nint ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t\t\toptname != IPV6_XFRM_POLICY) {\n\t\tlock_sock(sk);\n\t\terr = nf_setsockopt(sk, PF_INET6, optname, optval,\n\t\t\t\toptlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ipv6_setsockopt);\n\n#ifdef CONFIG_COMPAT\nint compat_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_setsockopt != NULL)\n\t\t\treturn udp_prot.compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_setsockopt);\n\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t    optname != IPV6_XFRM_POLICY) {\n\t\tlock_sock(sk);\n\t\terr = compat_nf_setsockopt(sk, PF_INET6, optname,\n\t\t\t\t\t   optval, optlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(compat_ipv6_setsockopt);\n#endif\n\nstatic int ipv6_getsockopt_sticky(struct sock *sk, struct ipv6_txoptions *opt,\n\t\t\t\t  int optname, char __user *optval, int len)\n{\n\tstruct ipv6_opt_hdr *hdr;\n\n\tif (!opt)\n\t\treturn 0;\n\n\tswitch (optname) {\n\tcase IPV6_HOPOPTS:\n\t\thdr = opt->hopopt;\n\t\tbreak;\n\tcase IPV6_RTHDRDSTOPTS:\n\t\thdr = opt->dst0opt;\n\t\tbreak;\n\tcase IPV6_RTHDR:\n\t\thdr = (struct ipv6_opt_hdr *)opt->srcrt;\n\t\tbreak;\n\tcase IPV6_DSTOPTS:\n\t\thdr = opt->dst1opt;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\t/* should not happen */\n\t}\n\n\tif (!hdr)\n\t\treturn 0;\n\n\tlen = min_t(unsigned int, len, ipv6_optlen(hdr));\n\tif (copy_to_user(optval, hdr, len))\n\t\treturn -EFAULT;\n\treturn len;\n}\n\nstatic int do_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen, unsigned int flags)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint len;\n\tint val;\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tswitch (optname) {\n\tcase IPV6_ADDRFORM:\n\t\tif (sk->sk_protocol != IPPROTO_UDP &&\n\t\t    sk->sk_protocol != IPPROTO_UDPLITE &&\n\t\t    sk->sk_protocol != IPPROTO_TCP)\n\t\t\treturn -ENOPROTOOPT;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tval = sk->sk_family;\n\t\tbreak;\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter gsf;\n\t\tint err;\n\n\t\tif (len < GROUP_FILTER_SIZE(0))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0)))\n\t\t\treturn -EFAULT;\n\t\tif (gsf.gf_group.ss_family != AF_INET6)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tlock_sock(sk);\n\t\terr = ip6_mc_msfget(sk, &gsf,\n\t\t\t(struct group_filter __user *)optval, optlen);\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\t\tstruct sk_buff *skb;\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tmsg.msg_control = optval;\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = flags;\n\n\t\tlock_sock(sk);\n\t\tskb = np->pktoptions;\n\t\tif (skb)\n\t\t\tip6_datagram_recv_ctl(sk, &msg, skb);\n\t\trelease_sock(sk);\n\t\tif (!skb) {\n\t\t\tif (np->rxopt.bits.rxinfo) {\n\t\t\t\tstruct in6_pktinfo src_info;\n\t\t\t\tsrc_info.ipi6_ifindex = np->mcast_oif ? np->mcast_oif :\n\t\t\t\t\tnp->sticky_pktinfo.ipi6_ifindex;\n\t\t\t\tsrc_info.ipi6_addr = np->mcast_oif ? sk->sk_v6_daddr : np->sticky_pktinfo.ipi6_addr;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_PKTINFO, sizeof(src_info), &src_info);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxhlim) {\n\t\t\t\tint hlim = np->mcast_hops;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxtclass) {\n\t\t\t\tint tclass = (int)ip6_tclass(np->rcv_flowinfo);\n\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxoinfo) {\n\t\t\t\tstruct in6_pktinfo src_info;\n\t\t\t\tsrc_info.ipi6_ifindex = np->mcast_oif ? np->mcast_oif :\n\t\t\t\t\tnp->sticky_pktinfo.ipi6_ifindex;\n\t\t\t\tsrc_info.ipi6_addr = np->mcast_oif ? sk->sk_v6_daddr :\n\t\t\t\t\t\t\t\t     np->sticky_pktinfo.ipi6_addr;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxohlim) {\n\t\t\t\tint hlim = np->mcast_hops;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxflow) {\n\t\t\t\t__be32 flowinfo = np->rcv_flowinfo;\n\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);\n\t\t\t}\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn put_user(len, optlen);\n\t}\n\tcase IPV6_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\n\t\tval = 0;\n\t\trcu_read_lock();\n\t\tdst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tval = dst_mtu(dst);\n\t\trcu_read_unlock();\n\t\tif (!val)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\t}\n\n\tcase IPV6_V6ONLY:\n\t\tval = sk->sk_ipv6only;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tval = np->rxopt.bits.rxinfo;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tval = np->rxopt.bits.rxoinfo;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tval = np->rxopt.bits.rxhlim;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tval = np->rxopt.bits.rxohlim;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tval = np->rxopt.bits.srcrt;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tval = np->rxopt.bits.osrcrt;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\n\t\tlock_sock(sk);\n\t\tlen = ipv6_getsockopt_sticky(sk, np->opt,\n\t\t\t\t\t     optname, optval, len);\n\t\trelease_sock(sk);\n\t\t/* check if ipv6_getsockopt_sticky() returns err code */\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\treturn put_user(len, optlen);\n\t}\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tval = np->rxopt.bits.hopopts;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tval = np->rxopt.bits.ohopopts;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tval = np->rxopt.bits.dstopts;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tval = np->rxopt.bits.odstopts;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tval = np->tclass;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tval = np->rxopt.bits.rxtclass;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tval = np->rxopt.bits.rxflow;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tval = np->rxopt.bits.rxpmtu;\n\t\tbreak;\n\n\tcase IPV6_PATHMTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tstruct ip6_mtuinfo mtuinfo;\n\n\t\tif (len < sizeof(mtuinfo))\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof(mtuinfo);\n\t\tmemset(&mtuinfo, 0, sizeof(mtuinfo));\n\n\t\trcu_read_lock();\n\t\tdst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tmtuinfo.ip6m_mtu = dst_mtu(dst);\n\t\trcu_read_unlock();\n\t\tif (!mtuinfo.ip6m_mtu)\n\t\t\treturn -ENOTCONN;\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &mtuinfo, len))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase IPV6_TRANSPARENT:\n\t\tval = inet_sk(sk)->transparent;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tval = np->rxopt.bits.rxorigdstaddr;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_HOPS:\n\tcase IPV6_MULTICAST_HOPS:\n\t{\n\t\tstruct dst_entry *dst;\n\n\t\tif (optname == IPV6_UNICAST_HOPS)\n\t\t\tval = np->hop_limit;\n\t\telse\n\t\t\tval = np->mcast_hops;\n\n\t\tif (val < 0) {\n\t\t\trcu_read_lock();\n\t\t\tdst = __sk_dst_get(sk);\n\t\t\tif (dst)\n\t\t\t\tval = ip6_dst_hoplimit(dst);\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tif (val < 0)\n\t\t\tval = sock_net(sk)->ipv6.devconf_all->hop_limit;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tval = np->mc_loop;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_IF:\n\t\tval = np->mcast_oif;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t\tval = (__force int)htonl((__u32) np->ucast_oif);\n\t\tbreak;\n\n\tcase IPV6_MTU_DISCOVER:\n\t\tval = np->pmtudisc;\n\t\tbreak;\n\n\tcase IPV6_RECVERR:\n\t\tval = np->recverr;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO_SEND:\n\t\tval = np->sndflow;\n\t\tbreak;\n\n\tcase IPV6_FLOWLABEL_MGR:\n\t{\n\t\tstruct in6_flowlabel_req freq;\n\t\tint flags;\n\n\t\tif (len < sizeof(freq))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&freq, optval, sizeof(freq)))\n\t\t\treturn -EFAULT;\n\n\t\tif (freq.flr_action != IPV6_FL_A_GET)\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof(freq);\n\t\tflags = freq.flr_flags;\n\n\t\tmemset(&freq, 0, sizeof(freq));\n\n\t\tval = ipv6_flowlabel_opt_get(sk, &freq, flags);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &freq, len))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t\tval = 0;\n\n\t\tif (np->srcprefs & IPV6_PREFER_SRC_TMP)\n\t\t\tval |= IPV6_PREFER_SRC_TMP;\n\t\telse if (np->srcprefs & IPV6_PREFER_SRC_PUBLIC)\n\t\t\tval |= IPV6_PREFER_SRC_PUBLIC;\n\t\telse {\n\t\t\t/* XXX: should we return system default? */\n\t\t\tval |= IPV6_PREFER_SRC_PUBTMP_DEFAULT;\n\t\t}\n\n\t\tif (np->srcprefs & IPV6_PREFER_SRC_COA)\n\t\t\tval |= IPV6_PREFER_SRC_COA;\n\t\telse\n\t\t\tval |= IPV6_PREFER_SRC_HOME;\n\t\tbreak;\n\n\tcase IPV6_MINHOPCOUNT:\n\t\tval = np->min_hopcount;\n\t\tbreak;\n\n\tcase IPV6_DONTFRAG:\n\t\tval = np->dontfrag;\n\t\tbreak;\n\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tval = np->autoflowlabel;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tlen = min_t(unsigned int, sizeof(int), len);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ipv6_getsockopt(sk, level, optname, optval, optlen, 0);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\terr = nf_getsockopt(sk, PF_INET6, optname, optval,\n\t\t\t\t&len);\n\t\trelease_sock(sk);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ipv6_getsockopt);\n\n#ifdef CONFIG_COMPAT\nint compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_getsockopt != NULL)\n\t\t\treturn udp_prot.compat_getsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname == MCAST_MSFILTER)\n\t\treturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_getsockopt);\n\n\terr = do_ipv6_getsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t MSG_CMSG_COMPAT);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\terr = compat_nf_getsockopt(sk, PF_INET6,\n\t\t\t\t\t   optname, optval, &len);\n\t\trelease_sock(sk);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(compat_ipv6_getsockopt);\n#endif\n\n", "/*\n *\tRAW sockets for IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tAdapted from linux/net/ipv4/raw.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI,H.@USAGI\t:\traw checksum (RFC2292(bis) compliance)\n *\tKazunori MIYAZAWA @USAGI:\tchange process style to use ip6_append_data\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmpv6.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/skbuff.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/addrconf.h>\n#include <net/transp_v6.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/tcp_states.h>\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n#include <net/mip6.h>\n#endif\n#include <linux/mroute6.h>\n\n#include <net/raw.h>\n#include <net/rawv6.h>\n#include <net/xfrm.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n\n#define\tICMPV6_HDRLEN\t4\t/* ICMPv6 header, RFC 4443 Section 2.1 */\n\nstatic struct raw_hashinfo raw_v6_hashinfo = {\n\t.lock = __RW_LOCK_UNLOCKED(raw_v6_hashinfo.lock),\n};\n\nstatic struct sock *__raw_v6_lookup(struct net *net, struct sock *sk,\n\t\tunsigned short num, const struct in6_addr *loc_addr,\n\t\tconst struct in6_addr *rmt_addr, int dif)\n{\n\tbool is_multicast = ipv6_addr_is_multicast(loc_addr);\n\n\tsk_for_each_from(sk)\n\t\tif (inet_sk(sk)->inet_num == num) {\n\n\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\tcontinue;\n\n\t\t\tif (!ipv6_addr_any(&sk->sk_v6_daddr) &&\n\t\t\t    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr))\n\t\t\t\tcontinue;\n\n\t\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)\n\t\t\t\tcontinue;\n\n\t\t\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\t\t\tif (ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr))\n\t\t\t\t\tgoto found;\n\t\t\t\tif (is_multicast &&\n\t\t\t\t    inet6_mc_check(sk, loc_addr, rmt_addr))\n\t\t\t\t\tgoto found;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\n/*\n *\t0 - deliver\n *\t1 - block\n */\nstatic int icmpv6_filter(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct icmp6hdr _hdr;\n\tconst struct icmp6hdr *hdr;\n\n\t/* We require only the four bytes of the ICMPv6 header, not any\n\t * additional bytes of message body in \"struct icmp6hdr\".\n\t */\n\thdr = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t ICMPV6_HDRLEN, &_hdr);\n\tif (hdr) {\n\t\tconst __u32 *data = &raw6_sk(sk)->filter.data[0];\n\t\tunsigned int type = hdr->icmp6_type;\n\n\t\treturn (data[type >> 5] & (1U << (type & 31))) != 0;\n\t}\n\treturn 1;\n}\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\ntypedef int mh_filter_t(struct sock *sock, struct sk_buff *skb);\n\nstatic mh_filter_t __rcu *mh_filter __read_mostly;\n\nint rawv6_mh_filter_register(mh_filter_t filter)\n{\n\trcu_assign_pointer(mh_filter, filter);\n\treturn 0;\n}\nEXPORT_SYMBOL(rawv6_mh_filter_register);\n\nint rawv6_mh_filter_unregister(mh_filter_t filter)\n{\n\tRCU_INIT_POINTER(mh_filter, NULL);\n\tsynchronize_rcu();\n\treturn 0;\n}\nEXPORT_SYMBOL(rawv6_mh_filter_unregister);\n\n#endif\n\n/*\n *\tdemultiplex raw sockets.\n *\t(should consider queueing the skb in the sock receive_queue\n *\twithout calling rawv6.c)\n *\n *\tCaller owns SKB so we must make clones.\n */\nstatic bool ipv6_raw_deliver(struct sk_buff *skb, int nexthdr)\n{\n\tconst struct in6_addr *saddr;\n\tconst struct in6_addr *daddr;\n\tstruct sock *sk;\n\tbool delivered = false;\n\t__u8 hash;\n\tstruct net *net;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = saddr + 1;\n\n\thash = nexthdr & (RAW_HTABLE_SIZE - 1);\n\n\tread_lock(&raw_v6_hashinfo.lock);\n\tsk = sk_head(&raw_v6_hashinfo.ht[hash]);\n\n\tif (!sk)\n\t\tgoto out;\n\n\tnet = dev_net(skb->dev);\n\tsk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr, inet6_iif(skb));\n\n\twhile (sk) {\n\t\tint filtered;\n\n\t\tdelivered = true;\n\t\tswitch (nexthdr) {\n\t\tcase IPPROTO_ICMPV6:\n\t\t\tfiltered = icmpv6_filter(sk, skb);\n\t\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPPROTO_MH:\n\t\t{\n\t\t\t/* XXX: To validate MH only once for each packet,\n\t\t\t * this is placed here. It should be after checking\n\t\t\t * xfrm policy, however it doesn't. The checking xfrm\n\t\t\t * policy is placed in rawv6_rcv() because it is\n\t\t\t * required for each socket.\n\t\t\t */\n\t\t\tmh_filter_t *filter;\n\n\t\t\tfilter = rcu_dereference(mh_filter);\n\t\t\tfiltered = filter ? (*filter)(sk, skb) : 0;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tfiltered = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (filtered < 0)\n\t\t\tbreak;\n\t\tif (filtered == 0) {\n\t\t\tstruct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Not releasing hash table! */\n\t\t\tif (clone) {\n\t\t\t\tnf_reset(clone);\n\t\t\t\trawv6_rcv(sk, clone);\n\t\t\t}\n\t\t}\n\t\tsk = __raw_v6_lookup(net, sk_next(sk), nexthdr, daddr, saddr,\n\t\t\t\t     inet6_iif(skb));\n\t}\nout:\n\tread_unlock(&raw_v6_hashinfo.lock);\n\treturn delivered;\n}\n\nbool raw6_local_deliver(struct sk_buff *skb, int nexthdr)\n{\n\tstruct sock *raw_sk;\n\n\traw_sk = sk_head(&raw_v6_hashinfo.ht[nexthdr & (RAW_HTABLE_SIZE - 1)]);\n\tif (raw_sk && !ipv6_raw_deliver(skb, nexthdr))\n\t\traw_sk = NULL;\n\n\treturn raw_sk != NULL;\n}\n\n/* This cleans up af_inet6 a bit. -DaveM */\nstatic int rawv6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) uaddr;\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (addr->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\n\t/* Raw sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out;\n\n\trcu_read_lock();\n\t/* Check if the address belongs to the host. */\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->sin6_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\tif (!(addr_type & IPV6_ADDR_MULTICAST) &&\n\t\t    !sock_net(sk)->ipv6.sysctl.ip_nonlocal_bind) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->sin6_addr,\n\t\t\t\t\t   dev, 0)) {\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->sin6_addr;\n\tif (!(addr_type & IPV6_ADDR_MULTICAST))\n\t\tnp->saddr = addr->sin6_addr;\n\terr = 0;\nout_unlock:\n\trcu_read_unlock();\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void rawv6_err(struct sock *sk, struct sk_buff *skb,\n\t       struct inet6_skb_parm *opt,\n\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint err;\n\tint harderr;\n\n\t/* Report error on raw socket, if:\n\t   1. User requested recverr.\n\t   2. Socket is connected (otherwise the error indication\n\t      is useless without recverr and error is hard.\n\t */\n\tif (!np->recverr && sk->sk_state != TCP_ESTABLISHED)\n\t\treturn;\n\n\tharderr = icmpv6_err_convert(type, code, &err);\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tip6_sk_update_pmtu(skb, sk, info);\n\t\tharderr = (np->pmtudisc == IPV6_PMTUDISC_DO);\n\t}\n\tif (type == NDISC_REDIRECT) {\n\t\tip6_sk_redirect(skb, sk);\n\t\treturn;\n\t}\n\tif (np->recverr) {\n\t\tu8 *payload = skb->data;\n\t\tif (!inet->hdrincl)\n\t\t\tpayload += offset;\n\t\tipv6_icmp_error(sk, skb, err, 0, ntohl(info), payload);\n\t}\n\n\tif (np->recverr || harderr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t}\n}\n\nvoid raw6_icmp_error(struct sk_buff *skb, int nexthdr,\n\t\tu8 type, u8 code, int inner_offset, __be32 info)\n{\n\tstruct sock *sk;\n\tint hash;\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct net *net;\n\n\thash = nexthdr & (RAW_HTABLE_SIZE - 1);\n\n\tread_lock(&raw_v6_hashinfo.lock);\n\tsk = sk_head(&raw_v6_hashinfo.ht[hash]);\n\tif (sk) {\n\t\t/* Note: ipv6_hdr(skb) != skb->data */\n\t\tconst struct ipv6hdr *ip6h = (const struct ipv6hdr *)skb->data;\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t\tnet = dev_net(skb->dev);\n\n\t\twhile ((sk = __raw_v6_lookup(net, sk, nexthdr, saddr, daddr,\n\t\t\t\t\t\tinet6_iif(skb)))) {\n\t\t\trawv6_err(sk, skb, NULL, type, code,\n\t\t\t\t\tinner_offset, info);\n\t\t\tsk = sk_next(sk);\n\t\t}\n\t}\n\tread_unlock(&raw_v6_hashinfo.lock);\n}\n\nstatic inline int rawv6_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tif ((raw6_sk(sk)->checksum || rcu_access_pointer(sk->sk_filter)) &&\n\t    skb_checksum_complete(skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\t/* Charge it to the socket. */\n\tskb_dst_drop(skb);\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tThis is next to useless...\n *\tif we demultiplex in network layer we don't need the extra call\n *\tjust to queue the skb...\n *\tmaybe we could have the network decide upon a hint if it\n *\tshould call raw_rcv for demultiplexing\n */\nint rawv6_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (!rp->checksum)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tskb_postpull_rcsum(skb, skb_network_header(skb),\n\t\t\t\t   skb_network_header_len(skb));\n\t\tif (!csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr,\n\t\t\t\t     skb->len, inet->inet_num, skb->csum))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\tif (!skb_csum_unnecessary(skb))\n\t\tskb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t\t\t\t &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t\t skb->len,\n\t\t\t\t\t\t\t inet->inet_num, 0));\n\n\tif (inet->hdrincl) {\n\t\tif (skb_checksum_complete(skb)) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tkfree_skb(skb);\n\t\t\treturn NET_RX_DROP;\n\t\t}\n\t}\n\n\trawv6_rcv_skb(sk, skb);\n\treturn 0;\n}\n\n\n/*\n *\tThis should be easy, if there is something there\n *\twe return it, otherwise we block.\n */\n\nstatic int rawv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tif (skb_csum_unnecessary(skb)) {\n\t\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\t} else if (msg->msg_flags&MSG_TRUNC) {\n\t\tif (__skb_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\t} else {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, 0, msg);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Copy the address. */\n\tif (sin6) {\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  inet6_iif(skb));\n\t\t*addr_len = sizeof(*sin6);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = skb->len;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tskb_kill_datagram(sk, skb, flags);\n\n\t/* Error for blocking case is chosen to masquerade\n\t   as some normal condition.\n\t */\n\terr = (flags&MSG_DONTWAIT) ? -EAGAIN : -EHOSTUNREACH;\n\tgoto out;\n}\n\nstatic int rawv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t     struct raw6_sock *rp)\n{\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tint offset;\n\tint len;\n\tint total_len;\n\t__wsum tmp_csum;\n\t__sum16 csum;\n\n\tif (!rp->checksum)\n\t\tgoto send;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\tgoto out;\n\n\toffset = rp->offset;\n\ttotal_len = inet_sk(sk)->cork.base.length;\n\tif (offset >= total_len - 1) {\n\t\terr = -EINVAL;\n\t\tip6_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\n\t/* should be check HW csum miyazawa */\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\t/*\n\t\t * Only one fragment on the socket.\n\t\t */\n\t\ttmp_csum = skb->csum;\n\t} else {\n\t\tstruct sk_buff *csum_skb = NULL;\n\t\ttmp_csum = 0;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\ttmp_csum = csum_add(tmp_csum, skb->csum);\n\n\t\t\tif (csum_skb)\n\t\t\t\tcontinue;\n\n\t\t\tlen = skb->len - skb_transport_offset(skb);\n\t\t\tif (offset >= len) {\n\t\t\t\toffset -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcsum_skb = skb;\n\t\t}\n\n\t\tskb = csum_skb;\n\t}\n\n\toffset += skb_transport_offset(skb);\n\tBUG_ON(skb_copy_bits(skb, offset, &csum, 2));\n\n\t/* in case cksum was not initialized */\n\tif (unlikely(csum))\n\t\ttmp_csum = csum_sub(tmp_csum, csum_unfold(csum));\n\n\tcsum = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t       total_len, fl6->flowi6_proto, tmp_csum);\n\n\tif (csum == 0 && fl6->flowi6_proto == IPPROTO_UDP)\n\t\tcsum = CSUM_MANGLED_0;\n\n\tBUG_ON(skb_store_bits(skb, offset, &csum, 2));\n\nsend:\n\terr = ip6_push_pending_frames(sk);\nout:\n\treturn err;\n}\n\nstatic int rawv6_send_hdrinc(struct sock *sk, struct msghdr *msg, int length,\n\t\t\tstruct flowi6 *fl6, struct dst_entry **dstp,\n\t\t\tunsigned int flags)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct rt6_info *rt = (struct rt6_info *)*dstp;\n\tint hlen = LL_RESERVED_SPACE(rt->dst.dev);\n\tint tlen = rt->dst.dev->needed_tailroom;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tipv6_local_error(sk, EMSGSIZE, fl6, rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\tskb_dst_set(skb, &rt->dst);\n\t*dstp = NULL;\n\n\tskb_put(skb, length);\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb->transport_header = skb->network_header;\n\terr = memcpy_from_msg(iph, msg, length);\n\tif (err)\n\t\tgoto error_fault;\n\n\tIP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, net, sk, skb,\n\t\t      NULL, rt->dst.dev, dst_output);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\tif (err)\n\t\tgoto error;\nout:\n\treturn 0;\n\nerror_fault:\n\terr = -EFAULT;\n\tkfree_skb(skb);\nerror:\n\tIP6_INC_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\tif (err == -ENOBUFS && !np->recverr)\n\t\terr = 0;\n\treturn err;\n}\n\nstruct raw6_frag_vec {\n\tstruct msghdr *msg;\n\tint hlen;\n\tchar c[4];\n};\n\nstatic int rawv6_probe_proto_opt(struct raw6_frag_vec *rfv, struct flowi6 *fl6)\n{\n\tint err = 0;\n\tswitch (fl6->flowi6_proto) {\n\tcase IPPROTO_ICMPV6:\n\t\trfv->hlen = 2;\n\t\terr = memcpy_from_msg(rfv->c, rfv->msg, rfv->hlen);\n\t\tif (!err) {\n\t\t\tfl6->fl6_icmp_type = rfv->c[0];\n\t\t\tfl6->fl6_icmp_code = rfv->c[1];\n\t\t}\n\t\tbreak;\n\tcase IPPROTO_MH:\n\t\trfv->hlen = 4;\n\t\terr = memcpy_from_msg(rfv->c, rfv->msg, rfv->hlen);\n\t\tif (!err)\n\t\t\tfl6->fl6_mh_type = rfv->c[2];\n\t}\n\treturn err;\n}\n\nstatic int raw6_getfrag(void *from, char *to, int offset, int len, int odd,\n\t\t       struct sk_buff *skb)\n{\n\tstruct raw6_frag_vec *rfv = from;\n\n\tif (offset < rfv->hlen) {\n\t\tint copy = min(rfv->hlen - offset, len);\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tmemcpy(to, rfv->c + offset, copy);\n\t\telse\n\t\t\tskb->csum = csum_block_add(\n\t\t\t\tskb->csum,\n\t\t\t\tcsum_partial_copy_nocheck(rfv->c + offset,\n\t\t\t\t\t\t\t  to, copy, 0),\n\t\t\t\todd);\n\n\t\todd = 0;\n\t\toffset += copy;\n\t\tto += copy;\n\t\tlen -= copy;\n\n\t\tif (!len)\n\t\t\treturn 0;\n\t}\n\n\toffset -= rfv->hlen;\n\n\treturn ip_generic_getfrag(rfv->msg, to, offset, len, odd, skb);\n}\n\nstatic int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct raw6_frag_vec rfv;\n\tstruct flowi6 fl6;\n\tint addr_len = msg->msg_namelen;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tu16 proto;\n\tint err;\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t */\n\tif (len > INT_MAX)\n\t\treturn -EMSGSIZE;\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (sin6) {\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\treturn -EINVAL;\n\n\t\tif (sin6->sin6_family && sin6->sin6_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\t/* port is the proto value [0..255] carried in nexthdr */\n\t\tproto = ntohs(sin6->sin6_port);\n\n\t\tif (!proto)\n\t\t\tproto = inet->inet_num;\n\t\telse if (proto != inet->inet_num)\n\t\t\treturn -EINVAL;\n\n\t\tif (proto > 255)\n\t\t\treturn -EINVAL;\n\n\t\tdaddr = &sin6->sin6_addr;\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (!flowlabel)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))\n\t\t\tfl6.flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tproto = inet->inet_num;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (fl6.flowi6_oif == 0)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(struct ipv6_txoptions);\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,\n\t\t\t\t\t    &hlimit, &tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\tif (!opt)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = proto;\n\trfv.msg = msg;\n\trfv.hlen = 0;\n\terr = rawv6_probe_proto_opt(&rfv, &fl6);\n\tif (err)\n\t\tgoto out;\n\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tif (inet->hdrincl)\n\t\tfl6.flowi6_flags |= FLOWI_FLAG_KNOWN_NH;\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\tif (hlimit < 0)\n\t\thlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\n\nback_from_confirm:\n\tif (inet->hdrincl)\n\t\terr = rawv6_send_hdrinc(sk, msg, len, &fl6, &dst, msg->msg_flags);\n\telse {\n\t\tlock_sock(sk);\n\t\terr = ip6_append_data(sk, raw6_getfrag, &rfv,\n\t\t\tlen, 0, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst,\n\t\t\tmsg->msg_flags, dontfrag);\n\n\t\tif (err)\n\t\t\tip6_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE))\n\t\t\terr = rawv6_push_pending_frames(sk, &fl6, rp);\n\t\trelease_sock(sk);\n\t}\ndone:\n\tdst_release(dst);\nout:\n\tfl6_sock_release(flowlabel);\n\treturn err < 0 ? err : len;\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic int rawv6_seticmpfilter(struct sock *sk, int level, int optname,\n\t\t\t       char __user *optval, int optlen)\n{\n\tswitch (optname) {\n\tcase ICMPV6_FILTER:\n\t\tif (optlen > sizeof(struct icmp6_filter))\n\t\t\toptlen = sizeof(struct icmp6_filter);\n\t\tif (copy_from_user(&raw6_sk(sk)->filter, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\treturn 0;\n}\n\nstatic int rawv6_geticmpfilter(struct sock *sk, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tint len;\n\n\tswitch (optname) {\n\tcase ICMPV6_FILTER:\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(struct icmp6_filter))\n\t\t\tlen = sizeof(struct icmp6_filter);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &raw6_sk(sk)->filter, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int do_rawv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tint val;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase IPV6_CHECKSUM:\n\t\tif (inet_sk(sk)->inet_num == IPPROTO_ICMPV6 &&\n\t\t    level == IPPROTO_IPV6) {\n\t\t\t/*\n\t\t\t * RFC3542 tells that IPV6_CHECKSUM socket\n\t\t\t * option in the IPPROTO_IPV6 level is not\n\t\t\t * allowed on ICMPv6 sockets.\n\t\t\t * If you want to set it, use IPPROTO_RAW\n\t\t\t * level IPV6_CHECKSUM socket option\n\t\t\t * (Linux extension).\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* You may get strange result with a positive odd offset;\n\t\t   RFC2292bis agrees with me. */\n\t\tif (val > 0 && (val&1))\n\t\t\treturn -EINVAL;\n\t\tif (val < 0) {\n\t\t\trp->checksum = 0;\n\t\t} else {\n\t\t\trp->checksum = 1;\n\t\t\trp->offset = val;\n\t\t}\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int rawv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_seticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM)\n\t\t\tbreak;\n\tdefault:\n\t\treturn ipv6_setsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\treturn do_rawv6_setsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_rawv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_seticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM)\n\t\t\tbreak;\n\tdefault:\n\t\treturn compat_ipv6_setsockopt(sk, level, optname,\n\t\t\t\t\t      optval, optlen);\n\t}\n\treturn do_rawv6_setsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int do_rawv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tint val, len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase IPV6_CHECKSUM:\n\t\t/*\n\t\t * We allow getsockopt() for IPPROTO_IPV6-level\n\t\t * IPV6_CHECKSUM socket option on ICMPv6 sockets\n\t\t * since RFC3542 is silent about it.\n\t\t */\n\t\tif (rp->checksum == 0)\n\t\t\tval = -1;\n\t\telse\n\t\t\tval = rp->offset;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, sizeof(int), len);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int rawv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_geticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM)\n\t\t\tbreak;\n\tdefault:\n\t\treturn ipv6_getsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\treturn do_rawv6_getsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_rawv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_geticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM)\n\t\t\tbreak;\n\tdefault:\n\t\treturn compat_ipv6_getsockopt(sk, level, optname,\n\t\t\t\t\t      optval, optlen);\n\t}\n\treturn do_rawv6_getsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int rawv6_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ: {\n\t\tint amount = sk_wmem_alloc_get(sk);\n\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb_tail_pointer(skb) -\n\t\t\t\tskb_transport_header(skb);\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\n\tdefault:\n#ifdef CONFIG_IPV6_MROUTE\n\t\treturn ip6mr_ioctl(sk, cmd, (void __user *)arg);\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_rawv6_ioctl(struct sock *sk, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\tcase SIOCINQ:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n#ifdef CONFIG_IPV6_MROUTE\n\t\treturn ip6mr_compat_ioctl(sk, cmd, compat_ptr(arg));\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n#endif\n\nstatic void rawv6_close(struct sock *sk, long timeout)\n{\n\tif (inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\tip6_ra_control(sk, -1);\n\tip6mr_sk_done(sk);\n\tsk_common_release(sk);\n}\n\nstatic void raw6_destroy(struct sock *sk)\n{\n\tlock_sock(sk);\n\tip6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tinet6_destroy_sock(sk);\n}\n\nstatic int rawv6_init_sk(struct sock *sk)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\n\tswitch (inet_sk(sk)->inet_num) {\n\tcase IPPROTO_ICMPV6:\n\t\trp->checksum = 1;\n\t\trp->offset   = 2;\n\t\tbreak;\n\tcase IPPROTO_MH:\n\t\trp->checksum = 1;\n\t\trp->offset   = 4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstruct proto rawv6_prot = {\n\t.name\t\t   = \"RAWv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = rawv6_close,\n\t.destroy\t   = raw6_destroy,\n\t.connect\t   = ip6_datagram_connect_v6_only,\n\t.disconnect\t   = udp_disconnect,\n\t.ioctl\t\t   = rawv6_ioctl,\n\t.init\t\t   = rawv6_init_sk,\n\t.setsockopt\t   = rawv6_setsockopt,\n\t.getsockopt\t   = rawv6_getsockopt,\n\t.sendmsg\t   = rawv6_sendmsg,\n\t.recvmsg\t   = rawv6_recvmsg,\n\t.bind\t\t   = rawv6_bind,\n\t.backlog_rcv\t   = rawv6_rcv_skb,\n\t.hash\t\t   = raw_hash_sk,\n\t.unhash\t\t   = raw_unhash_sk,\n\t.obj_size\t   = sizeof(struct raw6_sock),\n\t.h.raw_hash\t   = &raw_v6_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_rawv6_setsockopt,\n\t.compat_getsockopt = compat_rawv6_getsockopt,\n\t.compat_ioctl\t   = compat_rawv6_ioctl,\n#endif\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int raw6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\n\t} else {\n\t\tstruct sock *sp = v;\n\t\t__u16 srcp  = inet_sk(sp)->inet_num;\n\t\tip6_dgram_sock_seq_show(seq, v, srcp, 0,\n\t\t\t\t\traw_seq_private(seq)->bucket);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations raw6_seq_ops = {\n\t.start =\traw_seq_start,\n\t.next =\t\traw_seq_next,\n\t.stop =\t\traw_seq_stop,\n\t.show =\t\traw6_seq_show,\n};\n\nstatic int raw6_seq_open(struct inode *inode, struct file *file)\n{\n\treturn raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);\n}\n\nstatic const struct file_operations raw6_seq_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\traw6_seq_open,\n\t.read =\t\tseq_read,\n\t.llseek =\tseq_lseek,\n\t.release =\tseq_release_net,\n};\n\nstatic int __net_init raw6_init_net(struct net *net)\n{\n\tif (!proc_create(\"raw6\", S_IRUGO, net->proc_net, &raw6_seq_fops))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit raw6_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"raw6\", net->proc_net);\n}\n\nstatic struct pernet_operations raw6_net_ops = {\n\t.init = raw6_init_net,\n\t.exit = raw6_exit_net,\n};\n\nint __init raw6_proc_init(void)\n{\n\treturn register_pernet_subsys(&raw6_net_ops);\n}\n\nvoid raw6_proc_exit(void)\n{\n\tunregister_pernet_subsys(&raw6_net_ops);\n}\n#endif\t/* CONFIG_PROC_FS */\n\n/* Same as inet6_dgram_ops, sans udp_poll.  */\nstatic const struct proto_ops inet6_sockraw_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\t/* ok\t\t*/\n\t.socketpair\t   = sock_no_socketpair,\t/* a do nothing\t*/\n\t.accept\t\t   = sock_no_accept,\t\t/* a do nothing\t*/\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = datagram_poll,\t\t/* ok\t\t*/\n\t.ioctl\t\t   = inet6_ioctl,\t\t/* must change  */\n\t.listen\t\t   = sock_no_listen,\t\t/* ok\t\t*/\n\t.shutdown\t   = inet_shutdown,\t\t/* ok\t\t*/\n\t.setsockopt\t   = sock_common_setsockopt,\t/* ok\t\t*/\n\t.getsockopt\t   = sock_common_getsockopt,\t/* ok\t\t*/\n\t.sendmsg\t   = inet_sendmsg,\t\t/* ok\t\t*/\n\t.recvmsg\t   = sock_common_recvmsg,\t/* ok\t\t*/\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw rawv6_protosw = {\n\t.type\t\t= SOCK_RAW,\n\t.protocol\t= IPPROTO_IP,\t/* wild card */\n\t.prot\t\t= &rawv6_prot,\n\t.ops\t\t= &inet6_sockraw_ops,\n\t.flags\t\t= INET_PROTOSW_REUSE,\n};\n\nint __init rawv6_init(void)\n{\n\treturn inet6_register_protosw(&rawv6_protosw);\n}\n\nvoid rawv6_exit(void)\n{\n\tinet6_unregister_protosw(&rawv6_protosw);\n}\n", "/*\n *  IPv6 Syncookies implementation for the Linux kernel\n *\n *  Authors:\n *  Glenn Griffin\t<ggriffin.kernel@gmail.com>\n *\n *  Based on IPv4 implementation by Andi Kleen\n *  linux/net/ipv4/syncookies.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n */\n\n#include <linux/tcp.h>\n#include <linux/random.h>\n#include <linux/cryptohash.h>\n#include <linux/kernel.h>\n#include <net/ipv6.h>\n#include <net/tcp.h>\n\n#define COOKIEBITS 24\t/* Upper bits store count */\n#define COOKIEMASK (((__u32)1 << COOKIEBITS) - 1)\n\nstatic u32 syncookie6_secret[2][16-4+SHA_DIGEST_WORDS] __read_mostly;\n\n/* RFC 2460, Section 8.3:\n * [ipv6 tcp] MSS must be computed as the maximum packet size minus 60 [..]\n *\n * Due to IPV6_MIN_MTU=1280 the lowest possible MSS is 1220, which allows\n * using higher values than ipv4 tcp syncookies.\n * The other values are chosen based on ethernet (1500 and 9k MTU), plus\n * one that accounts for common encap (PPPoe) overhead. Table must be sorted.\n */\nstatic __u16 const msstab[] = {\n\t1280 - 60, /* IPV6_MIN_MTU - 60 */\n\t1480 - 60,\n\t1500 - 60,\n\t9000 - 60,\n};\n\nstatic DEFINE_PER_CPU(__u32 [16 + 5 + SHA_WORKSPACE_WORDS],\n\t\t      ipv6_cookie_scratch);\n\nstatic u32 cookie_hash(const struct in6_addr *saddr, const struct in6_addr *daddr,\n\t\t       __be16 sport, __be16 dport, u32 count, int c)\n{\n\t__u32 *tmp;\n\n\tnet_get_random_once(syncookie6_secret, sizeof(syncookie6_secret));\n\n\ttmp  = this_cpu_ptr(ipv6_cookie_scratch);\n\n\t/*\n\t * we have 320 bits of information to hash, copy in the remaining\n\t * 192 bits required for sha_transform, from the syncookie6_secret\n\t * and overwrite the digest with the secret\n\t */\n\tmemcpy(tmp + 10, syncookie6_secret[c], 44);\n\tmemcpy(tmp, saddr, 16);\n\tmemcpy(tmp + 4, daddr, 16);\n\ttmp[8] = ((__force u32)sport << 16) + (__force u32)dport;\n\ttmp[9] = count;\n\tsha_transform(tmp + 16, (__u8 *)tmp, tmp + 16 + 5);\n\n\treturn tmp[17];\n}\n\nstatic __u32 secure_tcp_syn_cookie(const struct in6_addr *saddr,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   __be16 sport, __be16 dport, __u32 sseq,\n\t\t\t\t   __u32 data)\n{\n\tu32 count = tcp_cookie_time();\n\treturn (cookie_hash(saddr, daddr, sport, dport, 0, 0) +\n\t\tsseq + (count << COOKIEBITS) +\n\t\t((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)\n\t\t& COOKIEMASK));\n}\n\nstatic __u32 check_tcp_syn_cookie(__u32 cookie, const struct in6_addr *saddr,\n\t\t\t\t  const struct in6_addr *daddr, __be16 sport,\n\t\t\t\t  __be16 dport, __u32 sseq)\n{\n\t__u32 diff, count = tcp_cookie_time();\n\n\tcookie -= cookie_hash(saddr, daddr, sport, dport, 0, 0) + sseq;\n\n\tdiff = (count - (cookie >> COOKIEBITS)) & ((__u32) -1 >> COOKIEBITS);\n\tif (diff >= MAX_SYNCOOKIE_AGE)\n\t\treturn (__u32)-1;\n\n\treturn (cookie -\n\t\tcookie_hash(saddr, daddr, sport, dport, count - diff, 1))\n\t\t& COOKIEMASK;\n}\n\nu32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,\n\t\t\t      const struct tcphdr *th, __u16 *mssp)\n{\n\tint mssind;\n\tconst __u16 mss = *mssp;\n\n\tfor (mssind = ARRAY_SIZE(msstab) - 1; mssind ; mssind--)\n\t\tif (mss >= msstab[mssind])\n\t\t\tbreak;\n\n\t*mssp = msstab[mssind];\n\n\treturn secure_tcp_syn_cookie(&iph->saddr, &iph->daddr, th->source,\n\t\t\t\t     th->dest, ntohl(th->seq), mssind);\n}\nEXPORT_SYMBOL_GPL(__cookie_v6_init_sequence);\n\n__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mssp)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\treturn __cookie_v6_init_sequence(iph, th, mssp);\n}\n\nint __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,\n\t\t      __u32 cookie)\n{\n\t__u32 seq = ntohl(th->seq) - 1;\n\t__u32 mssind = check_tcp_syn_cookie(cookie, &iph->saddr, &iph->daddr,\n\t\t\t\t\t    th->source, th->dest, seq);\n\n\treturn mssind < ARRAY_SIZE(msstab) ? msstab[mssind] : 0;\n}\nEXPORT_SYMBOL_GPL(__cookie_v6_check);\n\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct dst_entry *dst;\n\t__u8 rcv_wscale;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v6_check(ipv6_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, 0, NULL);\n\n\tif (!cookie_timestamp_decode(&tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp6_request_sock_ops, sk, false);\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->tfo_listener = false;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto out_free;\n\n\treq->mss = mss;\n\tireq->ir_rmt_port = th->source;\n\tireq->ir_num = ntohs(th->dest);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tif (ipv6_opt_accepted(sk, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\n\treq->num_retrans = 0;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\ttreq->snt_synack.v64\t= 0;\n\ttreq->rcv_isn = ntohl(th->seq) - 1;\n\ttreq->snt_isn = cookie;\n\n\t/*\n\t * We need to lookup the dst_entry to get the correct window size.\n\t * This is taken from tcp_v6_syn_recv_sock.  Somebody please enlighten\n\t * me if there is a preferred way.\n\t */\n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\t\tfl6.saddr = ireq->ir_v6_loc_addr;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;\n\t\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out_free;\n\t}\n\n\treq->rsk_window_clamp = tp->window_clamp ? :dst_metric(dst, RTAX_WINDOW);\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rsk_rcv_wnd, &req->rsk_window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale = rcv_wscale;\n\tireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), dst);\n\n\tret = tcp_get_cookie_sock(sk, skb, req, dst);\nout:\n\treturn ret;\nout_free:\n\treqsk_free(req);\n\treturn NULL;\n}\n", "/*\n *\tTCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on:\n *\tlinux/net/ipv4/tcp.c\n *\tlinux/net/ipv4/tcp_input.c\n *\tlinux/net/ipv4/tcp_output.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *\tYOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/tcp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/bottom_half.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/jiffies.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/ipsec.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n\n#include <net/tcp.h>\n#include <net/ndisc.h>\n#include <net/inet6_hashtables.h>\n#include <net/inet6_connection_sock.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/inet_ecn.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/snmp.h>\n#include <net/dsfield.h>\n#include <net/timewait_sock.h>\n#include <net/inet_common.h>\n#include <net/secure_seq.h>\n#include <net/tcp_memcontrol.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n\nstatic void\ttcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb);\nstatic void\ttcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      struct request_sock *req);\n\nstatic int\ttcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb);\n\nstatic const struct inet_connection_sock_af_ops ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops ipv6_specific;\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific;\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific;\n#else\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn NULL;\n}\n#endif\n\nstatic void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst) {\n\t\tconst struct rt6_info *rt = (const struct rt6_info *)dst;\n\n\t\tdst_hold(dst);\n\t\tsk->sk_rx_dst = dst;\n\t\tinet_sk(sk)->rx_dst_ifindex = skb->skb_iif;\n\t\tinet6_sk(sk)->rx_dst_cookie = rt6_get_cookie(rt);\n\t}\n}\n\nstatic __u32 tcp_v6_init_sequence(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t    ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t    tcp_hdr(skb)->dest,\n\t\t\t\t\t    tcp_hdr(skb)->source);\n}\n\nstatic int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t  int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\n\t/*\n\t *\tconnect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 0x1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type&IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp->rx_opt.ts_recent_stamp &&\n\t    !ipv6_addr_equal(&sk->sk_v6_daddr, &usin->sin6_addr)) {\n\t\ttp->rx_opt.ts_recent = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq = 0;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t *\tTCP over IPv4\n\t */\n\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &ipv6_mapped;\n\t\tsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\ttp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\terr = tcp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &ipv6_specific;\n\t\t\tsk->sk_backlog_rcv = tcp_v6_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\ttp->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (!saddr) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(sk, dst, NULL, NULL);\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp &&\n\t    ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr))\n\t\ttcp_fetch_timewait_stamp(sk, dst);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (np->opt)\n\t\ticsk->icsk_ext_hdr_len = (np->opt->opt_flen +\n\t\t\t\t\t  np->opt->opt_nflen);\n\n\ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n\n\tinet->inet_dport = usin->sin6_port;\n\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet6_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tsk_set_txhash(sk);\n\n\tif (!tp->write_seq && likely(!tp->repair))\n\t\ttp->write_seq = secure_tcpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t\t     sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t\t     inet->inet_sport,\n\t\t\t\t\t\t\t     inet->inet_dport);\n\n\terr = tcp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\ttcp_set_state(sk, TCP_CLOSE);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic void tcp_v6_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE))\n\t\treturn;\n\n\tdst = inet6_csk_update_pmtu(sk, tcp_sk(sk)->mtu_info);\n\tif (!dst)\n\t\treturn;\n\n\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst)) {\n\t\ttcp_sync_mss(sk, dst_mtu(dst));\n\t\ttcp_simple_retransmit(sk);\n\t}\n}\n\nstatic void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, &tcp_hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex);\n\n\tif (!sk) {\n\t\tICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\n\t\t\t\t   ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (ipv6_hdr(skb)->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\tif (dst)\n\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t * they should go through unfragmented).\n\t\t */\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\ttp->mtu_info = ntohl(info);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &tp->tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\ticmpv6_err_convert(type, code, &err);\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\t\t\tsk->sk_error_report(sk);\t\t/* Wake people up to see the error (see connect in sock.c) */\n\n\t\t\ttcp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}\n\n\nstatic void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn tcp_md5_do_lookup(sk, (union tcp_md5_addr *)addr, AF_INET6);\n}\n\nstatic struct tcp_md5sig_key *tcp_v6_md5_lookup(const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk)\n{\n\treturn tcp_v6_md5_do_lookup(sk, &addr_sk->sk_v6_daddr);\n}\n\nstatic int tcp_v6_parse_md5_keys(struct sock *sk, char __user *optval,\n\t\t\t\t int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&cmd.tcpm_addr;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tif (!cmd.tcpm_keylen) {\n\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t\t      AF_INET);\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t\t      AF_INET6);\n\t}\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t      AF_INET, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t      AF_INET6, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n}\n\nstatic int tcp_v6_md5_hash_pseudoheader(struct tcp_md5sig_pool *hp,\n\t\t\t\t\tconst struct in6_addr *daddr,\n\t\t\t\t\tconst struct in6_addr *saddr, int nbytes)\n{\n\tstruct tcp6_pseudohdr *bp;\n\tstruct scatterlist sg;\n\n\tbp = &hp->md5_blk.ip6;\n\t/* 1. TCP pseudo-header (RFC2460) */\n\tbp->saddr = *saddr;\n\tbp->daddr = *daddr;\n\tbp->protocol = cpu_to_be32(IPPROTO_TCP);\n\tbp->len = cpu_to_be32(nbytes);\n\n\tsg_init_one(&sg, bp, sizeof(*bp));\n\treturn crypto_hash_update(&hp->md5_desc, &sg, sizeof(*bp));\n}\n\nstatic int tcp_v6_md5_hash_hdr(char *md5_hash, struct tcp_md5sig_key *key,\n\t\t\t       const struct in6_addr *daddr, struct in6_addr *saddr,\n\t\t\t       const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct hash_desc *desc;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\tdesc = &hp->md5_desc;\n\n\tif (crypto_hash_init(desc))\n\t\tgoto clear_hash;\n\tif (tcp_v6_md5_hash_pseudoheader(hp, daddr, saddr, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_header(hp, th))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tif (crypto_hash_final(desc, md5_hash))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nstatic int tcp_v6_md5_hash_skb(char *md5_hash,\n\t\t\t       const struct tcp_md5sig_key *key,\n\t\t\t       const struct sock *sk,\n\t\t\t       const struct sk_buff *skb)\n{\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct tcp_md5sig_pool *hp;\n\tstruct hash_desc *desc;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (sk) { /* valid for establish/request sockets */\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else {\n\t\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\tdesc = &hp->md5_desc;\n\n\tif (crypto_hash_init(desc))\n\t\tgoto clear_hash;\n\n\tif (tcp_v6_md5_hash_pseudoheader(hp, daddr, saddr, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_header(hp, th))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tif (crypto_hash_final(desc, md5_hash))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\n#endif\n\nstatic bool tcp_v6_inbound_md5_hash(const struct sock *sk,\n\t\t\t\t    const struct sk_buff *skb)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct tcp_md5sig_key *hash_expected;\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint genhash;\n\tu8 newhash[16];\n\n\thash_expected = tcp_v6_md5_do_lookup(sk, &ip6h->saddr);\n\thash_location = tcp_parse_md5sig_option(th);\n\n\t/* We've parsed the options - do we have a hash? */\n\tif (!hash_expected && !hash_location)\n\t\treturn false;\n\n\tif (hash_expected && !hash_location) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);\n\t\treturn true;\n\t}\n\n\tif (!hash_expected && hash_location) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);\n\t\treturn true;\n\t}\n\n\t/* check the signature */\n\tgenhash = tcp_v6_md5_hash_skb(newhash,\n\t\t\t\t      hash_expected,\n\t\t\t\t      NULL, skb);\n\n\tif (genhash || memcmp(hash_location, newhash, 16) != 0) {\n\t\tnet_info_ratelimited(\"MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t\t     genhash ? \"failed\" : \"mismatch\",\n\t\t\t\t     &ip6h->saddr, ntohs(th->source),\n\t\t\t\t     &ip6h->daddr, ntohs(th->dest));\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic void tcp_v6_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk_listener);\n\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\t/* So that link locals have meaning */\n\tif (!sk_listener->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tif (!TCP_SKB_CB(skb)->tcp_tw_isn &&\n\t    (ipv6_opt_accepted(sk_listener, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t     np->rxopt.bits.rxinfo ||\n\t     np->rxopt.bits.rxoinfo || np->rxopt.bits.rxhlim ||\n\t     np->rxopt.bits.rxohlim || np->repflow)) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n}\n\nstatic struct dst_entry *tcp_v6_route_req(const struct sock *sk,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  const struct request_sock *req,\n\t\t\t\t\t  bool *strict)\n{\n\tif (strict)\n\t\t*strict = true;\n\treturn inet6_csk_route_req(sk, &fl->u.ip6, req, IPPROTO_TCP);\n}\n\nstruct request_sock_ops tcp6_request_sock_ops __read_mostly = {\n\t.family\t\t=\tAF_INET6,\n\t.obj_size\t=\tsizeof(struct tcp6_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v6_reqsk_send_ack,\n\t.destructor\t=\ttcp_v6_reqsk_destructor,\n\t.send_reset\t=\ttcp_v6_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nstatic const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {\n\t.mss_clamp\t=\tIPV6_MIN_MTU - sizeof(struct tcphdr) -\n\t\t\t\tsizeof(struct ipv6hdr),\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n#endif\n\t.init_req\t=\ttcp_v6_init_req,\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v6_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v6_route_req,\n\t.init_seq\t=\ttcp_v6_init_sequence,\n\t.send_synack\t=\ttcp_v6_send_synack,\n};\n\nstatic void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t\t u32 ack, u32 win, u32 tsval, u32 tsecr,\n\t\t\t\t int oif, struct tcp_md5sig_key *key, int rst,\n\t\t\t\t u8 tclass, u32 label)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct tcphdr *t1;\n\tstruct sk_buff *buff;\n\tstruct flowi6 fl6;\n\tstruct net *net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n\tstruct sock *ctl_sk = net->ipv6.tcp_sk;\n\tunsigned int tot_len = sizeof(struct tcphdr);\n\tstruct dst_entry *dst;\n\t__be32 *topt;\n\n\tif (tsecr)\n\t\ttot_len += TCPOLEN_TSTAMP_ALIGNED;\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key)\n\t\ttot_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n\tbuff = alloc_skb(MAX_HEADER + sizeof(struct ipv6hdr) + tot_len,\n\t\t\t GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\tskb_reserve(buff, MAX_HEADER + sizeof(struct ipv6hdr) + tot_len);\n\n\tt1 = (struct tcphdr *) skb_push(buff, tot_len);\n\tskb_reset_transport_header(buff);\n\n\t/* Swap the send and the receive. */\n\tmemset(t1, 0, sizeof(*t1));\n\tt1->dest = th->source;\n\tt1->source = th->dest;\n\tt1->doff = tot_len / 4;\n\tt1->seq = htonl(seq);\n\tt1->ack_seq = htonl(ack);\n\tt1->ack = !rst || !th->ack;\n\tt1->rst = rst;\n\tt1->window = htons(win);\n\n\ttopt = (__be32 *)(t1 + 1);\n\n\tif (tsecr) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);\n\t\t*topt++ = htonl(tsval);\n\t\t*topt++ = htonl(tsecr);\n\t}\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);\n\t\ttcp_v6_md5_hash_hdr((__u8 *)topt, key,\n\t\t\t\t    &ipv6_hdr(skb)->saddr,\n\t\t\t\t    &ipv6_hdr(skb)->daddr, t1);\n\t}\n#endif\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tfl6.saddr = ipv6_hdr(skb)->daddr;\n\tfl6.flowlabel = label;\n\n\tbuff->ip_summed = CHECKSUM_PARTIAL;\n\tbuff->csum = 0;\n\n\t__tcp_v6_send_check(buff, &fl6.saddr, &fl6.daddr);\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tif (rt6_need_strict(&fl6.daddr) && !oif)\n\t\tfl6.flowi6_oif = tcp_v6_iif(skb);\n\telse\n\t\tfl6.flowi6_oif = oif;\n\tfl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark);\n\tfl6.fl6_dport = t1->dest;\n\tfl6.fl6_sport = t1->source;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\t/* Pass a socket to ip6_dst_lookup either it is for RST\n\t * Underlying function will use this to retrieve the network\n\t * namespace\n\t */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(buff, dst);\n\t\tip6_xmit(ctl_sk, buff, &fl6, NULL, tclass);\n\t\tTCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);\n\t\tif (rst)\n\t\t\tTCP_INC_STATS_BH(net, TCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(buff);\n}\n\nstatic void tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = 0, ack_seq = 0;\n\tstruct tcp_md5sig_key *key = NULL;\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\tint oif;\n\n\tif (th->rst)\n\t\treturn;\n\n\t/* If sk not NULL, it means we did a successful lookup and incoming\n\t * route had to be correct. prequeue might have dropped our dst.\n\t */\n\tif (!sk && !ipv6_unicast_destination(skb))\n\t\treturn;\n\n#ifdef CONFIG_TCP_MD5SIG\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (!sk && hash_location) {\n\t\t/*\n\t\t * active side is lost. Try to find listening socket through\n\t\t * source port, and then find md5 key through listening socket.\n\t\t * we are not loose security here:\n\t\t * Incoming packet is checked with md5 hash with finding key,\n\t\t * no RST generated if md5 hash doesn't match.\n\t\t */\n\t\tsk1 = inet6_lookup_listener(dev_net(skb_dst(skb)->dev),\n\t\t\t\t\t   &tcp_hashinfo, &ipv6h->saddr,\n\t\t\t\t\t   th->source, &ipv6h->daddr,\n\t\t\t\t\t   ntohs(th->source), tcp_v6_iif(skb));\n\t\tif (!sk1)\n\t\t\treturn;\n\n\t\trcu_read_lock();\n\t\tkey = tcp_v6_md5_do_lookup(sk1, &ipv6h->saddr);\n\t\tif (!key)\n\t\t\tgoto release_sk1;\n\n\t\tgenhash = tcp_v6_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto release_sk1;\n\t} else {\n\t\tkey = sk ? tcp_v6_md5_do_lookup(sk, &ipv6h->saddr) : NULL;\n\t}\n#endif\n\n\tif (th->ack)\n\t\tseq = ntohl(th->ack_seq);\n\telse\n\t\tack_seq = ntohl(th->seq) + th->syn + th->fin + skb->len -\n\t\t\t  (th->doff << 2);\n\n\toif = sk ? sk->sk_bound_dev_if : 0;\n\ttcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1, 0, 0);\n\n#ifdef CONFIG_TCP_MD5SIG\nrelease_sk1:\n\tif (sk1) {\n\t\trcu_read_unlock();\n\t\tsock_put(sk1);\n\t}\n#endif\n}\n\nstatic void tcp_v6_send_ack(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t    u32 ack, u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key, u8 tclass,\n\t\t\t    u32 label)\n{\n\ttcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,\n\t\t\t     tclass, label);\n}\n\nstatic void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v6_send_ack(sk, skb, tcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent, tw->tw_bound_dev_if, tcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_tclass, cpu_to_be32(tw->tw_flowlabel));\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\t/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV\n\t * sk->sk_state == TCP_SYN_RECV -> for Fast Open.\n\t */\n\ttcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?\n\t\t\ttcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,\n\t\t\ttcp_rsk(req)->rcv_nxt, req->rsk_rcv_wnd,\n\t\t\ttcp_time_stamp, req->ts_recent, sk->sk_bound_dev_if,\n\t\t\ttcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr),\n\t\t\t0, 0);\n}\n\n\nstatic struct sock *tcp_v6_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v6_check(sk, skb);\n#endif\n\treturn sk;\n}\n\nstatic int tcp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&tcp6_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv6_ops, sk, skb);\n\ndrop:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn 0; /* don't send reset */\n}\n\nstatic struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\tif (np->opt)\n\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_atomic(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_atomic(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n\n/* The socket must have it's spinlock held when we get\n * here, unless it is a TCP_LISTEN socket.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp;\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, tcp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   tcp_v6_hnd_req and tcp_v6_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *\tsocket locking is here for SMP purposes as backlog rcv\n\t *\tis currently called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone(skb, sk_gfp_atomic(sk, GFP_ATOMIC));\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tsock_rps_save_rxhash(nsk, skb);\n\t\t\tsk_mark_napi_id(nsk, skb);\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\ncsum_err:\n\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t/* Do you ask, what is it?\n\n\t   1. skb was enqueued by tcp.\n\t   2. skb is added to tail of read queue, rather than out of order.\n\t   3. socket is not in passive state.\n\t   4. Finally, it really contains options, which user wants to receive.\n\t */\n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tskb_set_owner_r(opt_skb, sk);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}\n\nstatic void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,\n\t\t\t   const struct tcphdr *th)\n{\n\t/* This is tricky: we move IP6CB at its correct location into\n\t * TCP_SKB_CB(). It must be done after xfrm6_policy_check(), because\n\t * _decode_session6() uses IP6CB().\n\t * barrier() makes sure compiler won't play aliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h6, IP6CB(skb),\n\t\tsizeof(struct inet6_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff*4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv6_get_dsfield(hdr);\n\tTCP_SKB_CB(skb)->sacked = 0;\n}\n\nstatic void tcp_v6_restore_cb(struct sk_buff *skb)\n{\n\t/* We need to move header back to the beginning if xfrm6_policy_check()\n\t * and tcp_v6_fill_cb() are going to be called again.\n\t */\n\tmemmove(IP6CB(skb), &TCP_SKB_CB(skb)->header.h6,\n\t\tsizeof(struct inet6_skb_parm));\n}\n\nstatic int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/*\n\t *\tCount it even if it's bad.\n\t */\n\tTCP_INC_STATS_BH(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr)/4)\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = tcp_hdr(skb);\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&tcp_hashinfo, skb, th->source, th->dest,\n\t\t\t\tinet6_iif(skb));\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk = NULL;\n\n\t\tsk = req->rsk_listener;\n\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\tif (tcp_v6_inbound_md5_hash(sk, skb)) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (likely(sk->sk_state == TCP_LISTEN)) {\n\t\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\t} else {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\tsock_hold(sk);\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_it;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_v6_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_sk(sk)->segs_in += max_t(u16, 1, skb_shinfo(skb)->gso_segs);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else if (unlikely(sk_add_backlog(sk, skb,\n\t\t\t\t\t   sk->sk_rcvbuf + sk->sk_sndbuf))) {\n\t\tbh_unlock_sock(sk);\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_TCPBACKLOGDROP);\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\tTCP_INC_STATS_BH(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\tTCP_INC_STATS_BH(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest), tcp_v6_iif(skb));\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_restore_cb(skb);\n\t\tgoto no_tcp_socket;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}\n\nstatic void tcp_v6_early_demux(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *hdr;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\thdr = ipv6_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\t/* Note : We use inet6_iif() here, not tcp_v6_iif() */\n\tsk = __inet6_lookup_established(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t&hdr->saddr, th->source,\n\t\t\t\t\t&hdr->daddr, ntohs(th->dest),\n\t\t\t\t\tinet6_iif(skb));\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = READ_ONCE(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, inet6_sk(sk)->rx_dst_cookie);\n\t\t\tif (dst &&\n\t\t\t    inet_sk(sk)->rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\nstatic struct timewait_sock_ops tcp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp6_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor = tcp_twsk_destructor,\n};\n\nstatic const struct inet_connection_sock_af_ops ipv6_specific = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = tcp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet6_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.net_frag_header_len = sizeof(struct frag_hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v6_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific = {\n\t.md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/*\n *\tTCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific = {\n\t.md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int tcp_v6_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv6_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\n\treturn 0;\n}\n\nstatic void tcp_v6_destroy_sock(struct sock *sk)\n{\n\ttcp_v4_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\n#ifdef CONFIG_PROC_FS\n/* Proc filesystem TCPv6 sock list dumping. */\nstatic void get_openreq6(struct seq_file *seq,\n\t\t\t const struct request_sock *req, int i)\n{\n\tlong ttd = req->rsk_timer.expires - jiffies;\n\tconst struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;\n\tconst struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3],\n\t\t   inet_rsk(req)->ir_num,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3],\n\t\t   ntohs(inet_rsk(req)->ir_rmt_port),\n\t\t   TCP_SYN_RECV,\n\t\t   0, 0, /* could print option size, but that is af dependent. */\n\t\t   1,   /* timers active (only the expire timer) */\n\t\t   jiffies_to_clock_t(ttd),\n\t\t   req->num_timeout,\n\t\t   from_kuid_munged(seq_user_ns(seq),\n\t\t\t\t    sock_i_uid(req->rsk_listener)),\n\t\t   0,  /* non standard timer */\n\t\t   0, /* open_requests have no inode */\n\t\t   0, req);\n}\n\nstatic void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct inet_sock *inet = inet_sk(sp);\n\tconst struct tcp_sock *tp = tcp_sk(sp);\n\tconst struct inet_connection_sock *icsk = inet_csk(sp);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\tint rx_queue;\n\tint state;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sp->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sp->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = sk_state_load(sp);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = sp->sk_ack_backlog;\n\telse\n\t\t/* Because we don't lock the socket,\n\t\t * we might find a transient negative value.\n\t\t */\n\t\trx_queue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %lu %lu %u %u %d\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   state,\n\t\t   tp->write_seq - tp->snd_una,\n\t\t   rx_queue,\n\t\t   timer_active,\n\t\t   jiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\t   icsk->icsk_retransmits,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   icsk->icsk_probes_out,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   jiffies_to_clock_t(icsk->icsk_rto),\n\t\t   jiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t   (icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,\n\t\t   tp->snd_cwnd,\n\t\t   state == TCP_LISTEN ?\n\t\t\tfastopenq->max_qlen :\n\t\t\t(tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh)\n\t\t   );\n}\n\nstatic void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n\nstatic int tcp6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"  sl  \"\n\t\t\t \"local_address                         \"\n\t\t\t \"remote_address                        \"\n\t\t\t \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t \"   uid  timeout inode\\n\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait6_sock(seq, v, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq6(seq, v, st->num);\n\telse\n\t\tget_tcp6_sock(seq, v, st->num);\nout:\n\treturn 0;\n}\n\nstatic const struct file_operations tcp6_afinfo_seq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tcp_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net\n};\n\nstatic struct tcp_seq_afinfo tcp6_seq_afinfo = {\n\t.name\t\t= \"tcp6\",\n\t.family\t\t= AF_INET6,\n\t.seq_fops\t= &tcp6_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= tcp6_seq_show,\n\t},\n};\n\nint __net_init tcp6_proc_init(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp6_seq_afinfo);\n}\n\nvoid tcp6_proc_exit(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp6_seq_afinfo);\n}\n#endif\n\nstatic void tcp_v6_clear_sk(struct sock *sk, int size)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t/* we do not want to clear pinet6 field, because of RCU lookups */\n\tsk_prot_clear_nulls(sk, offsetof(struct inet_sock, pinet6));\n\n\tsize -= offsetof(struct inet_sock, pinet6) + sizeof(inet->pinet6);\n\tmemset(&inet->pinet6 + 1, 0, size);\n}\n\nstruct proto tcpv6_prot = {\n\t.name\t\t\t= \"TCPv6\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.connect\t\t= tcp_v6_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v6_init_sock,\n\t.destroy\t\t= tcp_v6_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.sendpage\t\t= tcp_sendpage,\n\t.backlog_rcv\t\t= tcp_v6_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem\t\t= sysctl_tcp_wmem,\n\t.sysctl_rmem\t\t= sysctl_tcp_rmem,\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp6_sock),\n\t.slab_flags\t\t= SLAB_DESTROY_BY_RCU,\n\t.twsk_prot\t\t= &tcp6_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp6_request_sock_ops,\n\t.h.hashinfo\t\t= &tcp_hashinfo,\n\t.no_autobind\t\t= true,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt\t= compat_tcp_setsockopt,\n\t.compat_getsockopt\t= compat_tcp_getsockopt,\n#endif\n#ifdef CONFIG_MEMCG_KMEM\n\t.proto_cgroup\t\t= tcp_proto_cgroup,\n#endif\n\t.clear_sk\t\t= tcp_v6_clear_sk,\n};\n\nstatic const struct inet6_protocol tcpv6_protocol = {\n\t.early_demux\t=\ttcp_v6_early_demux,\n\t.handler\t=\ttcp_v6_rcv,\n\t.err_handler\t=\ttcp_v6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic struct inet_protosw tcpv6_protosw = {\n\t.type\t\t=\tSOCK_STREAM,\n\t.protocol\t=\tIPPROTO_TCP,\n\t.prot\t\t=\t&tcpv6_prot,\n\t.ops\t\t=\t&inet6_stream_ops,\n\t.flags\t\t=\tINET_PROTOSW_PERMANENT |\n\t\t\t\tINET_PROTOSW_ICSK,\n};\n\nstatic int __net_init tcpv6_net_init(struct net *net)\n{\n\treturn inet_ctl_sock_create(&net->ipv6.tcp_sk, PF_INET6,\n\t\t\t\t    SOCK_RAW, IPPROTO_TCP, net);\n}\n\nstatic void __net_exit tcpv6_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.tcp_sk);\n}\n\nstatic void __net_exit tcpv6_net_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, &tcp_death_row, AF_INET6);\n}\n\nstatic struct pernet_operations tcpv6_net_ops = {\n\t.init\t    = tcpv6_net_init,\n\t.exit\t    = tcpv6_net_exit,\n\t.exit_batch = tcpv6_net_exit_batch,\n};\n\nint __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t/* register inet6 protocol */\n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\nout:\n\treturn ret;\n\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n\nvoid tcpv6_exit(void)\n{\n\tunregister_pernet_subsys(&tcpv6_net_ops);\n\tinet6_unregister_protosw(&tcpv6_protosw);\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n}\n", "/*\n *\tUDP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/ipv4/udp.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *      Kazunori MIYAZAWA @USAGI:       change process style to use ip6_append_data\n *      YOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/udp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/raw.h>\n#include <net/tcp_states.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n#include <net/inet6_hashtables.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <trace/events/skb.h>\n#include \"udp_impl.h\"\n\nstatic u32 udp6_ehashfn(const struct net *net,\n\t\t\tconst struct in6_addr *laddr,\n\t\t\tconst u16 lport,\n\t\t\tconst struct in6_addr *faddr,\n\t\t\tconst __be16 fport)\n{\n\tstatic u32 udp6_ehash_secret __read_mostly;\n\tstatic u32 udp_ipv6_hash_secret __read_mostly;\n\n\tu32 lhash, fhash;\n\n\tnet_get_random_once(&udp6_ehash_secret,\n\t\t\t    sizeof(udp6_ehash_secret));\n\tnet_get_random_once(&udp_ipv6_hash_secret,\n\t\t\t    sizeof(udp_ipv6_hash_secret));\n\n\tlhash = (__force u32)laddr->s6_addr32[3];\n\tfhash = __ipv6_addr_jhash(faddr, udp_ipv6_hash_secret);\n\n\treturn __inet6_ehashfn(lhash, lport, fhash, fport,\n\t\t\t       udp_ipv6_hash_secret + net_hash_mix(net));\n}\n\nint ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)\n{\n\tconst struct in6_addr *sk2_rcv_saddr6 = inet6_rcv_saddr(sk2);\n\tint sk2_ipv6only = inet_v6_ipv6only(sk2);\n\tint addr_type = ipv6_addr_type(&sk->sk_v6_rcv_saddr);\n\tint addr_type2 = sk2_rcv_saddr6 ? ipv6_addr_type(sk2_rcv_saddr6) : IPV6_ADDR_MAPPED;\n\n\t/* if both are mapped, treat as IPv4 */\n\tif (addr_type == IPV6_ADDR_MAPPED && addr_type2 == IPV6_ADDR_MAPPED)\n\t\treturn (!sk2_ipv6only &&\n\t\t\t(!sk->sk_rcv_saddr || !sk2->sk_rcv_saddr ||\n\t\t\t  sk->sk_rcv_saddr == sk2->sk_rcv_saddr));\n\n\tif (addr_type2 == IPV6_ADDR_ANY &&\n\t    !(sk2_ipv6only && addr_type == IPV6_ADDR_MAPPED))\n\t\treturn 1;\n\n\tif (addr_type == IPV6_ADDR_ANY &&\n\t    !(ipv6_only_sock(sk) && addr_type2 == IPV6_ADDR_MAPPED))\n\t\treturn 1;\n\n\tif (sk2_rcv_saddr6 &&\n\t    ipv6_addr_equal(&sk->sk_v6_rcv_saddr, sk2_rcv_saddr6))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic u32 udp6_portaddr_hash(const struct net *net,\n\t\t\t      const struct in6_addr *addr6,\n\t\t\t      unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\n\treturn hash ^ port;\n}\n\nint udp_v6_get_port(struct sock *sk, unsigned short snum)\n{\n\tunsigned int hash2_nulladdr =\n\t\tudp6_portaddr_hash(sock_net(sk), &in6addr_any, snum);\n\tunsigned int hash2_partial =\n\t\tudp6_portaddr_hash(sock_net(sk), &sk->sk_v6_rcv_saddr, 0);\n\n\t/* precompute partial secondary hash */\n\tudp_sk(sk)->udp_portaddr_hash = hash2_partial;\n\treturn udp_lib_get_port(sk, snum, ipv6_rcv_saddr_equal, hash2_nulladdr);\n}\n\nstatic void udp_v6_rehash(struct sock *sk)\n{\n\tu16 new_hash = udp6_portaddr_hash(sock_net(sk),\n\t\t\t\t\t  &sk->sk_v6_rcv_saddr,\n\t\t\t\t\t  inet_sk(sk)->inet_num);\n\n\tudp_lib_rehash(sk, new_hash);\n}\n\nstatic inline int compute_score(struct sock *sk, struct net *net,\n\t\t\t\tunsigned short hnum,\n\t\t\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\t\t\tconst struct in6_addr *daddr, __be16 dport,\n\t\t\t\tint dif)\n{\n\tint score;\n\tstruct inet_sock *inet;\n\n\tif (!net_eq(sock_net(sk), net) ||\n\t    udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6)\n\t\treturn -1;\n\n\tscore = 0;\n\tinet = inet_sk(sk);\n\n\tif (inet->inet_dport) {\n\t\tif (inet->inet_dport != sport)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_daddr, saddr))\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_bound_dev_if) {\n\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_incoming_cpu == raw_smp_processor_id())\n\t\tscore++;\n\n\treturn score;\n}\n\nstatic inline int compute_score2(struct sock *sk, struct net *net,\n\t\t\t\t const struct in6_addr *saddr, __be16 sport,\n\t\t\t\t const struct in6_addr *daddr,\n\t\t\t\t unsigned short hnum, int dif)\n{\n\tint score;\n\tstruct inet_sock *inet;\n\n\tif (!net_eq(sock_net(sk), net) ||\n\t    udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6)\n\t\treturn -1;\n\n\tif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\n\t\treturn -1;\n\n\tscore = 0;\n\tinet = inet_sk(sk);\n\n\tif (inet->inet_dport) {\n\t\tif (inet->inet_dport != sport)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_daddr, saddr))\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_bound_dev_if) {\n\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_incoming_cpu == raw_smp_processor_id())\n\t\tscore++;\n\n\treturn score;\n}\n\n/* called with read_rcu_lock() */\nstatic struct sock *udp6_lib_lookup2(struct net *net,\n\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\tconst struct in6_addr *daddr, unsigned int hnum, int dif,\n\t\tstruct udp_hslot *hslot2, unsigned int slot2)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tint score, badness, matches = 0, reuseport = 0;\n\tu32 hash = 0;\n\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tudp_portaddr_for_each_entry_rcu(sk, node, &hslot2->head) {\n\t\tscore = compute_score2(sk, net, saddr, sport,\n\t\t\t\t      daddr, hnum, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t\treuseport = sk->sk_reuseport;\n\t\t\tif (reuseport) {\n\t\t\t\thash = udp6_ehashfn(net, daddr, hnum,\n\t\t\t\t\t\t    saddr, sport);\n\t\t\t\tmatches = 1;\n\t\t\t}\n\t\t} else if (score == badness && reuseport) {\n\t\t\tmatches++;\n\t\t\tif (reciprocal_scale(hash, matches) == 0)\n\t\t\t\tresult = sk;\n\t\t\thash = next_pseudo_random32(hash);\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot2)\n\t\tgoto begin;\n\n\tif (result) {\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score2(result, net, saddr, sport,\n\t\t\t\t  daddr, hnum, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\treturn result;\n}\n\nstruct sock *__udp6_lib_lookup(struct net *net,\n\t\t\t\t      const struct in6_addr *saddr, __be16 sport,\n\t\t\t\t      const struct in6_addr *daddr, __be16 dport,\n\t\t\t\t      int dif, struct udp_table *udptable)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(dport);\n\tunsigned int hash2, slot2, slot = udp_hashfn(net, hnum, udptable->mask);\n\tstruct udp_hslot *hslot2, *hslot = &udptable->hash[slot];\n\tint score, badness, matches = 0, reuseport = 0;\n\tu32 hash = 0;\n\n\trcu_read_lock();\n\tif (hslot->count > 10) {\n\t\thash2 = udp6_portaddr_hash(net, daddr, hnum);\n\t\tslot2 = hash2 & udptable->mask;\n\t\thslot2 = &udptable->hash2[slot2];\n\t\tif (hslot->count < hslot2->count)\n\t\t\tgoto begin;\n\n\t\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t\t  daddr, hnum, dif,\n\t\t\t\t\t  hslot2, slot2);\n\t\tif (!result) {\n\t\t\thash2 = udp6_portaddr_hash(net, &in6addr_any, hnum);\n\t\t\tslot2 = hash2 & udptable->mask;\n\t\t\thslot2 = &udptable->hash2[slot2];\n\t\t\tif (hslot->count < hslot2->count)\n\t\t\t\tgoto begin;\n\n\t\t\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t\t\t  &in6addr_any, hnum, dif,\n\t\t\t\t\t\t  hslot2, slot2);\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn result;\n\t}\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tscore = compute_score(sk, net, hnum, saddr, sport, daddr, dport, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t\treuseport = sk->sk_reuseport;\n\t\t\tif (reuseport) {\n\t\t\t\thash = udp6_ehashfn(net, daddr, hnum,\n\t\t\t\t\t\t    saddr, sport);\n\t\t\t\tmatches = 1;\n\t\t\t}\n\t\t} else if (score == badness && reuseport) {\n\t\t\tmatches++;\n\t\t\tif (reciprocal_scale(hash, matches) == 0)\n\t\t\t\tresult = sk;\n\t\t\thash = next_pseudo_random32(hash);\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\n\tif (result) {\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score(result, net, hnum, saddr, sport,\n\t\t\t\t\tdaddr, dport, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(__udp6_lib_lookup);\n\nstatic struct sock *__udp6_lib_lookup_skb(struct sk_buff *skb,\n\t\t\t\t\t  __be16 sport, __be16 dport,\n\t\t\t\t\t  struct udp_table *udptable)\n{\n\tstruct sock *sk;\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\n\tsk = skb_steal_sock(skb);\n\tif (unlikely(sk))\n\t\treturn sk;\n\treturn __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, inet6_iif(skb),\n\t\t\t\t udptable);\n}\n\nstruct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,\n\t\t\t     const struct in6_addr *daddr, __be16 dport, int dif)\n{\n\treturn __udp6_lib_lookup(net, saddr, sport, daddr, dport, dif, &udp_table);\n}\nEXPORT_SYMBOL_GPL(udp6_lib_lookup);\n\n/*\n *\tThis should be easy, if there is something there we\n *\treturn it, otherwise we block.\n */\n\nint udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint is_udp4;\n\tbool slow;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tis_udp4 = (skb->protocol == htons(ETH_P_IP));\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t    msg, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udpv6_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tif (is_udp4)\n\t\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t\t   UDP_MIB_INERRORS,\n\t\t\t\t\t\t   is_udplite);\n\t\t\telse\n\t\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t\t    UDP_MIB_INERRORS,\n\t\t\t\t\t\t    is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tif (!peeked) {\n\t\tif (is_udp4)\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t\telse\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = udp_hdr(skb)->source;\n\t\tsin6->sin6_flowinfo = 0;\n\n\t\tif (is_udp4) {\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin6->sin6_addr);\n\t\t\tsin6->sin6_scope_id = 0;\n\t\t} else {\n\t\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    inet6_iif(skb));\n\t\t}\n\t\t*addr_len = sizeof(*sin6);\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\n\tif (is_udp4) {\n\t\tif (inet->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\t} else {\n\t\tif (np->rxopt.all)\n\t\t\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n\t}\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tif (is_udp4) {\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_CSUMERRORS, is_udplite);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t\t} else {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_CSUMERRORS, is_udplite);\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\t/* starting over for a new packet, but check if we need to yield */\n\tcond_resched();\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}\n\nvoid __udp6_lib_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t    u8 type, u8 code, int offset, __be32 info,\n\t\t    struct udp_table *udptable)\n{\n\tstruct ipv6_pinfo *np;\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct in6_addr *saddr = &hdr->saddr;\n\tconst struct in6_addr *daddr = &hdr->daddr;\n\tstruct udphdr *uh = (struct udphdr *)(skb->data+offset);\n\tstruct sock *sk;\n\tint err;\n\tstruct net *net = dev_net(skb->dev);\n\n\tsk = __udp6_lib_lookup(net, daddr, uh->dest,\n\t\t\t       saddr, uh->source, inet6_iif(skb), udptable);\n\tif (!sk) {\n\t\tICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\n\t\t\t\t   ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\t\tip6_sk_update_pmtu(skb, sk, info);\n\t}\n\tif (type == NDISC_REDIRECT) {\n\t\tip6_sk_redirect(skb, sk);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_err_convert(type, code, &err) && !np->recverr)\n\t\tgoto out;\n\n\tif (sk->sk_state != TCP_ESTABLISHED && !np->recverr)\n\t\tgoto out;\n\n\tif (np->recverr)\n\t\tipv6_icmp_error(sk, skb, err, uh->dest, ntohl(info), (u8 *)(uh+1));\n\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\nout:\n\tsock_put(sk);\n}\n\nstatic int __udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t}\n\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0) {\n\t\tint is_udplite = IS_UDPLITE(sk);\n\n\t\t/* Note that an ENOMEM error is charged twice */\n\t\tif (rc == -ENOMEM)\n\t\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\tUDP_MIB_RCVBUFERRORS, is_udplite);\n\t\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic __inline__ void udpv6_err(struct sk_buff *skb,\n\t\t\t\t struct inet6_skb_parm *opt, u8 type,\n\t\t\t\t u8 code, int offset, __be32 info)\n{\n\t__udp6_lib_err(skb, opt, type, code, offset, info, &udp_table);\n}\n\nstatic struct static_key udpv6_encap_needed __read_mostly;\nvoid udpv6_encap_enable(void)\n{\n\tif (!static_key_enabled(&udpv6_encap_needed))\n\t\tstatic_key_slow_inc(&udpv6_encap_needed);\n}\nEXPORT_SYMBOL(udpv6_encap_enable);\n\nint udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint rc;\n\tint is_udplite = IS_UDPLITE(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto drop;\n\n\tif (static_key_false(&udpv6_encap_needed) && up->encap_type) {\n\t\tint (*encap_rcv)(struct sock *sk, struct sk_buff *skb);\n\n\t\t/*\n\t\t * This is an encapsulation socket so pass the skb to\n\t\t * the socket's udp_encap_rcv() hook. Otherwise, just\n\t\t * fall through and pass this up the UDP socket.\n\t\t * up->encap_rcv() returns the following value:\n\t\t * =0 if skb was successfully passed to the encap\n\t\t *    handler or was discarded by it.\n\t\t * >0 if skb should be passed on to UDP.\n\t\t * <0 if skb should be resubmitted as proto -N\n\t\t */\n\n\t\t/* if we're overly short, let UDP handle it */\n\t\tencap_rcv = ACCESS_ONCE(up->encap_rcv);\n\t\tif (skb->len > sizeof(struct udphdr) && encap_rcv) {\n\t\t\tint ret;\n\n\t\t\t/* Verify checksum before giving to encap */\n\t\t\tif (udp_lib_checksum_complete(skb))\n\t\t\t\tgoto csum_error;\n\n\t\t\tret = encap_rcv(sk, skb);\n\t\t\tif (ret <= 0) {\n\t\t\t\tUDP_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\t\t UDP_MIB_INDATAGRAMS,\n\t\t\t\t\t\t is_udplite);\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t}\n\n\t\t/* FALLTHROUGH -- it's a UDP Packet */\n\t}\n\n\t/*\n\t * UDP-Lite specific tests, ignored on UDP sockets (see net/ipv4/udp.c).\n\t */\n\tif ((is_udplite & UDPLITE_RECV_CC)  &&  UDP_SKB_CB(skb)->partial_cov) {\n\n\t\tif (up->pcrlen == 0) {          /* full coverage was set  */\n\t\t\tnet_dbg_ratelimited(\"UDPLITE6: partial coverage %d while full coverage %d requested\\n\",\n\t\t\t\t\t    UDP_SKB_CB(skb)->cscov, skb->len);\n\t\t\tgoto drop;\n\t\t}\n\t\tif (UDP_SKB_CB(skb)->cscov  <  up->pcrlen) {\n\t\t\tnet_dbg_ratelimited(\"UDPLITE6: coverage %d too small, need min %d\\n\",\n\t\t\t\t\t    UDP_SKB_CB(skb)->cscov, up->pcrlen);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (rcu_access_pointer(sk->sk_filter)) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_error;\n\t}\n\n\tif (sk_rcvqueues_full(sk, sk->sk_rcvbuf)) {\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\t  UDP_MIB_RCVBUFERRORS, is_udplite);\n\t\tgoto drop;\n\t}\n\n\tskb_dst_drop(skb);\n\n\tbh_lock_sock(sk);\n\trc = 0;\n\tif (!sock_owned_by_user(sk))\n\t\trc = __udpv6_queue_rcv_skb(sk, skb);\n\telse if (sk_add_backlog(sk, skb, sk->sk_rcvbuf)) {\n\t\tbh_unlock_sock(sk);\n\t\tgoto drop;\n\t}\n\tbh_unlock_sock(sk);\n\n\treturn rc;\n\ncsum_error:\n\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\ndrop:\n\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\tatomic_inc(&sk->sk_drops);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic bool __udp_v6_is_mcast_sock(struct net *net, struct sock *sk,\n\t\t\t\t   __be16 loc_port, const struct in6_addr *loc_addr,\n\t\t\t\t   __be16 rmt_port, const struct in6_addr *rmt_addr,\n\t\t\t\t   int dif, unsigned short hnum)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tif (!net_eq(sock_net(sk), net))\n\t\treturn false;\n\n\tif (udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6 ||\n\t    (inet->inet_dport && inet->inet_dport != rmt_port) ||\n\t    (!ipv6_addr_any(&sk->sk_v6_daddr) &&\n\t\t    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr)) ||\n\t    (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif) ||\n\t    (!ipv6_addr_any(&sk->sk_v6_rcv_saddr) &&\n\t\t    !ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr)))\n\t\treturn false;\n\tif (!inet6_mc_check(sk, loc_addr, rmt_addr))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void flush_stack(struct sock **stack, unsigned int count,\n\t\t\tstruct sk_buff *skb, unsigned int final)\n{\n\tstruct sk_buff *skb1 = NULL;\n\tstruct sock *sk;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tsk = stack[i];\n\t\tif (likely(!skb1))\n\t\t\tskb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb1) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,\n\t\t\t\t\t  IS_UDPLITE(sk));\n\t\t\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS,\n\t\t\t\t\t  IS_UDPLITE(sk));\n\t\t}\n\n\t\tif (skb1 && udpv6_queue_rcv_skb(sk, skb1) <= 0)\n\t\t\tskb1 = NULL;\n\t\tsock_put(sk);\n\t}\n\tif (unlikely(skb1))\n\t\tkfree_skb(skb1);\n}\n\nstatic void udp6_csum_zero_error(struct sk_buff *skb)\n{\n\t/* RFC 2460 section 8.1 says that we SHOULD log\n\t * this error. Well, it is reasonable.\n\t */\n\tnet_dbg_ratelimited(\"IPv6: udp checksum is 0 for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t    &ipv6_hdr(skb)->saddr, ntohs(udp_hdr(skb)->source),\n\t\t\t    &ipv6_hdr(skb)->daddr, ntohs(udp_hdr(skb)->dest));\n}\n\n/*\n * Note: called only from the BH handler context,\n * so we don't need to lock the hashes.\n */\nstatic int __udp6_lib_mcast_deliver(struct net *net, struct sk_buff *skb,\n\t\tconst struct in6_addr *saddr, const struct in6_addr *daddr,\n\t\tstruct udp_table *udptable, int proto)\n{\n\tstruct sock *sk, *stack[256 / sizeof(struct sock *)];\n\tconst struct udphdr *uh = udp_hdr(skb);\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(uh->dest);\n\tstruct udp_hslot *hslot = udp_hashslot(udptable, net, hnum);\n\tint dif = inet6_iif(skb);\n\tunsigned int count = 0, offset = offsetof(typeof(*sk), sk_nulls_node);\n\tunsigned int hash2 = 0, hash2_any = 0, use_hash2 = (hslot->count > 10);\n\tbool inner_flushed = false;\n\n\tif (use_hash2) {\n\t\thash2_any = udp6_portaddr_hash(net, &in6addr_any, hnum) &\n\t\t\t    udp_table.mask;\n\t\thash2 = udp6_portaddr_hash(net, daddr, hnum) & udp_table.mask;\nstart_lookup:\n\t\thslot = &udp_table.hash2[hash2];\n\t\toffset = offsetof(typeof(*sk), __sk_common.skc_portaddr_node);\n\t}\n\n\tspin_lock(&hslot->lock);\n\tsk_nulls_for_each_entry_offset(sk, node, &hslot->head, offset) {\n\t\tif (__udp_v6_is_mcast_sock(net, sk,\n\t\t\t\t\t   uh->dest, daddr,\n\t\t\t\t\t   uh->source, saddr,\n\t\t\t\t\t   dif, hnum) &&\n\t\t    /* If zero checksum and no_check is not on for\n\t\t     * the socket then skip it.\n\t\t     */\n\t\t    (uh->check || udp_sk(sk)->no_check6_rx)) {\n\t\t\tif (unlikely(count == ARRAY_SIZE(stack))) {\n\t\t\t\tflush_stack(stack, count, skb, ~0);\n\t\t\t\tinner_flushed = true;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tstack[count++] = sk;\n\t\t\tsock_hold(sk);\n\t\t}\n\t}\n\n\tspin_unlock(&hslot->lock);\n\n\t/* Also lookup *:port if we are using hash2 and haven't done so yet. */\n\tif (use_hash2 && hash2 != hash2_any) {\n\t\thash2 = hash2_any;\n\t\tgoto start_lookup;\n\t}\n\n\tif (count) {\n\t\tflush_stack(stack, count, skb, count - 1);\n\t} else {\n\t\tif (!inner_flushed)\n\t\t\tUDP_INC_STATS_BH(net, UDP_MIB_IGNOREDMULTI,\n\t\t\t\t\t proto == IPPROTO_UDPLITE);\n\t\tconsume_skb(skb);\n\t}\n\treturn 0;\n}\n\nint __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct udphdr *uh;\n\tconst struct in6_addr *saddr, *daddr;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto discard;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t/* UDP validates ulen. */\n\n\t\t/* Check for jumbo payload */\n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto csum_error;\n\n\t/*\n\t *\tMulticast receive code\n\t */\n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable, proto);\n\n\t/* Unicast */\n\n\t/*\n\t * check socket cache ... must talk to Alan about his plans\n\t * for sock caches... i'll skip this for now.\n\t */\n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\tif (sk) {\n\t\tint ret;\n\n\t\tif (!uh->check && !udp_sk(sk)->no_check6_rx) {\n\t\t\tsock_put(sk);\n\t\t\tudp6_csum_zero_error(skb);\n\t\t\tgoto csum_error;\n\t\t}\n\n\t\tif (inet_get_convert_csum(sk) && uh->check && !IS_UDPLITE(sk))\n\t\t\tskb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,\n\t\t\t\t\t\t ip6_compute_pseudo);\n\n\t\tret = udpv6_queue_rcv_skb(sk, skb);\n\t\tsock_put(sk);\n\n\t\t/* a return value > 0 means to resubmit the input, but\n\t\t * it wants the return to be -protocol, or 0\n\t\t */\n\t\tif (ret > 0)\n\t\t\treturn -ret;\n\n\t\treturn 0;\n\t}\n\n\tif (!uh->check) {\n\t\tudp6_csum_zero_error(skb);\n\t\tgoto csum_error;\n\t}\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard;\n\n\tif (udp_lib_checksum_complete(skb))\n\t\tgoto csum_error;\n\n\tUDP6_INC_STATS_BH(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n\nshort_packet:\n\tnet_dbg_ratelimited(\"UDP%sv6: short packet: From [%pI6c]:%u %d/%d to [%pI6c]:%u\\n\",\n\t\t\t    proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t\t    saddr, ntohs(uh->source),\n\t\t\t    ulen, skb->len,\n\t\t\t    daddr, ntohs(uh->dest));\n\tgoto discard;\ncsum_error:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_CSUMERRORS, proto == IPPROTO_UDPLITE);\ndiscard:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic __inline__ int udpv6_rcv(struct sk_buff *skb)\n{\n\treturn __udp6_lib_rcv(skb, &udp_table, IPPROTO_UDP);\n}\n\n/*\n * Throw away all pending data and cancel the corking. Socket is locked.\n */\nstatic void udp_v6_flush_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\n\tif (up->pending == AF_INET)\n\t\tudp_flush_pending_frames(sk);\n\telse if (up->pending) {\n\t\tup->len = 0;\n\t\tup->pending = 0;\n\t\tip6_flush_pending_frames(sk);\n\t}\n}\n\n/**\n *\tudp6_hwcsum_outgoing  -  handle outgoing HW checksumming\n *\t@sk:\tsocket we are sending on\n *\t@skb:\tsk_buff containing the filled-in UDP header\n *\t\t(checksum field must be zeroed out)\n */\nstatic void udp6_hwcsum_outgoing(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t const struct in6_addr *saddr,\n\t\t\t\t const struct in6_addr *daddr, int len)\n{\n\tunsigned int offset;\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *frags = skb_shinfo(skb)->frag_list;\n\t__wsum csum = 0;\n\n\tif (!frags) {\n\t\t/* Only one fragment on the socket.  */\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tuh->check = ~csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP, 0);\n\t} else {\n\t\t/*\n\t\t * HW-checksum won't work as there are two or more\n\t\t * fragments on the socket so that all csums of sk_buffs\n\t\t * should be together\n\t\t */\n\t\toffset = skb_transport_offset(skb);\n\t\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tdo {\n\t\t\tcsum = csum_add(csum, frags->csum);\n\t\t} while ((frags = frags->next));\n\n\t\tuh->check = csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP,\n\t\t\t\t\t    csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t}\n}\n\n/*\n *\tSending\n */\n\nstatic int udp_v6_send_skb(struct sk_buff *skb, struct flowi6 *fl6)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct udphdr *uh;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\tint offset = skb_transport_offset(skb);\n\tint len = skb->len - offset;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(len);\n\tuh->check = 0;\n\n\tif (is_udplite)\n\t\tcsum = udplite_csum(skb);\n\telse if (udp_sk(sk)->no_check6_tx) {   /* UDP csum disabled */\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tgoto send;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr, len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum(skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip6_send_skb(skb);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\n\treturn err;\n}\n\nstatic int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct flowi6 fl6;\n\tint err = 0;\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_push_pending_frames(sk);\n\n\t/* ip6_finish_skb will release the cork, so make a copy of\n\t * fl6 here.\n\t */\n\tfl6 = inet_sk(sk)->cork.fl.u.ip6;\n\n\tskb = ip6_finish_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_v6_send_skb(skb, &fl6);\n\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}\n\nint udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\tint connected = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!up->pending) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else\n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_v4mapped(daddr)) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->inet_dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\tif (__ipv6_only_sock(sk))\n\t\t\t\treturn -ENETUNREACH;\n\t\t\treturn udp_sendmsg(sk, msg, len);\n\t\t}\n\t}\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_sendmsg(sk, msg, len);\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\n\tgetfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl6.fl6_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (!flowlabel)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))\n\t\t\tfl6.flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tconnected = 1;\n\t}\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,\n\t\t\t\t\t    &hlimit, &tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (!opt)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\tif (final_p)\n\t\tconnected = 0;\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) {\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\t\tconnected = 0;\n\t} else if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_sk_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto out;\n\t}\n\n\tif (hlimit < 0)\n\t\thlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\t/* Lockless fast path for the non-corking case */\n\tif (!corkreq) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = ip6_make_skb(sk, getfrag, msg, ulen,\n\t\t\t\t   sizeof(struct udphdr), hlimit, tclass, opt,\n\t\t\t\t   &fl6, (struct rt6_info *)dst,\n\t\t\t\t   msg->msg_flags, dontfrag);\n\t\terr = PTR_ERR(skb);\n\t\tif (!IS_ERR_OR_NULL(skb))\n\t\t\terr = udp_v6_send_skb(skb, &fl6);\n\t\tgoto release_dst;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tnet_dbg_ratelimited(\"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tup->pending = AF_INET6;\n\ndo_append_data:\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\tup->len += ulen;\n\terr = ip6_append_data(sk, getfrag, msg, ulen,\n\t\tsizeof(struct udphdr), hlimit, tclass, opt, &fl6,\n\t\t(struct rt6_info *)dst,\n\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\n\nrelease_dst:\n\tif (dst) {\n\t\tif (connected) {\n\t\t\tip6_dst_store(sk, dst,\n\t\t\t\t      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?\n\t\t\t\t      &sk->sk_v6_daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\t      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?\n\t\t\t\t      &np->saddr :\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n\nvoid udpv6_destroy_sock(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tlock_sock(sk);\n\tudp_v6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tif (static_key_false(&udpv6_encap_needed) && up->encap_type) {\n\t\tvoid (*encap_destroy)(struct sock *sk);\n\t\tencap_destroy = ACCESS_ONCE(up->encap_destroy);\n\t\tif (encap_destroy)\n\t\t\tencap_destroy(sk);\n\t}\n\n\tinet6_destroy_sock(sk);\n}\n\n/*\n *\tSocket option code for UDP\n */\nint udpv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_setsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nint compat_udpv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_setsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn compat_ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nint udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nint compat_udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn compat_ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic const struct inet6_protocol udpv6_protocol = {\n\t.handler\t=\tudpv6_rcv,\n\t.err_handler\t=\tudpv6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\n/* ------------------------------------------------------------------------ */\n#ifdef CONFIG_PROC_FS\nint udp6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\n\t} else {\n\t\tint bucket = ((struct udp_iter_state *)seq->private)->bucket;\n\t\tstruct inet_sock *inet = inet_sk(v);\n\t\t__u16 srcp = ntohs(inet->inet_sport);\n\t\t__u16 destp = ntohs(inet->inet_dport);\n\t\tip6_dgram_sock_seq_show(seq, v, srcp, destp, bucket);\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations udp6_afinfo_seq_fops = {\n\t.owner    = THIS_MODULE,\n\t.open     = udp_seq_open,\n\t.read     = seq_read,\n\t.llseek   = seq_lseek,\n\t.release  = seq_release_net\n};\n\nstatic struct udp_seq_afinfo udp6_seq_afinfo = {\n\t.name\t\t= \"udp6\",\n\t.family\t\t= AF_INET6,\n\t.udp_table\t= &udp_table,\n\t.seq_fops\t= &udp6_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= udp6_seq_show,\n\t},\n};\n\nint __net_init udp6_proc_init(struct net *net)\n{\n\treturn udp_proc_register(net, &udp6_seq_afinfo);\n}\n\nvoid udp6_proc_exit(struct net *net)\n{\n\tudp_proc_unregister(net, &udp6_seq_afinfo);\n}\n#endif /* CONFIG_PROC_FS */\n\nvoid udp_v6_clear_sk(struct sock *sk, int size)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t/* we do not want to clear pinet6 field, because of RCU lookups */\n\tsk_prot_clear_portaddr_nulls(sk, offsetof(struct inet_sock, pinet6));\n\n\tsize -= offsetof(struct inet_sock, pinet6) + sizeof(inet->pinet6);\n\tmemset(&inet->pinet6 + 1, 0, size);\n}\n\n/* ------------------------------------------------------------------------ */\n\nstruct proto udpv6_prot = {\n\t.name\t\t   = \"UDPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = udp_lib_close,\n\t.connect\t   = ip6_datagram_connect,\n\t.disconnect\t   = udp_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = udpv6_destroy_sock,\n\t.setsockopt\t   = udpv6_setsockopt,\n\t.getsockopt\t   = udpv6_getsockopt,\n\t.sendmsg\t   = udpv6_sendmsg,\n\t.recvmsg\t   = udpv6_recvmsg,\n\t.backlog_rcv\t   = __udpv6_queue_rcv_skb,\n\t.hash\t\t   = udp_lib_hash,\n\t.unhash\t\t   = udp_lib_unhash,\n\t.rehash\t\t   = udp_v6_rehash,\n\t.get_port\t   = udp_v6_get_port,\n\t.memory_allocated  = &udp_memory_allocated,\n\t.sysctl_mem\t   = sysctl_udp_mem,\n\t.sysctl_wmem\t   = &sysctl_udp_wmem_min,\n\t.sysctl_rmem\t   = &sysctl_udp_rmem_min,\n\t.obj_size\t   = sizeof(struct udp6_sock),\n\t.slab_flags\t   = SLAB_DESTROY_BY_RCU,\n\t.h.udp_table\t   = &udp_table,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_udpv6_setsockopt,\n\t.compat_getsockopt = compat_udpv6_getsockopt,\n#endif\n\t.clear_sk\t   = udp_v6_clear_sk,\n};\n\nstatic struct inet_protosw udpv6_protosw = {\n\t.type =      SOCK_DGRAM,\n\t.protocol =  IPPROTO_UDP,\n\t.prot =      &udpv6_prot,\n\t.ops =       &inet6_dgram_ops,\n\t.flags =     INET_PROTOSW_PERMANENT,\n};\n\nint __init udpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_register_protosw(&udpv6_protosw);\n\tif (ret)\n\t\tgoto out_udpv6_protocol;\nout:\n\treturn ret;\n\nout_udpv6_protocol:\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tgoto out;\n}\n\nvoid udpv6_exit(void)\n{\n\tinet6_unregister_protosw(&udpv6_protosw);\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n}\n", "/*\n * L2TPv3 IP encapsulation support for IPv6\n *\n * Copyright (c) 2012 Katalix Systems Ltd\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/icmp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/socket.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n\n#include \"l2tp_core.h\"\n\nstruct l2tp_ip6_sock {\n\t/* inet_sock has to be the first member of l2tp_ip6_sock */\n\tstruct inet_sock\tinet;\n\n\tu32\t\t\tconn_id;\n\tu32\t\t\tpeer_conn_id;\n\n\t/* ipv6_pinfo has to be the last member of l2tp_ip6_sock, see\n\t   inet6_sk_generic */\n\tstruct ipv6_pinfo\tinet6;\n};\n\nstatic DEFINE_RWLOCK(l2tp_ip6_lock);\nstatic struct hlist_head l2tp_ip6_table;\nstatic struct hlist_head l2tp_ip6_bind_table;\n\nstatic inline struct l2tp_ip6_sock *l2tp_ip6_sk(const struct sock *sk)\n{\n\treturn (struct l2tp_ip6_sock *)sk;\n}\n\nstatic struct sock *__l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t   struct in6_addr *laddr,\n\t\t\t\t\t   int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip6_bind_table) {\n\t\tconst struct in6_addr *addr = inet6_rcv_saddr(sk);\n\t\tstruct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);\n\n\t\tif (l2tp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((l2tp->conn_id == tunnel_id) &&\n\t\t    net_eq(sock_net(sk), net) &&\n\t\t    !(addr && ipv6_addr_equal(addr, laddr)) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\n\t\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic inline struct sock *l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t\tstruct in6_addr *laddr,\n\t\t\t\t\t\tint dif, u32 tunnel_id)\n{\n\tstruct sock *sk = __l2tp_ip6_bind_lookup(net, laddr, dif, tunnel_id);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\treturn sk;\n}\n\n/* When processing receive frames, there are two cases to\n * consider. Data frames consist of a non-zero session-id and an\n * optional cookie. Control frames consist of a regular L2TP header\n * preceded by 32-bits of zeros.\n *\n * L2TPv3 Session Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                           Session ID                          |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Cookie (optional, maximum 64 bits)...\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *                                                                 |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * L2TPv3 Control Message Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                      (32 bits of zeros)                       |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                     Control Connection ID                     |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Ns              |               Nr              |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * All control frames are passed to userspace.\n */\nstatic int l2tp_ip6_recv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tu32 session_id;\n\tu32 tunnel_id;\n\tunsigned char *ptr, *optr;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tint length;\n\n\t/* Point to L2TP header */\n\toptr = ptr = skb->data;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto discard;\n\n\tsession_id = ntohl(*((__be32 *) ptr));\n\tptr += 4;\n\n\t/* RFC3931: L2TP/IP packets have the first 4 bytes containing\n\t * the session_id. If it is 0, the packet is a L2TP control\n\t * frame and the session_id value can be discarded.\n\t */\n\tif (session_id == 0) {\n\t\t__skb_pull(skb, 4);\n\t\tgoto pass_up;\n\t}\n\n\t/* Ok, this is a data packet. Lookup the session. */\n\tsession = l2tp_session_find(&init_net, NULL, session_id);\n\tif (session == NULL)\n\t\tgoto discard;\n\n\ttunnel = session->tunnel;\n\tif (tunnel == NULL)\n\t\tgoto discard;\n\n\t/* Trace packet contents, if enabled */\n\tif (tunnel->debug & L2TP_MSG_DATA) {\n\t\tlength = min(32u, skb->len);\n\t\tif (!pskb_may_pull(skb, length))\n\t\t\tgoto discard;\n\n\t\tpr_debug(\"%s: ip recv\\n\", tunnel->name);\n\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, ptr, length);\n\t}\n\n\tl2tp_recv_common(session, skb, ptr, optr, 0, skb->len,\n\t\t\t tunnel->recv_payload_hook);\n\treturn 0;\n\npass_up:\n\t/* Get the tunnel_id from the L2TP header */\n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto discard;\n\n\tif ((skb->data[0] & 0xc0) != 0xc0)\n\t\tgoto discard;\n\n\ttunnel_id = ntohl(*(__be32 *) &skb->data[4]);\n\ttunnel = l2tp_tunnel_find(&init_net, tunnel_id);\n\tif (tunnel != NULL)\n\t\tsk = tunnel->sock;\n\telse {\n\t\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\n\t\tread_lock_bh(&l2tp_ip6_lock);\n\t\tsk = __l2tp_ip6_bind_lookup(&init_net, &iph->daddr,\n\t\t\t\t\t    0, tunnel_id);\n\t\tread_unlock_bh(&l2tp_ip6_lock);\n\t}\n\n\tif (sk == NULL)\n\t\tgoto discard;\n\n\tsock_hold(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_put;\n\n\tnf_reset(skb);\n\n\treturn sk_receive_skb(sk, skb, 1);\n\ndiscard_put:\n\tsock_put(sk);\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_open(struct sock *sk)\n{\n\t/* Prevent autobind. We don't have ports. */\n\tinet_sk(sk)->inet_num = IPPROTO_L2TP;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_node(sk, &l2tp_ip6_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\treturn 0;\n}\n\nstatic void l2tp_ip6_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsk_common_release(sk);\n}\n\nstatic void l2tp_ip6_destroy_sock(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\n\n\tlock_sock(sk);\n\tip6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tif (tunnel) {\n\t\tl2tp_tunnel_closeall(tunnel);\n\t\tsock_put(sk);\n\t}\n\n\tinet6_destroy_sock(sk);\n}\n\nstatic int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(&init_net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}\n\nstatic int l2tp_ip6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t    int addr_len)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;\n\tstruct in6_addr\t*daddr;\n\tint\taddr_type;\n\tint rc;\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EINVAL;\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tdaddr = &usin->sin6_addr;\n\t\tif (ipv4_is_multicast(daddr->s6_addr32[3]))\n\t\t\treturn -EINVAL;\n\t}\n\n\trc = ip6_datagram_connect(sk, uaddr, addr_len);\n\n\tlock_sock(sk);\n\n\tl2tp_ip6_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int l2tp_ip6_disconnect(struct sock *sk, int flags)\n{\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn 0;\n\n\treturn udp_disconnect(sk, flags);\n}\n\nstatic int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = sk->sk_v6_daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = sk->sk_v6_rcv_saddr;\n\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic int l2tp_ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\t__be32 *transhdr = NULL;\n\tint err = 0;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\ttranshdr = (__be32 *)skb_transport_header(skb);\n\t*transhdr = 0;\n\n\terr = ip6_push_pending_frames(sk);\n\nout:\n\treturn err;\n}\n\n/* Userspace will call sendmsg() on the tunnel socket to send L2TP\n * control frames.\n */\nstatic int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 fl6;\n\tint addr_len = msg->msg_namelen;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint transhdrlen = 4; /* zero session-id */\n\tint ulen = len + transhdrlen;\n\tint err;\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t */\n\tif (len > INT_MAX)\n\t\treturn -EMSGSIZE;\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (lsa) {\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\treturn -EINVAL;\n\n\t\tif (lsa->l2tp_family && lsa->l2tp_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\tdaddr = &lsa->l2tp_addr;\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = lsa->l2tp_flowinfo & IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    lsa->l2tp_scope_id &&\n\t\t    ipv6_addr_type(daddr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = lsa->l2tp_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (fl6.flowi6_oif == 0)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(struct ipv6_txoptions);\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,\n\t\t\t\t\t    &hlimit, &tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel & IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\n\tif (opt == NULL)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\n\tif (hlimit < 0)\n\t\thlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\n\nback_from_confirm:\n\tlock_sock(sk);\n\terr = ip6_append_data(sk, ip_generic_getfrag, msg,\n\t\t\t      ulen, transhdrlen, hlimit, tclass, opt,\n\t\t\t      &fl6, (struct rt6_info *)dst,\n\t\t\t      msg->msg_flags, dontfrag);\n\tif (err)\n\t\tip6_flush_pending_frames(sk);\n\telse if (!(msg->msg_flags & MSG_MORE))\n\t\terr = l2tp_ip6_push_pending_frames(sk);\n\trelease_sock(sk);\ndone:\n\tdst_release(dst);\nout:\n\tfl6_sock_release(flowlabel);\n\n\treturn err < 0 ? err : len;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic int l2tp_ip6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t    int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = inet6_iif(skb);\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n\nstatic struct proto l2tp_ip6_prot = {\n\t.name\t\t   = \"L2TP/IPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.init\t\t   = l2tp_ip6_open,\n\t.close\t\t   = l2tp_ip6_close,\n\t.bind\t\t   = l2tp_ip6_bind,\n\t.connect\t   = l2tp_ip6_connect,\n\t.disconnect\t   = l2tp_ip6_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = l2tp_ip6_destroy_sock,\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.sendmsg\t   = l2tp_ip6_sendmsg,\n\t.recvmsg\t   = l2tp_ip6_recvmsg,\n\t.backlog_rcv\t   = l2tp_ip6_backlog_recv,\n\t.hash\t\t   = inet_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.obj_size\t   = sizeof(struct l2tp_ip6_sock),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\nstatic const struct proto_ops l2tp_ip6_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = l2tp_ip6_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw l2tp_ip6_protosw = {\n\t.type\t\t= SOCK_DGRAM,\n\t.protocol\t= IPPROTO_L2TP,\n\t.prot\t\t= &l2tp_ip6_prot,\n\t.ops\t\t= &l2tp_ip6_ops,\n};\n\nstatic struct inet6_protocol l2tp_ip6_protocol __read_mostly = {\n\t.handler\t= l2tp_ip6_recv,\n};\n\nstatic int __init l2tp_ip6_init(void)\n{\n\tint err;\n\n\tpr_info(\"L2TP IP encapsulation support for IPv6 (L2TPv3)\\n\");\n\n\terr = proto_register(&l2tp_ip6_prot, 1);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tif (err)\n\t\tgoto out1;\n\n\tinet6_register_protosw(&l2tp_ip6_protosw);\n\treturn 0;\n\nout1:\n\tproto_unregister(&l2tp_ip6_prot);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_ip6_exit(void)\n{\n\tinet6_unregister_protosw(&l2tp_ip6_protosw);\n\tinet6_del_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tproto_unregister(&l2tp_ip6_prot);\n}\n\nmodule_init(l2tp_ip6_init);\nmodule_exit(l2tp_ip6_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Chris Elston <celston@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP IP encapsulation for IPv6\");\nMODULE_VERSION(\"1.0\");\n\n/* Use the value of SOCK_DGRAM (2) directory, because __stringify doesn't like\n * enums\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 2, IPPROTO_L2TP);\nMODULE_ALIAS_NET_PF_PROTO(PF_INET6, IPPROTO_L2TP);\n"], "fixing_code": ["#ifndef _IPV6_H\n#define _IPV6_H\n\n#include <uapi/linux/ipv6.h>\n\n#define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)\n#define ipv6_authlen(p) (((p)->hdrlen+2) << 2)\n/*\n * This structure contains configuration options per IPv6 link.\n */\nstruct ipv6_devconf {\n\t__s32\t\tforwarding;\n\t__s32\t\thop_limit;\n\t__s32\t\tmtu6;\n\t__s32\t\taccept_ra;\n\t__s32\t\taccept_redirects;\n\t__s32\t\tautoconf;\n\t__s32\t\tdad_transmits;\n\t__s32\t\trtr_solicits;\n\t__s32\t\trtr_solicit_interval;\n\t__s32\t\trtr_solicit_delay;\n\t__s32\t\tforce_mld_version;\n\t__s32\t\tmldv1_unsolicited_report_interval;\n\t__s32\t\tmldv2_unsolicited_report_interval;\n\t__s32\t\tuse_tempaddr;\n\t__s32\t\ttemp_valid_lft;\n\t__s32\t\ttemp_prefered_lft;\n\t__s32\t\tregen_max_retry;\n\t__s32\t\tmax_desync_factor;\n\t__s32\t\tmax_addresses;\n\t__s32\t\taccept_ra_defrtr;\n\t__s32\t\taccept_ra_min_hop_limit;\n\t__s32\t\taccept_ra_pinfo;\n\t__s32\t\tignore_routes_with_linkdown;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\t__s32\t\taccept_ra_rtr_pref;\n\t__s32\t\trtr_probe_interval;\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\t__s32\t\taccept_ra_rt_info_max_plen;\n#endif\n#endif\n\t__s32\t\tproxy_ndp;\n\t__s32\t\taccept_source_route;\n\t__s32\t\taccept_ra_from_local;\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t__s32\t\toptimistic_dad;\n\t__s32\t\tuse_optimistic;\n#endif\n#ifdef CONFIG_IPV6_MROUTE\n\t__s32\t\tmc_forwarding;\n#endif\n\t__s32\t\tdisable_ipv6;\n\t__s32\t\taccept_dad;\n\t__s32\t\tforce_tllao;\n\t__s32           ndisc_notify;\n\t__s32\t\tsuppress_frag_ndisc;\n\t__s32\t\taccept_ra_mtu;\n\tstruct ipv6_stable_secret {\n\t\tbool initialized;\n\t\tstruct in6_addr secret;\n\t} stable_secret;\n\t__s32\t\tuse_oif_addrs_only;\n\tvoid\t\t*sysctl;\n};\n\nstruct ipv6_params {\n\t__s32 disable_ipv6;\n\t__s32 autoconf;\n};\nextern struct ipv6_params ipv6_defaults;\n#include <linux/icmpv6.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n\n#include <net/inet_sock.h>\n\nstatic inline struct ipv6hdr *ipv6_hdr(const struct sk_buff *skb)\n{\n\treturn (struct ipv6hdr *)skb_network_header(skb);\n}\n\nstatic inline struct ipv6hdr *inner_ipv6_hdr(const struct sk_buff *skb)\n{\n\treturn (struct ipv6hdr *)skb_inner_network_header(skb);\n}\n\nstatic inline struct ipv6hdr *ipipv6_hdr(const struct sk_buff *skb)\n{\n\treturn (struct ipv6hdr *)skb_transport_header(skb);\n}\n\n/* \n   This structure contains results of exthdrs parsing\n   as offsets from skb->nh.\n */\n\nstruct inet6_skb_parm {\n\tint\t\t\tiif;\n\t__be16\t\t\tra;\n\t__u16\t\t\tdst0;\n\t__u16\t\t\tsrcrt;\n\t__u16\t\t\tdst1;\n\t__u16\t\t\tlastopt;\n\t__u16\t\t\tnhoff;\n\t__u16\t\t\tflags;\n#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)\n\t__u16\t\t\tdsthao;\n#endif\n\t__u16\t\t\tfrag_max_size;\n\n#define IP6SKB_XFRM_TRANSFORMED\t1\n#define IP6SKB_FORWARDED\t2\n#define IP6SKB_REROUTED\t\t4\n#define IP6SKB_ROUTERALERT\t8\n#define IP6SKB_FRAGMENTED      16\n#define IP6SKB_HOPBYHOP        32\n};\n\n#define IP6CB(skb)\t((struct inet6_skb_parm*)((skb)->cb))\n#define IP6CBMTU(skb)\t((struct ip6_mtuinfo *)((skb)->cb))\n\nstatic inline int inet6_iif(const struct sk_buff *skb)\n{\n\treturn IP6CB(skb)->iif;\n}\n\nstruct tcp6_request_sock {\n\tstruct tcp_request_sock\t  tcp6rsk_tcp;\n};\n\nstruct ipv6_mc_socklist;\nstruct ipv6_ac_socklist;\nstruct ipv6_fl_socklist;\n\nstruct inet6_cork {\n\tstruct ipv6_txoptions *opt;\n\tu8 hop_limit;\n\tu8 tclass;\n};\n\n/**\n * struct ipv6_pinfo - ipv6 private area\n *\n * In the struct sock hierarchy (tcp6_sock, upd6_sock, etc)\n * this _must_ be the last member, so that inet6_sk_generic\n * is able to calculate its offset from the base struct sock\n * by using the struct proto->slab_obj_size member. -acme\n */\nstruct ipv6_pinfo {\n\tstruct in6_addr \tsaddr;\n\tstruct in6_pktinfo\tsticky_pktinfo;\n\tconst struct in6_addr\t\t*daddr_cache;\n#ifdef CONFIG_IPV6_SUBTREES\n\tconst struct in6_addr\t\t*saddr_cache;\n#endif\n\n\t__be32\t\t\tflow_label;\n\t__u32\t\t\tfrag_size;\n\n\t/*\n\t * Packed in 16bits.\n\t * Omit one shift by by putting the signed field at MSB.\n\t */\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t__s16\t\t\thop_limit:9;\n\t__u16\t\t\t__unused_1:7;\n#else\n\t__u16\t\t\t__unused_1:7;\n\t__s16\t\t\thop_limit:9;\n#endif\n\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t/* Packed in 16bits. */\n\t__s16\t\t\tmcast_hops:9;\n\t__u16\t\t\t__unused_2:6,\n\t\t\t\tmc_loop:1;\n#else\n\t__u16\t\t\tmc_loop:1,\n\t\t\t\t__unused_2:6;\n\t__s16\t\t\tmcast_hops:9;\n#endif\n\tint\t\t\tucast_oif;\n\tint\t\t\tmcast_oif;\n\n\t/* pktoption flags */\n\tunion {\n\t\tstruct {\n\t\t\t__u16\tsrcrt:1,\n\t\t\t\tosrcrt:1,\n\t\t\t        rxinfo:1,\n\t\t\t        rxoinfo:1,\n\t\t\t\trxhlim:1,\n\t\t\t\trxohlim:1,\n\t\t\t\thopopts:1,\n\t\t\t\tohopopts:1,\n\t\t\t\tdstopts:1,\n\t\t\t\todstopts:1,\n                                rxflow:1,\n\t\t\t\trxtclass:1,\n\t\t\t\trxpmtu:1,\n\t\t\t\trxorigdstaddr:1;\n\t\t\t\t/* 2 bits hole */\n\t\t} bits;\n\t\t__u16\t\tall;\n\t} rxopt;\n\n\t/* sockopt flags */\n\t__u16\t\t\trecverr:1,\n\t                        sndflow:1,\n\t\t\t\trepflow:1,\n\t\t\t\tpmtudisc:3,\n\t\t\t\tpadding:1,\t/* 1 bit hole */\n\t\t\t\tsrcprefs:3,\t/* 001: prefer temporary address\n\t\t\t\t\t\t * 010: prefer public address\n\t\t\t\t\t\t * 100: prefer care-of address\n\t\t\t\t\t\t */\n\t\t\t\tdontfrag:1,\n\t\t\t\tautoflowlabel:1;\n\t__u8\t\t\tmin_hopcount;\n\t__u8\t\t\ttclass;\n\t__be32\t\t\trcv_flowinfo;\n\n\t__u32\t\t\tdst_cookie;\n\t__u32\t\t\trx_dst_cookie;\n\n\tstruct ipv6_mc_socklist\t__rcu *ipv6_mc_list;\n\tstruct ipv6_ac_socklist\t*ipv6_ac_list;\n\tstruct ipv6_fl_socklist __rcu *ipv6_fl_list;\n\n\tstruct ipv6_txoptions __rcu\t*opt;\n\tstruct sk_buff\t\t*pktoptions;\n\tstruct sk_buff\t\t*rxpmtu;\n\tstruct inet6_cork\tcork;\n};\n\n/* WARNING: don't change the layout of the members in {raw,udp,tcp}6_sock! */\nstruct raw6_sock {\n\t/* inet_sock has to be the first member of raw6_sock */\n\tstruct inet_sock\tinet;\n\t__u32\t\t\tchecksum;\t/* perform checksum */\n\t__u32\t\t\toffset;\t\t/* checksum offset  */\n\tstruct icmp6_filter\tfilter;\n\t__u32\t\t\tip6mr_table;\n\t/* ipv6_pinfo has to be the last member of raw6_sock, see inet6_sk_generic */\n\tstruct ipv6_pinfo\tinet6;\n};\n\nstruct udp6_sock {\n\tstruct udp_sock\t  udp;\n\t/* ipv6_pinfo has to be the last member of udp6_sock, see inet6_sk_generic */\n\tstruct ipv6_pinfo inet6;\n};\n\nstruct tcp6_sock {\n\tstruct tcp_sock\t  tcp;\n\t/* ipv6_pinfo has to be the last member of tcp6_sock, see inet6_sk_generic */\n\tstruct ipv6_pinfo inet6;\n};\n\nextern int inet6_sk_rebuild_header(struct sock *sk);\n\nstruct tcp6_timewait_sock {\n\tstruct tcp_timewait_sock   tcp6tw_tcp;\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline struct ipv6_pinfo *inet6_sk(const struct sock *__sk)\n{\n\treturn sk_fullsock(__sk) ? inet_sk(__sk)->pinet6 : NULL;\n}\n\nstatic inline struct raw6_sock *raw6_sk(const struct sock *sk)\n{\n\treturn (struct raw6_sock *)sk;\n}\n\nstatic inline void inet_sk_copy_descendant(struct sock *sk_to,\n\t\t\t\t\t   const struct sock *sk_from)\n{\n\tint ancestor_size = sizeof(struct inet_sock);\n\n\tif (sk_from->sk_family == PF_INET6)\n\t\tancestor_size += sizeof(struct ipv6_pinfo);\n\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}\n\n#define __ipv6_only_sock(sk)\t(sk->sk_ipv6only)\n#define ipv6_only_sock(sk)\t(__ipv6_only_sock(sk))\n#define ipv6_sk_rxinfo(sk)\t((sk)->sk_family == PF_INET6 && \\\n\t\t\t\t inet6_sk(sk)->rxopt.bits.rxinfo)\n\nstatic inline const struct in6_addr *inet6_rcv_saddr(const struct sock *sk)\n{\n\tif (sk->sk_family == AF_INET6)\n\t\treturn &sk->sk_v6_rcv_saddr;\n\treturn NULL;\n}\n\nstatic inline int inet_v6_ipv6only(const struct sock *sk)\n{\n\t/* ipv6only field is at same position for timewait and other sockets */\n\treturn ipv6_only_sock(sk);\n}\n#else\n#define __ipv6_only_sock(sk)\t0\n#define ipv6_only_sock(sk)\t0\n#define ipv6_sk_rxinfo(sk)\t0\n\nstatic inline struct ipv6_pinfo * inet6_sk(const struct sock *__sk)\n{\n\treturn NULL;\n}\n\nstatic inline struct inet6_request_sock *\n\t\t\tinet6_rsk(const struct request_sock *rsk)\n{\n\treturn NULL;\n}\n\nstatic inline struct raw6_sock *raw6_sk(const struct sock *sk)\n{\n\treturn NULL;\n}\n\n#define inet6_rcv_saddr(__sk)\tNULL\n#define tcp_twsk_ipv6only(__sk)\t\t0\n#define inet_v6_ipv6only(__sk)\t\t0\n#endif /* IS_ENABLED(CONFIG_IPV6) */\n#endif /* _IPV6_H */\n", "/*\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#ifndef _NET_IPV6_H\n#define _NET_IPV6_H\n\n#include <linux/ipv6.h>\n#include <linux/hardirq.h>\n#include <linux/jhash.h>\n#include <net/if_inet6.h>\n#include <net/ndisc.h>\n#include <net/flow.h>\n#include <net/flow_dissector.h>\n#include <net/snmp.h>\n\n#define SIN6_LEN_RFC2133\t24\n\n#define IPV6_MAXPLEN\t\t65535\n\n/*\n *\tNextHeader field of IPv6 header\n */\n\n#define NEXTHDR_HOP\t\t0\t/* Hop-by-hop option header. */\n#define NEXTHDR_TCP\t\t6\t/* TCP segment. */\n#define NEXTHDR_UDP\t\t17\t/* UDP message. */\n#define NEXTHDR_IPV6\t\t41\t/* IPv6 in IPv6 */\n#define NEXTHDR_ROUTING\t\t43\t/* Routing header. */\n#define NEXTHDR_FRAGMENT\t44\t/* Fragmentation/reassembly header. */\n#define NEXTHDR_GRE\t\t47\t/* GRE header. */\n#define NEXTHDR_ESP\t\t50\t/* Encapsulating security payload. */\n#define NEXTHDR_AUTH\t\t51\t/* Authentication header. */\n#define NEXTHDR_ICMP\t\t58\t/* ICMP for IPv6. */\n#define NEXTHDR_NONE\t\t59\t/* No next header */\n#define NEXTHDR_DEST\t\t60\t/* Destination options header. */\n#define NEXTHDR_SCTP\t\t132\t/* SCTP message. */\n#define NEXTHDR_MOBILITY\t135\t/* Mobility header. */\n\n#define NEXTHDR_MAX\t\t255\n\n#define IPV6_DEFAULT_HOPLIMIT   64\n#define IPV6_DEFAULT_MCASTHOPS\t1\n\n/*\n *\tAddr type\n *\t\n *\ttype\t-\tunicast | multicast\n *\tscope\t-\tlocal\t| site\t    | global\n *\tv4\t-\tcompat\n *\tv4mapped\n *\tany\n *\tloopback\n */\n\n#define IPV6_ADDR_ANY\t\t0x0000U\n\n#define IPV6_ADDR_UNICAST      \t0x0001U\t\n#define IPV6_ADDR_MULTICAST    \t0x0002U\t\n\n#define IPV6_ADDR_LOOPBACK\t0x0010U\n#define IPV6_ADDR_LINKLOCAL\t0x0020U\n#define IPV6_ADDR_SITELOCAL\t0x0040U\n\n#define IPV6_ADDR_COMPATv4\t0x0080U\n\n#define IPV6_ADDR_SCOPE_MASK\t0x00f0U\n\n#define IPV6_ADDR_MAPPED\t0x1000U\n\n/*\n *\tAddr scopes\n */\n#define IPV6_ADDR_MC_SCOPE(a)\t\\\n\t((a)->s6_addr[1] & 0x0f)\t/* nonstandard */\n#define __IPV6_ADDR_SCOPE_INVALID\t-1\n#define IPV6_ADDR_SCOPE_NODELOCAL\t0x01\n#define IPV6_ADDR_SCOPE_LINKLOCAL\t0x02\n#define IPV6_ADDR_SCOPE_SITELOCAL\t0x05\n#define IPV6_ADDR_SCOPE_ORGLOCAL\t0x08\n#define IPV6_ADDR_SCOPE_GLOBAL\t\t0x0e\n\n/*\n *\tAddr flags\n */\n#define IPV6_ADDR_MC_FLAG_TRANSIENT(a)\t\\\n\t((a)->s6_addr[1] & 0x10)\n#define IPV6_ADDR_MC_FLAG_PREFIX(a)\t\\\n\t((a)->s6_addr[1] & 0x20)\n#define IPV6_ADDR_MC_FLAG_RENDEZVOUS(a)\t\\\n\t((a)->s6_addr[1] & 0x40)\n\n/*\n *\tfragmentation header\n */\n\nstruct frag_hdr {\n\t__u8\tnexthdr;\n\t__u8\treserved;\n\t__be16\tfrag_off;\n\t__be32\tidentification;\n};\n\n#define\tIP6_MF\t\t0x0001\n#define\tIP6_OFFSET\t0xFFF8\n\n#define IP6_REPLY_MARK(net, mark) \\\n\t((net)->ipv6.sysctl.fwmark_reflect ? (mark) : 0)\n\n#include <net/sock.h>\n\n/* sysctls */\nextern int sysctl_mld_max_msf;\nextern int sysctl_mld_qrv;\n\n#define _DEVINC(net, statname, modifier, idev, field)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_INC_STATS##modifier((_idev)->stats.statname, (field)); \\\n\tSNMP_INC_STATS##modifier((net)->mib.statname##_statistics, (field));\\\n})\n\n/* per device counters are atomic_long_t */\n#define _DEVINCATOMIC(net, statname, modifier, idev, field)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_INC_STATS_ATOMIC_LONG((_idev)->stats.statname##dev, (field)); \\\n\tSNMP_INC_STATS##modifier((net)->mib.statname##_statistics, (field));\\\n})\n\n/* per device and per net counters are atomic_long_t */\n#define _DEVINC_ATOMIC_ATOMIC(net, statname, idev, field)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_INC_STATS_ATOMIC_LONG((_idev)->stats.statname##dev, (field)); \\\n\tSNMP_INC_STATS_ATOMIC_LONG((net)->mib.statname##_statistics, (field));\\\n})\n\n#define _DEVADD(net, statname, modifier, idev, field, val)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_ADD_STATS##modifier((_idev)->stats.statname, (field), (val)); \\\n\tSNMP_ADD_STATS##modifier((net)->mib.statname##_statistics, (field), (val));\\\n})\n\n#define _DEVUPD(net, statname, modifier, idev, field, val)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstruct inet6_dev *_idev = (idev);\t\t\t\t\\\n\tif (likely(_idev != NULL))\t\t\t\t\t\\\n\t\tSNMP_UPD_PO_STATS##modifier((_idev)->stats.statname, field, (val)); \\\n\tSNMP_UPD_PO_STATS##modifier((net)->mib.statname##_statistics, field, (val));\\\n})\n\n/* MIBs */\n\n#define IP6_INC_STATS(net, idev,field)\t\t\\\n\t\t_DEVINC(net, ipv6, 64, idev, field)\n#define IP6_INC_STATS_BH(net, idev,field)\t\\\n\t\t_DEVINC(net, ipv6, 64_BH, idev, field)\n#define IP6_ADD_STATS(net, idev,field,val)\t\\\n\t\t_DEVADD(net, ipv6, 64, idev, field, val)\n#define IP6_ADD_STATS_BH(net, idev,field,val)\t\\\n\t\t_DEVADD(net, ipv6, 64_BH, idev, field, val)\n#define IP6_UPD_PO_STATS(net, idev,field,val)   \\\n\t\t_DEVUPD(net, ipv6, 64, idev, field, val)\n#define IP6_UPD_PO_STATS_BH(net, idev,field,val)   \\\n\t\t_DEVUPD(net, ipv6, 64_BH, idev, field, val)\n#define ICMP6_INC_STATS(net, idev, field)\t\\\n\t\t_DEVINCATOMIC(net, icmpv6, , idev, field)\n#define ICMP6_INC_STATS_BH(net, idev, field)\t\\\n\t\t_DEVINCATOMIC(net, icmpv6, _BH, idev, field)\n\n#define ICMP6MSGOUT_INC_STATS(net, idev, field)\t\t\\\n\t_DEVINC_ATOMIC_ATOMIC(net, icmpv6msg, idev, field +256)\n#define ICMP6MSGOUT_INC_STATS_BH(net, idev, field)\t\\\n\t_DEVINC_ATOMIC_ATOMIC(net, icmpv6msg, idev, field +256)\n#define ICMP6MSGIN_INC_STATS_BH(net, idev, field)\t\\\n\t_DEVINC_ATOMIC_ATOMIC(net, icmpv6msg, idev, field)\n\nstruct ip6_ra_chain {\n\tstruct ip6_ra_chain\t*next;\n\tstruct sock\t\t*sk;\n\tint\t\t\tsel;\n\tvoid\t\t\t(*destructor)(struct sock *);\n};\n\nextern struct ip6_ra_chain\t*ip6_ra_chain;\nextern rwlock_t ip6_ra_lock;\n\n/*\n   This structure is prepared by protocol, when parsing\n   ancillary data and passed to IPv6.\n */\n\nstruct ipv6_txoptions {\n\tatomic_t\t\trefcnt;\n\t/* Length of this structure */\n\tint\t\t\ttot_len;\n\n\t/* length of extension headers   */\n\n\t__u16\t\t\topt_flen;\t/* after fragment hdr */\n\t__u16\t\t\topt_nflen;\t/* before fragment hdr */\n\n\tstruct ipv6_opt_hdr\t*hopopt;\n\tstruct ipv6_opt_hdr\t*dst0opt;\n\tstruct ipv6_rt_hdr\t*srcrt;\t/* Routing Header */\n\tstruct ipv6_opt_hdr\t*dst1opt;\n\tstruct rcu_head\t\trcu;\n\t/* Option buffer, as read by IPV6_PKTOPTIONS, starts here. */\n};\n\nstruct ip6_flowlabel {\n\tstruct ip6_flowlabel __rcu *next;\n\t__be32\t\t\tlabel;\n\tatomic_t\t\tusers;\n\tstruct in6_addr\t\tdst;\n\tstruct ipv6_txoptions\t*opt;\n\tunsigned long\t\tlinger;\n\tstruct rcu_head\t\trcu;\n\tu8\t\t\tshare;\n\tunion {\n\t\tstruct pid *pid;\n\t\tkuid_t uid;\n\t} owner;\n\tunsigned long\t\tlastuse;\n\tunsigned long\t\texpires;\n\tstruct net\t\t*fl_net;\n};\n\n#define IPV6_FLOWINFO_MASK\t\tcpu_to_be32(0x0FFFFFFF)\n#define IPV6_FLOWLABEL_MASK\t\tcpu_to_be32(0x000FFFFF)\n#define IPV6_FLOWLABEL_STATELESS_FLAG\tcpu_to_be32(0x00080000)\n\n#define IPV6_TCLASS_MASK (IPV6_FLOWINFO_MASK & ~IPV6_FLOWLABEL_MASK)\n#define IPV6_TCLASS_SHIFT\t20\n\nstruct ipv6_fl_socklist {\n\tstruct ipv6_fl_socklist\t__rcu\t*next;\n\tstruct ip6_flowlabel\t\t*fl;\n\tstruct rcu_head\t\t\trcu;\n};\n\nstatic inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n{\n\tstruct ipv6_txoptions *opt;\n\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt && !atomic_inc_not_zero(&opt->refcnt))\n\t\topt = NULL;\n\trcu_read_unlock();\n\treturn opt;\n}\n\nstatic inline void txopt_put(struct ipv6_txoptions *opt)\n{\n\tif (opt && atomic_dec_and_test(&opt->refcnt))\n\t\tkfree_rcu(opt, rcu);\n}\n\nstruct ip6_flowlabel *fl6_sock_lookup(struct sock *sk, __be32 label);\nstruct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t struct ip6_flowlabel *fl,\n\t\t\t\t\t struct ipv6_txoptions *fopt);\nvoid fl6_free_socklist(struct sock *sk);\nint ipv6_flowlabel_opt(struct sock *sk, char __user *optval, int optlen);\nint ipv6_flowlabel_opt_get(struct sock *sk, struct in6_flowlabel_req *freq,\n\t\t\t   int flags);\nint ip6_flowlabel_init(void);\nvoid ip6_flowlabel_cleanup(void);\n\nstatic inline void fl6_sock_release(struct ip6_flowlabel *fl)\n{\n\tif (fl)\n\t\tatomic_dec(&fl->users);\n}\n\nvoid icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info);\n\nint icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t       struct icmp6hdr *thdr, int len);\n\nint ip6_ra_control(struct sock *sk, int sel);\n\nint ipv6_parse_hopopts(struct sk_buff *skb);\n\nstruct ipv6_txoptions *ipv6_dup_options(struct sock *sk,\n\t\t\t\t\tstruct ipv6_txoptions *opt);\nstruct ipv6_txoptions *ipv6_renew_options(struct sock *sk,\n\t\t\t\t\t  struct ipv6_txoptions *opt,\n\t\t\t\t\t  int newtype,\n\t\t\t\t\t  struct ipv6_opt_hdr __user *newopt,\n\t\t\t\t\t  int newoptlen);\nstruct ipv6_txoptions *ipv6_fixup_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t  struct ipv6_txoptions *opt);\n\nbool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb,\n\t\t       const struct inet6_skb_parm *opt);\n\nstatic inline bool ipv6_accept_ra(struct inet6_dev *idev)\n{\n\t/* If forwarding is enabled, RA are not accepted unless the special\n\t * hybrid mode (accept_ra=2) is enabled.\n\t */\n\treturn idev->cnf.forwarding ? idev->cnf.accept_ra == 2 :\n\t    idev->cnf.accept_ra;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline int ip6_frag_mem(struct net *net)\n{\n\treturn sum_frag_mem_limit(&net->ipv6.frags);\n}\n#endif\n\n#define IPV6_FRAG_HIGH_THRESH\t(4 * 1024*1024)\t/* 4194304 */\n#define IPV6_FRAG_LOW_THRESH\t(3 * 1024*1024)\t/* 3145728 */\n#define IPV6_FRAG_TIMEOUT\t(60 * HZ)\t/* 60 seconds */\n\nint __ipv6_addr_type(const struct in6_addr *addr);\nstatic inline int ipv6_addr_type(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_type(addr) & 0xffff;\n}\n\nstatic inline int ipv6_addr_scope(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_type(addr) & IPV6_ADDR_SCOPE_MASK;\n}\n\nstatic inline int __ipv6_addr_src_scope(int type)\n{\n\treturn (type == IPV6_ADDR_ANY) ? __IPV6_ADDR_SCOPE_INVALID : (type >> 16);\n}\n\nstatic inline int ipv6_addr_src_scope(const struct in6_addr *addr)\n{\n\treturn __ipv6_addr_src_scope(__ipv6_addr_type(addr));\n}\n\nstatic inline bool __ipv6_addr_needs_scope_id(int type)\n{\n\treturn type & IPV6_ADDR_LINKLOCAL ||\n\t       (type & IPV6_ADDR_MULTICAST &&\n\t\t(type & (IPV6_ADDR_LOOPBACK|IPV6_ADDR_LINKLOCAL)));\n}\n\nstatic inline __u32 ipv6_iface_scope_id(const struct in6_addr *addr, int iface)\n{\n\treturn __ipv6_addr_needs_scope_id(__ipv6_addr_type(addr)) ? iface : 0;\n}\n\nstatic inline int ipv6_addr_cmp(const struct in6_addr *a1, const struct in6_addr *a2)\n{\n\treturn memcmp(a1, a2, sizeof(struct in6_addr));\n}\n\nstatic inline bool\nipv6_masked_addr_cmp(const struct in6_addr *a1, const struct in6_addr *m,\n\t\t     const struct in6_addr *a2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul1 = (const unsigned long *)a1;\n\tconst unsigned long *ulm = (const unsigned long *)m;\n\tconst unsigned long *ul2 = (const unsigned long *)a2;\n\n\treturn !!(((ul1[0] ^ ul2[0]) & ulm[0]) |\n\t\t  ((ul1[1] ^ ul2[1]) & ulm[1]));\n#else\n\treturn !!(((a1->s6_addr32[0] ^ a2->s6_addr32[0]) & m->s6_addr32[0]) |\n\t\t  ((a1->s6_addr32[1] ^ a2->s6_addr32[1]) & m->s6_addr32[1]) |\n\t\t  ((a1->s6_addr32[2] ^ a2->s6_addr32[2]) & m->s6_addr32[2]) |\n\t\t  ((a1->s6_addr32[3] ^ a2->s6_addr32[3]) & m->s6_addr32[3]));\n#endif\n}\n\nstatic inline void ipv6_addr_prefix(struct in6_addr *pfx, \n\t\t\t\t    const struct in6_addr *addr,\n\t\t\t\t    int plen)\n{\n\t/* caller must guarantee 0 <= plen <= 128 */\n\tint o = plen >> 3,\n\t    b = plen & 0x7;\n\n\tmemset(pfx->s6_addr, 0, sizeof(pfx->s6_addr));\n\tmemcpy(pfx->s6_addr, addr, o);\n\tif (b != 0)\n\t\tpfx->s6_addr[o] = addr->s6_addr[o] & (0xff00 >> b);\n}\n\nstatic inline void __ipv6_addr_set_half(__be32 *addr,\n\t\t\t\t\t__be32 wh, __be32 wl)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n#if defined(__BIG_ENDIAN)\n\tif (__builtin_constant_p(wh) && __builtin_constant_p(wl)) {\n\t\t*(__force u64 *)addr = ((__force u64)(wh) << 32 | (__force u64)(wl));\n\t\treturn;\n\t}\n#elif defined(__LITTLE_ENDIAN)\n\tif (__builtin_constant_p(wl) && __builtin_constant_p(wh)) {\n\t\t*(__force u64 *)addr = ((__force u64)(wl) << 32 | (__force u64)(wh));\n\t\treturn;\n\t}\n#endif\n#endif\n\taddr[0] = wh;\n\taddr[1] = wl;\n}\n\nstatic inline void ipv6_addr_set(struct in6_addr *addr, \n\t\t\t\t     __be32 w1, __be32 w2,\n\t\t\t\t     __be32 w3, __be32 w4)\n{\n\t__ipv6_addr_set_half(&addr->s6_addr32[0], w1, w2);\n\t__ipv6_addr_set_half(&addr->s6_addr32[2], w3, w4);\n}\n\nstatic inline bool ipv6_addr_equal(const struct in6_addr *a1,\n\t\t\t\t   const struct in6_addr *a2)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul1 = (const unsigned long *)a1;\n\tconst unsigned long *ul2 = (const unsigned long *)a2;\n\n\treturn ((ul1[0] ^ ul2[0]) | (ul1[1] ^ ul2[1])) == 0UL;\n#else\n\treturn ((a1->s6_addr32[0] ^ a2->s6_addr32[0]) |\n\t\t(a1->s6_addr32[1] ^ a2->s6_addr32[1]) |\n\t\t(a1->s6_addr32[2] ^ a2->s6_addr32[2]) |\n\t\t(a1->s6_addr32[3] ^ a2->s6_addr32[3])) == 0;\n#endif\n}\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\nstatic inline bool __ipv6_prefix_equal64_half(const __be64 *a1,\n\t\t\t\t\t      const __be64 *a2,\n\t\t\t\t\t      unsigned int len)\n{\n\tif (len && ((*a1 ^ *a2) & cpu_to_be64((~0UL) << (64 - len))))\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline bool ipv6_prefix_equal(const struct in6_addr *addr1,\n\t\t\t\t     const struct in6_addr *addr2,\n\t\t\t\t     unsigned int prefixlen)\n{\n\tconst __be64 *a1 = (const __be64 *)addr1;\n\tconst __be64 *a2 = (const __be64 *)addr2;\n\n\tif (prefixlen >= 64) {\n\t\tif (a1[0] ^ a2[0])\n\t\t\treturn false;\n\t\treturn __ipv6_prefix_equal64_half(a1 + 1, a2 + 1, prefixlen - 64);\n\t}\n\treturn __ipv6_prefix_equal64_half(a1, a2, prefixlen);\n}\n#else\nstatic inline bool ipv6_prefix_equal(const struct in6_addr *addr1,\n\t\t\t\t     const struct in6_addr *addr2,\n\t\t\t\t     unsigned int prefixlen)\n{\n\tconst __be32 *a1 = addr1->s6_addr32;\n\tconst __be32 *a2 = addr2->s6_addr32;\n\tunsigned int pdw, pbi;\n\n\t/* check complete u32 in prefix */\n\tpdw = prefixlen >> 5;\n\tif (pdw && memcmp(a1, a2, pdw << 2))\n\t\treturn false;\n\n\t/* check incomplete u32 in prefix */\n\tpbi = prefixlen & 0x1f;\n\tif (pbi && ((a1[pdw] ^ a2[pdw]) & htonl((0xffffffff) << (32 - pbi))))\n\t\treturn false;\n\n\treturn true;\n}\n#endif\n\nstruct inet_frag_queue;\n\nenum ip6_defrag_users {\n\tIP6_DEFRAG_LOCAL_DELIVER,\n\tIP6_DEFRAG_CONNTRACK_IN,\n\t__IP6_DEFRAG_CONNTRACK_IN\t= IP6_DEFRAG_CONNTRACK_IN + USHRT_MAX,\n\tIP6_DEFRAG_CONNTRACK_OUT,\n\t__IP6_DEFRAG_CONNTRACK_OUT\t= IP6_DEFRAG_CONNTRACK_OUT + USHRT_MAX,\n\tIP6_DEFRAG_CONNTRACK_BRIDGE_IN,\n\t__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = IP6_DEFRAG_CONNTRACK_BRIDGE_IN + USHRT_MAX,\n};\n\nstruct ip6_create_arg {\n\t__be32 id;\n\tu32 user;\n\tconst struct in6_addr *src;\n\tconst struct in6_addr *dst;\n\tint iif;\n\tu8 ecn;\n};\n\nvoid ip6_frag_init(struct inet_frag_queue *q, const void *a);\nbool ip6_frag_match(const struct inet_frag_queue *q, const void *a);\n\n/*\n *\tEquivalent of ipv4 struct ip\n */\nstruct frag_queue {\n\tstruct inet_frag_queue\tq;\n\n\t__be32\t\t\tid;\t\t/* fragment id\t\t*/\n\tu32\t\t\tuser;\n\tstruct in6_addr\t\tsaddr;\n\tstruct in6_addr\t\tdaddr;\n\n\tint\t\t\tiif;\n\tunsigned int\t\tcsum;\n\t__u16\t\t\tnhoffset;\n\tu8\t\t\tecn;\n};\n\nvoid ip6_expire_frag_queue(struct net *net, struct frag_queue *fq,\n\t\t\t   struct inet_frags *frags);\n\nstatic inline bool ipv6_addr_any(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul = (const unsigned long *)a;\n\n\treturn (ul[0] | ul[1]) == 0UL;\n#else\n\treturn (a->s6_addr32[0] | a->s6_addr32[1] |\n\t\ta->s6_addr32[2] | a->s6_addr32[3]) == 0;\n#endif\n}\n\nstatic inline u32 ipv6_addr_hash(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst unsigned long *ul = (const unsigned long *)a;\n\tunsigned long x = ul[0] ^ ul[1];\n\n\treturn (u32)(x ^ (x >> 32));\n#else\n\treturn (__force u32)(a->s6_addr32[0] ^ a->s6_addr32[1] ^\n\t\t\t     a->s6_addr32[2] ^ a->s6_addr32[3]);\n#endif\n}\n\n/* more secured version of ipv6_addr_hash() */\nstatic inline u32 __ipv6_addr_jhash(const struct in6_addr *a, const u32 initval)\n{\n\tu32 v = (__force u32)a->s6_addr32[0] ^ (__force u32)a->s6_addr32[1];\n\n\treturn jhash_3words(v,\n\t\t\t    (__force u32)a->s6_addr32[2],\n\t\t\t    (__force u32)a->s6_addr32[3],\n\t\t\t    initval);\n}\n\nstatic inline bool ipv6_addr_loopback(const struct in6_addr *a)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tconst __be64 *be = (const __be64 *)a;\n\n\treturn (be[0] | (be[1] ^ cpu_to_be64(1))) == 0UL;\n#else\n\treturn (a->s6_addr32[0] | a->s6_addr32[1] |\n\t\ta->s6_addr32[2] | (a->s6_addr32[3] ^ cpu_to_be32(1))) == 0;\n#endif\n}\n\n/*\n * Note that we must __force cast these to unsigned long to make sparse happy,\n * since all of the endian-annotated types are fixed size regardless of arch.\n */\nstatic inline bool ipv6_addr_v4mapped(const struct in6_addr *a)\n{\n\treturn (\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\t\t*(unsigned long *)a |\n#else\n\t\t(__force unsigned long)(a->s6_addr32[0] | a->s6_addr32[1]) |\n#endif\n\t\t(__force unsigned long)(a->s6_addr32[2] ^\n\t\t\t\t\tcpu_to_be32(0x0000ffff))) == 0UL;\n}\n\n/*\n * Check for a RFC 4843 ORCHID address\n * (Overlay Routable Cryptographic Hash Identifiers)\n */\nstatic inline bool ipv6_addr_orchid(const struct in6_addr *a)\n{\n\treturn (a->s6_addr32[0] & htonl(0xfffffff0)) == htonl(0x20010010);\n}\n\nstatic inline bool ipv6_addr_is_multicast(const struct in6_addr *addr)\n{\n\treturn (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);\n}\n\nstatic inline void ipv6_addr_set_v4mapped(const __be32 addr,\n\t\t\t\t\t  struct in6_addr *v4mapped)\n{\n\tipv6_addr_set(v4mapped,\n\t\t\t0, 0,\n\t\t\thtonl(0x0000FFFF),\n\t\t\taddr);\n}\n\n/*\n * find the first different bit between two addresses\n * length of address must be a multiple of 32bits\n */\nstatic inline int __ipv6_addr_diff32(const void *token1, const void *token2, int addrlen)\n{\n\tconst __be32 *a1 = token1, *a2 = token2;\n\tint i;\n\n\taddrlen >>= 2;\n\n\tfor (i = 0; i < addrlen; i++) {\n\t\t__be32 xb = a1[i] ^ a2[i];\n\t\tif (xb)\n\t\t\treturn i * 32 + 31 - __fls(ntohl(xb));\n\t}\n\n\t/*\n\t *\twe should *never* get to this point since that \n\t *\twould mean the addrs are equal\n\t *\n\t *\tHowever, we do get to it 8) And exacly, when\n\t *\taddresses are equal 8)\n\t *\n\t *\tip route add 1111::/128 via ...\n\t *\tip route add 1111::/64 via ...\n\t *\tand we are here.\n\t *\n\t *\tIdeally, this function should stop comparison\n\t *\tat prefix length. It does not, but it is still OK,\n\t *\tif returned value is greater than prefix length.\n\t *\t\t\t\t\t--ANK (980803)\n\t */\n\treturn addrlen << 5;\n}\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\nstatic inline int __ipv6_addr_diff64(const void *token1, const void *token2, int addrlen)\n{\n\tconst __be64 *a1 = token1, *a2 = token2;\n\tint i;\n\n\taddrlen >>= 3;\n\n\tfor (i = 0; i < addrlen; i++) {\n\t\t__be64 xb = a1[i] ^ a2[i];\n\t\tif (xb)\n\t\t\treturn i * 64 + 63 - __fls(be64_to_cpu(xb));\n\t}\n\n\treturn addrlen << 6;\n}\n#endif\n\nstatic inline int __ipv6_addr_diff(const void *token1, const void *token2, int addrlen)\n{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64\n\tif (__builtin_constant_p(addrlen) && !(addrlen & 7))\n\t\treturn __ipv6_addr_diff64(token1, token2, addrlen);\n#endif\n\treturn __ipv6_addr_diff32(token1, token2, addrlen);\n}\n\nstatic inline int ipv6_addr_diff(const struct in6_addr *a1, const struct in6_addr *a2)\n{\n\treturn __ipv6_addr_diff(a1, a2, sizeof(struct in6_addr));\n}\n\n__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr);\nvoid ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb);\n\nint ip6_dst_hoplimit(struct dst_entry *dst);\n\nstatic inline int ip6_sk_dst_hoplimit(struct ipv6_pinfo *np, struct flowi6 *fl6,\n\t\t\t\t      struct dst_entry *dst)\n{\n\tint hlimit;\n\n\tif (ipv6_addr_is_multicast(&fl6->daddr))\n\t\thlimit = np->mcast_hops;\n\telse\n\t\thlimit = np->hop_limit;\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\treturn hlimit;\n}\n\n/* copy IPv6 saddr & daddr to flow_keys, possibly using 64bit load/store\n * Equivalent to :\tflow->v6addrs.src = iph->saddr;\n *\t\t\tflow->v6addrs.dst = iph->daddr;\n */\nstatic inline void iph_to_flow_copy_v6addrs(struct flow_keys *flow,\n\t\t\t\t\t    const struct ipv6hdr *iph)\n{\n\tBUILD_BUG_ON(offsetof(typeof(flow->addrs), v6addrs.dst) !=\n\t\t     offsetof(typeof(flow->addrs), v6addrs.src) +\n\t\t     sizeof(flow->addrs.v6addrs.src));\n\tmemcpy(&flow->addrs.v6addrs, &iph->saddr, sizeof(flow->addrs.v6addrs));\n\tflow->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\n/* Sysctl settings for net ipv6.auto_flowlabels */\n#define IP6_AUTO_FLOW_LABEL_OFF\t\t0\n#define IP6_AUTO_FLOW_LABEL_OPTOUT\t1\n#define IP6_AUTO_FLOW_LABEL_OPTIN\t2\n#define IP6_AUTO_FLOW_LABEL_FORCED\t3\n\n#define IP6_AUTO_FLOW_LABEL_MAX\t\tIP6_AUTO_FLOW_LABEL_FORCED\n\n#define IP6_DEFAULT_AUTO_FLOW_LABELS\tIP6_AUTO_FLOW_LABEL_OPTOUT\n\nstatic inline __be32 ip6_make_flowlabel(struct net *net, struct sk_buff *skb,\n\t\t\t\t\t__be32 flowlabel, bool autolabel,\n\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tu32 hash;\n\n\tif (flowlabel ||\n\t    net->ipv6.sysctl.auto_flowlabels == IP6_AUTO_FLOW_LABEL_OFF ||\n\t    (!autolabel &&\n\t     net->ipv6.sysctl.auto_flowlabels != IP6_AUTO_FLOW_LABEL_FORCED))\n\t\treturn flowlabel;\n\n\thash = skb_get_hash_flowi6(skb, fl6);\n\n\t/* Since this is being sent on the wire obfuscate hash a bit\n\t * to minimize possbility that any useful information to an\n\t * attacker is leaked. Only lower 20 bits are relevant.\n\t */\n\trol32(hash, 16);\n\n\tflowlabel = (__force __be32)hash & IPV6_FLOWLABEL_MASK;\n\n\tif (net->ipv6.sysctl.flowlabel_state_ranges)\n\t\tflowlabel |= IPV6_FLOWLABEL_STATELESS_FLAG;\n\n\treturn flowlabel;\n}\n\nstatic inline int ip6_default_np_autolabel(struct net *net)\n{\n\tswitch (net->ipv6.sysctl.auto_flowlabels) {\n\tcase IP6_AUTO_FLOW_LABEL_OFF:\n\tcase IP6_AUTO_FLOW_LABEL_OPTIN:\n\tdefault:\n\t\treturn 0;\n\tcase IP6_AUTO_FLOW_LABEL_OPTOUT:\n\tcase IP6_AUTO_FLOW_LABEL_FORCED:\n\t\treturn 1;\n\t}\n}\n#else\nstatic inline void ip6_set_txhash(struct sock *sk) { }\nstatic inline __be32 ip6_make_flowlabel(struct net *net, struct sk_buff *skb,\n\t\t\t\t\t__be32 flowlabel, bool autolabel,\n\t\t\t\t\tstruct flowi6 *fl6)\n{\n\treturn flowlabel;\n}\nstatic inline int ip6_default_np_autolabel(struct net *net)\n{\n\treturn 0;\n}\n#endif\n\n\n/*\n *\tHeader manipulation\n */\nstatic inline void ip6_flow_hdr(struct ipv6hdr *hdr, unsigned int tclass,\n\t\t\t\t__be32 flowlabel)\n{\n\t*(__be32 *)hdr = htonl(0x60000000 | (tclass << 20)) | flowlabel;\n}\n\nstatic inline __be32 ip6_flowinfo(const struct ipv6hdr *hdr)\n{\n\treturn *(__be32 *)hdr & IPV6_FLOWINFO_MASK;\n}\n\nstatic inline __be32 ip6_flowlabel(const struct ipv6hdr *hdr)\n{\n\treturn *(__be32 *)hdr & IPV6_FLOWLABEL_MASK;\n}\n\nstatic inline u8 ip6_tclass(__be32 flowinfo)\n{\n\treturn ntohl(flowinfo & IPV6_TCLASS_MASK) >> IPV6_TCLASS_SHIFT;\n}\n/*\n *\tPrototypes exported by ipv6\n */\n\n/*\n *\trcv function (called from netdevice level)\n */\n\nint ipv6_rcv(struct sk_buff *skb, struct net_device *dev,\n\t     struct packet_type *pt, struct net_device *orig_dev);\n\nint ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb);\n\n/*\n *\tupper-layer output functions\n */\nint ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     struct ipv6_txoptions *opt, int tclass);\n\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr);\n\nint ip6_append_data(struct sock *sk,\n\t\t    int getfrag(void *from, char *to, int offset, int len,\n\t\t\t\tint odd, struct sk_buff *skb),\n\t\t    void *from, int length, int transhdrlen, int hlimit,\n\t\t    int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\t\t    struct rt6_info *rt, unsigned int flags, int dontfrag);\n\nint ip6_push_pending_frames(struct sock *sk);\n\nvoid ip6_flush_pending_frames(struct sock *sk);\n\nint ip6_send_skb(struct sk_buff *skb);\n\nstruct sk_buff *__ip6_make_skb(struct sock *sk, struct sk_buff_head *queue,\n\t\t\t       struct inet_cork_full *cork,\n\t\t\t       struct inet6_cork *v6_cork);\nstruct sk_buff *ip6_make_skb(struct sock *sk,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, int length, int transhdrlen,\n\t\t\t     int hlimit, int tclass, struct ipv6_txoptions *opt,\n\t\t\t     struct flowi6 *fl6, struct rt6_info *rt,\n\t\t\t     unsigned int flags, int dontfrag);\n\nstatic inline struct sk_buff *ip6_finish_skb(struct sock *sk)\n{\n\treturn __ip6_make_skb(sk, &sk->sk_write_queue, &inet_sk(sk)->cork,\n\t\t\t      &inet6_sk(sk)->cork);\n}\n\nint ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,\n\t\t   struct flowi6 *fl6);\nstruct dst_entry *ip6_dst_lookup_flow(const struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t      const struct in6_addr *final_dst);\nstruct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t\t const struct in6_addr *final_dst);\nstruct dst_entry *ip6_blackhole_route(struct net *net,\n\t\t\t\t      struct dst_entry *orig_dst);\n\n/*\n *\tskb processing functions\n */\n\nint ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb);\nint ip6_forward(struct sk_buff *skb);\nint ip6_input(struct sk_buff *skb);\nint ip6_mc_input(struct sk_buff *skb);\n\nint __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);\nint ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb);\n\n/*\n *\tExtension header (options) processing\n */\n\nvoid ipv6_push_nfrag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t  u8 *proto, struct in6_addr **daddr_p);\nvoid ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t u8 *proto);\n\nint ipv6_skip_exthdr(const struct sk_buff *, int start, u8 *nexthdrp,\n\t\t     __be16 *frag_offp);\n\nbool ipv6_ext_hdr(u8 nexthdr);\n\nenum {\n\tIP6_FH_F_FRAG\t\t= (1 << 0),\n\tIP6_FH_F_AUTH\t\t= (1 << 1),\n\tIP6_FH_F_SKIP_RH\t= (1 << 2),\n};\n\n/* find specified header and get offset to it */\nint ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset, int target,\n\t\t  unsigned short *fragoff, int *fragflg);\n\nint ipv6_find_tlv(struct sk_buff *skb, int offset, int type);\n\nstruct in6_addr *fl6_update_dst(struct flowi6 *fl6,\n\t\t\t\tconst struct ipv6_txoptions *opt,\n\t\t\t\tstruct in6_addr *orig);\n\n/*\n *\tsocket options (ipv6_sockglue.c)\n */\n\nint ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen);\nint ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen);\nint compat_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen);\nint compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen);\n\nint ip6_datagram_connect(struct sock *sk, struct sockaddr *addr, int addr_len);\nint ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *addr,\n\t\t\t\t int addr_len);\n\nint ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,\n\t\t    int *addr_len);\nint ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,\n\t\t     int *addr_len);\nvoid ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err, __be16 port,\n\t\t     u32 info, u8 *payload);\nvoid ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info);\nvoid ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu);\n\nint inet6_release(struct socket *sock);\nint inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len);\nint inet6_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len,\n\t\t  int peer);\nint inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);\n\nint inet6_hash_connect(struct inet_timewait_death_row *death_row,\n\t\t\t      struct sock *sk);\n\n/*\n * reassembly.c\n */\nextern const struct proto_ops inet6_stream_ops;\nextern const struct proto_ops inet6_dgram_ops;\n\nstruct group_source_req;\nstruct group_filter;\n\nint ip6_mc_source(int add, int omode, struct sock *sk,\n\t\t  struct group_source_req *pgsr);\nint ip6_mc_msfilter(struct sock *sk, struct group_filter *gsf);\nint ip6_mc_msfget(struct sock *sk, struct group_filter *gsf,\n\t\t  struct group_filter __user *optval, int __user *optlen);\n\n#ifdef CONFIG_PROC_FS\nint ac6_proc_init(struct net *net);\nvoid ac6_proc_exit(struct net *net);\nint raw6_proc_init(void);\nvoid raw6_proc_exit(void);\nint tcp6_proc_init(struct net *net);\nvoid tcp6_proc_exit(struct net *net);\nint udp6_proc_init(struct net *net);\nvoid udp6_proc_exit(struct net *net);\nint udplite6_proc_init(void);\nvoid udplite6_proc_exit(void);\nint ipv6_misc_proc_init(void);\nvoid ipv6_misc_proc_exit(void);\nint snmp6_register_dev(struct inet6_dev *idev);\nint snmp6_unregister_dev(struct inet6_dev *idev);\n\n#else\nstatic inline int ac6_proc_init(struct net *net) { return 0; }\nstatic inline void ac6_proc_exit(struct net *net) { }\nstatic inline int snmp6_register_dev(struct inet6_dev *idev) { return 0; }\nstatic inline int snmp6_unregister_dev(struct inet6_dev *idev) { return 0; }\n#endif\n\n#ifdef CONFIG_SYSCTL\nextern struct ctl_table ipv6_route_table_template[];\n\nstruct ctl_table *ipv6_icmp_sysctl_init(struct net *net);\nstruct ctl_table *ipv6_route_sysctl_init(struct net *net);\nint ipv6_sysctl_register(void);\nvoid ipv6_sysctl_unregister(void);\n#endif\n\nint ipv6_sock_mc_join(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\nint ipv6_sock_mc_drop(struct sock *sk, int ifindex,\n\t\t      const struct in6_addr *addr);\n#endif /* _NET_IPV6_H */\n", "/*\n *\tDCCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tBased on net/dccp6/ipv6.c\n *\n *\tArnaldo Carvalho de Melo <acme@ghostprotocols.net>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/xfrm.h>\n\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/inet_sock.h>\n#include <net/inet6_connection_sock.h>\n#include <net/inet6_hashtables.h>\n#include <net/ip6_route.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n#include <net/secure_seq.h>\n\n#include \"dccp.h\"\n#include \"ipv6.h\"\n#include \"feat.h\"\n\n/* The per-net dccp.v6_ctl_sk is used for sending RSTs and ACKs */\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops;\n\n/* add pseudo-header to DCCP checksum stored in skb->csum */\nstatic inline __sum16 dccp_v6_csum_finish(struct sk_buff *skb,\n\t\t\t\t      const struct in6_addr *saddr,\n\t\t\t\t      const struct in6_addr *daddr)\n{\n\treturn csum_ipv6_magic(saddr, daddr, skb->len, IPPROTO_DCCP, skb->csum);\n}\n\nstatic inline void dccp_v6_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\tdccp_csum_outgoing(skb);\n\tdh->dccph_checksum = dccp_v6_csum_finish(skb, &np->saddr, &sk->sk_v6_daddr);\n}\n\nstatic inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n\n}\n\nstatic void dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct dccp_hdr *dh = (struct dccp_hdr *)(skb->data + offset);\n\tstruct dccp_sock *dp;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tint err;\n\t__u64 seq;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->len < offset + sizeof(*dh) ||\n\t    skb->len < offset + __dccp_basic_hdr_len(dh)) {\n\t\tICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\n\t\t\t\t   ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tsk = __inet6_lookup_established(net, &dccp_hashinfo,\n\t\t\t\t\t&hdr->daddr, dh->dccph_dport,\n\t\t\t\t\t&hdr->saddr, ntohs(dh->dccph_sport),\n\t\t\t\t\tinet6_iif(skb));\n\n\tif (!sk) {\n\t\tICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\n\t\t\t\t   ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = dccp_hdr_seq(dh);\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV)\n\t\treturn dccp_req_err(sk, seq);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk))\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == DCCP_CLOSED)\n\t\tgoto out;\n\n\tdp = dccp_sk(sk);\n\tif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_LISTEN) &&\n\t    !between48(seq, dp->dccps_awl, dp->dccps_awh)) {\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\tif (dst)\n\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tstruct dst_entry *dst = NULL;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\tif (sock_owned_by_user(sk))\n\t\t\tgoto out;\n\t\tif ((1 << sk->sk_state) & (DCCPF_LISTEN | DCCPF_CLOSED))\n\t\t\tgoto out;\n\n\t\tdst = inet6_csk_update_pmtu(sk, ntohl(info));\n\t\tif (!dst)\n\t\t\tgoto out;\n\n\t\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst))\n\t\t\tdccp_sync_mss(sk, dst_mtu(dst));\n\t\tgoto out;\n\t}\n\n\ticmpv6_err_convert(type, code, &err);\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\tcase DCCP_RESPOND:  /* Cannot happen.\n\t\t\t       It can, it SYNs are crossed. --ANK */\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tDCCP_INC_STATS_BH(DCCP_MIB_ATTEMPTFAILS);\n\t\t\tsk->sk_err = err;\n\t\t\t/*\n\t\t\t * Wake people up to see the error\n\t\t\t * (see connect in sock.c)\n\t\t\t */\n\t\t\tsk->sk_error_report(sk);\n\t\t\tdccp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\trcu_read_lock();\n\t\terr = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),\n\t\t\t       np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic void dccp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tdccp_feat_list_purge(&dccp_rsk(req)->dreq_featneg);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\nstatic void dccp_v6_ctl_send_reset(const struct sock *sk, struct sk_buff *rxskb)\n{\n\tconst struct ipv6hdr *rxip6h;\n\tstruct sk_buff *skb;\n\tstruct flowi6 fl6;\n\tstruct net *net = dev_net(skb_dst(rxskb)->dev);\n\tstruct sock *ctl_sk = net->dccp.v6_ctl_sk;\n\tstruct dst_entry *dst;\n\n\tif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\n\t\treturn;\n\n\tif (!ipv6_unicast_destination(rxskb))\n\t\treturn;\n\n\tskb = dccp_ctl_make_reset(ctl_sk, rxskb);\n\tif (skb == NULL)\n\t\treturn;\n\n\trxip6h = ipv6_hdr(rxskb);\n\tdccp_hdr(skb)->dccph_checksum = dccp_v6_csum_finish(skb, &rxip6h->saddr,\n\t\t\t\t\t\t\t    &rxip6h->daddr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = rxip6h->saddr;\n\tfl6.saddr = rxip6h->daddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.flowi6_oif = inet6_iif(rxskb);\n\tfl6.fl6_dport = dccp_hdr(skb)->dccph_dport;\n\tfl6.fl6_sport = dccp_hdr(skb)->dccph_sport;\n\tsecurity_skb_classify_flow(rxskb, flowi6_to_flowi(&fl6));\n\n\t/* sk = NULL, but it is safe for now. RST socket required. */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(skb, dst);\n\t\tip6_xmit(ctl_sk, skb, &fl6, NULL, 0);\n\t\tDCCP_INC_STATS_BH(DCCP_MIB_OUTSEGS);\n\t\tDCCP_INC_STATS_BH(DCCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic struct request_sock_ops dccp6_request_sock_ops = {\n\t.family\t\t= AF_INET6,\n\t.obj_size\t= sizeof(struct dccp6_request_sock),\n\t.rtx_syn_ack\t= dccp_v6_send_response,\n\t.send_ack\t= dccp_reqsk_send_ack,\n\t.destructor\t= dccp_v6_reqsk_destructor,\n\t.send_reset\t= dccp_v6_ctl_send_reset,\n\t.syn_ack_timeout = dccp_syn_ack_timeout,\n};\n\nstatic int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct request_sock *req;\n\tstruct dccp_request_sock *dreq;\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tconst __be32 service = dccp_hdr_request(skb)->dccph_req_service;\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\treturn 0;\t/* discard, don't send a reset here */\n\n\tif (dccp_bad_service_code(sk, service)) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_BAD_SERVICE_CODE;\n\t\tgoto drop;\n\t}\n\t/*\n\t * There are no SYN attacks on IPv6, yet...\n\t */\n\tdcb->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\n\tif (inet_csk_reqsk_queue_is_full(sk))\n\t\tgoto drop;\n\n\tif (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1)\n\t\tgoto drop;\n\n\treq = inet_reqsk_alloc(&dccp6_request_sock_ops, sk, true);\n\tif (req == NULL)\n\t\tgoto drop;\n\n\tif (dccp_reqsk_init(req, dccp_sk(sk), skb))\n\t\tgoto drop_and_free;\n\n\tdreq = dccp_rsk(req);\n\tif (dccp_parse_options(sk, dreq, skb))\n\t\tgoto drop_and_free;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\tireq = inet_rsk(req);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tireq->ireq_family = AF_INET6;\n\n\tif (ipv6_opt_accepted(sk, skb, IP6CB(skb)) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = inet6_iif(skb);\n\n\t/*\n\t * Step 3: Process LISTEN state\n\t *\n\t *   Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookie\n\t *\n\t * Setting S.SWL/S.SWH to is deferred to dccp_create_openreq_child().\n\t */\n\tdreq->dreq_isr\t   = dcb->dccpd_seq;\n\tdreq->dreq_gsr     = dreq->dreq_isr;\n\tdreq->dreq_iss\t   = dccp_v6_init_sequence(skb);\n\tdreq->dreq_gss     = dreq->dreq_iss;\n\tdreq->dreq_service = service;\n\n\tif (dccp_v6_send_response(sk, req))\n\t\tgoto drop_and_free;\n\n\tinet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);\n\treturn 0;\n\ndrop_and_free:\n\treqsk_free(req);\ndrop:\n\tDCCP_INC_STATS_BH(DCCP_MIB_ATTEMPTFAILS);\n\treturn -1;\n}\n\nstatic struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst,\n\t\t\t\t\t      struct request_sock *req_unhash,\n\t\t\t\t\t      bool *own_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t  req_unhash, own_req);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;\n\tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if\t= ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\tdccp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\t/* Clone pktoptions received with SYN, if we own the req */\n\tif (*own_req && ireq->pktopts) {\n\t\tnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);\n\t\tconsume_skb(ireq->pktopts);\n\t\tireq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n\n/* The socket must have it's spinlock held when we get\n * here.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, dccp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   dccp_v6_hnd_req and dccp_v6_ctl_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t * socket locking is here for SMP purposes as backlog rcv is currently\n\t * called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t/*\n\t * FIXME: Add handling of IPV6_PKTOPTIONS skb. See the comments below\n\t *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.\n\t */\n\t\topt_skb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (sk->sk_state == DCCP_OPEN) { /* Fast path */\n\t\tif (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))\n\t\t\tgoto reset;\n\t\tif (opt_skb) {\n\t\t\t/* XXX This is where we would goto ipv6_pktoptions. */\n\t\t\t__kfree_skb(opt_skb);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies\n\t *\t      Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t *\n\t * NOTE: the check for the packet types is done in\n\t *\t dccp_rcv_state_process\n\t */\n\n\tif (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))\n\t\tgoto reset;\n\tif (opt_skb) {\n\t\t/* XXX This is where we would goto ipv6_pktoptions. */\n\t\t__kfree_skb(opt_skb);\n\t}\n\treturn 0;\n\nreset:\n\tdccp_v6_ctl_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb != NULL)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int dccp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t/* Step 1: Check header basics */\n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\t/* Step 1: If header checksum is incorrect, drop packet and return. */\n\tif (dccp_v6_csum_finish(skb, &ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr)) {\n\t\tDCCP_WARN(\"dropped packet with invalid checksum\\n\");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tif (dccp_packet_without_ack(skb))\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\telse\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&dccp_hashinfo, skb,\n\t\t\t        dh->dccph_sport, dh->dccph_dport,\n\t\t\t\tinet6_iif(skb));\n\tif (!sk) {\n\t\tdccp_pr_debug(\"failed to look up flow ID in table and \"\n\t\t\t      \"get corresponding socket\\n\");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t/*\n\t * Step 2:\n\t *\t... or S.state == TIMEWAIT,\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug(\"sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n\");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk = NULL;\n\n\t\tsk = req->rsk_listener;\n\t\tif (likely(sk->sk_state == DCCP_LISTEN)) {\n\t\t\tnsk = dccp_check_req(sk, skb, req);\n\t\t} else {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\tsock_hold(sk);\n\t\t\treqsk_put(req);\n\t\t} else if (dccp_child_process(sk, nsk, skb)) {\n\t\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t\t\tgoto discard_it;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * RFC 4340, sec. 9.2.1: Minimum Checksum Coverage\n\t *\to if MinCsCov = 0, only packets with CsCov = 0 are accepted\n\t *\to if MinCsCov > 0, also accept packets with CsCov >= MinCsCov\n\t */\n\tmin_cov = dccp_sk(sk)->dccps_pcrlen;\n\tif (dh->dccph_cscov  &&  (min_cov == 0 || dh->dccph_cscov < min_cov))  {\n\t\tdccp_pr_debug(\"Packet CsCov %d does not satisfy MinCsCov %d\\n\",\n\t\t\t      dh->dccph_cscov, min_cov);\n\t\t/* FIXME: send Data Dropped option (see also dccp_v4_rcv) */\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\treturn sk_receive_skb(sk, skb, 1) ? -1 : 0;\n\nno_dccp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\t/*\n\t * Step 2:\n\t *\tIf no socket ...\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type != DCCP_PKT_RESET) {\n\t\tDCCP_SKB_CB(skb)->dccpd_reset_code =\n\t\t\t\t\tDCCP_RESET_CODE_NO_CONNECTION;\n\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsock_put(sk);\n\tgoto discard_it;\n}\n\nstatic int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t   int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *)uaddr;\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\t/*\n\t * connect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t * DCCP over IPv4\n\t */\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\n\t\terr = dccp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &dccp_ipv6_af_ops;\n\t\t\tsk->sk_backlog_rcv = dccp_v6_do_rcv;\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (saddr == NULL) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\t__ip6_dst_store(sk, dst, NULL, NULL);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\n\tinet->inet_dport = usin->sin6_port;\n\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet6_hash_connect(&dccp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tdp->dccps_iss = secure_dccpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t      sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t      inet->inet_sport,\n\t\t\t\t\t\t      inet->inet_dport);\n\terr = dccp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\tdccp_set_state(sk, DCCP_CLOSED);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = dccp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\n/*\n *\tDCCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = dccp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int dccp_v6_init_sock(struct sock *sk)\n{\n\tstatic __u8 dccp_v6_ctl_sock_initialized;\n\tint err = dccp_init_sock(sk, dccp_v6_ctl_sock_initialized);\n\n\tif (err == 0) {\n\t\tif (unlikely(!dccp_v6_ctl_sock_initialized))\n\t\t\tdccp_v6_ctl_sock_initialized = 1;\n\t\tinet_csk(sk)->icsk_af_ops = &dccp_ipv6_af_ops;\n\t}\n\n\treturn err;\n}\n\nstatic void dccp_v6_destroy_sock(struct sock *sk)\n{\n\tdccp_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\nstatic struct timewait_sock_ops dccp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct dccp6_timewait_sock),\n};\n\nstatic struct proto dccp_v6_prot = {\n\t.name\t\t   = \"DCCPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = dccp_close,\n\t.connect\t   = dccp_v6_connect,\n\t.disconnect\t   = dccp_disconnect,\n\t.ioctl\t\t   = dccp_ioctl,\n\t.init\t\t   = dccp_v6_init_sock,\n\t.setsockopt\t   = dccp_setsockopt,\n\t.getsockopt\t   = dccp_getsockopt,\n\t.sendmsg\t   = dccp_sendmsg,\n\t.recvmsg\t   = dccp_recvmsg,\n\t.backlog_rcv\t   = dccp_v6_do_rcv,\n\t.hash\t\t   = inet_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.accept\t\t   = inet_csk_accept,\n\t.get_port\t   = inet_csk_get_port,\n\t.shutdown\t   = dccp_shutdown,\n\t.destroy\t   = dccp_v6_destroy_sock,\n\t.orphan_count\t   = &dccp_orphan_count,\n\t.max_header\t   = MAX_DCCP_HEADER,\n\t.obj_size\t   = sizeof(struct dccp6_sock),\n\t.slab_flags\t   = SLAB_DESTROY_BY_RCU,\n\t.rsk_prot\t   = &dccp6_request_sock_ops,\n\t.twsk_prot\t   = &dccp6_timewait_sock_ops,\n\t.h.hashinfo\t   = &dccp_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_dccp_setsockopt,\n\t.compat_getsockopt = compat_dccp_getsockopt,\n#endif\n};\n\nstatic const struct inet6_protocol dccp_v6_protocol = {\n\t.handler\t= dccp_v6_rcv,\n\t.err_handler\t= dccp_v6_err,\n\t.flags\t\t= INET6_PROTO_NOPOLICY | INET6_PROTO_FINAL,\n};\n\nstatic const struct proto_ops inet6_dccp_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = dccp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = inet_dccp_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw dccp_v6_protosw = {\n\t.type\t\t= SOCK_DCCP,\n\t.protocol\t= IPPROTO_DCCP,\n\t.prot\t\t= &dccp_v6_prot,\n\t.ops\t\t= &inet6_dccp_ops,\n\t.flags\t\t= INET_PROTOSW_ICSK,\n};\n\nstatic int __net_init dccp_v6_init_net(struct net *net)\n{\n\tif (dccp_hashinfo.bhash == NULL)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\treturn inet_ctl_sock_create(&net->dccp.v6_ctl_sk, PF_INET6,\n\t\t\t\t    SOCK_DCCP, IPPROTO_DCCP, net);\n}\n\nstatic void __net_exit dccp_v6_exit_net(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->dccp.v6_ctl_sk);\n}\n\nstatic struct pernet_operations dccp_v6_ops = {\n\t.init   = dccp_v6_init_net,\n\t.exit   = dccp_v6_exit_net,\n};\n\nstatic int __init dccp_v6_init(void)\n{\n\tint err = proto_register(&dccp_v6_prot, 1);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tif (err != 0)\n\t\tgoto out_unregister_proto;\n\n\tinet6_register_protosw(&dccp_v6_protosw);\n\n\terr = register_pernet_subsys(&dccp_v6_ops);\n\tif (err != 0)\n\t\tgoto out_destroy_ctl_sock;\nout:\n\treturn err;\n\nout_destroy_ctl_sock:\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\nout_unregister_proto:\n\tproto_unregister(&dccp_v6_prot);\n\tgoto out;\n}\n\nstatic void __exit dccp_v6_exit(void)\n{\n\tunregister_pernet_subsys(&dccp_v6_ops);\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\n\tproto_unregister(&dccp_v6_prot);\n}\n\nmodule_init(dccp_v6_init);\nmodule_exit(dccp_v6_exit);\n\n/*\n * __stringify doesn't likes enums, so use SOCK_DCCP (6) and IPPROTO_DCCP (33)\n * values directly, Also cover the case where the protocol is not specified,\n * i.e. net-pf-PF_INET6-proto-0-type-SOCK_DCCP\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 33, 6);\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 0, 6);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arnaldo Carvalho de Melo <acme@mandriva.com>\");\nMODULE_DESCRIPTION(\"DCCPv6 - Datagram Congestion Controlled Protocol\");\n", "/*\n *\tPF_INET6 socket protocol family\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tAdapted from linux/net/ipv4/af_inet.c\n *\n *\tFixes:\n *\tpiggy, Karl Knutson\t:\tSocket protocol table\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tArnaldo Melo\t\t:\tcheck proc_net_create return, cleanups\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/icmpv6.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <net/tcp.h>\n#include <net/ping.h>\n#include <net/protocol.h>\n#include <net/inet_common.h>\n#include <net/route.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/ndisc.h>\n#ifdef CONFIG_IPV6_TUNNEL\n#include <net/ip6_tunnel.h>\n#endif\n\n#include <asm/uaccess.h>\n#include <linux/mroute6.h>\n\nMODULE_AUTHOR(\"Cast of dozens\");\nMODULE_DESCRIPTION(\"IPv6 protocol stack for Linux\");\nMODULE_LICENSE(\"GPL\");\n\n/* The inetsw6 table contains everything that inet6_create needs to\n * build a new socket.\n */\nstatic struct list_head inetsw6[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw6_lock);\n\nstruct ipv6_params ipv6_defaults = {\n\t.disable_ipv6 = 0,\n\t.autoconf = 1,\n};\n\nstatic int disable_ipv6_mod;\n\nmodule_param_named(disable, disable_ipv6_mod, int, 0444);\nMODULE_PARM_DESC(disable, \"Disable IPv6 module such that it is non-functional\");\n\nmodule_param_named(disable_ipv6, ipv6_defaults.disable_ipv6, int, 0444);\nMODULE_PARM_DESC(disable_ipv6, \"Disable IPv6 on all interfaces\");\n\nmodule_param_named(autoconf, ipv6_defaults.autoconf, int, 0444);\nMODULE_PARM_DESC(autoconf, \"Enable IPv6 address autoconfiguration on all interfaces\");\n\nstatic __inline__ struct ipv6_pinfo *inet6_sk_generic(struct sock *sk)\n{\n\tconst int offset = sk->sk_prot->obj_size - sizeof(struct ipv6_pinfo);\n\n\treturn (struct ipv6_pinfo *)(((u8 *)sk) + offset);\n}\n\nstatic int inet6_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct inet_sock *inet;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tstruct inet_protosw *answer;\n\tstruct proto *answer_prot;\n\tunsigned char answer_flags;\n\tint try_loading_module = 0;\n\tint err;\n\n\t/* Look for the requested type/protocol pair. */\nlookup_protocol:\n\terr = -ESOCKTNOSUPPORT;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(answer, &inetsw6[sock->type], list) {\n\n\t\terr = 0;\n\t\t/* Check the non-wild match. */\n\t\tif (protocol == answer->protocol) {\n\t\t\tif (protocol != IPPROTO_IP)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Check for the two wild cases. */\n\t\t\tif (IPPROTO_IP == protocol) {\n\t\t\t\tprotocol = answer->protocol;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IPPROTO_IP == answer->protocol)\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\n\tif (err) {\n\t\tif (try_loading_module < 2) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * Be more specific, e.g. net-pf-10-proto-132-type-1\n\t\t\t * (net-pf-PF_INET6-proto-IPPROTO_SCTP-type-SOCK_STREAM)\n\t\t\t */\n\t\t\tif (++try_loading_module == 1)\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",\n\t\t\t\t\t\tPF_INET6, protocol, sock->type);\n\t\t\t/*\n\t\t\t * Fall back to generic, e.g. net-pf-10-proto-132\n\t\t\t * (net-pf-PF_INET6-proto-IPPROTO_SCTP)\n\t\t\t */\n\t\t\telse\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",\n\t\t\t\t\t\tPF_INET6, protocol);\n\t\t\tgoto lookup_protocol;\n\t\t} else\n\t\t\tgoto out_rcu_unlock;\n\t}\n\n\terr = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern &&\n\t    !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\tgoto out_rcu_unlock;\n\n\tsock->ops = answer->ops;\n\tanswer_prot = answer->prot;\n\tanswer_flags = answer->flags;\n\trcu_read_unlock();\n\n\tWARN_ON(!answer_prot->slab);\n\n\terr = -ENOBUFS;\n\tsk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\terr = 0;\n\tif (INET_PROTOSW_REUSE & answer_flags)\n\t\tsk->sk_reuse = SK_CAN_REUSE;\n\n\tinet = inet_sk(sk);\n\tinet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;\n\n\tif (SOCK_RAW == sock->type) {\n\t\tinet->inet_num = protocol;\n\t\tif (IPPROTO_RAW == protocol)\n\t\t\tinet->hdrincl = 1;\n\t}\n\n\tsk->sk_destruct\t\t= inet_sock_destruct;\n\tsk->sk_family\t\t= PF_INET6;\n\tsk->sk_protocol\t\t= protocol;\n\n\tsk->sk_backlog_rcv\t= answer->prot->backlog_rcv;\n\n\tinet_sk(sk)->pinet6 = np = inet6_sk_generic(sk);\n\tnp->hop_limit\t= -1;\n\tnp->mcast_hops\t= IPV6_DEFAULT_MCASTHOPS;\n\tnp->mc_loop\t= 1;\n\tnp->pmtudisc\t= IPV6_PMTUDISC_WANT;\n\tnp->autoflowlabel = ip6_default_np_autolabel(sock_net(sk));\n\tsk->sk_ipv6only\t= net->ipv6.sysctl.bindv6only;\n\n\t/* Init the ipv4 part of the socket since we can have sockets\n\t * using v6 API for ipv4.\n\t */\n\tinet->uc_ttl\t= -1;\n\n\tinet->mc_loop\t= 1;\n\tinet->mc_ttl\t= 1;\n\tinet->mc_index\t= 0;\n\tinet->mc_list\t= NULL;\n\tinet->rcv_tos\t= 0;\n\n\tif (net->ipv4.sysctl_ip_no_pmtu_disc)\n\t\tinet->pmtudisc = IP_PMTUDISC_DONT;\n\telse\n\t\tinet->pmtudisc = IP_PMTUDISC_WANT;\n\t/*\n\t * Increment only the relevant sk_prot->socks debug field, this changes\n\t * the previous behaviour of incrementing both the equivalent to\n\t * answer->prot->socks (inet6_sock_nr) and inet_sock_nr.\n\t *\n\t * This allows better debug granularity as we'll know exactly how many\n\t * UDPv6, TCPv6, etc socks were allocated, not the sum of all IPv6\n\t * transport protocol socks. -acme\n\t */\n\tsk_refcnt_debug_inc(sk);\n\n\tif (inet->inet_num) {\n\t\t/* It assumes that any protocol which allows\n\t\t * the user to assign a number at socket\n\t\t * creation time automatically shares.\n\t\t */\n\t\tinet->inet_sport = htons(inet->inet_num);\n\t\tsk->sk_prot->hash(sk);\n\t}\n\tif (sk->sk_prot->init) {\n\t\terr = sk->sk_prot->init(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn err;\nout_rcu_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\n\n\n/* bind for INET6 API */\nint inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tunsigned short snum;\n\tint addr_type = 0;\n\tint err = 0;\n\n\t/* If the socket has its own bind function then use it. */\n\tif (sk->sk_prot->bind)\n\t\treturn sk->sk_prot->bind(sk, uaddr, addr_len);\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (addr->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\tif ((addr_type & IPV6_ADDR_MULTICAST) && sock->type == SOCK_STREAM)\n\t\treturn -EINVAL;\n\n\tsnum = ntohs(addr->sin6_port);\n\tif (snum && snum < PROT_SOCK && !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\tlock_sock(sk);\n\n\t/* Check these errors (active socket, double bind). */\n\tif (sk->sk_state != TCP_CLOSE || inet->inet_num) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if the address belongs to the host. */\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tint chk_addr_ret;\n\n\t\t/* Binding to v4-mapped address on a v6-only socket\n\t\t * makes no sense\n\t\t */\n\t\tif (sk->sk_ipv6only) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Reproduce AF_INET checks to make the bindings consistent */\n\t\tv4addr = addr->sin6_addr.s6_addr32[3];\n\t\tchk_addr_ret = inet_addr_type(net, v4addr);\n\t\tif (!net->ipv4.sysctl_ip_nonlocal_bind &&\n\t\t    !(inet->freebind || inet->transparent) &&\n\t\t    v4addr != htonl(INADDR_ANY) &&\n\t\t    chk_addr_ret != RTN_LOCAL &&\n\t\t    chk_addr_ret != RTN_MULTICAST &&\n\t\t    chk_addr_ret != RTN_BROADCAST) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (addr_type != IPV6_ADDR_ANY) {\n\t\t\tstruct net_device *dev = NULL;\n\n\t\t\trcu_read_lock();\n\t\t\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t\t    addr->sin6_scope_id) {\n\t\t\t\t\t/* Override any existing binding, if another one\n\t\t\t\t\t * is supplied by user.\n\t\t\t\t\t */\n\t\t\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n\t\t\t\t}\n\n\t\t\t\t/* Binding to link-local address requires an interface */\n\t\t\t\tif (!sk->sk_bound_dev_if) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\tdev = dev_get_by_index_rcu(net, sk->sk_bound_dev_if);\n\t\t\t\tif (!dev) {\n\t\t\t\t\terr = -ENODEV;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t\t */\n\t\t\tv4addr = LOOPBACK4_IPV6;\n\t\t\tif (!(addr_type & IPV6_ADDR_MULTICAST))\t{\n\t\t\t\tif (!net->ipv6.sysctl.ip_nonlocal_bind &&\n\t\t\t\t    !(inet->freebind || inet->transparent) &&\n\t\t\t\t    !ipv6_chk_addr(net, &addr->sin6_addr,\n\t\t\t\t\t\t   dev, 0)) {\n\t\t\t\t\terr = -EADDRNOTAVAIL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n\n\tinet->inet_rcv_saddr = v4addr;\n\tinet->inet_saddr = v4addr;\n\n\tsk->sk_v6_rcv_saddr = addr->sin6_addr;\n\n\tif (!(addr_type & IPV6_ADDR_MULTICAST))\n\t\tnp->saddr = addr->sin6_addr;\n\n\t/* Make sure we are allowed to bind here. */\n\tif ((snum || !inet->bind_address_no_port) &&\n\t    sk->sk_prot->get_port(sk, snum)) {\n\t\tinet_reset_saddr(sk);\n\t\terr = -EADDRINUSE;\n\t\tgoto out;\n\t}\n\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n\t\tif (addr_type != IPV6_ADDR_MAPPED)\n\t\t\tsk->sk_ipv6only = 1;\n\t}\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tinet->inet_sport = htons(inet->inet_num);\n\tinet->inet_dport = 0;\n\tinet->inet_daddr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\nout_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\nEXPORT_SYMBOL(inet6_bind);\n\nint inet6_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\treturn -EINVAL;\n\n\t/* Free mc lists */\n\tipv6_sock_mc_close(sk);\n\n\t/* Free ac lists */\n\tipv6_sock_ac_close(sk);\n\n\treturn inet_release(sock);\n}\nEXPORT_SYMBOL(inet6_release);\n\nvoid inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\t/* Release rx options */\n\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\t/* Free flowlabels */\n\tfl6_free_socklist(sk);\n\n\t/* Free tx options */\n\n\topt = xchg((__force struct ipv6_txoptions **)&np->opt, NULL);\n\tif (opt) {\n\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\ttxopt_put(opt);\n\t}\n}\nEXPORT_SYMBOL_GPL(inet6_destroy_sock);\n\n/*\n *\tThis does both peername and sockname.\n */\n\nint inet6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_in6 *sin = (struct sockaddr_in6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\tsin->sin6_family = AF_INET6;\n\tsin->sin6_flowinfo = 0;\n\tsin->sin6_scope_id = 0;\n\tif (peer) {\n\t\tif (!inet->inet_dport)\n\t\t\treturn -ENOTCONN;\n\t\tif (((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_SYN_SENT)) &&\n\t\t    peer == 1)\n\t\t\treturn -ENOTCONN;\n\t\tsin->sin6_port = inet->inet_dport;\n\t\tsin->sin6_addr = sk->sk_v6_daddr;\n\t\tif (np->sndflow)\n\t\t\tsin->sin6_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\tsin->sin6_addr = np->saddr;\n\t\telse\n\t\t\tsin->sin6_addr = sk->sk_v6_rcv_saddr;\n\n\t\tsin->sin6_port = inet->inet_sport;\n\t}\n\tsin->sin6_scope_id = ipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t sk->sk_bound_dev_if);\n\t*uaddr_len = sizeof(*sin);\n\treturn 0;\n}\nEXPORT_SYMBOL(inet6_getname);\n\nint inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tswitch (cmd) {\n\tcase SIOCGSTAMP:\n\t\treturn sock_get_timestamp(sk, (struct timeval __user *)arg);\n\n\tcase SIOCGSTAMPNS:\n\t\treturn sock_get_timestampns(sk, (struct timespec __user *)arg);\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\n\t\treturn ipv6_route_ioctl(net, cmd, (void __user *)arg);\n\n\tcase SIOCSIFADDR:\n\t\treturn addrconf_add_ifaddr(net, (void __user *) arg);\n\tcase SIOCDIFADDR:\n\t\treturn addrconf_del_ifaddr(net, (void __user *) arg);\n\tcase SIOCSIFDSTADDR:\n\t\treturn addrconf_set_dstaddr(net, (void __user *) arg);\n\tdefault:\n\t\tif (!sk->sk_prot->ioctl)\n\t\t\treturn -ENOIOCTLCMD;\n\t\treturn sk->sk_prot->ioctl(sk, cmd, arg);\n\t}\n\t/*NOTREACHED*/\n\treturn 0;\n}\nEXPORT_SYMBOL(inet6_ioctl);\n\nconst struct proto_ops inet6_stream_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_stream_connect,\t/* ok\t\t*/\n\t.socketpair\t   = sock_no_socketpair,\t/* a do nothing\t*/\n\t.accept\t\t   = inet_accept,\t\t/* ok\t\t*/\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = tcp_poll,\t\t\t/* ok\t\t*/\n\t.ioctl\t\t   = inet6_ioctl,\t\t/* must change  */\n\t.listen\t\t   = inet_listen,\t\t/* ok\t\t*/\n\t.shutdown\t   = inet_shutdown,\t\t/* ok\t\t*/\n\t.setsockopt\t   = sock_common_setsockopt,\t/* ok\t\t*/\n\t.getsockopt\t   = sock_common_getsockopt,\t/* ok\t\t*/\n\t.sendmsg\t   = inet_sendmsg,\t\t/* ok\t\t*/\n\t.recvmsg\t   = inet_recvmsg,\t\t/* ok\t\t*/\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = inet_sendpage,\n\t.splice_read\t   = tcp_splice_read,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nconst struct proto_ops inet6_dgram_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\t/* ok\t\t*/\n\t.socketpair\t   = sock_no_socketpair,\t/* a do nothing\t*/\n\t.accept\t\t   = sock_no_accept,\t\t/* a do nothing\t*/\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = udp_poll,\t\t\t/* ok\t\t*/\n\t.ioctl\t\t   = inet6_ioctl,\t\t/* must change  */\n\t.listen\t\t   = sock_no_listen,\t\t/* ok\t\t*/\n\t.shutdown\t   = inet_shutdown,\t\t/* ok\t\t*/\n\t.setsockopt\t   = sock_common_setsockopt,\t/* ok\t\t*/\n\t.getsockopt\t   = sock_common_getsockopt,\t/* ok\t\t*/\n\t.sendmsg\t   = inet_sendmsg,\t\t/* ok\t\t*/\n\t.recvmsg\t   = inet_recvmsg,\t\t/* ok\t\t*/\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic const struct net_proto_family inet6_family_ops = {\n\t.family = PF_INET6,\n\t.create = inet6_create,\n\t.owner\t= THIS_MODULE,\n};\n\nint inet6_register_protosw(struct inet_protosw *p)\n{\n\tstruct list_head *lh;\n\tstruct inet_protosw *answer;\n\tstruct list_head *last_perm;\n\tint protocol = p->protocol;\n\tint ret;\n\n\tspin_lock_bh(&inetsw6_lock);\n\n\tret = -EINVAL;\n\tif (p->type >= SOCK_MAX)\n\t\tgoto out_illegal;\n\n\t/* If we are trying to override a permanent protocol, bail. */\n\tanswer = NULL;\n\tret = -EPERM;\n\tlast_perm = &inetsw6[p->type];\n\tlist_for_each(lh, &inetsw6[p->type]) {\n\t\tanswer = list_entry(lh, struct inet_protosw, list);\n\n\t\t/* Check only the non-wild match. */\n\t\tif (INET_PROTOSW_PERMANENT & answer->flags) {\n\t\t\tif (protocol == answer->protocol)\n\t\t\t\tbreak;\n\t\t\tlast_perm = lh;\n\t\t}\n\n\t\tanswer = NULL;\n\t}\n\tif (answer)\n\t\tgoto out_permanent;\n\n\t/* Add the new entry after the last permanent entry if any, so that\n\t * the new entry does not override a permanent entry when matched with\n\t * a wild-card protocol. But it is allowed to override any existing\n\t * non-permanent entry.  This means that when we remove this entry, the\n\t * system automatically returns to the old behavior.\n\t */\n\tlist_add_rcu(&p->list, last_perm);\n\tret = 0;\nout:\n\tspin_unlock_bh(&inetsw6_lock);\n\treturn ret;\n\nout_permanent:\n\tpr_err(\"Attempt to override permanent protocol %d\\n\", protocol);\n\tgoto out;\n\nout_illegal:\n\tpr_err(\"Ignoring attempt to register invalid socket type %d\\n\",\n\t       p->type);\n\tgoto out;\n}\nEXPORT_SYMBOL(inet6_register_protosw);\n\nvoid\ninet6_unregister_protosw(struct inet_protosw *p)\n{\n\tif (INET_PROTOSW_PERMANENT & p->flags) {\n\t\tpr_err(\"Attempt to unregister permanent protocol %d\\n\",\n\t\t       p->protocol);\n\t} else {\n\t\tspin_lock_bh(&inetsw6_lock);\n\t\tlist_del_rcu(&p->list);\n\t\tspin_unlock_bh(&inetsw6_lock);\n\n\t\tsynchronize_net();\n\t}\n}\nEXPORT_SYMBOL(inet6_unregister_protosw);\n\nint inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tfl6.fl6_sport = inet->inet_sport;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\t\trcu_read_lock();\n\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt),\n\t\t\t\t\t &final);\n\t\trcu_read_unlock();\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\n\t\t__ip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(inet6_sk_rebuild_header);\n\nbool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb,\n\t\t       const struct inet6_skb_parm *opt)\n{\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\n\tif (np->rxopt.all) {\n\t\tif (((opt->flags & IP6SKB_HOPBYHOP) &&\n\t\t     (np->rxopt.bits.hopopts || np->rxopt.bits.ohopopts)) ||\n\t\t    (ip6_flowinfo((struct ipv6hdr *) skb_network_header(skb)) &&\n\t\t     np->rxopt.bits.rxflow) ||\n\t\t    (opt->srcrt && (np->rxopt.bits.srcrt ||\n\t\t     np->rxopt.bits.osrcrt)) ||\n\t\t    ((opt->dst1 || opt->dst0) &&\n\t\t     (np->rxopt.bits.dstopts || np->rxopt.bits.odstopts)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(ipv6_opt_accepted);\n\nstatic struct packet_type ipv6_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_IPV6),\n\t.func = ipv6_rcv,\n};\n\nstatic int __init ipv6_packet_init(void)\n{\n\tdev_add_pack(&ipv6_packet_type);\n\treturn 0;\n}\n\nstatic void ipv6_packet_cleanup(void)\n{\n\tdev_remove_pack(&ipv6_packet_type);\n}\n\nstatic int __net_init ipv6_init_mibs(struct net *net)\n{\n\tint i;\n\n\tnet->mib.udp_stats_in6 = alloc_percpu(struct udp_mib);\n\tif (!net->mib.udp_stats_in6)\n\t\treturn -ENOMEM;\n\tnet->mib.udplite_stats_in6 = alloc_percpu(struct udp_mib);\n\tif (!net->mib.udplite_stats_in6)\n\t\tgoto err_udplite_mib;\n\tnet->mib.ipv6_statistics = alloc_percpu(struct ipstats_mib);\n\tif (!net->mib.ipv6_statistics)\n\t\tgoto err_ip_mib;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct ipstats_mib *af_inet6_stats;\n\t\taf_inet6_stats = per_cpu_ptr(net->mib.ipv6_statistics, i);\n\t\tu64_stats_init(&af_inet6_stats->syncp);\n\t}\n\n\n\tnet->mib.icmpv6_statistics = alloc_percpu(struct icmpv6_mib);\n\tif (!net->mib.icmpv6_statistics)\n\t\tgoto err_icmp_mib;\n\tnet->mib.icmpv6msg_statistics = kzalloc(sizeof(struct icmpv6msg_mib),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!net->mib.icmpv6msg_statistics)\n\t\tgoto err_icmpmsg_mib;\n\treturn 0;\n\nerr_icmpmsg_mib:\n\tfree_percpu(net->mib.icmpv6_statistics);\nerr_icmp_mib:\n\tfree_percpu(net->mib.ipv6_statistics);\nerr_ip_mib:\n\tfree_percpu(net->mib.udplite_stats_in6);\nerr_udplite_mib:\n\tfree_percpu(net->mib.udp_stats_in6);\n\treturn -ENOMEM;\n}\n\nstatic void ipv6_cleanup_mibs(struct net *net)\n{\n\tfree_percpu(net->mib.udp_stats_in6);\n\tfree_percpu(net->mib.udplite_stats_in6);\n\tfree_percpu(net->mib.ipv6_statistics);\n\tfree_percpu(net->mib.icmpv6_statistics);\n\tkfree(net->mib.icmpv6msg_statistics);\n}\n\nstatic int __net_init inet6_net_init(struct net *net)\n{\n\tint err = 0;\n\n\tnet->ipv6.sysctl.bindv6only = 0;\n\tnet->ipv6.sysctl.icmpv6_time = 1*HZ;\n\tnet->ipv6.sysctl.flowlabel_consistency = 1;\n\tnet->ipv6.sysctl.auto_flowlabels = IP6_DEFAULT_AUTO_FLOW_LABELS;\n\tnet->ipv6.sysctl.idgen_retries = 3;\n\tnet->ipv6.sysctl.idgen_delay = 1 * HZ;\n\tnet->ipv6.sysctl.flowlabel_state_ranges = 0;\n\tatomic_set(&net->ipv6.fib6_sernum, 1);\n\n\terr = ipv6_init_mibs(net);\n\tif (err)\n\t\treturn err;\n#ifdef CONFIG_PROC_FS\n\terr = udp6_proc_init(net);\n\tif (err)\n\t\tgoto out;\n\terr = tcp6_proc_init(net);\n\tif (err)\n\t\tgoto proc_tcp6_fail;\n\terr = ac6_proc_init(net);\n\tif (err)\n\t\tgoto proc_ac6_fail;\n#endif\n\treturn err;\n\n#ifdef CONFIG_PROC_FS\nproc_ac6_fail:\n\ttcp6_proc_exit(net);\nproc_tcp6_fail:\n\tudp6_proc_exit(net);\nout:\n\tipv6_cleanup_mibs(net);\n\treturn err;\n#endif\n}\n\nstatic void __net_exit inet6_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tudp6_proc_exit(net);\n\ttcp6_proc_exit(net);\n\tac6_proc_exit(net);\n#endif\n\tipv6_cleanup_mibs(net);\n}\n\nstatic struct pernet_operations inet6_net_ops = {\n\t.init = inet6_net_init,\n\t.exit = inet6_net_exit,\n};\n\nstatic const struct ipv6_stub ipv6_stub_impl = {\n\t.ipv6_sock_mc_join = ipv6_sock_mc_join,\n\t.ipv6_sock_mc_drop = ipv6_sock_mc_drop,\n\t.ipv6_dst_lookup = ip6_dst_lookup,\n\t.udpv6_encap_enable = udpv6_encap_enable,\n\t.ndisc_send_na = ndisc_send_na,\n\t.nd_tbl\t= &nd_tbl,\n};\n\nstatic int __init inet6_init(void)\n{\n\tstruct list_head *r;\n\tint err = 0;\n\n\tsock_skb_cb_check_size(sizeof(struct inet6_skb_parm));\n\n\t/* Register the socket-side information for inet6_create.  */\n\tfor (r = &inetsw6[0]; r < &inetsw6[SOCK_MAX]; ++r)\n\t\tINIT_LIST_HEAD(r);\n\n\tif (disable_ipv6_mod) {\n\t\tpr_info(\"Loaded, but administratively disabled, reboot required to enable\\n\");\n\t\tgoto out;\n\t}\n\n\terr = proto_register(&tcpv6_prot, 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = proto_register(&udpv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_tcp_proto;\n\n\terr = proto_register(&udplitev6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_udp_proto;\n\n\terr = proto_register(&rawv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_udplite_proto;\n\n\terr = proto_register(&pingv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_ping_proto;\n\n\t/* We MUST register RAW sockets before we create the ICMP6,\n\t * IGMP6, or NDISC control sockets.\n\t */\n\terr = rawv6_init();\n\tif (err)\n\t\tgoto out_unregister_raw_proto;\n\n\t/* Register the family here so that the init calls below will\n\t * be able to create sockets. (?? is this dangerous ??)\n\t */\n\terr = sock_register(&inet6_family_ops);\n\tif (err)\n\t\tgoto out_sock_register_fail;\n\n\t/*\n\t *\tipngwg API draft makes clear that the correct semantics\n\t *\tfor TCP and UDP is to consider one TCP and UDP instance\n\t *\tin a host available by both INET and INET6 APIs and\n\t *\table to communicate via both network protocols.\n\t */\n\n\terr = register_pernet_subsys(&inet6_net_ops);\n\tif (err)\n\t\tgoto register_pernet_fail;\n\terr = icmpv6_init();\n\tif (err)\n\t\tgoto icmp_fail;\n\terr = ip6_mr_init();\n\tif (err)\n\t\tgoto ipmr_fail;\n\terr = ndisc_init();\n\tif (err)\n\t\tgoto ndisc_fail;\n\terr = igmp6_init();\n\tif (err)\n\t\tgoto igmp_fail;\n\n\tipv6_stub = &ipv6_stub_impl;\n\n\terr = ipv6_netfilter_init();\n\tif (err)\n\t\tgoto netfilter_fail;\n\t/* Create /proc/foo6 entries. */\n#ifdef CONFIG_PROC_FS\n\terr = -ENOMEM;\n\tif (raw6_proc_init())\n\t\tgoto proc_raw6_fail;\n\tif (udplite6_proc_init())\n\t\tgoto proc_udplite6_fail;\n\tif (ipv6_misc_proc_init())\n\t\tgoto proc_misc6_fail;\n\tif (if6_proc_init())\n\t\tgoto proc_if6_fail;\n#endif\n\terr = ip6_route_init();\n\tif (err)\n\t\tgoto ip6_route_fail;\n\terr = ndisc_late_init();\n\tif (err)\n\t\tgoto ndisc_late_fail;\n\terr = ip6_flowlabel_init();\n\tif (err)\n\t\tgoto ip6_flowlabel_fail;\n\terr = addrconf_init();\n\tif (err)\n\t\tgoto addrconf_fail;\n\n\t/* Init v6 extension headers. */\n\terr = ipv6_exthdrs_init();\n\tif (err)\n\t\tgoto ipv6_exthdrs_fail;\n\n\terr = ipv6_frag_init();\n\tif (err)\n\t\tgoto ipv6_frag_fail;\n\n\t/* Init v6 transport protocols. */\n\terr = udpv6_init();\n\tif (err)\n\t\tgoto udpv6_fail;\n\n\terr = udplitev6_init();\n\tif (err)\n\t\tgoto udplitev6_fail;\n\n\terr = tcpv6_init();\n\tif (err)\n\t\tgoto tcpv6_fail;\n\n\terr = ipv6_packet_init();\n\tif (err)\n\t\tgoto ipv6_packet_fail;\n\n\terr = pingv6_init();\n\tif (err)\n\t\tgoto pingv6_fail;\n\n#ifdef CONFIG_SYSCTL\n\terr = ipv6_sysctl_register();\n\tif (err)\n\t\tgoto sysctl_fail;\n#endif\nout:\n\treturn err;\n\n#ifdef CONFIG_SYSCTL\nsysctl_fail:\n\tpingv6_exit();\n#endif\npingv6_fail:\n\tipv6_packet_cleanup();\nipv6_packet_fail:\n\ttcpv6_exit();\ntcpv6_fail:\n\tudplitev6_exit();\nudplitev6_fail:\n\tudpv6_exit();\nudpv6_fail:\n\tipv6_frag_exit();\nipv6_frag_fail:\n\tipv6_exthdrs_exit();\nipv6_exthdrs_fail:\n\taddrconf_cleanup();\naddrconf_fail:\n\tip6_flowlabel_cleanup();\nip6_flowlabel_fail:\n\tndisc_late_cleanup();\nndisc_late_fail:\n\tip6_route_cleanup();\nip6_route_fail:\n#ifdef CONFIG_PROC_FS\n\tif6_proc_exit();\nproc_if6_fail:\n\tipv6_misc_proc_exit();\nproc_misc6_fail:\n\tudplite6_proc_exit();\nproc_udplite6_fail:\n\traw6_proc_exit();\nproc_raw6_fail:\n#endif\n\tipv6_netfilter_fini();\nnetfilter_fail:\n\tigmp6_cleanup();\nigmp_fail:\n\tndisc_cleanup();\nndisc_fail:\n\tip6_mr_cleanup();\nipmr_fail:\n\ticmpv6_cleanup();\nicmp_fail:\n\tunregister_pernet_subsys(&inet6_net_ops);\nregister_pernet_fail:\n\tsock_unregister(PF_INET6);\n\trtnl_unregister_all(PF_INET6);\nout_sock_register_fail:\n\trawv6_exit();\nout_unregister_ping_proto:\n\tproto_unregister(&pingv6_prot);\nout_unregister_raw_proto:\n\tproto_unregister(&rawv6_prot);\nout_unregister_udplite_proto:\n\tproto_unregister(&udplitev6_prot);\nout_unregister_udp_proto:\n\tproto_unregister(&udpv6_prot);\nout_unregister_tcp_proto:\n\tproto_unregister(&tcpv6_prot);\n\tgoto out;\n}\nmodule_init(inet6_init);\n\nMODULE_ALIAS_NETPROTO(PF_INET6);\n", "/*\n *\tcommon UDP/RAW code\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/route.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/tcp_states.h>\n#include <net/dsfield.h>\n\n#include <linux/errqueue.h>\n#include <asm/uaccess.h>\n\nstatic bool ipv6_mapped_addr_any(const struct in6_addr *a)\n{\n\treturn ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);\n}\n\nstatic int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock\t*inet = inet_sk(sk);\n\tstruct ipv6_pinfo\t*np = inet6_sk(sk);\n\tstruct in6_addr\t*daddr, *final_p, final;\n\tstruct dst_entry\t*dst;\n\tstruct flowi6\t\tfl6;\n\tstruct ip6_flowlabel\t*flowlabel = NULL;\n\tstruct ipv6_txoptions\t*opt;\n\tint\t\t\taddr_type;\n\tint\t\t\terr;\n\n\tif (usin->sin6_family == AF_INET) {\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -EAFNOSUPPORT;\n\t\terr = __ip4_datagram_connect(sk, uaddr, addr_len);\n\t\tgoto ipv4_connected;\n\t}\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t/*\n\t\t *\tconnect to self\n\t\t */\n\t\tusin->sin6_addr.s6_addr[15] = 0x01;\n\t}\n\n\tdaddr = &usin->sin6_addr;\n\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tstruct sockaddr_in sin;\n\n\t\tif (__ipv6_only_sock(sk)) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out;\n\t\t}\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\tsin.sin_port = usin->sin6_port;\n\n\t\terr = __ip4_datagram_connect(sk,\n\t\t\t\t\t     (struct sockaddr *) &sin,\n\t\t\t\t\t     sizeof(sin));\n\nipv4_connected:\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tipv6_addr_set_v4mapped(inet->inet_daddr, &sk->sk_v6_daddr);\n\n\t\tif (ipv6_addr_any(&np->saddr) ||\n\t\t    ipv6_mapped_addr_any(&np->saddr))\n\t\t\tipv6_addr_set_v4mapped(inet->inet_saddr, &np->saddr);\n\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr) ||\n\t\t    ipv6_mapped_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\t\tipv6_addr_set_v4mapped(inet->inet_rcv_saddr,\n\t\t\t\t\t       &sk->sk_v6_rcv_saddr);\n\t\t\tif (sk->sk_prot->rehash)\n\t\t\t\tsk->sk_prot->rehash(sk);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\tif (!sk->sk_bound_dev_if && (addr_type & IPV6_ADDR_MULTICAST))\n\t\t\tsk->sk_bound_dev_if = np->mcast_oif;\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk->sk_v6_daddr = *daddr;\n\tnp->flow_label = fl6.flowlabel;\n\n\tinet->inet_dport = usin->sin6_port;\n\n\t/*\n\t *\tCheck for a route to destination an obtain the\n\t *\tdestination cache for it.\n\t */\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = inet->inet_dport;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\tif (!fl6.flowi6_oif && (addr_type&IPV6_ADDR_MULTICAST))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\trcu_read_lock();\n\topt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\terr = 0;\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\n\t/* source address lookup done in ip6_dst_lookup */\n\n\tif (ipv6_addr_any(&np->saddr))\n\t\tnp->saddr = fl6.saddr;\n\n\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\tsk->sk_v6_rcv_saddr = fl6.saddr;\n\t\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\t\tif (sk->sk_prot->rehash)\n\t\t\tsk->sk_prot->rehash(sk);\n\t}\n\n\tip6_dst_store(sk, dst,\n\t\t      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?\n\t\t      &sk->sk_v6_daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?\n\t\t      &np->saddr :\n#endif\n\t\t      NULL);\n\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk_set_txhash(sk);\nout:\n\tfl6_sock_release(flowlabel);\n\treturn err;\n}\n\nint ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tint res;\n\n\tlock_sock(sk);\n\tres = __ip6_datagram_connect(sk, uaddr, addr_len);\n\trelease_sock(sk);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_connect);\n\nint ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t\t int addr_len)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, uaddr);\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\treturn ip6_datagram_connect(sk, uaddr, addr_len);\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_connect_v6_only);\n\nvoid ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\n\t\t     __be16 port, u32 info, u8 *payload)\n{\n\tstruct ipv6_pinfo *np  = inet6_sk(sk);\n\tstruct icmp6hdr *icmph = icmp6_hdr(skb);\n\tstruct sock_exterr_skb *serr;\n\n\tif (!np->recverr)\n\t\treturn;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_ICMP6;\n\tserr->ee.ee_type = icmph->icmp6_type;\n\tserr->ee.ee_code = icmph->icmp6_code;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&(((struct ipv6hdr *)(icmph + 1))->daddr) -\n\t\t\t\t  skb_network_header(skb);\n\tserr->port = port;\n\n\t__skb_pull(skb, payload - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\nvoid ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info)\n{\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sock_exterr_skb *serr;\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\n\tif (!np->recverr)\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\tiph->daddr = fl6->daddr;\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\tserr->ee.ee_type = 0;\n\tserr->ee.ee_code = 0;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\n\tserr->port = fl6->fl6_dport;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\nvoid ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\tstruct ip6_mtuinfo *mtu_info;\n\n\tif (!np->rxopt.bits.rxpmtu)\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\tiph->daddr = fl6->daddr;\n\n\tmtu_info = IP6CBMTU(skb);\n\n\tmtu_info->ip6m_mtu = mtu;\n\tmtu_info->ip6m_addr.sin6_family = AF_INET6;\n\tmtu_info->ip6m_addr.sin6_port = 0;\n\tmtu_info->ip6m_addr.sin6_flowinfo = 0;\n\tmtu_info->ip6m_addr.sin6_scope_id = fl6->flowi6_oif;\n\tmtu_info->ip6m_addr.sin6_addr = ipv6_hdr(skb)->daddr;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tskb = xchg(&np->rxpmtu, skb);\n\tkfree_skb(skb);\n}\n\n/* For some errors we have valid addr_offset even with zero payload and\n * zero port. Also, addr_offset should be supported if port is set.\n */\nstatic inline bool ipv6_datagram_support_addr(struct sock_exterr_skb *serr)\n{\n\treturn serr->ee.ee_origin == SO_EE_ORIGIN_ICMP6 ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL || serr->port;\n}\n\n/* IPv6 supports cmsg on all origins aside from SO_EE_ORIGIN_LOCAL.\n *\n * At one point, excluding local errors was a quick test to identify icmp/icmp6\n * errors. This is no longer true, but the test remained, so the v6 stack,\n * unlike v4, also honors cmsg requests on all wifi and timestamp errors.\n *\n * Timestamp code paths do not initialize the fields expected by cmsg:\n * the PKTINFO fields in skb->cb[]. Fill those in here.\n */\nstatic bool ip6_datagram_support_cmsg(struct sk_buff *skb,\n\t\t\t\t      struct sock_exterr_skb *serr)\n{\n\tif (serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t    serr->ee.ee_origin == SO_EE_ORIGIN_ICMP6)\n\t\treturn true;\n\n\tif (serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL)\n\t\treturn false;\n\n\tif (!skb->dev)\n\t\treturn false;\n\n\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\tIP6CB(skb)->iif = skb->dev->ifindex;\n\telse\n\t\tPKTINFO_SKB_CB(skb)->ipi_ifindex = skb->dev->ifindex;\n\n\treturn true;\n}\n\n/*\n *\tHandle MSG_ERRQUEUE\n */\nint ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin, msg->msg_name);\n\tstruct {\n\t\tstruct sock_extended_err ee;\n\t\tstruct sockaddr_in6\t offender;\n\t} errhdr;\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = sock_dequeue_err_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tserr = SKB_EXT_ERR(skb);\n\n\tif (sin && ipv6_datagram_support_addr(serr)) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tsin->sin6_family = AF_INET6;\n\t\tsin->sin6_flowinfo = 0;\n\t\tsin->sin6_port = serr->port;\n\t\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tconst struct ipv6hdr *ip6h = container_of((struct in6_addr *)(nh + serr->addr_offset),\n\t\t\t\t\t\t\t\t  struct ipv6hdr, daddr);\n\t\t\tsin->sin6_addr = ip6h->daddr;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin->sin6_flowinfo = ip6_flowinfo(ip6h);\n\t\t\tsin->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t} else {\n\t\t\tipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),\n\t\t\t\t\t       &sin->sin6_addr);\n\t\t\tsin->sin6_scope_id = 0;\n\t\t}\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\n\tsin = &errhdr.offender;\n\tmemset(sin, 0, sizeof(*sin));\n\n\tif (ip6_datagram_support_cmsg(skb, serr)) {\n\t\tsin->sin6_family = AF_INET6;\n\t\tif (np->rxopt.all)\n\t\t\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\t\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tsin->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\t\tif (np->rxopt.all)\n\t\t\t\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n\t\t\tsin->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t} else {\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin->sin6_addr);\n\t\t\tif (inet_sk(sk)->cmsg_flags)\n\t\t\t\tip_cmsg_recv(msg, skb);\n\t\t}\n\t}\n\n\tput_cmsg(msg, SOL_IPV6, IPV6_RECVERR, sizeof(errhdr), &errhdr);\n\n\t/* Now we could try to dump offended packet options */\n\n\tmsg->msg_flags |= MSG_ERRQUEUE;\n\terr = copied;\n\nout_free_skb:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ipv6_recv_error);\n\n/*\n *\tHandle IPV6_RECVPATHMTU\n */\nint ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,\n\t\t     int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ip6_mtuinfo mtu_info;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin, msg->msg_name);\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tmemcpy(&mtu_info, IP6CBMTU(skb), sizeof(mtu_info));\n\n\tif (sin) {\n\t\tsin->sin6_family = AF_INET6;\n\t\tsin->sin6_flowinfo = 0;\n\t\tsin->sin6_port = 0;\n\t\tsin->sin6_scope_id = mtu_info.ip6m_addr.sin6_scope_id;\n\t\tsin->sin6_addr = mtu_info.ip6m_addr.sin6_addr;\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tput_cmsg(msg, SOL_IPV6, IPV6_PATHMTU, sizeof(mtu_info), &mtu_info);\n\n\terr = copied;\n\nout_free_skb:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}\n\n\nvoid ip6_datagram_recv_common_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tbool is_ipv6 = skb->protocol == htons(ETH_P_IPV6);\n\n\tif (np->rxopt.bits.rxinfo) {\n\t\tstruct in6_pktinfo src_info;\n\n\t\tif (is_ipv6) {\n\t\t\tsrc_info.ipi6_ifindex = IP6CB(skb)->iif;\n\t\t\tsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\n\t\t} else {\n\t\t\tsrc_info.ipi6_ifindex =\n\t\t\t\tPKTINFO_SKB_CB(skb)->ipi_ifindex;\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->daddr,\n\t\t\t\t\t       &src_info.ipi6_addr);\n\t\t}\n\n\t\tif (src_info.ipi6_ifindex >= 0)\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_PKTINFO,\n\t\t\t\t sizeof(src_info), &src_info);\n\t}\n}\n\nvoid ip6_datagram_recv_specific_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tunsigned char *nh = skb_network_header(skb);\n\n\tif (np->rxopt.bits.rxhlim) {\n\t\tint hlim = ipv6_hdr(skb)->hop_limit;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\n\t}\n\n\tif (np->rxopt.bits.rxtclass) {\n\t\tint tclass = ipv6_get_dsfield(ipv6_hdr(skb));\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\n\t}\n\n\tif (np->rxopt.bits.rxflow) {\n\t\t__be32 flowinfo = ip6_flowinfo((struct ipv6hdr *)nh);\n\t\tif (flowinfo)\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);\n\t}\n\n\t/* HbH is allowed only once */\n\tif (np->rxopt.bits.hopopts && (opt->flags & IP6SKB_HOPBYHOP)) {\n\t\tu8 *ptr = nh + sizeof(struct ipv6hdr);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_HOPOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\n\tif (opt->lastopt &&\n\t    (np->rxopt.bits.dstopts || np->rxopt.bits.srcrt)) {\n\t\t/*\n\t\t * Silly enough, but we need to reparse in order to\n\t\t * report extension headers (except for HbH)\n\t\t * in order.\n\t\t *\n\t\t * Also note that IPV6_RECVRTHDRDSTOPTS is NOT\n\t\t * (and WILL NOT be) defined because\n\t\t * IPV6_RECVDSTOPTS is more generic. --yoshfuji\n\t\t */\n\t\tunsigned int off = sizeof(struct ipv6hdr);\n\t\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\n\t\twhile (off <= opt->lastopt) {\n\t\t\tunsigned int len;\n\t\t\tu8 *ptr = nh + off;\n\n\t\t\tswitch (nexthdr) {\n\t\t\tcase IPPROTO_DSTOPTS:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tif (np->rxopt.bits.dstopts)\n\t\t\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_DSTOPTS, len, ptr);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_ROUTING:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tif (np->rxopt.bits.srcrt)\n\t\t\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_RTHDR, len, ptr);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_AH:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 2) << 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toff += len;\n\t\t}\n\t}\n\n\t/* socket options in old style */\n\tif (np->rxopt.bits.rxoinfo) {\n\t\tstruct in6_pktinfo src_info;\n\n\t\tsrc_info.ipi6_ifindex = opt->iif;\n\t\tsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\n\t}\n\tif (np->rxopt.bits.rxohlim) {\n\t\tint hlim = ipv6_hdr(skb)->hop_limit;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\n\t}\n\tif (np->rxopt.bits.ohopopts && (opt->flags & IP6SKB_HOPBYHOP)) {\n\t\tu8 *ptr = nh + sizeof(struct ipv6hdr);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292HOPOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.odstopts && opt->dst0) {\n\t\tu8 *ptr = nh + opt->dst0;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.osrcrt && opt->srcrt) {\n\t\tstruct ipv6_rt_hdr *rthdr = (struct ipv6_rt_hdr *)(nh + opt->srcrt);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292RTHDR, (rthdr->hdrlen+1) << 3, rthdr);\n\t}\n\tif (np->rxopt.bits.odstopts && opt->dst1) {\n\t\tu8 *ptr = nh + opt->dst1;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.rxorigdstaddr) {\n\t\tstruct sockaddr_in6 sin6;\n\t\t__be16 *ports = (__be16 *) skb_transport_header(skb);\n\n\t\tif (skb_transport_offset(skb) + 4 <= skb->len) {\n\t\t\t/* All current transport protocols have the port numbers in the\n\t\t\t * first four bytes of the transport header and this function is\n\t\t\t * written with this assumption in mind.\n\t\t\t */\n\n\t\t\tsin6.sin6_family = AF_INET6;\n\t\t\tsin6.sin6_addr = ipv6_hdr(skb)->daddr;\n\t\t\tsin6.sin6_port = ports[1];\n\t\t\tsin6.sin6_flowinfo = 0;\n\t\t\tsin6.sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t    opt->iif);\n\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_ORIGDSTADDR, sizeof(sin6), &sin6);\n\t\t}\n\t}\n}\n\nvoid ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_recv_ctl);\n\nint ip6_datagram_send_ctl(struct net *net, struct sock *sk,\n\t\t\t  struct msghdr *msg, struct flowi6 *fl6,\n\t\t\t  struct ipv6_txoptions *opt,\n\t\t\t  int *hlimit, int *tclass, int *dontfrag)\n{\n\tstruct in6_pktinfo *src_info;\n\tstruct cmsghdr *cmsg;\n\tstruct ipv6_rt_hdr *rthdr;\n\tstruct ipv6_opt_hdr *hdr;\n\tint len;\n\tint err = 0;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tint addr_type;\n\n\t\tif (!CMSG_OK(msg, cmsg)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_f;\n\t\t}\n\n\t\tif (cmsg->cmsg_level != SOL_IPV6)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase IPV6_PKTINFO:\n\t\tcase IPV6_2292PKTINFO:\n\t\t    {\n\t\t\tstruct net_device *dev = NULL;\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\n\n\t\t\tif (src_info->ipi6_ifindex) {\n\t\t\t\tif (fl6->flowi6_oif &&\n\t\t\t\t    src_info->ipi6_ifindex != fl6->flowi6_oif)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tfl6->flowi6_oif = src_info->ipi6_ifindex;\n\t\t\t}\n\n\t\t\taddr_type = __ipv6_addr_type(&src_info->ipi6_addr);\n\n\t\t\trcu_read_lock();\n\t\t\tif (fl6->flowi6_oif) {\n\t\t\t\tdev = dev_get_by_index_rcu(net, fl6->flowi6_oif);\n\t\t\t\tif (!dev) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (addr_type != IPV6_ADDR_ANY) {\n\t\t\t\tint strict = __ipv6_addr_src_scope(addr_type) <= IPV6_ADDR_SCOPE_LINKLOCAL;\n\t\t\t\tif (!(inet_sk(sk)->freebind || inet_sk(sk)->transparent) &&\n\t\t\t\t    !ipv6_chk_addr(net, &src_info->ipi6_addr,\n\t\t\t\t\t\t   strict ? dev : NULL, 0) &&\n\t\t\t\t    !ipv6_chk_acast_addr_src(net, dev,\n\t\t\t\t\t\t\t     &src_info->ipi6_addr))\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tfl6->saddr = src_info->ipi6_addr;\n\t\t\t}\n\n\t\t\trcu_read_unlock();\n\n\t\t\tif (err)\n\t\t\t\tgoto exit_f;\n\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase IPV6_FLOWINFO:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(4)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tif (fl6->flowlabel&IPV6_FLOWINFO_MASK) {\n\t\t\t\tif ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit_f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase IPV6_2292HOPOPTS:\n\t\tcase IPV6_HOPOPTS:\n\t\t\tif (opt->hopopt || cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\topt->opt_nflen += len;\n\t\t\topt->hopopt = hdr;\n\t\t\tbreak;\n\n\t\tcase IPV6_2292DSTOPTS:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (opt->dst1opt) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\topt->opt_flen += len;\n\t\t\topt->dst1opt = hdr;\n\t\t\tbreak;\n\n\t\tcase IPV6_DSTOPTS:\n\t\tcase IPV6_RTHDRDSTOPTS:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (cmsg->cmsg_type == IPV6_DSTOPTS) {\n\t\t\t\topt->opt_flen += len;\n\t\t\t\topt->dst1opt = hdr;\n\t\t\t} else {\n\t\t\t\topt->opt_nflen += len;\n\t\t\t\topt->dst0opt = hdr;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IPV6_2292RTHDR:\n\t\tcase IPV6_RTHDR:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_rt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\trthdr = (struct ipv6_rt_hdr *)CMSG_DATA(cmsg);\n\n\t\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t\tif (rthdr->hdrlen != 2 ||\n\t\t\t\t    rthdr->segments_left != 1) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit_f;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tlen = ((rthdr->hdrlen + 1) << 3);\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\t/* segments left must also match */\n\t\t\tif ((rthdr->hdrlen >> 1) != rthdr->segments_left) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\topt->opt_nflen += len;\n\t\t\topt->srcrt = rthdr;\n\n\t\t\tif (cmsg->cmsg_type == IPV6_2292RTHDR && opt->dst1opt) {\n\t\t\t\tint dsthdrlen = ((opt->dst1opt->hdrlen+1)<<3);\n\n\t\t\t\topt->opt_nflen += dsthdrlen;\n\t\t\t\topt->dst0opt = opt->dst1opt;\n\t\t\t\topt->dst1opt = NULL;\n\t\t\t\topt->opt_flen -= dsthdrlen;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IPV6_2292HOPLIMIT:\n\t\tcase IPV6_HOPLIMIT:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\t*hlimit = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (*hlimit < -1 || *hlimit > 0xff) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IPV6_TCLASS:\n\t\t    {\n\t\t\tint tc;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\tgoto exit_f;\n\n\t\t\ttc = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (tc < -1 || tc > 0xff)\n\t\t\t\tgoto exit_f;\n\n\t\t\terr = 0;\n\t\t\t*tclass = tc;\n\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase IPV6_DONTFRAG:\n\t\t    {\n\t\t\tint df;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\tgoto exit_f;\n\n\t\t\tdf = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (df < 0 || df > 1)\n\t\t\t\tgoto exit_f;\n\n\t\t\terr = 0;\n\t\t\t*dontfrag = df;\n\n\t\t\tbreak;\n\t\t    }\n\t\tdefault:\n\t\t\tnet_dbg_ratelimited(\"invalid cmsg type: %d\\n\",\n\t\t\t\t\t    cmsg->cmsg_type);\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_f;\n\t\t}\n\t}\n\nexit_f:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_send_ctl);\n\nvoid ip6_dgram_sock_seq_show(struct seq_file *seq, struct sock *sp,\n\t\t\t     __u16 srcp, __u16 destp, int bucket)\n{\n\tconst struct in6_addr *dest, *src;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tseq_printf(seq,\n\t\t   \"%5d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %d\\n\",\n\t\t   bucket,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   sp->sk_state,\n\t\t   sk_wmem_alloc_get(sp),\n\t\t   sk_rmem_alloc_get(sp),\n\t\t   0, 0L, 0,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   0,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   atomic_read(&sp->sk_drops));\n}\n", "/*\n *\tExtension Header handling for IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\tAndi Kleen\t\t<ak@muc.de>\n *\tAlexey Kuznetsov\t<kuznet@ms2.inr.ac.ru>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n/* Changes:\n *\tyoshfuji\t\t: ensure not to overrun while parsing\n *\t\t\t\t  tlv options.\n *\tMitsuru KANDA @USAGI and: Remove ipv6_parse_exthdrs().\n *\tYOSHIFUJI Hideaki @USAGI  Register inbound extension header\n *\t\t\t\t  handlers as inet6_protocol{}.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <net/dst.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n#include <net/xfrm.h>\n#endif\n\n#include <linux/uaccess.h>\n\n/*\n *\tParsing tlv encoded headers.\n *\n *\tParsing function \"func\" returns true, if parsing succeed\n *\tand false, if it failed.\n *\tIt MUST NOT touch skb->h.\n */\n\nstruct tlvtype_proc {\n\tint\ttype;\n\tbool\t(*func)(struct sk_buff *skb, int offset);\n};\n\n/*********************\n  Generic functions\n *********************/\n\n/* An unknown option is detected, decide what to do */\n\nstatic bool ip6_tlvopt_unknown(struct sk_buff *skb, int optoff)\n{\n\tswitch ((skb_network_header(skb)[optoff] & 0xC0) >> 6) {\n\tcase 0: /* ignore */\n\t\treturn true;\n\n\tcase 1: /* drop packet */\n\t\tbreak;\n\n\tcase 3: /* Send ICMP if not a multicast address and drop packet */\n\t\t/* Actually, it is redundant check. icmp_send\n\t\t   will recheck in any case.\n\t\t */\n\t\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr))\n\t\t\tbreak;\n\tcase 2: /* send ICMP PARM PROB regardless and drop packet */\n\t\ticmpv6_param_prob(skb, ICMPV6_UNK_OPTION, optoff);\n\t\treturn false;\n\t}\n\n\tkfree_skb(skb);\n\treturn false;\n}\n\n/* Parse tlv encoded option header (hop-by-hop or destination) */\n\nstatic bool ip6_parse_tlv(const struct tlvtype_proc *procs, struct sk_buff *skb)\n{\n\tconst struct tlvtype_proc *curr;\n\tconst unsigned char *nh = skb_network_header(skb);\n\tint off = skb_network_header_len(skb);\n\tint len = (skb_transport_header(skb)[1] + 1) << 3;\n\tint padlen = 0;\n\n\tif (skb_transport_offset(skb) + len > skb_headlen(skb))\n\t\tgoto bad;\n\n\toff += 2;\n\tlen -= 2;\n\n\twhile (len > 0) {\n\t\tint optlen = nh[off + 1] + 2;\n\t\tint i;\n\n\t\tswitch (nh[off]) {\n\t\tcase IPV6_TLV_PAD1:\n\t\t\toptlen = 1;\n\t\t\tpadlen++;\n\t\t\tif (padlen > 7)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\n\t\tcase IPV6_TLV_PADN:\n\t\t\t/* RFC 2460 states that the purpose of PadN is\n\t\t\t * to align the containing header to multiples\n\t\t\t * of 8. 7 is therefore the highest valid value.\n\t\t\t * See also RFC 4942, Section 2.1.9.5.\n\t\t\t */\n\t\t\tpadlen += optlen;\n\t\t\tif (padlen > 7)\n\t\t\t\tgoto bad;\n\t\t\t/* RFC 4942 recommends receiving hosts to\n\t\t\t * actively check PadN payload to contain\n\t\t\t * only zeroes.\n\t\t\t */\n\t\t\tfor (i = 2; i < optlen; i++) {\n\t\t\t\tif (nh[off + i] != 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: /* Other TLV code so scan list */\n\t\t\tif (optlen > len)\n\t\t\t\tgoto bad;\n\t\t\tfor (curr = procs; curr->type >= 0; curr++) {\n\t\t\t\tif (curr->type == nh[off]) {\n\t\t\t\t\t/* type specific length/alignment\n\t\t\t\t\t   checks will be performed in the\n\t\t\t\t\t   func(). */\n\t\t\t\t\tif (curr->func(skb, off) == false)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curr->type < 0) {\n\t\t\t\tif (ip6_tlvopt_unknown(skb, off) == 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpadlen = 0;\n\t\t\tbreak;\n\t\t}\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\n\tif (len == 0)\n\t\treturn true;\nbad:\n\tkfree_skb(skb);\n\treturn false;\n}\n\n/*****************************\n  Destination options header.\n *****************************/\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nstatic bool ipv6_dest_hao(struct sk_buff *skb, int optoff)\n{\n\tstruct ipv6_destopt_hao *hao;\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tstruct in6_addr tmp_addr;\n\tint ret;\n\n\tif (opt->dsthao) {\n\t\tnet_dbg_ratelimited(\"hao duplicated\\n\");\n\t\tgoto discard;\n\t}\n\topt->dsthao = opt->dst1;\n\topt->dst1 = 0;\n\n\thao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);\n\n\tif (hao->length != 16) {\n\t\tnet_dbg_ratelimited(\"hao invalid option length = %d\\n\",\n\t\t\t\t    hao->length);\n\t\tgoto discard;\n\t}\n\n\tif (!(ipv6_addr_type(&hao->addr) & IPV6_ADDR_UNICAST)) {\n\t\tnet_dbg_ratelimited(\"hao is not an unicast addr: %pI6\\n\",\n\t\t\t\t    &hao->addr);\n\t\tgoto discard;\n\t}\n\n\tret = xfrm6_input_addr(skb, (xfrm_address_t *)&ipv6h->daddr,\n\t\t\t       (xfrm_address_t *)&hao->addr, IPPROTO_DSTOPTS);\n\tif (unlikely(ret < 0))\n\t\tgoto discard;\n\n\tif (skb_cloned(skb)) {\n\t\tif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC))\n\t\t\tgoto discard;\n\n\t\t/* update all variable using below by copied skbuff */\n\t\thao = (struct ipv6_destopt_hao *)(skb_network_header(skb) +\n\t\t\t\t\t\t  optoff);\n\t\tipv6h = ipv6_hdr(skb);\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\ttmp_addr = ipv6h->saddr;\n\tipv6h->saddr = hao->addr;\n\thao->addr = tmp_addr;\n\n\tif (skb->tstamp.tv64 == 0)\n\t\t__net_timestamp(skb);\n\n\treturn true;\n\n discard:\n\tkfree_skb(skb);\n\treturn false;\n}\n#endif\n\nstatic const struct tlvtype_proc tlvprocdestopt_lst[] = {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t{\n\t\t.type\t= IPV6_TLV_HAO,\n\t\t.func\t= ipv6_dest_hao,\n\t},\n#endif\n\t{-1,\t\t\tNULL}\n};\n\nstatic int ipv6_destopt_rcv(struct sk_buff *skb)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t__u16 dstbuf;\n#endif\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) ||\n\t    !pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\n\t\tIP6_INC_STATS_BH(dev_net(dst->dev), ip6_dst_idev(dst),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\topt->lastopt = opt->dst1 = skb_network_header_len(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tdstbuf = opt->dst1;\n#endif\n\n\tif (ip6_parse_tlv(tlvprocdestopt_lst, skb)) {\n\t\tskb->transport_header += (skb_transport_header(skb)[1] + 1) << 3;\n\t\topt = IP6CB(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\topt->nhoff = dstbuf;\n#else\n\t\topt->nhoff = opt->dst1;\n#endif\n\t\treturn 1;\n\t}\n\n\tIP6_INC_STATS_BH(dev_net(dst->dev),\n\t\t\t ip6_dst_idev(dst), IPSTATS_MIB_INHDRERRORS);\n\treturn -1;\n}\n\n/********************************\n  Routing header.\n ********************************/\n\n/* called with rcu_read_lock() */\nstatic int ipv6_rthdr_rcv(struct sk_buff *skb)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct in6_addr *addr = NULL;\n\tstruct in6_addr daddr;\n\tstruct inet6_dev *idev;\n\tint n, i;\n\tstruct ipv6_rt_hdr *hdr;\n\tstruct rt0_hdr *rthdr;\n\tstruct net *net = dev_net(skb->dev);\n\tint accept_source_route = net->ipv6.devconf_all->accept_source_route;\n\n\tidev = __in6_dev_get(skb->dev);\n\tif (idev && accept_source_route > idev->cnf.accept_source_route)\n\t\taccept_source_route = idev->cnf.accept_source_route;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) ||\n\t    !pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\thdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);\n\n\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) ||\n\t    skb->pkt_type != PACKET_HOST) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\nlooped_back:\n\tif (hdr->segments_left == 0) {\n\t\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t/* Silently discard type 2 header unless it was\n\t\t\t * processed by own\n\t\t\t */\n\t\t\tif (!addr) {\n\t\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\topt->lastopt = opt->srcrt = skb_network_header_len(skb);\n\t\tskb->transport_header += (hdr->hdrlen + 1) << 3;\n\t\topt->dst0 = opt->dst1;\n\t\topt->dst1 = 0;\n\t\topt->nhoff = (&hdr->nexthdr) - skb_network_header(skb);\n\t\treturn 1;\n\t}\n\n\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase IPV6_SRCRT_TYPE_2:\n\t\tif (accept_source_route < 0)\n\t\t\tgoto unknown_rh;\n\t\t/* Silently discard invalid RTH type 2 */\n\t\tif (hdr->hdrlen != 2 || hdr->segments_left != 1) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tgoto unknown_rh;\n\t}\n\n\t/*\n\t *\tThis is the routing header forwarding algorithm from\n\t *\tRFC 2460, page 16.\n\t */\n\n\tn = hdr->hdrlen >> 1;\n\n\tif (hdr->segments_left > n) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((&hdr->segments_left) -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\t/* We are about to mangle packet header. Be careful!\n\t   Do not damage packets queued somewhere.\n\t */\n\tif (skb_cloned(skb)) {\n\t\t/* the copy is a forwarded packet */\n\t\tif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_OUTDISCARDS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\thdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\ti = n - --hdr->segments_left;\n\n\trthdr = (struct rt0_hdr *) hdr;\n\taddr = rthdr->addr;\n\taddr += i - 1;\n\n\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase IPV6_SRCRT_TYPE_2:\n\t\tif (xfrm6_input_addr(skb, (xfrm_address_t *)addr,\n\t\t\t\t     (xfrm_address_t *)&ipv6_hdr(skb)->saddr,\n\t\t\t\t     IPPROTO_ROUTING) < 0) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!ipv6_chk_home_addr(dev_net(skb_dst(skb)->dev), addr)) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ipv6_addr_is_multicast(addr)) {\n\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t IPSTATS_MIB_INADDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tdaddr = *addr;\n\t*addr = ipv6_hdr(skb)->daddr;\n\tipv6_hdr(skb)->daddr = daddr;\n\n\tskb_dst_drop(skb);\n\tip6_route_input(skb);\n\tif (skb_dst(skb)->error) {\n\t\tskb_push(skb, skb->data - skb_network_header(skb));\n\t\tdst_input(skb);\n\t\treturn -1;\n\t}\n\n\tif (skb_dst(skb)->dev->flags&IFF_LOOPBACK) {\n\t\tif (ipv6_hdr(skb)->hop_limit <= 1) {\n\t\t\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT,\n\t\t\t\t    0);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tipv6_hdr(skb)->hop_limit--;\n\t\tgoto looped_back;\n\t}\n\n\tskb_push(skb, skb->data - skb_network_header(skb));\n\tdst_input(skb);\n\treturn -1;\n\nunknown_rh:\n\tIP6_INC_STATS_BH(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_INHDRERRORS);\n\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t  (&hdr->type) - skb_network_header(skb));\n\treturn -1;\n}\n\nstatic const struct inet6_protocol rthdr_protocol = {\n\t.handler\t=\tipv6_rthdr_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct inet6_protocol destopt_protocol = {\n\t.handler\t=\tipv6_destopt_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct inet6_protocol nodata_protocol = {\n\t.handler\t=\tdst_discard,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nint __init ipv6_exthdrs_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_add_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\n\tif (ret)\n\t\tgoto out_rthdr;\n\n\tret = inet6_add_protocol(&nodata_protocol, IPPROTO_NONE);\n\tif (ret)\n\t\tgoto out_destopt;\n\nout:\n\treturn ret;\nout_destopt:\n\tinet6_del_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\nout_rthdr:\n\tinet6_del_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n\tgoto out;\n};\n\nvoid ipv6_exthdrs_exit(void)\n{\n\tinet6_del_protocol(&nodata_protocol, IPPROTO_NONE);\n\tinet6_del_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\n\tinet6_del_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n}\n\n/**********************************\n  Hop-by-hop options.\n **********************************/\n\n/*\n * Note: we cannot rely on skb_dst(skb) before we assign it in ip6_route_input().\n */\nstatic inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)\n{\n\treturn skb_dst(skb) ? ip6_dst_idev(skb_dst(skb)) : __in6_dev_get(skb->dev);\n}\n\nstatic inline struct net *ipv6_skb_net(struct sk_buff *skb)\n{\n\treturn skb_dst(skb) ? dev_net(skb_dst(skb)->dev) : dev_net(skb->dev);\n}\n\n/* Router Alert as of RFC 2711 */\n\nstatic bool ipv6_hop_ra(struct sk_buff *skb, int optoff)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\n\tif (nh[optoff + 1] == 2) {\n\t\tIP6CB(skb)->flags |= IP6SKB_ROUTERALERT;\n\t\tmemcpy(&IP6CB(skb)->ra, nh + optoff + 2, sizeof(IP6CB(skb)->ra));\n\t\treturn true;\n\t}\n\tnet_dbg_ratelimited(\"ipv6_hop_ra: wrong RA length %d\\n\",\n\t\t\t    nh[optoff + 1]);\n\tkfree_skb(skb);\n\treturn false;\n}\n\n/* Jumbo payload */\n\nstatic bool ipv6_hop_jumbo(struct sk_buff *skb, int optoff)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\tstruct net *net = ipv6_skb_net(skb);\n\tu32 pkt_len;\n\n\tif (nh[optoff + 1] != 4 || (optoff & 3) != 2) {\n\t\tnet_dbg_ratelimited(\"ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\\n\",\n\t\t\t\t    nh[optoff+1]);\n\t\tIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\tgoto drop;\n\t}\n\n\tpkt_len = ntohl(*(__be32 *)(nh + optoff + 2));\n\tif (pkt_len <= IPV6_MAXPLEN) {\n\t\tIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff+2);\n\t\treturn false;\n\t}\n\tif (ipv6_hdr(skb)->payload_len) {\n\t\tIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\n\t\t\t\t IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff);\n\t\treturn false;\n\t}\n\n\tif (pkt_len > skb->len - sizeof(struct ipv6hdr)) {\n\t\tIP6_INC_STATS_BH(net, ipv6_skb_idev(skb),\n\t\t\t\t IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t}\n\n\tif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n\treturn true;\n\ndrop:\n\tkfree_skb(skb);\n\treturn false;\n}\n\nstatic const struct tlvtype_proc tlvprochopopt_lst[] = {\n\t{\n\t\t.type\t= IPV6_TLV_ROUTERALERT,\n\t\t.func\t= ipv6_hop_ra,\n\t},\n\t{\n\t\t.type\t= IPV6_TLV_JUMBO,\n\t\t.func\t= ipv6_hop_jumbo,\n\t},\n\t{ -1, }\n};\n\nint ipv6_parse_hopopts(struct sk_buff *skb)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\n\t/*\n\t * skb_network_header(skb) is equal to skb->data, and\n\t * skb_network_header_len(skb) is always equal to\n\t * sizeof(struct ipv6hdr) by definition of\n\t * hop-by-hop options.\n\t */\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr) + 8) ||\n\t    !pskb_may_pull(skb, (sizeof(struct ipv6hdr) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\topt->flags |= IP6SKB_HOPBYHOP;\n\tif (ip6_parse_tlv(tlvprochopopt_lst, skb)) {\n\t\tskb->transport_header += (skb_transport_header(skb)[1] + 1) << 3;\n\t\topt = IP6CB(skb);\n\t\topt->nhoff = sizeof(struct ipv6hdr);\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\n/*\n *\tCreating outbound headers.\n *\n *\t\"build\" functions work when skb is filled from head to tail (datagram)\n *\t\"push\"\tfunctions work when headers are added from tail to head (tcp)\n *\n *\tIn both cases we assume, that caller reserved enough room\n *\tfor headers.\n */\n\nstatic void ipv6_push_rthdr(struct sk_buff *skb, u8 *proto,\n\t\t\t    struct ipv6_rt_hdr *opt,\n\t\t\t    struct in6_addr **addr_p)\n{\n\tstruct rt0_hdr *phdr, *ihdr;\n\tint hops;\n\n\tihdr = (struct rt0_hdr *) opt;\n\n\tphdr = (struct rt0_hdr *) skb_push(skb, (ihdr->rt_hdr.hdrlen + 1) << 3);\n\tmemcpy(phdr, ihdr, sizeof(struct rt0_hdr));\n\n\thops = ihdr->rt_hdr.hdrlen >> 1;\n\n\tif (hops > 1)\n\t\tmemcpy(phdr->addr, ihdr->addr + 1,\n\t\t       (hops - 1) * sizeof(struct in6_addr));\n\n\tphdr->addr[hops - 1] = **addr_p;\n\t*addr_p = ihdr->addr;\n\n\tphdr->rt_hdr.nexthdr = *proto;\n\t*proto = NEXTHDR_ROUTING;\n}\n\nstatic void ipv6_push_exthdr(struct sk_buff *skb, u8 *proto, u8 type, struct ipv6_opt_hdr *opt)\n{\n\tstruct ipv6_opt_hdr *h = (struct ipv6_opt_hdr *)skb_push(skb, ipv6_optlen(opt));\n\n\tmemcpy(h, opt, ipv6_optlen(opt));\n\th->nexthdr = *proto;\n\t*proto = type;\n}\n\nvoid ipv6_push_nfrag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t  u8 *proto,\n\t\t\t  struct in6_addr **daddr)\n{\n\tif (opt->srcrt) {\n\t\tipv6_push_rthdr(skb, proto, opt->srcrt, daddr);\n\t\t/*\n\t\t * IPV6_RTHDRDSTOPTS is ignored\n\t\t * unless IPV6_RTHDR is set (RFC3542).\n\t\t */\n\t\tif (opt->dst0opt)\n\t\t\tipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst0opt);\n\t}\n\tif (opt->hopopt)\n\t\tipv6_push_exthdr(skb, proto, NEXTHDR_HOP, opt->hopopt);\n}\nEXPORT_SYMBOL(ipv6_push_nfrag_opts);\n\nvoid ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt, u8 *proto)\n{\n\tif (opt->dst1opt)\n\t\tipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst1opt);\n}\n\nstruct ipv6_txoptions *\nipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n\t\t\t*((char **)&opt2->dst1opt) += dif;\n\t\tif (opt2->srcrt)\n\t\t\t*((char **)&opt2->srcrt) += dif;\n\t\tatomic_set(&opt2->refcnt, 1);\n\t}\n\treturn opt2;\n}\nEXPORT_SYMBOL_GPL(ipv6_dup_options);\n\nstatic int ipv6_renew_option(void *ohdr,\n\t\t\t     struct ipv6_opt_hdr __user *newopt, int newoptlen,\n\t\t\t     int inherit,\n\t\t\t     struct ipv6_opt_hdr **hdr,\n\t\t\t     char **p)\n{\n\tif (inherit) {\n\t\tif (ohdr) {\n\t\t\tmemcpy(*p, ohdr, ipv6_optlen((struct ipv6_opt_hdr *)ohdr));\n\t\t\t*hdr = (struct ipv6_opt_hdr *)*p;\n\t\t\t*p += CMSG_ALIGN(ipv6_optlen(*hdr));\n\t\t}\n\t} else {\n\t\tif (newopt) {\n\t\t\tif (copy_from_user(*p, newopt, newoptlen))\n\t\t\t\treturn -EFAULT;\n\t\t\t*hdr = (struct ipv6_opt_hdr *)*p;\n\t\t\tif (ipv6_optlen(*hdr) > newoptlen)\n\t\t\t\treturn -EINVAL;\n\t\t\t*p += CMSG_ALIGN(newoptlen);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstruct ipv6_txoptions *\nipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,\n\t\t   int newtype,\n\t\t   struct ipv6_opt_hdr __user *newopt, int newoptlen)\n{\n\tint tot_len = 0;\n\tchar *p;\n\tstruct ipv6_txoptions *opt2;\n\tint err;\n\n\tif (opt) {\n\t\tif (newtype != IPV6_HOPOPTS && opt->hopopt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->hopopt));\n\t\tif (newtype != IPV6_RTHDRDSTOPTS && opt->dst0opt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst0opt));\n\t\tif (newtype != IPV6_RTHDR && opt->srcrt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->srcrt));\n\t\tif (newtype != IPV6_DSTOPTS && opt->dst1opt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst1opt));\n\t}\n\n\tif (newopt && newoptlen)\n\t\ttot_len += CMSG_ALIGN(newoptlen);\n\n\tif (!tot_len)\n\t\treturn NULL;\n\n\ttot_len += sizeof(*opt2);\n\topt2 = sock_kmalloc(sk, tot_len, GFP_ATOMIC);\n\tif (!opt2)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\tmemset(opt2, 0, tot_len);\n\tatomic_set(&opt2->refcnt, 1);\n\topt2->tot_len = tot_len;\n\tp = (char *)(opt2 + 1);\n\n\terr = ipv6_renew_option(opt ? opt->hopopt : NULL, newopt, newoptlen,\n\t\t\t\tnewtype != IPV6_HOPOPTS,\n\t\t\t\t&opt2->hopopt, &p);\n\tif (err)\n\t\tgoto out;\n\n\terr = ipv6_renew_option(opt ? opt->dst0opt : NULL, newopt, newoptlen,\n\t\t\t\tnewtype != IPV6_RTHDRDSTOPTS,\n\t\t\t\t&opt2->dst0opt, &p);\n\tif (err)\n\t\tgoto out;\n\n\terr = ipv6_renew_option(opt ? opt->srcrt : NULL, newopt, newoptlen,\n\t\t\t\tnewtype != IPV6_RTHDR,\n\t\t\t\t(struct ipv6_opt_hdr **)&opt2->srcrt, &p);\n\tif (err)\n\t\tgoto out;\n\n\terr = ipv6_renew_option(opt ? opt->dst1opt : NULL, newopt, newoptlen,\n\t\t\t\tnewtype != IPV6_DSTOPTS,\n\t\t\t\t&opt2->dst1opt, &p);\n\tif (err)\n\t\tgoto out;\n\n\topt2->opt_nflen = (opt2->hopopt ? ipv6_optlen(opt2->hopopt) : 0) +\n\t\t\t  (opt2->dst0opt ? ipv6_optlen(opt2->dst0opt) : 0) +\n\t\t\t  (opt2->srcrt ? ipv6_optlen(opt2->srcrt) : 0);\n\topt2->opt_flen = (opt2->dst1opt ? ipv6_optlen(opt2->dst1opt) : 0);\n\n\treturn opt2;\nout:\n\tsock_kfree_s(sk, opt2, opt2->tot_len);\n\treturn ERR_PTR(err);\n}\n\nstruct ipv6_txoptions *ipv6_fixup_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t  struct ipv6_txoptions *opt)\n{\n\t/*\n\t * ignore the dest before srcrt unless srcrt is being included.\n\t * --yoshfuji\n\t */\n\tif (opt && opt->dst0opt && !opt->srcrt) {\n\t\tif (opt_space != opt) {\n\t\t\tmemcpy(opt_space, opt, sizeof(*opt_space));\n\t\t\topt = opt_space;\n\t\t}\n\t\topt->opt_nflen -= ipv6_optlen(opt->dst0opt);\n\t\topt->dst0opt = NULL;\n\t}\n\n\treturn opt;\n}\nEXPORT_SYMBOL_GPL(ipv6_fixup_options);\n\n/**\n * fl6_update_dst - update flowi destination address with info given\n *                  by srcrt option, if any.\n *\n * @fl6: flowi6 for which daddr is to be updated\n * @opt: struct ipv6_txoptions in which to look for srcrt opt\n * @orig: copy of original daddr address if modified\n *\n * Returns NULL if no txoptions or no srcrt, otherwise returns orig\n * and initial value of fl6->daddr set in orig\n */\nstruct in6_addr *fl6_update_dst(struct flowi6 *fl6,\n\t\t\t\tconst struct ipv6_txoptions *opt,\n\t\t\t\tstruct in6_addr *orig)\n{\n\tif (!opt || !opt->srcrt)\n\t\treturn NULL;\n\n\t*orig = fl6->daddr;\n\tfl6->daddr = *((struct rt0_hdr *)opt->srcrt)->addr;\n\treturn orig;\n}\nEXPORT_SYMBOL_GPL(fl6_update_dst);\n", "/*\n * INET        An implementation of the TCP/IP protocol suite for the LINUX\n *             operating system.  INET is implemented using the  BSD Socket\n *             interface as the means of communication with the user level.\n *\n *             Support for INET6 connection oriented protocols.\n *\n * Authors:    See the TCPv6 sources\n *\n *             This program is free software; you can redistribute it and/or\n *             modify it under the terms of the GNU General Public License\n *             as published by the Free Software Foundation; either version\n *             2 of the License, or(at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/jhash.h>\n#include <linux/slab.h>\n\n#include <net/addrconf.h>\n#include <net/inet_connection_sock.h>\n#include <net/inet_ecn.h>\n#include <net/inet_hashtables.h>\n#include <net/ip6_route.h>\n#include <net/sock.h>\n#include <net/inet6_connection_sock.h>\n\nint inet6_csk_bind_conflict(const struct sock *sk,\n\t\t\t    const struct inet_bind_bucket *tb, bool relax)\n{\n\tconst struct sock *sk2;\n\tint reuse = sk->sk_reuse;\n\tint reuseport = sk->sk_reuseport;\n\tkuid_t uid = sock_i_uid((struct sock *)sk);\n\n\t/* We must walk the whole port owner list in this case. -DaveM */\n\t/*\n\t * See comment in inet_csk_bind_conflict about sock lookup\n\t * vs net namespaces issues.\n\t */\n\tsk_for_each_bound(sk2, &tb->owners) {\n\t\tif (sk != sk2 &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     !sk2->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == sk2->sk_bound_dev_if)) {\n\t\t\tif ((!reuse || !sk2->sk_reuse ||\n\t\t\t     sk2->sk_state == TCP_LISTEN) &&\n\t\t\t    (!reuseport || !sk2->sk_reuseport ||\n\t\t\t     (sk2->sk_state != TCP_TIME_WAIT &&\n\t\t\t      !uid_eq(uid,\n\t\t\t\t      sock_i_uid((struct sock *)sk2))))) {\n\t\t\t\tif (ipv6_rcv_saddr_equal(sk, sk2))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!relax && reuse && sk2->sk_reuse &&\n\t\t\t    sk2->sk_state != TCP_LISTEN &&\n\t\t\t    ipv6_rcv_saddr_equal(sk, sk2))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sk2 != NULL;\n}\nEXPORT_SYMBOL_GPL(inet6_csk_bind_conflict);\n\nstruct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\n\treturn dst;\n}\nEXPORT_SYMBOL(inet6_csk_route_req);\n\nvoid inet6_csk_addr2sockaddr(struct sock *sk, struct sockaddr *uaddr)\n{\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) uaddr;\n\n\tsin6->sin6_family = AF_INET6;\n\tsin6->sin6_addr = sk->sk_v6_daddr;\n\tsin6->sin6_port\t= inet_sk(sk)->inet_dport;\n\t/* We do not store received flowlabel for TCP */\n\tsin6->sin6_flowinfo = 0;\n\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t  sk->sk_bound_dev_if);\n}\nEXPORT_SYMBOL_GPL(inet6_csk_addr2sockaddr);\n\nstatic inline\nvoid __inet6_csk_dst_store(struct sock *sk, struct dst_entry *dst,\n\t\t\t   const struct in6_addr *daddr,\n\t\t\t   const struct in6_addr *saddr)\n{\n\t__ip6_dst_store(sk, dst, daddr, saddr);\n}\n\nstatic inline\nstruct dst_entry *__inet6_csk_dst_check(struct sock *sk, u32 cookie)\n{\n\treturn __sk_dst_check(sk, cookie);\n}\n\nstatic struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}\n\nint inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\n\t/* Restore final destination back after routing done */\n\tfl6.daddr = sk->sk_v6_daddr;\n\n\tres = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),\n\t\t       np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(inet6_csk_xmit);\n\nstruct dst_entry *inet6_csk_update_pmtu(struct sock *sk, u32 mtu)\n{\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst = inet6_csk_route_socket(sk, &fl6);\n\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\tdst->ops->update_pmtu(dst, sk, NULL, mtu);\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\treturn IS_ERR(dst) ? NULL : dst;\n}\nEXPORT_SYMBOL_GPL(inet6_csk_update_pmtu);\n", "/*\n *\tIPv6 BSD socket options interface\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/net/ipv4/ip_sockglue.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *\tFIXME: Make the setsockopt code POSIX compliant: That is\n *\n *\to\tTruncate getsockopt returns\n *\to\tReturn an optlen of the truncated length if need be\n *\n *\tChanges:\n *\tDavid L Stevens <dlstevens@us.ibm.com>:\n *\t\t- added multicast source filtering API for MLDv2\n */\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/mroute6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <net/xfrm.h>\n#include <net/compat.h>\n\n#include <asm/uaccess.h>\n\nstruct ip6_ra_chain *ip6_ra_chain;\nDEFINE_RWLOCK(ip6_ra_lock);\n\nint ip6_ra_control(struct sock *sk, int sel)\n{\n\tstruct ip6_ra_chain *ra, *new_ra, **rap;\n\n\t/* RA packet may be delivered ONLY to IPPROTO_RAW socket */\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num != IPPROTO_RAW)\n\t\treturn -ENOPROTOOPT;\n\n\tnew_ra = (sel >= 0) ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\n\twrite_lock_bh(&ip6_ra_lock);\n\tfor (rap = &ip6_ra_chain; (ra = *rap) != NULL; rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (sel >= 0) {\n\t\t\t\twrite_unlock_bh(&ip6_ra_lock);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\n\t\t\t*rap = ra->next;\n\t\t\twrite_unlock_bh(&ip6_ra_lock);\n\n\t\t\tsock_put(sk);\n\t\t\tkfree(ra);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\twrite_unlock_bh(&ip6_ra_lock);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->sel = sel;\n\tnew_ra->next = ra;\n\t*rap = new_ra;\n\tsock_hold(sk);\n\twrite_unlock_bh(&ip6_ra_lock);\n\treturn 0;\n}\n\nstatic\nstruct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt,\n\t\t   opt);\n\tsk_dst_reset(sk);\n\n\treturn opt;\n}\n\nstatic bool setsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\tcase MCAST_MSFILTER:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val, valbool;\n\tint retv = -ENOPROTOOPT;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tif (!optval)\n\t\tval = 0;\n\telse {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\tval = 0;\n\t}\n\n\tvalbool = (val != 0);\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_setsockopt(sk, optname, optval, optlen);\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase IPV6_ADDRFORM:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val == PF_INET) {\n\t\t\tstruct ipv6_txoptions *opt;\n\t\t\tstruct sk_buff *pktopt;\n\n\t\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t    sk->sk_protocol == IPPROTO_UDPLITE) {\n\t\t\t\tstruct udp_sock *up = udp_sk(sk);\n\t\t\t\tif (up->pending == AF_INET6) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (sk->sk_protocol != IPPROTO_TCP)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\t\tretv = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ipv6_only_sock(sk) ||\n\t\t\t    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {\n\t\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfl6_free_socklist(sk);\n\t\t\tipv6_sock_mc_close(sk);\n\n\t\t\t/*\n\t\t\t * Sock is moving from IPv6 to IPv4 (sk_prot), so\n\t\t\t * remove it from the refcnt debug socks count in the\n\t\t\t * original family...\n\t\t\t */\n\t\t\tsk_refcnt_debug_dec(sk);\n\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, &tcp_prot, 1);\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tsk->sk_prot = &tcp_prot;\n\t\t\t\ticsk->icsk_af_ops = &ipv4_specific;\n\t\t\t\tsk->sk_socket->ops = &inet_stream_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t\t} else {\n\t\t\t\tstruct proto *prot = &udp_prot;\n\n\t\t\t\tif (sk->sk_protocol == IPPROTO_UDPLITE)\n\t\t\t\t\tprot = &udplite_prot;\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, prot, 1);\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tsk->sk_prot = prot;\n\t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t}\n\t\t\topt = xchg((__force struct ipv6_txoptions **)&np->opt,\n\t\t\t\t   NULL);\n\t\t\tif (opt) {\n\t\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\t\t\ttxopt_put(opt);\n\t\t\t}\n\t\t\tpktopt = xchg(&np->pktoptions, NULL);\n\t\t\tkfree_skb(pktopt);\n\n\t\t\tsk->sk_destruct = inet_sock_destruct;\n\t\t\t/*\n\t\t\t * ... and add it to the refcnt debug socks count\n\t\t\t * in the new family. -acme\n\t\t\t */\n\t\t\tsk_refcnt_debug_inc(sk);\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgoto e_inval;\n\n\tcase IPV6_V6ONLY:\n\t\tif (optlen < sizeof(int) ||\n\t\t    inet_sk(sk)->inet_num)\n\t\t\tgoto e_inval;\n\t\tsk->sk_ipv6only = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxoinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxhlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxohlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.srcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.osrcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.hopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.ohopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.dstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.odstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < -1 || val > 0xff)\n\t\t\tgoto e_inval;\n\t\t/* RFC 3542, 6.5: default traffic class of 0x0 */\n\t\tif (val == -1)\n\t\t\tval = 0;\n\t\tnp->tclass = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxtclass = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxpmtu = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TRANSPARENT:\n\t\tif (valbool && !ns_capable(net->user_ns, CAP_NET_ADMIN) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\tretv = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t/* we don't have a separate transparent bit for IPV6 we use the one in the IPv4 socket */\n\t\tinet_sk(sk)->transparent = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxorigdstaddr = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\t\tstruct ipv6_txoptions *opt;\n\n\t\t/* remove any sticky options header with a zero option\n\t\t * length, per RFC3542.\n\t\t */\n\t\tif (optlen == 0)\n\t\t\toptval = NULL;\n\t\telse if (!optval)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct ipv6_opt_hdr) ||\n\t\t\t optlen & 0x7 || optlen > 8 * 255)\n\t\t\tgoto e_inval;\n\n\t\t/* hop-by-hop / destination options are privileged option */\n\t\tretv = -EPERM;\n\t\tif (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\t\tbreak;\n\n\t\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n\t\topt = ipv6_renew_options(sk, opt, optname,\n\t\t\t\t\t (struct ipv6_opt_hdr __user *)optval,\n\t\t\t\t\t optlen);\n\t\tif (IS_ERR(opt)) {\n\t\t\tretv = PTR_ERR(opt);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* routing header option needs extra check */\n\t\tretv = -EINVAL;\n\t\tif (optname == IPV6_RTHDR && opt && opt->srcrt) {\n\t\t\tstruct ipv6_rt_hdr *rthdr = opt->srcrt;\n\t\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t\tif (rthdr->hdrlen != 2 ||\n\t\t\t\t    rthdr->segments_left != 1)\n\t\t\t\t\tgoto sticky_done;\n\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tgoto sticky_done;\n\t\t\t}\n\t\t}\n\n\t\tretv = 0;\n\t\topt = ipv6_update_options(sk, opt);\nsticky_done:\n\t\tif (opt) {\n\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\t\ttxopt_put(opt);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IPV6_PKTINFO:\n\t{\n\t\tstruct in6_pktinfo pkt;\n\n\t\tif (optlen == 0)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct in6_pktinfo) || !optval)\n\t\t\tgoto e_inval;\n\n\t\tif (copy_from_user(&pkt, optval, sizeof(struct in6_pktinfo))) {\n\t\t\t\tretv = -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (sk->sk_bound_dev_if && pkt.ipi6_ifindex != sk->sk_bound_dev_if)\n\t\t\tgoto e_inval;\n\n\t\tnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;\n\t\tnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct ipv6_txoptions *opt = NULL;\n\t\tstruct msghdr msg;\n\t\tstruct flowi6 fl6;\n\t\tint junk;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\n\t\tif (optlen == 0)\n\t\t\tgoto update;\n\n\t\t/* 1K is probably excessive\n\t\t * 1K is surely not enough, 2K per standard header is 16K.\n\t\t */\n\t\tretv = -EINVAL;\n\t\tif (optlen > 64*1024)\n\t\t\tbreak;\n\n\t\topt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);\n\t\tretv = -ENOBUFS;\n\t\tif (!opt)\n\t\t\tbreak;\n\n\t\tmemset(opt, 0, sizeof(*opt));\n\t\tatomic_set(&opt->refcnt, 1);\n\t\topt->tot_len = sizeof(*opt) + optlen;\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(opt+1, optval, optlen))\n\t\t\tgoto done;\n\n\t\tmsg.msg_controllen = optlen;\n\t\tmsg.msg_control = (void *)(opt+1);\n\n\t\tretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, opt, &junk,\n\t\t\t\t\t     &junk, &junk);\n\t\tif (retv)\n\t\t\tgoto done;\nupdate:\n\t\tretv = 0;\n\t\topt = ipv6_update_options(sk, opt);\ndone:\n\t\tif (opt) {\n\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\t\ttxopt_put(opt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase IPV6_UNICAST_HOPS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->hop_limit = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_HOPS:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val != valbool)\n\t\t\tgoto e_inval;\n\t\tnp->mc_loop = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tnp->ucast_oif = 0;\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(net, ifindex);\n\t\tretv = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\tretv = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tnp->ucast_oif = ifindex;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_IF:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tif (val) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != val)\n\t\t\t\tgoto e_inval;\n\n\t\t\tdev = dev_get_by_index(net, val);\n\t\t\tif (!dev) {\n\t\t\t\tretv = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_put(dev);\n\t\t}\n\t\tnp->mcast_oif = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_ADD_MEMBERSHIP)\n\t\t\tretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_JOIN_ANYCAST)\n\t\t\tretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in6 *psin6;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(struct group_req)))\n\t\t\tbreak;\n\t\tif (greq.gr_group.ss_family != AF_INET6) {\n\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin6 = (struct sockaddr_in6 *)&greq.gr_group;\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\tretv = ipv6_sock_mc_join(sk, greq.gr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, greq.gr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tint omode, add;\n\n\t\tif (optlen < sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\tretv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET6 ||\n\t\t    greqs.gsr_source.ss_family != AF_INET6) {\n\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct sockaddr_in6 *psin6;\n\n\t\t\tpsin6 = (struct sockaddr_in6 *)&greqs.gsr_group;\n\t\t\tretv = ipv6_sock_mc_join(sk, greqs.gsr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\t\t/* prior join w/ different source is ok */\n\t\t\tif (retv && retv != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\tretv = ip6_mc_source(add, omode, sk, &greqs);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter *gsf;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen)) {\n\t\t\tkfree(gsf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffffU ||\n\t\t    gsf->gf_numsrc > sysctl_mld_max_msf) {\n\t\t\tkfree(gsf);\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\tkfree(gsf);\n\t\t\tretv = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tretv = ip6_mc_msfilter(sk, gsf);\n\t\tkfree(gsf);\n\n\t\tbreak;\n\t}\n\tcase IPV6_ROUTER_ALERT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = ip6_ra_control(sk, val);\n\t\tbreak;\n\tcase IPV6_MTU_DISCOVER:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tnp->pmtudisc = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val && val < IPV6_MIN_MTU)\n\t\t\tgoto e_inval;\n\t\tnp->frag_size = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->recverr = valbool;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWINFO_SEND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->sndflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWLABEL_MGR:\n\t\tretv = ipv6_flowlabel_opt(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_IPSEC_POLICY:\n\tcase IPV6_XFRM_POLICY:\n\t\tretv = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tretv = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t    {\n\t\tunsigned int pref = 0;\n\t\tunsigned int prefmask = ~0;\n\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EINVAL;\n\n\t\t/* check PUBLIC/TMP/PUBTMP_DEFAULT conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_PUBLIC|\n\t\t\t       IPV6_PREFER_SRC_TMP|\n\t\t\t       IPV6_PREFER_SRC_PUBTMP_DEFAULT)) {\n\t\tcase IPV6_PREFER_SRC_PUBLIC:\n\t\t\tpref |= IPV6_PREFER_SRC_PUBLIC;\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_TMP:\n\t\t\tpref |= IPV6_PREFER_SRC_TMP;\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_PUBTMP_DEFAULT:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tgoto pref_skip_pubtmp;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tprefmask &= ~(IPV6_PREFER_SRC_PUBLIC|\n\t\t\t      IPV6_PREFER_SRC_TMP);\npref_skip_pubtmp:\n\n\t\t/* check HOME/COA conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_HOME|IPV6_PREFER_SRC_COA)) {\n\t\tcase IPV6_PREFER_SRC_HOME:\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_COA:\n\t\t\tpref |= IPV6_PREFER_SRC_COA;\n\t\tcase 0:\n\t\t\tgoto pref_skip_coa;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tprefmask &= ~IPV6_PREFER_SRC_COA;\npref_skip_coa:\n\n\t\t/* check CGA/NONCGA conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_CGA|IPV6_PREFER_SRC_NONCGA)) {\n\t\tcase IPV6_PREFER_SRC_CGA:\n\t\tcase IPV6_PREFER_SRC_NONCGA:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tnp->srcprefs = (np->srcprefs & prefmask) | pref;\n\t\tretv = 0;\n\n\t\tbreak;\n\t    }\n\tcase IPV6_MINHOPCOUNT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tnp->min_hopcount = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_DONTFRAG:\n\t\tnp->dontfrag = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tnp->autoflowlabel = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\n\treturn retv;\n\ne_inval:\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}\n\nint ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t\t\toptname != IPV6_XFRM_POLICY) {\n\t\tlock_sock(sk);\n\t\terr = nf_setsockopt(sk, PF_INET6, optname, optval,\n\t\t\t\toptlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ipv6_setsockopt);\n\n#ifdef CONFIG_COMPAT\nint compat_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_setsockopt != NULL)\n\t\t\treturn udp_prot.compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_setsockopt);\n\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t    optname != IPV6_XFRM_POLICY) {\n\t\tlock_sock(sk);\n\t\terr = compat_nf_setsockopt(sk, PF_INET6, optname,\n\t\t\t\t\t   optval, optlen);\n\t\trelease_sock(sk);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(compat_ipv6_setsockopt);\n#endif\n\nstatic int ipv6_getsockopt_sticky(struct sock *sk, struct ipv6_txoptions *opt,\n\t\t\t\t  int optname, char __user *optval, int len)\n{\n\tstruct ipv6_opt_hdr *hdr;\n\n\tif (!opt)\n\t\treturn 0;\n\n\tswitch (optname) {\n\tcase IPV6_HOPOPTS:\n\t\thdr = opt->hopopt;\n\t\tbreak;\n\tcase IPV6_RTHDRDSTOPTS:\n\t\thdr = opt->dst0opt;\n\t\tbreak;\n\tcase IPV6_RTHDR:\n\t\thdr = (struct ipv6_opt_hdr *)opt->srcrt;\n\t\tbreak;\n\tcase IPV6_DSTOPTS:\n\t\thdr = opt->dst1opt;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\t/* should not happen */\n\t}\n\n\tif (!hdr)\n\t\treturn 0;\n\n\tlen = min_t(unsigned int, len, ipv6_optlen(hdr));\n\tif (copy_to_user(optval, hdr, len))\n\t\treturn -EFAULT;\n\treturn len;\n}\n\nstatic int do_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen, unsigned int flags)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint len;\n\tint val;\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tswitch (optname) {\n\tcase IPV6_ADDRFORM:\n\t\tif (sk->sk_protocol != IPPROTO_UDP &&\n\t\t    sk->sk_protocol != IPPROTO_UDPLITE &&\n\t\t    sk->sk_protocol != IPPROTO_TCP)\n\t\t\treturn -ENOPROTOOPT;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tval = sk->sk_family;\n\t\tbreak;\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter gsf;\n\t\tint err;\n\n\t\tif (len < GROUP_FILTER_SIZE(0))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0)))\n\t\t\treturn -EFAULT;\n\t\tif (gsf.gf_group.ss_family != AF_INET6)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tlock_sock(sk);\n\t\terr = ip6_mc_msfget(sk, &gsf,\n\t\t\t(struct group_filter __user *)optval, optlen);\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\t\tstruct sk_buff *skb;\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tmsg.msg_control = optval;\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = flags;\n\n\t\tlock_sock(sk);\n\t\tskb = np->pktoptions;\n\t\tif (skb)\n\t\t\tip6_datagram_recv_ctl(sk, &msg, skb);\n\t\trelease_sock(sk);\n\t\tif (!skb) {\n\t\t\tif (np->rxopt.bits.rxinfo) {\n\t\t\t\tstruct in6_pktinfo src_info;\n\t\t\t\tsrc_info.ipi6_ifindex = np->mcast_oif ? np->mcast_oif :\n\t\t\t\t\tnp->sticky_pktinfo.ipi6_ifindex;\n\t\t\t\tsrc_info.ipi6_addr = np->mcast_oif ? sk->sk_v6_daddr : np->sticky_pktinfo.ipi6_addr;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_PKTINFO, sizeof(src_info), &src_info);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxhlim) {\n\t\t\t\tint hlim = np->mcast_hops;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxtclass) {\n\t\t\t\tint tclass = (int)ip6_tclass(np->rcv_flowinfo);\n\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxoinfo) {\n\t\t\t\tstruct in6_pktinfo src_info;\n\t\t\t\tsrc_info.ipi6_ifindex = np->mcast_oif ? np->mcast_oif :\n\t\t\t\t\tnp->sticky_pktinfo.ipi6_ifindex;\n\t\t\t\tsrc_info.ipi6_addr = np->mcast_oif ? sk->sk_v6_daddr :\n\t\t\t\t\t\t\t\t     np->sticky_pktinfo.ipi6_addr;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxohlim) {\n\t\t\t\tint hlim = np->mcast_hops;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxflow) {\n\t\t\t\t__be32 flowinfo = np->rcv_flowinfo;\n\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);\n\t\t\t}\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn put_user(len, optlen);\n\t}\n\tcase IPV6_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\n\t\tval = 0;\n\t\trcu_read_lock();\n\t\tdst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tval = dst_mtu(dst);\n\t\trcu_read_unlock();\n\t\tif (!val)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\t}\n\n\tcase IPV6_V6ONLY:\n\t\tval = sk->sk_ipv6only;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tval = np->rxopt.bits.rxinfo;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tval = np->rxopt.bits.rxoinfo;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tval = np->rxopt.bits.rxhlim;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tval = np->rxopt.bits.rxohlim;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tval = np->rxopt.bits.srcrt;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tval = np->rxopt.bits.osrcrt;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\t\tstruct ipv6_txoptions *opt;\n\n\t\tlock_sock(sk);\n\t\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n\t\tlen = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);\n\t\trelease_sock(sk);\n\t\t/* check if ipv6_getsockopt_sticky() returns err code */\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\treturn put_user(len, optlen);\n\t}\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tval = np->rxopt.bits.hopopts;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tval = np->rxopt.bits.ohopopts;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tval = np->rxopt.bits.dstopts;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tval = np->rxopt.bits.odstopts;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tval = np->tclass;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tval = np->rxopt.bits.rxtclass;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tval = np->rxopt.bits.rxflow;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tval = np->rxopt.bits.rxpmtu;\n\t\tbreak;\n\n\tcase IPV6_PATHMTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tstruct ip6_mtuinfo mtuinfo;\n\n\t\tif (len < sizeof(mtuinfo))\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof(mtuinfo);\n\t\tmemset(&mtuinfo, 0, sizeof(mtuinfo));\n\n\t\trcu_read_lock();\n\t\tdst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tmtuinfo.ip6m_mtu = dst_mtu(dst);\n\t\trcu_read_unlock();\n\t\tif (!mtuinfo.ip6m_mtu)\n\t\t\treturn -ENOTCONN;\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &mtuinfo, len))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase IPV6_TRANSPARENT:\n\t\tval = inet_sk(sk)->transparent;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tval = np->rxopt.bits.rxorigdstaddr;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_HOPS:\n\tcase IPV6_MULTICAST_HOPS:\n\t{\n\t\tstruct dst_entry *dst;\n\n\t\tif (optname == IPV6_UNICAST_HOPS)\n\t\t\tval = np->hop_limit;\n\t\telse\n\t\t\tval = np->mcast_hops;\n\n\t\tif (val < 0) {\n\t\t\trcu_read_lock();\n\t\t\tdst = __sk_dst_get(sk);\n\t\t\tif (dst)\n\t\t\t\tval = ip6_dst_hoplimit(dst);\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tif (val < 0)\n\t\t\tval = sock_net(sk)->ipv6.devconf_all->hop_limit;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tval = np->mc_loop;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_IF:\n\t\tval = np->mcast_oif;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t\tval = (__force int)htonl((__u32) np->ucast_oif);\n\t\tbreak;\n\n\tcase IPV6_MTU_DISCOVER:\n\t\tval = np->pmtudisc;\n\t\tbreak;\n\n\tcase IPV6_RECVERR:\n\t\tval = np->recverr;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO_SEND:\n\t\tval = np->sndflow;\n\t\tbreak;\n\n\tcase IPV6_FLOWLABEL_MGR:\n\t{\n\t\tstruct in6_flowlabel_req freq;\n\t\tint flags;\n\n\t\tif (len < sizeof(freq))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&freq, optval, sizeof(freq)))\n\t\t\treturn -EFAULT;\n\n\t\tif (freq.flr_action != IPV6_FL_A_GET)\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof(freq);\n\t\tflags = freq.flr_flags;\n\n\t\tmemset(&freq, 0, sizeof(freq));\n\n\t\tval = ipv6_flowlabel_opt_get(sk, &freq, flags);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &freq, len))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t\tval = 0;\n\n\t\tif (np->srcprefs & IPV6_PREFER_SRC_TMP)\n\t\t\tval |= IPV6_PREFER_SRC_TMP;\n\t\telse if (np->srcprefs & IPV6_PREFER_SRC_PUBLIC)\n\t\t\tval |= IPV6_PREFER_SRC_PUBLIC;\n\t\telse {\n\t\t\t/* XXX: should we return system default? */\n\t\t\tval |= IPV6_PREFER_SRC_PUBTMP_DEFAULT;\n\t\t}\n\n\t\tif (np->srcprefs & IPV6_PREFER_SRC_COA)\n\t\t\tval |= IPV6_PREFER_SRC_COA;\n\t\telse\n\t\t\tval |= IPV6_PREFER_SRC_HOME;\n\t\tbreak;\n\n\tcase IPV6_MINHOPCOUNT:\n\t\tval = np->min_hopcount;\n\t\tbreak;\n\n\tcase IPV6_DONTFRAG:\n\t\tval = np->dontfrag;\n\t\tbreak;\n\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tval = np->autoflowlabel;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tlen = min_t(unsigned int, sizeof(int), len);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ipv6_getsockopt(sk, level, optname, optval, optlen, 0);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\terr = nf_getsockopt(sk, PF_INET6, optname, optval,\n\t\t\t\t&len);\n\t\trelease_sock(sk);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ipv6_getsockopt);\n\n#ifdef CONFIG_COMPAT\nint compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_getsockopt != NULL)\n\t\t\treturn udp_prot.compat_getsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optname == MCAST_MSFILTER)\n\t\treturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_getsockopt);\n\n\terr = do_ipv6_getsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t MSG_CMSG_COMPAT);\n#ifdef CONFIG_NETFILTER\n\t/* we need to exclude all possible ENOPROTOOPTs except default case */\n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\tlock_sock(sk);\n\t\terr = compat_nf_getsockopt(sk, PF_INET6,\n\t\t\t\t\t   optname, optval, &len);\n\t\trelease_sock(sk);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(compat_ipv6_getsockopt);\n#endif\n\n", "/*\n *\tRAW sockets for IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tAdapted from linux/net/ipv4/raw.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI,H.@USAGI\t:\traw checksum (RFC2292(bis) compliance)\n *\tKazunori MIYAZAWA @USAGI:\tchange process style to use ip6_append_data\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmpv6.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/skbuff.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/addrconf.h>\n#include <net/transp_v6.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/tcp_states.h>\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n#include <net/mip6.h>\n#endif\n#include <linux/mroute6.h>\n\n#include <net/raw.h>\n#include <net/rawv6.h>\n#include <net/xfrm.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n\n#define\tICMPV6_HDRLEN\t4\t/* ICMPv6 header, RFC 4443 Section 2.1 */\n\nstatic struct raw_hashinfo raw_v6_hashinfo = {\n\t.lock = __RW_LOCK_UNLOCKED(raw_v6_hashinfo.lock),\n};\n\nstatic struct sock *__raw_v6_lookup(struct net *net, struct sock *sk,\n\t\tunsigned short num, const struct in6_addr *loc_addr,\n\t\tconst struct in6_addr *rmt_addr, int dif)\n{\n\tbool is_multicast = ipv6_addr_is_multicast(loc_addr);\n\n\tsk_for_each_from(sk)\n\t\tif (inet_sk(sk)->inet_num == num) {\n\n\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\tcontinue;\n\n\t\t\tif (!ipv6_addr_any(&sk->sk_v6_daddr) &&\n\t\t\t    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr))\n\t\t\t\tcontinue;\n\n\t\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif)\n\t\t\t\tcontinue;\n\n\t\t\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\t\t\tif (ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr))\n\t\t\t\t\tgoto found;\n\t\t\t\tif (is_multicast &&\n\t\t\t\t    inet6_mc_check(sk, loc_addr, rmt_addr))\n\t\t\t\t\tgoto found;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto found;\n\t\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\n/*\n *\t0 - deliver\n *\t1 - block\n */\nstatic int icmpv6_filter(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct icmp6hdr _hdr;\n\tconst struct icmp6hdr *hdr;\n\n\t/* We require only the four bytes of the ICMPv6 header, not any\n\t * additional bytes of message body in \"struct icmp6hdr\".\n\t */\n\thdr = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t ICMPV6_HDRLEN, &_hdr);\n\tif (hdr) {\n\t\tconst __u32 *data = &raw6_sk(sk)->filter.data[0];\n\t\tunsigned int type = hdr->icmp6_type;\n\n\t\treturn (data[type >> 5] & (1U << (type & 31))) != 0;\n\t}\n\treturn 1;\n}\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\ntypedef int mh_filter_t(struct sock *sock, struct sk_buff *skb);\n\nstatic mh_filter_t __rcu *mh_filter __read_mostly;\n\nint rawv6_mh_filter_register(mh_filter_t filter)\n{\n\trcu_assign_pointer(mh_filter, filter);\n\treturn 0;\n}\nEXPORT_SYMBOL(rawv6_mh_filter_register);\n\nint rawv6_mh_filter_unregister(mh_filter_t filter)\n{\n\tRCU_INIT_POINTER(mh_filter, NULL);\n\tsynchronize_rcu();\n\treturn 0;\n}\nEXPORT_SYMBOL(rawv6_mh_filter_unregister);\n\n#endif\n\n/*\n *\tdemultiplex raw sockets.\n *\t(should consider queueing the skb in the sock receive_queue\n *\twithout calling rawv6.c)\n *\n *\tCaller owns SKB so we must make clones.\n */\nstatic bool ipv6_raw_deliver(struct sk_buff *skb, int nexthdr)\n{\n\tconst struct in6_addr *saddr;\n\tconst struct in6_addr *daddr;\n\tstruct sock *sk;\n\tbool delivered = false;\n\t__u8 hash;\n\tstruct net *net;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = saddr + 1;\n\n\thash = nexthdr & (RAW_HTABLE_SIZE - 1);\n\n\tread_lock(&raw_v6_hashinfo.lock);\n\tsk = sk_head(&raw_v6_hashinfo.ht[hash]);\n\n\tif (!sk)\n\t\tgoto out;\n\n\tnet = dev_net(skb->dev);\n\tsk = __raw_v6_lookup(net, sk, nexthdr, daddr, saddr, inet6_iif(skb));\n\n\twhile (sk) {\n\t\tint filtered;\n\n\t\tdelivered = true;\n\t\tswitch (nexthdr) {\n\t\tcase IPPROTO_ICMPV6:\n\t\t\tfiltered = icmpv6_filter(sk, skb);\n\t\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPPROTO_MH:\n\t\t{\n\t\t\t/* XXX: To validate MH only once for each packet,\n\t\t\t * this is placed here. It should be after checking\n\t\t\t * xfrm policy, however it doesn't. The checking xfrm\n\t\t\t * policy is placed in rawv6_rcv() because it is\n\t\t\t * required for each socket.\n\t\t\t */\n\t\t\tmh_filter_t *filter;\n\n\t\t\tfilter = rcu_dereference(mh_filter);\n\t\t\tfiltered = filter ? (*filter)(sk, skb) : 0;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tfiltered = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (filtered < 0)\n\t\t\tbreak;\n\t\tif (filtered == 0) {\n\t\t\tstruct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Not releasing hash table! */\n\t\t\tif (clone) {\n\t\t\t\tnf_reset(clone);\n\t\t\t\trawv6_rcv(sk, clone);\n\t\t\t}\n\t\t}\n\t\tsk = __raw_v6_lookup(net, sk_next(sk), nexthdr, daddr, saddr,\n\t\t\t\t     inet6_iif(skb));\n\t}\nout:\n\tread_unlock(&raw_v6_hashinfo.lock);\n\treturn delivered;\n}\n\nbool raw6_local_deliver(struct sk_buff *skb, int nexthdr)\n{\n\tstruct sock *raw_sk;\n\n\traw_sk = sk_head(&raw_v6_hashinfo.ht[nexthdr & (RAW_HTABLE_SIZE - 1)]);\n\tif (raw_sk && !ipv6_raw_deliver(skb, nexthdr))\n\t\traw_sk = NULL;\n\n\treturn raw_sk != NULL;\n}\n\n/* This cleans up af_inet6 a bit. -DaveM */\nstatic int rawv6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) uaddr;\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (addr->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\n\t/* Raw sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out;\n\n\trcu_read_lock();\n\t/* Check if the address belongs to the host. */\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->sin6_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\tif (!(addr_type & IPV6_ADDR_MULTICAST) &&\n\t\t    !sock_net(sk)->ipv6.sysctl.ip_nonlocal_bind) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->sin6_addr,\n\t\t\t\t\t   dev, 0)) {\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->sin6_addr;\n\tif (!(addr_type & IPV6_ADDR_MULTICAST))\n\t\tnp->saddr = addr->sin6_addr;\n\terr = 0;\nout_unlock:\n\trcu_read_unlock();\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void rawv6_err(struct sock *sk, struct sk_buff *skb,\n\t       struct inet6_skb_parm *opt,\n\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint err;\n\tint harderr;\n\n\t/* Report error on raw socket, if:\n\t   1. User requested recverr.\n\t   2. Socket is connected (otherwise the error indication\n\t      is useless without recverr and error is hard.\n\t */\n\tif (!np->recverr && sk->sk_state != TCP_ESTABLISHED)\n\t\treturn;\n\n\tharderr = icmpv6_err_convert(type, code, &err);\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tip6_sk_update_pmtu(skb, sk, info);\n\t\tharderr = (np->pmtudisc == IPV6_PMTUDISC_DO);\n\t}\n\tif (type == NDISC_REDIRECT) {\n\t\tip6_sk_redirect(skb, sk);\n\t\treturn;\n\t}\n\tif (np->recverr) {\n\t\tu8 *payload = skb->data;\n\t\tif (!inet->hdrincl)\n\t\t\tpayload += offset;\n\t\tipv6_icmp_error(sk, skb, err, 0, ntohl(info), payload);\n\t}\n\n\tif (np->recverr || harderr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t}\n}\n\nvoid raw6_icmp_error(struct sk_buff *skb, int nexthdr,\n\t\tu8 type, u8 code, int inner_offset, __be32 info)\n{\n\tstruct sock *sk;\n\tint hash;\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct net *net;\n\n\thash = nexthdr & (RAW_HTABLE_SIZE - 1);\n\n\tread_lock(&raw_v6_hashinfo.lock);\n\tsk = sk_head(&raw_v6_hashinfo.ht[hash]);\n\tif (sk) {\n\t\t/* Note: ipv6_hdr(skb) != skb->data */\n\t\tconst struct ipv6hdr *ip6h = (const struct ipv6hdr *)skb->data;\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t\tnet = dev_net(skb->dev);\n\n\t\twhile ((sk = __raw_v6_lookup(net, sk, nexthdr, saddr, daddr,\n\t\t\t\t\t\tinet6_iif(skb)))) {\n\t\t\trawv6_err(sk, skb, NULL, type, code,\n\t\t\t\t\tinner_offset, info);\n\t\t\tsk = sk_next(sk);\n\t\t}\n\t}\n\tread_unlock(&raw_v6_hashinfo.lock);\n}\n\nstatic inline int rawv6_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tif ((raw6_sk(sk)->checksum || rcu_access_pointer(sk->sk_filter)) &&\n\t    skb_checksum_complete(skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\t/* Charge it to the socket. */\n\tskb_dst_drop(skb);\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tThis is next to useless...\n *\tif we demultiplex in network layer we don't need the extra call\n *\tjust to queue the skb...\n *\tmaybe we could have the network decide upon a hint if it\n *\tshould call raw_rcv for demultiplexing\n */\nint rawv6_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (!rp->checksum)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tskb_postpull_rcsum(skb, skb_network_header(skb),\n\t\t\t\t   skb_network_header_len(skb));\n\t\tif (!csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr,\n\t\t\t\t     skb->len, inet->inet_num, skb->csum))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\tif (!skb_csum_unnecessary(skb))\n\t\tskb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t\t\t\t &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t\t skb->len,\n\t\t\t\t\t\t\t inet->inet_num, 0));\n\n\tif (inet->hdrincl) {\n\t\tif (skb_checksum_complete(skb)) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tkfree_skb(skb);\n\t\t\treturn NET_RX_DROP;\n\t\t}\n\t}\n\n\trawv6_rcv_skb(sk, skb);\n\treturn 0;\n}\n\n\n/*\n *\tThis should be easy, if there is something there\n *\twe return it, otherwise we block.\n */\n\nstatic int rawv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tif (skb_csum_unnecessary(skb)) {\n\t\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\t} else if (msg->msg_flags&MSG_TRUNC) {\n\t\tif (__skb_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\t} else {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, 0, msg);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Copy the address. */\n\tif (sin6) {\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  inet6_iif(skb));\n\t\t*addr_len = sizeof(*sin6);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = skb->len;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tskb_kill_datagram(sk, skb, flags);\n\n\t/* Error for blocking case is chosen to masquerade\n\t   as some normal condition.\n\t */\n\terr = (flags&MSG_DONTWAIT) ? -EAGAIN : -EHOSTUNREACH;\n\tgoto out;\n}\n\nstatic int rawv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t     struct raw6_sock *rp)\n{\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tint offset;\n\tint len;\n\tint total_len;\n\t__wsum tmp_csum;\n\t__sum16 csum;\n\n\tif (!rp->checksum)\n\t\tgoto send;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\tgoto out;\n\n\toffset = rp->offset;\n\ttotal_len = inet_sk(sk)->cork.base.length;\n\tif (offset >= total_len - 1) {\n\t\terr = -EINVAL;\n\t\tip6_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\n\t/* should be check HW csum miyazawa */\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\t/*\n\t\t * Only one fragment on the socket.\n\t\t */\n\t\ttmp_csum = skb->csum;\n\t} else {\n\t\tstruct sk_buff *csum_skb = NULL;\n\t\ttmp_csum = 0;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\ttmp_csum = csum_add(tmp_csum, skb->csum);\n\n\t\t\tif (csum_skb)\n\t\t\t\tcontinue;\n\n\t\t\tlen = skb->len - skb_transport_offset(skb);\n\t\t\tif (offset >= len) {\n\t\t\t\toffset -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcsum_skb = skb;\n\t\t}\n\n\t\tskb = csum_skb;\n\t}\n\n\toffset += skb_transport_offset(skb);\n\tBUG_ON(skb_copy_bits(skb, offset, &csum, 2));\n\n\t/* in case cksum was not initialized */\n\tif (unlikely(csum))\n\t\ttmp_csum = csum_sub(tmp_csum, csum_unfold(csum));\n\n\tcsum = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t       total_len, fl6->flowi6_proto, tmp_csum);\n\n\tif (csum == 0 && fl6->flowi6_proto == IPPROTO_UDP)\n\t\tcsum = CSUM_MANGLED_0;\n\n\tBUG_ON(skb_store_bits(skb, offset, &csum, 2));\n\nsend:\n\terr = ip6_push_pending_frames(sk);\nout:\n\treturn err;\n}\n\nstatic int rawv6_send_hdrinc(struct sock *sk, struct msghdr *msg, int length,\n\t\t\tstruct flowi6 *fl6, struct dst_entry **dstp,\n\t\t\tunsigned int flags)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct rt6_info *rt = (struct rt6_info *)*dstp;\n\tint hlen = LL_RESERVED_SPACE(rt->dst.dev);\n\tint tlen = rt->dst.dev->needed_tailroom;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tipv6_local_error(sk, EMSGSIZE, fl6, rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\tskb_dst_set(skb, &rt->dst);\n\t*dstp = NULL;\n\n\tskb_put(skb, length);\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb->transport_header = skb->network_header;\n\terr = memcpy_from_msg(iph, msg, length);\n\tif (err)\n\t\tgoto error_fault;\n\n\tIP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, net, sk, skb,\n\t\t      NULL, rt->dst.dev, dst_output);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\tif (err)\n\t\tgoto error;\nout:\n\treturn 0;\n\nerror_fault:\n\terr = -EFAULT;\n\tkfree_skb(skb);\nerror:\n\tIP6_INC_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\tif (err == -ENOBUFS && !np->recverr)\n\t\terr = 0;\n\treturn err;\n}\n\nstruct raw6_frag_vec {\n\tstruct msghdr *msg;\n\tint hlen;\n\tchar c[4];\n};\n\nstatic int rawv6_probe_proto_opt(struct raw6_frag_vec *rfv, struct flowi6 *fl6)\n{\n\tint err = 0;\n\tswitch (fl6->flowi6_proto) {\n\tcase IPPROTO_ICMPV6:\n\t\trfv->hlen = 2;\n\t\terr = memcpy_from_msg(rfv->c, rfv->msg, rfv->hlen);\n\t\tif (!err) {\n\t\t\tfl6->fl6_icmp_type = rfv->c[0];\n\t\t\tfl6->fl6_icmp_code = rfv->c[1];\n\t\t}\n\t\tbreak;\n\tcase IPPROTO_MH:\n\t\trfv->hlen = 4;\n\t\terr = memcpy_from_msg(rfv->c, rfv->msg, rfv->hlen);\n\t\tif (!err)\n\t\t\tfl6->fl6_mh_type = rfv->c[2];\n\t}\n\treturn err;\n}\n\nstatic int raw6_getfrag(void *from, char *to, int offset, int len, int odd,\n\t\t       struct sk_buff *skb)\n{\n\tstruct raw6_frag_vec *rfv = from;\n\n\tif (offset < rfv->hlen) {\n\t\tint copy = min(rfv->hlen - offset, len);\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tmemcpy(to, rfv->c + offset, copy);\n\t\telse\n\t\t\tskb->csum = csum_block_add(\n\t\t\t\tskb->csum,\n\t\t\t\tcsum_partial_copy_nocheck(rfv->c + offset,\n\t\t\t\t\t\t\t  to, copy, 0),\n\t\t\t\todd);\n\n\t\todd = 0;\n\t\toffset += copy;\n\t\tto += copy;\n\t\tlen -= copy;\n\n\t\tif (!len)\n\t\t\treturn 0;\n\t}\n\n\toffset -= rfv->hlen;\n\n\treturn ip_generic_getfrag(rfv->msg, to, offset, len, odd, skb);\n}\n\nstatic int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ipv6_txoptions opt_space;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct raw6_frag_vec rfv;\n\tstruct flowi6 fl6;\n\tint addr_len = msg->msg_namelen;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tu16 proto;\n\tint err;\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t */\n\tif (len > INT_MAX)\n\t\treturn -EMSGSIZE;\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (sin6) {\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\treturn -EINVAL;\n\n\t\tif (sin6->sin6_family && sin6->sin6_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\t/* port is the proto value [0..255] carried in nexthdr */\n\t\tproto = ntohs(sin6->sin6_port);\n\n\t\tif (!proto)\n\t\t\tproto = inet->inet_num;\n\t\telse if (proto != inet->inet_num)\n\t\t\treturn -EINVAL;\n\n\t\tif (proto > 255)\n\t\t\treturn -EINVAL;\n\n\t\tdaddr = &sin6->sin6_addr;\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (!flowlabel)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))\n\t\t\tfl6.flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tproto = inet->inet_num;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (fl6.flowi6_oif == 0)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(struct ipv6_txoptions);\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,\n\t\t\t\t\t    &hlimit, &tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = proto;\n\trfv.msg = msg;\n\trfv.hlen = 0;\n\terr = rawv6_probe_proto_opt(&rfv, &fl6);\n\tif (err)\n\t\tgoto out;\n\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tif (inet->hdrincl)\n\t\tfl6.flowi6_flags |= FLOWI_FLAG_KNOWN_NH;\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\tif (hlimit < 0)\n\t\thlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\n\nback_from_confirm:\n\tif (inet->hdrincl)\n\t\terr = rawv6_send_hdrinc(sk, msg, len, &fl6, &dst, msg->msg_flags);\n\telse {\n\t\tlock_sock(sk);\n\t\terr = ip6_append_data(sk, raw6_getfrag, &rfv,\n\t\t\tlen, 0, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst,\n\t\t\tmsg->msg_flags, dontfrag);\n\n\t\tif (err)\n\t\t\tip6_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE))\n\t\t\terr = rawv6_push_pending_frames(sk, &fl6, rp);\n\t\trelease_sock(sk);\n\t}\ndone:\n\tdst_release(dst);\nout:\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\treturn err < 0 ? err : len;\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic int rawv6_seticmpfilter(struct sock *sk, int level, int optname,\n\t\t\t       char __user *optval, int optlen)\n{\n\tswitch (optname) {\n\tcase ICMPV6_FILTER:\n\t\tif (optlen > sizeof(struct icmp6_filter))\n\t\t\toptlen = sizeof(struct icmp6_filter);\n\t\tif (copy_from_user(&raw6_sk(sk)->filter, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\treturn 0;\n}\n\nstatic int rawv6_geticmpfilter(struct sock *sk, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tint len;\n\n\tswitch (optname) {\n\tcase ICMPV6_FILTER:\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(struct icmp6_filter))\n\t\t\tlen = sizeof(struct icmp6_filter);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &raw6_sk(sk)->filter, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int do_rawv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tint val;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase IPV6_CHECKSUM:\n\t\tif (inet_sk(sk)->inet_num == IPPROTO_ICMPV6 &&\n\t\t    level == IPPROTO_IPV6) {\n\t\t\t/*\n\t\t\t * RFC3542 tells that IPV6_CHECKSUM socket\n\t\t\t * option in the IPPROTO_IPV6 level is not\n\t\t\t * allowed on ICMPv6 sockets.\n\t\t\t * If you want to set it, use IPPROTO_RAW\n\t\t\t * level IPV6_CHECKSUM socket option\n\t\t\t * (Linux extension).\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* You may get strange result with a positive odd offset;\n\t\t   RFC2292bis agrees with me. */\n\t\tif (val > 0 && (val&1))\n\t\t\treturn -EINVAL;\n\t\tif (val < 0) {\n\t\t\trp->checksum = 0;\n\t\t} else {\n\t\t\trp->checksum = 1;\n\t\t\trp->offset = val;\n\t\t}\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int rawv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_seticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM)\n\t\t\tbreak;\n\tdefault:\n\t\treturn ipv6_setsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\treturn do_rawv6_setsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_rawv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_seticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM)\n\t\t\tbreak;\n\tdefault:\n\t\treturn compat_ipv6_setsockopt(sk, level, optname,\n\t\t\t\t\t      optval, optlen);\n\t}\n\treturn do_rawv6_setsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int do_rawv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tint val, len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase IPV6_CHECKSUM:\n\t\t/*\n\t\t * We allow getsockopt() for IPPROTO_IPV6-level\n\t\t * IPV6_CHECKSUM socket option on ICMPv6 sockets\n\t\t * since RFC3542 is silent about it.\n\t\t */\n\t\tif (rp->checksum == 0)\n\t\t\tval = -1;\n\t\telse\n\t\t\tval = rp->offset;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, sizeof(int), len);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int rawv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_geticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM)\n\t\t\tbreak;\n\tdefault:\n\t\treturn ipv6_getsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\treturn do_rawv6_getsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_rawv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_geticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM)\n\t\t\tbreak;\n\tdefault:\n\t\treturn compat_ipv6_getsockopt(sk, level, optname,\n\t\t\t\t\t      optval, optlen);\n\t}\n\treturn do_rawv6_getsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int rawv6_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ: {\n\t\tint amount = sk_wmem_alloc_get(sk);\n\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb_tail_pointer(skb) -\n\t\t\t\tskb_transport_header(skb);\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\n\tdefault:\n#ifdef CONFIG_IPV6_MROUTE\n\t\treturn ip6mr_ioctl(sk, cmd, (void __user *)arg);\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_rawv6_ioctl(struct sock *sk, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\tcase SIOCINQ:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n#ifdef CONFIG_IPV6_MROUTE\n\t\treturn ip6mr_compat_ioctl(sk, cmd, compat_ptr(arg));\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n#endif\n\nstatic void rawv6_close(struct sock *sk, long timeout)\n{\n\tif (inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\tip6_ra_control(sk, -1);\n\tip6mr_sk_done(sk);\n\tsk_common_release(sk);\n}\n\nstatic void raw6_destroy(struct sock *sk)\n{\n\tlock_sock(sk);\n\tip6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tinet6_destroy_sock(sk);\n}\n\nstatic int rawv6_init_sk(struct sock *sk)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\n\tswitch (inet_sk(sk)->inet_num) {\n\tcase IPPROTO_ICMPV6:\n\t\trp->checksum = 1;\n\t\trp->offset   = 2;\n\t\tbreak;\n\tcase IPPROTO_MH:\n\t\trp->checksum = 1;\n\t\trp->offset   = 4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstruct proto rawv6_prot = {\n\t.name\t\t   = \"RAWv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = rawv6_close,\n\t.destroy\t   = raw6_destroy,\n\t.connect\t   = ip6_datagram_connect_v6_only,\n\t.disconnect\t   = udp_disconnect,\n\t.ioctl\t\t   = rawv6_ioctl,\n\t.init\t\t   = rawv6_init_sk,\n\t.setsockopt\t   = rawv6_setsockopt,\n\t.getsockopt\t   = rawv6_getsockopt,\n\t.sendmsg\t   = rawv6_sendmsg,\n\t.recvmsg\t   = rawv6_recvmsg,\n\t.bind\t\t   = rawv6_bind,\n\t.backlog_rcv\t   = rawv6_rcv_skb,\n\t.hash\t\t   = raw_hash_sk,\n\t.unhash\t\t   = raw_unhash_sk,\n\t.obj_size\t   = sizeof(struct raw6_sock),\n\t.h.raw_hash\t   = &raw_v6_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_rawv6_setsockopt,\n\t.compat_getsockopt = compat_rawv6_getsockopt,\n\t.compat_ioctl\t   = compat_rawv6_ioctl,\n#endif\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int raw6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\n\t} else {\n\t\tstruct sock *sp = v;\n\t\t__u16 srcp  = inet_sk(sp)->inet_num;\n\t\tip6_dgram_sock_seq_show(seq, v, srcp, 0,\n\t\t\t\t\traw_seq_private(seq)->bucket);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations raw6_seq_ops = {\n\t.start =\traw_seq_start,\n\t.next =\t\traw_seq_next,\n\t.stop =\t\traw_seq_stop,\n\t.show =\t\traw6_seq_show,\n};\n\nstatic int raw6_seq_open(struct inode *inode, struct file *file)\n{\n\treturn raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);\n}\n\nstatic const struct file_operations raw6_seq_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\traw6_seq_open,\n\t.read =\t\tseq_read,\n\t.llseek =\tseq_lseek,\n\t.release =\tseq_release_net,\n};\n\nstatic int __net_init raw6_init_net(struct net *net)\n{\n\tif (!proc_create(\"raw6\", S_IRUGO, net->proc_net, &raw6_seq_fops))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit raw6_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"raw6\", net->proc_net);\n}\n\nstatic struct pernet_operations raw6_net_ops = {\n\t.init = raw6_init_net,\n\t.exit = raw6_exit_net,\n};\n\nint __init raw6_proc_init(void)\n{\n\treturn register_pernet_subsys(&raw6_net_ops);\n}\n\nvoid raw6_proc_exit(void)\n{\n\tunregister_pernet_subsys(&raw6_net_ops);\n}\n#endif\t/* CONFIG_PROC_FS */\n\n/* Same as inet6_dgram_ops, sans udp_poll.  */\nstatic const struct proto_ops inet6_sockraw_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\t/* ok\t\t*/\n\t.socketpair\t   = sock_no_socketpair,\t/* a do nothing\t*/\n\t.accept\t\t   = sock_no_accept,\t\t/* a do nothing\t*/\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = datagram_poll,\t\t/* ok\t\t*/\n\t.ioctl\t\t   = inet6_ioctl,\t\t/* must change  */\n\t.listen\t\t   = sock_no_listen,\t\t/* ok\t\t*/\n\t.shutdown\t   = inet_shutdown,\t\t/* ok\t\t*/\n\t.setsockopt\t   = sock_common_setsockopt,\t/* ok\t\t*/\n\t.getsockopt\t   = sock_common_getsockopt,\t/* ok\t\t*/\n\t.sendmsg\t   = inet_sendmsg,\t\t/* ok\t\t*/\n\t.recvmsg\t   = sock_common_recvmsg,\t/* ok\t\t*/\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw rawv6_protosw = {\n\t.type\t\t= SOCK_RAW,\n\t.protocol\t= IPPROTO_IP,\t/* wild card */\n\t.prot\t\t= &rawv6_prot,\n\t.ops\t\t= &inet6_sockraw_ops,\n\t.flags\t\t= INET_PROTOSW_REUSE,\n};\n\nint __init rawv6_init(void)\n{\n\treturn inet6_register_protosw(&rawv6_protosw);\n}\n\nvoid rawv6_exit(void)\n{\n\tinet6_unregister_protosw(&rawv6_protosw);\n}\n", "/*\n *  IPv6 Syncookies implementation for the Linux kernel\n *\n *  Authors:\n *  Glenn Griffin\t<ggriffin.kernel@gmail.com>\n *\n *  Based on IPv4 implementation by Andi Kleen\n *  linux/net/ipv4/syncookies.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n */\n\n#include <linux/tcp.h>\n#include <linux/random.h>\n#include <linux/cryptohash.h>\n#include <linux/kernel.h>\n#include <net/ipv6.h>\n#include <net/tcp.h>\n\n#define COOKIEBITS 24\t/* Upper bits store count */\n#define COOKIEMASK (((__u32)1 << COOKIEBITS) - 1)\n\nstatic u32 syncookie6_secret[2][16-4+SHA_DIGEST_WORDS] __read_mostly;\n\n/* RFC 2460, Section 8.3:\n * [ipv6 tcp] MSS must be computed as the maximum packet size minus 60 [..]\n *\n * Due to IPV6_MIN_MTU=1280 the lowest possible MSS is 1220, which allows\n * using higher values than ipv4 tcp syncookies.\n * The other values are chosen based on ethernet (1500 and 9k MTU), plus\n * one that accounts for common encap (PPPoe) overhead. Table must be sorted.\n */\nstatic __u16 const msstab[] = {\n\t1280 - 60, /* IPV6_MIN_MTU - 60 */\n\t1480 - 60,\n\t1500 - 60,\n\t9000 - 60,\n};\n\nstatic DEFINE_PER_CPU(__u32 [16 + 5 + SHA_WORKSPACE_WORDS],\n\t\t      ipv6_cookie_scratch);\n\nstatic u32 cookie_hash(const struct in6_addr *saddr, const struct in6_addr *daddr,\n\t\t       __be16 sport, __be16 dport, u32 count, int c)\n{\n\t__u32 *tmp;\n\n\tnet_get_random_once(syncookie6_secret, sizeof(syncookie6_secret));\n\n\ttmp  = this_cpu_ptr(ipv6_cookie_scratch);\n\n\t/*\n\t * we have 320 bits of information to hash, copy in the remaining\n\t * 192 bits required for sha_transform, from the syncookie6_secret\n\t * and overwrite the digest with the secret\n\t */\n\tmemcpy(tmp + 10, syncookie6_secret[c], 44);\n\tmemcpy(tmp, saddr, 16);\n\tmemcpy(tmp + 4, daddr, 16);\n\ttmp[8] = ((__force u32)sport << 16) + (__force u32)dport;\n\ttmp[9] = count;\n\tsha_transform(tmp + 16, (__u8 *)tmp, tmp + 16 + 5);\n\n\treturn tmp[17];\n}\n\nstatic __u32 secure_tcp_syn_cookie(const struct in6_addr *saddr,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   __be16 sport, __be16 dport, __u32 sseq,\n\t\t\t\t   __u32 data)\n{\n\tu32 count = tcp_cookie_time();\n\treturn (cookie_hash(saddr, daddr, sport, dport, 0, 0) +\n\t\tsseq + (count << COOKIEBITS) +\n\t\t((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)\n\t\t& COOKIEMASK));\n}\n\nstatic __u32 check_tcp_syn_cookie(__u32 cookie, const struct in6_addr *saddr,\n\t\t\t\t  const struct in6_addr *daddr, __be16 sport,\n\t\t\t\t  __be16 dport, __u32 sseq)\n{\n\t__u32 diff, count = tcp_cookie_time();\n\n\tcookie -= cookie_hash(saddr, daddr, sport, dport, 0, 0) + sseq;\n\n\tdiff = (count - (cookie >> COOKIEBITS)) & ((__u32) -1 >> COOKIEBITS);\n\tif (diff >= MAX_SYNCOOKIE_AGE)\n\t\treturn (__u32)-1;\n\n\treturn (cookie -\n\t\tcookie_hash(saddr, daddr, sport, dport, count - diff, 1))\n\t\t& COOKIEMASK;\n}\n\nu32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,\n\t\t\t      const struct tcphdr *th, __u16 *mssp)\n{\n\tint mssind;\n\tconst __u16 mss = *mssp;\n\n\tfor (mssind = ARRAY_SIZE(msstab) - 1; mssind ; mssind--)\n\t\tif (mss >= msstab[mssind])\n\t\t\tbreak;\n\n\t*mssp = msstab[mssind];\n\n\treturn secure_tcp_syn_cookie(&iph->saddr, &iph->daddr, th->source,\n\t\t\t\t     th->dest, ntohl(th->seq), mssind);\n}\nEXPORT_SYMBOL_GPL(__cookie_v6_init_sequence);\n\n__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mssp)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\treturn __cookie_v6_init_sequence(iph, th, mssp);\n}\n\nint __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,\n\t\t      __u32 cookie)\n{\n\t__u32 seq = ntohl(th->seq) - 1;\n\t__u32 mssind = check_tcp_syn_cookie(cookie, &iph->saddr, &iph->daddr,\n\t\t\t\t\t    th->source, th->dest, seq);\n\n\treturn mssind < ARRAY_SIZE(msstab) ? msstab[mssind] : 0;\n}\nEXPORT_SYMBOL_GPL(__cookie_v6_check);\n\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint mss;\n\tstruct dst_entry *dst;\n\t__u8 rcv_wscale;\n\n\tif (!sysctl_tcp_syncookies || !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v6_check(ipv6_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t/* check for timestamp cookie support */\n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(skb, &tcp_opt, 0, NULL);\n\n\tif (!cookie_timestamp_decode(&tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = inet_reqsk_alloc(&tcp6_request_sock_ops, sk, false);\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->tfo_listener = false;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto out_free;\n\n\treq->mss = mss;\n\tireq->ir_rmt_port = th->source;\n\tireq->ir_num = ntohs(th->dest);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tif (ipv6_opt_accepted(sk, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\n\treq->num_retrans = 0;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\ttreq->snt_synack.v64\t= 0;\n\ttreq->rcv_isn = ntohl(th->seq) - 1;\n\ttreq->snt_isn = cookie;\n\n\t/*\n\t * We need to lookup the dst_entry to get the correct window size.\n\t * This is taken from tcp_v6_syn_recv_sock.  Somebody please enlighten\n\t * me if there is a preferred way.\n\t */\n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\t\tfl6.saddr = ireq->ir_v6_loc_addr;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;\n\t\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out_free;\n\t}\n\n\treq->rsk_window_clamp = tp->window_clamp ? :dst_metric(dst, RTAX_WINDOW);\n\ttcp_select_initial_window(tcp_full_space(sk), req->mss,\n\t\t\t\t  &req->rsk_rcv_wnd, &req->rsk_window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale = rcv_wscale;\n\tireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), dst);\n\n\tret = tcp_get_cookie_sock(sk, skb, req, dst);\nout:\n\treturn ret;\nout_free:\n\treqsk_free(req);\n\treturn NULL;\n}\n", "/*\n *\tTCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on:\n *\tlinux/net/ipv4/tcp.c\n *\tlinux/net/ipv4/tcp_input.c\n *\tlinux/net/ipv4/tcp_output.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *\tYOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/tcp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/bottom_half.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/jiffies.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/ipsec.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n\n#include <net/tcp.h>\n#include <net/ndisc.h>\n#include <net/inet6_hashtables.h>\n#include <net/inet6_connection_sock.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/inet_ecn.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/snmp.h>\n#include <net/dsfield.h>\n#include <net/timewait_sock.h>\n#include <net/inet_common.h>\n#include <net/secure_seq.h>\n#include <net/tcp_memcontrol.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n\nstatic void\ttcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb);\nstatic void\ttcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      struct request_sock *req);\n\nstatic int\ttcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb);\n\nstatic const struct inet_connection_sock_af_ops ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops ipv6_specific;\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific;\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific;\n#else\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn NULL;\n}\n#endif\n\nstatic void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst) {\n\t\tconst struct rt6_info *rt = (const struct rt6_info *)dst;\n\n\t\tdst_hold(dst);\n\t\tsk->sk_rx_dst = dst;\n\t\tinet_sk(sk)->rx_dst_ifindex = skb->skb_iif;\n\t\tinet6_sk(sk)->rx_dst_cookie = rt6_get_cookie(rt);\n\t}\n}\n\nstatic __u32 tcp_v6_init_sequence(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t    ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t    tcp_hdr(skb)->dest,\n\t\t\t\t\t    tcp_hdr(skb)->source);\n}\n\nstatic int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t  int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\n\t/*\n\t *\tconnect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 0x1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type&IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp->rx_opt.ts_recent_stamp &&\n\t    !ipv6_addr_equal(&sk->sk_v6_daddr, &usin->sin6_addr)) {\n\t\ttp->rx_opt.ts_recent = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq = 0;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t *\tTCP over IPv4\n\t */\n\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &ipv6_mapped;\n\t\tsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\ttp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\terr = tcp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &ipv6_specific;\n\t\t\tsk->sk_backlog_rcv = tcp_v6_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\ttp->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (!saddr) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(sk, dst, NULL, NULL);\n\n\tif (tcp_death_row.sysctl_tw_recycle &&\n\t    !tp->rx_opt.ts_recent_stamp &&\n\t    ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr))\n\t\ttcp_fetch_timewait_stamp(sk, dst);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen +\n\t\t\t\t\t opt->opt_nflen;\n\n\ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n\n\tinet->inet_dport = usin->sin6_port;\n\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet6_hash_connect(&tcp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tsk_set_txhash(sk);\n\n\tif (!tp->write_seq && likely(!tp->repair))\n\t\ttp->write_seq = secure_tcpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t\t     sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t\t     inet->inet_sport,\n\t\t\t\t\t\t\t     inet->inet_dport);\n\n\terr = tcp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\ttcp_set_state(sk, TCP_CLOSE);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic void tcp_v6_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE))\n\t\treturn;\n\n\tdst = inet6_csk_update_pmtu(sk, tcp_sk(sk)->mtu_info);\n\tif (!dst)\n\t\treturn;\n\n\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst)) {\n\t\ttcp_sync_mss(sk, dst_mtu(dst));\n\t\ttcp_simple_retransmit(sk);\n\t}\n}\n\nstatic void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, &tcp_hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex);\n\n\tif (!sk) {\n\t\tICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\n\t\t\t\t   ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (ipv6_hdr(skb)->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\tif (dst)\n\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t * they should go through unfragmented).\n\t\t */\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\ttp->mtu_info = ntohl(info);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &tp->tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\ticmpv6_err_convert(type, code, &err);\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\t\t\tsk->sk_error_report(sk);\t\t/* Wake people up to see the error (see connect in sock.c) */\n\n\t\t\ttcp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\terr = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),\n\t\t\t       np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}\n\n\nstatic void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn tcp_md5_do_lookup(sk, (union tcp_md5_addr *)addr, AF_INET6);\n}\n\nstatic struct tcp_md5sig_key *tcp_v6_md5_lookup(const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk)\n{\n\treturn tcp_v6_md5_do_lookup(sk, &addr_sk->sk_v6_daddr);\n}\n\nstatic int tcp_v6_parse_md5_keys(struct sock *sk, char __user *optval,\n\t\t\t\t int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&cmd.tcpm_addr;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tif (!cmd.tcpm_keylen) {\n\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t\t      AF_INET);\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t\t      AF_INET6);\n\t}\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t      AF_INET, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t      AF_INET6, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n}\n\nstatic int tcp_v6_md5_hash_pseudoheader(struct tcp_md5sig_pool *hp,\n\t\t\t\t\tconst struct in6_addr *daddr,\n\t\t\t\t\tconst struct in6_addr *saddr, int nbytes)\n{\n\tstruct tcp6_pseudohdr *bp;\n\tstruct scatterlist sg;\n\n\tbp = &hp->md5_blk.ip6;\n\t/* 1. TCP pseudo-header (RFC2460) */\n\tbp->saddr = *saddr;\n\tbp->daddr = *daddr;\n\tbp->protocol = cpu_to_be32(IPPROTO_TCP);\n\tbp->len = cpu_to_be32(nbytes);\n\n\tsg_init_one(&sg, bp, sizeof(*bp));\n\treturn crypto_hash_update(&hp->md5_desc, &sg, sizeof(*bp));\n}\n\nstatic int tcp_v6_md5_hash_hdr(char *md5_hash, struct tcp_md5sig_key *key,\n\t\t\t       const struct in6_addr *daddr, struct in6_addr *saddr,\n\t\t\t       const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct hash_desc *desc;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\tdesc = &hp->md5_desc;\n\n\tif (crypto_hash_init(desc))\n\t\tgoto clear_hash;\n\tif (tcp_v6_md5_hash_pseudoheader(hp, daddr, saddr, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_header(hp, th))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tif (crypto_hash_final(desc, md5_hash))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nstatic int tcp_v6_md5_hash_skb(char *md5_hash,\n\t\t\t       const struct tcp_md5sig_key *key,\n\t\t\t       const struct sock *sk,\n\t\t\t       const struct sk_buff *skb)\n{\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct tcp_md5sig_pool *hp;\n\tstruct hash_desc *desc;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (sk) { /* valid for establish/request sockets */\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else {\n\t\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\tdesc = &hp->md5_desc;\n\n\tif (crypto_hash_init(desc))\n\t\tgoto clear_hash;\n\n\tif (tcp_v6_md5_hash_pseudoheader(hp, daddr, saddr, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_header(hp, th))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tif (crypto_hash_final(desc, md5_hash))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\n#endif\n\nstatic bool tcp_v6_inbound_md5_hash(const struct sock *sk,\n\t\t\t\t    const struct sk_buff *skb)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct tcp_md5sig_key *hash_expected;\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint genhash;\n\tu8 newhash[16];\n\n\thash_expected = tcp_v6_md5_do_lookup(sk, &ip6h->saddr);\n\thash_location = tcp_parse_md5sig_option(th);\n\n\t/* We've parsed the options - do we have a hash? */\n\tif (!hash_expected && !hash_location)\n\t\treturn false;\n\n\tif (hash_expected && !hash_location) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);\n\t\treturn true;\n\t}\n\n\tif (!hash_expected && hash_location) {\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);\n\t\treturn true;\n\t}\n\n\t/* check the signature */\n\tgenhash = tcp_v6_md5_hash_skb(newhash,\n\t\t\t\t      hash_expected,\n\t\t\t\t      NULL, skb);\n\n\tif (genhash || memcmp(hash_location, newhash, 16) != 0) {\n\t\tnet_info_ratelimited(\"MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t\t     genhash ? \"failed\" : \"mismatch\",\n\t\t\t\t     &ip6h->saddr, ntohs(th->source),\n\t\t\t\t     &ip6h->daddr, ntohs(th->dest));\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic void tcp_v6_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk_listener);\n\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\t/* So that link locals have meaning */\n\tif (!sk_listener->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tif (!TCP_SKB_CB(skb)->tcp_tw_isn &&\n\t    (ipv6_opt_accepted(sk_listener, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t     np->rxopt.bits.rxinfo ||\n\t     np->rxopt.bits.rxoinfo || np->rxopt.bits.rxhlim ||\n\t     np->rxopt.bits.rxohlim || np->repflow)) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n}\n\nstatic struct dst_entry *tcp_v6_route_req(const struct sock *sk,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  const struct request_sock *req,\n\t\t\t\t\t  bool *strict)\n{\n\tif (strict)\n\t\t*strict = true;\n\treturn inet6_csk_route_req(sk, &fl->u.ip6, req, IPPROTO_TCP);\n}\n\nstruct request_sock_ops tcp6_request_sock_ops __read_mostly = {\n\t.family\t\t=\tAF_INET6,\n\t.obj_size\t=\tsizeof(struct tcp6_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v6_reqsk_send_ack,\n\t.destructor\t=\ttcp_v6_reqsk_destructor,\n\t.send_reset\t=\ttcp_v6_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nstatic const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {\n\t.mss_clamp\t=\tIPV6_MIN_MTU - sizeof(struct tcphdr) -\n\t\t\t\tsizeof(struct ipv6hdr),\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n#endif\n\t.init_req\t=\ttcp_v6_init_req,\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v6_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v6_route_req,\n\t.init_seq\t=\ttcp_v6_init_sequence,\n\t.send_synack\t=\ttcp_v6_send_synack,\n};\n\nstatic void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t\t u32 ack, u32 win, u32 tsval, u32 tsecr,\n\t\t\t\t int oif, struct tcp_md5sig_key *key, int rst,\n\t\t\t\t u8 tclass, u32 label)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct tcphdr *t1;\n\tstruct sk_buff *buff;\n\tstruct flowi6 fl6;\n\tstruct net *net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n\tstruct sock *ctl_sk = net->ipv6.tcp_sk;\n\tunsigned int tot_len = sizeof(struct tcphdr);\n\tstruct dst_entry *dst;\n\t__be32 *topt;\n\n\tif (tsecr)\n\t\ttot_len += TCPOLEN_TSTAMP_ALIGNED;\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key)\n\t\ttot_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n\tbuff = alloc_skb(MAX_HEADER + sizeof(struct ipv6hdr) + tot_len,\n\t\t\t GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\tskb_reserve(buff, MAX_HEADER + sizeof(struct ipv6hdr) + tot_len);\n\n\tt1 = (struct tcphdr *) skb_push(buff, tot_len);\n\tskb_reset_transport_header(buff);\n\n\t/* Swap the send and the receive. */\n\tmemset(t1, 0, sizeof(*t1));\n\tt1->dest = th->source;\n\tt1->source = th->dest;\n\tt1->doff = tot_len / 4;\n\tt1->seq = htonl(seq);\n\tt1->ack_seq = htonl(ack);\n\tt1->ack = !rst || !th->ack;\n\tt1->rst = rst;\n\tt1->window = htons(win);\n\n\ttopt = (__be32 *)(t1 + 1);\n\n\tif (tsecr) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);\n\t\t*topt++ = htonl(tsval);\n\t\t*topt++ = htonl(tsecr);\n\t}\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);\n\t\ttcp_v6_md5_hash_hdr((__u8 *)topt, key,\n\t\t\t\t    &ipv6_hdr(skb)->saddr,\n\t\t\t\t    &ipv6_hdr(skb)->daddr, t1);\n\t}\n#endif\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tfl6.saddr = ipv6_hdr(skb)->daddr;\n\tfl6.flowlabel = label;\n\n\tbuff->ip_summed = CHECKSUM_PARTIAL;\n\tbuff->csum = 0;\n\n\t__tcp_v6_send_check(buff, &fl6.saddr, &fl6.daddr);\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tif (rt6_need_strict(&fl6.daddr) && !oif)\n\t\tfl6.flowi6_oif = tcp_v6_iif(skb);\n\telse\n\t\tfl6.flowi6_oif = oif;\n\tfl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark);\n\tfl6.fl6_dport = t1->dest;\n\tfl6.fl6_sport = t1->source;\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\t/* Pass a socket to ip6_dst_lookup either it is for RST\n\t * Underlying function will use this to retrieve the network\n\t * namespace\n\t */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(buff, dst);\n\t\tip6_xmit(ctl_sk, buff, &fl6, NULL, tclass);\n\t\tTCP_INC_STATS_BH(net, TCP_MIB_OUTSEGS);\n\t\tif (rst)\n\t\t\tTCP_INC_STATS_BH(net, TCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(buff);\n}\n\nstatic void tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = 0, ack_seq = 0;\n\tstruct tcp_md5sig_key *key = NULL;\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\tint oif;\n\n\tif (th->rst)\n\t\treturn;\n\n\t/* If sk not NULL, it means we did a successful lookup and incoming\n\t * route had to be correct. prequeue might have dropped our dst.\n\t */\n\tif (!sk && !ipv6_unicast_destination(skb))\n\t\treturn;\n\n#ifdef CONFIG_TCP_MD5SIG\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (!sk && hash_location) {\n\t\t/*\n\t\t * active side is lost. Try to find listening socket through\n\t\t * source port, and then find md5 key through listening socket.\n\t\t * we are not loose security here:\n\t\t * Incoming packet is checked with md5 hash with finding key,\n\t\t * no RST generated if md5 hash doesn't match.\n\t\t */\n\t\tsk1 = inet6_lookup_listener(dev_net(skb_dst(skb)->dev),\n\t\t\t\t\t   &tcp_hashinfo, &ipv6h->saddr,\n\t\t\t\t\t   th->source, &ipv6h->daddr,\n\t\t\t\t\t   ntohs(th->source), tcp_v6_iif(skb));\n\t\tif (!sk1)\n\t\t\treturn;\n\n\t\trcu_read_lock();\n\t\tkey = tcp_v6_md5_do_lookup(sk1, &ipv6h->saddr);\n\t\tif (!key)\n\t\t\tgoto release_sk1;\n\n\t\tgenhash = tcp_v6_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto release_sk1;\n\t} else {\n\t\tkey = sk ? tcp_v6_md5_do_lookup(sk, &ipv6h->saddr) : NULL;\n\t}\n#endif\n\n\tif (th->ack)\n\t\tseq = ntohl(th->ack_seq);\n\telse\n\t\tack_seq = ntohl(th->seq) + th->syn + th->fin + skb->len -\n\t\t\t  (th->doff << 2);\n\n\toif = sk ? sk->sk_bound_dev_if : 0;\n\ttcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1, 0, 0);\n\n#ifdef CONFIG_TCP_MD5SIG\nrelease_sk1:\n\tif (sk1) {\n\t\trcu_read_unlock();\n\t\tsock_put(sk1);\n\t}\n#endif\n}\n\nstatic void tcp_v6_send_ack(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t    u32 ack, u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key, u8 tclass,\n\t\t\t    u32 label)\n{\n\ttcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,\n\t\t\t     tclass, label);\n}\n\nstatic void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v6_send_ack(sk, skb, tcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent, tw->tw_bound_dev_if, tcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_tclass, cpu_to_be32(tw->tw_flowlabel));\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\t/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV\n\t * sk->sk_state == TCP_SYN_RECV -> for Fast Open.\n\t */\n\ttcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?\n\t\t\ttcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,\n\t\t\ttcp_rsk(req)->rcv_nxt, req->rsk_rcv_wnd,\n\t\t\ttcp_time_stamp, req->ts_recent, sk->sk_bound_dev_if,\n\t\t\ttcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr),\n\t\t\t0, 0);\n}\n\n\nstatic struct sock *tcp_v6_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v6_check(sk, skb);\n#endif\n\treturn sk;\n}\n\nstatic int tcp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&tcp6_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv6_ops, sk, skb);\n\ndrop:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn 0; /* don't send reset */\n}\n\nstatic struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_atomic(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_atomic(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n\n/* The socket must have it's spinlock held when we get\n * here, unless it is a TCP_LISTEN socket.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp;\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, tcp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   tcp_v6_hnd_req and tcp_v6_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *\tsocket locking is here for SMP purposes as backlog rcv\n\t *\tis currently called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone(skb, sk_gfp_atomic(sk, GFP_ATOMIC));\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tsock_rps_save_rxhash(nsk, skb);\n\t\t\tsk_mark_napi_id(nsk, skb);\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\ncsum_err:\n\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t/* Do you ask, what is it?\n\n\t   1. skb was enqueued by tcp.\n\t   2. skb is added to tail of read queue, rather than out of order.\n\t   3. socket is not in passive state.\n\t   4. Finally, it really contains options, which user wants to receive.\n\t */\n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tskb_set_owner_r(opt_skb, sk);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}\n\nstatic void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,\n\t\t\t   const struct tcphdr *th)\n{\n\t/* This is tricky: we move IP6CB at its correct location into\n\t * TCP_SKB_CB(). It must be done after xfrm6_policy_check(), because\n\t * _decode_session6() uses IP6CB().\n\t * barrier() makes sure compiler won't play aliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h6, IP6CB(skb),\n\t\tsizeof(struct inet6_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff*4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv6_get_dsfield(hdr);\n\tTCP_SKB_CB(skb)->sacked = 0;\n}\n\nstatic void tcp_v6_restore_cb(struct sk_buff *skb)\n{\n\t/* We need to move header back to the beginning if xfrm6_policy_check()\n\t * and tcp_v6_fill_cb() are going to be called again.\n\t */\n\tmemmove(IP6CB(skb), &TCP_SKB_CB(skb)->header.h6,\n\t\tsizeof(struct inet6_skb_parm));\n}\n\nstatic int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/*\n\t *\tCount it even if it's bad.\n\t */\n\tTCP_INC_STATS_BH(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr)/4)\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = tcp_hdr(skb);\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&tcp_hashinfo, skb, th->source, th->dest,\n\t\t\t\tinet6_iif(skb));\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk = NULL;\n\n\t\tsk = req->rsk_listener;\n\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\tif (tcp_v6_inbound_md5_hash(sk, skb)) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (likely(sk->sk_state == TCP_LISTEN)) {\n\t\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\t} else {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\tsock_hold(sk);\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_it;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_v6_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_sk(sk)->segs_in += max_t(u16, 1, skb_shinfo(skb)->gso_segs);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else if (unlikely(sk_add_backlog(sk, skb,\n\t\t\t\t\t   sk->sk_rcvbuf + sk->sk_sndbuf))) {\n\t\tbh_unlock_sock(sk);\n\t\tNET_INC_STATS_BH(net, LINUX_MIB_TCPBACKLOGDROP);\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\tTCP_INC_STATS_BH(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\tTCP_INC_STATS_BH(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest), tcp_v6_iif(skb));\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_restore_cb(skb);\n\t\tgoto no_tcp_socket;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}\n\nstatic void tcp_v6_early_demux(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *hdr;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\thdr = ipv6_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\t/* Note : We use inet6_iif() here, not tcp_v6_iif() */\n\tsk = __inet6_lookup_established(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t&hdr->saddr, th->source,\n\t\t\t\t\t&hdr->daddr, ntohs(th->dest),\n\t\t\t\t\tinet6_iif(skb));\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = READ_ONCE(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, inet6_sk(sk)->rx_dst_cookie);\n\t\t\tif (dst &&\n\t\t\t    inet_sk(sk)->rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\nstatic struct timewait_sock_ops tcp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp6_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor = tcp_twsk_destructor,\n};\n\nstatic const struct inet_connection_sock_af_ops ipv6_specific = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = tcp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet6_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.net_frag_header_len = sizeof(struct frag_hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v6_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific = {\n\t.md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/*\n *\tTCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.bind_conflict\t   = inet6_csk_bind_conflict,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific = {\n\t.md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int tcp_v6_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv6_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\n\treturn 0;\n}\n\nstatic void tcp_v6_destroy_sock(struct sock *sk)\n{\n\ttcp_v4_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\n#ifdef CONFIG_PROC_FS\n/* Proc filesystem TCPv6 sock list dumping. */\nstatic void get_openreq6(struct seq_file *seq,\n\t\t\t const struct request_sock *req, int i)\n{\n\tlong ttd = req->rsk_timer.expires - jiffies;\n\tconst struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;\n\tconst struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3],\n\t\t   inet_rsk(req)->ir_num,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3],\n\t\t   ntohs(inet_rsk(req)->ir_rmt_port),\n\t\t   TCP_SYN_RECV,\n\t\t   0, 0, /* could print option size, but that is af dependent. */\n\t\t   1,   /* timers active (only the expire timer) */\n\t\t   jiffies_to_clock_t(ttd),\n\t\t   req->num_timeout,\n\t\t   from_kuid_munged(seq_user_ns(seq),\n\t\t\t\t    sock_i_uid(req->rsk_listener)),\n\t\t   0,  /* non standard timer */\n\t\t   0, /* open_requests have no inode */\n\t\t   0, req);\n}\n\nstatic void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct inet_sock *inet = inet_sk(sp);\n\tconst struct tcp_sock *tp = tcp_sk(sp);\n\tconst struct inet_connection_sock *icsk = inet_csk(sp);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\tint rx_queue;\n\tint state;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sp->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sp->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = sk_state_load(sp);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = sp->sk_ack_backlog;\n\telse\n\t\t/* Because we don't lock the socket,\n\t\t * we might find a transient negative value.\n\t\t */\n\t\trx_queue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %lu %lu %u %u %d\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   state,\n\t\t   tp->write_seq - tp->snd_una,\n\t\t   rx_queue,\n\t\t   timer_active,\n\t\t   jiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\t   icsk->icsk_retransmits,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   icsk->icsk_probes_out,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   jiffies_to_clock_t(icsk->icsk_rto),\n\t\t   jiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t   (icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,\n\t\t   tp->snd_cwnd,\n\t\t   state == TCP_LISTEN ?\n\t\t\tfastopenq->max_qlen :\n\t\t\t(tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh)\n\t\t   );\n}\n\nstatic void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n\nstatic int tcp6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"  sl  \"\n\t\t\t \"local_address                         \"\n\t\t\t \"remote_address                        \"\n\t\t\t \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t \"   uid  timeout inode\\n\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait6_sock(seq, v, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq6(seq, v, st->num);\n\telse\n\t\tget_tcp6_sock(seq, v, st->num);\nout:\n\treturn 0;\n}\n\nstatic const struct file_operations tcp6_afinfo_seq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tcp_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net\n};\n\nstatic struct tcp_seq_afinfo tcp6_seq_afinfo = {\n\t.name\t\t= \"tcp6\",\n\t.family\t\t= AF_INET6,\n\t.seq_fops\t= &tcp6_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= tcp6_seq_show,\n\t},\n};\n\nint __net_init tcp6_proc_init(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp6_seq_afinfo);\n}\n\nvoid tcp6_proc_exit(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp6_seq_afinfo);\n}\n#endif\n\nstatic void tcp_v6_clear_sk(struct sock *sk, int size)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t/* we do not want to clear pinet6 field, because of RCU lookups */\n\tsk_prot_clear_nulls(sk, offsetof(struct inet_sock, pinet6));\n\n\tsize -= offsetof(struct inet_sock, pinet6) + sizeof(inet->pinet6);\n\tmemset(&inet->pinet6 + 1, 0, size);\n}\n\nstruct proto tcpv6_prot = {\n\t.name\t\t\t= \"TCPv6\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.connect\t\t= tcp_v6_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v6_init_sock,\n\t.destroy\t\t= tcp_v6_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.sendpage\t\t= tcp_sendpage,\n\t.backlog_rcv\t\t= tcp_v6_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem\t\t= sysctl_tcp_wmem,\n\t.sysctl_rmem\t\t= sysctl_tcp_rmem,\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp6_sock),\n\t.slab_flags\t\t= SLAB_DESTROY_BY_RCU,\n\t.twsk_prot\t\t= &tcp6_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp6_request_sock_ops,\n\t.h.hashinfo\t\t= &tcp_hashinfo,\n\t.no_autobind\t\t= true,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt\t= compat_tcp_setsockopt,\n\t.compat_getsockopt\t= compat_tcp_getsockopt,\n#endif\n#ifdef CONFIG_MEMCG_KMEM\n\t.proto_cgroup\t\t= tcp_proto_cgroup,\n#endif\n\t.clear_sk\t\t= tcp_v6_clear_sk,\n};\n\nstatic const struct inet6_protocol tcpv6_protocol = {\n\t.early_demux\t=\ttcp_v6_early_demux,\n\t.handler\t=\ttcp_v6_rcv,\n\t.err_handler\t=\ttcp_v6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic struct inet_protosw tcpv6_protosw = {\n\t.type\t\t=\tSOCK_STREAM,\n\t.protocol\t=\tIPPROTO_TCP,\n\t.prot\t\t=\t&tcpv6_prot,\n\t.ops\t\t=\t&inet6_stream_ops,\n\t.flags\t\t=\tINET_PROTOSW_PERMANENT |\n\t\t\t\tINET_PROTOSW_ICSK,\n};\n\nstatic int __net_init tcpv6_net_init(struct net *net)\n{\n\treturn inet_ctl_sock_create(&net->ipv6.tcp_sk, PF_INET6,\n\t\t\t\t    SOCK_RAW, IPPROTO_TCP, net);\n}\n\nstatic void __net_exit tcpv6_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.tcp_sk);\n}\n\nstatic void __net_exit tcpv6_net_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, &tcp_death_row, AF_INET6);\n}\n\nstatic struct pernet_operations tcpv6_net_ops = {\n\t.init\t    = tcpv6_net_init,\n\t.exit\t    = tcpv6_net_exit,\n\t.exit_batch = tcpv6_net_exit_batch,\n};\n\nint __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t/* register inet6 protocol */\n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\nout:\n\treturn ret;\n\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n\nvoid tcpv6_exit(void)\n{\n\tunregister_pernet_subsys(&tcpv6_net_ops);\n\tinet6_unregister_protosw(&tcpv6_protosw);\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n}\n", "/*\n *\tUDP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/ipv4/udp.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *      Kazunori MIYAZAWA @USAGI:       change process style to use ip6_append_data\n *      YOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/udp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/raw.h>\n#include <net/tcp_states.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n#include <net/inet6_hashtables.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <trace/events/skb.h>\n#include \"udp_impl.h\"\n\nstatic u32 udp6_ehashfn(const struct net *net,\n\t\t\tconst struct in6_addr *laddr,\n\t\t\tconst u16 lport,\n\t\t\tconst struct in6_addr *faddr,\n\t\t\tconst __be16 fport)\n{\n\tstatic u32 udp6_ehash_secret __read_mostly;\n\tstatic u32 udp_ipv6_hash_secret __read_mostly;\n\n\tu32 lhash, fhash;\n\n\tnet_get_random_once(&udp6_ehash_secret,\n\t\t\t    sizeof(udp6_ehash_secret));\n\tnet_get_random_once(&udp_ipv6_hash_secret,\n\t\t\t    sizeof(udp_ipv6_hash_secret));\n\n\tlhash = (__force u32)laddr->s6_addr32[3];\n\tfhash = __ipv6_addr_jhash(faddr, udp_ipv6_hash_secret);\n\n\treturn __inet6_ehashfn(lhash, lport, fhash, fport,\n\t\t\t       udp_ipv6_hash_secret + net_hash_mix(net));\n}\n\nint ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)\n{\n\tconst struct in6_addr *sk2_rcv_saddr6 = inet6_rcv_saddr(sk2);\n\tint sk2_ipv6only = inet_v6_ipv6only(sk2);\n\tint addr_type = ipv6_addr_type(&sk->sk_v6_rcv_saddr);\n\tint addr_type2 = sk2_rcv_saddr6 ? ipv6_addr_type(sk2_rcv_saddr6) : IPV6_ADDR_MAPPED;\n\n\t/* if both are mapped, treat as IPv4 */\n\tif (addr_type == IPV6_ADDR_MAPPED && addr_type2 == IPV6_ADDR_MAPPED)\n\t\treturn (!sk2_ipv6only &&\n\t\t\t(!sk->sk_rcv_saddr || !sk2->sk_rcv_saddr ||\n\t\t\t  sk->sk_rcv_saddr == sk2->sk_rcv_saddr));\n\n\tif (addr_type2 == IPV6_ADDR_ANY &&\n\t    !(sk2_ipv6only && addr_type == IPV6_ADDR_MAPPED))\n\t\treturn 1;\n\n\tif (addr_type == IPV6_ADDR_ANY &&\n\t    !(ipv6_only_sock(sk) && addr_type2 == IPV6_ADDR_MAPPED))\n\t\treturn 1;\n\n\tif (sk2_rcv_saddr6 &&\n\t    ipv6_addr_equal(&sk->sk_v6_rcv_saddr, sk2_rcv_saddr6))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic u32 udp6_portaddr_hash(const struct net *net,\n\t\t\t      const struct in6_addr *addr6,\n\t\t\t      unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\n\treturn hash ^ port;\n}\n\nint udp_v6_get_port(struct sock *sk, unsigned short snum)\n{\n\tunsigned int hash2_nulladdr =\n\t\tudp6_portaddr_hash(sock_net(sk), &in6addr_any, snum);\n\tunsigned int hash2_partial =\n\t\tudp6_portaddr_hash(sock_net(sk), &sk->sk_v6_rcv_saddr, 0);\n\n\t/* precompute partial secondary hash */\n\tudp_sk(sk)->udp_portaddr_hash = hash2_partial;\n\treturn udp_lib_get_port(sk, snum, ipv6_rcv_saddr_equal, hash2_nulladdr);\n}\n\nstatic void udp_v6_rehash(struct sock *sk)\n{\n\tu16 new_hash = udp6_portaddr_hash(sock_net(sk),\n\t\t\t\t\t  &sk->sk_v6_rcv_saddr,\n\t\t\t\t\t  inet_sk(sk)->inet_num);\n\n\tudp_lib_rehash(sk, new_hash);\n}\n\nstatic inline int compute_score(struct sock *sk, struct net *net,\n\t\t\t\tunsigned short hnum,\n\t\t\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\t\t\tconst struct in6_addr *daddr, __be16 dport,\n\t\t\t\tint dif)\n{\n\tint score;\n\tstruct inet_sock *inet;\n\n\tif (!net_eq(sock_net(sk), net) ||\n\t    udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6)\n\t\treturn -1;\n\n\tscore = 0;\n\tinet = inet_sk(sk);\n\n\tif (inet->inet_dport) {\n\t\tif (inet->inet_dport != sport)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_daddr, saddr))\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_bound_dev_if) {\n\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_incoming_cpu == raw_smp_processor_id())\n\t\tscore++;\n\n\treturn score;\n}\n\nstatic inline int compute_score2(struct sock *sk, struct net *net,\n\t\t\t\t const struct in6_addr *saddr, __be16 sport,\n\t\t\t\t const struct in6_addr *daddr,\n\t\t\t\t unsigned short hnum, int dif)\n{\n\tint score;\n\tstruct inet_sock *inet;\n\n\tif (!net_eq(sock_net(sk), net) ||\n\t    udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6)\n\t\treturn -1;\n\n\tif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\n\t\treturn -1;\n\n\tscore = 0;\n\tinet = inet_sk(sk);\n\n\tif (inet->inet_dport) {\n\t\tif (inet->inet_dport != sport)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_daddr, saddr))\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_bound_dev_if) {\n\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_incoming_cpu == raw_smp_processor_id())\n\t\tscore++;\n\n\treturn score;\n}\n\n/* called with read_rcu_lock() */\nstatic struct sock *udp6_lib_lookup2(struct net *net,\n\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\tconst struct in6_addr *daddr, unsigned int hnum, int dif,\n\t\tstruct udp_hslot *hslot2, unsigned int slot2)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tint score, badness, matches = 0, reuseport = 0;\n\tu32 hash = 0;\n\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tudp_portaddr_for_each_entry_rcu(sk, node, &hslot2->head) {\n\t\tscore = compute_score2(sk, net, saddr, sport,\n\t\t\t\t      daddr, hnum, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t\treuseport = sk->sk_reuseport;\n\t\t\tif (reuseport) {\n\t\t\t\thash = udp6_ehashfn(net, daddr, hnum,\n\t\t\t\t\t\t    saddr, sport);\n\t\t\t\tmatches = 1;\n\t\t\t}\n\t\t} else if (score == badness && reuseport) {\n\t\t\tmatches++;\n\t\t\tif (reciprocal_scale(hash, matches) == 0)\n\t\t\t\tresult = sk;\n\t\t\thash = next_pseudo_random32(hash);\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot2)\n\t\tgoto begin;\n\n\tif (result) {\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score2(result, net, saddr, sport,\n\t\t\t\t  daddr, hnum, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\treturn result;\n}\n\nstruct sock *__udp6_lib_lookup(struct net *net,\n\t\t\t\t      const struct in6_addr *saddr, __be16 sport,\n\t\t\t\t      const struct in6_addr *daddr, __be16 dport,\n\t\t\t\t      int dif, struct udp_table *udptable)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(dport);\n\tunsigned int hash2, slot2, slot = udp_hashfn(net, hnum, udptable->mask);\n\tstruct udp_hslot *hslot2, *hslot = &udptable->hash[slot];\n\tint score, badness, matches = 0, reuseport = 0;\n\tu32 hash = 0;\n\n\trcu_read_lock();\n\tif (hslot->count > 10) {\n\t\thash2 = udp6_portaddr_hash(net, daddr, hnum);\n\t\tslot2 = hash2 & udptable->mask;\n\t\thslot2 = &udptable->hash2[slot2];\n\t\tif (hslot->count < hslot2->count)\n\t\t\tgoto begin;\n\n\t\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t\t  daddr, hnum, dif,\n\t\t\t\t\t  hslot2, slot2);\n\t\tif (!result) {\n\t\t\thash2 = udp6_portaddr_hash(net, &in6addr_any, hnum);\n\t\t\tslot2 = hash2 & udptable->mask;\n\t\t\thslot2 = &udptable->hash2[slot2];\n\t\t\tif (hslot->count < hslot2->count)\n\t\t\t\tgoto begin;\n\n\t\t\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t\t\t  &in6addr_any, hnum, dif,\n\t\t\t\t\t\t  hslot2, slot2);\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn result;\n\t}\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tscore = compute_score(sk, net, hnum, saddr, sport, daddr, dport, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t\treuseport = sk->sk_reuseport;\n\t\t\tif (reuseport) {\n\t\t\t\thash = udp6_ehashfn(net, daddr, hnum,\n\t\t\t\t\t\t    saddr, sport);\n\t\t\t\tmatches = 1;\n\t\t\t}\n\t\t} else if (score == badness && reuseport) {\n\t\t\tmatches++;\n\t\t\tif (reciprocal_scale(hash, matches) == 0)\n\t\t\t\tresult = sk;\n\t\t\thash = next_pseudo_random32(hash);\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\n\tif (result) {\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score(result, net, hnum, saddr, sport,\n\t\t\t\t\tdaddr, dport, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(__udp6_lib_lookup);\n\nstatic struct sock *__udp6_lib_lookup_skb(struct sk_buff *skb,\n\t\t\t\t\t  __be16 sport, __be16 dport,\n\t\t\t\t\t  struct udp_table *udptable)\n{\n\tstruct sock *sk;\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\n\tsk = skb_steal_sock(skb);\n\tif (unlikely(sk))\n\t\treturn sk;\n\treturn __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, inet6_iif(skb),\n\t\t\t\t udptable);\n}\n\nstruct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,\n\t\t\t     const struct in6_addr *daddr, __be16 dport, int dif)\n{\n\treturn __udp6_lib_lookup(net, saddr, sport, daddr, dport, dif, &udp_table);\n}\nEXPORT_SYMBOL_GPL(udp6_lib_lookup);\n\n/*\n *\tThis should be easy, if there is something there we\n *\treturn it, otherwise we block.\n */\n\nint udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint is_udp4;\n\tbool slow;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tis_udp4 = (skb->protocol == htons(ETH_P_IP));\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t    msg, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udpv6_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tif (is_udp4)\n\t\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t\t   UDP_MIB_INERRORS,\n\t\t\t\t\t\t   is_udplite);\n\t\t\telse\n\t\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t\t    UDP_MIB_INERRORS,\n\t\t\t\t\t\t    is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tif (!peeked) {\n\t\tif (is_udp4)\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t\telse\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = udp_hdr(skb)->source;\n\t\tsin6->sin6_flowinfo = 0;\n\n\t\tif (is_udp4) {\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin6->sin6_addr);\n\t\t\tsin6->sin6_scope_id = 0;\n\t\t} else {\n\t\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    inet6_iif(skb));\n\t\t}\n\t\t*addr_len = sizeof(*sin6);\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\n\tif (is_udp4) {\n\t\tif (inet->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\t} else {\n\t\tif (np->rxopt.all)\n\t\t\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n\t}\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tif (is_udp4) {\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_CSUMERRORS, is_udplite);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t\t} else {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_CSUMERRORS, is_udplite);\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\t/* starting over for a new packet, but check if we need to yield */\n\tcond_resched();\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}\n\nvoid __udp6_lib_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t    u8 type, u8 code, int offset, __be32 info,\n\t\t    struct udp_table *udptable)\n{\n\tstruct ipv6_pinfo *np;\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct in6_addr *saddr = &hdr->saddr;\n\tconst struct in6_addr *daddr = &hdr->daddr;\n\tstruct udphdr *uh = (struct udphdr *)(skb->data+offset);\n\tstruct sock *sk;\n\tint err;\n\tstruct net *net = dev_net(skb->dev);\n\n\tsk = __udp6_lib_lookup(net, daddr, uh->dest,\n\t\t\t       saddr, uh->source, inet6_iif(skb), udptable);\n\tif (!sk) {\n\t\tICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\n\t\t\t\t   ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\t\tip6_sk_update_pmtu(skb, sk, info);\n\t}\n\tif (type == NDISC_REDIRECT) {\n\t\tip6_sk_redirect(skb, sk);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_err_convert(type, code, &err) && !np->recverr)\n\t\tgoto out;\n\n\tif (sk->sk_state != TCP_ESTABLISHED && !np->recverr)\n\t\tgoto out;\n\n\tif (np->recverr)\n\t\tipv6_icmp_error(sk, skb, err, uh->dest, ntohl(info), (u8 *)(uh+1));\n\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\nout:\n\tsock_put(sk);\n}\n\nstatic int __udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t}\n\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0) {\n\t\tint is_udplite = IS_UDPLITE(sk);\n\n\t\t/* Note that an ENOMEM error is charged twice */\n\t\tif (rc == -ENOMEM)\n\t\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\tUDP_MIB_RCVBUFERRORS, is_udplite);\n\t\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic __inline__ void udpv6_err(struct sk_buff *skb,\n\t\t\t\t struct inet6_skb_parm *opt, u8 type,\n\t\t\t\t u8 code, int offset, __be32 info)\n{\n\t__udp6_lib_err(skb, opt, type, code, offset, info, &udp_table);\n}\n\nstatic struct static_key udpv6_encap_needed __read_mostly;\nvoid udpv6_encap_enable(void)\n{\n\tif (!static_key_enabled(&udpv6_encap_needed))\n\t\tstatic_key_slow_inc(&udpv6_encap_needed);\n}\nEXPORT_SYMBOL(udpv6_encap_enable);\n\nint udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint rc;\n\tint is_udplite = IS_UDPLITE(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto drop;\n\n\tif (static_key_false(&udpv6_encap_needed) && up->encap_type) {\n\t\tint (*encap_rcv)(struct sock *sk, struct sk_buff *skb);\n\n\t\t/*\n\t\t * This is an encapsulation socket so pass the skb to\n\t\t * the socket's udp_encap_rcv() hook. Otherwise, just\n\t\t * fall through and pass this up the UDP socket.\n\t\t * up->encap_rcv() returns the following value:\n\t\t * =0 if skb was successfully passed to the encap\n\t\t *    handler or was discarded by it.\n\t\t * >0 if skb should be passed on to UDP.\n\t\t * <0 if skb should be resubmitted as proto -N\n\t\t */\n\n\t\t/* if we're overly short, let UDP handle it */\n\t\tencap_rcv = ACCESS_ONCE(up->encap_rcv);\n\t\tif (skb->len > sizeof(struct udphdr) && encap_rcv) {\n\t\t\tint ret;\n\n\t\t\t/* Verify checksum before giving to encap */\n\t\t\tif (udp_lib_checksum_complete(skb))\n\t\t\t\tgoto csum_error;\n\n\t\t\tret = encap_rcv(sk, skb);\n\t\t\tif (ret <= 0) {\n\t\t\t\tUDP_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\t\t UDP_MIB_INDATAGRAMS,\n\t\t\t\t\t\t is_udplite);\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t}\n\n\t\t/* FALLTHROUGH -- it's a UDP Packet */\n\t}\n\n\t/*\n\t * UDP-Lite specific tests, ignored on UDP sockets (see net/ipv4/udp.c).\n\t */\n\tif ((is_udplite & UDPLITE_RECV_CC)  &&  UDP_SKB_CB(skb)->partial_cov) {\n\n\t\tif (up->pcrlen == 0) {          /* full coverage was set  */\n\t\t\tnet_dbg_ratelimited(\"UDPLITE6: partial coverage %d while full coverage %d requested\\n\",\n\t\t\t\t\t    UDP_SKB_CB(skb)->cscov, skb->len);\n\t\t\tgoto drop;\n\t\t}\n\t\tif (UDP_SKB_CB(skb)->cscov  <  up->pcrlen) {\n\t\t\tnet_dbg_ratelimited(\"UDPLITE6: coverage %d too small, need min %d\\n\",\n\t\t\t\t\t    UDP_SKB_CB(skb)->cscov, up->pcrlen);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (rcu_access_pointer(sk->sk_filter)) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_error;\n\t}\n\n\tif (sk_rcvqueues_full(sk, sk->sk_rcvbuf)) {\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\t  UDP_MIB_RCVBUFERRORS, is_udplite);\n\t\tgoto drop;\n\t}\n\n\tskb_dst_drop(skb);\n\n\tbh_lock_sock(sk);\n\trc = 0;\n\tif (!sock_owned_by_user(sk))\n\t\trc = __udpv6_queue_rcv_skb(sk, skb);\n\telse if (sk_add_backlog(sk, skb, sk->sk_rcvbuf)) {\n\t\tbh_unlock_sock(sk);\n\t\tgoto drop;\n\t}\n\tbh_unlock_sock(sk);\n\n\treturn rc;\n\ncsum_error:\n\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\ndrop:\n\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\tatomic_inc(&sk->sk_drops);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic bool __udp_v6_is_mcast_sock(struct net *net, struct sock *sk,\n\t\t\t\t   __be16 loc_port, const struct in6_addr *loc_addr,\n\t\t\t\t   __be16 rmt_port, const struct in6_addr *rmt_addr,\n\t\t\t\t   int dif, unsigned short hnum)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tif (!net_eq(sock_net(sk), net))\n\t\treturn false;\n\n\tif (udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6 ||\n\t    (inet->inet_dport && inet->inet_dport != rmt_port) ||\n\t    (!ipv6_addr_any(&sk->sk_v6_daddr) &&\n\t\t    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr)) ||\n\t    (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif) ||\n\t    (!ipv6_addr_any(&sk->sk_v6_rcv_saddr) &&\n\t\t    !ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr)))\n\t\treturn false;\n\tif (!inet6_mc_check(sk, loc_addr, rmt_addr))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void flush_stack(struct sock **stack, unsigned int count,\n\t\t\tstruct sk_buff *skb, unsigned int final)\n{\n\tstruct sk_buff *skb1 = NULL;\n\tstruct sock *sk;\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tsk = stack[i];\n\t\tif (likely(!skb1))\n\t\t\tskb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb1) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,\n\t\t\t\t\t  IS_UDPLITE(sk));\n\t\t\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS,\n\t\t\t\t\t  IS_UDPLITE(sk));\n\t\t}\n\n\t\tif (skb1 && udpv6_queue_rcv_skb(sk, skb1) <= 0)\n\t\t\tskb1 = NULL;\n\t\tsock_put(sk);\n\t}\n\tif (unlikely(skb1))\n\t\tkfree_skb(skb1);\n}\n\nstatic void udp6_csum_zero_error(struct sk_buff *skb)\n{\n\t/* RFC 2460 section 8.1 says that we SHOULD log\n\t * this error. Well, it is reasonable.\n\t */\n\tnet_dbg_ratelimited(\"IPv6: udp checksum is 0 for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t    &ipv6_hdr(skb)->saddr, ntohs(udp_hdr(skb)->source),\n\t\t\t    &ipv6_hdr(skb)->daddr, ntohs(udp_hdr(skb)->dest));\n}\n\n/*\n * Note: called only from the BH handler context,\n * so we don't need to lock the hashes.\n */\nstatic int __udp6_lib_mcast_deliver(struct net *net, struct sk_buff *skb,\n\t\tconst struct in6_addr *saddr, const struct in6_addr *daddr,\n\t\tstruct udp_table *udptable, int proto)\n{\n\tstruct sock *sk, *stack[256 / sizeof(struct sock *)];\n\tconst struct udphdr *uh = udp_hdr(skb);\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(uh->dest);\n\tstruct udp_hslot *hslot = udp_hashslot(udptable, net, hnum);\n\tint dif = inet6_iif(skb);\n\tunsigned int count = 0, offset = offsetof(typeof(*sk), sk_nulls_node);\n\tunsigned int hash2 = 0, hash2_any = 0, use_hash2 = (hslot->count > 10);\n\tbool inner_flushed = false;\n\n\tif (use_hash2) {\n\t\thash2_any = udp6_portaddr_hash(net, &in6addr_any, hnum) &\n\t\t\t    udp_table.mask;\n\t\thash2 = udp6_portaddr_hash(net, daddr, hnum) & udp_table.mask;\nstart_lookup:\n\t\thslot = &udp_table.hash2[hash2];\n\t\toffset = offsetof(typeof(*sk), __sk_common.skc_portaddr_node);\n\t}\n\n\tspin_lock(&hslot->lock);\n\tsk_nulls_for_each_entry_offset(sk, node, &hslot->head, offset) {\n\t\tif (__udp_v6_is_mcast_sock(net, sk,\n\t\t\t\t\t   uh->dest, daddr,\n\t\t\t\t\t   uh->source, saddr,\n\t\t\t\t\t   dif, hnum) &&\n\t\t    /* If zero checksum and no_check is not on for\n\t\t     * the socket then skip it.\n\t\t     */\n\t\t    (uh->check || udp_sk(sk)->no_check6_rx)) {\n\t\t\tif (unlikely(count == ARRAY_SIZE(stack))) {\n\t\t\t\tflush_stack(stack, count, skb, ~0);\n\t\t\t\tinner_flushed = true;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tstack[count++] = sk;\n\t\t\tsock_hold(sk);\n\t\t}\n\t}\n\n\tspin_unlock(&hslot->lock);\n\n\t/* Also lookup *:port if we are using hash2 and haven't done so yet. */\n\tif (use_hash2 && hash2 != hash2_any) {\n\t\thash2 = hash2_any;\n\t\tgoto start_lookup;\n\t}\n\n\tif (count) {\n\t\tflush_stack(stack, count, skb, count - 1);\n\t} else {\n\t\tif (!inner_flushed)\n\t\t\tUDP_INC_STATS_BH(net, UDP_MIB_IGNOREDMULTI,\n\t\t\t\t\t proto == IPPROTO_UDPLITE);\n\t\tconsume_skb(skb);\n\t}\n\treturn 0;\n}\n\nint __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct udphdr *uh;\n\tconst struct in6_addr *saddr, *daddr;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto discard;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t/* UDP validates ulen. */\n\n\t\t/* Check for jumbo payload */\n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto csum_error;\n\n\t/*\n\t *\tMulticast receive code\n\t */\n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable, proto);\n\n\t/* Unicast */\n\n\t/*\n\t * check socket cache ... must talk to Alan about his plans\n\t * for sock caches... i'll skip this for now.\n\t */\n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\tif (sk) {\n\t\tint ret;\n\n\t\tif (!uh->check && !udp_sk(sk)->no_check6_rx) {\n\t\t\tsock_put(sk);\n\t\t\tudp6_csum_zero_error(skb);\n\t\t\tgoto csum_error;\n\t\t}\n\n\t\tif (inet_get_convert_csum(sk) && uh->check && !IS_UDPLITE(sk))\n\t\t\tskb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,\n\t\t\t\t\t\t ip6_compute_pseudo);\n\n\t\tret = udpv6_queue_rcv_skb(sk, skb);\n\t\tsock_put(sk);\n\n\t\t/* a return value > 0 means to resubmit the input, but\n\t\t * it wants the return to be -protocol, or 0\n\t\t */\n\t\tif (ret > 0)\n\t\t\treturn -ret;\n\n\t\treturn 0;\n\t}\n\n\tif (!uh->check) {\n\t\tudp6_csum_zero_error(skb);\n\t\tgoto csum_error;\n\t}\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard;\n\n\tif (udp_lib_checksum_complete(skb))\n\t\tgoto csum_error;\n\n\tUDP6_INC_STATS_BH(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n\nshort_packet:\n\tnet_dbg_ratelimited(\"UDP%sv6: short packet: From [%pI6c]:%u %d/%d to [%pI6c]:%u\\n\",\n\t\t\t    proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t\t    saddr, ntohs(uh->source),\n\t\t\t    ulen, skb->len,\n\t\t\t    daddr, ntohs(uh->dest));\n\tgoto discard;\ncsum_error:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_CSUMERRORS, proto == IPPROTO_UDPLITE);\ndiscard:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic __inline__ int udpv6_rcv(struct sk_buff *skb)\n{\n\treturn __udp6_lib_rcv(skb, &udp_table, IPPROTO_UDP);\n}\n\n/*\n * Throw away all pending data and cancel the corking. Socket is locked.\n */\nstatic void udp_v6_flush_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\n\tif (up->pending == AF_INET)\n\t\tudp_flush_pending_frames(sk);\n\telse if (up->pending) {\n\t\tup->len = 0;\n\t\tup->pending = 0;\n\t\tip6_flush_pending_frames(sk);\n\t}\n}\n\n/**\n *\tudp6_hwcsum_outgoing  -  handle outgoing HW checksumming\n *\t@sk:\tsocket we are sending on\n *\t@skb:\tsk_buff containing the filled-in UDP header\n *\t\t(checksum field must be zeroed out)\n */\nstatic void udp6_hwcsum_outgoing(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t const struct in6_addr *saddr,\n\t\t\t\t const struct in6_addr *daddr, int len)\n{\n\tunsigned int offset;\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *frags = skb_shinfo(skb)->frag_list;\n\t__wsum csum = 0;\n\n\tif (!frags) {\n\t\t/* Only one fragment on the socket.  */\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tuh->check = ~csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP, 0);\n\t} else {\n\t\t/*\n\t\t * HW-checksum won't work as there are two or more\n\t\t * fragments on the socket so that all csums of sk_buffs\n\t\t * should be together\n\t\t */\n\t\toffset = skb_transport_offset(skb);\n\t\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tdo {\n\t\t\tcsum = csum_add(csum, frags->csum);\n\t\t} while ((frags = frags->next));\n\n\t\tuh->check = csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP,\n\t\t\t\t\t    csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t}\n}\n\n/*\n *\tSending\n */\n\nstatic int udp_v6_send_skb(struct sk_buff *skb, struct flowi6 *fl6)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct udphdr *uh;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\tint offset = skb_transport_offset(skb);\n\tint len = skb->len - offset;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(len);\n\tuh->check = 0;\n\n\tif (is_udplite)\n\t\tcsum = udplite_csum(skb);\n\telse if (udp_sk(sk)->no_check6_tx) {   /* UDP csum disabled */\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tgoto send;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr, len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum(skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip6_send_skb(skb);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\n\treturn err;\n}\n\nstatic int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct flowi6 fl6;\n\tint err = 0;\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_push_pending_frames(sk);\n\n\t/* ip6_finish_skb will release the cork, so make a copy of\n\t * fl6 here.\n\t */\n\tfl6 = inet_sk(sk)->cork.fl.u.ip6;\n\n\tskb = ip6_finish_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_v6_send_skb(skb, &fl6);\n\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}\n\nint udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\tint connected = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!up->pending) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else\n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_v4mapped(daddr)) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->inet_dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\tif (__ipv6_only_sock(sk))\n\t\t\t\treturn -ENETUNREACH;\n\t\t\treturn udp_sendmsg(sk, msg, len);\n\t\t}\n\t}\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_sendmsg(sk, msg, len);\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\n\tgetfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl6.fl6_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (!flowlabel)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))\n\t\t\tfl6.flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tconnected = 1;\n\t}\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,\n\t\t\t\t\t    &hlimit, &tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\tif (final_p)\n\t\tconnected = 0;\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) {\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\t\tconnected = 0;\n\t} else if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_sk_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto out;\n\t}\n\n\tif (hlimit < 0)\n\t\thlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\t/* Lockless fast path for the non-corking case */\n\tif (!corkreq) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = ip6_make_skb(sk, getfrag, msg, ulen,\n\t\t\t\t   sizeof(struct udphdr), hlimit, tclass, opt,\n\t\t\t\t   &fl6, (struct rt6_info *)dst,\n\t\t\t\t   msg->msg_flags, dontfrag);\n\t\terr = PTR_ERR(skb);\n\t\tif (!IS_ERR_OR_NULL(skb))\n\t\t\terr = udp_v6_send_skb(skb, &fl6);\n\t\tgoto release_dst;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tnet_dbg_ratelimited(\"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tup->pending = AF_INET6;\n\ndo_append_data:\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\tup->len += ulen;\n\terr = ip6_append_data(sk, getfrag, msg, ulen,\n\t\tsizeof(struct udphdr), hlimit, tclass, opt, &fl6,\n\t\t(struct rt6_info *)dst,\n\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\n\nrelease_dst:\n\tif (dst) {\n\t\tif (connected) {\n\t\t\tip6_dst_store(sk, dst,\n\t\t\t\t      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?\n\t\t\t\t      &sk->sk_v6_daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\t      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?\n\t\t\t\t      &np->saddr :\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n\nvoid udpv6_destroy_sock(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tlock_sock(sk);\n\tudp_v6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tif (static_key_false(&udpv6_encap_needed) && up->encap_type) {\n\t\tvoid (*encap_destroy)(struct sock *sk);\n\t\tencap_destroy = ACCESS_ONCE(up->encap_destroy);\n\t\tif (encap_destroy)\n\t\t\tencap_destroy(sk);\n\t}\n\n\tinet6_destroy_sock(sk);\n}\n\n/*\n *\tSocket option code for UDP\n */\nint udpv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_setsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nint compat_udpv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_setsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn compat_ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nint udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nint compat_udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn compat_ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic const struct inet6_protocol udpv6_protocol = {\n\t.handler\t=\tudpv6_rcv,\n\t.err_handler\t=\tudpv6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\n/* ------------------------------------------------------------------------ */\n#ifdef CONFIG_PROC_FS\nint udp6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\n\t} else {\n\t\tint bucket = ((struct udp_iter_state *)seq->private)->bucket;\n\t\tstruct inet_sock *inet = inet_sk(v);\n\t\t__u16 srcp = ntohs(inet->inet_sport);\n\t\t__u16 destp = ntohs(inet->inet_dport);\n\t\tip6_dgram_sock_seq_show(seq, v, srcp, destp, bucket);\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations udp6_afinfo_seq_fops = {\n\t.owner    = THIS_MODULE,\n\t.open     = udp_seq_open,\n\t.read     = seq_read,\n\t.llseek   = seq_lseek,\n\t.release  = seq_release_net\n};\n\nstatic struct udp_seq_afinfo udp6_seq_afinfo = {\n\t.name\t\t= \"udp6\",\n\t.family\t\t= AF_INET6,\n\t.udp_table\t= &udp_table,\n\t.seq_fops\t= &udp6_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= udp6_seq_show,\n\t},\n};\n\nint __net_init udp6_proc_init(struct net *net)\n{\n\treturn udp_proc_register(net, &udp6_seq_afinfo);\n}\n\nvoid udp6_proc_exit(struct net *net)\n{\n\tudp_proc_unregister(net, &udp6_seq_afinfo);\n}\n#endif /* CONFIG_PROC_FS */\n\nvoid udp_v6_clear_sk(struct sock *sk, int size)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t/* we do not want to clear pinet6 field, because of RCU lookups */\n\tsk_prot_clear_portaddr_nulls(sk, offsetof(struct inet_sock, pinet6));\n\n\tsize -= offsetof(struct inet_sock, pinet6) + sizeof(inet->pinet6);\n\tmemset(&inet->pinet6 + 1, 0, size);\n}\n\n/* ------------------------------------------------------------------------ */\n\nstruct proto udpv6_prot = {\n\t.name\t\t   = \"UDPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = udp_lib_close,\n\t.connect\t   = ip6_datagram_connect,\n\t.disconnect\t   = udp_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = udpv6_destroy_sock,\n\t.setsockopt\t   = udpv6_setsockopt,\n\t.getsockopt\t   = udpv6_getsockopt,\n\t.sendmsg\t   = udpv6_sendmsg,\n\t.recvmsg\t   = udpv6_recvmsg,\n\t.backlog_rcv\t   = __udpv6_queue_rcv_skb,\n\t.hash\t\t   = udp_lib_hash,\n\t.unhash\t\t   = udp_lib_unhash,\n\t.rehash\t\t   = udp_v6_rehash,\n\t.get_port\t   = udp_v6_get_port,\n\t.memory_allocated  = &udp_memory_allocated,\n\t.sysctl_mem\t   = sysctl_udp_mem,\n\t.sysctl_wmem\t   = &sysctl_udp_wmem_min,\n\t.sysctl_rmem\t   = &sysctl_udp_rmem_min,\n\t.obj_size\t   = sizeof(struct udp6_sock),\n\t.slab_flags\t   = SLAB_DESTROY_BY_RCU,\n\t.h.udp_table\t   = &udp_table,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_udpv6_setsockopt,\n\t.compat_getsockopt = compat_udpv6_getsockopt,\n#endif\n\t.clear_sk\t   = udp_v6_clear_sk,\n};\n\nstatic struct inet_protosw udpv6_protosw = {\n\t.type =      SOCK_DGRAM,\n\t.protocol =  IPPROTO_UDP,\n\t.prot =      &udpv6_prot,\n\t.ops =       &inet6_dgram_ops,\n\t.flags =     INET_PROTOSW_PERMANENT,\n};\n\nint __init udpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_register_protosw(&udpv6_protosw);\n\tif (ret)\n\t\tgoto out_udpv6_protocol;\nout:\n\treturn ret;\n\nout_udpv6_protocol:\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tgoto out;\n}\n\nvoid udpv6_exit(void)\n{\n\tinet6_unregister_protosw(&udpv6_protosw);\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n}\n", "/*\n * L2TPv3 IP encapsulation support for IPv6\n *\n * Copyright (c) 2012 Katalix Systems Ltd\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/icmp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/socket.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n\n#include \"l2tp_core.h\"\n\nstruct l2tp_ip6_sock {\n\t/* inet_sock has to be the first member of l2tp_ip6_sock */\n\tstruct inet_sock\tinet;\n\n\tu32\t\t\tconn_id;\n\tu32\t\t\tpeer_conn_id;\n\n\t/* ipv6_pinfo has to be the last member of l2tp_ip6_sock, see\n\t   inet6_sk_generic */\n\tstruct ipv6_pinfo\tinet6;\n};\n\nstatic DEFINE_RWLOCK(l2tp_ip6_lock);\nstatic struct hlist_head l2tp_ip6_table;\nstatic struct hlist_head l2tp_ip6_bind_table;\n\nstatic inline struct l2tp_ip6_sock *l2tp_ip6_sk(const struct sock *sk)\n{\n\treturn (struct l2tp_ip6_sock *)sk;\n}\n\nstatic struct sock *__l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t   struct in6_addr *laddr,\n\t\t\t\t\t   int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip6_bind_table) {\n\t\tconst struct in6_addr *addr = inet6_rcv_saddr(sk);\n\t\tstruct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);\n\n\t\tif (l2tp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((l2tp->conn_id == tunnel_id) &&\n\t\t    net_eq(sock_net(sk), net) &&\n\t\t    !(addr && ipv6_addr_equal(addr, laddr)) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\n\t\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic inline struct sock *l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t\tstruct in6_addr *laddr,\n\t\t\t\t\t\tint dif, u32 tunnel_id)\n{\n\tstruct sock *sk = __l2tp_ip6_bind_lookup(net, laddr, dif, tunnel_id);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\treturn sk;\n}\n\n/* When processing receive frames, there are two cases to\n * consider. Data frames consist of a non-zero session-id and an\n * optional cookie. Control frames consist of a regular L2TP header\n * preceded by 32-bits of zeros.\n *\n * L2TPv3 Session Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                           Session ID                          |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Cookie (optional, maximum 64 bits)...\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *                                                                 |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * L2TPv3 Control Message Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                      (32 bits of zeros)                       |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                     Control Connection ID                     |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Ns              |               Nr              |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * All control frames are passed to userspace.\n */\nstatic int l2tp_ip6_recv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tu32 session_id;\n\tu32 tunnel_id;\n\tunsigned char *ptr, *optr;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tint length;\n\n\t/* Point to L2TP header */\n\toptr = ptr = skb->data;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto discard;\n\n\tsession_id = ntohl(*((__be32 *) ptr));\n\tptr += 4;\n\n\t/* RFC3931: L2TP/IP packets have the first 4 bytes containing\n\t * the session_id. If it is 0, the packet is a L2TP control\n\t * frame and the session_id value can be discarded.\n\t */\n\tif (session_id == 0) {\n\t\t__skb_pull(skb, 4);\n\t\tgoto pass_up;\n\t}\n\n\t/* Ok, this is a data packet. Lookup the session. */\n\tsession = l2tp_session_find(&init_net, NULL, session_id);\n\tif (session == NULL)\n\t\tgoto discard;\n\n\ttunnel = session->tunnel;\n\tif (tunnel == NULL)\n\t\tgoto discard;\n\n\t/* Trace packet contents, if enabled */\n\tif (tunnel->debug & L2TP_MSG_DATA) {\n\t\tlength = min(32u, skb->len);\n\t\tif (!pskb_may_pull(skb, length))\n\t\t\tgoto discard;\n\n\t\tpr_debug(\"%s: ip recv\\n\", tunnel->name);\n\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, ptr, length);\n\t}\n\n\tl2tp_recv_common(session, skb, ptr, optr, 0, skb->len,\n\t\t\t tunnel->recv_payload_hook);\n\treturn 0;\n\npass_up:\n\t/* Get the tunnel_id from the L2TP header */\n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto discard;\n\n\tif ((skb->data[0] & 0xc0) != 0xc0)\n\t\tgoto discard;\n\n\ttunnel_id = ntohl(*(__be32 *) &skb->data[4]);\n\ttunnel = l2tp_tunnel_find(&init_net, tunnel_id);\n\tif (tunnel != NULL)\n\t\tsk = tunnel->sock;\n\telse {\n\t\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\n\t\tread_lock_bh(&l2tp_ip6_lock);\n\t\tsk = __l2tp_ip6_bind_lookup(&init_net, &iph->daddr,\n\t\t\t\t\t    0, tunnel_id);\n\t\tread_unlock_bh(&l2tp_ip6_lock);\n\t}\n\n\tif (sk == NULL)\n\t\tgoto discard;\n\n\tsock_hold(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_put;\n\n\tnf_reset(skb);\n\n\treturn sk_receive_skb(sk, skb, 1);\n\ndiscard_put:\n\tsock_put(sk);\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_open(struct sock *sk)\n{\n\t/* Prevent autobind. We don't have ports. */\n\tinet_sk(sk)->inet_num = IPPROTO_L2TP;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_node(sk, &l2tp_ip6_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\treturn 0;\n}\n\nstatic void l2tp_ip6_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsk_common_release(sk);\n}\n\nstatic void l2tp_ip6_destroy_sock(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\n\n\tlock_sock(sk);\n\tip6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tif (tunnel) {\n\t\tl2tp_tunnel_closeall(tunnel);\n\t\tsock_put(sk);\n\t}\n\n\tinet6_destroy_sock(sk);\n}\n\nstatic int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(&init_net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}\n\nstatic int l2tp_ip6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t    int addr_len)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;\n\tstruct in6_addr\t*daddr;\n\tint\taddr_type;\n\tint rc;\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EINVAL;\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tdaddr = &usin->sin6_addr;\n\t\tif (ipv4_is_multicast(daddr->s6_addr32[3]))\n\t\t\treturn -EINVAL;\n\t}\n\n\trc = ip6_datagram_connect(sk, uaddr, addr_len);\n\n\tlock_sock(sk);\n\n\tl2tp_ip6_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int l2tp_ip6_disconnect(struct sock *sk, int flags)\n{\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn 0;\n\n\treturn udp_disconnect(sk, flags);\n}\n\nstatic int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = sk->sk_v6_daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = sk->sk_v6_rcv_saddr;\n\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic int l2tp_ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\t__be32 *transhdr = NULL;\n\tint err = 0;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\ttranshdr = (__be32 *)skb_transport_header(skb);\n\t*transhdr = 0;\n\n\terr = ip6_push_pending_frames(sk);\n\nout:\n\treturn err;\n}\n\n/* Userspace will call sendmsg() on the tunnel socket to send L2TP\n * control frames.\n */\nstatic int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 fl6;\n\tint addr_len = msg->msg_namelen;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint transhdrlen = 4; /* zero session-id */\n\tint ulen = len + transhdrlen;\n\tint err;\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t */\n\tif (len > INT_MAX)\n\t\treturn -EMSGSIZE;\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (lsa) {\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\treturn -EINVAL;\n\n\t\tif (lsa->l2tp_family && lsa->l2tp_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\tdaddr = &lsa->l2tp_addr;\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = lsa->l2tp_flowinfo & IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    lsa->l2tp_scope_id &&\n\t\t    ipv6_addr_type(daddr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = lsa->l2tp_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (fl6.flowi6_oif == 0)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(struct ipv6_txoptions);\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,\n\t\t\t\t\t    &hlimit, &tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel & IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\n\tif (hlimit < 0)\n\t\thlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\n\nback_from_confirm:\n\tlock_sock(sk);\n\terr = ip6_append_data(sk, ip_generic_getfrag, msg,\n\t\t\t      ulen, transhdrlen, hlimit, tclass, opt,\n\t\t\t      &fl6, (struct rt6_info *)dst,\n\t\t\t      msg->msg_flags, dontfrag);\n\tif (err)\n\t\tip6_flush_pending_frames(sk);\n\telse if (!(msg->msg_flags & MSG_MORE))\n\t\terr = l2tp_ip6_push_pending_frames(sk);\n\trelease_sock(sk);\ndone:\n\tdst_release(dst);\nout:\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\n\treturn err < 0 ? err : len;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic int l2tp_ip6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t    int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = inet6_iif(skb);\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n\nstatic struct proto l2tp_ip6_prot = {\n\t.name\t\t   = \"L2TP/IPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.init\t\t   = l2tp_ip6_open,\n\t.close\t\t   = l2tp_ip6_close,\n\t.bind\t\t   = l2tp_ip6_bind,\n\t.connect\t   = l2tp_ip6_connect,\n\t.disconnect\t   = l2tp_ip6_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = l2tp_ip6_destroy_sock,\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.sendmsg\t   = l2tp_ip6_sendmsg,\n\t.recvmsg\t   = l2tp_ip6_recvmsg,\n\t.backlog_rcv\t   = l2tp_ip6_backlog_recv,\n\t.hash\t\t   = inet_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.obj_size\t   = sizeof(struct l2tp_ip6_sock),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\nstatic const struct proto_ops l2tp_ip6_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = l2tp_ip6_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw l2tp_ip6_protosw = {\n\t.type\t\t= SOCK_DGRAM,\n\t.protocol\t= IPPROTO_L2TP,\n\t.prot\t\t= &l2tp_ip6_prot,\n\t.ops\t\t= &l2tp_ip6_ops,\n};\n\nstatic struct inet6_protocol l2tp_ip6_protocol __read_mostly = {\n\t.handler\t= l2tp_ip6_recv,\n};\n\nstatic int __init l2tp_ip6_init(void)\n{\n\tint err;\n\n\tpr_info(\"L2TP IP encapsulation support for IPv6 (L2TPv3)\\n\");\n\n\terr = proto_register(&l2tp_ip6_prot, 1);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tif (err)\n\t\tgoto out1;\n\n\tinet6_register_protosw(&l2tp_ip6_protosw);\n\treturn 0;\n\nout1:\n\tproto_unregister(&l2tp_ip6_prot);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_ip6_exit(void)\n{\n\tinet6_unregister_protosw(&l2tp_ip6_protosw);\n\tinet6_del_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tproto_unregister(&l2tp_ip6_prot);\n}\n\nmodule_init(l2tp_ip6_init);\nmodule_exit(l2tp_ip6_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Chris Elston <celston@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP IP encapsulation for IPv6\");\nMODULE_VERSION(\"1.0\");\n\n/* Use the value of SOCK_DGRAM (2) directory, because __stringify doesn't like\n * enums\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 2, IPPROTO_L2TP);\nMODULE_ALIAS_NET_PF_PROTO(PF_INET6, IPPROTO_L2TP);\n"], "filenames": ["include/linux/ipv6.h", "include/net/ipv6.h", "net/dccp/ipv6.c", "net/ipv6/af_inet6.c", "net/ipv6/datagram.c", "net/ipv6/exthdrs.c", "net/ipv6/inet6_connection_sock.c", "net/ipv6/ipv6_sockglue.c", "net/ipv6/raw.c", "net/ipv6/syncookies.c", "net/ipv6/tcp_ipv6.c", "net/ipv6/udp.c", "net/l2tp/l2tp_ip6.c"], "buggy_code_start_loc": [230, 207, 205, 431, 170, 729, 81, 114, 735, 225, 122, 1112, 488], "buggy_code_end_loc": [231, 254, 882, 663, 171, 794, 179, 1117, 908, 226, 1108, 1375, 633], "fixing_code_start_loc": [230, 208, 205, 431, 170, 730, 81, 114, 736, 225, 123, 1113, 489], "fixing_code_end_loc": [231, 274, 891, 668, 174, 795, 184, 1128, 913, 226, 1114, 1380, 638], "type": "CWE-264", "message": "The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call.", "other": {"cve": {"id": "CVE-2016-3841", "sourceIdentifier": "security@android.com", "published": "2016-08-06T20:59:01.297", "lastModified": "2018-01-05T02:30:43.917", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call."}, {"lang": "es", "value": "La pila IPv6 en el kernel de Linux en versiones anteriores a 4.3.3 no maneja adecuadamente datos de las opciones, lo que permite a usuarios locales obtener privilegios o provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n y ca\u00edda de sistema) a trav\u00e9s de una llamada al sistema sendmsg manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:android:6.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "691FA41B-C2CE-413F-ABB1-0B22CB322807"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.2", "matchCriteriaId": "17376827-DFED-4E71-8D4A-5E5C44073D57"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=45f6fad84cc305103b28d73482b344d7f5b76f39", "source": "security@android.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-0855.html", "source": "security@android.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2574.html", "source": "security@android.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2584.html", "source": "security@android.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2695.html", "source": "security@android.com"}, {"url": "http://source.android.com/security/bulletin/2016-08-01.html", "source": "security@android.com", "tags": ["Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.3.3", "source": "security@android.com", "tags": ["Release Notes"]}, {"url": "http://www.securityfocus.com/bid/92227", "source": "security@android.com"}, {"url": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39", "source": "security@android.com", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39"}}