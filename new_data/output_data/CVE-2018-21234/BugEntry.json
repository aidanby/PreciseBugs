{"buggy_code": ["# Jodd Changelog\n\nAll notable changes to Jodd project are documented here.\n\n## [n/a](https://github.com/oblac/jodd/compare/v5.0.3...master)\n\n(work in progress :)\n\n### Bug fixes\n\n+ **core** - fixed special cases in `NaturalOrderComparator`, making rules a bit more strict.  \n+ **mail** - fixed unused `debug` and `timeout`.\n+ **mail** - `RFC2822AddressParser` methods `parseToXxx()` now returns `null` for invalid emails.\n+ **http** - secure connection was sending `CONNECT` string twice.\n\n### Breaking changes\n\n+ **mail** - `debug` and `timeout` are now applied before creating the mail server.\n+ **http** - default security has been set to `TLSv1.1`.\n\n### New Features\n\n+ **joy** - added excluded jars for faster scanning.\n+ **mail** - added custom properties.\n+ **json** - added `onValue` callback for JSON serializer.\n+ **json** - added `excludeEmpty` flag for JSON serializer.\n+ **petite** - allow injection in the private fields of super types.\n\n\n\n## [v5.0.3](https://github.com/oblac/jodd/compare/v5.0.2...v5.0.3)\n\n### New Features\n\n+ **dboom** - added detection of the quote names in annotations.\n+ **dboom** - Added flags to column and table naming strategies for quote chars.\n\n\n\n## [v5.0.2](https://github.com/oblac/jodd/compare/v5.0.1...v5.0.2)\n\nOne minor fix and one important change for the bootstrap usages.\n\n### New Features\n\n+ **joy** - added static method for registering joy servlet context listener.\n\n### Bug Fixes\n\n+ **joy** - better output of the Joy configuration that does not cut of the values.  \n\n\n\n## [v5.0.1](https://github.com/oblac/jodd/compare/v5.0.0...v5.0.1)\n\nMinor fixes and improvements.\n\n### New Features\n\n+ **core*** - added the `Maybe.or(T)` method.\n+ **mail** - added `receive()` and fluent builder.\n+ **cli*** - parse values bundled with options (e.g. `--name=value`)\n\n### Bug Fixes\n\n+ **cli** - fixed the behaviour of parameters\n\n\n\n## [v5](https://github.com/oblac/jodd/compare/v4.3.2...v5.0.0)\n\nWelcome to Jodd 5.\n\nVersion 5 contains a great number of new features, changes, bug fixes and performance improvements. It's all new Jodd: slick as before, just better. \n\nHigh-five!\n\n## Previous releases\n\n[v4.x](CHANGELOG_v4.md)\n[v3.x](CHANGELOG_v3.md)\n", "// Copyright (c) 2003-present, Jodd Team (http://jodd.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\npackage jodd.json;\n\nimport jodd.introspector.ClassDescriptor;\nimport jodd.introspector.ClassIntrospector;\nimport jodd.introspector.PropertyDescriptor;\nimport jodd.json.meta.JsonAnnotationManager;\nimport jodd.json.meta.TypeData;\nimport jodd.util.CharArraySequence;\nimport jodd.util.CharUtil;\nimport jodd.util.StringPool;\nimport jodd.util.UnsafeUtil;\n\nimport java.math.BigInteger;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\n/**\n * Simple, developer-friendly JSON parser. It focuses on easy usage\n * and type mappings. Uses Jodd's type converters, so it is natural\n * companion for Jodd projects.\n * <p>\n * This JSON parser also works in {@link #lazy(boolean)} mode. This\n * mode is for top performance usage: parsing is done very, very lazy.\n * While you can use all the mappings and other tools, for best performance\n * the lazy mode should be used only with maps and lists (no special mappings).\n * Also, the performance has it's price: more memory consumption, because the\n * original input is hold until the result is in use.\n * <p>\n * See: http://www.ietf.org/rfc/rfc4627.txt\n */\npublic class JsonParser extends JsonParserBase {\n\n\tpublic static class Defaults {\n\n\t\tpublic static final String DEFAULT_CLASS_METADATA_NAME = \"__class\";\n\n\t\t/**\n\t\t * Flag for enabling the lazy mode.\n\t\t */\n\t\tpublic static boolean lazy = false;\n\t\t/**\n\t\t * Defines if parser will use extended paths information\n\t\t * and path matching.\n\t\t */\n\t\tpublic static boolean useAltPathsByParser = false;\n\t\t/**\n\t\t * Default value for loose mode.\n\t\t */\n\t\tpublic static boolean loose = false;\n\n\t\t/**\n\t\t * Specifies if 'class' metadata is used and its value. When set, class metadata\n\t\t * is used by {@link jodd.json.JsonSerializer} and all objects\n\t\t * will have additional field with the class type in the resulting JSON.\n\t\t * {@link jodd.json.JsonParser} will also consider this flag to build\n\t\t * correct object type. If <code>null</code>, class information is not used.\n\t\t */\n\t\tpublic static String classMetadataName = null;\n\t}\n\n\t/**\n\t * Static ctor.\n\t */\n\tpublic static JsonParser create() {\n\t\treturn new JsonParser();\n\t}\n\n\t/**\n\t * Creates a lazy implementation of the JSON parser.\n\t */\n\tpublic static JsonParser createLazyOne() {\n\t\treturn new JsonParser().lazy(true);\n\t}\n\n\tprivate static final char[] T_RUE = new char[] {'r', 'u', 'e'};\n\tprivate static final char[] F_ALSE = new char[] {'a', 'l', 's', 'e'};\n\tprivate static final char[] N_ULL = new char[] {'u', 'l', 'l'};\n\n\t/**\n\t * Map keys.\n\t */\n\tpublic static final String KEYS = \"keys\";\n\t/**\n\t * Array or map values.\n\t */\n\tpublic static final String VALUES = \"values\";\n\n\tprotected int ndx = 0;\n\tprotected char[] input;\n\tprotected int total;\n\tprotected Path path;\n\tprotected boolean useAltPaths = Defaults.useAltPathsByParser;\n\tprotected boolean lazy = Defaults.lazy;\n\tprotected boolean looseMode = Defaults.loose;\n\tprotected Class rootType;\n\tprotected MapToBean mapToBean;\n\tprivate boolean notFirstObject = false;\n\n\tprivate final JsonAnnotationManager jsonAnnotationManager;\n\n\tpublic JsonParser() {\n\t\tthis.text = new char[512];\n\t\tthis.jsonAnnotationManager = JsonAnnotationManager.get();\n\t}\n\n\t/**\n\t * Resets JSON parser, so it can be reused.\n\t */\n\tprotected void reset() {\n\t\tthis.ndx = 0;\n\t\tthis.textLen = 0;\n\t\tthis.path = new Path();\n\t\tif (useAltPaths) {\n\t\t\tpath.altPath = new Path();\n\t\t}\n\n\t\tif (classMetadataName != null) {\n\t\t\tmapToBean = createMapToBean(classMetadataName);\n\t\t}\n\t}\n\n\t/**\n\t * Enables usage of additional paths.\n\t */\n\tpublic JsonParser useAltPaths() {\n\t\tthis.useAltPaths = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enables 'loose' mode for parsing. When 'loose' mode is enabled,\n\t * JSON parsers swallows also invalid JSONs:\n\t * <ul>\n\t *     <li>invalid escape character sequence is simply added to the output</li>\n\t *     <li>strings can be quoted with single-quotes</li>\n\t *     <li>strings can be unquoted, but may not contain escapes</li>\n\t * </ul>\n\t */\n\tpublic JsonParser looseMode(final boolean looseMode) {\n\t\tthis.looseMode = looseMode;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Defines how JSON parser works. In non-lazy mode, the whole JSON is parsed as it is.\n\t * In the lazy mode, not everything is parsed, but some things are left lazy.\n\t * This way we gain performance, especially on partial usage of the whole JSON.\n\t * However, be aware that parser holds the input memory until the returned\n\t * objects are disposed.\n\t */\n\tpublic JsonParser lazy(final boolean lazy) {\n\t\tthis.lazy = lazy;\n\t\tthis.mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASMAP_SUPPLIER;\n\t\tthis.listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER;\n\t\treturn this;\n\t}\n\n\t// ---------------------------------------------------------------- mappings\n\n\tprotected Map<Path, Class> mappings;\n\n\t/**\n\t * Maps a class to JSONs root.\n\t */\n\tpublic JsonParser map(final Class target) {\n\t\trootType = target;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Maps a class to given path. For arrays, append <code>values</code>\n\t * to the path to specify component type (if not specified by\n\t * generics).\n\t */\n\tpublic JsonParser map(final String path, final Class target) {\n\t\tif (path == null) {\n\t\t\trootType = target;\n\t\t\treturn this;\n\t\t}\n\t\tif (mappings == null) {\n\t\t\tmappings = new HashMap<>();\n\t\t}\n\t\tmappings.put(Path.parse(path), target);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replaces type with mapped type for current path.\n\t */\n\tprotected Class replaceWithMappedTypeForPath(final Class target) {\n\t\tif (mappings == null) {\n\t\t\treturn target;\n\t\t}\n\n\t\tClass newType;\n\n\t\t// first try alt paths\n\n\t\tPath altPath = path.getAltPath();\n\n\t\tif (altPath != null) {\n\t\t\tif (!altPath.equals(path)) {\n\t\t\t\tnewType = mappings.get(altPath);\n\n\t\t\t\tif (newType != null) {\n\t\t\t\t\treturn newType;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// now check regular paths\n\n\t\tnewType = mappings.get(path);\n\n\t\tif (newType != null) {\n\t\t\treturn newType;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t// ---------------------------------------------------------------- converters\n\n\tprotected Map<Path, ValueConverter> convs;\n\n\t/**\n\t * Defines {@link jodd.json.ValueConverter} to use on given path.\n\t */\n\tpublic JsonParser withValueConverter(final String path, final ValueConverter valueConverter) {\n\t\tif (convs == null) {\n\t\t\tconvs = new HashMap<>();\n\t\t}\n\t\tconvs.put(Path.parse(path), valueConverter);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lookups for value converter for current path.\n\t */\n\tprotected ValueConverter lookupValueConverter() {\n\t\tif (convs == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn convs.get(path);\n\t}\n\n\t// ---------------------------------------------------------------- class meta data name\n\n\tprotected String classMetadataName = Defaults.classMetadataName;\n\n\t/**\n\t * Sets local class meta-data name.\n\t * <p>\n\t * Note that by using the class meta-data name you may expose a security hole in case untrusted source\n\t * manages to specify a class that is accessible through class loader and exposes set of methods and/or fields,\n\t * access of which opens an actual security hole. Such classes are known as \u201cdeserialization gadget\u201ds.\n\t *\n\t * Because of this, use of \"default typing\" is not encouraged in general, and in particular is recommended against\n\t * if the source of content is not trusted. Conversely, default typing may be used for processing content in\n\t * cases where both ends (sender and receiver) are controlled by same entity.\n\t */\n\tpublic JsonParser setClassMetadataName(final String name) {\n\t\tclassMetadataName = name;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets usage of default class meta-data name.\n\t * Using it may introduce a security hole, see {@link #setClassMetadataName(String)} for more details.\n\t * @see #setClassMetadataName(String)\n\t */\n\tpublic JsonParser withClassMetadata(final boolean useMetadata) {\n\t\tif (useMetadata) {\n\t\t\tclassMetadataName = Defaults.DEFAULT_CLASS_METADATA_NAME;\n\t\t}\n\t\telse {\n\t\t\tclassMetadataName = null;\n\t\t}\n\t\treturn this;\n\t}\n\n\n\t// ---------------------------------------------------------------- parse\n\n\t/**\n\t * Parses input JSON as given type.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T parse(final String input, final Class<T> targetType) {\n\t\trootType = targetType;\n\t\treturn _parse(UnsafeUtil.getChars(input));\n\t}\n\n\t/**\n\t * Parses input JSON to {@link JsonObject}, special case of {@link #parse(String, Class)}.\n\t */\n\tpublic JsonObject parseAsJsonObject(final String input) {\n\t\treturn new JsonObject(parse(input));\n\t}\n\n\t/**\n\t * Parses input JSON to {@link JsonArray}, special case of parsing.\n\t */\n\tpublic JsonArray parseAsJsonArray(final String input) {\n\t\treturn new JsonArray(parse(input));\n\t}\n\n\t/**\n\t * Parses input JSON to a list with specified component type.\n\t */\n\tpublic <T> List<T> parseAsList(final String string, final Class<T> componentType) {\n\t\treturn new JsonParser()\n\t\t\t.map(JsonParser.VALUES, componentType)\n\t\t\t.parse(string);\n\t}\n\n\t/**\n\t * Parses input JSON to a list with specified key and value types.\n\t */\n\tpublic <K, V> Map<K, V> parseAsMap(\n\t\tfinal String string, final Class<K> keyType, final Class<V> valueType) {\n\n\t\treturn new JsonParser()\n\t\t\t.map(JsonParser.KEYS, keyType)\n\t\t\t.map(JsonParser.VALUES, valueType)\n\t\t\t.parse(string);\n\t}\n\n\t/**\n\t * Parses input JSON string.\n\t */\n\tpublic <T> T parse(final String input) {\n\t\treturn _parse(UnsafeUtil.getChars(input));\n\t}\n\n\t/**\n\t * Parses input JSON as given type.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T parse(final char[] input, final Class<T> targetType) {\n\t\trootType = targetType;\n\t\treturn _parse(input);\n\t}\n\n\t/**\n\t * Parses input JSON char array.\n\t */\n\tpublic <T> T parse(final char[] input) {\n\t\treturn _parse(input);\n\t}\n\n\n\tprivate <T> T _parse(final char[] input) {\n\t\tthis.input = input;\n\t\tthis.total = input.length;\n\n\t\treset();\n\n\t\tskipWhiteSpaces();\n\n\t\tObject value;\n\n\t\ttry {\n\t\t\tvalue = parseValue(rootType, null, null);\n\t\t}\n\t\tcatch (IndexOutOfBoundsException iofbex) {\n\t\t\tsyntaxError(\"End of JSON\");\n\t\t\treturn null;\n\t\t}\n\n\t\tskipWhiteSpaces();\n\n\t\tif (ndx != total) {\n\t\t\tsyntaxError(\"Trailing chars\");\n\t\t\treturn null;\n\t\t}\n\n\t\tif (lazy) {\n\t\t\t// lets resolve root lazy values\n\t\t\tvalue = resolveLazyValue(value);\n\t\t}\n\n\t\t// convert map to target type\n\n\t\tif (classMetadataName != null && rootType == null) {\n\t\t\tif (value instanceof Map) {\n\t\t\t\tMap map = (Map) value;\n\n\t\t\t\tvalue = mapToBean.map2bean(map, null);\n\t\t\t}\n\t\t}\n\n\t\treturn (T) value;\n\t}\n\n\t// ---------------------------------------------------------------- parser\n\n\t/**\n\t * Parses a JSON value.\n\t * @param targetType target type to convert, may be <code>null</code>\n\t * @param componentType component type for maps and arrays, may be <code>null</code>\n\t */\n\tprotected Object parseValue(final Class targetType, final Class keyType, final Class componentType) {\n\t\tfinal ValueConverter valueConverter;\n\n\t\tfinal char c = input[ndx];\n\n\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\t\tif (!looseMode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '\"':\n\t\t\t\tndx++;\n\t\t\t\tObject string = parseStringContent(c);\n\n\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\treturn valueConverter.convert(string);\n\t\t\t\t}\n\n\t\t\t\tif (targetType != null && targetType != String.class) {\n\t\t\t\t\tstring = convertType(string, targetType);\n\t\t\t\t}\n\t\t\t\treturn string;\n\n\t\t\tcase '{':\n\t\t\t\tndx++;\n\t\t\t\tif (lazy) {\n\t\t\t\t\tif (notFirstObject) {\n\t\t\t\t\t\tfinal Object value = new ObjectParser(this, targetType, keyType, componentType);\n\n\t\t\t\t\t\tskipObject();\n\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnotFirstObject = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn parseObjectContent(targetType, keyType, componentType);\n\n\t\t\tcase '[':\n\t\t\t\tndx++;\n\t\t\t\treturn parseArrayContent(targetType, componentType);\n\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\tcase '-':\n\t\t\t\tObject number = parseNumber();\n\n\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\treturn valueConverter.convert(number);\n\t\t\t\t}\n\n\t\t\t\tif (targetType != null) {\n\t\t\t\t\tnumber = convertType(number, targetType);\n\t\t\t\t}\n\t\t\t\treturn number;\n\n\t\t\tcase 'n':\n\t\t\t\tndx++;\n\t\t\t\tif (match(N_ULL)) {\n\t\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\t\treturn valueConverter.convert(null);\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tndx++;\n\t\t\t\tif (match(T_RUE)) {\n\t\t\t\t\tObject value = Boolean.TRUE;\n\n\t\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\t\treturn valueConverter.convert(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetType != null) {\n\t\t\t\t\t\tvalue = convertType(value, targetType);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tndx++;\n\t\t\t\tif (match(F_ALSE)) {\n\t\t\t\t\tObject value = Boolean.FALSE;\n\n\t\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\t\treturn valueConverter.convert(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetType != null) {\n\t\t\t\t\t\tvalue = convertType(value, targetType);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (looseMode) {\n\t\t\t// try to parse unquoted string\n\t\t\tObject string = parseUnquotedStringContent();\n\n\t\t\tvalueConverter = lookupValueConverter();\n\t\t\tif (valueConverter != null) {\n\t\t\t\treturn valueConverter.convert(string);\n\t\t\t}\n\n\t\t\tif (targetType != null && targetType != String.class) {\n\t\t\t\tstring = convertType(string, targetType);\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\n\t\tsyntaxError(\"Invalid char: \" + input[ndx]);\n\t\treturn null;\n\t}\n\n\n\t// ---------------------------------------------------------------- lazy\n\n\t/**\n\t * Resolves lazy value during the parsing runtime.\n\t */\n\tprivate Object resolveLazyValue(Object value) {\n\t\tif (value instanceof Supplier) {\n\t\t\tvalue = ((Supplier)value).get();\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Skips over complete object. It is not parsed, just skipped. It will be\n\t * parsed later, but oonly if required.\n\t */\n\tprivate void skipObject() {\n\t\tint bracketCount = 1;\n\t\tboolean insideString = false;\n\n\t\twhile (ndx < total) {\n\t\t\tfinal char c = input[ndx];\n\n\t\t\tif (insideString) {\n\t\t\t\tif (c == '\\\"') {\n\t\t\t\t\tinsideString = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\"') {\n\t\t\t\t\tinsideString = true;\n\t\t\t\t}\n\t\t\t\tif (c == '{') {\n\t\t\t\t\tbracketCount++;\n\t\t\t\t} else if (c == '}') {\n\t\t\t\t\tbracketCount--;\n\t\t\t\t\tif (bracketCount == 0) {\n\t\t\t\t\t\tndx++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tndx++;\n\t\t}\n\t}\n\n\t// ---------------------------------------------------------------- string\n\n\tprotected char[] text;\n\tprotected int textLen;\n\n\t/**\n\t * Parses a string.\n\t */\n\tprotected String parseString() {\n\t\tchar quote = '\\\"';\n\t\tif (looseMode) {\n\t\t\tquote = consumeOneOf('\\\"', '\\'');\n\t\t\tif (quote == 0) {\n\t\t\t\treturn parseUnquotedStringContent();\n\t\t\t}\n\t\t} else {\n\t\t\tconsume(quote);\n\t\t}\n\n\t\treturn parseStringContent(quote);\n\t}\n\n\t/**\n\t * Parses string content, once when starting quote has been consumed.\n\t */\n\tprotected String parseStringContent(final char quote) {\n\t\tfinal int startNdx = ndx;\n\n\t\t// roll-out until the end of the string or the escape char\n\t\twhile (true) {\n\t\t\tfinal char c = input[ndx];\n\n\t\t\tif (c == quote) {\n\t\t\t\t// no escapes found, just use existing string\n\t\t\t\tndx++;\n\t\t\t\treturn new String(input, startNdx, ndx - 1 - startNdx);\n\t\t\t}\n\n\t\t\tif (c == '\\\\') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tndx++;\n\t\t}\n\n\t\t// escapes found, proceed differently\n\n\t\ttextLen = ndx - startNdx;\n\n\t\tgrowEmpty();\n\n//\t\tfor (int i = startNdx, j = 0; j < textLen; i++, j++) {\n//\t\t\ttext[j] = input[i];\n//\t\t}\n\t\tSystem.arraycopy(input, startNdx, text, 0, textLen);\n\n\t\t// escape char, process everything until the end\n\t\twhile (true) {\n\t\t\tchar c = input[ndx];\n\n\t\t\tif (c == quote) {\n\t\t\t\t// done\n\t\t\t\tndx++;\n\t\t\t\tfinal String str = new String(text, 0, textLen);\n\t\t\t\ttextLen = 0;\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t\tif (c == '\\\\') {\n\t\t\t\t// escape char found\n\t\t\t\tndx++;\n\n\t\t\t\tc = input[ndx];\n\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\"' : c = '\\\"'; break;\n\t\t\t\t\tcase '\\\\' : c = '\\\\'; break;\n\t\t\t\t\tcase '/' : c = '/'; break;\n\t\t\t\t\tcase 'b' : c = '\\b'; break;\n\t\t\t\t\tcase 'f' : c = '\\f'; break;\n\t\t\t\t\tcase 'n' : c = '\\n'; break;\n\t\t\t\t\tcase 'r' : c = '\\r'; break;\n\t\t\t\t\tcase 't' : c = '\\t'; break;\n\t\t\t\t\tcase 'u' :\n\t\t\t\t\t\tndx++;\n\t\t\t\t\t\tc = parseUnicode();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (looseMode) {\n\t\t\t\t\t\t\tif (c != '\\'') {\n\t\t\t\t\t\t\t\tc = '\\\\';\n\t\t\t\t\t\t\t\tndx--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsyntaxError(\"Invalid escape char: \" + c);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext[textLen] = c;\n\n\t\t\ttextLen++;\n\n\t\t\tgrowAndCopy();\n\n\t\t\tndx++;\n\t\t}\n\t}\n\n\t/**\n\t * Grows empty text array.\n\t */\n\tprotected void growEmpty() {\n\t\tif (textLen >= text.length) {\n\t\t\tint newSize = textLen << 1;\n\n\t\t\ttext = new char[newSize];\n\t\t}\n\t}\n\n\t/**\n\t * Grows text array when {@code text.length == textLen}.\n\t */\n\tprotected void growAndCopy() {\n\t\tif (textLen == text.length) {\n\t\t\tint newSize = text.length << 1;\n\n\t\t\tchar[] newText = new char[newSize];\n\n\t\t\tif (textLen > 0) {\n\t\t\t\tSystem.arraycopy(text, 0, newText, 0, textLen);\n\t\t\t}\n\n\t\t\ttext = newText;\n\t\t}\n\t}\n\n\t/**\n\t * Parses 4 characters and returns unicode character.\n\t */\n\tprotected char parseUnicode() {\n\t\tint i0 = CharUtil.hex2int(input[ndx++]);\n\t\tint i1 = CharUtil.hex2int(input[ndx++]);\n\t\tint i2 = CharUtil.hex2int(input[ndx++]);\n\t\tint i3 = CharUtil.hex2int(input[ndx]);\n\n\t\treturn (char) ((i0 << 12) + (i1 << 8) + (i2 << 4) + i3);\n\t}\n\n\t// ---------------------------------------------------------------- un-quoted\n\n\tprivate final static char[] UNQOUTED_DELIMETERS = \",:[]{}\\\\\\\"'\".toCharArray();\n\n\t/**\n\t * Parses un-quoted string content.\n\t */\n\tprotected String parseUnquotedStringContent() {\n\t\tfinal int startNdx = ndx;\n\n\t\twhile (true) {\n\t\t\tfinal char c = input[ndx];\n\n\t\t\tif (c <= ' ' || CharUtil.equalsOne(c, UNQOUTED_DELIMETERS)) {\n\t\t\t\tfinal int currentNdx = ndx;\n\n\t\t\t\t// done\n\t\t\t\tskipWhiteSpaces();\n\n\t\t\t\treturn new String(input, startNdx, currentNdx - startNdx);\n\t\t\t}\n\n\t\t\tndx++;\n\t\t}\n\t}\n\n\n\t// ---------------------------------------------------------------- number\n\n\t/**\n\t * Parses JSON numbers.\n\t */\n\tprotected Number parseNumber() {\n\t\tfinal int startIndex = ndx;\n\n\t\tchar c = input[ndx];\n\n\t\tboolean isDouble = false;\n\t\tboolean isExp = false;\n\n\t\tif (c == '-') {\n\t\t\tndx++;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (isEOF()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tc = input[ndx];\n\n\t\t\tif (c >= '0' && c <= '9') {\n\t\t\t\tndx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c <= 32) {\t\t// white space\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == ',' || c == '}' || c == ']') {\t// delimiter\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tisDouble = true;\n\t\t\t}\n\t\t\telse if (c == 'e' || c == 'E') {\n\t\t\t\tisExp = true;\n\t\t\t}\n\t\t\tndx++;\n\t\t}\n\n\n\t\tfinal String value = new String(input, startIndex, ndx - startIndex);\n\n\t\tif (isDouble) {\n\t\t\treturn Double.valueOf(value);\n\t\t}\n\n\t\tlong longNumber;\n\n\t\tif (isExp) {\n\t\t\tlongNumber = Double.valueOf(value).longValue();\n\t\t}\n\t\telse {\n\t\t\tif (value.length() >= 19) {\n\t\t\t\t// if string is 19 chars and longer, it can be over the limit\n\t\t\t\tBigInteger bigInteger = new BigInteger(value);\n\n\t\t\t\tif (isGreaterThenLong(bigInteger)) {\n\t\t\t\t\treturn bigInteger;\n\t\t\t\t}\n\t\t\t\tlongNumber = bigInteger.longValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlongNumber = Long.parseLong(value);\n\t\t\t}\n\t\t}\n\n\t\tif ((longNumber >= Integer.MIN_VALUE) && (longNumber <= Integer.MAX_VALUE)) {\n\t\t\treturn Integer.valueOf((int) longNumber);\n\t\t}\n\t\treturn Long.valueOf(longNumber);\n\t}\n\n\tprivate static boolean isGreaterThenLong(final BigInteger bigInteger) {\n\t\tif (bigInteger.compareTo(MAX_LONG) > 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (bigInteger.compareTo(MIN_LONG) < 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n\tprivate static final BigInteger MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\n\n\t// ---------------------------------------------------------------- array\n\n\t/**\n\t * Parses arrays, once when open bracket has been consumed.\n\t */\n\tprotected Object parseArrayContent(Class targetType, Class componentType) {\n\t\t// detect special case\n\n\t\tif (targetType == Object.class) {\n\t\t\ttargetType = List.class;\n\t\t}\n\n\t\t// continue\n\n\t\ttargetType = replaceWithMappedTypeForPath(targetType);\n\n\t\tif (componentType == null && targetType != null && targetType.isArray()) {\n\t\t\tcomponentType = targetType.getComponentType();\n\t\t}\n\n\t\tpath.push(VALUES);\n\n\t\tcomponentType = replaceWithMappedTypeForPath(componentType);\n\n\t\tCollection<Object> target = newArrayInstance(targetType);\n\n\t\tboolean koma = false;\n\n\t\tmainloop:\n\t\twhile (true) {\n\t\t\tskipWhiteSpaces();\n\n\t\t\tchar c = input[ndx];\n\n\t\t\tif (c == ']') {\n\t\t\t\tif (koma) {\n\t\t\t\t\tsyntaxError(\"Trailing comma\");\n\t\t\t\t}\n\n\t\t\t\tndx++;\n\t\t\t\tpath.pop();\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\tObject value = parseValue(componentType, null, null);\n\n\t\t\ttarget.add(value);\n\n\t\t\tskipWhiteSpaces();\n\n\t\t\tc = input[ndx];\n\n\t\t\tswitch (c) {\n\t\t\t\tcase ']': ndx++; break mainloop;\n\t\t\t\tcase ',': ndx++; koma = true; break;\n\t\t\t\tdefault: syntaxError(\"Invalid char: expected ] or ,\");\n\t\t\t}\n\n\t\t}\n\n\t\tpath.pop();\n\n\t\tif (targetType != null) {\n\t\t\treturn convertType(target, targetType);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t// ---------------------------------------------------------------- object\n\n\t/**\n\t * Parses object, once when open bracket has been consumed.\n\t */\n\tprotected Object parseObjectContent(Class targetType, Class valueKeyType, Class valueType) {\n\t\t// detect special case\n\n\t\tif (targetType == Object.class) {\n\t\t\ttargetType = Map.class;\n\t\t}\n\n\t\t// continue\n\n\t\ttargetType = replaceWithMappedTypeForPath(targetType);\n\n\t\tObject target;\n\t\tboolean isTargetTypeMap = true;\n\t\tboolean isTargetRealTypeMap = true;\n\t\tClassDescriptor targetTypeClassDescriptor = null;\n\t\tTypeData typeData = null;\n\n\t\tif (targetType != null) {\n\t\t\ttargetTypeClassDescriptor = ClassIntrospector.get().lookup(targetType);\n\n\t\t\t// find if the target is really a map\n\t\t\t// because when classMetadataName != null we are forcing\n\t\t\t// map usage locally in this method\n\n\t\t\tisTargetRealTypeMap = targetTypeClassDescriptor.isMap();\n\n\t\t\ttypeData = jsonAnnotationManager.lookupTypeData(targetType);\n\t\t}\n\n\t\tif (isTargetRealTypeMap) {\n\t\t\t// resolve keys only for real maps\n\t\t\tpath.push(KEYS);\n\t\t\tvalueKeyType = replaceWithMappedTypeForPath(valueKeyType);\n\t\t\tpath.pop();\n\t\t}\n\n\t\tif (classMetadataName == null) {\n\t\t\t// create instance of target type, no 'class' information\n\t\t\ttarget = newObjectInstance(targetType);\n\n\t\t\tisTargetTypeMap = isTargetRealTypeMap;\n\t\t} else {\n\t\t\t// all beans will be created first as a map\n\t\t\ttarget = mapSupplier.get();\n\t\t}\n\n\t\tboolean koma = false;\n\n\t\tmainloop:\n\t\twhile (true) {\n\t\t\tskipWhiteSpaces();\n\n\t\t\tchar c = input[ndx];\n\n\t\t\tif (c == '}') {\n\t\t\t\tif (koma) {\n\t\t\t\t\tsyntaxError(\"Trailing comma\");\n\t\t\t\t}\n\n\t\t\t\tndx++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkoma = false;\n\n\t\t\tString key = parseString();\n\t\t\tString keyOriginal = key;\n\n\t\t\tskipWhiteSpaces();\n\n\t\t\tconsume(':');\n\n\t\t\tskipWhiteSpaces();\n\n\t\t\t// read the type of the simple property\n\n\t\t\tPropertyDescriptor pd = null;\n\t\t\tClass propertyType = null;\n\t\t\tClass keyType = null;\n\t\t\tClass componentType = null;\n\n\t\t\t// resolve simple property\n\n\t\t\tif (!isTargetRealTypeMap) {\n\t\t\t\t// replace key with real property value\n\t\t\t\tkey = jsonAnnotationManager.resolveRealName(targetType, key);\n\t\t\t}\n\n\t\t\tif (!isTargetTypeMap) {\n\t\t\t\tpd = targetTypeClassDescriptor.getPropertyDescriptor(key, true);\n\n\t\t\t\tif (pd != null) {\n\t\t\t\t\tpropertyType = pd.getType();\n\t\t\t\t\tkeyType = pd.resolveKeyType(true);\n\t\t\t\t\tcomponentType = pd.resolveComponentType(true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject value;\n\n\t\t\tif (!isTargetTypeMap) {\n\t\t\t\t// *** inject into bean\n\t\t\t\t\tpath.push(key);\n\n\t\t\t\t\tvalue = parseValue(propertyType, keyType, componentType);\n\n\t\t\t\t\tpath.pop();\n\n\t\t\t\tif (typeData.rules.match(keyOriginal, !typeData.strict)) {\n\n\t\t\t\t\tif (pd != null) {\n\t\t\t\t\t\tif (lazy) {\n\t\t\t\t\t\t\t// need to resolve lazy value before injecting objects into it\n\t\t\t\t\t\t\tvalue = resolveLazyValue(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only inject values if target property exist\n\t\t\t\t\t\tinjectValueIntoObject(target, pd, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject keyValue = key;\n\n\t\t\t\tif (valueKeyType != null) {\n\t\t\t\t\tkeyValue = convertType(key, valueKeyType);\n\t\t\t\t}\n\n\t\t\t\t// *** add to map\n\t\t\t\tif (isTargetRealTypeMap) {\n\t\t\t\t\tpath.push(VALUES, key);\n\n\t\t\t\t\tvalueType = replaceWithMappedTypeForPath(valueType);\n\t\t\t\t} else {\n\t\t\t\t\tpath.push(key);\n\t\t\t\t}\n\n\n\t\t\t\tvalue = parseValue(valueType, null, null);\n\n\t\t\t\tpath.pop();\n\n\t\t\t\t((Map) target).put(keyValue, value);\n\t\t\t}\n\n\t\t\tskipWhiteSpaces();\n\n\t\t\tc = input[ndx];\n\n\t\t\tswitch (c) {\n\t\t\t\tcase '}': ndx++; break mainloop;\n\t\t\t\tcase ',': ndx++; koma = true; break;\n\t\t\t\tdefault: syntaxError(\"Invalid char: expected } or ,\");\n\t\t\t}\n\t\t}\n\n\t\t// done\n\n\t\t// convert Map to target type\n\t\tif (classMetadataName != null) {\n\t\t\ttarget = mapToBean.map2bean((Map) target, targetType);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t// ---------------------------------------------------------------- scanning tools\n\n\t/**\n\t * Consumes char at current position. If char is different, throws the exception.\n\t */\n\tprotected void consume(final char c) {\n\t\tif (input[ndx] != c) {\n\t\t\tsyntaxError(\"Invalid char: expected \" + c);\n\t\t}\n\n\t\tndx++;\n\t}\n\n\t/**\n\t * Consumes one of the allowed char at current position.\n\t * If char is different, return <code>0</code>.\n\t * If matched, returns matched char.\n\t */\n\tprotected char consumeOneOf(final char c1, final char c2) {\n\t\tchar c = input[ndx];\n\n\t\tif ((c != c1) && (c != c2)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tndx++;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * Returns <code>true</code> if scanning is at the end.\n\t */\n\tprotected boolean isEOF() {\n\t\treturn ndx >= total;\n\t}\n\n\t/**\n\t * Skips whitespaces. For the simplification, whitespaces are\n\t * considered any characters less or equal to 32 (space).\n\t */\n\tprotected final void skipWhiteSpaces() {\n\t\twhile (true) {\n\t\t\tif (isEOF()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (input[ndx] > 32) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tndx++;\n\t\t}\n    }\n\n\t/**\n\t * Matches char buffer with content on given location.\n\t */\n\tprotected final boolean match(final char[] target) {\n\t\tfor (char c : target) {\n\t\t\tif (input[ndx] != c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tndx++;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t// ---------------------------------------------------------------- error\n\n\t/**\n\t * Throws {@link jodd.json.JsonException} indicating a syntax error.\n\t */\n\tprotected void syntaxError(final String message) {\n\t\tString left = \"...\";\n\t\tString right = \"...\";\n\t\tint offset = 10;\n\n\t\tint from = ndx - offset;\n\t\tif (from < 0) {\n\t\t\tfrom = 0;\n\t\t\tleft = StringPool.EMPTY;\n\t\t}\n\n\t\tint to = ndx + offset;\n\t\tif (to > input.length) {\n\t\t\tto = input.length;\n\t\t\tright = StringPool.EMPTY;\n\t\t}\n\n\t\tfinal CharSequence str = CharArraySequence.of(input, from, to - from);\n\n\t\tthrow new JsonException(\n\t\t\t\t\"Syntax error! \" + message + \"\\n\" +\n\t\t\t\t\"offset: \" + ndx + \" near: \\\"\" + left + str + right + \"\\\"\");\n\t}\n\n}", "// Copyright (c) 2003-present, Jodd Team (http://jodd.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\npackage jodd.json;\n\nimport jodd.introspector.ClassDescriptor;\nimport jodd.introspector.ClassIntrospector;\nimport jodd.introspector.CtorDescriptor;\nimport jodd.introspector.PropertyDescriptor;\nimport jodd.introspector.Setter;\nimport jodd.typeconverter.TypeConverterManager;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\n/**\n * Just a base class of {@link jodd.json.JsonParser} that contains\n * various utilities, to reduce the size of a parser.\n */\npublic abstract class JsonParserBase {\n\n\tprotected static final Supplier<Map> HASMAP_SUPPLIER = LinkedHashMap::new;\n\tprotected static final Supplier<Map> LAZYMAP_SUPPLIER = LazyMap::new;\n\n\tprotected static final Supplier<List> ARRAYLIST_SUPPLIER = ArrayList::new;\n\tprotected static final Supplier<List> LAZYLIST_SUPPLIER = LazyList::new;\n\n\tprotected Supplier<Map> mapSupplier = HASMAP_SUPPLIER;\n\tprotected Supplier<List> listSupplier = ARRAYLIST_SUPPLIER;\n\n\t/**\n\t * Creates new instance of {@link jodd.json.MapToBean}.\n\t */\n\tprotected MapToBean createMapToBean(final String classMetadataName) {\n\t\treturn new MapToBean(this, classMetadataName);\n\t}\n\n\t// ---------------------------------------------------------------- object tools\n\n\t/**\n\t * Creates new type for JSON array objects.\n\t * It returns a collection.\n\t * Later, the collection will be converted into the target type.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected Collection<Object> newArrayInstance(final Class targetType) {\n\t\tif (targetType == null ||\n\t\t\ttargetType == List.class ||\n\t\t\ttargetType == Collection.class ||\n\t\t\ttargetType.isArray()) {\n\n\t\t\treturn listSupplier.get();\n\t\t}\n\n\t\tif (targetType == Set.class) {\n\t\t\treturn new HashSet<>();\n\t\t}\n\n\t\ttry {\n\t\t\treturn (Collection<Object>) targetType.getDeclaredConstructor().newInstance();\n\t\t} catch (Exception e) {\n\t\t\tthrow new JsonException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Creates new object or a <code>HashMap</code> if type is not specified.\n\t */\n\tprotected Object newObjectInstance(final Class targetType) {\n\t\tif (targetType == null ||\n\t\t\ttargetType == Map.class) {\n\n\t\t\treturn mapSupplier.get();\n\t\t}\n\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(targetType);\n\n\t\tCtorDescriptor ctorDescriptor = cd.getDefaultCtorDescriptor(true);\n\t\tif (ctorDescriptor == null) {\n\t\t\tthrow new JsonException(\"Default ctor not found for: \" + targetType.getName());\n\t\t}\n\n\t\ttry {\n//\t\t\treturn ClassUtil.newInstance(targetType);\n\t\t\treturn ctorDescriptor.getConstructor().newInstance();\n\t\t} catch (Exception e) {\n\t\t\tthrow new JsonException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Injects value into the targets property.\n\t */\n\tprotected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) {\n\t\tObject convertedValue = value;\n\n\t\tif (value != null) {\n\t\t\tClass targetClass = pd.getType();\n\n\t\t\tconvertedValue = convertType(value, targetClass);\n\t\t}\n\n\t\ttry {\n\t\t\tSetter setter = pd.getSetter(true);\n\t\t\tif (setter != null) {\n\t\t\t\tsetter.invokeSetter(target, convertedValue);\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow new JsonException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Converts type of the given value.\n\t */\n\tprotected Object convertType(final Object value, final Class targetType) {\n\t\tClass valueClass = value.getClass();\n\n\t\tif (valueClass == targetType) {\n\t\t\treturn value;\n\t\t}\n\n\t\ttry {\n\t\t\treturn TypeConverterManager.get().convertType(value, targetType);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonException(\"Type conversion failed\", ex);\n\t\t}\n\t}\n\n}", "// Copyright (c) 2003-present, Jodd Team (http://jodd.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\npackage jodd.json;\n\nimport jodd.introspector.ClassDescriptor;\nimport jodd.introspector.ClassIntrospector;\nimport jodd.introspector.PropertyDescriptor;\nimport jodd.introspector.Setter;\nimport jodd.typeconverter.TypeConverterManager;\nimport jodd.util.ClassLoaderUtil;\nimport jodd.util.ClassUtil;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Map to bean converter.\n * Used when parsing with class metadata enabled.\n */\npublic class MapToBean {\n\n\tprotected boolean declared = true;\n\tprotected final JsonParserBase jsonParser;\n\tprotected final String classMetadataName;\n\n\tpublic MapToBean(final JsonParserBase jsonParser, final String classMetadataName) {\n\t\tthis.jsonParser = jsonParser;\n\t\tthis.classMetadataName = classMetadataName;\n\t}\n\n\t/**\n\t * Converts map to target type.\n\t */\n\tpublic Object map2bean(final Map map, Class targetType) {\n\t\tObject target = null;\n\n\t\t// create targets type\n\t\tString className = (String) map.get(classMetadataName);\n\n\t\tif (className == null) {\n\t\t\tif (targetType == null) {\n\t\t\t\t// nothing to do, no information about target type found\n\t\t\t\ttarget = map;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\ttargetType = ClassLoaderUtil.loadClass(className);\n\t\t\t} catch (ClassNotFoundException cnfex) {\n\t\t\t\tthrow new JsonException(cnfex);\n\t\t\t}\n\t\t}\n\n\t\tif (target == null) {\n\t\t\ttarget = jsonParser.newObjectInstance(targetType);\n\t\t}\n\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());\n\n\t\tboolean targetIsMap = target instanceof Map;\n\n\t\tfor (Object key : map.keySet()) {\n\t\t\tString keyName = key.toString();\n\n\t\t\tif (classMetadataName != null) {\n\t\t\t\tif (keyName.equals(classMetadataName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared);\n\n\t\t\tif (!targetIsMap && pd == null) {\n\t\t\t\t// target property does not exist, continue\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// value is one of JSON basic types, like Number, Map, List...\n\t\t\tObject value = map.get(key);\n\n\t\t\tClass propertyType = pd == null ? null : pd.getType();\n\t\t\tClass componentType = pd == null ? null : pd.resolveComponentType(true);\n\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof List) {\n\t\t\t\t\tif (componentType != null && componentType != String.class) {\n\t\t\t\t\t\tvalue = generifyList((List) value, componentType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (value instanceof Map) {\n\t\t\t\t\t// if the value we want to inject is a Map...\n\t\t\t\t\tif (!ClassUtil.isTypeOf(propertyType, Map.class)) {\n\t\t\t\t\t\t// ... and if target is NOT a map\n\t\t\t\t\t\tvalue = map2bean((Map) value, propertyType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// target is also a Map, but we might need to generify it\n\t\t\t\t\t\tClass keyType = pd == null ? null : pd.resolveKeyType(true);\n\n\t\t\t\t\t\tif (keyType != String.class || componentType != String.class) {\n\t\t\t\t\t\t\t// generify\n\t\t\t\t\t\t\tvalue = generifyMap((Map) value, keyType, componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (targetIsMap) {\n\t\t\t\t((Map)target).put(keyName, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tsetValue(target, pd, value);\n\t\t\t\t} catch (Exception ignore) {\n\t\t\t\t\tignore.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Converts type of all list elements to match the component type.\n\t */\n\tprivate Object generifyList(final List list, final Class componentType) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tObject element = list.get(i);\n\n\t\t\tif (element != null) {\n\t\t\t\tif (element instanceof Map) {\n\t\t\t\t\tObject bean = map2bean((Map) element, componentType);\n\t\t\t\t\tlist.set(i, bean);\n\t\t\t\t} else {\n\t\t\t\t\tObject value = convert(element, componentType);\n\t\t\t\t\tlist.set(i, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t/**\n\t * Sets the property value.\n\t */\n\tprivate void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException {\n\t\tClass propertyType;\n\n\t\tSetter setter = pd.getSetter(true);\n\t\tif (setter != null) {\n\t\t\tif (value != null) {\n\t\t\t\tpropertyType = setter.getSetterRawType();\n\t\t\t\tvalue = jsonParser.convertType(value, propertyType);\n\t\t\t}\n\t\t\tsetter.invokeSetter(target, value);\n\t\t}\n\t}\n\n\t/**\n\t * Change map elements to match key and value types.\n\t */\n\tprotected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) {\n\n\t\tif (keyType == String.class) {\n\t\t\t// only value type is changed, we can make value replacements\n\t\t\tfor (Map.Entry<Object, Object> entry : map.entrySet()) {\n\t\t\t\tObject value = entry.getValue();\n\t\t\t\tObject newValue = convert(value, valueType);\n\n\t\t\t\tif (value != newValue) {\n\t\t\t\t\tentry.setValue(newValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (Map<K, V>) map;\n\t\t}\n\n\t\t// key is changed too, we need a new map\n\t\tMap<K, V> newMap = new HashMap<>(map.size());\n\n\t\tfor (Map.Entry<Object, Object> entry : map.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tObject newKey = convert(key, keyType);\n\n\t\t\tObject value = entry.getValue();\n\t\t\tObject newValue = convert(value, valueType);\n\n\t\t\tnewMap.put((K)newKey, (V)newValue);\n\t\t}\n\n\t\treturn newMap;\n\t}\n\n\tprotected Object convert(final Object value, final Class targetType) {\n\t\tClass valueClass = value.getClass();\n\n\t\tif (valueClass == targetType) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (value instanceof Map) {\n\t\t\tif (targetType == Map.class) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn map2bean((Map) value, targetType);\n\t\t}\n\n\t\ttry {\n\t\t\treturn TypeConverterManager.get().convertType(value, targetType);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonException(\"Type conversion failed\", ex);\n\t\t}\n\t}\n\n}", "// Copyright (c) 2003-present, Jodd Team (http://jodd.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\npackage jodd.json;\n\nimport jodd.json.fixtures.JsonParsers;\nimport jodd.json.fixtures.mock.Employee;\nimport jodd.json.fixtures.mock.Group;\nimport jodd.json.fixtures.mock.Network;\nimport jodd.json.fixtures.mock.Pair;\nimport jodd.json.fixtures.mock.Person;\nimport jodd.json.fixtures.mock.Phone;\nimport jodd.json.fixtures.mock.Spiderman;\nimport jodd.json.fixtures.mock.superhero.Hero;\nimport jodd.json.fixtures.mock.superhero.SecretIdentity;\nimport jodd.json.fixtures.mock.superhero.SecretLair;\nimport jodd.json.fixtures.mock.superhero.SuperPower;\nimport jodd.json.fixtures.mock.superhero.Villian;\nimport jodd.json.fixtures.mock.superhero.XRayVision;\nimport jodd.json.fixtures.model.Account;\nimport jodd.json.impl.DateJsonSerializer;\nimport jodd.util.StringUtil;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.awt.geom.Point2D;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nclass JSONDeserializerTest {\n\n\tprivate static final double DELTA = 0.000000001;\n\n\tprivate DataCreator creator;\n\n\t@BeforeEach\n\tvoid setUp() {\n\t\tcreator = new DataCreator();\n\t}\n\n\t@AfterEach\n\tvoid tearDown() {\n\t\tJsonParser.Defaults.classMetadataName = null;\n\t\tJsonSerializer.Defaults.classMetadataName = null;\n\t}\n\n\t@Test\n\tvoid testDeserializeNoIncludes() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPerson jodder = creator.createJodder();\n\t\t\tString json = new JsonSerializer().serialize(jodder);\n\t\t\tPerson jsonJodder = jsonParser.parse(json, Person.class);\n\n\t\t\tassertNotNull(jsonJodder);\n\n\t\t\tassertEquals(jodder.getLastname(), jsonJodder.getLastname());\n\t\t\tassertEquals(jodder.getFirstname(), jsonJodder.getFirstname());\n\t\t\tassertEquals(jodder.getBirthdate(), jsonJodder.getBirthdate());\n\n\t\t\tassertEquals(jodder.getHome().getState(), jsonJodder.getHome().getState());\n\t\t\tassertEquals(jodder.getHome().getStreet(), jsonJodder.getHome().getStreet());\n\t\t\tassertEquals(jodder.getHome().getCity(), jsonJodder.getHome().getCity());\n\n\t\t\tassertEquals(jodder.getWork().getCity(), jsonJodder.getWork().getCity());\n\n\t\t\tassertEquals(jsonJodder, jsonJodder.getWork().getPerson());\n\n\t\t\tassertEquals(0, jsonJodder.getHobbies().size());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeWithPath() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tMap map = new HashMap();\n\t\t\tmap.put(\"person\", igor);\n\n\t\t\tString json = new JsonSerializer().serialize(map);\n\n\t\t\tmap = jsonParser.map(\"values\", Person.class).parse(json);\n\t\t\tPerson jsonIgor = (Person) map.get(\"person\");\n\n\t\t\tassertNotNull(jsonIgor);\n\n\t\t\tassertEquals(igor.getLastname(), jsonIgor.getLastname());\n\t\t\tassertEquals(igor.getFirstname(), jsonIgor.getFirstname());\n\t\t\tassertEquals(igor.getBirthdate(), jsonIgor.getBirthdate());\n\n\t\t\tassertEquals(igor.getHome().getState(), jsonIgor.getHome().getState());\n\t\t\tassertEquals(igor.getHome().getStreet(), jsonIgor.getHome().getStreet());\n\t\t\tassertEquals(igor.getHome().getCity(), jsonIgor.getHome().getCity());\n\n\t\t\tassertEquals(igor.getWork().getCity(), jsonIgor.getWork().getCity());\n\n\t\t\tassertEquals(jsonIgor, jsonIgor.getWork().getPerson());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeWithIncludes() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tString json = new JsonSerializer().include(\"phones\", \"hobbies\").serialize(igor);\n\t\t\tPerson jsonIgor = jsonParser.parse(json, Person.class);\n\n\t\t\tassertEquals(2, jsonIgor.getPhones().size());\n\t\t\tassertEquals(0, jsonIgor.getHobbies().size());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testSubClassDeserialize() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tEmployee dilbert = creator.createDilbert();\n\n\t\t\tString json = new JsonSerializer().include(\"phones\", \"hobbies\").serialize(dilbert);\n\t\t\tPerson jsonDilbert = jsonParser.parse(json, Employee.class);\n\n\t\t\tassertNotNull(jsonDilbert);\n\t\t\tassertTrue(jsonDilbert instanceof Employee);\n\t\t\tassertEquals(dilbert.getCompany(), ((Employee) jsonDilbert).getCompany());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeInterfaces() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer().include(\"powers\").setClassMetadataName(\"class\").serialize(superman);\n\t\t\tHero jsonSuperMan = jsonParser.setClassMetadataName(\"class\").parse(json, Hero.class);\n\n\t\t\tassertNotNull(jsonSuperMan);\n\t\t\tassertEquals(4, jsonSuperMan.getPowers().size());\n\t\t\tassertHeroHasSuperPowers(jsonSuperMan);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeInterfaces2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer().include(\"powers\").withClassMetadata(true).serialize(superman);\n\t\t\tHero jsonSuperMan = jsonParser.withClassMetadata(true).parse(json, Hero.class);\n\n\t\t\tassertNotNull(jsonSuperMan);\n\t\t\tassertEquals(4, jsonSuperMan.getPowers().size());\n\t\t\tassertHeroHasSuperPowers(jsonSuperMan);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testNoClassHints() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer().exclude(\"*.class\").serialize(superman);\n\n\t\t\tHero jsonSuperMan = jsonParser\n\t\t\t\t.map(Hero.class)\n\t\t\t\t.map(\"lair\", SecretLair.class)\n\t\t\t\t.map(\"secretIdentity\", SecretIdentity.class)\n\t\t\t\t.parse(json);\n\n\t\t\tassertNotNull(jsonSuperMan);\n\t\t\tassertEquals(\"Super Man\", jsonSuperMan.getName());\n\t\t\tassertNotNull(jsonSuperMan.getIdentity());\n\t\t\tassertEquals(\"Clark Kent\", jsonSuperMan.getIdentity().getName());\n\t\t\tassertNotNull(jsonSuperMan.getLair());\n\t\t\tassertEquals(\"Fortress of Solitude\", jsonSuperMan.getLair().getName());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testNoHintsButClassesForCollection() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer()\n\t\t\t\t.exclude(\"*.class\")\n\t\t\t\t.include(\"powers.class\")\n\t\t\t\t.serialize(superman);\n\t\t\tHero jsonSuperMan = jsonParser.parse(json, Hero.class);\n\t\t\tassertHeroHasSuperPowers(jsonSuperMan);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testNoClassHintsForCollections() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer()\n\t\t\t\t.include(\"powers\")        // redudant\n\t\t\t\t.include(\"powers.class\")\n\t\t\t\t.withSerializer(\"powers.class\", new SimpleClassnameTransformer())\n\t\t\t\t.exclude(\"*.class\")\n\t\t\t\t.serialize(superman);\n\n\t\t\tint count = StringUtil.count(json, \"***\");\n\t\t\tassertEquals(4, count);\n\n\t\t\tjson = StringUtil.remove(json, \"***\");\n\n\t\t\tHero jsonSuperMan = jsonParser\n\t\t\t\t.map(\"lair\", SecretLair.class)\n\t\t\t\t.map(\"secretIdentity\", SecretIdentity.class)\n\t\t\t\t.parse(json, Hero.class);\n\n\t\t\tassertEquals(\"Fortress of Solitude\", jsonSuperMan.getLair().getName());\n\t\t\tassertHeroHasSuperPowers(jsonSuperMan);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testListSerialization() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tPerson modesty = creator.createModesty();\n\t\tPerson igor = creator.createJodder();\n\t\tPerson pedro = creator.createPedro();\n\t\tList<Person> list = new ArrayList<>(3);\n\t\tlist.add(modesty);\n\t\tlist.add(igor);\n\t\tlist.add(pedro);\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = new JsonSerializer().serialize(list);\n\n\t\t\tList<Person> people = jsonParser.parse(json);\n\t\t\tassertTrue(people instanceof List);\n\n\t\t\tjson = new JsonSerializer().exclude(\"*.class\").serialize(list);\n\t\t\tpeople = jsonParser.map(\"values\", Person.class).parse(json);\n\n\t\t\tassertEquals(3, people.size());\n\t\t\tassertEquals(Person.class, people.get(0).getClass());\n\t\t});\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = new JsonSerializer().exclude(\"*.class\").serialize(list);\n\n\t\t\tList<Map> peopleMap = jsonParser.parse(json);\n\n\t\t\tassertEquals(3, peopleMap.size());\n\t\t\tassertTrue(peopleMap.get(0) instanceof Map);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testGenericTypeDeserialization() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tPair<Hero, Villian> archenemies = new Pair<>(creator.createSuperman(), creator.createLexLuthor());\n\n\t\t\tString json = new JsonSerializer()\n\t\t\t\t.exclude(\"*.class\")\n\t\t\t\t.serialize(archenemies);\n\n\t\t\tPair<Hero, Villian> deserialArchEnemies = jsonParser\n\t\t\t\t.map(\"first\", Hero.class)\n\t\t\t\t.map(\"second\", Villian.class)\n\t\t\t\t.parse(json, Pair.class);\n\n\t\t\tassertEquals(archenemies.getFirst().getClass(), deserialArchEnemies.getFirst().getClass());\n\t\t\tassertEquals(archenemies.getSecond().getClass(), deserialArchEnemies.getSecond().getClass());\n\n\t\t\tassertEquals(archenemies.getFirst().getIdentity(), deserialArchEnemies.getFirst().getIdentity());\n\t\t\tassertEquals(archenemies.getFirst().getLair(), deserialArchEnemies.getFirst().getLair());\n\t\t\tassertEquals(archenemies.getFirst().getName(), deserialArchEnemies.getFirst().getName());\n\n\t\t\tassertEquals(archenemies.getSecond().getName(), deserialArchEnemies.getSecond().getName());\n\t\t\tassertEquals(archenemies.getSecond().getLair(), deserialArchEnemies.getSecond().getLair());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testGenericTypeDeserialization2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPair<Hero, Villian> archenemies = new Pair<>(creator.createSuperman(), creator.createLexLuthor());\n\n\t\t\tString json = new JsonSerializer()\n\t\t\t\t.serialize(archenemies);\n\n\t\t\tPair<Hero, Villian> deserialArchEnemies = jsonParser\n\t\t\t\t.map(\"first\", Hero.class)\n\t\t\t\t.map(\"second\", Villian.class)\n\t\t\t\t.parse(json, Pair.class);\n\n\t\t\tassertEquals(archenemies.getFirst().getClass(), deserialArchEnemies.getFirst().getClass());\n\t\t\tassertEquals(archenemies.getSecond().getClass(), deserialArchEnemies.getSecond().getClass());\n\n\t\t\tassertEquals(archenemies.getFirst().getIdentity(), deserialArchEnemies.getFirst().getIdentity());\n\t\t\tassertEquals(archenemies.getFirst().getLair(), deserialArchEnemies.getFirst().getLair());\n\t\t\tassertEquals(archenemies.getFirst().getName(), deserialArchEnemies.getFirst().getName());\n\n\t\t\tassertEquals(archenemies.getSecond().getName(), deserialArchEnemies.getSecond().getName());\n\t\t\tassertEquals(archenemies.getSecond().getLair(), deserialArchEnemies.getSecond().getLair());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testGeneralMapDeserialization() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tString json = new JsonSerializer().exclude(\"*.class\").serialize(creator.createJodder());\n\t\t\tMap<String, Object> deserialized = jsonParser.parse(json);\n\n\t\t\tassertEquals(\"Igor\", deserialized.get(\"firstname\"));\n\t\t\tassertEquals(\"Spasic\", deserialized.get(\"lastname\"));\n\t\t\tassertTrue(Map.class.isAssignableFrom(deserialized.get(\"work\").getClass()));\n\t\t\tassertTrue(Map.class.isAssignableFrom(deserialized.get(\"home\").getClass()));\n\t\t});\n\t}\n\n\t@Test\n\tvoid testGeneralMapDeserialization2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = new JsonSerializer().serialize(creator.createJodder());\n\t\t\tMap<String, Object> deserialized = jsonParser.parse(json);\n\n\t\t\tassertEquals(\"Igor\", deserialized.get(\"firstname\"));\n\t\t\tassertEquals(\"Spasic\", deserialized.get(\"lastname\"));\n\t\t\tassertTrue(Map.class.isAssignableFrom(deserialized.get(\"work\").getClass()));\n\t\t\tassertTrue(Map.class.isAssignableFrom(deserialized.get(\"home\").getClass()));\n\t\t});\n\t}\n\n\t@Test\n\tvoid testListDeserializationNoClass() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tPerson modesty = creator.createModesty();\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tPerson pedro = creator.createPedro();\n\t\t\tList<Person> list = new ArrayList<>(3);\n\t\t\tlist.add(modesty);\n\t\t\tlist.add(igor);\n\t\t\tlist.add(pedro);\n\n\t\t\tString json = new JsonSerializer().exclude(\"*.class\").serialize(list);\n\t\t\tList<Person> people = jsonParser.map(\"values\", Person.class).parse(json);\n\t\t\tassertEquals(3, list.size());\n\t\t\tassertEquals(modesty.getFirstname(), list.get(0).getFirstname());\n\t\t\tassertEquals(igor.getFirstname(), list.get(1).getFirstname());\n\t\t\tassertEquals(pedro.getFirstname(), list.get(2).getFirstname());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testListDeserializationNoClass2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPerson modesty = creator.createModesty();\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tPerson pedro = creator.createPedro();\n\t\t\tList<Person> list = new ArrayList<>(3);\n\t\t\tlist.add(modesty);\n\t\t\tlist.add(igor);\n\t\t\tlist.add(pedro);\n\n\t\t\tString json = new JsonSerializer().serialize(list);\n\t\t\tList<Person> people = jsonParser.map(\"values\", Person.class).parse(json);\n\t\t\tassertEquals(3, list.size());\n\t\t\tassertEquals(modesty.getFirstname(), list.get(0).getFirstname());\n\t\t\tassertEquals(igor.getFirstname(), list.get(1).getFirstname());\n\t\t\tassertEquals(pedro.getFirstname(), list.get(2).getFirstname());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDateTransforming() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tfinal SimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd\");\n\t\t\tPerson foo = new Person(\"Foo\", \"Bar\", new Date(), null, null);\n\t\t\ttry {\n\t\t\t\tfoo.setBirthdate(df.parse(\"2009/01/02\"));\n\t\t\t} catch (ParseException pe) {\n\t\t\t\tfail(pe);\n\t\t\t}\n\n\n\t\t\tString json = new JsonSerializer().withSerializer(\"birthdate\", new DateJsonSerializer() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean serialize(JsonContext jsonContext, Date date) {\n\t\t\t\t\tjsonContext.writeString(df.format(date));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}).serialize(foo);\n\n\t\t\tPerson newUser = jsonParser\n\t\t\t\t.withValueConverter(\"birthdate\", (ValueConverter<String, Date>) data -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn df.parse(data);\n\t\t\t\t\t} catch (ParseException pe) {\n\t\t\t\t\t\tthrow new JsonException(pe);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.parse(json, Person.class);\n\n\t\t\tassertEquals(foo.getBirthdate(), newUser.getBirthdate());\n\t\t\tassertEquals(\"2009/01/02\", df.format(newUser.getBirthdate()));\n\t\t});\n\t}\n\n\t@Test\n\tvoid testMapWithEmbeddedObject() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tMap<String, Network> networks = jsonParser\n\t\t\t\t.setClassMetadataName(\"class\")\n\t\t\t\t.parse(\"{\\\"1\\\": {\\\"class\\\":\\\"\" + Network.class.getName() + \"\\\", \\\"name\\\": \\\"Jodd\\\"} }\");\n\n\t\t\tassertNotNull(networks);\n\t\t\tassertEquals(1, networks.size());\n\t\t\tassertTrue(networks.containsKey(\"1\"));\n\t\t\tassertNotNull(networks.get(\"1\"));\n\t\t\tassertEquals(Network.class, networks.get(\"1\").getClass());\n\t\t\tassertEquals(\"Jodd\", networks.get(\"1\").getName());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testMapWithEmbeddedObject2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tMap<String, Pair<Phone, Network>> complex = jsonParser\n\t\t\t\t.map(\"values\", Pair.class)\n\t\t\t\t.map(\"values.first\", Phone.class)\n\t\t\t\t.map(\"values.second\", Network.class)\n\t\t\t\t.parse(\"{\\\"1\\\": { \\\"first\\\": { \\\"areaCode\\\": \\\"404\\\" }, \\\"second\\\": {\\\"name\\\": \\\"Jodd\\\"} } }\");\n\t\t\tassertNotNull(complex);\n\t\t\tassertEquals(1, complex.size());\n\t\t\tassertTrue(complex.containsKey(\"1\"));\n\t\t\tassertNotNull(complex.get(\"1\"));\n\t\t\tassertEquals(Pair.class, complex.get(\"1\").getClass());\n\t\t\tassertEquals(Phone.class, complex.get(\"1\").getFirst().getClass());\n\t\t\tassertEquals(Network.class, complex.get(\"1\").getSecond().getClass());\n\t\t\tassertEquals(\"404\", complex.get(\"1\").getFirst().getAreaCode());\n\t\t\tassertEquals(\"Jodd\", complex.get(\"1\").getSecond().getName());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testListWithEmbeddedObject() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tList<Network> networks = jsonParser\n\t\t\t\t.setClassMetadataName(\"class\")\n\t\t\t\t.parse(\"[\" +\n\t\t\t\t\t\"\t{\\\"class\\\":\\\"\" + Network.class.getName() + \"\\\", \\\"name\\\": \\\"Jodd\\\"},\" +\n\t\t\t\t\t\"\t{\\\"class\\\":\\\"\" + Network.class.getName() + \"\\\", \\\"name\\\": \\\"Mojo\\\"}\" +\n\t\t\t\t\t\"]\");\n\n\t\t\tassertNotNull(networks);\n\t\t\tassertEquals(2, networks.size());\n\t\t\tNetwork network = networks.get(0);\n\t\t\tassertEquals(\"Jodd\", network.getName());\n\t\t\tnetwork = networks.get(1);\n\t\t\tassertEquals(\"Mojo\", network.getName());\n\t\t});\n\t}\n\n\n\t@Test\n\tvoid testArrayType() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tPerson modesty = creator.createModesty();\n\n\t\t\tGroup group = new Group(\"brothers\", igor, modesty);\n\t\t\tString json = new JsonSerializer().include(\"people\").exclude(\"*.class\").serialize(group);\n\t\t\tGroup bro = jsonParser.map(Group.class).parse(json);\n\n\t\t\tassertNotNull(bro);\n\t\t\tassertEquals(\"brothers\", bro.getGroupName());\n\t\t\tassertEquals(2, bro.getPeople().length);\n\t\t\tassertEquals(\"Igor\", bro.getPeople()[0].getFirstname());\n\t\t\tassertEquals(\"Modesty\", bro.getPeople()[1].getFirstname());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testEmptyArray() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tGroup group = jsonParser.parse(\"{\\\"people\\\": [], \\\"groupName\\\": \\\"Nobody\\\" }\", Group.class);\n\t\t\tassertEquals(\"Nobody\", group.getGroupName());\n\t\t\tassertEquals(0, group.getPeople().length);\n\t\t});\n\t}\n\n\n\t@Test\n\tvoid testNullDeserialization() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString input = \"{\\\"property\\\": null, \\\"property2\\\":5, \\\"property3\\\":\\\"abc\\\"}\";\n\n\t\t\tJsonParser deserializer = jsonParser;\n\t\t\tdeserializer.map(null, HashMap.class);\n\t\t\tMap<String, Object> result = deserializer.parse(input);\n\n\t\t\tassertNotNull(result);\n\t\t\t// fails on this line, because the first property is not deserialized\n\t\t\tassertEquals(3, result.size());\n\t\t\tassertTrue(result.containsKey(\"property\"));\n\t\t\tassertNull(result.get(\"property\"), \"the value should be null\");\n\t\t});\n\t}\n\n\t@Test\n\tvoid testPrimitives() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tList<Date> dates = new ArrayList<>();\n\t\t\tdates.add(new Date());\n\t\t\tdates.add(new Date(1970, 1, 12));\n\t\t\tdates.add(new Date(1986, 3, 21));\n\n\t\t\tString json = new JsonSerializer().serialize(dates);\n\t\t\tList<Date> jsonDates = jsonParser\n\t\t\t\t.map(null, ArrayList.class)\n\t\t\t\t.map(\"values\", Date.class)\n\t\t\t\t.parse(json);\n\n\t\t\tassertEquals(jsonDates.size(), dates.size());\n\t\t\tassertEquals(Date.class, jsonDates.get(0).getClass());\n\t\t});\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tList<? extends Number> numbers = Arrays.asList(1, 0.5, 100.4f, (short) 5);\n\t\t\tString json = new JsonSerializer().serialize(numbers);\n\t\t\tList<Number> jsonNumbers = jsonParser.parse(json);\n\n\t\t\tassertEquals(numbers.size(), jsonNumbers.size());\n\t\t\tfor (int i = 0; i < numbers.size(); i++) {\n\t\t\t\tassertEquals(numbers.get(i).floatValue(), jsonNumbers.get(i).floatValue(), DELTA);\n\t\t\t}\n\n\t\t\tassertEquals(numbers.size(), jsonNumbers.size());\n\t\t});\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tList<Boolean> bools = Arrays.asList(true, false, true, false, false);\n\t\t\tString json = new JsonSerializer().serialize(bools);\n\t\t\tList<Boolean> jsonBools = jsonParser.parse(json);\n\n\t\t\tassertEquals(bools.size(), jsonBools.size());\n\t\t\tfor (int i = 0; i < bools.size(); i++) {\n\t\t\t\tassertEquals(bools.get(i), jsonBools.get(i));\n\t\t\t}\n\t\t});\n\t}\n\n\t@Test\n\tvoid testArray() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPerson[] p = new Person[3];\n\t\t\tp[0] = creator.createJodder();\n\t\t\tp[1] = creator.createDilbert();\n\t\t\tp[2] = creator.createModesty();\n\n\t\t\tString json = new JsonSerializer().serialize(p);\n\n\t\t\tPerson[] jsonP = jsonParser.parse(json, Person[].class);\n\n\t\t\tassertEquals(3, jsonP.length);\n\t\t\tassertEquals(\"Igor\", jsonP[0].getFirstname());\n\t\t\tassertEquals(\"Dilbert\", jsonP[1].getFirstname());\n\t\t\tassertEquals(\"Modesty\", jsonP[2].getFirstname());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testArray_boolean() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tfinal boolean[] input = new boolean[]{true, false, true};\n\t\t\tfinal boolean[] expected_bools = input;\n\t\t\tfinal String expected_json = \"[true,false,true]\";\n\n\t\t\tfinal String actual_json = new JsonSerializer().serialize(input);\n\t\t\tfinal boolean[] actual_bools = jsonParser.parse(actual_json, boolean[].class);\n\n\t\t\t// asserts\n\t\t\tassertNotNull(actual_json);\n\t\t\tassertNotNull(actual_bools);\n\t\t\tassertEquals(expected_json, actual_json);\n\t\t\tassertArrayEquals(expected_bools, actual_bools);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializationIntoPublicFields() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tSpiderman spiderman = new Spiderman();\n\t\t\tspiderman.spideySense = false;\n\t\t\tspiderman.superpower = \"Creates Many Webs and Super Tough\";\n\n\t\t\tString json = new JsonSerializer().serialize(spiderman);\n\t\t\tSpiderman jsonSpiderman = jsonParser.parse(json);\n\n\t\t\tassertEquals(spiderman.spideySense, jsonSpiderman.spideySense);\n\t\t\tassertEquals(spiderman.superpower, jsonSpiderman.superpower);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testAutoTypeConvertToNumerical() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tAccount account = jsonParser\n\t\t\t\t.parse(\"{\\\"id\\\": \\\"5\\\", \\\"accountNumber\\\": \\\"1234567-123\\\"}\", Account.class);\n\t\t\tassertEquals(new Integer(5), account.getId());\n\n\t\t\tXRayVision xray = jsonParser.parse(\"{ \\\"power\\\": \\\"2.3\\\" }\", XRayVision.class);\n\t\t\tassertEquals(2.3f, xray.getPower(), DELTA);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeURL() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = \"{\\n\" +\n\t\t\t\t\"  \\\"oslc_cm:next\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/results\\\\/3\\\",\\n\" +\n\t\t\t\t\"  \\\"oslc_cm:previous\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/results\\\\/1\\\", \\n\" +\n\t\t\t\t\"  \\\"oslc_cm:totalCount\\\" : 27,\\n\" +\n\t\t\t\t\"  \\\"oslc_cm:results\\\": [\\n\" +\n\t\t\t\t\"    {\\n\" +\n\t\t\t\t\"      \\\"rdf:resource\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/records\\\\/1234\\\"\\n\" +\n\t\t\t\t\"    },\\n\" +\n\t\t\t\t\"    {\\n\" +\n\t\t\t\t\"      \\\"rdf:resource\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/records\\\\/1235\\\"\\n\" +\n\t\t\t\t\"    },\\n\" +\n\t\t\t\t\"    {\\n\" +\n\t\t\t\t\"      \\\"rdf:resource\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/records\\\\/1236\\\"\\n\" +\n\t\t\t\t\"    }   \\n\" +\n\t\t\t\t\"  ]\\n\" +\n\t\t\t\t\"}\";\n\t\t\tMap<String, Object> page2 = jsonParser.parse(json);\n\t\t\tassertEquals(\"http://localhost:9080/results/3\", page2.get(\"oslc_cm:next\"));\n\t\t\tassertEquals(3, ((List) page2.get(\"oslc_cm:results\")).size());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testPoint() {\n\t\tJsonParser.Defaults.classMetadataName = \"__class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"__class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = new JsonSerializer().serialize(new Point2D.Float(1.0f, 2.0f));\n\t\t\tPoint2D.Float point = jsonParser.parse(json);\n\t\t\tassertEquals(1.0f, point.x, DELTA);\n\t\t\tassertEquals(2.0f, point.y, DELTA);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testUnixEpoch() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tCalendar cal = Calendar.getInstance();\n\t\t\tcal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\n\t\t\tcal.set(Calendar.YEAR, 1970);\n\t\t\tcal.set(Calendar.MONTH, 0);\n\t\t\tcal.set(Calendar.DAY_OF_MONTH, 1);\n\t\t\tcal.set(Calendar.AM_PM, Calendar.AM);\n\t\t\tcal.set(Calendar.HOUR, 0);\n\t\t\tcal.set(Calendar.MINUTE, 0);\n\t\t\tcal.set(Calendar.SECOND, 0);\n\t\t\tcal.set(Calendar.MILLISECOND, 0);\n\n\t\t\tPerson hank = new Person(\"Hank\", \"Paulsen\", cal.getTime(), null, null);\n\n\t\t\tString json = new JsonSerializer().serialize(hank);\n\t\t\tPerson deHank = jsonParser.parse(json, Person.class);\n\n\t\t\tassertEquals(hank.getFirstname(), deHank.getFirstname());\n\t\t\tassertEquals(hank.getLastname(), deHank.getLastname());\n\t\t\tassertEquals(hank.getBirthdate(), deHank.getBirthdate());\n\t\t});\n\t}\n\n\tpublic static class SimpleClassnameTransformer implements TypeJsonSerializer {\n\t\t@Override\n\t\tpublic boolean serialize(JsonContext jsonContext, Object value) {\n\t\t\tString name = value.toString() + \"***\";\n\t\t\tjsonContext.writeString(name);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate void assertHeroHasSuperPowers(Hero hero) {\n\t\tfor (int i = 0; i < hero.getPowers().size(); i++) {\n\t\t\tassertTrue(hero.getPowers().get(i) instanceof SuperPower);\n\t\t}\n\t}\n\n}\n"], "fixing_code": ["# Jodd Changelog\n\nAll notable changes to Jodd project are documented here.\n\n## [n/a](https://github.com/oblac/jodd/compare/v5.0.3...master)\n\n(work in progress :)\n\n### Bug fixes\n\n+ **core** - fixed special cases in `NaturalOrderComparator`, making rules a bit more strict.  \n+ **mail** - fixed unused `debug` and `timeout`.\n+ **mail** - `RFC2822AddressParser` methods `parseToXxx()` now returns `null` for invalid emails.\n+ **http** - secure connection was sending `CONNECT` string twice.\n\n### Breaking changes\n\n+ **mail** - `debug` and `timeout` are now applied before creating the mail server.\n+ **http** - default security has been set to `TLSv1.1`.\n\n### New Features\n\n+ **joy** - added excluded jars for faster scanning.\n+ **mail** - added custom properties.\n+ **json** - added `onValue` callback for JSON serializer.\n+ **json** - added `excludeEmpty` flag for JSON serializer.\n+ **json** - added `allowClass` for whitelisting class names.\n+ **petite** - allow injection in the private fields of super types.\n\n\n\n## [v5.0.3](https://github.com/oblac/jodd/compare/v5.0.2...v5.0.3)\n\n### New Features\n\n+ **dboom** - added detection of the quote names in annotations.\n+ **dboom** - Added flags to column and table naming strategies for quote chars.\n\n\n\n## [v5.0.2](https://github.com/oblac/jodd/compare/v5.0.1...v5.0.2)\n\nOne minor fix and one important change for the bootstrap usages.\n\n### New Features\n\n+ **joy** - added static method for registering joy servlet context listener.\n\n### Bug Fixes\n\n+ **joy** - better output of the Joy configuration that does not cut of the values.  \n\n\n\n## [v5.0.1](https://github.com/oblac/jodd/compare/v5.0.0...v5.0.1)\n\nMinor fixes and improvements.\n\n### New Features\n\n+ **core*** - added the `Maybe.or(T)` method.\n+ **mail** - added `receive()` and fluent builder.\n+ **cli*** - parse values bundled with options (e.g. `--name=value`)\n\n### Bug Fixes\n\n+ **cli** - fixed the behaviour of parameters\n\n\n\n## [v5](https://github.com/oblac/jodd/compare/v4.3.2...v5.0.0)\n\nWelcome to Jodd 5.\n\nVersion 5 contains a great number of new features, changes, bug fixes and performance improvements. It's all new Jodd: slick as before, just better. \n\nHigh-five!\n\n## Previous releases\n\n[v4.x](CHANGELOG_v4.md)\n[v3.x](CHANGELOG_v3.md)\n", "// Copyright (c) 2003-present, Jodd Team (http://jodd.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\npackage jodd.json;\n\nimport jodd.introspector.ClassDescriptor;\nimport jodd.introspector.ClassIntrospector;\nimport jodd.introspector.PropertyDescriptor;\nimport jodd.json.meta.JsonAnnotationManager;\nimport jodd.json.meta.TypeData;\nimport jodd.util.CharArraySequence;\nimport jodd.util.CharUtil;\nimport jodd.util.StringPool;\nimport jodd.util.UnsafeUtil;\n\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\n/**\n * Simple, developer-friendly JSON parser. It focuses on easy usage\n * and type mappings. Uses Jodd's type converters, so it is natural\n * companion for Jodd projects.\n * <p>\n * This JSON parser also works in {@link #lazy(boolean)} mode. This\n * mode is for top performance usage: parsing is done very, very lazy.\n * While you can use all the mappings and other tools, for best performance\n * the lazy mode should be used only with maps and lists (no special mappings).\n * Also, the performance has it's price: more memory consumption, because the\n * original input is hold until the result is in use.\n * <p>\n * See: http://www.ietf.org/rfc/rfc4627.txt\n */\npublic class JsonParser extends JsonParserBase {\n\n\tpublic static class Defaults {\n\n\t\tpublic static final String DEFAULT_CLASS_METADATA_NAME = \"__class\";\n\n\t\t/**\n\t\t * Flag for enabling the lazy mode.\n\t\t */\n\t\tpublic static boolean lazy = false;\n\t\t/**\n\t\t * Defines if parser will use extended paths information\n\t\t * and path matching.\n\t\t */\n\t\tpublic static boolean useAltPathsByParser = false;\n\t\t/**\n\t\t * Default value for loose mode.\n\t\t */\n\t\tpublic static boolean loose = false;\n\n\t\t/**\n\t\t * Specifies if 'class' metadata is used and its value. When set, class metadata\n\t\t * is used by {@link jodd.json.JsonSerializer} and all objects\n\t\t * will have additional field with the class type in the resulting JSON.\n\t\t * {@link jodd.json.JsonParser} will also consider this flag to build\n\t\t * correct object type. If <code>null</code>, class information is not used.\n\t\t */\n\t\tpublic static String classMetadataName = null;\n\t}\n\n\t/**\n\t * Static ctor.\n\t */\n\tpublic static JsonParser create() {\n\t\treturn new JsonParser();\n\t}\n\n\t/**\n\t * Creates a lazy implementation of the JSON parser.\n\t */\n\tpublic static JsonParser createLazyOne() {\n\t\treturn new JsonParser().lazy(true);\n\t}\n\n\tprivate static final char[] T_RUE = new char[] {'r', 'u', 'e'};\n\tprivate static final char[] F_ALSE = new char[] {'a', 'l', 's', 'e'};\n\tprivate static final char[] N_ULL = new char[] {'u', 'l', 'l'};\n\n\t/**\n\t * Map keys.\n\t */\n\tpublic static final String KEYS = \"keys\";\n\t/**\n\t * Array or map values.\n\t */\n\tpublic static final String VALUES = \"values\";\n\n\tprotected int ndx = 0;\n\tprotected char[] input;\n\tprotected int total;\n\tprotected Path path;\n\tprotected boolean useAltPaths = Defaults.useAltPathsByParser;\n\tprotected boolean lazy = Defaults.lazy;\n\tprotected boolean looseMode = Defaults.loose;\n\tprotected Class rootType;\n\tprotected MapToBean mapToBean;\n\tprivate boolean notFirstObject = false;\n\n\tprivate final JsonAnnotationManager jsonAnnotationManager;\n\n\tpublic JsonParser() {\n\t\tthis.text = new char[512];\n\t\tthis.jsonAnnotationManager = JsonAnnotationManager.get();\n\t}\n\n\t/**\n\t * Resets JSON parser, so it can be reused.\n\t */\n\tprotected void reset() {\n\t\tthis.ndx = 0;\n\t\tthis.textLen = 0;\n\t\tthis.path = new Path();\n\t\tif (useAltPaths) {\n\t\t\tpath.altPath = new Path();\n\t\t}\n\n\t\tif (classMetadataName != null) {\n\t\t\tmapToBean = createMapToBean(classMetadataName);\n\t\t}\n\t}\n\n\t/**\n\t * Enables usage of additional paths.\n\t */\n\tpublic JsonParser useAltPaths() {\n\t\tthis.useAltPaths = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enables 'loose' mode for parsing. When 'loose' mode is enabled,\n\t * JSON parsers swallows also invalid JSONs:\n\t * <ul>\n\t *     <li>invalid escape character sequence is simply added to the output</li>\n\t *     <li>strings can be quoted with single-quotes</li>\n\t *     <li>strings can be unquoted, but may not contain escapes</li>\n\t * </ul>\n\t */\n\tpublic JsonParser looseMode(final boolean looseMode) {\n\t\tthis.looseMode = looseMode;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Defines how JSON parser works. In non-lazy mode, the whole JSON is parsed as it is.\n\t * In the lazy mode, not everything is parsed, but some things are left lazy.\n\t * This way we gain performance, especially on partial usage of the whole JSON.\n\t * However, be aware that parser holds the input memory until the returned\n\t * objects are disposed.\n\t */\n\tpublic JsonParser lazy(final boolean lazy) {\n\t\tthis.lazy = lazy;\n\t\tthis.mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASMAP_SUPPLIER;\n\t\tthis.listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER;\n\t\treturn this;\n\t}\n\n\t// ---------------------------------------------------------------- mappings\n\n\tprotected Map<Path, Class> mappings;\n\n\t/**\n\t * Maps a class to JSONs root.\n\t */\n\tpublic JsonParser map(final Class target) {\n\t\trootType = target;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Maps a class to given path. For arrays, append <code>values</code>\n\t * to the path to specify component type (if not specified by\n\t * generics).\n\t */\n\tpublic JsonParser map(final String path, final Class target) {\n\t\tif (path == null) {\n\t\t\trootType = target;\n\t\t\treturn this;\n\t\t}\n\t\tif (mappings == null) {\n\t\t\tmappings = new HashMap<>();\n\t\t}\n\t\tmappings.put(Path.parse(path), target);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replaces type with mapped type for current path.\n\t */\n\tprotected Class replaceWithMappedTypeForPath(final Class target) {\n\t\tif (mappings == null) {\n\t\t\treturn target;\n\t\t}\n\n\t\tClass newType;\n\n\t\t// first try alt paths\n\n\t\tPath altPath = path.getAltPath();\n\n\t\tif (altPath != null) {\n\t\t\tif (!altPath.equals(path)) {\n\t\t\t\tnewType = mappings.get(altPath);\n\n\t\t\t\tif (newType != null) {\n\t\t\t\t\treturn newType;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// now check regular paths\n\n\t\tnewType = mappings.get(path);\n\n\t\tif (newType != null) {\n\t\t\treturn newType;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t// ---------------------------------------------------------------- converters\n\n\tprotected Map<Path, ValueConverter> convs;\n\n\t/**\n\t * Defines {@link jodd.json.ValueConverter} to use on given path.\n\t */\n\tpublic JsonParser withValueConverter(final String path, final ValueConverter valueConverter) {\n\t\tif (convs == null) {\n\t\t\tconvs = new HashMap<>();\n\t\t}\n\t\tconvs.put(Path.parse(path), valueConverter);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Lookups for value converter for current path.\n\t */\n\tprotected ValueConverter lookupValueConverter() {\n\t\tif (convs == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn convs.get(path);\n\t}\n\n\t// ---------------------------------------------------------------- class meta data name\n\n\tprotected String classMetadataName = Defaults.classMetadataName;\n\n\t/**\n\t * Sets local class meta-data name.\n\t * <p>\n\t * Note that by using the class meta-data name you may expose a security hole in case untrusted source\n\t * manages to specify a class that is accessible through class loader and exposes set of methods and/or fields,\n\t * access of which opens an actual security hole. Such classes are known as \u201cdeserialization gadget\u201ds.\n\t *\n\t * Because of this, use of \"default typing\" is not encouraged in general, and in particular is recommended against\n\t * if the source of content is not trusted. Conversely, default typing may be used for processing content in\n\t * cases where both ends (sender and receiver) are controlled by same entity.\n\t */\n\tpublic JsonParser setClassMetadataName(final String name) {\n\t\tclassMetadataName = name;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets usage of default class meta-data name.\n\t * Using it may introduce a security hole, see {@link #setClassMetadataName(String)} for more details.\n\t * @see #setClassMetadataName(String)\n\t */\n\tpublic JsonParser withClassMetadata(final boolean useMetadata) {\n\t\tif (useMetadata) {\n\t\t\tclassMetadataName = Defaults.DEFAULT_CLASS_METADATA_NAME;\n\t\t}\n\t\telse {\n\t\t\tclassMetadataName = null;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a {@link jodd.util.Wildcard wildcard} pattern for white-listing classes.\n\t * @see #setClassMetadataName(String)\n\t */\n\tpublic JsonParser allowClass(final String classPattern) {\n\t\tif (super.classnameWhitelist == null) {\n\t\t\tsuper.classnameWhitelist = new ArrayList<>();\n\t\t}\n\t\tclassnameWhitelist.add(classPattern);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes the whitelist of allowed classes.\n\t * @see #setClassMetadataName(String)\n\t */\n\tpublic JsonParser allowAllClasses() {\n\t\tclassnameWhitelist = null;\n\t\treturn this;\n\t}\n\n\t// ---------------------------------------------------------------- parse\n\n\t/**\n\t * Parses input JSON as given type.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T parse(final String input, final Class<T> targetType) {\n\t\trootType = targetType;\n\t\treturn _parse(UnsafeUtil.getChars(input));\n\t}\n\n\t/**\n\t * Parses input JSON to {@link JsonObject}, special case of {@link #parse(String, Class)}.\n\t */\n\tpublic JsonObject parseAsJsonObject(final String input) {\n\t\treturn new JsonObject(parse(input));\n\t}\n\n\t/**\n\t * Parses input JSON to {@link JsonArray}, special case of parsing.\n\t */\n\tpublic JsonArray parseAsJsonArray(final String input) {\n\t\treturn new JsonArray(parse(input));\n\t}\n\n\t/**\n\t * Parses input JSON to a list with specified component type.\n\t */\n\tpublic <T> List<T> parseAsList(final String string, final Class<T> componentType) {\n\t\treturn new JsonParser()\n\t\t\t.map(JsonParser.VALUES, componentType)\n\t\t\t.parse(string);\n\t}\n\n\t/**\n\t * Parses input JSON to a list with specified key and value types.\n\t */\n\tpublic <K, V> Map<K, V> parseAsMap(\n\t\tfinal String string, final Class<K> keyType, final Class<V> valueType) {\n\n\t\treturn new JsonParser()\n\t\t\t.map(JsonParser.KEYS, keyType)\n\t\t\t.map(JsonParser.VALUES, valueType)\n\t\t\t.parse(string);\n\t}\n\n\t/**\n\t * Parses input JSON string.\n\t */\n\tpublic <T> T parse(final String input) {\n\t\treturn _parse(UnsafeUtil.getChars(input));\n\t}\n\n\t/**\n\t * Parses input JSON as given type.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T parse(final char[] input, final Class<T> targetType) {\n\t\trootType = targetType;\n\t\treturn _parse(input);\n\t}\n\n\t/**\n\t * Parses input JSON char array.\n\t */\n\tpublic <T> T parse(final char[] input) {\n\t\treturn _parse(input);\n\t}\n\n\n\tprivate <T> T _parse(final char[] input) {\n\t\tthis.input = input;\n\t\tthis.total = input.length;\n\n\t\treset();\n\n\t\tskipWhiteSpaces();\n\n\t\tObject value;\n\n\t\ttry {\n\t\t\tvalue = parseValue(rootType, null, null);\n\t\t}\n\t\tcatch (IndexOutOfBoundsException iofbex) {\n\t\t\tsyntaxError(\"End of JSON\");\n\t\t\treturn null;\n\t\t}\n\n\t\tskipWhiteSpaces();\n\n\t\tif (ndx != total) {\n\t\t\tsyntaxError(\"Trailing chars\");\n\t\t\treturn null;\n\t\t}\n\n\t\tif (lazy) {\n\t\t\t// lets resolve root lazy values\n\t\t\tvalue = resolveLazyValue(value);\n\t\t}\n\n\t\t// convert map to target type\n\n\t\tif (classMetadataName != null && rootType == null) {\n\t\t\tif (value instanceof Map) {\n\t\t\t\tMap map = (Map) value;\n\n\t\t\t\tvalue = mapToBean.map2bean(map, null);\n\t\t\t}\n\t\t}\n\n\t\treturn (T) value;\n\t}\n\n\t// ---------------------------------------------------------------- parser\n\n\t/**\n\t * Parses a JSON value.\n\t * @param targetType target type to convert, may be <code>null</code>\n\t * @param componentType component type for maps and arrays, may be <code>null</code>\n\t */\n\tprotected Object parseValue(final Class targetType, final Class keyType, final Class componentType) {\n\t\tfinal ValueConverter valueConverter;\n\n\t\tfinal char c = input[ndx];\n\n\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\t\tif (!looseMode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase '\"':\n\t\t\t\tndx++;\n\t\t\t\tObject string = parseStringContent(c);\n\n\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\treturn valueConverter.convert(string);\n\t\t\t\t}\n\n\t\t\t\tif (targetType != null && targetType != String.class) {\n\t\t\t\t\tstring = convertType(string, targetType);\n\t\t\t\t}\n\t\t\t\treturn string;\n\n\t\t\tcase '{':\n\t\t\t\tndx++;\n\t\t\t\tif (lazy) {\n\t\t\t\t\tif (notFirstObject) {\n\t\t\t\t\t\tfinal Object value = new ObjectParser(this, targetType, keyType, componentType);\n\n\t\t\t\t\t\tskipObject();\n\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnotFirstObject = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn parseObjectContent(targetType, keyType, componentType);\n\n\t\t\tcase '[':\n\t\t\t\tndx++;\n\t\t\t\treturn parseArrayContent(targetType, componentType);\n\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\tcase '-':\n\t\t\t\tObject number = parseNumber();\n\n\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\treturn valueConverter.convert(number);\n\t\t\t\t}\n\n\t\t\t\tif (targetType != null) {\n\t\t\t\t\tnumber = convertType(number, targetType);\n\t\t\t\t}\n\t\t\t\treturn number;\n\n\t\t\tcase 'n':\n\t\t\t\tndx++;\n\t\t\t\tif (match(N_ULL)) {\n\t\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\t\treturn valueConverter.convert(null);\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\tndx++;\n\t\t\t\tif (match(T_RUE)) {\n\t\t\t\t\tObject value = Boolean.TRUE;\n\n\t\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\t\treturn valueConverter.convert(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetType != null) {\n\t\t\t\t\t\tvalue = convertType(value, targetType);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tndx++;\n\t\t\t\tif (match(F_ALSE)) {\n\t\t\t\t\tObject value = Boolean.FALSE;\n\n\t\t\t\t\tvalueConverter = lookupValueConverter();\n\t\t\t\t\tif (valueConverter != null) {\n\t\t\t\t\t\treturn valueConverter.convert(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetType != null) {\n\t\t\t\t\t\tvalue = convertType(value, targetType);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (looseMode) {\n\t\t\t// try to parse unquoted string\n\t\t\tObject string = parseUnquotedStringContent();\n\n\t\t\tvalueConverter = lookupValueConverter();\n\t\t\tif (valueConverter != null) {\n\t\t\t\treturn valueConverter.convert(string);\n\t\t\t}\n\n\t\t\tif (targetType != null && targetType != String.class) {\n\t\t\t\tstring = convertType(string, targetType);\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\n\t\tsyntaxError(\"Invalid char: \" + input[ndx]);\n\t\treturn null;\n\t}\n\n\n\t// ---------------------------------------------------------------- lazy\n\n\t/**\n\t * Resolves lazy value during the parsing runtime.\n\t */\n\tprivate Object resolveLazyValue(Object value) {\n\t\tif (value instanceof Supplier) {\n\t\t\tvalue = ((Supplier)value).get();\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Skips over complete object. It is not parsed, just skipped. It will be\n\t * parsed later, but oonly if required.\n\t */\n\tprivate void skipObject() {\n\t\tint bracketCount = 1;\n\t\tboolean insideString = false;\n\n\t\twhile (ndx < total) {\n\t\t\tfinal char c = input[ndx];\n\n\t\t\tif (insideString) {\n\t\t\t\tif (c == '\\\"') {\n\t\t\t\t\tinsideString = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c == '\\\"') {\n\t\t\t\t\tinsideString = true;\n\t\t\t\t}\n\t\t\t\tif (c == '{') {\n\t\t\t\t\tbracketCount++;\n\t\t\t\t} else if (c == '}') {\n\t\t\t\t\tbracketCount--;\n\t\t\t\t\tif (bracketCount == 0) {\n\t\t\t\t\t\tndx++;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tndx++;\n\t\t}\n\t}\n\n\t// ---------------------------------------------------------------- string\n\n\tprotected char[] text;\n\tprotected int textLen;\n\n\t/**\n\t * Parses a string.\n\t */\n\tprotected String parseString() {\n\t\tchar quote = '\\\"';\n\t\tif (looseMode) {\n\t\t\tquote = consumeOneOf('\\\"', '\\'');\n\t\t\tif (quote == 0) {\n\t\t\t\treturn parseUnquotedStringContent();\n\t\t\t}\n\t\t} else {\n\t\t\tconsume(quote);\n\t\t}\n\n\t\treturn parseStringContent(quote);\n\t}\n\n\t/**\n\t * Parses string content, once when starting quote has been consumed.\n\t */\n\tprotected String parseStringContent(final char quote) {\n\t\tfinal int startNdx = ndx;\n\n\t\t// roll-out until the end of the string or the escape char\n\t\twhile (true) {\n\t\t\tfinal char c = input[ndx];\n\n\t\t\tif (c == quote) {\n\t\t\t\t// no escapes found, just use existing string\n\t\t\t\tndx++;\n\t\t\t\treturn new String(input, startNdx, ndx - 1 - startNdx);\n\t\t\t}\n\n\t\t\tif (c == '\\\\') {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tndx++;\n\t\t}\n\n\t\t// escapes found, proceed differently\n\n\t\ttextLen = ndx - startNdx;\n\n\t\tgrowEmpty();\n\n//\t\tfor (int i = startNdx, j = 0; j < textLen; i++, j++) {\n//\t\t\ttext[j] = input[i];\n//\t\t}\n\t\tSystem.arraycopy(input, startNdx, text, 0, textLen);\n\n\t\t// escape char, process everything until the end\n\t\twhile (true) {\n\t\t\tchar c = input[ndx];\n\n\t\t\tif (c == quote) {\n\t\t\t\t// done\n\t\t\t\tndx++;\n\t\t\t\tfinal String str = new String(text, 0, textLen);\n\t\t\t\ttextLen = 0;\n\t\t\t\treturn str;\n\t\t\t}\n\n\t\t\tif (c == '\\\\') {\n\t\t\t\t// escape char found\n\t\t\t\tndx++;\n\n\t\t\t\tc = input[ndx];\n\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '\\\"' : c = '\\\"'; break;\n\t\t\t\t\tcase '\\\\' : c = '\\\\'; break;\n\t\t\t\t\tcase '/' : c = '/'; break;\n\t\t\t\t\tcase 'b' : c = '\\b'; break;\n\t\t\t\t\tcase 'f' : c = '\\f'; break;\n\t\t\t\t\tcase 'n' : c = '\\n'; break;\n\t\t\t\t\tcase 'r' : c = '\\r'; break;\n\t\t\t\t\tcase 't' : c = '\\t'; break;\n\t\t\t\t\tcase 'u' :\n\t\t\t\t\t\tndx++;\n\t\t\t\t\t\tc = parseUnicode();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (looseMode) {\n\t\t\t\t\t\t\tif (c != '\\'') {\n\t\t\t\t\t\t\t\tc = '\\\\';\n\t\t\t\t\t\t\t\tndx--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsyntaxError(\"Invalid escape char: \" + c);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext[textLen] = c;\n\n\t\t\ttextLen++;\n\n\t\t\tgrowAndCopy();\n\n\t\t\tndx++;\n\t\t}\n\t}\n\n\t/**\n\t * Grows empty text array.\n\t */\n\tprotected void growEmpty() {\n\t\tif (textLen >= text.length) {\n\t\t\tint newSize = textLen << 1;\n\n\t\t\ttext = new char[newSize];\n\t\t}\n\t}\n\n\t/**\n\t * Grows text array when {@code text.length == textLen}.\n\t */\n\tprotected void growAndCopy() {\n\t\tif (textLen == text.length) {\n\t\t\tint newSize = text.length << 1;\n\n\t\t\tchar[] newText = new char[newSize];\n\n\t\t\tif (textLen > 0) {\n\t\t\t\tSystem.arraycopy(text, 0, newText, 0, textLen);\n\t\t\t}\n\n\t\t\ttext = newText;\n\t\t}\n\t}\n\n\t/**\n\t * Parses 4 characters and returns unicode character.\n\t */\n\tprotected char parseUnicode() {\n\t\tint i0 = CharUtil.hex2int(input[ndx++]);\n\t\tint i1 = CharUtil.hex2int(input[ndx++]);\n\t\tint i2 = CharUtil.hex2int(input[ndx++]);\n\t\tint i3 = CharUtil.hex2int(input[ndx]);\n\n\t\treturn (char) ((i0 << 12) + (i1 << 8) + (i2 << 4) + i3);\n\t}\n\n\t// ---------------------------------------------------------------- un-quoted\n\n\tprivate final static char[] UNQOUTED_DELIMETERS = \",:[]{}\\\\\\\"'\".toCharArray();\n\n\t/**\n\t * Parses un-quoted string content.\n\t */\n\tprotected String parseUnquotedStringContent() {\n\t\tfinal int startNdx = ndx;\n\n\t\twhile (true) {\n\t\t\tfinal char c = input[ndx];\n\n\t\t\tif (c <= ' ' || CharUtil.equalsOne(c, UNQOUTED_DELIMETERS)) {\n\t\t\t\tfinal int currentNdx = ndx;\n\n\t\t\t\t// done\n\t\t\t\tskipWhiteSpaces();\n\n\t\t\t\treturn new String(input, startNdx, currentNdx - startNdx);\n\t\t\t}\n\n\t\t\tndx++;\n\t\t}\n\t}\n\n\n\t// ---------------------------------------------------------------- number\n\n\t/**\n\t * Parses JSON numbers.\n\t */\n\tprotected Number parseNumber() {\n\t\tfinal int startIndex = ndx;\n\n\t\tchar c = input[ndx];\n\n\t\tboolean isDouble = false;\n\t\tboolean isExp = false;\n\n\t\tif (c == '-') {\n\t\t\tndx++;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (isEOF()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tc = input[ndx];\n\n\t\t\tif (c >= '0' && c <= '9') {\n\t\t\t\tndx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c <= 32) {\t\t// white space\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == ',' || c == '}' || c == ']') {\t// delimiter\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (c == '.') {\n\t\t\t\tisDouble = true;\n\t\t\t}\n\t\t\telse if (c == 'e' || c == 'E') {\n\t\t\t\tisExp = true;\n\t\t\t}\n\t\t\tndx++;\n\t\t}\n\n\n\t\tfinal String value = new String(input, startIndex, ndx - startIndex);\n\n\t\tif (isDouble) {\n\t\t\treturn Double.valueOf(value);\n\t\t}\n\n\t\tlong longNumber;\n\n\t\tif (isExp) {\n\t\t\tlongNumber = Double.valueOf(value).longValue();\n\t\t}\n\t\telse {\n\t\t\tif (value.length() >= 19) {\n\t\t\t\t// if string is 19 chars and longer, it can be over the limit\n\t\t\t\tBigInteger bigInteger = new BigInteger(value);\n\n\t\t\t\tif (isGreaterThenLong(bigInteger)) {\n\t\t\t\t\treturn bigInteger;\n\t\t\t\t}\n\t\t\t\tlongNumber = bigInteger.longValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlongNumber = Long.parseLong(value);\n\t\t\t}\n\t\t}\n\n\t\tif ((longNumber >= Integer.MIN_VALUE) && (longNumber <= Integer.MAX_VALUE)) {\n\t\t\treturn Integer.valueOf((int) longNumber);\n\t\t}\n\t\treturn Long.valueOf(longNumber);\n\t}\n\n\tprivate static boolean isGreaterThenLong(final BigInteger bigInteger) {\n\t\tif (bigInteger.compareTo(MAX_LONG) > 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (bigInteger.compareTo(MIN_LONG) < 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n\tprivate static final BigInteger MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\n\n\t// ---------------------------------------------------------------- array\n\n\t/**\n\t * Parses arrays, once when open bracket has been consumed.\n\t */\n\tprotected Object parseArrayContent(Class targetType, Class componentType) {\n\t\t// detect special case\n\n\t\tif (targetType == Object.class) {\n\t\t\ttargetType = List.class;\n\t\t}\n\n\t\t// continue\n\n\t\ttargetType = replaceWithMappedTypeForPath(targetType);\n\n\t\tif (componentType == null && targetType != null && targetType.isArray()) {\n\t\t\tcomponentType = targetType.getComponentType();\n\t\t}\n\n\t\tpath.push(VALUES);\n\n\t\tcomponentType = replaceWithMappedTypeForPath(componentType);\n\n\t\tCollection<Object> target = newArrayInstance(targetType);\n\n\t\tboolean koma = false;\n\n\t\tmainloop:\n\t\twhile (true) {\n\t\t\tskipWhiteSpaces();\n\n\t\t\tchar c = input[ndx];\n\n\t\t\tif (c == ']') {\n\t\t\t\tif (koma) {\n\t\t\t\t\tsyntaxError(\"Trailing comma\");\n\t\t\t\t}\n\n\t\t\t\tndx++;\n\t\t\t\tpath.pop();\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\tObject value = parseValue(componentType, null, null);\n\n\t\t\ttarget.add(value);\n\n\t\t\tskipWhiteSpaces();\n\n\t\t\tc = input[ndx];\n\n\t\t\tswitch (c) {\n\t\t\t\tcase ']': ndx++; break mainloop;\n\t\t\t\tcase ',': ndx++; koma = true; break;\n\t\t\t\tdefault: syntaxError(\"Invalid char: expected ] or ,\");\n\t\t\t}\n\n\t\t}\n\n\t\tpath.pop();\n\n\t\tif (targetType != null) {\n\t\t\treturn convertType(target, targetType);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t// ---------------------------------------------------------------- object\n\n\t/**\n\t * Parses object, once when open bracket has been consumed.\n\t */\n\tprotected Object parseObjectContent(Class targetType, Class valueKeyType, Class valueType) {\n\t\t// detect special case\n\n\t\tif (targetType == Object.class) {\n\t\t\ttargetType = Map.class;\n\t\t}\n\n\t\t// continue\n\n\t\ttargetType = replaceWithMappedTypeForPath(targetType);\n\n\t\tObject target;\n\t\tboolean isTargetTypeMap = true;\n\t\tboolean isTargetRealTypeMap = true;\n\t\tClassDescriptor targetTypeClassDescriptor = null;\n\t\tTypeData typeData = null;\n\n\t\tif (targetType != null) {\n\t\t\ttargetTypeClassDescriptor = ClassIntrospector.get().lookup(targetType);\n\n\t\t\t// find if the target is really a map\n\t\t\t// because when classMetadataName != null we are forcing\n\t\t\t// map usage locally in this method\n\n\t\t\tisTargetRealTypeMap = targetTypeClassDescriptor.isMap();\n\n\t\t\ttypeData = jsonAnnotationManager.lookupTypeData(targetType);\n\t\t}\n\n\t\tif (isTargetRealTypeMap) {\n\t\t\t// resolve keys only for real maps\n\t\t\tpath.push(KEYS);\n\t\t\tvalueKeyType = replaceWithMappedTypeForPath(valueKeyType);\n\t\t\tpath.pop();\n\t\t}\n\n\t\tif (classMetadataName == null) {\n\t\t\t// create instance of target type, no 'class' information\n\t\t\ttarget = newObjectInstance(targetType);\n\n\t\t\tisTargetTypeMap = isTargetRealTypeMap;\n\t\t} else {\n\t\t\t// all beans will be created first as a map\n\t\t\ttarget = mapSupplier.get();\n\t\t}\n\n\t\tboolean koma = false;\n\n\t\tmainloop:\n\t\twhile (true) {\n\t\t\tskipWhiteSpaces();\n\n\t\t\tchar c = input[ndx];\n\n\t\t\tif (c == '}') {\n\t\t\t\tif (koma) {\n\t\t\t\t\tsyntaxError(\"Trailing comma\");\n\t\t\t\t}\n\n\t\t\t\tndx++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkoma = false;\n\n\t\t\tString key = parseString();\n\t\t\tString keyOriginal = key;\n\n\t\t\tskipWhiteSpaces();\n\n\t\t\tconsume(':');\n\n\t\t\tskipWhiteSpaces();\n\n\t\t\t// read the type of the simple property\n\n\t\t\tPropertyDescriptor pd = null;\n\t\t\tClass propertyType = null;\n\t\t\tClass keyType = null;\n\t\t\tClass componentType = null;\n\n\t\t\t// resolve simple property\n\n\t\t\tif (!isTargetRealTypeMap) {\n\t\t\t\t// replace key with real property value\n\t\t\t\tkey = jsonAnnotationManager.resolveRealName(targetType, key);\n\t\t\t}\n\n\t\t\tif (!isTargetTypeMap) {\n\t\t\t\tpd = targetTypeClassDescriptor.getPropertyDescriptor(key, true);\n\n\t\t\t\tif (pd != null) {\n\t\t\t\t\tpropertyType = pd.getType();\n\t\t\t\t\tkeyType = pd.resolveKeyType(true);\n\t\t\t\t\tcomponentType = pd.resolveComponentType(true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject value;\n\n\t\t\tif (!isTargetTypeMap) {\n\t\t\t\t// *** inject into bean\n\t\t\t\t\tpath.push(key);\n\n\t\t\t\t\tvalue = parseValue(propertyType, keyType, componentType);\n\n\t\t\t\t\tpath.pop();\n\n\t\t\t\tif (typeData.rules.match(keyOriginal, !typeData.strict)) {\n\n\t\t\t\t\tif (pd != null) {\n\t\t\t\t\t\tif (lazy) {\n\t\t\t\t\t\t\t// need to resolve lazy value before injecting objects into it\n\t\t\t\t\t\t\tvalue = resolveLazyValue(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only inject values if target property exist\n\t\t\t\t\t\tinjectValueIntoObject(target, pd, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject keyValue = key;\n\n\t\t\t\tif (valueKeyType != null) {\n\t\t\t\t\tkeyValue = convertType(key, valueKeyType);\n\t\t\t\t}\n\n\t\t\t\t// *** add to map\n\t\t\t\tif (isTargetRealTypeMap) {\n\t\t\t\t\tpath.push(VALUES, key);\n\n\t\t\t\t\tvalueType = replaceWithMappedTypeForPath(valueType);\n\t\t\t\t} else {\n\t\t\t\t\tpath.push(key);\n\t\t\t\t}\n\n\n\t\t\t\tvalue = parseValue(valueType, null, null);\n\n\t\t\t\tpath.pop();\n\n\t\t\t\t((Map) target).put(keyValue, value);\n\t\t\t}\n\n\t\t\tskipWhiteSpaces();\n\n\t\t\tc = input[ndx];\n\n\t\t\tswitch (c) {\n\t\t\t\tcase '}': ndx++; break mainloop;\n\t\t\t\tcase ',': ndx++; koma = true; break;\n\t\t\t\tdefault: syntaxError(\"Invalid char: expected } or ,\");\n\t\t\t}\n\t\t}\n\n\t\t// done\n\n\t\t// convert Map to target type\n\t\tif (classMetadataName != null) {\n\t\t\ttarget = mapToBean.map2bean((Map) target, targetType);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t// ---------------------------------------------------------------- scanning tools\n\n\t/**\n\t * Consumes char at current position. If char is different, throws the exception.\n\t */\n\tprotected void consume(final char c) {\n\t\tif (input[ndx] != c) {\n\t\t\tsyntaxError(\"Invalid char: expected \" + c);\n\t\t}\n\n\t\tndx++;\n\t}\n\n\t/**\n\t * Consumes one of the allowed char at current position.\n\t * If char is different, return <code>0</code>.\n\t * If matched, returns matched char.\n\t */\n\tprotected char consumeOneOf(final char c1, final char c2) {\n\t\tchar c = input[ndx];\n\n\t\tif ((c != c1) && (c != c2)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tndx++;\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * Returns <code>true</code> if scanning is at the end.\n\t */\n\tprotected boolean isEOF() {\n\t\treturn ndx >= total;\n\t}\n\n\t/**\n\t * Skips whitespaces. For the simplification, whitespaces are\n\t * considered any characters less or equal to 32 (space).\n\t */\n\tprotected final void skipWhiteSpaces() {\n\t\twhile (true) {\n\t\t\tif (isEOF()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (input[ndx] > 32) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tndx++;\n\t\t}\n    }\n\n\t/**\n\t * Matches char buffer with content on given location.\n\t */\n\tprotected final boolean match(final char[] target) {\n\t\tfor (char c : target) {\n\t\t\tif (input[ndx] != c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tndx++;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t// ---------------------------------------------------------------- error\n\n\t/**\n\t * Throws {@link jodd.json.JsonException} indicating a syntax error.\n\t */\n\tprotected void syntaxError(final String message) {\n\t\tString left = \"...\";\n\t\tString right = \"...\";\n\t\tint offset = 10;\n\n\t\tint from = ndx - offset;\n\t\tif (from < 0) {\n\t\t\tfrom = 0;\n\t\t\tleft = StringPool.EMPTY;\n\t\t}\n\n\t\tint to = ndx + offset;\n\t\tif (to > input.length) {\n\t\t\tto = input.length;\n\t\t\tright = StringPool.EMPTY;\n\t\t}\n\n\t\tfinal CharSequence str = CharArraySequence.of(input, from, to - from);\n\n\t\tthrow new JsonException(\n\t\t\t\t\"Syntax error! \" + message + \"\\n\" +\n\t\t\t\t\"offset: \" + ndx + \" near: \\\"\" + left + str + right + \"\\\"\");\n\t}\n\n}", "// Copyright (c) 2003-present, Jodd Team (http://jodd.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\npackage jodd.json;\n\nimport jodd.introspector.ClassDescriptor;\nimport jodd.introspector.ClassIntrospector;\nimport jodd.introspector.CtorDescriptor;\nimport jodd.introspector.PropertyDescriptor;\nimport jodd.introspector.Setter;\nimport jodd.typeconverter.TypeConverterManager;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\n/**\n * Just a base class of {@link jodd.json.JsonParser} that contains\n * various utilities, to reduce the size of a parser.\n */\npublic abstract class JsonParserBase {\n\n\tprotected static final Supplier<Map> HASMAP_SUPPLIER = LinkedHashMap::new;\n\tprotected static final Supplier<Map> LAZYMAP_SUPPLIER = LazyMap::new;\n\n\tprotected static final Supplier<List> ARRAYLIST_SUPPLIER = ArrayList::new;\n\tprotected static final Supplier<List> LAZYLIST_SUPPLIER = LazyList::new;\n\n\tprotected Supplier<Map> mapSupplier = HASMAP_SUPPLIER;\n\tprotected Supplier<List> listSupplier = ARRAYLIST_SUPPLIER;\n\tprotected List<String> classnameWhitelist;\n\n\t/**\n\t * Creates new instance of {@link jodd.json.MapToBean}.\n\t */\n\tprotected MapToBean createMapToBean(final String classMetadataName) {\n\t\treturn new MapToBean(this, classMetadataName);\n\t}\n\n\t// ---------------------------------------------------------------- object tools\n\n\t/**\n\t * Creates new type for JSON array objects.\n\t * It returns a collection.\n\t * Later, the collection will be converted into the target type.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected Collection<Object> newArrayInstance(final Class targetType) {\n\t\tif (targetType == null ||\n\t\t\ttargetType == List.class ||\n\t\t\ttargetType == Collection.class ||\n\t\t\ttargetType.isArray()) {\n\n\t\t\treturn listSupplier.get();\n\t\t}\n\n\t\tif (targetType == Set.class) {\n\t\t\treturn new HashSet<>();\n\t\t}\n\n\t\ttry {\n\t\t\treturn (Collection<Object>) targetType.getDeclaredConstructor().newInstance();\n\t\t} catch (Exception e) {\n\t\t\tthrow new JsonException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Creates new object or a <code>HashMap</code> if type is not specified.\n\t */\n\tprotected Object newObjectInstance(final Class targetType) {\n\t\tif (targetType == null ||\n\t\t\ttargetType == Map.class) {\n\n\t\t\treturn mapSupplier.get();\n\t\t}\n\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(targetType);\n\n\t\tCtorDescriptor ctorDescriptor = cd.getDefaultCtorDescriptor(true);\n\t\tif (ctorDescriptor == null) {\n\t\t\tthrow new JsonException(\"Default ctor not found for: \" + targetType.getName());\n\t\t}\n\n\t\ttry {\n//\t\t\treturn ClassUtil.newInstance(targetType);\n\t\t\treturn ctorDescriptor.getConstructor().newInstance();\n\t\t} catch (Exception e) {\n\t\t\tthrow new JsonException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Injects value into the targets property.\n\t */\n\tprotected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) {\n\t\tObject convertedValue = value;\n\n\t\tif (value != null) {\n\t\t\tClass targetClass = pd.getType();\n\n\t\t\tconvertedValue = convertType(value, targetClass);\n\t\t}\n\n\t\ttry {\n\t\t\tSetter setter = pd.getSetter(true);\n\t\t\tif (setter != null) {\n\t\t\t\tsetter.invokeSetter(target, convertedValue);\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tthrow new JsonException(ex);\n\t\t}\n\t}\n\n\t/**\n\t * Converts type of the given value.\n\t */\n\tprotected Object convertType(final Object value, final Class targetType) {\n\t\tClass valueClass = value.getClass();\n\n\t\tif (valueClass == targetType) {\n\t\t\treturn value;\n\t\t}\n\n\t\ttry {\n\t\t\treturn TypeConverterManager.get().convertType(value, targetType);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonException(\"Type conversion failed\", ex);\n\t\t}\n\t}\n\n}", "// Copyright (c) 2003-present, Jodd Team (http://jodd.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\npackage jodd.json;\n\nimport jodd.introspector.ClassDescriptor;\nimport jodd.introspector.ClassIntrospector;\nimport jodd.introspector.PropertyDescriptor;\nimport jodd.introspector.Setter;\nimport jodd.typeconverter.TypeConverterManager;\nimport jodd.util.ClassLoaderUtil;\nimport jodd.util.ClassUtil;\nimport jodd.util.Wildcard;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Map to bean converter.\n * Used when parsing with class metadata enabled.\n */\npublic class MapToBean {\n\n\tprotected boolean declared = true;\n\tprotected final JsonParserBase jsonParser;\n\tprotected final String classMetadataName;\n\n\tpublic MapToBean(final JsonParserBase jsonParser, final String classMetadataName) {\n\t\tthis.jsonParser = jsonParser;\n\t\tthis.classMetadataName = classMetadataName;\n\t}\n\n\t/**\n\t * Converts map to target type.\n\t */\n\tpublic Object map2bean(final Map map, Class targetType) {\n\t\tObject target = null;\n\n\t\t// create targets type\n\t\tString className = (String) map.get(classMetadataName);\n\n\t\tif (className == null) {\n\t\t\tif (targetType == null) {\n\t\t\t\t// nothing to do, no information about target type found\n\t\t\t\ttarget = map;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcheckClassName(jsonParser.classnameWhitelist, className);\n\n\t\t\ttry {\n\t\t\t\ttargetType = ClassLoaderUtil.loadClass(className);\n\t\t\t} catch (ClassNotFoundException cnfex) {\n\t\t\t\tthrow new JsonException(cnfex);\n\t\t\t}\n\t\t}\n\n\t\tif (target == null) {\n\t\t\ttarget = jsonParser.newObjectInstance(targetType);\n\t\t}\n\n\t\tClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());\n\n\t\tboolean targetIsMap = target instanceof Map;\n\n\t\tfor (Object key : map.keySet()) {\n\t\t\tString keyName = key.toString();\n\n\t\t\tif (classMetadataName != null) {\n\t\t\t\tif (keyName.equals(classMetadataName)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared);\n\n\t\t\tif (!targetIsMap && pd == null) {\n\t\t\t\t// target property does not exist, continue\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// value is one of JSON basic types, like Number, Map, List...\n\t\t\tObject value = map.get(key);\n\n\t\t\tClass propertyType = pd == null ? null : pd.getType();\n\t\t\tClass componentType = pd == null ? null : pd.resolveComponentType(true);\n\n\t\t\tif (value != null) {\n\t\t\t\tif (value instanceof List) {\n\t\t\t\t\tif (componentType != null && componentType != String.class) {\n\t\t\t\t\t\tvalue = generifyList((List) value, componentType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (value instanceof Map) {\n\t\t\t\t\t// if the value we want to inject is a Map...\n\t\t\t\t\tif (!ClassUtil.isTypeOf(propertyType, Map.class)) {\n\t\t\t\t\t\t// ... and if target is NOT a map\n\t\t\t\t\t\tvalue = map2bean((Map) value, propertyType);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// target is also a Map, but we might need to generify it\n\t\t\t\t\t\tClass keyType = pd == null ? null : pd.resolveKeyType(true);\n\n\t\t\t\t\t\tif (keyType != String.class || componentType != String.class) {\n\t\t\t\t\t\t\t// generify\n\t\t\t\t\t\t\tvalue = generifyMap((Map) value, keyType, componentType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (targetIsMap) {\n\t\t\t\t((Map)target).put(keyName, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tsetValue(target, pd, value);\n\t\t\t\t} catch (Exception ignore) {\n\t\t\t\t\tignore.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tprivate void checkClassName(final List<String> classnameWhitelist, final String className) {\n\t\tif (classnameWhitelist == null) {\n\t\t\treturn;\n\t\t}\n\t\tclassnameWhitelist.forEach(pattern -> {\n\t\t\tif (!Wildcard.equalsOrMatch(className, pattern)) {\n\t\t\t\tthrow new JsonException(\"Class can't be loaded as it is not whitelisted: \" + className);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Converts type of all list elements to match the component type.\n\t */\n\tprivate Object generifyList(final List list, final Class componentType) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tObject element = list.get(i);\n\n\t\t\tif (element != null) {\n\t\t\t\tif (element instanceof Map) {\n\t\t\t\t\tObject bean = map2bean((Map) element, componentType);\n\t\t\t\t\tlist.set(i, bean);\n\t\t\t\t} else {\n\t\t\t\t\tObject value = convert(element, componentType);\n\t\t\t\t\tlist.set(i, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}\n\n\t/**\n\t * Sets the property value.\n\t */\n\tprivate void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException {\n\t\tClass propertyType;\n\n\t\tSetter setter = pd.getSetter(true);\n\t\tif (setter != null) {\n\t\t\tif (value != null) {\n\t\t\t\tpropertyType = setter.getSetterRawType();\n\t\t\t\tvalue = jsonParser.convertType(value, propertyType);\n\t\t\t}\n\t\t\tsetter.invokeSetter(target, value);\n\t\t}\n\t}\n\n\t/**\n\t * Change map elements to match key and value types.\n\t */\n\tprotected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) {\n\n\t\tif (keyType == String.class) {\n\t\t\t// only value type is changed, we can make value replacements\n\t\t\tfor (Map.Entry<Object, Object> entry : map.entrySet()) {\n\t\t\t\tObject value = entry.getValue();\n\t\t\t\tObject newValue = convert(value, valueType);\n\n\t\t\t\tif (value != newValue) {\n\t\t\t\t\tentry.setValue(newValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (Map<K, V>) map;\n\t\t}\n\n\t\t// key is changed too, we need a new map\n\t\tMap<K, V> newMap = new HashMap<>(map.size());\n\n\t\tfor (Map.Entry<Object, Object> entry : map.entrySet()) {\n\t\t\tObject key = entry.getKey();\n\t\t\tObject newKey = convert(key, keyType);\n\n\t\t\tObject value = entry.getValue();\n\t\t\tObject newValue = convert(value, valueType);\n\n\t\t\tnewMap.put((K)newKey, (V)newValue);\n\t\t}\n\n\t\treturn newMap;\n\t}\n\n\tprotected Object convert(final Object value, final Class targetType) {\n\t\tClass valueClass = value.getClass();\n\n\t\tif (valueClass == targetType) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (value instanceof Map) {\n\t\t\tif (targetType == Map.class) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn map2bean((Map) value, targetType);\n\t\t}\n\n\t\ttry {\n\t\t\treturn TypeConverterManager.get().convertType(value, targetType);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new JsonException(\"Type conversion failed\", ex);\n\t\t}\n\t}\n\n}", "// Copyright (c) 2003-present, Jodd Team (http://jodd.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\npackage jodd.json;\n\nimport jodd.json.fixtures.JsonParsers;\nimport jodd.json.fixtures.mock.Employee;\nimport jodd.json.fixtures.mock.Group;\nimport jodd.json.fixtures.mock.Network;\nimport jodd.json.fixtures.mock.Pair;\nimport jodd.json.fixtures.mock.Person;\nimport jodd.json.fixtures.mock.Phone;\nimport jodd.json.fixtures.mock.Spiderman;\nimport jodd.json.fixtures.mock.superhero.Hero;\nimport jodd.json.fixtures.mock.superhero.SecretIdentity;\nimport jodd.json.fixtures.mock.superhero.SecretLair;\nimport jodd.json.fixtures.mock.superhero.SuperPower;\nimport jodd.json.fixtures.mock.superhero.Villian;\nimport jodd.json.fixtures.mock.superhero.XRayVision;\nimport jodd.json.fixtures.model.Account;\nimport jodd.json.impl.DateJsonSerializer;\nimport jodd.util.StringUtil;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.awt.geom.Point2D;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nclass JSONDeserializerTest {\n\n\tprivate static final double DELTA = 0.000000001;\n\n\tprivate DataCreator creator;\n\n\t@BeforeEach\n\tvoid setUp() {\n\t\tcreator = new DataCreator();\n\t}\n\n\t@AfterEach\n\tvoid tearDown() {\n\t\tJsonParser.Defaults.classMetadataName = null;\n\t\tJsonSerializer.Defaults.classMetadataName = null;\n\t}\n\n\t@Test\n\tvoid testDeserializeNoIncludes() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPerson jodder = creator.createJodder();\n\t\t\tString json = new JsonSerializer().serialize(jodder);\n\t\t\tPerson jsonJodder = jsonParser.parse(json, Person.class);\n\n\t\t\tassertNotNull(jsonJodder);\n\n\t\t\tassertEquals(jodder.getLastname(), jsonJodder.getLastname());\n\t\t\tassertEquals(jodder.getFirstname(), jsonJodder.getFirstname());\n\t\t\tassertEquals(jodder.getBirthdate(), jsonJodder.getBirthdate());\n\n\t\t\tassertEquals(jodder.getHome().getState(), jsonJodder.getHome().getState());\n\t\t\tassertEquals(jodder.getHome().getStreet(), jsonJodder.getHome().getStreet());\n\t\t\tassertEquals(jodder.getHome().getCity(), jsonJodder.getHome().getCity());\n\n\t\t\tassertEquals(jodder.getWork().getCity(), jsonJodder.getWork().getCity());\n\n\t\t\tassertEquals(jsonJodder, jsonJodder.getWork().getPerson());\n\n\t\t\tassertEquals(0, jsonJodder.getHobbies().size());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeWithPath() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tMap map = new HashMap();\n\t\t\tmap.put(\"person\", igor);\n\n\t\t\tString json = new JsonSerializer().serialize(map);\n\n\t\t\tmap = jsonParser.map(\"values\", Person.class).parse(json);\n\t\t\tPerson jsonIgor = (Person) map.get(\"person\");\n\n\t\t\tassertNotNull(jsonIgor);\n\n\t\t\tassertEquals(igor.getLastname(), jsonIgor.getLastname());\n\t\t\tassertEquals(igor.getFirstname(), jsonIgor.getFirstname());\n\t\t\tassertEquals(igor.getBirthdate(), jsonIgor.getBirthdate());\n\n\t\t\tassertEquals(igor.getHome().getState(), jsonIgor.getHome().getState());\n\t\t\tassertEquals(igor.getHome().getStreet(), jsonIgor.getHome().getStreet());\n\t\t\tassertEquals(igor.getHome().getCity(), jsonIgor.getHome().getCity());\n\n\t\t\tassertEquals(igor.getWork().getCity(), jsonIgor.getWork().getCity());\n\n\t\t\tassertEquals(jsonIgor, jsonIgor.getWork().getPerson());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeWithIncludes() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tString json = new JsonSerializer().include(\"phones\", \"hobbies\").serialize(igor);\n\t\t\tPerson jsonIgor = jsonParser.parse(json, Person.class);\n\n\t\t\tassertEquals(2, jsonIgor.getPhones().size());\n\t\t\tassertEquals(0, jsonIgor.getHobbies().size());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testSubClassDeserialize() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tEmployee dilbert = creator.createDilbert();\n\n\t\t\tString json = new JsonSerializer().include(\"phones\", \"hobbies\").serialize(dilbert);\n\t\t\tPerson jsonDilbert = jsonParser.parse(json, Employee.class);\n\n\t\t\tassertNotNull(jsonDilbert);\n\t\t\tassertTrue(jsonDilbert instanceof Employee);\n\t\t\tassertEquals(dilbert.getCompany(), ((Employee) jsonDilbert).getCompany());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeInterfaces() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer().include(\"powers\").setClassMetadataName(\"class\").serialize(superman);\n\t\t\tHero jsonSuperMan = jsonParser.setClassMetadataName(\"class\").parse(json, Hero.class);\n\n\t\t\tassertNotNull(jsonSuperMan);\n\t\t\tassertEquals(4, jsonSuperMan.getPowers().size());\n\t\t\tassertHeroHasSuperPowers(jsonSuperMan);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeInterfaces2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer().include(\"powers\").withClassMetadata(true).serialize(superman);\n\t\t\tHero jsonSuperMan = jsonParser.withClassMetadata(true).parse(json, Hero.class);\n\n\t\t\tassertNotNull(jsonSuperMan);\n\t\t\tassertEquals(4, jsonSuperMan.getPowers().size());\n\t\t\tassertHeroHasSuperPowers(jsonSuperMan);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testNoClassHints() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer().exclude(\"*.class\").serialize(superman);\n\n\t\t\tHero jsonSuperMan = jsonParser\n\t\t\t\t.map(Hero.class)\n\t\t\t\t.map(\"lair\", SecretLair.class)\n\t\t\t\t.map(\"secretIdentity\", SecretIdentity.class)\n\t\t\t\t.parse(json);\n\n\t\t\tassertNotNull(jsonSuperMan);\n\t\t\tassertEquals(\"Super Man\", jsonSuperMan.getName());\n\t\t\tassertNotNull(jsonSuperMan.getIdentity());\n\t\t\tassertEquals(\"Clark Kent\", jsonSuperMan.getIdentity().getName());\n\t\t\tassertNotNull(jsonSuperMan.getLair());\n\t\t\tassertEquals(\"Fortress of Solitude\", jsonSuperMan.getLair().getName());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testNoHintsButClassesForCollection() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer()\n\t\t\t\t.exclude(\"*.class\")\n\t\t\t\t.include(\"powers.class\")\n\t\t\t\t.serialize(superman);\n\t\t\tHero jsonSuperMan = jsonParser.parse(json, Hero.class);\n\t\t\tassertHeroHasSuperPowers(jsonSuperMan);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testNoClassHintsForCollections() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tHero superman = creator.createSuperman();\n\t\t\tString json = new JsonSerializer()\n\t\t\t\t.include(\"powers\")        // redudant\n\t\t\t\t.include(\"powers.class\")\n\t\t\t\t.withSerializer(\"powers.class\", new SimpleClassnameTransformer())\n\t\t\t\t.exclude(\"*.class\")\n\t\t\t\t.serialize(superman);\n\n\t\t\tint count = StringUtil.count(json, \"***\");\n\t\t\tassertEquals(4, count);\n\n\t\t\tjson = StringUtil.remove(json, \"***\");\n\n\t\t\tHero jsonSuperMan = jsonParser\n\t\t\t\t.map(\"lair\", SecretLair.class)\n\t\t\t\t.map(\"secretIdentity\", SecretIdentity.class)\n\t\t\t\t.parse(json, Hero.class);\n\n\t\t\tassertEquals(\"Fortress of Solitude\", jsonSuperMan.getLair().getName());\n\t\t\tassertHeroHasSuperPowers(jsonSuperMan);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testListSerialization() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tPerson modesty = creator.createModesty();\n\t\tPerson igor = creator.createJodder();\n\t\tPerson pedro = creator.createPedro();\n\t\tList<Person> list = new ArrayList<>(3);\n\t\tlist.add(modesty);\n\t\tlist.add(igor);\n\t\tlist.add(pedro);\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = new JsonSerializer().serialize(list);\n\n\t\t\tList<Person> people = jsonParser.parse(json);\n\t\t\tassertTrue(people instanceof List);\n\n\t\t\tjson = new JsonSerializer().exclude(\"*.class\").serialize(list);\n\t\t\tpeople = jsonParser.map(\"values\", Person.class).parse(json);\n\n\t\t\tassertEquals(3, people.size());\n\t\t\tassertEquals(Person.class, people.get(0).getClass());\n\t\t});\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = new JsonSerializer().exclude(\"*.class\").serialize(list);\n\n\t\t\tList<Map> peopleMap = jsonParser.parse(json);\n\n\t\t\tassertEquals(3, peopleMap.size());\n\t\t\tassertTrue(peopleMap.get(0) instanceof Map);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testGenericTypeDeserialization() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tPair<Hero, Villian> archenemies = new Pair<>(creator.createSuperman(), creator.createLexLuthor());\n\n\t\t\tString json = new JsonSerializer()\n\t\t\t\t.exclude(\"*.class\")\n\t\t\t\t.serialize(archenemies);\n\n\t\t\tPair<Hero, Villian> deserialArchEnemies = jsonParser\n\t\t\t\t.map(\"first\", Hero.class)\n\t\t\t\t.map(\"second\", Villian.class)\n\t\t\t\t.parse(json, Pair.class);\n\n\t\t\tassertEquals(archenemies.getFirst().getClass(), deserialArchEnemies.getFirst().getClass());\n\t\t\tassertEquals(archenemies.getSecond().getClass(), deserialArchEnemies.getSecond().getClass());\n\n\t\t\tassertEquals(archenemies.getFirst().getIdentity(), deserialArchEnemies.getFirst().getIdentity());\n\t\t\tassertEquals(archenemies.getFirst().getLair(), deserialArchEnemies.getFirst().getLair());\n\t\t\tassertEquals(archenemies.getFirst().getName(), deserialArchEnemies.getFirst().getName());\n\n\t\t\tassertEquals(archenemies.getSecond().getName(), deserialArchEnemies.getSecond().getName());\n\t\t\tassertEquals(archenemies.getSecond().getLair(), deserialArchEnemies.getSecond().getLair());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testGenericTypeDeserialization2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPair<Hero, Villian> archenemies = new Pair<>(creator.createSuperman(), creator.createLexLuthor());\n\n\t\t\tString json = new JsonSerializer()\n\t\t\t\t.serialize(archenemies);\n\n\t\t\tPair<Hero, Villian> deserialArchEnemies = jsonParser\n\t\t\t\t.map(\"first\", Hero.class)\n\t\t\t\t.map(\"second\", Villian.class)\n\t\t\t\t.parse(json, Pair.class);\n\n\t\t\tassertEquals(archenemies.getFirst().getClass(), deserialArchEnemies.getFirst().getClass());\n\t\t\tassertEquals(archenemies.getSecond().getClass(), deserialArchEnemies.getSecond().getClass());\n\n\t\t\tassertEquals(archenemies.getFirst().getIdentity(), deserialArchEnemies.getFirst().getIdentity());\n\t\t\tassertEquals(archenemies.getFirst().getLair(), deserialArchEnemies.getFirst().getLair());\n\t\t\tassertEquals(archenemies.getFirst().getName(), deserialArchEnemies.getFirst().getName());\n\n\t\t\tassertEquals(archenemies.getSecond().getName(), deserialArchEnemies.getSecond().getName());\n\t\t\tassertEquals(archenemies.getSecond().getLair(), deserialArchEnemies.getSecond().getLair());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testGeneralMapDeserialization() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tString json = new JsonSerializer().exclude(\"*.class\").serialize(creator.createJodder());\n\t\t\tMap<String, Object> deserialized = jsonParser.parse(json);\n\n\t\t\tassertEquals(\"Igor\", deserialized.get(\"firstname\"));\n\t\t\tassertEquals(\"Spasic\", deserialized.get(\"lastname\"));\n\t\t\tassertTrue(Map.class.isAssignableFrom(deserialized.get(\"work\").getClass()));\n\t\t\tassertTrue(Map.class.isAssignableFrom(deserialized.get(\"home\").getClass()));\n\t\t});\n\t}\n\n\t@Test\n\tvoid testGeneralMapDeserialization2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = new JsonSerializer().serialize(creator.createJodder());\n\t\t\tMap<String, Object> deserialized = jsonParser.parse(json);\n\n\t\t\tassertEquals(\"Igor\", deserialized.get(\"firstname\"));\n\t\t\tassertEquals(\"Spasic\", deserialized.get(\"lastname\"));\n\t\t\tassertTrue(Map.class.isAssignableFrom(deserialized.get(\"work\").getClass()));\n\t\t\tassertTrue(Map.class.isAssignableFrom(deserialized.get(\"home\").getClass()));\n\t\t});\n\t}\n\n\t@Test\n\tvoid testListDeserializationNoClass() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\n\t\t\tPerson modesty = creator.createModesty();\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tPerson pedro = creator.createPedro();\n\t\t\tList<Person> list = new ArrayList<>(3);\n\t\t\tlist.add(modesty);\n\t\t\tlist.add(igor);\n\t\t\tlist.add(pedro);\n\n\t\t\tString json = new JsonSerializer().exclude(\"*.class\").serialize(list);\n\t\t\tList<Person> people = jsonParser.map(\"values\", Person.class).parse(json);\n\t\t\tassertEquals(3, list.size());\n\t\t\tassertEquals(modesty.getFirstname(), list.get(0).getFirstname());\n\t\t\tassertEquals(igor.getFirstname(), list.get(1).getFirstname());\n\t\t\tassertEquals(pedro.getFirstname(), list.get(2).getFirstname());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testListDeserializationNoClass2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPerson modesty = creator.createModesty();\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tPerson pedro = creator.createPedro();\n\t\t\tList<Person> list = new ArrayList<>(3);\n\t\t\tlist.add(modesty);\n\t\t\tlist.add(igor);\n\t\t\tlist.add(pedro);\n\n\t\t\tString json = new JsonSerializer().serialize(list);\n\t\t\tList<Person> people = jsonParser.map(\"values\", Person.class).parse(json);\n\t\t\tassertEquals(3, list.size());\n\t\t\tassertEquals(modesty.getFirstname(), list.get(0).getFirstname());\n\t\t\tassertEquals(igor.getFirstname(), list.get(1).getFirstname());\n\t\t\tassertEquals(pedro.getFirstname(), list.get(2).getFirstname());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDateTransforming() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tfinal SimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd\");\n\t\t\tPerson foo = new Person(\"Foo\", \"Bar\", new Date(), null, null);\n\t\t\ttry {\n\t\t\t\tfoo.setBirthdate(df.parse(\"2009/01/02\"));\n\t\t\t} catch (ParseException pe) {\n\t\t\t\tfail(pe);\n\t\t\t}\n\n\n\t\t\tString json = new JsonSerializer().withSerializer(\"birthdate\", new DateJsonSerializer() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean serialize(JsonContext jsonContext, Date date) {\n\t\t\t\t\tjsonContext.writeString(df.format(date));\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}).serialize(foo);\n\n\t\t\tPerson newUser = jsonParser\n\t\t\t\t.withValueConverter(\"birthdate\", (ValueConverter<String, Date>) data -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn df.parse(data);\n\t\t\t\t\t} catch (ParseException pe) {\n\t\t\t\t\t\tthrow new JsonException(pe);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.parse(json, Person.class);\n\n\t\t\tassertEquals(foo.getBirthdate(), newUser.getBirthdate());\n\t\t\tassertEquals(\"2009/01/02\", df.format(newUser.getBirthdate()));\n\t\t});\n\t}\n\n\t@Test\n\tvoid testMapWithEmbeddedObject() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tMap<String, Network> networks = jsonParser\n\t\t\t\t.setClassMetadataName(\"class\")\n\t\t\t\t.parse(\"{\\\"1\\\": {\\\"class\\\":\\\"\" + Network.class.getName() + \"\\\", \\\"name\\\": \\\"Jodd\\\"} }\");\n\n\t\t\tassertNotNull(networks);\n\t\t\tassertEquals(1, networks.size());\n\t\t\tassertTrue(networks.containsKey(\"1\"));\n\t\t\tassertNotNull(networks.get(\"1\"));\n\t\t\tassertEquals(Network.class, networks.get(\"1\").getClass());\n\t\t\tassertEquals(\"Jodd\", networks.get(\"1\").getName());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testMapWithEmbeddedObject2() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tMap<String, Pair<Phone, Network>> complex = jsonParser\n\t\t\t\t.map(\"values\", Pair.class)\n\t\t\t\t.map(\"values.first\", Phone.class)\n\t\t\t\t.map(\"values.second\", Network.class)\n\t\t\t\t.parse(\"{\\\"1\\\": { \\\"first\\\": { \\\"areaCode\\\": \\\"404\\\" }, \\\"second\\\": {\\\"name\\\": \\\"Jodd\\\"} } }\");\n\t\t\tassertNotNull(complex);\n\t\t\tassertEquals(1, complex.size());\n\t\t\tassertTrue(complex.containsKey(\"1\"));\n\t\t\tassertNotNull(complex.get(\"1\"));\n\t\t\tassertEquals(Pair.class, complex.get(\"1\").getClass());\n\t\t\tassertEquals(Phone.class, complex.get(\"1\").getFirst().getClass());\n\t\t\tassertEquals(Network.class, complex.get(\"1\").getSecond().getClass());\n\t\t\tassertEquals(\"404\", complex.get(\"1\").getFirst().getAreaCode());\n\t\t\tassertEquals(\"Jodd\", complex.get(\"1\").getSecond().getName());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testListWithEmbeddedObject() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tList<Network> networks = jsonParser\n\t\t\t\t.setClassMetadataName(\"class\")\n\t\t\t\t.parse(\"[\" +\n\t\t\t\t\t\"\t{\\\"class\\\":\\\"\" + Network.class.getName() + \"\\\", \\\"name\\\": \\\"Jodd\\\"},\" +\n\t\t\t\t\t\"\t{\\\"class\\\":\\\"\" + Network.class.getName() + \"\\\", \\\"name\\\": \\\"Mojo\\\"}\" +\n\t\t\t\t\t\"]\");\n\n\t\t\tassertNotNull(networks);\n\t\t\tassertEquals(2, networks.size());\n\t\t\tNetwork network = networks.get(0);\n\t\t\tassertEquals(\"Jodd\", network.getName());\n\t\t\tnetwork = networks.get(1);\n\t\t\tassertEquals(\"Mojo\", network.getName());\n\t\t});\n\t}\n\n\n\t@Test\n\tvoid testArrayType() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPerson igor = creator.createJodder();\n\t\t\tPerson modesty = creator.createModesty();\n\n\t\t\tGroup group = new Group(\"brothers\", igor, modesty);\n\t\t\tString json = new JsonSerializer().include(\"people\").exclude(\"*.class\").serialize(group);\n\t\t\tGroup bro = jsonParser.map(Group.class).parse(json);\n\n\t\t\tassertNotNull(bro);\n\t\t\tassertEquals(\"brothers\", bro.getGroupName());\n\t\t\tassertEquals(2, bro.getPeople().length);\n\t\t\tassertEquals(\"Igor\", bro.getPeople()[0].getFirstname());\n\t\t\tassertEquals(\"Modesty\", bro.getPeople()[1].getFirstname());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testEmptyArray() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tGroup group = jsonParser.parse(\"{\\\"people\\\": [], \\\"groupName\\\": \\\"Nobody\\\" }\", Group.class);\n\t\t\tassertEquals(\"Nobody\", group.getGroupName());\n\t\t\tassertEquals(0, group.getPeople().length);\n\t\t});\n\t}\n\n\n\t@Test\n\tvoid testNullDeserialization() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString input = \"{\\\"property\\\": null, \\\"property2\\\":5, \\\"property3\\\":\\\"abc\\\"}\";\n\n\t\t\tJsonParser deserializer = jsonParser;\n\t\t\tdeserializer.map(null, HashMap.class);\n\t\t\tMap<String, Object> result = deserializer.parse(input);\n\n\t\t\tassertNotNull(result);\n\t\t\t// fails on this line, because the first property is not deserialized\n\t\t\tassertEquals(3, result.size());\n\t\t\tassertTrue(result.containsKey(\"property\"));\n\t\t\tassertNull(result.get(\"property\"), \"the value should be null\");\n\t\t});\n\t}\n\n\t@Test\n\tvoid testPrimitives() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tList<Date> dates = new ArrayList<>();\n\t\t\tdates.add(new Date());\n\t\t\tdates.add(new Date(1970, 1, 12));\n\t\t\tdates.add(new Date(1986, 3, 21));\n\n\t\t\tString json = new JsonSerializer().serialize(dates);\n\t\t\tList<Date> jsonDates = jsonParser\n\t\t\t\t.map(null, ArrayList.class)\n\t\t\t\t.map(\"values\", Date.class)\n\t\t\t\t.parse(json);\n\n\t\t\tassertEquals(jsonDates.size(), dates.size());\n\t\t\tassertEquals(Date.class, jsonDates.get(0).getClass());\n\t\t});\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tList<? extends Number> numbers = Arrays.asList(1, 0.5, 100.4f, (short) 5);\n\t\t\tString json = new JsonSerializer().serialize(numbers);\n\t\t\tList<Number> jsonNumbers = jsonParser.parse(json);\n\n\t\t\tassertEquals(numbers.size(), jsonNumbers.size());\n\t\t\tfor (int i = 0; i < numbers.size(); i++) {\n\t\t\t\tassertEquals(numbers.get(i).floatValue(), jsonNumbers.get(i).floatValue(), DELTA);\n\t\t\t}\n\n\t\t\tassertEquals(numbers.size(), jsonNumbers.size());\n\t\t});\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tList<Boolean> bools = Arrays.asList(true, false, true, false, false);\n\t\t\tString json = new JsonSerializer().serialize(bools);\n\t\t\tList<Boolean> jsonBools = jsonParser.parse(json);\n\n\t\t\tassertEquals(bools.size(), jsonBools.size());\n\t\t\tfor (int i = 0; i < bools.size(); i++) {\n\t\t\t\tassertEquals(bools.get(i), jsonBools.get(i));\n\t\t\t}\n\t\t});\n\t}\n\n\t@Test\n\tvoid testArray() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tPerson[] p = new Person[3];\n\t\t\tp[0] = creator.createJodder();\n\t\t\tp[1] = creator.createDilbert();\n\t\t\tp[2] = creator.createModesty();\n\n\t\t\tString json = new JsonSerializer().serialize(p);\n\n\t\t\tPerson[] jsonP = jsonParser.parse(json, Person[].class);\n\n\t\t\tassertEquals(3, jsonP.length);\n\t\t\tassertEquals(\"Igor\", jsonP[0].getFirstname());\n\t\t\tassertEquals(\"Dilbert\", jsonP[1].getFirstname());\n\t\t\tassertEquals(\"Modesty\", jsonP[2].getFirstname());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testArray_boolean() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tfinal boolean[] input = new boolean[]{true, false, true};\n\t\t\tfinal boolean[] expected_bools = input;\n\t\t\tfinal String expected_json = \"[true,false,true]\";\n\n\t\t\tfinal String actual_json = new JsonSerializer().serialize(input);\n\t\t\tfinal boolean[] actual_bools = jsonParser.parse(actual_json, boolean[].class);\n\n\t\t\t// asserts\n\t\t\tassertNotNull(actual_json);\n\t\t\tassertNotNull(actual_bools);\n\t\t\tassertEquals(expected_json, actual_json);\n\t\t\tassertArrayEquals(expected_bools, actual_bools);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializationIntoPublicFields() {\n\t\tJsonParser.Defaults.classMetadataName = \"class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tSpiderman spiderman = new Spiderman();\n\t\t\tspiderman.spideySense = false;\n\t\t\tspiderman.superpower = \"Creates Many Webs and Super Tough\";\n\n\t\t\tString json = new JsonSerializer().serialize(spiderman);\n\t\t\tSpiderman jsonSpiderman = jsonParser.parse(json);\n\n\t\t\tassertEquals(spiderman.spideySense, jsonSpiderman.spideySense);\n\t\t\tassertEquals(spiderman.superpower, jsonSpiderman.superpower);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testAutoTypeConvertToNumerical() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tAccount account = jsonParser\n\t\t\t\t.parse(\"{\\\"id\\\": \\\"5\\\", \\\"accountNumber\\\": \\\"1234567-123\\\"}\", Account.class);\n\t\t\tassertEquals(new Integer(5), account.getId());\n\n\t\t\tXRayVision xray = jsonParser.parse(\"{ \\\"power\\\": \\\"2.3\\\" }\", XRayVision.class);\n\t\t\tassertEquals(2.3f, xray.getPower(), DELTA);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testDeserializeURL() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = \"{\\n\" +\n\t\t\t\t\"  \\\"oslc_cm:next\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/results\\\\/3\\\",\\n\" +\n\t\t\t\t\"  \\\"oslc_cm:previous\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/results\\\\/1\\\", \\n\" +\n\t\t\t\t\"  \\\"oslc_cm:totalCount\\\" : 27,\\n\" +\n\t\t\t\t\"  \\\"oslc_cm:results\\\": [\\n\" +\n\t\t\t\t\"    {\\n\" +\n\t\t\t\t\"      \\\"rdf:resource\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/records\\\\/1234\\\"\\n\" +\n\t\t\t\t\"    },\\n\" +\n\t\t\t\t\"    {\\n\" +\n\t\t\t\t\"      \\\"rdf:resource\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/records\\\\/1235\\\"\\n\" +\n\t\t\t\t\"    },\\n\" +\n\t\t\t\t\"    {\\n\" +\n\t\t\t\t\"      \\\"rdf:resource\\\": \\\"http:\\\\/\\\\/localhost:9080\\\\/records\\\\/1236\\\"\\n\" +\n\t\t\t\t\"    }   \\n\" +\n\t\t\t\t\"  ]\\n\" +\n\t\t\t\t\"}\";\n\t\t\tMap<String, Object> page2 = jsonParser.parse(json);\n\t\t\tassertEquals(\"http://localhost:9080/results/3\", page2.get(\"oslc_cm:next\"));\n\t\t\tassertEquals(3, ((List) page2.get(\"oslc_cm:results\")).size());\n\t\t});\n\t}\n\n\t@Test\n\tvoid testPoint() {\n\t\tJsonParser.Defaults.classMetadataName = \"__class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"__class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tString json = new JsonSerializer().serialize(new Point2D.Float(1.0f, 2.0f));\n\t\t\tPoint2D.Float point = jsonParser.parse(json);\n\t\t\tassertEquals(1.0f, point.x, DELTA);\n\t\t\tassertEquals(2.0f, point.y, DELTA);\n\t\t});\n\t}\n\n\t@Test\n\tvoid testPointWithException() {\n\t\tJsonParser.Defaults.classMetadataName = \"__class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"__class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tjsonParser.allowClass(\"notAllowed\");\n\t\t\tfinal String json = new JsonSerializer().serialize(new Point2D.Float(1.0f, 2.0f));\n\t\t\tassertThrows(JsonException.class, () -> {\n\t\t\t\tjsonParser.parse(json);\n\t\t\t});\n\t\t\tjsonParser.allowAllClasses();\n\t\t});\n\t}\n\n\t@Test\n\tvoid testPointWithoutExceptionWhitelisted() {\n\t\tJsonParser.Defaults.classMetadataName = \"__class\";\n\t\tJsonSerializer.Defaults.classMetadataName = \"__class\";\n\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tjsonParser.allowClass(\"*.Point?D*\");\n\t\t\tString json = new JsonSerializer().serialize(new Point2D.Float(1.0f, 2.0f));\n\t\t\tPoint2D.Float point = jsonParser.parse(json);\n\t\t\tassertEquals(1.0f, point.x, DELTA);\n\t\t\tassertEquals(2.0f, point.y, DELTA);\n\t\t\tjsonParser.allowAllClasses();\n\t\t});\n\t}\n\n\n\t@Test\n\tvoid testUnixEpoch() {\n\t\tJsonParsers.forEachParser(jsonParser -> {\n\t\t\tCalendar cal = Calendar.getInstance();\n\t\t\tcal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n\n\t\t\tcal.set(Calendar.YEAR, 1970);\n\t\t\tcal.set(Calendar.MONTH, 0);\n\t\t\tcal.set(Calendar.DAY_OF_MONTH, 1);\n\t\t\tcal.set(Calendar.AM_PM, Calendar.AM);\n\t\t\tcal.set(Calendar.HOUR, 0);\n\t\t\tcal.set(Calendar.MINUTE, 0);\n\t\t\tcal.set(Calendar.SECOND, 0);\n\t\t\tcal.set(Calendar.MILLISECOND, 0);\n\n\t\t\tPerson hank = new Person(\"Hank\", \"Paulsen\", cal.getTime(), null, null);\n\n\t\t\tString json = new JsonSerializer().serialize(hank);\n\t\t\tPerson deHank = jsonParser.parse(json, Person.class);\n\n\t\t\tassertEquals(hank.getFirstname(), deHank.getFirstname());\n\t\t\tassertEquals(hank.getLastname(), deHank.getLastname());\n\t\t\tassertEquals(hank.getBirthdate(), deHank.getBirthdate());\n\t\t});\n\t}\n\n\tpublic static class SimpleClassnameTransformer implements TypeJsonSerializer {\n\t\t@Override\n\t\tpublic boolean serialize(JsonContext jsonContext, Object value) {\n\t\t\tString name = value.toString() + \"***\";\n\t\t\tjsonContext.writeString(name);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate void assertHeroHasSuperPowers(Hero hero) {\n\t\tfor (int i = 0; i < hero.getPowers().size(); i++) {\n\t\t\tassertTrue(hero.getPowers().get(i) instanceof SuperPower);\n\t\t}\n\t}\n\n}\n"], "filenames": ["CHANGELOG.md", "jodd-json/src/main/java/jodd/json/JsonParser.java", "jodd-json/src/main/java/jodd/json/JsonParserBase.java", "jodd-json/src/main/java/jodd/json/MapToBean.java", "jodd-json/src/test/java/jodd/json/JSONDeserializerTest.java"], "buggy_code_start_loc": [26, 38, 57, 34, 64], "buggy_code_end_loc": [26, 309, 57, 147, 712], "fixing_code_start_loc": [27, 39, 58, 35, 65], "fixing_code_end_loc": [28, 331, 59, 162, 745], "type": "CWE-502", "message": "Jodd before 5.0.4 performs Deserialization of Untrusted JSON Data when setClassMetadataName is set.", "other": {"cve": {"id": "CVE-2018-21234", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-21T23:15:11.103", "lastModified": "2022-04-22T18:53:47.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Jodd before 5.0.4 performs Deserialization of Untrusted JSON Data when setClassMetadataName is set."}, {"lang": "es", "value": "Jodd versiones anteriores a la versi\u00f3n 5.0.4, realiza una Deserializaci\u00f3n de Datos JSON No Confiables, cuando se establece la funci\u00f3n setClassMetadataName."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jodd:jodd:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.4", "matchCriteriaId": "BD427A38-CFDA-4A9B-ADD2-F56A19928CDD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:hive:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "88DA79E9-51EC-459A-A393-72BF6E8013A2"}]}]}], "references": [{"url": "https://github.com/oblac/jodd/commit/9bffc3913aeb8472c11bb543243004b4b4376f16", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/oblac/jodd/compare/v5.0.3...v5.0.4", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/oblac/jodd/issues/628", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r0bacc701ab7105500a0ab2769270d18f332cb379e6a62ec7553f3327@%3Cissues.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r157d01c96a2c10e7ceb3e005f42c52cfe87b11dd018935e1c4277433@%3Cgitbox.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r317aec95c436848233047af7ecb3ce04ce446eb6031f981aef50df0d@%3Cdev.drill.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r729bc1e0f367fe8a857ac8a14641dba284ac4cf5131edf483022cf59@%3Cissues.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r965503b27d67a2d934e34fc1d088c9547d51d927c43b8b9bd9b7e695@%3Cissues.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc23200043872384e0fc48a4a4502f4c6b4b5ddc79ba4076414150d59@%3Cissues.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc85b650b4ad2c77d7c39c69824488e40dce6d0ebbb4204777d094375@%3Cgitbox.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd575d9877424a2d8776f5c2ff33bf3dc3382cd83f031d483f29c11ab@%3Cissues.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdbb99b43334b59d3d3478d360c87e3235ba22edb1de7d39019194347@%3Cissues.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdce006b282e56c5cc73cdf452c51c5097154d0503396d62f48abbeae@%3Cgitbox.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf458683390d6650b26a2c8ba8ad396e038e520ad1cc3f3f1e20514d9@%3Cdev.hive.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/oblac/jodd/commit/9bffc3913aeb8472c11bb543243004b4b4376f16"}}