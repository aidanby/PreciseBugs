{"buggy_code": ["<?php\n/**\n * MyBB 1.8\n * Copyright 2014 MyBB Group, All Rights Reserved\n *\n * Website: http://www.mybb.com\n * License: http://www.mybb.com/about/license\n *\n */\n\n/*\noptions = array(\n\tallow_html\n\tallow_smilies\n\tallow_mycode\n\tnl2br\n\tfilter_badwords\n\tme_username\n\tshorten_urls\n\thighlight\n\tfilter_cdata\n)\n*/\n\nclass postParser\n{\n\t/**\n\t * Internal cache of MyCode.\n\t *\n\t * @access public\n\t * @var mixed\n\t */\n\tpublic $mycode_cache = 0;\n\n\t/**\n\t * Internal cache of smilies\n\t *\n\t * @access public\n\t * @var mixed\n\t */\n\tpublic $smilies_cache = 0;\n\n\t/**\n\t * Internal cache of badwords filters\n\t *\n\t * @access public\n\t * @var mixed\n\t */\n\tpublic $badwords_cache = 0;\n\n\t/**\n\t * Base URL for smilies\n\t *\n\t * @access public\n\t * @var string\n\t */\n\tpublic $base_url;\n\n\t/**\n\t * Parsed Highlights cache\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $highlight_cache = array();\n\n\t/**\n\t * Options for this parsed message\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $options;\n\n\t/**\n\t * Internal cache for nested lists\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $list_elements;\n\n\t/**\n\t * Internal counter for nested lists\n\t *\n\t * @access public\n\t * @var int\n\t */\n\tpublic $list_count;\n\n\t/**\n\t * Whether or not should a <br /> with clear: both be added at the end of the parsed message\n\t *\n\t * @access public\n\t * @var boolean\n\t */\n\tpublic $clear_needed = false;\n\n\t/**\n\t * Parses a message with the specified options.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @param array $options Array of yes/no options - allow_html,filter_badwords,allow_mycode,allow_smilies,nl2br,me_username,filter_cdata.\n\t * @return string The parsed message.\n\t */\n\tfunction parse_message($message, $options=array())\n\t{\n\t\tglobal $plugins, $mybb;\n\n\t\t$this->clear_needed = false;\n\n\t\t// Set base URL for parsing smilies\n\t\t$this->base_url = $mybb->settings['bburl'];\n\n\t\tif($this->base_url != \"\")\n\t\t{\n\t\t\tif(my_substr($this->base_url, my_strlen($this->base_url) -1) != \"/\")\n\t\t\t{\n\t\t\t\t$this->base_url = $this->base_url.\"/\";\n\t\t\t}\n\t\t}\n\n\t\t// Set the options\n\t\t$this->options = $options;\n\n\t\t$message = $plugins->run_hooks(\"parse_message_start\", $message);\n\n\t\t// Get rid of carriage returns for they are the workings of the devil\n\t\t$message = str_replace(\"\\r\", \"\", $message);\n\n\t\t// Filter bad words if requested.\n\t\tif(!empty($this->options['filter_badwords']))\n\t\t{\n\t\t\t$message = $this->parse_badwords($message);\n\t\t}\n\n\t\t// Filter CDATA tags if requested (syndication.php).\n\t\tif(!empty($this->options['filter_cdata']))\n\t\t{\n\t\t\t$message = $this->parse_cdata($message);\n\t\t}\n\n\t\t// If MyCode needs to be replaced, first filter out [code] and [php] tags.\n\t\t$code_matches = array();\n\t\tif(!empty($this->options['allow_mycode']) && $mybb->settings['allowcodemycode'] == 1)\n\t\t{\n\t\t\t// This code is reserved and could break codes\n\t\t\t$message = str_replace(\"<mybb-code>\\n\", \"<mybb_code>\\n\", $message);\n\n\t\t\tpreg_match_all(\"#\\[(code|php)\\](.*?)(\\[/\\\\1\\])+(\\r\\n?|\\n?)#si\", $message, $code_matches, PREG_SET_ORDER);\n\t\t\tforeach($code_matches as $point => $part)\n\t\t\t{\n\t\t\t\tif(isset($part[3]))\n\t\t\t\t{\n\t\t\t\t\t$part[1] = \"[\".$part[1].\"]\";\n\t\t\t\t\t$code_matches[$point][2] = substr_replace($part[0], \"\", strrpos($part[0], $part[3]), strlen($part[3]));\n\t\t\t\t\t$code_matches[$point][2] = substr_replace($code_matches[$point][2], \"\", strpos($code_matches[$point][2], $part[1]), strlen($part[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t$message = preg_replace(\"#\\[(code|php)\\](.*?)(\\[/\\\\1\\])+(\\r\\n?|\\n?)#si\", \"<mybb-code>\\n\", $message);\n\t\t}\n\n\t\tif(empty($this->options['allow_html']))\n\t\t{\n\t\t\t$message = $this->parse_html($message);\n\t\t\t$message = str_replace(\"&lt;mybb-code&gt;\\n\", \"<mybb-code>\\n\", $message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Replace base, meta,script and style tags in our post - these are > dangerous <\n\t\t\t$message = preg_replace('#<(/?)(base|meta|script|style)([^>]*)>#i', '&lt;$1$2$3&gt;', $message);\n\t\t\t$message = $this->fix_javascript($message);\n\n\t\t\t$find = array(\"<br />\\n\", \"<br>\\n\");\n\t\t\t$replace = array(\"\\n\", \"\\n\");\n\t\t\t$message = str_replace($find, $replace, $message);\n\t\t}\n\n\t\t$message = $plugins->run_hooks(\"parse_message_htmlsanitized\", $message);\n\n\t\t// Replace \"me\" code and slaps if we have a username\n\t\tif(!empty($this->options['me_username']) && $mybb->settings['allowmemycode'] == 1)\n\t\t{\n\t\t\tglobal $lang;\n\n\t\t\t$message = preg_replace('#(>|^|\\r|\\n)/me ([^\\r\\n<]*)#i', \"\\\\1<span style=\\\"color: red;\\\" class=\\\"mycode_me\\\">* {$this->options['me_username']} \\\\2</span>\", $message);\n\t\t\t$message = preg_replace('#(>|^|\\r|\\n)/slap ([^\\r\\n<]*)#i', \"\\\\1<span style=\\\"color: red;\\\" class=\\\"mycode_slap\\\">* {$this->options['me_username']} {$lang->slaps} \\\\2 {$lang->with_trout}</span>\", $message);\n\t\t}\n\n\t\t$message = $plugins->run_hooks(\"parse_message_me_mycode\", $message);\n\n\t\t// If we can, parse smilies\n\t\tif(!empty($this->options['allow_smilies']))\n\t\t{\n\t\t\t$message = $this->parse_smilies($message, $this->options['allow_html']);\n\t\t}\n\n\t\t// Replace MyCode if requested.\n\t\tif(!empty($this->options['allow_mycode']))\n\t\t{\n\t\t\t$message = $this->parse_mycode($message);\n\t\t}\n\n\t\t// Filter url codes, if disabled.\n\t\tif($mybb->settings['allowlinkmycode'] != 1)\n\t\t{\n\t\t\t$message = preg_replace(\"#\\[(\\/)?url{1}(.*?)\\]#i\", \"\", $message);\n\t\t}\n\n\t\t// Parse Highlights\n\t\tif(!empty($this->options['highlight']))\n\t\t{\n\t\t\t$message = $this->highlight_message($message, $this->options['highlight']);\n\t\t}\n\n\t\t// Run plugin hooks\n\t\t$message = $plugins->run_hooks(\"parse_message\", $message);\n\n\t\tif(!empty($this->options['allow_mycode']))\n\t\t{\n\t\t\t// Now that we're done, if we split up any code tags, parse them and glue it all back together\n\t\t\tif(count($code_matches) > 0)\n\t\t\t{\n\t\t\t\tforeach($code_matches as $text)\n\t\t\t\t{\n\t\t\t\t\tif(my_strtolower($text[1]) == \"code\")\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fix up HTML inside the code tags so it is clean\n\t\t\t\t\t\t$text[2] = $this->parse_html($text[2]);\n\n\t\t\t\t\t\t$code = $this->mycode_parse_code($text[2]);\n\t\t\t\t\t}\n\t\t\t\t\telseif(my_strtolower($text[1]) == \"php\")\n\t\t\t\t\t{\n\t\t\t\t\t\t$code = $this->mycode_parse_php($text[2]);\n\t\t\t\t\t}\n\t\t\t\t\t$message = preg_replace(\"#\\<mybb-code>\\n?#\", $code, $message, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!isset($this->options['nl2br']) || $this->options['nl2br'] != 0)\n\t\t{\n\t\t\t$message = nl2br($message);\n\t\t\t// Fix up new lines and block level elements\n\t\t\t$message = preg_replace(\"#(</?(?:html|head|body|div|p|form|table|thead|tbody|tfoot|tr|td|th|ul|ol|li|div|p|blockquote|cite|hr)[^>]*>)\\s*<br />#i\", \"$1\", $message);\n\t\t\t$message = preg_replace(\"#(&nbsp;)+(</?(?:html|head|body|div|p|form|table|thead|tbody|tfoot|tr|td|th|ul|ol|li|div|p|blockquote|cite|hr)[^>]*>)#i\", \"$2\", $message);\n\t\t}\n\n\t\tif($this->clear_needed)\n\t\t{\n\t\t\t$message .= '<br class=\"clear\" />';\n\t\t}\n\n\t\t$message = $plugins->run_hooks(\"parse_message_end\", $message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Converts HTML in a message to their specific entities whilst allowing unicode characters.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @return string The formatted message.\n\t */\n\tfunction parse_html($message)\n\t{\n\t\t$message = preg_replace(\"#&(?!\\#[0-9]+;)#si\", \"&amp;\", $message); // fix & but allow unicode\n\t\t$message = str_replace(\"<\",\"&lt;\",$message);\n\t\t$message = str_replace(\">\",\"&gt;\",$message);\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Generates a cache of MyCode, both standard and custom.\n\t *\n\t * @access private\n\t */\n\tfunction cache_mycode()\n\t{\n\t\tglobal $cache, $lang, $mybb;\n\t\t$this->mycode_cache = array();\n\n\t\t$standard_mycode = $callback_mycode = $nestable_mycode = array();\n\t\t$standard_count = $callback_count = $nestable_count = 0;\n\n\t\tif($mybb->settings['allowbasicmycode'] == 1)\n\t\t{\n\t\t\t$standard_mycode['b']['regex'] = \"#\\[b\\](.*?)\\[/b\\]#si\";\n\t\t\t$standard_mycode['b']['replacement'] = \"<span style=\\\"font-weight: bold;\\\" class=\\\"mycode_b\\\">$1</span>\";\n\n\t\t\t$standard_mycode['u']['regex'] = \"#\\[u\\](.*?)\\[/u\\]#si\";\n\t\t\t$standard_mycode['u']['replacement'] = \"<span style=\\\"text-decoration: underline;\\\" class=\\\"mycode_u\\\">$1</span>\";\n\n\t\t\t$standard_mycode['i']['regex'] = \"#\\[i\\](.*?)\\[/i\\]#si\";\n\t\t\t$standard_mycode['i']['replacement'] = \"<span style=\\\"font-style: italic;\\\" class=\\\"mycode_i\\\">$1</span>\";\n\n\t\t\t$standard_mycode['s']['regex'] = \"#\\[s\\](.*?)\\[/s\\]#si\";\n\t\t\t$standard_mycode['s']['replacement'] = \"<span style=\\\"text-decoration: line-through;\\\" class=\\\"mycode_s\\\">$1</span>\";\n\n\t\t\t$standard_mycode['hr']['regex'] = \"#\\[hr\\]#si\";\n\t\t\t$standard_mycode['hr']['replacement'] = \"<hr class=\\\"mycode_hr\\\" />\";\n\n\t\t\t++$standard_count;\n\t\t}\n\n\t\tif($mybb->settings['allowsymbolmycode'] == 1)\n\t\t{\n\t\t\t$standard_mycode['copy']['regex'] = \"#\\(c\\)#i\";\n\t\t\t$standard_mycode['copy']['replacement'] = \"&copy;\";\n\n\t\t\t$standard_mycode['tm']['regex'] = \"#\\(tm\\)#i\";\n\t\t\t$standard_mycode['tm']['replacement'] = \"&#153;\";\n\n\t\t\t$standard_mycode['reg']['regex'] = \"#\\(r\\)#i\";\n\t\t\t$standard_mycode['reg']['replacement'] = \"&reg;\";\n\n\t\t\t++$standard_count;\n\t\t}\n\n\t\tif($mybb->settings['allowlinkmycode'] == 1)\n\t\t{\n\t\t\t$callback_mycode['url_simple']['regex'] = \"#\\[url\\]((?!javascript)[a-z]+?://)([^\\r\\n\\\"<]+?)\\[/url\\]#si\";\n\t\t\t$callback_mycode['url_simple']['replacement'] = array($this, 'mycode_parse_url_callback1');\n\n\t\t\t$callback_mycode['url_simple2']['regex'] = \"#\\[url\\]((?!javascript:)[^\\r\\n\\\"<]+?)\\[/url\\]#i\";\n\t\t\t$callback_mycode['url_simple2']['replacement'] = array($this, 'mycode_parse_url_callback2');\n\n\t\t\t$callback_mycode['url_complex']['regex'] = \"#\\[url=((?!javascript)[a-z]+?://)([^\\r\\n\\\"<]+?)\\](.+?)\\[/url\\]#si\";\n\t\t\t$callback_mycode['url_complex']['replacement'] = array($this, 'mycode_parse_url_callback1');\n\n\t\t\t$callback_mycode['url_complex2']['regex'] = \"#\\[url=((?!javascript:)[^\\r\\n\\\"<]+?)\\](.+?)\\[/url\\]#si\";\n\t\t\t$callback_mycode['url_complex2']['replacement'] = array($this, 'mycode_parse_url_callback2');\n\n\t\t\t++$callback_count;\n\t\t}\n\n\t\tif($mybb->settings['allowemailmycode'] == 1)\n\t\t{\n\t\t\t$callback_mycode['email_simple']['regex'] = \"#\\[email\\]((?:[a-zA-Z0-9-_\\+\\.]+?)@[a-zA-Z0-9-]+\\.[a-zA-Z0-9\\.-]+(?:\\?.*?)?)\\[/email\\]#i\";\n\t\t\t$callback_mycode['email_simple']['replacement'] = array($this, 'mycode_parse_email_callback');\n\n\t\t\t$callback_mycode['email_complex']['regex'] = \"#\\[email=((?:[a-zA-Z0-9-_\\+\\.]+?)@[a-zA-Z0-9-]+\\.[a-zA-Z0-9\\.-]+(?:\\?.*?)?)\\](.*?)\\[/email\\]#i\";\n\t\t\t$callback_mycode['email_complex']['replacement'] = array($this, 'mycode_parse_email_callback');\n\n\t\t\t++$callback_count;\n\t\t}\n\n\t\tif($mybb->settings['allowcolormycode'] == 1)\n\t\t{\n\t\t\t$nestable_mycode['color']['regex'] = \"#\\[color=([a-zA-Z]*|\\#?[\\da-fA-F]{3}|\\#?[\\da-fA-F]{6})](.*?)\\[/color\\]#si\";\n\t\t\t$nestable_mycode['color']['replacement'] = \"<span style=\\\"color: $1;\\\" class=\\\"mycode_color\\\">$2</span>\";\n\n\t\t\t++$nestable_count;\n\t\t}\n\n\t\tif($mybb->settings['allowsizemycode'] == 1)\n\t\t{\n\t\t\t$nestable_mycode['size']['regex'] = \"#\\[size=(xx-small|x-small|small|medium|large|x-large|xx-large)\\](.*?)\\[/size\\]#si\";\n\t\t\t$nestable_mycode['size']['replacement'] = \"<span style=\\\"font-size: $1;\\\" class=\\\"mycode_size\\\">$2</span>\";\n\n\t\t\t$callback_mycode['size_int']['regex'] = \"#\\[size=([0-9\\+\\-]+?)\\](.*?)\\[/size\\]#si\";\n\t\t\t$callback_mycode['size_int']['replacement'] = array($this, 'mycode_handle_size_callback');\n\n\t\t\t++$nestable_count;\n\t\t\t++$callback_count;\n\t\t}\n\n\t\tif($mybb->settings['allowfontmycode'] == 1)\n\t\t{\n\t\t\t$nestable_mycode['font']['regex'] = \"#\\[font=(\\\"?)([a-z0-9 ,\\-_']+)\\\\1\\](.*?)\\[/font\\]#si\";\n\t\t\t$nestable_mycode['font']['replacement'] = \"<span style=\\\"font-family: $2;\\\" class=\\\"mycode_font\\\">$3</span>\";\n\n\t\t\t++$nestable_count;\n\t\t}\n\n\t\tif($mybb->settings['allowalignmycode'] == 1)\n\t\t{\n\t\t\t$nestable_mycode['align']['regex'] = \"#\\[align=(left|center|right|justify)\\](.*?)\\[/align\\]#si\";\n\t\t\t$nestable_mycode['align']['replacement'] = \"<div style=\\\"text-align: $1;\\\" class=\\\"mycode_align\\\">$2</div>\";\n\n\t\t\t++$nestable_count;\n\t\t}\n\n\t\t$custom_mycode = $cache->read(\"mycode\");\n\n\t\t// If there is custom MyCode, load it.\n\t\tif(is_array($custom_mycode))\n\t\t{\n\t\t\tforeach($custom_mycode as $key => $mycode)\n\t\t\t{\n\t\t\t\t$mycode['regex'] = str_replace(\"\\x0\", \"\", $mycode['regex']);\n\t\t\t\t$custom_mycode[$key]['regex'] = \"#\".$mycode['regex'].\"#si\";\n\n\t\t\t\t++$standard_count;\n\t\t\t}\n\t\t\t$mycode = array_merge($standard_mycode, $custom_mycode);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$mycode = $standard_mycode;\n\t\t}\n\n\t\t// Assign the MyCode to the cache.\n\t\tforeach($mycode as $code)\n\t\t{\n\t\t\t$this->mycode_cache['standard']['find'][] = $code['regex'];\n\t\t\t$this->mycode_cache['standard']['replacement'][] = $code['replacement'];\n\t\t}\n\n\t\t// Assign the nestable MyCode to the cache.\n\t\tforeach($nestable_mycode as $code)\n\t\t{\n\t\t\t$this->mycode_cache['nestable'][] = array('find' => $code['regex'], 'replacement' => $code['replacement']);\n\t\t}\n\n\t\t// Assign the nestable MyCode to the cache.\n\t\tforeach($callback_mycode as $code)\n\t\t{\n\t\t\t$this->mycode_cache['callback'][] = array('find' => $code['regex'], 'replacement' => $code['replacement']);\n\t\t}\n\n\t\t$this->mycode_cache['standard_count'] = $standard_count;\n\t\t$this->mycode_cache['callback_count'] = $callback_count;\n\t\t$this->mycode_cache['nestable_count'] = $nestable_count;\n\t}\n\n\t/**\n\t * Parses MyCode tags in a specific message with the specified options.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @param array $options Array of options in yes/no format. Options are allow_imgcode.\n\t * @return string The parsed message.\n\t */\n\tfunction parse_mycode($message, $options=array())\n\t{\n\t\tglobal $lang, $mybb;\n\n\t\tif(empty($this->options))\n\t\t{\n\t\t\t$this->options = $options;\n\t\t}\n\n\t\t// Cache the MyCode globally if needed.\n\t\tif($this->mycode_cache == 0)\n\t\t{\n\t\t\t$this->cache_mycode();\n\t\t}\n\n\t\t// Parse quotes first\n\t\t$message = $this->mycode_parse_quotes($message);\n\n\t\t// Convert images when allowed.\n\t\tif(!empty($this->options['allow_imgcode']))\n\t\t{\n\t\t\t$message = preg_replace_callback(\"#\\[img\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_callback1'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_callback2'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img align=(left|right)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_callback3'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*) align=(left|right)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_callback4'), $message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$message = preg_replace_callback(\"#\\[img\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_disabled_callback1'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_disabled_callback2'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img align=(left|right)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_disabled_callback3'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*) align=(left|right)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_disabled_callback4'), $message);\n\t\t}\n\n\t\t// Convert videos when allow.\n\t\tif(!empty($this->options['allow_videocode']))\n\t\t{\n\t\t\t$message = preg_replace_callback(\"#\\[video=(.*?)\\](.*?)\\[/video\\]#i\", array($this, 'mycode_parse_video_callback'), $message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$message = preg_replace_callback(\"#\\[video=(.*?)\\](.*?)\\[/video\\]#i\", array($this, 'mycode_parse_video_disabled_callback'), $message);\n\t\t}\n\n\t\t$message = str_replace('$', '&#36;', $message);\n\n\t\t// Replace the rest\n\t\tif($this->mycode_cache['standard_count'] > 0)\n\t\t{\n\t\t\t$message = preg_replace($this->mycode_cache['standard']['find'], $this->mycode_cache['standard']['replacement'], $message);\n\t\t}\n\n\t\tif($this->mycode_cache['callback_count'] > 0)\n\t\t{\n\t\t\tforeach($this->mycode_cache['callback'] as $replace)\n\t\t\t{\n\t\t\t\t$message = preg_replace_callback($replace['find'], $replace['replacement'], $message);\n\t\t\t}\n\t\t}\n\n\t\t// Replace the nestable mycode's\n\t\tif($this->mycode_cache['nestable_count'] > 0)\n\t\t{\n\t\t\tforeach($this->mycode_cache['nestable'] as $mycode)\n\t\t\t{\n\t\t\t\twhile(preg_match($mycode['find'], $message))\n\t\t\t\t{\n\t\t\t\t\t$message = preg_replace($mycode['find'], $mycode['replacement'], $message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reset list cache\n\t\tif($mybb->settings['allowlistmycode'] == 1)\n\t\t{\n\t\t\t$this->list_elements = array();\n\t\t\t$this->list_count = 0;\n\n\t\t\t// Find all lists\n\t\t\t$message = preg_replace_callback(\"#(\\[list(=(a|A|i|I|1))?\\]|\\[/list\\])#si\", array($this, 'mycode_prepare_list'), $message);\n\n\t\t\t// Replace all lists\n\t\t\tfor($i = $this->list_count; $i > 0; $i--)\n\t\t\t{\n\t\t\t\t// Ignores missing end tags\n\t\t\t\t$message = preg_replace_callback(\"#\\s?\\[list(=(a|A|i|I|1))?&{$i}\\](.*?)(\\[/list&{$i}\\]|$)(\\r\\n?|\\n?)#si\", array($this, 'mycode_parse_list_callback'), $message, 1);\n\t\t\t}\n\t\t}\n\n\t\t$message = $this->mycode_auto_url($message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Generates a cache of smilies\n\t *\n\t * @access private\n\t */\n\tfunction cache_smilies()\n\t{\n\t\tglobal $cache, $mybb, $theme, $templates;\n\t\t$this->smilies_cache = array();\n\n\t\t$smilies = $cache->read(\"smilies\");\n\t\tif(is_array($smilies))\n\t\t{\n\t\t\t$extra_class = $onclick = '';\n\t\t\tforeach($smilies as $sid => $smilie)\n\t\t\t{\n\t\t\t\t$smilie['find'] = explode(\"\\n\", $smilie['find']);\n\t\t\t\t$smilie['image'] = str_replace(\"{theme}\", $theme['imgdir'], $smilie['image']);\n\t\t\t\t$smilie['image'] = htmlspecialchars_uni($mybb->get_asset_url($smilie['image']));\n\t\t\t\t$smilie['name'] = htmlspecialchars_uni($smilie['name']);\n\n\t\t\t\tforeach($smilie['find'] as $s)\n\t\t\t\t{\n\t\t\t\t\t$s = $this->parse_html($s);\n\t\t\t\t\teval(\"\\$smilie_template = \\\"\".$templates->get(\"smilie\", 1, 0).\"\\\";\");\n\t\t\t\t\t$this->smilies_cache[$s] = $smilie_template;\n\t\t\t\t\t// workaround for smilies starting with ;\n\t\t\t\t\tif($s[0] == \";\")\n\t\t\t\t\t{\n\t\t\t\t\t\t$this->smilies_cache += array(\n\t\t\t\t\t\t\t\"&amp$s\" => \"&amp$s\",\n\t\t\t\t\t\t\t\"&lt$s\" => \"&lt$s\",\n\t\t\t\t\t\t\t\"&gt$s\" => \"&gt$s\",\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parses smilie code in the specified message.\n\t *\n\t * @param string $message $message The message being parsed.\n\t * @param int $allow_html not used\n\t * @return string The parsed message.\n\t */\n\tfunction parse_smilies($message, $allow_html=0)\n\t{\n\t\tif($this->smilies_cache == 0)\n\t\t{\n\t\t\t$this->cache_smilies();\n\t\t}\n\n\t\t// No smilies?\n\t\tif(!count($this->smilies_cache))\n\t\t{\n\t\t\treturn $message;\n\t\t}\n\n\t\t// First we take out any of the tags we don't want parsed between (url= etc)\n\t\tpreg_match_all(\"#\\[(url(=[^\\]]*)?\\]|quote=([^\\]]*)?\\])|(http|ftp)(s|)://[^\\s]*#i\", $message, $bad_matches, PREG_PATTERN_ORDER);\n\t\tif(count($bad_matches[0]) > 0)\n\t\t{\n\t\t\t$message = preg_replace(\"#\\[(url(=[^\\]]*)?\\]|quote=([^\\]]*)?\\])|(http|ftp)(s|)://[^\\s]*#si\", \"<mybb-bad-sm>\", $message);\n\t\t}\n\n\t\t$message = strtr($message, $this->smilies_cache);\n\n\t\t// If we matched any tags previously, swap them back in\n\t\tif(count($bad_matches[0]) > 0)\n\t\t{\n\t\t\t$message = explode(\"<mybb-bad-sm>\", $message);\n\t\t\t$i = 0;\n\t\t\tforeach($bad_matches[0] as $match)\n\t\t\t{\n\t\t\t\t$message[$i] .= $match;\n\t\t\t\t$i++;\n\t\t\t}\n\t\t\t$message = implode(\"\", $message);\n\t\t}\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Generates a cache of badwords filters.\n\t *\n\t * @access private\n\t */\n\tfunction cache_badwords()\n\t{\n\t\tglobal $cache;\n\t\t$this->badwords_cache = array();\n\t\t$this->badwords_cache = $cache->read(\"badwords\");\n\t}\n\n\t/**\n\t * Parses a list of filtered/badwords in the specified message.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @param array $options Array of parser options in yes/no format.\n\t * @return string The parsed message.\n\t */\n\tfunction parse_badwords($message, $options=array())\n\t{\n\t\tif(empty($this->options))\n\t\t{\n\t\t\t$this->options = $options;\n\t\t}\n\n\t\tif($this->badwords_cache == 0)\n\t\t{\n\t\t\t$this->cache_badwords();\n\t\t}\n\t\tif(is_array($this->badwords_cache))\n\t\t{\n\t\t\treset($this->badwords_cache);\n\t\t\tforeach($this->badwords_cache as $bid => $badword)\n\t\t\t{\n\t\t\t\tif(!$badword['replacement'])\n\t\t\t\t{\n\t\t\t\t\t$badword['replacement'] = \"*****\";\n\t\t\t\t}\n\n\t\t\t\tif(!$badword['regex'])\n\t\t\t\t{\n\t\t\t\t\t$badword['badword'] = $this->generate_regex($badword['badword']);\n\t\t\t\t}\n\n\t\t\t\t$message = preg_replace('#'.$badword['badword'].'#is', $badword['replacement'], $message);\n\t\t\t}\n\t\t}\n\t\tif(!empty($this->options['strip_tags']))\n\t\t{\n\t\t\t$message = strip_tags($message);\n\t\t}\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Generates REGEX patterns based on user defined badword string.\n\t *\n\t * @param string $badword The word defined to replace.\n\t * @return string The regex pattern to match the word or null on error.\n\t */\n\tfunction generate_regex($bad_word = \"\")\n\t{\n\t\tif($bad_word == \"\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// Neutralize escape character, regex operators, multiple adjacent wildcards and generate pattern\n\t\t$ptrn = array('/\\\\\\\\/', '/([\\[\\^\\$\\.\\|\\?\\(\\)\\{\\}]{1})/', '/\\*\\++/', '/\\++\\*/', '/\\*+/');\n\t\t$rplc = array('\\\\\\\\\\\\\\\\','\\\\\\\\${1}', '*', '*', '[^\\s\\n]*');\n\t\t$bad_word = preg_replace($ptrn, $rplc, $bad_word);\n\t\t\n\t\t// Count + and generate pattern\n\t\t$bad_word = explode('+', $bad_word);\n\t\t$trap = \"\";\n\t\t$plus = 0;\n\t\tforeach($bad_word as $bad_piece)\n\t\t{\n\t\t\tif($bad_piece)\n\t\t\t{\n\t\t\t\t$trap .= $plus ? '[^\\s\\n]{'.$plus.'}'.$bad_piece : $bad_piece;\n\t\t\t\t$plus = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$plus++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Handle trailing +\n\t\tif($plus > 1)\n\t\t{\n\t\t\t$trap .= '[^\\s\\n]{'.($plus-1).'}';\n\t\t}\n\t\t\n\t\treturn '\\b'.$trap.'\\b';\n\t}\n\n\t/**\n\t * Resolves nested CDATA tags in the specified message.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @return string The parsed message.\n\t */\n\tfunction parse_cdata($message)\n\t{\n\t\t$message = str_replace(']]>', ']]]]><![CDATA[>', $message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Attempts to move any javascript references in the specified message.\n\t *\n\t * @param string The message to be parsed.\n\t * @return string The parsed message.\n\t */\n\tfunction fix_javascript($message)\n\t{\n\t\t$js_array = array(\n\t\t\t\"#(&\\#(0*)106;?|&\\#(0*)74;?|&\\#x(0*)4a;?|&\\#x(0*)6a;?|j)((&\\#(0*)97;?|&\\#(0*)65;?|a)(&\\#(0*)118;?|&\\#(0*)86;?|v)(&\\#(0*)97;?|&\\#(0*)65;?|a)(\\s)?(&\\#(0*)115;?|&\\#(0*)83;?|s)(&\\#(0*)99;?|&\\#(0*)67;?|c)(&\\#(0*)114;?|&\\#(0*)82;?|r)(&\\#(0*)105;?|&\\#(0*)73;?|i)(&\\#112;?|&\\#(0*)80;?|p)(&\\#(0*)116;?|&\\#(0*)84;?|t)(&\\#(0*)58;?|\\:))#i\",\n\t\t\t\"#([\\s\\\"']on)([a-z]+\\s*=)#i\",\n\t\t);\n\n\t\t// Add invisible white space\n\t\t$message = preg_replace($js_array, \"$1\\xE2\\x80\\x8C$2$6\", $message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t* Handles fontsize.\n\t*\n\t* @param int $size The original size.\n\t* @param string $text The text within a size tag.\n\t* @return string The parsed text.\n\t*/\n\tfunction mycode_handle_size($size, $text)\n\t{\n\t\tglobal $templates;\n\n\t\t$size = (int)$size;\n\n\t\tif($size < 1)\n\t\t{\n\t\t\t$size = 1;\n\t\t}\n\n\t\tif($size > 50)\n\t\t{\n\t\t\t$size = 50;\n\t\t}\n\n\t\t$text = str_replace(\"\\'\", \"'\", $text);\n\n\t\teval(\"\\$mycode_size = \\\"\".$templates->get(\"mycode_size_int\", 1, 0).\"\\\";\");\n\t\treturn $mycode_size;\n\t}\n\n\t/**\n\t* Handles fontsize.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed text.\n\t*/\n\tfunction mycode_handle_size_callback($matches)\n\t{\n\t\treturn $this->mycode_handle_size($matches[1], $matches[2]);\n\t}\n\n\t/**\n\t* Parses quote MyCode.\n\t*\n\t* @param string $message The message to be parsed\n\t* @param boolean $text_only Are we formatting as text?\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_quotes($message, $text_only=false)\n\t{\n\t\tglobal $lang, $templates, $theme, $mybb;\n\n\t\t// Assign pattern and replace values.\n\t\t$pattern = \"#\\[quote\\](.*?)\\[\\/quote\\](\\r\\n?|\\n?)#si\";\n\t\t$pattern_callback = \"#\\[quote=([\\\"']|&quot;|)(.*?)(?:\\\\1)(.*?)(?:[\\\"']|&quot;)?\\](.*?)\\[/quote\\](\\r\\n?|\\n?)#si\";\n\n\t\tif($text_only == false)\n\t\t{\n\t\t\t$replace = \"<blockquote class=\\\"mycode_quote\\\"><cite>$lang->quote</cite>$1</blockquote>\\n\";\n\t\t\t$replace_callback = array($this, 'mycode_parse_post_quotes_callback1');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$replace = empty($this->options['signature_parse']) ? \"\\n{$lang->quote}\\n--\\n$1\\n--\\n\" : \"$1\";\n\t\t\t$replace_callback = array($this, 'mycode_parse_post_quotes_callback2');\n\t\t}\n\n\t\tdo\n\t\t{\n\t\t\t// preg_replace has erased the message? Restore it...\n\t\t\t$previous_message = $message;\n\t\t\t$message = preg_replace($pattern, $replace, $message, -1, $count);\n\t\t\t$message = preg_replace_callback($pattern_callback, $replace_callback, $message, -1, $count_callback);\n\t\t\tif(!$message)\n\t\t\t{\n\t\t\t\t$message = $previous_message;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while($count || $count_callback);\n\n\t\tif($text_only == false)\n\t\t{\n\t\t\t$find = array(\n\t\t\t\t\"#(\\r\\n*|\\n*)<\\/cite>(\\r\\n*|\\n*)#\",\n\t\t\t\t\"#(\\r\\n*|\\n*)<\\/blockquote>#\"\n\t\t\t);\n\n\t\t\t$replace = array(\n\t\t\t\t\"</cite><br />\",\n\t\t\t\t\"</blockquote>\"\n\t\t\t);\n\t\t\t$message = preg_replace($find, $replace, $message);\n\t\t}\n\t\treturn $message;\n\t}\n\n\t/**\n\t* Parses quotes with post id and/or dateline.\n\t*\n\t* @param string $message The message to be parsed\n\t* @param string $username The username to be parsed\n\t* @param boolean $text_only Are we formatting as text?\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_post_quotes($message, $username, $text_only=false)\n\t{\n\t\tglobal $lang, $templates, $theme, $mybb;\n\n\t\t$linkback = $date = \"\";\n\n\t\t$message = trim($message);\n\t\t$message = preg_replace(\"#(^<br(\\s?)(\\/?)>|<br(\\s?)(\\/?)>$)#i\", \"\", $message);\n\n\t\tif(!$message)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\t$username .= \"'\";\n\t\t$delete_quote = true;\n\n\t\tpreg_match(\"#pid=(?:&quot;|\\\"|')?([0-9]+)[\\\"']?(?:&quot;|\\\"|')?#i\", $username, $match);\n\t\tif((int)$match[1])\n\t\t{\n\t\t\t$pid = (int)$match[1];\n\t\t\t$url = $mybb->settings['bburl'].\"/\".get_post_link($pid).\"#pid$pid\";\n\t\t\tif(defined(\"IN_ARCHIVE\"))\n\t\t\t{\n\t\t\t\t$linkback = \" <a href=\\\"{$url}\\\">[ -> ]</a>\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teval(\"\\$linkback = \\\" \".$templates->get(\"postbit_gotopost\", 1, 0).\"\\\";\");\n\t\t\t}\n\n\t\t\t$username = preg_replace(\"#(?:&quot;|\\\"|')? pid=(?:&quot;|\\\"|')?[0-9]+[\\\"']?(?:&quot;|\\\"|')?#i\", '', $username);\n\t\t\t$delete_quote = false;\n\t\t}\n\n\t\tunset($match);\n\t\tpreg_match(\"#dateline=(?:&quot;|\\\"|')?([0-9]+)(?:&quot;|\\\"|')?#i\", $username, $match);\n\t\tif((int)$match[1])\n\t\t{\n\t\t\tif($match[1] < TIME_NOW)\n\t\t\t{\n\t\t\t\tif($text_only)\n\t\t\t\t{\n\t\t\t\t\t$postdate = my_date('normal', (int)$match[1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$postdate = my_date('relative', (int)$match[1]);\n\t\t\t\t}\n\t\t\t\t$date = \" ({$postdate})\";\n\t\t\t}\n\t\t\t$username = preg_replace(\"#(?:&quot;|\\\"|')? dateline=(?:&quot;|\\\"|')?[0-9]+(?:&quot;|\\\"|')?#i\", '', $username);\n\t\t\t$delete_quote = false;\n\t\t}\n\n\t\tif($delete_quote)\n\t\t{\n\t\t\t$username = my_substr($username, 0, my_strlen($username)-1);\n\t\t}\n\n\t\tif(!empty($this->options['allow_html']))\n\t\t{\n\t\t\t$username = htmlspecialchars_uni($username);\n\t\t}\n\n\t\tif($text_only)\n\t\t{\n\t\t\treturn \"\\n{$username} {$lang->wrote}{$date}\\n--\\n{$message}\\n--\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$span = \"\";\n\t\t\tif(!$delete_quote)\n\t\t\t{\n\t\t\t\t$span = \"<span>{$date}</span>\";\n\t\t\t}\n\n\t\t\teval(\"\\$mycode_quote = \\\"\".$templates->get(\"mycode_quote_post\", 1, 0).\"\\\";\");\n\t\t\treturn $mycode_quote;\n\t\t}\n\t}\n\n\t/**\n\t* Parses quotes with post id and/or dateline.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_post_quotes_callback1($matches)\n\t{\n\t\treturn $this->mycode_parse_post_quotes($matches[4],$matches[2].$matches[3]);\n\t}\n\n\t/**\n\t* Parses quotes with post id and/or dateline.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_post_quotes_callback2($matches)\n\t{\n\t\treturn $this->mycode_parse_post_quotes($matches[4],$matches[2].$matches[3], true);\n\t}\n\n\t/**\n\t* Parses code MyCode.\n\t*\n\t* @param string $code The message to be parsed\n\t* @param boolean $text_only Are we formatting as text?\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_code($code, $text_only=false)\n\t{\n\t\tglobal $lang, $templates;\n\n\t\tif($text_only == true)\n\t\t{\n\t\t\treturn empty($this->options['signature_parse']) ? \"\\n{$lang->code}\\n--\\n{$code}\\n--\\n\" : $code;\n\t\t}\n\n\t\t// Clean the string before parsing.\n\t\t$code = preg_replace('#^(\\t*)(\\n|\\r|\\0|\\x0B| )*#', '\\\\1', $code);\n\t\t$code = rtrim($code);\n\t\t$original = preg_replace('#^\\t*#', '', $code);\n\n\t\tif(empty($original))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t$code = str_replace('$', '&#36;', $code);\n\t\t$code = preg_replace('#\\$([0-9])#', '\\\\\\$\\\\1', $code);\n\t\t$code = str_replace('\\\\', '&#92;', $code);\n\t\t$code = str_replace(\"\\t\", '&nbsp;&nbsp;&nbsp;&nbsp;', $code);\n\t\t$code = str_replace(\"  \", '&nbsp;&nbsp;', $code);\n\n\t\teval(\"\\$mycode_code = \\\"\".$templates->get(\"mycode_code\", 1, 0).\"\\\";\");\n\t\treturn $mycode_code;\n\t}\n\n\t/**\n\t* Parses code MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_code_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_code($matches[1], true);\n\t}\n\n\t/**\n\t* Parses PHP code MyCode.\n\t*\n\t* @param string $str The message to be parsed\n\t* @param boolean $bare_return Whether or not it should return it as pre-wrapped in a div or not.\n\t* @param boolean $text_only Are we formatting as text?\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_php($str, $bare_return = false, $text_only = false)\n\t{\n\t\tglobal $lang, $templates;\n\n\t\tif($text_only == true)\n\t\t{\n\t\t\treturn empty($this->options['signature_parse']) ? \"\\n{$lang->php_code}\\n--\\n{$str}\\n--\\n\" : $str;\n\t\t}\n\n\t\t// Clean the string before parsing except tab spaces.\n\t\t$str = preg_replace('#^(\\t*)(\\n|\\r|\\0|\\x0B| )*#', '\\\\1', $str);\n\t\t$str = rtrim($str);\n\n\t\t$original = preg_replace('#^\\t*#', '', $str);\n\n\t\tif(empty($original))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// See if open and close tags are provided.\n\t\t$added_open_tag = false;\n\t\tif(!preg_match(\"#^\\s*<\\?#si\", $str))\n\t\t{\n\t\t\t$added_open_tag = true;\n\t\t\t$str = \"<?php \\n\".$str;\n\t\t}\n\n\t\t$added_end_tag = false;\n\t\tif(!preg_match(\"#\\?>\\s*$#si\", $str))\n\t\t{\n\t\t\t$added_end_tag = true;\n\t\t\t$str = $str.\" \\n?>\";\n\t\t}\n\n\t\t$code = @highlight_string($str, true);\n\n\t\t// Do the actual replacing.\n\t\t$code = preg_replace('#<code>\\s*<span style=\"color: \\#000000\">\\s*#i', \"<code>\", $code);\n\t\t$code = preg_replace(\"#</span>\\s*</code>#\", \"</code>\", $code);\n\t\t$code = preg_replace(\"#</span>(\\r\\n?|\\n?)</code>#\", \"</span></code>\", $code);\n\t\t$code = str_replace(\"\\\\\", '&#092;', $code);\n\t\t$code = str_replace('$', '&#36;', $code);\n\t\t$code = preg_replace(\"#&amp;\\#([0-9]+);#si\", \"&#$1;\", $code);\n\n\t\tif($added_open_tag)\n\t\t{\n\t\t\t$code = preg_replace(\"#<code><span style=\\\"color: \\#([A-Z0-9]{6})\\\">&lt;\\?php( |&nbsp;)(<br />?)#\", \"<code><span style=\\\"color: #$1\\\">\", $code);\n\t\t}\n\n\t\tif($added_end_tag)\n\t\t{\n\t\t\t$code = str_replace(\"?&gt;</span></code>\", \"</span></code>\", $code);\n\t\t\t// Wait a minute. It fails highlighting? Stupid highlighter.\n\t\t\t$code = str_replace(\"?&gt;</code>\", \"</code>\", $code);\n\t\t}\n\n\t\t$code = preg_replace(\"#<span style=\\\"color: \\#([A-Z0-9]{6})\\\"></span>#\", \"\", $code);\n\t\t$code = str_replace(\"<code>\", \"<div dir=\\\"ltr\\\"><code>\", $code);\n\t\t$code = str_replace(\"</code>\", \"</code></div>\", $code);\n\t\t$code = preg_replace(\"# *$#\", \"\", $code);\n\n\t\tif($bare_return)\n\t\t{\n\t\t\treturn $code;\n\t\t}\n\n\t\t// Send back the code all nice and pretty\n\t\teval(\"\\$mycode_php = \\\"\".$templates->get(\"mycode_php\", 1, 0).\"\\\";\");\n\t\treturn $mycode_php;\n\t}\n\n\t/**\n\t* Parses PHP code MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_php_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_php($matches[1], false, true);\n\t}\n\n\t/**\n\t* Parses URL MyCode.\n\t*\n\t* @param string $url The URL to link to.\n\t* @param string $name The name of the link.\n\t* @return string The built-up link.\n\t*/\n\tfunction mycode_parse_url($url, $name=\"\")\n\t{\n\t\tglobal $templates;\n\t\tif(!preg_match(\"#^[a-z0-9]+://#i\", $url))\n\t\t{\n\t\t\t$url = \"http://\".$url;\n\t\t}\n\n\t\tif(!empty($this->options['allow_html']))\n\t\t{\n\t\t\t$url = $this->parse_html($url);\n\t\t}\n\n\t\tif(!$name)\n\t\t{\n\t\t\t$name = $url;\n\t\t}\n\n\t\tif($name == $url && (!isset($this->options['shorten_urls']) || !empty($this->options['shorten_urls'])))\n\t\t{\n\t\t\t$name = htmlspecialchars_decode($name);\n\t\t\tif(my_strlen($name) > 55)\n\t\t\t{\n\t\t\t\t$name = my_substr($name , 0, 40).'...'.my_substr($name , -10);\n\t\t\t}\n\t\t\t$name = htmlspecialchars_uni($name);\n\t\t}\n\n\t\tif(!empty($this->options['nofollow_on']))\n\t\t{\n\t\t\t$rel = \" rel=\\\"noopener nofollow\\\"\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$rel = \" rel=\\\"noopener\\\"\";\n\t\t}\n\n\t\t// Fix some entities in URLs\n\t\t$url = $this->encode_url($url);\n\t\t$name = $this->parse_badwords(preg_replace(\"#&amp;\\#([0-9]+);#si\", \"&#$1;\", $name)); // Fix & but allow unicode, filter bad words\n\n\t\teval(\"\\$mycode_url = \\\"\".$templates->get(\"mycode_url\", 1, 0).\"\\\";\");\n\t\treturn $mycode_url;\n\t}\n\n\t/**\n\t* Parses URL MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The built-up link.\n\t*/\n\tfunction mycode_parse_url_callback1($matches)\n\t{\n\t\tif(!isset($matches[3]))\n\t\t{\n\t\t\t$matches[3] = '';\n\t\t}\n\t\treturn $this->mycode_parse_url($matches[1].$matches[2], $matches[3]);\n\t}\n\n\t/**\n\t* Parses URL MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The built-up link.\n\t*/\n\tfunction mycode_parse_url_callback2($matches)\n\t{\n\t\tif(!isset($matches[2]))\n\t\t{\n\t\t\t$matches[2] = '';\n\t\t}\n\t\treturn $this->mycode_parse_url($matches[1], $matches[2]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param string $url The URL to the image\n\t * @param array $dimensions Optional array of dimensions\n\t * @param string $align\n\t * @return string\n\t */\n\tfunction mycode_parse_img($url, $dimensions=array(), $align='')\n\t{\n\t\tglobal $lang, $templates;\n\t\t$url = trim($url);\n\t\t$url = str_replace(\"\\n\", \"\", $url);\n\t\t$url = str_replace(\"\\r\", \"\", $url);\n\n\t\tif(!empty($this->options['allow_html']))\n\t\t{\n\t\t\t$url = $this->parse_html($url);\n\t\t}\n\n\t\t$css_align = '';\n\t\tif($align == \"right\")\n\t\t{\n\t\t\t$css_align = ' style=\"float: right;\"';\n\t\t}\n\t\telse if($align == \"left\")\n\t\t{\n\t\t\t$css_align = ' style=\"float: left;\"';\n\t\t}\n\n\t\tif($align)\n\t\t{\n\t\t\t$this->clear_needed = true;\n\t\t}\n\n\t\t$alt = basename($url);\n\t\t$alt = htmlspecialchars_decode($alt);\n\t\tif(my_strlen($alt) > 55)\n\t\t{\n\t\t\t$alt = my_substr($alt, 0, 40).'...'.my_substr($alt, -10);\n\t\t}\n\t\t$alt = $this->encode_url($alt);\n\n\t\t$alt = $lang->sprintf($lang->posted_image, $alt);\n\t\t$width = $height = '';\n\t\tif(isset($dimensions[0]) && $dimensions[0] > 0 && isset($dimensions[1]) && $dimensions[1] > 0)\n\t\t{\n\t\t\t$width = \" width=\\\"{$dimensions[0]}\\\"\";\n\t\t\t$height = \" height=\\\"{$dimensions[1]}\\\"\";\n\t\t}\n\n\t\t$url = $this->encode_url($url);\n\n\t\teval(\"\\$mycode_img = \\\"\".$templates->get(\"mycode_img\", 1, 0).\"\\\";\");\n\t\treturn $mycode_img;\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_callback1($matches)\n\t{\n\t\treturn $this->mycode_parse_img($matches[2]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_callback2($matches)\n\t{\n\t\treturn $this->mycode_parse_img($matches[4], array($matches[1], $matches[2]));\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_callback3($matches)\n\t{\n\t\treturn $this->mycode_parse_img($matches[3], array(), $matches[1]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_callback4($matches)\n\t{\n\t\treturn $this->mycode_parse_img($matches[5], array($matches[1], $matches[2]), $matches[3]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param string $url The URL to the image\n\t * @return string\n\t */\n\tfunction mycode_parse_img_disabled($url)\n\t{\n\t\tglobal $lang;\n\t\t$url = trim($url);\n\t\t$url = str_replace(\"\\n\", \"\", $url);\n\t\t$url = str_replace(\"\\r\", \"\", $url);\n\t\t$url = str_replace(\"\\'\", \"'\", $url);\n\n\t\t$image = $lang->sprintf($lang->posted_image, $this->mycode_parse_url($url));\n\t\treturn $image;\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_disabled_callback1($matches)\n\t{\n\t\treturn $this->mycode_parse_img_disabled($matches[2]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_disabled_callback2($matches)\n\t{\n\t\treturn $this->mycode_parse_img_disabled($matches[4]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_disabled_callback3($matches)\n\t{\n\t\treturn $this->mycode_parse_img_disabled($matches[3]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_disabled_callback4($matches)\n\t{\n\t\treturn $this->mycode_parse_img_disabled($matches[5]);\n\t}\n\n\t/**\n\t* Parses email MyCode.\n\t*\n\t* @param string $email The email address to link to.\n\t* @param string $name The name for the link.\n\t* @return string The built-up email link.\n\t*/\n\tfunction mycode_parse_email($email, $name=\"\")\n\t{\n\t\tglobal $templates;\n\n\t\tif(!$name)\n\t\t{\n\t\t\t$name = $email;\n\t\t}\n\t\tif(preg_match(\"/^([a-zA-Z0-9-_\\+\\.]+?)@[a-zA-Z0-9-]+\\.[a-zA-Z0-9\\.-]+$/si\", $email))\n\t\t{\n\t\t\t$email = $email;\n\t\t}\n\t\telseif(preg_match(\"/^([a-zA-Z0-9-_\\+\\.]+?)@[a-zA-Z0-9-]+\\.[a-zA-Z0-9\\.-]+\\?(.*?)$/si\", $email))\n\t\t{\n\t\t\t$email = htmlspecialchars_uni($email);\n\t\t}\n\n\t\teval(\"\\$mycode_email = \\\"\".$templates->get(\"mycode_email\", 1, 0).\"\\\";\");\n\t\treturn $mycode_email;\n\t}\n\n\t/**\n\t* Parses email MyCode.\n\t*\n\t* @param array $matches Matches\n\t* @return string The built-up email link.\n\t*/\n\tfunction mycode_parse_email_callback($matches)\n\t{\n\t\tif(!isset($matches[2]))\n\t\t{\n\t\t\t$matches[2] = '';\n\t\t}\n\t\treturn $this->mycode_parse_email($matches[1], $matches[2]);\n\t}\n\n\t/**\n\t* Parses video MyCode.\n\t*\n\t* @param string $video The video provider.\n\t* @param string $url The video to link to.\n\t* @return string The built-up video code.\n\t*/\n\tfunction mycode_parse_video($video, $url)\n\t{\n\t\tglobal $templates;\n\n\t\tif(empty($video) || empty($url))\n\t\t{\n\t\t\treturn \"[video={$video}]{$url}[/video]\";\n\t\t}\n\n\t\t// Check URL is a valid URL first, as `parse_url` doesn't check validity.\n\t\tif(false === filter_var($url, FILTER_VALIDATE_URL))\n\t\t{\n            return \"[video={$video}]{$url}[/video]\";\n        }\n\n\t\t$parsed_url = @parse_url(urldecode($url));\n\t\tif($parsed_url === false)\n\t\t{\n\t\t\treturn \"[video={$video}]{$url}[/video]\";\n\t\t}\n\n\t\t$fragments = array();\n\t\tif($parsed_url['fragment'])\n\t\t{\n\t\t\t$fragments = explode(\"&\", $parsed_url['fragment']);\n\t\t}\n\n\t\tif($video == \"liveleak\")\n\t\t{\n\t\t\t// The query part can start with any alphabet, but set only 'i' to catch in index key later\n\t\t\t$parsed_url['query'] = \"i\".substr($parsed_url['query'], 1);\n\t\t}\n\n\t\t$queries = explode(\"&\", $parsed_url['query']);\n\n\t\t$input = array();\n\t\tforeach($queries as $query)\n\t\t{\n\t\t\tlist($key, $value) = explode(\"=\", $query);\n\t\t\t$key = str_replace(\"amp;\", \"\", $key);\n\t\t\t$input[$key] = $value;\n\t\t}\n\n\t\t$path = explode('/', $parsed_url['path']);\n\n\t\tswitch($video)\n\t\t{\n\t\t\tcase \"dailymotion\":\n\t\t\t\tif(isset($path[2]))\n\t\t\t\t{\n\t\t\t\t\tlist($id) = explode('_', $path[2], 2); // http://www.dailymotion.com/video/fds123_title-goes-here\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[1]; // http://dai.ly/fds123\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"metacafe\":\n\t\t\t\t$id = $path[2]; // http://www.metacafe.com/watch/fds123/title_goes_here/\n\t\t\t\t$title = htmlspecialchars_uni($path[3]);\n\t\t\t\tbreak;\n\t\t\tcase \"myspacetv\":\n\t\t\t\t$id = $path[4]; // http://www.myspace.com/video/fds/fds/123\n\t\t\t\tbreak;\n\t\t\tcase \"facebook\":\n\t\t\t\tif(isset($input['v']))\n\t\t\t\t{\n\t\t\t\t\t$id = $input['v']; // http://www.facebook.com/video/video.php?v=123\n\t\t\t\t}\n\t\t\t\telseif(substr($path[3], 0, 3) == 'vb.')\n\t\t\t\t{\n\t\t\t\t\t$id = $path[4]; // https://www.facebook.com/fds/videos/vb.123/123/\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[3]; // https://www.facebook.com/fds/videos/123/\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"mixer\":\n\t\t\t\t$id = $path[1]; // https://mixer.com/streamer\n\t\t\t\tbreak;\n\t\t\tcase \"liveleak\":\n\t\t\t\t$id = $input['i']; // http://www.liveleak.com/view?i=123\n\t\t\t\tbreak;\n\t\t\tcase \"yahoo\":\n\t\t\t\tif(isset($path[2]))\n\t\t\t\t{\n\t\t\t\t\t$id = $path[2]; // http://xy.screen.yahoo.com/fds/fds-123.html\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[1]; // http://xy.screen.yahoo.com/fds-123.html\n\t\t\t\t}\n\t\t\t\t// Support for localized portals\n\t\t\t\t$domain = explode('.', $parsed_url['host']);\n\t\t\t\tif($domain[0] != 'screen' && preg_match('#^([a-z-]+)$#', $domain[0]))\n\t\t\t\t{\n\t\t\t\t\t$local = \"{$domain[0]}.\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$local = '';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"vimeo\":\n\t\t\t\tif(isset($path[3]))\n\t\t\t\t{\n\t\t\t\t\t$id = $path[3]; // http://vimeo.com/fds/fds/fds123\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[1]; // http://vimeo.com/fds123\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"youtube\":\n\t\t\t\tif($fragments[0])\n\t\t\t\t{\n\t\t\t\t\t$id = str_replace('!v=', '', $fragments[0]); // http://www.youtube.com/watch#!v=fds123\n\t\t\t\t}\n\t\t\t\telseif($input['v'])\n\t\t\t\t{\n\t\t\t\t\t$id = $input['v']; // http://www.youtube.com/watch?v=fds123\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[1]; // http://www.youtu.be/fds123\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"twitch\":\n\t\t\t\tif(count($path) >= 3 && $path[1] == 'videos')\n\t\t\t\t{\n\t\t\t\t\t// Direct video embed with URL like: https://www.twitch.tv/videos/179723472\n\t\t\t\t\t$id = 'video=v'.$path[2];\n\t\t\t\t}\n\t\t\t\telseif(count($path) >= 4 && $path[2] == 'v')\n\t\t\t\t{\n\t\t\t\t\t// Direct video embed with URL like: https://www.twitch.tv/waypoint/v/179723472\n\t\t\t\t\t$id = 'video=v'.$path[3];\n\t\t\t\t}\n\t\t\t\telseif(count($path) >= 2)\n\t\t\t\t{\n\t\t\t\t\t// Channel (livestream) embed with URL like: https://twitch.tv/waypoint\n\t\t\t\t\t$id = 'channel='.$path[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn \"[video={$video}]{$url}[/video]\";\n\t\t}\n\n\t\tif(empty($id))\n\t\t{\n\t\t\treturn \"[video={$video}]{$url}[/video]\";\n\t\t}\n\n\t\t$id = $this->encode_url($id);\n\n\t\teval(\"\\$video_code = \\\"\".$templates->get(\"video_{$video}_embed\", 1, 0).\"\\\";\");\n\t\treturn $video_code;\n\t}\n\n\t/**\n\t* Parses video MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The built-up video code.\n\t*/\n\tfunction mycode_parse_video_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_video($matches[1], $matches[2]);\n\t}\n\n\t/**\n\t * Parses video MyCode disabled.\n\t *\n\t * @param string $url The URL to the video\n\t * @return string\n\t */\n\tfunction mycode_parse_video_disabled($url)\n\t{\n\t\tglobal $lang;\n\t\t$url = trim($url);\n\t\t$url = str_replace(\"\\n\", \"\", $url);\n\t\t$url = str_replace(\"\\r\", \"\", $url);\n\t\t$url = str_replace(\"\\'\", \"'\", $url);\n\n\t\t$video = $lang->sprintf($lang->posted_video, $this->mycode_parse_url($url));\n\t\treturn $video;\n\t}\n\n\t/**\n\t* Parses video MyCode disabled.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The built-up video code.\n\t*/\n\tfunction mycode_parse_video_disabled_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_video_disabled($matches[2]);\n\t}\n\n\t/**\n\t* Parses URLs automatically.\n\t*\n\t* @param string $message The message to be parsed\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_auto_url($message)\n\t{\n\t\t$message = \" \".$message;\n\n\t\t// Links should end with slashes, numbers, characters and braces but not with dots, commas or question marks\n\t\t// Don't create links within existing links (handled up-front in the callback function).\n\t\t$message = preg_replace_callback(\"#<a\\\\s[^>]*>.*?</a>|([\\s\\(\\)\\[\\>])(http|https|ftp|news|irc|ircs|irc6){1}(://)([^\\/\\\"\\s\\<\\[\\.]+\\.([^\\/\\\"\\s\\<\\[\\.]+\\.)*[\\w]+(:[0-9]+)?(/([^\\\"\\s<\\[]|\\[\\])*)?([\\w\\/\\)]))#ius\", array($this, 'mycode_auto_url_callback'), $message);\n\t\t$message = preg_replace_callback(\"#<a\\\\s[^>]*>.*?</a>|([\\s\\(\\)\\[\\>])(www|ftp)(\\.)(([^\\/\\\"\\s\\<\\[\\.]+\\.)*[\\w]+(:[0-9]+)?(/([^\\\"\\s<\\[]|\\[\\])*)?([\\w\\/\\)]))#ius\", array($this, 'mycode_auto_url_callback'), $message);\n\t\t$message = my_substr($message, 1);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t* Parses URLs automatically.\n\t*\n\t* @param array $matches Matches\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_auto_url_callback($matches=array())\n\t{\n\t\t// If we matched a preexisting link (the part of the regexes in mycode_auto_url() before the pipe symbol),\n\t\t// then simply return it - we don't create links within existing links.\n\t\tif(count($matches) == 1)\n\t\t{\n\t\t\treturn $matches[0];\n\t\t}\n\n\t\t$external = '';\n\t\t// Allow links like http://en.wikipedia.org/wiki/PHP_(disambiguation) but detect mismatching braces\n\t\twhile(my_substr($matches[4], -1) == ')')\n\t\t{\n\t\t\tif(substr_count($matches[4], ')') > substr_count($matches[4], '('))\n\t\t\t{\n\t\t\t\t$matches[4] = my_substr($matches[4], 0, -1);\n\t\t\t\t$external = ')'.$external;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Example: ([...] http://en.wikipedia.org/Example_(disambiguation).)\n\t\t\t$last_char = my_substr($matches[4], -1);\n\t\t\twhile($last_char == '.' || $last_char == ',' || $last_char == '?' || $last_char == '!')\n\t\t\t{\n\t\t\t\t$matches[4] = my_substr($matches[4], 0, -1);\n\t\t\t\t$external = $last_char.$external;\n\t\t\t\t$last_char = my_substr($matches[4], -1);\n\t\t\t}\n\t\t}\n\t\t$url = \"{$matches[2]}{$matches[3]}{$matches[4]}\";\n\n\t\treturn $matches[1].$this->mycode_parse_url($url, $url).$external;\n\t}\n\n\t/**\n\t* Parses list MyCode.\n\t*\n\t* @param string $message The message to be parsed\n\t* @param string $type The list type\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_list($message, $type=\"\")\n\t{\n\t\t// No list elements? That's invalid HTML\n\t\tif(strpos($message, '[*]') === false)\n\t\t{\n\t\t\t$message = \"[*]{$message}\";\n\t\t}\n\n\t\t$message = preg_split(\"#[^\\S\\n\\r]*\\[\\*\\]\\s*#\", $message);\n\t\tif(isset($message[0]) && trim($message[0]) == '')\n\t\t{\n\t\t\tarray_shift($message);\n\t\t}\n\t\t$message = '<li>'.implode(\"</li>\\n<li>\", $message).\"</li>\\n\";\n\n\t\tif($type)\n\t\t{\n\t\t\t$list = \"\\n<ol type=\\\"$type\\\" class=\\\"mycode_list\\\">$message</ol>\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$list = \"<ul class=\\\"mycode_list\\\">$message</ul>\\n\";\n\t\t}\n\t\t$list = preg_replace(\"#<(ol type=\\\"$type\\\"|ul)>\\s*</li>#\", \"<$1>\", $list);\n\t\treturn $list;\n\t}\n\n\t/**\n\t* Parses list MyCode.\n\t*\n\t* @param array $matches Matches\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_list_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_list($matches[3], $matches[2]);\n\t}\n\n\t/**\n\t* Prepares list MyCode by finding the matching list tags.\n\t*\n\t* @param array $matches Matches\n\t* @return string Temporary replacements.\n\t*/\n\tfunction mycode_prepare_list($matches)\n\t{\n\t\t// Append number to identify matching list tags\n\t\tif(strcasecmp($matches[1], '[/list]') == 0)\n\t\t{\n\t\t\t$count = array_pop($this->list_elements);\n\t\t\tif($count !== NULL)\n\t\t\t{\n\t\t\t\treturn \"[/list&{$count}]\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// No open list tag...\n\t\t\t\treturn $matches[0];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++$this->list_count;\n\t\t\t$this->list_elements[] = $this->list_count;\n\t\t\tif(!empty($matches[2]))\n\t\t\t{\n\t\t\t\treturn \"[list{$matches[2]}&{$this->list_count}]\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn \"[list&{$this->list_count}]\";\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Strips smilies from a string\n\t *\n\t * @param string $message The message for smilies to be stripped from\n\t * @return string The message with smilies stripped\n\t */\n\tfunction strip_smilies($message)\n\t{\n\t\tif($this->smilies_cache == 0)\n\t\t{\n\t\t\t$this->cache_smilies();\n\t\t}\n\t\tif(is_array($this->smilies_cache))\n\t\t{\n\t\t\t$message = str_replace($this->smilies_cache, array_keys($this->smilies_cache), $message);\n\t\t}\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Highlights a string\n\t *\n\t * @param string $message The message to be highligted\n\t * @param string $highlight The highlight keywords\n\t * @return string The message with highlight bbcodes\n\t */\n\tfunction highlight_message($message, $highlight)\n\t{\n\t\tif(empty($this->highlight_cache))\n\t\t{\n\t\t\t$this->highlight_cache = build_highlight_array($highlight);\n\t\t}\n\n\t\tif(is_array($this->highlight_cache) && !empty($this->highlight_cache))\n\t\t{\n\t\t\t$message = preg_replace(array_keys($this->highlight_cache), $this->highlight_cache, $message);\n\t\t}\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Parses message to plain text equivalents of MyCode.\n\t *\n\t * @param string $message The message to be parsed\n\t * @param array $options\n\t * @return string The parsed message.\n\t */\n\tfunction text_parse_message($message, $options=array())\n\t{\n\t\tglobal $plugins;\n\n\t\tif(empty($this->options))\n\t\t{\n\t\t\t$this->options = $options;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach($options as $option_name => $option_value)\n\t\t\t{\n\t\t\t\t$this->options[$option_name] = $option_value;\n\t\t\t}\n\t\t}\n\n\t\t// Filter bad words if requested.\n\t\tif(!empty($this->options['filter_badwords']))\n\t\t{\n\t\t\t$message = $this->parse_badwords($message);\n\t\t}\n\n\t\t// Parse quotes first\n\t\t$message = $this->mycode_parse_quotes($message, true);\n\n\t\t$message = preg_replace_callback(\"#\\[php\\](.*?)\\[/php\\](\\r\\n?|\\n?)#is\", array($this, 'mycode_parse_php_callback'), $message);\n\t\t$message = preg_replace_callback(\"#\\[code\\](.*?)\\[/code\\](\\r\\n?|\\n?)#is\", array($this, 'mycode_parse_code_callback'), $message);\n\n\t\t$find = array(\n\t\t\t\"#\\[(b|u|i|s|url|email|color|img)\\](.*?)\\[/\\\\1\\]#is\",\n\t\t\t\"#\\[(email|color|size|font|align|video)=[^]]*\\](.*?)\\[/\\\\1\\]#is\",\n\t\t\t\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\",\n\t\t\t\"#\\[url=((?!javascript)[a-z]+?://)([^\\r\\n\\\"<]+?)\\](.+?)\\[/url\\]#si\",\n\t\t\t\"#\\[url=((?!javascript:)[^\\r\\n\\\"<&\\(\\)]+?)\\](.+?)\\[/url\\]#si\",\n\t\t\t\"#\\[attachment=([0-9]+?)\\]#i\",\n\t\t);\n\n\t\t$replace = array(\n\t\t\t\"$2\",\n\t\t\t\"$2\",\n\t\t\t\"$4\",\n\t\t\t\"$3 ($1$2)\",\n\t\t\t\"$2 ($1)\",\n\t\t\t\"\",\n\t\t);\n\t\t\n\t\t$messageBefore = \"\";\n\t\t// The counter limit for this \"for\" loop is for defensive programming purpose only. It protects against infinite repetition. \n\t\tfor($cnt = 1; $cnt < 20 && $message != $messageBefore; $cnt++)\n\t\t{\n\t\t\t$messageBefore = $message;\n\t\t\t$message = preg_replace($find, $replace, $messageBefore);\n\t\t}\n\n\t\t// Replace \"me\" code and slaps if we have a username\n\t\tif(!empty($this->options['me_username']))\n\t\t{\n\t\t\tglobal $lang;\n\n\t\t\t$message = preg_replace('#(>|^|\\r|\\n)/me ([^\\r\\n<]*)#i', \"\\\\1* {$this->options['me_username']} \\\\2\", $message);\n\t\t\t$message = preg_replace('#(>|^|\\r|\\n)/slap ([^\\r\\n<]*)#i', \"\\\\1* {$this->options['me_username']} {$lang->slaps} \\\\2 {$lang->with_trout}\", $message);\n\t\t}\n\n\t\t// Reset list cache\n\t\t$this->list_elements = array();\n\t\t$this->list_count = 0;\n\n\t\t// Find all lists\n\t\t$message = preg_replace_callback(\"#(\\[list(=(a|A|i|I|1))?\\]|\\[/list\\])#si\", array($this, 'mycode_prepare_list'), $message);\n\n\t\t// Replace all lists\n\t\tfor($i = $this->list_count; $i > 0; $i--)\n\t\t{\n\t\t\t// Ignores missing end tags\n\t\t\t$message = preg_replace_callback(\"#\\s?\\[list(=(a|A|i|I|1))?&{$i}\\](.*?)(\\[/list&{$i}\\]|$)(\\r\\n?|\\n?)#si\", array($this, 'mycode_parse_list_callback'), $message, 1);\n\t\t}\n\n\t\t// Run plugin hooks\n\t\t$message = $plugins->run_hooks(\"text_parse_message\", $message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Replaces certain characters with their entities in a URL.\n\t *\n\t * @param string $url The URL to be escaped.\n\t * @return string The escaped URL.\n\t */\n\tfunction encode_url($url)\n\t{\n\t\t$entities = array('$' => '%24', '&#36;' => '%24', '^' => '%5E', '`' => '%60', '[' => '%5B', ']' => '%5D', '{' => '%7B', '}' => '%7D', '\"' => '%22', '<' => '%3C', '>' => '%3E', ' ' => '%20');\n\n\t\t$url = str_replace(array_keys($entities), array_values($entities), $url);\n\n\t\treturn $url;\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * MyBB 1.8\n * Copyright 2014 MyBB Group, All Rights Reserved\n *\n * Website: http://www.mybb.com\n * License: http://www.mybb.com/about/license\n *\n */\n\n/*\noptions = array(\n\tallow_html\n\tallow_smilies\n\tallow_mycode\n\tnl2br\n\tfilter_badwords\n\tme_username\n\tshorten_urls\n\thighlight\n\tfilter_cdata\n)\n*/\n\nclass postParser\n{\n\t/**\n\t * Internal cache of MyCode.\n\t *\n\t * @access public\n\t * @var mixed\n\t */\n\tpublic $mycode_cache = 0;\n\n\t/**\n\t * Internal cache of smilies\n\t *\n\t * @access public\n\t * @var mixed\n\t */\n\tpublic $smilies_cache = 0;\n\n\t/**\n\t * Internal cache of badwords filters\n\t *\n\t * @access public\n\t * @var mixed\n\t */\n\tpublic $badwords_cache = 0;\n\n\t/**\n\t * Base URL for smilies\n\t *\n\t * @access public\n\t * @var string\n\t */\n\tpublic $base_url;\n\n\t/**\n\t * Parsed Highlights cache\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $highlight_cache = array();\n\n\t/**\n\t * Options for this parsed message\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $options;\n\n\t/**\n\t * Internal cache for nested lists\n\t *\n\t * @access public\n\t * @var array\n\t */\n\tpublic $list_elements;\n\n\t/**\n\t * Internal counter for nested lists\n\t *\n\t * @access public\n\t * @var int\n\t */\n\tpublic $list_count;\n\n\t/**\n\t * Whether or not should a <br /> with clear: both be added at the end of the parsed message\n\t *\n\t * @access public\n\t * @var boolean\n\t */\n\tpublic $clear_needed = false;\n\n\t/**\n\t * Parses a message with the specified options.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @param array $options Array of yes/no options - allow_html,filter_badwords,allow_mycode,allow_smilies,nl2br,me_username,filter_cdata.\n\t * @return string The parsed message.\n\t */\n\tfunction parse_message($message, $options=array())\n\t{\n\t\tglobal $plugins, $mybb;\n\n\t\t$this->clear_needed = false;\n\n\t\t// Set base URL for parsing smilies\n\t\t$this->base_url = $mybb->settings['bburl'];\n\n\t\tif($this->base_url != \"\")\n\t\t{\n\t\t\tif(my_substr($this->base_url, my_strlen($this->base_url) -1) != \"/\")\n\t\t\t{\n\t\t\t\t$this->base_url = $this->base_url.\"/\";\n\t\t\t}\n\t\t}\n\n\t\t// Set the options\n\t\t$this->options = $options;\n\n\t\t$message = $plugins->run_hooks(\"parse_message_start\", $message);\n\n\t\t// Get rid of carriage returns for they are the workings of the devil\n\t\t$message = str_replace(\"\\r\", \"\", $message);\n\n\t\t// Filter bad words if requested.\n\t\tif(!empty($this->options['filter_badwords']))\n\t\t{\n\t\t\t$message = $this->parse_badwords($message);\n\t\t}\n\n\t\t// Filter CDATA tags if requested (syndication.php).\n\t\tif(!empty($this->options['filter_cdata']))\n\t\t{\n\t\t\t$message = $this->parse_cdata($message);\n\t\t}\n\n\t\t// If MyCode needs to be replaced, first filter out [code] and [php] tags.\n\t\t$code_matches = array();\n\t\tif(!empty($this->options['allow_mycode']) && $mybb->settings['allowcodemycode'] == 1)\n\t\t{\n\t\t\t// This code is reserved and could break codes\n\t\t\t$message = str_replace(\"<mybb-code>\\n\", \"<mybb_code>\\n\", $message);\n\n\t\t\tpreg_match_all(\"#\\[(code|php)\\](.*?)(\\[/\\\\1\\])+(\\r\\n?|\\n?)#si\", $message, $code_matches, PREG_SET_ORDER);\n\t\t\tforeach($code_matches as $point => $part)\n\t\t\t{\n\t\t\t\tif(isset($part[3]))\n\t\t\t\t{\n\t\t\t\t\t$part[1] = \"[\".$part[1].\"]\";\n\t\t\t\t\t$code_matches[$point][2] = substr_replace($part[0], \"\", strrpos($part[0], $part[3]), strlen($part[3]));\n\t\t\t\t\t$code_matches[$point][2] = substr_replace($code_matches[$point][2], \"\", strpos($code_matches[$point][2], $part[1]), strlen($part[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t$message = preg_replace(\"#\\[(code|php)\\](.*?)(\\[/\\\\1\\])+(\\r\\n?|\\n?)#si\", \"<mybb-code>\\n\", $message);\n\t\t}\n\n\t\tif(empty($this->options['allow_html']))\n\t\t{\n\t\t\t$message = $this->parse_html($message);\n\t\t\t$message = str_replace(\"&lt;mybb-code&gt;\\n\", \"<mybb-code>\\n\", $message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Replace base, meta,script and style tags in our post - these are > dangerous <\n\t\t\t$message = preg_replace('#<(/?)(base|meta|script|style)([^>]*)>#i', '&lt;$1$2$3&gt;', $message);\n\t\t\t$message = $this->fix_javascript($message);\n\n\t\t\t$find = array(\"<br />\\n\", \"<br>\\n\");\n\t\t\t$replace = array(\"\\n\", \"\\n\");\n\t\t\t$message = str_replace($find, $replace, $message);\n\t\t}\n\n\t\t$message = $plugins->run_hooks(\"parse_message_htmlsanitized\", $message);\n\n\t\t// Replace \"me\" code and slaps if we have a username\n\t\tif(!empty($this->options['me_username']) && $mybb->settings['allowmemycode'] == 1)\n\t\t{\n\t\t\tglobal $lang;\n\n\t\t\t$message = preg_replace('#(>|^|\\r|\\n)/me ([^\\r\\n<]*)#i', \"\\\\1<span style=\\\"color: red;\\\" class=\\\"mycode_me\\\">* {$this->options['me_username']} \\\\2</span>\", $message);\n\t\t\t$message = preg_replace('#(>|^|\\r|\\n)/slap ([^\\r\\n<]*)#i', \"\\\\1<span style=\\\"color: red;\\\" class=\\\"mycode_slap\\\">* {$this->options['me_username']} {$lang->slaps} \\\\2 {$lang->with_trout}</span>\", $message);\n\t\t}\n\n\t\t$message = $plugins->run_hooks(\"parse_message_me_mycode\", $message);\n\n\t\t// If we can, parse smilies\n\t\tif(!empty($this->options['allow_smilies']))\n\t\t{\n\t\t\t$message = $this->parse_smilies($message, $this->options['allow_html']);\n\t\t}\n\n\t\t// Replace MyCode if requested.\n\t\tif(!empty($this->options['allow_mycode']))\n\t\t{\n\t\t\t$message = $this->parse_mycode($message);\n\t\t}\n\n\t\t// Filter url codes, if disabled.\n\t\tif($mybb->settings['allowlinkmycode'] != 1)\n\t\t{\n\t\t\t$message = preg_replace(\"#\\[(\\/)?url{1}(.*?)\\]#i\", \"\", $message);\n\t\t}\n\n\t\t// Parse Highlights\n\t\tif(!empty($this->options['highlight']))\n\t\t{\n\t\t\t$message = $this->highlight_message($message, $this->options['highlight']);\n\t\t}\n\n\t\t// Run plugin hooks\n\t\t$message = $plugins->run_hooks(\"parse_message\", $message);\n\n\t\tif(!empty($this->options['allow_mycode']))\n\t\t{\n\t\t\t// Now that we're done, if we split up any code tags, parse them and glue it all back together\n\t\t\tif(count($code_matches) > 0)\n\t\t\t{\n\t\t\t\tforeach($code_matches as $text)\n\t\t\t\t{\n\t\t\t\t\tif(my_strtolower($text[1]) == \"code\")\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fix up HTML inside the code tags so it is clean\n\t\t\t\t\t\t$text[2] = $this->parse_html($text[2]);\n\n\t\t\t\t\t\t$code = $this->mycode_parse_code($text[2]);\n\t\t\t\t\t}\n\t\t\t\t\telseif(my_strtolower($text[1]) == \"php\")\n\t\t\t\t\t{\n\t\t\t\t\t\t$code = $this->mycode_parse_php($text[2]);\n\t\t\t\t\t}\n\t\t\t\t\t$message = preg_replace(\"#\\<mybb-code>\\n?#\", $code, $message, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!isset($this->options['nl2br']) || $this->options['nl2br'] != 0)\n\t\t{\n\t\t\t$message = nl2br($message);\n\t\t\t// Fix up new lines and block level elements\n\t\t\t$message = preg_replace(\"#(</?(?:html|head|body|div|p|form|table|thead|tbody|tfoot|tr|td|th|ul|ol|li|div|p|blockquote|cite|hr)[^>]*>)\\s*<br />#i\", \"$1\", $message);\n\t\t\t$message = preg_replace(\"#(&nbsp;)+(</?(?:html|head|body|div|p|form|table|thead|tbody|tfoot|tr|td|th|ul|ol|li|div|p|blockquote|cite|hr)[^>]*>)#i\", \"$2\", $message);\n\t\t}\n\n\t\tif($this->clear_needed)\n\t\t{\n\t\t\t$message .= '<br class=\"clear\" />';\n\t\t}\n\n\t\t$message = $plugins->run_hooks(\"parse_message_end\", $message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Converts HTML in a message to their specific entities whilst allowing unicode characters.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @return string The formatted message.\n\t */\n\tfunction parse_html($message)\n\t{\n\t\t$message = preg_replace(\"#&(?!\\#[0-9]+;)#si\", \"&amp;\", $message); // fix & but allow unicode\n\t\t$message = str_replace(\"<\",\"&lt;\",$message);\n\t\t$message = str_replace(\">\",\"&gt;\",$message);\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Generates a cache of MyCode, both standard and custom.\n\t *\n\t * @access private\n\t */\n\tfunction cache_mycode()\n\t{\n\t\tglobal $cache, $lang, $mybb;\n\t\t$this->mycode_cache = array();\n\n\t\t$standard_mycode = $callback_mycode = $nestable_mycode = array();\n\t\t$standard_count = $callback_count = $nestable_count = 0;\n\n\t\tif($mybb->settings['allowbasicmycode'] == 1)\n\t\t{\n\t\t\t$standard_mycode['b']['regex'] = \"#\\[b\\](.*?)\\[/b\\]#si\";\n\t\t\t$standard_mycode['b']['replacement'] = \"<span style=\\\"font-weight: bold;\\\" class=\\\"mycode_b\\\">$1</span>\";\n\n\t\t\t$standard_mycode['u']['regex'] = \"#\\[u\\](.*?)\\[/u\\]#si\";\n\t\t\t$standard_mycode['u']['replacement'] = \"<span style=\\\"text-decoration: underline;\\\" class=\\\"mycode_u\\\">$1</span>\";\n\n\t\t\t$standard_mycode['i']['regex'] = \"#\\[i\\](.*?)\\[/i\\]#si\";\n\t\t\t$standard_mycode['i']['replacement'] = \"<span style=\\\"font-style: italic;\\\" class=\\\"mycode_i\\\">$1</span>\";\n\n\t\t\t$standard_mycode['s']['regex'] = \"#\\[s\\](.*?)\\[/s\\]#si\";\n\t\t\t$standard_mycode['s']['replacement'] = \"<span style=\\\"text-decoration: line-through;\\\" class=\\\"mycode_s\\\">$1</span>\";\n\n\t\t\t$standard_mycode['hr']['regex'] = \"#\\[hr\\]#si\";\n\t\t\t$standard_mycode['hr']['replacement'] = \"<hr class=\\\"mycode_hr\\\" />\";\n\n\t\t\t++$standard_count;\n\t\t}\n\n\t\tif($mybb->settings['allowsymbolmycode'] == 1)\n\t\t{\n\t\t\t$standard_mycode['copy']['regex'] = \"#\\(c\\)#i\";\n\t\t\t$standard_mycode['copy']['replacement'] = \"&copy;\";\n\n\t\t\t$standard_mycode['tm']['regex'] = \"#\\(tm\\)#i\";\n\t\t\t$standard_mycode['tm']['replacement'] = \"&#153;\";\n\n\t\t\t$standard_mycode['reg']['regex'] = \"#\\(r\\)#i\";\n\t\t\t$standard_mycode['reg']['replacement'] = \"&reg;\";\n\n\t\t\t++$standard_count;\n\t\t}\n\n\t\tif($mybb->settings['allowlinkmycode'] == 1)\n\t\t{\n\t\t\t$callback_mycode['url_simple']['regex'] = \"#\\[url\\]((?!javascript)[a-z]+?://)([^\\r\\n\\\"<]+?)\\[/url\\]#si\";\n\t\t\t$callback_mycode['url_simple']['replacement'] = array($this, 'mycode_parse_url_callback1');\n\n\t\t\t$callback_mycode['url_simple2']['regex'] = \"#\\[url\\]((?!javascript:)[^\\r\\n\\\"<]+?)\\[/url\\]#i\";\n\t\t\t$callback_mycode['url_simple2']['replacement'] = array($this, 'mycode_parse_url_callback2');\n\n\t\t\t$callback_mycode['url_complex']['regex'] = \"#\\[url=((?!javascript)[a-z]+?://)([^\\r\\n\\\"<]+?)\\](.+?)\\[/url\\]#si\";\n\t\t\t$callback_mycode['url_complex']['replacement'] = array($this, 'mycode_parse_url_callback1');\n\n\t\t\t$callback_mycode['url_complex2']['regex'] = \"#\\[url=((?!javascript:)[^\\r\\n\\\"<]+?)\\](.+?)\\[/url\\]#si\";\n\t\t\t$callback_mycode['url_complex2']['replacement'] = array($this, 'mycode_parse_url_callback2');\n\n\t\t\t++$callback_count;\n\t\t}\n\n\t\tif($mybb->settings['allowemailmycode'] == 1)\n\t\t{\n\t\t\t$callback_mycode['email_simple']['regex'] = \"#\\[email\\]((?:[a-zA-Z0-9-_\\+\\.]+?)@[a-zA-Z0-9-]+\\.[a-zA-Z0-9\\.-]+(?:\\?.*?)?)\\[/email\\]#i\";\n\t\t\t$callback_mycode['email_simple']['replacement'] = array($this, 'mycode_parse_email_callback');\n\n\t\t\t$callback_mycode['email_complex']['regex'] = \"#\\[email=((?:[a-zA-Z0-9-_\\+\\.]+?)@[a-zA-Z0-9-]+\\.[a-zA-Z0-9\\.-]+(?:\\?.*?)?)\\](.*?)\\[/email\\]#i\";\n\t\t\t$callback_mycode['email_complex']['replacement'] = array($this, 'mycode_parse_email_callback');\n\n\t\t\t++$callback_count;\n\t\t}\n\n\t\tif($mybb->settings['allowcolormycode'] == 1)\n\t\t{\n\t\t\t$nestable_mycode['color']['regex'] = \"#\\[color=([a-zA-Z]*|\\#?[\\da-fA-F]{3}|\\#?[\\da-fA-F]{6})](.*?)\\[/color\\]#si\";\n\t\t\t$nestable_mycode['color']['replacement'] = \"<span style=\\\"color: $1;\\\" class=\\\"mycode_color\\\">$2</span>\";\n\n\t\t\t++$nestable_count;\n\t\t}\n\n\t\tif($mybb->settings['allowsizemycode'] == 1)\n\t\t{\n\t\t\t$nestable_mycode['size']['regex'] = \"#\\[size=(xx-small|x-small|small|medium|large|x-large|xx-large)\\](.*?)\\[/size\\]#si\";\n\t\t\t$nestable_mycode['size']['replacement'] = \"<span style=\\\"font-size: $1;\\\" class=\\\"mycode_size\\\">$2</span>\";\n\n\t\t\t$callback_mycode['size_int']['regex'] = \"#\\[size=([0-9\\+\\-]+?)\\](.*?)\\[/size\\]#si\";\n\t\t\t$callback_mycode['size_int']['replacement'] = array($this, 'mycode_handle_size_callback');\n\n\t\t\t++$nestable_count;\n\t\t\t++$callback_count;\n\t\t}\n\n\t\tif($mybb->settings['allowfontmycode'] == 1)\n\t\t{\n\t\t\t$nestable_mycode['font']['regex'] = \"#\\[font=(\\\"?)([a-z0-9 ,\\-_']+)\\\\1\\](.*?)\\[/font\\]#si\";\n\t\t\t$nestable_mycode['font']['replacement'] = \"<span style=\\\"font-family: $2;\\\" class=\\\"mycode_font\\\">$3</span>\";\n\n\t\t\t++$nestable_count;\n\t\t}\n\n\t\tif($mybb->settings['allowalignmycode'] == 1)\n\t\t{\n\t\t\t$nestable_mycode['align']['regex'] = \"#\\[align=(left|center|right|justify)\\](.*?)\\[/align\\]#si\";\n\t\t\t$nestable_mycode['align']['replacement'] = \"<div style=\\\"text-align: $1;\\\" class=\\\"mycode_align\\\">$2</div>\";\n\n\t\t\t++$nestable_count;\n\t\t}\n\n\t\t$custom_mycode = $cache->read(\"mycode\");\n\n\t\t// If there is custom MyCode, load it.\n\t\tif(is_array($custom_mycode))\n\t\t{\n\t\t\tforeach($custom_mycode as $key => $mycode)\n\t\t\t{\n\t\t\t\t$mycode['regex'] = str_replace(\"\\x0\", \"\", $mycode['regex']);\n\t\t\t\t$custom_mycode[$key]['regex'] = \"#\".$mycode['regex'].\"#si\";\n\n\t\t\t\t++$standard_count;\n\t\t\t}\n\t\t\t$mycode = array_merge($standard_mycode, $custom_mycode);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$mycode = $standard_mycode;\n\t\t}\n\n\t\t// Assign the MyCode to the cache.\n\t\tforeach($mycode as $code)\n\t\t{\n\t\t\t$this->mycode_cache['standard']['find'][] = $code['regex'];\n\t\t\t$this->mycode_cache['standard']['replacement'][] = $code['replacement'];\n\t\t}\n\n\t\t// Assign the nestable MyCode to the cache.\n\t\tforeach($nestable_mycode as $code)\n\t\t{\n\t\t\t$this->mycode_cache['nestable'][] = array('find' => $code['regex'], 'replacement' => $code['replacement']);\n\t\t}\n\n\t\t// Assign the nestable MyCode to the cache.\n\t\tforeach($callback_mycode as $code)\n\t\t{\n\t\t\t$this->mycode_cache['callback'][] = array('find' => $code['regex'], 'replacement' => $code['replacement']);\n\t\t}\n\n\t\t$this->mycode_cache['standard_count'] = $standard_count;\n\t\t$this->mycode_cache['callback_count'] = $callback_count;\n\t\t$this->mycode_cache['nestable_count'] = $nestable_count;\n\t}\n\n\t/**\n\t * Parses MyCode tags in a specific message with the specified options.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @param array $options Array of options in yes/no format. Options are allow_imgcode.\n\t * @return string The parsed message.\n\t */\n\tfunction parse_mycode($message, $options=array())\n\t{\n\t\tglobal $lang, $mybb;\n\n\t\tif(empty($this->options))\n\t\t{\n\t\t\t$this->options = $options;\n\t\t}\n\n\t\t// Cache the MyCode globally if needed.\n\t\tif($this->mycode_cache == 0)\n\t\t{\n\t\t\t$this->cache_mycode();\n\t\t}\n\n\t\t// Parse quotes first\n\t\t$message = $this->mycode_parse_quotes($message);\n\n\t\t// Convert images when allowed.\n\t\tif(!empty($this->options['allow_imgcode']))\n\t\t{\n\t\t\t$message = preg_replace_callback(\"#\\[img\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_callback1'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_callback2'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img align=(left|right)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_callback3'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*) align=(left|right)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_callback4'), $message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$message = preg_replace_callback(\"#\\[img\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_disabled_callback1'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_disabled_callback2'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img align=(left|right)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_disabled_callback3'), $message);\n\t\t\t$message = preg_replace_callback(\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*) align=(left|right)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\", array($this, 'mycode_parse_img_disabled_callback4'), $message);\n\t\t}\n\n\t\t// Convert videos when allow.\n\t\tif(!empty($this->options['allow_videocode']))\n\t\t{\n\t\t\t$message = preg_replace_callback(\"#\\[video=(.*?)\\](.*?)\\[/video\\]#i\", array($this, 'mycode_parse_video_callback'), $message);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$message = preg_replace_callback(\"#\\[video=(.*?)\\](.*?)\\[/video\\]#i\", array($this, 'mycode_parse_video_disabled_callback'), $message);\n\t\t}\n\n\t\t$message = str_replace('$', '&#36;', $message);\n\n\t\t// Replace the rest\n\t\tif($this->mycode_cache['standard_count'] > 0)\n\t\t{\n\t\t\t$message = preg_replace($this->mycode_cache['standard']['find'], $this->mycode_cache['standard']['replacement'], $message);\n\t\t}\n\n\t\tif($this->mycode_cache['callback_count'] > 0)\n\t\t{\n\t\t\tforeach($this->mycode_cache['callback'] as $replace)\n\t\t\t{\n\t\t\t\t$message = preg_replace_callback($replace['find'], $replace['replacement'], $message);\n\t\t\t}\n\t\t}\n\n\t\t// Replace the nestable mycode's\n\t\tif($this->mycode_cache['nestable_count'] > 0)\n\t\t{\n\t\t\tforeach($this->mycode_cache['nestable'] as $mycode)\n\t\t\t{\n\t\t\t\twhile(preg_match($mycode['find'], $message))\n\t\t\t\t{\n\t\t\t\t\t$message = preg_replace($mycode['find'], $mycode['replacement'], $message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reset list cache\n\t\tif($mybb->settings['allowlistmycode'] == 1)\n\t\t{\n\t\t\t$this->list_elements = array();\n\t\t\t$this->list_count = 0;\n\n\t\t\t// Find all lists\n\t\t\t$message = preg_replace_callback(\"#(\\[list(=(a|A|i|I|1))?\\]|\\[/list\\])#si\", array($this, 'mycode_prepare_list'), $message);\n\n\t\t\t// Replace all lists\n\t\t\tfor($i = $this->list_count; $i > 0; $i--)\n\t\t\t{\n\t\t\t\t// Ignores missing end tags\n\t\t\t\t$message = preg_replace_callback(\"#\\s?\\[list(=(a|A|i|I|1))?&{$i}\\](.*?)(\\[/list&{$i}\\]|$)(\\r\\n?|\\n?)#si\", array($this, 'mycode_parse_list_callback'), $message, 1);\n\t\t\t}\n\t\t}\n\n\t\t$message = $this->mycode_auto_url($message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Generates a cache of smilies\n\t *\n\t * @access private\n\t */\n\tfunction cache_smilies()\n\t{\n\t\tglobal $cache, $mybb, $theme, $templates;\n\t\t$this->smilies_cache = array();\n\n\t\t$smilies = $cache->read(\"smilies\");\n\t\tif(is_array($smilies))\n\t\t{\n\t\t\t$extra_class = $onclick = '';\n\t\t\tforeach($smilies as $sid => $smilie)\n\t\t\t{\n\t\t\t\t$smilie['find'] = explode(\"\\n\", $smilie['find']);\n\t\t\t\t$smilie['image'] = str_replace(\"{theme}\", $theme['imgdir'], $smilie['image']);\n\t\t\t\t$smilie['image'] = htmlspecialchars_uni($mybb->get_asset_url($smilie['image']));\n\t\t\t\t$smilie['name'] = htmlspecialchars_uni($smilie['name']);\n\n\t\t\t\tforeach($smilie['find'] as $s)\n\t\t\t\t{\n\t\t\t\t\t$s = $this->parse_html($s);\n\t\t\t\t\teval(\"\\$smilie_template = \\\"\".$templates->get(\"smilie\", 1, 0).\"\\\";\");\n\t\t\t\t\t$this->smilies_cache[$s] = $smilie_template;\n\t\t\t\t\t// workaround for smilies starting with ;\n\t\t\t\t\tif($s[0] == \";\")\n\t\t\t\t\t{\n\t\t\t\t\t\t$this->smilies_cache += array(\n\t\t\t\t\t\t\t\"&amp$s\" => \"&amp$s\",\n\t\t\t\t\t\t\t\"&lt$s\" => \"&lt$s\",\n\t\t\t\t\t\t\t\"&gt$s\" => \"&gt$s\",\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parses smilie code in the specified message.\n\t *\n\t * @param string $message $message The message being parsed.\n\t * @param int $allow_html not used\n\t * @return string The parsed message.\n\t */\n\tfunction parse_smilies($message, $allow_html=0)\n\t{\n\t\tif($this->smilies_cache == 0)\n\t\t{\n\t\t\t$this->cache_smilies();\n\t\t}\n\n\t\t// No smilies?\n\t\tif(!count($this->smilies_cache))\n\t\t{\n\t\t\treturn $message;\n\t\t}\n\n\t\t// First we take out any of the tags we don't want parsed between (url= etc)\n\t\tpreg_match_all(\"#\\[(url(=[^\\]]*)?\\]|quote=([^\\]]*)?\\])|(http|ftp)(s|)://[^\\s]*#i\", $message, $bad_matches, PREG_PATTERN_ORDER);\n\t\tif(count($bad_matches[0]) > 0)\n\t\t{\n\t\t\t$message = preg_replace(\"#\\[(url(=[^\\]]*)?\\]|quote=([^\\]]*)?\\])|(http|ftp)(s|)://[^\\s]*#si\", \"<mybb-bad-sm>\", $message);\n\t\t}\n\n\t\t$message = strtr($message, $this->smilies_cache);\n\n\t\t// If we matched any tags previously, swap them back in\n\t\tif(count($bad_matches[0]) > 0)\n\t\t{\n\t\t\t$message = explode(\"<mybb-bad-sm>\", $message);\n\t\t\t$i = 0;\n\t\t\tforeach($bad_matches[0] as $match)\n\t\t\t{\n\t\t\t\t$message[$i] .= $match;\n\t\t\t\t$i++;\n\t\t\t}\n\t\t\t$message = implode(\"\", $message);\n\t\t}\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Generates a cache of badwords filters.\n\t *\n\t * @access private\n\t */\n\tfunction cache_badwords()\n\t{\n\t\tglobal $cache;\n\t\t$this->badwords_cache = array();\n\t\t$this->badwords_cache = $cache->read(\"badwords\");\n\t}\n\n\t/**\n\t * Parses a list of filtered/badwords in the specified message.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @param array $options Array of parser options in yes/no format.\n\t * @return string The parsed message.\n\t */\n\tfunction parse_badwords($message, $options=array())\n\t{\n\t\tif(empty($this->options))\n\t\t{\n\t\t\t$this->options = $options;\n\t\t}\n\n\t\tif($this->badwords_cache == 0)\n\t\t{\n\t\t\t$this->cache_badwords();\n\t\t}\n\t\tif(is_array($this->badwords_cache))\n\t\t{\n\t\t\treset($this->badwords_cache);\n\t\t\tforeach($this->badwords_cache as $bid => $badword)\n\t\t\t{\n\t\t\t\tif(!$badword['replacement'])\n\t\t\t\t{\n\t\t\t\t\t$badword['replacement'] = \"*****\";\n\t\t\t\t}\n\n\t\t\t\tif(!$badword['regex'])\n\t\t\t\t{\n\t\t\t\t\t$badword['badword'] = $this->generate_regex($badword['badword']);\n\t\t\t\t}\n\n\t\t\t\t$message = preg_replace('#'.$badword['badword'].'#is', $badword['replacement'], $message);\n\t\t\t}\n\t\t}\n\t\tif(!empty($this->options['strip_tags']))\n\t\t{\n\t\t\t$message = strip_tags($message);\n\t\t}\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Generates REGEX patterns based on user defined badword string.\n\t *\n\t * @param string $badword The word defined to replace.\n\t * @return string The regex pattern to match the word or null on error.\n\t */\n\tfunction generate_regex($bad_word = \"\")\n\t{\n\t\tif($bad_word == \"\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// Neutralize escape character, regex operators, multiple adjacent wildcards and generate pattern\n\t\t$ptrn = array('/\\\\\\\\/', '/([\\[\\^\\$\\.\\|\\?\\(\\)\\{\\}]{1})/', '/\\*\\++/', '/\\++\\*/', '/\\*+/');\n\t\t$rplc = array('\\\\\\\\\\\\\\\\','\\\\\\\\${1}', '*', '*', '[^\\s\\n]*');\n\t\t$bad_word = preg_replace($ptrn, $rplc, $bad_word);\n\t\t\n\t\t// Count + and generate pattern\n\t\t$bad_word = explode('+', $bad_word);\n\t\t$trap = \"\";\n\t\t$plus = 0;\n\t\tforeach($bad_word as $bad_piece)\n\t\t{\n\t\t\tif($bad_piece)\n\t\t\t{\n\t\t\t\t$trap .= $plus ? '[^\\s\\n]{'.$plus.'}'.$bad_piece : $bad_piece;\n\t\t\t\t$plus = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$plus++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Handle trailing +\n\t\tif($plus > 1)\n\t\t{\n\t\t\t$trap .= '[^\\s\\n]{'.($plus-1).'}';\n\t\t}\n\t\t\n\t\treturn '\\b'.$trap.'\\b';\n\t}\n\n\t/**\n\t * Resolves nested CDATA tags in the specified message.\n\t *\n\t * @param string $message The message to be parsed.\n\t * @return string The parsed message.\n\t */\n\tfunction parse_cdata($message)\n\t{\n\t\t$message = str_replace(']]>', ']]]]><![CDATA[>', $message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Attempts to move any javascript references in the specified message.\n\t *\n\t * @param string The message to be parsed.\n\t * @return string The parsed message.\n\t */\n\tfunction fix_javascript($message)\n\t{\n\t\t$js_array = array(\n\t\t\t\"#(&\\#(0*)106;?|&\\#(0*)74;?|&\\#x(0*)4a;?|&\\#x(0*)6a;?|j)((&\\#(0*)97;?|&\\#(0*)65;?|a)(&\\#(0*)118;?|&\\#(0*)86;?|v)(&\\#(0*)97;?|&\\#(0*)65;?|a)(\\s)?(&\\#(0*)115;?|&\\#(0*)83;?|s)(&\\#(0*)99;?|&\\#(0*)67;?|c)(&\\#(0*)114;?|&\\#(0*)82;?|r)(&\\#(0*)105;?|&\\#(0*)73;?|i)(&\\#112;?|&\\#(0*)80;?|p)(&\\#(0*)116;?|&\\#(0*)84;?|t)(&\\#(0*)58;?|\\:))#i\",\n\t\t\t\"#([\\s\\\"']on)([a-z]+\\s*=)#i\",\n\t\t);\n\n\t\t// Add invisible white space\n\t\t$message = preg_replace($js_array, \"$1\\xE2\\x80\\x8C$2$6\", $message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t* Handles fontsize.\n\t*\n\t* @param int $size The original size.\n\t* @param string $text The text within a size tag.\n\t* @return string The parsed text.\n\t*/\n\tfunction mycode_handle_size($size, $text)\n\t{\n\t\tglobal $templates;\n\n\t\t$size = (int)$size;\n\n\t\tif($size < 1)\n\t\t{\n\t\t\t$size = 1;\n\t\t}\n\n\t\tif($size > 50)\n\t\t{\n\t\t\t$size = 50;\n\t\t}\n\n\t\t$text = str_replace(\"\\'\", \"'\", $text);\n\n\t\teval(\"\\$mycode_size = \\\"\".$templates->get(\"mycode_size_int\", 1, 0).\"\\\";\");\n\t\treturn $mycode_size;\n\t}\n\n\t/**\n\t* Handles fontsize.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed text.\n\t*/\n\tfunction mycode_handle_size_callback($matches)\n\t{\n\t\treturn $this->mycode_handle_size($matches[1], $matches[2]);\n\t}\n\n\t/**\n\t* Parses quote MyCode.\n\t*\n\t* @param string $message The message to be parsed\n\t* @param boolean $text_only Are we formatting as text?\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_quotes($message, $text_only=false)\n\t{\n\t\tglobal $lang, $templates, $theme, $mybb;\n\n\t\t// Assign pattern and replace values.\n\t\t$pattern = \"#\\[quote\\](.*?)\\[\\/quote\\](\\r\\n?|\\n?)#si\";\n\t\t$pattern_callback = \"#\\[quote=([\\\"']|&quot;|)(.*?)(?:\\\\1)(.*?)(?:[\\\"']|&quot;)?\\](.*?)\\[/quote\\](\\r\\n?|\\n?)#si\";\n\n\t\tif($text_only == false)\n\t\t{\n\t\t\t$replace = \"<blockquote class=\\\"mycode_quote\\\"><cite>$lang->quote</cite>$1</blockquote>\\n\";\n\t\t\t$replace_callback = array($this, 'mycode_parse_post_quotes_callback1');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$replace = empty($this->options['signature_parse']) ? \"\\n{$lang->quote}\\n--\\n$1\\n--\\n\" : \"$1\";\n\t\t\t$replace_callback = array($this, 'mycode_parse_post_quotes_callback2');\n\t\t}\n\n\t\tdo\n\t\t{\n\t\t\t// preg_replace has erased the message? Restore it...\n\t\t\t$previous_message = $message;\n\t\t\t$message = preg_replace($pattern, $replace, $message, -1, $count);\n\t\t\t$message = preg_replace_callback($pattern_callback, $replace_callback, $message, -1, $count_callback);\n\t\t\tif(!$message)\n\t\t\t{\n\t\t\t\t$message = $previous_message;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while($count || $count_callback);\n\n\t\tif($text_only == false)\n\t\t{\n\t\t\t$find = array(\n\t\t\t\t\"#(\\r\\n*|\\n*)<\\/cite>(\\r\\n*|\\n*)#\",\n\t\t\t\t\"#(\\r\\n*|\\n*)<\\/blockquote>#\"\n\t\t\t);\n\n\t\t\t$replace = array(\n\t\t\t\t\"</cite><br />\",\n\t\t\t\t\"</blockquote>\"\n\t\t\t);\n\t\t\t$message = preg_replace($find, $replace, $message);\n\t\t}\n\t\treturn $message;\n\t}\n\n\t/**\n\t* Parses quotes with post id and/or dateline.\n\t*\n\t* @param string $message The message to be parsed\n\t* @param string $username The username to be parsed\n\t* @param boolean $text_only Are we formatting as text?\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_post_quotes($message, $username, $text_only=false)\n\t{\n\t\tglobal $lang, $templates, $theme, $mybb;\n\n\t\t$linkback = $date = \"\";\n\n\t\t$message = trim($message);\n\t\t$message = preg_replace(\"#(^<br(\\s?)(\\/?)>|<br(\\s?)(\\/?)>$)#i\", \"\", $message);\n\n\t\tif(!$message)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\t$username .= \"'\";\n\t\t$delete_quote = true;\n\n\t\tpreg_match(\"#pid=(?:&quot;|\\\"|')?([0-9]+)[\\\"']?(?:&quot;|\\\"|')?#i\", $username, $match);\n\t\tif((int)$match[1])\n\t\t{\n\t\t\t$pid = (int)$match[1];\n\t\t\t$url = $mybb->settings['bburl'].\"/\".get_post_link($pid).\"#pid$pid\";\n\t\t\tif(defined(\"IN_ARCHIVE\"))\n\t\t\t{\n\t\t\t\t$linkback = \" <a href=\\\"{$url}\\\">[ -> ]</a>\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\teval(\"\\$linkback = \\\" \".$templates->get(\"postbit_gotopost\", 1, 0).\"\\\";\");\n\t\t\t}\n\n\t\t\t$username = preg_replace(\"#(?:&quot;|\\\"|')? pid=(?:&quot;|\\\"|')?[0-9]+[\\\"']?(?:&quot;|\\\"|')?#i\", '', $username);\n\t\t\t$delete_quote = false;\n\t\t}\n\n\t\tunset($match);\n\t\tpreg_match(\"#dateline=(?:&quot;|\\\"|')?([0-9]+)(?:&quot;|\\\"|')?#i\", $username, $match);\n\t\tif((int)$match[1])\n\t\t{\n\t\t\tif($match[1] < TIME_NOW)\n\t\t\t{\n\t\t\t\tif($text_only)\n\t\t\t\t{\n\t\t\t\t\t$postdate = my_date('normal', (int)$match[1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$postdate = my_date('relative', (int)$match[1]);\n\t\t\t\t}\n\t\t\t\t$date = \" ({$postdate})\";\n\t\t\t}\n\t\t\t$username = preg_replace(\"#(?:&quot;|\\\"|')? dateline=(?:&quot;|\\\"|')?[0-9]+(?:&quot;|\\\"|')?#i\", '', $username);\n\t\t\t$delete_quote = false;\n\t\t}\n\n\t\tif($delete_quote)\n\t\t{\n\t\t\t$username = my_substr($username, 0, my_strlen($username)-1);\n\t\t}\n\n\t\tif(!empty($this->options['allow_html']))\n\t\t{\n\t\t\t$username = htmlspecialchars_uni($username);\n\t\t}\n\n\t\tif($text_only)\n\t\t{\n\t\t\treturn \"\\n{$username} {$lang->wrote}{$date}\\n--\\n{$message}\\n--\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$span = \"\";\n\t\t\tif(!$delete_quote)\n\t\t\t{\n\t\t\t\t$span = \"<span>{$date}</span>\";\n\t\t\t}\n\n\t\t\teval(\"\\$mycode_quote = \\\"\".$templates->get(\"mycode_quote_post\", 1, 0).\"\\\";\");\n\t\t\treturn $mycode_quote;\n\t\t}\n\t}\n\n\t/**\n\t* Parses quotes with post id and/or dateline.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_post_quotes_callback1($matches)\n\t{\n\t\treturn $this->mycode_parse_post_quotes($matches[4],$matches[2].$matches[3]);\n\t}\n\n\t/**\n\t* Parses quotes with post id and/or dateline.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_post_quotes_callback2($matches)\n\t{\n\t\treturn $this->mycode_parse_post_quotes($matches[4],$matches[2].$matches[3], true);\n\t}\n\n\t/**\n\t* Parses code MyCode.\n\t*\n\t* @param string $code The message to be parsed\n\t* @param boolean $text_only Are we formatting as text?\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_code($code, $text_only=false)\n\t{\n\t\tglobal $lang, $templates;\n\n\t\tif($text_only == true)\n\t\t{\n\t\t\treturn empty($this->options['signature_parse']) ? \"\\n{$lang->code}\\n--\\n{$code}\\n--\\n\" : $code;\n\t\t}\n\n\t\t// Clean the string before parsing.\n\t\t$code = preg_replace('#^(\\t*)(\\n|\\r|\\0|\\x0B| )*#', '\\\\1', $code);\n\t\t$code = rtrim($code);\n\t\t$original = preg_replace('#^\\t*#', '', $code);\n\n\t\tif(empty($original))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t$code = str_replace('$', '&#36;', $code);\n\t\t$code = preg_replace('#\\$([0-9])#', '\\\\\\$\\\\1', $code);\n\t\t$code = str_replace('\\\\', '&#92;', $code);\n\t\t$code = str_replace(\"\\t\", '&nbsp;&nbsp;&nbsp;&nbsp;', $code);\n\t\t$code = str_replace(\"  \", '&nbsp;&nbsp;', $code);\n\n\t\teval(\"\\$mycode_code = \\\"\".$templates->get(\"mycode_code\", 1, 0).\"\\\";\");\n\t\treturn $mycode_code;\n\t}\n\n\t/**\n\t* Parses code MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_code_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_code($matches[1], true);\n\t}\n\n\t/**\n\t* Parses PHP code MyCode.\n\t*\n\t* @param string $str The message to be parsed\n\t* @param boolean $bare_return Whether or not it should return it as pre-wrapped in a div or not.\n\t* @param boolean $text_only Are we formatting as text?\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_php($str, $bare_return = false, $text_only = false)\n\t{\n\t\tglobal $lang, $templates;\n\n\t\tif($text_only == true)\n\t\t{\n\t\t\treturn empty($this->options['signature_parse']) ? \"\\n{$lang->php_code}\\n--\\n{$str}\\n--\\n\" : $str;\n\t\t}\n\n\t\t// Clean the string before parsing except tab spaces.\n\t\t$str = preg_replace('#^(\\t*)(\\n|\\r|\\0|\\x0B| )*#', '\\\\1', $str);\n\t\t$str = rtrim($str);\n\n\t\t$original = preg_replace('#^\\t*#', '', $str);\n\n\t\tif(empty($original))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// See if open and close tags are provided.\n\t\t$added_open_tag = false;\n\t\tif(!preg_match(\"#^\\s*<\\?#si\", $str))\n\t\t{\n\t\t\t$added_open_tag = true;\n\t\t\t$str = \"<?php \\n\".$str;\n\t\t}\n\n\t\t$added_end_tag = false;\n\t\tif(!preg_match(\"#\\?>\\s*$#si\", $str))\n\t\t{\n\t\t\t$added_end_tag = true;\n\t\t\t$str = $str.\" \\n?>\";\n\t\t}\n\n\t\t$code = @highlight_string($str, true);\n\n\t\t// Do the actual replacing.\n\t\t$code = preg_replace('#<code>\\s*<span style=\"color: \\#000000\">\\s*#i', \"<code>\", $code);\n\t\t$code = preg_replace(\"#</span>\\s*</code>#\", \"</code>\", $code);\n\t\t$code = preg_replace(\"#</span>(\\r\\n?|\\n?)</code>#\", \"</span></code>\", $code);\n\t\t$code = str_replace(\"\\\\\", '&#092;', $code);\n\t\t$code = str_replace('$', '&#36;', $code);\n\t\t$code = preg_replace(\"#&amp;\\#([0-9]+);#si\", \"&#$1;\", $code);\n\n\t\tif($added_open_tag)\n\t\t{\n\t\t\t$code = preg_replace(\"#<code><span style=\\\"color: \\#([A-Z0-9]{6})\\\">&lt;\\?php( |&nbsp;)(<br />?)#\", \"<code><span style=\\\"color: #$1\\\">\", $code);\n\t\t}\n\n\t\tif($added_end_tag)\n\t\t{\n\t\t\t$code = str_replace(\"?&gt;</span></code>\", \"</span></code>\", $code);\n\t\t\t// Wait a minute. It fails highlighting? Stupid highlighter.\n\t\t\t$code = str_replace(\"?&gt;</code>\", \"</code>\", $code);\n\t\t}\n\n\t\t$code = preg_replace(\"#<span style=\\\"color: \\#([A-Z0-9]{6})\\\"></span>#\", \"\", $code);\n\t\t$code = str_replace(\"<code>\", \"<div dir=\\\"ltr\\\"><code>\", $code);\n\t\t$code = str_replace(\"</code>\", \"</code></div>\", $code);\n\t\t$code = preg_replace(\"# *$#\", \"\", $code);\n\n\t\tif($bare_return)\n\t\t{\n\t\t\treturn $code;\n\t\t}\n\n\t\t// Send back the code all nice and pretty\n\t\teval(\"\\$mycode_php = \\\"\".$templates->get(\"mycode_php\", 1, 0).\"\\\";\");\n\t\treturn $mycode_php;\n\t}\n\n\t/**\n\t* Parses PHP code MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_php_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_php($matches[1], false, true);\n\t}\n\n\t/**\n\t* Parses URL MyCode.\n\t*\n\t* @param string $url The URL to link to.\n\t* @param string $name The name of the link.\n\t* @return string The built-up link.\n\t*/\n\tfunction mycode_parse_url($url, $name=\"\")\n\t{\n\t\tglobal $templates;\n\t\tif(!preg_match(\"#^[a-z0-9]+://#i\", $url))\n\t\t{\n\t\t\t$url = \"http://\".$url;\n\t\t}\n\n\t\tif(!empty($this->options['allow_html']))\n\t\t{\n\t\t\t$url = $this->parse_html($url);\n\t\t}\n\n\t\tif(!$name)\n\t\t{\n\t\t\t$name = $url;\n\t\t}\n\n\t\tif($name == $url && (!isset($this->options['shorten_urls']) || !empty($this->options['shorten_urls'])))\n\t\t{\n\t\t\t$name = htmlspecialchars_decode($name);\n\t\t\tif(my_strlen($name) > 55)\n\t\t\t{\n\t\t\t\t$name = my_substr($name , 0, 40).'...'.my_substr($name , -10);\n\t\t\t}\n\t\t\t$name = htmlspecialchars_uni($name);\n\t\t}\n\n\t\tif(!empty($this->options['nofollow_on']))\n\t\t{\n\t\t\t$rel = \" rel=\\\"noopener nofollow\\\"\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$rel = \" rel=\\\"noopener\\\"\";\n\t\t}\n\n\t\t// Fix some entities in URLs\n\t\t$url = $this->encode_url($url);\n\t\t$name = $this->parse_badwords(preg_replace(\"#&amp;\\#([0-9]+);#si\", \"&#$1;\", $name)); // Fix & but allow unicode, filter bad words\n\n\t\teval(\"\\$mycode_url = \\\"\".$templates->get(\"mycode_url\", 1, 0).\"\\\";\");\n\t\treturn $mycode_url;\n\t}\n\n\t/**\n\t* Parses URL MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The built-up link.\n\t*/\n\tfunction mycode_parse_url_callback1($matches)\n\t{\n\t\tif(!isset($matches[3]))\n\t\t{\n\t\t\t$matches[3] = '';\n\t\t}\n\t\treturn $this->mycode_parse_url($matches[1].$matches[2], $matches[3]);\n\t}\n\n\t/**\n\t* Parses URL MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The built-up link.\n\t*/\n\tfunction mycode_parse_url_callback2($matches)\n\t{\n\t\tif(!isset($matches[2]))\n\t\t{\n\t\t\t$matches[2] = '';\n\t\t}\n\t\treturn $this->mycode_parse_url($matches[1], $matches[2]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param string $url The URL to the image\n\t * @param array $dimensions Optional array of dimensions\n\t * @param string $align\n\t * @return string\n\t */\n\tfunction mycode_parse_img($url, $dimensions=array(), $align='')\n\t{\n\t\tglobal $lang, $templates;\n\t\t$url = trim($url);\n\t\t$url = str_replace(\"\\n\", \"\", $url);\n\t\t$url = str_replace(\"\\r\", \"\", $url);\n\n\t\tif(!empty($this->options['allow_html']))\n\t\t{\n\t\t\t$url = $this->parse_html($url);\n\t\t}\n\n\t\t$css_align = '';\n\t\tif($align == \"right\")\n\t\t{\n\t\t\t$css_align = ' style=\"float: right;\"';\n\t\t}\n\t\telse if($align == \"left\")\n\t\t{\n\t\t\t$css_align = ' style=\"float: left;\"';\n\t\t}\n\n\t\tif($align)\n\t\t{\n\t\t\t$this->clear_needed = true;\n\t\t}\n\n\t\t$alt = basename($url);\n\t\t$alt = htmlspecialchars_decode($alt);\n\t\tif(my_strlen($alt) > 55)\n\t\t{\n\t\t\t$alt = my_substr($alt, 0, 40).'...'.my_substr($alt, -10);\n\t\t}\n\t\t$alt = $this->encode_url($alt);\n\n\t\t$alt = $lang->sprintf($lang->posted_image, $alt);\n\t\t$width = $height = '';\n\t\tif(isset($dimensions[0]) && $dimensions[0] > 0 && isset($dimensions[1]) && $dimensions[1] > 0)\n\t\t{\n\t\t\t$width = \" width=\\\"{$dimensions[0]}\\\"\";\n\t\t\t$height = \" height=\\\"{$dimensions[1]}\\\"\";\n\t\t}\n\n\t\t$url = $this->encode_url($url);\n\n\t\teval(\"\\$mycode_img = \\\"\".$templates->get(\"mycode_img\", 1, 0).\"\\\";\");\n\t\treturn $mycode_img;\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_callback1($matches)\n\t{\n\t\treturn $this->mycode_parse_img($matches[2]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_callback2($matches)\n\t{\n\t\treturn $this->mycode_parse_img($matches[4], array($matches[1], $matches[2]));\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_callback3($matches)\n\t{\n\t\treturn $this->mycode_parse_img($matches[3], array(), $matches[1]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_callback4($matches)\n\t{\n\t\treturn $this->mycode_parse_img($matches[5], array($matches[1], $matches[2]), $matches[3]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param string $url The URL to the image\n\t * @return string\n\t */\n\tfunction mycode_parse_img_disabled($url)\n\t{\n\t\tglobal $lang;\n\t\t$url = trim($url);\n\t\t$url = str_replace(\"\\n\", \"\", $url);\n\t\t$url = str_replace(\"\\r\", \"\", $url);\n\t\t$url = str_replace(\"\\'\", \"'\", $url);\n\n\t\t$image = $lang->sprintf($lang->posted_image, $this->mycode_parse_url($url));\n\t\treturn $image;\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_disabled_callback1($matches)\n\t{\n\t\treturn $this->mycode_parse_img_disabled($matches[2]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_disabled_callback2($matches)\n\t{\n\t\treturn $this->mycode_parse_img_disabled($matches[4]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_disabled_callback3($matches)\n\t{\n\t\treturn $this->mycode_parse_img_disabled($matches[3]);\n\t}\n\n\t/**\n\t * Parses IMG MyCode disabled.\n\t *\n\t * @param array $matches Matches.\n\t * @return string Image code.\n\t */\n\tfunction mycode_parse_img_disabled_callback4($matches)\n\t{\n\t\treturn $this->mycode_parse_img_disabled($matches[5]);\n\t}\n\n\t/**\n\t* Parses email MyCode.\n\t*\n\t* @param string $email The email address to link to.\n\t* @param string $name The name for the link.\n\t* @return string The built-up email link.\n\t*/\n\tfunction mycode_parse_email($email, $name=\"\")\n\t{\n\t\tglobal $templates;\n\n\t\tif(!$name)\n\t\t{\n\t\t\t$name = $email;\n\t\t}\n\n\t\t$email = $this->encode_url($email);\n\n\t\teval(\"\\$mycode_email = \\\"\".$templates->get(\"mycode_email\", 1, 0).\"\\\";\");\n\t\treturn $mycode_email;\n\t}\n\n\t/**\n\t* Parses email MyCode.\n\t*\n\t* @param array $matches Matches\n\t* @return string The built-up email link.\n\t*/\n\tfunction mycode_parse_email_callback($matches)\n\t{\n\t\tif(!isset($matches[2]))\n\t\t{\n\t\t\t$matches[2] = '';\n\t\t}\n\t\treturn $this->mycode_parse_email($matches[1], $matches[2]);\n\t}\n\n\t/**\n\t* Parses video MyCode.\n\t*\n\t* @param string $video The video provider.\n\t* @param string $url The video to link to.\n\t* @return string The built-up video code.\n\t*/\n\tfunction mycode_parse_video($video, $url)\n\t{\n\t\tglobal $templates;\n\n\t\tif(empty($video) || empty($url))\n\t\t{\n\t\t\treturn \"[video={$video}]{$url}[/video]\";\n\t\t}\n\n\t\t// Check URL is a valid URL first, as `parse_url` doesn't check validity.\n\t\tif(false === filter_var($url, FILTER_VALIDATE_URL))\n\t\t{\n            return \"[video={$video}]{$url}[/video]\";\n        }\n\n\t\t$parsed_url = @parse_url(urldecode($url));\n\t\tif($parsed_url === false)\n\t\t{\n\t\t\treturn \"[video={$video}]{$url}[/video]\";\n\t\t}\n\n\t\t$fragments = array();\n\t\tif($parsed_url['fragment'])\n\t\t{\n\t\t\t$fragments = explode(\"&\", $parsed_url['fragment']);\n\t\t}\n\n\t\tif($video == \"liveleak\")\n\t\t{\n\t\t\t// The query part can start with any alphabet, but set only 'i' to catch in index key later\n\t\t\t$parsed_url['query'] = \"i\".substr($parsed_url['query'], 1);\n\t\t}\n\n\t\t$queries = explode(\"&\", $parsed_url['query']);\n\n\t\t$input = array();\n\t\tforeach($queries as $query)\n\t\t{\n\t\t\tlist($key, $value) = explode(\"=\", $query);\n\t\t\t$key = str_replace(\"amp;\", \"\", $key);\n\t\t\t$input[$key] = $value;\n\t\t}\n\n\t\t$path = explode('/', $parsed_url['path']);\n\n\t\tswitch($video)\n\t\t{\n\t\t\tcase \"dailymotion\":\n\t\t\t\tif(isset($path[2]))\n\t\t\t\t{\n\t\t\t\t\tlist($id) = explode('_', $path[2], 2); // http://www.dailymotion.com/video/fds123_title-goes-here\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[1]; // http://dai.ly/fds123\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"metacafe\":\n\t\t\t\t$id = $path[2]; // http://www.metacafe.com/watch/fds123/title_goes_here/\n\t\t\t\t$title = htmlspecialchars_uni($path[3]);\n\t\t\t\tbreak;\n\t\t\tcase \"myspacetv\":\n\t\t\t\t$id = $path[4]; // http://www.myspace.com/video/fds/fds/123\n\t\t\t\tbreak;\n\t\t\tcase \"facebook\":\n\t\t\t\tif(isset($input['v']))\n\t\t\t\t{\n\t\t\t\t\t$id = $input['v']; // http://www.facebook.com/video/video.php?v=123\n\t\t\t\t}\n\t\t\t\telseif(substr($path[3], 0, 3) == 'vb.')\n\t\t\t\t{\n\t\t\t\t\t$id = $path[4]; // https://www.facebook.com/fds/videos/vb.123/123/\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[3]; // https://www.facebook.com/fds/videos/123/\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"mixer\":\n\t\t\t\t$id = $path[1]; // https://mixer.com/streamer\n\t\t\t\tbreak;\n\t\t\tcase \"liveleak\":\n\t\t\t\t$id = $input['i']; // http://www.liveleak.com/view?i=123\n\t\t\t\tbreak;\n\t\t\tcase \"yahoo\":\n\t\t\t\tif(isset($path[2]))\n\t\t\t\t{\n\t\t\t\t\t$id = $path[2]; // http://xy.screen.yahoo.com/fds/fds-123.html\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[1]; // http://xy.screen.yahoo.com/fds-123.html\n\t\t\t\t}\n\t\t\t\t// Support for localized portals\n\t\t\t\t$domain = explode('.', $parsed_url['host']);\n\t\t\t\tif($domain[0] != 'screen' && preg_match('#^([a-z-]+)$#', $domain[0]))\n\t\t\t\t{\n\t\t\t\t\t$local = \"{$domain[0]}.\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$local = '';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"vimeo\":\n\t\t\t\tif(isset($path[3]))\n\t\t\t\t{\n\t\t\t\t\t$id = $path[3]; // http://vimeo.com/fds/fds/fds123\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[1]; // http://vimeo.com/fds123\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"youtube\":\n\t\t\t\tif($fragments[0])\n\t\t\t\t{\n\t\t\t\t\t$id = str_replace('!v=', '', $fragments[0]); // http://www.youtube.com/watch#!v=fds123\n\t\t\t\t}\n\t\t\t\telseif($input['v'])\n\t\t\t\t{\n\t\t\t\t\t$id = $input['v']; // http://www.youtube.com/watch?v=fds123\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$id = $path[1]; // http://www.youtu.be/fds123\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"twitch\":\n\t\t\t\tif(count($path) >= 3 && $path[1] == 'videos')\n\t\t\t\t{\n\t\t\t\t\t// Direct video embed with URL like: https://www.twitch.tv/videos/179723472\n\t\t\t\t\t$id = 'video=v'.$path[2];\n\t\t\t\t}\n\t\t\t\telseif(count($path) >= 4 && $path[2] == 'v')\n\t\t\t\t{\n\t\t\t\t\t// Direct video embed with URL like: https://www.twitch.tv/waypoint/v/179723472\n\t\t\t\t\t$id = 'video=v'.$path[3];\n\t\t\t\t}\n\t\t\t\telseif(count($path) >= 2)\n\t\t\t\t{\n\t\t\t\t\t// Channel (livestream) embed with URL like: https://twitch.tv/waypoint\n\t\t\t\t\t$id = 'channel='.$path[1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn \"[video={$video}]{$url}[/video]\";\n\t\t}\n\n\t\tif(empty($id))\n\t\t{\n\t\t\treturn \"[video={$video}]{$url}[/video]\";\n\t\t}\n\n\t\t$id = $this->encode_url($id);\n\n\t\teval(\"\\$video_code = \\\"\".$templates->get(\"video_{$video}_embed\", 1, 0).\"\\\";\");\n\t\treturn $video_code;\n\t}\n\n\t/**\n\t* Parses video MyCode.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The built-up video code.\n\t*/\n\tfunction mycode_parse_video_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_video($matches[1], $matches[2]);\n\t}\n\n\t/**\n\t * Parses video MyCode disabled.\n\t *\n\t * @param string $url The URL to the video\n\t * @return string\n\t */\n\tfunction mycode_parse_video_disabled($url)\n\t{\n\t\tglobal $lang;\n\t\t$url = trim($url);\n\t\t$url = str_replace(\"\\n\", \"\", $url);\n\t\t$url = str_replace(\"\\r\", \"\", $url);\n\t\t$url = str_replace(\"\\'\", \"'\", $url);\n\n\t\t$video = $lang->sprintf($lang->posted_video, $this->mycode_parse_url($url));\n\t\treturn $video;\n\t}\n\n\t/**\n\t* Parses video MyCode disabled.\n\t*\n\t* @param array $matches Matches.\n\t* @return string The built-up video code.\n\t*/\n\tfunction mycode_parse_video_disabled_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_video_disabled($matches[2]);\n\t}\n\n\t/**\n\t* Parses URLs automatically.\n\t*\n\t* @param string $message The message to be parsed\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_auto_url($message)\n\t{\n\t\t$message = \" \".$message;\n\n\t\t// Links should end with slashes, numbers, characters and braces but not with dots, commas or question marks\n\t\t// Don't create links within existing links (handled up-front in the callback function).\n\t\t$message = preg_replace_callback(\"#<a\\\\s[^>]*>.*?</a>|([\\s\\(\\)\\[\\>])(http|https|ftp|news|irc|ircs|irc6){1}(://)([^\\/\\\"\\s\\<\\[\\.]+\\.([^\\/\\\"\\s\\<\\[\\.]+\\.)*[\\w]+(:[0-9]+)?(/([^\\\"\\s<\\[]|\\[\\])*)?([\\w\\/\\)]))#ius\", array($this, 'mycode_auto_url_callback'), $message);\n\t\t$message = preg_replace_callback(\"#<a\\\\s[^>]*>.*?</a>|([\\s\\(\\)\\[\\>])(www|ftp)(\\.)(([^\\/\\\"\\s\\<\\[\\.]+\\.)*[\\w]+(:[0-9]+)?(/([^\\\"\\s<\\[]|\\[\\])*)?([\\w\\/\\)]))#ius\", array($this, 'mycode_auto_url_callback'), $message);\n\t\t$message = my_substr($message, 1);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t* Parses URLs automatically.\n\t*\n\t* @param array $matches Matches\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_auto_url_callback($matches=array())\n\t{\n\t\t// If we matched a preexisting link (the part of the regexes in mycode_auto_url() before the pipe symbol),\n\t\t// then simply return it - we don't create links within existing links.\n\t\tif(count($matches) == 1)\n\t\t{\n\t\t\treturn $matches[0];\n\t\t}\n\n\t\t$external = '';\n\t\t// Allow links like http://en.wikipedia.org/wiki/PHP_(disambiguation) but detect mismatching braces\n\t\twhile(my_substr($matches[4], -1) == ')')\n\t\t{\n\t\t\tif(substr_count($matches[4], ')') > substr_count($matches[4], '('))\n\t\t\t{\n\t\t\t\t$matches[4] = my_substr($matches[4], 0, -1);\n\t\t\t\t$external = ')'.$external;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Example: ([...] http://en.wikipedia.org/Example_(disambiguation).)\n\t\t\t$last_char = my_substr($matches[4], -1);\n\t\t\twhile($last_char == '.' || $last_char == ',' || $last_char == '?' || $last_char == '!')\n\t\t\t{\n\t\t\t\t$matches[4] = my_substr($matches[4], 0, -1);\n\t\t\t\t$external = $last_char.$external;\n\t\t\t\t$last_char = my_substr($matches[4], -1);\n\t\t\t}\n\t\t}\n\t\t$url = \"{$matches[2]}{$matches[3]}{$matches[4]}\";\n\n\t\treturn $matches[1].$this->mycode_parse_url($url, $url).$external;\n\t}\n\n\t/**\n\t* Parses list MyCode.\n\t*\n\t* @param string $message The message to be parsed\n\t* @param string $type The list type\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_list($message, $type=\"\")\n\t{\n\t\t// No list elements? That's invalid HTML\n\t\tif(strpos($message, '[*]') === false)\n\t\t{\n\t\t\t$message = \"[*]{$message}\";\n\t\t}\n\n\t\t$message = preg_split(\"#[^\\S\\n\\r]*\\[\\*\\]\\s*#\", $message);\n\t\tif(isset($message[0]) && trim($message[0]) == '')\n\t\t{\n\t\t\tarray_shift($message);\n\t\t}\n\t\t$message = '<li>'.implode(\"</li>\\n<li>\", $message).\"</li>\\n\";\n\n\t\tif($type)\n\t\t{\n\t\t\t$list = \"\\n<ol type=\\\"$type\\\" class=\\\"mycode_list\\\">$message</ol>\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$list = \"<ul class=\\\"mycode_list\\\">$message</ul>\\n\";\n\t\t}\n\t\t$list = preg_replace(\"#<(ol type=\\\"$type\\\"|ul)>\\s*</li>#\", \"<$1>\", $list);\n\t\treturn $list;\n\t}\n\n\t/**\n\t* Parses list MyCode.\n\t*\n\t* @param array $matches Matches\n\t* @return string The parsed message.\n\t*/\n\tfunction mycode_parse_list_callback($matches)\n\t{\n\t\treturn $this->mycode_parse_list($matches[3], $matches[2]);\n\t}\n\n\t/**\n\t* Prepares list MyCode by finding the matching list tags.\n\t*\n\t* @param array $matches Matches\n\t* @return string Temporary replacements.\n\t*/\n\tfunction mycode_prepare_list($matches)\n\t{\n\t\t// Append number to identify matching list tags\n\t\tif(strcasecmp($matches[1], '[/list]') == 0)\n\t\t{\n\t\t\t$count = array_pop($this->list_elements);\n\t\t\tif($count !== NULL)\n\t\t\t{\n\t\t\t\treturn \"[/list&{$count}]\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// No open list tag...\n\t\t\t\treturn $matches[0];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++$this->list_count;\n\t\t\t$this->list_elements[] = $this->list_count;\n\t\t\tif(!empty($matches[2]))\n\t\t\t{\n\t\t\t\treturn \"[list{$matches[2]}&{$this->list_count}]\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn \"[list&{$this->list_count}]\";\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Strips smilies from a string\n\t *\n\t * @param string $message The message for smilies to be stripped from\n\t * @return string The message with smilies stripped\n\t */\n\tfunction strip_smilies($message)\n\t{\n\t\tif($this->smilies_cache == 0)\n\t\t{\n\t\t\t$this->cache_smilies();\n\t\t}\n\t\tif(is_array($this->smilies_cache))\n\t\t{\n\t\t\t$message = str_replace($this->smilies_cache, array_keys($this->smilies_cache), $message);\n\t\t}\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Highlights a string\n\t *\n\t * @param string $message The message to be highligted\n\t * @param string $highlight The highlight keywords\n\t * @return string The message with highlight bbcodes\n\t */\n\tfunction highlight_message($message, $highlight)\n\t{\n\t\tif(empty($this->highlight_cache))\n\t\t{\n\t\t\t$this->highlight_cache = build_highlight_array($highlight);\n\t\t}\n\n\t\tif(is_array($this->highlight_cache) && !empty($this->highlight_cache))\n\t\t{\n\t\t\t$message = preg_replace(array_keys($this->highlight_cache), $this->highlight_cache, $message);\n\t\t}\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Parses message to plain text equivalents of MyCode.\n\t *\n\t * @param string $message The message to be parsed\n\t * @param array $options\n\t * @return string The parsed message.\n\t */\n\tfunction text_parse_message($message, $options=array())\n\t{\n\t\tglobal $plugins;\n\n\t\tif(empty($this->options))\n\t\t{\n\t\t\t$this->options = $options;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach($options as $option_name => $option_value)\n\t\t\t{\n\t\t\t\t$this->options[$option_name] = $option_value;\n\t\t\t}\n\t\t}\n\n\t\t// Filter bad words if requested.\n\t\tif(!empty($this->options['filter_badwords']))\n\t\t{\n\t\t\t$message = $this->parse_badwords($message);\n\t\t}\n\n\t\t// Parse quotes first\n\t\t$message = $this->mycode_parse_quotes($message, true);\n\n\t\t$message = preg_replace_callback(\"#\\[php\\](.*?)\\[/php\\](\\r\\n?|\\n?)#is\", array($this, 'mycode_parse_php_callback'), $message);\n\t\t$message = preg_replace_callback(\"#\\[code\\](.*?)\\[/code\\](\\r\\n?|\\n?)#is\", array($this, 'mycode_parse_code_callback'), $message);\n\n\t\t$find = array(\n\t\t\t\"#\\[(b|u|i|s|url|email|color|img)\\](.*?)\\[/\\\\1\\]#is\",\n\t\t\t\"#\\[(email|color|size|font|align|video)=[^]]*\\](.*?)\\[/\\\\1\\]#is\",\n\t\t\t\"#\\[img=([1-9][0-9]*)x([1-9][0-9]*)\\](\\r\\n?|\\n?)(https?://([^<>\\\"']+?))\\[/img\\]#is\",\n\t\t\t\"#\\[url=((?!javascript)[a-z]+?://)([^\\r\\n\\\"<]+?)\\](.+?)\\[/url\\]#si\",\n\t\t\t\"#\\[url=((?!javascript:)[^\\r\\n\\\"<&\\(\\)]+?)\\](.+?)\\[/url\\]#si\",\n\t\t\t\"#\\[attachment=([0-9]+?)\\]#i\",\n\t\t);\n\n\t\t$replace = array(\n\t\t\t\"$2\",\n\t\t\t\"$2\",\n\t\t\t\"$4\",\n\t\t\t\"$3 ($1$2)\",\n\t\t\t\"$2 ($1)\",\n\t\t\t\"\",\n\t\t);\n\t\t\n\t\t$messageBefore = \"\";\n\t\t// The counter limit for this \"for\" loop is for defensive programming purpose only. It protects against infinite repetition. \n\t\tfor($cnt = 1; $cnt < 20 && $message != $messageBefore; $cnt++)\n\t\t{\n\t\t\t$messageBefore = $message;\n\t\t\t$message = preg_replace($find, $replace, $messageBefore);\n\t\t}\n\n\t\t// Replace \"me\" code and slaps if we have a username\n\t\tif(!empty($this->options['me_username']))\n\t\t{\n\t\t\tglobal $lang;\n\n\t\t\t$message = preg_replace('#(>|^|\\r|\\n)/me ([^\\r\\n<]*)#i', \"\\\\1* {$this->options['me_username']} \\\\2\", $message);\n\t\t\t$message = preg_replace('#(>|^|\\r|\\n)/slap ([^\\r\\n<]*)#i', \"\\\\1* {$this->options['me_username']} {$lang->slaps} \\\\2 {$lang->with_trout}\", $message);\n\t\t}\n\n\t\t// Reset list cache\n\t\t$this->list_elements = array();\n\t\t$this->list_count = 0;\n\n\t\t// Find all lists\n\t\t$message = preg_replace_callback(\"#(\\[list(=(a|A|i|I|1))?\\]|\\[/list\\])#si\", array($this, 'mycode_prepare_list'), $message);\n\n\t\t// Replace all lists\n\t\tfor($i = $this->list_count; $i > 0; $i--)\n\t\t{\n\t\t\t// Ignores missing end tags\n\t\t\t$message = preg_replace_callback(\"#\\s?\\[list(=(a|A|i|I|1))?&{$i}\\](.*?)(\\[/list&{$i}\\]|$)(\\r\\n?|\\n?)#si\", array($this, 'mycode_parse_list_callback'), $message, 1);\n\t\t}\n\n\t\t// Run plugin hooks\n\t\t$message = $plugins->run_hooks(\"text_parse_message\", $message);\n\n\t\treturn $message;\n\t}\n\n\t/**\n\t * Replaces certain characters with their entities in a URL.\n\t *\n\t * @param string $url The URL to be escaped.\n\t * @return string The escaped URL.\n\t */\n\tfunction encode_url($url)\n\t{\n\t\t$entities = array('$' => '%24', '&#36;' => '%24', '^' => '%5E', '`' => '%60', '[' => '%5B', ']' => '%5D', '{' => '%7B', '}' => '%7D', '\"' => '%22', '<' => '%3C', '>' => '%3E', ' ' => '%20');\n\n\t\t$url = str_replace(array_keys($entities), array_values($entities), $url);\n\n\t\treturn $url;\n\t}\n}\n"], "filenames": ["inc/class_parser.php"], "buggy_code_start_loc": [1350], "buggy_code_end_loc": [1358], "fixing_code_start_loc": [1350], "fixing_code_end_loc": [1352], "type": "CWE-79", "message": "MyBB before 1.8.25 allows stored XSS via nested [email] tags with MyCode (aka BBCode).", "other": {"cve": {"id": "CVE-2021-27279", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-22T20:15:13.243", "lastModified": "2021-02-26T15:37:45.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MyBB before 1.8.25 allows stored XSS via nested [email] tags with MyCode (aka BBCode)."}, {"lang": "es", "value": "MyBB versiones anteriores a 1.8.25, permite un ataque de tipo XSS almacenado por medio de etiquetas [correo electr\u00f3nico] anidadas con MyCode (tambi\u00e9n se conoce como BBCode)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mybb:mybb:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.25", "matchCriteriaId": "F8B31EA3-CFEA-43B3-8348-397BED3FD568"}]}]}], "references": [{"url": "https://github.com/mybb/mybb/commit/cb781b49116bf5c4d8deca3e17498122b701677a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mybb/mybb/security/advisories/GHSA-6483-hcpp-p75w", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://mybb.com/versions/1.8.25/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mybb/mybb/commit/cb781b49116bf5c4d8deca3e17498122b701677a"}}