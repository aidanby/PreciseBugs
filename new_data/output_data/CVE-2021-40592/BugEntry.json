{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMFF reader filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"isoffin.h\"\n\n#ifndef GPAC_DISABLE_ISOM\n\n#include <gpac/crypt_tools.h>\n#include <gpac/media_tools.h>\n\nISOMChannel *isor_get_channel(ISOMReader *reader, GF_FilterPid *pid)\n{\n\tu32 i=0;\n\tISOMChannel *ch;\n\twhile ((ch = (ISOMChannel *)gf_list_enum(reader->channels, &i))) {\n\t\tif (ch->pid == pid) return ch;\n\t}\n\treturn NULL;\n}\n\n\nstatic GFINLINE Bool isor_is_local(const char *url)\n{\n\tif (!strnicmp(url, \"file://\", 7)) return GF_TRUE;\n\tif (!strnicmp(url, \"gmem://\", 7)) return GF_TRUE;\n\tif (!strnicmp(url, \"gfio://\", 7)) return GF_TRUE;\n\tif (!strnicmp(url, \"isobmff://\", 10)) return GF_TRUE;\n\tif (strstr(url, \"://\")) return GF_FALSE;\n\t/*the rest is local (mounted on FS)*/\n\treturn GF_TRUE;\n}\n\n\nstatic GF_Err isoffin_setup(GF_Filter *filter, ISOMReader *read)\n{\n\tchar szURL[2048];\n\tchar *tmp, *src;\n\tGF_Err e;\n\tconst GF_PropertyValue *prop;\n\tif (!read) return GF_SERVICE_ERROR;\n\n\tif (read->pid) {\n\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\tassert(prop);\n\t\tsrc = prop->value.string;\n\t} else {\n\t\tsrc = read->src;\n\t}\n\tif (!src)  return GF_SERVICE_ERROR;\n\n\tread->src_crc = gf_crc_32(src, (u32) strlen(src));\n\n\tstrcpy(szURL, src);\n\ttmp = gf_file_ext_start(szURL);\n\tif (tmp) {\n\t\tBool truncate = GF_TRUE;\n\t\ttmp = strchr(tmp, '#');\n\t\tif (!tmp && read->pid) {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n\t\t\tif (prop && prop->value.string) {\n\t\t\t\ttmp = gf_file_ext_start(prop->value.string);\n\t\t\t\tif (tmp) tmp = strchr(tmp, '#');\n\t\t\t\ttruncate = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (tmp) {\n\t\t\tif (!strnicmp(tmp, \"#audio\", 6)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_AUDIO;\n\t\t\t} else if (!strnicmp(tmp, \"#video\", 6)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_VISUAL;\n\t\t\t} else if (!strnicmp(tmp, \"#auxv\", 5)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_AUXV;\n\t\t\t} else if (!strnicmp(tmp, \"#pict\", 5)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_PICT;\n\t\t\t} else if (!strnicmp(tmp, \"#text\", 5)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_TEXT;\n\t\t\t} else if (!strnicmp(tmp, \"#trackID=\", 9)) {\n\t\t\t\tread->play_only_track_id = atoi(tmp+9);\n\t\t\t} else if (!strnicmp(tmp, \"#ID=\", 4)) {\n\t\t\t\tread->play_only_track_id = atoi(tmp+4);\n\t\t\t} else {\n\t\t\t\tread->play_only_track_id = atoi(tmp+1);\n\t\t\t}\n\t\t\tif (truncate) tmp[0] = 0;\n\t\t}\n\t}\n\n\tif (! isor_is_local(szURL)) {\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tread->start_range = read->end_range = 0;\n\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_RANGE);\n\tif (prop) {\n\t\tread->start_range = prop->value.lfrac.num;\n\t\tread->end_range = prop->value.lfrac.den;\n\t}\n\n\tread->missing_bytes = 0;\n\te = gf_isom_open_progressive(szURL, read->start_range, read->end_range, read->sigfrag, &read->mov, &read->missing_bytes);\n\n\tif (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\tread->moov_not_loaded = 1;\n\t\treturn GF_OK;\n\t}\n\n\tread->input_loaded = GF_TRUE;\n\t//if missing bytes is set, file is incomplete, check if cache is complete\n\tif (read->missing_bytes) {\n\t\tread->input_loaded = GF_FALSE;\n\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\tif (prop && prop->value.boolean)\n\t\t\tread->input_loaded = GF_TRUE;\n\t}\n\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] error while opening %s, error=%s\\n\", szURL,gf_error_to_string(e)));\n\t\tgf_filter_setup_failure(filter, e);\n\t\treturn e;\n\t}\n\tread->frag_type = gf_isom_is_fragmented(read->mov) ? 1 : 0;\n    if (!read->frag_type && read->sigfrag) {\n        e = GF_BAD_PARAM;\n        GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] sigfrag requested but file %s is not fragmented\\n\", szURL));\n        gf_filter_setup_failure(filter, e);\n        return e;\n    }\n    \n\tread->timescale = gf_isom_get_timescale(read->mov);\n\tif (!read->input_loaded && read->frag_type)\n\t\tread->refresh_fragmented = GF_TRUE;\n\n\tif (read->strtxt)\n\t\tgf_isom_text_set_streaming_mode(read->mov, GF_TRUE);\n\n\treturn isor_declare_objects(read);\n}\n\nstatic void isoffin_delete_channel(ISOMChannel *ch)\n{\n\tisor_reset_reader(ch);\n\tif (ch->nal_bs) gf_bs_del(ch->nal_bs);\n\tif (ch->avcc) gf_odf_avc_cfg_del(ch->avcc);\n\tif (ch->hvcc) gf_odf_hevc_cfg_del(ch->hvcc);\n\tif (ch->vvcc) gf_odf_vvc_cfg_del(ch->vvcc);\n\tgf_free(ch);\n}\n\nstatic void isoffin_disconnect(ISOMReader *read)\n{\n\tread->disconnected = GF_TRUE;\n\twhile (gf_list_count(read->channels)) {\n\t\tISOMChannel *ch = (ISOMChannel *)gf_list_get(read->channels, 0);\n\t\tgf_list_rem(read->channels, 0);\n\t\tif (ch->pid)\n\t\t\tgf_filter_pid_remove(ch->pid);\n\t\tisoffin_delete_channel(ch);\n\t}\n\n\tif (read->mov) gf_isom_close(read->mov);\n\tread->mov = NULL;\n\n\tread->pid = NULL;\n}\n\nstatic GF_Err isoffin_reconfigure(GF_Filter *filter, ISOMReader *read, const char *next_url)\n{\n\tconst GF_PropertyValue *prop;\n\tu32 i, count;\n\tBool is_new_mov = GF_FALSE;\n\tu64 tfdt;\n//\tGF_ISOTrackID trackID;\n\tGF_ISOSegOpenMode flags=0;\n\tGF_Err e;\n\n\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\tif (prop && prop->value.boolean)\n\t\tread->input_loaded = GF_TRUE;\n\n\tread->refresh_fragmented = GF_FALSE;\n\tread->full_segment_flush = GF_TRUE;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] reconfigure triggered, URL %s\\n\", next_url));\n\n\t//no need to lock blob if next_url is a blob, all parsing and probing functions below will lock the blob if any\n\n\tswitch (gf_isom_probe_file_range(next_url, read->start_range, read->end_range)) {\n\t//this is a fragment\n\tcase 3:\n\t\tgf_isom_release_segment(read->mov, 1);\n\t\tgf_isom_reset_fragment_info(read->mov, GF_TRUE);\n\n\t\tif (read->no_order_check) flags |= GF_ISOM_SEGMENT_NO_ORDER_FLAG;\n\n\t\t//no longer used in filters\n#if 0\n\t\tif (scalable_segment) flags |= GF_ISOM_SEGMENT_SCALABLE_FLAG;\n#endif\n\t\te = gf_isom_open_segment(read->mov, next_url, read->start_range, read->end_range, flags);\n\t\tif (!read->input_loaded && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\te = GF_OK;\n\t\t}\n\t\t//always refresh fragmented files, since we could have a full moof+mdat in buffer (not incomplete file)\n\t\t//but still further fragments to be pushed\n\t\tif (!read->start_range && !read->end_range)\n\t\t\tread->refresh_fragmented = GF_TRUE;\n\t\tread->seg_name_changed = GF_TRUE;\n\n\t\tfor (i=0; i<gf_list_count(read->channels); i++) {\n\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\tif (ch->last_state==GF_EOS)\n\t\t\t\tch->last_state=GF_OK;\n\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\tif (e<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Error opening new segment %s at UTC \"LLU\": %s\\n\", next_url, gf_net_get_utc(), gf_error_to_string(e) ));\n\t\t} else if (read->end_range) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Playing new range in %s: \"LLU\"-\"LLU\"\\n\", next_url, read->start_range, read->end_range));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] playing new segment %s\\n\", next_url));\n\t\t}\n#endif\n\t\tbreak;\n\t//this is a movie, reload\n\tcase 2:\n\tcase 1:\n\t\t//get tfdt of next segment (cumulated sample dur since moov load)\n\t\t//if the next segment has a tfdt or a tfrx, this will be ignored\n\t\t//otherwise this value will be used as base tfdt for next segment\n\t\ttfdt = gf_isom_get_smooth_next_tfdt(read->mov, 1);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Switching between files - opening new init segment %s (time offset=\"LLU\") - range \"LLU\"-\"LLU\"\\n\", next_url, tfdt, read->start_range, read->end_range));\n\n\t\tif (gf_isom_is_smooth_streaming_moov(read->mov)) {\n\t\t\tchar *tfdt_val = strstr(next_url, \"tfdt=\");\n\t\t\t//smooth addressing, replace tfdt=0000000000000000 with proper value\n\t\t\tif (tfdt_val) {\n\t\t\t\tsprintf(tfdt_val+5, LLX, tfdt);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Error finding init time for init segment %s at UTC \"LLU\"\\n\", next_url, gf_net_get_utc() ));\n\t\t\t}\n\t\t}\n\n\t\tif (read->mov) gf_isom_close(read->mov);\n\t\te = gf_isom_open_progressive(next_url, read->start_range, read->end_range, read->sigfrag, &read->mov, &read->missing_bytes);\n\n\t\t//init seg not completely downloaded, retry at next packet\n\t\tif (!read->input_loaded && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\tread->src_crc = 0;\n\t\t\tread->moov_not_loaded = 2;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tread->moov_not_loaded = 0;\n\t\tif (e < 0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Error opening init segment %s at UTC \"LLU\": %s\\n\", next_url, gf_net_get_utc(), gf_error_to_string(e) ));\n\t\t}\n\t\tif (read->sigfrag)\n\t\t\tgf_isom_enable_traf_map_templates(read->mov);\n\n\t\tis_new_mov = GF_TRUE;\n\t\tbreak;\n\t//empty file\n\tcase 4:\n\t\treturn GF_OK;\n\tdefault:\n\t\tif (!read->mov) {\n            return GF_NOT_SUPPORTED;\n\t\t}\n        e = GF_ISOM_INVALID_FILE;\n        break;\n\t}\n\n\tgf_filter_post_process_task(filter);\n\n\tcount = gf_list_count(read->channels);\n\t\n\tif (e<0) {\n\t\tcount = gf_list_count(read->channels);\n\t\tgf_isom_release_segment(read->mov, 1);\n        read->invalid_segment = GF_TRUE;\n\t\t//error opening the segment, reset everything ...\n\t\tgf_isom_reset_fragment_info(read->mov, GF_FALSE);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n            if (ch) {\n                ch->sample_num = 0;\n                ch->eos_sent = GF_FALSE;\n            }\n\t\t}\n        GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Error opening current segment %s: %s\\n\", next_url, gf_error_to_string(e) ));\n\t\treturn GF_OK;\n\t}\n\t//segment is the first in our cache, we may need a refresh\n\tif (!read->input_loaded) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Opening current segment in progressive mode (download in progress)\\n\"));\n\t} else {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Opening current segment in non-progressive mode (completely downloaded)\\n\"));\n\t}\n\n\tisor_check_producer_ref_time(read);\n\n\tfor (i=0; i<count; i++) {\n\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\tch->last_state = GF_OK;\n\t\tch->eos_sent = GF_FALSE;\n\n\t\t//old code from master, currently no longer used\n\t\t//in filters we don't use extractors for the time being, we only do implicit reconstruction at the decoder side\n#if 0\n\t\tif (ch->base_track) {\n\t\t\tif (scalable_segment)\n\t\t\t\ttrackID = gf_isom_get_highest_track_in_scalable_segment(read->mov, ch->base_track);\n\t\t\t\tif (trackID) {\n\t\t\t\t\tch->track_id = trackID;\n\t\t\t\t\tch->track = gf_isom_get_track_by_id(read->mov, ch->track_id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tch->track = ch->base_track;\n\t\t\t\tch->track_id = gf_isom_get_track_id(read->mov, ch->track);\n\t\t\t}\n\t\t}\n#endif\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Track %d - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\n\t\t//TODO: signal all discontinuities here\n\t\tif (is_new_mov) {\n\t\t\tch->track = gf_isom_get_track_by_id(read->mov, ch->track_id);\n\t\t\tif (!ch->track) {\n\t\t\t\tif (gf_isom_get_track_count(read->mov)==1) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Mismatch between track IDs of different representations\\n\"));\n\t\t\t\t\tch->track = 1;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Mismatch between track IDs of different representations\\n\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*we changed our moov structure, sample_num now starts from 0*/\n\t\t\tch->sample_num = 0;\n\t\t\t//this may happen if we reload moov before initializing the channel\n\t\t\tif (!ch->last_sample_desc_index)\n\t\t\t\tch->last_sample_desc_index = 1;\n\t\t\t//and update channel config\n\t\t\tisor_update_channel_config(ch);\n\n\t\t\t/*restore NAL extraction mode*/\n\t\t\tgf_isom_set_nalu_extract_mode(read->mov, ch->track, ch->nalu_extract_mode);\n\n\t\t\tif (ch->is_cenc) {\n\t\t\t\tisor_set_crypt_config(ch);\n\t\t\t}\n\t\t}\n\n\t\tch->last_state = GF_OK;\n\t}\n\treturn e;\n}\n\nGF_Err isoffin_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *prop;\n\tISOMReader *read = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tisoffin_disconnect(read);\n\t\treturn GF_OK;\n\t}\n\t//check if we  have a file path; if not, this is a pure stream of boxes (no local file cache)\n\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);\n\tif (!prop || !prop->value.string) {\n\t\tif (!read->mem_load_mode)\n\t\t\tread->mem_load_mode = 1;\n\t\tif (!read->pid) read->pid = pid;\n\t\tread->input_loaded = GF_FALSE;\n\t\treturn GF_OK;\n\t}\n\n\tif (read->pid && prop->value.string) {\n\t\tconst char *next_url = prop->value.string;\n\t\tu64 sr, er;\n\t\tu32 crc = gf_crc_32(next_url, (u32) strlen(next_url) );\n\n\t\tsr = er = 0;\n\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_RANGE);\n\t\tif (prop) {\n\t\t\tsr = prop->value.lfrac.num;\n\t\t\ter = prop->value.lfrac.den;\n\t\t}\n\n\t\t//if eos is signaled, don't check for crc since we might have the same blob address (same alloc)\n\t\tif (!read->eos_signaled && (read->src_crc == crc) && (read->start_range==sr) && (read->end_range==er)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] same URL crc and range for %s, skipping reconfigure\\n\", next_url));\n\t\t\treturn GF_OK;\n\t\t}\n\t\tread->src_crc = crc;\n\t\tread->start_range = sr;\n\t\tread->end_range = er;\n\t\tread->input_loaded = GF_FALSE;\n\t\tread->eos_signaled = GF_FALSE;\n\t\t\n\t\t//we need to reconfigure\n\t\treturn isoffin_reconfigure(filter, read, next_url);\n\t}\n\n\tread->pid = pid;\n\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_CACHED);\n\tif (prop && prop->value.boolean) {\n\t\tGF_FilterEvent evt;\n\t\tread->input_loaded = GF_TRUE;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY_HINT, pid);\n\t\tevt.play.full_file_only=1;\n\t\tgf_filter_pid_send_event(pid, &evt);\n\t}\n\treturn isoffin_setup(filter, read);\n}\n\nGF_Err isoffin_initialize(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tGF_Err e = GF_OK;\n\tread->filter = filter;\n\tread->channels = gf_list_new();\n\n\tif (read->xps_check==MP4DMX_XPS_AUTO) {\n\t\tread->xps_check = (read->smode==MP4DMX_SPLIT_EXTRACTORS) ? MP4DMX_XPS_KEEP : MP4DMX_XPS_REMOVE;\n\t}\n\n\tif (read->src) {\n\t\tread->input_loaded = GF_TRUE;\n\t\treturn isoffin_setup(filter, read);\n\t}\n\telse if (read->mov) {\n\t\tread->extern_mov = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t\tread->frag_type = gf_isom_is_fragmented(read->mov) ? 1 : 0;\n\t\tread->timescale = gf_isom_get_timescale(read->mov);\n\n\t\tif (read->sigfrag) {\n\t\t\tgf_isom_enable_traf_map_templates(read->mov);\n\t\t}\n\n\t\tif (read->catseg) {\n\t\t\te = gf_isom_open_segment(read->mov, read->catseg, 0, 0, 0);\n\t\t}\n\t\tif (!e)\n\t\t\te = isor_declare_objects(read);\n\n\t\tgf_filter_post_process_task(filter);\n\t}\n\treturn e;\n}\n\n\nstatic void isoffin_finalize(GF_Filter *filter)\n{\n\tISOMReader *read = (ISOMReader *) gf_filter_get_udta(filter);\n\n\tread->disconnected = GF_TRUE;\n\n\twhile (gf_list_count(read->channels)) {\n\t\tISOMChannel *ch = (ISOMChannel *)gf_list_get(read->channels, 0);\n\t\tgf_list_rem(read->channels, 0);\n\t\tisoffin_delete_channel(ch);\n\t}\n\tgf_list_del(read->channels);\n\n\tif (!read->extern_mov && read->mov) gf_isom_close(read->mov);\n\tread->mov = NULL;\n\n\tif (read->mem_blob.data) gf_free(read->mem_blob.data);\n\tif (read->mem_url) gf_free(read->mem_url);\n}\n\nvoid isor_declare_pssh(ISOMChannel *ch)\n{\n\tu32 i, PSSH_count;\n\tu8 *psshd;\n\tGF_BitStream *pssh_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tu32 s;\n\n\tPSSH_count = gf_isom_get_pssh_count(ch->owner->mov);\n\tgf_bs_write_u32(pssh_bs, PSSH_count);\n\n\t/*fill PSSH in the structure. We will free it in CENC_Setup*/\n\tfor (i=0; i<PSSH_count; i++) {\n\t\tbin128 SystemID;\n\t\tu32 version;\n\t\tu32 KID_count;\n\t\tbin128 *KIDs;\n\t\tu32 private_data_size;\n\t\tu8 *private_data;\n\t\tgf_isom_get_pssh_info(ch->owner->mov, i+1, SystemID, &version, &KID_count, (const bin128 **) & KIDs, (const u8 **) &private_data, &private_data_size);\n\n\t\tgf_bs_write_data(pssh_bs, SystemID, 16);\n\t\tgf_bs_write_u32(pssh_bs, version);\n\t\tgf_bs_write_u32(pssh_bs, KID_count);\n\t\tfor (s=0; s<KID_count; s++) {\n\t\t\tgf_bs_write_data(pssh_bs, KIDs[s], 16);\n\t\t}\n\t\tgf_bs_write_u32(pssh_bs, private_data_size);\n\t\tgf_bs_write_data(pssh_bs, private_data, private_data_size);\n\t}\n\tgf_bs_get_content(pssh_bs, &psshd, &s);\n\tgf_bs_del(pssh_bs);\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_PSSH, & PROP_DATA_NO_COPY(psshd, s) );\n}\n\nvoid isor_set_crypt_config(ISOMChannel *ch)\n{\n\tGF_ISOFile *mov = ch->owner->mov;\n\tu32 track = ch->track;\n\tu32 scheme_type, scheme_version, i, count;\n\tconst char *kms_uri, *scheme_uri;\n\tBool selectiveEncryption=0;\n\tu32 IVLength=0;\n\tu32 KeyIndicationLength=0;\n\tconst char *txtHdr=NULL;\n\tconst char *contentID=NULL;\n\tu32 txtHdrLen=0;\n\tu64 plainTextLen=0;\n\tu32 crypt_type=0;\n\tu32 stsd_idx = ch->owner->stsd ? ch->owner->stsd : 1;\n\n\tif (!ch->is_encrypted) return;\n\n\tscheme_type = scheme_version = 0;\n\tkms_uri = scheme_uri = NULL;\n\n\t/*ugly fix to detect when an stsd uses both clear and encrypted sample descriptions*/\n\tcount = gf_isom_get_sample_description_count(ch->owner->mov, ch->track);\n\tif (count>1) {\n\t\tu32 first_crypted_stsd = 0;\n\t\tu32 nb_same_mtype = 1;\n\t\tu32 nb_clear=0, nb_encrypted=0;\n\t\tu32 base_subtype = 0;\n\t\tBool first_is_clear = GF_FALSE;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 mtype = gf_isom_get_media_subtype(ch->owner->mov, ch->track, i+1);\n\t\t\tif ( gf_isom_is_media_encrypted(ch->owner->mov, track, i+1)) {\n\t\t\t\tgf_isom_get_original_format_type(ch->owner->mov, ch->track, i+1, &mtype);\n\t\t\t\tnb_encrypted++;\n\t\t\t\tif (!first_crypted_stsd) first_crypted_stsd = i+1;\n\t\t\t} else {\n\t\t\t\tnb_clear++;\n\t\t\t\tif (!i) first_is_clear = GF_TRUE;\n\t\t\t}\n\t\t\tif (!i) base_subtype = mtype;\n\t\t\telse if (base_subtype==mtype) {\n\t\t\t\tnb_same_mtype++;\n\t\t\t}\n\t\t}\n\t\tif ((nb_same_mtype==count) && (nb_clear==nb_encrypted)) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_STSD_MODE, &PROP_UINT(first_is_clear ? 1 : 2) );\n\t\t\tstsd_idx = first_crypted_stsd;\n\t\t}\n\n\t}\n\n\tif (gf_isom_is_ismacryp_media(mov, track, stsd_idx)) {\n\t\tgf_isom_get_ismacryp_info(mov, track, stsd_idx, NULL, &scheme_type, &scheme_version, &scheme_uri, &kms_uri, &selectiveEncryption, &IVLength, &KeyIndicationLength);\n\t} else if (gf_isom_is_omadrm_media(mov, track, stsd_idx)) {\n\t\t//u8 hash[20];\n\t\tgf_isom_get_omadrm_info(mov, track, stsd_idx, NULL, &scheme_type, &scheme_version, &contentID, &kms_uri, &txtHdr, &txtHdrLen, &plainTextLen, &crypt_type, &selectiveEncryption, &IVLength, &KeyIndicationLength);\n\n\t\t//gf_media_get_file_hash(gf_isom_get_filename(mov), hash);\n\t} else if (gf_isom_is_cenc_media(mov, track, stsd_idx)) {\n\t\tch->is_cenc = GF_TRUE;\n\n\t\tgf_isom_get_cenc_info(ch->owner->mov, ch->track, stsd_idx, NULL, &scheme_type, &scheme_version);\n\n\t\t//if no PSSH declared, DO update the properties (PSSH is not mandatory)\n\t} else if (gf_isom_is_adobe_protection_media(mov, track, stsd_idx)) {\n\t\tu32 ofmt;\n\t\tscheme_version = 1;\n\t\tscheme_type = GF_ISOM_ADOBE_SCHEME;\n\t\tconst char *metadata = NULL;\n\n\t\tgf_isom_get_adobe_protection_info(mov, track, stsd_idx, &ofmt, &scheme_type, &scheme_version, &metadata);\n\t\tif (metadata)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ADOBE_CRYPT_META, &PROP_DATA((char *)metadata, (u32) strlen(metadata) ) );\n\t}\n\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, &PROP_4CC(scheme_type) );\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION, &PROP_UINT(scheme_version) );\n\tif (scheme_uri) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROTECTION_SCHEME_URI, &PROP_STRING((char*) scheme_uri) );\n\tif (kms_uri) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROTECTION_KMS_URI, &PROP_STRING((char*) kms_uri) );\n\n\tif (selectiveEncryption) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISMA_SELECTIVE_ENC, &PROP_BOOL(GF_TRUE) );\n\tif (IVLength) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISMA_IV_LENGTH, &PROP_UINT(IVLength) );\n\tif (KeyIndicationLength) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISMA_KI_LENGTH, &PROP_UINT(KeyIndicationLength) );\n\tif (crypt_type) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_OMA_CRYPT_TYPE, &PROP_UINT(crypt_type) );\n\tif (contentID) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_OMA_CID, &PROP_STRING(contentID) );\n\tif (txtHdr) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_OMA_TXT_HDR, &PROP_STRING(txtHdr) );\n\tif (plainTextLen) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_OMA_CLEAR_LEN, &PROP_LONGUINT(plainTextLen) );\n\n\tif (ch->is_cenc) {\n\t\tconst u8 *key_info;\n\t\tu32 key_info_size;\n\t\tu32 container_type;\n\n\t\tisor_declare_pssh(ch);\n\n\t\tgf_isom_cenc_get_default_info(ch->owner->mov, ch->track, stsd_idx, &container_type, &ch->pck_encrypted, &ch->crypt_byte_block, &ch->skip_byte_block, &key_info, &key_info_size);\n\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_STORE, &PROP_4CC(container_type) );\n\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ENCRYPTED, &PROP_BOOL(ch->pck_encrypted) );\n\n\t\tif (ch->skip_byte_block || ch->crypt_byte_block) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_PATTERN, &PROP_FRAC_INT(ch->skip_byte_block, ch->crypt_byte_block) );\n\t\t}\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO, &PROP_DATA((u8 *)key_info, key_info_size) );\n\t\tch->key_info_crc = gf_crc_32(key_info, key_info_size);\n\t}\n}\n\n\nISOMChannel *isor_create_channel(ISOMReader *read, GF_FilterPid *pid, u32 track, u32 item_id, Bool force_no_extractors)\n{\n\tISOMChannel *ch;\n\tconst GF_PropertyValue *p;\n\ts64 ts_shift;\n\tif (!read->mov) return NULL;\n\n\tGF_SAFEALLOC(ch, ISOMChannel);\n\tif (!ch) {\n\t\treturn NULL;\n\t}\n\tch->owner = read;\n\tch->pid = pid;\n\tch->to_init = GF_TRUE;\n\tgf_list_add(read->channels, ch);\n\tch->track = track;\n\tch->item_id = item_id;\n\n\tch->nalu_extract_mode = 0;\n\tch->track_id = gf_isom_get_track_id(read->mov, ch->track);\n\tswitch (gf_isom_get_media_type(ch->owner->mov, ch->track)) {\n\tcase GF_ISOM_MEDIA_OCR:\n\t\tch->streamType = GF_STREAM_OCR;\n\t\tbreak;\n\tcase GF_ISOM_MEDIA_SCENE:\n\t\tch->streamType = GF_STREAM_SCENE;\n\t\tbreak;\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_AUXV:\n\tcase GF_ISOM_MEDIA_PICT:\n\t\tgf_isom_get_reference(ch->owner->mov, ch->track, GF_ISOM_REF_BASE, 1, &ch->base_track);\n\t\t//use base track only if avc/svc or hevc/lhvc. If avc+lhvc we need different rules\n\t\tif ( gf_isom_get_avc_svc_type(ch->owner->mov, ch->base_track, 1) == GF_ISOM_AVCTYPE_AVC_ONLY) {\n\t\t\tif ( gf_isom_get_hevc_lhvc_type(ch->owner->mov, ch->track, 1) >= GF_ISOM_HEVCTYPE_HEVC_ONLY) {\n\t\t\t\tch->base_track=0;\n\t\t\t}\n\t\t}\n\t\tch->next_track = 0;\n\t\t/*in scalable mode add SPS/PPS in-band*/\n\t\tif (ch->base_track)\n\t\t\tch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG /*| GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG*/;\n\t\tbreak;\n\t}\n\tif (!read->noedit) {\n\t\tch->ts_offset = 0;\n\t\tch->has_edit_list = gf_isom_get_edit_list_type(ch->owner->mov, ch->track, &ch->ts_offset) ? GF_TRUE : GF_FALSE;\n\t\tif (!ch->has_edit_list && ch->ts_offset) {\n\t\t\t//if >0 this is a hold, we signal positive delay\n\t\t\t//if <0 this is a skip, we signal negative delay\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DELAY, &PROP_LONGSINT( ch->ts_offset) );\n\t\t}\n\t} else\n\t\tch->has_edit_list = GF_FALSE;\n\n\tch->has_rap = (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1) ? GF_TRUE : GF_FALSE;\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t//some fragmented files do not advertize a sync sample table (legal) so we need to update as soon as we fetch a fragment\n\t//to see if we are all-intra (as detected here) or not\n\tif (!ch->has_rap && ch->owner->frag_type)\n\t\tch->check_has_rap = GF_TRUE;\n\tch->timescale = gf_isom_get_media_timescale(ch->owner->mov, ch->track);\n\n\tts_shift = gf_isom_get_cts_to_dts_shift(ch->owner->mov, ch->track);\n\tif (ts_shift) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CTS_SHIFT, &PROP_UINT((u32) ts_shift) );\n\t}\n\n\tif (!track || !gf_isom_is_track_encrypted(read->mov, track)) {\n\t\tif (force_no_extractors) {\n\t\t\tch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_LAYER_ONLY;\n\t\t} else {\n\t\t\tswitch (read->smode) {\n\t\t\tcase MP4DMX_SPLIT_EXTRACTORS:\n\t\t\t\tch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT | GF_ISOM_NALU_EXTRACT_TILE_ONLY;\n\t\t\t\tbreak;\n\t\t\tcase MP4DMX_SPLIT:\n\t\t\t\tch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_LAYER_ONLY | GF_ISOM_NALU_EXTRACT_TILE_ONLY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ch->nalu_extract_mode) {\n\t\t\tgf_isom_set_nalu_extract_mode(ch->owner->mov, ch->track, ch->nalu_extract_mode);\n\t\t}\n\t\treturn ch;\n\t}\n\tif (ch->owner->nocrypt) {\n\t\tch->is_encrypted = GF_FALSE;\n\t\treturn ch;\n\t}\n\tch->is_encrypted = GF_TRUE;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) gf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_STREAM_TYPE, &PROP_UINT(p->value.uint) );\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_ENCRYPTED) );\n\n\tisor_set_crypt_config(ch);\n\n\tif (ch->nalu_extract_mode) {\n\t\tif (ch->is_encrypted) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] using sample NAL rewrite with encryption is not yet supported, patch welcome\\n\"));\n\t\t} else {\n\t\t\tgf_isom_set_nalu_extract_mode(ch->owner->mov, ch->track, ch->nalu_extract_mode);\n\t\t}\n\t}\n\treturn ch;\n}\n\n/*switch channel quality. Return next channel or current channel if error*/\nstatic\nu32 isoffin_channel_switch_quality(ISOMChannel *ch, GF_ISOFile *the_file, Bool switch_up)\n{\n\tu32 i, count, next_track, trackID, cur_track;\n\ts32 ref_count;\n\n\tcur_track = ch->next_track ? ch->next_track : ch->track;\n\tcount = gf_isom_get_track_count(the_file);\n\ttrackID = gf_isom_get_track_id(the_file, cur_track);\n\tnext_track = 0;\n\n\tif (switch_up) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tref_count = gf_isom_get_reference_count(the_file, i+1, GF_ISOM_REF_SCAL);\n\t\t\tif (ref_count < 0)\n\t\t\t\treturn cur_track; //error\n\t\t\tif (ref_count == 0)\n\t\t\t\tcontinue;\n\t\t\t/*next track is the one that has the last reference of type GF_ISOM_REF_SCAL refers to this current track*/\n\t\t\tif ((u32)ref_count == gf_isom_has_track_reference(the_file, i+1, GF_ISOM_REF_SCAL, trackID)) {\n\t\t\t\tnext_track = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*this is the highest quality*/\n\t\tif (!next_track) {\n\t\t\tch->playing = GF_TRUE;\n\t\t\tref_count = gf_isom_get_reference_count(the_file, ch->track, GF_ISOM_REF_BASE);\n\t\t\ttrackID = 0;\n\t\t\tif (ref_count) {\n\t\t\t\tgf_isom_get_reference(the_file, ch->track, GF_ISOM_REF_BASE, 1, &trackID);\n\t\t\t\tfor (i=0; i<gf_list_count(ch->owner->channels) && trackID; i++) {\n\t\t\t\t\tISOMChannel *base = gf_list_get(ch->owner->channels, i);\n\t\t\t\t\tif (base->track_id==trackID) {\n\t\t\t\t\t\tu32 sample_desc_index;\n\t\t\t\t\t\tu64 resume_at;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\t//try to locate sync after current time in base\n\t\t\t\t\t\tresume_at = gf_timestamp_rescale(base->static_sample->DTS, base->timescale, ch->timescale);\n\t\t\t\t\t\te = gf_isom_get_sample_for_media_time(ch->owner->mov, ch->track, resume_at, &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t//found, rewind so that next fetch is the sync\n\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//no further sync found, realign with base timescale\n\t\t\t\t\t\telse if (e==GF_EOS) {\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_media_time(ch->owner->mov, ch->track, resume_at, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//unknown state, realign sample num with base\n\t\t\t\t\t\tif (e<0) {\n\t\t\t\t\t\t\tch->sample_num = base->sample_num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cur_track;\n\t\t}\n\t} else {\n\t\tif (cur_track == ch->base_track)\n\t\t\treturn cur_track;\n\t\tref_count = gf_isom_get_reference_count(the_file, cur_track, GF_ISOM_REF_SCAL);\n\t\tif (ref_count <= 0)\n\t\t\treturn cur_track;\n\t\tgf_isom_get_reference(the_file, cur_track, GF_ISOM_REF_SCAL, ref_count, &next_track);\n\t\tif (!next_track)\n\t\t\treturn cur_track;\n\n\t\tif (ch->track != next_track) {\n\t\t\tch->playing = GF_FALSE;\n\t\t\tch->eos_sent = GF_TRUE;\n\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t}\n\t}\n\n\t/*in scalable mode add SPS/PPS in-band*/\n\tif (ch->owner->smode)\n\t\tgf_isom_set_nalu_extract_mode(the_file, next_track, ch->nalu_extract_mode);\n\n\treturn next_track;\n}\n\nstatic Bool isoffin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 count, i;\n\tBool cancel_event = GF_TRUE;\n\tISOMChannel *ch;\n\tISOMReader *read = gf_filter_get_udta(filter);\n\n\tif (!read || read->disconnected) return GF_FALSE;\n\n\tif (evt->base.type == GF_FEVT_QUALITY_SWITCH) {\n\t\tcount = gf_list_count(read->channels);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tch = (ISOMChannel *)gf_list_get(read->channels, i);\n\t\t\tif (ch->base_track && gf_isom_needs_layer_reconstruction(read->mov)) {\n\t\t\t\t/*ch->next_track = */ //old code, see not in isoffin_reconfigure\n\t\t\t\tisoffin_channel_switch_quality(ch, read->mov, evt->quality_switch.up);\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\n\tif (!evt->base.on_pid) return GF_FALSE;\n\n\tch = isor_get_channel(read, evt->base.on_pid);\n\tif (!ch)\n\t\treturn GF_FALSE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tisor_reset_reader(ch);\n\t\tch->eos_sent = GF_FALSE;\n\t\tch->speed = evt->play.speed;\n\t\tch->initial_play_seen = GF_TRUE;\n\t\tread->reset_frag_state = 1;\n\t\t//it can happen that input_is_stop is still TRUE because we did not get called back after the stop - reset to FALSE since we now play\n\t\tread->input_is_stop = GF_FALSE;\n\t\tif (read->frag_type)\n\t\t\tread->frag_type = 1;\n\n\t\tch->start = ch->end = 0;\n\t\tif (evt->play.speed>=0) {\n\t\t\tDouble t;\n\t\t\tif (evt->play.start_range>=0) {\n\t\t\t\tt = evt->play.start_range;\n\t\t\t\tt *= ch->timescale;\n\t\t\t\tch->start = (u64) t;\n\t\t\t}\n\t\t\tif (evt->play.end_range >= evt->play.start_range) {\n\t\t\t\tch->end = (u64) -1;\n\t\t\t\tif (evt->play.end_range<FLT_MAX) {\n\t\t\t\t\tt = evt->play.end_range;\n\t\t\t\t\tt *= ch->timescale;\n\t\t\t\t\tch->end = (u64) t;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tDouble end = evt->play.end_range;\n\t\t\tif (end==-1) end = 0;\n\t\t\tch->start = (u64) (s64) (evt->play.start_range * ch->timescale);\n\t\t\tif (end <= evt->play.start_range)\n\t\t\t\tch->end = (u64) (s64) (end  * ch->timescale);\n\t\t}\n\t\tch->playing = GF_TRUE;\n\t\tch->sample_num = evt->play.from_pck;\n\n\t\tch->sap_only = evt->play.drop_non_ref ? GF_TRUE : GF_FALSE;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Starting channel playback \"LLD\" to \"LLD\" (%g to %g)\\n\", ch->start, ch->end, evt->play.start_range, evt->play.end_range));\n\n\t\tif (!read->nb_playing)\n\t\t\tgf_isom_reset_seq_num(read->mov);\n\n\t\tif (read->is_partial_download) read->input_loaded = GF_FALSE;\n\n\t\tif (evt->play.no_byterange_forward) {\n\t\t\t//new segment will be loaded, reset\n\t\t\tgf_isom_reset_tables(read->mov, GF_TRUE);\n\t\t\tgf_isom_reset_data_offset(read->mov, NULL);\n\t\t\tread->refresh_fragmented = GF_TRUE;\n\t\t\tread->mem_blob.size = 0;\n\t\t\t//send play event\n\t\t\tcancel_event = GF_FALSE;\n\t\t} else if (!read->nb_playing && read->pid && !read->input_loaded) {\n\t\t\tGF_FilterEvent fevt;\n\t\t\tBool is_sidx_seek = GF_FALSE;\n\t\t\tu64 max_offset = GF_FILTER_NO_BO;\n\t\t\tcount = gf_list_count(read->channels);\n\n\t\t\t//try sidx\n\t\t\tif (read->frag_type) {\n\t\t\t\tu32 ts;\n\t\t\t\tu64 dur=0;\n\t\t\t\tGF_Err e = gf_isom_get_file_offset_for_time(read->mov, evt->play.start_range, &max_offset);\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\tif (evt->play.start_range>0)\n\t\t\t\t\t\tgf_isom_reset_tables(read->mov, GF_TRUE);\n\n\t\t\t\t\tis_sidx_seek = GF_TRUE;\n\t\t\t\t\t//in case we loaded moov but not sidx, update duration\n\t\t\t\t\tif ((gf_isom_get_sidx_duration(read->mov, &dur, &ts)==GF_OK) && dur) {\n\t\t\t\t\t\tdur = gf_timestamp_rescale(dur, ts, read->timescale);\n\t\t\t\t\t\tif (ch->duration != dur) {\n\t\t\t\t\t\t\tch->duration = dur;\n\t\t\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ch->duration, read->timescale));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!is_sidx_seek) {\n\t\t\t\tfor (i=0; i< count; i++) {\n\t\t\t\t\tu32 mode, sample_desc_index, sample_num;\n\t\t\t\t\tu64 data_offset;\n\t\t\t\t\tGF_Err e;\n\t\t\t\t\tu64 time;\n\t\t\t\t\tch = gf_list_get(read->channels, i);\n\t\t\t\t\tmode = ch->disable_seek ? GF_ISOM_SEARCH_BACKWARD : GF_ISOM_SEARCH_SYNC_BACKWARD;\n\t\t\t\t\ttime = (u64) (evt->play.start_range * ch->timescale);\n\n\t\t\t\t\t/*take care of seeking out of the track range*/\n\t\t\t\t\tif (!read->frag_type && (ch->duration < time)) {\n\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(read->mov, ch->track, ch->duration, \t&sample_desc_index, mode, NULL, &sample_num, &data_offset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(read->mov, ch->track, time, &sample_desc_index, mode, NULL, &sample_num, &data_offset);\n\t\t\t\t\t}\n\t\t\t\t\tif ((e == GF_OK) && (data_offset<max_offset))\n\t\t\t\t\t\tmax_offset = data_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((evt->play.start_range || read->is_partial_download)  && (max_offset != GF_FILTER_NO_BO) ) {\n\n\t\t\t\t//send a seek request\n\t\t\t\tread->is_partial_download = GF_TRUE;\n\t\t\t\tread->wait_for_source = GF_TRUE;\n\t\t\t\tread->refresh_fragmented = GF_TRUE;\n\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, read->pid);\n\t\t\t\tfevt.seek.start_offset = max_offset;\n\t\t\t\tgf_filter_pid_send_event(read->pid, &fevt);\n\t\t\t\tgf_isom_set_byte_offset(read->mov, is_sidx_seek ? 0 : max_offset);\n\n\t\t\t}\n\t\t}\n\t\t//always request a process task upon a play\n\t\tgf_filter_post_process_task(read->filter);\n\t\tread->nb_playing++;\n\t\t//cancel event unless dash mode\n\t\treturn cancel_event;\n\n\tcase GF_FEVT_STOP:\n \t\tif (read->nb_playing) read->nb_playing--;\n\t\tisor_reset_reader(ch);\n\t\t//don't send a stop if some of our channels are still waiting for initial play\n\t\tfor (i=0; i<gf_list_count(read->channels); i++) {\n\t\t\tISOMChannel *a_ch = gf_list_get(read->channels, i);\n\t\t\tif (ch==a_ch) continue;\n\t\t\tif (!a_ch->initial_play_seen) return GF_TRUE;\n\t\t}\n\t\t//cancel event if nothing playing\n\t\tif (read->nb_playing) return GF_TRUE;\n\t\tread->input_is_stop = GF_TRUE;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\tcase GF_FEVT_RESUME:\n\t\tch->speed = evt->play.speed;\n\t\tif (ch->sap_only && !evt->play.drop_non_ref) {\n\t\t\tch->sap_only = 2;\n\t\t} else {\n\t\t\tch->sap_only = evt->play.drop_non_ref ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event\n\treturn GF_FALSE;\n}\n\nstatic void isoffin_push_buffer(GF_Filter *filter, ISOMReader *read, const u8 *pck_data, u32 data_size)\n{\n\tu64 bytes_missing;\n\tGF_Err e;\n\n\tif (!read->mem_url) {\n\t\tchar szPath[200];\n\t\tsprintf(szPath, \"gmem://%p\", &read->mem_blob);\n\t\tread->mem_url = gf_strdup(szPath);\n\t}\n\tread->mem_blob.data = gf_realloc(read->mem_blob.data, read->mem_blob.size + data_size);\n\tmemcpy(read->mem_blob.data + read->mem_blob.size, pck_data, data_size);\n\tread->mem_blob.size += data_size;\n\n\tif (read->mem_load_mode==1) {\n\t\tu32 box_type;\n\t\te = gf_isom_open_progressive_ex(read->mem_url, 0, 0, GF_FALSE, &read->mov, &bytes_missing, &box_type);\n\n\t\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\tgf_filter_setup_failure(filter, e);\n\t\t\tread->mem_load_mode = 0;\n\t\t\tread->in_error = e;\n\t\t\treturn;\n\t\t}\n\t\tif (!read->mov) {\n\t\t\tswitch (box_type) {\n\t\t\tcase GF_4CC('m','d','a','t'):\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] non fragmented ISOBMFF with moof after mdat and no underlying file cache (pipe or other stream input), not supported !\\n\"));\n\t\t\t\tgf_filter_setup_failure(filter, GF_NOT_SUPPORTED);\n\t\t\t\tread->mem_load_mode = 0;\n\t\t\t\tread->in_error = GF_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tread->moov_not_loaded = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tread->frag_type = gf_isom_is_fragmented(read->mov) ? 1 : 0;\n\t\tread->timescale = gf_isom_get_timescale(read->mov);\n\t\tisor_declare_objects(read);\n\t\tread->mem_load_mode = 2;\n\t\tread->moov_not_loaded = 0;\n\t\treturn;\n\t}\n\t//refresh file\n\tgf_isom_refresh_fragmented(read->mov, &bytes_missing, read->mem_url);\n\n\tif ((read->mem_load_mode==2) && bytes_missing)\n\t\tread->force_fetch = GF_TRUE;\n\n}\n\nstatic void isoffin_purge_mem(ISOMReader *read, u64 min_offset)\n{\n\tu32 i, count;\n\tu64 top_offset;\n\tu32 nb_bytes_to_purge;\n\tu64 bytes_missing;\n\n\t//purge every\n\tif (read->mstore_purge && (min_offset - read->last_min_offset < read->mstore_purge))\n\t\treturn;\n\n\tif (read->frag_type) {\n\t\t//get position of current box being parsed - if new offset is greater than this box we cannot remove\n\t\t//bytes (we would trash the top-level box header)\n\t\tgf_isom_get_current_top_box_offset(read->mov, &top_offset);\n\t\tif (top_offset<min_offset) {\n\t\t\treturn;\n\t\t}\n\t}\n\tread->last_min_offset = min_offset;\n\n\tassert(min_offset>=read->bytes_removed);\n\t//min_offset is given in absolute file position\n\tnb_bytes_to_purge = (u32) (min_offset - read->bytes_removed);\n\tassert(nb_bytes_to_purge<=read->mem_blob.size);\n\n\tmemmove(read->mem_blob.data, read->mem_blob.data+nb_bytes_to_purge, read->mem_blob.size - nb_bytes_to_purge);\n\tread->mem_blob.size -= nb_bytes_to_purge;\n\tread->bytes_removed += nb_bytes_to_purge;\n\tgf_isom_set_removed_bytes(read->mov, read->bytes_removed);\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] mem mode %d bytes in mem, \"LLU\" bytes trashed since start\\n\", read->mem_blob.size, read->bytes_removed));\n\n\t//force a refresh\n\tgf_isom_refresh_fragmented(read->mov, &bytes_missing, read->mem_url);\n\n\tif (!read->frag_type)\n\t\treturn;\n\n\t//fragmented file, cleanup sample tables\n\tcount = gf_list_count(read->channels);\n\tfor (i=0; i<count; i++) {\n\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\tu32 num_samples;\n\t\tu32 prev_samples = gf_isom_get_sample_count(read->mov, ch->track);\n\t\t//don't run this too often\n\t\tif (ch->sample_num<=1+read->mstore_samples) continue;\n\n\t\tnum_samples = ch->sample_num-1;\n\t\tif (num_samples>=prev_samples) continue;\n\n\t\tif (gf_isom_purge_samples(read->mov, ch->track, num_samples) == GF_OK)\n\t\t\tch->sample_num = 1;\n\n\t\tnum_samples = gf_isom_get_sample_count(read->mov, ch->track);\n\t\tassert(ch->sample_num<=num_samples);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] mem mode %d samples now in track %d (prev %d)\\n\", num_samples, ch->track_id, prev_samples));\n\t}\n}\n\nstatic GF_Err isoffin_process(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tu32 i, count = gf_list_count(read->channels);\n\tBool is_active = GF_FALSE;\n\tBool in_is_eos = GF_FALSE;\n\tBool check_forced_end = GF_FALSE;\n\tBool has_new_data = GF_FALSE;\n\tu64 min_offset_plus_one = 0;\n\tu32 nb_forced_end=0;\n\tif (read->in_error)\n\t\treturn read->in_error;\n\n\tif (read->pid) {\n\t\tBool fetch_input = GF_TRUE;\n\n\t\t//we failed at loading the init segment during a dash switch, retry\n\t\tif (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) {\n\t\t\tisoffin_configure_pid(filter, read->pid, GF_FALSE);\n\t\t\tif (read->moov_not_loaded) return GF_OK;\n\t\t}\n\t\tif (read->mem_load_mode==2) {\n\t\t\tif (!read->force_fetch && read->mem_blob.size > read->mstore_size) {\n\t\t\t\tfetch_input = GF_FALSE;\n\t\t\t}\n\t\t\tread->force_fetch = GF_FALSE;\n\t\t}\n\t\twhile (fetch_input) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid);\n\t\t\tif (!pck) {\n\t\t\t\t//we issued a seek, wait for the first packet to be received before fetching channels\n\t\t\t\t//otherwise we could end up reading from the wrong cache\n\t\t\t\tif (read->wait_for_source) {\n\t\t\t\t\t//something went wrong during the seek request\n\t\t\t\t\tif (gf_filter_pid_is_eos(read->pid))\n\t\t\t\t\t\treturn GF_EOS;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread->wait_for_source = GF_FALSE;\n\n\t\t\tif (read->mem_load_mode) {\n\t\t\t\tu32 data_size;\n\t\t\t\tconst u8 *pck_data = gf_filter_pck_get_data(pck, &data_size);\n\t\t\t\tisoffin_push_buffer(filter, read, pck_data, data_size);\n\t\t\t}\n\t\t\t//we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it\n\t\t\telse if (read->moov_not_loaded==2) {\n\t\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\thas_new_data = GF_TRUE;\n\t\t\tif (read->in_error)\n\t\t\t\treturn read->in_error;\n\t\t}\n\t\tif (gf_filter_pid_is_eos(read->pid)) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n\t\tif (read->input_is_stop) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t\tread->input_is_stop = GF_FALSE;\n\t\t}\n\t\tif (!read->frag_type && read->input_loaded) {\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n        //segment is invalid, wait for eos on input an send eos on all channels\n        if (read->invalid_segment) {\n            if (!in_is_eos) return GF_OK;\n            read->invalid_segment = GF_FALSE;\n\n            for (i=0; i<count; i++) {\n                ISOMChannel *ch = gf_list_get(read->channels, i);\n                if (!ch->playing) {\n                    continue;\n                }\n                if (!ch->eos_sent) {\n                    ch->eos_sent = GF_TRUE;\n                    gf_filter_pid_set_eos(ch->pid);\n                }\n            }\n            read->eos_signaled = GF_TRUE;\n            return GF_EOS;\n        }\n\t} else if (read->extern_mov) {\n\t\tin_is_eos = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t}\n\tif (read->moov_not_loaded==1) {\n\t\tif (read->mem_load_mode)\n\t\t\treturn GF_OK;\n\t\tread->moov_not_loaded = GF_FALSE;\n\t\treturn isoffin_setup(filter, read);\n\t}\n\n\tif (read->refresh_fragmented) {\n\t\tconst GF_PropertyValue *prop;\n\n\t\tif (in_is_eos) {\n\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t} else {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\t\tif (prop && prop->value.boolean)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\n\t\tif (has_new_data) {\n\t\t\tu64 bytesMissing=0;\n\t\t\tGF_Err e;\n\t\t\tconst char *new_url = NULL;\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\t\tif (prop) new_url = prop->value.string;\n\n\t\t\te = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);\n\n\t\t\tif (e && (e!= GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Failed to refresh current segment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Refreshing current segment at UTC \"LLU\" - \"LLU\" bytes still missing - input is EOS %d\\n\", gf_net_get_utc(), bytesMissing, in_is_eos));\n\t\t\t}\n\n\t\t\tif (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Incomplete Segment received - \"LLU\" bytes missing but EOF found\\n\", bytesMissing ));\n\t\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tisor_check_producer_ref_time(read);\n\t\t\tif (!read->frag_type)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 nb_pck=50;\n\t\tISOMChannel *ch;\n\t\tch = gf_list_get(read->channels, i);\n\t\tif (!ch->playing) {\n\t\t\tnb_forced_end++;\n\t\t\tcontinue;\n\t\t}\n\t\t//eos not sent on this channel, we are active\n\t\tif (!ch->eos_sent)\n\t\t\tis_active = GF_TRUE;\n\n\t\twhile (nb_pck) {\n\t\t\tch->sample_data_offset = 0;\n\t\t\tif (!read->full_segment_flush && gf_filter_pid_would_block(ch->pid) )\n\t\t\t\tbreak;\n\n\t\t\tif (ch->item_id) {\n\t\t\t\tisor_reader_get_sample_from_item(ch);\n\t\t\t} else {\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t}\n\n\t\t\tif (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) {\n\t\t\t\tisor_reader_release_sample(ch);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch->sample) {\n\t\t\t\tu32 sample_dur;\n\t\t\t\tu8 dep_flags;\n\t\t\t\tu8 *subs_buf;\n\t\t\t\tu32 subs_buf_size;\n\t\t\t\tGF_FilterPacket *pck;\n\t\t\t\tif (ch->needs_pid_reconfig) {\n\t\t\t\t\tisor_update_channel_config(ch);\n\t\t\t\t\tch->needs_pid_reconfig = GF_FALSE;\n\t\t\t\t}\n\n\t\t\t\t//we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed\n\t\t\t\tif (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) {\n\t\t\t\t\tch->check_has_rap = GF_FALSE;\n\t\t\t\t\tch->has_rap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t\t\t\t}\n\n\t\t\t\t//strip param sets from payload, trigger reconfig if needed\n\t\t\t\tisor_reader_check_config(ch);\n\n\t\t\t\tif (read->nodata) {\n\t\t\t\t\tpck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemcpy(data, ch->sample->data, ch->sample->dataLength);\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_dts(pck, ch->dts);\n\t\t\t\tgf_filter_pck_set_cts(pck, ch->cts);\n\t\t\t\tif (ch->sample->IsRAP==-1) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t\t\t\tch->redundant = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP);\n\t\t\t\t}\n\n\t\t\t\tif (ch->sap_3)\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);\n\t\t\t\telse if (ch->sap_4_type) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);\n\t\t\t\t\tgf_filter_pck_set_roll_info(pck, ch->roll);\n\t\t\t\t}\n\n\t\t\t\tsample_dur = ch->au_duration;\n\t\t\t\tif (ch->sample->nb_pack)\n\t\t\t\t\tsample_dur *= ch->sample->nb_pack;\n\t\t\t\tgf_filter_pck_set_duration(pck, sample_dur);\n\t\t\t\tgf_filter_pck_set_seek_flag(pck, ch->seek_flag);\n\n\t\t\t\t//for now we only signal xPS mask for non-sap\n\t\t\t\tif (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) );\n\t\t\t\t}\n\n\t\t\t\tdep_flags = ch->isLeading;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependsOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependedOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->redundant;\n\n\t\t\t\tif (dep_flags)\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(pck, dep_flags);\n\n\t\t\t\tgf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);\n\t\t\t\tgf_filter_pck_set_seq_num(pck, ch->sample_num);\n\n\n\t\t\t\tsubs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size);\n\t\t\t\tif (subs_buf) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );\n\t\t\t\t}\n\n\t\t\t\tif (ch->sai_buffer && ch->pck_encrypted) {\n\t\t\t\t\tassert(ch->sai_buffer_size);\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) );\n\t\t\t\t}\n\n\t\t\t\tif (read->sigfrag) {\n\t\t\t\t\tGF_ISOFragmentBoundaryInfo finfo;\n\t\t\t\t\tif (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) {\n\t\t\t\t\t\tu64 start=0;\n\t\t\t\t\t\tu32 traf_start = finfo.seg_start_plus_one ? 2 : 1;\n\n\t\t\t\t\t\tif (finfo.seg_start_plus_one)\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));\n\n\t\t\t\t\t\tstart = finfo.frag_start;\n\t\t\t\t\t\tif (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end));\n\t\t\t\t\t\tif (finfo.moof_template) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (finfo.sidx_end) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (read->seg_name_changed) {\n\t\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n\t\t\t\t\t\t\tread->seg_name_changed = GF_FALSE;\n\t\t\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_URL, &PROP_STRING(p->value.string));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ch->sender_ntp) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp));\n\t\t\t\t\tif (ch->ntp_at_server_ntp) {\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch->eos_sent = GF_FALSE;\n\n\t\t\t\t//this might not be the true end of stream\n\t\t\t\tif ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));\n\t\t\t\t}\n\n\t\t\t\tgf_filter_pck_send(pck);\n\t\t\t\tisor_reader_release_sample(ch);\n\n\t\t\t\tch->last_valid_sample_data_offset = ch->sample_data_offset;\n\t\t\t\tnb_pck--;\n\t\t\t} else if (ch->last_state==GF_EOS) {\n\t\t\t\tif (ch->playing == 2) {\n\t\t\t\t\tif (in_is_eos) {\n\t\t\t\t\t\tch->playing = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnb_forced_end++;\n\t\t\t\t\t\tcheck_forced_end = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (in_is_eos && !ch->eos_sent) {\n\t\t\t\t\tvoid *tfrf;\n\t\t\t\t\tconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);\n\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\n\t\t\t\t\ttfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);\n\t\t\t\t\tif (tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );\n\t\t\t\t\t\tch->last_has_tfrf = GF_TRUE;\n\t\t\t\t\t} else if (ch->last_has_tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);\n\t\t\t\t\t\tch->last_has_tfrf = GF_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tread->force_fetch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))\n\t\t\tmin_offset_plus_one = 1 + ch->last_valid_sample_data_offset;\n\t}\n\tif (read->mem_load_mode && min_offset_plus_one) {\n\t\tisoffin_purge_mem(read, min_offset_plus_one-1);\n\t}\n\n\t//we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input\n\tif (read->pid && check_forced_end && (nb_forced_end==count)) {\n\t\t//abort input\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid);\n\t\tgf_filter_pid_send_event(read->pid, &evt);\n\t}\n\n\n\tif (!is_active) {\n\t\treturn GF_EOS;\n\t}\n\t//if (in_is_eos)\n//\tgf_filter_ask_rt_reschedule(filter, 1);\n\treturn GF_OK;\n\n}\n\nstatic const char *isoffin_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tif (gf_isom_probe_data(data, size)) {\n\t\t*score = GF_FPROBE_SUPPORTED;\n\t\treturn \"video/mp4\";\n\t}\n\treturn NULL;\n}\n\n#define OFFS(_n)\t#_n, offsetof(ISOMReader, _n)\n\nstatic const GF_FilterArgs ISOFFInArgs[] =\n{\n\t{ OFFS(src), \"location of source content (only used when explicitly loading the demuxer)\", GF_PROP_NAME, NULL, NULL, 0},\n\t{ OFFS(allt), \"load all tracks even if unknown\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noedit), \"do not use edit lists\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(itt), \"convert all items of root meta into a single PID\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(itemid), \"keep item IDs in PID properties\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(smode), \"load mode for scalable/tile tracks\\n\"\n\t\"- split: each track is declared, extractors are removed\\n\"\n\t\"- splitx: each track is declared, extractors are kept\\n\"\n\t\"- single: a single track is declared (highest level for scalable, tile base for tiling)\", GF_PROP_UINT, \"split\", \"split|splitx|single\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(alltk), \"declare all tracks even disabled ones\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(frame_size), \"frame size for raw audio samples (dispatches frame_size samples per packet)\", GF_PROP_UINT, \"1024\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(expart), \"expose cover art as a dedicated video pid\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sigfrag), \"signal fragment and segment boundaries of source on output packets\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\n\t{ OFFS(tkid), \"declare only track based on given param\\n\"\n\t\"- integer value: declares track with the given ID\\n\"\n\t\"- audio: declares first audio track\\n\"\n\t\"- video: declares first video track\\n\"\n\t\"- 4CC: declares first track with matching 4CC for handler type\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(stsd), \"only extract sample mapped to the given sample description index. 0 means no filter\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mov), \"pointer to a read/edit ISOBMF file used internally by importers and exporters\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(analyze), \"skip reformat of decoder config and SEI and dispatch all NAL in input order - shall only be used with inspect filter analyze mode!\", GF_PROP_UINT, \"off\", \"off|on|bs|full\", GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(catseg), \"append the given segment to the movie at init time (only local file supported)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(nocrypt), \"signal encrypted tracks as non encrypted (mostly used for export)\", GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(mstore_size), \"target buffer size in bytes\", GF_PROP_UINT, \"1000000\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mstore_purge), \"minimum size in bytes between memory purges when reading from memory stream (pipe etc...), 0 means purge as soon as possible\", GF_PROP_UINT, \"50000\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mstore_samples), \"minimum number of samples to be present before purging sample tables when reading from memory stream (pipe etc...), 0 means purge as soon as possible\", GF_PROP_UINT, \"50\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strtxt), \"load text tracks (apple/tx3g) as MPEG-4 streaming text tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(xps_check), \"parameter sets extraction mode from AVC/HEVC/VVC samples\\n\"\n\t\"- keep: do not inspect sample (assumes input file is compliant when generating DASH/HLS/CMAF)\\n\"\n\t\"- rem: removes all inband xPS and notify configuration changes accordingly\\n\"\n\t\"- auto: resolves to `keep` for `smode=splix` (dasher mode), `rem` otherwise\"\n\t, GF_PROP_UINT, \"auto\", \"auto|keep|rem\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(nodata), \"do not load sample data\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\nstatic const GF_FilterCapability ISOFFInCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"mp4|mpg4|m4a|m4i|3gp|3gpp|3g2|3gp2|iso|m4s|heif|heic|avci|mj2|mov|qt\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"application/x-isomedia|application/mp4|video/mp4|audio/mp4|video/3gpp|audio/3gpp|video/3gp2|audio/3gp2|video/iso.segment|audio/iso.segment|image/heif|image/heic|image/avci|video/quicktime\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_METADATA),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_ENCRYPTED),\n\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\t//also declare generic file output for embedded files (cover art & co), but explicit to skip this cap in chain resolution\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_OUTPUT | GF_CAPFLAG_LOADED_FILTER ,GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE)\n};\n\nGF_FilterRegister ISOFFInRegister = {\n\t.name = \"mp4dmx\",\n\tGF_FS_SET_DESCRIPTION(\"ISOBMFF/QT demuxer\")\n\tGF_FS_SET_HELP(\"This filter demultiplexes ISOBMF and QT files (regular or fragmented).\\n\"\n\t\t\"# Track Selection\\n\"\n\t\t\"The filter can use fragment identifiers of source to select a single track for playback. The allowed fragments are:\\n\"\n\t\t\" - #audio: only use the first audio track\\n\"\n\t\t\" - #video: only use the first video track\\n\"\n\t\t\" - #auxv: only use the first auxiliary video track\\n\"\n\t\t\" - #pict: only use the first picture track\\n\"\n\t\t\" - #text: only use the first text track\\n\"\n\t\t\" - #trackID=VAL: only use the track with given ID\\n\"\n\t\t\" - #ID=VAL: only use the track with given ID\\n\"\n\t\t\" - #VAL: only use the track with given ID\\n\"\n\t\t\"\\n\"\n\t\t\"# Scalable Tracks\\n\"\n\t\t\"When scalable tracks are present in a file, the reader can operate in 3 modes using [-smode]() option:\\n\"\\\n\t \t\"- smode=single: resolves all extractors to extract a single bitstream from a scalable set. The highest level is used\\n\"\\\n\t \t\"In this mode, there is no enhancement decoder config, only a base one resulting from the merge of the configs\\n\"\\\n\t \t\"- smode=split: all extractors are removed and every track of the scalable set is declared. In this mode, each enhancement track has no base decoder config\\n\"\n\t \t\"and an enhancement decoder config.\\n\"\\\n\t \t\"- smode=splitx: extractors are kept in the bitstream, and every track of the scalable set is declared. In this mode, each enhancement track has a base decoder config\\n\"\n\t \t\" (copied from base) and an enhancement decoder config. This is mostly used for DASHing content.\\n\"\\\n\t \t\"Warning: smode=splitx will result in extractor NAL units still present in the output bitstream, which shall only be true if the output is ISOBMFF based\\n\")\n\t.private_size = sizeof(ISOMReader),\n\t.args = ISOFFInArgs,\n\t.initialize = isoffin_initialize,\n\t.finalize = isoffin_finalize,\n\t.process = isoffin_process,\n\t.configure_pid = isoffin_configure_pid,\n\tSETCAPS(ISOFFInCaps),\n\t.process_event = isoffin_process_event,\n\t.probe_data = isoffin_probe_data\n};\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n\nconst GF_FilterRegister *isoffin_register(GF_FilterSession *session)\n{\n#ifdef GPAC_DISABLE_ISOM\n\treturn NULL;\n#else\n\treturn &ISOFFInRegister;\n#endif /*GPAC_DISABLE_ISOM*/\n}\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMFF reader filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include \"isoffin.h\"\n\n#ifndef GPAC_DISABLE_ISOM\n#include <gpac/network.h>\n#include <gpac/avparse.h>\n\n\nvoid isor_reset_reader(ISOMChannel *ch)\n{\n\tch->last_state = GF_OK;\n\tisor_reader_release_sample(ch);\n\n\tif (ch->static_sample) {\n\t\tch->static_sample->dataLength = ch->static_sample->alloc_size;\n\t\tgf_isom_sample_del(&ch->static_sample);\n\t}\n\tch->sample = NULL;\n\tch->sample_num = 0;\n\tch->speed = 1.0;\n\tch->start = ch->end = 0;\n\tch->to_init = 1;\n\tch->playing = GF_FALSE;\n\tif (ch->sai_buffer) gf_free(ch->sai_buffer);\n\tch->sai_buffer = NULL;\n\tch->sai_alloc_size = 0;\n\tch->dts = ch->cts = 0;\n\tch->seek_flag = 0;\n}\n\nvoid isor_check_producer_ref_time(ISOMReader *read)\n{\n\tGF_ISOTrackID trackID;\n\tu64 ntp;\n\tu64 timestamp;\n\n\tif (gf_sys_is_test_mode()) {\n\t\treturn;\n\t}\n\n\tif (gf_isom_get_last_producer_time_box(read->mov, &trackID, &ntp, &timestamp, GF_TRUE)) {\n#if !defined(_WIN32_WCE) && !defined(GPAC_DISABLE_LOG)\n\n\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\ttime_t secs;\n\t\t\tstruct tm t;\n\n\t\t\ts32 diff = gf_net_get_ntp_diff_ms(ntp);\n\n\t\t\tsecs = (ntp>>32) - GF_NTP_SEC_1900_TO_1970;\n\t\t\tt = *gf_gmtime(&secs);\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] TrackID %d: Timestamp \"LLU\" matches sender NTP time %d-%02d-%02dT%02d:%02d:%02dZ - NTP clock diff (local - remote): %d ms\\n\", trackID, timestamp, 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, diff));\n\t\t}\n#endif\n\t\tread->last_sender_ntp = ntp;\n\t\tread->cts_for_last_sender_ntp = timestamp;\n\t\tread->ntp_at_last_sender_ntp = gf_net_get_ntp_ts();\n\t}\n}\n\n\nstatic void init_reader(ISOMChannel *ch)\n{\n\tu32 sample_desc_index=0;\n\n\tch->au_seq_num = 1;\n\n\tassert(ch->sample==NULL);\n\tif (!ch->static_sample) {\n\t\tch->static_sample = gf_isom_sample_new();\n\t}\n\n\tif (ch->streamType==GF_STREAM_OCR) {\n\t\tassert(!ch->sample);\n\t\tch->sample = gf_isom_sample_new();\n\t\tch->sample->IsRAP = RAP;\n\t\tch->sample->DTS = ch->start;\n\t\tch->last_state=GF_OK;\n\t} else if (ch->sample_num) {\n\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\tch->disable_seek = GF_TRUE;\n\t\tch->au_seq_num = ch->sample_num;\n\t} else {\n\t\t//if seek is disabled, get the next closest sample for this time; otherwise, get the previous RAP sample for this time\n\t\tu32 mode = ch->disable_seek ? GF_ISOM_SEARCH_BACKWARD : GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t\t/*take care of seeking out of the track range*/\n\t\tif (!ch->owner->frag_type && (ch->duration<=ch->start)) {\n\t\t\tch->last_state = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->duration-1, &sample_desc_index, mode, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t} else if (ch->start || ch->has_edit_list) {\n\t\t\tch->last_state = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->start, &sample_desc_index, mode, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t} else {\n\t\t\tch->sample_num = 1;\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\tif (!ch->sample) ch->last_state = GF_EOS;\n\t\t}\n\t\tif (ch->last_state) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_OK;\n\t\t} else {\n\t\t\tch->sample = ch->static_sample;\n\t\t}\n\n\t\tif (ch->has_rap && ch->has_edit_list) {\n\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t}\n\n\t\tif (ch->sample && !ch->sample->data && ch->owner->frag_type && !ch->has_edit_list) {\n\t\t\tch->sample = NULL;\n\t\t\tch->sample_num = 1;\n\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t}\n\t}\n\n\n\t/*no sample means we're not in the track range - stop*/\n\tif (!ch->sample) {\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t} else if (ch->sample_num) {\n\t\t\tch->last_state = (ch->owner->frag_type==1) ? GF_OK : GF_EOS;\n\t\t\tch->to_init = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tch->sample_time = ch->sample->DTS;\n\n\tch->to_init = GF_FALSE;\n\n\tch->seek_flag = 0;\n\tif (ch->disable_seek) {\n\t\tch->dts = ch->sample->DTS;\n\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\tch->start = 0;\n\t} else {\n\t\ts64 cts;\n\t\tch->dts = ch->start;\n\t\tch->cts = ch->start;\n\n\t\tcts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\tif (ch->ts_offset<0)\n\t\t\tcts += ch->ts_offset;\n\n\t\t//TODO - we need to notify scene decoder how many secs elapsed between RAP and seek point\n\t\tif (ch->cts != cts) {\n\t\t\tch->seek_flag = 1;\n\t\t}\n\t}\n\tif (!sample_desc_index) sample_desc_index = 1;\n\tch->last_sample_desc_index = sample_desc_index;\n\tch->owner->no_order_check = ch->speed < 0 ? GF_TRUE : GF_FALSE;\n}\n\n\nstatic void isor_update_cenc_info(ISOMChannel *ch, Bool for_item)\n{\n\tGF_Err e;\n\tBool Is_Encrypted;\n\tu32 out_size;\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 piff_info[20];\n\tu8 *key_info = NULL;\n\tu32 key_info_size = 0;\n\tu8 item_mkey = 0;\n\n\t//this will be skipped anyways, don't fectch ...\n\tif (ch->owner->stsd && (ch->last_sample_desc_index != ch->owner->stsd) && ch->sample) {\n\t\treturn;\n\t}\n\n\n\tout_size = ch->sai_alloc_size;\n\tif (for_item) {\n\t\tu32 aux_info_param=0;\n\t\te = gf_isom_extract_meta_item_get_cenc_info(ch->owner->mov, GF_TRUE, 0, ch->item_id, &Is_Encrypted, &skip_byte_block, &crypt_byte_block, (const u8 **) &key_info, &key_info_size, &aux_info_param, &ch->sai_buffer, &out_size, &ch->sai_alloc_size);\n\n\t\t/*The ienc property is always exposed as a multiple key info in GPAC\n\t\tHowever the type of SAI may be single-key (aux_info_param==0) or multiple-key (aux_info_param==1) for the same ienc used\n\t\tWe therefore temporary force the key info type to single key if v0 SAI CENC are used\n\t\tNote that this is thread safe as this filter is the only one using the opened file\n\t\t*/\n\t\tif (aux_info_param==0) {\n\t\t\titem_mkey = key_info[0];\n\t\t}\n\t} else {\n\t\te = gf_isom_get_sample_cenc_info(ch->owner->mov, ch->track, ch->sample_num, &Is_Encrypted, &crypt_byte_block, &skip_byte_block, (const u8 **) &key_info, &key_info_size);\n\t}\n\tif (!key_info) {\n\t\tpiff_info[0] = 0;\n\t\tpiff_info[1] = 0;\n\t\tpiff_info[2] = 0;\n\t\tpiff_info[3] = key_info_size;\n\t\tmemset(piff_info + 4, 0, 16);\n\t\tkey_info_size = 20;\n\t\tkey_info = (u8 *) piff_info;\n\t}\n\n\n\tif (!for_item && (e==GF_OK) && Is_Encrypted) {\n\t\te = gf_isom_cenc_get_sample_aux_info(ch->owner->mov, ch->track, ch->sample_num, ch->last_sample_desc_index, NULL, &ch->sai_buffer, &out_size);\n\t}\n\n\tif (out_size > ch->sai_alloc_size) ch->sai_alloc_size = out_size;\n\tch->sai_buffer_size = out_size;\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch CENC auxiliary info for %s %d: %s\\n\", for_item ? \"item\" : \"track\", for_item ? ch->item_id : ch->track, gf_error_to_string(e) ));\n\t\treturn;\n\t}\n\n\tch->pck_encrypted = Is_Encrypted;\n\tch->cenc_ki = NULL;\n\n\t/*notify change of IV/KID only when packet is encrypted\n\t1- these info are ignored when packet is not encrypted\n\t2- this allows us to define the initial CENC state for multi-stsd cases*/\n\tif (Is_Encrypted) {\n\t\tu32 ki_crc;\n\n\t\tif ((ch->crypt_byte_block != crypt_byte_block) || (ch->skip_byte_block != skip_byte_block)) {\n\t\t\tch->crypt_byte_block = crypt_byte_block;\n\t\t\tch->skip_byte_block = skip_byte_block;\n\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_PATTERN, &PROP_FRAC_INT(ch->skip_byte_block, ch->crypt_byte_block) );\n\t\t}\n\t\tif (item_mkey)\n\t\t\tkey_info[0] = 0;\n\n\t\tki_crc = gf_crc_32(key_info, key_info_size);\n\t\tif (ch->key_info_crc != ki_crc) {\n\t\t\tch->key_info_crc = ki_crc;\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO, &PROP_DATA((u8 *)key_info, key_info_size) );\n\t\t}\n\n\t\tif (item_mkey)\n\t\t\tkey_info[0] = item_mkey;\n\n\t\tch->cenc_ki = gf_filter_pid_get_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO);\n\t}\n}\n\nvoid isor_reader_get_sample_from_item(ISOMChannel *ch)\n{\n\tif (ch->au_seq_num) {\n\t\tif (!ch->owner->itt || !isor_declare_item_properties(ch->owner, ch, 1+ch->au_seq_num)) {\n\t\t\tch->last_state = GF_EOS;\n\t\t\treturn;\n\t\t}\n\t}\n\tch->sample_time = 0;\n\tch->last_state = GF_OK;\n\tif (!ch->static_sample) {\n\t\tch->static_sample = gf_isom_sample_new();\n\t}\n\n\tch->sample = ch->static_sample;\n\tch->sample->IsRAP = RAP;\n\tch->au_duration = 1000;\n\tch->dts = ch->cts = 1000 * ch->au_seq_num;\n\tgf_isom_extract_meta_item_mem(ch->owner->mov, GF_TRUE, 0, ch->item_id, &ch->sample->data, &ch->sample->dataLength, &ch->static_sample->alloc_size, NULL, GF_FALSE);\n\n\tif (ch->is_encrypted && ch->is_cenc) {\n\t\tisor_update_cenc_info(ch, GF_TRUE);\n\t}\n}\n\nvoid isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tif (e == GF_OK) ch->sample = ch->static_sample;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n\t\t        ) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\t\t}\n\t\treturn;\n\t}\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\tch->au_duration = gf_isom_get_sample_duration(ch->owner->mov, ch->track, ch->sample_num);\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\tch->set_disc = ch->owner->clock_discontinuity ? 2 : 0;\n\tch->owner->clock_discontinuity = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->au_duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}\n\nvoid isor_reader_release_sample(ISOMChannel *ch)\n{\n\tif (ch->sample)\n\t\tch->au_seq_num++;\n\tch->sample = NULL;\n\tch->sai_buffer_size = 0;\n}\n\nstatic void isor_reset_seq_list(GF_List *list)\n{\n\twhile (gf_list_count(list)) {\n\t\tGF_NALUFFParam *sl = gf_list_pop_back(list);\n\t\tgf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n}\n\nenum\n{\n\tRESET_STATE_VPS=1,\n\tRESET_STATE_SPS=1<<1,\n\tRESET_STATE_PPS=1<<2,\n\tRESET_STATE_SPS_EXT=1<<3,\n\tRESET_STATE_DCI=1<<4,\n};\n\nstatic void isor_replace_nal(ISOMChannel *ch, u8 *data, u32 size, u8 nal_type, u32 *reset_state)\n{\n\tu32 i, count, state=0;\n\tGF_NALUFFParam *sl;\n\tGF_List *list=NULL;\n\tif (ch->avcc) {\n\t\tif (nal_type==GF_AVC_NALU_PIC_PARAM) {\n\t\t\tlist = ch->avcc->pictureParameterSets;\n\t\t\tstate=RESET_STATE_PPS;\n\t\t} else if (nal_type==GF_AVC_NALU_SEQ_PARAM) {\n\t\t\tlist = ch->avcc->sequenceParameterSets;\n\t\t\tstate=RESET_STATE_SPS;\n\t\t} else if (nal_type==GF_AVC_NALU_SEQ_PARAM_EXT) {\n\t\t\tlist = ch->avcc->sequenceParameterSetExtensions;\n\t\t\tstate=RESET_STATE_SPS_EXT;\n\t\t} else return;\n\t}\n\telse if (ch->hvcc) {\n\t\tGF_NALUFFParamArray *hvca=NULL;\n\t\tcount = gf_list_count(ch->hvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\thvca = gf_list_get(ch->hvcc->param_array, i);\n\t\t\tif (hvca->type==nal_type) {\n\t\t\t\tlist = hvca->nalus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thvca = NULL;\n\t\t}\n\t\tif (!hvca) {\n\t\t\tGF_SAFEALLOC(hvca, GF_NALUFFParamArray);\n\t\t\tif (hvca) {\n\t\t\t\tlist = hvca->nalus = gf_list_new();\n\t\t\t\thvca->type = nal_type;\n\t\t\t\tgf_list_add(ch->hvcc->param_array, hvca);\n\t\t\t}\n\t\t}\n\t\tswitch (nal_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tstate = RESET_STATE_VPS;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tstate = RESET_STATE_SPS;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tstate = RESET_STATE_PPS;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ch->vvcc) {\n\t\tGF_NALUFFParamArray *vvca=NULL;\n\t\tcount = gf_list_count(ch->vvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tvvca = gf_list_get(ch->vvcc->param_array, i);\n\t\t\tif (vvca->type==nal_type) {\n\t\t\t\tlist = vvca->nalus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvvca = NULL;\n\t\t}\n\t\tif (!vvca) {\n\t\t\tGF_SAFEALLOC(vvca, GF_NALUFFParamArray);\n\t\t\tif (vvca) {\n\t\t\t\tlist = vvca->nalus = gf_list_new();\n\t\t\t\tvvca->type = nal_type;\n\t\t\t\tgf_list_add(ch->vvcc->param_array, vvca);\n\t\t\t}\n\t\t}\n\t\tswitch (nal_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tstate = RESET_STATE_VPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tstate = RESET_STATE_SPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tstate = RESET_STATE_PPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tstate = RESET_STATE_DCI;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tch->xps_mask |= state;\n\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif ((sl->size==size) && !memcmp(sl->data, data, size)) return;\n\t}\n\tif (! (*reset_state & state))  {\n\t\tisor_reset_seq_list(list);\n\t\t*reset_state |= state;\n\t}\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char)*size);\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tgf_list_add(list, sl);\n}\n\nu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);\n\nvoid isor_sai_bytes_removed(ISOMChannel *ch, u32 pos, u32 removed)\n{\n\tu32 offset = 0;\n\tu8 *sai;\n\tu32 sai_size, cur_pos;\n\tu32 sub_count_size = 0;\n\tu32 i, subs_count = 0;\n\n\tif (!ch->cenc_ki || !ch->sai_buffer) return;\n\n\tsai = ch->sai_buffer;\n\tsai_size = ch->sai_buffer_size;\n\n\t//multikey\n\tif (ch->cenc_ki->value.data.ptr[0]) {\n\t\tu32 remain;\n\t\tu32 j, nb_iv_init = sai[0];\n\t\tnb_iv_init <<= 8;\n\t\tnb_iv_init |= sai[1];\n\t\tu8 *sai_p = sai + 2;\n\t\tremain = sai_size-2;\n\n\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\tu32 mk_iv_size;\n\t\t\tu32 idx = sai_p[0];\n\t\t\tidx<<=8;\n\t\t\tidx |= sai_p[1];\n\n\t\t\tmk_iv_size = key_info_get_iv_size(ch->cenc_ki->value.data.ptr, ch->cenc_ki->value.data.size, idx, NULL, NULL);\n\t\t\tmk_iv_size += 2; //idx\n\t\t\tif (mk_iv_size > remain) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsai_p += mk_iv_size;\n\t\t\tremain -= mk_iv_size;\n\t\t}\n\t\toffset = (u32) (sai_p - sai);\n\t\tsub_count_size = 4; //32bit sub count\n\n\t} else {\n\t\toffset = key_info_get_iv_size(ch->cenc_ki->value.data.ptr, ch->cenc_ki->value.data.size, 1, NULL, NULL);\n\t\tsub_count_size = 2; //16bit sub count\n\t}\n\n\tsai += offset;\n\tif (sub_count_size==2) {\n\t\tsubs_count = ((u32) sai[0]) << 8 | sai[1];\n\t} else {\n\t\tsubs_count = GF_4CC(sai[0], sai[1], sai[2], sai[3]);\n\t}\n\tsai += sub_count_size;\n\tsai_size -= offset + sub_count_size;\n\tcur_pos = 0;\n\tfor (i=0; i<subs_count; i++) {\n\t\tif (sai_size<6)\n\t\t\treturn;\n\t\tu32 clear = ((u32) sai[0]) << 8 | sai[1];\n\t\tu32 crypt = GF_4CC(sai[2], sai[3], sai[4], sai[5]);\n\t\tif (cur_pos + clear > pos) {\n\t\t\tclear -= removed;\n\t\t\tsai[0] = (clear>>8) & 0xFF;\n\t\t\tsai[1] = (clear) & 0xFF;\n\t\t\treturn;\n\t\t}\n\t\tcur_pos += clear + crypt;\n\t\tsai += 6;\n\t}\n}\n\nvoid isor_reader_check_config(ISOMChannel *ch)\n{\n\tu32 nalu_len, reset_state;\n\tif (!ch->check_hevc_ps && !ch->check_avc_ps && !ch->check_vvc_ps && !ch->check_mhas_pl) return;\n\n\tif (!ch->sample) return;\n\tch->xps_mask = 0;\n\n\t//we cannot touch the payload if encrypted but not CENC !!\n\tif (ch->is_encrypted && !ch->is_cenc)\n\t\treturn;\n\n\tif (ch->check_mhas_pl) {\n\t\t//we cannot touch the payload if encrypted !!\n\t\tif (ch->pck_encrypted) return;\n\t\tu64 ch_layout = 0;\n\t\ts32 PL = gf_mpegh_get_mhas_pl(ch->sample->data, ch->sample->dataLength, &ch_layout);\n\t\tif (PL>0) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROFILE_LEVEL, &PROP_UINT((u32) PL));\n\t\t\tch->check_mhas_pl = GF_FALSE;\n\t\t\tif (ch_layout)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(ch_layout));\n\t\t}\n\t\treturn;\n\t}\n\t//analyze mode, do not rewrite\n\tif (ch->owner->analyze) return;\n\n\t//we cannot touch the payload if encrypted but no SAI buffer\n\tif (ch->pck_encrypted && !ch->sai_buffer)\n\t\treturn;\n\n\tnalu_len = 4;\n\tif (ch->avcc) nalu_len = ch->avcc->nal_unit_size;\n\telse if (ch->hvcc) nalu_len = ch->hvcc->nal_unit_size;\n\telse if (ch->vvcc) nalu_len = ch->vvcc->nal_unit_size;\n\n\treset_state = 0;\n\n\tif (!ch->nal_bs) ch->nal_bs = gf_bs_new(ch->sample->data, ch->sample->dataLength, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ch->nal_bs, ch->sample->data, ch->sample->dataLength);\n\n\twhile (gf_bs_available(ch->nal_bs)) {\n\t\tBool replace_nal = GF_FALSE;\n\t\tu8 nal_type=0;\n\t\tu32 pos = (u32) gf_bs_get_position(ch->nal_bs);\n\t\tu32 size = gf_bs_read_int(ch->nal_bs, nalu_len*8);\n\t\t//this takes care of size + pos + nalu_len > 0 but (s32) size < 0 ...\n\t\tif (ch->sample->dataLength < size) break;\n\t\tif (ch->sample->dataLength < size + pos + nalu_len) break;\n\t\tif (ch->check_avc_ps) {\n\t\t\tu8 hdr = gf_bs_peek_bits(ch->nal_bs, 8, 0);\n\t\t\tnal_type = hdr & 0x1F;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch->check_hevc_ps) {\n\t\t\tu8 hdr = gf_bs_peek_bits(ch->nal_bs, 8, 0);\n\t\t\tnal_type = (hdr & 0x7E) >> 1;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch->check_vvc_ps) {\n\t\t\tu8 hdr = gf_bs_peek_bits(ch->nal_bs, 8, 1);\n\t\t\tnal_type = hdr >> 3;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(ch->nal_bs, size);\n\n\t\tif (replace_nal) {\n\t\t\tu32 move_size = ch->sample->dataLength - size - pos - nalu_len;\n\t\t\tisor_replace_nal(ch, ch->sample->data + pos + nalu_len, size, nal_type, &reset_state);\n\t\t\tif (move_size)\n\t\t\t\tmemmove(ch->sample->data + pos, ch->sample->data + pos + size + nalu_len, ch->sample->dataLength - size - pos - nalu_len);\n\n\t\t\tch->sample->dataLength -= size + nalu_len;\n\t\t\tgf_bs_reassign_buffer(ch->nal_bs, ch->sample->data, ch->sample->dataLength);\n\t\t\tgf_bs_seek(ch->nal_bs, pos);\n\n\t\t\t//remove nal from clear subsample range\n\t\t\tif (ch->pck_encrypted)\n\t\t\t\tisor_sai_bytes_removed(ch, pos, nalu_len+size);\n\t\t}\n\t}\n\n\tif (reset_state) {\n\t\tu8 *dsi=NULL;\n\t\tu32 dsi_size=0;\n\t\tif (ch->check_avc_ps) {\n\t\t\tgf_odf_avc_cfg_write(ch->avcc, &dsi, &dsi_size);\n\t\t}\n\t\telse if (ch->check_hevc_ps) {\n\t\t\tgf_odf_hevc_cfg_write(ch->hvcc, &dsi, &dsi_size);\n\t\t}\n\t\telse if (ch->check_vvc_ps) {\n\t\t\tgf_odf_vvc_cfg_write(ch->vvcc, &dsi, &dsi_size);\n\t\t}\n\t\tif (dsi && dsi_size) {\n\t\t\tu32 dsi_crc = gf_crc_32(dsi, dsi_size);\n\t\t\tif (ch->dsi_crc == dsi_crc) {\n\t\t\t\tgf_free(dsi);\n\t\t\t} else {\n\t\t\t\tch->dsi_crc = dsi_crc;\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) );\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMFF reader filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"isoffin.h\"\n\n#ifndef GPAC_DISABLE_ISOM\n\n#include <gpac/crypt_tools.h>\n#include <gpac/media_tools.h>\n\nISOMChannel *isor_get_channel(ISOMReader *reader, GF_FilterPid *pid)\n{\n\tu32 i=0;\n\tISOMChannel *ch;\n\twhile ((ch = (ISOMChannel *)gf_list_enum(reader->channels, &i))) {\n\t\tif (ch->pid == pid) return ch;\n\t}\n\treturn NULL;\n}\n\n\nstatic GFINLINE Bool isor_is_local(const char *url)\n{\n\tif (!strnicmp(url, \"file://\", 7)) return GF_TRUE;\n\tif (!strnicmp(url, \"gmem://\", 7)) return GF_TRUE;\n\tif (!strnicmp(url, \"gfio://\", 7)) return GF_TRUE;\n\tif (!strnicmp(url, \"isobmff://\", 10)) return GF_TRUE;\n\tif (strstr(url, \"://\")) return GF_FALSE;\n\t/*the rest is local (mounted on FS)*/\n\treturn GF_TRUE;\n}\n\n\nstatic GF_Err isoffin_setup(GF_Filter *filter, ISOMReader *read)\n{\n\tchar szURL[2048];\n\tchar *tmp, *src;\n\tGF_Err e;\n\tconst GF_PropertyValue *prop;\n\tif (!read) return GF_SERVICE_ERROR;\n\n\tif (read->pid) {\n\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\tassert(prop);\n\t\tsrc = prop->value.string;\n\t} else {\n\t\tsrc = read->src;\n\t}\n\tif (!src)  return GF_SERVICE_ERROR;\n\n\tread->src_crc = gf_crc_32(src, (u32) strlen(src));\n\n\tstrcpy(szURL, src);\n\ttmp = gf_file_ext_start(szURL);\n\tif (tmp) {\n\t\tBool truncate = GF_TRUE;\n\t\ttmp = strchr(tmp, '#');\n\t\tif (!tmp && read->pid) {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n\t\t\tif (prop && prop->value.string) {\n\t\t\t\ttmp = gf_file_ext_start(prop->value.string);\n\t\t\t\tif (tmp) tmp = strchr(tmp, '#');\n\t\t\t\ttruncate = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (tmp) {\n\t\t\tif (!strnicmp(tmp, \"#audio\", 6)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_AUDIO;\n\t\t\t} else if (!strnicmp(tmp, \"#video\", 6)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_VISUAL;\n\t\t\t} else if (!strnicmp(tmp, \"#auxv\", 5)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_AUXV;\n\t\t\t} else if (!strnicmp(tmp, \"#pict\", 5)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_PICT;\n\t\t\t} else if (!strnicmp(tmp, \"#text\", 5)) {\n\t\t\t\tread->play_only_first_media = GF_ISOM_MEDIA_TEXT;\n\t\t\t} else if (!strnicmp(tmp, \"#trackID=\", 9)) {\n\t\t\t\tread->play_only_track_id = atoi(tmp+9);\n\t\t\t} else if (!strnicmp(tmp, \"#ID=\", 4)) {\n\t\t\t\tread->play_only_track_id = atoi(tmp+4);\n\t\t\t} else {\n\t\t\t\tread->play_only_track_id = atoi(tmp+1);\n\t\t\t}\n\t\t\tif (truncate) tmp[0] = 0;\n\t\t}\n\t}\n\n\tif (! isor_is_local(szURL)) {\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tread->start_range = read->end_range = 0;\n\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_RANGE);\n\tif (prop) {\n\t\tread->start_range = prop->value.lfrac.num;\n\t\tread->end_range = prop->value.lfrac.den;\n\t}\n\n\tread->missing_bytes = 0;\n\te = gf_isom_open_progressive(szURL, read->start_range, read->end_range, read->sigfrag, &read->mov, &read->missing_bytes);\n\n\tif (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\tread->moov_not_loaded = 1;\n\t\treturn GF_OK;\n\t}\n\n\tread->input_loaded = GF_TRUE;\n\t//if missing bytes is set, file is incomplete, check if cache is complete\n\tif (read->missing_bytes) {\n\t\tread->input_loaded = GF_FALSE;\n\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\tif (prop && prop->value.boolean)\n\t\t\tread->input_loaded = GF_TRUE;\n\t}\n\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] error while opening %s, error=%s\\n\", szURL,gf_error_to_string(e)));\n\t\tgf_filter_setup_failure(filter, e);\n\t\treturn e;\n\t}\n\tread->frag_type = gf_isom_is_fragmented(read->mov) ? 1 : 0;\n    if (!read->frag_type && read->sigfrag) {\n        e = GF_BAD_PARAM;\n        GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] sigfrag requested but file %s is not fragmented\\n\", szURL));\n        gf_filter_setup_failure(filter, e);\n        return e;\n    }\n    \n\tread->timescale = gf_isom_get_timescale(read->mov);\n\tif (!read->input_loaded && read->frag_type)\n\t\tread->refresh_fragmented = GF_TRUE;\n\n\tif (read->strtxt)\n\t\tgf_isom_text_set_streaming_mode(read->mov, GF_TRUE);\n\n\treturn isor_declare_objects(read);\n}\n\nstatic void isoffin_delete_channel(ISOMChannel *ch)\n{\n\tisor_reset_reader(ch);\n\tif (ch->nal_bs) gf_bs_del(ch->nal_bs);\n\tif (ch->avcc) gf_odf_avc_cfg_del(ch->avcc);\n\tif (ch->hvcc) gf_odf_hevc_cfg_del(ch->hvcc);\n\tif (ch->vvcc) gf_odf_vvc_cfg_del(ch->vvcc);\n\tgf_free(ch);\n}\n\nstatic void isoffin_disconnect(ISOMReader *read)\n{\n\tread->disconnected = GF_TRUE;\n\twhile (gf_list_count(read->channels)) {\n\t\tISOMChannel *ch = (ISOMChannel *)gf_list_get(read->channels, 0);\n\t\tgf_list_rem(read->channels, 0);\n\t\tif (ch->pid)\n\t\t\tgf_filter_pid_remove(ch->pid);\n\t\tisoffin_delete_channel(ch);\n\t}\n\n\tif (read->mov) gf_isom_close(read->mov);\n\tread->mov = NULL;\n\n\tread->pid = NULL;\n}\n\nstatic GF_Err isoffin_reconfigure(GF_Filter *filter, ISOMReader *read, const char *next_url)\n{\n\tconst GF_PropertyValue *prop;\n\tu32 i, count;\n\tBool is_new_mov = GF_FALSE;\n\tu64 tfdt;\n//\tGF_ISOTrackID trackID;\n\tGF_ISOSegOpenMode flags=0;\n\tGF_Err e;\n\n\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\tif (prop && prop->value.boolean)\n\t\tread->input_loaded = GF_TRUE;\n\n\tread->refresh_fragmented = GF_FALSE;\n\tread->full_segment_flush = GF_TRUE;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] reconfigure triggered, URL %s\\n\", next_url));\n\n\t//no need to lock blob if next_url is a blob, all parsing and probing functions below will lock the blob if any\n\n\tswitch (gf_isom_probe_file_range(next_url, read->start_range, read->end_range)) {\n\t//this is a fragment\n\tcase 3:\n\t\tgf_isom_release_segment(read->mov, 1);\n\t\tgf_isom_reset_fragment_info(read->mov, GF_TRUE);\n\n\t\tif (read->no_order_check) flags |= GF_ISOM_SEGMENT_NO_ORDER_FLAG;\n\n\t\t//no longer used in filters\n#if 0\n\t\tif (scalable_segment) flags |= GF_ISOM_SEGMENT_SCALABLE_FLAG;\n#endif\n\t\te = gf_isom_open_segment(read->mov, next_url, read->start_range, read->end_range, flags);\n\t\tif (!read->input_loaded && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\te = GF_OK;\n\t\t}\n\t\t//always refresh fragmented files, since we could have a full moof+mdat in buffer (not incomplete file)\n\t\t//but still further fragments to be pushed\n\t\tif (!read->start_range && !read->end_range)\n\t\t\tread->refresh_fragmented = GF_TRUE;\n\t\tread->seg_name_changed = GF_TRUE;\n\n\t\tfor (i=0; i<gf_list_count(read->channels); i++) {\n\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\tif (ch->last_state==GF_EOS)\n\t\t\t\tch->last_state=GF_OK;\n\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\tif (e<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Error opening new segment %s at UTC \"LLU\": %s\\n\", next_url, gf_net_get_utc(), gf_error_to_string(e) ));\n\t\t} else if (read->end_range) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Playing new range in %s: \"LLU\"-\"LLU\"\\n\", next_url, read->start_range, read->end_range));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] playing new segment %s\\n\", next_url));\n\t\t}\n#endif\n\t\tbreak;\n\t//this is a movie, reload\n\tcase 2:\n\tcase 1:\n\t\t//get tfdt of next segment (cumulated sample dur since moov load)\n\t\t//if the next segment has a tfdt or a tfrx, this will be ignored\n\t\t//otherwise this value will be used as base tfdt for next segment\n\t\ttfdt = gf_isom_get_smooth_next_tfdt(read->mov, 1);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Switching between files - opening new init segment %s (time offset=\"LLU\") - range \"LLU\"-\"LLU\"\\n\", next_url, tfdt, read->start_range, read->end_range));\n\n\t\tif (gf_isom_is_smooth_streaming_moov(read->mov)) {\n\t\t\tchar *tfdt_val = strstr(next_url, \"tfdt=\");\n\t\t\t//smooth addressing, replace tfdt=0000000000000000 with proper value\n\t\t\tif (tfdt_val) {\n\t\t\t\tsprintf(tfdt_val+5, LLX, tfdt);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Error finding init time for init segment %s at UTC \"LLU\"\\n\", next_url, gf_net_get_utc() ));\n\t\t\t}\n\t\t}\n\n\t\tif (read->mov) gf_isom_close(read->mov);\n\t\te = gf_isom_open_progressive(next_url, read->start_range, read->end_range, read->sigfrag, &read->mov, &read->missing_bytes);\n\n\t\t//init seg not completely downloaded, retry at next packet\n\t\tif (!read->input_loaded && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\tread->src_crc = 0;\n\t\t\tread->moov_not_loaded = 2;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tread->moov_not_loaded = 0;\n\t\tif (e < 0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Error opening init segment %s at UTC \"LLU\": %s\\n\", next_url, gf_net_get_utc(), gf_error_to_string(e) ));\n\t\t}\n\t\tif (read->sigfrag)\n\t\t\tgf_isom_enable_traf_map_templates(read->mov);\n\n\t\tis_new_mov = GF_TRUE;\n\t\tbreak;\n\t//empty file\n\tcase 4:\n\t\treturn GF_OK;\n\tdefault:\n\t\tif (!read->mov) {\n            return GF_NOT_SUPPORTED;\n\t\t}\n        e = GF_ISOM_INVALID_FILE;\n        break;\n\t}\n\n\tgf_filter_post_process_task(filter);\n\n\tcount = gf_list_count(read->channels);\n\t\n\tif (e<0) {\n\t\tcount = gf_list_count(read->channels);\n\t\tgf_isom_release_segment(read->mov, 1);\n        read->invalid_segment = GF_TRUE;\n\t\t//error opening the segment, reset everything ...\n\t\tgf_isom_reset_fragment_info(read->mov, GF_FALSE);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n            if (ch) {\n                ch->sample_num = 0;\n                ch->eos_sent = GF_FALSE;\n            }\n\t\t}\n        GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Error opening current segment %s: %s\\n\", next_url, gf_error_to_string(e) ));\n\t\treturn GF_OK;\n\t}\n\t//segment is the first in our cache, we may need a refresh\n\tif (!read->input_loaded) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Opening current segment in progressive mode (download in progress)\\n\"));\n\t} else {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Opening current segment in non-progressive mode (completely downloaded)\\n\"));\n\t}\n\n\tisor_check_producer_ref_time(read);\n\n\tfor (i=0; i<count; i++) {\n\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\tch->last_state = GF_OK;\n\t\tch->eos_sent = GF_FALSE;\n\n\t\t//old code from master, currently no longer used\n\t\t//in filters we don't use extractors for the time being, we only do implicit reconstruction at the decoder side\n#if 0\n\t\tif (ch->base_track) {\n\t\t\tif (scalable_segment)\n\t\t\t\ttrackID = gf_isom_get_highest_track_in_scalable_segment(read->mov, ch->base_track);\n\t\t\t\tif (trackID) {\n\t\t\t\t\tch->track_id = trackID;\n\t\t\t\t\tch->track = gf_isom_get_track_by_id(read->mov, ch->track_id);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tch->track = ch->base_track;\n\t\t\t\tch->track_id = gf_isom_get_track_id(read->mov, ch->track);\n\t\t\t}\n\t\t}\n#endif\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Track %d - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\n\t\t//TODO: signal all discontinuities here\n\t\tif (is_new_mov) {\n\t\t\tch->track = gf_isom_get_track_by_id(read->mov, ch->track_id);\n\t\t\tif (!ch->track) {\n\t\t\t\tif (gf_isom_get_track_count(read->mov)==1) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Mismatch between track IDs of different representations\\n\"));\n\t\t\t\t\tch->track = 1;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Mismatch between track IDs of different representations\\n\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*we changed our moov structure, sample_num now starts from 0*/\n\t\t\tch->sample_num = 0;\n\t\t\t//this may happen if we reload moov before initializing the channel\n\t\t\tif (!ch->last_sample_desc_index)\n\t\t\t\tch->last_sample_desc_index = 1;\n\t\t\t//and update channel config\n\t\t\tisor_update_channel_config(ch);\n\n\t\t\t/*restore NAL extraction mode*/\n\t\t\tgf_isom_set_nalu_extract_mode(read->mov, ch->track, ch->nalu_extract_mode);\n\n\t\t\tif (ch->is_cenc) {\n\t\t\t\tisor_set_crypt_config(ch);\n\t\t\t}\n\t\t}\n\n\t\tch->last_state = GF_OK;\n\t}\n\treturn e;\n}\n\nGF_Err isoffin_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *prop;\n\tISOMReader *read = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tisoffin_disconnect(read);\n\t\treturn GF_OK;\n\t}\n\t//check if we  have a file path; if not, this is a pure stream of boxes (no local file cache)\n\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);\n\tif (!prop || !prop->value.string) {\n\t\tif (!read->mem_load_mode)\n\t\t\tread->mem_load_mode = 1;\n\t\tif (!read->pid) read->pid = pid;\n\t\tread->input_loaded = GF_FALSE;\n\t\treturn GF_OK;\n\t}\n\n\tif (read->pid && prop->value.string) {\n\t\tconst char *next_url = prop->value.string;\n\t\tu64 sr, er;\n\t\tu32 crc = gf_crc_32(next_url, (u32) strlen(next_url) );\n\n\t\tsr = er = 0;\n\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_RANGE);\n\t\tif (prop) {\n\t\t\tsr = prop->value.lfrac.num;\n\t\t\ter = prop->value.lfrac.den;\n\t\t}\n\n\t\t//if eos is signaled, don't check for crc since we might have the same blob address (same alloc)\n\t\tif (!read->eos_signaled && (read->src_crc == crc) && (read->start_range==sr) && (read->end_range==er)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] same URL crc and range for %s, skipping reconfigure\\n\", next_url));\n\t\t\treturn GF_OK;\n\t\t}\n\t\tread->src_crc = crc;\n\t\tread->start_range = sr;\n\t\tread->end_range = er;\n\t\tread->input_loaded = GF_FALSE;\n\t\tread->eos_signaled = GF_FALSE;\n\t\t\n\t\t//we need to reconfigure\n\t\treturn isoffin_reconfigure(filter, read, next_url);\n\t}\n\n\tread->pid = pid;\n\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_CACHED);\n\tif (prop && prop->value.boolean) {\n\t\tGF_FilterEvent evt;\n\t\tread->input_loaded = GF_TRUE;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY_HINT, pid);\n\t\tevt.play.full_file_only=1;\n\t\tgf_filter_pid_send_event(pid, &evt);\n\t}\n\treturn isoffin_setup(filter, read);\n}\n\nGF_Err isoffin_initialize(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tGF_Err e = GF_OK;\n\tread->filter = filter;\n\tread->channels = gf_list_new();\n\n\tif (read->xps_check==MP4DMX_XPS_AUTO) {\n\t\tread->xps_check = (read->smode==MP4DMX_SPLIT_EXTRACTORS) ? MP4DMX_XPS_KEEP : MP4DMX_XPS_REMOVE;\n\t}\n\n\tif (read->src) {\n\t\tread->input_loaded = GF_TRUE;\n\t\treturn isoffin_setup(filter, read);\n\t}\n\telse if (read->mov) {\n\t\tread->extern_mov = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t\tread->frag_type = gf_isom_is_fragmented(read->mov) ? 1 : 0;\n\t\tread->timescale = gf_isom_get_timescale(read->mov);\n\n\t\tif (read->sigfrag) {\n\t\t\tgf_isom_enable_traf_map_templates(read->mov);\n\t\t}\n\n\t\tif (read->catseg) {\n\t\t\te = gf_isom_open_segment(read->mov, read->catseg, 0, 0, 0);\n\t\t}\n\t\tif (!e)\n\t\t\te = isor_declare_objects(read);\n\n\t\tgf_filter_post_process_task(filter);\n\t}\n\treturn e;\n}\n\n\nstatic void isoffin_finalize(GF_Filter *filter)\n{\n\tISOMReader *read = (ISOMReader *) gf_filter_get_udta(filter);\n\n\tread->disconnected = GF_TRUE;\n\n\twhile (gf_list_count(read->channels)) {\n\t\tISOMChannel *ch = (ISOMChannel *)gf_list_get(read->channels, 0);\n\t\tgf_list_rem(read->channels, 0);\n\t\tisoffin_delete_channel(ch);\n\t}\n\tgf_list_del(read->channels);\n\n\tif (!read->extern_mov && read->mov) gf_isom_close(read->mov);\n\tread->mov = NULL;\n\n\tif (read->mem_blob.data) gf_free(read->mem_blob.data);\n\tif (read->mem_url) gf_free(read->mem_url);\n}\n\nvoid isor_declare_pssh(ISOMChannel *ch)\n{\n\tu32 i, PSSH_count;\n\tu8 *psshd;\n\tGF_BitStream *pssh_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tu32 s;\n\n\tPSSH_count = gf_isom_get_pssh_count(ch->owner->mov);\n\tgf_bs_write_u32(pssh_bs, PSSH_count);\n\n\t/*fill PSSH in the structure. We will free it in CENC_Setup*/\n\tfor (i=0; i<PSSH_count; i++) {\n\t\tbin128 SystemID;\n\t\tu32 version;\n\t\tu32 KID_count;\n\t\tbin128 *KIDs;\n\t\tu32 private_data_size;\n\t\tu8 *private_data;\n\t\tgf_isom_get_pssh_info(ch->owner->mov, i+1, SystemID, &version, &KID_count, (const bin128 **) & KIDs, (const u8 **) &private_data, &private_data_size);\n\n\t\tgf_bs_write_data(pssh_bs, SystemID, 16);\n\t\tgf_bs_write_u32(pssh_bs, version);\n\t\tgf_bs_write_u32(pssh_bs, KID_count);\n\t\tfor (s=0; s<KID_count; s++) {\n\t\t\tgf_bs_write_data(pssh_bs, KIDs[s], 16);\n\t\t}\n\t\tgf_bs_write_u32(pssh_bs, private_data_size);\n\t\tgf_bs_write_data(pssh_bs, private_data, private_data_size);\n\t}\n\tgf_bs_get_content(pssh_bs, &psshd, &s);\n\tgf_bs_del(pssh_bs);\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_PSSH, & PROP_DATA_NO_COPY(psshd, s) );\n}\n\nvoid isor_set_crypt_config(ISOMChannel *ch)\n{\n\tGF_ISOFile *mov = ch->owner->mov;\n\tu32 track = ch->track;\n\tu32 scheme_type, scheme_version, i, count;\n\tconst char *kms_uri, *scheme_uri;\n\tBool selectiveEncryption=0;\n\tu32 IVLength=0;\n\tu32 KeyIndicationLength=0;\n\tconst char *txtHdr=NULL;\n\tconst char *contentID=NULL;\n\tu32 txtHdrLen=0;\n\tu64 plainTextLen=0;\n\tu32 crypt_type=0;\n\tu32 stsd_idx = ch->owner->stsd ? ch->owner->stsd : 1;\n\n\tif (!ch->is_encrypted) return;\n\n\tscheme_type = scheme_version = 0;\n\tkms_uri = scheme_uri = NULL;\n\n\t/*ugly fix to detect when an stsd uses both clear and encrypted sample descriptions*/\n\tcount = gf_isom_get_sample_description_count(ch->owner->mov, ch->track);\n\tif (count>1) {\n\t\tu32 first_crypted_stsd = 0;\n\t\tu32 nb_same_mtype = 1;\n\t\tu32 nb_clear=0, nb_encrypted=0;\n\t\tu32 base_subtype = 0;\n\t\tBool first_is_clear = GF_FALSE;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 mtype = gf_isom_get_media_subtype(ch->owner->mov, ch->track, i+1);\n\t\t\tif ( gf_isom_is_media_encrypted(ch->owner->mov, track, i+1)) {\n\t\t\t\tgf_isom_get_original_format_type(ch->owner->mov, ch->track, i+1, &mtype);\n\t\t\t\tnb_encrypted++;\n\t\t\t\tif (!first_crypted_stsd) first_crypted_stsd = i+1;\n\t\t\t} else {\n\t\t\t\tnb_clear++;\n\t\t\t\tif (!i) first_is_clear = GF_TRUE;\n\t\t\t}\n\t\t\tif (!i) base_subtype = mtype;\n\t\t\telse if (base_subtype==mtype) {\n\t\t\t\tnb_same_mtype++;\n\t\t\t}\n\t\t}\n\t\tif ((nb_same_mtype==count) && (nb_clear==nb_encrypted)) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_STSD_MODE, &PROP_UINT(first_is_clear ? 1 : 2) );\n\t\t\tstsd_idx = first_crypted_stsd;\n\t\t}\n\n\t}\n\n\tif (gf_isom_is_ismacryp_media(mov, track, stsd_idx)) {\n\t\tgf_isom_get_ismacryp_info(mov, track, stsd_idx, NULL, &scheme_type, &scheme_version, &scheme_uri, &kms_uri, &selectiveEncryption, &IVLength, &KeyIndicationLength);\n\t} else if (gf_isom_is_omadrm_media(mov, track, stsd_idx)) {\n\t\t//u8 hash[20];\n\t\tgf_isom_get_omadrm_info(mov, track, stsd_idx, NULL, &scheme_type, &scheme_version, &contentID, &kms_uri, &txtHdr, &txtHdrLen, &plainTextLen, &crypt_type, &selectiveEncryption, &IVLength, &KeyIndicationLength);\n\n\t\t//gf_media_get_file_hash(gf_isom_get_filename(mov), hash);\n\t} else if (gf_isom_is_cenc_media(mov, track, stsd_idx)) {\n\t\tch->is_cenc = GF_TRUE;\n\n\t\tgf_isom_get_cenc_info(ch->owner->mov, ch->track, stsd_idx, NULL, &scheme_type, &scheme_version);\n\n\t\t//if no PSSH declared, DO update the properties (PSSH is not mandatory)\n\t} else if (gf_isom_is_adobe_protection_media(mov, track, stsd_idx)) {\n\t\tu32 ofmt;\n\t\tscheme_version = 1;\n\t\tscheme_type = GF_ISOM_ADOBE_SCHEME;\n\t\tconst char *metadata = NULL;\n\n\t\tgf_isom_get_adobe_protection_info(mov, track, stsd_idx, &ofmt, &scheme_type, &scheme_version, &metadata);\n\t\tif (metadata)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ADOBE_CRYPT_META, &PROP_DATA((char *)metadata, (u32) strlen(metadata) ) );\n\t}\n\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, &PROP_4CC(scheme_type) );\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION, &PROP_UINT(scheme_version) );\n\tif (scheme_uri) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROTECTION_SCHEME_URI, &PROP_STRING((char*) scheme_uri) );\n\tif (kms_uri) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROTECTION_KMS_URI, &PROP_STRING((char*) kms_uri) );\n\n\tif (selectiveEncryption) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISMA_SELECTIVE_ENC, &PROP_BOOL(GF_TRUE) );\n\tif (IVLength) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISMA_IV_LENGTH, &PROP_UINT(IVLength) );\n\tif (KeyIndicationLength) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISMA_KI_LENGTH, &PROP_UINT(KeyIndicationLength) );\n\tif (crypt_type) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_OMA_CRYPT_TYPE, &PROP_UINT(crypt_type) );\n\tif (contentID) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_OMA_CID, &PROP_STRING(contentID) );\n\tif (txtHdr) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_OMA_TXT_HDR, &PROP_STRING(txtHdr) );\n\tif (plainTextLen) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_OMA_CLEAR_LEN, &PROP_LONGUINT(plainTextLen) );\n\n\tif (ch->is_cenc) {\n\t\tconst u8 *key_info;\n\t\tu32 key_info_size;\n\t\tu32 container_type;\n\n\t\tisor_declare_pssh(ch);\n\n\t\tgf_isom_cenc_get_default_info(ch->owner->mov, ch->track, stsd_idx, &container_type, &ch->pck_encrypted, &ch->crypt_byte_block, &ch->skip_byte_block, &key_info, &key_info_size);\n\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_STORE, &PROP_4CC(container_type) );\n\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ENCRYPTED, &PROP_BOOL(ch->pck_encrypted) );\n\n\t\tif (ch->skip_byte_block || ch->crypt_byte_block) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_PATTERN, &PROP_FRAC_INT(ch->skip_byte_block, ch->crypt_byte_block) );\n\t\t}\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO, &PROP_DATA((u8 *)key_info, key_info_size) );\n\t\tch->key_info_crc = gf_crc_32(key_info, key_info_size);\n\t}\n}\n\n\nISOMChannel *isor_create_channel(ISOMReader *read, GF_FilterPid *pid, u32 track, u32 item_id, Bool force_no_extractors)\n{\n\tISOMChannel *ch;\n\tconst GF_PropertyValue *p;\n\ts64 ts_shift;\n\tif (!read->mov) return NULL;\n\n\tGF_SAFEALLOC(ch, ISOMChannel);\n\tif (!ch) {\n\t\treturn NULL;\n\t}\n\tch->owner = read;\n\tch->pid = pid;\n\tch->to_init = GF_TRUE;\n\tgf_list_add(read->channels, ch);\n\tch->track = track;\n\tch->item_id = item_id;\n\n\tch->nalu_extract_mode = 0;\n\tch->track_id = gf_isom_get_track_id(read->mov, ch->track);\n\tswitch (gf_isom_get_media_type(ch->owner->mov, ch->track)) {\n\tcase GF_ISOM_MEDIA_OCR:\n\t\tch->streamType = GF_STREAM_OCR;\n\t\tbreak;\n\tcase GF_ISOM_MEDIA_SCENE:\n\t\tch->streamType = GF_STREAM_SCENE;\n\t\tbreak;\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_AUXV:\n\tcase GF_ISOM_MEDIA_PICT:\n\t\tgf_isom_get_reference(ch->owner->mov, ch->track, GF_ISOM_REF_BASE, 1, &ch->base_track);\n\t\t//use base track only if avc/svc or hevc/lhvc. If avc+lhvc we need different rules\n\t\tif ( gf_isom_get_avc_svc_type(ch->owner->mov, ch->base_track, 1) == GF_ISOM_AVCTYPE_AVC_ONLY) {\n\t\t\tif ( gf_isom_get_hevc_lhvc_type(ch->owner->mov, ch->track, 1) >= GF_ISOM_HEVCTYPE_HEVC_ONLY) {\n\t\t\t\tch->base_track=0;\n\t\t\t}\n\t\t}\n\t\tch->next_track = 0;\n\t\t/*in scalable mode add SPS/PPS in-band*/\n\t\tif (ch->base_track)\n\t\t\tch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG /*| GF_ISOM_NALU_EXTRACT_ANNEXB_FLAG*/;\n\t\tbreak;\n\t}\n\tif (!read->noedit) {\n\t\tch->ts_offset = 0;\n\t\tch->has_edit_list = gf_isom_get_edit_list_type(ch->owner->mov, ch->track, &ch->ts_offset) ? GF_TRUE : GF_FALSE;\n\t\tif (!ch->has_edit_list && ch->ts_offset) {\n\t\t\t//if >0 this is a hold, we signal positive delay\n\t\t\t//if <0 this is a skip, we signal negative delay\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DELAY, &PROP_LONGSINT( ch->ts_offset) );\n\t\t}\n\t} else\n\t\tch->has_edit_list = GF_FALSE;\n\n\tch->has_rap = (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1) ? GF_TRUE : GF_FALSE;\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t//some fragmented files do not advertize a sync sample table (legal) so we need to update as soon as we fetch a fragment\n\t//to see if we are all-intra (as detected here) or not\n\tif (!ch->has_rap && ch->owner->frag_type)\n\t\tch->check_has_rap = GF_TRUE;\n\tch->timescale = gf_isom_get_media_timescale(ch->owner->mov, ch->track);\n\n\tts_shift = gf_isom_get_cts_to_dts_shift(ch->owner->mov, ch->track);\n\tif (ts_shift) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CTS_SHIFT, &PROP_UINT((u32) ts_shift) );\n\t}\n\n\tif (!track || !gf_isom_is_track_encrypted(read->mov, track)) {\n\t\tif (force_no_extractors) {\n\t\t\tch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_LAYER_ONLY;\n\t\t} else {\n\t\t\tswitch (read->smode) {\n\t\t\tcase MP4DMX_SPLIT_EXTRACTORS:\n\t\t\t\tch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_INSPECT | GF_ISOM_NALU_EXTRACT_TILE_ONLY;\n\t\t\t\tbreak;\n\t\t\tcase MP4DMX_SPLIT:\n\t\t\t\tch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_LAYER_ONLY | GF_ISOM_NALU_EXTRACT_TILE_ONLY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ch->nalu_extract_mode) {\n\t\t\tgf_isom_set_nalu_extract_mode(ch->owner->mov, ch->track, ch->nalu_extract_mode);\n\t\t}\n\t\treturn ch;\n\t}\n\tif (ch->owner->nocrypt) {\n\t\tch->is_encrypted = GF_FALSE;\n\t\treturn ch;\n\t}\n\tch->is_encrypted = GF_TRUE;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) gf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_STREAM_TYPE, &PROP_UINT(p->value.uint) );\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_ENCRYPTED) );\n\n\tisor_set_crypt_config(ch);\n\n\tif (ch->nalu_extract_mode) {\n\t\tif (ch->is_encrypted) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] using sample NAL rewrite with encryption is not yet supported, patch welcome\\n\"));\n\t\t} else {\n\t\t\tgf_isom_set_nalu_extract_mode(ch->owner->mov, ch->track, ch->nalu_extract_mode);\n\t\t}\n\t}\n\treturn ch;\n}\n\n/*switch channel quality. Return next channel or current channel if error*/\nstatic\nu32 isoffin_channel_switch_quality(ISOMChannel *ch, GF_ISOFile *the_file, Bool switch_up)\n{\n\tu32 i, count, next_track, trackID, cur_track;\n\ts32 ref_count;\n\n\tcur_track = ch->next_track ? ch->next_track : ch->track;\n\tcount = gf_isom_get_track_count(the_file);\n\ttrackID = gf_isom_get_track_id(the_file, cur_track);\n\tnext_track = 0;\n\n\tif (switch_up) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tref_count = gf_isom_get_reference_count(the_file, i+1, GF_ISOM_REF_SCAL);\n\t\t\tif (ref_count < 0)\n\t\t\t\treturn cur_track; //error\n\t\t\tif (ref_count == 0)\n\t\t\t\tcontinue;\n\t\t\t/*next track is the one that has the last reference of type GF_ISOM_REF_SCAL refers to this current track*/\n\t\t\tif ((u32)ref_count == gf_isom_has_track_reference(the_file, i+1, GF_ISOM_REF_SCAL, trackID)) {\n\t\t\t\tnext_track = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*this is the highest quality*/\n\t\tif (!next_track) {\n\t\t\tch->playing = GF_TRUE;\n\t\t\tref_count = gf_isom_get_reference_count(the_file, ch->track, GF_ISOM_REF_BASE);\n\t\t\ttrackID = 0;\n\t\t\tif (ref_count) {\n\t\t\t\tgf_isom_get_reference(the_file, ch->track, GF_ISOM_REF_BASE, 1, &trackID);\n\t\t\t\tfor (i=0; i<gf_list_count(ch->owner->channels) && trackID; i++) {\n\t\t\t\t\tISOMChannel *base = gf_list_get(ch->owner->channels, i);\n\t\t\t\t\tif (base->track_id==trackID) {\n\t\t\t\t\t\tu32 sample_desc_index;\n\t\t\t\t\t\tu64 resume_at;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\t//try to locate sync after current time in base\n\t\t\t\t\t\tresume_at = gf_timestamp_rescale(base->static_sample->DTS, base->timescale, ch->timescale);\n\t\t\t\t\t\te = gf_isom_get_sample_for_media_time(ch->owner->mov, ch->track, resume_at, &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t//found, rewind so that next fetch is the sync\n\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//no further sync found, realign with base timescale\n\t\t\t\t\t\telse if (e==GF_EOS) {\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_media_time(ch->owner->mov, ch->track, resume_at, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//unknown state, realign sample num with base\n\t\t\t\t\t\tif (e<0) {\n\t\t\t\t\t\t\tch->sample_num = base->sample_num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cur_track;\n\t\t}\n\t} else {\n\t\tif (cur_track == ch->base_track)\n\t\t\treturn cur_track;\n\t\tref_count = gf_isom_get_reference_count(the_file, cur_track, GF_ISOM_REF_SCAL);\n\t\tif (ref_count <= 0)\n\t\t\treturn cur_track;\n\t\tgf_isom_get_reference(the_file, cur_track, GF_ISOM_REF_SCAL, ref_count, &next_track);\n\t\tif (!next_track)\n\t\t\treturn cur_track;\n\n\t\tif (ch->track != next_track) {\n\t\t\tch->playing = GF_FALSE;\n\t\t\tch->eos_sent = GF_TRUE;\n\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t}\n\t}\n\n\t/*in scalable mode add SPS/PPS in-band*/\n\tif (ch->owner->smode)\n\t\tgf_isom_set_nalu_extract_mode(the_file, next_track, ch->nalu_extract_mode);\n\n\treturn next_track;\n}\n\nstatic Bool isoffin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 count, i;\n\tBool cancel_event = GF_TRUE;\n\tISOMChannel *ch;\n\tISOMReader *read = gf_filter_get_udta(filter);\n\n\tif (!read || read->disconnected) return GF_FALSE;\n\n\tif (evt->base.type == GF_FEVT_QUALITY_SWITCH) {\n\t\tcount = gf_list_count(read->channels);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tch = (ISOMChannel *)gf_list_get(read->channels, i);\n\t\t\tif (ch->base_track && gf_isom_needs_layer_reconstruction(read->mov)) {\n\t\t\t\t/*ch->next_track = */ //old code, see not in isoffin_reconfigure\n\t\t\t\tisoffin_channel_switch_quality(ch, read->mov, evt->quality_switch.up);\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\n\tif (!evt->base.on_pid) return GF_FALSE;\n\n\tch = isor_get_channel(read, evt->base.on_pid);\n\tif (!ch)\n\t\treturn GF_FALSE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tisor_reset_reader(ch);\n\t\tch->eos_sent = GF_FALSE;\n\t\tch->speed = evt->play.speed;\n\t\tch->initial_play_seen = GF_TRUE;\n\t\tread->reset_frag_state = 1;\n\t\t//it can happen that input_is_stop is still TRUE because we did not get called back after the stop - reset to FALSE since we now play\n\t\tread->input_is_stop = GF_FALSE;\n\t\tif (read->frag_type)\n\t\t\tread->frag_type = 1;\n\n\t\tch->start = ch->end = 0;\n\t\tif (evt->play.speed>=0) {\n\t\t\tDouble t;\n\t\t\tif (evt->play.start_range>=0) {\n\t\t\t\tt = evt->play.start_range;\n\t\t\t\tt *= ch->timescale;\n\t\t\t\tch->start = (u64) t;\n\t\t\t}\n\t\t\tif (evt->play.end_range >= evt->play.start_range) {\n\t\t\t\tch->end = (u64) -1;\n\t\t\t\tif (evt->play.end_range<FLT_MAX) {\n\t\t\t\t\tt = evt->play.end_range;\n\t\t\t\t\tt *= ch->timescale;\n\t\t\t\t\tch->end = (u64) t;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tDouble end = evt->play.end_range;\n\t\t\tif (end==-1) end = 0;\n\t\t\tch->start = (u64) (s64) (evt->play.start_range * ch->timescale);\n\t\t\tif (end <= evt->play.start_range)\n\t\t\t\tch->end = (u64) (s64) (end  * ch->timescale);\n\t\t}\n\t\tch->playing = GF_TRUE;\n\t\tch->sample_num = evt->play.from_pck;\n\n\t\tch->sap_only = evt->play.drop_non_ref ? GF_TRUE : GF_FALSE;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Starting channel playback \"LLD\" to \"LLD\" (%g to %g)\\n\", ch->start, ch->end, evt->play.start_range, evt->play.end_range));\n\n\t\tif (!read->nb_playing)\n\t\t\tgf_isom_reset_seq_num(read->mov);\n\n\t\tif (read->is_partial_download) read->input_loaded = GF_FALSE;\n\n\t\tif (evt->play.no_byterange_forward) {\n\t\t\t//new segment will be loaded, reset\n\t\t\tgf_isom_reset_tables(read->mov, GF_TRUE);\n\t\t\tgf_isom_reset_data_offset(read->mov, NULL);\n\t\t\tread->refresh_fragmented = GF_TRUE;\n\t\t\tread->mem_blob.size = 0;\n\t\t\t//send play event\n\t\t\tcancel_event = GF_FALSE;\n\t\t} else if (!read->nb_playing && read->pid && !read->input_loaded) {\n\t\t\tGF_FilterEvent fevt;\n\t\t\tBool is_sidx_seek = GF_FALSE;\n\t\t\tu64 max_offset = GF_FILTER_NO_BO;\n\t\t\tcount = gf_list_count(read->channels);\n\n\t\t\t//try sidx\n\t\t\tif (read->frag_type) {\n\t\t\t\tu32 ts;\n\t\t\t\tu64 dur=0;\n\t\t\t\tGF_Err e = gf_isom_get_file_offset_for_time(read->mov, evt->play.start_range, &max_offset);\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\tif (evt->play.start_range>0)\n\t\t\t\t\t\tgf_isom_reset_tables(read->mov, GF_TRUE);\n\n\t\t\t\t\tis_sidx_seek = GF_TRUE;\n\t\t\t\t\t//in case we loaded moov but not sidx, update duration\n\t\t\t\t\tif ((gf_isom_get_sidx_duration(read->mov, &dur, &ts)==GF_OK) && dur) {\n\t\t\t\t\t\tdur = gf_timestamp_rescale(dur, ts, read->timescale);\n\t\t\t\t\t\tif (ch->duration != dur) {\n\t\t\t\t\t\t\tch->duration = dur;\n\t\t\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ch->duration, read->timescale));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!is_sidx_seek) {\n\t\t\t\tfor (i=0; i< count; i++) {\n\t\t\t\t\tu32 mode, sample_desc_index, sample_num;\n\t\t\t\t\tu64 data_offset;\n\t\t\t\t\tGF_Err e;\n\t\t\t\t\tu64 time;\n\t\t\t\t\tch = gf_list_get(read->channels, i);\n\t\t\t\t\tmode = ch->disable_seek ? GF_ISOM_SEARCH_BACKWARD : GF_ISOM_SEARCH_SYNC_BACKWARD;\n\t\t\t\t\ttime = (u64) (evt->play.start_range * ch->timescale);\n\n\t\t\t\t\t/*take care of seeking out of the track range*/\n\t\t\t\t\tif (!read->frag_type && (ch->duration < time)) {\n\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(read->mov, ch->track, ch->duration, \t&sample_desc_index, mode, NULL, &sample_num, &data_offset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(read->mov, ch->track, time, &sample_desc_index, mode, NULL, &sample_num, &data_offset);\n\t\t\t\t\t}\n\t\t\t\t\tif ((e == GF_OK) && (data_offset<max_offset))\n\t\t\t\t\t\tmax_offset = data_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((evt->play.start_range || read->is_partial_download)  && (max_offset != GF_FILTER_NO_BO) ) {\n\n\t\t\t\t//send a seek request\n\t\t\t\tread->is_partial_download = GF_TRUE;\n\t\t\t\tread->wait_for_source = GF_TRUE;\n\t\t\t\tread->refresh_fragmented = GF_TRUE;\n\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, read->pid);\n\t\t\t\tfevt.seek.start_offset = max_offset;\n\t\t\t\tgf_filter_pid_send_event(read->pid, &fevt);\n\t\t\t\tgf_isom_set_byte_offset(read->mov, is_sidx_seek ? 0 : max_offset);\n\n\t\t\t}\n\t\t}\n\t\t//always request a process task upon a play\n\t\tgf_filter_post_process_task(read->filter);\n\t\tread->nb_playing++;\n\t\t//cancel event unless dash mode\n\t\treturn cancel_event;\n\n\tcase GF_FEVT_STOP:\n \t\tif (read->nb_playing) read->nb_playing--;\n\t\tisor_reset_reader(ch);\n\t\t//don't send a stop if some of our channels are still waiting for initial play\n\t\tfor (i=0; i<gf_list_count(read->channels); i++) {\n\t\t\tISOMChannel *a_ch = gf_list_get(read->channels, i);\n\t\t\tif (ch==a_ch) continue;\n\t\t\tif (!a_ch->initial_play_seen) return GF_TRUE;\n\t\t}\n\t\t//cancel event if nothing playing\n\t\tif (read->nb_playing) return GF_TRUE;\n\t\tread->input_is_stop = GF_TRUE;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\tcase GF_FEVT_RESUME:\n\t\tch->speed = evt->play.speed;\n\t\tif (ch->sap_only && !evt->play.drop_non_ref) {\n\t\t\tch->sap_only = 2;\n\t\t} else {\n\t\t\tch->sap_only = evt->play.drop_non_ref ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event\n\treturn GF_FALSE;\n}\n\nstatic void isoffin_push_buffer(GF_Filter *filter, ISOMReader *read, const u8 *pck_data, u32 data_size)\n{\n\tu64 bytes_missing;\n\tGF_Err e;\n\n\tif (!read->mem_url) {\n\t\tchar szPath[200];\n\t\tsprintf(szPath, \"gmem://%p\", &read->mem_blob);\n\t\tread->mem_url = gf_strdup(szPath);\n\t}\n\tread->mem_blob.data = gf_realloc(read->mem_blob.data, read->mem_blob.size + data_size);\n\tmemcpy(read->mem_blob.data + read->mem_blob.size, pck_data, data_size);\n\tread->mem_blob.size += data_size;\n\n\tif (read->mem_load_mode==1) {\n\t\tu32 box_type;\n\t\te = gf_isom_open_progressive_ex(read->mem_url, 0, 0, GF_FALSE, &read->mov, &bytes_missing, &box_type);\n\n\t\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\tgf_filter_setup_failure(filter, e);\n\t\t\tread->mem_load_mode = 0;\n\t\t\tread->in_error = e;\n\t\t\treturn;\n\t\t}\n\t\tif (!read->mov) {\n\t\t\tswitch (box_type) {\n\t\t\tcase GF_4CC('m','d','a','t'):\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] non fragmented ISOBMFF with moof after mdat and no underlying file cache (pipe or other stream input), not supported !\\n\"));\n\t\t\t\tgf_filter_setup_failure(filter, GF_NOT_SUPPORTED);\n\t\t\t\tread->mem_load_mode = 0;\n\t\t\t\tread->in_error = GF_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tread->moov_not_loaded = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tread->frag_type = gf_isom_is_fragmented(read->mov) ? 1 : 0;\n\t\tread->timescale = gf_isom_get_timescale(read->mov);\n\t\tisor_declare_objects(read);\n\t\tread->mem_load_mode = 2;\n\t\tread->moov_not_loaded = 0;\n\t\treturn;\n\t}\n\t//refresh file\n\tgf_isom_refresh_fragmented(read->mov, &bytes_missing, read->mem_url);\n\n\tif ((read->mem_load_mode==2) && bytes_missing)\n\t\tread->force_fetch = GF_TRUE;\n\n}\n\nstatic void isoffin_purge_mem(ISOMReader *read, u64 min_offset)\n{\n\tu32 i, count;\n\tu64 top_offset;\n\tu32 nb_bytes_to_purge;\n\tu64 bytes_missing;\n\n\t//purge every\n\tif (read->mstore_purge && (min_offset - read->last_min_offset < read->mstore_purge))\n\t\treturn;\n\n\tif (read->frag_type) {\n\t\t//get position of current box being parsed - if new offset is greater than this box we cannot remove\n\t\t//bytes (we would trash the top-level box header)\n\t\tgf_isom_get_current_top_box_offset(read->mov, &top_offset);\n\t\tif (top_offset<min_offset) {\n\t\t\treturn;\n\t\t}\n\t}\n\tread->last_min_offset = min_offset;\n\n\tassert(min_offset>=read->bytes_removed);\n\t//min_offset is given in absolute file position\n\tnb_bytes_to_purge = (u32) (min_offset - read->bytes_removed);\n\tassert(nb_bytes_to_purge<=read->mem_blob.size);\n\n\tmemmove(read->mem_blob.data, read->mem_blob.data+nb_bytes_to_purge, read->mem_blob.size - nb_bytes_to_purge);\n\tread->mem_blob.size -= nb_bytes_to_purge;\n\tread->bytes_removed += nb_bytes_to_purge;\n\tgf_isom_set_removed_bytes(read->mov, read->bytes_removed);\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] mem mode %d bytes in mem, \"LLU\" bytes trashed since start\\n\", read->mem_blob.size, read->bytes_removed));\n\n\t//force a refresh\n\tgf_isom_refresh_fragmented(read->mov, &bytes_missing, read->mem_url);\n\n\tif (!read->frag_type)\n\t\treturn;\n\n\t//fragmented file, cleanup sample tables\n\tcount = gf_list_count(read->channels);\n\tfor (i=0; i<count; i++) {\n\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\tu32 num_samples;\n\t\tu32 prev_samples = gf_isom_get_sample_count(read->mov, ch->track);\n\t\t//don't run this too often\n\t\tif (ch->sample_num<=1+read->mstore_samples) continue;\n\n\t\tnum_samples = ch->sample_num-1;\n\t\tif (num_samples>=prev_samples) continue;\n\n\t\tif (gf_isom_purge_samples(read->mov, ch->track, num_samples) == GF_OK)\n\t\t\tch->sample_num = 1;\n\n\t\tnum_samples = gf_isom_get_sample_count(read->mov, ch->track);\n\t\tassert(ch->sample_num<=num_samples);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] mem mode %d samples now in track %d (prev %d)\\n\", num_samples, ch->track_id, prev_samples));\n\t}\n}\n\nstatic GF_Err isoffin_process(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tu32 i, count = gf_list_count(read->channels);\n\tBool is_active = GF_FALSE;\n\tBool in_is_eos = GF_FALSE;\n\tBool check_forced_end = GF_FALSE;\n\tBool has_new_data = GF_FALSE;\n\tu64 min_offset_plus_one = 0;\n\tu32 nb_forced_end=0;\n\tif (read->in_error)\n\t\treturn read->in_error;\n\n\tif (read->pid) {\n\t\tBool fetch_input = GF_TRUE;\n\n\t\t//we failed at loading the init segment during a dash switch, retry\n\t\tif (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) {\n\t\t\tisoffin_configure_pid(filter, read->pid, GF_FALSE);\n\t\t\tif (read->moov_not_loaded) return GF_OK;\n\t\t}\n\t\tif (read->mem_load_mode==2) {\n\t\t\tif (!read->force_fetch && read->mem_blob.size > read->mstore_size) {\n\t\t\t\tfetch_input = GF_FALSE;\n\t\t\t}\n\t\t\tread->force_fetch = GF_FALSE;\n\t\t}\n\t\twhile (fetch_input) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid);\n\t\t\tif (!pck) {\n\t\t\t\t//we issued a seek, wait for the first packet to be received before fetching channels\n\t\t\t\t//otherwise we could end up reading from the wrong cache\n\t\t\t\tif (read->wait_for_source) {\n\t\t\t\t\t//something went wrong during the seek request\n\t\t\t\t\tif (gf_filter_pid_is_eos(read->pid))\n\t\t\t\t\t\treturn GF_EOS;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread->wait_for_source = GF_FALSE;\n\n\t\t\tif (read->mem_load_mode) {\n\t\t\t\tu32 data_size;\n\t\t\t\tconst u8 *pck_data = gf_filter_pck_get_data(pck, &data_size);\n\t\t\t\tisoffin_push_buffer(filter, read, pck_data, data_size);\n\t\t\t}\n\t\t\t//we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it\n\t\t\telse if (read->moov_not_loaded==2) {\n\t\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\thas_new_data = GF_TRUE;\n\t\t\tif (read->in_error)\n\t\t\t\treturn read->in_error;\n\t\t}\n\t\tif (gf_filter_pid_is_eos(read->pid)) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n\t\tif (read->input_is_stop) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t\tread->input_is_stop = GF_FALSE;\n\t\t}\n\t\tif (!read->frag_type && read->input_loaded) {\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n        //segment is invalid, wait for eos on input an send eos on all channels\n        if (read->invalid_segment) {\n            if (!in_is_eos) return GF_OK;\n            read->invalid_segment = GF_FALSE;\n\n            for (i=0; i<count; i++) {\n                ISOMChannel *ch = gf_list_get(read->channels, i);\n                if (!ch->playing) {\n                    continue;\n                }\n                if (!ch->eos_sent) {\n                    ch->eos_sent = GF_TRUE;\n                    gf_filter_pid_set_eos(ch->pid);\n                }\n            }\n            read->eos_signaled = GF_TRUE;\n            return GF_EOS;\n        }\n\t} else if (read->extern_mov) {\n\t\tin_is_eos = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t}\n\tif (read->moov_not_loaded==1) {\n\t\tif (read->mem_load_mode)\n\t\t\treturn GF_OK;\n\t\tread->moov_not_loaded = GF_FALSE;\n\t\treturn isoffin_setup(filter, read);\n\t}\n\n\tif (read->refresh_fragmented) {\n\t\tconst GF_PropertyValue *prop;\n\n\t\tif (in_is_eos) {\n\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t} else {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\t\tif (prop && prop->value.boolean)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\n\t\tif (has_new_data) {\n\t\t\tu64 bytesMissing=0;\n\t\t\tGF_Err e;\n\t\t\tconst char *new_url = NULL;\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\t\tif (prop) new_url = prop->value.string;\n\n\t\t\te = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);\n\n\t\t\tif (e && (e!= GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Failed to refresh current segment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Refreshing current segment at UTC \"LLU\" - \"LLU\" bytes still missing - input is EOS %d\\n\", gf_net_get_utc(), bytesMissing, in_is_eos));\n\t\t\t}\n\n\t\t\tif (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Incomplete Segment received - \"LLU\" bytes missing but EOF found\\n\", bytesMissing ));\n\t\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tisor_check_producer_ref_time(read);\n\t\t\tif (!read->frag_type)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 nb_pck=50;\n\t\tISOMChannel *ch;\n\t\tch = gf_list_get(read->channels, i);\n\t\tif (!ch->playing) {\n\t\t\tnb_forced_end++;\n\t\t\tcontinue;\n\t\t}\n\t\t//eos not sent on this channel, we are active\n\t\tif (!ch->eos_sent)\n\t\t\tis_active = GF_TRUE;\n\n\t\twhile (nb_pck) {\n\t\t\tch->sample_data_offset = 0;\n\t\t\tif (!read->full_segment_flush && gf_filter_pid_would_block(ch->pid) )\n\t\t\t\tbreak;\n\n\t\t\tif (ch->item_id) {\n\t\t\t\tisor_reader_get_sample_from_item(ch);\n\t\t\t} else {\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t}\n\n\t\t\tif (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) {\n\t\t\t\tisor_reader_release_sample(ch);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch->sample) {\n\t\t\t\tu32 sample_dur;\n\t\t\t\tu8 dep_flags;\n\t\t\t\tu8 *subs_buf;\n\t\t\t\tu32 subs_buf_size;\n\t\t\t\tGF_FilterPacket *pck;\n\t\t\t\tif (ch->needs_pid_reconfig) {\n\t\t\t\t\tisor_update_channel_config(ch);\n\t\t\t\t\tch->needs_pid_reconfig = GF_FALSE;\n\t\t\t\t}\n\n\t\t\t\t//we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed\n\t\t\t\tif (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) {\n\t\t\t\t\tch->check_has_rap = GF_FALSE;\n\t\t\t\t\tch->has_rap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t\t\t\t}\n\n\t\t\t\t//strip param sets from payload, trigger reconfig if needed\n\t\t\t\tisor_reader_check_config(ch);\n\n\t\t\t\tif (read->nodata) {\n\t\t\t\t\tpck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemcpy(data, ch->sample->data, ch->sample->dataLength);\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_dts(pck, ch->dts);\n\t\t\t\tgf_filter_pck_set_cts(pck, ch->cts);\n\t\t\t\tif (ch->sample->IsRAP==-1) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t\t\t\tch->redundant = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP);\n\t\t\t\t}\n\n\t\t\t\tif (ch->sap_3)\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);\n\t\t\t\telse if (ch->sap_4_type) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);\n\t\t\t\t\tgf_filter_pck_set_roll_info(pck, ch->roll);\n\t\t\t\t}\n\n\t\t\t\tsample_dur = ch->au_duration;\n\t\t\t\tif (ch->sample->nb_pack)\n\t\t\t\t\tsample_dur *= ch->sample->nb_pack;\n\t\t\t\tgf_filter_pck_set_duration(pck, sample_dur);\n\t\t\t\tgf_filter_pck_set_seek_flag(pck, ch->seek_flag);\n\n\t\t\t\t//for now we only signal xPS mask for non-sap\n\t\t\t\tif (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) );\n\t\t\t\t}\n\n\t\t\t\tdep_flags = ch->isLeading;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependsOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependedOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->redundant;\n\n\t\t\t\tif (dep_flags)\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(pck, dep_flags);\n\n\t\t\t\tgf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);\n\t\t\t\tgf_filter_pck_set_seq_num(pck, ch->sample_num);\n\n\n\t\t\t\tsubs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size);\n\t\t\t\tif (subs_buf) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );\n\t\t\t\t}\n\n\t\t\t\tif (ch->sai_buffer && ch->pck_encrypted) {\n\t\t\t\t\tassert(ch->sai_buffer_size);\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) );\n\t\t\t\t}\n\n\t\t\t\tif (read->sigfrag) {\n\t\t\t\t\tGF_ISOFragmentBoundaryInfo finfo;\n\t\t\t\t\tif (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) {\n\t\t\t\t\t\tu64 start=0;\n\t\t\t\t\t\tu32 traf_start = finfo.seg_start_plus_one ? 2 : 1;\n\n\t\t\t\t\t\tif (finfo.seg_start_plus_one)\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));\n\n\t\t\t\t\t\tstart = finfo.frag_start;\n\t\t\t\t\t\tif (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end));\n\t\t\t\t\t\tif (finfo.moof_template) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (finfo.sidx_end) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (read->seg_name_changed) {\n\t\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n\t\t\t\t\t\t\tread->seg_name_changed = GF_FALSE;\n\t\t\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_URL, &PROP_STRING(p->value.string));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ch->sender_ntp) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp));\n\t\t\t\t\tif (ch->ntp_at_server_ntp) {\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch->eos_sent = GF_FALSE;\n\n\t\t\t\t//this might not be the true end of stream\n\t\t\t\tif ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));\n\t\t\t\t}\n\n\t\t\t\tgf_filter_pck_send(pck);\n\t\t\t\tisor_reader_release_sample(ch);\n\n\t\t\t\tch->last_valid_sample_data_offset = ch->sample_data_offset;\n\t\t\t\tnb_pck--;\n\t\t\t} else if (ch->last_state==GF_EOS) {\n\t\t\t\tif (ch->playing == 2) {\n\t\t\t\t\tif (in_is_eos) {\n\t\t\t\t\t\tch->playing = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnb_forced_end++;\n\t\t\t\t\t\tcheck_forced_end = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (in_is_eos && !ch->eos_sent) {\n\t\t\t\t\tvoid *tfrf;\n\t\t\t\t\tconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);\n\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\n\t\t\t\t\ttfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);\n\t\t\t\t\tif (tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );\n\t\t\t\t\t\tch->last_has_tfrf = GF_TRUE;\n\t\t\t\t\t} else if (ch->last_has_tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);\n\t\t\t\t\t\tch->last_has_tfrf = GF_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (ch->last_state==GF_ISOM_INVALID_FILE) {\n\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\treturn ch->last_state;\n\t\t\t} else {\n\t\t\t\tread->force_fetch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))\n\t\t\tmin_offset_plus_one = 1 + ch->last_valid_sample_data_offset;\n\t}\n\tif (read->mem_load_mode && min_offset_plus_one) {\n\t\tisoffin_purge_mem(read, min_offset_plus_one-1);\n\t}\n\n\t//we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input\n\tif (read->pid && check_forced_end && (nb_forced_end==count)) {\n\t\t//abort input\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid);\n\t\tgf_filter_pid_send_event(read->pid, &evt);\n\t}\n\n\n\tif (!is_active) {\n\t\treturn GF_EOS;\n\t}\n\t//if (in_is_eos)\n//\tgf_filter_ask_rt_reschedule(filter, 1);\n\treturn GF_OK;\n\n}\n\nstatic const char *isoffin_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tif (gf_isom_probe_data(data, size)) {\n\t\t*score = GF_FPROBE_SUPPORTED;\n\t\treturn \"video/mp4\";\n\t}\n\treturn NULL;\n}\n\n#define OFFS(_n)\t#_n, offsetof(ISOMReader, _n)\n\nstatic const GF_FilterArgs ISOFFInArgs[] =\n{\n\t{ OFFS(src), \"location of source content (only used when explicitly loading the demuxer)\", GF_PROP_NAME, NULL, NULL, 0},\n\t{ OFFS(allt), \"load all tracks even if unknown\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noedit), \"do not use edit lists\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(itt), \"convert all items of root meta into a single PID\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(itemid), \"keep item IDs in PID properties\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(smode), \"load mode for scalable/tile tracks\\n\"\n\t\"- split: each track is declared, extractors are removed\\n\"\n\t\"- splitx: each track is declared, extractors are kept\\n\"\n\t\"- single: a single track is declared (highest level for scalable, tile base for tiling)\", GF_PROP_UINT, \"split\", \"split|splitx|single\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(alltk), \"declare all tracks even disabled ones\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(frame_size), \"frame size for raw audio samples (dispatches frame_size samples per packet)\", GF_PROP_UINT, \"1024\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(expart), \"expose cover art as a dedicated video pid\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sigfrag), \"signal fragment and segment boundaries of source on output packets\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\n\t{ OFFS(tkid), \"declare only track based on given param\\n\"\n\t\"- integer value: declares track with the given ID\\n\"\n\t\"- audio: declares first audio track\\n\"\n\t\"- video: declares first video track\\n\"\n\t\"- 4CC: declares first track with matching 4CC for handler type\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(stsd), \"only extract sample mapped to the given sample description index. 0 means no filter\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mov), \"pointer to a read/edit ISOBMF file used internally by importers and exporters\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(analyze), \"skip reformat of decoder config and SEI and dispatch all NAL in input order - shall only be used with inspect filter analyze mode!\", GF_PROP_UINT, \"off\", \"off|on|bs|full\", GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(catseg), \"append the given segment to the movie at init time (only local file supported)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(nocrypt), \"signal encrypted tracks as non encrypted (mostly used for export)\", GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(mstore_size), \"target buffer size in bytes\", GF_PROP_UINT, \"1000000\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mstore_purge), \"minimum size in bytes between memory purges when reading from memory stream (pipe etc...), 0 means purge as soon as possible\", GF_PROP_UINT, \"50000\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mstore_samples), \"minimum number of samples to be present before purging sample tables when reading from memory stream (pipe etc...), 0 means purge as soon as possible\", GF_PROP_UINT, \"50\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strtxt), \"load text tracks (apple/tx3g) as MPEG-4 streaming text tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(xps_check), \"parameter sets extraction mode from AVC/HEVC/VVC samples\\n\"\n\t\"- keep: do not inspect sample (assumes input file is compliant when generating DASH/HLS/CMAF)\\n\"\n\t\"- rem: removes all inband xPS and notify configuration changes accordingly\\n\"\n\t\"- auto: resolves to `keep` for `smode=splix` (dasher mode), `rem` otherwise\"\n\t, GF_PROP_UINT, \"auto\", \"auto|keep|rem\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(nodata), \"do not load sample data\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\nstatic const GF_FilterCapability ISOFFInCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"mp4|mpg4|m4a|m4i|3gp|3gpp|3g2|3gp2|iso|m4s|heif|heic|avci|mj2|mov|qt\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"application/x-isomedia|application/mp4|video/mp4|audio/mp4|video/3gpp|audio/3gpp|video/3gp2|audio/3gp2|video/iso.segment|audio/iso.segment|image/heif|image/heic|image/avci|video/quicktime\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_METADATA),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_ENCRYPTED),\n\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\t//also declare generic file output for embedded files (cover art & co), but explicit to skip this cap in chain resolution\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_OUTPUT | GF_CAPFLAG_LOADED_FILTER ,GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE)\n};\n\nGF_FilterRegister ISOFFInRegister = {\n\t.name = \"mp4dmx\",\n\tGF_FS_SET_DESCRIPTION(\"ISOBMFF/QT demuxer\")\n\tGF_FS_SET_HELP(\"This filter demultiplexes ISOBMF and QT files (regular or fragmented).\\n\"\n\t\t\"# Track Selection\\n\"\n\t\t\"The filter can use fragment identifiers of source to select a single track for playback. The allowed fragments are:\\n\"\n\t\t\" - #audio: only use the first audio track\\n\"\n\t\t\" - #video: only use the first video track\\n\"\n\t\t\" - #auxv: only use the first auxiliary video track\\n\"\n\t\t\" - #pict: only use the first picture track\\n\"\n\t\t\" - #text: only use the first text track\\n\"\n\t\t\" - #trackID=VAL: only use the track with given ID\\n\"\n\t\t\" - #ID=VAL: only use the track with given ID\\n\"\n\t\t\" - #VAL: only use the track with given ID\\n\"\n\t\t\"\\n\"\n\t\t\"# Scalable Tracks\\n\"\n\t\t\"When scalable tracks are present in a file, the reader can operate in 3 modes using [-smode]() option:\\n\"\\\n\t \t\"- smode=single: resolves all extractors to extract a single bitstream from a scalable set. The highest level is used\\n\"\\\n\t \t\"In this mode, there is no enhancement decoder config, only a base one resulting from the merge of the configs\\n\"\\\n\t \t\"- smode=split: all extractors are removed and every track of the scalable set is declared. In this mode, each enhancement track has no base decoder config\\n\"\n\t \t\"and an enhancement decoder config.\\n\"\\\n\t \t\"- smode=splitx: extractors are kept in the bitstream, and every track of the scalable set is declared. In this mode, each enhancement track has a base decoder config\\n\"\n\t \t\" (copied from base) and an enhancement decoder config. This is mostly used for DASHing content.\\n\"\\\n\t \t\"Warning: smode=splitx will result in extractor NAL units still present in the output bitstream, which shall only be true if the output is ISOBMFF based\\n\")\n\t.private_size = sizeof(ISOMReader),\n\t.args = ISOFFInArgs,\n\t.initialize = isoffin_initialize,\n\t.finalize = isoffin_finalize,\n\t.process = isoffin_process,\n\t.configure_pid = isoffin_configure_pid,\n\tSETCAPS(ISOFFInCaps),\n\t.process_event = isoffin_process_event,\n\t.probe_data = isoffin_probe_data\n};\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n\nconst GF_FilterRegister *isoffin_register(GF_FilterSession *session)\n{\n#ifdef GPAC_DISABLE_ISOM\n\treturn NULL;\n#else\n\treturn &ISOFFInRegister;\n#endif /*GPAC_DISABLE_ISOM*/\n}\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMFF reader filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include \"isoffin.h\"\n\n#ifndef GPAC_DISABLE_ISOM\n#include <gpac/network.h>\n#include <gpac/avparse.h>\n\n\nvoid isor_reset_reader(ISOMChannel *ch)\n{\n\tch->last_state = GF_OK;\n\tisor_reader_release_sample(ch);\n\n\tif (ch->static_sample) {\n\t\tch->static_sample->dataLength = ch->static_sample->alloc_size;\n\t\tgf_isom_sample_del(&ch->static_sample);\n\t}\n\tch->sample = NULL;\n\tch->sample_num = 0;\n\tch->speed = 1.0;\n\tch->start = ch->end = 0;\n\tch->to_init = 1;\n\tch->playing = GF_FALSE;\n\tif (ch->sai_buffer) gf_free(ch->sai_buffer);\n\tch->sai_buffer = NULL;\n\tch->sai_alloc_size = 0;\n\tch->dts = ch->cts = 0;\n\tch->seek_flag = 0;\n}\n\nvoid isor_check_producer_ref_time(ISOMReader *read)\n{\n\tGF_ISOTrackID trackID;\n\tu64 ntp;\n\tu64 timestamp;\n\n\tif (gf_sys_is_test_mode()) {\n\t\treturn;\n\t}\n\n\tif (gf_isom_get_last_producer_time_box(read->mov, &trackID, &ntp, &timestamp, GF_TRUE)) {\n#if !defined(_WIN32_WCE) && !defined(GPAC_DISABLE_LOG)\n\n\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\ttime_t secs;\n\t\t\tstruct tm t;\n\n\t\t\ts32 diff = gf_net_get_ntp_diff_ms(ntp);\n\n\t\t\tsecs = (ntp>>32) - GF_NTP_SEC_1900_TO_1970;\n\t\t\tt = *gf_gmtime(&secs);\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] TrackID %d: Timestamp \"LLU\" matches sender NTP time %d-%02d-%02dT%02d:%02d:%02dZ - NTP clock diff (local - remote): %d ms\\n\", trackID, timestamp, 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, diff));\n\t\t}\n#endif\n\t\tread->last_sender_ntp = ntp;\n\t\tread->cts_for_last_sender_ntp = timestamp;\n\t\tread->ntp_at_last_sender_ntp = gf_net_get_ntp_ts();\n\t}\n}\n\n\nstatic void init_reader(ISOMChannel *ch)\n{\n\tu32 sample_desc_index=0;\n\n\tch->au_seq_num = 1;\n\n\tassert(ch->sample==NULL);\n\tif (!ch->static_sample) {\n\t\tch->static_sample = gf_isom_sample_new();\n\t}\n\n\tif (ch->streamType==GF_STREAM_OCR) {\n\t\tassert(!ch->sample);\n\t\tch->sample = gf_isom_sample_new();\n\t\tch->sample->IsRAP = RAP;\n\t\tch->sample->DTS = ch->start;\n\t\tch->last_state=GF_OK;\n\t} else if (ch->sample_num) {\n\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\tch->disable_seek = GF_TRUE;\n\t\tch->au_seq_num = ch->sample_num;\n\t} else {\n\t\t//if seek is disabled, get the next closest sample for this time; otherwise, get the previous RAP sample for this time\n\t\tu32 mode = ch->disable_seek ? GF_ISOM_SEARCH_BACKWARD : GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t\t/*take care of seeking out of the track range*/\n\t\tif (!ch->owner->frag_type && (ch->duration<=ch->start)) {\n\t\t\tch->last_state = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->duration-1, &sample_desc_index, mode, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t} else if (ch->start || ch->has_edit_list) {\n\t\t\tch->last_state = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->start, &sample_desc_index, mode, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t} else {\n\t\t\tch->sample_num = 1;\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\tif (!ch->sample) ch->last_state = GF_EOS;\n\t\t}\n\t\tif (ch->last_state) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_OK;\n\t\t} else {\n\t\t\tch->sample = ch->static_sample;\n\t\t}\n\n\t\tif (ch->has_rap && ch->has_edit_list) {\n\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t}\n\n\t\tif (ch->sample && !ch->sample->data && ch->owner->frag_type && !ch->has_edit_list) {\n\t\t\tch->sample = NULL;\n\t\t\tch->sample_num = 1;\n\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t}\n\t}\n\n\n\t/*no sample means we're not in the track range - stop*/\n\tif (!ch->sample) {\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t} else if (ch->sample_num) {\n\t\t\tch->last_state = (ch->owner->frag_type==1) ? GF_OK : GF_EOS;\n\t\t\tch->to_init = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tch->sample_time = ch->sample->DTS;\n\n\tch->to_init = GF_FALSE;\n\n\tch->seek_flag = 0;\n\tif (ch->disable_seek) {\n\t\tch->dts = ch->sample->DTS;\n\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\tch->start = 0;\n\t} else {\n\t\ts64 cts;\n\t\tch->dts = ch->start;\n\t\tch->cts = ch->start;\n\n\t\tcts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\tif (ch->ts_offset<0)\n\t\t\tcts += ch->ts_offset;\n\n\t\t//TODO - we need to notify scene decoder how many secs elapsed between RAP and seek point\n\t\tif (ch->cts != cts) {\n\t\t\tch->seek_flag = 1;\n\t\t}\n\t}\n\tif (!sample_desc_index) sample_desc_index = 1;\n\tch->last_sample_desc_index = sample_desc_index;\n\tch->owner->no_order_check = ch->speed < 0 ? GF_TRUE : GF_FALSE;\n}\n\n\nstatic void isor_update_cenc_info(ISOMChannel *ch, Bool for_item)\n{\n\tGF_Err e;\n\tBool Is_Encrypted;\n\tu32 out_size;\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 piff_info[20];\n\tu8 *key_info = NULL;\n\tu32 key_info_size = 0;\n\tu8 item_mkey = 0;\n\n\t//this will be skipped anyways, don't fectch ...\n\tif (ch->owner->stsd && (ch->last_sample_desc_index != ch->owner->stsd) && ch->sample) {\n\t\treturn;\n\t}\n\n\n\tout_size = ch->sai_alloc_size;\n\tif (for_item) {\n\t\tu32 aux_info_param=0;\n\t\te = gf_isom_extract_meta_item_get_cenc_info(ch->owner->mov, GF_TRUE, 0, ch->item_id, &Is_Encrypted, &skip_byte_block, &crypt_byte_block, (const u8 **) &key_info, &key_info_size, &aux_info_param, &ch->sai_buffer, &out_size, &ch->sai_alloc_size);\n\n\t\t/*The ienc property is always exposed as a multiple key info in GPAC\n\t\tHowever the type of SAI may be single-key (aux_info_param==0) or multiple-key (aux_info_param==1) for the same ienc used\n\t\tWe therefore temporary force the key info type to single key if v0 SAI CENC are used\n\t\tNote that this is thread safe as this filter is the only one using the opened file\n\t\t*/\n\t\tif (aux_info_param==0) {\n\t\t\titem_mkey = key_info[0];\n\t\t}\n\t} else {\n\t\te = gf_isom_get_sample_cenc_info(ch->owner->mov, ch->track, ch->sample_num, &Is_Encrypted, &crypt_byte_block, &skip_byte_block, (const u8 **) &key_info, &key_info_size);\n\t}\n\tif (!key_info) {\n\t\tpiff_info[0] = 0;\n\t\tpiff_info[1] = 0;\n\t\tpiff_info[2] = 0;\n\t\tpiff_info[3] = key_info_size;\n\t\tmemset(piff_info + 4, 0, 16);\n\t\tkey_info_size = 20;\n\t\tkey_info = (u8 *) piff_info;\n\t}\n\n\n\tif (!for_item && (e==GF_OK) && Is_Encrypted) {\n\t\te = gf_isom_cenc_get_sample_aux_info(ch->owner->mov, ch->track, ch->sample_num, ch->last_sample_desc_index, NULL, &ch->sai_buffer, &out_size);\n\t}\n\n\tif (out_size > ch->sai_alloc_size) ch->sai_alloc_size = out_size;\n\tch->sai_buffer_size = out_size;\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch CENC auxiliary info for %s %d: %s\\n\", for_item ? \"item\" : \"track\", for_item ? ch->item_id : ch->track, gf_error_to_string(e) ));\n\t\treturn;\n\t}\n\n\tch->pck_encrypted = Is_Encrypted;\n\tch->cenc_ki = NULL;\n\n\t/*notify change of IV/KID only when packet is encrypted\n\t1- these info are ignored when packet is not encrypted\n\t2- this allows us to define the initial CENC state for multi-stsd cases*/\n\tif (Is_Encrypted) {\n\t\tu32 ki_crc;\n\n\t\tif ((ch->crypt_byte_block != crypt_byte_block) || (ch->skip_byte_block != skip_byte_block)) {\n\t\t\tch->crypt_byte_block = crypt_byte_block;\n\t\t\tch->skip_byte_block = skip_byte_block;\n\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_PATTERN, &PROP_FRAC_INT(ch->skip_byte_block, ch->crypt_byte_block) );\n\t\t}\n\t\tif (item_mkey)\n\t\t\tkey_info[0] = 0;\n\n\t\tki_crc = gf_crc_32(key_info, key_info_size);\n\t\tif (ch->key_info_crc != ki_crc) {\n\t\t\tch->key_info_crc = ki_crc;\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO, &PROP_DATA((u8 *)key_info, key_info_size) );\n\t\t}\n\n\t\tif (item_mkey)\n\t\t\tkey_info[0] = item_mkey;\n\n\t\tch->cenc_ki = gf_filter_pid_get_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO);\n\t}\n}\n\nvoid isor_reader_get_sample_from_item(ISOMChannel *ch)\n{\n\tif (ch->au_seq_num) {\n\t\tif (!ch->owner->itt || !isor_declare_item_properties(ch->owner, ch, 1+ch->au_seq_num)) {\n\t\t\tch->last_state = GF_EOS;\n\t\t\treturn;\n\t\t}\n\t}\n\tch->sample_time = 0;\n\tch->last_state = GF_OK;\n\tif (!ch->static_sample) {\n\t\tch->static_sample = gf_isom_sample_new();\n\t}\n\n\tch->sample = ch->static_sample;\n\tch->sample->IsRAP = RAP;\n\tch->au_duration = 1000;\n\tch->dts = ch->cts = 1000 * ch->au_seq_num;\n\tgf_isom_extract_meta_item_mem(ch->owner->mov, GF_TRUE, 0, ch->item_id, &ch->sample->data, &ch->sample->dataLength, &ch->static_sample->alloc_size, NULL, GF_FALSE);\n\n\tif (ch->is_encrypted && ch->is_cenc) {\n\t\tisor_update_cenc_info(ch, GF_TRUE);\n\t}\n}\n\nvoid isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tif (e == GF_OK) ch->sample = ch->static_sample;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->to_init && ch->sample_num) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\"));\n\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\tif (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n\t\t        ) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\t\t}\n\t\treturn;\n\t}\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\tch->au_duration = gf_isom_get_sample_duration(ch->owner->mov, ch->track, ch->sample_num);\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\tch->set_disc = ch->owner->clock_discontinuity ? 2 : 0;\n\tch->owner->clock_discontinuity = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->au_duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}\n\nvoid isor_reader_release_sample(ISOMChannel *ch)\n{\n\tif (ch->sample)\n\t\tch->au_seq_num++;\n\tch->sample = NULL;\n\tch->sai_buffer_size = 0;\n}\n\nstatic void isor_reset_seq_list(GF_List *list)\n{\n\twhile (gf_list_count(list)) {\n\t\tGF_NALUFFParam *sl = gf_list_pop_back(list);\n\t\tgf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n}\n\nenum\n{\n\tRESET_STATE_VPS=1,\n\tRESET_STATE_SPS=1<<1,\n\tRESET_STATE_PPS=1<<2,\n\tRESET_STATE_SPS_EXT=1<<3,\n\tRESET_STATE_DCI=1<<4,\n};\n\nstatic void isor_replace_nal(ISOMChannel *ch, u8 *data, u32 size, u8 nal_type, u32 *reset_state)\n{\n\tu32 i, count, state=0;\n\tGF_NALUFFParam *sl;\n\tGF_List *list=NULL;\n\tif (ch->avcc) {\n\t\tif (nal_type==GF_AVC_NALU_PIC_PARAM) {\n\t\t\tlist = ch->avcc->pictureParameterSets;\n\t\t\tstate=RESET_STATE_PPS;\n\t\t} else if (nal_type==GF_AVC_NALU_SEQ_PARAM) {\n\t\t\tlist = ch->avcc->sequenceParameterSets;\n\t\t\tstate=RESET_STATE_SPS;\n\t\t} else if (nal_type==GF_AVC_NALU_SEQ_PARAM_EXT) {\n\t\t\tlist = ch->avcc->sequenceParameterSetExtensions;\n\t\t\tstate=RESET_STATE_SPS_EXT;\n\t\t} else return;\n\t}\n\telse if (ch->hvcc) {\n\t\tGF_NALUFFParamArray *hvca=NULL;\n\t\tcount = gf_list_count(ch->hvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\thvca = gf_list_get(ch->hvcc->param_array, i);\n\t\t\tif (hvca->type==nal_type) {\n\t\t\t\tlist = hvca->nalus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thvca = NULL;\n\t\t}\n\t\tif (!hvca) {\n\t\t\tGF_SAFEALLOC(hvca, GF_NALUFFParamArray);\n\t\t\tif (hvca) {\n\t\t\t\tlist = hvca->nalus = gf_list_new();\n\t\t\t\thvca->type = nal_type;\n\t\t\t\tgf_list_add(ch->hvcc->param_array, hvca);\n\t\t\t}\n\t\t}\n\t\tswitch (nal_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tstate = RESET_STATE_VPS;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tstate = RESET_STATE_SPS;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tstate = RESET_STATE_PPS;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ch->vvcc) {\n\t\tGF_NALUFFParamArray *vvca=NULL;\n\t\tcount = gf_list_count(ch->vvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tvvca = gf_list_get(ch->vvcc->param_array, i);\n\t\t\tif (vvca->type==nal_type) {\n\t\t\t\tlist = vvca->nalus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvvca = NULL;\n\t\t}\n\t\tif (!vvca) {\n\t\t\tGF_SAFEALLOC(vvca, GF_NALUFFParamArray);\n\t\t\tif (vvca) {\n\t\t\t\tlist = vvca->nalus = gf_list_new();\n\t\t\t\tvvca->type = nal_type;\n\t\t\t\tgf_list_add(ch->vvcc->param_array, vvca);\n\t\t\t}\n\t\t}\n\t\tswitch (nal_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tstate = RESET_STATE_VPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tstate = RESET_STATE_SPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tstate = RESET_STATE_PPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tstate = RESET_STATE_DCI;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tch->xps_mask |= state;\n\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif ((sl->size==size) && !memcmp(sl->data, data, size)) return;\n\t}\n\tif (! (*reset_state & state))  {\n\t\tisor_reset_seq_list(list);\n\t\t*reset_state |= state;\n\t}\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char)*size);\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tgf_list_add(list, sl);\n}\n\nu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);\n\nvoid isor_sai_bytes_removed(ISOMChannel *ch, u32 pos, u32 removed)\n{\n\tu32 offset = 0;\n\tu8 *sai;\n\tu32 sai_size, cur_pos;\n\tu32 sub_count_size = 0;\n\tu32 i, subs_count = 0;\n\n\tif (!ch->cenc_ki || !ch->sai_buffer) return;\n\n\tsai = ch->sai_buffer;\n\tsai_size = ch->sai_buffer_size;\n\n\t//multikey\n\tif (ch->cenc_ki->value.data.ptr[0]) {\n\t\tu32 remain;\n\t\tu32 j, nb_iv_init = sai[0];\n\t\tnb_iv_init <<= 8;\n\t\tnb_iv_init |= sai[1];\n\t\tu8 *sai_p = sai + 2;\n\t\tremain = sai_size-2;\n\n\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\tu32 mk_iv_size;\n\t\t\tu32 idx = sai_p[0];\n\t\t\tidx<<=8;\n\t\t\tidx |= sai_p[1];\n\n\t\t\tmk_iv_size = key_info_get_iv_size(ch->cenc_ki->value.data.ptr, ch->cenc_ki->value.data.size, idx, NULL, NULL);\n\t\t\tmk_iv_size += 2; //idx\n\t\t\tif (mk_iv_size > remain) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsai_p += mk_iv_size;\n\t\t\tremain -= mk_iv_size;\n\t\t}\n\t\toffset = (u32) (sai_p - sai);\n\t\tsub_count_size = 4; //32bit sub count\n\n\t} else {\n\t\toffset = key_info_get_iv_size(ch->cenc_ki->value.data.ptr, ch->cenc_ki->value.data.size, 1, NULL, NULL);\n\t\tsub_count_size = 2; //16bit sub count\n\t}\n\n\tsai += offset;\n\tif (sub_count_size==2) {\n\t\tsubs_count = ((u32) sai[0]) << 8 | sai[1];\n\t} else {\n\t\tsubs_count = GF_4CC(sai[0], sai[1], sai[2], sai[3]);\n\t}\n\tsai += sub_count_size;\n\tsai_size -= offset + sub_count_size;\n\tcur_pos = 0;\n\tfor (i=0; i<subs_count; i++) {\n\t\tif (sai_size<6)\n\t\t\treturn;\n\t\tu32 clear = ((u32) sai[0]) << 8 | sai[1];\n\t\tu32 crypt = GF_4CC(sai[2], sai[3], sai[4], sai[5]);\n\t\tif (cur_pos + clear > pos) {\n\t\t\tclear -= removed;\n\t\t\tsai[0] = (clear>>8) & 0xFF;\n\t\t\tsai[1] = (clear) & 0xFF;\n\t\t\treturn;\n\t\t}\n\t\tcur_pos += clear + crypt;\n\t\tsai += 6;\n\t}\n}\n\nvoid isor_reader_check_config(ISOMChannel *ch)\n{\n\tu32 nalu_len, reset_state;\n\tif (!ch->check_hevc_ps && !ch->check_avc_ps && !ch->check_vvc_ps && !ch->check_mhas_pl) return;\n\n\tif (!ch->sample) return;\n\tch->xps_mask = 0;\n\n\t//we cannot touch the payload if encrypted but not CENC !!\n\tif (ch->is_encrypted && !ch->is_cenc)\n\t\treturn;\n\n\tif (ch->check_mhas_pl) {\n\t\t//we cannot touch the payload if encrypted !!\n\t\tif (ch->pck_encrypted) return;\n\t\tu64 ch_layout = 0;\n\t\ts32 PL = gf_mpegh_get_mhas_pl(ch->sample->data, ch->sample->dataLength, &ch_layout);\n\t\tif (PL>0) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROFILE_LEVEL, &PROP_UINT((u32) PL));\n\t\t\tch->check_mhas_pl = GF_FALSE;\n\t\t\tif (ch_layout)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(ch_layout));\n\t\t}\n\t\treturn;\n\t}\n\t//analyze mode, do not rewrite\n\tif (ch->owner->analyze) return;\n\n\t//we cannot touch the payload if encrypted but no SAI buffer\n\tif (ch->pck_encrypted && !ch->sai_buffer)\n\t\treturn;\n\n\tnalu_len = 4;\n\tif (ch->avcc) nalu_len = ch->avcc->nal_unit_size;\n\telse if (ch->hvcc) nalu_len = ch->hvcc->nal_unit_size;\n\telse if (ch->vvcc) nalu_len = ch->vvcc->nal_unit_size;\n\n\treset_state = 0;\n\n\tif (!ch->nal_bs) ch->nal_bs = gf_bs_new(ch->sample->data, ch->sample->dataLength, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ch->nal_bs, ch->sample->data, ch->sample->dataLength);\n\n\twhile (gf_bs_available(ch->nal_bs)) {\n\t\tBool replace_nal = GF_FALSE;\n\t\tu8 nal_type=0;\n\t\tu32 pos = (u32) gf_bs_get_position(ch->nal_bs);\n\t\tu32 size = gf_bs_read_int(ch->nal_bs, nalu_len*8);\n\t\t//this takes care of size + pos + nalu_len > 0 but (s32) size < 0 ...\n\t\tif (ch->sample->dataLength < size) break;\n\t\tif (ch->sample->dataLength < size + pos + nalu_len) break;\n\t\tif (ch->check_avc_ps) {\n\t\t\tu8 hdr = gf_bs_peek_bits(ch->nal_bs, 8, 0);\n\t\t\tnal_type = hdr & 0x1F;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch->check_hevc_ps) {\n\t\t\tu8 hdr = gf_bs_peek_bits(ch->nal_bs, 8, 0);\n\t\t\tnal_type = (hdr & 0x7E) >> 1;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch->check_vvc_ps) {\n\t\t\tu8 hdr = gf_bs_peek_bits(ch->nal_bs, 8, 1);\n\t\t\tnal_type = hdr >> 3;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(ch->nal_bs, size);\n\n\t\tif (replace_nal) {\n\t\t\tu32 move_size = ch->sample->dataLength - size - pos - nalu_len;\n\t\t\tisor_replace_nal(ch, ch->sample->data + pos + nalu_len, size, nal_type, &reset_state);\n\t\t\tif (move_size)\n\t\t\t\tmemmove(ch->sample->data + pos, ch->sample->data + pos + size + nalu_len, ch->sample->dataLength - size - pos - nalu_len);\n\n\t\t\tch->sample->dataLength -= size + nalu_len;\n\t\t\tgf_bs_reassign_buffer(ch->nal_bs, ch->sample->data, ch->sample->dataLength);\n\t\t\tgf_bs_seek(ch->nal_bs, pos);\n\n\t\t\t//remove nal from clear subsample range\n\t\t\tif (ch->pck_encrypted)\n\t\t\t\tisor_sai_bytes_removed(ch, pos, nalu_len+size);\n\t\t}\n\t}\n\n\tif (reset_state) {\n\t\tu8 *dsi=NULL;\n\t\tu32 dsi_size=0;\n\t\tif (ch->check_avc_ps) {\n\t\t\tgf_odf_avc_cfg_write(ch->avcc, &dsi, &dsi_size);\n\t\t}\n\t\telse if (ch->check_hevc_ps) {\n\t\t\tgf_odf_hevc_cfg_write(ch->hvcc, &dsi, &dsi_size);\n\t\t}\n\t\telse if (ch->check_vvc_ps) {\n\t\t\tgf_odf_vvc_cfg_write(ch->vvcc, &dsi, &dsi_size);\n\t\t}\n\t\tif (dsi && dsi_size) {\n\t\t\tu32 dsi_crc = gf_crc_32(dsi, dsi_size);\n\t\t\tif (ch->dsi_crc == dsi_crc) {\n\t\t\t\tgf_free(dsi);\n\t\t\t} else {\n\t\t\t\tch->dsi_crc = dsi_crc;\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) );\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/filters/isoffin_read.c", "src/filters/isoffin_read_ch.c"], "buggy_code_start_loc": [1455, 481], "buggy_code_end_loc": [1455, 481], "fixing_code_start_loc": [1456, 482], "fixing_code_end_loc": [1463, 486], "type": "CWE-835", "message": "GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop') vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process() can result in DoS by infinite loop. To exploit, the victim must open a specially crafted mp4 file.", "other": {"cve": {"id": "CVE-2021-40592", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-08T18:15:08.173", "lastModified": "2023-05-27T04:15:17.280", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop') vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process() can result in DoS by infinite loop. To exploit, the victim must open a specially crafted mp4 file."}, {"lang": "es", "value": "GPAC versiones anteriores al commit 71460d72ec07df766dab0a4d526829f3efcf0a (versi\u00f3n v1.0.1 en adelante) contiene una vulnerabilidad de bucle con condici\u00f3n de salida inalcanzable (\"bucle infinito\") en el filtro de lectura ISOBMFF, isoffin_read.c. La funci\u00f3n isoffin_process() puede resultar en DoS por bucle infinito. Para aprovecharla, la v\u00edctima debe abrir un archivo mp4 especialmente dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1", "matchCriteriaId": "CCA1FE1D-17AE-45F9-A7BD-A8316EE859D6"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/71460d72ec07df766dab0a4d52687529f3efcf0a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1876", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/71460d72ec07df766dab0a4d52687529f3efcf0a"}}