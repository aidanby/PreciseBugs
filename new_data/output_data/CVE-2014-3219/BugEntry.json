{"buggy_code": ["/** \\file env.c\n  Functions for setting and getting environment variables.\n*/\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <wchar.h>\n#include <string.h>\n#include <stdio.h>\n#include <locale.h>\n#include <unistd.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <pthread.h>\n#include <pwd.h>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#if HAVE_NCURSES_H\n#include <ncurses.h>\n#else\n#include <curses.h>\n#endif\n\n#if HAVE_TERM_H\n#include <term.h>\n#elif HAVE_NCURSES_TERM_H\n#include <ncurses/term.h>\n#endif\n\n#if HAVE_LIBINTL_H\n#include <libintl.h>\n#endif\n\n#include <errno.h>\n\n#include \"fallback.h\"\n#include \"util.h\"\n\n#include \"wutil.h\"\n#include \"proc.h\"\n#include \"common.h\"\n#include \"env.h\"\n#include \"sanity.h\"\n#include \"expand.h\"\n#include \"history.h\"\n#include \"reader.h\"\n#include \"parser.h\"\n#include \"env_universal.h\"\n#include \"input.h\"\n#include \"event.h\"\n#include \"path.h\"\n\n#include \"complete.h\"\n#include \"fish_version.h\"\n\n/** Command used to start fishd */\n#define FISHD_CMD L\"fishd ^ /tmp/fishd.log.%s\"\n\n// Version for easier debugging\n//#define FISHD_CMD L\"fishd\"\n\n/** Value denoting a null string */\n#define ENV_NULL L\"\\x1d\"\n\n/** Some configuration path environment variables */\n#define FISH_DATADIR_VAR L\"__fish_datadir\"\n#define FISH_SYSCONFDIR_VAR L\"__fish_sysconfdir\"\n#define FISH_HELPDIR_VAR L\"__fish_help_dir\"\n#define FISH_BIN_DIR L\"__fish_bin_dir\"\n\n/**\n   At init, we read all the environment variables from this array.\n*/\nextern char **environ;\n/**\n   This should be the same thing as \\c environ, but it is possible only one of the two work...\n*/\nextern char **__environ;\n\n\nbool g_log_forks = false;\nbool g_use_posix_spawn = false; //will usually be set to true\n\n\n/**\n   Struct representing one level in the function variable stack\n*/\nstruct env_node_t\n{\n    /**\n      Variable table\n    */\n    var_table_t env;\n    /**\n      Does this node imply a new variable scope? If yes, all\n      non-global variables below this one in the stack are\n      invisible. If new_scope is set for the global variable node,\n      the universe will explode.\n    */\n    bool new_scope;\n    /**\n       Does this node contain any variables which are exported to subshells\n    */\n    bool exportv;\n\n    /**\n      Pointer to next level\n    */\n    struct env_node_t *next;\n\n\n    env_node_t() : new_scope(false), exportv(false), next(NULL) { }\n\n    /* Returns a pointer to the given entry if present, or NULL. */\n    const var_entry_t *find_entry(const wcstring &key);\n\n    /* Returns the next scope to search in order, respecting the new_scope flag, or NULL if we're done. */\n    env_node_t *next_scope_to_search(void);\n};\n\nclass variable_entry_t\n{\n    wcstring value; /**< Value of the variable */\n};\n\nstatic pthread_mutex_t env_lock = PTHREAD_MUTEX_INITIALIZER;\n\n/** Top node on the function stack */\nstatic env_node_t *top = NULL;\n\n/** Bottom node on the function stack */\nstatic env_node_t *global_env = NULL;\n\n\n/**\n   Table for global variables\n*/\nstatic var_table_t *global;\n\n/* Helper class for storing constant strings, without needing to wrap them in a wcstring */\n\n/* Comparer for const string set */\nstruct const_string_set_comparer\n{\n    bool operator()(const wchar_t *a, const wchar_t *b)\n    {\n        return wcscmp(a, b) < 0;\n    }\n};\ntypedef std::set<const wchar_t *, const_string_set_comparer> const_string_set_t;\n\n/** Table of variables that may not be set using the set command. */\nstatic const_string_set_t env_read_only;\n\nstatic bool is_read_only(const wcstring &key)\n{\n    return env_read_only.find(key.c_str()) != env_read_only.end();\n}\n\n/**\n   Table of variables whose value is dynamically calculated, such as umask, status, etc\n*/\nstatic const_string_set_t env_electric;\n\nstatic bool is_electric(const wcstring &key)\n{\n    return env_electric.find(key.c_str()) != env_electric.end();\n}\n\n/**\n   Exported variable array used by execv\n*/\nstatic null_terminated_array_t<char> export_array;\n\n/**\n   Flag for checking if we need to regenerate the exported variable\n   array\n*/\nstatic bool has_changed_exported = true;\nstatic void mark_changed_exported()\n{\n    has_changed_exported = true;\n}\n\n/**\n   List of all locale variable names\n*/\nstatic const wchar_t * const locale_variable[] =\n{\n    L\"LANG\",\n    L\"LC_ALL\",\n    L\"LC_COLLATE\",\n    L\"LC_CTYPE\",\n    L\"LC_MESSAGES\",\n    L\"LC_MONETARY\",\n    L\"LC_NUMERIC\",\n    L\"LC_TIME\",\n    NULL\n};\n\n\nconst var_entry_t *env_node_t::find_entry(const wcstring &key)\n{\n    const var_entry_t *result = NULL;\n    var_table_t::const_iterator where = env.find(key);\n    if (where != env.end())\n    {\n        result = &where->second;\n    }\n    return result;\n}\n\nenv_node_t *env_node_t::next_scope_to_search(void)\n{\n    return this->new_scope ? global_env : this->next;\n}\n\n\n/**\n   When fishd isn't started, this function is provided to\n   env_universal as a callback, it tries to start up fishd. It's\n   implementation is a bit of a hack, since it evaluates a bit of\n   shellscript, and it might be used at times when that might not be\n   the best idea.\n*/\nstatic void start_fishd()\n{\n    struct passwd *pw = getpwuid(getuid());\n\n    debug(3, L\"Spawning new copy of fishd\");\n\n    if (!pw)\n    {\n        debug(0, _(L\"Could not get user information\"));\n        return;\n    }\n\n    wcstring cmd = format_string(FISHD_CMD, pw->pw_name);\n\n    /* Prefer the fishd in __fish_bin_dir, if exists */\n    const env_var_t bin_dir = env_get_string(L\"__fish_bin_dir\");\n    if (! bin_dir.missing_or_empty())\n    {\n        wcstring path = bin_dir + L\"/fishd\";\n        if (waccess(path, X_OK) == 0)\n        {\n            /* The path command just looks like 'fishd', so insert the bin path to make it absolute */\n            cmd.insert(0, bin_dir + L\"/\");\n        }\n    }\n    parser_t &parser = parser_t::principal_parser();\n    parser.eval(cmd, io_chain_t(), TOP);\n}\n\n/**\n   Return the current umask value.\n*/\nstatic mode_t get_umask()\n{\n    mode_t res;\n    res = umask(0);\n    umask(res);\n    return res;\n}\n\n/** Checks if the specified variable is a locale variable */\nstatic bool var_is_locale(const wcstring &key)\n{\n    for (size_t i=0; locale_variable[i]; i++)\n    {\n        if (key == locale_variable[i])\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n  Properly sets all locale information\n*/\nstatic void handle_locale()\n{\n    const env_var_t lc_all = env_get_string(L\"LC_ALL\");\n    const wcstring old_locale = wsetlocale(LC_MESSAGES, NULL);\n\n    /*\n      Array of locale constants corresponding to the local variable names defined in locale_variable\n    */\n    static const int cat[] =\n    {\n        0,\n        LC_ALL,\n        LC_COLLATE,\n        LC_CTYPE,\n        LC_MESSAGES,\n        LC_MONETARY,\n        LC_NUMERIC,\n        LC_TIME\n    }\n    ;\n\n    if (!lc_all.missing())\n    {\n        wsetlocale(LC_ALL, lc_all.c_str());\n    }\n    else\n    {\n        const env_var_t lang = env_get_string(L\"LANG\");\n        if (!lang.missing())\n        {\n            wsetlocale(LC_ALL, lang.c_str());\n        }\n\n        for (int i=2; locale_variable[i]; i++)\n        {\n            const env_var_t val = env_get_string(locale_variable[i]);\n\n            if (!val.missing())\n            {\n                wsetlocale(cat[i], val.c_str());\n            }\n        }\n    }\n\n    const wcstring new_locale = wsetlocale(LC_MESSAGES, NULL);\n    if (old_locale != new_locale)\n    {\n\n        /*\n           Try to make change known to gettext. Both changing\n           _nl_msg_cat_cntr and calling dcgettext might potentially\n           tell some gettext implementation that the translation\n           strings should be reloaded. We do both and hope for the\n           best.\n        */\n\n        extern int _nl_msg_cat_cntr;\n        _nl_msg_cat_cntr++;\n\n        fish_dcgettext(\"fish\", \"Changing language to English\", LC_MESSAGES);\n\n        if (get_is_interactive())\n        {\n            debug(0, _(L\"Changing language to English\"));\n        }\n    }\n}\n\n\n/** React to modifying hte given variable */\nstatic void react_to_variable_change(const wcstring &key)\n{\n    if (var_is_locale(key))\n    {\n        handle_locale();\n    }\n    else if (key == L\"fish_term256\")\n    {\n        update_fish_term256();\n        reader_react_to_color_change();\n    }\n    else if (string_prefixes_string(L\"fish_color_\", key))\n    {\n        reader_react_to_color_change();\n    }\n}\n\n/**\n   Universal variable callback function. This function makes sure the\n   proper events are triggered when an event occurs.\n*/\nstatic void universal_callback(fish_message_type_t type,\n                               const wchar_t *name,\n                               const wchar_t *val)\n{\n    const wchar_t *str = NULL;\n\n    switch (type)\n    {\n        case SET:\n        case SET_EXPORT:\n        {\n            str=L\"SET\";\n            break;\n        }\n\n        case ERASE:\n        {\n            str=L\"ERASE\";\n            break;\n        }\n\n        default:\n            break;\n    }\n\n    if (str)\n    {\n        mark_changed_exported();\n\n        event_t ev = event_t::variable_event(name);\n        ev.arguments.push_back(L\"VARIABLE\");\n        ev.arguments.push_back(str);\n        ev.arguments.push_back(name);\n        event_fire(&ev);\n    }\n\n    if (name)\n        react_to_variable_change(name);\n}\n\n/**\n   Make sure the PATH variable contains something\n*/\nstatic void setup_path()\n{\n    const env_var_t path = env_get_string(L\"PATH\");\n    if (path.missing_or_empty())\n    {\n        const wchar_t *value = L\"/usr/bin\" ARRAY_SEP_STR L\"/bin\";\n        env_set(L\"PATH\", value, ENV_GLOBAL | ENV_EXPORT);\n    }\n}\n\nint env_set_pwd()\n{\n    wchar_t dir_path[4096];\n    wchar_t *res = wgetcwd(dir_path, 4096);\n    if (!res)\n    {\n        return 0;\n    }\n    env_set(L\"PWD\", dir_path, ENV_EXPORT | ENV_GLOBAL);\n    return 1;\n}\n\nwcstring env_get_pwd_slash(void)\n{\n    env_var_t pwd = env_get_string(L\"PWD\");\n    if (pwd.missing_or_empty())\n    {\n        return L\"\";\n    }\n    if (! string_suffixes_string(L\"/\", pwd))\n    {\n        pwd.push_back(L'/');\n    }\n    return pwd;\n}\n\n/**\n   Set up default values for various variables if not defined.\n */\nstatic void env_set_defaults()\n{\n\n    if (env_get_string(L\"USER\").missing())\n    {\n        struct passwd *pw = getpwuid(getuid());\n        if (pw->pw_name != NULL)\n        {\n            const wcstring wide_name = str2wcstring(pw->pw_name);\n            env_set(L\"USER\", wide_name.c_str(), ENV_GLOBAL);\n        }\n    }\n\n    if (env_get_string(L\"HOME\").missing())\n    {\n        const env_var_t unam = env_get_string(L\"USER\");\n        char *unam_narrow = wcs2str(unam.c_str());\n        struct passwd *pw = getpwnam(unam_narrow);\n        if (pw->pw_dir != NULL)\n        {\n            const wcstring dir = str2wcstring(pw->pw_dir);\n            env_set(L\"HOME\", dir.c_str(), ENV_GLOBAL);\n        }\n        free(unam_narrow);\n    }\n\n    env_set_pwd();\n\n}\n\n// Some variables should not be arrays. This used to be handled by a startup script, but we'd like to get down to 0 forks for startup, so handle it here.\nstatic bool variable_can_be_array(const wcstring &key)\n{\n    if (key == L\"DISPLAY\")\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nvoid env_init(const struct config_paths_t *paths /* or NULL */)\n{\n    /*\n      env_read_only variables can not be altered directly by the user\n    */\n\n    const wchar_t * const ro_keys[] =\n    {\n        L\"status\",\n        L\"history\",\n        L\"version\",\n        L\"_\",\n        L\"LINES\",\n        L\"COLUMNS\",\n        L\"PWD\",\n        L\"SHLVL\",\n        L\"FISH_VERSION\",\n    };\n    for (size_t i=0; i < sizeof ro_keys / sizeof *ro_keys; i++)\n    {\n        env_read_only.insert(ro_keys[i]);\n    }\n\n    /*\n      HOME and USER should be writeable by root, since this can be a\n      convenient way to install software.\n    */\n    if (getuid() != 0)\n    {\n        env_read_only.insert(L\"HOME\");\n        env_read_only.insert(L\"USER\");\n    }\n\n    /*\n       Names of all dynamically calculated variables\n       */\n    env_electric.insert(L\"history\");\n    env_electric.insert(L\"status\");\n    env_electric.insert(L\"umask\");\n\n    top = new env_node_t;\n    global_env = top;\n    global = &top->env;\n\n    /*\n      Now the environemnt variable handling is set up, the next step\n      is to insert valid data\n    */\n\n    /*\n      Import environment variables\n    */\n    for (char **p = (environ ? environ : __environ); p && *p; p++)\n    {\n        const wcstring key_and_val = str2wcstring(*p); //like foo=bar\n        size_t eql = key_and_val.find(L'=');\n        if (eql == wcstring::npos)\n        {\n            // no equals found\n            env_set(key_and_val, L\"\", ENV_EXPORT);\n        }\n        else\n        {\n            wcstring key = key_and_val.substr(0, eql);\n            wcstring val = key_and_val.substr(eql + 1);\n            if (variable_can_be_array(val))\n            {\n                std::replace(val.begin(), val.end(), L':', ARRAY_SEP);\n            }\n\n            env_set(key, val.c_str(), ENV_EXPORT | ENV_GLOBAL);\n        }\n    }\n\n    /* Set the given paths in the environment, if we have any */\n    if (paths != NULL)\n    {\n        env_set(FISH_DATADIR_VAR, paths->data.c_str(), ENV_GLOBAL | ENV_EXPORT);\n        env_set(FISH_SYSCONFDIR_VAR, paths->sysconf.c_str(), ENV_GLOBAL | ENV_EXPORT);\n        env_set(FISH_HELPDIR_VAR, paths->doc.c_str(), ENV_GLOBAL | ENV_EXPORT);\n        env_set(FISH_BIN_DIR, paths->bin.c_str(), ENV_GLOBAL | ENV_EXPORT);\n    }\n\n    /*\n      Set up the PATH variable\n    */\n    setup_path();\n\n    /*\n      Set up the USER variable\n    */\n    const struct passwd *pw = getpwuid(getuid());\n    if (pw && pw->pw_name)\n    {\n        const wcstring uname = str2wcstring(pw->pw_name);\n        env_set(L\"USER\", uname.c_str(), ENV_GLOBAL | ENV_EXPORT);\n    }\n\n    /*\n      Set up the version variables\n    */\n    wcstring version = str2wcstring(get_fish_version());\n    env_set(L\"version\", version.c_str(), ENV_GLOBAL);\n    env_set(L\"FISH_VERSION\", version.c_str(), ENV_GLOBAL);\n\n    const env_var_t fishd_dir_wstr = env_get_string(L\"FISHD_SOCKET_DIR\");\n    const env_var_t user_dir_wstr = env_get_string(L\"USER\");\n\n    wchar_t * fishd_dir = fishd_dir_wstr.missing()?NULL:const_cast<wchar_t*>(fishd_dir_wstr.c_str());\n    wchar_t * user_dir = user_dir_wstr.missing()?NULL:const_cast<wchar_t*>(user_dir_wstr.c_str());\n\n    env_universal_init(fishd_dir , user_dir ,\n                       &start_fishd,\n                       &universal_callback);\n\n    /*\n      Set up SHLVL variable\n    */\n    const env_var_t shlvl_str = env_get_string(L\"SHLVL\");\n    wcstring nshlvl_str = L\"1\";\n    if (! shlvl_str.missing())\n    {\n        long shlvl_i = wcstol(shlvl_str.c_str(), NULL, 10);\n        if (shlvl_i >= 0)\n        {\n            nshlvl_str = to_string<long>(shlvl_i + 1);\n        }\n    }\n    env_set(L\"SHLVL\", nshlvl_str.c_str(), ENV_GLOBAL | ENV_EXPORT);\n\n    /* Set correct defaults for e.g. USER and HOME variables */\n    env_set_defaults();\n\n    /* Set g_log_forks */\n    env_var_t log_forks = env_get_string(L\"fish_log_forks\");\n    g_log_forks = ! log_forks.missing_or_empty() && from_string<bool>(log_forks);\n\n    /* Set g_use_posix_spawn. Default to true. */\n    env_var_t use_posix_spawn = env_get_string(L\"fish_use_posix_spawn\");\n    g_use_posix_spawn = (use_posix_spawn.missing_or_empty() ? true : from_string<bool>(use_posix_spawn));\n\n    /* Set fish_bind_mode to \"default\" */\n    env_set(FISH_BIND_MODE_VAR, DEFAULT_BIND_MODE, ENV_GLOBAL);\n}\n\nvoid env_destroy()\n{\n    env_universal_destroy();\n\n    while (&top->env != global)\n    {\n        env_pop();\n    }\n\n    env_read_only.clear();\n    env_electric.clear();\n\n    var_table_t::iterator iter;\n    for (iter = global->begin(); iter != global->end(); ++iter)\n    {\n        const var_entry_t &entry = iter->second;\n        if (entry.exportv)\n        {\n            mark_changed_exported();\n            break;\n        }\n    }\n\n    delete top;\n}\n\n/**\n   Search all visible scopes in order for the specified key. Return\n   the first scope in which it was found.\n*/\nstatic env_node_t *env_get_node(const wcstring &key)\n{\n    env_node_t *env = top;\n    while (env != NULL)\n    {\n        if (env->find_entry(key) != NULL)\n        {\n            break;\n        }\n\n        env = env->next_scope_to_search();\n    }\n    return env;\n}\n\nint env_set(const wcstring &key, const wchar_t *val, int var_mode)\n{\n    ASSERT_IS_MAIN_THREAD();\n    bool has_changed_old = has_changed_exported;\n    bool has_changed_new = false;\n    int done=0;\n\n    int is_universal = 0;\n\n    if (val && contains(key, L\"PWD\", L\"HOME\"))\n    {\n        /* Canoncalize our path; if it changes, recurse and try again. */\n        wcstring val_canonical = val;\n        path_make_canonical(val_canonical);\n        if (val != val_canonical)\n        {\n            return env_set(key, val_canonical.c_str(), var_mode);\n        }\n    }\n\n    if ((var_mode & ENV_USER) && is_read_only(key))\n    {\n        return ENV_PERM;\n    }\n\n    if (key == L\"umask\")\n    {\n        wchar_t *end;\n\n        /*\n         Set the new umask\n         */\n        if (val && wcslen(val))\n        {\n            errno=0;\n            long mask = wcstol(val, &end, 8);\n\n            if (!errno && (!*end) && (mask <= 0777) && (mask >= 0))\n            {\n                umask(mask);\n            }\n        }\n        /* Do not actually create a umask variable, on env_get, it will be calculated dynamically */\n        return 0;\n    }\n\n    /*\n     Zero element arrays are internaly not coded as null but as this\n     placeholder string\n     */\n    if (!val)\n    {\n        val = ENV_NULL;\n    }\n\n    if (var_mode & ENV_UNIVERSAL)\n    {\n        bool exportv;\n        if (var_mode & ENV_EXPORT)\n        {\n            // export\n            exportv = true;\n        }\n        else if (var_mode & ENV_UNEXPORT)\n        {\n            // unexport\n            exportv = false;\n        }\n        else\n        {\n            // not changing the export\n            exportv = env_universal_get_export(key);\n        }\n        env_universal_set(key, val, exportv);\n        is_universal = 1;\n\n    }\n    else\n    {\n        // Determine the node\n\n        env_node_t *preexisting_node = env_get_node(key);\n        bool preexisting_entry_exportv = false;\n        if (preexisting_node != NULL)\n        {\n            var_table_t::const_iterator result = preexisting_node->env.find(key);\n            assert(result != preexisting_node->env.end());\n            const var_entry_t &entry = result->second;\n            if (entry.exportv)\n            {\n                preexisting_entry_exportv = true;\n                has_changed_new = true;\n            }\n        }\n\n        env_node_t *node = NULL;\n        if (var_mode & ENV_GLOBAL)\n        {\n            node = global_env;\n        }\n        else if (var_mode & ENV_LOCAL)\n        {\n            node = top;\n        }\n        else if (preexisting_node != NULL)\n        {\n            node = preexisting_node;\n\n            if ((var_mode & (ENV_EXPORT | ENV_UNEXPORT)) == 0)\n            {\n                // use existing entry's exportv\n                var_mode = preexisting_entry_exportv ? ENV_EXPORT : 0;\n            }\n        }\n        else\n        {\n            if (! get_proc_had_barrier())\n            {\n                set_proc_had_barrier(true);\n                env_universal_barrier();\n            }\n\n            if (! env_universal_get(key).missing())\n            {\n                bool exportv;\n                if (var_mode & ENV_EXPORT)\n                {\n                    exportv = true;\n                }\n                else if (var_mode & ENV_UNEXPORT)\n                {\n                    exportv = false;\n                }\n                else\n                {\n                    exportv = env_universal_get_export(key);\n                }\n\n                env_universal_set(key, val, exportv);\n                is_universal = 1;\n\n                done = 1;\n\n            }\n            else\n            {\n                /*\n                 New variable with unspecified scope. The default\n                 scope is the innermost scope that is shadowing,\n                 which will be either the current function or the\n                 global scope.\n                 */\n                node = top;\n                while (node->next && !node->new_scope)\n                {\n                    node = node->next;\n                }\n            }\n        }\n\n        if (!done)\n        {\n            // Set the entry in the node\n            // Note that operator[] accesses the existing entry, or creates a new one\n            var_entry_t &entry = node->env[key];\n            if (entry.exportv)\n            {\n                // this variable already existed, and was exported\n                has_changed_new = true;\n            }\n            entry.val = val;\n            if (var_mode & ENV_EXPORT)\n            {\n                // the new variable is exported\n                entry.exportv = true;\n                node->exportv = true;\n                has_changed_new = true;\n            }\n            else\n            {\n                entry.exportv = false;\n            }\n\n            if (has_changed_old || has_changed_new)\n                mark_changed_exported();\n        }\n\n    }\n\n    if (!is_universal)\n    {\n        event_t ev = event_t::variable_event(key);\n        ev.arguments.reserve(3);\n        ev.arguments.push_back(L\"VARIABLE\");\n        ev.arguments.push_back(L\"SET\");\n        ev.arguments.push_back(key);\n\n        //  debug( 1, L\"env_set: fire events on variable %ls\", key );\n        event_fire(&ev);\n        //  debug( 1, L\"env_set: return from event firing\" );\n    }\n\n    react_to_variable_change(key);\n\n    return 0;\n}\n\n\n/**\n   Attempt to remove/free the specified key/value pair from the\n   specified map.\n\n   \\return zero if the variable was not found, non-zero otherwise\n*/\nstatic bool try_remove(env_node_t *n, const wchar_t *key, int var_mode)\n{\n    if (n == NULL)\n    {\n        return false;\n    }\n\n    var_table_t::iterator result = n->env.find(key);\n    if (result != n->env.end())\n    {\n        if (result->second.exportv)\n        {\n            mark_changed_exported();\n        }\n        n->env.erase(result);\n        return true;\n    }\n\n    if (var_mode & ENV_LOCAL)\n    {\n        return false;\n    }\n\n    if (n->new_scope)\n    {\n        return try_remove(global_env, key, var_mode);\n    }\n    else\n    {\n        return try_remove(n->next, key, var_mode);\n    }\n}\n\n\nint env_remove(const wcstring &key, int var_mode)\n{\n    ASSERT_IS_MAIN_THREAD();\n    env_node_t *first_node;\n    int erased = 0;\n\n    if ((var_mode & ENV_USER) && is_read_only(key))\n    {\n        return 2;\n    }\n\n    first_node = top;\n\n    if (!(var_mode & ENV_UNIVERSAL))\n    {\n\n        if (var_mode & ENV_GLOBAL)\n        {\n            first_node = global_env;\n        }\n\n        if (try_remove(first_node, key.c_str(), var_mode))\n        {\n            event_t ev = event_t::variable_event(key);\n            ev.arguments.push_back(L\"VARIABLE\");\n            ev.arguments.push_back(L\"ERASE\");\n            ev.arguments.push_back(key);\n\n            event_fire(&ev);\n\n            erased = 1;\n        }\n    }\n\n    if (!erased &&\n            !(var_mode & ENV_GLOBAL) &&\n            !(var_mode & ENV_LOCAL))\n    {\n        erased = ! env_universal_remove(key.c_str());\n    }\n\n    react_to_variable_change(key);\n\n    return !erased;\n}\n\nconst wchar_t *env_var_t::c_str(void) const\n{\n    assert(! is_missing);\n    return wcstring::c_str();\n}\n\nenv_var_t env_get_string(const wcstring &key)\n{\n    /* Big hack...we only allow getting the history on the main thread. Note that history_t may ask for an environment variable, so don't take the lock here (we don't need it) */\n    const bool is_main = is_main_thread();\n    if (key == L\"history\" && is_main)\n    {\n        env_var_t result;\n\n        history_t *history = reader_get_history();\n        if (! history)\n        {\n            history = &history_t::history_with_name(L\"fish\");\n        }\n        if (history)\n            history->get_string_representation(result, ARRAY_SEP_STR);\n        return result;\n    }\n    else if (key == L\"COLUMNS\")\n    {\n        return to_string(common_get_width());\n    }\n    else if (key == L\"LINES\")\n    {\n        return to_string(common_get_height());\n    }\n    else if (key == L\"status\")\n    {\n        return to_string(proc_get_last_status());\n    }\n    else if (key == L\"umask\")\n    {\n        return format_string(L\"0%0.3o\", get_umask());\n    }\n    else\n    {\n        {\n            /* Lock around a local region */\n            scoped_lock lock(env_lock);\n\n            env_node_t *env = top;\n            wcstring result;\n\n            while (env != NULL)\n            {\n                const var_entry_t *entry = env->find_entry(key);\n                if (entry != NULL)\n                {\n                    if (entry->val == ENV_NULL)\n                    {\n                        return env_var_t::missing_var();\n                    }\n                    else\n                    {\n                        return entry->val;\n                    }\n                }\n\n                env = env->next_scope_to_search();\n            }\n        }\n\n        /* Another big hack - only do a universal barrier on the main thread (since it can change variable values)\n           Make sure we do this outside the env_lock because it may itself call env_get_string */\n        if (is_main && ! get_proc_had_barrier())\n        {\n            set_proc_had_barrier(true);\n            env_universal_barrier();\n        }\n\n        env_var_t item = env_universal_get(key);\n\n        if (item.missing() || (wcscmp(item.c_str(), ENV_NULL)==0))\n        {\n            return env_var_t::missing_var();\n        }\n        else\n        {\n            return item;\n        }\n    }\n}\n\nbool env_exist(const wchar_t *key, int mode)\n{\n    env_node_t *env;\n\n    CHECK(key, false);\n\n    /*\n      Read only variables all exist, and they are all global. A local\n      version can not exist.\n    */\n    if (!(mode & ENV_LOCAL) && !(mode & ENV_UNIVERSAL))\n    {\n        if (is_read_only(key) || is_electric(key))\n        {\n            //Such variables are never exported\n            if (mode & ENV_EXPORT)\n            {\n                return false;\n            }\n            else if (mode & ENV_UNEXPORT)\n            {\n                return true;\n            }\n            return true;\n        }\n    }\n\n    if (!(mode & ENV_UNIVERSAL))\n    {\n        env = (mode & ENV_GLOBAL)?global_env:top;\n\n        while (env != 0)\n        {\n            var_table_t::iterator result = env->env.find(key);\n\n            if (result != env->env.end())\n            {\n                const var_entry_t &res = result->second;\n\n                if (mode & ENV_EXPORT)\n                {\n                    return res.exportv;\n                }\n                else if (mode & ENV_UNEXPORT)\n                {\n                    return ! res.exportv;\n                }\n\n                return true;\n            }\n\n            if (mode & ENV_LOCAL)\n                break;\n\n            env = env->next_scope_to_search();\n        }\n    }\n\n    if (!(mode & ENV_LOCAL) && !(mode & ENV_GLOBAL))\n    {\n        if (! get_proc_had_barrier())\n        {\n            set_proc_had_barrier(true);\n            env_universal_barrier();\n        }\n\n        if (! env_universal_get(key).missing())\n        {\n            if (mode & ENV_EXPORT)\n            {\n                return env_universal_get_export(key) == 1;\n            }\n            else if (mode & ENV_UNEXPORT)\n            {\n                return env_universal_get_export(key) == 0;\n            }\n\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n   Returns true if the specified scope or any non-shadowed non-global subscopes contain an exported variable.\n*/\nstatic int local_scope_exports(env_node_t *n)\n{\n\n    if (n==global_env)\n        return 0;\n\n    if (n->exportv)\n        return 1;\n\n    if (n->new_scope)\n        return 0;\n\n    return local_scope_exports(n->next);\n}\n\nvoid env_push(bool new_scope)\n{\n    env_node_t *node = new env_node_t;\n    node->next = top;\n    node->new_scope=new_scope;\n\n    if (new_scope)\n    {\n        if (local_scope_exports(top))\n            mark_changed_exported();\n    }\n    top = node;\n\n}\n\n\nvoid env_pop()\n{\n    if (&top->env != global)\n    {\n        int i;\n        int locale_changed = 0;\n\n        env_node_t *killme = top;\n\n        for (i=0; locale_variable[i]; i++)\n        {\n            var_table_t::iterator result =  killme->env.find(locale_variable[i]);\n            if (result != killme->env.end())\n            {\n                locale_changed = 1;\n                break;\n            }\n        }\n\n        if (killme->new_scope)\n        {\n            if (killme->exportv || local_scope_exports(killme->next))\n                mark_changed_exported();\n        }\n\n        top = top->next;\n\n        var_table_t::iterator iter;\n        for (iter = killme->env.begin(); iter != killme->env.end(); ++iter)\n        {\n            const var_entry_t &entry = iter->second;\n            if (entry.exportv)\n            {\n                mark_changed_exported();\n                break;\n            }\n        }\n\n        delete killme;\n\n        if (locale_changed)\n            handle_locale();\n\n    }\n    else\n    {\n        debug(0,\n              _(L\"Tried to pop empty environment stack.\"));\n        sanity_lose();\n    }\n}\n\n/**\n   Function used with to insert keys of one table into a set::set<wcstring>\n*/\nstatic void add_key_to_string_set(const var_table_t &envs, std::set<wcstring> *str_set, bool show_exported, bool show_unexported)\n{\n    var_table_t::const_iterator iter;\n    for (iter = envs.begin(); iter != envs.end(); ++iter)\n    {\n        const var_entry_t &e = iter->second;\n\n        if ((e.exportv && show_exported) ||\n                (!e.exportv && show_unexported))\n        {\n            /* Insert this key */\n            str_set->insert(iter->first);\n        }\n\n    }\n}\n\nwcstring_list_t env_get_names(int flags)\n{\n    scoped_lock lock(env_lock);\n\n    wcstring_list_t result;\n    std::set<wcstring> names;\n    int show_local = flags & ENV_LOCAL;\n    int show_global = flags & ENV_GLOBAL;\n    int show_universal = flags & ENV_UNIVERSAL;\n\n    env_node_t *n=top;\n    const bool show_exported = (flags & ENV_EXPORT) || !(flags & ENV_UNEXPORT);\n    const bool show_unexported = (flags & ENV_UNEXPORT) || !(flags & ENV_EXPORT);\n\n    if (!show_local && !show_global && !show_universal)\n    {\n        show_local =show_universal = show_global=1;\n    }\n\n    if (show_local)\n    {\n        while (n)\n        {\n            if (n == global_env)\n                break;\n\n            add_key_to_string_set(n->env, &names, show_exported, show_unexported);\n            if (n->new_scope)\n                break;\n            else\n                n = n->next;\n\n        }\n    }\n\n    if (show_global)\n    {\n        add_key_to_string_set(global_env->env, &names, show_exported, show_unexported);\n        if (show_unexported)\n        {\n            result.insert(result.end(), env_electric.begin(), env_electric.end());\n        }\n\n        if (show_exported)\n        {\n            result.push_back(L\"COLUMNS\");\n            result.push_back(L\"LINES\");\n        }\n\n    }\n\n    if (show_universal)\n    {\n\n        wcstring_list_t uni_list;\n        env_universal_get_names(uni_list,\n                                show_exported,\n                                show_unexported);\n        names.insert(uni_list.begin(), uni_list.end());\n    }\n\n    result.insert(result.end(), names.begin(), names.end());\n    return result;\n}\n\n/**\n  Get list of all exported variables\n*/\n\nstatic void get_exported(const env_node_t *n, std::map<wcstring, wcstring> &h)\n{\n    if (!n)\n        return;\n\n    if (n->new_scope)\n        get_exported(global_env, h);\n    else\n        get_exported(n->next, h);\n\n    var_table_t::const_iterator iter;\n    for (iter = n->env.begin(); iter != n->env.end(); ++iter)\n    {\n        const wcstring &key = iter->first;\n        const var_entry_t &val_entry = iter->second;\n        if (val_entry.exportv && (val_entry.val != ENV_NULL))\n        {\n            // Don't use std::map::insert here, since we need to overwrite existing values from previous scopes\n            h[key] = val_entry.val;\n        }\n    }\n}\n\nstatic void export_func(const std::map<wcstring, wcstring> &envs, std::vector<std::string> &out)\n{\n    std::map<wcstring, wcstring>::const_iterator iter;\n    for (iter = envs.begin(); iter != envs.end(); ++iter)\n    {\n        const std::string ks = wcs2string(iter->first);\n        std::string vs = wcs2string(iter->second);\n\n        for (size_t i=0; i < vs.size(); i++)\n        {\n            char &vc = vs.at(i);\n            if (vc == ARRAY_SEP)\n                vc = ':';\n        }\n\n        /* Put a string on the vector */\n        out.push_back(std::string());\n        std::string &str = out.back();\n        str.reserve(ks.size() + 1 + vs.size());\n\n        /* Append our environment variable data to it */\n        str.append(ks);\n        str.append(\"=\");\n        str.append(vs);\n    }\n}\n\nstatic void update_export_array_if_necessary(bool recalc)\n{\n    ASSERT_IS_MAIN_THREAD();\n    if (recalc && ! get_proc_had_barrier())\n    {\n        set_proc_had_barrier(true);\n        env_universal_barrier();\n    }\n\n    if (has_changed_exported)\n    {\n        std::map<wcstring, wcstring> vals;\n        size_t i;\n\n        debug(4, L\"env_export_arr() recalc\");\n\n        get_exported(top, vals);\n\n        wcstring_list_t uni;\n        env_universal_get_names(uni, 1, 0);\n        for (i=0; i<uni.size(); i++)\n        {\n            const wcstring &key = uni.at(i);\n            const env_var_t val = env_universal_get(key);\n\n            if (! val.missing() && wcscmp(val.c_str(), ENV_NULL))\n            {\n                // Note that std::map::insert does NOT overwrite a value already in the map,\n                // which we depend on here\n                vals.insert(std::pair<wcstring, wcstring>(key, val));\n            }\n        }\n\n        std::vector<std::string> local_export_buffer;\n        export_func(vals, local_export_buffer);\n        export_array.set(local_export_buffer);\n        has_changed_exported=false;\n    }\n\n}\n\nconst char * const *env_export_arr(bool recalc)\n{\n    ASSERT_IS_MAIN_THREAD();\n    update_export_array_if_necessary(recalc);\n    return export_array.get();\n}\n\nenv_vars_snapshot_t::env_vars_snapshot_t(const wchar_t * const *keys)\n{\n    ASSERT_IS_MAIN_THREAD();\n    wcstring key;\n    for (size_t i=0; keys[i]; i++)\n    {\n        key.assign(keys[i]);\n        const env_var_t val = env_get_string(key);\n        if (! val.missing())\n        {\n            vars[key] = val;\n        }\n    }\n}\n\nenv_vars_snapshot_t::env_vars_snapshot_t() { }\n\n/* The \"current\" variables are not a snapshot at all, but instead trampoline to env_get_string, etc. We identify the current snapshot based on pointer values. */\nstatic const env_vars_snapshot_t sCurrentSnapshot;\nconst env_vars_snapshot_t &env_vars_snapshot_t::current()\n{\n    return sCurrentSnapshot;\n}\n\nbool env_vars_snapshot_t::is_current() const\n{\n    return this == &sCurrentSnapshot;\n}\n\nenv_var_t env_vars_snapshot_t::get(const wcstring &key) const\n{\n    /* If we represent the current state, bounce to env_get_string */\n    if (this->is_current())\n    {\n        return env_get_string(key);\n    }\n    else\n    {\n        std::map<wcstring, wcstring>::const_iterator iter = vars.find(key);\n        return (iter == vars.end() ? env_var_t::missing_var() : env_var_t(iter->second));\n    }\n}\n\nconst wchar_t * const env_vars_snapshot_t::highlighting_keys[] = {L\"PATH\", L\"CDPATH\", L\"fish_function_path\", NULL};\n", "\nfunction __fish_print_packages\n\n\t# apt-cache is much, much faster than rpm, and can do this in real\n\t# time. We use it if available.\n\n\tswitch (commandline -tc)\n\t\tcase '-**'\n\t\t\treturn\n\tend\n\n\t#Get the word 'Package' in the current language\n\tset -l package (_ Package)\n\n\tif type -f apt-cache >/dev/null\n\t\t# Do not generate the cache as apparently sometimes this is slow.\n\t\t# http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=547550\n\t\tapt-cache --no-generate pkgnames (commandline -tc) ^/dev/null | sed -e 's/$/'\\t$package'/'\n\t\treturn\n\tend\n\n\t# Pkg is fast on FreeBSD and provides versioning info which we want for\n\t# installed packages\n\tif \tbegin\n\t\t\ttype -f pkg > /dev/null\n\t\t\tand test (uname) = \"FreeBSD\"\n\t\tend\n\t\tpkg query \"%n-%v\"\n\t\treturn\n\tend\n\n    # Caches for 5 minutes\n\tif type -f pacman >/dev/null\n\t\tset cache_file /tmp/.pac-cache.$USER\n\t\tif test -f $cache_file\n\t\t\tcat $cache_file\n\t\t\tset age (math (date +%s) - (stat -c '%Y' $cache_file))\n\t\t\tset max_age 250\n\t\t\tif test $age -lt $max_age\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\n\t\t# prints: <package name>\tPackage\n\t\tpacman -Ssq | sed -e 's/$/\\t'$package'/' >$cache_file &\n\t\treturn\n\tend\n\n\t# yum is slow, just like rpm, so go to the background\n\tif type -f /usr/share/yum-cli/completion-helper.py >/dev/null\n\n\t\t# If the cache is less than six hours old, we do not recalculate it\n\n\t\tset cache_file /tmp/.yum-cache.$USER\n\t\t\tif test -f $cache_file\n\t\t\tcat $cache_file\n\t\t\tset age (math (date +%s) - (stat -c '%Y' $cache_file))\n\t\t\tset max_age 21600\n\t\t\tif test $age -lt $max_age\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\n\t\t# Remove package version information from output and pipe into cache file\n\t\t/usr/share/yum-cli/completion-helper.py list all -d 0 -C | sed \"s/\\..*/\\t$package/\" >$cache_file &\n\t\treturn\n\tend\n\n\t# Rpm is too slow for this job, so we set it up to do completions\n\t# as a background job and cache the results.\n\n\tif type -f rpm >/dev/null\n\n\t\t# If the cache is less than five minutes old, we do not recalculate it\n\n\t\tset cache_file /tmp/.rpm-cache.$USER\n\t\t\tif test -f $cache_file\n\t\t\tcat $cache_file\n\t\t\tset age (math (date +%s) - (stat -c '%Y' $cache_file))\n\t\t\tset max_age 250\n\t\t\tif test $age -lt $max_age\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\n\t\t# Remove package version information from output and pipe into cache file\n\t\trpm -qa |sed -e 's/-[^-]*-[^-]*$/\\t'$package'/' >$cache_file &\n\t\treturn\n\tend\n\n\t# This completes the package name from the portage tree.\n\t# True for installing new packages. Function for printing\n\t# installed on the system packages is in completions/emerge.fish\n\n\t# eix is MUCH faster than emerge so use it if it is available\n\tif type -f eix > /dev/null\n\t\teix --only-names \"^\"(commandline -tc) | cut -d/ -f2\n\t\treturn\n\telse\n\t\t# FIXME?  Seems to be broken\n\t\tif type -f emerge >/dev/null\n\t\t\temerge -s \\^(commandline -tc) |sgrep \"^*\" |cut -d\\  -f3 |cut -d/ -f2\n\t\t\treturn\n\t\tend\n\tend\n\nend\n\n"], "fixing_code": ["/** \\file env.c\n  Functions for setting and getting environment variables.\n*/\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <wchar.h>\n#include <string.h>\n#include <stdio.h>\n#include <locale.h>\n#include <unistd.h>\n#include <signal.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <pthread.h>\n#include <pwd.h>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#if HAVE_NCURSES_H\n#include <ncurses.h>\n#else\n#include <curses.h>\n#endif\n\n#if HAVE_TERM_H\n#include <term.h>\n#elif HAVE_NCURSES_TERM_H\n#include <ncurses/term.h>\n#endif\n\n#if HAVE_LIBINTL_H\n#include <libintl.h>\n#endif\n\n#include <errno.h>\n\n#include \"fallback.h\"\n#include \"util.h\"\n\n#include \"wutil.h\"\n#include \"proc.h\"\n#include \"common.h\"\n#include \"env.h\"\n#include \"sanity.h\"\n#include \"expand.h\"\n#include \"history.h\"\n#include \"reader.h\"\n#include \"parser.h\"\n#include \"env_universal.h\"\n#include \"input.h\"\n#include \"event.h\"\n#include \"path.h\"\n\n#include \"complete.h\"\n#include \"fish_version.h\"\n\n/** Command used to start fishd */\n#define FISHD_CMD L\"fishd ^ /dev/null\"\n\n// Version for easier debugging\n//#define FISHD_CMD L\"fishd\"\n\n/** Value denoting a null string */\n#define ENV_NULL L\"\\x1d\"\n\n/** Some configuration path environment variables */\n#define FISH_DATADIR_VAR L\"__fish_datadir\"\n#define FISH_SYSCONFDIR_VAR L\"__fish_sysconfdir\"\n#define FISH_HELPDIR_VAR L\"__fish_help_dir\"\n#define FISH_BIN_DIR L\"__fish_bin_dir\"\n\n/**\n   At init, we read all the environment variables from this array.\n*/\nextern char **environ;\n/**\n   This should be the same thing as \\c environ, but it is possible only one of the two work...\n*/\nextern char **__environ;\n\n\nbool g_log_forks = false;\nbool g_use_posix_spawn = false; //will usually be set to true\n\n\n/**\n   Struct representing one level in the function variable stack\n*/\nstruct env_node_t\n{\n    /**\n      Variable table\n    */\n    var_table_t env;\n    /**\n      Does this node imply a new variable scope? If yes, all\n      non-global variables below this one in the stack are\n      invisible. If new_scope is set for the global variable node,\n      the universe will explode.\n    */\n    bool new_scope;\n    /**\n       Does this node contain any variables which are exported to subshells\n    */\n    bool exportv;\n\n    /**\n      Pointer to next level\n    */\n    struct env_node_t *next;\n\n\n    env_node_t() : new_scope(false), exportv(false), next(NULL) { }\n\n    /* Returns a pointer to the given entry if present, or NULL. */\n    const var_entry_t *find_entry(const wcstring &key);\n\n    /* Returns the next scope to search in order, respecting the new_scope flag, or NULL if we're done. */\n    env_node_t *next_scope_to_search(void);\n};\n\nclass variable_entry_t\n{\n    wcstring value; /**< Value of the variable */\n};\n\nstatic pthread_mutex_t env_lock = PTHREAD_MUTEX_INITIALIZER;\n\n/** Top node on the function stack */\nstatic env_node_t *top = NULL;\n\n/** Bottom node on the function stack */\nstatic env_node_t *global_env = NULL;\n\n\n/**\n   Table for global variables\n*/\nstatic var_table_t *global;\n\n/* Helper class for storing constant strings, without needing to wrap them in a wcstring */\n\n/* Comparer for const string set */\nstruct const_string_set_comparer\n{\n    bool operator()(const wchar_t *a, const wchar_t *b)\n    {\n        return wcscmp(a, b) < 0;\n    }\n};\ntypedef std::set<const wchar_t *, const_string_set_comparer> const_string_set_t;\n\n/** Table of variables that may not be set using the set command. */\nstatic const_string_set_t env_read_only;\n\nstatic bool is_read_only(const wcstring &key)\n{\n    return env_read_only.find(key.c_str()) != env_read_only.end();\n}\n\n/**\n   Table of variables whose value is dynamically calculated, such as umask, status, etc\n*/\nstatic const_string_set_t env_electric;\n\nstatic bool is_electric(const wcstring &key)\n{\n    return env_electric.find(key.c_str()) != env_electric.end();\n}\n\n/**\n   Exported variable array used by execv\n*/\nstatic null_terminated_array_t<char> export_array;\n\n/**\n   Flag for checking if we need to regenerate the exported variable\n   array\n*/\nstatic bool has_changed_exported = true;\nstatic void mark_changed_exported()\n{\n    has_changed_exported = true;\n}\n\n/**\n   List of all locale variable names\n*/\nstatic const wchar_t * const locale_variable[] =\n{\n    L\"LANG\",\n    L\"LC_ALL\",\n    L\"LC_COLLATE\",\n    L\"LC_CTYPE\",\n    L\"LC_MESSAGES\",\n    L\"LC_MONETARY\",\n    L\"LC_NUMERIC\",\n    L\"LC_TIME\",\n    NULL\n};\n\n\nconst var_entry_t *env_node_t::find_entry(const wcstring &key)\n{\n    const var_entry_t *result = NULL;\n    var_table_t::const_iterator where = env.find(key);\n    if (where != env.end())\n    {\n        result = &where->second;\n    }\n    return result;\n}\n\nenv_node_t *env_node_t::next_scope_to_search(void)\n{\n    return this->new_scope ? global_env : this->next;\n}\n\n\n/**\n   When fishd isn't started, this function is provided to\n   env_universal as a callback, it tries to start up fishd. It's\n   implementation is a bit of a hack, since it evaluates a bit of\n   shellscript, and it might be used at times when that might not be\n   the best idea.\n*/\nstatic void start_fishd()\n{\n    struct passwd *pw = getpwuid(getuid());\n\n    debug(3, L\"Spawning new copy of fishd\");\n\n    if (!pw)\n    {\n        debug(0, _(L\"Could not get user information\"));\n        return;\n    }\n\n    wcstring cmd = format_string(FISHD_CMD, pw->pw_name);\n\n    /* Prefer the fishd in __fish_bin_dir, if exists */\n    const env_var_t bin_dir = env_get_string(L\"__fish_bin_dir\");\n    if (! bin_dir.missing_or_empty())\n    {\n        wcstring path = bin_dir + L\"/fishd\";\n        if (waccess(path, X_OK) == 0)\n        {\n            /* The path command just looks like 'fishd', so insert the bin path to make it absolute */\n            cmd.insert(0, bin_dir + L\"/\");\n        }\n    }\n    parser_t &parser = parser_t::principal_parser();\n    parser.eval(cmd, io_chain_t(), TOP);\n}\n\n/**\n   Return the current umask value.\n*/\nstatic mode_t get_umask()\n{\n    mode_t res;\n    res = umask(0);\n    umask(res);\n    return res;\n}\n\n/** Checks if the specified variable is a locale variable */\nstatic bool var_is_locale(const wcstring &key)\n{\n    for (size_t i=0; locale_variable[i]; i++)\n    {\n        if (key == locale_variable[i])\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n  Properly sets all locale information\n*/\nstatic void handle_locale()\n{\n    const env_var_t lc_all = env_get_string(L\"LC_ALL\");\n    const wcstring old_locale = wsetlocale(LC_MESSAGES, NULL);\n\n    /*\n      Array of locale constants corresponding to the local variable names defined in locale_variable\n    */\n    static const int cat[] =\n    {\n        0,\n        LC_ALL,\n        LC_COLLATE,\n        LC_CTYPE,\n        LC_MESSAGES,\n        LC_MONETARY,\n        LC_NUMERIC,\n        LC_TIME\n    }\n    ;\n\n    if (!lc_all.missing())\n    {\n        wsetlocale(LC_ALL, lc_all.c_str());\n    }\n    else\n    {\n        const env_var_t lang = env_get_string(L\"LANG\");\n        if (!lang.missing())\n        {\n            wsetlocale(LC_ALL, lang.c_str());\n        }\n\n        for (int i=2; locale_variable[i]; i++)\n        {\n            const env_var_t val = env_get_string(locale_variable[i]);\n\n            if (!val.missing())\n            {\n                wsetlocale(cat[i], val.c_str());\n            }\n        }\n    }\n\n    const wcstring new_locale = wsetlocale(LC_MESSAGES, NULL);\n    if (old_locale != new_locale)\n    {\n\n        /*\n           Try to make change known to gettext. Both changing\n           _nl_msg_cat_cntr and calling dcgettext might potentially\n           tell some gettext implementation that the translation\n           strings should be reloaded. We do both and hope for the\n           best.\n        */\n\n        extern int _nl_msg_cat_cntr;\n        _nl_msg_cat_cntr++;\n\n        fish_dcgettext(\"fish\", \"Changing language to English\", LC_MESSAGES);\n\n        if (get_is_interactive())\n        {\n            debug(0, _(L\"Changing language to English\"));\n        }\n    }\n}\n\n\n/** React to modifying hte given variable */\nstatic void react_to_variable_change(const wcstring &key)\n{\n    if (var_is_locale(key))\n    {\n        handle_locale();\n    }\n    else if (key == L\"fish_term256\")\n    {\n        update_fish_term256();\n        reader_react_to_color_change();\n    }\n    else if (string_prefixes_string(L\"fish_color_\", key))\n    {\n        reader_react_to_color_change();\n    }\n}\n\n/**\n   Universal variable callback function. This function makes sure the\n   proper events are triggered when an event occurs.\n*/\nstatic void universal_callback(fish_message_type_t type,\n                               const wchar_t *name,\n                               const wchar_t *val)\n{\n    const wchar_t *str = NULL;\n\n    switch (type)\n    {\n        case SET:\n        case SET_EXPORT:\n        {\n            str=L\"SET\";\n            break;\n        }\n\n        case ERASE:\n        {\n            str=L\"ERASE\";\n            break;\n        }\n\n        default:\n            break;\n    }\n\n    if (str)\n    {\n        mark_changed_exported();\n\n        event_t ev = event_t::variable_event(name);\n        ev.arguments.push_back(L\"VARIABLE\");\n        ev.arguments.push_back(str);\n        ev.arguments.push_back(name);\n        event_fire(&ev);\n    }\n\n    if (name)\n        react_to_variable_change(name);\n}\n\n/**\n   Make sure the PATH variable contains something\n*/\nstatic void setup_path()\n{\n    const env_var_t path = env_get_string(L\"PATH\");\n    if (path.missing_or_empty())\n    {\n        const wchar_t *value = L\"/usr/bin\" ARRAY_SEP_STR L\"/bin\";\n        env_set(L\"PATH\", value, ENV_GLOBAL | ENV_EXPORT);\n    }\n}\n\nint env_set_pwd()\n{\n    wchar_t dir_path[4096];\n    wchar_t *res = wgetcwd(dir_path, 4096);\n    if (!res)\n    {\n        return 0;\n    }\n    env_set(L\"PWD\", dir_path, ENV_EXPORT | ENV_GLOBAL);\n    return 1;\n}\n\nwcstring env_get_pwd_slash(void)\n{\n    env_var_t pwd = env_get_string(L\"PWD\");\n    if (pwd.missing_or_empty())\n    {\n        return L\"\";\n    }\n    if (! string_suffixes_string(L\"/\", pwd))\n    {\n        pwd.push_back(L'/');\n    }\n    return pwd;\n}\n\n/**\n   Set up default values for various variables if not defined.\n */\nstatic void env_set_defaults()\n{\n\n    if (env_get_string(L\"USER\").missing())\n    {\n        struct passwd *pw = getpwuid(getuid());\n        if (pw->pw_name != NULL)\n        {\n            const wcstring wide_name = str2wcstring(pw->pw_name);\n            env_set(L\"USER\", wide_name.c_str(), ENV_GLOBAL);\n        }\n    }\n\n    if (env_get_string(L\"HOME\").missing())\n    {\n        const env_var_t unam = env_get_string(L\"USER\");\n        char *unam_narrow = wcs2str(unam.c_str());\n        struct passwd *pw = getpwnam(unam_narrow);\n        if (pw->pw_dir != NULL)\n        {\n            const wcstring dir = str2wcstring(pw->pw_dir);\n            env_set(L\"HOME\", dir.c_str(), ENV_GLOBAL);\n        }\n        free(unam_narrow);\n    }\n\n    env_set_pwd();\n\n}\n\n// Some variables should not be arrays. This used to be handled by a startup script, but we'd like to get down to 0 forks for startup, so handle it here.\nstatic bool variable_can_be_array(const wcstring &key)\n{\n    if (key == L\"DISPLAY\")\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nvoid env_init(const struct config_paths_t *paths /* or NULL */)\n{\n    /*\n      env_read_only variables can not be altered directly by the user\n    */\n\n    const wchar_t * const ro_keys[] =\n    {\n        L\"status\",\n        L\"history\",\n        L\"version\",\n        L\"_\",\n        L\"LINES\",\n        L\"COLUMNS\",\n        L\"PWD\",\n        L\"SHLVL\",\n        L\"FISH_VERSION\",\n    };\n    for (size_t i=0; i < sizeof ro_keys / sizeof *ro_keys; i++)\n    {\n        env_read_only.insert(ro_keys[i]);\n    }\n\n    /*\n      HOME and USER should be writeable by root, since this can be a\n      convenient way to install software.\n    */\n    if (getuid() != 0)\n    {\n        env_read_only.insert(L\"HOME\");\n        env_read_only.insert(L\"USER\");\n    }\n\n    /*\n       Names of all dynamically calculated variables\n       */\n    env_electric.insert(L\"history\");\n    env_electric.insert(L\"status\");\n    env_electric.insert(L\"umask\");\n\n    top = new env_node_t;\n    global_env = top;\n    global = &top->env;\n\n    /*\n      Now the environemnt variable handling is set up, the next step\n      is to insert valid data\n    */\n\n    /*\n      Import environment variables\n    */\n    for (char **p = (environ ? environ : __environ); p && *p; p++)\n    {\n        const wcstring key_and_val = str2wcstring(*p); //like foo=bar\n        size_t eql = key_and_val.find(L'=');\n        if (eql == wcstring::npos)\n        {\n            // no equals found\n            env_set(key_and_val, L\"\", ENV_EXPORT);\n        }\n        else\n        {\n            wcstring key = key_and_val.substr(0, eql);\n            wcstring val = key_and_val.substr(eql + 1);\n            if (variable_can_be_array(val))\n            {\n                std::replace(val.begin(), val.end(), L':', ARRAY_SEP);\n            }\n\n            env_set(key, val.c_str(), ENV_EXPORT | ENV_GLOBAL);\n        }\n    }\n\n    /* Set the given paths in the environment, if we have any */\n    if (paths != NULL)\n    {\n        env_set(FISH_DATADIR_VAR, paths->data.c_str(), ENV_GLOBAL | ENV_EXPORT);\n        env_set(FISH_SYSCONFDIR_VAR, paths->sysconf.c_str(), ENV_GLOBAL | ENV_EXPORT);\n        env_set(FISH_HELPDIR_VAR, paths->doc.c_str(), ENV_GLOBAL | ENV_EXPORT);\n        env_set(FISH_BIN_DIR, paths->bin.c_str(), ENV_GLOBAL | ENV_EXPORT);\n    }\n\n    /*\n      Set up the PATH variable\n    */\n    setup_path();\n\n    /*\n      Set up the USER variable\n    */\n    const struct passwd *pw = getpwuid(getuid());\n    if (pw && pw->pw_name)\n    {\n        const wcstring uname = str2wcstring(pw->pw_name);\n        env_set(L\"USER\", uname.c_str(), ENV_GLOBAL | ENV_EXPORT);\n    }\n\n    /*\n      Set up the version variables\n    */\n    wcstring version = str2wcstring(get_fish_version());\n    env_set(L\"version\", version.c_str(), ENV_GLOBAL);\n    env_set(L\"FISH_VERSION\", version.c_str(), ENV_GLOBAL);\n\n    const env_var_t fishd_dir_wstr = env_get_string(L\"FISHD_SOCKET_DIR\");\n    const env_var_t user_dir_wstr = env_get_string(L\"USER\");\n\n    wchar_t * fishd_dir = fishd_dir_wstr.missing()?NULL:const_cast<wchar_t*>(fishd_dir_wstr.c_str());\n    wchar_t * user_dir = user_dir_wstr.missing()?NULL:const_cast<wchar_t*>(user_dir_wstr.c_str());\n\n    env_universal_init(fishd_dir , user_dir ,\n                       &start_fishd,\n                       &universal_callback);\n\n    /*\n      Set up SHLVL variable\n    */\n    const env_var_t shlvl_str = env_get_string(L\"SHLVL\");\n    wcstring nshlvl_str = L\"1\";\n    if (! shlvl_str.missing())\n    {\n        long shlvl_i = wcstol(shlvl_str.c_str(), NULL, 10);\n        if (shlvl_i >= 0)\n        {\n            nshlvl_str = to_string<long>(shlvl_i + 1);\n        }\n    }\n    env_set(L\"SHLVL\", nshlvl_str.c_str(), ENV_GLOBAL | ENV_EXPORT);\n\n    /* Set correct defaults for e.g. USER and HOME variables */\n    env_set_defaults();\n\n    /* Set g_log_forks */\n    env_var_t log_forks = env_get_string(L\"fish_log_forks\");\n    g_log_forks = ! log_forks.missing_or_empty() && from_string<bool>(log_forks);\n\n    /* Set g_use_posix_spawn. Default to true. */\n    env_var_t use_posix_spawn = env_get_string(L\"fish_use_posix_spawn\");\n    g_use_posix_spawn = (use_posix_spawn.missing_or_empty() ? true : from_string<bool>(use_posix_spawn));\n\n    /* Set fish_bind_mode to \"default\" */\n    env_set(FISH_BIND_MODE_VAR, DEFAULT_BIND_MODE, ENV_GLOBAL);\n}\n\nvoid env_destroy()\n{\n    env_universal_destroy();\n\n    while (&top->env != global)\n    {\n        env_pop();\n    }\n\n    env_read_only.clear();\n    env_electric.clear();\n\n    var_table_t::iterator iter;\n    for (iter = global->begin(); iter != global->end(); ++iter)\n    {\n        const var_entry_t &entry = iter->second;\n        if (entry.exportv)\n        {\n            mark_changed_exported();\n            break;\n        }\n    }\n\n    delete top;\n}\n\n/**\n   Search all visible scopes in order for the specified key. Return\n   the first scope in which it was found.\n*/\nstatic env_node_t *env_get_node(const wcstring &key)\n{\n    env_node_t *env = top;\n    while (env != NULL)\n    {\n        if (env->find_entry(key) != NULL)\n        {\n            break;\n        }\n\n        env = env->next_scope_to_search();\n    }\n    return env;\n}\n\nint env_set(const wcstring &key, const wchar_t *val, int var_mode)\n{\n    ASSERT_IS_MAIN_THREAD();\n    bool has_changed_old = has_changed_exported;\n    bool has_changed_new = false;\n    int done=0;\n\n    int is_universal = 0;\n\n    if (val && contains(key, L\"PWD\", L\"HOME\"))\n    {\n        /* Canoncalize our path; if it changes, recurse and try again. */\n        wcstring val_canonical = val;\n        path_make_canonical(val_canonical);\n        if (val != val_canonical)\n        {\n            return env_set(key, val_canonical.c_str(), var_mode);\n        }\n    }\n\n    if ((var_mode & ENV_USER) && is_read_only(key))\n    {\n        return ENV_PERM;\n    }\n\n    if (key == L\"umask\")\n    {\n        wchar_t *end;\n\n        /*\n         Set the new umask\n         */\n        if (val && wcslen(val))\n        {\n            errno=0;\n            long mask = wcstol(val, &end, 8);\n\n            if (!errno && (!*end) && (mask <= 0777) && (mask >= 0))\n            {\n                umask(mask);\n            }\n        }\n        /* Do not actually create a umask variable, on env_get, it will be calculated dynamically */\n        return 0;\n    }\n\n    /*\n     Zero element arrays are internaly not coded as null but as this\n     placeholder string\n     */\n    if (!val)\n    {\n        val = ENV_NULL;\n    }\n\n    if (var_mode & ENV_UNIVERSAL)\n    {\n        bool exportv;\n        if (var_mode & ENV_EXPORT)\n        {\n            // export\n            exportv = true;\n        }\n        else if (var_mode & ENV_UNEXPORT)\n        {\n            // unexport\n            exportv = false;\n        }\n        else\n        {\n            // not changing the export\n            exportv = env_universal_get_export(key);\n        }\n        env_universal_set(key, val, exportv);\n        is_universal = 1;\n\n    }\n    else\n    {\n        // Determine the node\n\n        env_node_t *preexisting_node = env_get_node(key);\n        bool preexisting_entry_exportv = false;\n        if (preexisting_node != NULL)\n        {\n            var_table_t::const_iterator result = preexisting_node->env.find(key);\n            assert(result != preexisting_node->env.end());\n            const var_entry_t &entry = result->second;\n            if (entry.exportv)\n            {\n                preexisting_entry_exportv = true;\n                has_changed_new = true;\n            }\n        }\n\n        env_node_t *node = NULL;\n        if (var_mode & ENV_GLOBAL)\n        {\n            node = global_env;\n        }\n        else if (var_mode & ENV_LOCAL)\n        {\n            node = top;\n        }\n        else if (preexisting_node != NULL)\n        {\n            node = preexisting_node;\n\n            if ((var_mode & (ENV_EXPORT | ENV_UNEXPORT)) == 0)\n            {\n                // use existing entry's exportv\n                var_mode = preexisting_entry_exportv ? ENV_EXPORT : 0;\n            }\n        }\n        else\n        {\n            if (! get_proc_had_barrier())\n            {\n                set_proc_had_barrier(true);\n                env_universal_barrier();\n            }\n\n            if (! env_universal_get(key).missing())\n            {\n                bool exportv;\n                if (var_mode & ENV_EXPORT)\n                {\n                    exportv = true;\n                }\n                else if (var_mode & ENV_UNEXPORT)\n                {\n                    exportv = false;\n                }\n                else\n                {\n                    exportv = env_universal_get_export(key);\n                }\n\n                env_universal_set(key, val, exportv);\n                is_universal = 1;\n\n                done = 1;\n\n            }\n            else\n            {\n                /*\n                 New variable with unspecified scope. The default\n                 scope is the innermost scope that is shadowing,\n                 which will be either the current function or the\n                 global scope.\n                 */\n                node = top;\n                while (node->next && !node->new_scope)\n                {\n                    node = node->next;\n                }\n            }\n        }\n\n        if (!done)\n        {\n            // Set the entry in the node\n            // Note that operator[] accesses the existing entry, or creates a new one\n            var_entry_t &entry = node->env[key];\n            if (entry.exportv)\n            {\n                // this variable already existed, and was exported\n                has_changed_new = true;\n            }\n            entry.val = val;\n            if (var_mode & ENV_EXPORT)\n            {\n                // the new variable is exported\n                entry.exportv = true;\n                node->exportv = true;\n                has_changed_new = true;\n            }\n            else\n            {\n                entry.exportv = false;\n            }\n\n            if (has_changed_old || has_changed_new)\n                mark_changed_exported();\n        }\n\n    }\n\n    if (!is_universal)\n    {\n        event_t ev = event_t::variable_event(key);\n        ev.arguments.reserve(3);\n        ev.arguments.push_back(L\"VARIABLE\");\n        ev.arguments.push_back(L\"SET\");\n        ev.arguments.push_back(key);\n\n        //  debug( 1, L\"env_set: fire events on variable %ls\", key );\n        event_fire(&ev);\n        //  debug( 1, L\"env_set: return from event firing\" );\n    }\n\n    react_to_variable_change(key);\n\n    return 0;\n}\n\n\n/**\n   Attempt to remove/free the specified key/value pair from the\n   specified map.\n\n   \\return zero if the variable was not found, non-zero otherwise\n*/\nstatic bool try_remove(env_node_t *n, const wchar_t *key, int var_mode)\n{\n    if (n == NULL)\n    {\n        return false;\n    }\n\n    var_table_t::iterator result = n->env.find(key);\n    if (result != n->env.end())\n    {\n        if (result->second.exportv)\n        {\n            mark_changed_exported();\n        }\n        n->env.erase(result);\n        return true;\n    }\n\n    if (var_mode & ENV_LOCAL)\n    {\n        return false;\n    }\n\n    if (n->new_scope)\n    {\n        return try_remove(global_env, key, var_mode);\n    }\n    else\n    {\n        return try_remove(n->next, key, var_mode);\n    }\n}\n\n\nint env_remove(const wcstring &key, int var_mode)\n{\n    ASSERT_IS_MAIN_THREAD();\n    env_node_t *first_node;\n    int erased = 0;\n\n    if ((var_mode & ENV_USER) && is_read_only(key))\n    {\n        return 2;\n    }\n\n    first_node = top;\n\n    if (!(var_mode & ENV_UNIVERSAL))\n    {\n\n        if (var_mode & ENV_GLOBAL)\n        {\n            first_node = global_env;\n        }\n\n        if (try_remove(first_node, key.c_str(), var_mode))\n        {\n            event_t ev = event_t::variable_event(key);\n            ev.arguments.push_back(L\"VARIABLE\");\n            ev.arguments.push_back(L\"ERASE\");\n            ev.arguments.push_back(key);\n\n            event_fire(&ev);\n\n            erased = 1;\n        }\n    }\n\n    if (!erased &&\n            !(var_mode & ENV_GLOBAL) &&\n            !(var_mode & ENV_LOCAL))\n    {\n        erased = ! env_universal_remove(key.c_str());\n    }\n\n    react_to_variable_change(key);\n\n    return !erased;\n}\n\nconst wchar_t *env_var_t::c_str(void) const\n{\n    assert(! is_missing);\n    return wcstring::c_str();\n}\n\nenv_var_t env_get_string(const wcstring &key)\n{\n    /* Big hack...we only allow getting the history on the main thread. Note that history_t may ask for an environment variable, so don't take the lock here (we don't need it) */\n    const bool is_main = is_main_thread();\n    if (key == L\"history\" && is_main)\n    {\n        env_var_t result;\n\n        history_t *history = reader_get_history();\n        if (! history)\n        {\n            history = &history_t::history_with_name(L\"fish\");\n        }\n        if (history)\n            history->get_string_representation(result, ARRAY_SEP_STR);\n        return result;\n    }\n    else if (key == L\"COLUMNS\")\n    {\n        return to_string(common_get_width());\n    }\n    else if (key == L\"LINES\")\n    {\n        return to_string(common_get_height());\n    }\n    else if (key == L\"status\")\n    {\n        return to_string(proc_get_last_status());\n    }\n    else if (key == L\"umask\")\n    {\n        return format_string(L\"0%0.3o\", get_umask());\n    }\n    else\n    {\n        {\n            /* Lock around a local region */\n            scoped_lock lock(env_lock);\n\n            env_node_t *env = top;\n            wcstring result;\n\n            while (env != NULL)\n            {\n                const var_entry_t *entry = env->find_entry(key);\n                if (entry != NULL)\n                {\n                    if (entry->val == ENV_NULL)\n                    {\n                        return env_var_t::missing_var();\n                    }\n                    else\n                    {\n                        return entry->val;\n                    }\n                }\n\n                env = env->next_scope_to_search();\n            }\n        }\n\n        /* Another big hack - only do a universal barrier on the main thread (since it can change variable values)\n           Make sure we do this outside the env_lock because it may itself call env_get_string */\n        if (is_main && ! get_proc_had_barrier())\n        {\n            set_proc_had_barrier(true);\n            env_universal_barrier();\n        }\n\n        env_var_t item = env_universal_get(key);\n\n        if (item.missing() || (wcscmp(item.c_str(), ENV_NULL)==0))\n        {\n            return env_var_t::missing_var();\n        }\n        else\n        {\n            return item;\n        }\n    }\n}\n\nbool env_exist(const wchar_t *key, int mode)\n{\n    env_node_t *env;\n\n    CHECK(key, false);\n\n    /*\n      Read only variables all exist, and they are all global. A local\n      version can not exist.\n    */\n    if (!(mode & ENV_LOCAL) && !(mode & ENV_UNIVERSAL))\n    {\n        if (is_read_only(key) || is_electric(key))\n        {\n            //Such variables are never exported\n            if (mode & ENV_EXPORT)\n            {\n                return false;\n            }\n            else if (mode & ENV_UNEXPORT)\n            {\n                return true;\n            }\n            return true;\n        }\n    }\n\n    if (!(mode & ENV_UNIVERSAL))\n    {\n        env = (mode & ENV_GLOBAL)?global_env:top;\n\n        while (env != 0)\n        {\n            var_table_t::iterator result = env->env.find(key);\n\n            if (result != env->env.end())\n            {\n                const var_entry_t &res = result->second;\n\n                if (mode & ENV_EXPORT)\n                {\n                    return res.exportv;\n                }\n                else if (mode & ENV_UNEXPORT)\n                {\n                    return ! res.exportv;\n                }\n\n                return true;\n            }\n\n            if (mode & ENV_LOCAL)\n                break;\n\n            env = env->next_scope_to_search();\n        }\n    }\n\n    if (!(mode & ENV_LOCAL) && !(mode & ENV_GLOBAL))\n    {\n        if (! get_proc_had_barrier())\n        {\n            set_proc_had_barrier(true);\n            env_universal_barrier();\n        }\n\n        if (! env_universal_get(key).missing())\n        {\n            if (mode & ENV_EXPORT)\n            {\n                return env_universal_get_export(key) == 1;\n            }\n            else if (mode & ENV_UNEXPORT)\n            {\n                return env_universal_get_export(key) == 0;\n            }\n\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n   Returns true if the specified scope or any non-shadowed non-global subscopes contain an exported variable.\n*/\nstatic int local_scope_exports(env_node_t *n)\n{\n\n    if (n==global_env)\n        return 0;\n\n    if (n->exportv)\n        return 1;\n\n    if (n->new_scope)\n        return 0;\n\n    return local_scope_exports(n->next);\n}\n\nvoid env_push(bool new_scope)\n{\n    env_node_t *node = new env_node_t;\n    node->next = top;\n    node->new_scope=new_scope;\n\n    if (new_scope)\n    {\n        if (local_scope_exports(top))\n            mark_changed_exported();\n    }\n    top = node;\n\n}\n\n\nvoid env_pop()\n{\n    if (&top->env != global)\n    {\n        int i;\n        int locale_changed = 0;\n\n        env_node_t *killme = top;\n\n        for (i=0; locale_variable[i]; i++)\n        {\n            var_table_t::iterator result =  killme->env.find(locale_variable[i]);\n            if (result != killme->env.end())\n            {\n                locale_changed = 1;\n                break;\n            }\n        }\n\n        if (killme->new_scope)\n        {\n            if (killme->exportv || local_scope_exports(killme->next))\n                mark_changed_exported();\n        }\n\n        top = top->next;\n\n        var_table_t::iterator iter;\n        for (iter = killme->env.begin(); iter != killme->env.end(); ++iter)\n        {\n            const var_entry_t &entry = iter->second;\n            if (entry.exportv)\n            {\n                mark_changed_exported();\n                break;\n            }\n        }\n\n        delete killme;\n\n        if (locale_changed)\n            handle_locale();\n\n    }\n    else\n    {\n        debug(0,\n              _(L\"Tried to pop empty environment stack.\"));\n        sanity_lose();\n    }\n}\n\n/**\n   Function used with to insert keys of one table into a set::set<wcstring>\n*/\nstatic void add_key_to_string_set(const var_table_t &envs, std::set<wcstring> *str_set, bool show_exported, bool show_unexported)\n{\n    var_table_t::const_iterator iter;\n    for (iter = envs.begin(); iter != envs.end(); ++iter)\n    {\n        const var_entry_t &e = iter->second;\n\n        if ((e.exportv && show_exported) ||\n                (!e.exportv && show_unexported))\n        {\n            /* Insert this key */\n            str_set->insert(iter->first);\n        }\n\n    }\n}\n\nwcstring_list_t env_get_names(int flags)\n{\n    scoped_lock lock(env_lock);\n\n    wcstring_list_t result;\n    std::set<wcstring> names;\n    int show_local = flags & ENV_LOCAL;\n    int show_global = flags & ENV_GLOBAL;\n    int show_universal = flags & ENV_UNIVERSAL;\n\n    env_node_t *n=top;\n    const bool show_exported = (flags & ENV_EXPORT) || !(flags & ENV_UNEXPORT);\n    const bool show_unexported = (flags & ENV_UNEXPORT) || !(flags & ENV_EXPORT);\n\n    if (!show_local && !show_global && !show_universal)\n    {\n        show_local =show_universal = show_global=1;\n    }\n\n    if (show_local)\n    {\n        while (n)\n        {\n            if (n == global_env)\n                break;\n\n            add_key_to_string_set(n->env, &names, show_exported, show_unexported);\n            if (n->new_scope)\n                break;\n            else\n                n = n->next;\n\n        }\n    }\n\n    if (show_global)\n    {\n        add_key_to_string_set(global_env->env, &names, show_exported, show_unexported);\n        if (show_unexported)\n        {\n            result.insert(result.end(), env_electric.begin(), env_electric.end());\n        }\n\n        if (show_exported)\n        {\n            result.push_back(L\"COLUMNS\");\n            result.push_back(L\"LINES\");\n        }\n\n    }\n\n    if (show_universal)\n    {\n\n        wcstring_list_t uni_list;\n        env_universal_get_names(uni_list,\n                                show_exported,\n                                show_unexported);\n        names.insert(uni_list.begin(), uni_list.end());\n    }\n\n    result.insert(result.end(), names.begin(), names.end());\n    return result;\n}\n\n/**\n  Get list of all exported variables\n*/\n\nstatic void get_exported(const env_node_t *n, std::map<wcstring, wcstring> &h)\n{\n    if (!n)\n        return;\n\n    if (n->new_scope)\n        get_exported(global_env, h);\n    else\n        get_exported(n->next, h);\n\n    var_table_t::const_iterator iter;\n    for (iter = n->env.begin(); iter != n->env.end(); ++iter)\n    {\n        const wcstring &key = iter->first;\n        const var_entry_t &val_entry = iter->second;\n        if (val_entry.exportv && (val_entry.val != ENV_NULL))\n        {\n            // Don't use std::map::insert here, since we need to overwrite existing values from previous scopes\n            h[key] = val_entry.val;\n        }\n    }\n}\n\nstatic void export_func(const std::map<wcstring, wcstring> &envs, std::vector<std::string> &out)\n{\n    std::map<wcstring, wcstring>::const_iterator iter;\n    for (iter = envs.begin(); iter != envs.end(); ++iter)\n    {\n        const std::string ks = wcs2string(iter->first);\n        std::string vs = wcs2string(iter->second);\n\n        for (size_t i=0; i < vs.size(); i++)\n        {\n            char &vc = vs.at(i);\n            if (vc == ARRAY_SEP)\n                vc = ':';\n        }\n\n        /* Put a string on the vector */\n        out.push_back(std::string());\n        std::string &str = out.back();\n        str.reserve(ks.size() + 1 + vs.size());\n\n        /* Append our environment variable data to it */\n        str.append(ks);\n        str.append(\"=\");\n        str.append(vs);\n    }\n}\n\nstatic void update_export_array_if_necessary(bool recalc)\n{\n    ASSERT_IS_MAIN_THREAD();\n    if (recalc && ! get_proc_had_barrier())\n    {\n        set_proc_had_barrier(true);\n        env_universal_barrier();\n    }\n\n    if (has_changed_exported)\n    {\n        std::map<wcstring, wcstring> vals;\n        size_t i;\n\n        debug(4, L\"env_export_arr() recalc\");\n\n        get_exported(top, vals);\n\n        wcstring_list_t uni;\n        env_universal_get_names(uni, 1, 0);\n        for (i=0; i<uni.size(); i++)\n        {\n            const wcstring &key = uni.at(i);\n            const env_var_t val = env_universal_get(key);\n\n            if (! val.missing() && wcscmp(val.c_str(), ENV_NULL))\n            {\n                // Note that std::map::insert does NOT overwrite a value already in the map,\n                // which we depend on here\n                vals.insert(std::pair<wcstring, wcstring>(key, val));\n            }\n        }\n\n        std::vector<std::string> local_export_buffer;\n        export_func(vals, local_export_buffer);\n        export_array.set(local_export_buffer);\n        has_changed_exported=false;\n    }\n\n}\n\nconst char * const *env_export_arr(bool recalc)\n{\n    ASSERT_IS_MAIN_THREAD();\n    update_export_array_if_necessary(recalc);\n    return export_array.get();\n}\n\nenv_vars_snapshot_t::env_vars_snapshot_t(const wchar_t * const *keys)\n{\n    ASSERT_IS_MAIN_THREAD();\n    wcstring key;\n    for (size_t i=0; keys[i]; i++)\n    {\n        key.assign(keys[i]);\n        const env_var_t val = env_get_string(key);\n        if (! val.missing())\n        {\n            vars[key] = val;\n        }\n    }\n}\n\nenv_vars_snapshot_t::env_vars_snapshot_t() { }\n\n/* The \"current\" variables are not a snapshot at all, but instead trampoline to env_get_string, etc. We identify the current snapshot based on pointer values. */\nstatic const env_vars_snapshot_t sCurrentSnapshot;\nconst env_vars_snapshot_t &env_vars_snapshot_t::current()\n{\n    return sCurrentSnapshot;\n}\n\nbool env_vars_snapshot_t::is_current() const\n{\n    return this == &sCurrentSnapshot;\n}\n\nenv_var_t env_vars_snapshot_t::get(const wcstring &key) const\n{\n    /* If we represent the current state, bounce to env_get_string */\n    if (this->is_current())\n    {\n        return env_get_string(key);\n    }\n    else\n    {\n        std::map<wcstring, wcstring>::const_iterator iter = vars.find(key);\n        return (iter == vars.end() ? env_var_t::missing_var() : env_var_t(iter->second));\n    }\n}\n\nconst wchar_t * const env_vars_snapshot_t::highlighting_keys[] = {L\"PATH\", L\"CDPATH\", L\"fish_function_path\", NULL};\n", "\nfunction __fish_print_packages\n\n\t# apt-cache is much, much faster than rpm, and can do this in real\n\t# time. We use it if available.\n\n\tswitch (commandline -tc)\n\t\tcase '-**'\n\t\t\treturn\n\tend\n\n\t#Get the word 'Package' in the current language\n\tset -l package (_ Package)\n\n\t# Set up cache directory\n\tif test -z \"$XDG_CACHE_HOME\"\n\t\tset XDG_CACHE_HOME $HOME/.cache\n\tend\n\tmkdir -m 700 -p $XDG_CACHE_HOME\n\n\tif type -f apt-cache >/dev/null\n\t\t# Do not generate the cache as apparently sometimes this is slow.\n\t\t# http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=547550\n\t\tapt-cache --no-generate pkgnames (commandline -tc) ^/dev/null | sed -e 's/$/'\\t$package'/'\n\t\treturn\n\tend\n\n\t# Pkg is fast on FreeBSD and provides versioning info which we want for\n\t# installed packages\n\tif \tbegin\n\t\t\ttype -f pkg > /dev/null\n\t\t\tand test (uname) = \"FreeBSD\"\n\t\tend\n\t\tpkg query \"%n-%v\"\n\t\treturn\n\tend\n\n    # Caches for 5 minutes\n\tif type -f pacman >/dev/null\n\t\tset cache_file $XDG_CACHE_HOME/.pac-cache.$USER\n\t\tif test -f $cache_file\n\t\t\tcat $cache_file\n\t\t\tset age (math (date +%s) - (stat -c '%Y' $cache_file))\n\t\t\tset max_age 250\n\t\t\tif test $age -lt $max_age\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\n\t\t# prints: <package name>\tPackage\n\t\tpacman -Ssq | sed -e 's/$/\\t'$package'/' >$cache_file &\n\t\treturn\n\tend\n\n\t# yum is slow, just like rpm, so go to the background\n\tif type -f /usr/share/yum-cli/completion-helper.py >/dev/null\n\n\t\t# If the cache is less than six hours old, we do not recalculate it\n\n\t\tset cache_file $XDG_CACHE_HOME/.yum-cache.$USER\n\t\t\tif test -f $cache_file\n\t\t\tcat $cache_file\n\t\t\tset age (math (date +%s) - (stat -c '%Y' $cache_file))\n\t\t\tset max_age 21600\n\t\t\tif test $age -lt $max_age\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\n\t\t# Remove package version information from output and pipe into cache file\n\t\t/usr/share/yum-cli/completion-helper.py list all -d 0 -C | sed \"s/\\..*/\\t$package/\" >$cache_file &\n\t\treturn\n\tend\n\n\t# Rpm is too slow for this job, so we set it up to do completions\n\t# as a background job and cache the results.\n\n\tif type -f rpm >/dev/null\n\n\t\t# If the cache is less than five minutes old, we do not recalculate it\n\n\t\tset cache_file $XDG_CACHE_HOME/.rpm-cache.$USER\n\t\t\tif test -f $cache_file\n\t\t\tcat $cache_file\n\t\t\tset age (math (date +%s) - (stat -c '%Y' $cache_file))\n\t\t\tset max_age 250\n\t\t\tif test $age -lt $max_age\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\n\t\t# Remove package version information from output and pipe into cache file\n\t\trpm -qa |sed -e 's/-[^-]*-[^-]*$/\\t'$package'/' >$cache_file &\n\t\treturn\n\tend\n\n\t# This completes the package name from the portage tree.\n\t# True for installing new packages. Function for printing\n\t# installed on the system packages is in completions/emerge.fish\n\n\t# eix is MUCH faster than emerge so use it if it is available\n\tif type -f eix > /dev/null\n\t\teix --only-names \"^\"(commandline -tc) | cut -d/ -f2\n\t\treturn\n\telse\n\t\t# FIXME?  Seems to be broken\n\t\tif type -f emerge >/dev/null\n\t\t\temerge -s \\^(commandline -tc) |sgrep \"^*\" |cut -d\\  -f3 |cut -d/ -f2\n\t\t\treturn\n\t\tend\n\tend\n\nend\n\n"], "filenames": ["env.cpp", "share/functions/__fish_print_packages.fish"], "buggy_code_start_loc": [61, 13], "buggy_code_end_loc": [62, 77], "fixing_code_start_loc": [61, 14], "fixing_code_end_loc": [62, 83], "type": "CWE-59", "message": "fish before 2.1.1 allows local users to write to arbitrary files via a symlink attack on (1) /tmp/fishd.log.%s, (2) /tmp/.pac-cache.$USER, (3) /tmp/.yum-cache.$USER, or (4) /tmp/.rpm-cache.$USER.", "other": {"cve": {"id": "CVE-2014-3219", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-09T22:29:00.363", "lastModified": "2019-09-24T15:15:11.410", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fish before 2.1.1 allows local users to write to arbitrary files via a symlink attack on (1) /tmp/fishd.log.%s, (2) /tmp/.pac-cache.$USER, (3) /tmp/.yum-cache.$USER, or (4) /tmp/.rpm-cache.$USER."}, {"lang": "es", "value": "fish, en versiones anteriores a la 2.1.1, permite que usuarios locales escriban en archivos arbitrarios mediante un ataque de v\u00ednculo simb\u00f3lico en (1) /tmp/fishd.log.%s, (2) /tmp/.pac-cache.$USER, (3) /tmp/.yum-cache.$USER o (4) /tmp/.rpm-cache.$USER."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.1, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fishshell:fish:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.1", "matchCriteriaId": "D9589A93-99C5-4C12-977B-8866311876A1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:19:*:*:*:*:*:*:*", "matchCriteriaId": "5991814D-CA77-4C25-90D2-DB542B17E0AD"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-May/132751.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00059.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00071.html", "source": "cve@mitre.org"}, {"url": "http://security.gentoo.org/glsa/glsa-201412-49.xml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/05/06/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/09/28/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/67115", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1092091", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/fish-shell/fish-shell/commit/3225d7e169a9edb2f470c26989e7bc8e0d0355ce", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fish-shell/fish-shell/issues/1440", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fish-shell/fish-shell/commit/3225d7e169a9edb2f470c26989e7bc8e0d0355ce"}}