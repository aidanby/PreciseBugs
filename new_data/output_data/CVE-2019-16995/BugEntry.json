{"buggy_code": ["/* Copyright 2011-2014 Autronica Fire and Security AS\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n * Author(s):\n *\t2011-2014 Arvid Brodin, arvid.brodin@alten.se\n *\n * This file contains device methods for creating, using and destroying\n * virtual HSR devices.\n */\n\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/pkt_sched.h>\n#include \"hsr_device.h\"\n#include \"hsr_slave.h\"\n#include \"hsr_framereg.h\"\n#include \"hsr_main.h\"\n#include \"hsr_forward.h\"\n\n\nstatic bool is_admin_up(struct net_device *dev)\n{\n\treturn dev && (dev->flags & IFF_UP);\n}\n\nstatic bool is_slave_up(struct net_device *dev)\n{\n\treturn dev && is_admin_up(dev) && netif_oper_up(dev);\n}\n\nstatic void __hsr_set_operstate(struct net_device *dev, int transition)\n{\n\twrite_lock_bh(&dev_base_lock);\n\tif (dev->operstate != transition) {\n\t\tdev->operstate = transition;\n\t\twrite_unlock_bh(&dev_base_lock);\n\t\tnetdev_state_change(dev);\n\t} else {\n\t\twrite_unlock_bh(&dev_base_lock);\n\t}\n}\n\nstatic void hsr_set_operstate(struct hsr_port *master, bool has_carrier)\n{\n\tif (!is_admin_up(master->dev)) {\n\t\t__hsr_set_operstate(master->dev, IF_OPER_DOWN);\n\t\treturn;\n\t}\n\n\tif (has_carrier)\n\t\t__hsr_set_operstate(master->dev, IF_OPER_UP);\n\telse\n\t\t__hsr_set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);\n}\n\nstatic bool hsr_check_carrier(struct hsr_port *master)\n{\n\tstruct hsr_port *port;\n\tbool has_carrier;\n\n\thas_carrier = false;\n\n\trcu_read_lock();\n\thsr_for_each_port(master->hsr, port)\n\t\tif ((port->type != HSR_PT_MASTER) && is_slave_up(port->dev)) {\n\t\t\thas_carrier = true;\n\t\t\tbreak;\n\t\t}\n\trcu_read_unlock();\n\n\tif (has_carrier)\n\t\tnetif_carrier_on(master->dev);\n\telse\n\t\tnetif_carrier_off(master->dev);\n\n\treturn has_carrier;\n}\n\n\nstatic void hsr_check_announce(struct net_device *hsr_dev,\n\t\t\t       unsigned char old_operstate)\n{\n\tstruct hsr_priv *hsr;\n\n\thsr = netdev_priv(hsr_dev);\n\n\tif ((hsr_dev->operstate == IF_OPER_UP)\n\t\t\t&& (old_operstate != IF_OPER_UP)) {\n\t\t/* Went up */\n\t\thsr->announce_count = 0;\n\t\thsr->announce_timer.expires = jiffies +\n\t\t\t\tmsecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);\n\t\tadd_timer(&hsr->announce_timer);\n\t}\n\n\tif ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))\n\t\t/* Went down */\n\t\tdel_timer(&hsr->announce_timer);\n}\n\nvoid hsr_check_carrier_and_operstate(struct hsr_priv *hsr)\n{\n\tstruct hsr_port *master;\n\tunsigned char old_operstate;\n\tbool has_carrier;\n\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\t/* netif_stacked_transfer_operstate() cannot be used here since\n\t * it doesn't set IF_OPER_LOWERLAYERDOWN (?)\n\t */\n\told_operstate = master->dev->operstate;\n\thas_carrier = hsr_check_carrier(master);\n\thsr_set_operstate(master, has_carrier);\n\thsr_check_announce(master->dev, old_operstate);\n}\n\nint hsr_get_max_mtu(struct hsr_priv *hsr)\n{\n\tunsigned int mtu_max;\n\tstruct hsr_port *port;\n\n\tmtu_max = ETH_DATA_LEN;\n\trcu_read_lock();\n\thsr_for_each_port(hsr, port)\n\t\tif (port->type != HSR_PT_MASTER)\n\t\t\tmtu_max = min(port->dev->mtu, mtu_max);\n\trcu_read_unlock();\n\n\tif (mtu_max < HSR_HLEN)\n\t\treturn 0;\n\treturn mtu_max - HSR_HLEN;\n}\n\n\nstatic int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *master;\n\n\thsr = netdev_priv(dev);\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\n\tif (new_mtu > hsr_get_max_mtu(hsr)) {\n\t\tnetdev_info(master->dev, \"A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\\n\",\n\t\t\t    HSR_HLEN);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic int hsr_dev_open(struct net_device *dev)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tchar designation;\n\n\thsr = netdev_priv(dev);\n\tdesignation = '\\0';\n\n\trcu_read_lock();\n\thsr_for_each_port(hsr, port) {\n\t\tif (port->type == HSR_PT_MASTER)\n\t\t\tcontinue;\n\t\tswitch (port->type) {\n\t\tcase HSR_PT_SLAVE_A:\n\t\t\tdesignation = 'A';\n\t\t\tbreak;\n\t\tcase HSR_PT_SLAVE_B:\n\t\t\tdesignation = 'B';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdesignation = '?';\n\t\t}\n\t\tif (!is_slave_up(port->dev))\n\t\t\tnetdev_warn(dev, \"Slave %c (%s) is not up; please bring it up to get a fully working HSR network\\n\",\n\t\t\t\t    designation, port->dev->name);\n\t}\n\trcu_read_unlock();\n\n\tif (designation == '\\0')\n\t\tnetdev_warn(dev, \"No slave devices configured\\n\");\n\n\treturn 0;\n}\n\n\nstatic int hsr_dev_close(struct net_device *dev)\n{\n\t/* Nothing to do here. */\n\treturn 0;\n}\n\n\nstatic netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,\n\t\t\t\t\t\tnetdev_features_t features)\n{\n\tnetdev_features_t mask;\n\tstruct hsr_port *port;\n\n\tmask = features;\n\n\t/* Mask out all features that, if supported by one device, should be\n\t * enabled for all devices (see NETIF_F_ONE_FOR_ALL).\n\t *\n\t * Anything that's off in mask will not be enabled - so only things\n\t * that were in features originally, and also is in NETIF_F_ONE_FOR_ALL,\n\t * may become enabled.\n\t */\n\tfeatures &= ~NETIF_F_ONE_FOR_ALL;\n\thsr_for_each_port(hsr, port)\n\t\tfeatures = netdev_increment_features(features,\n\t\t\t\t\t\t     port->dev->features,\n\t\t\t\t\t\t     mask);\n\n\treturn features;\n}\n\nstatic netdev_features_t hsr_fix_features(struct net_device *dev,\n\t\t\t\t\t  netdev_features_t features)\n{\n\tstruct hsr_priv *hsr = netdev_priv(dev);\n\n\treturn hsr_features_recompute(hsr, features);\n}\n\n\nstatic int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct hsr_priv *hsr = netdev_priv(dev);\n\tstruct hsr_port *master;\n\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\tskb->dev = master->dev;\n\thsr_forward_skb(skb, master);\n\n\treturn NETDEV_TX_OK;\n}\n\n\nstatic const struct header_ops hsr_header_ops = {\n\t.create\t = eth_header,\n\t.parse\t = eth_header_parse,\n};\n\nstatic void send_hsr_supervision_frame(struct hsr_port *master,\n\t\tu8 type, u8 hsrVer)\n{\n\tstruct sk_buff *skb;\n\tint hlen, tlen;\n\tstruct hsr_tag *hsr_tag;\n\tstruct hsr_sup_tag *hsr_stag;\n\tstruct hsr_sup_payload *hsr_sp;\n\tunsigned long irqflags;\n\n\thlen = LL_RESERVED_SPACE(master->dev);\n\ttlen = master->dev->needed_tailroom;\n\tskb = dev_alloc_skb(\n\t\t\tsizeof(struct hsr_tag) +\n\t\t\tsizeof(struct hsr_sup_tag) +\n\t\t\tsizeof(struct hsr_sup_payload) + hlen + tlen);\n\n\tif (skb == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, hlen);\n\n\tskb->dev = master->dev;\n\tskb->protocol = htons(hsrVer ? ETH_P_HSR : ETH_P_PRP);\n\tskb->priority = TC_PRIO_CONTROL;\n\n\tif (dev_hard_header(skb, skb->dev, (hsrVer ? ETH_P_HSR : ETH_P_PRP),\n\t\t\t    master->hsr->sup_multicast_addr,\n\t\t\t    skb->dev->dev_addr, skb->len) <= 0)\n\t\tgoto out;\n\tskb_reset_mac_header(skb);\n\n\tif (hsrVer > 0) {\n\t\thsr_tag = skb_put(skb, sizeof(struct hsr_tag));\n\t\thsr_tag->encap_proto = htons(ETH_P_PRP);\n\t\tset_hsr_tag_LSDU_size(hsr_tag, HSR_V1_SUP_LSDUSIZE);\n\t}\n\n\thsr_stag = skb_put(skb, sizeof(struct hsr_sup_tag));\n\tset_hsr_stag_path(hsr_stag, (hsrVer ? 0x0 : 0xf));\n\tset_hsr_stag_HSR_Ver(hsr_stag, hsrVer);\n\n\t/* From HSRv1 on we have separate supervision sequence numbers. */\n\tspin_lock_irqsave(&master->hsr->seqnr_lock, irqflags);\n\tif (hsrVer > 0) {\n\t\thsr_stag->sequence_nr = htons(master->hsr->sup_sequence_nr);\n\t\thsr_tag->sequence_nr = htons(master->hsr->sequence_nr);\n\t\tmaster->hsr->sup_sequence_nr++;\n\t\tmaster->hsr->sequence_nr++;\n\t} else {\n\t\thsr_stag->sequence_nr = htons(master->hsr->sequence_nr);\n\t\tmaster->hsr->sequence_nr++;\n\t}\n\tspin_unlock_irqrestore(&master->hsr->seqnr_lock, irqflags);\n\n\thsr_stag->HSR_TLV_Type = type;\n\t/* TODO: Why 12 in HSRv0? */\n\thsr_stag->HSR_TLV_Length = hsrVer ? sizeof(struct hsr_sup_payload) : 12;\n\n\t/* Payload: MacAddressA */\n\thsr_sp = skb_put(skb, sizeof(struct hsr_sup_payload));\n\tether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);\n\n\tif (skb_put_padto(skb, ETH_ZLEN + HSR_HLEN))\n\t\treturn;\n\n\thsr_forward_skb(skb, master);\n\treturn;\n\nout:\n\tWARN_ONCE(1, \"HSR: Could not send supervision frame\\n\");\n\tkfree_skb(skb);\n}\n\n\n/* Announce (supervision frame) timer function\n */\nstatic void hsr_announce(struct timer_list *t)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *master;\n\n\thsr = from_timer(hsr, t, announce_timer);\n\n\trcu_read_lock();\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\n\tif (hsr->announce_count < 3 && hsr->protVersion == 0) {\n\t\tsend_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE,\n\t\t\t\thsr->protVersion);\n\t\thsr->announce_count++;\n\n\t\thsr->announce_timer.expires = jiffies +\n\t\t\t\tmsecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);\n\t} else {\n\t\tsend_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK,\n\t\t\t\thsr->protVersion);\n\n\t\thsr->announce_timer.expires = jiffies +\n\t\t\t\tmsecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);\n\t}\n\n\tif (is_admin_up(master->dev))\n\t\tadd_timer(&hsr->announce_timer);\n\n\trcu_read_unlock();\n}\n\n\n/* According to comments in the declaration of struct net_device, this function\n * is \"Called from unregister, can be used to call free_netdev\". Ok then...\n */\nstatic void hsr_dev_destroy(struct net_device *hsr_dev)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\n\thsr = netdev_priv(hsr_dev);\n\n\trtnl_lock();\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\n\trtnl_unlock();\n\n\tdel_timer_sync(&hsr->prune_timer);\n\tdel_timer_sync(&hsr->announce_timer);\n\n\tsynchronize_rcu();\n}\n\nstatic const struct net_device_ops hsr_device_ops = {\n\t.ndo_change_mtu = hsr_dev_change_mtu,\n\t.ndo_open = hsr_dev_open,\n\t.ndo_stop = hsr_dev_close,\n\t.ndo_start_xmit = hsr_dev_xmit,\n\t.ndo_fix_features = hsr_fix_features,\n};\n\nstatic struct device_type hsr_type = {\n\t.name = \"hsr\",\n};\n\nvoid hsr_dev_setup(struct net_device *dev)\n{\n\teth_hw_addr_random(dev);\n\n\tether_setup(dev);\n\tdev->min_mtu = 0;\n\tdev->header_ops = &hsr_header_ops;\n\tdev->netdev_ops = &hsr_device_ops;\n\tSET_NETDEV_DEVTYPE(dev, &hsr_type);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = hsr_dev_destroy;\n\n\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |\n\t\t\t   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |\n\t\t\t   NETIF_F_HW_VLAN_CTAG_TX;\n\n\tdev->features = dev->hw_features;\n\n\t/* Prevent recursive tx locking */\n\tdev->features |= NETIF_F_LLTX;\n\t/* VLAN on top of HSR needs testing and probably some work on\n\t * hsr_header_create() etc.\n\t */\n\tdev->features |= NETIF_F_VLAN_CHALLENGED;\n\t/* Not sure about this. Taken from bridge code. netdev_features.h says\n\t * it means \"Does not change network namespaces\".\n\t */\n\tdev->features |= NETIF_F_NETNS_LOCAL;\n}\n\n\n/* Return true if dev is a HSR master; return false otherwise.\n */\ninline bool is_hsr_master(struct net_device *dev)\n{\n\treturn (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);\n}\n\n/* Default multicast address for HSR Supervision frames */\nstatic const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {\n\t0x01, 0x15, 0x4e, 0x00, 0x01, 0x00\n};\n\nint hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\treturn res;\n\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\n\n\treturn res;\n}\n", "/* Copyright 2011-2014 Autronica Fire and Security AS\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n * Author(s):\n *\t2011-2014 Arvid Brodin, arvid.brodin@alten.se\n *\n * The HSR spec says never to forward the same frame twice on the same\n * interface. A frame is identified by its source MAC address and its HSR\n * sequence number. This code keeps track of senders and their sequence numbers\n * to allow filtering of duplicate frames, and to detect HSR ring errors.\n */\n\n#include <linux/if_ether.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include \"hsr_main.h\"\n#include \"hsr_framereg.h\"\n#include \"hsr_netlink.h\"\n\n\nstruct hsr_node {\n\tstruct list_head\tmac_list;\n\tunsigned char\t\tMacAddressA[ETH_ALEN];\n\tunsigned char\t\tMacAddressB[ETH_ALEN];\n\t/* Local slave through which AddrB frames are received from this node */\n\tenum hsr_port_type\tAddrB_port;\n\tunsigned long\t\ttime_in[HSR_PT_PORTS];\n\tbool\t\t\ttime_in_stale[HSR_PT_PORTS];\n\tu16\t\t\tseq_out[HSR_PT_PORTS];\n\tstruct rcu_head\t\trcu_head;\n};\n\n\n/*\tTODO: use hash lists for mac addresses (linux/jhash.h)?    */\n\n\n/* seq_nr_after(a, b) - return true if a is after (higher in sequence than) b,\n * false otherwise.\n */\nstatic bool seq_nr_after(u16 a, u16 b)\n{\n\t/* Remove inconsistency where\n\t * seq_nr_after(a, b) == seq_nr_before(a, b)\n\t */\n\tif ((int) b - a == 32768)\n\t\treturn false;\n\n\treturn (((s16) (b - a)) < 0);\n}\n#define seq_nr_before(a, b)\t\tseq_nr_after((b), (a))\n#define seq_nr_after_or_eq(a, b)\t(!seq_nr_before((a), (b)))\n#define seq_nr_before_or_eq(a, b)\t(!seq_nr_after((a), (b)))\n\n\nbool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr)\n{\n\tstruct hsr_node *node;\n\n\tnode = list_first_or_null_rcu(&hsr->self_node_db, struct hsr_node,\n\t\t\t\t      mac_list);\n\tif (!node) {\n\t\tWARN_ONCE(1, \"HSR: No self node\\n\");\n\t\treturn false;\n\t}\n\n\tif (ether_addr_equal(addr, node->MacAddressA))\n\t\treturn true;\n\tif (ether_addr_equal(addr, node->MacAddressB))\n\t\treturn true;\n\n\treturn false;\n}\n\n/* Search for mac entry. Caller must hold rcu read lock.\n */\nstatic struct hsr_node *find_node_by_AddrA(struct list_head *node_db,\n\t\t\t\t\t   const unsigned char addr[ETH_ALEN])\n{\n\tstruct hsr_node *node;\n\n\tlist_for_each_entry_rcu(node, node_db, mac_list) {\n\t\tif (ether_addr_equal(node->MacAddressA, addr))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n\n/* Helper for device init; the self_node_db is used in hsr_rcv() to recognize\n * frames from self that's been looped over the HSR ring.\n */\nint hsr_create_self_node(struct list_head *self_node_db,\n\t\t\t unsigned char addr_a[ETH_ALEN],\n\t\t\t unsigned char addr_b[ETH_ALEN])\n{\n\tstruct hsr_node *node, *oldnode;\n\n\tnode = kmalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tether_addr_copy(node->MacAddressA, addr_a);\n\tether_addr_copy(node->MacAddressB, addr_b);\n\n\trcu_read_lock();\n\toldnode = list_first_or_null_rcu(self_node_db,\n\t\t\t\t\t\tstruct hsr_node, mac_list);\n\tif (oldnode) {\n\t\tlist_replace_rcu(&oldnode->mac_list, &node->mac_list);\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t\tkfree(oldnode);\n\t} else {\n\t\trcu_read_unlock();\n\t\tlist_add_tail_rcu(&node->mac_list, self_node_db);\n\t}\n\n\treturn 0;\n}\n\n\n/* Allocate an hsr_node and add it to node_db. 'addr' is the node's AddressA;\n * seq_out is used to initialize filtering of outgoing duplicate frames\n * originating from the newly added node.\n */\nstruct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],\n\t\t\t      u16 seq_out)\n{\n\tstruct hsr_node *node;\n\tunsigned long now;\n\tint i;\n\n\tnode = kzalloc(sizeof(*node), GFP_ATOMIC);\n\tif (!node)\n\t\treturn NULL;\n\n\tether_addr_copy(node->MacAddressA, addr);\n\n\t/* We are only interested in time diffs here, so use current jiffies\n\t * as initialization. (0 could trigger an spurious ring error warning).\n\t */\n\tnow = jiffies;\n\tfor (i = 0; i < HSR_PT_PORTS; i++)\n\t\tnode->time_in[i] = now;\n\tfor (i = 0; i < HSR_PT_PORTS; i++)\n\t\tnode->seq_out[i] = seq_out;\n\n\tlist_add_tail_rcu(&node->mac_list, node_db);\n\n\treturn node;\n}\n\n/* Get the hsr_node from which 'skb' was sent.\n */\nstruct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,\n\t\t\t      bool is_sup)\n{\n\tstruct list_head *node_db = &port->hsr->node_db;\n\tstruct hsr_node *node;\n\tstruct ethhdr *ethhdr;\n\tu16 seq_out;\n\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn NULL;\n\n\tethhdr = (struct ethhdr *) skb_mac_header(skb);\n\n\tlist_for_each_entry_rcu(node, node_db, mac_list) {\n\t\tif (ether_addr_equal(node->MacAddressA, ethhdr->h_source))\n\t\t\treturn node;\n\t\tif (ether_addr_equal(node->MacAddressB, ethhdr->h_source))\n\t\t\treturn node;\n\t}\n\n\t/* Everyone may create a node entry, connected node to a HSR device. */\n\n\tif (ethhdr->h_proto == htons(ETH_P_PRP)\n\t\t\t|| ethhdr->h_proto == htons(ETH_P_HSR)) {\n\t\t/* Use the existing sequence_nr from the tag as starting point\n\t\t * for filtering duplicate frames.\n\t\t */\n\t\tseq_out = hsr_get_skb_sequence_nr(skb) - 1;\n\t} else {\n\t\t/* this is called also for frames from master port and\n\t\t * so warn only for non master ports\n\t\t */\n\t\tif (port->type != HSR_PT_MASTER)\n\t\t\tWARN_ONCE(1, \"%s: Non-HSR frame\\n\", __func__);\n\t\tseq_out = HSR_SEQNR_START;\n\t}\n\n\treturn hsr_add_node(node_db, ethhdr->h_source, seq_out);\n}\n\n/* Use the Supervision frame's info about an eventual MacAddressB for merging\n * nodes that has previously had their MacAddressB registered as a separate\n * node.\n */\nvoid hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,\n\t\t\t  struct hsr_port *port_rcv)\n{\n\tstruct ethhdr *ethhdr;\n\tstruct hsr_node *node_real;\n\tstruct hsr_sup_payload *hsr_sp;\n\tstruct list_head *node_db;\n\tint i;\n\n\tethhdr = (struct ethhdr *) skb_mac_header(skb);\n\n\t/* Leave the ethernet header. */\n\tskb_pull(skb, sizeof(struct ethhdr));\n\n\t/* And leave the HSR tag. */\n\tif (ethhdr->h_proto == htons(ETH_P_HSR))\n\t\tskb_pull(skb, sizeof(struct hsr_tag));\n\n\t/* And leave the HSR sup tag. */\n\tskb_pull(skb, sizeof(struct hsr_sup_tag));\n\n\thsr_sp = (struct hsr_sup_payload *) skb->data;\n\n\t/* Merge node_curr (registered on MacAddressB) into node_real */\n\tnode_db = &port_rcv->hsr->node_db;\n\tnode_real = find_node_by_AddrA(node_db, hsr_sp->MacAddressA);\n\tif (!node_real)\n\t\t/* No frame received from AddrA of this node yet */\n\t\tnode_real = hsr_add_node(node_db, hsr_sp->MacAddressA,\n\t\t\t\t\t HSR_SEQNR_START - 1);\n\tif (!node_real)\n\t\tgoto done; /* No mem */\n\tif (node_real == node_curr)\n\t\t/* Node has already been merged */\n\t\tgoto done;\n\n\tether_addr_copy(node_real->MacAddressB, ethhdr->h_source);\n\tfor (i = 0; i < HSR_PT_PORTS; i++) {\n\t\tif (!node_curr->time_in_stale[i] &&\n\t\t    time_after(node_curr->time_in[i], node_real->time_in[i])) {\n\t\t\tnode_real->time_in[i] = node_curr->time_in[i];\n\t\t\tnode_real->time_in_stale[i] = node_curr->time_in_stale[i];\n\t\t}\n\t\tif (seq_nr_after(node_curr->seq_out[i], node_real->seq_out[i]))\n\t\t\tnode_real->seq_out[i] = node_curr->seq_out[i];\n\t}\n\tnode_real->AddrB_port = port_rcv->type;\n\n\tlist_del_rcu(&node_curr->mac_list);\n\tkfree_rcu(node_curr, rcu_head);\n\ndone:\n\tskb_push(skb, sizeof(struct hsrv1_ethhdr_sp));\n}\n\n\n/* 'skb' is a frame meant for this host, that is to be passed to upper layers.\n *\n * If the frame was sent by a node's B interface, replace the source\n * address with that node's \"official\" address (MacAddressA) so that upper\n * layers recognize where it came from.\n */\nvoid hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb)\n{\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmemcpy(&eth_hdr(skb)->h_source, node->MacAddressA, ETH_ALEN);\n}\n\n/* 'skb' is a frame meant for another host.\n * 'port' is the outgoing interface\n *\n * Substitute the target (dest) MAC address if necessary, so the it matches the\n * recipient interface MAC address, regardless of whether that is the\n * recipient's A or B interface.\n * This is needed to keep the packets flowing through switches that learn on\n * which \"side\" the different interfaces are.\n */\nvoid hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port)\n{\n\tstruct hsr_node *node_dst;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn;\n\n\tnode_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);\n\tif (!node_dst) {\n\t\tWARN_ONCE(1, \"%s: Unknown node\\n\", __func__);\n\t\treturn;\n\t}\n\tif (port->type != node_dst->AddrB_port)\n\t\treturn;\n\n\tether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);\n}\n\n\nvoid hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,\n\t\t\t   u16 sequence_nr)\n{\n\t/* Don't register incoming frames without a valid sequence number. This\n\t * ensures entries of restarted nodes gets pruned so that they can\n\t * re-register and resume communications.\n\t */\n\tif (seq_nr_before(sequence_nr, node->seq_out[port->type]))\n\t\treturn;\n\n\tnode->time_in[port->type] = jiffies;\n\tnode->time_in_stale[port->type] = false;\n}\n\n/* 'skb' is a HSR Ethernet frame (with a HSR tag inserted), with a valid\n * ethhdr->h_source address and skb->mac_header set.\n *\n * Return:\n *\t 1 if frame can be shown to have been sent recently on this interface,\n *\t 0 otherwise, or\n *\t negative error code on error\n */\nint hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,\n\t\t\t   u16 sequence_nr)\n{\n\tif (seq_nr_before_or_eq(sequence_nr, node->seq_out[port->type]))\n\t\treturn 1;\n\n\tnode->seq_out[port->type] = sequence_nr;\n\treturn 0;\n}\n\n\nstatic struct hsr_port *get_late_port(struct hsr_priv *hsr,\n\t\t\t\t      struct hsr_node *node)\n{\n\tif (node->time_in_stale[HSR_PT_SLAVE_A])\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (node->time_in_stale[HSR_PT_SLAVE_B])\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\n\tif (time_after(node->time_in[HSR_PT_SLAVE_B],\n\t\t       node->time_in[HSR_PT_SLAVE_A] +\n\t\t\t\t\tmsecs_to_jiffies(MAX_SLAVE_DIFF)))\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (time_after(node->time_in[HSR_PT_SLAVE_A],\n\t\t       node->time_in[HSR_PT_SLAVE_B] +\n\t\t\t\t\tmsecs_to_jiffies(MAX_SLAVE_DIFF)))\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\n\treturn NULL;\n}\n\n\n/* Remove stale sequence_nr records. Called by timer every\n * HSR_LIFE_CHECK_INTERVAL (two seconds or so).\n */\nvoid hsr_prune_nodes(struct timer_list *t)\n{\n\tstruct hsr_priv *hsr = from_timer(hsr, t, prune_timer);\n\tstruct hsr_node *node;\n\tstruct hsr_port *port;\n\tunsigned long timestamp;\n\tunsigned long time_a, time_b;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(node, &hsr->node_db, mac_list) {\n\t\t/* Shorthand */\n\t\ttime_a = node->time_in[HSR_PT_SLAVE_A];\n\t\ttime_b = node->time_in[HSR_PT_SLAVE_B];\n\n\t\t/* Check for timestamps old enough to risk wrap-around */\n\t\tif (time_after(jiffies, time_a + MAX_JIFFY_OFFSET/2))\n\t\t\tnode->time_in_stale[HSR_PT_SLAVE_A] = true;\n\t\tif (time_after(jiffies, time_b + MAX_JIFFY_OFFSET/2))\n\t\t\tnode->time_in_stale[HSR_PT_SLAVE_B] = true;\n\n\t\t/* Get age of newest frame from node.\n\t\t * At least one time_in is OK here; nodes get pruned long\n\t\t * before both time_ins can get stale\n\t\t */\n\t\ttimestamp = time_a;\n\t\tif (node->time_in_stale[HSR_PT_SLAVE_A] ||\n\t\t    (!node->time_in_stale[HSR_PT_SLAVE_B] &&\n\t\t    time_after(time_b, time_a)))\n\t\t\ttimestamp = time_b;\n\n\t\t/* Warn of ring error only as long as we get frames at all */\n\t\tif (time_is_after_jiffies(timestamp +\n\t\t\t\t\tmsecs_to_jiffies(1.5*MAX_SLAVE_DIFF))) {\n\t\t\trcu_read_lock();\n\t\t\tport = get_late_port(hsr, node);\n\t\t\tif (port != NULL)\n\t\t\t\thsr_nl_ringerror(hsr, node->MacAddressA, port);\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\t/* Prune old entries */\n\t\tif (time_is_before_jiffies(timestamp +\n\t\t\t\t\tmsecs_to_jiffies(HSR_NODE_FORGET_TIME))) {\n\t\t\thsr_nl_nodedown(hsr, node->MacAddressA);\n\t\t\tlist_del_rcu(&node->mac_list);\n\t\t\t/* Note that we need to free this entry later: */\n\t\t\tkfree_rcu(node, rcu_head);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n\nvoid *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,\n\t\t\tunsigned char addr[ETH_ALEN])\n{\n\tstruct hsr_node *node;\n\n\tif (!_pos) {\n\t\tnode = list_first_or_null_rcu(&hsr->node_db,\n\t\t\t\t\t      struct hsr_node, mac_list);\n\t\tif (node)\n\t\t\tether_addr_copy(addr, node->MacAddressA);\n\t\treturn node;\n\t}\n\n\tnode = _pos;\n\tlist_for_each_entry_continue_rcu(node, &hsr->node_db, mac_list) {\n\t\tether_addr_copy(addr, node->MacAddressA);\n\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n\nint hsr_get_node_data(struct hsr_priv *hsr,\n\t\t      const unsigned char *addr,\n\t\t      unsigned char addr_b[ETH_ALEN],\n\t\t      unsigned int *addr_b_ifindex,\n\t\t      int *if1_age,\n\t\t      u16 *if1_seq,\n\t\t      int *if2_age,\n\t\t      u16 *if2_seq)\n{\n\tstruct hsr_node *node;\n\tstruct hsr_port *port;\n\tunsigned long tdiff;\n\n\n\trcu_read_lock();\n\tnode = find_node_by_AddrA(&hsr->node_db, addr);\n\tif (!node) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\t/* No such entry */\n\t}\n\n\tether_addr_copy(addr_b, node->MacAddressB);\n\n\ttdiff = jiffies - node->time_in[HSR_PT_SLAVE_A];\n\tif (node->time_in_stale[HSR_PT_SLAVE_A])\n\t\t*if1_age = INT_MAX;\n#if HZ <= MSEC_PER_SEC\n\telse if (tdiff > msecs_to_jiffies(INT_MAX))\n\t\t*if1_age = INT_MAX;\n#endif\n\telse\n\t\t*if1_age = jiffies_to_msecs(tdiff);\n\n\ttdiff = jiffies - node->time_in[HSR_PT_SLAVE_B];\n\tif (node->time_in_stale[HSR_PT_SLAVE_B])\n\t\t*if2_age = INT_MAX;\n#if HZ <= MSEC_PER_SEC\n\telse if (tdiff > msecs_to_jiffies(INT_MAX))\n\t\t*if2_age = INT_MAX;\n#endif\n\telse\n\t\t*if2_age = jiffies_to_msecs(tdiff);\n\n\t/* Present sequence numbers as if they were incoming on interface */\n\t*if1_seq = node->seq_out[HSR_PT_SLAVE_B];\n\t*if2_seq = node->seq_out[HSR_PT_SLAVE_A];\n\n\tif (node->AddrB_port != HSR_PT_NONE) {\n\t\tport = hsr_port_get_hsr(hsr, node->AddrB_port);\n\t\t*addr_b_ifindex = port->dev->ifindex;\n\t} else {\n\t\t*addr_b_ifindex = -1;\n\t}\n\n\trcu_read_unlock();\n\n\treturn 0;\n}\n", "/* Copyright 2011-2014 Autronica Fire and Security AS\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n * Author(s):\n *\t2011-2014 Arvid Brodin, arvid.brodin@alten.se\n */\n\n#ifndef __HSR_FRAMEREG_H\n#define __HSR_FRAMEREG_H\n\n#include \"hsr_main.h\"\n\nstruct hsr_node;\n\nstruct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],\n\t\t\t      u16 seq_out);\nstruct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,\n\t\t\t      bool is_sup);\nvoid hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,\n\t\t\t  struct hsr_port *port);\nbool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr);\n\nvoid hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb);\nvoid hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port);\n\nvoid hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,\n\t\t\t   u16 sequence_nr);\nint hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,\n\t\t\t   u16 sequence_nr);\n\nvoid hsr_prune_nodes(struct timer_list *t);\n\nint hsr_create_self_node(struct list_head *self_node_db,\n\t\t\t unsigned char addr_a[ETH_ALEN],\n\t\t\t unsigned char addr_b[ETH_ALEN]);\n\nvoid *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,\n\t\t\tunsigned char addr[ETH_ALEN]);\n\nint hsr_get_node_data(struct hsr_priv *hsr,\n\t\t      const unsigned char *addr,\n\t\t      unsigned char addr_b[ETH_ALEN],\n\t\t      unsigned int *addr_b_ifindex,\n\t\t      int *if1_age,\n\t\t      u16 *if1_seq,\n\t\t      int *if2_age,\n\t\t      u16 *if2_seq);\n\n#endif /* __HSR_FRAMEREG_H */\n"], "fixing_code": ["/* Copyright 2011-2014 Autronica Fire and Security AS\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n * Author(s):\n *\t2011-2014 Arvid Brodin, arvid.brodin@alten.se\n *\n * This file contains device methods for creating, using and destroying\n * virtual HSR devices.\n */\n\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/pkt_sched.h>\n#include \"hsr_device.h\"\n#include \"hsr_slave.h\"\n#include \"hsr_framereg.h\"\n#include \"hsr_main.h\"\n#include \"hsr_forward.h\"\n\n\nstatic bool is_admin_up(struct net_device *dev)\n{\n\treturn dev && (dev->flags & IFF_UP);\n}\n\nstatic bool is_slave_up(struct net_device *dev)\n{\n\treturn dev && is_admin_up(dev) && netif_oper_up(dev);\n}\n\nstatic void __hsr_set_operstate(struct net_device *dev, int transition)\n{\n\twrite_lock_bh(&dev_base_lock);\n\tif (dev->operstate != transition) {\n\t\tdev->operstate = transition;\n\t\twrite_unlock_bh(&dev_base_lock);\n\t\tnetdev_state_change(dev);\n\t} else {\n\t\twrite_unlock_bh(&dev_base_lock);\n\t}\n}\n\nstatic void hsr_set_operstate(struct hsr_port *master, bool has_carrier)\n{\n\tif (!is_admin_up(master->dev)) {\n\t\t__hsr_set_operstate(master->dev, IF_OPER_DOWN);\n\t\treturn;\n\t}\n\n\tif (has_carrier)\n\t\t__hsr_set_operstate(master->dev, IF_OPER_UP);\n\telse\n\t\t__hsr_set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);\n}\n\nstatic bool hsr_check_carrier(struct hsr_port *master)\n{\n\tstruct hsr_port *port;\n\tbool has_carrier;\n\n\thas_carrier = false;\n\n\trcu_read_lock();\n\thsr_for_each_port(master->hsr, port)\n\t\tif ((port->type != HSR_PT_MASTER) && is_slave_up(port->dev)) {\n\t\t\thas_carrier = true;\n\t\t\tbreak;\n\t\t}\n\trcu_read_unlock();\n\n\tif (has_carrier)\n\t\tnetif_carrier_on(master->dev);\n\telse\n\t\tnetif_carrier_off(master->dev);\n\n\treturn has_carrier;\n}\n\n\nstatic void hsr_check_announce(struct net_device *hsr_dev,\n\t\t\t       unsigned char old_operstate)\n{\n\tstruct hsr_priv *hsr;\n\n\thsr = netdev_priv(hsr_dev);\n\n\tif ((hsr_dev->operstate == IF_OPER_UP)\n\t\t\t&& (old_operstate != IF_OPER_UP)) {\n\t\t/* Went up */\n\t\thsr->announce_count = 0;\n\t\thsr->announce_timer.expires = jiffies +\n\t\t\t\tmsecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);\n\t\tadd_timer(&hsr->announce_timer);\n\t}\n\n\tif ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))\n\t\t/* Went down */\n\t\tdel_timer(&hsr->announce_timer);\n}\n\nvoid hsr_check_carrier_and_operstate(struct hsr_priv *hsr)\n{\n\tstruct hsr_port *master;\n\tunsigned char old_operstate;\n\tbool has_carrier;\n\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\t/* netif_stacked_transfer_operstate() cannot be used here since\n\t * it doesn't set IF_OPER_LOWERLAYERDOWN (?)\n\t */\n\told_operstate = master->dev->operstate;\n\thas_carrier = hsr_check_carrier(master);\n\thsr_set_operstate(master, has_carrier);\n\thsr_check_announce(master->dev, old_operstate);\n}\n\nint hsr_get_max_mtu(struct hsr_priv *hsr)\n{\n\tunsigned int mtu_max;\n\tstruct hsr_port *port;\n\n\tmtu_max = ETH_DATA_LEN;\n\trcu_read_lock();\n\thsr_for_each_port(hsr, port)\n\t\tif (port->type != HSR_PT_MASTER)\n\t\t\tmtu_max = min(port->dev->mtu, mtu_max);\n\trcu_read_unlock();\n\n\tif (mtu_max < HSR_HLEN)\n\t\treturn 0;\n\treturn mtu_max - HSR_HLEN;\n}\n\n\nstatic int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *master;\n\n\thsr = netdev_priv(dev);\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\n\tif (new_mtu > hsr_get_max_mtu(hsr)) {\n\t\tnetdev_info(master->dev, \"A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\\n\",\n\t\t\t    HSR_HLEN);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic int hsr_dev_open(struct net_device *dev)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tchar designation;\n\n\thsr = netdev_priv(dev);\n\tdesignation = '\\0';\n\n\trcu_read_lock();\n\thsr_for_each_port(hsr, port) {\n\t\tif (port->type == HSR_PT_MASTER)\n\t\t\tcontinue;\n\t\tswitch (port->type) {\n\t\tcase HSR_PT_SLAVE_A:\n\t\t\tdesignation = 'A';\n\t\t\tbreak;\n\t\tcase HSR_PT_SLAVE_B:\n\t\t\tdesignation = 'B';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdesignation = '?';\n\t\t}\n\t\tif (!is_slave_up(port->dev))\n\t\t\tnetdev_warn(dev, \"Slave %c (%s) is not up; please bring it up to get a fully working HSR network\\n\",\n\t\t\t\t    designation, port->dev->name);\n\t}\n\trcu_read_unlock();\n\n\tif (designation == '\\0')\n\t\tnetdev_warn(dev, \"No slave devices configured\\n\");\n\n\treturn 0;\n}\n\n\nstatic int hsr_dev_close(struct net_device *dev)\n{\n\t/* Nothing to do here. */\n\treturn 0;\n}\n\n\nstatic netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,\n\t\t\t\t\t\tnetdev_features_t features)\n{\n\tnetdev_features_t mask;\n\tstruct hsr_port *port;\n\n\tmask = features;\n\n\t/* Mask out all features that, if supported by one device, should be\n\t * enabled for all devices (see NETIF_F_ONE_FOR_ALL).\n\t *\n\t * Anything that's off in mask will not be enabled - so only things\n\t * that were in features originally, and also is in NETIF_F_ONE_FOR_ALL,\n\t * may become enabled.\n\t */\n\tfeatures &= ~NETIF_F_ONE_FOR_ALL;\n\thsr_for_each_port(hsr, port)\n\t\tfeatures = netdev_increment_features(features,\n\t\t\t\t\t\t     port->dev->features,\n\t\t\t\t\t\t     mask);\n\n\treturn features;\n}\n\nstatic netdev_features_t hsr_fix_features(struct net_device *dev,\n\t\t\t\t\t  netdev_features_t features)\n{\n\tstruct hsr_priv *hsr = netdev_priv(dev);\n\n\treturn hsr_features_recompute(hsr, features);\n}\n\n\nstatic int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct hsr_priv *hsr = netdev_priv(dev);\n\tstruct hsr_port *master;\n\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\tskb->dev = master->dev;\n\thsr_forward_skb(skb, master);\n\n\treturn NETDEV_TX_OK;\n}\n\n\nstatic const struct header_ops hsr_header_ops = {\n\t.create\t = eth_header,\n\t.parse\t = eth_header_parse,\n};\n\nstatic void send_hsr_supervision_frame(struct hsr_port *master,\n\t\tu8 type, u8 hsrVer)\n{\n\tstruct sk_buff *skb;\n\tint hlen, tlen;\n\tstruct hsr_tag *hsr_tag;\n\tstruct hsr_sup_tag *hsr_stag;\n\tstruct hsr_sup_payload *hsr_sp;\n\tunsigned long irqflags;\n\n\thlen = LL_RESERVED_SPACE(master->dev);\n\ttlen = master->dev->needed_tailroom;\n\tskb = dev_alloc_skb(\n\t\t\tsizeof(struct hsr_tag) +\n\t\t\tsizeof(struct hsr_sup_tag) +\n\t\t\tsizeof(struct hsr_sup_payload) + hlen + tlen);\n\n\tif (skb == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, hlen);\n\n\tskb->dev = master->dev;\n\tskb->protocol = htons(hsrVer ? ETH_P_HSR : ETH_P_PRP);\n\tskb->priority = TC_PRIO_CONTROL;\n\n\tif (dev_hard_header(skb, skb->dev, (hsrVer ? ETH_P_HSR : ETH_P_PRP),\n\t\t\t    master->hsr->sup_multicast_addr,\n\t\t\t    skb->dev->dev_addr, skb->len) <= 0)\n\t\tgoto out;\n\tskb_reset_mac_header(skb);\n\n\tif (hsrVer > 0) {\n\t\thsr_tag = skb_put(skb, sizeof(struct hsr_tag));\n\t\thsr_tag->encap_proto = htons(ETH_P_PRP);\n\t\tset_hsr_tag_LSDU_size(hsr_tag, HSR_V1_SUP_LSDUSIZE);\n\t}\n\n\thsr_stag = skb_put(skb, sizeof(struct hsr_sup_tag));\n\tset_hsr_stag_path(hsr_stag, (hsrVer ? 0x0 : 0xf));\n\tset_hsr_stag_HSR_Ver(hsr_stag, hsrVer);\n\n\t/* From HSRv1 on we have separate supervision sequence numbers. */\n\tspin_lock_irqsave(&master->hsr->seqnr_lock, irqflags);\n\tif (hsrVer > 0) {\n\t\thsr_stag->sequence_nr = htons(master->hsr->sup_sequence_nr);\n\t\thsr_tag->sequence_nr = htons(master->hsr->sequence_nr);\n\t\tmaster->hsr->sup_sequence_nr++;\n\t\tmaster->hsr->sequence_nr++;\n\t} else {\n\t\thsr_stag->sequence_nr = htons(master->hsr->sequence_nr);\n\t\tmaster->hsr->sequence_nr++;\n\t}\n\tspin_unlock_irqrestore(&master->hsr->seqnr_lock, irqflags);\n\n\thsr_stag->HSR_TLV_Type = type;\n\t/* TODO: Why 12 in HSRv0? */\n\thsr_stag->HSR_TLV_Length = hsrVer ? sizeof(struct hsr_sup_payload) : 12;\n\n\t/* Payload: MacAddressA */\n\thsr_sp = skb_put(skb, sizeof(struct hsr_sup_payload));\n\tether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);\n\n\tif (skb_put_padto(skb, ETH_ZLEN + HSR_HLEN))\n\t\treturn;\n\n\thsr_forward_skb(skb, master);\n\treturn;\n\nout:\n\tWARN_ONCE(1, \"HSR: Could not send supervision frame\\n\");\n\tkfree_skb(skb);\n}\n\n\n/* Announce (supervision frame) timer function\n */\nstatic void hsr_announce(struct timer_list *t)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *master;\n\n\thsr = from_timer(hsr, t, announce_timer);\n\n\trcu_read_lock();\n\tmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\n\n\tif (hsr->announce_count < 3 && hsr->protVersion == 0) {\n\t\tsend_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE,\n\t\t\t\thsr->protVersion);\n\t\thsr->announce_count++;\n\n\t\thsr->announce_timer.expires = jiffies +\n\t\t\t\tmsecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);\n\t} else {\n\t\tsend_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK,\n\t\t\t\thsr->protVersion);\n\n\t\thsr->announce_timer.expires = jiffies +\n\t\t\t\tmsecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);\n\t}\n\n\tif (is_admin_up(master->dev))\n\t\tadd_timer(&hsr->announce_timer);\n\n\trcu_read_unlock();\n}\n\n\n/* According to comments in the declaration of struct net_device, this function\n * is \"Called from unregister, can be used to call free_netdev\". Ok then...\n */\nstatic void hsr_dev_destroy(struct net_device *hsr_dev)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\n\thsr = netdev_priv(hsr_dev);\n\n\trtnl_lock();\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\n\trtnl_unlock();\n\n\tdel_timer_sync(&hsr->prune_timer);\n\tdel_timer_sync(&hsr->announce_timer);\n\n\tsynchronize_rcu();\n}\n\nstatic const struct net_device_ops hsr_device_ops = {\n\t.ndo_change_mtu = hsr_dev_change_mtu,\n\t.ndo_open = hsr_dev_open,\n\t.ndo_stop = hsr_dev_close,\n\t.ndo_start_xmit = hsr_dev_xmit,\n\t.ndo_fix_features = hsr_fix_features,\n};\n\nstatic struct device_type hsr_type = {\n\t.name = \"hsr\",\n};\n\nvoid hsr_dev_setup(struct net_device *dev)\n{\n\teth_hw_addr_random(dev);\n\n\tether_setup(dev);\n\tdev->min_mtu = 0;\n\tdev->header_ops = &hsr_header_ops;\n\tdev->netdev_ops = &hsr_device_ops;\n\tSET_NETDEV_DEVTYPE(dev, &hsr_type);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = hsr_dev_destroy;\n\n\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |\n\t\t\t   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |\n\t\t\t   NETIF_F_HW_VLAN_CTAG_TX;\n\n\tdev->features = dev->hw_features;\n\n\t/* Prevent recursive tx locking */\n\tdev->features |= NETIF_F_LLTX;\n\t/* VLAN on top of HSR needs testing and probably some work on\n\t * hsr_header_create() etc.\n\t */\n\tdev->features |= NETIF_F_VLAN_CHALLENGED;\n\t/* Not sure about this. Taken from bridge code. netdev_features.h says\n\t * it means \"Does not change network namespaces\".\n\t */\n\tdev->features |= NETIF_F_NETNS_LOCAL;\n}\n\n\n/* Return true if dev is a HSR master; return false otherwise.\n */\ninline bool is_hsr_master(struct net_device *dev)\n{\n\treturn (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);\n}\n\n/* Default multicast address for HSR Supervision frames */\nstatic const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {\n\t0x01, 0x15, 0x4e, 0x00, 0x01, 0x00\n};\n\nint hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\n\t/* Make sure we recognize frames from ourselves in hsr_rcv() */\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\n\tspin_lock_init(&hsr->seqnr_lock);\n\t/* Overflow soon to find bugs easier: */\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\n\thsr->protVersion = protocol_version;\n\n\t/* FIXME: should I modify the value of these?\n\t *\n\t * - hsr_dev->flags - i.e.\n\t *\t\t\tIFF_MASTER/SLAVE?\n\t * - hsr_dev->priv_flags - i.e.\n\t *\t\t\tIFF_EBRIDGE?\n\t *\t\t\tIFF_TX_SKB_SHARING?\n\t *\t\t\tIFF_HSR_MASTER/SLAVE?\n\t */\n\n\t/* Make sure the 1st call to netif_carrier_on() gets through */\n\tnetif_carrier_off(hsr_dev);\n\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\tgoto err_add_port;\n\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\n\treturn 0;\n\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\nerr_add_port:\n\thsr_del_node(&hsr->self_node_db);\n\n\treturn res;\n}\n", "/* Copyright 2011-2014 Autronica Fire and Security AS\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n * Author(s):\n *\t2011-2014 Arvid Brodin, arvid.brodin@alten.se\n *\n * The HSR spec says never to forward the same frame twice on the same\n * interface. A frame is identified by its source MAC address and its HSR\n * sequence number. This code keeps track of senders and their sequence numbers\n * to allow filtering of duplicate frames, and to detect HSR ring errors.\n */\n\n#include <linux/if_ether.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include \"hsr_main.h\"\n#include \"hsr_framereg.h\"\n#include \"hsr_netlink.h\"\n\n\nstruct hsr_node {\n\tstruct list_head\tmac_list;\n\tunsigned char\t\tMacAddressA[ETH_ALEN];\n\tunsigned char\t\tMacAddressB[ETH_ALEN];\n\t/* Local slave through which AddrB frames are received from this node */\n\tenum hsr_port_type\tAddrB_port;\n\tunsigned long\t\ttime_in[HSR_PT_PORTS];\n\tbool\t\t\ttime_in_stale[HSR_PT_PORTS];\n\tu16\t\t\tseq_out[HSR_PT_PORTS];\n\tstruct rcu_head\t\trcu_head;\n};\n\n\n/*\tTODO: use hash lists for mac addresses (linux/jhash.h)?    */\n\n\n/* seq_nr_after(a, b) - return true if a is after (higher in sequence than) b,\n * false otherwise.\n */\nstatic bool seq_nr_after(u16 a, u16 b)\n{\n\t/* Remove inconsistency where\n\t * seq_nr_after(a, b) == seq_nr_before(a, b)\n\t */\n\tif ((int) b - a == 32768)\n\t\treturn false;\n\n\treturn (((s16) (b - a)) < 0);\n}\n#define seq_nr_before(a, b)\t\tseq_nr_after((b), (a))\n#define seq_nr_after_or_eq(a, b)\t(!seq_nr_before((a), (b)))\n#define seq_nr_before_or_eq(a, b)\t(!seq_nr_after((a), (b)))\n\n\nbool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr)\n{\n\tstruct hsr_node *node;\n\n\tnode = list_first_or_null_rcu(&hsr->self_node_db, struct hsr_node,\n\t\t\t\t      mac_list);\n\tif (!node) {\n\t\tWARN_ONCE(1, \"HSR: No self node\\n\");\n\t\treturn false;\n\t}\n\n\tif (ether_addr_equal(addr, node->MacAddressA))\n\t\treturn true;\n\tif (ether_addr_equal(addr, node->MacAddressB))\n\t\treturn true;\n\n\treturn false;\n}\n\n/* Search for mac entry. Caller must hold rcu read lock.\n */\nstatic struct hsr_node *find_node_by_AddrA(struct list_head *node_db,\n\t\t\t\t\t   const unsigned char addr[ETH_ALEN])\n{\n\tstruct hsr_node *node;\n\n\tlist_for_each_entry_rcu(node, node_db, mac_list) {\n\t\tif (ether_addr_equal(node->MacAddressA, addr))\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n\n/* Helper for device init; the self_node_db is used in hsr_rcv() to recognize\n * frames from self that's been looped over the HSR ring.\n */\nint hsr_create_self_node(struct list_head *self_node_db,\n\t\t\t unsigned char addr_a[ETH_ALEN],\n\t\t\t unsigned char addr_b[ETH_ALEN])\n{\n\tstruct hsr_node *node, *oldnode;\n\n\tnode = kmalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tether_addr_copy(node->MacAddressA, addr_a);\n\tether_addr_copy(node->MacAddressB, addr_b);\n\n\trcu_read_lock();\n\toldnode = list_first_or_null_rcu(self_node_db,\n\t\t\t\t\t\tstruct hsr_node, mac_list);\n\tif (oldnode) {\n\t\tlist_replace_rcu(&oldnode->mac_list, &node->mac_list);\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t\tkfree(oldnode);\n\t} else {\n\t\trcu_read_unlock();\n\t\tlist_add_tail_rcu(&node->mac_list, self_node_db);\n\t}\n\n\treturn 0;\n}\n\nvoid hsr_del_node(struct list_head *self_node_db)\n{\n\tstruct hsr_node *node;\n\n\trcu_read_lock();\n\tnode = list_first_or_null_rcu(self_node_db, struct hsr_node, mac_list);\n\trcu_read_unlock();\n\tif (node) {\n\t\tlist_del_rcu(&node->mac_list);\n\t\tkfree(node);\n\t}\n}\n\n/* Allocate an hsr_node and add it to node_db. 'addr' is the node's AddressA;\n * seq_out is used to initialize filtering of outgoing duplicate frames\n * originating from the newly added node.\n */\nstruct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],\n\t\t\t      u16 seq_out)\n{\n\tstruct hsr_node *node;\n\tunsigned long now;\n\tint i;\n\n\tnode = kzalloc(sizeof(*node), GFP_ATOMIC);\n\tif (!node)\n\t\treturn NULL;\n\n\tether_addr_copy(node->MacAddressA, addr);\n\n\t/* We are only interested in time diffs here, so use current jiffies\n\t * as initialization. (0 could trigger an spurious ring error warning).\n\t */\n\tnow = jiffies;\n\tfor (i = 0; i < HSR_PT_PORTS; i++)\n\t\tnode->time_in[i] = now;\n\tfor (i = 0; i < HSR_PT_PORTS; i++)\n\t\tnode->seq_out[i] = seq_out;\n\n\tlist_add_tail_rcu(&node->mac_list, node_db);\n\n\treturn node;\n}\n\n/* Get the hsr_node from which 'skb' was sent.\n */\nstruct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,\n\t\t\t      bool is_sup)\n{\n\tstruct list_head *node_db = &port->hsr->node_db;\n\tstruct hsr_node *node;\n\tstruct ethhdr *ethhdr;\n\tu16 seq_out;\n\n\tif (!skb_mac_header_was_set(skb))\n\t\treturn NULL;\n\n\tethhdr = (struct ethhdr *) skb_mac_header(skb);\n\n\tlist_for_each_entry_rcu(node, node_db, mac_list) {\n\t\tif (ether_addr_equal(node->MacAddressA, ethhdr->h_source))\n\t\t\treturn node;\n\t\tif (ether_addr_equal(node->MacAddressB, ethhdr->h_source))\n\t\t\treturn node;\n\t}\n\n\t/* Everyone may create a node entry, connected node to a HSR device. */\n\n\tif (ethhdr->h_proto == htons(ETH_P_PRP)\n\t\t\t|| ethhdr->h_proto == htons(ETH_P_HSR)) {\n\t\t/* Use the existing sequence_nr from the tag as starting point\n\t\t * for filtering duplicate frames.\n\t\t */\n\t\tseq_out = hsr_get_skb_sequence_nr(skb) - 1;\n\t} else {\n\t\t/* this is called also for frames from master port and\n\t\t * so warn only for non master ports\n\t\t */\n\t\tif (port->type != HSR_PT_MASTER)\n\t\t\tWARN_ONCE(1, \"%s: Non-HSR frame\\n\", __func__);\n\t\tseq_out = HSR_SEQNR_START;\n\t}\n\n\treturn hsr_add_node(node_db, ethhdr->h_source, seq_out);\n}\n\n/* Use the Supervision frame's info about an eventual MacAddressB for merging\n * nodes that has previously had their MacAddressB registered as a separate\n * node.\n */\nvoid hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,\n\t\t\t  struct hsr_port *port_rcv)\n{\n\tstruct ethhdr *ethhdr;\n\tstruct hsr_node *node_real;\n\tstruct hsr_sup_payload *hsr_sp;\n\tstruct list_head *node_db;\n\tint i;\n\n\tethhdr = (struct ethhdr *) skb_mac_header(skb);\n\n\t/* Leave the ethernet header. */\n\tskb_pull(skb, sizeof(struct ethhdr));\n\n\t/* And leave the HSR tag. */\n\tif (ethhdr->h_proto == htons(ETH_P_HSR))\n\t\tskb_pull(skb, sizeof(struct hsr_tag));\n\n\t/* And leave the HSR sup tag. */\n\tskb_pull(skb, sizeof(struct hsr_sup_tag));\n\n\thsr_sp = (struct hsr_sup_payload *) skb->data;\n\n\t/* Merge node_curr (registered on MacAddressB) into node_real */\n\tnode_db = &port_rcv->hsr->node_db;\n\tnode_real = find_node_by_AddrA(node_db, hsr_sp->MacAddressA);\n\tif (!node_real)\n\t\t/* No frame received from AddrA of this node yet */\n\t\tnode_real = hsr_add_node(node_db, hsr_sp->MacAddressA,\n\t\t\t\t\t HSR_SEQNR_START - 1);\n\tif (!node_real)\n\t\tgoto done; /* No mem */\n\tif (node_real == node_curr)\n\t\t/* Node has already been merged */\n\t\tgoto done;\n\n\tether_addr_copy(node_real->MacAddressB, ethhdr->h_source);\n\tfor (i = 0; i < HSR_PT_PORTS; i++) {\n\t\tif (!node_curr->time_in_stale[i] &&\n\t\t    time_after(node_curr->time_in[i], node_real->time_in[i])) {\n\t\t\tnode_real->time_in[i] = node_curr->time_in[i];\n\t\t\tnode_real->time_in_stale[i] = node_curr->time_in_stale[i];\n\t\t}\n\t\tif (seq_nr_after(node_curr->seq_out[i], node_real->seq_out[i]))\n\t\t\tnode_real->seq_out[i] = node_curr->seq_out[i];\n\t}\n\tnode_real->AddrB_port = port_rcv->type;\n\n\tlist_del_rcu(&node_curr->mac_list);\n\tkfree_rcu(node_curr, rcu_head);\n\ndone:\n\tskb_push(skb, sizeof(struct hsrv1_ethhdr_sp));\n}\n\n\n/* 'skb' is a frame meant for this host, that is to be passed to upper layers.\n *\n * If the frame was sent by a node's B interface, replace the source\n * address with that node's \"official\" address (MacAddressA) so that upper\n * layers recognize where it came from.\n */\nvoid hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb)\n{\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tmemcpy(&eth_hdr(skb)->h_source, node->MacAddressA, ETH_ALEN);\n}\n\n/* 'skb' is a frame meant for another host.\n * 'port' is the outgoing interface\n *\n * Substitute the target (dest) MAC address if necessary, so the it matches the\n * recipient interface MAC address, regardless of whether that is the\n * recipient's A or B interface.\n * This is needed to keep the packets flowing through switches that learn on\n * which \"side\" the different interfaces are.\n */\nvoid hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port)\n{\n\tstruct hsr_node *node_dst;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn;\n\n\tnode_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);\n\tif (!node_dst) {\n\t\tWARN_ONCE(1, \"%s: Unknown node\\n\", __func__);\n\t\treturn;\n\t}\n\tif (port->type != node_dst->AddrB_port)\n\t\treturn;\n\n\tether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);\n}\n\n\nvoid hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,\n\t\t\t   u16 sequence_nr)\n{\n\t/* Don't register incoming frames without a valid sequence number. This\n\t * ensures entries of restarted nodes gets pruned so that they can\n\t * re-register and resume communications.\n\t */\n\tif (seq_nr_before(sequence_nr, node->seq_out[port->type]))\n\t\treturn;\n\n\tnode->time_in[port->type] = jiffies;\n\tnode->time_in_stale[port->type] = false;\n}\n\n/* 'skb' is a HSR Ethernet frame (with a HSR tag inserted), with a valid\n * ethhdr->h_source address and skb->mac_header set.\n *\n * Return:\n *\t 1 if frame can be shown to have been sent recently on this interface,\n *\t 0 otherwise, or\n *\t negative error code on error\n */\nint hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,\n\t\t\t   u16 sequence_nr)\n{\n\tif (seq_nr_before_or_eq(sequence_nr, node->seq_out[port->type]))\n\t\treturn 1;\n\n\tnode->seq_out[port->type] = sequence_nr;\n\treturn 0;\n}\n\n\nstatic struct hsr_port *get_late_port(struct hsr_priv *hsr,\n\t\t\t\t      struct hsr_node *node)\n{\n\tif (node->time_in_stale[HSR_PT_SLAVE_A])\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (node->time_in_stale[HSR_PT_SLAVE_B])\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\n\tif (time_after(node->time_in[HSR_PT_SLAVE_B],\n\t\t       node->time_in[HSR_PT_SLAVE_A] +\n\t\t\t\t\tmsecs_to_jiffies(MAX_SLAVE_DIFF)))\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);\n\tif (time_after(node->time_in[HSR_PT_SLAVE_A],\n\t\t       node->time_in[HSR_PT_SLAVE_B] +\n\t\t\t\t\tmsecs_to_jiffies(MAX_SLAVE_DIFF)))\n\t\treturn hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);\n\n\treturn NULL;\n}\n\n\n/* Remove stale sequence_nr records. Called by timer every\n * HSR_LIFE_CHECK_INTERVAL (two seconds or so).\n */\nvoid hsr_prune_nodes(struct timer_list *t)\n{\n\tstruct hsr_priv *hsr = from_timer(hsr, t, prune_timer);\n\tstruct hsr_node *node;\n\tstruct hsr_port *port;\n\tunsigned long timestamp;\n\tunsigned long time_a, time_b;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(node, &hsr->node_db, mac_list) {\n\t\t/* Shorthand */\n\t\ttime_a = node->time_in[HSR_PT_SLAVE_A];\n\t\ttime_b = node->time_in[HSR_PT_SLAVE_B];\n\n\t\t/* Check for timestamps old enough to risk wrap-around */\n\t\tif (time_after(jiffies, time_a + MAX_JIFFY_OFFSET/2))\n\t\t\tnode->time_in_stale[HSR_PT_SLAVE_A] = true;\n\t\tif (time_after(jiffies, time_b + MAX_JIFFY_OFFSET/2))\n\t\t\tnode->time_in_stale[HSR_PT_SLAVE_B] = true;\n\n\t\t/* Get age of newest frame from node.\n\t\t * At least one time_in is OK here; nodes get pruned long\n\t\t * before both time_ins can get stale\n\t\t */\n\t\ttimestamp = time_a;\n\t\tif (node->time_in_stale[HSR_PT_SLAVE_A] ||\n\t\t    (!node->time_in_stale[HSR_PT_SLAVE_B] &&\n\t\t    time_after(time_b, time_a)))\n\t\t\ttimestamp = time_b;\n\n\t\t/* Warn of ring error only as long as we get frames at all */\n\t\tif (time_is_after_jiffies(timestamp +\n\t\t\t\t\tmsecs_to_jiffies(1.5*MAX_SLAVE_DIFF))) {\n\t\t\trcu_read_lock();\n\t\t\tport = get_late_port(hsr, node);\n\t\t\tif (port != NULL)\n\t\t\t\thsr_nl_ringerror(hsr, node->MacAddressA, port);\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\t/* Prune old entries */\n\t\tif (time_is_before_jiffies(timestamp +\n\t\t\t\t\tmsecs_to_jiffies(HSR_NODE_FORGET_TIME))) {\n\t\t\thsr_nl_nodedown(hsr, node->MacAddressA);\n\t\t\tlist_del_rcu(&node->mac_list);\n\t\t\t/* Note that we need to free this entry later: */\n\t\t\tkfree_rcu(node, rcu_head);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n\nvoid *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,\n\t\t\tunsigned char addr[ETH_ALEN])\n{\n\tstruct hsr_node *node;\n\n\tif (!_pos) {\n\t\tnode = list_first_or_null_rcu(&hsr->node_db,\n\t\t\t\t\t      struct hsr_node, mac_list);\n\t\tif (node)\n\t\t\tether_addr_copy(addr, node->MacAddressA);\n\t\treturn node;\n\t}\n\n\tnode = _pos;\n\tlist_for_each_entry_continue_rcu(node, &hsr->node_db, mac_list) {\n\t\tether_addr_copy(addr, node->MacAddressA);\n\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n\nint hsr_get_node_data(struct hsr_priv *hsr,\n\t\t      const unsigned char *addr,\n\t\t      unsigned char addr_b[ETH_ALEN],\n\t\t      unsigned int *addr_b_ifindex,\n\t\t      int *if1_age,\n\t\t      u16 *if1_seq,\n\t\t      int *if2_age,\n\t\t      u16 *if2_seq)\n{\n\tstruct hsr_node *node;\n\tstruct hsr_port *port;\n\tunsigned long tdiff;\n\n\n\trcu_read_lock();\n\tnode = find_node_by_AddrA(&hsr->node_db, addr);\n\tif (!node) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\t/* No such entry */\n\t}\n\n\tether_addr_copy(addr_b, node->MacAddressB);\n\n\ttdiff = jiffies - node->time_in[HSR_PT_SLAVE_A];\n\tif (node->time_in_stale[HSR_PT_SLAVE_A])\n\t\t*if1_age = INT_MAX;\n#if HZ <= MSEC_PER_SEC\n\telse if (tdiff > msecs_to_jiffies(INT_MAX))\n\t\t*if1_age = INT_MAX;\n#endif\n\telse\n\t\t*if1_age = jiffies_to_msecs(tdiff);\n\n\ttdiff = jiffies - node->time_in[HSR_PT_SLAVE_B];\n\tif (node->time_in_stale[HSR_PT_SLAVE_B])\n\t\t*if2_age = INT_MAX;\n#if HZ <= MSEC_PER_SEC\n\telse if (tdiff > msecs_to_jiffies(INT_MAX))\n\t\t*if2_age = INT_MAX;\n#endif\n\telse\n\t\t*if2_age = jiffies_to_msecs(tdiff);\n\n\t/* Present sequence numbers as if they were incoming on interface */\n\t*if1_seq = node->seq_out[HSR_PT_SLAVE_B];\n\t*if2_seq = node->seq_out[HSR_PT_SLAVE_A];\n\n\tif (node->AddrB_port != HSR_PT_NONE) {\n\t\tport = hsr_port_get_hsr(hsr, node->AddrB_port);\n\t\t*addr_b_ifindex = port->dev->ifindex;\n\t} else {\n\t\t*addr_b_ifindex = -1;\n\t}\n\n\trcu_read_unlock();\n\n\treturn 0;\n}\n", "/* Copyright 2011-2014 Autronica Fire and Security AS\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n * Author(s):\n *\t2011-2014 Arvid Brodin, arvid.brodin@alten.se\n */\n\n#ifndef __HSR_FRAMEREG_H\n#define __HSR_FRAMEREG_H\n\n#include \"hsr_main.h\"\n\nstruct hsr_node;\n\nvoid hsr_del_node(struct list_head *self_node_db);\nstruct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],\n\t\t\t      u16 seq_out);\nstruct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,\n\t\t\t      bool is_sup);\nvoid hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,\n\t\t\t  struct hsr_port *port);\nbool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr);\n\nvoid hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb);\nvoid hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port);\n\nvoid hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,\n\t\t\t   u16 sequence_nr);\nint hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,\n\t\t\t   u16 sequence_nr);\n\nvoid hsr_prune_nodes(struct timer_list *t);\n\nint hsr_create_self_node(struct list_head *self_node_db,\n\t\t\t unsigned char addr_a[ETH_ALEN],\n\t\t\t unsigned char addr_b[ETH_ALEN]);\n\nvoid *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,\n\t\t\tunsigned char addr[ETH_ALEN]);\n\nint hsr_get_node_data(struct hsr_priv *hsr,\n\t\t      const unsigned char *addr,\n\t\t      unsigned char addr_b[ETH_ALEN],\n\t\t      unsigned int *addr_b_ifindex,\n\t\t      int *if1_age,\n\t\t      u16 *if1_seq,\n\t\t      int *if2_age,\n\t\t      u16 *if2_seq);\n\n#endif /* __HSR_FRAMEREG_H */\n"], "filenames": ["net/hsr/hsr_device.c", "net/hsr/hsr_framereg.c", "net/hsr/hsr_framereg.h"], "buggy_code_start_loc": [489, 126, 18], "buggy_code_end_loc": [508, 126, 18], "fixing_code_start_loc": [489, 127, 19], "fixing_code_end_loc": [511, 139, 20], "type": "CWE-401", "message": "In the Linux kernel before 5.0.3, a memory leak exits in hsr_dev_finalize() in net/hsr/hsr_device.c if hsr_add_port fails to add a port, which may cause denial of service, aka CID-6caabe7f197d.", "other": {"cve": {"id": "CVE-2019-16995", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-30T13:15:11.073", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.0.3, a memory leak exits in hsr_dev_finalize() in net/hsr/hsr_device.c if hsr_add_port fails to add a port, which may cause denial of service, aka CID-6caabe7f197d."}, {"lang": "es", "value": "En el kernel de Linux versiones anterior a 5.0.3, se presenta una p\u00e9rdida de memoria en la funci\u00f3n hsr_dev_finalize() en el archivo net/hsr/hsr_device.c si hsr_add_port no puede agregar un puerto, lo que puede causar una denegaci\u00f3n de servicio, tambi\u00e9n se conoce como CID-6caabe7f197d."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.137", "matchCriteriaId": "BB34954F-85F0-4EC8-B5CA-B011ABBE5853"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4", "versionEndExcluding": "4.4.177", "matchCriteriaId": "9F072826-3124-4D61-AFB1-8AF3A3BB854A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9", "versionEndExcluding": "4.9.164", "matchCriteriaId": "716B1964-0D5D-4294-AB7C-EEE18888AC11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14", "versionEndExcluding": "4.14.107", "matchCriteriaId": "3D9802BC-B2CB-42CE-A05F-A69106C6AA49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.19", "versionEndExcluding": "4.19.30", "matchCriteriaId": "BC127C2C-98DF-49A8-BFE3-5705DFED3F97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "4.20.17", "matchCriteriaId": "98796F7D-2B92-4B5B-89FC-C3D626C8A63B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndExcluding": "5.0.3", "matchCriteriaId": "57A92A89-9014-451A-ADEE-E3A6E11EA415"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "2258D313-BAF7-482D-98E0-79F2A448287B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_a700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "952F55C9-7E7C-4539-9D08-E736B3488569"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_a700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9FED1B0D-F901-413A-85D9-05D4C427570D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h610s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FD7CFE0E-9D1E-4495-B302-89C3096FC0DF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h610s:-:*:*:*:*:*:*:*", "matchCriteriaId": "F63A3FA7-AAED-4A9D-9FDE-6195302DA0F6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:service_processor:-:*:*:*:*:*:*:*", "matchCriteriaId": "146A767F-DC04-454B-9913-17D3A2B5AAA4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.0.3", "source": "cve@mitre.org", "tags": ["Exploit", "Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6caabe7f197d3466d238f70915d65301f1716626", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6caabe7f197d3466d238f70915d65301f1716626", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191031-0005/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6caabe7f197d3466d238f70915d65301f1716626"}}