{"buggy_code": ["  # N    A large safe prime (N = 2q+1, where q is prime)\n  #      All arithmetic is done modulo N.\n  # g    A generator modulo N\n  # k    Multiplier parameter (k = H(N, g) in SRP-6a, k = 3 for legacy SRP-6)\n  # s    User's salt\n  # I    Username\n  # p    Cleartext Password\n  # H()  One-way hash function\n  # ^    (Modular) Exponentiation\n  # u    Random scrambling parameter\n  # a,b  Secret ephemeral values\n  # A,B  Public ephemeral values\n  # x    Private key (derived from p and s)\n  # v    Password verifier\n\nfrom __future__ import division\nimport os\nimport sys\nimport hashlib\nimport random\nimport ctypes\nimport time\nimport six\n\n\n_rfc5054_compat = False\n_no_username_in_x = False\n\ndef rfc5054_enable(enable=True):\n    global _rfc5054_compat\n    _rfc5054_compat = enable\n\ndef no_username_in_x(enable=True):\n    global _no_username_in_x\n    _no_username_in_x = enable\n\n\nSHA1   = 0\nSHA224 = 1\nSHA256 = 2\nSHA384 = 3\nSHA512 = 4\n\nNG_1024   = 0\nNG_2048   = 1\nNG_4096   = 2\nNG_8192   = 3\nNG_CUSTOM = 4\n\n_hash_map = { SHA1   : hashlib.sha1,\n              SHA224 : hashlib.sha224,\n              SHA256 : hashlib.sha256,\n              SHA384 : hashlib.sha384,\n              SHA512 : hashlib.sha512 }\n\n\n_ng_const = (\n# 1024-bit\n(six.b('''\\\nEEAF0AB9ADB38DD69C33F80AFA8FC5E86072618775FF3C0B9EA2314C9C256576D674DF7496\\\nEA81D3383B4813D692C6E0E0D5D8E250B98BE48E495C1D6089DAD15DC7D7B46154D6B6CE8E\\\nF4AD69B15D4982559B297BCF1885C529F566660E57EC68EDBC3C05726CC02FD4CBF4976EAA\\\n9AFD5138FE8376435B9FC61D2FC0EB06E3'''),\nsix.b(\"2\")),\n# 2048\n(six.b('''\\\nAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4\\\nA099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF60\\\n95179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF\\\n747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B907\\\n8717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB37861\\\n60279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DB\\\nFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73'''),\nsix.b(\"2\")),\n# 4096\n(six.b('''\\\nFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08\\\n8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B\\\n302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9\\\nA637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6\\\n49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8\\\nFD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\n670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C\\\n180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718\\\n3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D\\\n04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D\\\nB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226\\\n1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C\\\nBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC\\\nE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26\\\n99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB\\\n04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2\\\n233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127\\\nD5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199\\\nFFFFFFFFFFFFFFFF'''),\nsix.b(\"5\")),\n# 8192\n(six.b('''\\\nFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08\\\n8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B\\\n302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9\\\nA637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6\\\n49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8\\\nFD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\n670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C\\\n180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718\\\n3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D\\\n04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D\\\nB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226\\\n1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C\\\nBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC\\\nE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26\\\n99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB\\\n04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2\\\n233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127\\\nD5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492\\\n36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406\\\nAD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918\\\nDA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B33205151\\\n2BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03\\\nF482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97F\\\nBEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA\\\nCC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58B\\\nB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632\\\n387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E\\\n6DBE115974A3926F12FEE5E438777CB6A932DF8CD8BEC4D073B931BA\\\n3BC832B68D9DD300741FA7BF8AFC47ED2576F6936BA424663AAB639C\\\n5AE4F5683423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD9\\\n22222E04A4037C0713EB57A81A23F0C73473FC646CEA306B4BCBC886\\\n2F8385DDFA9D4B7FA2C087E879683303ED5BDD3A062B3CF5B3A278A6\\\n6D2A13F83F44F82DDF310EE074AB6A364597E899A0255DC164F31CC5\\\n0846851DF9AB48195DED7EA1B1D510BD7EE74D73FAF36BC31ECFA268\\\n359046F4EB879F924009438B481C6CD7889A002ED5EE382BC9190DA6\\\nFC026E479558E4475677E9AA9E3050E2765694DFC81F56E880B96E71\\\n60C980DD98EDD3DFFFFFFFFFFFFFFFFF'''),\nsix.b('13'))\n)\n\n\n\n#N_HEX  = \"AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73\"\n#G_HEX  = \"2\"\n#HNxorg = None\n\ndlls = list()\n\nplatform = sys.platform\nif platform == 'darwin':\n    dlls.append( ctypes.cdll.LoadLibrary('libssl.dylib') )\nelif 'win' in platform:\n    for d in ('libeay32.dll', 'libssl32.dll', 'ssleay32.dll'):\n        try:\n            dlls.append( ctypes.cdll.LoadLibrary(d) )\n        except:\n            pass\nelse:\n    try:\n        dlls.append( ctypes.cdll.LoadLibrary('libssl.so.10') )\n    except OSError:\n        try:\n            dlls.append( ctypes.cdll.LoadLibrary('libssl.so.1.0.0') )\n        except OSError:\n            dlls.append( ctypes.cdll.LoadLibrary('libssl.so') )\n\nclass BIGNUM_Struct (ctypes.Structure):\n    _fields_ = [ (\"d\",     ctypes.c_void_p),\n                 (\"top\",   ctypes.c_int),\n                 (\"dmax\",  ctypes.c_int),\n                 (\"neg\",   ctypes.c_int),\n                 (\"flags\", ctypes.c_int) ]\n\n\nclass BN_CTX_Struct (ctypes.Structure):\n    _fields_ = [ (\"_\", ctypes.c_byte) ]\n\n\nBIGNUM = ctypes.POINTER( BIGNUM_Struct )\nBN_CTX = ctypes.POINTER( BN_CTX_Struct )\n\n\ndef load_func( name, args, returns = ctypes.c_int):\n    d = sys.modules[ __name__ ].__dict__\n    f = None\n\n    for dll in dlls:\n        try:\n            f = getattr(dll, name)\n            f.argtypes = args\n            f.restype  = returns\n            d[ name ] = f\n            return\n        except:\n            pass\n    raise ImportError('Unable to load required functions from SSL dlls')\n\n\nload_func( 'BN_new',   [],         BIGNUM )\nload_func( 'BN_free',  [ BIGNUM ], None )\nload_func( 'BN_clear', [ BIGNUM ], None )\n\nload_func( 'BN_CTX_new',  []        , BN_CTX )\nload_func( 'BN_CTX_free', [ BN_CTX ], None   )\n\nload_func( 'BN_cmp',      [ BIGNUM, BIGNUM ], ctypes.c_int )\n\nload_func( 'BN_num_bits', [ BIGNUM ], ctypes.c_int )\n\nload_func( 'BN_add',     [ BIGNUM, BIGNUM, BIGNUM ] )\nload_func( 'BN_sub',     [ BIGNUM, BIGNUM, BIGNUM ] )\nload_func( 'BN_mul',     [ BIGNUM, BIGNUM, BIGNUM, BN_CTX ] )\nload_func( 'BN_div',     [ BIGNUM, BIGNUM, BIGNUM, BIGNUM, BN_CTX ] )\nload_func( 'BN_mod_exp', [ BIGNUM, BIGNUM, BIGNUM, BIGNUM, BN_CTX ] )\n\nload_func( 'BN_rand',    [ BIGNUM, ctypes.c_int, ctypes.c_int, ctypes.c_int ] )\n\nload_func( 'BN_bn2bin',  [ BIGNUM, ctypes.c_char_p ] )\nload_func( 'BN_bin2bn',  [ ctypes.c_char_p, ctypes.c_int, BIGNUM ], BIGNUM )\n\nload_func( 'BN_hex2bn',  [ ctypes.POINTER(BIGNUM), ctypes.c_char_p ] )\nload_func( 'BN_bn2hex',  [ BIGNUM ], ctypes.c_char_p )\n\nload_func( 'CRYPTO_free', [ ctypes.c_char_p ] )\n\nload_func( 'RAND_seed', [ ctypes.c_char_p, ctypes.c_int ] )\n\n\ndef BN_num_bytes(a):\n    return ((BN_num_bits(a)+7)//8)\n\n\ndef BN_mod(rem,m,d,ctx):\n    return BN_div(None, rem, m, d, ctx)\n\n\ndef BN_is_zero( n ):\n    return n[0].top == 0\n\n\ndef bn_to_bytes( n ):\n    b = ctypes.create_string_buffer( BN_num_bytes(n) )\n    BN_bn2bin(n, b)\n    return b.raw\n\n\ndef bytes_to_bn( dest_bn, bytes ):\n    BN_bin2bn(bytes, len(bytes), dest_bn)\n\n\ndef H_str( hash_class, dest_bn, s ):\n    d = hash_class(s).digest()\n    buff = ctypes.create_string_buffer( s )\n    BN_bin2bn(d, len(d), dest)\n\n\ndef H_bn( hash_class, dest, n ):\n    bin = ctypes.create_string_buffer( BN_num_bytes(n) )\n    BN_bn2bin(n, bin)\n    d = hash_class( bin.raw ).digest()\n    BN_bin2bn(d, len(d), dest)\n\n\ndef H_bn_bn( hash_class, dest, n1, n2, width ):\n    h    = hash_class()\n    bin1 = ctypes.create_string_buffer( BN_num_bytes(n1) )\n    bin2 = ctypes.create_string_buffer( BN_num_bytes(n2) )\n    BN_bn2bin(n1, bin1)\n    BN_bn2bin(n2, bin2)\n    if _rfc5054_compat:\n        h.update(bytes(width - len(bin1.raw)))\n    h.update( bin1.raw )\n    if _rfc5054_compat:\n        h.update(bytes(width - len(bin2.raw)))\n    h.update( bin2.raw )\n    d = h.digest()\n    BN_bin2bn(d, len(d), dest)\n\n\ndef H_bn_str( hash_class, dest, n, s ):\n    h   = hash_class()\n    bin = ctypes.create_string_buffer( BN_num_bytes(n) )\n    BN_bn2bin(n, bin)\n    h.update( bin.raw )\n    h.update( s )\n    d = h.digest()\n    BN_bin2bn(d, len(d), dest)\n\n\ndef calculate_x( hash_class, dest, salt, username, password ):\n    username = username.encode() if hasattr(username, 'encode') else username\n    password = password.encode() if hasattr(password, 'encode') else password\n    if _no_username_in_x:\n        username = six.b('')\n    up = hash_class(username + six.b(':') + password).digest()\n    H_bn_str( hash_class, dest, salt, up )\n\n\ndef update_hash( ctx, n ):\n    buff = ctypes.create_string_buffer( BN_num_bytes(n) )\n    BN_bn2bin(n, buff)\n    ctx.update( buff.raw )\n\n\ndef calculate_M( hash_class, N, g, I, s, A, B, K ):\n    I = I.encode() if hasattr(I, 'encode') else I\n    h = hash_class()\n    h.update( HNxorg( hash_class, N, g ) )\n    h.update( hash_class(I).digest() )\n    update_hash( h, s )\n    update_hash( h, A )\n    update_hash( h, B )\n    h.update( K )\n    return h.digest()\n\n\ndef calculate_H_AMK( hash_class, A, M, K ):\n    h = hash_class()\n    update_hash( h, A )\n    h.update( M )\n    h.update( K )\n    return h.digest()\n\n\ndef HNxorg( hash_class, N, g ):\n    bN = ctypes.create_string_buffer( BN_num_bytes(N) )\n    bg = ctypes.create_string_buffer( BN_num_bytes(g) )\n\n    BN_bn2bin(N, bN)\n    BN_bn2bin(g, bg)\n\n    padding = len(bN) - len(bg) if _rfc5054_compat else 0\n\n    hN = hash_class( bN.raw ).digest()\n    hg = hash_class( b''.join([ b'\\0'*padding, bg.raw ]) ).digest()\n\n    return six.b( ''.join( chr( six.indexbytes(hN, i) ^ six.indexbytes(hg, i) ) for i in range(0,len(hN)) ) )\n\n\ndef get_ngk( hash_class, ng_type, n_hex, g_hex, ctx ):\n    if ng_type < NG_CUSTOM:\n        n_hex, g_hex = _ng_const[ ng_type ]\n    N = BN_new()\n    g = BN_new()\n    k = BN_new()\n\n    BN_hex2bn( N, n_hex )\n    BN_hex2bn( g, g_hex )\n    H_bn_bn(hash_class, k, N, g, width=BN_num_bytes(N))\n    if _rfc5054_compat:\n        BN_mod(k, k, N, ctx)\n\n    return N, g, k\n\n\n\ndef create_salted_verification_key( username, password, hash_alg=SHA1, ng_type=NG_2048, n_hex=None, g_hex=None, salt_len=4 ):\n    if ng_type == NG_CUSTOM and (n_hex is None or g_hex is None):\n        raise ValueError(\"Both n_hex and g_hex are required when ng_type = NG_CUSTOM\")\n    s    = BN_new()\n    v    = BN_new()\n    x    = BN_new()\n    ctx  = BN_CTX_new()\n\n    hash_class = _hash_map[ hash_alg ]\n    N,g,k      = get_ngk( hash_class, ng_type, n_hex, g_hex, ctx )\n\n    BN_rand(s, salt_len * 8, -1, 0);\n\n    calculate_x( hash_class, x, s, username, password )\n\n    BN_mod_exp(v, g, x, N, ctx)\n\n    salt     = bn_to_bytes( s )\n    verifier = bn_to_bytes( v )\n\n    BN_free(s)\n    BN_free(v)\n    BN_free(x)\n    BN_free(N)\n    BN_free(g)\n    BN_free(k)\n    BN_CTX_free(ctx)\n\n    return salt, verifier\n\n\n\nclass Verifier (object):\n    def __init__(self,  username, bytes_s, bytes_v, bytes_A, hash_alg=SHA1, ng_type=NG_2048, n_hex=None, g_hex=None, bytes_b=None):\n        if ng_type == NG_CUSTOM and (n_hex is None or g_hex is None):\n            raise ValueError(\"Both n_hex and g_hex are required when ng_type = NG_CUSTOM\")\n        if bytes_b and len(bytes_b) != 32:\n            raise ValueError(\"32 bytes required for bytes_b\")\n        self.A     = BN_new()\n        self.B     = BN_new()\n        self.K     = None\n        self.S     = BN_new()\n        self.u     = BN_new()\n        self.b     = BN_new()\n        self.s     = BN_new()\n        self.v     = BN_new()\n        self.tmp1  = BN_new()\n        self.tmp2  = BN_new()\n        self.ctx   = BN_CTX_new()\n        self.I     = username\n        self.M     = None\n        self.H_AMK = None\n        self._authenticated = False\n\n        self.safety_failed = False\n\n        hash_class = _hash_map[ hash_alg ]\n        N,g,k      = get_ngk( hash_class, ng_type, n_hex, g_hex, self.ctx )\n\n        self.hash_class = hash_class\n        self.N          = N\n        self.g          = g\n        self.k          = k\n\n        bytes_to_bn( self.s, bytes_s )\n        bytes_to_bn( self.v, bytes_v )\n        bytes_to_bn( self.A, bytes_A )\n\n        # SRP-6a safety check\n        BN_mod(self.tmp1, self.A, N, self.ctx)\n\n        if BN_is_zero(self.tmp1):\n            self.safety_failed = True\n        else:\n            if bytes_b:\n                bytes_to_bn( self.b, bytes_b )\n            else:\n                BN_rand(self.b, 256, 0, 0)\n\n            # B = kv + g^b\n            BN_mul(self.tmp1, k, self.v, self.ctx)\n            BN_mod_exp(self.tmp2, g, self.b, N, self.ctx)\n            BN_add(self.B, self.tmp1, self.tmp2)\n            BN_mod(self.B, self.B, N, self.ctx)\n\n            H_bn_bn(hash_class, self.u, self.A, self.B, width=BN_num_bytes(N))\n\n            # S = (A *(v^u)) ^ b\n            BN_mod_exp(self.tmp1, self.v, self.u, N, self.ctx)\n            BN_mul(self.tmp2, self.A, self.tmp1, self.ctx)\n            BN_mod_exp(self.S, self.tmp2, self.b, N, self.ctx)\n\n            self.K = hash_class( bn_to_bytes(self.S) ).digest()\n\n            self.M     = calculate_M( hash_class, N, g, self.I, self.s, self.A, self.B, self.K )\n            self.H_AMK = calculate_H_AMK( hash_class, self.A, self.M, self.K )\n\n\n    def __del__(self):\n        if not hasattr(self, 'A'):\n            return # __init__ threw exception. no clean up required\n        BN_free(self.A)\n        BN_free(self.B)\n        BN_free(self.S)\n        BN_free(self.u)\n        BN_free(self.b)\n        BN_free(self.s)\n        BN_free(self.v)\n        BN_free(self.N)\n        BN_free(self.g)\n        BN_free(self.k)\n        BN_free(self.tmp1)\n        BN_free(self.tmp2)\n        BN_CTX_free(self.ctx)\n\n\n    def authenticated(self):\n        return self._authenticated\n\n\n    def get_username(self):\n        return self.I\n\n\n    def get_ephemeral_secret(self):\n        return bn_to_bytes(self.b)\n\n\n    def get_session_key(self):\n        return self.K if self._authenticated else None\n\n\n    # returns (bytes_s, bytes_B) on success, (None,None) if SRP-6a safety check fails\n    def get_challenge(self):\n        if self.safety_failed:\n            return None, None\n        else:\n            return (bn_to_bytes(self.s), bn_to_bytes(self.B))\n\n\n    def verify_session(self, user_M):\n        if user_M == self.M:\n            self._authenticated = True\n            return self.H_AMK\n\n\n\n\nclass User (object):\n    def __init__(self, username, password, hash_alg=SHA1, ng_type=NG_2048, n_hex=None, g_hex=None, bytes_a=None, bytes_A=None):\n        if ng_type == NG_CUSTOM and (n_hex is None or g_hex is None):\n            raise ValueError(\"Both n_hex and g_hex are required when ng_type = NG_CUSTOM\")\n        if bytes_a and len(bytes_a) != 32:\n            raise ValueError(\"32 bytes required for bytes_a\")\n        self.username = username\n        self.password = password\n        self.a     = BN_new()\n        self.A     = BN_new()\n        self.B     = BN_new()\n        self.s     = BN_new()\n        self.S     = BN_new()\n        self.u     = BN_new()\n        self.x     = BN_new()\n        self.v     = BN_new()\n        self.tmp1  = BN_new()\n        self.tmp2  = BN_new()\n        self.tmp3  = BN_new()\n        self.ctx   = BN_CTX_new()\n        self.M     = None\n        self.K     = None\n        self.H_AMK = None\n        self._authenticated = False\n\n        hash_class = _hash_map[ hash_alg ]\n        N,g,k      = get_ngk( hash_class, ng_type, n_hex, g_hex, self.ctx )\n\n        self.hash_class = hash_class\n        self.N          = N\n        self.g          = g\n        self.k          = k\n\n        if bytes_a:\n            bytes_to_bn( self.a, bytes_a )\n        else:\n            BN_rand(self.a, 256, 0, 0)\n\n        if bytes_A:\n            bytes_to_bn( self.A, bytes_A )\n        else:\n            BN_mod_exp(self.A, g, self.a, N, self.ctx)\n\n\n\n    def __del__(self):\n        if not hasattr(self, 'a'):\n            return # __init__ threw exception. no clean up required\n        BN_free(self.a)\n        BN_free(self.A)\n        BN_free(self.B)\n        BN_free(self.s)\n        BN_free(self.S)\n        BN_free(self.u)\n        BN_free(self.x)\n        BN_free(self.v)\n        BN_free(self.N)\n        BN_free(self.g)\n        BN_free(self.k)\n        BN_free(self.tmp1)\n        BN_free(self.tmp2)\n        BN_free(self.tmp3)\n        BN_CTX_free(self.ctx)\n\n\n    def authenticated(self):\n        return self._authenticated\n\n\n    def get_username(self):\n        return self.username\n\n\n    def get_ephemeral_secret(self):\n        return bn_to_bytes(self.a)\n\n\n    def get_session_key(self):\n        return self.K if self._authenticated else None\n\n\n    def start_authentication(self):\n        return (self.username, bn_to_bytes(self.A))\n\n\n    # Returns M or None if SRP-6a safety check is violated\n    def process_challenge(self, bytes_s, bytes_B):\n\n        hash_class = self.hash_class\n        N = self.N\n        g = self.g\n        k = self.k\n\n        bytes_to_bn( self.s, bytes_s )\n        bytes_to_bn( self.B, bytes_B )\n\n        # SRP-6a safety check\n        if BN_is_zero(self.B):\n            return None\n\n        H_bn_bn(hash_class, self.u, self.A, self.B, width=BN_num_bytes(N))\n\n        # SRP-6a safety check\n        if BN_is_zero(self.u):\n            return None\n\n        calculate_x( hash_class, self.x, self.s, self.username, self.password )\n\n        BN_mod_exp(self.v, g, self.x, N, self.ctx)\n\n        # S = (B - k*(g^x)) ^ (a + ux)\n\n        BN_mul(self.tmp1, self.u, self.x, self.ctx)\n        BN_add(self.tmp2, self.a, self.tmp1)            # tmp2 = (a + ux)\n        BN_mod_exp(self.tmp1, g, self.x, N, self.ctx)\n        BN_mul(self.tmp3, k, self.tmp1, self.ctx)       # tmp3 = k*(g^x)\n        BN_sub(self.tmp1, self.B, self.tmp3)            # tmp1 = (B - K*(g^x))\n        BN_mod_exp(self.S, self.tmp1, self.tmp2, N, self.ctx)\n\n        self.K     = hash_class( bn_to_bytes(self.S) ).digest()\n        self.M     = calculate_M( hash_class, N, g, self.username, self.s, self.A, self.B, self.K )\n        self.H_AMK = calculate_H_AMK( hash_class, self.A, self.M, self.K )\n\n        return self.M\n\n\n    def verify_session(self, host_HAMK):\n        if self.H_AMK == host_HAMK:\n            self._authenticated = True\n\n\n\n#---------------------------------------------------------\n# Init\n#\nRAND_seed( os.urandom(32), 32 )\n"], "fixing_code": ["  # N    A large safe prime (N = 2q+1, where q is prime)\n  #      All arithmetic is done modulo N.\n  # g    A generator modulo N\n  # k    Multiplier parameter (k = H(N, g) in SRP-6a, k = 3 for legacy SRP-6)\n  # s    User's salt\n  # I    Username\n  # p    Cleartext Password\n  # H()  One-way hash function\n  # ^    (Modular) Exponentiation\n  # u    Random scrambling parameter\n  # a,b  Secret ephemeral values\n  # A,B  Public ephemeral values\n  # x    Private key (derived from p and s)\n  # v    Password verifier\n\nfrom __future__ import division\nimport os\nimport sys\nimport hashlib\nimport random\nimport ctypes\nimport time\nimport six\n\n\n_rfc5054_compat = False\n_no_username_in_x = False\n\ndef rfc5054_enable(enable=True):\n    global _rfc5054_compat\n    _rfc5054_compat = enable\n\ndef no_username_in_x(enable=True):\n    global _no_username_in_x\n    _no_username_in_x = enable\n\n\nSHA1   = 0\nSHA224 = 1\nSHA256 = 2\nSHA384 = 3\nSHA512 = 4\n\nNG_1024   = 0\nNG_2048   = 1\nNG_4096   = 2\nNG_8192   = 3\nNG_CUSTOM = 4\n\n_hash_map = { SHA1   : hashlib.sha1,\n              SHA224 : hashlib.sha224,\n              SHA256 : hashlib.sha256,\n              SHA384 : hashlib.sha384,\n              SHA512 : hashlib.sha512 }\n\n\n_ng_const = (\n# 1024-bit\n(six.b('''\\\nEEAF0AB9ADB38DD69C33F80AFA8FC5E86072618775FF3C0B9EA2314C9C256576D674DF7496\\\nEA81D3383B4813D692C6E0E0D5D8E250B98BE48E495C1D6089DAD15DC7D7B46154D6B6CE8E\\\nF4AD69B15D4982559B297BCF1885C529F566660E57EC68EDBC3C05726CC02FD4CBF4976EAA\\\n9AFD5138FE8376435B9FC61D2FC0EB06E3'''),\nsix.b(\"2\")),\n# 2048\n(six.b('''\\\nAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4\\\nA099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF60\\\n95179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF\\\n747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B907\\\n8717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB37861\\\n60279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DB\\\nFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73'''),\nsix.b(\"2\")),\n# 4096\n(six.b('''\\\nFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08\\\n8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B\\\n302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9\\\nA637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6\\\n49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8\\\nFD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\n670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C\\\n180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718\\\n3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D\\\n04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D\\\nB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226\\\n1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C\\\nBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC\\\nE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26\\\n99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB\\\n04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2\\\n233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127\\\nD5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199\\\nFFFFFFFFFFFFFFFF'''),\nsix.b(\"5\")),\n# 8192\n(six.b('''\\\nFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08\\\n8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B\\\n302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9\\\nA637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6\\\n49286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8\\\nFD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D\\\n670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C\\\n180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF695581718\\\n3995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D\\\n04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7D\\\nB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D226\\\n1AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200C\\\nBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFC\\\nE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B26\\\n99C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB\\\n04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2\\\n233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127\\\nD5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934028492\\\n36C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406\\\nAD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918\\\nDA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B33205151\\\n2BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03\\\nF482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97F\\\nBEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AA\\\nCC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58B\\\nB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632\\\n387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E\\\n6DBE115974A3926F12FEE5E438777CB6A932DF8CD8BEC4D073B931BA\\\n3BC832B68D9DD300741FA7BF8AFC47ED2576F6936BA424663AAB639C\\\n5AE4F5683423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD9\\\n22222E04A4037C0713EB57A81A23F0C73473FC646CEA306B4BCBC886\\\n2F8385DDFA9D4B7FA2C087E879683303ED5BDD3A062B3CF5B3A278A6\\\n6D2A13F83F44F82DDF310EE074AB6A364597E899A0255DC164F31CC5\\\n0846851DF9AB48195DED7EA1B1D510BD7EE74D73FAF36BC31ECFA268\\\n359046F4EB879F924009438B481C6CD7889A002ED5EE382BC9190DA6\\\nFC026E479558E4475677E9AA9E3050E2765694DFC81F56E880B96E71\\\n60C980DD98EDD3DFFFFFFFFFFFFFFFFF'''),\nsix.b('13'))\n)\n\n\n\n#N_HEX  = \"AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73\"\n#G_HEX  = \"2\"\n#HNxorg = None\n\ndlls = list()\n\nplatform = sys.platform\nif platform == 'darwin':\n    dlls.append( ctypes.cdll.LoadLibrary('libssl.dylib') )\nelif 'win' in platform:\n    for d in ('libeay32.dll', 'libssl32.dll', 'ssleay32.dll'):\n        try:\n            dlls.append( ctypes.cdll.LoadLibrary(d) )\n        except:\n            pass\nelse:\n    try:\n        dlls.append( ctypes.cdll.LoadLibrary('libssl.so.10') )\n    except OSError:\n        try:\n            dlls.append( ctypes.cdll.LoadLibrary('libssl.so.1.0.0') )\n        except OSError:\n            dlls.append( ctypes.cdll.LoadLibrary('libssl.so') )\n\nclass BIGNUM_Struct (ctypes.Structure):\n    _fields_ = [ (\"d\",     ctypes.c_void_p),\n                 (\"top\",   ctypes.c_int),\n                 (\"dmax\",  ctypes.c_int),\n                 (\"neg\",   ctypes.c_int),\n                 (\"flags\", ctypes.c_int) ]\n\n\nclass BN_CTX_Struct (ctypes.Structure):\n    _fields_ = [ (\"_\", ctypes.c_byte) ]\n\n\nBIGNUM = ctypes.POINTER( BIGNUM_Struct )\nBN_CTX = ctypes.POINTER( BN_CTX_Struct )\n\n\ndef load_func( name, args, returns = ctypes.c_int):\n    d = sys.modules[ __name__ ].__dict__\n    f = None\n\n    for dll in dlls:\n        try:\n            f = getattr(dll, name)\n            f.argtypes = args\n            f.restype  = returns\n            d[ name ] = f\n            return\n        except:\n            pass\n    raise ImportError('Unable to load required functions from SSL dlls')\n\n\nload_func( 'BN_new',   [],         BIGNUM )\nload_func( 'BN_free',  [ BIGNUM ], None )\nload_func( 'BN_clear', [ BIGNUM ], None )\n\nload_func( 'BN_CTX_new',  []        , BN_CTX )\nload_func( 'BN_CTX_free', [ BN_CTX ], None   )\n\nload_func( 'BN_set_flags', [ BIGNUM, ctypes.c_int ], None )\nBN_FLG_CONSTTIME = 0x04\n\nload_func( 'BN_cmp',      [ BIGNUM, BIGNUM ], ctypes.c_int )\n\nload_func( 'BN_num_bits', [ BIGNUM ], ctypes.c_int )\n\nload_func( 'BN_add',     [ BIGNUM, BIGNUM, BIGNUM ] )\nload_func( 'BN_sub',     [ BIGNUM, BIGNUM, BIGNUM ] )\nload_func( 'BN_mul',     [ BIGNUM, BIGNUM, BIGNUM, BN_CTX ] )\nload_func( 'BN_div',     [ BIGNUM, BIGNUM, BIGNUM, BIGNUM, BN_CTX ] )\nload_func( 'BN_mod_exp', [ BIGNUM, BIGNUM, BIGNUM, BIGNUM, BN_CTX ] )\n\nload_func( 'BN_rand',    [ BIGNUM, ctypes.c_int, ctypes.c_int, ctypes.c_int ] )\n\nload_func( 'BN_bn2bin',  [ BIGNUM, ctypes.c_char_p ] )\nload_func( 'BN_bin2bn',  [ ctypes.c_char_p, ctypes.c_int, BIGNUM ], BIGNUM )\n\nload_func( 'BN_hex2bn',  [ ctypes.POINTER(BIGNUM), ctypes.c_char_p ] )\nload_func( 'BN_bn2hex',  [ BIGNUM ], ctypes.c_char_p )\n\nload_func( 'CRYPTO_free', [ ctypes.c_char_p ] )\n\nload_func( 'RAND_seed', [ ctypes.c_char_p, ctypes.c_int ] )\n\n\ndef BN_num_bytes(a):\n    return ((BN_num_bits(a)+7)//8)\n\n\ndef BN_mod(rem,m,d,ctx):\n    return BN_div(None, rem, m, d, ctx)\n\n\ndef BN_is_zero( n ):\n    return n[0].top == 0\n\n\ndef bn_to_bytes( n ):\n    b = ctypes.create_string_buffer( BN_num_bytes(n) )\n    BN_bn2bin(n, b)\n    return b.raw\n\n\ndef bytes_to_bn( dest_bn, bytes ):\n    BN_bin2bn(bytes, len(bytes), dest_bn)\n\n\ndef H_str( hash_class, dest_bn, s ):\n    d = hash_class(s).digest()\n    buff = ctypes.create_string_buffer( s )\n    BN_bin2bn(d, len(d), dest)\n\n\ndef H_bn( hash_class, dest, n ):\n    bin = ctypes.create_string_buffer( BN_num_bytes(n) )\n    BN_bn2bin(n, bin)\n    d = hash_class( bin.raw ).digest()\n    BN_bin2bn(d, len(d), dest)\n\n\ndef H_bn_bn( hash_class, dest, n1, n2, width ):\n    h    = hash_class()\n    bin1 = ctypes.create_string_buffer( BN_num_bytes(n1) )\n    bin2 = ctypes.create_string_buffer( BN_num_bytes(n2) )\n    BN_bn2bin(n1, bin1)\n    BN_bn2bin(n2, bin2)\n    if _rfc5054_compat:\n        h.update(bytes(width - len(bin1.raw)))\n    h.update( bin1.raw )\n    if _rfc5054_compat:\n        h.update(bytes(width - len(bin2.raw)))\n    h.update( bin2.raw )\n    d = h.digest()\n    BN_bin2bn(d, len(d), dest)\n\n\ndef H_bn_str( hash_class, dest, n, s ):\n    h   = hash_class()\n    bin = ctypes.create_string_buffer( BN_num_bytes(n) )\n    BN_bn2bin(n, bin)\n    h.update( bin.raw )\n    h.update( s )\n    d = h.digest()\n    BN_bin2bn(d, len(d), dest)\n\n\ndef calculate_x( hash_class, dest, salt, username, password ):\n    username = username.encode() if hasattr(username, 'encode') else username\n    password = password.encode() if hasattr(password, 'encode') else password\n    if _no_username_in_x:\n        username = six.b('')\n    up = hash_class(username + six.b(':') + password).digest()\n    H_bn_str( hash_class, dest, salt, up )\n    BN_set_flags(dest, BN_FLG_CONSTTIME)\n\n\ndef update_hash( ctx, n ):\n    buff = ctypes.create_string_buffer( BN_num_bytes(n) )\n    BN_bn2bin(n, buff)\n    ctx.update( buff.raw )\n\n\ndef calculate_M( hash_class, N, g, I, s, A, B, K ):\n    I = I.encode() if hasattr(I, 'encode') else I\n    h = hash_class()\n    h.update( HNxorg( hash_class, N, g ) )\n    h.update( hash_class(I).digest() )\n    update_hash( h, s )\n    update_hash( h, A )\n    update_hash( h, B )\n    h.update( K )\n    return h.digest()\n\n\ndef calculate_H_AMK( hash_class, A, M, K ):\n    h = hash_class()\n    update_hash( h, A )\n    h.update( M )\n    h.update( K )\n    return h.digest()\n\n\ndef HNxorg( hash_class, N, g ):\n    bN = ctypes.create_string_buffer( BN_num_bytes(N) )\n    bg = ctypes.create_string_buffer( BN_num_bytes(g) )\n\n    BN_bn2bin(N, bN)\n    BN_bn2bin(g, bg)\n\n    padding = len(bN) - len(bg) if _rfc5054_compat else 0\n\n    hN = hash_class( bN.raw ).digest()\n    hg = hash_class( b''.join([ b'\\0'*padding, bg.raw ]) ).digest()\n\n    return six.b( ''.join( chr( six.indexbytes(hN, i) ^ six.indexbytes(hg, i) ) for i in range(0,len(hN)) ) )\n\n\ndef get_ngk( hash_class, ng_type, n_hex, g_hex, ctx ):\n    if ng_type < NG_CUSTOM:\n        n_hex, g_hex = _ng_const[ ng_type ]\n    N = BN_new()\n    g = BN_new()\n    k = BN_new()\n\n    BN_hex2bn( N, n_hex )\n    BN_hex2bn( g, g_hex )\n    H_bn_bn(hash_class, k, N, g, width=BN_num_bytes(N))\n    if _rfc5054_compat:\n        BN_mod(k, k, N, ctx)\n\n    return N, g, k\n\n\n\ndef create_salted_verification_key( username, password, hash_alg=SHA1, ng_type=NG_2048, n_hex=None, g_hex=None, salt_len=4 ):\n    if ng_type == NG_CUSTOM and (n_hex is None or g_hex is None):\n        raise ValueError(\"Both n_hex and g_hex are required when ng_type = NG_CUSTOM\")\n    s    = BN_new()\n    v    = BN_new()\n    x    = BN_new()\n    ctx  = BN_CTX_new()\n\n    hash_class = _hash_map[ hash_alg ]\n    N,g,k      = get_ngk( hash_class, ng_type, n_hex, g_hex, ctx )\n\n    BN_rand(s, salt_len * 8, -1, 0);\n\n    calculate_x( hash_class, x, s, username, password )\n\n    BN_mod_exp(v, g, x, N, ctx)\n\n    salt     = bn_to_bytes( s )\n    verifier = bn_to_bytes( v )\n\n    BN_free(s)\n    BN_free(v)\n    BN_free(x)\n    BN_free(N)\n    BN_free(g)\n    BN_free(k)\n    BN_CTX_free(ctx)\n\n    return salt, verifier\n\n\n\nclass Verifier (object):\n    def __init__(self,  username, bytes_s, bytes_v, bytes_A, hash_alg=SHA1, ng_type=NG_2048, n_hex=None, g_hex=None, bytes_b=None):\n        if ng_type == NG_CUSTOM and (n_hex is None or g_hex is None):\n            raise ValueError(\"Both n_hex and g_hex are required when ng_type = NG_CUSTOM\")\n        if bytes_b and len(bytes_b) != 32:\n            raise ValueError(\"32 bytes required for bytes_b\")\n        self.A     = BN_new()\n        self.B     = BN_new()\n        self.K     = None\n        self.S     = BN_new()\n        self.u     = BN_new()\n        self.b     = BN_new()\n        self.s     = BN_new()\n        self.v     = BN_new()\n        self.tmp1  = BN_new()\n        self.tmp2  = BN_new()\n        self.ctx   = BN_CTX_new()\n        self.I     = username\n        self.M     = None\n        self.H_AMK = None\n        self._authenticated = False\n\n        self.safety_failed = False\n\n        hash_class = _hash_map[ hash_alg ]\n        N,g,k      = get_ngk( hash_class, ng_type, n_hex, g_hex, self.ctx )\n\n        self.hash_class = hash_class\n        self.N          = N\n        self.g          = g\n        self.k          = k\n\n        bytes_to_bn( self.s, bytes_s )\n        bytes_to_bn( self.v, bytes_v )\n        bytes_to_bn( self.A, bytes_A )\n\n        # SRP-6a safety check\n        BN_mod(self.tmp1, self.A, N, self.ctx)\n\n        if BN_is_zero(self.tmp1):\n            self.safety_failed = True\n        else:\n            if bytes_b:\n                bytes_to_bn( self.b, bytes_b )\n            else:\n                BN_rand(self.b, 256, 0, 0)\n            BN_set_flags(self.b, BN_FLG_CONSTTIME)\n\n            # B = kv + g^b\n            BN_mul(self.tmp1, k, self.v, self.ctx)\n            BN_mod_exp(self.tmp2, g, self.b, N, self.ctx)\n            BN_add(self.B, self.tmp1, self.tmp2)\n            BN_mod(self.B, self.B, N, self.ctx)\n\n            H_bn_bn(hash_class, self.u, self.A, self.B, width=BN_num_bytes(N))\n\n            # S = (A *(v^u)) ^ b\n            BN_mod_exp(self.tmp1, self.v, self.u, N, self.ctx)\n            BN_mul(self.tmp2, self.A, self.tmp1, self.ctx)\n            BN_mod_exp(self.S, self.tmp2, self.b, N, self.ctx)\n\n            self.K = hash_class( bn_to_bytes(self.S) ).digest()\n\n            self.M     = calculate_M( hash_class, N, g, self.I, self.s, self.A, self.B, self.K )\n            self.H_AMK = calculate_H_AMK( hash_class, self.A, self.M, self.K )\n\n\n    def __del__(self):\n        if not hasattr(self, 'A'):\n            return # __init__ threw exception. no clean up required\n        BN_free(self.A)\n        BN_free(self.B)\n        BN_free(self.S)\n        BN_free(self.u)\n        BN_free(self.b)\n        BN_free(self.s)\n        BN_free(self.v)\n        BN_free(self.N)\n        BN_free(self.g)\n        BN_free(self.k)\n        BN_free(self.tmp1)\n        BN_free(self.tmp2)\n        BN_CTX_free(self.ctx)\n\n\n    def authenticated(self):\n        return self._authenticated\n\n\n    def get_username(self):\n        return self.I\n\n\n    def get_ephemeral_secret(self):\n        return bn_to_bytes(self.b)\n\n\n    def get_session_key(self):\n        return self.K if self._authenticated else None\n\n\n    # returns (bytes_s, bytes_B) on success, (None,None) if SRP-6a safety check fails\n    def get_challenge(self):\n        if self.safety_failed:\n            return None, None\n        else:\n            return (bn_to_bytes(self.s), bn_to_bytes(self.B))\n\n\n    def verify_session(self, user_M):\n        if user_M == self.M:\n            self._authenticated = True\n            return self.H_AMK\n\n\n\n\nclass User (object):\n    def __init__(self, username, password, hash_alg=SHA1, ng_type=NG_2048, n_hex=None, g_hex=None, bytes_a=None, bytes_A=None):\n        if ng_type == NG_CUSTOM and (n_hex is None or g_hex is None):\n            raise ValueError(\"Both n_hex and g_hex are required when ng_type = NG_CUSTOM\")\n        if bytes_a and len(bytes_a) != 32:\n            raise ValueError(\"32 bytes required for bytes_a\")\n        self.username = username\n        self.password = password\n        self.a     = BN_new()\n        self.A     = BN_new()\n        self.B     = BN_new()\n        self.s     = BN_new()\n        self.S     = BN_new()\n        self.u     = BN_new()\n        self.x     = BN_new()\n        self.v     = BN_new()\n        self.tmp1  = BN_new()\n        self.tmp2  = BN_new()\n        self.tmp3  = BN_new()\n        self.ctx   = BN_CTX_new()\n        self.M     = None\n        self.K     = None\n        self.H_AMK = None\n        self._authenticated = False\n\n        hash_class = _hash_map[ hash_alg ]\n        N,g,k      = get_ngk( hash_class, ng_type, n_hex, g_hex, self.ctx )\n\n        self.hash_class = hash_class\n        self.N          = N\n        self.g          = g\n        self.k          = k\n\n        if bytes_a:\n            bytes_to_bn( self.a, bytes_a )\n        else:\n            BN_rand(self.a, 256, 0, 0)\n\n        if bytes_A:\n            bytes_to_bn( self.A, bytes_A )\n        else:\n            BN_set_flags(self.a, BN_FLG_CONSTTIME)\n            BN_mod_exp(self.A, g, self.a, N, self.ctx)\n\n\n\n    def __del__(self):\n        if not hasattr(self, 'a'):\n            return # __init__ threw exception. no clean up required\n        BN_free(self.a)\n        BN_free(self.A)\n        BN_free(self.B)\n        BN_free(self.s)\n        BN_free(self.S)\n        BN_free(self.u)\n        BN_free(self.x)\n        BN_free(self.v)\n        BN_free(self.N)\n        BN_free(self.g)\n        BN_free(self.k)\n        BN_free(self.tmp1)\n        BN_free(self.tmp2)\n        BN_free(self.tmp3)\n        BN_CTX_free(self.ctx)\n\n\n    def authenticated(self):\n        return self._authenticated\n\n\n    def get_username(self):\n        return self.username\n\n\n    def get_ephemeral_secret(self):\n        return bn_to_bytes(self.a)\n\n\n    def get_session_key(self):\n        return self.K if self._authenticated else None\n\n\n    def start_authentication(self):\n        return (self.username, bn_to_bytes(self.A))\n\n\n    # Returns M or None if SRP-6a safety check is violated\n    def process_challenge(self, bytes_s, bytes_B):\n\n        hash_class = self.hash_class\n        N = self.N\n        g = self.g\n        k = self.k\n\n        bytes_to_bn( self.s, bytes_s )\n        bytes_to_bn( self.B, bytes_B )\n\n        # SRP-6a safety check\n        if BN_is_zero(self.B):\n            return None\n\n        H_bn_bn(hash_class, self.u, self.A, self.B, width=BN_num_bytes(N))\n\n        # SRP-6a safety check\n        if BN_is_zero(self.u):\n            return None\n\n        calculate_x( hash_class, self.x, self.s, self.username, self.password )\n\n        BN_mod_exp(self.v, g, self.x, N, self.ctx)\n\n        # S = (B - k*(g^x)) ^ (a + ux)\n\n        BN_mul(self.tmp1, self.u, self.x, self.ctx)\n        BN_add(self.tmp2, self.a, self.tmp1)            # tmp2 = (a + ux)\n        BN_mod_exp(self.tmp1, g, self.x, N, self.ctx)\n        BN_mul(self.tmp3, k, self.tmp1, self.ctx)       # tmp3 = k*(g^x)\n        BN_sub(self.tmp1, self.B, self.tmp3)            # tmp1 = (B - K*(g^x))\n        BN_mod_exp(self.S, self.tmp1, self.tmp2, N, self.ctx)\n\n        self.K     = hash_class( bn_to_bytes(self.S) ).digest()\n        self.M     = calculate_M( hash_class, N, g, self.username, self.s, self.A, self.B, self.K )\n        self.H_AMK = calculate_H_AMK( hash_class, self.A, self.M, self.K )\n\n        return self.M\n\n\n    def verify_session(self, host_HAMK):\n        if self.H_AMK == host_HAMK:\n            self._authenticated = True\n\n\n\n#---------------------------------------------------------\n# Init\n#\nRAND_seed( os.urandom(32), 32 )\n"], "filenames": ["srp/_ctsrp.py"], "buggy_code_start_loc": [203], "buggy_code_end_loc": [543], "fixing_code_start_loc": [204], "fixing_code_end_loc": [550], "type": "CWE-203", "message": "A vulnerability, which was classified as problematic, has been found in cocagne pysrp up to 1.0.16. This issue affects the function calculate_x of the file srp/_ctsrp.py. The manipulation leads to information exposure through discrepancy. Upgrading to version 1.0.17 is able to address this issue. The name of the patch is dba52642f5e95d3da7af1780561213ee6053195f. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216875.", "other": {"cve": {"id": "CVE-2021-4286", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-27T11:15:10.557", "lastModified": "2023-01-06T06:01:43.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, has been found in cocagne pysrp up to 1.0.16. This issue affects the function calculate_x of the file srp/_ctsrp.py. The manipulation leads to information exposure through discrepancy. Upgrading to version 1.0.17 is able to address this issue. The name of the patch is dba52642f5e95d3da7af1780561213ee6053195f. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216875."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pysrp_project:pysrp:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.17", "matchCriteriaId": "F2121A2F-3095-4E37-B00A-2D6F1AC7DE71"}]}]}], "references": [{"url": "https://github.com/cocagne/pysrp/commit/dba52642f5e95d3da7af1780561213ee6053195f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cocagne/pysrp/pull/43", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cocagne/pysrp/releases/tag/1.0.17", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216875", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216875", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cocagne/pysrp/commit/dba52642f5e95d3da7af1780561213ee6053195f"}}