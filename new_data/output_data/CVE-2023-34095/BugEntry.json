{"buggy_code": ["#include \"cpdb-frontend.h\"\n\nstatic void                 on_printer_added                (GDBusConnection *          connection,\n                                                             const gchar *              sender_name,\n                                                             const gchar *              object_path,\n                                                             const gchar *              interface_name,\n                                                             const gchar *              signal_name,\n                                                             GVariant *                 parameters,\n                                                             gpointer                   user_data);\nstatic void                 on_printer_removed              (GDBusConnection *          connection,\n                                                             const gchar *              sender_name,\n                                                             const gchar *              object_path,\n                                                             const gchar *              interface_name,\n                                                             const gchar *              signal_name,\n                                                             GVariant *                 parameters,\n                                                             gpointer                   user_data);\nstatic void                 on_printer_state_changed        (GDBusConnection *          connection,\n                                                             const gchar *              sender_name,\n                                                             const gchar *              object_path,\n                                                             const gchar *              interface_name,\n                                                             const gchar *              signal_name,\n                                                             GVariant *                 parameters,\n                                                             gpointer                   user_data);\n\nstatic void                 on_name_acquired                (GDBusConnection *          connection,\n                                                             const gchar *              name,\n                                                            gpointer                   user_data);\nstatic void                 on_name_lost                    (GDBusConnection *          connection,\n                                                             const gchar *              name,\n                                                             gpointer                   user_data);\n\nstatic void                 fetchPrinterListFromBackend     (cpdb_frontend_obj_t *      frontend_obj,\n                                                             const char *               backend);\n                                             \nstatic void                 cpdbActivateBackends            (cpdb_frontend_obj_t *      frontend_obj);\n\nstatic GList *              cpdbLoadDefaultPrinters         (const char *               path);\n\nstatic int                  cpdbSetDefaultPrinter           (const char *               path,\n                                                             cpdb_printer_obj_t *       printer_obj);\n\nstatic void                 cpdbFillBasicOptions            (cpdb_printer_obj_t *       printer_obj,\n                                                             GVariant *                 variant);\n\nstatic void                 cpdbDeleteTranslations          (cpdb_printer_obj_t *       printer_obj);\n\nstatic void                 cpdbUnpackOptions               (int                        num_options,\n                                                             GVariant *                 var,\n                                                             int                        num_media,\n                                                             GVariant *                 media_var,\n                                                             cpdb_options_t *           options);\nstatic void                 cpdbUnpackJobArray              (GVariant *                 var,\n                                                             int                        num_jobs,\n                                                             cpdb_job_t *               jobs,\n                                                             char *                     backend_name);\nstatic GHashTable *         cpdbUnpackTranslations          (GVariant *                 translations);\n\n/**\n________________________________________________ cpdb_frontend_obj_t __________________________________________\n\n**/\n\ncpdb_frontend_obj_t *cpdbGetNewFrontendObj(const char *instance_name,\n                                           cpdb_printer_callback printer_cb)\n{\n    cpdb_frontend_obj_t *f = g_new0(cpdb_frontend_obj_t, 1);\n    \n    f->skeleton = print_frontend_skeleton_new();\n    f->connection = NULL;\n    f->own_id = 0;\n    f->name_done = FALSE;\n    if (instance_name == NULL)\n        f->bus_name = cpdbGetStringCopy(CPDB_DIALOG_BUS_NAME);\n    else\n        f->bus_name = cpdbConcat(CPDB_DIALOG_BUS_NAME, instance_name);\n    f->printer_cb = printer_cb;\n    f->num_backends = 0;\n    f->backend = g_hash_table_new_full(g_str_hash,\n                                       g_str_equal,\n                                       free,\n                                       g_object_unref);\n    f->num_printers = 0;\n    f->printer = g_hash_table_new_full(g_str_hash,\n                                       g_str_equal,\n                                       free,\n                                       NULL);\n    f->last_saved_settings = cpdbReadSettingsFromDisk();\n    return f;\n}\n\nvoid cpdbDeleteFrontendObj(cpdb_frontend_obj_t *f)\n{\n    if (f == NULL)\n        return;\n    logdebug(\"Deleting frontend obj %s\\n\", f->bus_name);\n\n    cpdbDisconnectFromDBus(f);\n\n    if (f->skeleton)\n        g_object_unref(f->skeleton);\n    if (f->bus_name)\n        free(f->bus_name);\n    if (f->backend)\n        g_hash_table_destroy(f->backend);\n    if (f->printer)\n        g_hash_table_destroy(f->printer);\n    if (f->last_saved_settings)\n        cpdbDeleteSettings(f->last_saved_settings);\n    \n    free(f);\n}\n\nstatic void on_printer_added(GDBusConnection *connection,\n                             const gchar *sender_name,\n                             const gchar *object_path,\n                             const gchar *interface_name,\n                             const gchar *signal_name,\n                             GVariant *parameters,\n                             gpointer user_data)\n{\n    cpdb_frontend_obj_t *f = (cpdb_frontend_obj_t *)user_data;\n    cpdb_printer_obj_t *p = cpdbGetNewPrinterObj();\n    \n    /* If some previously saved settings were retrieved, \n     * use them in this new cpdb_printer_obj_t */\n    if (f->last_saved_settings != NULL)\n    {\n        cpdbCopySettings(f->last_saved_settings, p->settings);\n    }\n    cpdbFillBasicOptions(p, parameters);\n    cpdbAddPrinter(f, p);\n    f->printer_cb(f, p, CPDB_CHANGE_PRINTER_ADDED);\n}\n\nstatic void on_printer_removed(GDBusConnection *connection,\n                               const gchar *sender_name,\n                               const gchar *object_path,\n                               const gchar *interface_name,\n                               const gchar *signal_name,\n                               GVariant *parameters,\n                               gpointer user_data)\n{\n    cpdb_frontend_obj_t *f = (cpdb_frontend_obj_t *)user_data;\n    char *printer_id;\n    char *backend_name;\n    \n    g_variant_get(parameters, \"(ss)\", &printer_id, &backend_name);\n    cpdb_printer_obj_t *p = cpdbRemovePrinter(f, printer_id, backend_name);\n    f->printer_cb(f, p, CPDB_CHANGE_PRINTER_REMOVED);\n}\n\nstatic void on_printer_state_changed(GDBusConnection *connection,\n                                     const gchar *sender_name,\n                                     const gchar *object_path,\n                                     const gchar *interface_name,\n                                     const gchar *signal_name,\n                                     GVariant *parameters,\n                                     gpointer user_data)\n{\n    cpdb_frontend_obj_t *f = (cpdb_frontend_obj_t *) user_data;\n    gboolean printer_is_accepting_jobs;\n    char *printer_id, *printer_state, *backend_name;\n\n    g_variant_get(parameters, \"(ssbs)\", &printer_id, &printer_state,\n                    &printer_is_accepting_jobs, &backend_name);\n    cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n    if (p->state)\n        free(p->state);\n    p->state = cpdbGetStringCopy(printer_state);\n    p->accepting_jobs = printer_is_accepting_jobs;\n    f->printer_cb(f, p, CPDB_CHANGE_PRINTER_STATE_CHANGED);\n}\n\nstatic void on_name_acquired(GDBusConnection *connection,\n                             const gchar *name,\n                             gpointer user_data)\n{\n    GError *error = NULL;\n    cpdb_frontend_obj_t *f = user_data;\n\n    logdebug(\"Acquired bus name %s\\n\", name);\n    \n    g_dbus_connection_signal_subscribe(connection,\n                                       NULL,                            //Sender name\n                                       \"org.openprinting.PrintBackend\", //Sender interface\n                                       CPDB_SIGNAL_PRINTER_ADDED,       //Signal name\n                                       NULL,                            /**match on all object paths**/\n                                       NULL,                            /**match on all arguments**/\n                                       0,                               //Flags\n                                       on_printer_added,                //callback\n                                       user_data,                       //user_data\n                                       NULL);\n\n    g_dbus_connection_signal_subscribe(connection,\n                                       NULL,                            //Sender name\n                                       \"org.openprinting.PrintBackend\", //Sender interface\n                                       CPDB_SIGNAL_PRINTER_REMOVED,     //Signal name\n                                       NULL,                            /**match on all object paths**/\n                                       NULL,                            /**match on all arguments**/\n                                       0,                               //Flags\n                                       on_printer_removed,              //callback\n                                       user_data,                       //user_data\n                                       NULL);\n    g_dbus_connection_signal_subscribe(connection,\n                                       NULL,                                //Sender name\n                                       \"org.openprinting.PrintBackend\",     //Sender interface\n                                       CPDB_SIGNAL_PRINTER_STATE_CHANGED,   //Signal name\n                                       NULL,                                /**match on all object paths**/\n                                       NULL,                                /**match on all arguments**/\n                                       0,                                   //Flags\n                                       on_printer_state_changed,            //callback\n                                       user_data,                           //user_data\n                                       NULL);\n\n    g_dbus_interface_skeleton_export(G_DBUS_INTERFACE_SKELETON(f->skeleton),\n                                     connection, \n                                     CPDB_DIALOG_OBJ_PATH,\n                                     &error);\n    if (error)\n    {\n        logerror(\"Error exporting frontend interface : %s\\n\", error->message);\n        return;\n    }\n    \n    cpdbActivateBackends(f);\n    f->name_done = TRUE;\n}\n\nstatic void on_name_lost(GDBusConnection *connection,\n                         const gchar *name,\n                         gpointer user_data)\n{\n    logdebug(\"Lost bus name %s\\n\", name);\n    cpdb_frontend_obj_t *f = user_data;\n    f->name_done = TRUE;\n}\n\nstatic GDBusConnection *get_dbus_connection()\n{\n    gchar *bus_addr;\n    GError *error = NULL;\n    GDBusConnection *connection;\n    \n    bus_addr = g_dbus_address_get_for_bus_sync(G_BUS_TYPE_SESSION,\n                                               NULL,\n                                               &error);\n    \n    connection = g_dbus_connection_new_for_address_sync(bus_addr,\n                                                        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT |\n                                                        G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,\n                                                        NULL,\n                                                        NULL,\n                                                        &error);\n    if (error)\n    {\n        logerror(\"Error acquiring bus connection : %s\\n\", error->message);\n        return NULL;\n    }\n    logdebug(\"Acquired bus connection\\n\");\n    return connection;\n}\n\nvoid cpdbConnectToDBus(cpdb_frontend_obj_t *f)\n{\n    GMainContext *context;\n\n    if ((f->connection = get_dbus_connection()) == NULL)\n    {\n        loginfo(\"Couldn't connect to DBus\\n\");\n        return;\n    }\n    \n    f->own_id = g_bus_own_name_on_connection(f->connection,\n                                             f->bus_name,\n                                             0,\n                                             on_name_acquired,\n                                             on_name_lost,\n                                             f,\n                                             NULL);\n\n    // Wait till either of name acquired/lost callbacks finish\n    context = g_main_context_get_thread_default();\n    while (!f->name_done)\n    {\n        g_main_context_iteration(context, TRUE);\n    }\n}\n\nvoid cpdbDisconnectFromDBus(cpdb_frontend_obj_t *f)\n{\n    if (f->connection == NULL || g_dbus_connection_is_closed(f->connection))\n    {\n        logwarn(\"Already disconnected from DBus\\n\");\n        return;\n    }\n    \n    print_frontend_emit_stop_listing(f->skeleton);\n    g_dbus_connection_flush_sync(f->connection, NULL, NULL);\n    \n    g_bus_unown_name(f->own_id);\n    g_dbus_connection_close_sync(f->connection, NULL, NULL);\n}\n\nstatic void fetchPrinterListFromBackend(cpdb_frontend_obj_t *f, const char *backend)\n{\n    int num_printers;\n    GVariantIter iter;\n    GVariant *printers, *printer;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    cpdb_printer_obj_t *p;\n\n    if ((proxy = g_hash_table_lookup(f->backend, backend)) == NULL)\n    {\n        logerror(\"Couldn't get %s proxy object\\n\", backend);\n        return;\n    }\n    print_backend_call_get_printer_list_sync (proxy, &num_printers,\n                                                &printers, NULL, &error);\n    if (error)\n    {\n        logerror(\"Error getting %s printer list : %s\\n\", backend, error->message);\n        return;\n    }\n    logdebug(\"Fetched %d printers from backend %s\\n\", num_printers, backend);\n    g_variant_iter_init(&iter, printers);\n    while (g_variant_iter_loop(&iter, \"(v)\", &printer))\n    {\n        p = cpdbGetNewPrinterObj();\n        cpdbFillBasicOptions(p, printer);\n        if (f->last_saved_settings != NULL)\n            cpdbCopySettings(f->last_saved_settings, p->settings);\n        cpdbAddPrinter(f, p);\n    }\n}\n\nstatic void cpdbActivateBackends(cpdb_frontend_obj_t *f)\n{\n    DIR *d;\n    int len;\n    const char *info_dir_name;\n    struct dirent *dir;\n    PrintBackend *proxy;\n    char *backend_suffix;\n\n    logdebug(\"Activating backends\\n\");\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    if ((d = opendir(info_dir_name)) == NULL)\n    {\n        logerror(\"Couldn't open backend info directory : %s\\n\",\n\t\t info_dir_name);\n        return;\n    }\n    len = strlen(CPDB_BACKEND_PREFIX);\n\n    while ((dir = readdir (d)) != NULL)\n    {\n        if (strncmp(CPDB_BACKEND_PREFIX, dir->d_name, len) == 0)\n        {\n            backend_suffix = cpdbGetStringCopy((dir->d_name) + len);\n            loginfo(\"Found backend %s\\n\", backend_suffix);\n            proxy = cpdbCreateBackendFromFile(f->connection, dir->d_name);\n            g_hash_table_insert(f->backend, backend_suffix, proxy);\n            f->num_backends++;\n            fetchPrinterListFromBackend(f, backend_suffix);\n        }\n    }\n    closedir(d);\n}\n\nPrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    \n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    \n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    \n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    \n    return proxy;\n}\n\nvoid cpdbIgnoreLastSavedSettings(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Ignoring previous settings\\n\");\n    cpdbDeleteSettings(f->last_saved_settings);\n    f->last_saved_settings = NULL;\n}\n\ngboolean cpdbAddPrinter(cpdb_frontend_obj_t *f, \n                        cpdb_printer_obj_t *p)\n{\n    p->backend_proxy = g_hash_table_lookup(f->backend, p->backend_name);\n    if (p->backend_proxy == NULL)\n    {\n        logerror(\"Couldn't add printer %s : Backend doesn't exist %s\\n\",\n                    p->id, p->backend_name);\n        return FALSE;\n    }\n    g_object_ref(p->backend_proxy);\n\n    loginfo(\"Adding printer %s %s\\n\", p->id, p->backend_name);\n    cpdbDebugPrinter(p);\n    g_hash_table_insert(f->printer, cpdbConcatSep(p->id, p->backend_name), p);\n    f->num_printers++;\n\n    return TRUE;\n}\n\ncpdb_printer_obj_t *cpdbRemovePrinter(cpdb_frontend_obj_t *f,\n                                      const char *printer_id,\n                                      const char *backend_name)\n{\n    char *key;\n    cpdb_printer_obj_t *p = NULL;\n\n    loginfo(\"Removing printer %s %s\\n\", printer_id, backend_name);\n    key = cpdbConcatSep(printer_id, backend_name);\n    if (g_hash_table_contains(f->printer, key))\n    {\n        p = cpdbFindPrinterObj(f, printer_id, backend_name);\n        g_hash_table_remove(f->printer, key);\n        f->num_printers--;\n    }\n    else\n    {\n        logwarn(\"Printer %s %s not found\\n\", printer_id, backend_name);\n    }\n    \n    free(key);\n    return p;\n}\n\nvoid cpdbHideRemotePrinters(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Hiding remote printers\\n\");\n    print_frontend_emit_hide_remote_printers(f->skeleton);\n}\n\nvoid cpdbUnhideRemotePrinters(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Unhiding remote printers\\n\");\n    print_frontend_emit_unhide_remote_printers(f->skeleton);\n}\n\nvoid cpdbHideTemporaryPrinters(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Hiding temporary printers\\n\");\n    print_frontend_emit_hide_temporary_printers(f->skeleton);\n}\n\nvoid cpdbUnhideTemporaryPrinters(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Unhiding temporary printers\\n\");\n    print_frontend_emit_unhide_temporary_printers(f->skeleton);\n}\n\ncpdb_printer_obj_t *cpdbFindPrinterObj(cpdb_frontend_obj_t *f,\n                                       const char *printer_id,\n                                       const char *backend_name)\n{\n    char *hashtable_key;\n    cpdb_printer_obj_t *p;\n\n    if (printer_id == NULL || backend_name == NULL)\n    {\n        logwarn(\"Invalid parameters: cpdbFindPrinterObj()\\n\");\n        return NULL;\n    }\n\n    hashtable_key = cpdbConcatSep(printer_id, backend_name);\n    p = g_hash_table_lookup(f->printer, hashtable_key);\n    if (p == NULL)\n    {\n        logwarn(\"Couldn't find printer %s %s : Doesn't exist\\n\",\n                printer_id, backend_name);\n    }\n\n    free(hashtable_key);\n    return p;\n}\n\ncpdb_printer_obj_t *cpdbGetDefaultPrinterForBackend(cpdb_frontend_obj_t *f,\n                                                    const char *backend_name)\n{\n    char *def;\n    GError *error = NULL;\n    PrintBackend *proxy;\n    cpdb_printer_obj_t *p = NULL;\n    \n    proxy = g_hash_table_lookup(f->backend, backend_name);\n    if (proxy == NULL)\n    {\n        logwarn(\"Couldn't find backend proxy for %s\\n\", backend_name);\n        proxy = cpdbCreateBackendFromFile(f->connection, backend_name);\n        if (proxy == NULL)\n        {\n            logerror(\"Error getting default printer for backend : Couldn't get backend proxy\\n\");\n            return NULL;\n        }\n    }\n\n    print_backend_call_get_default_printer_sync(proxy, &def, NULL, &error);\n    if (error)\n    {\n        logerror(\"Error getting default printer for backend : %s\\n\", error->message);\n        return NULL;\n    }\n    \n    p = cpdbFindPrinterObj(f, def, backend_name);\n    if (p)\n        logdebug(\"Obtained default printer %s for backend %s\\n\", p->id, backend_name);\n    return p;\n}\n\nGList *cpdbLoadDefaultPrinters(const char *path)\n{\n    FILE *fp;\n    char buf[CPDB_BSIZE];\n    GList *printers = NULL;\n\n    if ((fp = fopen(path, \"r\")) == NULL)\n    {\n        logwarn(\"Error loading default printers : Couldn't open %s for reading\\n\",\n                path);\n        return NULL;\n    }\n\n    while (fgets(buf, sizeof(buf), fp) != NULL)\n    {\n        buf[strcspn(buf, \"\\r\\n\")] = 0;\n        printers = g_list_prepend(printers, cpdbGetStringCopy(buf));\n    }\n    printers = g_list_reverse(printers);\n    logdebug(\"Loaded default printers from %s\\n\", path);\n\n    fclose(fp);\n    return printers;\n}\n\ncpdb_printer_obj_t *cpdbGetDefaultPrinter(cpdb_frontend_obj_t *f)\n{   \n    gpointer key, value;\n    GHashTableIter iter;\n    char *conf_dir, *path, *printer_id, *backend_name;\n    cpdb_printer_obj_t *default_printer = NULL;\n    GList *printer, *user_printers, *system_printers, *printers = NULL;\n\n    if (f->num_printers == 0 || f->num_backends == 0)\n    {\n        logwarn(\"Couldn't get default printer : No printers found\\n\");\n        return NULL;\n    }\n    \n    /** Find a default printer from user config first,\n     *  before trying system wide config **/\n    conf_dir = cpdbGetUserConfDir();\n    if (conf_dir)\n    {\n        path = cpdbConcatPath(conf_dir, CPDB_DEFAULT_PRINTERS_FILE);\n        printers = g_list_concat(printers, cpdbLoadDefaultPrinters(path));\n        free(path);\n        free(conf_dir);\n    }\n    conf_dir = cpdbGetSysConfDir();\n    if (conf_dir)\n    {\n        path = cpdbConcatPath(conf_dir, CPDB_DEFAULT_PRINTERS_FILE);\n        printers = g_list_concat(printers, cpdbLoadDefaultPrinters(path));\n        free(path);\n        free(conf_dir);\n    }\n    \n    for (printer = printers; printer != NULL; printer = printer->next)\n    {\n        printer_id = strtok(printer->data, \"#\"); \n        backend_name = strtok(NULL, \"\\n\");\n\n        default_printer = cpdbFindPrinterObj(f, printer_id, backend_name);\n        if (default_printer)\n        {\n            g_list_free_full(printers, free);\n            goto found;\n        }\n    }\n    if (printers)\n        g_list_free_full(printers, free);\n\n    logdebug(\"Couldn't find a valid default printer from config files\\n\");\n\n    /**  Fallback to default CUPS printer if CUPS backend exists **/\n    default_printer = cpdbGetDefaultPrinterForBackend(f, \"CUPS\");\n    if (default_printer)\n        goto found;\n    logdebug(\"Couldn't find a valid default CUPS printer\\n\");\n    \n    /** Fallback to default FILE printer if FILE backend exists **/\n    default_printer = cpdbGetDefaultPrinterForBackend(f, \"FILE\");\n    if (default_printer)\n        goto found;\n    logdebug(\"Couldn't find a valid default FILE printer\\n\");\n    \n    /** Fallback to the default printer of first backend found **/\n    g_hash_table_iter_init(&iter, f->backend);\n    g_hash_table_iter_next(&iter, &key, &value);\n\n    backend_name = (char *) key;\n    default_printer = cpdbGetDefaultPrinterForBackend(f, backend_name);\n    if (default_printer)\n        goto found;\n    logdebug(\"Couldn't find a valid default %s printer\\n\", backend_name);\n    \n    /** Fallback to first printer found **/\n    g_hash_table_iter_init(&iter, f->printer);\n    g_hash_table_iter_next(&iter, &key, &value);\n    default_printer = (cpdb_printer_obj_t *) value;\n    if (!default_printer)\n    {\n        logerror(\"Couldn't find a valid printer\\n\");\n        return NULL;\n    }\n\nfound:\n    logdebug(\"Found default printer %s %s\\n\",\n                default_printer->id, default_printer->backend_name);\n    return default_printer;\n}\n\nint cpdbSetDefaultPrinter(const char *path,\n                          cpdb_printer_obj_t *p)\n{\n    FILE *fp;\n    char *printer_data;\n    GList *printer, *next, *printers;\n    \n    printers = cpdbLoadDefaultPrinters(path);\n    printer_data = cpdbConcatSep(p->id, p->backend_name);\n    \n    if ((fp = fopen(path, \"w\")) == NULL)\n    {\n        logerror(\"Error setting default printer : Couldn't open %s for writing\\n\",\n                    path);\n        return 0;\n    }\n\n    /* Delete duplicate entries */\n    printer = printers;\n    while (printer != NULL)\n    {\n        next = printer->next;\n        if (strcmp(printer->data, printer_data) == 0)\n        {\n            free(printer->data);\n            printers = g_list_delete_link(printers, printer);\n        }\n\n        printer = next;\n    }\n\n    printers = g_list_prepend(printers, printer_data);\n    for (printer = printers; printer != NULL; printer = printer->next)\n    {\n        fprintf(fp, \"%s\\n\", (char *)printer->data);\n    }\n    g_list_free_full(printers, free);\n    loginfo(\"Saved default printers to %s\", path);\n\n    fclose(fp);\n    return 1;\n}\n\nint cpdbSetUserDefaultPrinter(cpdb_printer_obj_t *p)\n{\n    int ret;\n    char *conf_dir, *path;\n\n    if ((conf_dir = cpdbGetUserConfDir()) == NULL)\n    {\n        logerror(\"Error setting default printer : Couldn't get system config dir\\n\");\n        return 0;\n    }\n    path = cpdbConcatPath(conf_dir, CPDB_DEFAULT_PRINTERS_FILE);\n    ret = cpdbSetDefaultPrinter(path, p);\n\n    free(path);\n    free(conf_dir);\n    return ret;\n}\n\nint cpdbSetSystemDefaultPrinter(cpdb_printer_obj_t *p)\n{\n    int ret;\n    char *conf_dir, *path;\n\n    if ((conf_dir = cpdbGetSysConfDir()) == NULL)\n    {\n        logerror(\"Error setting default printer : Couldn't get system config dir\\n\");\n        return 0;\n    }\n    path = cpdbConcatPath(conf_dir, CPDB_DEFAULT_PRINTERS_FILE);\n    ret = cpdbSetDefaultPrinter(path, p);\n\n    free(path);\n    free(conf_dir);\n    return ret;\n}\n\nint cpdbGetAllJobs(cpdb_frontend_obj_t *f,\n                   cpdb_job_t **j,\n                   gboolean active_only)\n{\n    \n\t/**inititalizing the arrays required for each of the backends **/\n\t\n    /** num_jobs[] stores the number of jobs for each of the backends**/\n    int *num_jobs = g_new(int, f->num_backends);\n    \n    /**backend_names[] stores the name for each of the backends**/\n    char **backend_names = g_new0(char *, f->num_backends);\n    \n    /**retval[] stores the gvariant returned by the respective backend **/\n    GVariant **retval = g_new(GVariant *, f->num_backends);\n    \n    GError *error = NULL;\n    gpointer key, value;\n    GHashTableIter iter;\n    int i = 0, total_jobs = 0;\n \n    /** Iterating over all the backends and getting each's active jobs**/\n    g_hash_table_iter_init(&iter, f->backend);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        PrintBackend *proxy = (PrintBackend *)value;\n        \n        backend_names[i] = (char *)key;\n        print_backend_call_get_all_jobs_sync(proxy,\n                                             active_only,\n                                             &(num_jobs[i]),\n                                             &(retval[i]),\n                                             NULL,\n                                             &error);\n        \n        if(error)\n        {\n            logerror(\"Error gettings jobs for backend %s : %s\\n\",\n                        backend_names[i], error->message);\n        \tnum_jobs[i] = 0;\n        \t\n        }\n        else\n        {\n        \tlogdebug(\"Obtained %d jobs for backend %s\\n\",\n                        num_jobs[i], backend_names[i]);\n        }\n        \n        total_jobs += num_jobs[i];\n        i++; /** off to the next backend **/\n    }\n    \n    int n = 0;\n    cpdb_job_t *jobs = g_new(cpdb_job_t, total_jobs);\n    for (i = 0; i < f->num_backends; i++)\n    {\n    \tif(num_jobs[i])\n        {\n    \t\tcpdbUnpackJobArray(retval[i],\n                               num_jobs[i],\n                               jobs + n,\n                               backend_names[i]);\n        }\n        n += num_jobs[i];\n    }\n    *j = jobs;\n\n    free(num_jobs);\n    return total_jobs;\n}\n\n/**\n________________________________________________ cpdb_printer_obj_t __________________________________________\n**/\n\ncpdb_printer_obj_t *cpdbGetNewPrinterObj()\n{\n    cpdb_printer_obj_t *p = g_new0 (cpdb_printer_obj_t, 1);\n    p->options = NULL;\n    p->settings = cpdbGetNewSettings();\n    return p;\n}\n\nstatic void cpdbDeleteTranslations(cpdb_printer_obj_t *p)\n{\n    g_free(p->locale);\n    if (p->translations)\n        g_hash_table_destroy(p->translations);\n\n    p->locale = NULL;\n    p->translations = NULL;\n}\n\nvoid cpdbDeletePrinterObj(cpdb_printer_obj_t *p)\n{\n    if (p == NULL)\n        return;\n    \n    logdebug(\"Deleting printer object %s\\n\", p->id);\n    if (p->backend_name)\n        free(p->backend_name);\n    if (p->backend_proxy)\n        g_object_unref(p->backend_proxy);\n    if (p->options)\n        cpdbDeleteOptions(p->options);\n    if (p->settings)\n        cpdbDeleteSettings(p->settings);\n    cpdbDeleteTranslations(p);\n    \n    free(p);\n}\n\nvoid cpdbFillBasicOptions(cpdb_printer_obj_t *p,\n                          GVariant *gv)\n{\n    g_variant_get(gv, CPDB_PRINTER_ADDED_ARGS,\n                  &(p->id),\n                  &(p->name),\n                  &(p->info),\n                  &(p->location),\n                  &(p->make_and_model),\n                  &(p->accepting_jobs),\n                  &(p->state),\n                  &(p->backend_name));\n}\n\nvoid cpdbDebugPrinter(const cpdb_printer_obj_t *p)\n{\n    logdebug(\"-------------------------\\n\");\n    logdebug(\"Printer %s\\n\", p->id);\n    logdebug(\"name: %s\\n\", p->name);\n    logdebug(\"location: %s\\n\", p->location);\n    logdebug(\"info: %s\\n\", p->info);\n    logdebug(\"make and model: %s\\n\", p->make_and_model);\n    logdebug(\"accepting jobs? %s\\n\", (p->accepting_jobs ? \"yes\" : \"no\"));\n    logdebug(\"state: %s\\n\", p->state);\n    logdebug(\"backend: %s\\n\", p->backend_name);\n    logdebug(\"-------------------------\\n\\n\");\n}\n\ngboolean cpdbIsAcceptingJobs(cpdb_printer_obj_t *p)\n{\n    GError *error = NULL;\n    \n    print_backend_call_is_accepting_jobs_sync(p->backend_proxy,\n                                              p->id,\n                                              &p->accepting_jobs,\n                                              NULL,\n                                              &error);\n    if (error)\n    {\n        logerror(\"Error getting accepting_jobs status for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        return FALSE;\n    }\n\n    logdebug(\"Obtained accepting_jobs=%d; for %s %s\\n\", \n                p->accepting_jobs, p->id, p->backend_name);\n    return p->accepting_jobs;\n}\n\nchar *cpdbGetState(cpdb_printer_obj_t *p)\n{\n    GError *error = NULL;\n    \n    print_backend_call_get_printer_state_sync(p->backend_proxy,\n                                              p->id,\n                                              &p->state,\n                                              NULL,\n                                              &error);\n    if (error)\n    {\n        logerror(\"Error getting printer state for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n\n    logdebug(\"Obtained state=%s; for %s %s\\n\", \n                p->state, p->id, p->backend_name);\n    return p->state;\n}\n\ncpdb_options_t *cpdbGetAllOptions(cpdb_printer_obj_t *p)\n{\n    if (p == NULL) \n    {\n        logwarn(\"Invalid params: cpdbGetAllOptions()\\n\");\n        return NULL;\n    }\n\n    /** \n     * If the options were previously queried, \n     * return them, instead of querying again.\n    */\n    if (p->options)\n        return p->options;\n\n    GError *error = NULL;\n    int num_options, num_media;\n    GVariant *var, *media_var;\n    print_backend_call_get_all_options_sync(p->backend_proxy,\n                                            p->id,\n                                            &num_options,\n                                            &var,\n                                            &num_media,\n                                            &media_var,\n                                            NULL,\n                                            &error);\n    if (error)\n    {\n        logerror(\"Error getting printer options for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n\n    loginfo(\"Obtained %d options and %d media for %s %s\\n\",\n            num_options, num_media, p->id, p->backend_name);\n    p->options = cpdbGetNewOptions();\n    cpdbUnpackOptions(num_options, var, num_media, media_var, p->options);\n    return p->options;\n}\n\ncpdb_option_t *cpdbGetOption(cpdb_printer_obj_t *p,\n                             const char *name)\n{\n    if (p == NULL || name == NULL) \n    {\n        logwarn(\"Invalid params: cpdbGetOption()\\n\");\n        return NULL;\n    }\n\n    cpdbGetAllOptions(p);\n    return (cpdb_option_t *)(g_hash_table_lookup(p->options->table, name));\n}\n\nchar *cpdbGetDefault(cpdb_printer_obj_t *p,\n                     const char *name)\n{\n    if (p == NULL || name == NULL)\n    {\n        logwarn(\"Invalid params: cpdbGetDefault()\\n\");\n        return NULL;\n    }\n\n    cpdb_option_t *o = cpdbGetOption(p, name);\n    if (!o)\n        return NULL;\n    return o->default_value;\n}\n\nchar *cpdbGetSetting(cpdb_printer_obj_t *p,\n                     const char *name)\n{\n    if (p == NULL || name == NULL)\n    {\n        logwarn(\"Invalid params: cpdbGetSetting()\\n\");\n        return NULL;\n    }\n\n    if (!g_hash_table_contains(p->settings->table, name))\n        return NULL;\n    return g_hash_table_lookup(p->settings->table, name);\n}\n\nchar *cpdbGetCurrent(cpdb_printer_obj_t *p,\n                     const char *name)\n{\n    char *set = cpdbGetSetting(p, name);\n    if (set)\n        return set;\n\n    return cpdbGetDefault(p, name);\n}\n\nint cpdbGetActiveJobsCount(cpdb_printer_obj_t *p)\n{\n    int count;\n    GError *error = NULL;\n    \n    print_backend_call_get_active_jobs_count_sync(p->backend_proxy,\n                                                  p->id,\n                                                  &count,\n                                                  NULL,\n                                                  &error);\n    if (error)\n    {\n        logerror(\"Error getting active jobs count for % %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        return -1;\n    }\n    \n    logdebug(\"Obtained %d active jobs for %s %s\\n\", count, \n                p->id, p->backend_name);\n    return count;\n}\n\nstatic void cpdbDebugPrintSettings(cpdb_settings_t *s)\n{\n    gpointer key, value;\n    GHashTableIter iter;\n\n    g_hash_table_iter_init(&iter, s->table);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        logdebug(\"%s -> %s\\n\", (char *) key, (char *) value);\n    }\n}\n\nchar *cpdbPrintFile(cpdb_printer_obj_t *p,\n                    const char *file_path)\n{\n    char *jobid, *absolute_file_path;\n    GError *error = NULL;\n    \n    absolute_file_path = cpdbGetAbsolutePath(file_path);\n    logdebug(\"Printing file %s on %s %s\\n\",\n                absolute_file_path, p->id, p->backend_name);\n    cpdbDebugPrintSettings(p->settings);\n    print_backend_call_print_file_sync(p->backend_proxy,\n                                       p->id,\n                                       absolute_file_path,\n                                       p->settings->count,\n                                       cpdbSerializeToGVariant(p->settings),\n                                       \"final-file-path-not-required\",\n                                       &jobid,\n                                       NULL,\n                                       &error);\n                                       \n    if (error)\n    {\n        logerror(\"Error printing file %s on %s %s : %s\\n\", \n                    absolute_file_path, p->id, p->backend_name, error->message);\n        return NULL;\n    }\n    \n    if (jobid == NULL || jobid == \"\")\n    {\n        logerror(\"Error printing file %s on %s %s : Couldn't create a job\\n\", \n                    absolute_file_path, p->id, p->backend_name);\n        return NULL;\n    }\n    \n    loginfo(\"File %s sent for printing on %s %s successfully\\n\",\n                absolute_file_path, p->id, p->backend_name);\n    cpdbSaveSettingsToDisk(p->settings);\n    free(absolute_file_path);\n    return jobid;\n}\n\nchar *cpdbPrintFilePath(cpdb_printer_obj_t *p,\n                        const char *file_path,\n                        const char *final_file_path)\n{\n    char *result, *absolute_file_path, *absolute_final_file_path;\n    GError *error = NULL;\n    \n    absolute_file_path = cpdbGetAbsolutePath(file_path);\n    absolute_final_file_path = cpdbGetAbsolutePath(final_file_path);\n    logdebug(\"Printing file %s on %s %s to %s\\n\",\n                absolute_file_path, p->id, p->backend_name, absolute_final_file_path);\n    cpdbDebugPrintSettings(p->settings);\n    print_backend_call_print_file_sync(p->backend_proxy,\n                                       p->id,\n                                       absolute_file_path,\n                                       p->settings->count,\n                                       cpdbSerializeToGVariant(p->settings),\n                                       absolute_final_file_path,\n                                       &result,\n                                       NULL,\n                                       &error);\n    \n    if (error)\n    {\n        logerror(\"Error printing file %s to %s : %s\\n\", \n                 absolute_file_path, absolute_final_file_path, error->message);\n        return NULL;\n    }\n    \n    if (result == NULL)\n    {\n        logerror(\"Error printing file %s to %s\\n\", \n                 absolute_file_path, absolute_final_file_path);\n        return NULL;\n    }\n    \n    loginfo(\"File %s printed to %s successfully\\n\",\n                absolute_file_path, absolute_final_file_path);\n    free(absolute_file_path);\n    free(absolute_final_file_path);\n    return result;\n}\n\nvoid cpdbAddSettingToPrinter(cpdb_printer_obj_t *p,\n                             const char *name,\n                             const char *val)\n{\n    if (p == NULL || name == NULL)\n    {\n        logwarn(\"Invalid params: cpdbAddSettingToPrinter()\\n\");\n        return;\n    }\n\n    cpdbAddSetting(p->settings, name, val);\n}\n\ngboolean cpdbClearSettingFromPrinter(cpdb_printer_obj_t *p,\n                                     const char *name)\n{\n    if (p == NULL || name == NULL)\n    {\n        logwarn(\"Invalid params: cpdbClearSettingFromPrinter()\\n\");\n        return FALSE;\n    }\n    return cpdbClearSetting(p->settings, name);\n}\n\ngboolean cpdbCancelJob(cpdb_printer_obj_t *p,\n                       const char *job_id)\n{\n    gboolean status;\n    GError *error = NULL;\n    \n    print_backend_call_cancel_job_sync(p->backend_proxy,\n                                       job_id,\n                                       p->id,\n                                       &status,\n                                       NULL,\n                                       &error);\n    if (error)\n    {\n        logerror(\"Error cancelling job %s on %s %s\\n\", \n                    job_id, p->id, p->backend_name, error->message);\n        return FALSE;\n    }\n    \n    logdebug(\"Obtained status=%d for cancelling job %s on %s %s\\n\",\n                status, job_id, p->id, p->backend_name);\n    return status;\n}\n\nvoid cpdbPicklePrinterToFile(cpdb_printer_obj_t *p,\n                             const char *filename,\n                             const cpdb_frontend_obj_t *parent_dialog)\n{\n\tFILE *fp;\n\tchar *path;\n    const char *unique_bus_name;\n    GHashTableIter iter;\n    gpointer key, value;\n    GError *error = NULL;\n\t\n    print_backend_call_keep_alive_sync(p->backend_proxy, NULL, &error);\n    if (error)\n    {\n        logerror(\"Error keeping backend %s alive : %s\\n\",\n                    p->backend_name, error->message);\n        return;\n    }\n    loginfo(\"Keeping backend %s alive\\n\", p->backend_name);\n    \n    path = cpdbGetAbsolutePath(filename);\n    if ((fp = fopen(path, \"w\")) == NULL)\n    {\n        logerror(\"Error pickling printer %s %s : Couldn't open %s for writing\\n\",\n                    p->id, p->backend_name, path);\n        return;\n    }\n\n    unique_bus_name = g_dbus_connection_get_unique_name(parent_dialog->connection);\n    if (unique_bus_name == NULL)\n    {\n        logerror(\"Error pickling printer %s %s: Couldn't get unique bus name\\n\",\n                    p->id, p->backend_name);\n        return;\n    }\n    \n    fprintf(fp, \"%s#\\n\", unique_bus_name);\n    fprintf(fp, \"%s#\\n\", p->backend_name);\n    fprintf(fp, \"%s#\\n\", p->id);\n    fprintf(fp, \"%s#\\n\", p->name);\n    fprintf(fp, \"%s#\\n\", p->location);\n    fprintf(fp, \"%s#\\n\", p->info);\n    fprintf(fp, \"%s#\\n\", p->make_and_model);\n    fprintf(fp, \"%s#\\n\", p->state);\n    fprintf(fp, \"%d\\n\", p->accepting_jobs);\n\n    /* Not pickling the cpdb_options_t, \n     * because it can be reconstructed by querying the backend */\n\n    fprintf(fp, \"%d\\n\", p->settings->count);\n    g_hash_table_iter_init(&iter, p->settings->table);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        fprintf(fp, \"%s#%s#\\n\", (char *)key, (char *)value);\n    }\n    loginfo(\"Pickled printer %s %s to %s\\n\",\n            p->id, p->backend_name, path);\n    \n    fclose(fp);\n    free(path);\n}\n\ncpdb_printer_obj_t *cpdbResurrectPrinterFromFile(const char *filename)\n{\n    FILE *fp;\n    int count;\n    char buf[CPDB_BSIZE];\n    GDBusConnection *connection;\n    char *name, *value, *path = NULL;\n    char *backend_file_name = NULL, *previous_parent_dialog = NULL;\n    GError *error = NULL;\n    cpdb_printer_obj_t *p;\n\n    path = cpdbGetAbsolutePath(filename);\n    if ((fp = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error resurrecting printer : Couldn't open %s for reading\\n\",\n\t\t path);\n        goto failed;\n    }\n\n    p = cpdbGetNewPrinterObj();\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    previous_parent_dialog = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->backend_name = cpdbGetStringCopy(strtok(buf, \"#\"));\n    \n    backend_file_name = cpdbConcat(CPDB_BACKEND_PREFIX, p->backend_name);\n    if ((connection = get_dbus_connection()) == NULL)\n    {\n        logerror(\"Error resurrecting printer : Couldn't get dbus connection\\n\");\n        goto failed;\n    }\n    p->backend_proxy = cpdbCreateBackendFromFile(connection,\n                                                 backend_file_name);\n    free(backend_file_name);\n    print_backend_call_replace_sync(p->backend_proxy, \n                                    previous_parent_dialog, \n                                    NULL, \n                                    &error);\n    if (error)\n    {\n        logerror(\"Error replacing resurrected printer : %s\\n\",\n                    error->message); \n        goto failed;\n    }\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->id = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->name = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->location = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->info = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->make_and_model = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->state = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fscanf(fp, \"%d\\n\", &p->accepting_jobs) == 0)\n        goto parse_error;\n    \n    cpdbDebugPrinter(p);\n\n    if (fscanf(fp, \"%d\\n\", &count) == 0)\n        goto parse_error;\n    while (count--)\n    {\n        if (fgets(buf, sizeof(buf), fp) == NULL)\n            goto parse_error;\n        name = strtok(buf, \"#\");\n        value = strtok(NULL, \"#\");\n        cpdbAddSetting(p->settings, name, value);\n    }\n    loginfo(\"Resurrected printer %s %s from %s\\n\", \n            p->id, p->backend_name, filename);\n\n    fclose(fp);\n    free(path);\n    free(backend_file_name);\n    free(previous_parent_dialog);\n    return p;\n\nparse_error:\n    logerror(\"Error resurrecting printer : Coudln't parse %s\\n\", path);\n    \nfailed:\n    if (fp)\n        fclose(fp);\n    free(path);\n    if (backend_file_name)\n        free(backend_file_name);\n    if (previous_parent_dialog)\n        free(previous_parent_dialog);\n    return NULL;\n}\n\nchar *cpdbGetOptionTranslation(cpdb_printer_obj_t *p,\n                               const char *option_name,\n                               const char *locale)\n{\n    char *name_key, *translation;\n    GError *error = NULL;\n\n    if (p == NULL || option_name == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid paramaters: cpdbGetOptionTranslation()\\n\");\n        return NULL;\n    }\n\n    if (p->locale != NULL && strcmp(p->locale, locale) == 0)\n    {\n        name_key = cpdbConcatSep(CPDB_OPT_PREFIX, option_name);\n        translation = g_hash_table_lookup(p->translations, name_key);\n        free(name_key);\n        if (translation)\n        {\n            logdebug(\"Found translation=%s; for option=%s;locale=%s;printer=%s#%s;\\n\",\n                        translation, option_name, locale, p->id, p->backend_name);\n            return cpdbGetStringCopy(translation);\n        }\n    }\n\n    print_backend_call_get_option_translation_sync(p->backend_proxy,\n                                                   p->id,\n                                                   option_name,\n                                                   locale,\n                                                   &translation,\n                                                   NULL,\n                                                   &error);\n    if (error)\n    {\n        logerror(\"Error getting translation for option=%s;locale=%s;printer=%s#%s; : %s\\n\",\n                    option_name, locale,\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n    \n    logdebug(\"Obtained translation=%s; for option=%s;locale=%s;printer=%s#%s;\\n\",\n                translation, option_name, locale, p->id, p->backend_name);\n    return cpdbGetStringCopy(translation);\n}\n\nchar *cpdbGetChoiceTranslation(cpdb_printer_obj_t *p,\n                               const char *option_name,\n                               const char *choice_name,\n                               const char *locale)\n{\n    char *name_key, *choice_key, *translation;\n    GError *error = NULL;\n\n    if (p == NULL || option_name == NULL || choice_name == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid paramaters: cpdbGetChoiceTranslation()\\n\");\n        return NULL;\n    }\n\n    if (p->locale != NULL && strcmp(p->locale, locale) == 0)\n    {\n        name_key = cpdbConcatSep(CPDB_OPT_PREFIX, option_name);\n        choice_key = cpdbConcatSep(name_key, choice_name);\n        translation = g_hash_table_lookup(p->translations, choice_key);\n        free(name_key);\n        free(choice_key);\n        if (translation)\n        {\n            logdebug(\"Found translation=%s; for option=%s;choice=%s;locale=%s;printer=%s#%s;\\n\",\n                        translation, option_name, choice_name, locale, \n                        p->id, p->backend_name);\n            return cpdbGetStringCopy(translation);\n        }\n    }\n    \n    print_backend_call_get_choice_translation_sync(p->backend_proxy,\n                                                   p->id,\n                                                   option_name,\n                                                   choice_name,\n                                                   locale,\n                                                   &translation,\n                                                   NULL,\n                                                   &error);\n    if (error)\n    {\n        logerror(\"Error getting translation for option=%s;choice=%s;locale=%s;printer=%s#%s; : %s\\n\",\n                    option_name, choice_name, locale,\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n    \n    logdebug(\"Obtained translation=%s; for option=%s;choice=%s;locale=%s;printer=%s#%s;\\n\",\n                translation, option_name, choice_name, locale, \n                p->id, p->backend_name);\n    return cpdbGetStringCopy(translation);\n}\n\n\nchar *cpdbGetGroupTranslation(cpdb_printer_obj_t *p,\n                              const char *group_name,\n                              const char *locale)\n{\n    char *group_key, *translation;\n    GError *error = NULL;\n\n    if (p == NULL || group_name == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid paramaters: cpdbGetGroupTranslation()\\n\");\n        return NULL;\n    }\n\n    if (p->locale != NULL && strcmp(p->locale, locale) == 0)\n    {\n        group_key = cpdbConcatSep(CPDB_GRP_PREFIX, group_name);\n        translation = g_hash_table_lookup(p->translations, group_key);\n        free(group_key);\n        if (translation)\n        {\n            logdebug(\"Found translation=%s; for group=%s;locale=%s;printer=%s#%s;\\n\",\n                        translation, group_name, locale, p->id, p->backend_name);\n            return cpdbGetStringCopy(translation);\n        }\n    }\n    \n    print_backend_call_get_group_translation_sync(p->backend_proxy,\n                                                  p->id,\n                                                  group_name,\n                                                  locale,\n                                                  &translation,\n                                                  NULL,\n                                                  &error);\n\n    if (error)\n    {\n        logerror(\"Error getting translation for group=%s;locale=%s;printer=%s#%s; : %s\\n\",\n                    group_name, locale,\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n    \n    logdebug(\"Obtained translation=%s; for group=%s;locale=%s;printer=%s#%s;\\n\",\n                translation, group_name, locale, p->id, p->backend_name);\n    return cpdbGetStringCopy(translation);\n}\n\nvoid cpdbGetAllTranslations(cpdb_printer_obj_t *p,\n                            const char *locale)\n{\n    GVariant *translations;\n    GError *error = NULL;\n\n    if (p == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid parameters: cpdbGetAllTranslations()\\n\");\n        return;\n    }\n\n    if (p->locale != NULL && strcmp(p->locale, locale) == 0)\n        return;\n\n    print_backend_call_get_all_translations_sync(p->backend_proxy,\n                                                 p->id,\n                                                 locale,\n                                                 &translations,\n                                                 NULL,\n                                                 &error);\n    if (error)\n    {\n        logerror(\"Error getting printer translations in %s for %s %s : %s\\n\",\n                    locale, p->id, p->backend_name, error->message);\n        return;\n    }\n    logdebug(\"Fetched translations for printer %s %s\\n\", p->id, p->backend_name);\n\n    cpdbDeleteTranslations(p);\n    p->locale = cpdbGetStringCopy(locale);\n    p->translations = cpdbUnpackTranslations(translations);\n}\n\ncpdb_media_t *cpdbGetMedia(cpdb_printer_obj_t *p,\n                           const char *media)\n{\n    cpdbGetAllOptions(p);\n    return (cpdb_media_t *) g_hash_table_lookup(p->options->media, media);\n}\n\nint cpdbGetMediaSize(cpdb_printer_obj_t *p,\n                     const char *media,\n                     int *width,\n                     int *length)\n{    \n    cpdb_media_t *m = cpdbGetMedia(p, media);\n    if (m)\n    {\n        *width = m->width;\n        *length = m->length;\n        return 1;\n    }\n\n    return 0;\n}\n\nint cpdbGetMediaMargins(cpdb_printer_obj_t *p,\n                        const char *media,\n                        cpdb_margin_t **margins)\n{\n    int num_margins = 0;\n    cpdb_media_t *m = cpdbGetMedia(p, media);\n\n    if (m)\n    {\n        num_margins = m->num_margins;\n        *margins = m->margins;\n    }\n\n    return num_margins;\t\n}\n\ntypedef struct {\n    cpdb_printer_obj_t *p;\n    cpdb_async_callback caller_cb;\n    void *user_data;\n} cpdb_async_details_obj_t;\n\nvoid acquire_details_cb(PrintBackend *proxy,\n                        GAsyncResult *res,\n                        gpointer user_data)\n{\n    cpdb_async_details_obj_t *a = user_data;\n    \n    cpdb_printer_obj_t *p = a->p;\n    cpdb_async_callback caller_cb = a->caller_cb;\n    \n    p->options = cpdbGetNewOptions();\n    GError *error = NULL;\n    int num_options, num_media;\n    GVariant *var, *media_var;\n    \n    print_backend_call_get_all_options_finish (proxy,\n                                               &num_options,\n                                               &var,\n                                               &num_media,\n                                               &media_var,\n                                               res,\n                                               &error);\n    if (error)\n    {\n        logerror(\"Error acquiring printer details for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        if (caller_cb)\n            caller_cb(p, FALSE, a->user_data);\n    }\n    else\n    {\n        loginfo(\"Acquired %d options and %d media for %s %s\\n\",\n                num_options, num_media, p->id, p->backend_name);\n        cpdbUnpackOptions(num_options, var, num_media, media_var, p->options);\n        if (caller_cb)\n            caller_cb(p, TRUE, a->user_data);\n    }\n    \n    free(a);\n}\n\nvoid cpdbAcquireDetails(cpdb_printer_obj_t *p,\n                        cpdb_async_callback caller_cb,\n                        void *user_data)\n{\n    if (p == NULL)\n    {\n        logwarn(\"Invalid parameters: cpdbAcquireDetails()\\n\");\n        return;\n    }\n\n    if (p->options)\n    {\n        if (caller_cb)\n            caller_cb(p, TRUE, user_data);\n        return;\n    }\n    \n    cpdb_async_details_obj_t *a = g_new0(cpdb_async_details_obj_t, 1);\n    a->p = p;\n    a->caller_cb = caller_cb;\n    a->user_data = user_data;\n    \n    logdebug(\"Acquiring printer details for %s %s\\n\", p->id, p->backend_name);\n    print_backend_call_get_all_options(p->backend_proxy,\n                                       p->id, \n                                       NULL,\n                                       (GAsyncReadyCallback) acquire_details_cb,\n                                       a);\n}\n\n\ntypedef struct {\n    cpdb_printer_obj_t *p;\n    char *locale;\n    cpdb_async_callback caller_cb;\n    void *user_data;\n} cpdb_async_translations_obj_t;\n\n\nstatic void acquire_translations_cb(PrintBackend *proxy,\n                                    GAsyncResult *res,\n                                    gpointer user_data)\n{\n    GError *error = NULL;\n    GVariant *translations;\n\n    cpdb_async_translations_obj_t *a = user_data;\n    cpdb_printer_obj_t *p = a->p;\n\n    print_backend_call_get_all_translations_finish(proxy, &translations,\n                                                    res, &error);\n    if (error)\n    {\n        logerror(\"Error getting printer translations for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        a->caller_cb(p, FALSE, a->user_data);\n    }\n    else\n    {\n        cpdbDeleteTranslations(p);\n        p->locale = cpdbGetStringCopy(a->locale);\n        p->translations = cpdbUnpackTranslations(translations);\n        a->caller_cb(p, TRUE, a->user_data);\n    }\n\n    free(a->locale);\n    free(a);\n}\n\nvoid cpdbAcquireTranslations(cpdb_printer_obj_t *p,\n                             const char *locale,\n                             cpdb_async_callback caller_cb,\n                             void *user_data)\n{\n    if (p == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid parameters: cpdbAcquireTranslations()\\n\");\n        return;\n    }\n\n    if (p->locale != NULL && strcmp(locale, p->locale) == 0)\n    {\n        caller_cb(p, TRUE, user_data);\n        return;\n    }\n\n    cpdb_async_translations_obj_t *a = g_new0(cpdb_async_translations_obj_t, 1);\n    a->p = p;\n    a->locale = cpdbGetStringCopy(locale);\n    a->caller_cb = caller_cb;\n    a->user_data = user_data;\n\n    logdebug(\"Acquiring printer translations for %s %s\\n\",\n                p->id, p->backend_name);\n    print_backend_call_get_all_translations(p->backend_proxy,\n                                            p->id,\n                                            locale,\n                                            NULL,\n                                            (GAsyncReadyCallback) acquire_translations_cb,\n                                            a);\n}\n\n/**\n________________________________________________ cpdb_settings_t __________________________________________\n**/\ncpdb_settings_t *cpdbGetNewSettings()\n{\n    cpdb_settings_t *s = g_new0(cpdb_settings_t, 1);\n    s->count = 0;\n    s->table = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n    return s;\n}\n\nvoid cpdbCopySettings(const cpdb_settings_t *source,\n                      cpdb_settings_t *dest)\n{\n    if (source == NULL || dest == NULL)\n    {\n        logwarn(\"Invalid params: cpdbCopySettings()\\n\");\n        return;\n    }\n\n    GHashTableIter iter;\n    g_hash_table_iter_init(&iter, source->table);\n    gpointer key, value;\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        cpdbAddSetting(dest, (char *)key, (char *)value);\n    }\n}\nvoid cpdbAddSetting(cpdb_settings_t *s, \n                    const char *name,\n                    const char *val)\n{\n    if (s == NULL || name == NULL) \n    {\n        logwarn(\"Invalid params: cpdbAddSettings()\\n\");\n        return;\n    }\n\n    gboolean new_entry = g_hash_table_insert(s->table,\n                                             cpdbGetStringCopy(name),\n                                             cpdbGetStringCopy(val));\n    if (new_entry)\n        s->count++;\n}\n\ngboolean cpdbClearSetting(cpdb_settings_t *s, const char *name)\n{\n    if (s == NULL || name == NULL) \n    {\n        logwarn(\"Invalid params: cpdbClearSetting()\\n\");\n        return FALSE;\n    }\n\n    if (g_hash_table_contains(s->table, name))\n    {\n        g_hash_table_remove(s->table, name);\n        s->count--;\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}\n\nGVariant *cpdbSerializeToGVariant(cpdb_settings_t *s)\n{\n    GVariantBuilder *builder;\n    GVariant *variant;\n    builder = g_variant_builder_new(G_VARIANT_TYPE(\"a(ss)\"));\n\n    GHashTableIter iter;\n    g_hash_table_iter_init(&iter, s->table);\n\n    gpointer key, value;\n    for (int i = 0; i < s->count; i++)\n    {\n        g_hash_table_iter_next(&iter, &key, &value);\n        g_variant_builder_add(builder, \"(ss)\", key, value);\n    }\n\n    if (s->count == 0)\n        g_variant_builder_add(builder, \"(ss)\", \"NA\", \"NA\");\n\n    variant = g_variant_new(\"a(ss)\", builder);\n    return variant;\n}\n\nvoid cpdbSaveSettingsToDisk(cpdb_settings_t *s)\n{\n    FILE *fp;\n    char *conf_dir, *path;\n    GHashTableIter iter;\n    gpointer key, value;\n\n    if ((conf_dir = cpdbGetUserConfDir()) == NULL)\n    {\n        logerror(\"Error saving settings to disk : Couldn't obtain user config dir\\n\");\n        return;\n    }\n    path = cpdbConcatPath(conf_dir, CPDB_PRINT_SETTINGS_FILE);\n\n    if ((fp = fopen(path, \"w\")) == NULL)\n    {\n        logerror(\"Error saving settings to disk : Couldn't open %s for writing\\n\",\n                    path);\n        return;\n    }\n    fprintf(fp, \"%d\\n\", s->count);\n    \n    g_hash_table_iter_init(&iter, s->table);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        fprintf(fp, \"%s#%s#\\n\", (char *)key, (char *)value);\n    }\n    loginfo(\"Saved %d settings on disk to %s\\n\", s->count, path);\n\n    fclose(fp);\n    free(path);\n    free(conf_dir);\n}\n\ncpdb_settings_t *cpdbReadSettingsFromDisk()\n{\n    FILE *fp;\n    int count;\n    char *name, *value, *conf_dir, *path;\n    char buf[CPDB_BSIZE];\n    cpdb_settings_t *s;\n\n    if ((conf_dir = cpdbGetUserConfDir()) == NULL)\n    {\n        logerror(\"No previous settings found : Couldn't obtain user config dir\\n\");\n        return NULL;\n    }\n    path = cpdbConcatPath(conf_dir, CPDB_PRINT_SETTINGS_FILE);\n\n    if ((fp = fopen(path, \"r\")) == NULL)\n    {\n        loginfo(\"No previous settings found : Couldn't open %s for reading\\n\",\n                    path);\n        free(path);\n        free(conf_dir);\n        \n        return NULL;\n    }\n\n    s = cpdbGetNewSettings();\n    if (fscanf(fp, \"%d\\n\", &count) == 0)\n    {\n        logerror(\"Error getting settings from disk : Couldn't parse %s\\n\",\n                    path);\n        fclose(fp);\n        free(path);\n        free(conf_dir);\n        cpdbDeleteSettings(s);\n        return NULL;\n    }\n    while (count--)\n    {\n        if (fgets(buf, sizeof(buf), fp) == NULL)\n            break;\n        name = strtok(buf, \"#\");\n        value = strtok(NULL, \"#\");\n        cpdbAddSetting(s, name, value);\n    }\n    loginfo(\"Retrievied %d settings from disk at %s\\n\", s->count, path);\n\n    fclose(fp);\n    free(path);\n    free(conf_dir);\n    return s;\n}\n\nvoid cpdbDeleteSettings(cpdb_settings_t *s)\n{\n    if (s == NULL)\n        return;\n    \n    if (s->table)\n        g_hash_table_destroy(s->table);\n    \n    free(s);\n}\n/**\n________________________________________________ cpdb_options_t __________________________________________\n**/\ncpdb_options_t *cpdbGetNewOptions()\n{\n    cpdb_options_t *o = g_new0(cpdb_options_t, 1);\n    o->count = 0;\n    o->table = g_hash_table_new_full(g_str_hash,\n                                     g_str_equal,\n                                     g_free,\n                                     (GDestroyNotify) cpdbDeleteOption);\n    o->media_count = 0;\n    o->media = g_hash_table_new_full(g_str_hash,\n                                     g_str_equal,\n                                     g_free,\n                                     (GDestroyNotify) cpdbDeleteMedia);\n    return o;\n}\n\nvoid cpdbDeleteOptions(cpdb_options_t *opts)\n{\n    if (opts == NULL)\n        return;\n    \n    if (opts->table)\n        g_hash_table_destroy(opts->table);\n    if (opts->media)\n        g_hash_table_destroy(opts->media);\n\n    free(opts);\n}\n\n/**************cpdb_option_t************************************/\n\nvoid cpdbDeleteOption(cpdb_option_t *opt)\n{\n    if (opt == NULL)\n        return;\n    \n    if (opt->option_name)\n        free(opt->option_name);\n    if (opt->group_name)\n        free(opt->group_name);\n    if (opt->supported_values)\n        free(opt->supported_values);\n    if (opt->default_value)\n        free(opt->default_value);\n\n    free(opt);\n}\n\n/**************cpdb_option_t************************************/\n\nvoid cpdbDeleteMedia(cpdb_media_t *media)\n{\n    if (media == NULL)\n        return;\n    \n    if (media->name)\n        free(media->name);\n    if (media->margins)\n        free(media->margins);\n    \n    free(media);\n}\n\n/**\n * ________________________________ cpdb_job_t __________________________\n */\nvoid cpdbUnpackJobArray(GVariant *var,\n                        int num_jobs,\n                        cpdb_job_t *jobs,\n                        char *backend_name)\n{\n    int i;\n    char *str;\n    GVariantIter *iter;\n    g_variant_get(var, CPDB_JOB_ARRAY_ARGS, &iter);\n    int size;\n    char *jobid, *title, *printer, *user, *state, *submit_time;\n    for (i = 0; i < num_jobs; i++)\n    {\n        g_variant_iter_loop(iter,\n                            CPDB_JOB_ARGS,\n                            &jobid,\n                            &title,\n                            &printer,\n                            &user,\n                            &state,\n                            &submit_time,\n                            &size);\n        logdebug(\"jobid=%s;\\n\", jobid);\n        jobs[i].job_id = cpdbGetStringCopy(jobid);\n        logdebug(\"title=%s;\\n\", title);\n        jobs[i].title = cpdbGetStringCopy(title);\n        logdebug(\"printer=%s;\\n\", printer);\n        jobs[i].printer_id = cpdbGetStringCopy(printer);\n        logdebug(\"backend_name=%s;\\n\", backend_name);\n        jobs[i].backend_name = backend_name;\n        logdebug(\"user=%s;\\n\", user);\n        jobs[i].user = cpdbGetStringCopy(user);\n        logdebug(\"state=%s;\\n\", state);\n        jobs[i].state = cpdbGetStringCopy(state);\n        logdebug(\"submit_time=%s;\\n\", submit_time);\n        jobs[i].submitted_at = cpdbGetStringCopy(submit_time);\n        logdebug(\"size=%d;\\n\", size);\n        jobs[i].size = size;\n    }\n}\n/**\n * ________________________________utility functions__________________________\n */\n\nvoid cpdbUnpackOptions(int num_options,\n                       GVariant *opts_var,\n                       int num_media,\n                       GVariant *media_var,\n                       cpdb_options_t *options)\n{\n    cpdb_option_t *opt;\n    cpdb_media_t *media;\n    char buf[CPDB_BSIZE];\n    int i, j, num, width, length, l, r, t, b;\n    GVariantIter *iter, *sub_iter;\n    char *str, *name, *def, *group;\n    \n    options->count = num_options;\n    g_variant_get(opts_var, \"a(sssia(s))\", &iter);\n    for (i = 0; i < num_options; i++)\n    {\n        opt = g_new0(cpdb_option_t, 1);\n        g_variant_iter_loop(iter, \"(sssia(s))\",\n                            &name, &group, &def, &num, &sub_iter);\n\n        logdebug(\"name=%s;\\n\", name);\n        opt->option_name = cpdbGetStringCopy(name);\n        logdebug(\"group=%s;\\n\", group);\n        opt->group_name = cpdbGetStringCopy(group);\n        logdebug(\"default=%s;\\n\", def);\n        opt->default_value = cpdbGetStringCopy(def);\n        logdebug(\"num_choices=%d;\\n\", num);\n        opt->num_supported = num;\n        logdebug(\"choices:\\n\");\n        opt->supported_values = cpdbNewCStringArray(num);\n        for (j = 0; j < num; j++)\n        {\n            g_variant_iter_loop(sub_iter, \"(s)\", &str);\n            logdebug(\"  %s;\\n\", str);\n            opt->supported_values[j] = cpdbGetStringCopy(str);\n        }\n        g_hash_table_insert(options->table, cpdbGetStringCopy(opt->option_name), opt);\n    }\n    \n    options->media_count = num_media;\n    g_variant_get(media_var, \"a(siiia(iiii))\", &iter);\n    for (i = 0; i < num_media; i++)\n    {\n\t\tmedia = g_new0(cpdb_media_t, 1);\n\t\tg_variant_iter_loop(iter, \"(siiia(iiii))\",\n\t\t\t\t\t\t\t&name, &width, &length, &num, &sub_iter);\n        \n        logdebug(\"name=%s;\\n\", name);\n\t\tmedia->name = cpdbGetStringCopy(name);\n        logdebug(\"width=%d;\\n\", width);\n\t\tmedia->width = width;\n        logdebug(\"length=%d;\\n\", length);\n\t\tmedia->length = length;\n        logdebug(\"num_margins=%d;\\n\", num);\n\t\tmedia->num_margins = num;\n\t\tmedia->margins = g_new0(cpdb_margin_t, num);\n\t\tfor (j = 0; j < num; j++)\n\t\t{\n\t\t\tg_variant_iter_loop(sub_iter, \"(iiii)\", &l, &r, &t, &b);\n            logdebug(\"    %d,%d,%d,%d;\\n\", l, r, t, b);\n\t\t\tmedia->margins[j].left = l;\n            media->margins[j].right = r;\n            media->margins[j].top = t; \n            media->margins[j].bottom = b;\n\t\t}\n\t\tg_hash_table_insert(options->media, cpdbGetStringCopy(media->name), media);\n\t}\n    \n}\n\nstatic GHashTable *cpdbUnpackTranslations (GVariant *variant)\n{\n    GVariantIter iter;\n    gchar *key, *value;\n    GHashTable *translations;\n\n    translations = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n    g_variant_iter_init(&iter, variant);\n    while (g_variant_iter_loop(&iter, CPDB_TL_ARGS, &key, &value))\n    {\n        logdebug(\"Fetched translation '%s' : '%s'\\n\", key, value);\n        g_hash_table_insert(translations,\n                            cpdbGetStringCopy(key), cpdbGetStringCopy(value));\n    }\n\n    return translations;\n}\n\n\n/************************************************************************************************/\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <locale.h>\n\n#include <glib.h>\n#include <libintl.h>\n\n#include <cpdb/frontend.h>\n\n#define BUFSIZE 1024\n\nvoid display_help();\ngpointer parse_commands(gpointer user_data);\ncpdb_frontend_obj_t *f;\nstatic const char *locale;\n\nstatic void printBasicOptions(const cpdb_printer_obj_t *p)\n{\n    printf(\"-------------------------\\n\");\n    printf(\"Printer %s\\n\", p->id);\n    printf(\"name: %s\\n\", p->name);\n    printf(\"location: %s\\n\", p->location);\n    printf(\"info: %s\\n\", p->info);\n    printf(\"make and model: %s\\n\", p->make_and_model);\n    printf(\"accepting jobs? %s\\n\", (p->accepting_jobs ? \"yes\" : \"no\"));\n    printf(\"state: %s\\n\", p->state);\n    printf(\"backend: %s\\n\", p->backend_name);\n    printf(\"-------------------------\\n\\n\");\n}\n\nstatic void printMedia(const cpdb_media_t *media)\n{\n    printf(\"[+] Media: %s\\n\", media->name);\n    printf(\"   * width = %d\\n\", media->width);\n    printf(\"   * length = %d\\n\", media->length);\n    printf(\" --> Supported margins: %d\\n\", media->num_margins);\n    printf(\"     left, right, top, bottom\\n\");\n    for (int i = 0; i < media->num_margins; i++)\n    {\n        printf(\"     * %d, %d, %d, %d,\\n\",\n               media->margins[i].left,\n               media->margins[i].right,\n               media->margins[i].top,\n               media->margins[i].bottom);\n    }\n    printf(\"\\n\");\n}\n\nstatic void printOption(const cpdb_option_t *opt)\n{\n    int i;\n    \n    printf(\"[+] %s\\n\", opt->option_name);\n    printf(\" --> GROUP: %s\\n\", opt->group_name);\n    for (i = 0; i < opt->num_supported; i++)\n    {\n        printf(\"   * %s\\n\", opt->supported_values[i]);\n    }\n    printf(\" --> DEFAULT: %s\\n\\n\", opt->default_value);\n}\n\nstatic void printTranslations(cpdb_printer_obj_t *p)\n{\n    GHashTableIter iter;\n    gpointer key, value;\n\n    if (p->locale == NULL || p->translations == NULL)\n    {\n        printf(\"No translations found\\n\");\n        return;\n    }\n\n    g_hash_table_iter_init(&iter, p->translations);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        printf(\"'%s' : '%s'\\n\", (char *)key, (char *)value);\n    }\n}\n\nstatic void displayAllPrinters(cpdb_frontend_obj_t *f)\n{\n    GHashTableIter iter;\n    gpointer key, value;\n\n    g_hash_table_iter_init(&iter, f->printer);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        const cpdb_printer_obj_t *p = value;\n        printBasicOptions(p);\n    }\n}\n\nstatic void printer_callback(cpdb_frontend_obj_t *f, cpdb_printer_obj_t *p, cpdb_printer_update_t change)\n{\n    switch(change)\n    {\n    case CPDB_CHANGE_PRINTER_ADDED:\n        g_message(\"Added printer %s : %s!\\n\", p->name, p->backend_name);\n        printBasicOptions(p);\n        break;\n\n    case CPDB_CHANGE_PRINTER_REMOVED:\n        g_message(\"Removed printer %s : %s!\\n\", p->name, p->backend_name);\n        cpdbDeletePrinterObj(p);\n        break;\n    \n    case CPDB_CHANGE_PRINTER_STATE_CHANGED:\n        g_message(\"Printer state changed for %s : %s to \\\"%s\\\"\", p->name, p->backend_name, p->state);\n        break;\n    }\n}\n\nstatic void acquire_details_callback(cpdb_printer_obj_t *p, int success, void *user_data)\n{\n    if (success)\n        g_message(\"Details acquired for %s : %s\\n\", p->name, p->backend_name);\n    else\n        g_message(\"Could not acquire printer details for %s : %s\\n\", p->name, p->backend_name);\n}\n\nstatic void acquire_translations_callback(cpdb_printer_obj_t *p, int success, void *user_data)\n{\n    if (!success)\n        g_message(\"Could not acquire printer translations for %s : %s\\n\", p->name, p->backend_name);\n    g_message(\"Translations acquired for %s : %s\\n\", p->name, p->backend_name);\n    printTranslations(p);\n}\n\nint main(int argc, char **argv)\n{\n    cpdb_printer_callback printer_cb = (cpdb_printer_callback)printer_callback;\n\n    setlocale (LC_ALL, \"\");\n    cpdbInit();\n\n    locale = getenv(\"LANGUAGE\");\n\n    char *dialog_bus_name = malloc(300);\n    if (argc > 1) //this is for creating multiple instances of a dialog simultaneously\n        f = cpdbGetNewFrontendObj(argv[1], printer_cb);\n    else\n        f = cpdbGetNewFrontendObj(NULL, printer_cb);\n\n    /** Uncomment the line below if you don't want to use the previously saved settings**/\n    cpdbIgnoreLastSavedSettings(f);\n    g_thread_new(\"parse_commands_thread\", parse_commands, NULL);\n    cpdbConnectToDBus(f);\n    displayAllPrinters(f);\n    GMainLoop *loop = g_main_loop_new(NULL, FALSE);\n    g_main_loop_run(loop);\n}\n\ngpointer parse_commands(gpointer user_data)\n{\n    fflush(stdout);\n    char buf[BUFSIZE];\n    while (1)\n    {\n        printf(\"> \");\n        fflush(stdout);\n        scanf(\"%s\", buf);\n        if (strcmp(buf, \"stop\") == 0)\n        {\n            cpdbDeleteFrontendObj(f);\n            g_message(\"Stopping front end..\\n\");\n            exit(0);\n        }\n        else if (strcmp(buf, \"restart\") == 0)\n        {\n            cpdbDisconnectFromDBus(f);\n            cpdbConnectToDBus(f);\n        }\n        else if (strcmp(buf, \"hide-remote\") == 0)\n        {\n            cpdbHideRemotePrinters(f);\n            g_message(\"Hiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"unhide-remote\") == 0)\n        {\n            cpdbUnhideRemotePrinters(f);\n            g_message(\"Unhiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"hide-temporary\") == 0)\n        {\n            cpdbHideTemporaryPrinters(f);\n            g_message(\"Hiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"unhide-temporary\") == 0)\n        {\n            cpdbUnhideTemporaryPrinters(f);\n            g_message(\"Unhiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"get-all-options\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            g_message(\"Getting all attributes ..\\n\");\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(p == NULL)\n              continue;\n\n            cpdb_options_t *opts = cpdbGetAllOptions(p);\n\n            printf(\"Retrieved %d options.\\n\", opts->count);\n            GHashTableIter iter;\n            gpointer value;\n\n            g_hash_table_iter_init(&iter, opts->table);\n            while (g_hash_table_iter_next(&iter, NULL, &value))\n            {\n                printOption(value);\n            }\n        }\n        else if (strcmp(buf, \"get-all-media\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            g_message(\"Getting all attributes ..\\n\");\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(p == NULL)\n              continue;\n\n            cpdb_options_t *opts = cpdbGetAllOptions(p);\n\n            printf(\"Retrieved %d medias.\\n\", opts->media_count);\n            GHashTableIter iter;\n            gpointer value;\n\n            g_hash_table_iter_init(&iter, opts->media);\n            while (g_hash_table_iter_next(&iter, NULL, &value))\n            {\n                printMedia(value);\n            }\n        }\n        else if (strcmp(buf, \"get-default\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetDefault(p, option_name);\n            if (!ans)\n                printf(\"cpdb_option_t %s doesn't exist.\", option_name);\n            else\n                printf(\"Default : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"get-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], setting_name[BUFSIZE];\n            scanf(\"%s%s%s\", setting_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetSetting(p, setting_name);\n            if (!ans)\n                printf(\"Setting %s doesn't exist.\\n\", setting_name);\n            else\n                printf(\"Setting value : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"get-current\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetCurrent(p, option_name);\n            if (!ans)\n                printf(\"cpdb_option_t %s doesn't exist.\", option_name);\n            else\n                printf(\"Current value : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"add-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE], option_val[BUFSIZE];\n            scanf(\"%s %s %s %s\", option_name, option_val, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s : %s\\n\", option_name, option_val);\n            cpdbAddSettingToPrinter(p, cpdbGetStringCopy(option_name), cpdbGetStringCopy(option_val));\n        }\n        else if (strcmp(buf, \"clear-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbClearSettingFromPrinter(p, option_name);\n        }\n        else if (strcmp(buf, \"get-state\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetState(p));\n        }\n        else if (strcmp(buf, \"is-accepting-jobs\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"Accepting jobs ? : %d \\n\", cpdbIsAcceptingJobs(p));\n        }\n        else if (strcmp(buf, \"help\") == 0)\n        {\n            display_help();\n        }\n        else if (strcmp(buf, \"ping\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            print_backend_call_ping_sync(p->backend_proxy, p->id, NULL, NULL);\n        }\n        else if (strcmp(buf, \"get-default-printer\") == 0)\n        {\n            cpdb_printer_obj_t *p = cpdbGetDefaultPrinter(f);\n            if (p)\n                printf(\"%s#%s\\n\", p->name, p->backend_name);\n            else\n                printf(\"No default printer found\\n\");\n        }\n        else if (strcmp(buf, \"get-default-printer-for-backend\") == 0)\n        {\n            char backend_name[BUFSIZE];\n            scanf(\"%s\", backend_name);\n            /**\n             * Backend name = The last part of the backend dbus service\n             * Eg. \"CUPS\" or \"GCP\"\n             */\n            cpdb_printer_obj_t *p = cpdbGetDefaultPrinterForBackend(f, backend_name);\n            printf(\"%s\\n\", p->name);\n        }\n        else if (strcmp(buf, \"set-user-default-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (p)\n            {\n                if (cpdbSetUserDefaultPrinter(p))\n                    printf(\"Set printer as user default\\n\");\n                else\n                    printf(\"Couldn't set printer as user default\\n\");\n            }\n        }\n        else if (strcmp(buf, \"set-system-default-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (p)\n            {\n                if (cpdbSetSystemDefaultPrinter(p))\n                    printf(\"Set printer as system default\\n\");\n                else\n                    printf(\"Couldn't set printer as system default\\n\");\n            }\n        }\n        else if (strcmp(buf, \"print-file\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], file_path[BUFSIZE];\n            scanf(\"%s%s%s\", file_path, printer_id, backend_name);\n            /**\n             * Try adding some settings here .. change them and experiment\n             */\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(strcmp(backend_name, \"FILE\") == 0)\n            {\n              char final_file_path[BUFSIZE];\n              printf(\"Please give the final file path: \");\n              scanf(\"%s\", final_file_path);\n              cpdbPrintFilePath(p, file_path, final_file_path);\n              continue;\n            }\n\n            cpdbAddSettingToPrinter(p, \"copies\", \"3\");\n            cpdbPrintFile(p, file_path);\n        }\n        else if (strcmp(buf, \"get-active-jobs-count\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%d jobs currently active.\\n\", cpdbGetActiveJobsCount(p));\n        }\n        else if (strcmp(buf, \"get-all-jobs\") == 0)\n        {\n            int active_only;\n            scanf(\"%d\", &active_only);\n            cpdb_job_t *j;\n            int x = cpdbGetAllJobs(f, &j, active_only);\n            printf(\"Total %d jobs\\n\", x);\n            int i;\n            for (i = 0; i < x; i++)\n            {\n                printf(\"%s .. %s  .. %s  .. %s  .. %s\\n\", j[i].job_id, j[i].title, j[i].printer_id, j[i].state, j[i].submitted_at);\n            }\n        }\n        else if (strcmp(buf, \"cancel-job\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char job_id[BUFSIZE];\n            scanf(\"%s%s%s\", job_id, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (cpdbCancelJob(p, job_id))\n                printf(\"cpdb_job_t %s has been cancelled.\\n\", job_id);\n            else\n                printf(\"Unable to cancel job %s\\n\", job_id);\n        }\n        else if (strcmp(buf, \"pickle-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char job_id[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbPicklePrinterToFile(p, \"/tmp/.printer-pickle\", f);\n        }\n        else if (strcmp(buf, \"get-option-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char option_name[BUFSIZE];\n            scanf(\"%s%s%s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetOptionTranslation(p, option_name, locale));\n        }\n        else if (strcmp(buf, \"get-choice-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char option_name[BUFSIZE];\n            char choice_name[BUFSIZE];\n            scanf(\"%s%s%s%s\", option_name, choice_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetChoiceTranslation(p, option_name, choice_name, locale));\n        }\n        else if (strcmp(buf, \"get-group-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char group_name[BUFSIZE];\n            scanf(\"%s%s%s\", group_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetGroupTranslation(p, group_name, locale));\n        }\n        else if (strcmp(buf, \"get-all-translations\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbGetAllTranslations(p, locale);\n            printTranslations(p);\n        }\n        else if (strcmp(buf, \"get-media-size\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char media[BUFSIZE];\n            int width, length;\n            scanf(\"%s%s%s\", media, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            int ok = cpdbGetMediaSize(p, media, &width, &length);\n            if (ok)\n                printf(\"%dx%d\\n\", width, length);\n        }\n        else if (strcmp(buf, \"get-media-margins\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char media[BUFSIZE];\n            scanf(\"%s%s%s\", media, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            cpdb_margin_t *margins;\n            int num_margins = cpdbGetMediaMargins(p, media, &margins);\n            for (int i = 0; i < num_margins; i++)\n                printf(\"%d %d %d %d\\n\", margins[i].left, margins[i].right, margins[i].top, margins[i].bottom);\n        }\n        else if (strcmp(buf, \"acquire-details\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            \n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if(p == NULL)\n              continue;\n\n            g_message(\"Acquiring printer details asynchronously...\\n\");\n            cpdbAcquireDetails(p, acquire_details_callback, NULL);\n\t\t}\n        else if (strcmp(buf, \"acquire-translations\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%s%s\", printer_id, backend_name);\n            \n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if(p == NULL)\n              continue;\n\n            g_message(\"Acquiring printer translations asynchronously...\\n\");\n            cpdbAcquireTranslations(p, locale, acquire_translations_callback, NULL);\n        }\n    }\n}\n\nvoid display_help()\n{\n    g_message(\"Available commands .. \");\n    printf(\"%s\\n\", \"stop\");\n    printf(\"%s\\n\", \"hide-remote\");\n    printf(\"%s\\n\", \"unhide-remote\");\n    printf(\"%s\\n\", \"hide-temporary\");\n    printf(\"%s\\n\", \"unhide-temporary\");\n    //printf(\"%s\\n\", \"ping <printer id> \");\n    printf(\"%s\\n\", \"get-default-printer\");\n    printf(\"%s\\n\", \"get-default-printer-for-backend <backend name>\");\n    printf(\"%s\\n\", \"set-user-default-printer <printer id> <backend name>\");\n    printf(\"%s\\n\", \"set-system-default-printer <printer id> <backend name>\");\n    printf(\"%s\\n\", \"print-file <file path> <printer_id> <backend_name>\");\n    printf(\"%s\\n\", \"get-active-jobs-count <printer-name> <backend-name>\");\n    printf(\"%s\\n\", \"get-all-jobs <0 for all jobs; 1 for only active>\");\n    printf(\"%s\\n\", \"get-state <printer id> <backend name>\");\n    printf(\"%s\\n\", \"is-accepting-jobs <printer id> <backend name(like \\\"CUPS\\\")>\");\n    printf(\"%s\\n\", \"cancel-job <job-id> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"acquire-details <printer id> <backend name>\");\n    printf(\"%s\\n\", \"acquire-translations <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-all-options <printer-name> <backend-name>\");\n    printf(\"%s\\n\", \"get-default <option name> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-setting <option name> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-current <option name> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"add-setting <option name> <option value> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"clear-setting <option name> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-media-size <media> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-media-margins <media> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-option-translation <option> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-choice-translation <option> <choice> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-group-translation <group> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-all-translations <printer id> <backend name>\");\n    printf(\"%s\\n\", \"pickle-printer <printer id> <backend name>\\n\");\n}\n"], "fixing_code": ["#include \"cpdb-frontend.h\"\n\nstatic void                 on_printer_added                (GDBusConnection *          connection,\n                                                             const gchar *              sender_name,\n                                                             const gchar *              object_path,\n                                                             const gchar *              interface_name,\n                                                             const gchar *              signal_name,\n                                                             GVariant *                 parameters,\n                                                             gpointer                   user_data);\nstatic void                 on_printer_removed              (GDBusConnection *          connection,\n                                                             const gchar *              sender_name,\n                                                             const gchar *              object_path,\n                                                             const gchar *              interface_name,\n                                                             const gchar *              signal_name,\n                                                             GVariant *                 parameters,\n                                                             gpointer                   user_data);\nstatic void                 on_printer_state_changed        (GDBusConnection *          connection,\n                                                             const gchar *              sender_name,\n                                                             const gchar *              object_path,\n                                                             const gchar *              interface_name,\n                                                             const gchar *              signal_name,\n                                                             GVariant *                 parameters,\n                                                             gpointer                   user_data);\n\nstatic void                 on_name_acquired                (GDBusConnection *          connection,\n                                                             const gchar *              name,\n                                                            gpointer                   user_data);\nstatic void                 on_name_lost                    (GDBusConnection *          connection,\n                                                             const gchar *              name,\n                                                             gpointer                   user_data);\n\nstatic void                 fetchPrinterListFromBackend     (cpdb_frontend_obj_t *      frontend_obj,\n                                                             const char *               backend);\n                                             \nstatic void                 cpdbActivateBackends            (cpdb_frontend_obj_t *      frontend_obj);\n\nstatic GList *              cpdbLoadDefaultPrinters         (const char *               path);\n\nstatic int                  cpdbSetDefaultPrinter           (const char *               path,\n                                                             cpdb_printer_obj_t *       printer_obj);\n\nstatic void                 cpdbFillBasicOptions            (cpdb_printer_obj_t *       printer_obj,\n                                                             GVariant *                 variant);\n\nstatic void                 cpdbDeleteTranslations          (cpdb_printer_obj_t *       printer_obj);\n\nstatic void                 cpdbUnpackOptions               (int                        num_options,\n                                                             GVariant *                 var,\n                                                             int                        num_media,\n                                                             GVariant *                 media_var,\n                                                             cpdb_options_t *           options);\nstatic void                 cpdbUnpackJobArray              (GVariant *                 var,\n                                                             int                        num_jobs,\n                                                             cpdb_job_t *               jobs,\n                                                             char *                     backend_name);\nstatic GHashTable *         cpdbUnpackTranslations          (GVariant *                 translations);\n\n/**\n________________________________________________ cpdb_frontend_obj_t __________________________________________\n\n**/\n\ncpdb_frontend_obj_t *cpdbGetNewFrontendObj(const char *instance_name,\n                                           cpdb_printer_callback printer_cb)\n{\n    cpdb_frontend_obj_t *f = g_new0(cpdb_frontend_obj_t, 1);\n    \n    f->skeleton = print_frontend_skeleton_new();\n    f->connection = NULL;\n    f->own_id = 0;\n    f->name_done = FALSE;\n    if (instance_name == NULL)\n        f->bus_name = cpdbGetStringCopy(CPDB_DIALOG_BUS_NAME);\n    else\n        f->bus_name = cpdbConcat(CPDB_DIALOG_BUS_NAME, instance_name);\n    f->printer_cb = printer_cb;\n    f->num_backends = 0;\n    f->backend = g_hash_table_new_full(g_str_hash,\n                                       g_str_equal,\n                                       free,\n                                       g_object_unref);\n    f->num_printers = 0;\n    f->printer = g_hash_table_new_full(g_str_hash,\n                                       g_str_equal,\n                                       free,\n                                       NULL);\n    f->last_saved_settings = cpdbReadSettingsFromDisk();\n    return f;\n}\n\nvoid cpdbDeleteFrontendObj(cpdb_frontend_obj_t *f)\n{\n    if (f == NULL)\n        return;\n    logdebug(\"Deleting frontend obj %s\\n\", f->bus_name);\n\n    cpdbDisconnectFromDBus(f);\n\n    if (f->skeleton)\n        g_object_unref(f->skeleton);\n    if (f->bus_name)\n        free(f->bus_name);\n    if (f->backend)\n        g_hash_table_destroy(f->backend);\n    if (f->printer)\n        g_hash_table_destroy(f->printer);\n    if (f->last_saved_settings)\n        cpdbDeleteSettings(f->last_saved_settings);\n    \n    free(f);\n}\n\nstatic void on_printer_added(GDBusConnection *connection,\n                             const gchar *sender_name,\n                             const gchar *object_path,\n                             const gchar *interface_name,\n                             const gchar *signal_name,\n                             GVariant *parameters,\n                             gpointer user_data)\n{\n    cpdb_frontend_obj_t *f = (cpdb_frontend_obj_t *)user_data;\n    cpdb_printer_obj_t *p = cpdbGetNewPrinterObj();\n    \n    /* If some previously saved settings were retrieved, \n     * use them in this new cpdb_printer_obj_t */\n    if (f->last_saved_settings != NULL)\n    {\n        cpdbCopySettings(f->last_saved_settings, p->settings);\n    }\n    cpdbFillBasicOptions(p, parameters);\n    cpdbAddPrinter(f, p);\n    f->printer_cb(f, p, CPDB_CHANGE_PRINTER_ADDED);\n}\n\nstatic void on_printer_removed(GDBusConnection *connection,\n                               const gchar *sender_name,\n                               const gchar *object_path,\n                               const gchar *interface_name,\n                               const gchar *signal_name,\n                               GVariant *parameters,\n                               gpointer user_data)\n{\n    cpdb_frontend_obj_t *f = (cpdb_frontend_obj_t *)user_data;\n    char *printer_id;\n    char *backend_name;\n    \n    g_variant_get(parameters, \"(ss)\", &printer_id, &backend_name);\n    cpdb_printer_obj_t *p = cpdbRemovePrinter(f, printer_id, backend_name);\n    f->printer_cb(f, p, CPDB_CHANGE_PRINTER_REMOVED);\n}\n\nstatic void on_printer_state_changed(GDBusConnection *connection,\n                                     const gchar *sender_name,\n                                     const gchar *object_path,\n                                     const gchar *interface_name,\n                                     const gchar *signal_name,\n                                     GVariant *parameters,\n                                     gpointer user_data)\n{\n    cpdb_frontend_obj_t *f = (cpdb_frontend_obj_t *) user_data;\n    gboolean printer_is_accepting_jobs;\n    char *printer_id, *printer_state, *backend_name;\n\n    g_variant_get(parameters, \"(ssbs)\", &printer_id, &printer_state,\n                    &printer_is_accepting_jobs, &backend_name);\n    cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n    if (p->state)\n        free(p->state);\n    p->state = cpdbGetStringCopy(printer_state);\n    p->accepting_jobs = printer_is_accepting_jobs;\n    f->printer_cb(f, p, CPDB_CHANGE_PRINTER_STATE_CHANGED);\n}\n\nstatic void on_name_acquired(GDBusConnection *connection,\n                             const gchar *name,\n                             gpointer user_data)\n{\n    GError *error = NULL;\n    cpdb_frontend_obj_t *f = user_data;\n\n    logdebug(\"Acquired bus name %s\\n\", name);\n    \n    g_dbus_connection_signal_subscribe(connection,\n                                       NULL,                            //Sender name\n                                       \"org.openprinting.PrintBackend\", //Sender interface\n                                       CPDB_SIGNAL_PRINTER_ADDED,       //Signal name\n                                       NULL,                            /**match on all object paths**/\n                                       NULL,                            /**match on all arguments**/\n                                       0,                               //Flags\n                                       on_printer_added,                //callback\n                                       user_data,                       //user_data\n                                       NULL);\n\n    g_dbus_connection_signal_subscribe(connection,\n                                       NULL,                            //Sender name\n                                       \"org.openprinting.PrintBackend\", //Sender interface\n                                       CPDB_SIGNAL_PRINTER_REMOVED,     //Signal name\n                                       NULL,                            /**match on all object paths**/\n                                       NULL,                            /**match on all arguments**/\n                                       0,                               //Flags\n                                       on_printer_removed,              //callback\n                                       user_data,                       //user_data\n                                       NULL);\n    g_dbus_connection_signal_subscribe(connection,\n                                       NULL,                                //Sender name\n                                       \"org.openprinting.PrintBackend\",     //Sender interface\n                                       CPDB_SIGNAL_PRINTER_STATE_CHANGED,   //Signal name\n                                       NULL,                                /**match on all object paths**/\n                                       NULL,                                /**match on all arguments**/\n                                       0,                                   //Flags\n                                       on_printer_state_changed,            //callback\n                                       user_data,                           //user_data\n                                       NULL);\n\n    g_dbus_interface_skeleton_export(G_DBUS_INTERFACE_SKELETON(f->skeleton),\n                                     connection, \n                                     CPDB_DIALOG_OBJ_PATH,\n                                     &error);\n    if (error)\n    {\n        logerror(\"Error exporting frontend interface : %s\\n\", error->message);\n        return;\n    }\n    \n    cpdbActivateBackends(f);\n    f->name_done = TRUE;\n}\n\nstatic void on_name_lost(GDBusConnection *connection,\n                         const gchar *name,\n                         gpointer user_data)\n{\n    logdebug(\"Lost bus name %s\\n\", name);\n    cpdb_frontend_obj_t *f = user_data;\n    f->name_done = TRUE;\n}\n\nstatic GDBusConnection *get_dbus_connection()\n{\n    gchar *bus_addr;\n    GError *error = NULL;\n    GDBusConnection *connection;\n    \n    bus_addr = g_dbus_address_get_for_bus_sync(G_BUS_TYPE_SESSION,\n                                               NULL,\n                                               &error);\n    \n    connection = g_dbus_connection_new_for_address_sync(bus_addr,\n                                                        G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT |\n                                                        G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION,\n                                                        NULL,\n                                                        NULL,\n                                                        &error);\n    if (error)\n    {\n        logerror(\"Error acquiring bus connection : %s\\n\", error->message);\n        return NULL;\n    }\n    logdebug(\"Acquired bus connection\\n\");\n    return connection;\n}\n\nvoid cpdbConnectToDBus(cpdb_frontend_obj_t *f)\n{\n    GMainContext *context;\n\n    if ((f->connection = get_dbus_connection()) == NULL)\n    {\n        loginfo(\"Couldn't connect to DBus\\n\");\n        return;\n    }\n    \n    f->own_id = g_bus_own_name_on_connection(f->connection,\n                                             f->bus_name,\n                                             0,\n                                             on_name_acquired,\n                                             on_name_lost,\n                                             f,\n                                             NULL);\n\n    // Wait till either of name acquired/lost callbacks finish\n    context = g_main_context_get_thread_default();\n    while (!f->name_done)\n    {\n        g_main_context_iteration(context, TRUE);\n    }\n}\n\nvoid cpdbDisconnectFromDBus(cpdb_frontend_obj_t *f)\n{\n    if (f->connection == NULL || g_dbus_connection_is_closed(f->connection))\n    {\n        logwarn(\"Already disconnected from DBus\\n\");\n        return;\n    }\n    \n    print_frontend_emit_stop_listing(f->skeleton);\n    g_dbus_connection_flush_sync(f->connection, NULL, NULL);\n    \n    g_bus_unown_name(f->own_id);\n    g_dbus_connection_close_sync(f->connection, NULL, NULL);\n}\n\nstatic void fetchPrinterListFromBackend(cpdb_frontend_obj_t *f, const char *backend)\n{\n    int num_printers;\n    GVariantIter iter;\n    GVariant *printers, *printer;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    cpdb_printer_obj_t *p;\n\n    if ((proxy = g_hash_table_lookup(f->backend, backend)) == NULL)\n    {\n        logerror(\"Couldn't get %s proxy object\\n\", backend);\n        return;\n    }\n    print_backend_call_get_printer_list_sync (proxy, &num_printers,\n                                                &printers, NULL, &error);\n    if (error)\n    {\n        logerror(\"Error getting %s printer list : %s\\n\", backend, error->message);\n        return;\n    }\n    logdebug(\"Fetched %d printers from backend %s\\n\", num_printers, backend);\n    g_variant_iter_init(&iter, printers);\n    while (g_variant_iter_loop(&iter, \"(v)\", &printer))\n    {\n        p = cpdbGetNewPrinterObj();\n        cpdbFillBasicOptions(p, printer);\n        if (f->last_saved_settings != NULL)\n            cpdbCopySettings(f->last_saved_settings, p->settings);\n        cpdbAddPrinter(f, p);\n    }\n}\n\nstatic void cpdbActivateBackends(cpdb_frontend_obj_t *f)\n{\n    DIR *d;\n    int len;\n    const char *info_dir_name;\n    struct dirent *dir;\n    PrintBackend *proxy;\n    char *backend_suffix;\n\n    logdebug(\"Activating backends\\n\");\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    if ((d = opendir(info_dir_name)) == NULL)\n    {\n        logerror(\"Couldn't open backend info directory : %s\\n\",\n\t\t info_dir_name);\n        return;\n    }\n    len = strlen(CPDB_BACKEND_PREFIX);\n\n    while ((dir = readdir (d)) != NULL)\n    {\n        if (strncmp(CPDB_BACKEND_PREFIX, dir->d_name, len) == 0)\n        {\n            backend_suffix = cpdbGetStringCopy((dir->d_name) + len);\n            loginfo(\"Found backend %s\\n\", backend_suffix);\n            proxy = cpdbCreateBackendFromFile(f->connection, dir->d_name);\n            g_hash_table_insert(f->backend, backend_suffix, proxy);\n            f->num_backends++;\n            fetchPrinterListFromBackend(f, backend_suffix);\n        }\n    }\n    closedir(d);\n}\n\nPrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    \n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    \n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%1023s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    \n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    \n    return proxy;\n}\n\nvoid cpdbIgnoreLastSavedSettings(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Ignoring previous settings\\n\");\n    cpdbDeleteSettings(f->last_saved_settings);\n    f->last_saved_settings = NULL;\n}\n\ngboolean cpdbAddPrinter(cpdb_frontend_obj_t *f, \n                        cpdb_printer_obj_t *p)\n{\n    p->backend_proxy = g_hash_table_lookup(f->backend, p->backend_name);\n    if (p->backend_proxy == NULL)\n    {\n        logerror(\"Couldn't add printer %s : Backend doesn't exist %s\\n\",\n                    p->id, p->backend_name);\n        return FALSE;\n    }\n    g_object_ref(p->backend_proxy);\n\n    loginfo(\"Adding printer %s %s\\n\", p->id, p->backend_name);\n    cpdbDebugPrinter(p);\n    g_hash_table_insert(f->printer, cpdbConcatSep(p->id, p->backend_name), p);\n    f->num_printers++;\n\n    return TRUE;\n}\n\ncpdb_printer_obj_t *cpdbRemovePrinter(cpdb_frontend_obj_t *f,\n                                      const char *printer_id,\n                                      const char *backend_name)\n{\n    char *key;\n    cpdb_printer_obj_t *p = NULL;\n\n    loginfo(\"Removing printer %s %s\\n\", printer_id, backend_name);\n    key = cpdbConcatSep(printer_id, backend_name);\n    if (g_hash_table_contains(f->printer, key))\n    {\n        p = cpdbFindPrinterObj(f, printer_id, backend_name);\n        g_hash_table_remove(f->printer, key);\n        f->num_printers--;\n    }\n    else\n    {\n        logwarn(\"Printer %s %s not found\\n\", printer_id, backend_name);\n    }\n    \n    free(key);\n    return p;\n}\n\nvoid cpdbHideRemotePrinters(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Hiding remote printers\\n\");\n    print_frontend_emit_hide_remote_printers(f->skeleton);\n}\n\nvoid cpdbUnhideRemotePrinters(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Unhiding remote printers\\n\");\n    print_frontend_emit_unhide_remote_printers(f->skeleton);\n}\n\nvoid cpdbHideTemporaryPrinters(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Hiding temporary printers\\n\");\n    print_frontend_emit_hide_temporary_printers(f->skeleton);\n}\n\nvoid cpdbUnhideTemporaryPrinters(cpdb_frontend_obj_t *f)\n{\n    loginfo(\"Unhiding temporary printers\\n\");\n    print_frontend_emit_unhide_temporary_printers(f->skeleton);\n}\n\ncpdb_printer_obj_t *cpdbFindPrinterObj(cpdb_frontend_obj_t *f,\n                                       const char *printer_id,\n                                       const char *backend_name)\n{\n    char *hashtable_key;\n    cpdb_printer_obj_t *p;\n\n    if (printer_id == NULL || backend_name == NULL)\n    {\n        logwarn(\"Invalid parameters: cpdbFindPrinterObj()\\n\");\n        return NULL;\n    }\n\n    hashtable_key = cpdbConcatSep(printer_id, backend_name);\n    p = g_hash_table_lookup(f->printer, hashtable_key);\n    if (p == NULL)\n    {\n        logwarn(\"Couldn't find printer %s %s : Doesn't exist\\n\",\n                printer_id, backend_name);\n    }\n\n    free(hashtable_key);\n    return p;\n}\n\ncpdb_printer_obj_t *cpdbGetDefaultPrinterForBackend(cpdb_frontend_obj_t *f,\n                                                    const char *backend_name)\n{\n    char *def;\n    GError *error = NULL;\n    PrintBackend *proxy;\n    cpdb_printer_obj_t *p = NULL;\n    \n    proxy = g_hash_table_lookup(f->backend, backend_name);\n    if (proxy == NULL)\n    {\n        logwarn(\"Couldn't find backend proxy for %s\\n\", backend_name);\n        proxy = cpdbCreateBackendFromFile(f->connection, backend_name);\n        if (proxy == NULL)\n        {\n            logerror(\"Error getting default printer for backend : Couldn't get backend proxy\\n\");\n            return NULL;\n        }\n    }\n\n    print_backend_call_get_default_printer_sync(proxy, &def, NULL, &error);\n    if (error)\n    {\n        logerror(\"Error getting default printer for backend : %s\\n\", error->message);\n        return NULL;\n    }\n    \n    p = cpdbFindPrinterObj(f, def, backend_name);\n    if (p)\n        logdebug(\"Obtained default printer %s for backend %s\\n\", p->id, backend_name);\n    return p;\n}\n\nGList *cpdbLoadDefaultPrinters(const char *path)\n{\n    FILE *fp;\n    char buf[CPDB_BSIZE];\n    GList *printers = NULL;\n\n    if ((fp = fopen(path, \"r\")) == NULL)\n    {\n        logwarn(\"Error loading default printers : Couldn't open %s for reading\\n\",\n                path);\n        return NULL;\n    }\n\n    while (fgets(buf, sizeof(buf), fp) != NULL)\n    {\n        buf[strcspn(buf, \"\\r\\n\")] = 0;\n        printers = g_list_prepend(printers, cpdbGetStringCopy(buf));\n    }\n    printers = g_list_reverse(printers);\n    logdebug(\"Loaded default printers from %s\\n\", path);\n\n    fclose(fp);\n    return printers;\n}\n\ncpdb_printer_obj_t *cpdbGetDefaultPrinter(cpdb_frontend_obj_t *f)\n{   \n    gpointer key, value;\n    GHashTableIter iter;\n    char *conf_dir, *path, *printer_id, *backend_name;\n    cpdb_printer_obj_t *default_printer = NULL;\n    GList *printer, *user_printers, *system_printers, *printers = NULL;\n\n    if (f->num_printers == 0 || f->num_backends == 0)\n    {\n        logwarn(\"Couldn't get default printer : No printers found\\n\");\n        return NULL;\n    }\n    \n    /** Find a default printer from user config first,\n     *  before trying system wide config **/\n    conf_dir = cpdbGetUserConfDir();\n    if (conf_dir)\n    {\n        path = cpdbConcatPath(conf_dir, CPDB_DEFAULT_PRINTERS_FILE);\n        printers = g_list_concat(printers, cpdbLoadDefaultPrinters(path));\n        free(path);\n        free(conf_dir);\n    }\n    conf_dir = cpdbGetSysConfDir();\n    if (conf_dir)\n    {\n        path = cpdbConcatPath(conf_dir, CPDB_DEFAULT_PRINTERS_FILE);\n        printers = g_list_concat(printers, cpdbLoadDefaultPrinters(path));\n        free(path);\n        free(conf_dir);\n    }\n    \n    for (printer = printers; printer != NULL; printer = printer->next)\n    {\n        printer_id = strtok(printer->data, \"#\"); \n        backend_name = strtok(NULL, \"\\n\");\n\n        default_printer = cpdbFindPrinterObj(f, printer_id, backend_name);\n        if (default_printer)\n        {\n            g_list_free_full(printers, free);\n            goto found;\n        }\n    }\n    if (printers)\n        g_list_free_full(printers, free);\n\n    logdebug(\"Couldn't find a valid default printer from config files\\n\");\n\n    /**  Fallback to default CUPS printer if CUPS backend exists **/\n    default_printer = cpdbGetDefaultPrinterForBackend(f, \"CUPS\");\n    if (default_printer)\n        goto found;\n    logdebug(\"Couldn't find a valid default CUPS printer\\n\");\n    \n    /** Fallback to default FILE printer if FILE backend exists **/\n    default_printer = cpdbGetDefaultPrinterForBackend(f, \"FILE\");\n    if (default_printer)\n        goto found;\n    logdebug(\"Couldn't find a valid default FILE printer\\n\");\n    \n    /** Fallback to the default printer of first backend found **/\n    g_hash_table_iter_init(&iter, f->backend);\n    g_hash_table_iter_next(&iter, &key, &value);\n\n    backend_name = (char *) key;\n    default_printer = cpdbGetDefaultPrinterForBackend(f, backend_name);\n    if (default_printer)\n        goto found;\n    logdebug(\"Couldn't find a valid default %s printer\\n\", backend_name);\n    \n    /** Fallback to first printer found **/\n    g_hash_table_iter_init(&iter, f->printer);\n    g_hash_table_iter_next(&iter, &key, &value);\n    default_printer = (cpdb_printer_obj_t *) value;\n    if (!default_printer)\n    {\n        logerror(\"Couldn't find a valid printer\\n\");\n        return NULL;\n    }\n\nfound:\n    logdebug(\"Found default printer %s %s\\n\",\n                default_printer->id, default_printer->backend_name);\n    return default_printer;\n}\n\nint cpdbSetDefaultPrinter(const char *path,\n                          cpdb_printer_obj_t *p)\n{\n    FILE *fp;\n    char *printer_data;\n    GList *printer, *next, *printers;\n    \n    printers = cpdbLoadDefaultPrinters(path);\n    printer_data = cpdbConcatSep(p->id, p->backend_name);\n    \n    if ((fp = fopen(path, \"w\")) == NULL)\n    {\n        logerror(\"Error setting default printer : Couldn't open %s for writing\\n\",\n                    path);\n        return 0;\n    }\n\n    /* Delete duplicate entries */\n    printer = printers;\n    while (printer != NULL)\n    {\n        next = printer->next;\n        if (strcmp(printer->data, printer_data) == 0)\n        {\n            free(printer->data);\n            printers = g_list_delete_link(printers, printer);\n        }\n\n        printer = next;\n    }\n\n    printers = g_list_prepend(printers, printer_data);\n    for (printer = printers; printer != NULL; printer = printer->next)\n    {\n        fprintf(fp, \"%s\\n\", (char *)printer->data);\n    }\n    g_list_free_full(printers, free);\n    loginfo(\"Saved default printers to %s\", path);\n\n    fclose(fp);\n    return 1;\n}\n\nint cpdbSetUserDefaultPrinter(cpdb_printer_obj_t *p)\n{\n    int ret;\n    char *conf_dir, *path;\n\n    if ((conf_dir = cpdbGetUserConfDir()) == NULL)\n    {\n        logerror(\"Error setting default printer : Couldn't get system config dir\\n\");\n        return 0;\n    }\n    path = cpdbConcatPath(conf_dir, CPDB_DEFAULT_PRINTERS_FILE);\n    ret = cpdbSetDefaultPrinter(path, p);\n\n    free(path);\n    free(conf_dir);\n    return ret;\n}\n\nint cpdbSetSystemDefaultPrinter(cpdb_printer_obj_t *p)\n{\n    int ret;\n    char *conf_dir, *path;\n\n    if ((conf_dir = cpdbGetSysConfDir()) == NULL)\n    {\n        logerror(\"Error setting default printer : Couldn't get system config dir\\n\");\n        return 0;\n    }\n    path = cpdbConcatPath(conf_dir, CPDB_DEFAULT_PRINTERS_FILE);\n    ret = cpdbSetDefaultPrinter(path, p);\n\n    free(path);\n    free(conf_dir);\n    return ret;\n}\n\nint cpdbGetAllJobs(cpdb_frontend_obj_t *f,\n                   cpdb_job_t **j,\n                   gboolean active_only)\n{\n    \n\t/**inititalizing the arrays required for each of the backends **/\n\t\n    /** num_jobs[] stores the number of jobs for each of the backends**/\n    int *num_jobs = g_new(int, f->num_backends);\n    \n    /**backend_names[] stores the name for each of the backends**/\n    char **backend_names = g_new0(char *, f->num_backends);\n    \n    /**retval[] stores the gvariant returned by the respective backend **/\n    GVariant **retval = g_new(GVariant *, f->num_backends);\n    \n    GError *error = NULL;\n    gpointer key, value;\n    GHashTableIter iter;\n    int i = 0, total_jobs = 0;\n \n    /** Iterating over all the backends and getting each's active jobs**/\n    g_hash_table_iter_init(&iter, f->backend);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        PrintBackend *proxy = (PrintBackend *)value;\n        \n        backend_names[i] = (char *)key;\n        print_backend_call_get_all_jobs_sync(proxy,\n                                             active_only,\n                                             &(num_jobs[i]),\n                                             &(retval[i]),\n                                             NULL,\n                                             &error);\n        \n        if(error)\n        {\n            logerror(\"Error gettings jobs for backend %s : %s\\n\",\n                        backend_names[i], error->message);\n        \tnum_jobs[i] = 0;\n        \t\n        }\n        else\n        {\n        \tlogdebug(\"Obtained %d jobs for backend %s\\n\",\n                        num_jobs[i], backend_names[i]);\n        }\n        \n        total_jobs += num_jobs[i];\n        i++; /** off to the next backend **/\n    }\n    \n    int n = 0;\n    cpdb_job_t *jobs = g_new(cpdb_job_t, total_jobs);\n    for (i = 0; i < f->num_backends; i++)\n    {\n    \tif(num_jobs[i])\n        {\n    \t\tcpdbUnpackJobArray(retval[i],\n                               num_jobs[i],\n                               jobs + n,\n                               backend_names[i]);\n        }\n        n += num_jobs[i];\n    }\n    *j = jobs;\n\n    free(num_jobs);\n    return total_jobs;\n}\n\n/**\n________________________________________________ cpdb_printer_obj_t __________________________________________\n**/\n\ncpdb_printer_obj_t *cpdbGetNewPrinterObj()\n{\n    cpdb_printer_obj_t *p = g_new0 (cpdb_printer_obj_t, 1);\n    p->options = NULL;\n    p->settings = cpdbGetNewSettings();\n    return p;\n}\n\nstatic void cpdbDeleteTranslations(cpdb_printer_obj_t *p)\n{\n    g_free(p->locale);\n    if (p->translations)\n        g_hash_table_destroy(p->translations);\n\n    p->locale = NULL;\n    p->translations = NULL;\n}\n\nvoid cpdbDeletePrinterObj(cpdb_printer_obj_t *p)\n{\n    if (p == NULL)\n        return;\n    \n    logdebug(\"Deleting printer object %s\\n\", p->id);\n    if (p->backend_name)\n        free(p->backend_name);\n    if (p->backend_proxy)\n        g_object_unref(p->backend_proxy);\n    if (p->options)\n        cpdbDeleteOptions(p->options);\n    if (p->settings)\n        cpdbDeleteSettings(p->settings);\n    cpdbDeleteTranslations(p);\n    \n    free(p);\n}\n\nvoid cpdbFillBasicOptions(cpdb_printer_obj_t *p,\n                          GVariant *gv)\n{\n    g_variant_get(gv, CPDB_PRINTER_ADDED_ARGS,\n                  &(p->id),\n                  &(p->name),\n                  &(p->info),\n                  &(p->location),\n                  &(p->make_and_model),\n                  &(p->accepting_jobs),\n                  &(p->state),\n                  &(p->backend_name));\n}\n\nvoid cpdbDebugPrinter(const cpdb_printer_obj_t *p)\n{\n    logdebug(\"-------------------------\\n\");\n    logdebug(\"Printer %s\\n\", p->id);\n    logdebug(\"name: %s\\n\", p->name);\n    logdebug(\"location: %s\\n\", p->location);\n    logdebug(\"info: %s\\n\", p->info);\n    logdebug(\"make and model: %s\\n\", p->make_and_model);\n    logdebug(\"accepting jobs? %s\\n\", (p->accepting_jobs ? \"yes\" : \"no\"));\n    logdebug(\"state: %s\\n\", p->state);\n    logdebug(\"backend: %s\\n\", p->backend_name);\n    logdebug(\"-------------------------\\n\\n\");\n}\n\ngboolean cpdbIsAcceptingJobs(cpdb_printer_obj_t *p)\n{\n    GError *error = NULL;\n    \n    print_backend_call_is_accepting_jobs_sync(p->backend_proxy,\n                                              p->id,\n                                              &p->accepting_jobs,\n                                              NULL,\n                                              &error);\n    if (error)\n    {\n        logerror(\"Error getting accepting_jobs status for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        return FALSE;\n    }\n\n    logdebug(\"Obtained accepting_jobs=%d; for %s %s\\n\", \n                p->accepting_jobs, p->id, p->backend_name);\n    return p->accepting_jobs;\n}\n\nchar *cpdbGetState(cpdb_printer_obj_t *p)\n{\n    GError *error = NULL;\n    \n    print_backend_call_get_printer_state_sync(p->backend_proxy,\n                                              p->id,\n                                              &p->state,\n                                              NULL,\n                                              &error);\n    if (error)\n    {\n        logerror(\"Error getting printer state for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n\n    logdebug(\"Obtained state=%s; for %s %s\\n\", \n                p->state, p->id, p->backend_name);\n    return p->state;\n}\n\ncpdb_options_t *cpdbGetAllOptions(cpdb_printer_obj_t *p)\n{\n    if (p == NULL) \n    {\n        logwarn(\"Invalid params: cpdbGetAllOptions()\\n\");\n        return NULL;\n    }\n\n    /** \n     * If the options were previously queried, \n     * return them, instead of querying again.\n    */\n    if (p->options)\n        return p->options;\n\n    GError *error = NULL;\n    int num_options, num_media;\n    GVariant *var, *media_var;\n    print_backend_call_get_all_options_sync(p->backend_proxy,\n                                            p->id,\n                                            &num_options,\n                                            &var,\n                                            &num_media,\n                                            &media_var,\n                                            NULL,\n                                            &error);\n    if (error)\n    {\n        logerror(\"Error getting printer options for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n\n    loginfo(\"Obtained %d options and %d media for %s %s\\n\",\n            num_options, num_media, p->id, p->backend_name);\n    p->options = cpdbGetNewOptions();\n    cpdbUnpackOptions(num_options, var, num_media, media_var, p->options);\n    return p->options;\n}\n\ncpdb_option_t *cpdbGetOption(cpdb_printer_obj_t *p,\n                             const char *name)\n{\n    if (p == NULL || name == NULL) \n    {\n        logwarn(\"Invalid params: cpdbGetOption()\\n\");\n        return NULL;\n    }\n\n    cpdbGetAllOptions(p);\n    return (cpdb_option_t *)(g_hash_table_lookup(p->options->table, name));\n}\n\nchar *cpdbGetDefault(cpdb_printer_obj_t *p,\n                     const char *name)\n{\n    if (p == NULL || name == NULL)\n    {\n        logwarn(\"Invalid params: cpdbGetDefault()\\n\");\n        return NULL;\n    }\n\n    cpdb_option_t *o = cpdbGetOption(p, name);\n    if (!o)\n        return NULL;\n    return o->default_value;\n}\n\nchar *cpdbGetSetting(cpdb_printer_obj_t *p,\n                     const char *name)\n{\n    if (p == NULL || name == NULL)\n    {\n        logwarn(\"Invalid params: cpdbGetSetting()\\n\");\n        return NULL;\n    }\n\n    if (!g_hash_table_contains(p->settings->table, name))\n        return NULL;\n    return g_hash_table_lookup(p->settings->table, name);\n}\n\nchar *cpdbGetCurrent(cpdb_printer_obj_t *p,\n                     const char *name)\n{\n    char *set = cpdbGetSetting(p, name);\n    if (set)\n        return set;\n\n    return cpdbGetDefault(p, name);\n}\n\nint cpdbGetActiveJobsCount(cpdb_printer_obj_t *p)\n{\n    int count;\n    GError *error = NULL;\n    \n    print_backend_call_get_active_jobs_count_sync(p->backend_proxy,\n                                                  p->id,\n                                                  &count,\n                                                  NULL,\n                                                  &error);\n    if (error)\n    {\n        logerror(\"Error getting active jobs count for % %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        return -1;\n    }\n    \n    logdebug(\"Obtained %d active jobs for %s %s\\n\", count, \n                p->id, p->backend_name);\n    return count;\n}\n\nstatic void cpdbDebugPrintSettings(cpdb_settings_t *s)\n{\n    gpointer key, value;\n    GHashTableIter iter;\n\n    g_hash_table_iter_init(&iter, s->table);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        logdebug(\"%s -> %s\\n\", (char *) key, (char *) value);\n    }\n}\n\nchar *cpdbPrintFile(cpdb_printer_obj_t *p,\n                    const char *file_path)\n{\n    char *jobid, *absolute_file_path;\n    GError *error = NULL;\n    \n    absolute_file_path = cpdbGetAbsolutePath(file_path);\n    logdebug(\"Printing file %s on %s %s\\n\",\n                absolute_file_path, p->id, p->backend_name);\n    cpdbDebugPrintSettings(p->settings);\n    print_backend_call_print_file_sync(p->backend_proxy,\n                                       p->id,\n                                       absolute_file_path,\n                                       p->settings->count,\n                                       cpdbSerializeToGVariant(p->settings),\n                                       \"final-file-path-not-required\",\n                                       &jobid,\n                                       NULL,\n                                       &error);\n                                       \n    if (error)\n    {\n        logerror(\"Error printing file %s on %s %s : %s\\n\", \n                    absolute_file_path, p->id, p->backend_name, error->message);\n        return NULL;\n    }\n    \n    if (jobid == NULL || jobid == \"\")\n    {\n        logerror(\"Error printing file %s on %s %s : Couldn't create a job\\n\", \n                    absolute_file_path, p->id, p->backend_name);\n        return NULL;\n    }\n    \n    loginfo(\"File %s sent for printing on %s %s successfully\\n\",\n                absolute_file_path, p->id, p->backend_name);\n    cpdbSaveSettingsToDisk(p->settings);\n    free(absolute_file_path);\n    return jobid;\n}\n\nchar *cpdbPrintFilePath(cpdb_printer_obj_t *p,\n                        const char *file_path,\n                        const char *final_file_path)\n{\n    char *result, *absolute_file_path, *absolute_final_file_path;\n    GError *error = NULL;\n    \n    absolute_file_path = cpdbGetAbsolutePath(file_path);\n    absolute_final_file_path = cpdbGetAbsolutePath(final_file_path);\n    logdebug(\"Printing file %s on %s %s to %s\\n\",\n                absolute_file_path, p->id, p->backend_name, absolute_final_file_path);\n    cpdbDebugPrintSettings(p->settings);\n    print_backend_call_print_file_sync(p->backend_proxy,\n                                       p->id,\n                                       absolute_file_path,\n                                       p->settings->count,\n                                       cpdbSerializeToGVariant(p->settings),\n                                       absolute_final_file_path,\n                                       &result,\n                                       NULL,\n                                       &error);\n    \n    if (error)\n    {\n        logerror(\"Error printing file %s to %s : %s\\n\", \n                 absolute_file_path, absolute_final_file_path, error->message);\n        return NULL;\n    }\n    \n    if (result == NULL)\n    {\n        logerror(\"Error printing file %s to %s\\n\", \n                 absolute_file_path, absolute_final_file_path);\n        return NULL;\n    }\n    \n    loginfo(\"File %s printed to %s successfully\\n\",\n                absolute_file_path, absolute_final_file_path);\n    free(absolute_file_path);\n    free(absolute_final_file_path);\n    return result;\n}\n\nvoid cpdbAddSettingToPrinter(cpdb_printer_obj_t *p,\n                             const char *name,\n                             const char *val)\n{\n    if (p == NULL || name == NULL)\n    {\n        logwarn(\"Invalid params: cpdbAddSettingToPrinter()\\n\");\n        return;\n    }\n\n    cpdbAddSetting(p->settings, name, val);\n}\n\ngboolean cpdbClearSettingFromPrinter(cpdb_printer_obj_t *p,\n                                     const char *name)\n{\n    if (p == NULL || name == NULL)\n    {\n        logwarn(\"Invalid params: cpdbClearSettingFromPrinter()\\n\");\n        return FALSE;\n    }\n    return cpdbClearSetting(p->settings, name);\n}\n\ngboolean cpdbCancelJob(cpdb_printer_obj_t *p,\n                       const char *job_id)\n{\n    gboolean status;\n    GError *error = NULL;\n    \n    print_backend_call_cancel_job_sync(p->backend_proxy,\n                                       job_id,\n                                       p->id,\n                                       &status,\n                                       NULL,\n                                       &error);\n    if (error)\n    {\n        logerror(\"Error cancelling job %s on %s %s\\n\", \n                    job_id, p->id, p->backend_name, error->message);\n        return FALSE;\n    }\n    \n    logdebug(\"Obtained status=%d for cancelling job %s on %s %s\\n\",\n                status, job_id, p->id, p->backend_name);\n    return status;\n}\n\nvoid cpdbPicklePrinterToFile(cpdb_printer_obj_t *p,\n                             const char *filename,\n                             const cpdb_frontend_obj_t *parent_dialog)\n{\n\tFILE *fp;\n\tchar *path;\n    const char *unique_bus_name;\n    GHashTableIter iter;\n    gpointer key, value;\n    GError *error = NULL;\n\t\n    print_backend_call_keep_alive_sync(p->backend_proxy, NULL, &error);\n    if (error)\n    {\n        logerror(\"Error keeping backend %s alive : %s\\n\",\n                    p->backend_name, error->message);\n        return;\n    }\n    loginfo(\"Keeping backend %s alive\\n\", p->backend_name);\n    \n    path = cpdbGetAbsolutePath(filename);\n    if ((fp = fopen(path, \"w\")) == NULL)\n    {\n        logerror(\"Error pickling printer %s %s : Couldn't open %s for writing\\n\",\n                    p->id, p->backend_name, path);\n        return;\n    }\n\n    unique_bus_name = g_dbus_connection_get_unique_name(parent_dialog->connection);\n    if (unique_bus_name == NULL)\n    {\n        logerror(\"Error pickling printer %s %s: Couldn't get unique bus name\\n\",\n                    p->id, p->backend_name);\n        return;\n    }\n    \n    fprintf(fp, \"%s#\\n\", unique_bus_name);\n    fprintf(fp, \"%s#\\n\", p->backend_name);\n    fprintf(fp, \"%s#\\n\", p->id);\n    fprintf(fp, \"%s#\\n\", p->name);\n    fprintf(fp, \"%s#\\n\", p->location);\n    fprintf(fp, \"%s#\\n\", p->info);\n    fprintf(fp, \"%s#\\n\", p->make_and_model);\n    fprintf(fp, \"%s#\\n\", p->state);\n    fprintf(fp, \"%d\\n\", p->accepting_jobs);\n\n    /* Not pickling the cpdb_options_t, \n     * because it can be reconstructed by querying the backend */\n\n    fprintf(fp, \"%d\\n\", p->settings->count);\n    g_hash_table_iter_init(&iter, p->settings->table);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        fprintf(fp, \"%s#%s#\\n\", (char *)key, (char *)value);\n    }\n    loginfo(\"Pickled printer %s %s to %s\\n\",\n            p->id, p->backend_name, path);\n    \n    fclose(fp);\n    free(path);\n}\n\ncpdb_printer_obj_t *cpdbResurrectPrinterFromFile(const char *filename)\n{\n    FILE *fp;\n    int count;\n    char buf[CPDB_BSIZE];\n    GDBusConnection *connection;\n    char *name, *value, *path = NULL;\n    char *backend_file_name = NULL, *previous_parent_dialog = NULL;\n    GError *error = NULL;\n    cpdb_printer_obj_t *p;\n\n    path = cpdbGetAbsolutePath(filename);\n    if ((fp = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error resurrecting printer : Couldn't open %s for reading\\n\",\n\t\t path);\n        goto failed;\n    }\n\n    p = cpdbGetNewPrinterObj();\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    previous_parent_dialog = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->backend_name = cpdbGetStringCopy(strtok(buf, \"#\"));\n    \n    backend_file_name = cpdbConcat(CPDB_BACKEND_PREFIX, p->backend_name);\n    if ((connection = get_dbus_connection()) == NULL)\n    {\n        logerror(\"Error resurrecting printer : Couldn't get dbus connection\\n\");\n        goto failed;\n    }\n    p->backend_proxy = cpdbCreateBackendFromFile(connection,\n                                                 backend_file_name);\n    free(backend_file_name);\n    print_backend_call_replace_sync(p->backend_proxy, \n                                    previous_parent_dialog, \n                                    NULL, \n                                    &error);\n    if (error)\n    {\n        logerror(\"Error replacing resurrected printer : %s\\n\",\n                    error->message); \n        goto failed;\n    }\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->id = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->name = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->location = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->info = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->make_and_model = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fgets(buf, sizeof(buf), fp) == NULL)\n        goto parse_error;\n    p->state = cpdbGetStringCopy(strtok(buf, \"#\"));\n\n    if (fscanf(fp, \"%d\\n\", &p->accepting_jobs) == 0)\n        goto parse_error;\n    \n    cpdbDebugPrinter(p);\n\n    if (fscanf(fp, \"%d\\n\", &count) == 0)\n        goto parse_error;\n    while (count--)\n    {\n        if (fgets(buf, sizeof(buf), fp) == NULL)\n            goto parse_error;\n        name = strtok(buf, \"#\");\n        value = strtok(NULL, \"#\");\n        cpdbAddSetting(p->settings, name, value);\n    }\n    loginfo(\"Resurrected printer %s %s from %s\\n\", \n            p->id, p->backend_name, filename);\n\n    fclose(fp);\n    free(path);\n    free(backend_file_name);\n    free(previous_parent_dialog);\n    return p;\n\nparse_error:\n    logerror(\"Error resurrecting printer : Coudln't parse %s\\n\", path);\n    \nfailed:\n    if (fp)\n        fclose(fp);\n    free(path);\n    if (backend_file_name)\n        free(backend_file_name);\n    if (previous_parent_dialog)\n        free(previous_parent_dialog);\n    return NULL;\n}\n\nchar *cpdbGetOptionTranslation(cpdb_printer_obj_t *p,\n                               const char *option_name,\n                               const char *locale)\n{\n    char *name_key, *translation;\n    GError *error = NULL;\n\n    if (p == NULL || option_name == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid paramaters: cpdbGetOptionTranslation()\\n\");\n        return NULL;\n    }\n\n    if (p->locale != NULL && strcmp(p->locale, locale) == 0)\n    {\n        name_key = cpdbConcatSep(CPDB_OPT_PREFIX, option_name);\n        translation = g_hash_table_lookup(p->translations, name_key);\n        free(name_key);\n        if (translation)\n        {\n            logdebug(\"Found translation=%s; for option=%s;locale=%s;printer=%s#%s;\\n\",\n                        translation, option_name, locale, p->id, p->backend_name);\n            return cpdbGetStringCopy(translation);\n        }\n    }\n\n    print_backend_call_get_option_translation_sync(p->backend_proxy,\n                                                   p->id,\n                                                   option_name,\n                                                   locale,\n                                                   &translation,\n                                                   NULL,\n                                                   &error);\n    if (error)\n    {\n        logerror(\"Error getting translation for option=%s;locale=%s;printer=%s#%s; : %s\\n\",\n                    option_name, locale,\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n    \n    logdebug(\"Obtained translation=%s; for option=%s;locale=%s;printer=%s#%s;\\n\",\n                translation, option_name, locale, p->id, p->backend_name);\n    return cpdbGetStringCopy(translation);\n}\n\nchar *cpdbGetChoiceTranslation(cpdb_printer_obj_t *p,\n                               const char *option_name,\n                               const char *choice_name,\n                               const char *locale)\n{\n    char *name_key, *choice_key, *translation;\n    GError *error = NULL;\n\n    if (p == NULL || option_name == NULL || choice_name == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid paramaters: cpdbGetChoiceTranslation()\\n\");\n        return NULL;\n    }\n\n    if (p->locale != NULL && strcmp(p->locale, locale) == 0)\n    {\n        name_key = cpdbConcatSep(CPDB_OPT_PREFIX, option_name);\n        choice_key = cpdbConcatSep(name_key, choice_name);\n        translation = g_hash_table_lookup(p->translations, choice_key);\n        free(name_key);\n        free(choice_key);\n        if (translation)\n        {\n            logdebug(\"Found translation=%s; for option=%s;choice=%s;locale=%s;printer=%s#%s;\\n\",\n                        translation, option_name, choice_name, locale, \n                        p->id, p->backend_name);\n            return cpdbGetStringCopy(translation);\n        }\n    }\n    \n    print_backend_call_get_choice_translation_sync(p->backend_proxy,\n                                                   p->id,\n                                                   option_name,\n                                                   choice_name,\n                                                   locale,\n                                                   &translation,\n                                                   NULL,\n                                                   &error);\n    if (error)\n    {\n        logerror(\"Error getting translation for option=%s;choice=%s;locale=%s;printer=%s#%s; : %s\\n\",\n                    option_name, choice_name, locale,\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n    \n    logdebug(\"Obtained translation=%s; for option=%s;choice=%s;locale=%s;printer=%s#%s;\\n\",\n                translation, option_name, choice_name, locale, \n                p->id, p->backend_name);\n    return cpdbGetStringCopy(translation);\n}\n\n\nchar *cpdbGetGroupTranslation(cpdb_printer_obj_t *p,\n                              const char *group_name,\n                              const char *locale)\n{\n    char *group_key, *translation;\n    GError *error = NULL;\n\n    if (p == NULL || group_name == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid paramaters: cpdbGetGroupTranslation()\\n\");\n        return NULL;\n    }\n\n    if (p->locale != NULL && strcmp(p->locale, locale) == 0)\n    {\n        group_key = cpdbConcatSep(CPDB_GRP_PREFIX, group_name);\n        translation = g_hash_table_lookup(p->translations, group_key);\n        free(group_key);\n        if (translation)\n        {\n            logdebug(\"Found translation=%s; for group=%s;locale=%s;printer=%s#%s;\\n\",\n                        translation, group_name, locale, p->id, p->backend_name);\n            return cpdbGetStringCopy(translation);\n        }\n    }\n    \n    print_backend_call_get_group_translation_sync(p->backend_proxy,\n                                                  p->id,\n                                                  group_name,\n                                                  locale,\n                                                  &translation,\n                                                  NULL,\n                                                  &error);\n\n    if (error)\n    {\n        logerror(\"Error getting translation for group=%s;locale=%s;printer=%s#%s; : %s\\n\",\n                    group_name, locale,\n                    p->id, p->backend_name, error->message);\n        return NULL;\n    }\n    \n    logdebug(\"Obtained translation=%s; for group=%s;locale=%s;printer=%s#%s;\\n\",\n                translation, group_name, locale, p->id, p->backend_name);\n    return cpdbGetStringCopy(translation);\n}\n\nvoid cpdbGetAllTranslations(cpdb_printer_obj_t *p,\n                            const char *locale)\n{\n    GVariant *translations;\n    GError *error = NULL;\n\n    if (p == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid parameters: cpdbGetAllTranslations()\\n\");\n        return;\n    }\n\n    if (p->locale != NULL && strcmp(p->locale, locale) == 0)\n        return;\n\n    print_backend_call_get_all_translations_sync(p->backend_proxy,\n                                                 p->id,\n                                                 locale,\n                                                 &translations,\n                                                 NULL,\n                                                 &error);\n    if (error)\n    {\n        logerror(\"Error getting printer translations in %s for %s %s : %s\\n\",\n                    locale, p->id, p->backend_name, error->message);\n        return;\n    }\n    logdebug(\"Fetched translations for printer %s %s\\n\", p->id, p->backend_name);\n\n    cpdbDeleteTranslations(p);\n    p->locale = cpdbGetStringCopy(locale);\n    p->translations = cpdbUnpackTranslations(translations);\n}\n\ncpdb_media_t *cpdbGetMedia(cpdb_printer_obj_t *p,\n                           const char *media)\n{\n    cpdbGetAllOptions(p);\n    return (cpdb_media_t *) g_hash_table_lookup(p->options->media, media);\n}\n\nint cpdbGetMediaSize(cpdb_printer_obj_t *p,\n                     const char *media,\n                     int *width,\n                     int *length)\n{    \n    cpdb_media_t *m = cpdbGetMedia(p, media);\n    if (m)\n    {\n        *width = m->width;\n        *length = m->length;\n        return 1;\n    }\n\n    return 0;\n}\n\nint cpdbGetMediaMargins(cpdb_printer_obj_t *p,\n                        const char *media,\n                        cpdb_margin_t **margins)\n{\n    int num_margins = 0;\n    cpdb_media_t *m = cpdbGetMedia(p, media);\n\n    if (m)\n    {\n        num_margins = m->num_margins;\n        *margins = m->margins;\n    }\n\n    return num_margins;\t\n}\n\ntypedef struct {\n    cpdb_printer_obj_t *p;\n    cpdb_async_callback caller_cb;\n    void *user_data;\n} cpdb_async_details_obj_t;\n\nvoid acquire_details_cb(PrintBackend *proxy,\n                        GAsyncResult *res,\n                        gpointer user_data)\n{\n    cpdb_async_details_obj_t *a = user_data;\n    \n    cpdb_printer_obj_t *p = a->p;\n    cpdb_async_callback caller_cb = a->caller_cb;\n    \n    p->options = cpdbGetNewOptions();\n    GError *error = NULL;\n    int num_options, num_media;\n    GVariant *var, *media_var;\n    \n    print_backend_call_get_all_options_finish (proxy,\n                                               &num_options,\n                                               &var,\n                                               &num_media,\n                                               &media_var,\n                                               res,\n                                               &error);\n    if (error)\n    {\n        logerror(\"Error acquiring printer details for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        if (caller_cb)\n            caller_cb(p, FALSE, a->user_data);\n    }\n    else\n    {\n        loginfo(\"Acquired %d options and %d media for %s %s\\n\",\n                num_options, num_media, p->id, p->backend_name);\n        cpdbUnpackOptions(num_options, var, num_media, media_var, p->options);\n        if (caller_cb)\n            caller_cb(p, TRUE, a->user_data);\n    }\n    \n    free(a);\n}\n\nvoid cpdbAcquireDetails(cpdb_printer_obj_t *p,\n                        cpdb_async_callback caller_cb,\n                        void *user_data)\n{\n    if (p == NULL)\n    {\n        logwarn(\"Invalid parameters: cpdbAcquireDetails()\\n\");\n        return;\n    }\n\n    if (p->options)\n    {\n        if (caller_cb)\n            caller_cb(p, TRUE, user_data);\n        return;\n    }\n    \n    cpdb_async_details_obj_t *a = g_new0(cpdb_async_details_obj_t, 1);\n    a->p = p;\n    a->caller_cb = caller_cb;\n    a->user_data = user_data;\n    \n    logdebug(\"Acquiring printer details for %s %s\\n\", p->id, p->backend_name);\n    print_backend_call_get_all_options(p->backend_proxy,\n                                       p->id, \n                                       NULL,\n                                       (GAsyncReadyCallback) acquire_details_cb,\n                                       a);\n}\n\n\ntypedef struct {\n    cpdb_printer_obj_t *p;\n    char *locale;\n    cpdb_async_callback caller_cb;\n    void *user_data;\n} cpdb_async_translations_obj_t;\n\n\nstatic void acquire_translations_cb(PrintBackend *proxy,\n                                    GAsyncResult *res,\n                                    gpointer user_data)\n{\n    GError *error = NULL;\n    GVariant *translations;\n\n    cpdb_async_translations_obj_t *a = user_data;\n    cpdb_printer_obj_t *p = a->p;\n\n    print_backend_call_get_all_translations_finish(proxy, &translations,\n                                                    res, &error);\n    if (error)\n    {\n        logerror(\"Error getting printer translations for %s %s : %s\\n\",\n                    p->id, p->backend_name, error->message);\n        a->caller_cb(p, FALSE, a->user_data);\n    }\n    else\n    {\n        cpdbDeleteTranslations(p);\n        p->locale = cpdbGetStringCopy(a->locale);\n        p->translations = cpdbUnpackTranslations(translations);\n        a->caller_cb(p, TRUE, a->user_data);\n    }\n\n    free(a->locale);\n    free(a);\n}\n\nvoid cpdbAcquireTranslations(cpdb_printer_obj_t *p,\n                             const char *locale,\n                             cpdb_async_callback caller_cb,\n                             void *user_data)\n{\n    if (p == NULL || locale == NULL)\n    {\n        logwarn(\"Invalid parameters: cpdbAcquireTranslations()\\n\");\n        return;\n    }\n\n    if (p->locale != NULL && strcmp(locale, p->locale) == 0)\n    {\n        caller_cb(p, TRUE, user_data);\n        return;\n    }\n\n    cpdb_async_translations_obj_t *a = g_new0(cpdb_async_translations_obj_t, 1);\n    a->p = p;\n    a->locale = cpdbGetStringCopy(locale);\n    a->caller_cb = caller_cb;\n    a->user_data = user_data;\n\n    logdebug(\"Acquiring printer translations for %s %s\\n\",\n                p->id, p->backend_name);\n    print_backend_call_get_all_translations(p->backend_proxy,\n                                            p->id,\n                                            locale,\n                                            NULL,\n                                            (GAsyncReadyCallback) acquire_translations_cb,\n                                            a);\n}\n\n/**\n________________________________________________ cpdb_settings_t __________________________________________\n**/\ncpdb_settings_t *cpdbGetNewSettings()\n{\n    cpdb_settings_t *s = g_new0(cpdb_settings_t, 1);\n    s->count = 0;\n    s->table = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n    return s;\n}\n\nvoid cpdbCopySettings(const cpdb_settings_t *source,\n                      cpdb_settings_t *dest)\n{\n    if (source == NULL || dest == NULL)\n    {\n        logwarn(\"Invalid params: cpdbCopySettings()\\n\");\n        return;\n    }\n\n    GHashTableIter iter;\n    g_hash_table_iter_init(&iter, source->table);\n    gpointer key, value;\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        cpdbAddSetting(dest, (char *)key, (char *)value);\n    }\n}\nvoid cpdbAddSetting(cpdb_settings_t *s, \n                    const char *name,\n                    const char *val)\n{\n    if (s == NULL || name == NULL) \n    {\n        logwarn(\"Invalid params: cpdbAddSettings()\\n\");\n        return;\n    }\n\n    gboolean new_entry = g_hash_table_insert(s->table,\n                                             cpdbGetStringCopy(name),\n                                             cpdbGetStringCopy(val));\n    if (new_entry)\n        s->count++;\n}\n\ngboolean cpdbClearSetting(cpdb_settings_t *s, const char *name)\n{\n    if (s == NULL || name == NULL) \n    {\n        logwarn(\"Invalid params: cpdbClearSetting()\\n\");\n        return FALSE;\n    }\n\n    if (g_hash_table_contains(s->table, name))\n    {\n        g_hash_table_remove(s->table, name);\n        s->count--;\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n}\n\nGVariant *cpdbSerializeToGVariant(cpdb_settings_t *s)\n{\n    GVariantBuilder *builder;\n    GVariant *variant;\n    builder = g_variant_builder_new(G_VARIANT_TYPE(\"a(ss)\"));\n\n    GHashTableIter iter;\n    g_hash_table_iter_init(&iter, s->table);\n\n    gpointer key, value;\n    for (int i = 0; i < s->count; i++)\n    {\n        g_hash_table_iter_next(&iter, &key, &value);\n        g_variant_builder_add(builder, \"(ss)\", key, value);\n    }\n\n    if (s->count == 0)\n        g_variant_builder_add(builder, \"(ss)\", \"NA\", \"NA\");\n\n    variant = g_variant_new(\"a(ss)\", builder);\n    return variant;\n}\n\nvoid cpdbSaveSettingsToDisk(cpdb_settings_t *s)\n{\n    FILE *fp;\n    char *conf_dir, *path;\n    GHashTableIter iter;\n    gpointer key, value;\n\n    if ((conf_dir = cpdbGetUserConfDir()) == NULL)\n    {\n        logerror(\"Error saving settings to disk : Couldn't obtain user config dir\\n\");\n        return;\n    }\n    path = cpdbConcatPath(conf_dir, CPDB_PRINT_SETTINGS_FILE);\n\n    if ((fp = fopen(path, \"w\")) == NULL)\n    {\n        logerror(\"Error saving settings to disk : Couldn't open %s for writing\\n\",\n                    path);\n        return;\n    }\n    fprintf(fp, \"%d\\n\", s->count);\n    \n    g_hash_table_iter_init(&iter, s->table);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        fprintf(fp, \"%s#%s#\\n\", (char *)key, (char *)value);\n    }\n    loginfo(\"Saved %d settings on disk to %s\\n\", s->count, path);\n\n    fclose(fp);\n    free(path);\n    free(conf_dir);\n}\n\ncpdb_settings_t *cpdbReadSettingsFromDisk()\n{\n    FILE *fp;\n    int count;\n    char *name, *value, *conf_dir, *path;\n    char buf[CPDB_BSIZE];\n    cpdb_settings_t *s;\n\n    if ((conf_dir = cpdbGetUserConfDir()) == NULL)\n    {\n        logerror(\"No previous settings found : Couldn't obtain user config dir\\n\");\n        return NULL;\n    }\n    path = cpdbConcatPath(conf_dir, CPDB_PRINT_SETTINGS_FILE);\n\n    if ((fp = fopen(path, \"r\")) == NULL)\n    {\n        loginfo(\"No previous settings found : Couldn't open %s for reading\\n\",\n                    path);\n        free(path);\n        free(conf_dir);\n        \n        return NULL;\n    }\n\n    s = cpdbGetNewSettings();\n    if (fscanf(fp, \"%d\\n\", &count) == 0)\n    {\n        logerror(\"Error getting settings from disk : Couldn't parse %s\\n\",\n                    path);\n        fclose(fp);\n        free(path);\n        free(conf_dir);\n        cpdbDeleteSettings(s);\n        return NULL;\n    }\n    while (count--)\n    {\n        if (fgets(buf, sizeof(buf), fp) == NULL)\n            break;\n        name = strtok(buf, \"#\");\n        value = strtok(NULL, \"#\");\n        cpdbAddSetting(s, name, value);\n    }\n    loginfo(\"Retrievied %d settings from disk at %s\\n\", s->count, path);\n\n    fclose(fp);\n    free(path);\n    free(conf_dir);\n    return s;\n}\n\nvoid cpdbDeleteSettings(cpdb_settings_t *s)\n{\n    if (s == NULL)\n        return;\n    \n    if (s->table)\n        g_hash_table_destroy(s->table);\n    \n    free(s);\n}\n/**\n________________________________________________ cpdb_options_t __________________________________________\n**/\ncpdb_options_t *cpdbGetNewOptions()\n{\n    cpdb_options_t *o = g_new0(cpdb_options_t, 1);\n    o->count = 0;\n    o->table = g_hash_table_new_full(g_str_hash,\n                                     g_str_equal,\n                                     g_free,\n                                     (GDestroyNotify) cpdbDeleteOption);\n    o->media_count = 0;\n    o->media = g_hash_table_new_full(g_str_hash,\n                                     g_str_equal,\n                                     g_free,\n                                     (GDestroyNotify) cpdbDeleteMedia);\n    return o;\n}\n\nvoid cpdbDeleteOptions(cpdb_options_t *opts)\n{\n    if (opts == NULL)\n        return;\n    \n    if (opts->table)\n        g_hash_table_destroy(opts->table);\n    if (opts->media)\n        g_hash_table_destroy(opts->media);\n\n    free(opts);\n}\n\n/**************cpdb_option_t************************************/\n\nvoid cpdbDeleteOption(cpdb_option_t *opt)\n{\n    if (opt == NULL)\n        return;\n    \n    if (opt->option_name)\n        free(opt->option_name);\n    if (opt->group_name)\n        free(opt->group_name);\n    if (opt->supported_values)\n        free(opt->supported_values);\n    if (opt->default_value)\n        free(opt->default_value);\n\n    free(opt);\n}\n\n/**************cpdb_option_t************************************/\n\nvoid cpdbDeleteMedia(cpdb_media_t *media)\n{\n    if (media == NULL)\n        return;\n    \n    if (media->name)\n        free(media->name);\n    if (media->margins)\n        free(media->margins);\n    \n    free(media);\n}\n\n/**\n * ________________________________ cpdb_job_t __________________________\n */\nvoid cpdbUnpackJobArray(GVariant *var,\n                        int num_jobs,\n                        cpdb_job_t *jobs,\n                        char *backend_name)\n{\n    int i;\n    char *str;\n    GVariantIter *iter;\n    g_variant_get(var, CPDB_JOB_ARRAY_ARGS, &iter);\n    int size;\n    char *jobid, *title, *printer, *user, *state, *submit_time;\n    for (i = 0; i < num_jobs; i++)\n    {\n        g_variant_iter_loop(iter,\n                            CPDB_JOB_ARGS,\n                            &jobid,\n                            &title,\n                            &printer,\n                            &user,\n                            &state,\n                            &submit_time,\n                            &size);\n        logdebug(\"jobid=%s;\\n\", jobid);\n        jobs[i].job_id = cpdbGetStringCopy(jobid);\n        logdebug(\"title=%s;\\n\", title);\n        jobs[i].title = cpdbGetStringCopy(title);\n        logdebug(\"printer=%s;\\n\", printer);\n        jobs[i].printer_id = cpdbGetStringCopy(printer);\n        logdebug(\"backend_name=%s;\\n\", backend_name);\n        jobs[i].backend_name = backend_name;\n        logdebug(\"user=%s;\\n\", user);\n        jobs[i].user = cpdbGetStringCopy(user);\n        logdebug(\"state=%s;\\n\", state);\n        jobs[i].state = cpdbGetStringCopy(state);\n        logdebug(\"submit_time=%s;\\n\", submit_time);\n        jobs[i].submitted_at = cpdbGetStringCopy(submit_time);\n        logdebug(\"size=%d;\\n\", size);\n        jobs[i].size = size;\n    }\n}\n/**\n * ________________________________utility functions__________________________\n */\n\nvoid cpdbUnpackOptions(int num_options,\n                       GVariant *opts_var,\n                       int num_media,\n                       GVariant *media_var,\n                       cpdb_options_t *options)\n{\n    cpdb_option_t *opt;\n    cpdb_media_t *media;\n    char buf[CPDB_BSIZE];\n    int i, j, num, width, length, l, r, t, b;\n    GVariantIter *iter, *sub_iter;\n    char *str, *name, *def, *group;\n    \n    options->count = num_options;\n    g_variant_get(opts_var, \"a(sssia(s))\", &iter);\n    for (i = 0; i < num_options; i++)\n    {\n        opt = g_new0(cpdb_option_t, 1);\n        g_variant_iter_loop(iter, \"(sssia(s))\",\n                            &name, &group, &def, &num, &sub_iter);\n\n        logdebug(\"name=%s;\\n\", name);\n        opt->option_name = cpdbGetStringCopy(name);\n        logdebug(\"group=%s;\\n\", group);\n        opt->group_name = cpdbGetStringCopy(group);\n        logdebug(\"default=%s;\\n\", def);\n        opt->default_value = cpdbGetStringCopy(def);\n        logdebug(\"num_choices=%d;\\n\", num);\n        opt->num_supported = num;\n        logdebug(\"choices:\\n\");\n        opt->supported_values = cpdbNewCStringArray(num);\n        for (j = 0; j < num; j++)\n        {\n            g_variant_iter_loop(sub_iter, \"(s)\", &str);\n            logdebug(\"  %s;\\n\", str);\n            opt->supported_values[j] = cpdbGetStringCopy(str);\n        }\n        g_hash_table_insert(options->table, cpdbGetStringCopy(opt->option_name), opt);\n    }\n    \n    options->media_count = num_media;\n    g_variant_get(media_var, \"a(siiia(iiii))\", &iter);\n    for (i = 0; i < num_media; i++)\n    {\n\t\tmedia = g_new0(cpdb_media_t, 1);\n\t\tg_variant_iter_loop(iter, \"(siiia(iiii))\",\n\t\t\t\t\t\t\t&name, &width, &length, &num, &sub_iter);\n        \n        logdebug(\"name=%s;\\n\", name);\n\t\tmedia->name = cpdbGetStringCopy(name);\n        logdebug(\"width=%d;\\n\", width);\n\t\tmedia->width = width;\n        logdebug(\"length=%d;\\n\", length);\n\t\tmedia->length = length;\n        logdebug(\"num_margins=%d;\\n\", num);\n\t\tmedia->num_margins = num;\n\t\tmedia->margins = g_new0(cpdb_margin_t, num);\n\t\tfor (j = 0; j < num; j++)\n\t\t{\n\t\t\tg_variant_iter_loop(sub_iter, \"(iiii)\", &l, &r, &t, &b);\n            logdebug(\"    %d,%d,%d,%d;\\n\", l, r, t, b);\n\t\t\tmedia->margins[j].left = l;\n            media->margins[j].right = r;\n            media->margins[j].top = t; \n            media->margins[j].bottom = b;\n\t\t}\n\t\tg_hash_table_insert(options->media, cpdbGetStringCopy(media->name), media);\n\t}\n    \n}\n\nstatic GHashTable *cpdbUnpackTranslations (GVariant *variant)\n{\n    GVariantIter iter;\n    gchar *key, *value;\n    GHashTable *translations;\n\n    translations = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n    g_variant_iter_init(&iter, variant);\n    while (g_variant_iter_loop(&iter, CPDB_TL_ARGS, &key, &value))\n    {\n        logdebug(\"Fetched translation '%s' : '%s'\\n\", key, value);\n        g_hash_table_insert(translations,\n                            cpdbGetStringCopy(key), cpdbGetStringCopy(value));\n    }\n\n    return translations;\n}\n\n\n/************************************************************************************************/\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <locale.h>\n\n#include <glib.h>\n#include <libintl.h>\n\n#include <cpdb/frontend.h>\n\n#define BUFSIZE 1024\n\nvoid display_help();\ngpointer parse_commands(gpointer user_data);\ncpdb_frontend_obj_t *f;\nstatic const char *locale;\n\nstatic void printBasicOptions(const cpdb_printer_obj_t *p)\n{\n    printf(\"-------------------------\\n\");\n    printf(\"Printer %s\\n\", p->id);\n    printf(\"name: %s\\n\", p->name);\n    printf(\"location: %s\\n\", p->location);\n    printf(\"info: %s\\n\", p->info);\n    printf(\"make and model: %s\\n\", p->make_and_model);\n    printf(\"accepting jobs? %s\\n\", (p->accepting_jobs ? \"yes\" : \"no\"));\n    printf(\"state: %s\\n\", p->state);\n    printf(\"backend: %s\\n\", p->backend_name);\n    printf(\"-------------------------\\n\\n\");\n}\n\nstatic void printMedia(const cpdb_media_t *media)\n{\n    printf(\"[+] Media: %s\\n\", media->name);\n    printf(\"   * width = %d\\n\", media->width);\n    printf(\"   * length = %d\\n\", media->length);\n    printf(\" --> Supported margins: %d\\n\", media->num_margins);\n    printf(\"     left, right, top, bottom\\n\");\n    for (int i = 0; i < media->num_margins; i++)\n    {\n        printf(\"     * %d, %d, %d, %d,\\n\",\n               media->margins[i].left,\n               media->margins[i].right,\n               media->margins[i].top,\n               media->margins[i].bottom);\n    }\n    printf(\"\\n\");\n}\n\nstatic void printOption(const cpdb_option_t *opt)\n{\n    int i;\n    \n    printf(\"[+] %s\\n\", opt->option_name);\n    printf(\" --> GROUP: %s\\n\", opt->group_name);\n    for (i = 0; i < opt->num_supported; i++)\n    {\n        printf(\"   * %s\\n\", opt->supported_values[i]);\n    }\n    printf(\" --> DEFAULT: %s\\n\\n\", opt->default_value);\n}\n\nstatic void printTranslations(cpdb_printer_obj_t *p)\n{\n    GHashTableIter iter;\n    gpointer key, value;\n\n    if (p->locale == NULL || p->translations == NULL)\n    {\n        printf(\"No translations found\\n\");\n        return;\n    }\n\n    g_hash_table_iter_init(&iter, p->translations);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        printf(\"'%s' : '%s'\\n\", (char *)key, (char *)value);\n    }\n}\n\nstatic void displayAllPrinters(cpdb_frontend_obj_t *f)\n{\n    GHashTableIter iter;\n    gpointer key, value;\n\n    g_hash_table_iter_init(&iter, f->printer);\n    while (g_hash_table_iter_next(&iter, &key, &value))\n    {\n        const cpdb_printer_obj_t *p = value;\n        printBasicOptions(p);\n    }\n}\n\nstatic void printer_callback(cpdb_frontend_obj_t *f, cpdb_printer_obj_t *p, cpdb_printer_update_t change)\n{\n    switch(change)\n    {\n    case CPDB_CHANGE_PRINTER_ADDED:\n        g_message(\"Added printer %s : %s!\\n\", p->name, p->backend_name);\n        printBasicOptions(p);\n        break;\n\n    case CPDB_CHANGE_PRINTER_REMOVED:\n        g_message(\"Removed printer %s : %s!\\n\", p->name, p->backend_name);\n        cpdbDeletePrinterObj(p);\n        break;\n    \n    case CPDB_CHANGE_PRINTER_STATE_CHANGED:\n        g_message(\"Printer state changed for %s : %s to \\\"%s\\\"\", p->name, p->backend_name, p->state);\n        break;\n    }\n}\n\nstatic void acquire_details_callback(cpdb_printer_obj_t *p, int success, void *user_data)\n{\n    if (success)\n        g_message(\"Details acquired for %s : %s\\n\", p->name, p->backend_name);\n    else\n        g_message(\"Could not acquire printer details for %s : %s\\n\", p->name, p->backend_name);\n}\n\nstatic void acquire_translations_callback(cpdb_printer_obj_t *p, int success, void *user_data)\n{\n    if (!success)\n        g_message(\"Could not acquire printer translations for %s : %s\\n\", p->name, p->backend_name);\n    g_message(\"Translations acquired for %s : %s\\n\", p->name, p->backend_name);\n    printTranslations(p);\n}\n\nint main(int argc, char **argv)\n{\n    cpdb_printer_callback printer_cb = (cpdb_printer_callback)printer_callback;\n\n    setlocale (LC_ALL, \"\");\n    cpdbInit();\n\n    locale = getenv(\"LANGUAGE\");\n\n    char *dialog_bus_name = malloc(300);\n    if (argc > 1) //this is for creating multiple instances of a dialog simultaneously\n        f = cpdbGetNewFrontendObj(argv[1], printer_cb);\n    else\n        f = cpdbGetNewFrontendObj(NULL, printer_cb);\n\n    /** Uncomment the line below if you don't want to use the previously saved settings**/\n    cpdbIgnoreLastSavedSettings(f);\n    g_thread_new(\"parse_commands_thread\", parse_commands, NULL);\n    cpdbConnectToDBus(f);\n    displayAllPrinters(f);\n    GMainLoop *loop = g_main_loop_new(NULL, FALSE);\n    g_main_loop_run(loop);\n}\n\ngpointer parse_commands(gpointer user_data)\n{\n    fflush(stdout);\n    char buf[BUFSIZE];\n    while (1)\n    {\n        printf(\"> \");\n        fflush(stdout);\n        scanf(\"%1023s\", buf);\n        if (strcmp(buf, \"stop\") == 0)\n        {\n            cpdbDeleteFrontendObj(f);\n            g_message(\"Stopping front end..\\n\");\n            exit(0);\n        }\n        else if (strcmp(buf, \"restart\") == 0)\n        {\n            cpdbDisconnectFromDBus(f);\n            cpdbConnectToDBus(f);\n        }\n        else if (strcmp(buf, \"hide-remote\") == 0)\n        {\n            cpdbHideRemotePrinters(f);\n            g_message(\"Hiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"unhide-remote\") == 0)\n        {\n            cpdbUnhideRemotePrinters(f);\n            g_message(\"Unhiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"hide-temporary\") == 0)\n        {\n            cpdbHideTemporaryPrinters(f);\n            g_message(\"Hiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"unhide-temporary\") == 0)\n        {\n            cpdbUnhideTemporaryPrinters(f);\n            g_message(\"Unhiding remote printers discovered by the backend..\\n\");\n        }\n        else if (strcmp(buf, \"get-all-options\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            g_message(\"Getting all attributes ..\\n\");\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(p == NULL)\n              continue;\n\n            cpdb_options_t *opts = cpdbGetAllOptions(p);\n\n            printf(\"Retrieved %d options.\\n\", opts->count);\n            GHashTableIter iter;\n            gpointer value;\n\n            g_hash_table_iter_init(&iter, opts->table);\n            while (g_hash_table_iter_next(&iter, NULL, &value))\n            {\n                printOption(value);\n            }\n        }\n        else if (strcmp(buf, \"get-all-media\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            g_message(\"Getting all attributes ..\\n\");\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(p == NULL)\n              continue;\n\n            cpdb_options_t *opts = cpdbGetAllOptions(p);\n\n            printf(\"Retrieved %d medias.\\n\", opts->media_count);\n            GHashTableIter iter;\n            gpointer value;\n\n            g_hash_table_iter_init(&iter, opts->media);\n            while (g_hash_table_iter_next(&iter, NULL, &value))\n            {\n                printMedia(value);\n            }\n        }\n        else if (strcmp(buf, \"get-default\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetDefault(p, option_name);\n            if (!ans)\n                printf(\"cpdb_option_t %s doesn't exist.\", option_name);\n            else\n                printf(\"Default : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"get-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], setting_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", setting_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetSetting(p, setting_name);\n            if (!ans)\n                printf(\"Setting %s doesn't exist.\\n\", setting_name);\n            else\n                printf(\"Setting value : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"get-current\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            char *ans = cpdbGetCurrent(p, option_name);\n            if (!ans)\n                printf(\"cpdb_option_t %s doesn't exist.\", option_name);\n            else\n                printf(\"Current value : %s\\n\", ans);\n        }\n        else if (strcmp(buf, \"add-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE], option_val[BUFSIZE];\n            scanf(\"%1023s %1023s %1023s %1023s\", option_name, option_val, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s : %s\\n\", option_name, option_val);\n            cpdbAddSettingToPrinter(p, cpdbGetStringCopy(option_name), cpdbGetStringCopy(option_val));\n        }\n        else if (strcmp(buf, \"clear-setting\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], option_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbClearSettingFromPrinter(p, option_name);\n        }\n        else if (strcmp(buf, \"get-state\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetState(p));\n        }\n        else if (strcmp(buf, \"is-accepting-jobs\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"Accepting jobs ? : %d \\n\", cpdbIsAcceptingJobs(p));\n        }\n        else if (strcmp(buf, \"help\") == 0)\n        {\n            display_help();\n        }\n        else if (strcmp(buf, \"ping\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            print_backend_call_ping_sync(p->backend_proxy, p->id, NULL, NULL);\n        }\n        else if (strcmp(buf, \"get-default-printer\") == 0)\n        {\n            cpdb_printer_obj_t *p = cpdbGetDefaultPrinter(f);\n            if (p)\n                printf(\"%s#%s\\n\", p->name, p->backend_name);\n            else\n                printf(\"No default printer found\\n\");\n        }\n        else if (strcmp(buf, \"get-default-printer-for-backend\") == 0)\n        {\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s\", backend_name);\n            /**\n             * Backend name = The last part of the backend dbus service\n             * Eg. \"CUPS\" or \"GCP\"\n             */\n            cpdb_printer_obj_t *p = cpdbGetDefaultPrinterForBackend(f, backend_name);\n            printf(\"%s\\n\", p->name);\n        }\n        else if (strcmp(buf, \"set-user-default-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (p)\n            {\n                if (cpdbSetUserDefaultPrinter(p))\n                    printf(\"Set printer as user default\\n\");\n                else\n                    printf(\"Couldn't set printer as user default\\n\");\n            }\n        }\n        else if (strcmp(buf, \"set-system-default-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (p)\n            {\n                if (cpdbSetSystemDefaultPrinter(p))\n                    printf(\"Set printer as system default\\n\");\n                else\n                    printf(\"Couldn't set printer as system default\\n\");\n            }\n        }\n        else if (strcmp(buf, \"print-file\") == 0)\n        {\n            char printer_id[BUFSIZE], backend_name[BUFSIZE], file_path[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", file_path, printer_id, backend_name);\n            /**\n             * Try adding some settings here .. change them and experiment\n             */\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            if(strcmp(backend_name, \"FILE\") == 0)\n            {\n              char final_file_path[BUFSIZE];\n              printf(\"Please give the final file path: \");\n              scanf(\"%1023s\", final_file_path);\n              cpdbPrintFilePath(p, file_path, final_file_path);\n              continue;\n            }\n\n            cpdbAddSettingToPrinter(p, \"copies\", \"3\");\n            cpdbPrintFile(p, file_path);\n        }\n        else if (strcmp(buf, \"get-active-jobs-count\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%d jobs currently active.\\n\", cpdbGetActiveJobsCount(p));\n        }\n        else if (strcmp(buf, \"get-all-jobs\") == 0)\n        {\n            int active_only;\n            scanf(\"%d\", &active_only);\n            cpdb_job_t *j;\n            int x = cpdbGetAllJobs(f, &j, active_only);\n            printf(\"Total %d jobs\\n\", x);\n            int i;\n            for (i = 0; i < x; i++)\n            {\n                printf(\"%s .. %s  .. %s  .. %s  .. %s\\n\", j[i].job_id, j[i].title, j[i].printer_id, j[i].state, j[i].submitted_at);\n            }\n        }\n        else if (strcmp(buf, \"cancel-job\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char job_id[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", job_id, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if (cpdbCancelJob(p, job_id))\n                printf(\"cpdb_job_t %s has been cancelled.\\n\", job_id);\n            else\n                printf(\"Unable to cancel job %s\\n\", job_id);\n        }\n        else if (strcmp(buf, \"pickle-printer\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char job_id[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbPicklePrinterToFile(p, \"/tmp/.printer-pickle\", f);\n        }\n        else if (strcmp(buf, \"get-option-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char option_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", option_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetOptionTranslation(p, option_name, locale));\n        }\n        else if (strcmp(buf, \"get-choice-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char option_name[BUFSIZE];\n            char choice_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s%1023s\", option_name, choice_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetChoiceTranslation(p, option_name, choice_name, locale));\n        }\n        else if (strcmp(buf, \"get-group-translation\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char group_name[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", group_name, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            printf(\"%s\\n\", cpdbGetGroupTranslation(p, group_name, locale));\n        }\n        else if (strcmp(buf, \"get-all-translations\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            cpdbGetAllTranslations(p, locale);\n            printTranslations(p);\n        }\n        else if (strcmp(buf, \"get-media-size\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char media[BUFSIZE];\n            int width, length;\n            scanf(\"%1023s%1023s%1023s\", media, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            int ok = cpdbGetMediaSize(p, media, &width, &length);\n            if (ok)\n                printf(\"%dx%d\\n\", width, length);\n        }\n        else if (strcmp(buf, \"get-media-margins\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            char media[BUFSIZE];\n            scanf(\"%1023s%1023s%1023s\", media, printer_id, backend_name);\n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n\n            cpdb_margin_t *margins;\n            int num_margins = cpdbGetMediaMargins(p, media, &margins);\n            for (int i = 0; i < num_margins; i++)\n                printf(\"%d %d %d %d\\n\", margins[i].left, margins[i].right, margins[i].top, margins[i].bottom);\n        }\n        else if (strcmp(buf, \"acquire-details\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            \n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if(p == NULL)\n              continue;\n\n            g_message(\"Acquiring printer details asynchronously...\\n\");\n            cpdbAcquireDetails(p, acquire_details_callback, NULL);\n\t\t}\n        else if (strcmp(buf, \"acquire-translations\") == 0)\n        {\n            char printer_id[BUFSIZE];\n            char backend_name[BUFSIZE];\n            scanf(\"%1023s%1023s\", printer_id, backend_name);\n            \n            cpdb_printer_obj_t *p = cpdbFindPrinterObj(f, printer_id, backend_name);\n            if(p == NULL)\n              continue;\n\n            g_message(\"Acquiring printer translations asynchronously...\\n\");\n            cpdbAcquireTranslations(p, locale, acquire_translations_callback, NULL);\n        }\n    }\n}\n\nvoid display_help()\n{\n    g_message(\"Available commands .. \");\n    printf(\"%s\\n\", \"stop\");\n    printf(\"%s\\n\", \"hide-remote\");\n    printf(\"%s\\n\", \"unhide-remote\");\n    printf(\"%s\\n\", \"hide-temporary\");\n    printf(\"%s\\n\", \"unhide-temporary\");\n    //printf(\"%s\\n\", \"ping <printer id> \");\n    printf(\"%s\\n\", \"get-default-printer\");\n    printf(\"%s\\n\", \"get-default-printer-for-backend <backend name>\");\n    printf(\"%s\\n\", \"set-user-default-printer <printer id> <backend name>\");\n    printf(\"%s\\n\", \"set-system-default-printer <printer id> <backend name>\");\n    printf(\"%s\\n\", \"print-file <file path> <printer_id> <backend_name>\");\n    printf(\"%s\\n\", \"get-active-jobs-count <printer-name> <backend-name>\");\n    printf(\"%s\\n\", \"get-all-jobs <0 for all jobs; 1 for only active>\");\n    printf(\"%s\\n\", \"get-state <printer id> <backend name>\");\n    printf(\"%s\\n\", \"is-accepting-jobs <printer id> <backend name(like \\\"CUPS\\\")>\");\n    printf(\"%s\\n\", \"cancel-job <job-id> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"acquire-details <printer id> <backend name>\");\n    printf(\"%s\\n\", \"acquire-translations <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-all-options <printer-name> <backend-name>\");\n    printf(\"%s\\n\", \"get-default <option name> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-setting <option name> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-current <option name> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"add-setting <option name> <option value> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"clear-setting <option name> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-media-size <media> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-media-margins <media> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-option-translation <option> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-choice-translation <option> <choice> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-group-translation <group> <printer id> <backend name>\");\n    printf(\"%s\\n\", \"get-all-translations <printer id> <backend name>\");\n    printf(\"%s\\n\", \"pickle-printer <printer id> <backend name>\\n\");\n}\n"], "filenames": ["cpdb/cpdb-frontend.c", "tools/cpdb-text-frontend.c"], "buggy_code_start_loc": [394, 162], "buggy_code_end_loc": [395, 505], "fixing_code_start_loc": [394, 162], "fixing_code_end_loc": [395, 505], "type": "CWE-121", "message": "cpdb-libs provides frontend and backend libraries for the Common Printing Dialog Backends (CPDB) project. In versions 1.0 through 2.0b4, cpdb-libs is vulnerable to buffer overflows via improper use of `scanf(3)`. cpdb-libs uses the `fscanf()` and `scanf()` functions to parse command lines and configuration files, dropping the read string components into fixed-length buffers, but does not limit the length of the strings to be read by `fscanf()` and `scanf()` causing buffer overflows when a string is longer than 1023 characters. A patch for this issue is available at commit f181bd1f14757c2ae0f17cc76dc20421a40f30b7. As all buffers have a length of 1024 characters, the patch limits the maximum string length to be read to 1023 by replacing all occurrences of `%s` with `%1023s` in all calls of the `fscanf()` and `scanf()` functions.\n", "other": {"cve": {"id": "CVE-2023-34095", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-14T17:15:09.243", "lastModified": "2023-06-26T15:24:27.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cpdb-libs provides frontend and backend libraries for the Common Printing Dialog Backends (CPDB) project. In versions 1.0 through 2.0b4, cpdb-libs is vulnerable to buffer overflows via improper use of `scanf(3)`. cpdb-libs uses the `fscanf()` and `scanf()` functions to parse command lines and configuration files, dropping the read string components into fixed-length buffers, but does not limit the length of the strings to be read by `fscanf()` and `scanf()` causing buffer overflows when a string is longer than 1023 characters. A patch for this issue is available at commit f181bd1f14757c2ae0f17cc76dc20421a40f30b7. As all buffers have a length of 1024 characters, the patch limits the maximum string length to be read to 1023 by replacing all occurrences of `%s` with `%1023s` in all calls of the `fscanf()` and `scanf()` functions.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openprinting:cpdb-libs:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0", "versionEndExcluding": "2.0", "matchCriteriaId": "57F84EB4-6BF2-4AAA-9BC6-F881F046A97B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openprinting:cpdb-libs:2.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "367C92BD-4CA9-4024-B9FA-7430236C9F6F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openprinting:cpdb-libs:2.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "CED72D06-A6D2-486F-B3FA-6ADA82262C6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openprinting:cpdb-libs:2.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "8545935C-24E9-49F6-8EBE-4D49F2C72F81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openprinting:cpdb-libs:2.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "F7330E46-2ACD-4832-89F9-D0372C9BFF06"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/06/14/7", "source": "security-advisories@github.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/OpenPrinting/cpdb-libs/blob/85555fba64d34f53a2fce099b0488904cc48ed35/cpdb/cpdb-frontend.c#L372", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/OpenPrinting/cpdb-libs/blob/85555fba64d34f53a2fce099b0488904cc48ed35/tools/cpdb-text-frontend.c#L362", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/OpenPrinting/cpdb-libs/blob/85555fba64d34f53a2fce099b0488904cc48ed35/tools/cpdb-text-frontend.c#L453", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/OpenPrinting/cpdb-libs/commit/f181bd1f14757c2ae0f17cc76dc20421a40f30b7", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/OpenPrinting/cpdb-libs/security/advisories/GHSA-25j7-9gfc-f46x", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenPrinting/cpdb-libs/commit/f181bd1f14757c2ae0f17cc76dc20421a40f30b7"}}