{"buggy_code": ["package org.dynmap.servlet;\n\nimport org.dynmap.DynmapCore;\nimport org.dynmap.DynmapWorld;\nimport org.dynmap.MapType.ImageEncoding;\nimport org.dynmap.PlayerFaces;\nimport org.dynmap.storage.MapStorage;\nimport org.dynmap.storage.MapStorageTile;\nimport org.dynmap.storage.MapStorageTile.TileRead;\nimport org.dynmap.utils.BufferInputStream;\nimport org.eclipse.jetty.http.HttpStatus;\nimport org.eclipse.jetty.server.Request;\nimport org.eclipse.jetty.server.handler.AbstractHandler;\n\nimport javax.imageio.ImageIO;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\n\npublic class MapStorageResourceHandler extends AbstractHandler {\n\n    private DynmapCore core;\n    private byte[] blankpng;\n    private long blankpnghash = 0x12345678;\n    \n    public MapStorageResourceHandler() {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BufferedImage blank = new BufferedImage(128, 128, BufferedImage.TYPE_INT_ARGB);\n        try {\n            ImageIO.write(blank, \"png\", baos);\n            blankpng = baos.toByteArray();\n        } catch (IOException e) {\n        }\n        \n    }\n    @Override\n    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String path = baseRequest.getPathInfo();\n        int soff = 0, eoff;\n        // We're handling this request\n        baseRequest.setHandled(true);\n\n        if (path.charAt(0) == '/') soff = 1;\n        eoff = path.indexOf('/', soff);\n        if (soff < 0) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        String world = path.substring(soff, eoff);\n        String uri = path.substring(eoff+1);\n        // If faces directory, handle faces\n        if (world.equals(\"faces\")) {\n            handleFace(response, uri);\n            return;\n        }\n        // If markers directory, handle markers\n        if (world.equals(\"_markers_\")) {\n            handleMarkers(response, uri);\n            return;\n        }\n\n        DynmapWorld w = null;\n        if (core.mapManager != null) {\n            w = core.mapManager.getWorld(world);\n        }\n        // If world not found quit\n        if (w == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        MapStorage store = w.getMapStorage();    // Get storage handler\n        // Get tile reference, based on URI and world\n        MapStorageTile tile = store.getTile(w, uri);\n        if (tile == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Read tile\n        TileRead tr = null;\n        if (tile.getReadLock(5000)) {\n            tr = tile.read();\n            tile.releaseReadLock();\n        }\n        response.setHeader(\"Cache-Control\", \"max-age=0,must-revalidate\");\n        String etag;\n        if (tr == null) {\n        \tetag = \"\\\"\" + blankpnghash + \"\\\"\";\n        }\n        else {\n        \tetag = \"\\\"\" + tr.hashCode + \"\\\"\";\n        }\n        response.setHeader(\"ETag\", etag);\n        String ifnullmatch = request.getHeader(\"If-None-Match\");\n        if ((ifnullmatch != null) && ifnullmatch.equals(etag)) {\n            response.sendError(HttpStatus.NOT_MODIFIED_304);\n        \treturn;\n        }\n        if (tr == null) {\n            response.setContentType(\"image/png\");\n            response.setIntHeader(\"Content-Length\", blankpng.length);\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Got tile, package up for response\n        response.setDateHeader(\"Last-Modified\", tr.lastModified);\n        response.setIntHeader(\"Content-Length\", tr.image.length());\n        if (tr.format == ImageEncoding.PNG) {\n            response.setContentType(\"image/png\");\n        }\n        else {\n            response.setContentType(\"image/jpeg\");\n        }\n        ServletOutputStream out = response.getOutputStream();\n        out.write(tr.image.buffer(), 0, tr.image.length());\n        out.flush();\n\n    }\n\n    private void handleFace(HttpServletResponse response, String uri) throws IOException, ServletException {\n        String[] suri = uri.split(\"[/\\\\.]\");\n        if (suri.length < 3) {  // 3 parts : face ID, player name, png\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        // Find type\n        PlayerFaces.FaceType ft = PlayerFaces.FaceType.byID(suri[0]);\n        if (ft == null) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        BufferInputStream bis = null;\n        if (core.playerfacemgr != null) {\n            bis = core.playerfacemgr.storage.getPlayerFaceImage(suri[1], ft);\n        }\n        if (bis == null) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        // Got image, package up for response\n        response.setIntHeader(\"Content-Length\", bis.length());\n        response.setContentType(\"image/png\");\n        ServletOutputStream out = response.getOutputStream();\n        out.write(bis.buffer(), 0, bis.length());\n        out.flush();\n    }\n\n    private void handleMarkers(HttpServletResponse response, String uri) throws IOException, ServletException {\n        String[] suri = uri.split(\"/\");\n        // If json file in last part\n        if ((suri.length == 1) && suri[0].startsWith(\"marker_\") && suri[0].endsWith(\".json\")) {\n            String content = core.getDefaultMapStorage().getMarkerFile(suri[0].substring(7, suri[0].length() - 5));\n            response.setContentType(\"application/json\");\n            PrintWriter pw = response.getWriter();\n            pw.print(content);\n            pw.flush();\n            return;\n        }\n        // If png, make marker ID\n        if (suri[suri.length-1].endsWith(\".png\")) {\n            BufferInputStream bis = core.getDefaultMapStorage().getMarkerImage(uri.substring(0, uri.length()-4));\n            // Got image, package up for response\n            response.setIntHeader(\"Content-Length\", bis.length());\n            response.setContentType(\"image/png\");\n            ServletOutputStream out = response.getOutputStream();\n            out.write(bis.buffer(), 0, bis.length());\n            out.flush();\n            return;\n        }\n        response.sendError(HttpStatus.NOT_FOUND_404);\n    }\n\n    public void setCore(DynmapCore core) {\n        this.core = core;\n    }\n}\n"], "fixing_code": ["package org.dynmap.servlet;\n\nimport org.dynmap.DynmapCore;\nimport org.dynmap.DynmapWorld;\nimport org.dynmap.MapType.ImageEncoding;\nimport org.dynmap.PlayerFaces;\nimport org.dynmap.storage.MapStorage;\nimport org.dynmap.storage.MapStorageTile;\nimport org.dynmap.storage.MapStorageTile.TileRead;\nimport org.dynmap.utils.BufferInputStream;\nimport org.eclipse.jetty.http.HttpStatus;\nimport org.eclipse.jetty.server.Request;\nimport org.eclipse.jetty.server.handler.AbstractHandler;\n\nimport javax.imageio.ImageIO;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\n\npublic class MapStorageResourceHandler extends AbstractHandler {\n\n    private DynmapCore core;\n    private byte[] blankpng;\n    private long blankpnghash = 0x12345678;\n    \n    public MapStorageResourceHandler() {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BufferedImage blank = new BufferedImage(128, 128, BufferedImage.TYPE_INT_ARGB);\n        try {\n            ImageIO.write(blank, \"png\", baos);\n            blankpng = baos.toByteArray();\n        } catch (IOException e) {\n        }\n        \n    }\n    @Override\n    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String path = baseRequest.getPathInfo();\n        int soff = 0, eoff;\n        // We're handling this request\n        baseRequest.setHandled(true);\n        if(core.getLoginRequired()\n            && request.getSession(true).getAttribute(LoginServlet.USERID_ATTRIB) == null){\n            response.sendError(HttpStatus.UNAUTHORIZED_401);\n            return;\n        }\n        if (path.charAt(0) == '/') soff = 1;\n        eoff = path.indexOf('/', soff);\n        if (soff < 0) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        String world = path.substring(soff, eoff);\n        String uri = path.substring(eoff+1);\n        // If faces directory, handle faces\n        if (world.equals(\"faces\")) {\n            handleFace(response, uri);\n            return;\n        }\n        // If markers directory, handle markers\n        if (world.equals(\"_markers_\")) {\n            handleMarkers(response, uri);\n            return;\n        }\n\n        DynmapWorld w = null;\n        if (core.mapManager != null) {\n            w = core.mapManager.getWorld(world);\n        }\n        // If world not found quit\n        if (w == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        MapStorage store = w.getMapStorage();    // Get storage handler\n        // Get tile reference, based on URI and world\n        MapStorageTile tile = store.getTile(w, uri);\n        if (tile == null) {\n            response.setContentType(\"image/png\");\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Read tile\n        TileRead tr = null;\n        if (tile.getReadLock(5000)) {\n            tr = tile.read();\n            tile.releaseReadLock();\n        }\n        response.setHeader(\"Cache-Control\", \"max-age=0,must-revalidate\");\n        String etag;\n        if (tr == null) {\n        \tetag = \"\\\"\" + blankpnghash + \"\\\"\";\n        }\n        else {\n        \tetag = \"\\\"\" + tr.hashCode + \"\\\"\";\n        }\n        response.setHeader(\"ETag\", etag);\n        String ifnullmatch = request.getHeader(\"If-None-Match\");\n        if ((ifnullmatch != null) && ifnullmatch.equals(etag)) {\n            response.sendError(HttpStatus.NOT_MODIFIED_304);\n        \treturn;\n        }\n        if (tr == null) {\n            response.setContentType(\"image/png\");\n            response.setIntHeader(\"Content-Length\", blankpng.length);\n            OutputStream os = response.getOutputStream();\n            os.write(blankpng);\n            return;\n        }\n        // Got tile, package up for response\n        response.setDateHeader(\"Last-Modified\", tr.lastModified);\n        response.setIntHeader(\"Content-Length\", tr.image.length());\n        if (tr.format == ImageEncoding.PNG) {\n            response.setContentType(\"image/png\");\n        }\n        else {\n            response.setContentType(\"image/jpeg\");\n        }\n        ServletOutputStream out = response.getOutputStream();\n        out.write(tr.image.buffer(), 0, tr.image.length());\n        out.flush();\n\n    }\n\n    private void handleFace(HttpServletResponse response, String uri) throws IOException, ServletException {\n        String[] suri = uri.split(\"[/\\\\.]\");\n        if (suri.length < 3) {  // 3 parts : face ID, player name, png\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        // Find type\n        PlayerFaces.FaceType ft = PlayerFaces.FaceType.byID(suri[0]);\n        if (ft == null) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        BufferInputStream bis = null;\n        if (core.playerfacemgr != null) {\n            bis = core.playerfacemgr.storage.getPlayerFaceImage(suri[1], ft);\n        }\n        if (bis == null) {\n            response.sendError(HttpStatus.NOT_FOUND_404);\n            return;\n        }\n        // Got image, package up for response\n        response.setIntHeader(\"Content-Length\", bis.length());\n        response.setContentType(\"image/png\");\n        ServletOutputStream out = response.getOutputStream();\n        out.write(bis.buffer(), 0, bis.length());\n        out.flush();\n    }\n\n    private void handleMarkers(HttpServletResponse response, String uri) throws IOException, ServletException {\n        String[] suri = uri.split(\"/\");\n        // If json file in last part\n        if ((suri.length == 1) && suri[0].startsWith(\"marker_\") && suri[0].endsWith(\".json\")) {\n            String content = core.getDefaultMapStorage().getMarkerFile(suri[0].substring(7, suri[0].length() - 5));\n            response.setContentType(\"application/json\");\n            PrintWriter pw = response.getWriter();\n            pw.print(content);\n            pw.flush();\n            return;\n        }\n        // If png, make marker ID\n        if (suri[suri.length-1].endsWith(\".png\")) {\n            BufferInputStream bis = core.getDefaultMapStorage().getMarkerImage(uri.substring(0, uri.length()-4));\n            // Got image, package up for response\n            response.setIntHeader(\"Content-Length\", bis.length());\n            response.setContentType(\"image/png\");\n            ServletOutputStream out = response.getOutputStream();\n            out.write(bis.buffer(), 0, bis.length());\n            out.flush();\n            return;\n        }\n        response.sendError(HttpStatus.NOT_FOUND_404);\n    }\n\n    public void setCore(DynmapCore core) {\n        this.core = core;\n    }\n}\n"], "filenames": ["DynmapCore/src/main/java/org/dynmap/servlet/MapStorageResourceHandler.java"], "buggy_code_start_loc": [49], "buggy_code_end_loc": [50], "fixing_code_start_loc": [49], "fixing_code_end_loc": [54], "type": "CWE-287", "message": "In Webbukkit Dynmap 3.0-beta-3 or below, due to a missing login check in servlet/MapStorageHandler.java, an attacker can see a map image without login even if victim enables login-required in setting.", "other": {"cve": {"id": "CVE-2019-12395", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-28T13:29:00.490", "lastModified": "2021-11-08T19:47:10.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Webbukkit Dynmap 3.0-beta-3 or below, due to a missing login check in servlet/MapStorageHandler.java, an attacker can see a map image without login even if victim enables login-required in setting."}, {"lang": "es", "value": "En Webbukkit Dynmap 3.0-beta-3 o inferior, debido a una falta de comprobaci\u00f3n de inicio de sesi\u00f3n en servlet / MapStorageHandler.java, un atacante puede ver una imagen del mapa sin iniciar sesi\u00f3n, incluso si la v\u00edctima habilita el inicio de sesi\u00f3n requerido en la configuraci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dynmap_project:dynmap:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0", "matchCriteriaId": "10C67B48-312F-4A2C-9FC8-174028401A86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dynmap_project:dynmap:3.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "BB14CD41-5A40-46F5-B458-797C0724501B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dynmap_project:dynmap:3.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "856831C2-772A-4472-92A7-99AB91154735"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dynmap_project:dynmap:3.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "257ADFCF-9444-402D-97F6-AEB3379B04BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dynmap_project:dynmap:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "19BA4C5F-1600-46E2-9BE1-0DB74F729657"}]}]}], "references": [{"url": "http://jvn.jp/en/jp/JVN89046645/index.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/webbukkit/dynmap/commit/641f142cd3ccdcbfb04eda3059be22dd9ed93783", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/webbukkit/dynmap/issues/2474", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/webbukkit/dynmap/pull/2475", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/webbukkit/dynmap/commit/641f142cd3ccdcbfb04eda3059be22dd9ed93783"}}