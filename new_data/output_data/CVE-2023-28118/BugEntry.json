{"buggy_code": ["/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\n/**\n * Configuration options for parsing YAML to objects and serialising objects to YAML.\n *\n * * [encodeDefaults]: set to false to not write default property values to YAML (defaults to `true`)\n * * [strictMode]: set to true to throw an exception when reading an object that has an unknown property, or false to ignore unknown properties (defaults to `true`)\n * * [extensionDefinitionPrefix]: prefix used on root-level keys (where document root is an object) to define extensions that can later be merged (defaults to `null`, which disables extensions altogether). See https://batect.charleskorn.com/config/Overview.html#anchors-aliases-extensions-and-merging for example.\n * * [polymorphismStyle]: how to read or write the type of a polymorphic object:\n *    * [PolymorphismStyle.Tag]: use a YAML tag (eg. `!<typeOfThing> { property: value }`)\n *    * [PolymorphismStyle.Property]: use a property (eg. `{ type: typeOfThing, property: value }`)\n * * [polymorphismPropertyName]: property name to use when [polymorphismStyle] is [PolymorphismStyle.Property]\n * * [encodingIndentationSize]: number of spaces to use as indentation when encoding objects as YAML\n * * [breakScalarsAt]: maximum length of scalars when encoding objects as YAML (scalars exceeding this length will be split into multiple lines)\n * * [sequenceStyle]: how sequences (aka lists and arrays) should be formatted. See [SequenceStyle] for an example of each\n * * [ambiguousQuoteStyle]: how strings should be escaped when [singleLineStringStyle] is [SingleLineStringStyle.PlainExceptAmbiguous] and the value is ambiguous\n * * [sequenceBlockIndent]: number of spaces to use as indentation for sequences, if [sequenceStyle] set to [SequenceStyle.Block]\n */\npublic data class YamlConfiguration constructor(\n    internal val encodeDefaults: Boolean = true,\n    internal val strictMode: Boolean = true,\n    internal val extensionDefinitionPrefix: String? = null,\n    internal val polymorphismStyle: PolymorphismStyle = PolymorphismStyle.Tag,\n    internal val polymorphismPropertyName: String = \"type\",\n    internal val encodingIndentationSize: Int = 2,\n    internal val breakScalarsAt: Int = 80,\n    internal val sequenceStyle: SequenceStyle = SequenceStyle.Block,\n    internal val singleLineStringStyle: SingleLineStringStyle = SingleLineStringStyle.DoubleQuoted,\n    internal val multiLineStringStyle: MultiLineStringStyle = singleLineStringStyle.multiLineStringStyle,\n    internal val ambiguousQuoteStyle: AmbiguousQuoteStyle = AmbiguousQuoteStyle.DoubleQuoted,\n    internal val sequenceBlockIndent: Int = 0,\n)\n\npublic enum class PolymorphismStyle {\n    Tag,\n    Property,\n}\n\npublic enum class SequenceStyle {\n    /**\n     * The block form, eg\n     * ```yaml\n     * - 1\n     * - 2\n     * - 3\n     * ```\n     */\n    Block,\n\n    /**\n     * The flow form, eg\n     * ```yaml\n     * [1, 2, 3]\n     * ```\n     */\n    Flow,\n}\n\npublic enum class MultiLineStringStyle {\n    Literal,\n    DoubleQuoted,\n    SingleQuoted,\n    Plain,\n}\n\npublic enum class SingleLineStringStyle {\n    DoubleQuoted,\n    SingleQuoted,\n    Plain,\n\n    /**\n     * This is the same as [SingleLineStringStyle.Plain], except strings that could be misinterpreted as other types\n     * will be quoted with the escape style defined in [AmbiguousQuoteStyle].\n     *\n     * For example, the strings \"True\", \"0xAB\", \"1\" and \"1.2\" would all be quoted,\n     * while \"1.2.3\" and \"abc\" would not be quoted.\n     */\n    PlainExceptAmbiguous,\n    ;\n\n    public val multiLineStringStyle: MultiLineStringStyle\n        get() = when (this) {\n            DoubleQuoted -> MultiLineStringStyle.DoubleQuoted\n            SingleQuoted -> MultiLineStringStyle.SingleQuoted\n            Plain -> MultiLineStringStyle.Plain\n            PlainExceptAmbiguous -> MultiLineStringStyle.Plain\n        }\n}\n\npublic enum class AmbiguousQuoteStyle {\n    DoubleQuoted,\n    SingleQuoted,\n}\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\nimport kotlinx.serialization.SerializationException\n\npublic open class YamlException(\n    override val message: String,\n    public val path: YamlPath,\n    override val cause: Throwable? = null,\n) : SerializationException(message, cause) {\n    public val location: Location = path.endLocation\n    public val line: Int = location.line\n    public val column: Int = location.column\n\n    override fun toString(): String = \"${this::class.qualifiedName} at ${path.toHumanReadableString()} on line $line, column $column: $message\"\n}\n\npublic class DuplicateKeyException(\n    public val originalPath: YamlPath,\n    public val duplicatePath: YamlPath,\n    public val key: String,\n) :\n    YamlException(\"Duplicate key $key. It was previously given at line ${originalPath.endLocation.line}, column ${originalPath.endLocation.column}.\", duplicatePath) {\n\n    public val originalLocation: Location = originalPath.endLocation\n    public val duplicateLocation: Location = duplicatePath.endLocation\n}\n\npublic class EmptyYamlDocumentException(message: String, path: YamlPath) : YamlException(message, path)\n\npublic class InvalidPropertyValueException(\n    public val propertyName: String,\n    public val reason: String,\n    path: YamlPath,\n    cause: Throwable? = null,\n) : YamlException(\"Value for '$propertyName' is invalid: $reason\", path, cause)\n\npublic class MalformedYamlException(message: String, path: YamlPath) : YamlException(message, path)\n\npublic class UnexpectedNullValueException(path: YamlPath) : YamlException(\"Unexpected null or empty value for non-null field.\", path)\n\npublic class MissingRequiredPropertyException(\n    public val propertyName: String,\n    path: YamlPath,\n    cause: Throwable? = null,\n) :\n    YamlException(\"Property '$propertyName' is required but it is missing.\", path, cause)\n\npublic class UnknownPropertyException(\n    public val propertyName: String,\n    public val validPropertyNames: Set<String>,\n    path: YamlPath,\n) :\n    YamlException(\"Unknown property '$propertyName'. Known properties are: ${validPropertyNames.sorted().joinToString(\", \")}\", path)\n\npublic class UnknownPolymorphicTypeException(\n    public val typeName: String,\n    public val validTypeNames: Set<String>,\n    path: YamlPath,\n    cause: Throwable? = null,\n) :\n    YamlException(\"Unknown type '$typeName'. Known types are: ${validTypeNames.sorted().joinToString(\", \")}\", path, cause)\n\npublic class YamlScalarFormatException(\n    message: String,\n    path: YamlPath,\n    public val originalValue: String,\n) : YamlException(message, path)\n\npublic open class IncorrectTypeException(message: String, path: YamlPath) : YamlException(message, path)\n\npublic class MissingTypeTagException(path: YamlPath) :\n    IncorrectTypeException(\"Value is missing a type tag (eg. !<type>)\", path)\n\npublic class UnknownAnchorException(public val anchorName: String, path: YamlPath) :\n    YamlException(\"Unknown anchor '$anchorName'.\", path)\n\npublic class NoAnchorForExtensionException(\n    public val key: String,\n    public val extensionDefinitionPrefix: String,\n    path: YamlPath,\n) :\n    YamlException(\"The key '$key' starts with the extension definition prefix '$extensionDefinitionPrefix' but does not define an anchor.\", path)\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n@file:OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\n\npackage com.charleskorn.kaml\n\nimport com.charleskorn.kaml.testobjects.NestedObjects\nimport com.charleskorn.kaml.testobjects.PolymorphicWrapper\nimport com.charleskorn.kaml.testobjects.SealedWrapper\nimport com.charleskorn.kaml.testobjects.SimpleStructure\nimport com.charleskorn.kaml.testobjects.Team\nimport com.charleskorn.kaml.testobjects.TestEnum\nimport com.charleskorn.kaml.testobjects.TestEnumWithExplicitNames\nimport com.charleskorn.kaml.testobjects.TestSealedStructure\nimport com.charleskorn.kaml.testobjects.UnsealedClass\nimport com.charleskorn.kaml.testobjects.UnsealedString\nimport com.charleskorn.kaml.testobjects.UnwrappedInt\nimport com.charleskorn.kaml.testobjects.UnwrappedInterface\nimport com.charleskorn.kaml.testobjects.UnwrappedString\nimport com.charleskorn.kaml.testobjects.polymorphicModule\nimport io.kotest.assertions.asClue\nimport io.kotest.assertions.throwables.shouldThrow\nimport io.kotest.core.spec.style.DescribeSpec\nimport io.kotest.matchers.shouldBe\nimport io.kotest.matchers.types.shouldBeInstanceOf\nimport kotlinx.serialization.Contextual\nimport kotlinx.serialization.ExperimentalSerializationApi\nimport kotlinx.serialization.InternalSerializationApi\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.PolymorphicSerializer\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.builtins.ListSerializer\nimport kotlinx.serialization.builtins.MapSerializer\nimport kotlinx.serialization.builtins.nullable\nimport kotlinx.serialization.builtins.serializer\nimport kotlinx.serialization.descriptors.PrimitiveKind\nimport kotlinx.serialization.descriptors.PrimitiveSerialDescriptor\nimport kotlinx.serialization.descriptors.SerialDescriptor\nimport kotlinx.serialization.descriptors.SerialKind\nimport kotlinx.serialization.descriptors.StructureKind\nimport kotlinx.serialization.descriptors.buildClassSerialDescriptor\nimport kotlinx.serialization.descriptors.buildSerialDescriptor\nimport kotlinx.serialization.encoding.Decoder\nimport kotlinx.serialization.encoding.Encoder\nimport kotlinx.serialization.modules.serializersModuleOf\nimport kotlin.jvm.JvmInline\n\nclass YamlReadingTest : DescribeSpec({\n    describe(\"a YAML parser\") {\n        describe(\"parsing scalars\") {\n            context(\"given the input 'hello'\") {\n                val input = \"hello\"\n\n                context(\"parsing that input as a string\") {\n                    val result = Yaml.default.decodeFromString(String.serializer(), input)\n\n                    it(\"deserializes it to the expected string value\") {\n                        result shouldBe \"hello\"\n                    }\n                }\n\n                context(\"parsing that input as a nullable string\") {\n                    val result = Yaml.default.decodeFromString(String.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected string value\") {\n                        result shouldBe \"hello\"\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(LocationThrowingSerializer, input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 1) and path: <root>\"\n                        }\n                    }\n                }\n\n                context(\"parsing that input as a value type\") {\n                    val result = Yaml.default.decodeFromString(StringValue.serializer(), input)\n\n                    it(\"deserializes it to the expected object\") {\n                        result shouldBe StringValue(\"hello\")\n                    }\n                }\n            }\n\n            context(\"given the input '123'\") {\n                val input = \"123\"\n\n                context(\"parsing that input as an integer\") {\n                    val result = Yaml.default.decodeFromString(Int.serializer(), input)\n\n                    it(\"deserializes it to the expected integer\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a long\") {\n                    val result = Yaml.default.decodeFromString(Long.serializer(), input)\n\n                    it(\"deserializes it to the expected long\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a short\") {\n                    val result = Yaml.default.decodeFromString(Short.serializer(), input)\n\n                    it(\"deserializes it to the expected short\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a byte\") {\n                    val result = Yaml.default.decodeFromString(Byte.serializer(), input)\n\n                    it(\"deserializes it to the expected byte\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a double\") {\n                    val result = Yaml.default.decodeFromString(Double.serializer(), input)\n\n                    it(\"deserializes it to the expected double\") {\n                        result shouldBe 123.0\n                    }\n                }\n\n                context(\"parsing that input as a float\") {\n                    val result = Yaml.default.decodeFromString(Float.serializer(), input)\n\n                    it(\"deserializes it to the expected float\") {\n                        result shouldBe 123.0f\n                    }\n                }\n\n                context(\"parsing that input as a nullable integer\") {\n                    val result = Yaml.default.decodeFromString(Int.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected integer\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a nullable long\") {\n                    val result = Yaml.default.decodeFromString(Long.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected long\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a nullable short\") {\n                    val result = Yaml.default.decodeFromString(Short.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected short\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a nullable byte\") {\n                    val result = Yaml.default.decodeFromString(Byte.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected byte\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a nullable double\") {\n                    val result = Yaml.default.decodeFromString(Double.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected double\") {\n                        result shouldBe 123.0\n                    }\n                }\n\n                context(\"parsing that input as a nullable float\") {\n                    val result = Yaml.default.decodeFromString(Float.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected float\") {\n                        result shouldBe 123.0f\n                    }\n                }\n            }\n\n            context(\"given the input 'true'\") {\n                val input = \"true\"\n\n                context(\"parsing that input as a boolean\") {\n                    val result = Yaml.default.decodeFromString(Boolean.serializer(), input)\n\n                    it(\"deserializes it to the expected boolean value\") {\n                        result shouldBe true\n                    }\n                }\n\n                context(\"parsing that input as a nullable boolean\") {\n                    val result = Yaml.default.decodeFromString(Boolean.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected boolean value\") {\n                        result shouldBe true\n                    }\n                }\n            }\n\n            context(\"given the input 'c'\") {\n                val input = \"c\"\n\n                context(\"parsing that input as a character\") {\n                    val result = Yaml.default.decodeFromString(Char.serializer(), input)\n\n                    it(\"deserializes it to the expected character value\") {\n                        result shouldBe 'c'\n                    }\n                }\n\n                context(\"parsing that input as a nullable character\") {\n                    val result = Yaml.default.decodeFromString(Char.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected character value\") {\n                        result shouldBe 'c'\n                    }\n                }\n            }\n\n            data class EnumFixture(val input: String, val serializer: KSerializer<*>)\n\n            mapOf(\n                EnumFixture(\"Value1\", TestEnum.serializer()) to TestEnum.Value1,\n                EnumFixture(\"Value2\", TestEnum.serializer()) to TestEnum.Value2,\n                EnumFixture(\"A\", TestEnumWithExplicitNames.serializer()) to TestEnumWithExplicitNames.Alpha,\n                EnumFixture(\"B\", TestEnumWithExplicitNames.serializer()) to TestEnumWithExplicitNames.Beta,\n                EnumFixture(\"With space\", TestEnumWithExplicitNames.serializer()) to TestEnumWithExplicitNames.WithSpace,\n            ).forEach { (fixture, expectedValue) ->\n                val (input, serializer) = fixture\n                context(\"given the input '$input'\") {\n                    context(\"parsing that input as an enumeration value\") {\n                        val result = Yaml.default.decodeFromString(serializer, input)\n\n                        it(\"deserializes it to the expected enumeration value\") {\n                            result shouldBe expectedValue\n                        }\n                    }\n                }\n            }\n\n            context(\"parsing an invalid enumeration value\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<YamlScalarFormatException> { Yaml.default.decodeFromString(TestEnum.serializer(), \"nonsense\") }\n\n                    exception.asClue {\n                        it.message shouldBe \"Value 'nonsense' is not a valid option, permitted choices are: Value1, Value2\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing null values\") {\n            val input = \"null\"\n\n            context(\"parsing a null value as a nullable string\") {\n                val result = Yaml.default.decodeFromString(String.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable string\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(String.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable integer\") {\n                val result = Yaml.default.decodeFromString(Int.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable integer\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Int.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable long\") {\n                val result = Yaml.default.decodeFromString(Long.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable long\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Long.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable short\") {\n                val result = Yaml.default.decodeFromString(Short.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable short\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Short.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable byte\") {\n                val result = Yaml.default.decodeFromString(Byte.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable byte\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Byte.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable double\") {\n                val result = Yaml.default.decodeFromString(Double.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable double\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Double.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable float\") {\n                val result = Yaml.default.decodeFromString(Float.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable float\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Float.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable boolean\") {\n                val result = Yaml.default.decodeFromString(Boolean.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable boolean\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Boolean.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable character\") {\n                val result = Yaml.default.decodeFromString(Char.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable character\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Char.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable enum\") {\n                val result = Yaml.default.decodeFromString(TestEnum.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable enum\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(TestEnum.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable list\") {\n                val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()).nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable list\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable object\") {\n                val result = Yaml.default.decodeFromString(ComplexStructure.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable object\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value with a serializer that uses YAML location information when throwing exceptions\") {\n                it(\"throws an exception with the correct location information\") {\n                    val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(LocationThrowingSerializer, input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Serializer called with location (1, 1) and path: <root>\"\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing lists\") {\n            context(\"given a list of strings\") {\n                val input = \"\"\"\n                    - thing1\n                    - thing2\n                    - thing3\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(\"thing1\", \"thing2\", \"thing3\")\n                    }\n                }\n\n                context(\"parsing that input as a nullable list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()).nullable, input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(\"thing1\", \"thing2\", \"thing3\")\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(ListSerializer(LocationThrowingSerializer), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 3) and path: [0]\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given a list of numbers\") {\n                val input = \"\"\"\n                    - 123\n                    - 45\n                    - 6\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list of integers\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Int.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123, 45, 6)\n                    }\n                }\n\n                context(\"parsing that input as a list of longs\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Long.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123L, 45, 6)\n                    }\n                }\n\n                context(\"parsing that input as a list of shorts\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Short.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123.toShort(), 45, 6)\n                    }\n                }\n\n                context(\"parsing that input as a list of bytes\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Byte.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123.toByte(), 45, 6)\n                    }\n                }\n\n                context(\"parsing that input as a list of doubles\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Double.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123.0, 45.0, 6.0)\n                    }\n                }\n\n                context(\"parsing that input as a list of floats\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Float.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123.0f, 45.0f, 6.0f)\n                    }\n                }\n            }\n\n            context(\"given a list of booleans\") {\n                val input = \"\"\"\n                    - true\n                    - false\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Boolean.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(true, false)\n                    }\n                }\n            }\n\n            context(\"given a list of enum values\") {\n                val input = \"\"\"\n                    - Value1\n                    - Value2\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(TestEnum.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(TestEnum.Value1, TestEnum.Value2)\n                    }\n                }\n            }\n\n            context(\"given a list of characters\") {\n                val input = \"\"\"\n                    - a\n                    - b\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Char.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf('a', 'b')\n                    }\n                }\n            }\n\n            context(\"given a list of nullable strings\") {\n                val input = \"\"\"\n                    - thing1\n                    - null\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer().nullable), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(\"thing1\", null)\n                    }\n                }\n            }\n\n            context(\"given a list of lists\") {\n                val input = \"\"\"\n                    - [thing1, thing2]\n                    - [thing3]\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(ListSerializer(String.serializer())), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe\n                            listOf(\n                                listOf(\"thing1\", \"thing2\"),\n                                listOf(\"thing3\"),\n                            )\n                    }\n                }\n            }\n\n            context(\"given a list of objects\") {\n                val input = \"\"\"\n                    - name: thing1\n                    - name: thing2\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(SimpleStructure.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe\n                            listOf(\n                                SimpleStructure(\"thing1\"),\n                                SimpleStructure(\"thing2\"),\n                            )\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing objects\") {\n            context(\"given some input representing an object with an optional value specified\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                    nullable: present\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                \"present\",\n                            )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an optional value specified as null\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                    nullable: null\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                null,\n                            )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an optional value not specified\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                null,\n                            )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an embedded list\") {\n                val input = \"\"\"\n                    members:\n                        - Alex\n                        - Jamie\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(Team.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe Team(listOf(\"Alex\", \"Jamie\"))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an embedded object\") {\n                val input = \"\"\"\n                    firstPerson:\n                        name: Alex\n                    secondPerson:\n                        name: Jamie\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NestedObjects.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe NestedObjects(SimpleStructure(\"Alex\"), SimpleStructure(\"Jamie\"))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object where the keys are in a different order to the object definition\") {\n                val input = \"\"\"\n                    secondPerson:\n                        name: Jamie\n                    firstPerson:\n                        name: Alex\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NestedObjects.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe NestedObjects(SimpleStructure(\"Alex\"), SimpleStructure(\"Jamie\"))\n                    }\n                }\n            }\n\n            context(\"given some tagged input representing an arbitrary list\") {\n                val input = \"\"\"\n                    !!list\n                        - 5\n                        - 3\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Int.serializer()), input)\n                    it(\"deserializes it to a list ignoring the tag\") {\n                        result shouldBe listOf(5, 3)\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(LocationThrowingSerializer, input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 1) and path: <root>\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given some tagged input representing an arbitrary map\") {\n                val input = \"\"\"\n                    !!map\n                    foo: bar\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as map\") {\n                    val result = Yaml.default.decodeFromString(\n                        MapSerializer(String.serializer(), String.serializer()),\n                        input,\n                    )\n                    it(\"deserializes it to a Map ignoring the tag\") {\n                        result shouldBe mapOf(\"foo\" to \"bar\")\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(LocationThrowingMapSerializer, input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 1) and path: <root>\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a missing key\") {\n                val input = \"\"\"\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<MissingRequiredPropertyException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Property 'string' is required but it is missing.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 1\n                            it.propertyName shouldBe \"string\"\n                            it.path shouldBe YamlPath.root\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an unknown key\") {\n                val input = \"\"\"\n                    abc123: something\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<UnknownPropertyException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Unknown property 'abc123'. Known properties are: boolean, byte, char, double, enum, float, int, long, nullable, short, string\"\n                            it.line shouldBe 1\n                            it.column shouldBe 1\n                            it.propertyName shouldBe \"abc123\"\n                            it.validPropertyNames shouldBe setOf(\"boolean\", \"byte\", \"char\", \"double\", \"enum\", \"float\", \"int\", \"long\", \"nullable\", \"short\", \"string\")\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"abc123\", Location(1, 1))\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an invalid value for a field\") {\n                mapOf(\n                    \"byte\" to \"Value 'xxx' is not a valid byte value.\",\n                    \"short\" to \"Value 'xxx' is not a valid short value.\",\n                    \"int\" to \"Value 'xxx' is not a valid integer value.\",\n                    \"long\" to \"Value 'xxx' is not a valid long value.\",\n                    \"float\" to \"Value 'xxx' is not a valid floating point value.\",\n                    \"double\" to \"Value 'xxx' is not a valid floating point value.\",\n                    \"enum\" to \"Value 'xxx' is not a valid option, permitted choices are: Value1, Value2\",\n                    \"boolean\" to \"Value 'xxx' is not a valid boolean, permitted choices are: true or false\",\n                    \"char\" to \"Value 'xxx' is not a valid character value.\",\n                ).forEach { (fieldName, errorMessage) ->\n                    context(\"given the invalid field represents a $fieldName\") {\n                        val input = \"$fieldName: xxx\"\n\n                        context(\"parsing that input\") {\n                            it(\"throws an appropriate exception\") {\n                                val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Value for '$fieldName' is invalid: $errorMessage\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe fieldName.length + 3\n                                    it.propertyName shouldBe fieldName\n                                    it.reason shouldBe errorMessage\n                                    it.path shouldBe YamlPath.root.withMapElementKey(fieldName, Location(1, 1)).withMapElementValue(Location(1, fieldName.length + 3))\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable scalar field\") {\n                val input = \"name: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(SimpleStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'name' is invalid: Unexpected null or empty value for non-null field.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 7\n                            it.propertyName shouldBe \"name\"\n                            it.reason shouldBe \"Unexpected null or empty value for non-null field.\"\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"name\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable nested object field\") {\n                val input = \"firstPerson: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(NestedObjects.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'firstPerson' is invalid: Unexpected null or empty value for non-null field.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 14\n                            it.propertyName shouldBe \"firstPerson\"\n                            it.reason shouldBe \"Unexpected null or empty value for non-null field.\"\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"firstPerson\", Location(1, 1)).withMapElementValue(Location(1, 14))\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a nullable nested object field\") {\n\n                val input = \"firstPerson: null\"\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NullableNestedObject.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe NullableNestedObject(null)\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable nested list field\") {\n                val input = \"members: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(Team.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'members' is invalid: Unexpected null or empty value for non-null field.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 10\n                            it.propertyName shouldBe \"members\"\n                            it.reason shouldBe \"Unexpected null or empty value for non-null field.\"\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"members\", Location(1, 1)).withMapElementValue(Location(1, 10))\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a nullable nested list field\") {\n                val input = \"members: null\"\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NullableNestedList.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe NullableNestedList(null)\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a custom serializer for one of its values\") {\n                val input = \"value: something\"\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(StructureWithLocationThrowingSerializer.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 8) and path: value\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing a generic map\") {\n                val input = \"\"\"\n                    SOME_ENV_VAR: somevalue\n                    SOME_OTHER_ENV_VAR: someothervalue\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                    it(\"deserializes it to a Kotlin map\") {\n                        result shouldBe\n                            mapOf(\n                                \"SOME_ENV_VAR\" to \"somevalue\",\n                                \"SOME_OTHER_ENV_VAR\" to \"someothervalue\",\n                            )\n                    }\n                }\n\n                context(\"parsing that input with a serializer for the key that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(MapSerializer(LocationThrowingSerializer, String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 1) and path: SOME_ENV_VAR\"\n                        }\n                    }\n                }\n\n                context(\"parsing that input with a serializer for the value that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(MapSerializer(String.serializer(), LocationThrowingSerializer), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 15) and path: SOME_ENV_VAR\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input with some extensions\") {\n                val input = \"\"\"\n                    .some-extension: &name Jamie\n\n                    name: *name\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val configuration = YamlConfiguration(extensionDefinitionPrefix = \".\")\n                    val yaml = Yaml(configuration = configuration)\n                    val result = yaml.decodeFromString(SimpleStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object, replacing the reference to the extension with the extension\") {\n                        result shouldBe SimpleStructure(\"Jamie\")\n                    }\n                }\n            }\n\n            context(\"given some input with an additional unknown field\") {\n                val input = \"\"\"\n                    name: Blah Blahson\n                    extra-field: Hello\n                \"\"\".trimIndent()\n\n                context(\"given strict mode is enabled\") {\n                    val configuration = YamlConfiguration(strictMode = true)\n                    val yaml = Yaml(configuration = configuration)\n\n                    context(\"parsing that input\") {\n                        it(\"throws an appropriate exception\") {\n                            val exception = shouldThrow<UnknownPropertyException> { yaml.decodeFromString(SimpleStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown property 'extra-field'. Known properties are: name\"\n                                it.line shouldBe 2\n                                it.column shouldBe 1\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"extra-field\", Location(2, 1))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given strict mode is disabled\") {\n                    val configuration = YamlConfiguration(strictMode = false)\n                    val yaml = Yaml(configuration = configuration)\n\n                    context(\"parsing that input\") {\n                        it(\"ignores the extra field and returns a deserialised object\") {\n                            yaml.decodeFromString(SimpleStructure.serializer(), input) shouldBe SimpleStructure(\"Blah Blahson\")\n                        }\n                    }\n                }\n            }\n\n            context(\"given a nullable object\") {\n                val input = \"\"\"\n                    host: \"db.test.com\"\n                \"\"\".trimIndent()\n\n                val result = Yaml.default.decodeFromString(Database.serializer().nullable, input)\n\n                it(\"deserializes it to the expected object\") {\n                    result shouldBe Database(\"db.test.com\")\n                }\n            }\n        }\n\n        describe(\"parsing polymorphic values\") {\n            describe(\"given tags are used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Tag))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        !<sealedString>\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                // See https://github.com/charleskorn/kaml/issues/179.\n                context(\"given some input where a tag is provided but no value is provided\") {\n                    val input = \"\"\"\n                        !<sealedString>\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an appropriate exception\") {\n                            val exception = shouldThrow<MissingRequiredPropertyException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Property 'value' is required but it is missing.\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.propertyName shouldBe \"value\"\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input where the value is a literal\") {\n                    val input = \"\"\"\n                        !<simpleString> \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnwrappedInterface::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe UnwrappedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as a string\") {\n                        val result = polymorphicYaml.decodeFromString(String.serializer(), input)\n\n                        it(\"deserializes it to a string ignoring the tag\") {\n                            result shouldBe \"asdfg\"\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        !<unsealedString>\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe UnsealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element: !<sealedString>\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"element\" to mapOf(\"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value is a literal\") {\n                    val input = \"\"\"\n                        test: !<simpleInt> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe PolymorphicWrapper(UnwrappedInt(42))\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - !<sealedString>\n                          value: null\n                        - !<sealedInt>\n                          value: -987\n                        - !<sealedInt>\n                          value: 654\n                        - !<sealedString>\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\"),\n                                )\n                        }\n                    }\n                }\n\n                context(\"given some untagged input for a polymorphic class\") {\n                    val input = \"\"\"\n                        element:\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Value for 'element' is invalid: Value is missing a type tag (eg. !<type>)\"\n                                it.line shouldBe 2\n                                it.column shouldBe 5\n                                it.cause.shouldBeInstanceOf<MissingTypeTagException>()\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"element\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some untagged input for a polymorphic value\") {\n                    val input = \"\"\"\n                        test: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Value for 'test' is invalid: Value is missing a type tag (eg. !<type>)\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.cause.shouldBeInstanceOf<MissingTypeTagException>()\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"test\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some untagged null input for a polymorphic value\") {\n                    val input = \"\"\"\n                        test: null\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Value for 'test' is invalid: Value is missing a type tag (eg. !<type>)\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.cause.shouldBeInstanceOf<MissingTypeTagException>()\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"test\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"unsealedBoolean\", \"unsealedString\")\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"sealedInt\", \"sealedString\")\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value from a literal with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"sealedInt\", \"sealedString\")\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n            }\n\n            describe(\"given a property is used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Property))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        type: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map including the type\") {\n                            result shouldBe mapOf(\"type\" to \"sealedString\", \"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        type: unsealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe UnsealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"type\" to \"unsealedString\", \"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element:\n                            type: sealedString\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"element\" to mapOf(\"type\" to \"sealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input missing a type property\") {\n                    val input = \"\"\"\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<MissingRequiredPropertyException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Property 'type' is required but it is missing.\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.propertyName shouldBe \"type\"\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                mapOf(\n                    \"a list\" to \"[]\",\n                    \"a map\" to \"{}\",\n                    \"a null value\" to \"null\",\n                    \"a tagged value\" to \"!<tag> sealedString\",\n                ).forEach { (description, value) ->\n                    context(\"given some input with a type property that is $description\") {\n                        val input = \"\"\"\n                            type: $value\n                            value: \"asdfg\"\n                        \"\"\".trimIndent()\n\n                        context(\"parsing that input\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Value for 'type' is invalid: expected a string, but got $description\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 7\n                                    it.propertyName shouldBe \"type\"\n                                    it.reason shouldBe \"expected a string, but got $description\"\n                                    it.path shouldBe YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - type: sealedString\n                          value: null\n                        - type: sealedInt\n                          value: -987\n                        - type: sealedInt\n                          value: 654\n                        - type: sealedString\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\"),\n                                )\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        type: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"unsealedBoolean\", \"unsealedString\")\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        type: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"sealedInt\", \"sealedString\")\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input with a tag and a type property\") {\n                    val input = \"\"\"\n                        !<sealedInt>\n                        type: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"uses the type from the property and ignores the tag\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n                }\n            }\n\n            describe(\"given a custom property name is used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Property, polymorphismPropertyName = \"kind\"))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        kind: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map including the type\") {\n                            result shouldBe mapOf(\"kind\" to \"sealedString\", \"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        kind: unsealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe UnsealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"kind\" to \"unsealedString\", \"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element:\n                            kind: sealedString\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"element\" to mapOf(\"kind\" to \"sealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input missing a type property\") {\n                    val input = \"\"\"\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<MissingRequiredPropertyException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Property 'kind' is required but it is missing.\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.propertyName shouldBe \"kind\"\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                mapOf(\n                    \"a list\" to \"[]\",\n                    \"a map\" to \"{}\",\n                    \"a null value\" to \"null\",\n                    \"a tagged value\" to \"!<tag> sealedString\",\n                ).forEach { (description, value) ->\n                    context(\"given some input with a type property that is $description\") {\n                        val input = \"\"\"\n                            kind: $value\n                            value: \"asdfg\"\n                        \"\"\".trimIndent()\n\n                        context(\"parsing that input\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Value for 'kind' is invalid: expected a string, but got $description\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 7\n                                    it.propertyName shouldBe \"kind\"\n                                    it.reason shouldBe \"expected a string, but got $description\"\n                                    it.path shouldBe YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - kind: sealedString\n                          value: null\n                        - kind: sealedInt\n                          value: -987\n                        - kind: sealedInt\n                          value: 654\n                        - kind: sealedString\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\"),\n                                )\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        kind: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"unsealedBoolean\", \"unsealedString\")\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        kind: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"sealedInt\", \"sealedString\")\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input with a tag and a type property\") {\n                    val input = \"\"\"\n                        !<sealedInt>\n                        kind: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"uses the type from the property and ignores the tag\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing values with a dynamically installed serializer\") {\n            describe(\"parsing a literal with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor: SerialDescriptor\n                        get() = String.serializer().descriptor\n\n                    override fun deserialize(decoder: Decoder): Inner = Inner(\"from context serializer\")\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    result shouldBe Container(Inner(\"from context serializer\"))\n                }\n            }\n\n            describe(\"parsing a class with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor = buildClassSerialDescriptor(\"Inner\") {\n                        element(\"thing\", String.serializer().descriptor)\n                    }\n\n                    override fun deserialize(decoder: Decoder): Inner {\n                        val objectDecoder = decoder.beginStructure(descriptor)\n                        val index = objectDecoder.decodeElementIndex(descriptor)\n                        val name = objectDecoder.decodeStringElement(descriptor, index)\n                        objectDecoder.endStructure(descriptor)\n\n                        return Inner(\"$name, from context serializer\")\n                    }\n\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner:\n                        thing: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    result shouldBe Container(Inner(\"this is the input, from context serializer\"))\n                }\n            }\n\n            describe(\"parsing a map with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor = buildSerialDescriptor(\"Inner\", StructureKind.MAP) {\n                        element(\"key\", String.serializer().descriptor)\n                        element(\"value\", String.serializer().descriptor)\n                    }\n\n                    override fun deserialize(decoder: Decoder): Inner {\n                        val objectDecoder = decoder.beginStructure(descriptor)\n                        val keyIndex = objectDecoder.decodeElementIndex(descriptor)\n                        val key = objectDecoder.decodeStringElement(descriptor, keyIndex)\n                        val valueIndex = objectDecoder.decodeElementIndex(descriptor)\n                        val value = objectDecoder.decodeStringElement(descriptor, valueIndex)\n\n                        objectDecoder.endStructure(descriptor)\n\n                        return Inner(\"$key: $value, from context serializer\")\n                    }\n\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner:\n                        thing: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    result shouldBe Container(Inner(\"thing: this is the input, from context serializer\"))\n                }\n            }\n        }\n\n        describe(\"parsing values with mismatched types\") {\n            data class Scenario(\n                val description: String,\n                val serializer: KSerializer<out Any?>,\n                val expectedErrorMessage: String = description,\n            )\n\n            context(\"given a list\") {\n                listOf(\n                    Scenario(\"a string\", String.serializer()),\n                    Scenario(\"an integer\", Int.serializer()),\n                    Scenario(\"a long\", Long.serializer()),\n                    Scenario(\"a short\", Short.serializer()),\n                    Scenario(\"a byte\", Byte.serializer()),\n                    Scenario(\"a double\", Double.serializer()),\n                    Scenario(\"a float\", Float.serializer()),\n                    Scenario(\"a boolean\", Boolean.serializer()),\n                    Scenario(\"a character\", Char.serializer()),\n                    Scenario(\"an enumeration value\", TestEnum.serializer()),\n                    Scenario(\"a map\", MapSerializer(String.serializer(), String.serializer())),\n                    Scenario(\"an object\", ComplexStructure.serializer()),\n                    Scenario(\"a nullable string\", String.serializer().nullable, \"a string\"),\n                ).forEach { (description, serializer, expectedErrorMessage) ->\n                    val input = \"- thing\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(serializer, input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Expected $expectedErrorMessage, but got a list\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key:\n                            - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'key' is invalid: Expected a string, but got a list\"\n                            it.line shouldBe 2\n                            it.column shouldBe 5\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        string:\n                            - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'string' is invalid: Expected a string, but got a list\"\n                            it.line shouldBe 2\n                            it.column shouldBe 5\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"string\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - [ some_value ]\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Expected a string, but got a list\"\n                            it.line shouldBe 1\n                            it.column shouldBe 3\n                            it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3))\n                        }\n                    }\n                }\n            }\n\n            context(\"given a map\") {\n                listOf(\n                    Scenario(\"a string\", String.serializer()),\n                    Scenario(\"an integer\", Int.serializer()),\n                    Scenario(\"a long\", Long.serializer()),\n                    Scenario(\"a short\", Short.serializer()),\n                    Scenario(\"a byte\", Byte.serializer()),\n                    Scenario(\"a double\", Double.serializer()),\n                    Scenario(\"a float\", Float.serializer()),\n                    Scenario(\"a boolean\", Boolean.serializer()),\n                    Scenario(\"a character\", Char.serializer()),\n                    Scenario(\"an enumeration value\", TestEnum.serializer()),\n                    Scenario(\"a list\", ListSerializer(String.serializer())),\n                    Scenario(\"a nullable string\", String.serializer().nullable, \"a string\"),\n                ).forEach { (description, serializer, expectedErrorMessage) ->\n                    val input = \"key: value\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(serializer, input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Expected $expectedErrorMessage, but got a map\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key:\n                            some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'key' is invalid: Expected a string, but got a map\"\n                            it.line shouldBe 2\n                            it.column shouldBe 5\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        string:\n                            some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'string' is invalid: Expected a string, but got a map\"\n                            it.line shouldBe 2\n                            it.column shouldBe 5\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"string\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Expected a string, but got a map\"\n                            it.line shouldBe 1\n                            it.column shouldBe 3\n                            it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3))\n                        }\n                    }\n                }\n            }\n\n            context(\"given a scalar value\") {\n                mapOf(\n                    \"a list\" to ListSerializer(String.serializer()),\n                    \"a map\" to MapSerializer(String.serializer(), String.serializer()),\n                    \"an object\" to ComplexStructure.serializer(),\n                ).forEach { (description, serializer) ->\n                    val input = \"blah\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(serializer, input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Expected $description, but got a scalar value\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(MapSerializer(String.serializer(), ListSerializer(String.serializer())), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'key' is invalid: Expected a list, but got a scalar value\"\n                            it.line shouldBe 1\n                            it.column shouldBe 6\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(1, 6))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        members: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(Team.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'members' is invalid: Expected a list, but got a scalar value\"\n                            it.line shouldBe 1\n                            it.column shouldBe 10\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"members\", Location(1, 1)).withMapElementValue(Location(1, 10))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ListSerializer((ListSerializer(String.serializer()))), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Expected a list, but got a scalar value\"\n                            it.line shouldBe 1\n                            it.column shouldBe 3\n                            it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3))\n                        }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing values with a contextual serializer\") {\n            mapOf(\n                \"scalar\" to \"2\",\n                \"list\" to \"[ thing ]\",\n                \"map\" to \"{ key: value }\",\n            ).forEach { (description, input) ->\n                context(\"given some input representing a $description\") {\n                    context(\"parsing that input using a contextual serializer at the top level\") {\n                        val result = Yaml.default.decodeFromString(ContextualSerializer, input)\n\n                        it(\"the serializer receives the top-level object\") {\n                            result shouldBe description\n                        }\n                    }\n\n                    context(\"parsing that input using a contextual serializer nested within an object\") {\n                        val result = Yaml.default.decodeFromString(ObjectWithNestedContextualSerializer.serializer(), \"thing: $input\")\n\n                        it(\"the serializer receives the correct object\") {\n                            result shouldBe ObjectWithNestedContextualSerializer(description)\n                        }\n                    }\n                }\n            }\n\n            describe(\"given the contextual serializer attempts to begin a structure that does not match the input\") {\n                context(\"given the input is a map\") {\n                    val input = \"a: b\"\n\n                    mapOf(\n                        PrimitiveKind.STRING to \"a string\",\n                        StructureKind.LIST to \"a list\",\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $description\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Expected $description, but got a map\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 1\n                                    it.path shouldBe YamlPath.root\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given the input is a list\") {\n                    val input = \"- a\"\n\n                    mapOf(\n                        StructureKind.OBJECT to \"an object\",\n                        StructureKind.CLASS to \"an object\",\n                        StructureKind.MAP to \"a map\",\n                        PrimitiveKind.STRING to \"a string\",\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $kind\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Expected $description, but got a list\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 1\n                                    it.path shouldBe YamlPath.root\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given the input is a scalar\") {\n                    val input = \"2\"\n\n                    mapOf(\n                        StructureKind.OBJECT to \"an object\",\n                        StructureKind.CLASS to \"an object\",\n                        StructureKind.MAP to \"a map\",\n                        StructureKind.LIST to \"a list\",\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $kind\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Expected $description, but got a scalar value\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 1\n                                    it.path shouldBe YamlPath.root\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            describe(\"decoding from a YamlNode\") {\n                val input = \"\"\"\n                    keyA:\n                        host: A\n                    keyB:\n                        host: B\n                \"\"\".trimIndent()\n\n                val mapAsListSerializer = object : KSerializer<List<Database>> {\n                    override val descriptor = buildSerialDescriptor(\"DatabaseList\", StructureKind.MAP) {\n                    }\n\n                    override fun deserialize(decoder: Decoder): List<Database> {\n                        check(decoder is YamlInput)\n                        return decoder.node.yamlMap.entries.map { (_, value) ->\n                            decoder.yaml.decodeFromYamlNode(Database.serializer(), value)\n                        }\n                    }\n\n                    override fun serialize(encoder: Encoder, value: List<Database>) = throw UnsupportedOperationException()\n                }\n\n                val parser = Yaml.default\n                val result = parser.decodeFromString(mapAsListSerializer, input)\n\n                it(\"decodes the map value as a list using the YamlNode\") {\n                    result shouldBe listOf(Database(\"A\"), Database(\"B\"))\n                }\n            }\n\n            describe(\"decoding from a YamlNode at a non-root node\") {\n                val input = \"\"\"\n                    databaseListing:\n                        keyA:\n                            host: A\n                        keyB:\n                            host: B\n                \"\"\".trimIndent()\n\n                val parser = Yaml.default\n                val result = parser.decodeFromString(ServerConfig.serializer(), input)\n\n                it(\"decodes the map value as a list using the YamlNode\") {\n                    result shouldBe ServerConfig(DatabaseListing(listOf(Database(\"A\"), Database(\"B\"))))\n                }\n            }\n        }\n    }\n})\n\n@Serializable\nprivate data class ComplexStructure(\n    val string: String,\n    val byte: Byte,\n    val short: Short,\n    val int: Int,\n    val long: Long,\n    val float: Float,\n    val double: Double,\n    val enum: TestEnum,\n    val boolean: Boolean,\n    val char: Char,\n    val nullable: String? = null,\n)\n\n@Serializable\nprivate data class StructureWithLocationThrowingSerializer(\n    @Suppress(\"SERIALIZER_TYPE_INCOMPATIBLE\")\n    @Serializable(with = LocationThrowingSerializer::class)\n    val value: CustomSerializedValue,\n)\n\nprivate data class CustomSerializedValue(val thing: String)\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nprivate object LocationThrowingSerializer : KSerializer<Any> {\n    override val descriptor = buildSerialDescriptor(LocationThrowingSerializer::class.qualifiedName!!, SerialKind.CONTEXTUAL)\n\n    override fun deserialize(decoder: Decoder): Any {\n        val location = (decoder as YamlInput).getCurrentLocation()\n        val path = decoder.getCurrentPath()\n\n        throw LocationInformationException(\"Serializer called with location (${location.line}, ${location.column}) and path: ${path.toHumanReadableString()}\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Any) = throw UnsupportedOperationException()\n}\n\nprivate object LocationThrowingMapSerializer : KSerializer<Any> {\n    override val descriptor: SerialDescriptor = MapSerializer(String.serializer(), String.serializer()).descriptor\n\n    override fun deserialize(decoder: Decoder): Any {\n        val location = (decoder as YamlInput).getCurrentLocation()\n        val path = decoder.getCurrentPath()\n\n        throw LocationInformationException(\"Serializer called with location (${location.line}, ${location.column}) and path: ${path.toHumanReadableString()}\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Any) = throw UnsupportedOperationException()\n}\n\nprivate class LocationInformationException(message: String) : RuntimeException(message)\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nobject ContextualSerializer : KSerializer<String> {\n    override val descriptor = buildSerialDescriptor(\"ContextualSerializer\", SerialKind.CONTEXTUAL) {\n        element(\"string\", PrimitiveSerialDescriptor(\"value\", PrimitiveKind.STRING))\n        element(\"object\", buildSerialDescriptor(\"thing\", StructureKind.OBJECT))\n    }\n\n    override fun deserialize(decoder: Decoder): String {\n        val input = decoder.beginStructure(descriptor) as YamlInput\n        val type = input.node::class.simpleName!!\n        input.endStructure(descriptor)\n\n        return type.removePrefix(\"Yaml\").lowercase()\n    }\n\n    override fun serialize(encoder: Encoder, value: String): Unit = throw UnsupportedOperationException()\n}\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nclass ContextualSerializerThatAttemptsToDeserializeIncorrectType(private val kind: SerialKind) : KSerializer<String> {\n    private val innerDescriptor = if (kind == StructureKind.CLASS) buildClassSerialDescriptor(\"thing\") else buildSerialDescriptor(\"thing\", kind)\n\n    override val descriptor = buildSerialDescriptor(\"ContextualSerializer\", SerialKind.CONTEXTUAL) {\n        element(\"string\", PrimitiveSerialDescriptor(\"value\", PrimitiveKind.STRING))\n        element(\"object\", innerDescriptor)\n    }\n\n    override fun deserialize(decoder: Decoder): String {\n        val input = decoder.beginStructure(descriptor) as YamlInput\n\n        input.beginStructure(innerDescriptor)\n\n        return \"Should never get to this point\"\n    }\n\n    override fun serialize(encoder: Encoder, value: String): Unit = throw UnsupportedOperationException()\n}\n\n// FIXME: ideally these would just be inline in the test cases that need them, but due to\n// https://github.com/Kotlin/kotlinx.serialization/issues/1427, this is no longer possible with\n// kotlinx.serialization 1.2 and above.\n// See also https://github.com/Kotlin/kotlinx.serialization/issues/1468.\n\n@Serializable\nprivate data class NullableNestedObject(val firstPerson: SimpleStructure?)\n\n@Serializable\ndata class NullableNestedList(val members: List<String>?)\n\n@Serializable\nprivate data class Database(val host: String)\n\n@Serializable(with = DecodingFromYamlNodeSerializer::class)\nprivate data class DatabaseListing(val databases: List<Database>)\n\n@Serializable\nprivate data class ServerConfig(val databaseListing: DatabaseListing)\n\nprivate data class Inner(val name: String)\n\n@Serializable\nprivate data class Container(@Contextual val inner: Inner)\n\n@Serializable\nprivate data class ObjectWithNestedContextualSerializer(@Serializable(with = ContextualSerializer::class) val thing: String)\n\n@Serializable\n@JvmInline\nvalue class StringValue(val value: String)\n\nprivate object DecodingFromYamlNodeSerializer : KSerializer<DatabaseListing> {\n    override val descriptor: SerialDescriptor = buildSerialDescriptor(\"DecodingFromYamlNodeSerializer\", StructureKind.MAP)\n\n    override fun deserialize(decoder: Decoder): DatabaseListing {\n        check(decoder is YamlInput)\n\n        val currentMap = decoder.node.yamlMap.get<YamlMap>(\"databaseListing\")\n        checkNotNull(currentMap)\n\n        val list = currentMap.entries.map { (_, value) ->\n            decoder.yaml.decodeFromYamlNode(Database.serializer(), value)\n        }\n\n        return DatabaseListing(list)\n    }\n\n    override fun serialize(encoder: Encoder, value: DatabaseListing) = throw UnsupportedOperationException()\n}\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\nimport kotlinx.serialization.DeserializationStrategy\nimport kotlinx.serialization.SerializationStrategy\nimport kotlinx.serialization.StringFormat\nimport kotlinx.serialization.modules.EmptySerializersModule\nimport kotlinx.serialization.modules.SerializersModule\nimport kotlinx.serialization.serializer\nimport org.snakeyaml.engine.v2.api.StreamDataWriter\nimport org.snakeyaml.engine.v2.api.YamlOutputStreamWriter\nimport java.io.IOException\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.io.OutputStream\nimport java.io.Reader\nimport java.io.StringReader\nimport java.io.StringWriter\nimport java.nio.charset.Charset\n\npublic actual class Yaml(\n    override val serializersModule: SerializersModule = EmptySerializersModule(),\n    public actual val configuration: YamlConfiguration = YamlConfiguration(),\n) : StringFormat {\n    override fun <T> decodeFromString(deserializer: DeserializationStrategy<T>, string: String): T {\n        return decodeFromReader(deserializer, StringReader(string))\n    }\n\n    public fun <T> decodeFromStream(deserializer: DeserializationStrategy<T>, source: InputStream, charset: Charset = Charsets.UTF_8): T {\n        return decodeFromReader(deserializer, InputStreamReader(source, charset))\n    }\n\n    private fun <T> decodeFromReader(deserializer: DeserializationStrategy<T>, source: Reader): T {\n        val rootNode = parseToYamlNodeFromReader(source)\n\n        val input = YamlInput.createFor(rootNode, this, serializersModule, configuration, deserializer.descriptor)\n        return input.decodeSerializableValue(deserializer)\n    }\n\n    public fun parseToYamlNode(string: String): YamlNode = parseToYamlNodeFromReader(StringReader(string))\n\n    public fun parseToYamlNode(source: InputStream): YamlNode = parseToYamlNodeFromReader(InputStreamReader(source))\n\n    private fun parseToYamlNodeFromReader(source: Reader): YamlNode {\n        val parser = YamlParser(source)\n        val reader = YamlNodeReader(parser, configuration.extensionDefinitionPrefix)\n        val node = reader.read()\n        parser.ensureEndOfStreamReached()\n        return node\n    }\n\n    public actual fun <T> decodeFromYamlNode(deserializer: DeserializationStrategy<T>, node: YamlNode): T {\n        val input = YamlInput.createFor(node, this, serializersModule, configuration, deserializer.descriptor)\n        return input.decodeSerializableValue(deserializer)\n    }\n\n    override fun <T> encodeToString(serializer: SerializationStrategy<T>, value: T): String {\n        val writer = object : StringWriter(), StreamDataWriter {\n            override fun flush() { }\n        }\n\n        encodeToStreamDataWriter(serializer, value, writer)\n\n        return writer.toString().trimEnd()\n    }\n\n    public fun <T> encodeToStream(serializer: SerializationStrategy<T>, value: T, stream: OutputStream, charset: Charset = Charsets.UTF_8) {\n        val writer = object : YamlOutputStreamWriter(stream, charset) {\n            override fun processIOException(e: IOException?) {\n                if (e != null) {\n                    throw e\n                }\n            }\n        }\n\n        encodeToStreamDataWriter(serializer, value, writer)\n    }\n\n    private fun <T> encodeToStreamDataWriter(serializer: SerializationStrategy<T>, value: T, writer: StreamDataWriter) {\n        YamlOutput(writer, serializersModule, configuration).use { output ->\n            output.encodeSerializableValue(serializer, value)\n        }\n    }\n\n    public actual companion object {\n        public actual val default: Yaml = Yaml()\n    }\n}\n\n/**\n * Decodes and deserializes from the given [stream] to the value of type [T] using the\n * deserializer retrieved from the reified type parameter.\n */\npublic inline fun <reified T> Yaml.decodeFromStream(stream: InputStream): T =\n    decodeFromStream(serializersModule.serializer(), stream)\n\n/**\n * Serializes and encodes the given [value] to the given [stream] using the serializer\n * retrieved from the reified type parameter.\n */\npublic inline fun <reified T> Yaml.encodeToStream(value: T, stream: OutputStream) {\n    encodeToStream(serializersModule.serializer(), value, stream)\n}\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\nimport org.snakeyaml.engine.v2.common.Anchor\nimport org.snakeyaml.engine.v2.events.AliasEvent\nimport org.snakeyaml.engine.v2.events.Event\nimport org.snakeyaml.engine.v2.events.MappingStartEvent\nimport org.snakeyaml.engine.v2.events.NodeEvent\nimport org.snakeyaml.engine.v2.events.ScalarEvent\nimport org.snakeyaml.engine.v2.events.SequenceStartEvent\nimport java.util.Optional\n\ninternal actual class YamlNodeReader(\n    private val parser: YamlParser,\n    private val extensionDefinitionPrefix: String? = null,\n) {\n    private val aliases = mutableMapOf<Anchor, YamlNode>()\n\n    actual fun read(): YamlNode = readNode(YamlPath.root)\n\n    private fun readNode(path: YamlPath): YamlNode = readNodeAndAnchor(path).first\n\n    private fun readNodeAndAnchor(path: YamlPath): Pair<YamlNode, Anchor?> {\n        val event = parser.consumeEvent(path)\n        val node = readFromEvent(event, path)\n\n        if (event is NodeEvent) {\n            event.anchor.ifPresent {\n                aliases.put(it, node.withPath(YamlPath.forAliasDefinition(it.value, event.location)))\n            }\n\n            return node to event.anchor.orElse(null)\n        }\n\n        return node to null\n    }\n\n    private fun readFromEvent(event: Event, path: YamlPath): YamlNode = when (event) {\n        is ScalarEvent -> readScalarOrNull(event, path).maybeToTaggedNode(event.tag)\n        is SequenceStartEvent -> readSequence(path).maybeToTaggedNode(event.tag)\n        is MappingStartEvent -> readMapping(path).maybeToTaggedNode(event.tag)\n        is AliasEvent -> readAlias(event, path)\n        else -> throw MalformedYamlException(\"Unexpected ${event.eventId}\", path.withError(event.location))\n    }\n\n    private fun readScalarOrNull(event: ScalarEvent, path: YamlPath): YamlNode {\n        if ((event.value == \"null\" || event.value == \"\" || event.value == \"~\") && event.isPlain) {\n            return YamlNull(path)\n        } else {\n            return YamlScalar(event.value, path)\n        }\n    }\n\n    private fun readSequence(path: YamlPath): YamlList {\n        val items = mutableListOf<YamlNode>()\n\n        while (true) {\n            val event = parser.peekEvent(path)\n\n            when (event.eventId) {\n                Event.ID.SequenceEnd -> {\n                    parser.consumeEventOfType(Event.ID.SequenceEnd, path)\n                    return YamlList(items, path)\n                }\n\n                else -> items += readNode(path.withListEntry(items.size, event.location))\n            }\n        }\n    }\n\n    private fun readMapping(path: YamlPath): YamlMap {\n        val items = mutableMapOf<YamlScalar, YamlNode>()\n\n        while (true) {\n            val event = parser.peekEvent(path)\n\n            when (event.eventId) {\n                Event.ID.MappingEnd -> {\n                    parser.consumeEventOfType(Event.ID.MappingEnd, path)\n                    return YamlMap(doMerges(items), path)\n                }\n\n                else -> {\n                    val keyLocation = parser.peekEvent(path).location\n                    val key = readMapKey(path)\n                    val keyNode = YamlScalar(key, path.withMapElementKey(key, keyLocation))\n\n                    val valueLocation = parser.peekEvent(keyNode.path).location\n                    val valuePath = if (isMerge(keyNode)) path.withMerge(valueLocation) else keyNode.path.withMapElementValue(valueLocation)\n                    val (value, anchor) = readNodeAndAnchor(valuePath)\n\n                    if (path == YamlPath.root && extensionDefinitionPrefix != null && key.startsWith(extensionDefinitionPrefix)) {\n                        if (anchor == null) {\n                            throw NoAnchorForExtensionException(key, extensionDefinitionPrefix, path.withError(event.location))\n                        }\n                    } else {\n                        items += (keyNode to value)\n                    }\n                }\n            }\n        }\n    }\n\n    private fun readMapKey(path: YamlPath): String {\n        val event = parser.peekEvent(path)\n\n        when (event.eventId) {\n            Event.ID.Scalar -> {\n                parser.consumeEventOfType(Event.ID.Scalar, path)\n                val scalarEvent = event as ScalarEvent\n                val isNullKey = (scalarEvent.value == \"null\" || scalarEvent.value == \"~\") && scalarEvent.isPlain\n\n                if (scalarEvent.tag.isPresent || isNullKey) {\n                    throw nonScalarMapKeyException(path, event)\n                }\n\n                return scalarEvent.value\n            }\n            else -> throw nonScalarMapKeyException(path, event)\n        }\n    }\n\n    private fun nonScalarMapKeyException(path: YamlPath, event: Event) = MalformedYamlException(\"Property name must not be a list, map, null or tagged value. (To use 'null' as a property name, enclose it in quotes.)\", path.withError(event.location))\n\n    private fun YamlNode.maybeToTaggedNode(tag: Optional<String>): YamlNode =\n        tag.map<YamlNode> { YamlTaggedNode(it, this) }.orElse(this)\n\n    private fun doMerges(items: Map<YamlScalar, YamlNode>): Map<YamlScalar, YamlNode> {\n        val mergeEntries = items.entries.filter { (key, _) -> isMerge(key) }\n\n        when (mergeEntries.count()) {\n            0 -> return items\n            1 -> when (val mappingsToMerge = mergeEntries.single().value) {\n                is YamlList -> return doMerges(items, mappingsToMerge.items)\n                else -> return doMerges(items, listOf(mappingsToMerge))\n            }\n            else -> throw MalformedYamlException(\"Cannot perform multiple '<<' merges into a map. Instead, combine all merges into a single '<<' entry.\", mergeEntries.second().key.path)\n        }\n    }\n\n    private fun isMerge(key: YamlNode): Boolean = key is YamlScalar && key.content == \"<<\"\n\n    private fun doMerges(original: Map<YamlScalar, YamlNode>, others: List<YamlNode>): Map<YamlScalar, YamlNode> {\n        val merged = mutableMapOf<YamlScalar, YamlNode>()\n\n        original\n            .filterNot { (key, _) -> isMerge(key) }\n            .forEach { (key, value) -> merged.put(key, value) }\n\n        others\n            .forEach { other ->\n                when (other) {\n                    is YamlNull -> throw MalformedYamlException(\"Cannot merge a null value into a map.\", other.path)\n                    is YamlScalar -> throw MalformedYamlException(\"Cannot merge a scalar value into a map.\", other.path)\n                    is YamlList -> throw MalformedYamlException(\"Cannot merge a list value into a map.\", other.path)\n                    is YamlTaggedNode -> throw MalformedYamlException(\"Cannot merge a tagged value into a map.\", other.path)\n                    is YamlMap ->\n                        other.entries.forEach { (key, value) ->\n                            val existingEntry = merged.entries.singleOrNull { it.key.equivalentContentTo(key) }\n\n                            if (existingEntry == null) {\n                                merged.put(key, value)\n                            }\n                        }\n                }\n            }\n\n        return merged\n    }\n\n    private fun readAlias(event: AliasEvent, path: YamlPath): YamlNode {\n        val anchor = event.anchor.get()\n\n        val resolvedNode = aliases.getOrElse(anchor) {\n            throw UnknownAnchorException(anchor.value, path.withError(event.location))\n        }\n\n        return resolvedNode.withPath(path.withAliasReference(anchor.value, event.location).withAliasDefinition(anchor.value, resolvedNode.location))\n    }\n\n    private fun <T> Iterable<T>.second(): T = this.drop(1).first()\n\n    private val Event.location: Location\n        get() = Location(startMark.get().line + 1, startMark.get().column + 1)\n}\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n@file:Suppress(\"MoveLambdaOutsideParentheses\")\n\npackage com.charleskorn.kaml\n\nimport io.kotest.assertions.asClue\nimport io.kotest.assertions.throwables.shouldNotThrowAny\nimport io.kotest.assertions.throwables.shouldThrow\nimport io.kotest.core.spec.style.DescribeSpec\nimport io.kotest.matchers.shouldBe\n\nclass YamlNodeReaderTest : DescribeSpec({\n    describe(\"a YAML node reader\") {\n        mapOf(\n            \"hello\" to \"hello\",\n            \"12\" to \"12\",\n            \"\"\"\"hello\"\"\"\" to \"hello\",\n            \"'hello'\" to \"hello\",\n            \"'he''llo'\" to \"he'llo\",\n            \"\"\"\"hello\\\"\"\"\"\" to \"\"\"hello\"\"\"\",\n            \"\"\"\"\\\"hello\"\"\"\" to \"\"\"\"hello\"\"\",\n            \"\"\"\"he\\\"llo\"\"\"\" to \"\"\"he\"llo\"\"\",\n            \"\"\"\"he\\\"\\\"llo\"\"\"\" to \"\"\"he\"\"llo\"\"\",\n            \"\"\"\"hello\\n\"\"\"\" to \"hello\\n\",\n            // Sample from http://yaml.org/spec/1.2/spec.html#escaping/in%20double-quoted%20scalars/\n            \"\"\"\"Fun with \\\\ \\\" \\a \\b \\e \\f \\n \\r \\t \\v \\0 \\  \\_ \\N \\L \\P \\x41 \\u0041 \\U00000041\"\"\"\" to \"Fun with \\u005C \\u0022 \\u0007 \\u0008 \\u001B \\u000C \\u000A \\u000D \\u0009 \\u000B \\u0000 \\u0020 \\u00A0 \\u0085 \\u2028 \\u2029 A A A\",\n            \"''\" to \"\",\n            \"\"\"\"\"\"\"\" to \"\",\n            \"'null'\" to \"null\",\n            \"\"\"\"null\"\"\"\" to \"null\",\n            \"'~'\" to \"~\",\n            \"\"\"\"~\"\"\"\" to \"~\",\n        ).forEach { (input, expectedResult) ->\n            context(\"given the string '$input'\") {\n                describe(\"parsing that input\") {\n                    val parser = YamlParser(input)\n                    val result = YamlNodeReader(parser).read()\n\n                    it(\"returns the expected scalar value\") {\n                        result shouldBe YamlScalar(expectedResult, YamlPath.root)\n                    }\n                }\n            }\n        }\n\n        // https://yaml.org/spec/1.2/spec.html#id2793979 is useful reference here, as is\n        // https://yaml-multiline.info/\n        mapOf(\n            \"\"\"\n                |thing: |\n                |  line 1\n                |  line 2\n                |\n            \"\"\".trimMargin() to \"line 1\\nline 2\\n\",\n            \"\"\"\n                |thing: >\n                |  some\n                |  text\n                |\n            \"\"\".trimMargin() to \"some text\\n\",\n\n            // Preserve consecutive blank lines when literal\n            \"\"\"\n                |thing: |\n                |  some\n                |\n                |  text\n                |\n            \"\"\".trimMargin() to \"some\\n\\ntext\\n\",\n\n            // Don't preserve consecutive blank lines when folded\n            \"\"\"\n                |thing: >\n                |  some\n                |\n                |  text\n                |\n            \"\"\".trimMargin() to \"some\\ntext\\n\",\n\n            // No chomping indicator - default behaviour is to clip, so retain trailing new line but not blank lines\n            \"\"\"\n                |thing: |\n                |  line 1\n                |  line 2\n                |\n                |\n            \"\"\".trimMargin() to \"line 1\\nline 2\\n\",\n            \"\"\"\n                |thing: >\n                |  some\n                |  text\n                |\n                |\n            \"\"\".trimMargin() to \"some text\\n\",\n\n            // Indentation indicator\n            \"\"\"\n                |thing: |1\n                |  line 1\n                |  line 2\n                |\n            \"\"\".trimMargin() to \" line 1\\n line 2\\n\",\n            \"\"\"\n                |thing: >1\n                |  some\n                |  text\n                | here\n                | there\n                |\n            \"\"\".trimMargin() to \" some\\n text\\nhere there\\n\",\n\n            // 'Strip' chomping indicator - remove all trailing new lines\n            \"\"\"\n                |thing: |-\n                |  line 1\n                |  line 2\n                |\n            \"\"\".trimMargin() to \"line 1\\nline 2\",\n            \"\"\"\n                |thing: >-\n                |  some\n                |  text\n                |\n            \"\"\".trimMargin() to \"some text\",\n\n            // 'Keep' chomping indicator - keep all trailing new lines\n            \"\"\"\n                |thing: |+\n                |  line 1\n                |  line 2\n                |\n                |\n            \"\"\".trimMargin() to \"line 1\\nline 2\\n\\n\",\n            \"\"\"\n                |thing: >+\n                |  some\n                |  text\n                |\n                |\n            \"\"\".trimMargin() to \"some text\\n\\n\",\n\n            // Chomping indicator with indentation indicator\n            \"\"\"\n                |thing: |-1\n                |  line 1\n                |  line 2\n                |\n            \"\"\".trimMargin() to \" line 1\\n line 2\",\n            \"\"\"\n                |thing: >-1\n                |  some\n                |  text\n                | here\n                | there\n                |\n            \"\"\".trimMargin() to \" some\\n text\\nhere there\",\n            \"\"\"\n                |thing: |+1\n                |  line 1\n                |  line 2\n                |\n                |\n            \"\"\".trimMargin() to \" line 1\\n line 2\\n\\n\",\n            \"\"\"\n                |thing: >+1\n                |  some\n                |  text\n                | here\n                | there\n                |\n                |\n            \"\"\".trimMargin() to \" some\\n text\\nhere there\\n\\n\",\n        ).forEach { (input, text) ->\n            context(\"given the block scalar '${input.replace(\"\\n\", \"\\\\n\")}'\") {\n                describe(\"parsing that input\") {\n                    val parser = YamlParser(input)\n                    val result = YamlNodeReader(parser).read()\n\n                    val keyPath = YamlPath.root.withMapElementKey(\"thing\", Location(1, 1))\n                    val valuePath = keyPath.withMapElementValue(Location(1, 8))\n\n                    it(\"returns the expected multi-line text value\") {\n                        result shouldBe\n                            YamlMap(\n                                mapOf(\n                                    YamlScalar(\"thing\", keyPath) to YamlScalar(text, valuePath),\n                                ),\n                                YamlPath.root,\n                            )\n                    }\n                }\n            }\n        }\n\n        mapOf(\n            \"given a double-quoted string without a trailing double quote\" to \"\"\"\"hello\"\"\",\n            \"given a single-quoted string without a trailing single quote\" to \"'hello\",\n        ).forEach { (description, input) ->\n            context(description) {\n                describe(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<MalformedYamlException> {\n                            val parser = YamlParser(input)\n                            YamlNodeReader(parser).read()\n                        }\n\n                        exception.asClue {\n                            it.message shouldBe\n                                \"\"\"\n                                        while scanning a quoted scalar\n                                         at line 1, column 1:\n                                            $input\n                                            ^\n                                        found unexpected end of stream\n                                         at line 1, column 7:\n                                            $input\n                                                  ^\n                                \"\"\".trimIndent()\n\n                            it.line shouldBe 1\n                            it.column shouldBe 7\n                            it.path shouldBe YamlPath.root.withError(Location(1, 7))\n                        }\n                    }\n                }\n            }\n        }\n\n        context(\"given a flow-style list without a trailing closing bracket\") {\n            val input = \"[thing\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                    while parsing a flow sequence\n                                     at line 1, column 1:\n                                        [thing\n                                        ^\n                                    expected ',' or ']', but got <stream end>\n                                     at line 1, column 7:\n                                        [thing\n                                              ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 1\n                        it.column shouldBe 7\n                        it.path shouldBe YamlPath.root.withError(Location(1, 7))\n                    }\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings\") {\n            val input = \"\"\"\n                - thing1\n                - thing2\n                - \"thing3\"\n                - 'thing4'\n                - \"thing\\\"5\"\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(0, Location(1, 3))),\n                                YamlScalar(\"thing2\", YamlPath.root.withListEntry(1, Location(2, 3))),\n                                YamlScalar(\"thing3\", YamlPath.root.withListEntry(2, Location(3, 3))),\n                                YamlScalar(\"thing4\", YamlPath.root.withListEntry(3, Location(4, 3))),\n                                YamlScalar(\"thing\\\"5\", YamlPath.root.withListEntry(4, Location(5, 3))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings with an alias and anchor present\") {\n            val input = \"\"\"\n                - &thing thing1\n                - thing2\n                - *thing\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(0, Location(1, 3))),\n                                YamlScalar(\"thing2\", YamlPath.root.withListEntry(1, Location(2, 3))),\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(2, Location(3, 3)).withAliasReference(\"thing\", Location(3, 3)).withAliasDefinition(\"thing\", Location(1, 3))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings with an alias that is redefined\") {\n            val input = \"\"\"\n                - &thing thing1\n                - thing2\n                - *thing\n                - &thing thing3\n                - *thing\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list, using the most-recently defined value each time the alias is referenced\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(0, Location(1, 3))),\n                                YamlScalar(\"thing2\", YamlPath.root.withListEntry(1, Location(2, 3))),\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(2, Location(3, 3)).withAliasReference(\"thing\", Location(3, 3)).withAliasDefinition(\"thing\", Location(1, 3))),\n                                YamlScalar(\"thing3\", YamlPath.root.withListEntry(3, Location(4, 3))),\n                                YamlScalar(\"thing3\", YamlPath.root.withListEntry(4, Location(5, 3)).withAliasReference(\"thing\", Location(5, 3)).withAliasDefinition(\"thing\", Location(4, 3))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings with a reference to a non-existent anchor\") {\n            val input = \"\"\"\n                - thing2\n                - *thing\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnknownAnchorException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unknown anchor 'thing'.\"\n                        it.line shouldBe 2\n                        it.column shouldBe 3\n                        it.path shouldBe YamlPath.root.withListEntry(1, Location(2, 3)).withError(Location(2, 3))\n                    }\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings in flow style\") {\n            val input = \"\"\"[thing1, thing2, \"thing3\", 'thing4', \"thing\\\"5\"]\"\"\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(0, Location(1, 2))),\n                                YamlScalar(\"thing2\", YamlPath.root.withListEntry(1, Location(1, 10))),\n                                YamlScalar(\"thing3\", YamlPath.root.withListEntry(2, Location(1, 18))),\n                                YamlScalar(\"thing4\", YamlPath.root.withListEntry(3, Location(1, 28))),\n                                YamlScalar(\"thing\\\"5\", YamlPath.root.withListEntry(4, Location(1, 38))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given some input representing an empty list of strings in flow style\") {\n            val input = \"[]\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns an empty list\") {\n                    result shouldBe YamlList(emptyList(), YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a nested list given with both the inner and outer lists given in flow style with no elements\") {\n            val input = \"[[], []]\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlList(emptyList(), YamlPath.root.withListEntry(0, Location(1, 2))),\n                                YamlList(emptyList(), YamlPath.root.withListEntry(1, Location(1, 6))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a nested list given with the outer list in non-flow style and the inner lists in flow style with no elements\") {\n            val input = \"\"\"\n                - []\n                - []\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlList(emptyList(), YamlPath.root.withListEntry(0, Location(1, 3))),\n                                YamlList(emptyList(), YamlPath.root.withListEntry(1, Location(2, 3))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a nested list given with the outer list in non-flow style and the inner lists in both non-flow and flow styles with some elements\") {\n            val input = \"\"\"\n                - [thing1, thing2]\n                -\n                    - thing3\n                    - thing4\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                val firstListPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val secondListPath = YamlPath.root.withListEntry(1, Location(3, 5))\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlList(\n                                    listOf(\n                                        YamlScalar(\"thing1\", firstListPath.withListEntry(0, Location(1, 4))),\n                                        YamlScalar(\"thing2\", firstListPath.withListEntry(1, Location(1, 12))),\n                                    ),\n                                    firstListPath,\n                                ),\n                                YamlList(\n                                    listOf(\n                                        YamlScalar(\"thing3\", secondListPath.withListEntry(0, Location(3, 7))),\n                                        YamlScalar(\"thing4\", secondListPath.withListEntry(1, Location(4, 7))),\n                                    ),\n                                    secondListPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        listOf(\n            \"-\",\n            \"- \",\n        ).forEach { input ->\n            context(\"given a list with a single null entry in the format '$input'\") {\n                describe(\"parsing that input\") {\n                    val parser = YamlParser(input)\n                    val result = YamlNodeReader(parser).read()\n\n                    it(\"returns a list with a single null entry\") {\n                        result shouldBe\n                            YamlList(\n                                listOf(\n                                    YamlNull(YamlPath.root.withListEntry(0, Location(1, 2))),\n                                ),\n                                YamlPath.root,\n                            )\n                    }\n                }\n            }\n        }\n\n        context(\"given the string 'null'\") {\n            val input = \"null\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns a single null entry\") {\n                    result shouldBe YamlNull(YamlPath.root)\n                }\n            }\n        }\n\n        // See https://github.com/charleskorn/kaml/issues/149.\n        context(\"given the string '~'\") {\n            val input = \"~\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns a single null entry\") {\n                    result shouldBe YamlNull(YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a single key-value pair\") {\n            val input = \"key: value\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val keyPath = YamlPath.root.withMapElementKey(\"key\", Location(1, 1))\n                val valuePath = keyPath.withMapElementValue(Location(1, 6))\n\n                it(\"returns a map with a single key-value pair\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key\", keyPath) to YamlScalar(\"value\", valuePath),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a single key-value pair with a null value\") {\n            val input = \"key:\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val keyPath = YamlPath.root.withMapElementKey(\"key\", Location(1, 1))\n                val valuePath = keyPath.withMapElementValue(Location(1, 5))\n\n                it(\"returns a map with a single key-value pair with a null value\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key\", keyPath) to YamlNull(valuePath),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with two key-value pairs\") {\n            val input = \"\"\"\n                key1: value1\n                key2: value2\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 1))\n                val value1Path = key1Path.withMapElementValue(Location(1, 7))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(2, 1))\n                val value2Path = key2Path.withMapElementValue(Location(2, 7))\n\n                it(\"returns a map with two key-value pairs\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", value1Path),\n                                YamlScalar(\"key2\", key2Path) to YamlScalar(\"value2\", value2Path),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with two key-value pairs, one of which has a null value\") {\n            val input = \"\"\"\n                key1: value1\n                key2:\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 1))\n                val value1Path = key1Path.withMapElementValue(Location(1, 7))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(2, 1))\n                val value2Path = key2Path.withMapElementValue(Location(2, 6))\n\n                it(\"returns a map with two key-value pairs\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", value1Path),\n                                YamlScalar(\"key2\", key2Path) to YamlNull(value2Path),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with two key-value pairs, one of which has a reference to the other\") {\n            val input = \"\"\"\n                key1: &value value1\n                key2: *value\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 1))\n                val value1Path = key1Path.withMapElementValue(Location(1, 7))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(2, 1))\n                val value2Path = key2Path.withMapElementValue(Location(2, 7)).withAliasReference(\"value\", Location(2, 7)).withAliasDefinition(\"value\", Location(1, 7))\n\n                it(\"returns a map with two key-value pairs\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", value1Path),\n                                YamlScalar(\"key2\", key2Path) to YamlScalar(\"value1\", value2Path),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with nested values\") {\n            val input = \"\"\"\n                key1: value1\n                key2: value2\n                key3:\n                  - listitem1\n                  - listitem2\n                  - thing: value\n                key4: [something]\n                key5:\n                  inner: othervalue\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 1))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(2, 1))\n                val key3Path = YamlPath.root.withMapElementKey(\"key3\", Location(3, 1))\n                val value3Path = key3Path.withMapElementValue(Location(4, 3))\n                val thingPath = value3Path.withListEntry(2, Location(6, 5)).withMapElementKey(\"thing\", Location(6, 5))\n                val key4Path = YamlPath.root.withMapElementKey(\"key4\", Location(7, 1))\n                val value4Path = key4Path.withMapElementValue(Location(7, 7))\n                val key5Path = YamlPath.root.withMapElementKey(\"key5\", Location(8, 1))\n                val value5Path = key5Path.withMapElementValue(Location(9, 3))\n                val innerPath = value5Path.withMapElementKey(\"inner\", Location(9, 3))\n\n                it(\"returns a map with all expected key-value pairs\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", key1Path.withMapElementValue(Location(1, 7))),\n                                YamlScalar(\"key2\", key2Path) to YamlScalar(\"value2\", key2Path.withMapElementValue(Location(2, 7))),\n                                YamlScalar(\"key3\", key3Path) to YamlList(\n                                    listOf(\n                                        YamlScalar(\"listitem1\", value3Path.withListEntry(0, Location(4, 5))),\n                                        YamlScalar(\"listitem2\", value3Path.withListEntry(1, Location(5, 5))),\n                                        YamlMap(\n                                            mapOf(\n                                                YamlScalar(\"thing\", thingPath) to YamlScalar(\"value\", thingPath.withMapElementValue(Location(6, 12))),\n                                            ),\n                                            value3Path.withListEntry(2, Location(6, 5)),\n                                        ),\n                                    ),\n                                    value3Path,\n                                ),\n                                YamlScalar(\"key4\", key4Path) to YamlList(\n                                    listOf(\n                                        YamlScalar(\"something\", value4Path.withListEntry(0, Location(7, 8))),\n                                    ),\n                                    value4Path,\n                                ),\n                                YamlScalar(\"key5\", key5Path) to YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"inner\", innerPath) to YamlScalar(\"othervalue\", innerPath.withMapElementValue(Location(9, 10))),\n                                    ),\n                                    value5Path,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        mapOf(\n            \"null\" to \"null value\",\n            \"~\" to \"shorthand null value\",\n            \"[]\" to \"list\",\n            \"{}\" to \"map\",\n            \"!thing hello\" to \"tagged value\",\n        ).forEach { (value, description) ->\n            context(\"given a map with a $description for a key\") {\n                val input = \"\"\"\n                    key: value\n                    $value: something\n                \"\"\".trimIndent()\n\n                describe(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<MalformedYamlException> {\n                            val parser = YamlParser(input)\n                            YamlNodeReader(parser).read()\n                        }\n\n                        exception.asClue {\n                            it.message shouldBe \"Property name must not be a list, map, null or tagged value. (To use 'null' as a property name, enclose it in quotes.)\"\n                            it.line shouldBe 2\n                            it.column shouldBe 1\n                            it.path shouldBe YamlPath.root.withError(Location(2, 1))\n                        }\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with the the word 'null' as a key in quotes\") {\n            val input = \"\"\"\n                key: value\n                \"null\": something\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"does not throw an exception\") {\n                    shouldNotThrowAny {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with the the value '~' as a key in quotes\") {\n            val input = \"\"\"\n                key: value\n                \"~\": something\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"does not throw an exception\") {\n                    shouldNotThrowAny {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n                }\n            }\n        }\n\n        context(\"given a key-value pair with extra indentation\") {\n            val input = \"\"\"\n                thing:\n                  key1: value1\n                   key2: value2\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                mapping values are not allowed here (is the indentation level of this line or a line nearby incorrect?)\n                                 at line 3, column 8:\n                                       key2: value2\n                                           ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 3\n                        it.column shouldBe 8\n                        it.path shouldBe YamlPath.root.withMapElementKey(\"thing\", Location(1, 1)).withMapElementValue(Location(2, 3)).withError(Location(3, 8))\n                    }\n                }\n            }\n        }\n\n        context(\"given a key-value pair with not enough indentation\") {\n            val input = \"\"\"\n                thing:\n                  key1: value1\n                 key2: value2\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                while parsing a block mapping\n                                 at line 1, column 1:\n                                    thing:\n                                    ^\n                                expected <block end>, but found '<block mapping start>' (is the indentation level of this line or a line nearby incorrect?)\n                                 at line 3, column 2:\n                                     key2: value2\n                                     ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 3\n                        it.column shouldBe 2\n                        it.path shouldBe YamlPath.root.withError(Location(3, 2))\n                    }\n                }\n            }\n        }\n\n        context(\"given a list item in a map value with not enough indentation\") {\n            val input = \"\"\"\n                thing:\n                  - value1\n                 - value2\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                while parsing a block mapping\n                                 at line 1, column 1:\n                                    thing:\n                                    ^\n                                expected <block end>, but found '<block sequence start>' (is the indentation level of this line or a line nearby incorrect?)\n                                 at line 3, column 2:\n                                     - value2\n                                     ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 3\n                        it.column shouldBe 2\n                        it.path shouldBe YamlPath.root.withError(Location(3, 2))\n                    }\n                }\n            }\n        }\n\n        context(\"given an empty map in flow style\") {\n            val input = \"{}\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns an empty map\") {\n                    result shouldBe\n                        YamlMap(emptyMap(), YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a single opening curly brace\") {\n            val input = \"{\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                while parsing a flow node\n                                 at line 1, column 2:\n                                    {\n                                     ^\n                                expected the node content, but found '<stream end>'\n                                 at line 1, column 2:\n                                    {\n                                     ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 1\n                        it.column shouldBe 2\n                        it.path shouldBe YamlPath.root.withError(Location(1, 2))\n                    }\n                }\n            }\n        }\n\n        context(\"given a single key-value pair in flow style\") {\n            val input = \"{key: value}\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val keyPath = YamlPath.root.withMapElementKey(\"key\", Location(1, 2))\n                val valuePath = keyPath.withMapElementValue(Location(1, 7))\n\n                it(\"returns a map with a single key-value pair\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key\", keyPath) to YamlScalar(\"value\", valuePath),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a single key-value pair in flow style with a missing closing curly brace\") {\n            val input = \"{key: value\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                    while parsing a flow mapping\n                                     at line 1, column 1:\n                                        {key: value\n                                        ^\n                                    expected ',' or '}', but got <stream end>\n                                     at line 1, column 12:\n                                        {key: value\n                                                   ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 1\n                        it.column shouldBe 12\n                        it.path shouldBe YamlPath.root.withError(Location(1, 12))\n                    }\n                }\n            }\n        }\n\n        context(\"given two key-value pairs in flow style\") {\n            val input = \"{key1: value1, key2: value2}\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 2))\n                val value1Path = key1Path.withMapElementValue(Location(1, 8))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(1, 16))\n                val value2Path = key2Path.withMapElementValue(Location(1, 22))\n\n                it(\"returns a map with a single key-value pair\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", value1Path),\n                                YamlScalar(\"key2\", key2Path) to YamlScalar(\"value2\", value2Path),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a scalar with a preceding comment\") {\n            val input = \"\"\"\n                # this is a comment\n                somevalue\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns that scalar, ignoring the comment\") {\n                    // FIXME: ideally we'd return a path with the location (2, 1)\n                    result shouldBe YamlScalar(\"somevalue\", YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a scalar with a following comment\") {\n            val input = \"\"\"\n                somevalue\n                # this is a comment\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns that scalar, ignoring the comment\") {\n                    result shouldBe\n                        YamlScalar(\"somevalue\", YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a scalar with a multiple lines of preceding and following comments\") {\n            val input = \"\"\"\n                # this is a comment\n                # also a comment\n                somevalue\n                # still a comment\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns that scalar, ignoring the comments\") {\n                    // FIXME: ideally we'd return a path with the location (3, 1)\n                    result shouldBe YamlScalar(\"somevalue\", YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a scalar with a following inline comment\") {\n            val input = \"\"\"\n                somevalue # this is a comment\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns that scalar, ignoring the comment\") {\n                    result shouldBe\n                        YamlScalar(\"somevalue\", YamlPath.root)\n                }\n            }\n        }\n\n        mapOf(\n            \"!thing\" to YamlTaggedNode(\"!thing\", YamlNull(YamlPath.root)),\n            \"!!str 'some string'\" to YamlTaggedNode(\"tag:yaml.org,2002:str\", YamlScalar(\"some string\", YamlPath.root)),\n        ).forEach { (input, featureName) ->\n            context(\"given the input '$input' which contains a tagged node\") {\n                describe(\"parsing that input\") {\n                    it(\"returns the expected node\") {\n                        YamlNodeReader(YamlParser(input)).read() shouldBe featureName\n                    }\n                }\n            }\n        }\n\n        context(\"given an empty document\") {\n            val input = \"\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that the document is empty\") {\n                    val exception = shouldThrow<EmptyYamlDocumentException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"The YAML document is empty.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n        }\n\n        context(\"given a document with just a comment\") {\n            val input = \"# this is a comment\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that the document is empty\") {\n                    val exception = shouldThrow<EmptyYamlDocumentException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"The YAML document is empty.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n        }\n\n        // The following examples are taken from https://yaml.org/type/merge.html\n        context(\"given a map with a single map to merge into it\") {\n            val input = \"\"\"\n                - &CENTER { x: 1, y: 2 }\n\n                - << : *CENTER\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                val firstItemPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val firstXPath = firstItemPath.withMapElementKey(\"x\", Location(1, 13))\n                val firstYPath = firstItemPath.withMapElementKey(\"y\", Location(1, 19))\n                val secondItemPath = YamlPath.root.withListEntry(1, Location(3, 3))\n                val mergeResolutionPath = secondItemPath.withMerge(Location(3, 8)).withAliasReference(\"CENTER\", Location(3, 8)).withAliasDefinition(\"CENTER\", Location(1, 3))\n                val secondXPath = mergeResolutionPath.withMapElementKey(\"x\", Location(1, 13))\n                val secondYPath = mergeResolutionPath.withMapElementKey(\"y\", Location(1, 19))\n                val labelPath = secondItemPath.withMapElementKey(\"label\", Location(5, 3))\n                val rPath = secondItemPath.withMapElementKey(\"r\", Location(4, 3))\n\n                it(\"returns that map with the values from the source map merged into it\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", firstXPath) to YamlScalar(\"1\", firstXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", firstYPath) to YamlScalar(\"2\", firstYPath.withMapElementValue(Location(1, 22))),\n                                    ),\n                                    firstItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", secondXPath) to YamlScalar(\"1\", secondXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", secondYPath) to YamlScalar(\"2\", secondYPath.withMapElementValue(Location(1, 22))),\n                                        YamlScalar(\"r\", rPath) to YamlScalar(\"10\", rPath.withMapElementValue(Location(4, 6))),\n                                        YamlScalar(\"label\", labelPath) to YamlScalar(\"center/big\", labelPath.withMapElementValue(Location(5, 10))),\n                                    ),\n                                    secondItemPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with a single map to merge into it, with both containing the same key\") {\n            val input = \"\"\"\n                - &CENTER { x: 1, y: 2 }\n\n                - << : *CENTER\n                  x: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                val firstItemPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val firstXPath = firstItemPath.withMapElementKey(\"x\", Location(1, 13))\n                val firstYPath = firstItemPath.withMapElementKey(\"y\", Location(1, 19))\n                val secondItemPath = YamlPath.root.withListEntry(1, Location(3, 3))\n                val mergeResolutionPath = secondItemPath.withMerge(Location(3, 8)).withAliasReference(\"CENTER\", Location(3, 8)).withAliasDefinition(\"CENTER\", Location(1, 3))\n                val secondXPath = secondItemPath.withMapElementKey(\"x\", Location(4, 3))\n                val secondYPath = mergeResolutionPath.withMapElementKey(\"y\", Location(1, 19))\n                val labelPath = secondItemPath.withMapElementKey(\"label\", Location(5, 3))\n\n                it(\"returns that map with the values from the source map merged into it, with the local values taking precedence\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", firstXPath) to YamlScalar(\"1\", firstXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", firstYPath) to YamlScalar(\"2\", firstYPath.withMapElementValue(Location(1, 22))),\n                                    ),\n                                    firstItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", secondXPath) to YamlScalar(\"10\", secondXPath.withMapElementValue(Location(4, 6))),\n                                        YamlScalar(\"y\", secondYPath) to YamlScalar(\"2\", secondYPath.withMapElementValue(Location(1, 22))),\n                                        YamlScalar(\"label\", labelPath) to YamlScalar(\"center/big\", labelPath.withMapElementValue(Location(5, 10))),\n                                    ),\n                                    secondItemPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with a single null value to merge into it\") {\n            val input = \"\"\"\n                - << : null\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a null value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a null value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 8\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with a single scalar value to merge into it\") {\n            val input = \"\"\"\n                - << : abc123\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a scalar value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a scalar value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 8\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with multiple maps to merge into it\") {\n            val input = \"\"\"\n                - &CENTER { x: 1, y: 2 }\n                - &RADIUS { r: 10 }\n\n                - << : [ *CENTER, *RADIUS ]\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                val firstItemPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val firstXPath = firstItemPath.withMapElementKey(\"x\", Location(1, 13))\n                val firstYPath = firstItemPath.withMapElementKey(\"y\", Location(1, 19))\n\n                val secondItemPath = YamlPath.root.withListEntry(1, Location(2, 3))\n                val secondRPath = secondItemPath.withMapElementKey(\"r\", Location(2, 13))\n\n                val thirdItemPath = YamlPath.root.withListEntry(2, Location(4, 3))\n                val centerMergeResolutionPath = thirdItemPath.withMerge(Location(4, 8)).withListEntry(0, Location(4, 10)).withAliasReference(\"CENTER\", Location(4, 10)).withAliasDefinition(\"CENTER\", Location(1, 3))\n                val thirdXPath = centerMergeResolutionPath.withMapElementKey(\"x\", Location(1, 13))\n                val thirdYPath = centerMergeResolutionPath.withMapElementKey(\"y\", Location(1, 19))\n                val radiusMergeResolutionPath = thirdItemPath.withMerge(Location(4, 8)).withListEntry(1, Location(4, 19)).withAliasReference(\"RADIUS\", Location(4, 19)).withAliasDefinition(\"RADIUS\", Location(2, 3))\n                val thirdRPath = radiusMergeResolutionPath.withMapElementKey(\"r\", Location(2, 13))\n                val labelPath = thirdItemPath.withMapElementKey(\"label\", Location(5, 3))\n\n                it(\"returns that map with the values from the source maps merged into it\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", firstXPath) to YamlScalar(\"1\", firstXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", firstYPath) to YamlScalar(\"2\", firstYPath.withMapElementValue(Location(1, 22))),\n                                    ),\n                                    firstItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"r\", secondRPath) to YamlScalar(\"10\", secondRPath.withMapElementValue(Location(2, 16))),\n                                    ),\n                                    secondItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", thirdXPath) to YamlScalar(\"1\", thirdXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", thirdYPath) to YamlScalar(\"2\", thirdYPath.withMapElementValue(Location(1, 22))),\n                                        YamlScalar(\"r\", thirdRPath) to YamlScalar(\"10\", thirdRPath.withMapElementValue(Location(2, 16))),\n                                        YamlScalar(\"label\", labelPath) to YamlScalar(\"center/big\", labelPath.withMapElementValue(Location(5, 10))),\n                                    ),\n                                    thirdItemPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with multiple maps to merge into it, with both source and destination maps containing the same keys\") {\n            val input = \"\"\"\n                - &LEFT { x: 0, y: 2 }\n                - &BIG { r: 10 }\n                - &SMALL { r: 1 }\n\n                - << : [ *BIG, *LEFT, *SMALL ]\n                  x: 1\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                val firstItemPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val firstXPath = firstItemPath.withMapElementKey(\"x\", Location(1, 11))\n                val firstYPath = firstItemPath.withMapElementKey(\"y\", Location(1, 17))\n\n                val secondItemPath = YamlPath.root.withListEntry(1, Location(2, 3))\n                val secondRPath = secondItemPath.withMapElementKey(\"r\", Location(2, 10))\n\n                val thirdItemPath = YamlPath.root.withListEntry(2, Location(3, 3))\n                val thirdRPath = thirdItemPath.withMapElementKey(\"r\", Location(3, 12))\n\n                val fourthItemPath = YamlPath.root.withListEntry(3, Location(5, 3))\n                val fourthXPath = fourthItemPath.withMapElementKey(\"x\", Location(6, 3))\n                val leftMergeResolutionPath = fourthItemPath.withMerge(Location(5, 8)).withListEntry(1, Location(5, 16)).withAliasReference(\"LEFT\", Location(5, 16)).withAliasDefinition(\"LEFT\", Location(1, 3))\n                val fourthYPath = leftMergeResolutionPath.withMapElementKey(\"y\", Location(1, 17))\n                val bigMergeResolutionPath = fourthItemPath.withMerge(Location(5, 8)).withListEntry(0, Location(5, 10)).withAliasReference(\"BIG\", Location(5, 10)).withAliasDefinition(\"BIG\", Location(2, 3))\n                val fourthRPath = bigMergeResolutionPath.withMapElementKey(\"r\", Location(2, 10))\n                val labelPath = fourthItemPath.withMapElementKey(\"label\", Location(7, 3))\n\n                it(\"returns that map with the values from the source maps merged into it, with local values taking precedence over earlier source values, and with earlier source values taking precedence over later source values\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", firstXPath) to YamlScalar(\"0\", firstXPath.withMapElementValue(Location(1, 14))),\n                                        YamlScalar(\"y\", firstYPath) to YamlScalar(\"2\", firstYPath.withMapElementValue(Location(1, 20))),\n                                    ),\n                                    firstItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"r\", secondRPath) to YamlScalar(\"10\", secondRPath.withMapElementValue(Location(2, 13))),\n                                    ),\n                                    secondItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"r\", thirdRPath) to YamlScalar(\"1\", thirdRPath.withMapElementValue(Location(3, 15))),\n                                    ),\n                                    thirdItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", fourthXPath) to YamlScalar(\"1\", fourthXPath.withMapElementValue(Location(6, 6))),\n                                        YamlScalar(\"y\", fourthYPath) to YamlScalar(\"2\", fourthYPath.withMapElementValue(Location(1, 20))),\n                                        YamlScalar(\"r\", fourthRPath) to YamlScalar(\"10\", fourthRPath.withMapElementValue(Location(2, 13))),\n                                        YamlScalar(\"label\", labelPath) to YamlScalar(\"center/big\", labelPath.withMapElementValue(Location(7, 10))),\n                                    ),\n                                    fourthItemPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with a null value in a list of values to merge into it\") {\n            val input = \"\"\"\n                - << : [null]\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a null value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a null value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 9\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8)).withListEntry(0, Location(1, 9))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with a scalar value in a list of values to merge into it\") {\n            val input = \"\"\"\n                - << : [abc123]\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a scalar value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a scalar value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 9\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8)).withListEntry(0, Location(1, 9))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with a list value in a list of values to merge into it\") {\n            val input = \"\"\"\n                - << : [ [] ]\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a list value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a list value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 10\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8)).withListEntry(0, Location(1, 10))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with multiple lists of items to merge into it\") {\n            val input = \"\"\"\n                - << : []\n                  << : []\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that multiple merges are not possible\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot perform multiple '<<' merges into a map. Instead, combine all merges into a single '<<' entry.\"\n                        it.line shouldBe 2\n                        it.column shouldBe 3\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMapElementKey(\"<<\", Location(2, 3))\n                    }\n                }\n            }\n        }\n\n        context(\"given a top-level map with an entry matching the extension definition prefix\") {\n            val input = \"\"\"\n                .extension: &extension extension-value\n\n                foo:\n                    bar: value\n                    baz: *extension\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input with an extension definition prefix defined\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, extensionDefinitionPrefix = \".\").read()\n\n                val fooKeyPath = YamlPath.root.withMapElementKey(\"foo\", Location(3, 1))\n                val fooValuePath = fooKeyPath.withMapElementValue(Location(4, 5))\n                val barKeyPath = fooValuePath.withMapElementKey(\"bar\", Location(4, 5))\n                val bazKeyPath = fooValuePath.withMapElementKey(\"baz\", Location(5, 5))\n                val bazValuePath = bazKeyPath.withMapElementValue(Location(5, 10)).withAliasReference(\"extension\", Location(5, 10)).withAliasDefinition(\"extension\", Location(1, 13))\n\n                it(\"returns the map, merging the alias where it is referenced and removing it from the top-level entry\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"foo\", fooKeyPath) to YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"bar\", barKeyPath) to YamlScalar(\"value\", barKeyPath.withMapElementValue(Location(4, 10))),\n                                        YamlScalar(\"baz\", bazKeyPath) to YamlScalar(\"extension-value\", bazValuePath),\n                                    ),\n                                    fooValuePath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a non-top-level map with an entry matching the extension definition prefix\") {\n            val input = \"\"\"\n                foo:\n                    .bar: value\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input with an extension definition prefix defined\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, extensionDefinitionPrefix = \".\").read()\n\n                val fooKeyPath = YamlPath.root.withMapElementKey(\"foo\", Location(1, 1))\n                val fooValuePath = fooKeyPath.withMapElementValue(Location(2, 5))\n                val barKeyPath = fooValuePath.withMapElementKey(\".bar\", Location(2, 5))\n\n                it(\"returns the map, retaining the key matching the extension definition prefix\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"foo\", fooKeyPath) to YamlMap(\n                                    mapOf(\n                                        YamlScalar(\".bar\", barKeyPath) to YamlScalar(\"value\", barKeyPath.withMapElementValue(Location(2, 11))),\n                                    ),\n                                    fooValuePath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a top-level map that has another map merged into it with an entry with a key matching the extension definition prefix\") {\n            val input = \"\"\"\n                .extension: &extension\n                    .some-key: some-value\n\n                << : [ *extension ]\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input with an extension definition prefix defined\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, extensionDefinitionPrefix = \".\").read()\n\n                val keyPath = YamlPath.root\n                    .withMerge(Location(4, 6))\n                    .withListEntry(0, Location(4, 8))\n                    .withAliasReference(\"extension\", Location(4, 8))\n                    .withAliasDefinition(\"extension\", Location(1, 13))\n                    .withMapElementKey(\".some-key\", Location(2, 5))\n\n                val valuePath = keyPath.withMapElementValue(Location(2, 16))\n\n                it(\"returns the map, merging the other map into it and preserving its keys\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\".some-key\", keyPath) to YamlScalar(\"some-value\", valuePath),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a top-level map with a key matching the extension definition prefix but no anchor defined\") {\n            val input = \"\"\"\n                .invalid-extension: some-value\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that an anchor is required for keys with the extension definition prefix\") {\n                    val exception = shouldThrow<NoAnchorForExtensionException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser, extensionDefinitionPrefix = \".\").read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"The key '.invalid-extension' starts with the extension definition prefix '.' but does not define an anchor.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root.withError(Location(1, 1))\n                    }\n                }\n            }\n        }\n    }\n})\n"], "fixing_code": ["/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\n/**\n * Configuration options for parsing YAML to objects and serialising objects to YAML.\n *\n * * [encodeDefaults]: set to false to not write default property values to YAML (defaults to `true`)\n * * [strictMode]: set to true to throw an exception when reading an object that has an unknown property, or false to ignore unknown properties (defaults to `true`)\n * * [extensionDefinitionPrefix]: prefix used on root-level keys (where document root is an object) to define extensions that can later be merged (defaults to `null`, which disables extensions altogether). See https://batect.charleskorn.com/config/Overview.html#anchors-aliases-extensions-and-merging for example.\n * * [polymorphismStyle]: how to read or write the type of a polymorphic object:\n *    * [PolymorphismStyle.Tag]: use a YAML tag (eg. `!<typeOfThing> { property: value }`)\n *    * [PolymorphismStyle.Property]: use a property (eg. `{ type: typeOfThing, property: value }`)\n * * [polymorphismPropertyName]: property name to use when [polymorphismStyle] is [PolymorphismStyle.Property]\n * * [encodingIndentationSize]: number of spaces to use as indentation when encoding objects as YAML\n * * [breakScalarsAt]: maximum length of scalars when encoding objects as YAML (scalars exceeding this length will be split into multiple lines)\n * * [sequenceStyle]: how sequences (aka lists and arrays) should be formatted. See [SequenceStyle] for an example of each\n * * [ambiguousQuoteStyle]: how strings should be escaped when [singleLineStringStyle] is [SingleLineStringStyle.PlainExceptAmbiguous] and the value is ambiguous\n * * [sequenceBlockIndent]: number of spaces to use as indentation for sequences, if [sequenceStyle] set to [SequenceStyle.Block]\n * * [allowAnchorsAndAliases]: set to true to allow anchors and aliases when decoding YAML (defaults to `false`)\n */\npublic data class YamlConfiguration constructor(\n    internal val encodeDefaults: Boolean = true,\n    internal val strictMode: Boolean = true,\n    internal val extensionDefinitionPrefix: String? = null,\n    internal val polymorphismStyle: PolymorphismStyle = PolymorphismStyle.Tag,\n    internal val polymorphismPropertyName: String = \"type\",\n    internal val encodingIndentationSize: Int = 2,\n    internal val breakScalarsAt: Int = 80,\n    internal val sequenceStyle: SequenceStyle = SequenceStyle.Block,\n    internal val singleLineStringStyle: SingleLineStringStyle = SingleLineStringStyle.DoubleQuoted,\n    internal val multiLineStringStyle: MultiLineStringStyle = singleLineStringStyle.multiLineStringStyle,\n    internal val ambiguousQuoteStyle: AmbiguousQuoteStyle = AmbiguousQuoteStyle.DoubleQuoted,\n    internal val sequenceBlockIndent: Int = 0,\n    internal val allowAnchorsAndAliases: Boolean = false,\n)\n\npublic enum class PolymorphismStyle {\n    Tag,\n    Property,\n}\n\npublic enum class SequenceStyle {\n    /**\n     * The block form, eg\n     * ```yaml\n     * - 1\n     * - 2\n     * - 3\n     * ```\n     */\n    Block,\n\n    /**\n     * The flow form, eg\n     * ```yaml\n     * [1, 2, 3]\n     * ```\n     */\n    Flow,\n}\n\npublic enum class MultiLineStringStyle {\n    Literal,\n    DoubleQuoted,\n    SingleQuoted,\n    Plain,\n}\n\npublic enum class SingleLineStringStyle {\n    DoubleQuoted,\n    SingleQuoted,\n    Plain,\n\n    /**\n     * This is the same as [SingleLineStringStyle.Plain], except strings that could be misinterpreted as other types\n     * will be quoted with the escape style defined in [AmbiguousQuoteStyle].\n     *\n     * For example, the strings \"True\", \"0xAB\", \"1\" and \"1.2\" would all be quoted,\n     * while \"1.2.3\" and \"abc\" would not be quoted.\n     */\n    PlainExceptAmbiguous,\n    ;\n\n    public val multiLineStringStyle: MultiLineStringStyle\n        get() = when (this) {\n            DoubleQuoted -> MultiLineStringStyle.DoubleQuoted\n            SingleQuoted -> MultiLineStringStyle.SingleQuoted\n            Plain -> MultiLineStringStyle.Plain\n            PlainExceptAmbiguous -> MultiLineStringStyle.Plain\n        }\n}\n\npublic enum class AmbiguousQuoteStyle {\n    DoubleQuoted,\n    SingleQuoted,\n}\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\nimport kotlinx.serialization.SerializationException\n\npublic open class YamlException(\n    override val message: String,\n    public val path: YamlPath,\n    override val cause: Throwable? = null,\n) : SerializationException(message, cause) {\n    public val location: Location = path.endLocation\n    public val line: Int = location.line\n    public val column: Int = location.column\n\n    override fun toString(): String = \"${this::class.qualifiedName} at ${path.toHumanReadableString()} on line $line, column $column: $message\"\n}\n\npublic class DuplicateKeyException(\n    public val originalPath: YamlPath,\n    public val duplicatePath: YamlPath,\n    public val key: String,\n) :\n    YamlException(\"Duplicate key $key. It was previously given at line ${originalPath.endLocation.line}, column ${originalPath.endLocation.column}.\", duplicatePath) {\n\n    public val originalLocation: Location = originalPath.endLocation\n    public val duplicateLocation: Location = duplicatePath.endLocation\n}\n\npublic class EmptyYamlDocumentException(message: String, path: YamlPath) : YamlException(message, path)\n\npublic class InvalidPropertyValueException(\n    public val propertyName: String,\n    public val reason: String,\n    path: YamlPath,\n    cause: Throwable? = null,\n) : YamlException(\"Value for '$propertyName' is invalid: $reason\", path, cause)\n\npublic class MalformedYamlException(message: String, path: YamlPath) : YamlException(message, path)\n\npublic class UnexpectedNullValueException(path: YamlPath) : YamlException(\"Unexpected null or empty value for non-null field.\", path)\n\npublic class MissingRequiredPropertyException(\n    public val propertyName: String,\n    path: YamlPath,\n    cause: Throwable? = null,\n) :\n    YamlException(\"Property '$propertyName' is required but it is missing.\", path, cause)\n\npublic class UnknownPropertyException(\n    public val propertyName: String,\n    public val validPropertyNames: Set<String>,\n    path: YamlPath,\n) :\n    YamlException(\"Unknown property '$propertyName'. Known properties are: ${validPropertyNames.sorted().joinToString(\", \")}\", path)\n\npublic class UnknownPolymorphicTypeException(\n    public val typeName: String,\n    public val validTypeNames: Set<String>,\n    path: YamlPath,\n    cause: Throwable? = null,\n) :\n    YamlException(\"Unknown type '$typeName'. Known types are: ${validTypeNames.sorted().joinToString(\", \")}\", path, cause)\n\npublic class YamlScalarFormatException(\n    message: String,\n    path: YamlPath,\n    public val originalValue: String,\n) : YamlException(message, path)\n\npublic open class IncorrectTypeException(message: String, path: YamlPath) : YamlException(message, path)\n\npublic class MissingTypeTagException(path: YamlPath) :\n    IncorrectTypeException(\"Value is missing a type tag (eg. !<type>)\", path)\n\npublic class UnknownAnchorException(public val anchorName: String, path: YamlPath) :\n    YamlException(\"Unknown anchor '$anchorName'.\", path)\n\npublic class NoAnchorForExtensionException(\n    public val key: String,\n    public val extensionDefinitionPrefix: String,\n    path: YamlPath,\n) :\n    YamlException(\"The key '$key' starts with the extension definition prefix '$extensionDefinitionPrefix' but does not define an anchor.\", path)\n\npublic class ForbiddenAnchorOrAliasException(message: String, path: YamlPath) : YamlException(message, path)\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n@file:OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\n\npackage com.charleskorn.kaml\n\nimport com.charleskorn.kaml.testobjects.NestedObjects\nimport com.charleskorn.kaml.testobjects.PolymorphicWrapper\nimport com.charleskorn.kaml.testobjects.SealedWrapper\nimport com.charleskorn.kaml.testobjects.SimpleStructure\nimport com.charleskorn.kaml.testobjects.Team\nimport com.charleskorn.kaml.testobjects.TestEnum\nimport com.charleskorn.kaml.testobjects.TestEnumWithExplicitNames\nimport com.charleskorn.kaml.testobjects.TestSealedStructure\nimport com.charleskorn.kaml.testobjects.UnsealedClass\nimport com.charleskorn.kaml.testobjects.UnsealedString\nimport com.charleskorn.kaml.testobjects.UnwrappedInt\nimport com.charleskorn.kaml.testobjects.UnwrappedInterface\nimport com.charleskorn.kaml.testobjects.UnwrappedString\nimport com.charleskorn.kaml.testobjects.polymorphicModule\nimport io.kotest.assertions.asClue\nimport io.kotest.assertions.throwables.shouldThrow\nimport io.kotest.core.spec.style.DescribeSpec\nimport io.kotest.matchers.shouldBe\nimport io.kotest.matchers.types.shouldBeInstanceOf\nimport kotlinx.serialization.Contextual\nimport kotlinx.serialization.ExperimentalSerializationApi\nimport kotlinx.serialization.InternalSerializationApi\nimport kotlinx.serialization.KSerializer\nimport kotlinx.serialization.PolymorphicSerializer\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.builtins.ListSerializer\nimport kotlinx.serialization.builtins.MapSerializer\nimport kotlinx.serialization.builtins.nullable\nimport kotlinx.serialization.builtins.serializer\nimport kotlinx.serialization.descriptors.PrimitiveKind\nimport kotlinx.serialization.descriptors.PrimitiveSerialDescriptor\nimport kotlinx.serialization.descriptors.SerialDescriptor\nimport kotlinx.serialization.descriptors.SerialKind\nimport kotlinx.serialization.descriptors.StructureKind\nimport kotlinx.serialization.descriptors.buildClassSerialDescriptor\nimport kotlinx.serialization.descriptors.buildSerialDescriptor\nimport kotlinx.serialization.encoding.Decoder\nimport kotlinx.serialization.encoding.Encoder\nimport kotlinx.serialization.modules.serializersModuleOf\nimport kotlin.jvm.JvmInline\n\nclass YamlReadingTest : DescribeSpec({\n    describe(\"a YAML parser\") {\n        describe(\"parsing scalars\") {\n            context(\"given the input 'hello'\") {\n                val input = \"hello\"\n\n                context(\"parsing that input as a string\") {\n                    val result = Yaml.default.decodeFromString(String.serializer(), input)\n\n                    it(\"deserializes it to the expected string value\") {\n                        result shouldBe \"hello\"\n                    }\n                }\n\n                context(\"parsing that input as a nullable string\") {\n                    val result = Yaml.default.decodeFromString(String.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected string value\") {\n                        result shouldBe \"hello\"\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(LocationThrowingSerializer, input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 1) and path: <root>\"\n                        }\n                    }\n                }\n\n                context(\"parsing that input as a value type\") {\n                    val result = Yaml.default.decodeFromString(StringValue.serializer(), input)\n\n                    it(\"deserializes it to the expected object\") {\n                        result shouldBe StringValue(\"hello\")\n                    }\n                }\n            }\n\n            context(\"given the input '123'\") {\n                val input = \"123\"\n\n                context(\"parsing that input as an integer\") {\n                    val result = Yaml.default.decodeFromString(Int.serializer(), input)\n\n                    it(\"deserializes it to the expected integer\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a long\") {\n                    val result = Yaml.default.decodeFromString(Long.serializer(), input)\n\n                    it(\"deserializes it to the expected long\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a short\") {\n                    val result = Yaml.default.decodeFromString(Short.serializer(), input)\n\n                    it(\"deserializes it to the expected short\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a byte\") {\n                    val result = Yaml.default.decodeFromString(Byte.serializer(), input)\n\n                    it(\"deserializes it to the expected byte\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a double\") {\n                    val result = Yaml.default.decodeFromString(Double.serializer(), input)\n\n                    it(\"deserializes it to the expected double\") {\n                        result shouldBe 123.0\n                    }\n                }\n\n                context(\"parsing that input as a float\") {\n                    val result = Yaml.default.decodeFromString(Float.serializer(), input)\n\n                    it(\"deserializes it to the expected float\") {\n                        result shouldBe 123.0f\n                    }\n                }\n\n                context(\"parsing that input as a nullable integer\") {\n                    val result = Yaml.default.decodeFromString(Int.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected integer\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a nullable long\") {\n                    val result = Yaml.default.decodeFromString(Long.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected long\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a nullable short\") {\n                    val result = Yaml.default.decodeFromString(Short.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected short\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a nullable byte\") {\n                    val result = Yaml.default.decodeFromString(Byte.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected byte\") {\n                        result shouldBe 123\n                    }\n                }\n\n                context(\"parsing that input as a nullable double\") {\n                    val result = Yaml.default.decodeFromString(Double.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected double\") {\n                        result shouldBe 123.0\n                    }\n                }\n\n                context(\"parsing that input as a nullable float\") {\n                    val result = Yaml.default.decodeFromString(Float.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected float\") {\n                        result shouldBe 123.0f\n                    }\n                }\n            }\n\n            context(\"given the input 'true'\") {\n                val input = \"true\"\n\n                context(\"parsing that input as a boolean\") {\n                    val result = Yaml.default.decodeFromString(Boolean.serializer(), input)\n\n                    it(\"deserializes it to the expected boolean value\") {\n                        result shouldBe true\n                    }\n                }\n\n                context(\"parsing that input as a nullable boolean\") {\n                    val result = Yaml.default.decodeFromString(Boolean.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected boolean value\") {\n                        result shouldBe true\n                    }\n                }\n            }\n\n            context(\"given the input 'c'\") {\n                val input = \"c\"\n\n                context(\"parsing that input as a character\") {\n                    val result = Yaml.default.decodeFromString(Char.serializer(), input)\n\n                    it(\"deserializes it to the expected character value\") {\n                        result shouldBe 'c'\n                    }\n                }\n\n                context(\"parsing that input as a nullable character\") {\n                    val result = Yaml.default.decodeFromString(Char.serializer().nullable, input)\n\n                    it(\"deserializes it to the expected character value\") {\n                        result shouldBe 'c'\n                    }\n                }\n            }\n\n            data class EnumFixture(val input: String, val serializer: KSerializer<*>)\n\n            mapOf(\n                EnumFixture(\"Value1\", TestEnum.serializer()) to TestEnum.Value1,\n                EnumFixture(\"Value2\", TestEnum.serializer()) to TestEnum.Value2,\n                EnumFixture(\"A\", TestEnumWithExplicitNames.serializer()) to TestEnumWithExplicitNames.Alpha,\n                EnumFixture(\"B\", TestEnumWithExplicitNames.serializer()) to TestEnumWithExplicitNames.Beta,\n                EnumFixture(\"With space\", TestEnumWithExplicitNames.serializer()) to TestEnumWithExplicitNames.WithSpace,\n            ).forEach { (fixture, expectedValue) ->\n                val (input, serializer) = fixture\n                context(\"given the input '$input'\") {\n                    context(\"parsing that input as an enumeration value\") {\n                        val result = Yaml.default.decodeFromString(serializer, input)\n\n                        it(\"deserializes it to the expected enumeration value\") {\n                            result shouldBe expectedValue\n                        }\n                    }\n                }\n            }\n\n            context(\"parsing an invalid enumeration value\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<YamlScalarFormatException> { Yaml.default.decodeFromString(TestEnum.serializer(), \"nonsense\") }\n\n                    exception.asClue {\n                        it.message shouldBe \"Value 'nonsense' is not a valid option, permitted choices are: Value1, Value2\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing null values\") {\n            val input = \"null\"\n\n            context(\"parsing a null value as a nullable string\") {\n                val result = Yaml.default.decodeFromString(String.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable string\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(String.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable integer\") {\n                val result = Yaml.default.decodeFromString(Int.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable integer\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Int.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable long\") {\n                val result = Yaml.default.decodeFromString(Long.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable long\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Long.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable short\") {\n                val result = Yaml.default.decodeFromString(Short.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable short\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Short.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable byte\") {\n                val result = Yaml.default.decodeFromString(Byte.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable byte\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Byte.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable double\") {\n                val result = Yaml.default.decodeFromString(Double.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable double\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Double.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable float\") {\n                val result = Yaml.default.decodeFromString(Float.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable float\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Float.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable boolean\") {\n                val result = Yaml.default.decodeFromString(Boolean.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable boolean\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Boolean.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable character\") {\n                val result = Yaml.default.decodeFromString(Char.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable character\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(Char.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable enum\") {\n                val result = Yaml.default.decodeFromString(TestEnum.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable enum\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(TestEnum.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable list\") {\n                val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()).nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable list\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value as a nullable object\") {\n                val result = Yaml.default.decodeFromString(ComplexStructure.serializer().nullable, input)\n\n                it(\"returns a null value\") {\n                    result shouldBe null\n                }\n            }\n\n            context(\"parsing a null value as a non-nullable object\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnexpectedNullValueException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unexpected null or empty value for non-null field.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n\n            context(\"parsing a null value with a serializer that uses YAML location information when throwing exceptions\") {\n                it(\"throws an exception with the correct location information\") {\n                    val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(LocationThrowingSerializer, input) }\n\n                    exception.asClue {\n                        it.message shouldBe \"Serializer called with location (1, 1) and path: <root>\"\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing lists\") {\n            context(\"given a list of strings\") {\n                val input = \"\"\"\n                    - thing1\n                    - thing2\n                    - thing3\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(\"thing1\", \"thing2\", \"thing3\")\n                    }\n                }\n\n                context(\"parsing that input as a nullable list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer()).nullable, input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(\"thing1\", \"thing2\", \"thing3\")\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(ListSerializer(LocationThrowingSerializer), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 3) and path: [0]\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given a list of numbers\") {\n                val input = \"\"\"\n                    - 123\n                    - 45\n                    - 6\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list of integers\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Int.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123, 45, 6)\n                    }\n                }\n\n                context(\"parsing that input as a list of longs\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Long.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123L, 45, 6)\n                    }\n                }\n\n                context(\"parsing that input as a list of shorts\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Short.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123.toShort(), 45, 6)\n                    }\n                }\n\n                context(\"parsing that input as a list of bytes\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Byte.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123.toByte(), 45, 6)\n                    }\n                }\n\n                context(\"parsing that input as a list of doubles\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Double.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123.0, 45.0, 6.0)\n                    }\n                }\n\n                context(\"parsing that input as a list of floats\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Float.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(123.0f, 45.0f, 6.0f)\n                    }\n                }\n            }\n\n            context(\"given a list of booleans\") {\n                val input = \"\"\"\n                    - true\n                    - false\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Boolean.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(true, false)\n                    }\n                }\n            }\n\n            context(\"given a list of enum values\") {\n                val input = \"\"\"\n                    - Value1\n                    - Value2\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(TestEnum.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(TestEnum.Value1, TestEnum.Value2)\n                    }\n                }\n            }\n\n            context(\"given a list of characters\") {\n                val input = \"\"\"\n                    - a\n                    - b\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Char.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf('a', 'b')\n                    }\n                }\n            }\n\n            context(\"given a list of nullable strings\") {\n                val input = \"\"\"\n                    - thing1\n                    - null\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(String.serializer().nullable), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe listOf(\"thing1\", null)\n                    }\n                }\n            }\n\n            context(\"given a list of lists\") {\n                val input = \"\"\"\n                    - [thing1, thing2]\n                    - [thing3]\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(ListSerializer(String.serializer())), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe\n                            listOf(\n                                listOf(\"thing1\", \"thing2\"),\n                                listOf(\"thing3\"),\n                            )\n                    }\n                }\n            }\n\n            context(\"given a list of objects\") {\n                val input = \"\"\"\n                    - name: thing1\n                    - name: thing2\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as a list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(SimpleStructure.serializer()), input)\n\n                    it(\"deserializes it to the expected value\") {\n                        result shouldBe\n                            listOf(\n                                SimpleStructure(\"thing1\"),\n                                SimpleStructure(\"thing2\"),\n                            )\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing objects\") {\n            context(\"given some input representing an object with an optional value specified\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                    nullable: present\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                \"present\",\n                            )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an optional value specified as null\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                    nullable: null\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                null,\n                            )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an optional value not specified\") {\n                val input = \"\"\"\n                    string: Alex\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(ComplexStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe\n                            ComplexStructure(\n                                \"Alex\",\n                                12,\n                                1234,\n                                123456,\n                                1234567,\n                                1.2f,\n                                2.4,\n                                TestEnum.Value1,\n                                true,\n                                'A',\n                                null,\n                            )\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an embedded list\") {\n                val input = \"\"\"\n                    members:\n                        - Alex\n                        - Jamie\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(Team.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe Team(listOf(\"Alex\", \"Jamie\"))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an embedded object\") {\n                val input = \"\"\"\n                    firstPerson:\n                        name: Alex\n                    secondPerson:\n                        name: Jamie\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NestedObjects.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe NestedObjects(SimpleStructure(\"Alex\"), SimpleStructure(\"Jamie\"))\n                    }\n                }\n            }\n\n            context(\"given some input representing an object where the keys are in a different order to the object definition\") {\n                val input = \"\"\"\n                    secondPerson:\n                        name: Jamie\n                    firstPerson:\n                        name: Alex\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NestedObjects.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe NestedObjects(SimpleStructure(\"Alex\"), SimpleStructure(\"Jamie\"))\n                    }\n                }\n            }\n\n            context(\"given some tagged input representing an arbitrary list\") {\n                val input = \"\"\"\n                    !!list\n                        - 5\n                        - 3\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as list\") {\n                    val result = Yaml.default.decodeFromString(ListSerializer(Int.serializer()), input)\n                    it(\"deserializes it to a list ignoring the tag\") {\n                        result shouldBe listOf(5, 3)\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(LocationThrowingSerializer, input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 1) and path: <root>\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given some tagged input representing an arbitrary map\") {\n                val input = \"\"\"\n                    !!map\n                    foo: bar\n                \"\"\".trimIndent()\n\n                context(\"parsing that input as map\") {\n                    val result = Yaml.default.decodeFromString(\n                        MapSerializer(String.serializer(), String.serializer()),\n                        input,\n                    )\n                    it(\"deserializes it to a Map ignoring the tag\") {\n                        result shouldBe mapOf(\"foo\" to \"bar\")\n                    }\n                }\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(LocationThrowingMapSerializer, input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 1) and path: <root>\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a missing key\") {\n                val input = \"\"\"\n                    byte: 12\n                    short: 1234\n                    int: 123456\n                    long: 1234567\n                    float: 1.2\n                    double: 2.4\n                    enum: Value1\n                    boolean: true\n                    char: A\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<MissingRequiredPropertyException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Property 'string' is required but it is missing.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 1\n                            it.propertyName shouldBe \"string\"\n                            it.path shouldBe YamlPath.root\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an unknown key\") {\n                val input = \"\"\"\n                    abc123: something\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<UnknownPropertyException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Unknown property 'abc123'. Known properties are: boolean, byte, char, double, enum, float, int, long, nullable, short, string\"\n                            it.line shouldBe 1\n                            it.column shouldBe 1\n                            it.propertyName shouldBe \"abc123\"\n                            it.validPropertyNames shouldBe setOf(\"boolean\", \"byte\", \"char\", \"double\", \"enum\", \"float\", \"int\", \"long\", \"nullable\", \"short\", \"string\")\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"abc123\", Location(1, 1))\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with an invalid value for a field\") {\n                mapOf(\n                    \"byte\" to \"Value 'xxx' is not a valid byte value.\",\n                    \"short\" to \"Value 'xxx' is not a valid short value.\",\n                    \"int\" to \"Value 'xxx' is not a valid integer value.\",\n                    \"long\" to \"Value 'xxx' is not a valid long value.\",\n                    \"float\" to \"Value 'xxx' is not a valid floating point value.\",\n                    \"double\" to \"Value 'xxx' is not a valid floating point value.\",\n                    \"enum\" to \"Value 'xxx' is not a valid option, permitted choices are: Value1, Value2\",\n                    \"boolean\" to \"Value 'xxx' is not a valid boolean, permitted choices are: true or false\",\n                    \"char\" to \"Value 'xxx' is not a valid character value.\",\n                ).forEach { (fieldName, errorMessage) ->\n                    context(\"given the invalid field represents a $fieldName\") {\n                        val input = \"$fieldName: xxx\"\n\n                        context(\"parsing that input\") {\n                            it(\"throws an appropriate exception\") {\n                                val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Value for '$fieldName' is invalid: $errorMessage\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe fieldName.length + 3\n                                    it.propertyName shouldBe fieldName\n                                    it.reason shouldBe errorMessage\n                                    it.path shouldBe YamlPath.root.withMapElementKey(fieldName, Location(1, 1)).withMapElementValue(Location(1, fieldName.length + 3))\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable scalar field\") {\n                val input = \"name: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(SimpleStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'name' is invalid: Unexpected null or empty value for non-null field.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 7\n                            it.propertyName shouldBe \"name\"\n                            it.reason shouldBe \"Unexpected null or empty value for non-null field.\"\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"name\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable nested object field\") {\n                val input = \"firstPerson: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(NestedObjects.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'firstPerson' is invalid: Unexpected null or empty value for non-null field.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 14\n                            it.propertyName shouldBe \"firstPerson\"\n                            it.reason shouldBe \"Unexpected null or empty value for non-null field.\"\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"firstPerson\", Location(1, 1)).withMapElementValue(Location(1, 14))\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a nullable nested object field\") {\n\n                val input = \"firstPerson: null\"\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NullableNestedObject.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe NullableNestedObject(null)\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a non-nullable nested list field\") {\n                val input = \"members: null\"\n\n                context(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(Team.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'members' is invalid: Unexpected null or empty value for non-null field.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 10\n                            it.propertyName shouldBe \"members\"\n                            it.reason shouldBe \"Unexpected null or empty value for non-null field.\"\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"members\", Location(1, 1)).withMapElementValue(Location(1, 10))\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a null value for a nullable nested list field\") {\n                val input = \"members: null\"\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(NullableNestedList.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object\") {\n                        result shouldBe NullableNestedList(null)\n                    }\n                }\n            }\n\n            context(\"given some input representing an object with a custom serializer for one of its values\") {\n                val input = \"value: something\"\n\n                context(\"parsing that input with a serializer that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(StructureWithLocationThrowingSerializer.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 8) and path: value\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input representing a generic map\") {\n                val input = \"\"\"\n                    SOME_ENV_VAR: somevalue\n                    SOME_OTHER_ENV_VAR: someothervalue\n                \"\"\".trimIndent()\n\n                context(\"parsing that input\") {\n                    val result = Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                    it(\"deserializes it to a Kotlin map\") {\n                        result shouldBe\n                            mapOf(\n                                \"SOME_ENV_VAR\" to \"somevalue\",\n                                \"SOME_OTHER_ENV_VAR\" to \"someothervalue\",\n                            )\n                    }\n                }\n\n                context(\"parsing that input with a serializer for the key that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(MapSerializer(LocationThrowingSerializer, String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 1) and path: SOME_ENV_VAR\"\n                        }\n                    }\n                }\n\n                context(\"parsing that input with a serializer for the value that uses YAML location information when throwing exceptions\") {\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<LocationInformationException> { Yaml.default.decodeFromString(MapSerializer(String.serializer(), LocationThrowingSerializer), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Serializer called with location (1, 15) and path: SOME_ENV_VAR\"\n                        }\n                    }\n                }\n            }\n\n            context(\"given some input with some extensions\") {\n                val input = \"\"\"\n                    .some-extension: &name Jamie\n\n                    name: *name\n                \"\"\".trimIndent()\n\n                context(\"parsing anchors and aliases is disabled\") {\n                    val configuration = YamlConfiguration(extensionDefinitionPrefix = \".\", allowAnchorsAndAliases = false)\n                    val yaml = Yaml(configuration = configuration)\n\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<ForbiddenAnchorOrAliasException> { yaml.decodeFromString(SimpleStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Parsing anchors and aliases is disabled.\"\n                            it.line shouldBe 1\n                            it.column shouldBe 18\n                        }\n                    }\n                }\n\n                context(\"parsing anchors and aliases is enabled\") {\n                    val configuration = YamlConfiguration(extensionDefinitionPrefix = \".\", allowAnchorsAndAliases = true)\n                    val yaml = Yaml(configuration = configuration)\n                    val result = yaml.decodeFromString(SimpleStructure.serializer(), input)\n\n                    it(\"deserializes it to a Kotlin object, replacing the reference to the extension with the extension\") {\n                        result shouldBe SimpleStructure(\"Jamie\")\n                    }\n                }\n            }\n\n            context(\"given some input with an additional unknown field\") {\n                val input = \"\"\"\n                    name: Blah Blahson\n                    extra-field: Hello\n                \"\"\".trimIndent()\n\n                context(\"given strict mode is enabled\") {\n                    val configuration = YamlConfiguration(strictMode = true)\n                    val yaml = Yaml(configuration = configuration)\n\n                    context(\"parsing that input\") {\n                        it(\"throws an appropriate exception\") {\n                            val exception = shouldThrow<UnknownPropertyException> { yaml.decodeFromString(SimpleStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown property 'extra-field'. Known properties are: name\"\n                                it.line shouldBe 2\n                                it.column shouldBe 1\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"extra-field\", Location(2, 1))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given strict mode is disabled\") {\n                    val configuration = YamlConfiguration(strictMode = false)\n                    val yaml = Yaml(configuration = configuration)\n\n                    context(\"parsing that input\") {\n                        it(\"ignores the extra field and returns a deserialised object\") {\n                            yaml.decodeFromString(SimpleStructure.serializer(), input) shouldBe SimpleStructure(\"Blah Blahson\")\n                        }\n                    }\n                }\n            }\n\n            context(\"given a nullable object\") {\n                val input = \"\"\"\n                    host: \"db.test.com\"\n                \"\"\".trimIndent()\n\n                val result = Yaml.default.decodeFromString(Database.serializer().nullable, input)\n\n                it(\"deserializes it to the expected object\") {\n                    result shouldBe Database(\"db.test.com\")\n                }\n            }\n        }\n\n        describe(\"parsing polymorphic values\") {\n            describe(\"given tags are used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Tag))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        !<sealedString>\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                // See https://github.com/charleskorn/kaml/issues/179.\n                context(\"given some input where a tag is provided but no value is provided\") {\n                    val input = \"\"\"\n                        !<sealedString>\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an appropriate exception\") {\n                            val exception = shouldThrow<MissingRequiredPropertyException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Property 'value' is required but it is missing.\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.propertyName shouldBe \"value\"\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input where the value is a literal\") {\n                    val input = \"\"\"\n                        !<simpleString> \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnwrappedInterface::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe UnwrappedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as a string\") {\n                        val result = polymorphicYaml.decodeFromString(String.serializer(), input)\n\n                        it(\"deserializes it to a string ignoring the tag\") {\n                            result shouldBe \"asdfg\"\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        !<unsealedString>\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe UnsealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element: !<sealedString>\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"element\" to mapOf(\"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value is a literal\") {\n                    val input = \"\"\"\n                        test: !<simpleInt> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe PolymorphicWrapper(UnwrappedInt(42))\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - !<sealedString>\n                          value: null\n                        - !<sealedInt>\n                          value: -987\n                        - !<sealedInt>\n                          value: 654\n                        - !<sealedString>\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\"),\n                                )\n                        }\n                    }\n                }\n\n                context(\"given some untagged input for a polymorphic class\") {\n                    val input = \"\"\"\n                        element:\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Value for 'element' is invalid: Value is missing a type tag (eg. !<type>)\"\n                                it.line shouldBe 2\n                                it.column shouldBe 5\n                                it.cause.shouldBeInstanceOf<MissingTypeTagException>()\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"element\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some untagged input for a polymorphic value\") {\n                    val input = \"\"\"\n                        test: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Value for 'test' is invalid: Value is missing a type tag (eg. !<type>)\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.cause.shouldBeInstanceOf<MissingTypeTagException>()\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"test\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some untagged null input for a polymorphic value\") {\n                    val input = \"\"\"\n                        test: null\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(PolymorphicWrapper.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Value for 'test' is invalid: Value is missing a type tag (eg. !<type>)\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.cause.shouldBeInstanceOf<MissingTypeTagException>()\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"test\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"unsealedBoolean\", \"unsealedString\")\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"sealedInt\", \"sealedString\")\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value from a literal with an unknown type tag\") {\n                    val input = \"\"\"\n                        !<someOtherType> 42\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"sealedInt\", \"sealedString\")\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n            }\n\n            describe(\"given a property is used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Property))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        type: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map including the type\") {\n                            result shouldBe mapOf(\"type\" to \"sealedString\", \"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        type: unsealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe UnsealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"type\" to \"unsealedString\", \"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element:\n                            type: sealedString\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"element\" to mapOf(\"type\" to \"sealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input missing a type property\") {\n                    val input = \"\"\"\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<MissingRequiredPropertyException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Property 'type' is required but it is missing.\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.propertyName shouldBe \"type\"\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                mapOf(\n                    \"a list\" to \"[]\",\n                    \"a map\" to \"{}\",\n                    \"a null value\" to \"null\",\n                    \"a tagged value\" to \"!<tag> sealedString\",\n                ).forEach { (description, value) ->\n                    context(\"given some input with a type property that is $description\") {\n                        val input = \"\"\"\n                            type: $value\n                            value: \"asdfg\"\n                        \"\"\".trimIndent()\n\n                        context(\"parsing that input\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Value for 'type' is invalid: expected a string, but got $description\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 7\n                                    it.propertyName shouldBe \"type\"\n                                    it.reason shouldBe \"expected a string, but got $description\"\n                                    it.path shouldBe YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - type: sealedString\n                          value: null\n                        - type: sealedInt\n                          value: -987\n                        - type: sealedInt\n                          value: 654\n                        - type: sealedString\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\"),\n                                )\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        type: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"unsealedBoolean\", \"unsealedString\")\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        type: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"sealedInt\", \"sealedString\")\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"type\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input with a tag and a type property\") {\n                    val input = \"\"\"\n                        !<sealedInt>\n                        type: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"uses the type from the property and ignores the tag\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n                }\n            }\n\n            describe(\"given a custom property name is used to store the type information\") {\n                val polymorphicYaml = Yaml(serializersModule = polymorphicModule, configuration = YamlConfiguration(polymorphismStyle = PolymorphismStyle.Property, polymorphismPropertyName = \"kind\"))\n\n                context(\"given some input where the value should be a sealed class\") {\n                    val input = \"\"\"\n                        kind: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map including the type\") {\n                            result shouldBe mapOf(\"kind\" to \"sealedString\", \"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input where the value should be an unsealed class\") {\n                    val input = \"\"\"\n                        kind: unsealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe UnsealedString(\"asdfg\")\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"kind\" to \"unsealedString\", \"value\" to \"asdfg\")\n                        }\n                    }\n                }\n\n                context(\"given some input for an object where the property value should be a sealed class\") {\n                    val input = \"\"\"\n                        element:\n                            kind: sealedString\n                            value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(SealedWrapper.serializer(), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe SealedWrapper(TestSealedStructure.SimpleSealedString(\"asdfg\"))\n                        }\n                    }\n\n                    context(\"parsing that input as map\") {\n                        val result = polymorphicYaml.decodeFromString(MapSerializer(String.serializer(), MapSerializer(String.serializer(), String.serializer())), input)\n\n                        it(\"deserializes it to a map ignoring the tag\") {\n                            result shouldBe mapOf(\"element\" to mapOf(\"kind\" to \"sealedString\", \"value\" to \"asdfg\"))\n                        }\n                    }\n                }\n\n                context(\"given some input missing a type property\") {\n                    val input = \"\"\"\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<MissingRequiredPropertyException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Property 'kind' is required but it is missing.\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.propertyName shouldBe \"kind\"\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                mapOf(\n                    \"a list\" to \"[]\",\n                    \"a map\" to \"{}\",\n                    \"a null value\" to \"null\",\n                    \"a tagged value\" to \"!<tag> sealedString\",\n                ).forEach { (description, value) ->\n                    context(\"given some input with a type property that is $description\") {\n                        val input = \"\"\"\n                            kind: $value\n                            value: \"asdfg\"\n                        \"\"\".trimIndent()\n\n                        context(\"parsing that input\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<InvalidPropertyValueException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Value for 'kind' is invalid: expected a string, but got $description\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 7\n                                    it.propertyName shouldBe \"kind\"\n                                    it.reason shouldBe \"expected a string, but got $description\"\n                                    it.path shouldBe YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some tagged input representing a list of polymorphic objects\") {\n                    val input = \"\"\"\n                        - kind: sealedString\n                          value: null\n                        - kind: sealedInt\n                          value: -987\n                        - kind: sealedInt\n                          value: 654\n                        - kind: sealedString\n                          value: \"tests\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(ListSerializer(TestSealedStructure.serializer()), input)\n\n                        it(\"deserializes it to a Kotlin object\") {\n                            result shouldBe\n                                listOf(\n                                    TestSealedStructure.SimpleSealedString(null),\n                                    TestSealedStructure.SimpleSealedInt(-987),\n                                    TestSealedStructure.SimpleSealedInt(654),\n                                    TestSealedStructure.SimpleSealedString(\"tests\"),\n                                )\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from an unsealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        kind: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(PolymorphicSerializer(UnsealedClass::class), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: unsealedBoolean, unsealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"unsealedBoolean\", \"unsealedString\")\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given a polymorphic value for a property from a sealed type with an unknown type tag\") {\n                    val input = \"\"\"\n                        kind: someOtherType\n                        value: 123\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<UnknownPolymorphicTypeException> { polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Unknown type 'someOtherType'. Known types are: sealedInt, sealedString\"\n                                it.line shouldBe 1\n                                it.column shouldBe 7\n                                it.typeName shouldBe \"someOtherType\"\n                                it.validTypeNames shouldBe setOf(\"sealedInt\", \"sealedString\")\n                                it.path shouldBe YamlPath.root.withMapElementKey(\"kind\", Location(1, 1)).withMapElementValue(Location(1, 7))\n                            }\n                        }\n                    }\n                }\n\n                context(\"given some input with a tag and a type property\") {\n                    val input = \"\"\"\n                        !<sealedInt>\n                        kind: sealedString\n                        value: \"asdfg\"\n                    \"\"\".trimIndent()\n\n                    context(\"parsing that input\") {\n                        val result = polymorphicYaml.decodeFromString(TestSealedStructure.serializer(), input)\n\n                        it(\"uses the type from the property and ignores the tag\") {\n                            result shouldBe TestSealedStructure.SimpleSealedString(\"asdfg\")\n                        }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing values with a dynamically installed serializer\") {\n            describe(\"parsing a literal with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor: SerialDescriptor\n                        get() = String.serializer().descriptor\n\n                    override fun deserialize(decoder: Decoder): Inner = Inner(\"from context serializer\")\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    result shouldBe Container(Inner(\"from context serializer\"))\n                }\n            }\n\n            describe(\"parsing a class with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor = buildClassSerialDescriptor(\"Inner\") {\n                        element(\"thing\", String.serializer().descriptor)\n                    }\n\n                    override fun deserialize(decoder: Decoder): Inner {\n                        val objectDecoder = decoder.beginStructure(descriptor)\n                        val index = objectDecoder.decodeElementIndex(descriptor)\n                        val name = objectDecoder.decodeStringElement(descriptor, index)\n                        objectDecoder.endStructure(descriptor)\n\n                        return Inner(\"$name, from context serializer\")\n                    }\n\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner:\n                        thing: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    result shouldBe Container(Inner(\"this is the input, from context serializer\"))\n                }\n            }\n\n            describe(\"parsing a map with a contextual serializer\") {\n                val contextSerializer = object : KSerializer<Inner> {\n                    override val descriptor = buildSerialDescriptor(\"Inner\", StructureKind.MAP) {\n                        element(\"key\", String.serializer().descriptor)\n                        element(\"value\", String.serializer().descriptor)\n                    }\n\n                    override fun deserialize(decoder: Decoder): Inner {\n                        val objectDecoder = decoder.beginStructure(descriptor)\n                        val keyIndex = objectDecoder.decodeElementIndex(descriptor)\n                        val key = objectDecoder.decodeStringElement(descriptor, keyIndex)\n                        val valueIndex = objectDecoder.decodeElementIndex(descriptor)\n                        val value = objectDecoder.decodeStringElement(descriptor, valueIndex)\n\n                        objectDecoder.endStructure(descriptor)\n\n                        return Inner(\"$key: $value, from context serializer\")\n                    }\n\n                    override fun serialize(encoder: Encoder, value: Inner) = throw UnsupportedOperationException()\n                }\n\n                val module = serializersModuleOf(Inner::class, contextSerializer)\n                val parser = Yaml(serializersModule = module)\n\n                val input = \"\"\"\n                    inner:\n                        thing: this is the input\n                \"\"\".trimIndent()\n\n                val result = parser.decodeFromString(Container.serializer(), input)\n\n                it(\"deserializes it using the dynamically installed serializer\") {\n                    result shouldBe Container(Inner(\"thing: this is the input, from context serializer\"))\n                }\n            }\n        }\n\n        describe(\"parsing values with mismatched types\") {\n            data class Scenario(\n                val description: String,\n                val serializer: KSerializer<out Any?>,\n                val expectedErrorMessage: String = description,\n            )\n\n            context(\"given a list\") {\n                listOf(\n                    Scenario(\"a string\", String.serializer()),\n                    Scenario(\"an integer\", Int.serializer()),\n                    Scenario(\"a long\", Long.serializer()),\n                    Scenario(\"a short\", Short.serializer()),\n                    Scenario(\"a byte\", Byte.serializer()),\n                    Scenario(\"a double\", Double.serializer()),\n                    Scenario(\"a float\", Float.serializer()),\n                    Scenario(\"a boolean\", Boolean.serializer()),\n                    Scenario(\"a character\", Char.serializer()),\n                    Scenario(\"an enumeration value\", TestEnum.serializer()),\n                    Scenario(\"a map\", MapSerializer(String.serializer(), String.serializer())),\n                    Scenario(\"an object\", ComplexStructure.serializer()),\n                    Scenario(\"a nullable string\", String.serializer().nullable, \"a string\"),\n                ).forEach { (description, serializer, expectedErrorMessage) ->\n                    val input = \"- thing\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(serializer, input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Expected $expectedErrorMessage, but got a list\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key:\n                            - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'key' is invalid: Expected a string, but got a list\"\n                            it.line shouldBe 2\n                            it.column shouldBe 5\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        string:\n                            - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'string' is invalid: Expected a string, but got a list\"\n                            it.line shouldBe 2\n                            it.column shouldBe 5\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"string\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - [ some_value ]\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Expected a string, but got a list\"\n                            it.line shouldBe 1\n                            it.column shouldBe 3\n                            it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3))\n                        }\n                    }\n                }\n            }\n\n            context(\"given a map\") {\n                listOf(\n                    Scenario(\"a string\", String.serializer()),\n                    Scenario(\"an integer\", Int.serializer()),\n                    Scenario(\"a long\", Long.serializer()),\n                    Scenario(\"a short\", Short.serializer()),\n                    Scenario(\"a byte\", Byte.serializer()),\n                    Scenario(\"a double\", Double.serializer()),\n                    Scenario(\"a float\", Float.serializer()),\n                    Scenario(\"a boolean\", Boolean.serializer()),\n                    Scenario(\"a character\", Char.serializer()),\n                    Scenario(\"an enumeration value\", TestEnum.serializer()),\n                    Scenario(\"a list\", ListSerializer(String.serializer())),\n                    Scenario(\"a nullable string\", String.serializer().nullable, \"a string\"),\n                ).forEach { (description, serializer, expectedErrorMessage) ->\n                    val input = \"key: value\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(serializer, input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Expected $expectedErrorMessage, but got a map\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key:\n                            some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(MapSerializer(String.serializer(), String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'key' is invalid: Expected a string, but got a map\"\n                            it.line shouldBe 2\n                            it.column shouldBe 5\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        string:\n                            some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(ComplexStructure.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'string' is invalid: Expected a string, but got a map\"\n                            it.line shouldBe 2\n                            it.column shouldBe 5\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"string\", Location(1, 1)).withMapElementValue(Location(2, 5))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - some_key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ListSerializer(String.serializer()), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Expected a string, but got a map\"\n                            it.line shouldBe 1\n                            it.column shouldBe 3\n                            it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3))\n                        }\n                    }\n                }\n            }\n\n            context(\"given a scalar value\") {\n                mapOf(\n                    \"a list\" to ListSerializer(String.serializer()),\n                    \"a map\" to MapSerializer(String.serializer(), String.serializer()),\n                    \"an object\" to ComplexStructure.serializer(),\n                ).forEach { (description, serializer) ->\n                    val input = \"blah\"\n\n                    context(\"parsing that input as $description\") {\n                        it(\"throws an exception with the correct location information\") {\n                            val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(serializer, input) }\n\n                            exception.asClue {\n                                it.message shouldBe \"Expected $description, but got a scalar value\"\n                                it.line shouldBe 1\n                                it.column shouldBe 1\n                                it.path shouldBe YamlPath.root\n                            }\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a map\") {\n                    val input = \"\"\"\n                        key: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(MapSerializer(String.serializer(), ListSerializer(String.serializer())), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'key' is invalid: Expected a list, but got a scalar value\"\n                            it.line shouldBe 1\n                            it.column shouldBe 6\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"key\", Location(1, 1)).withMapElementValue(Location(1, 6))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in an object\") {\n                    val input = \"\"\"\n                        members: some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<InvalidPropertyValueException> { Yaml.default.decodeFromString(Team.serializer(), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Value for 'members' is invalid: Expected a list, but got a scalar value\"\n                            it.line shouldBe 1\n                            it.column shouldBe 10\n                            it.path shouldBe YamlPath.root.withMapElementKey(\"members\", Location(1, 1)).withMapElementValue(Location(1, 10))\n                        }\n                    }\n                }\n\n                context(\"parsing that input as the value in a list\") {\n                    val input = \"\"\"\n                        - some_value\n                    \"\"\".trimIndent()\n\n                    it(\"throws an exception with the correct location information\") {\n                        val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ListSerializer((ListSerializer(String.serializer()))), input) }\n\n                        exception.asClue {\n                            it.message shouldBe \"Expected a list, but got a scalar value\"\n                            it.line shouldBe 1\n                            it.column shouldBe 3\n                            it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3))\n                        }\n                    }\n                }\n            }\n        }\n\n        describe(\"parsing values with a contextual serializer\") {\n            mapOf(\n                \"scalar\" to \"2\",\n                \"list\" to \"[ thing ]\",\n                \"map\" to \"{ key: value }\",\n            ).forEach { (description, input) ->\n                context(\"given some input representing a $description\") {\n                    context(\"parsing that input using a contextual serializer at the top level\") {\n                        val result = Yaml.default.decodeFromString(ContextualSerializer, input)\n\n                        it(\"the serializer receives the top-level object\") {\n                            result shouldBe description\n                        }\n                    }\n\n                    context(\"parsing that input using a contextual serializer nested within an object\") {\n                        val result = Yaml.default.decodeFromString(ObjectWithNestedContextualSerializer.serializer(), \"thing: $input\")\n\n                        it(\"the serializer receives the correct object\") {\n                            result shouldBe ObjectWithNestedContextualSerializer(description)\n                        }\n                    }\n                }\n            }\n\n            describe(\"given the contextual serializer attempts to begin a structure that does not match the input\") {\n                context(\"given the input is a map\") {\n                    val input = \"a: b\"\n\n                    mapOf(\n                        PrimitiveKind.STRING to \"a string\",\n                        StructureKind.LIST to \"a list\",\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $description\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Expected $description, but got a map\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 1\n                                    it.path shouldBe YamlPath.root\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given the input is a list\") {\n                    val input = \"- a\"\n\n                    mapOf(\n                        StructureKind.OBJECT to \"an object\",\n                        StructureKind.CLASS to \"an object\",\n                        StructureKind.MAP to \"a map\",\n                        PrimitiveKind.STRING to \"a string\",\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $kind\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Expected $description, but got a list\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 1\n                                    it.path shouldBe YamlPath.root\n                                }\n                            }\n                        }\n                    }\n                }\n\n                context(\"given the input is a scalar\") {\n                    val input = \"2\"\n\n                    mapOf(\n                        StructureKind.OBJECT to \"an object\",\n                        StructureKind.CLASS to \"an object\",\n                        StructureKind.MAP to \"a map\",\n                        StructureKind.LIST to \"a list\",\n                    ).forEach { (kind, description) ->\n                        context(\"attempting to begin $kind\") {\n                            it(\"throws an exception with the correct location information\") {\n                                val exception = shouldThrow<IncorrectTypeException> { Yaml.default.decodeFromString(ContextualSerializerThatAttemptsToDeserializeIncorrectType(kind), input) }\n\n                                exception.asClue {\n                                    it.message shouldBe \"Expected $description, but got a scalar value\"\n                                    it.line shouldBe 1\n                                    it.column shouldBe 1\n                                    it.path shouldBe YamlPath.root\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            describe(\"decoding from a YamlNode\") {\n                val input = \"\"\"\n                    keyA:\n                        host: A\n                    keyB:\n                        host: B\n                \"\"\".trimIndent()\n\n                val mapAsListSerializer = object : KSerializer<List<Database>> {\n                    override val descriptor = buildSerialDescriptor(\"DatabaseList\", StructureKind.MAP) {\n                    }\n\n                    override fun deserialize(decoder: Decoder): List<Database> {\n                        check(decoder is YamlInput)\n                        return decoder.node.yamlMap.entries.map { (_, value) ->\n                            decoder.yaml.decodeFromYamlNode(Database.serializer(), value)\n                        }\n                    }\n\n                    override fun serialize(encoder: Encoder, value: List<Database>) = throw UnsupportedOperationException()\n                }\n\n                val parser = Yaml.default\n                val result = parser.decodeFromString(mapAsListSerializer, input)\n\n                it(\"decodes the map value as a list using the YamlNode\") {\n                    result shouldBe listOf(Database(\"A\"), Database(\"B\"))\n                }\n            }\n\n            describe(\"decoding from a YamlNode at a non-root node\") {\n                val input = \"\"\"\n                    databaseListing:\n                        keyA:\n                            host: A\n                        keyB:\n                            host: B\n                \"\"\".trimIndent()\n\n                val parser = Yaml.default\n                val result = parser.decodeFromString(ServerConfig.serializer(), input)\n\n                it(\"decodes the map value as a list using the YamlNode\") {\n                    result shouldBe ServerConfig(DatabaseListing(listOf(Database(\"A\"), Database(\"B\"))))\n                }\n            }\n        }\n    }\n})\n\n@Serializable\nprivate data class ComplexStructure(\n    val string: String,\n    val byte: Byte,\n    val short: Short,\n    val int: Int,\n    val long: Long,\n    val float: Float,\n    val double: Double,\n    val enum: TestEnum,\n    val boolean: Boolean,\n    val char: Char,\n    val nullable: String? = null,\n)\n\n@Serializable\nprivate data class StructureWithLocationThrowingSerializer(\n    @Suppress(\"SERIALIZER_TYPE_INCOMPATIBLE\")\n    @Serializable(with = LocationThrowingSerializer::class)\n    val value: CustomSerializedValue,\n)\n\nprivate data class CustomSerializedValue(val thing: String)\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nprivate object LocationThrowingSerializer : KSerializer<Any> {\n    override val descriptor = buildSerialDescriptor(LocationThrowingSerializer::class.qualifiedName!!, SerialKind.CONTEXTUAL)\n\n    override fun deserialize(decoder: Decoder): Any {\n        val location = (decoder as YamlInput).getCurrentLocation()\n        val path = decoder.getCurrentPath()\n\n        throw LocationInformationException(\"Serializer called with location (${location.line}, ${location.column}) and path: ${path.toHumanReadableString()}\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Any) = throw UnsupportedOperationException()\n}\n\nprivate object LocationThrowingMapSerializer : KSerializer<Any> {\n    override val descriptor: SerialDescriptor = MapSerializer(String.serializer(), String.serializer()).descriptor\n\n    override fun deserialize(decoder: Decoder): Any {\n        val location = (decoder as YamlInput).getCurrentLocation()\n        val path = decoder.getCurrentPath()\n\n        throw LocationInformationException(\"Serializer called with location (${location.line}, ${location.column}) and path: ${path.toHumanReadableString()}\")\n    }\n\n    override fun serialize(encoder: Encoder, value: Any) = throw UnsupportedOperationException()\n}\n\nprivate class LocationInformationException(message: String) : RuntimeException(message)\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nobject ContextualSerializer : KSerializer<String> {\n    override val descriptor = buildSerialDescriptor(\"ContextualSerializer\", SerialKind.CONTEXTUAL) {\n        element(\"string\", PrimitiveSerialDescriptor(\"value\", PrimitiveKind.STRING))\n        element(\"object\", buildSerialDescriptor(\"thing\", StructureKind.OBJECT))\n    }\n\n    override fun deserialize(decoder: Decoder): String {\n        val input = decoder.beginStructure(descriptor) as YamlInput\n        val type = input.node::class.simpleName!!\n        input.endStructure(descriptor)\n\n        return type.removePrefix(\"Yaml\").lowercase()\n    }\n\n    override fun serialize(encoder: Encoder, value: String): Unit = throw UnsupportedOperationException()\n}\n\n@OptIn(InternalSerializationApi::class, ExperimentalSerializationApi::class)\nclass ContextualSerializerThatAttemptsToDeserializeIncorrectType(private val kind: SerialKind) : KSerializer<String> {\n    private val innerDescriptor = if (kind == StructureKind.CLASS) buildClassSerialDescriptor(\"thing\") else buildSerialDescriptor(\"thing\", kind)\n\n    override val descriptor = buildSerialDescriptor(\"ContextualSerializer\", SerialKind.CONTEXTUAL) {\n        element(\"string\", PrimitiveSerialDescriptor(\"value\", PrimitiveKind.STRING))\n        element(\"object\", innerDescriptor)\n    }\n\n    override fun deserialize(decoder: Decoder): String {\n        val input = decoder.beginStructure(descriptor) as YamlInput\n\n        input.beginStructure(innerDescriptor)\n\n        return \"Should never get to this point\"\n    }\n\n    override fun serialize(encoder: Encoder, value: String): Unit = throw UnsupportedOperationException()\n}\n\n// FIXME: ideally these would just be inline in the test cases that need them, but due to\n// https://github.com/Kotlin/kotlinx.serialization/issues/1427, this is no longer possible with\n// kotlinx.serialization 1.2 and above.\n// See also https://github.com/Kotlin/kotlinx.serialization/issues/1468.\n\n@Serializable\nprivate data class NullableNestedObject(val firstPerson: SimpleStructure?)\n\n@Serializable\ndata class NullableNestedList(val members: List<String>?)\n\n@Serializable\nprivate data class Database(val host: String)\n\n@Serializable(with = DecodingFromYamlNodeSerializer::class)\nprivate data class DatabaseListing(val databases: List<Database>)\n\n@Serializable\nprivate data class ServerConfig(val databaseListing: DatabaseListing)\n\nprivate data class Inner(val name: String)\n\n@Serializable\nprivate data class Container(@Contextual val inner: Inner)\n\n@Serializable\nprivate data class ObjectWithNestedContextualSerializer(@Serializable(with = ContextualSerializer::class) val thing: String)\n\n@Serializable\n@JvmInline\nvalue class StringValue(val value: String)\n\nprivate object DecodingFromYamlNodeSerializer : KSerializer<DatabaseListing> {\n    override val descriptor: SerialDescriptor = buildSerialDescriptor(\"DecodingFromYamlNodeSerializer\", StructureKind.MAP)\n\n    override fun deserialize(decoder: Decoder): DatabaseListing {\n        check(decoder is YamlInput)\n\n        val currentMap = decoder.node.yamlMap.get<YamlMap>(\"databaseListing\")\n        checkNotNull(currentMap)\n\n        val list = currentMap.entries.map { (_, value) ->\n            decoder.yaml.decodeFromYamlNode(Database.serializer(), value)\n        }\n\n        return DatabaseListing(list)\n    }\n\n    override fun serialize(encoder: Encoder, value: DatabaseListing) = throw UnsupportedOperationException()\n}\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\nimport kotlinx.serialization.DeserializationStrategy\nimport kotlinx.serialization.SerializationStrategy\nimport kotlinx.serialization.StringFormat\nimport kotlinx.serialization.modules.EmptySerializersModule\nimport kotlinx.serialization.modules.SerializersModule\nimport kotlinx.serialization.serializer\nimport org.snakeyaml.engine.v2.api.StreamDataWriter\nimport org.snakeyaml.engine.v2.api.YamlOutputStreamWriter\nimport java.io.IOException\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.io.OutputStream\nimport java.io.Reader\nimport java.io.StringReader\nimport java.io.StringWriter\nimport java.nio.charset.Charset\n\npublic actual class Yaml(\n    override val serializersModule: SerializersModule = EmptySerializersModule(),\n    public actual val configuration: YamlConfiguration = YamlConfiguration(),\n) : StringFormat {\n    override fun <T> decodeFromString(deserializer: DeserializationStrategy<T>, string: String): T {\n        return decodeFromReader(deserializer, StringReader(string))\n    }\n\n    public fun <T> decodeFromStream(deserializer: DeserializationStrategy<T>, source: InputStream, charset: Charset = Charsets.UTF_8): T {\n        return decodeFromReader(deserializer, InputStreamReader(source, charset))\n    }\n\n    private fun <T> decodeFromReader(deserializer: DeserializationStrategy<T>, source: Reader): T {\n        val rootNode = parseToYamlNodeFromReader(source)\n\n        val input = YamlInput.createFor(rootNode, this, serializersModule, configuration, deserializer.descriptor)\n        return input.decodeSerializableValue(deserializer)\n    }\n\n    public fun parseToYamlNode(string: String): YamlNode = parseToYamlNodeFromReader(StringReader(string))\n\n    public fun parseToYamlNode(source: InputStream): YamlNode = parseToYamlNodeFromReader(InputStreamReader(source))\n\n    private fun parseToYamlNodeFromReader(source: Reader): YamlNode {\n        val parser = YamlParser(source)\n        val reader = YamlNodeReader(parser, configuration.extensionDefinitionPrefix, configuration.allowAnchorsAndAliases)\n        val node = reader.read()\n        parser.ensureEndOfStreamReached()\n        return node\n    }\n\n    public actual fun <T> decodeFromYamlNode(deserializer: DeserializationStrategy<T>, node: YamlNode): T {\n        val input = YamlInput.createFor(node, this, serializersModule, configuration, deserializer.descriptor)\n        return input.decodeSerializableValue(deserializer)\n    }\n\n    override fun <T> encodeToString(serializer: SerializationStrategy<T>, value: T): String {\n        val writer = object : StringWriter(), StreamDataWriter {\n            override fun flush() { }\n        }\n\n        encodeToStreamDataWriter(serializer, value, writer)\n\n        return writer.toString().trimEnd()\n    }\n\n    public fun <T> encodeToStream(serializer: SerializationStrategy<T>, value: T, stream: OutputStream, charset: Charset = Charsets.UTF_8) {\n        val writer = object : YamlOutputStreamWriter(stream, charset) {\n            override fun processIOException(e: IOException?) {\n                if (e != null) {\n                    throw e\n                }\n            }\n        }\n\n        encodeToStreamDataWriter(serializer, value, writer)\n    }\n\n    private fun <T> encodeToStreamDataWriter(serializer: SerializationStrategy<T>, value: T, writer: StreamDataWriter) {\n        YamlOutput(writer, serializersModule, configuration).use { output ->\n            output.encodeSerializableValue(serializer, value)\n        }\n    }\n\n    public actual companion object {\n        public actual val default: Yaml = Yaml()\n    }\n}\n\n/**\n * Decodes and deserializes from the given [stream] to the value of type [T] using the\n * deserializer retrieved from the reified type parameter.\n */\npublic inline fun <reified T> Yaml.decodeFromStream(stream: InputStream): T =\n    decodeFromStream(serializersModule.serializer(), stream)\n\n/**\n * Serializes and encodes the given [value] to the given [stream] using the serializer\n * retrieved from the reified type parameter.\n */\npublic inline fun <reified T> Yaml.encodeToStream(value: T, stream: OutputStream) {\n    encodeToStream(serializersModule.serializer(), value, stream)\n}\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\npackage com.charleskorn.kaml\n\nimport org.snakeyaml.engine.v2.common.Anchor\nimport org.snakeyaml.engine.v2.events.AliasEvent\nimport org.snakeyaml.engine.v2.events.Event\nimport org.snakeyaml.engine.v2.events.MappingStartEvent\nimport org.snakeyaml.engine.v2.events.NodeEvent\nimport org.snakeyaml.engine.v2.events.ScalarEvent\nimport org.snakeyaml.engine.v2.events.SequenceStartEvent\nimport java.util.Optional\n\ninternal actual class YamlNodeReader(\n    private val parser: YamlParser,\n    private val extensionDefinitionPrefix: String? = null,\n    private val allowAnchorsAndAliases: Boolean = false,\n) {\n    private val aliases = mutableMapOf<Anchor, YamlNode>()\n\n    actual fun read(): YamlNode = readNode(YamlPath.root)\n\n    private fun readNode(path: YamlPath): YamlNode = readNodeAndAnchor(path).first\n\n    private fun readNodeAndAnchor(path: YamlPath): Pair<YamlNode, Anchor?> {\n        val event = parser.consumeEvent(path)\n        val node = readFromEvent(event, path)\n\n        if (event is NodeEvent) {\n            event.anchor.ifPresent {\n                if (!allowAnchorsAndAliases) {\n                    throw ForbiddenAnchorOrAliasException(\"Parsing anchors and aliases is disabled.\", path)\n                }\n\n                aliases.put(it, node.withPath(YamlPath.forAliasDefinition(it.value, event.location)))\n            }\n\n            return node to event.anchor.orElse(null)\n        }\n\n        return node to null\n    }\n\n    private fun readFromEvent(event: Event, path: YamlPath): YamlNode = when (event) {\n        is ScalarEvent -> readScalarOrNull(event, path).maybeToTaggedNode(event.tag)\n        is SequenceStartEvent -> readSequence(path).maybeToTaggedNode(event.tag)\n        is MappingStartEvent -> readMapping(path).maybeToTaggedNode(event.tag)\n        is AliasEvent -> readAlias(event, path)\n        else -> throw MalformedYamlException(\"Unexpected ${event.eventId}\", path.withError(event.location))\n    }\n\n    private fun readScalarOrNull(event: ScalarEvent, path: YamlPath): YamlNode {\n        if ((event.value == \"null\" || event.value == \"\" || event.value == \"~\") && event.isPlain) {\n            return YamlNull(path)\n        } else {\n            return YamlScalar(event.value, path)\n        }\n    }\n\n    private fun readSequence(path: YamlPath): YamlList {\n        val items = mutableListOf<YamlNode>()\n\n        while (true) {\n            val event = parser.peekEvent(path)\n\n            when (event.eventId) {\n                Event.ID.SequenceEnd -> {\n                    parser.consumeEventOfType(Event.ID.SequenceEnd, path)\n                    return YamlList(items, path)\n                }\n\n                else -> items += readNode(path.withListEntry(items.size, event.location))\n            }\n        }\n    }\n\n    private fun readMapping(path: YamlPath): YamlMap {\n        val items = mutableMapOf<YamlScalar, YamlNode>()\n\n        while (true) {\n            val event = parser.peekEvent(path)\n\n            when (event.eventId) {\n                Event.ID.MappingEnd -> {\n                    parser.consumeEventOfType(Event.ID.MappingEnd, path)\n                    return YamlMap(doMerges(items), path)\n                }\n\n                else -> {\n                    val keyLocation = parser.peekEvent(path).location\n                    val key = readMapKey(path)\n                    val keyNode = YamlScalar(key, path.withMapElementKey(key, keyLocation))\n\n                    val valueLocation = parser.peekEvent(keyNode.path).location\n                    val valuePath = if (isMerge(keyNode)) path.withMerge(valueLocation) else keyNode.path.withMapElementValue(valueLocation)\n                    val (value, anchor) = readNodeAndAnchor(valuePath)\n\n                    if (path == YamlPath.root && extensionDefinitionPrefix != null && key.startsWith(extensionDefinitionPrefix)) {\n                        if (anchor == null) {\n                            throw NoAnchorForExtensionException(key, extensionDefinitionPrefix, path.withError(event.location))\n                        }\n                    } else {\n                        items += (keyNode to value)\n                    }\n                }\n            }\n        }\n    }\n\n    private fun readMapKey(path: YamlPath): String {\n        val event = parser.peekEvent(path)\n\n        when (event.eventId) {\n            Event.ID.Scalar -> {\n                parser.consumeEventOfType(Event.ID.Scalar, path)\n                val scalarEvent = event as ScalarEvent\n                val isNullKey = (scalarEvent.value == \"null\" || scalarEvent.value == \"~\") && scalarEvent.isPlain\n\n                if (scalarEvent.tag.isPresent || isNullKey) {\n                    throw nonScalarMapKeyException(path, event)\n                }\n\n                return scalarEvent.value\n            }\n            else -> throw nonScalarMapKeyException(path, event)\n        }\n    }\n\n    private fun nonScalarMapKeyException(path: YamlPath, event: Event) = MalformedYamlException(\"Property name must not be a list, map, null or tagged value. (To use 'null' as a property name, enclose it in quotes.)\", path.withError(event.location))\n\n    private fun YamlNode.maybeToTaggedNode(tag: Optional<String>): YamlNode =\n        tag.map<YamlNode> { YamlTaggedNode(it, this) }.orElse(this)\n\n    private fun doMerges(items: Map<YamlScalar, YamlNode>): Map<YamlScalar, YamlNode> {\n        val mergeEntries = items.entries.filter { (key, _) -> isMerge(key) }\n\n        when (mergeEntries.count()) {\n            0 -> return items\n            1 -> when (val mappingsToMerge = mergeEntries.single().value) {\n                is YamlList -> return doMerges(items, mappingsToMerge.items)\n                else -> return doMerges(items, listOf(mappingsToMerge))\n            }\n            else -> throw MalformedYamlException(\"Cannot perform multiple '<<' merges into a map. Instead, combine all merges into a single '<<' entry.\", mergeEntries.second().key.path)\n        }\n    }\n\n    private fun isMerge(key: YamlNode): Boolean = key is YamlScalar && key.content == \"<<\"\n\n    private fun doMerges(original: Map<YamlScalar, YamlNode>, others: List<YamlNode>): Map<YamlScalar, YamlNode> {\n        val merged = mutableMapOf<YamlScalar, YamlNode>()\n\n        original\n            .filterNot { (key, _) -> isMerge(key) }\n            .forEach { (key, value) -> merged.put(key, value) }\n\n        others\n            .forEach { other ->\n                when (other) {\n                    is YamlNull -> throw MalformedYamlException(\"Cannot merge a null value into a map.\", other.path)\n                    is YamlScalar -> throw MalformedYamlException(\"Cannot merge a scalar value into a map.\", other.path)\n                    is YamlList -> throw MalformedYamlException(\"Cannot merge a list value into a map.\", other.path)\n                    is YamlTaggedNode -> throw MalformedYamlException(\"Cannot merge a tagged value into a map.\", other.path)\n                    is YamlMap ->\n                        other.entries.forEach { (key, value) ->\n                            val existingEntry = merged.entries.singleOrNull { it.key.equivalentContentTo(key) }\n\n                            if (existingEntry == null) {\n                                merged.put(key, value)\n                            }\n                        }\n                }\n            }\n\n        return merged\n    }\n\n    private fun readAlias(event: AliasEvent, path: YamlPath): YamlNode {\n        if (!allowAnchorsAndAliases) {\n            throw ForbiddenAnchorOrAliasException(\"Parsing anchors and aliases is disabled.\", path)\n        }\n\n        val anchor = event.anchor.get()\n\n        val resolvedNode = aliases.getOrElse(anchor) {\n            throw UnknownAnchorException(anchor.value, path.withError(event.location))\n        }\n\n        return resolvedNode.withPath(path.withAliasReference(anchor.value, event.location).withAliasDefinition(anchor.value, resolvedNode.location))\n    }\n\n    private fun <T> Iterable<T>.second(): T = this.drop(1).first()\n\n    private val Event.location: Location\n        get() = Location(startMark.get().line + 1, startMark.get().column + 1)\n}\n", "/*\n\n   Copyright 2018-2021 Charles Korn.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n@file:Suppress(\"MoveLambdaOutsideParentheses\")\n\npackage com.charleskorn.kaml\n\nimport io.kotest.assertions.asClue\nimport io.kotest.assertions.throwables.shouldNotThrowAny\nimport io.kotest.assertions.throwables.shouldThrow\nimport io.kotest.core.spec.style.DescribeSpec\nimport io.kotest.matchers.shouldBe\n\nclass YamlNodeReaderTest : DescribeSpec({\n    describe(\"a YAML node reader\") {\n        mapOf(\n            \"hello\" to \"hello\",\n            \"12\" to \"12\",\n            \"\"\"\"hello\"\"\"\" to \"hello\",\n            \"'hello'\" to \"hello\",\n            \"'he''llo'\" to \"he'llo\",\n            \"\"\"\"hello\\\"\"\"\"\" to \"\"\"hello\"\"\"\",\n            \"\"\"\"\\\"hello\"\"\"\" to \"\"\"\"hello\"\"\",\n            \"\"\"\"he\\\"llo\"\"\"\" to \"\"\"he\"llo\"\"\",\n            \"\"\"\"he\\\"\\\"llo\"\"\"\" to \"\"\"he\"\"llo\"\"\",\n            \"\"\"\"hello\\n\"\"\"\" to \"hello\\n\",\n            // Sample from http://yaml.org/spec/1.2/spec.html#escaping/in%20double-quoted%20scalars/\n            \"\"\"\"Fun with \\\\ \\\" \\a \\b \\e \\f \\n \\r \\t \\v \\0 \\  \\_ \\N \\L \\P \\x41 \\u0041 \\U00000041\"\"\"\" to \"Fun with \\u005C \\u0022 \\u0007 \\u0008 \\u001B \\u000C \\u000A \\u000D \\u0009 \\u000B \\u0000 \\u0020 \\u00A0 \\u0085 \\u2028 \\u2029 A A A\",\n            \"''\" to \"\",\n            \"\"\"\"\"\"\"\" to \"\",\n            \"'null'\" to \"null\",\n            \"\"\"\"null\"\"\"\" to \"null\",\n            \"'~'\" to \"~\",\n            \"\"\"\"~\"\"\"\" to \"~\",\n        ).forEach { (input, expectedResult) ->\n            context(\"given the string '$input'\") {\n                describe(\"parsing that input\") {\n                    val parser = YamlParser(input)\n                    val result = YamlNodeReader(parser).read()\n\n                    it(\"returns the expected scalar value\") {\n                        result shouldBe YamlScalar(expectedResult, YamlPath.root)\n                    }\n                }\n            }\n        }\n\n        // https://yaml.org/spec/1.2/spec.html#id2793979 is useful reference here, as is\n        // https://yaml-multiline.info/\n        mapOf(\n            \"\"\"\n                |thing: |\n                |  line 1\n                |  line 2\n                |\n            \"\"\".trimMargin() to \"line 1\\nline 2\\n\",\n            \"\"\"\n                |thing: >\n                |  some\n                |  text\n                |\n            \"\"\".trimMargin() to \"some text\\n\",\n\n            // Preserve consecutive blank lines when literal\n            \"\"\"\n                |thing: |\n                |  some\n                |\n                |  text\n                |\n            \"\"\".trimMargin() to \"some\\n\\ntext\\n\",\n\n            // Don't preserve consecutive blank lines when folded\n            \"\"\"\n                |thing: >\n                |  some\n                |\n                |  text\n                |\n            \"\"\".trimMargin() to \"some\\ntext\\n\",\n\n            // No chomping indicator - default behaviour is to clip, so retain trailing new line but not blank lines\n            \"\"\"\n                |thing: |\n                |  line 1\n                |  line 2\n                |\n                |\n            \"\"\".trimMargin() to \"line 1\\nline 2\\n\",\n            \"\"\"\n                |thing: >\n                |  some\n                |  text\n                |\n                |\n            \"\"\".trimMargin() to \"some text\\n\",\n\n            // Indentation indicator\n            \"\"\"\n                |thing: |1\n                |  line 1\n                |  line 2\n                |\n            \"\"\".trimMargin() to \" line 1\\n line 2\\n\",\n            \"\"\"\n                |thing: >1\n                |  some\n                |  text\n                | here\n                | there\n                |\n            \"\"\".trimMargin() to \" some\\n text\\nhere there\\n\",\n\n            // 'Strip' chomping indicator - remove all trailing new lines\n            \"\"\"\n                |thing: |-\n                |  line 1\n                |  line 2\n                |\n            \"\"\".trimMargin() to \"line 1\\nline 2\",\n            \"\"\"\n                |thing: >-\n                |  some\n                |  text\n                |\n            \"\"\".trimMargin() to \"some text\",\n\n            // 'Keep' chomping indicator - keep all trailing new lines\n            \"\"\"\n                |thing: |+\n                |  line 1\n                |  line 2\n                |\n                |\n            \"\"\".trimMargin() to \"line 1\\nline 2\\n\\n\",\n            \"\"\"\n                |thing: >+\n                |  some\n                |  text\n                |\n                |\n            \"\"\".trimMargin() to \"some text\\n\\n\",\n\n            // Chomping indicator with indentation indicator\n            \"\"\"\n                |thing: |-1\n                |  line 1\n                |  line 2\n                |\n            \"\"\".trimMargin() to \" line 1\\n line 2\",\n            \"\"\"\n                |thing: >-1\n                |  some\n                |  text\n                | here\n                | there\n                |\n            \"\"\".trimMargin() to \" some\\n text\\nhere there\",\n            \"\"\"\n                |thing: |+1\n                |  line 1\n                |  line 2\n                |\n                |\n            \"\"\".trimMargin() to \" line 1\\n line 2\\n\\n\",\n            \"\"\"\n                |thing: >+1\n                |  some\n                |  text\n                | here\n                | there\n                |\n                |\n            \"\"\".trimMargin() to \" some\\n text\\nhere there\\n\\n\",\n        ).forEach { (input, text) ->\n            context(\"given the block scalar '${input.replace(\"\\n\", \"\\\\n\")}'\") {\n                describe(\"parsing that input\") {\n                    val parser = YamlParser(input)\n                    val result = YamlNodeReader(parser).read()\n\n                    val keyPath = YamlPath.root.withMapElementKey(\"thing\", Location(1, 1))\n                    val valuePath = keyPath.withMapElementValue(Location(1, 8))\n\n                    it(\"returns the expected multi-line text value\") {\n                        result shouldBe\n                            YamlMap(\n                                mapOf(\n                                    YamlScalar(\"thing\", keyPath) to YamlScalar(text, valuePath),\n                                ),\n                                YamlPath.root,\n                            )\n                    }\n                }\n            }\n        }\n\n        mapOf(\n            \"given a double-quoted string without a trailing double quote\" to \"\"\"\"hello\"\"\",\n            \"given a single-quoted string without a trailing single quote\" to \"'hello\",\n        ).forEach { (description, input) ->\n            context(description) {\n                describe(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<MalformedYamlException> {\n                            val parser = YamlParser(input)\n                            YamlNodeReader(parser).read()\n                        }\n\n                        exception.asClue {\n                            it.message shouldBe\n                                \"\"\"\n                                        while scanning a quoted scalar\n                                         at line 1, column 1:\n                                            $input\n                                            ^\n                                        found unexpected end of stream\n                                         at line 1, column 7:\n                                            $input\n                                                  ^\n                                \"\"\".trimIndent()\n\n                            it.line shouldBe 1\n                            it.column shouldBe 7\n                            it.path shouldBe YamlPath.root.withError(Location(1, 7))\n                        }\n                    }\n                }\n            }\n        }\n\n        context(\"given a flow-style list without a trailing closing bracket\") {\n            val input = \"[thing\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                    while parsing a flow sequence\n                                     at line 1, column 1:\n                                        [thing\n                                        ^\n                                    expected ',' or ']', but got <stream end>\n                                     at line 1, column 7:\n                                        [thing\n                                              ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 1\n                        it.column shouldBe 7\n                        it.path shouldBe YamlPath.root.withError(Location(1, 7))\n                    }\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings\") {\n            val input = \"\"\"\n                - thing1\n                - thing2\n                - \"thing3\"\n                - 'thing4'\n                - \"thing\\\"5\"\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(0, Location(1, 3))),\n                                YamlScalar(\"thing2\", YamlPath.root.withListEntry(1, Location(2, 3))),\n                                YamlScalar(\"thing3\", YamlPath.root.withListEntry(2, Location(3, 3))),\n                                YamlScalar(\"thing4\", YamlPath.root.withListEntry(3, Location(4, 3))),\n                                YamlScalar(\"thing\\\"5\", YamlPath.root.withListEntry(4, Location(5, 3))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings with an alias and anchor present\") {\n            val input = \"\"\"\n                - &thing thing1\n                - thing2\n                - *thing\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, allowAnchorsAndAliases = true).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(0, Location(1, 3))),\n                                YamlScalar(\"thing2\", YamlPath.root.withListEntry(1, Location(2, 3))),\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(2, Location(3, 3)).withAliasReference(\"thing\", Location(3, 3)).withAliasDefinition(\"thing\", Location(1, 3))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings with an alias that is redefined\") {\n            val input = \"\"\"\n                - &thing thing1\n                - thing2\n                - *thing\n                - &thing thing3\n                - *thing\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, allowAnchorsAndAliases = true).read()\n\n                it(\"returns the expected list, using the most-recently defined value each time the alias is referenced\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(0, Location(1, 3))),\n                                YamlScalar(\"thing2\", YamlPath.root.withListEntry(1, Location(2, 3))),\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(2, Location(3, 3)).withAliasReference(\"thing\", Location(3, 3)).withAliasDefinition(\"thing\", Location(1, 3))),\n                                YamlScalar(\"thing3\", YamlPath.root.withListEntry(3, Location(4, 3))),\n                                YamlScalar(\"thing3\", YamlPath.root.withListEntry(4, Location(5, 3)).withAliasReference(\"thing\", Location(5, 3)).withAliasDefinition(\"thing\", Location(4, 3))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings with a reference to a non-existent anchor\") {\n            val input = \"\"\"\n                - thing2\n                - *thing\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input with anchor and alias parsing enabled\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<UnknownAnchorException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser, allowAnchorsAndAliases = true).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Unknown anchor 'thing'.\"\n                        it.line shouldBe 2\n                        it.column shouldBe 3\n                        it.path shouldBe YamlPath.root.withListEntry(1, Location(2, 3)).withError(Location(2, 3))\n                    }\n                }\n            }\n\n            describe(\"parsing that input with anchor and alias parsing disabled\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<ForbiddenAnchorOrAliasException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser, allowAnchorsAndAliases = false).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Parsing anchors and aliases is disabled.\"\n                        it.line shouldBe 2\n                        it.column shouldBe 3\n                    }\n                }\n            }\n        }\n\n        context(\"given some input representing a list of strings in flow style\") {\n            val input = \"\"\"[thing1, thing2, \"thing3\", 'thing4', \"thing\\\"5\"]\"\"\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlScalar(\"thing1\", YamlPath.root.withListEntry(0, Location(1, 2))),\n                                YamlScalar(\"thing2\", YamlPath.root.withListEntry(1, Location(1, 10))),\n                                YamlScalar(\"thing3\", YamlPath.root.withListEntry(2, Location(1, 18))),\n                                YamlScalar(\"thing4\", YamlPath.root.withListEntry(3, Location(1, 28))),\n                                YamlScalar(\"thing\\\"5\", YamlPath.root.withListEntry(4, Location(1, 38))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given some input representing an empty list of strings in flow style\") {\n            val input = \"[]\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns an empty list\") {\n                    result shouldBe YamlList(emptyList(), YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a nested list given with both the inner and outer lists given in flow style with no elements\") {\n            val input = \"[[], []]\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlList(emptyList(), YamlPath.root.withListEntry(0, Location(1, 2))),\n                                YamlList(emptyList(), YamlPath.root.withListEntry(1, Location(1, 6))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a nested list given with the outer list in non-flow style and the inner lists in flow style with no elements\") {\n            val input = \"\"\"\n                - []\n                - []\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlList(emptyList(), YamlPath.root.withListEntry(0, Location(1, 3))),\n                                YamlList(emptyList(), YamlPath.root.withListEntry(1, Location(2, 3))),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a nested list given with the outer list in non-flow style and the inner lists in both non-flow and flow styles with some elements\") {\n            val input = \"\"\"\n                - [thing1, thing2]\n                -\n                    - thing3\n                    - thing4\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                val firstListPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val secondListPath = YamlPath.root.withListEntry(1, Location(3, 5))\n\n                it(\"returns the expected list\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlList(\n                                    listOf(\n                                        YamlScalar(\"thing1\", firstListPath.withListEntry(0, Location(1, 4))),\n                                        YamlScalar(\"thing2\", firstListPath.withListEntry(1, Location(1, 12))),\n                                    ),\n                                    firstListPath,\n                                ),\n                                YamlList(\n                                    listOf(\n                                        YamlScalar(\"thing3\", secondListPath.withListEntry(0, Location(3, 7))),\n                                        YamlScalar(\"thing4\", secondListPath.withListEntry(1, Location(4, 7))),\n                                    ),\n                                    secondListPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        listOf(\n            \"-\",\n            \"- \",\n        ).forEach { input ->\n            context(\"given a list with a single null entry in the format '$input'\") {\n                describe(\"parsing that input\") {\n                    val parser = YamlParser(input)\n                    val result = YamlNodeReader(parser).read()\n\n                    it(\"returns a list with a single null entry\") {\n                        result shouldBe\n                            YamlList(\n                                listOf(\n                                    YamlNull(YamlPath.root.withListEntry(0, Location(1, 2))),\n                                ),\n                                YamlPath.root,\n                            )\n                    }\n                }\n            }\n        }\n\n        context(\"given the string 'null'\") {\n            val input = \"null\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns a single null entry\") {\n                    result shouldBe YamlNull(YamlPath.root)\n                }\n            }\n        }\n\n        // See https://github.com/charleskorn/kaml/issues/149.\n        context(\"given the string '~'\") {\n            val input = \"~\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns a single null entry\") {\n                    result shouldBe YamlNull(YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a single key-value pair\") {\n            val input = \"key: value\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val keyPath = YamlPath.root.withMapElementKey(\"key\", Location(1, 1))\n                val valuePath = keyPath.withMapElementValue(Location(1, 6))\n\n                it(\"returns a map with a single key-value pair\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key\", keyPath) to YamlScalar(\"value\", valuePath),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a single key-value pair with a null value\") {\n            val input = \"key:\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val keyPath = YamlPath.root.withMapElementKey(\"key\", Location(1, 1))\n                val valuePath = keyPath.withMapElementValue(Location(1, 5))\n\n                it(\"returns a map with a single key-value pair with a null value\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key\", keyPath) to YamlNull(valuePath),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with two key-value pairs\") {\n            val input = \"\"\"\n                key1: value1\n                key2: value2\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 1))\n                val value1Path = key1Path.withMapElementValue(Location(1, 7))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(2, 1))\n                val value2Path = key2Path.withMapElementValue(Location(2, 7))\n\n                it(\"returns a map with two key-value pairs\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", value1Path),\n                                YamlScalar(\"key2\", key2Path) to YamlScalar(\"value2\", value2Path),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with two key-value pairs, one of which has a null value\") {\n            val input = \"\"\"\n                key1: value1\n                key2:\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 1))\n                val value1Path = key1Path.withMapElementValue(Location(1, 7))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(2, 1))\n                val value2Path = key2Path.withMapElementValue(Location(2, 6))\n\n                it(\"returns a map with two key-value pairs\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", value1Path),\n                                YamlScalar(\"key2\", key2Path) to YamlNull(value2Path),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with two key-value pairs, one of which has a reference to the other\") {\n            val input = \"\"\"\n                key1: &value value1\n                key2: *value\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, allowAnchorsAndAliases = true).read()\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 1))\n                val value1Path = key1Path.withMapElementValue(Location(1, 7))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(2, 1))\n                val value2Path = key2Path.withMapElementValue(Location(2, 7)).withAliasReference(\"value\", Location(2, 7)).withAliasDefinition(\"value\", Location(1, 7))\n\n                it(\"returns a map with two key-value pairs\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", value1Path),\n                                YamlScalar(\"key2\", key2Path) to YamlScalar(\"value1\", value2Path),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with nested values\") {\n            val input = \"\"\"\n                key1: value1\n                key2: value2\n                key3:\n                  - listitem1\n                  - listitem2\n                  - thing: value\n                key4: [something]\n                key5:\n                  inner: othervalue\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 1))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(2, 1))\n                val key3Path = YamlPath.root.withMapElementKey(\"key3\", Location(3, 1))\n                val value3Path = key3Path.withMapElementValue(Location(4, 3))\n                val thingPath = value3Path.withListEntry(2, Location(6, 5)).withMapElementKey(\"thing\", Location(6, 5))\n                val key4Path = YamlPath.root.withMapElementKey(\"key4\", Location(7, 1))\n                val value4Path = key4Path.withMapElementValue(Location(7, 7))\n                val key5Path = YamlPath.root.withMapElementKey(\"key5\", Location(8, 1))\n                val value5Path = key5Path.withMapElementValue(Location(9, 3))\n                val innerPath = value5Path.withMapElementKey(\"inner\", Location(9, 3))\n\n                it(\"returns a map with all expected key-value pairs\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", key1Path.withMapElementValue(Location(1, 7))),\n                                YamlScalar(\"key2\", key2Path) to YamlScalar(\"value2\", key2Path.withMapElementValue(Location(2, 7))),\n                                YamlScalar(\"key3\", key3Path) to YamlList(\n                                    listOf(\n                                        YamlScalar(\"listitem1\", value3Path.withListEntry(0, Location(4, 5))),\n                                        YamlScalar(\"listitem2\", value3Path.withListEntry(1, Location(5, 5))),\n                                        YamlMap(\n                                            mapOf(\n                                                YamlScalar(\"thing\", thingPath) to YamlScalar(\"value\", thingPath.withMapElementValue(Location(6, 12))),\n                                            ),\n                                            value3Path.withListEntry(2, Location(6, 5)),\n                                        ),\n                                    ),\n                                    value3Path,\n                                ),\n                                YamlScalar(\"key4\", key4Path) to YamlList(\n                                    listOf(\n                                        YamlScalar(\"something\", value4Path.withListEntry(0, Location(7, 8))),\n                                    ),\n                                    value4Path,\n                                ),\n                                YamlScalar(\"key5\", key5Path) to YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"inner\", innerPath) to YamlScalar(\"othervalue\", innerPath.withMapElementValue(Location(9, 10))),\n                                    ),\n                                    value5Path,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        mapOf(\n            \"null\" to \"null value\",\n            \"~\" to \"shorthand null value\",\n            \"[]\" to \"list\",\n            \"{}\" to \"map\",\n            \"!thing hello\" to \"tagged value\",\n        ).forEach { (value, description) ->\n            context(\"given a map with a $description for a key\") {\n                val input = \"\"\"\n                    key: value\n                    $value: something\n                \"\"\".trimIndent()\n\n                describe(\"parsing that input\") {\n                    it(\"throws an appropriate exception\") {\n                        val exception = shouldThrow<MalformedYamlException> {\n                            val parser = YamlParser(input)\n                            YamlNodeReader(parser).read()\n                        }\n\n                        exception.asClue {\n                            it.message shouldBe \"Property name must not be a list, map, null or tagged value. (To use 'null' as a property name, enclose it in quotes.)\"\n                            it.line shouldBe 2\n                            it.column shouldBe 1\n                            it.path shouldBe YamlPath.root.withError(Location(2, 1))\n                        }\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with the the word 'null' as a key in quotes\") {\n            val input = \"\"\"\n                key: value\n                \"null\": something\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"does not throw an exception\") {\n                    shouldNotThrowAny {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with the the value '~' as a key in quotes\") {\n            val input = \"\"\"\n                key: value\n                \"~\": something\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"does not throw an exception\") {\n                    shouldNotThrowAny {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n                }\n            }\n        }\n\n        context(\"given a key-value pair with extra indentation\") {\n            val input = \"\"\"\n                thing:\n                  key1: value1\n                   key2: value2\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                mapping values are not allowed here (is the indentation level of this line or a line nearby incorrect?)\n                                 at line 3, column 8:\n                                       key2: value2\n                                           ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 3\n                        it.column shouldBe 8\n                        it.path shouldBe YamlPath.root.withMapElementKey(\"thing\", Location(1, 1)).withMapElementValue(Location(2, 3)).withError(Location(3, 8))\n                    }\n                }\n            }\n        }\n\n        context(\"given a key-value pair with not enough indentation\") {\n            val input = \"\"\"\n                thing:\n                  key1: value1\n                 key2: value2\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                while parsing a block mapping\n                                 at line 1, column 1:\n                                    thing:\n                                    ^\n                                expected <block end>, but found '<block mapping start>' (is the indentation level of this line or a line nearby incorrect?)\n                                 at line 3, column 2:\n                                     key2: value2\n                                     ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 3\n                        it.column shouldBe 2\n                        it.path shouldBe YamlPath.root.withError(Location(3, 2))\n                    }\n                }\n            }\n        }\n\n        context(\"given a list item in a map value with not enough indentation\") {\n            val input = \"\"\"\n                thing:\n                  - value1\n                 - value2\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                while parsing a block mapping\n                                 at line 1, column 1:\n                                    thing:\n                                    ^\n                                expected <block end>, but found '<block sequence start>' (is the indentation level of this line or a line nearby incorrect?)\n                                 at line 3, column 2:\n                                     - value2\n                                     ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 3\n                        it.column shouldBe 2\n                        it.path shouldBe YamlPath.root.withError(Location(3, 2))\n                    }\n                }\n            }\n        }\n\n        context(\"given an empty map in flow style\") {\n            val input = \"{}\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns an empty map\") {\n                    result shouldBe\n                        YamlMap(emptyMap(), YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a single opening curly brace\") {\n            val input = \"{\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                while parsing a flow node\n                                 at line 1, column 2:\n                                    {\n                                     ^\n                                expected the node content, but found '<stream end>'\n                                 at line 1, column 2:\n                                    {\n                                     ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 1\n                        it.column shouldBe 2\n                        it.path shouldBe YamlPath.root.withError(Location(1, 2))\n                    }\n                }\n            }\n        }\n\n        context(\"given a single key-value pair in flow style\") {\n            val input = \"{key: value}\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val keyPath = YamlPath.root.withMapElementKey(\"key\", Location(1, 2))\n                val valuePath = keyPath.withMapElementValue(Location(1, 7))\n\n                it(\"returns a map with a single key-value pair\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key\", keyPath) to YamlScalar(\"value\", valuePath),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a single key-value pair in flow style with a missing closing curly brace\") {\n            val input = \"{key: value\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe\n                            \"\"\"\n                                    while parsing a flow mapping\n                                     at line 1, column 1:\n                                        {key: value\n                                        ^\n                                    expected ',' or '}', but got <stream end>\n                                     at line 1, column 12:\n                                        {key: value\n                                                   ^\n                            \"\"\".trimIndent()\n\n                        it.line shouldBe 1\n                        it.column shouldBe 12\n                        it.path shouldBe YamlPath.root.withError(Location(1, 12))\n                    }\n                }\n            }\n        }\n\n        context(\"given two key-value pairs in flow style\") {\n            val input = \"{key1: value1, key2: value2}\"\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n                val key1Path = YamlPath.root.withMapElementKey(\"key1\", Location(1, 2))\n                val value1Path = key1Path.withMapElementValue(Location(1, 8))\n                val key2Path = YamlPath.root.withMapElementKey(\"key2\", Location(1, 16))\n                val value2Path = key2Path.withMapElementValue(Location(1, 22))\n\n                it(\"returns a map with a single key-value pair\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"key1\", key1Path) to YamlScalar(\"value1\", value1Path),\n                                YamlScalar(\"key2\", key2Path) to YamlScalar(\"value2\", value2Path),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a scalar with a preceding comment\") {\n            val input = \"\"\"\n                # this is a comment\n                somevalue\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns that scalar, ignoring the comment\") {\n                    // FIXME: ideally we'd return a path with the location (2, 1)\n                    result shouldBe YamlScalar(\"somevalue\", YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a scalar with a following comment\") {\n            val input = \"\"\"\n                somevalue\n                # this is a comment\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns that scalar, ignoring the comment\") {\n                    result shouldBe\n                        YamlScalar(\"somevalue\", YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a scalar with a multiple lines of preceding and following comments\") {\n            val input = \"\"\"\n                # this is a comment\n                # also a comment\n                somevalue\n                # still a comment\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns that scalar, ignoring the comments\") {\n                    // FIXME: ideally we'd return a path with the location (3, 1)\n                    result shouldBe YamlScalar(\"somevalue\", YamlPath.root)\n                }\n            }\n        }\n\n        context(\"given a scalar with a following inline comment\") {\n            val input = \"\"\"\n                somevalue # this is a comment\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser).read()\n\n                it(\"returns that scalar, ignoring the comment\") {\n                    result shouldBe\n                        YamlScalar(\"somevalue\", YamlPath.root)\n                }\n            }\n        }\n\n        mapOf(\n            \"!thing\" to YamlTaggedNode(\"!thing\", YamlNull(YamlPath.root)),\n            \"!!str 'some string'\" to YamlTaggedNode(\"tag:yaml.org,2002:str\", YamlScalar(\"some string\", YamlPath.root)),\n        ).forEach { (input, featureName) ->\n            context(\"given the input '$input' which contains a tagged node\") {\n                describe(\"parsing that input\") {\n                    it(\"returns the expected node\") {\n                        YamlNodeReader(YamlParser(input)).read() shouldBe featureName\n                    }\n                }\n            }\n        }\n\n        context(\"given an empty document\") {\n            val input = \"\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that the document is empty\") {\n                    val exception = shouldThrow<EmptyYamlDocumentException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"The YAML document is empty.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n        }\n\n        context(\"given a document with just a comment\") {\n            val input = \"# this is a comment\"\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that the document is empty\") {\n                    val exception = shouldThrow<EmptyYamlDocumentException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"The YAML document is empty.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root\n                    }\n                }\n            }\n        }\n\n        // The following examples are taken from https://yaml.org/type/merge.html\n        context(\"given a map with a single map to merge into it\") {\n            val input = \"\"\"\n                - &CENTER { x: 1, y: 2 }\n\n                - << : *CENTER\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, allowAnchorsAndAliases = true).read()\n\n                val firstItemPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val firstXPath = firstItemPath.withMapElementKey(\"x\", Location(1, 13))\n                val firstYPath = firstItemPath.withMapElementKey(\"y\", Location(1, 19))\n                val secondItemPath = YamlPath.root.withListEntry(1, Location(3, 3))\n                val mergeResolutionPath = secondItemPath.withMerge(Location(3, 8)).withAliasReference(\"CENTER\", Location(3, 8)).withAliasDefinition(\"CENTER\", Location(1, 3))\n                val secondXPath = mergeResolutionPath.withMapElementKey(\"x\", Location(1, 13))\n                val secondYPath = mergeResolutionPath.withMapElementKey(\"y\", Location(1, 19))\n                val labelPath = secondItemPath.withMapElementKey(\"label\", Location(5, 3))\n                val rPath = secondItemPath.withMapElementKey(\"r\", Location(4, 3))\n\n                it(\"returns that map with the values from the source map merged into it\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", firstXPath) to YamlScalar(\"1\", firstXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", firstYPath) to YamlScalar(\"2\", firstYPath.withMapElementValue(Location(1, 22))),\n                                    ),\n                                    firstItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", secondXPath) to YamlScalar(\"1\", secondXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", secondYPath) to YamlScalar(\"2\", secondYPath.withMapElementValue(Location(1, 22))),\n                                        YamlScalar(\"r\", rPath) to YamlScalar(\"10\", rPath.withMapElementValue(Location(4, 6))),\n                                        YamlScalar(\"label\", labelPath) to YamlScalar(\"center/big\", labelPath.withMapElementValue(Location(5, 10))),\n                                    ),\n                                    secondItemPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with a single map to merge into it, with both containing the same key\") {\n            val input = \"\"\"\n                - &CENTER { x: 1, y: 2 }\n\n                - << : *CENTER\n                  x: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, allowAnchorsAndAliases = true).read()\n\n                val firstItemPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val firstXPath = firstItemPath.withMapElementKey(\"x\", Location(1, 13))\n                val firstYPath = firstItemPath.withMapElementKey(\"y\", Location(1, 19))\n                val secondItemPath = YamlPath.root.withListEntry(1, Location(3, 3))\n                val mergeResolutionPath = secondItemPath.withMerge(Location(3, 8)).withAliasReference(\"CENTER\", Location(3, 8)).withAliasDefinition(\"CENTER\", Location(1, 3))\n                val secondXPath = secondItemPath.withMapElementKey(\"x\", Location(4, 3))\n                val secondYPath = mergeResolutionPath.withMapElementKey(\"y\", Location(1, 19))\n                val labelPath = secondItemPath.withMapElementKey(\"label\", Location(5, 3))\n\n                it(\"returns that map with the values from the source map merged into it, with the local values taking precedence\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", firstXPath) to YamlScalar(\"1\", firstXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", firstYPath) to YamlScalar(\"2\", firstYPath.withMapElementValue(Location(1, 22))),\n                                    ),\n                                    firstItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", secondXPath) to YamlScalar(\"10\", secondXPath.withMapElementValue(Location(4, 6))),\n                                        YamlScalar(\"y\", secondYPath) to YamlScalar(\"2\", secondYPath.withMapElementValue(Location(1, 22))),\n                                        YamlScalar(\"label\", labelPath) to YamlScalar(\"center/big\", labelPath.withMapElementValue(Location(5, 10))),\n                                    ),\n                                    secondItemPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with a single null value to merge into it\") {\n            val input = \"\"\"\n                - << : null\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a null value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a null value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 8\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with a single scalar value to merge into it\") {\n            val input = \"\"\"\n                - << : abc123\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a scalar value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a scalar value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 8\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with multiple maps to merge into it\") {\n            val input = \"\"\"\n                - &CENTER { x: 1, y: 2 }\n                - &RADIUS { r: 10 }\n\n                - << : [ *CENTER, *RADIUS ]\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, allowAnchorsAndAliases = true).read()\n\n                val firstItemPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val firstXPath = firstItemPath.withMapElementKey(\"x\", Location(1, 13))\n                val firstYPath = firstItemPath.withMapElementKey(\"y\", Location(1, 19))\n\n                val secondItemPath = YamlPath.root.withListEntry(1, Location(2, 3))\n                val secondRPath = secondItemPath.withMapElementKey(\"r\", Location(2, 13))\n\n                val thirdItemPath = YamlPath.root.withListEntry(2, Location(4, 3))\n                val centerMergeResolutionPath = thirdItemPath.withMerge(Location(4, 8)).withListEntry(0, Location(4, 10)).withAliasReference(\"CENTER\", Location(4, 10)).withAliasDefinition(\"CENTER\", Location(1, 3))\n                val thirdXPath = centerMergeResolutionPath.withMapElementKey(\"x\", Location(1, 13))\n                val thirdYPath = centerMergeResolutionPath.withMapElementKey(\"y\", Location(1, 19))\n                val radiusMergeResolutionPath = thirdItemPath.withMerge(Location(4, 8)).withListEntry(1, Location(4, 19)).withAliasReference(\"RADIUS\", Location(4, 19)).withAliasDefinition(\"RADIUS\", Location(2, 3))\n                val thirdRPath = radiusMergeResolutionPath.withMapElementKey(\"r\", Location(2, 13))\n                val labelPath = thirdItemPath.withMapElementKey(\"label\", Location(5, 3))\n\n                it(\"returns that map with the values from the source maps merged into it\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", firstXPath) to YamlScalar(\"1\", firstXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", firstYPath) to YamlScalar(\"2\", firstYPath.withMapElementValue(Location(1, 22))),\n                                    ),\n                                    firstItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"r\", secondRPath) to YamlScalar(\"10\", secondRPath.withMapElementValue(Location(2, 16))),\n                                    ),\n                                    secondItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", thirdXPath) to YamlScalar(\"1\", thirdXPath.withMapElementValue(Location(1, 16))),\n                                        YamlScalar(\"y\", thirdYPath) to YamlScalar(\"2\", thirdYPath.withMapElementValue(Location(1, 22))),\n                                        YamlScalar(\"r\", thirdRPath) to YamlScalar(\"10\", thirdRPath.withMapElementValue(Location(2, 16))),\n                                        YamlScalar(\"label\", labelPath) to YamlScalar(\"center/big\", labelPath.withMapElementValue(Location(5, 10))),\n                                    ),\n                                    thirdItemPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with multiple maps to merge into it, with both source and destination maps containing the same keys\") {\n            val input = \"\"\"\n                - &LEFT { x: 0, y: 2 }\n                - &BIG { r: 10 }\n                - &SMALL { r: 1 }\n\n                - << : [ *BIG, *LEFT, *SMALL ]\n                  x: 1\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, allowAnchorsAndAliases = true).read()\n\n                val firstItemPath = YamlPath.root.withListEntry(0, Location(1, 3))\n                val firstXPath = firstItemPath.withMapElementKey(\"x\", Location(1, 11))\n                val firstYPath = firstItemPath.withMapElementKey(\"y\", Location(1, 17))\n\n                val secondItemPath = YamlPath.root.withListEntry(1, Location(2, 3))\n                val secondRPath = secondItemPath.withMapElementKey(\"r\", Location(2, 10))\n\n                val thirdItemPath = YamlPath.root.withListEntry(2, Location(3, 3))\n                val thirdRPath = thirdItemPath.withMapElementKey(\"r\", Location(3, 12))\n\n                val fourthItemPath = YamlPath.root.withListEntry(3, Location(5, 3))\n                val fourthXPath = fourthItemPath.withMapElementKey(\"x\", Location(6, 3))\n                val leftMergeResolutionPath = fourthItemPath.withMerge(Location(5, 8)).withListEntry(1, Location(5, 16)).withAliasReference(\"LEFT\", Location(5, 16)).withAliasDefinition(\"LEFT\", Location(1, 3))\n                val fourthYPath = leftMergeResolutionPath.withMapElementKey(\"y\", Location(1, 17))\n                val bigMergeResolutionPath = fourthItemPath.withMerge(Location(5, 8)).withListEntry(0, Location(5, 10)).withAliasReference(\"BIG\", Location(5, 10)).withAliasDefinition(\"BIG\", Location(2, 3))\n                val fourthRPath = bigMergeResolutionPath.withMapElementKey(\"r\", Location(2, 10))\n                val labelPath = fourthItemPath.withMapElementKey(\"label\", Location(7, 3))\n\n                it(\"returns that map with the values from the source maps merged into it, with local values taking precedence over earlier source values, and with earlier source values taking precedence over later source values\") {\n                    result shouldBe\n                        YamlList(\n                            listOf(\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", firstXPath) to YamlScalar(\"0\", firstXPath.withMapElementValue(Location(1, 14))),\n                                        YamlScalar(\"y\", firstYPath) to YamlScalar(\"2\", firstYPath.withMapElementValue(Location(1, 20))),\n                                    ),\n                                    firstItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"r\", secondRPath) to YamlScalar(\"10\", secondRPath.withMapElementValue(Location(2, 13))),\n                                    ),\n                                    secondItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"r\", thirdRPath) to YamlScalar(\"1\", thirdRPath.withMapElementValue(Location(3, 15))),\n                                    ),\n                                    thirdItemPath,\n                                ),\n                                YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"x\", fourthXPath) to YamlScalar(\"1\", fourthXPath.withMapElementValue(Location(6, 6))),\n                                        YamlScalar(\"y\", fourthYPath) to YamlScalar(\"2\", fourthYPath.withMapElementValue(Location(1, 20))),\n                                        YamlScalar(\"r\", fourthRPath) to YamlScalar(\"10\", fourthRPath.withMapElementValue(Location(2, 13))),\n                                        YamlScalar(\"label\", labelPath) to YamlScalar(\"center/big\", labelPath.withMapElementValue(Location(7, 10))),\n                                    ),\n                                    fourthItemPath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a map with a null value in a list of values to merge into it\") {\n            val input = \"\"\"\n                - << : [null]\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a null value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a null value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 9\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8)).withListEntry(0, Location(1, 9))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with a scalar value in a list of values to merge into it\") {\n            val input = \"\"\"\n                - << : [abc123]\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a scalar value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a scalar value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 9\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8)).withListEntry(0, Location(1, 9))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with a list value in a list of values to merge into it\") {\n            val input = \"\"\"\n                - << : [ [] ]\n                  r: 10\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that merging a list value is not valid\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot merge a list value into a map.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 10\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMerge(Location(1, 8)).withListEntry(0, Location(1, 10))\n                    }\n                }\n            }\n        }\n\n        context(\"given a map with multiple lists of items to merge into it\") {\n            val input = \"\"\"\n                - << : []\n                  << : []\n                  label: center/big\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that multiple merges are not possible\") {\n                    val exception = shouldThrow<MalformedYamlException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser).read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"Cannot perform multiple '<<' merges into a map. Instead, combine all merges into a single '<<' entry.\"\n                        it.line shouldBe 2\n                        it.column shouldBe 3\n                        it.path shouldBe YamlPath.root.withListEntry(0, Location(1, 3)).withMapElementKey(\"<<\", Location(2, 3))\n                    }\n                }\n            }\n        }\n\n        context(\"given a top-level map with an entry matching the extension definition prefix\") {\n            val input = \"\"\"\n                .extension: &extension extension-value\n\n                foo:\n                    bar: value\n                    baz: *extension\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input with an extension definition prefix defined\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, extensionDefinitionPrefix = \".\", allowAnchorsAndAliases = true).read()\n\n                val fooKeyPath = YamlPath.root.withMapElementKey(\"foo\", Location(3, 1))\n                val fooValuePath = fooKeyPath.withMapElementValue(Location(4, 5))\n                val barKeyPath = fooValuePath.withMapElementKey(\"bar\", Location(4, 5))\n                val bazKeyPath = fooValuePath.withMapElementKey(\"baz\", Location(5, 5))\n                val bazValuePath = bazKeyPath.withMapElementValue(Location(5, 10)).withAliasReference(\"extension\", Location(5, 10)).withAliasDefinition(\"extension\", Location(1, 13))\n\n                it(\"returns the map, merging the alias where it is referenced and removing it from the top-level entry\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"foo\", fooKeyPath) to YamlMap(\n                                    mapOf(\n                                        YamlScalar(\"bar\", barKeyPath) to YamlScalar(\"value\", barKeyPath.withMapElementValue(Location(4, 10))),\n                                        YamlScalar(\"baz\", bazKeyPath) to YamlScalar(\"extension-value\", bazValuePath),\n                                    ),\n                                    fooValuePath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a non-top-level map with an entry matching the extension definition prefix\") {\n            val input = \"\"\"\n                foo:\n                    .bar: value\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input with an extension definition prefix defined\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, extensionDefinitionPrefix = \".\").read()\n\n                val fooKeyPath = YamlPath.root.withMapElementKey(\"foo\", Location(1, 1))\n                val fooValuePath = fooKeyPath.withMapElementValue(Location(2, 5))\n                val barKeyPath = fooValuePath.withMapElementKey(\".bar\", Location(2, 5))\n\n                it(\"returns the map, retaining the key matching the extension definition prefix\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\"foo\", fooKeyPath) to YamlMap(\n                                    mapOf(\n                                        YamlScalar(\".bar\", barKeyPath) to YamlScalar(\"value\", barKeyPath.withMapElementValue(Location(2, 11))),\n                                    ),\n                                    fooValuePath,\n                                ),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a top-level map that has another map merged into it with an entry with a key matching the extension definition prefix\") {\n            val input = \"\"\"\n                .extension: &extension\n                    .some-key: some-value\n\n                << : [ *extension ]\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input with an extension definition prefix defined\") {\n                val parser = YamlParser(input)\n                val result = YamlNodeReader(parser, extensionDefinitionPrefix = \".\", allowAnchorsAndAliases = true).read()\n\n                val keyPath = YamlPath.root\n                    .withMerge(Location(4, 6))\n                    .withListEntry(0, Location(4, 8))\n                    .withAliasReference(\"extension\", Location(4, 8))\n                    .withAliasDefinition(\"extension\", Location(1, 13))\n                    .withMapElementKey(\".some-key\", Location(2, 5))\n\n                val valuePath = keyPath.withMapElementValue(Location(2, 16))\n\n                it(\"returns the map, merging the other map into it and preserving its keys\") {\n                    result shouldBe\n                        YamlMap(\n                            mapOf(\n                                YamlScalar(\".some-key\", keyPath) to YamlScalar(\"some-value\", valuePath),\n                            ),\n                            YamlPath.root,\n                        )\n                }\n            }\n        }\n\n        context(\"given a top-level map with a key matching the extension definition prefix but no anchor defined\") {\n            val input = \"\"\"\n                .invalid-extension: some-value\n            \"\"\".trimIndent()\n\n            describe(\"parsing that input\") {\n                it(\"throws an appropriate exception stating that an anchor is required for keys with the extension definition prefix\") {\n                    val exception = shouldThrow<NoAnchorForExtensionException> {\n                        val parser = YamlParser(input)\n                        YamlNodeReader(parser, extensionDefinitionPrefix = \".\").read()\n                    }\n\n                    exception.asClue {\n                        it.message shouldBe \"The key '.invalid-extension' starts with the extension definition prefix '.' but does not define an anchor.\"\n                        it.line shouldBe 1\n                        it.column shouldBe 1\n                        it.path shouldBe YamlPath.root.withError(Location(1, 1))\n                    }\n                }\n            }\n        }\n    }\n})\n"], "filenames": ["src/commonMain/kotlin/com/charleskorn/kaml/YamlConfiguration.kt", "src/commonMain/kotlin/com/charleskorn/kaml/YamlException.kt", "src/commonTest/kotlin/com/charleskorn/kaml/YamlReadingTest.kt", "src/jvmMain/kotlin/com/charleskorn/kaml/Yaml.kt", "src/jvmMain/kotlin/com/charleskorn/kaml/YamlNodeReader.kt", "src/jvmTest/kotlin/com/charleskorn/kaml/YamlNodeReaderTest.kt"], "buggy_code_start_loc": [35, 100, 1173, 63, 32, 315], "buggy_code_end_loc": [49, 100, 1175, 64, 188, 1602], "fixing_code_start_loc": [36, 101, 1173, 63, 33, 315], "fixing_code_end_loc": [52, 103, 1190, 64, 198, 1617], "type": "CWE-776", "message": "kaml provides YAML support for kotlinx.serialization. Prior to version 0.53.0, applications that use kaml to parse untrusted input containing anchors and aliases may consume excessive memory and crash. Version 0.53.0 and later default to refusing to parse YAML documents containing anchors and aliases. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-28118", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-20T13:15:11.877", "lastModified": "2023-03-24T18:00:16.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "kaml provides YAML support for kotlinx.serialization. Prior to version 0.53.0, applications that use kaml to parse untrusted input containing anchors and aliases may consume excessive memory and crash. Version 0.53.0 and later default to refusing to parse YAML documents containing anchors and aliases. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-776"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kaml_project:kaml:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.53.0", "matchCriteriaId": "14E288FA-2A10-49B3-B836-442D90F4A7D4"}]}]}], "references": [{"url": "https://github.com/charleskorn/kaml/commit/5f82a2d7e00bfc307afca05d1dc4d7c50593531a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/charleskorn/kaml/releases/tag/0.53.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/charleskorn/kaml/security/advisories/GHSA-c24f-2j3g-rg48", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/charleskorn/kaml/commit/5f82a2d7e00bfc307afca05d1dc4d7c50593531a"}}