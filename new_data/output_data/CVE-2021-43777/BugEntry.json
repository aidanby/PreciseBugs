{"buggy_code": ["import hashlib\nimport hmac\nimport logging\nimport time\nfrom datetime import timedelta\nfrom urllib.parse import urlsplit, urlunsplit\n\nfrom flask import jsonify, redirect, request, url_for, session\nfrom flask_login import LoginManager, login_user, logout_user, user_logged_in\nfrom redash import models, settings\nfrom redash.authentication import jwt_auth\nfrom redash.authentication.org_resolving import current_org\nfrom redash.settings.organization import settings as org_settings\nfrom redash.tasks import record_event\nfrom sqlalchemy.orm.exc import NoResultFound\nfrom werkzeug.exceptions import Unauthorized\n\nlogin_manager = LoginManager()\nlogger = logging.getLogger(\"authentication\")\n\n\ndef get_login_url(external=False, next=\"/\"):\n    if settings.MULTI_ORG and current_org == None:\n        login_url = \"/\"\n    elif settings.MULTI_ORG:\n        login_url = url_for(\n            \"redash.login\", org_slug=current_org.slug, next=next, _external=external\n        )\n    else:\n        login_url = url_for(\"redash.login\", next=next, _external=external)\n\n    return login_url\n\n\ndef sign(key, path, expires):\n    if not key:\n        return None\n\n    h = hmac.new(key.encode(), msg=path.encode(), digestmod=hashlib.sha1)\n    h.update(str(expires).encode())\n\n    return h.hexdigest()\n\n\n@login_manager.user_loader\ndef load_user(user_id_with_identity):\n    user = api_key_load_user_from_request(request)\n    if user:\n        return user\n\n    org = current_org._get_current_object()\n\n    try:\n        user_id, _ = user_id_with_identity.split(\"-\")\n        user = models.User.get_by_id_and_org(user_id, org)\n        if user.is_disabled or user.get_id() != user_id_with_identity:\n            return None\n\n        return user\n    except (models.NoResultFound, ValueError, AttributeError):\n        return None\n\n\ndef request_loader(request):\n    user = None\n    if settings.AUTH_TYPE == \"hmac\":\n        user = hmac_load_user_from_request(request)\n    elif settings.AUTH_TYPE == \"api_key\":\n        user = api_key_load_user_from_request(request)\n    else:\n        logger.warning(\n            \"Unknown authentication type ({}). Using default (HMAC).\".format(\n                settings.AUTH_TYPE\n            )\n        )\n        user = hmac_load_user_from_request(request)\n\n    if org_settings[\"auth_jwt_login_enabled\"] and user is None:\n        user = jwt_token_load_user_from_request(request)\n    return user\n\n\ndef hmac_load_user_from_request(request):\n    signature = request.args.get(\"signature\")\n    expires = float(request.args.get(\"expires\") or 0)\n    query_id = request.view_args.get(\"query_id\", None)\n    user_id = request.args.get(\"user_id\", None)\n\n    # TODO: 3600 should be a setting\n    if signature and time.time() < expires <= time.time() + 3600:\n        if user_id:\n            user = models.User.query.get(user_id)\n            calculated_signature = sign(user.api_key, request.path, expires)\n\n            if user.api_key and signature == calculated_signature:\n                return user\n\n        if query_id:\n            query = models.Query.query.filter(models.Query.id == query_id).one()\n            calculated_signature = sign(query.api_key, request.path, expires)\n\n            if query.api_key and signature == calculated_signature:\n                return models.ApiUser(\n                    query.api_key,\n                    query.org,\n                    list(query.groups.keys()),\n                    name=\"ApiKey: Query {}\".format(query.id),\n                )\n\n    return None\n\n\ndef get_user_from_api_key(api_key, query_id):\n    if not api_key:\n        return None\n\n    user = None\n\n    # TODO: once we switch all api key storage into the ApiKey model, this code will be much simplified\n    org = current_org._get_current_object()\n    try:\n        user = models.User.get_by_api_key_and_org(api_key, org)\n        if user.is_disabled:\n            user = None\n    except models.NoResultFound:\n        try:\n            api_key = models.ApiKey.get_by_api_key(api_key)\n            user = models.ApiUser(api_key, api_key.org, [])\n        except models.NoResultFound:\n            if query_id:\n                query = models.Query.get_by_id_and_org(query_id, org)\n                if query and query.api_key == api_key:\n                    user = models.ApiUser(\n                        api_key,\n                        query.org,\n                        list(query.groups.keys()),\n                        name=\"ApiKey: Query {}\".format(query.id),\n                    )\n\n    return user\n\n\ndef get_api_key_from_request(request):\n    api_key = request.args.get(\"api_key\", None)\n\n    if api_key is not None:\n        return api_key\n\n    if request.headers.get(\"Authorization\"):\n        auth_header = request.headers.get(\"Authorization\")\n        api_key = auth_header.replace(\"Key \", \"\", 1)\n    elif request.view_args is not None and request.view_args.get(\"token\"):\n        api_key = request.view_args[\"token\"]\n\n    return api_key\n\n\ndef api_key_load_user_from_request(request):\n    api_key = get_api_key_from_request(request)\n    if request.view_args is not None:\n        query_id = request.view_args.get(\"query_id\", None)\n        user = get_user_from_api_key(api_key, query_id)\n    else:\n        user = None\n\n    return user\n\n\ndef jwt_token_load_user_from_request(request):\n    org = current_org._get_current_object()\n\n    payload = None\n\n    if org_settings[\"auth_jwt_auth_cookie_name\"]:\n        jwt_token = request.cookies.get(org_settings[\"auth_jwt_auth_cookie_name\"], None)\n    elif org_settings[\"auth_jwt_auth_header_name\"]:\n        jwt_token = request.headers.get(org_settings[\"auth_jwt_auth_header_name\"], None)\n    else:\n        return None\n\n    if jwt_token:\n        payload, token_is_valid = jwt_auth.verify_jwt_token(\n            jwt_token,\n            expected_issuer=org_settings[\"auth_jwt_auth_issuer\"],\n            expected_audience=org_settings[\"auth_jwt_auth_audience\"],\n            algorithms=org_settings[\"auth_jwt_auth_algorithms\"],\n            public_certs_url=org_settings[\"auth_jwt_auth_public_certs_url\"],\n        )\n        if not token_is_valid:\n            raise Unauthorized(\"Invalid JWT token\")\n\n    if not payload:\n        return\n\n    try:\n        user = models.User.get_by_email_and_org(payload[\"email\"], org)\n    except models.NoResultFound:\n        user = create_and_login_user(current_org, payload[\"email\"], payload[\"email\"])\n\n    return user\n\n\ndef log_user_logged_in(app, user):\n    event = {\n        \"org_id\": user.org_id,\n        \"user_id\": user.id,\n        \"action\": \"login\",\n        \"object_type\": \"redash\",\n        \"timestamp\": int(time.time()),\n        \"user_agent\": request.user_agent.string,\n        \"ip\": request.remote_addr,\n    }\n\n    record_event.delay(event)\n\n\n@login_manager.unauthorized_handler\ndef redirect_to_login():\n    if request.is_xhr or \"/api/\" in request.path:\n        response = jsonify(\n            {\"message\": \"Couldn't find resource. Please login and try again.\"}\n        )\n        response.status_code = 404\n        return response\n\n    login_url = get_login_url(next=request.url, external=False)\n\n    return redirect(login_url)\n\n\ndef logout_and_redirect_to_index():\n    logout_user()\n\n    if settings.MULTI_ORG and current_org == None:\n        index_url = \"/\"\n    elif settings.MULTI_ORG:\n        index_url = url_for(\"redash.index\", org_slug=current_org.slug, _external=False)\n    else:\n        index_url = url_for(\"redash.index\", _external=False)\n\n    return redirect(index_url)\n\n\ndef init_app(app):\n    from redash.authentication import (\n        google_oauth,\n        saml_auth,\n        remote_user_auth,\n        ldap_auth,\n    )\n\n    login_manager.init_app(app)\n    login_manager.anonymous_user = models.AnonymousUser\n    login_manager.REMEMBER_COOKIE_DURATION = settings.REMEMBER_COOKIE_DURATION\n\n    @app.before_request\n    def extend_session():\n        session.permanent = True\n        app.permanent_session_lifetime = timedelta(seconds=settings.SESSION_EXPIRY_TIME)\n\n    from redash.security import csrf\n    for auth in [google_oauth, saml_auth, remote_user_auth, ldap_auth]:\n        blueprint = auth.blueprint\n        csrf.exempt(blueprint)\n        app.register_blueprint(blueprint)\n\n    user_logged_in.connect(log_user_logged_in)\n    login_manager.request_loader(request_loader)\n\n\ndef create_and_login_user(org, name, email, picture=None):\n    try:\n        user_object = models.User.get_by_email_and_org(email, org)\n        if user_object.is_disabled:\n            return None\n        if user_object.is_invitation_pending:\n            user_object.is_invitation_pending = False\n            models.db.session.commit()\n        if user_object.name != name:\n            logger.debug(\"Updating user name (%r -> %r)\", user_object.name, name)\n            user_object.name = name\n            models.db.session.commit()\n    except NoResultFound:\n        logger.debug(\"Creating user object (%r)\", name)\n        user_object = models.User(\n            org=org,\n            name=name,\n            email=email,\n            is_invitation_pending=False,\n            _profile_image_url=picture,\n            group_ids=[org.default_group.id],\n        )\n        models.db.session.add(user_object)\n        models.db.session.commit()\n\n    login_user(user_object, remember=True)\n\n    return user_object\n\n\ndef get_next_path(unsafe_next_path):\n    if not unsafe_next_path:\n        return \"\"\n\n    # Preventing open redirection attacks\n    parts = list(urlsplit(unsafe_next_path))\n    parts[0] = \"\"  # clear scheme\n    parts[1] = \"\"  # clear netloc\n    safe_next_path = urlunsplit(parts)\n\n    # If the original path was a URL, we might end up with an empty\n    # safe url, which will redirect to the login page. Changing to\n    # relative root to redirect to the app root after login.\n    if not safe_next_path:\n        safe_next_path = \"./\"\n\n    return safe_next_path\n", "import logging\nimport requests\nfrom flask import redirect, url_for, Blueprint, flash, request, session\nfrom flask_oauthlib.client import OAuth\n\nfrom redash import models, settings\nfrom redash.authentication import (\n    create_and_login_user,\n    logout_and_redirect_to_index,\n    get_next_path,\n)\nfrom redash.authentication.org_resolving import current_org\n\nlogger = logging.getLogger(\"google_oauth\")\n\noauth = OAuth()\nblueprint = Blueprint(\"google_oauth\", __name__)\n\n\ndef google_remote_app():\n    if \"google\" not in oauth.remote_apps:\n        oauth.remote_app(\n            \"google\",\n            base_url=\"https://www.google.com/accounts/\",\n            authorize_url=\"https://accounts.google.com/o/oauth2/auth?prompt=select_account+consent\",\n            request_token_url=None,\n            request_token_params={\n                \"scope\": \"https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile\"\n            },\n            access_token_url=\"https://accounts.google.com/o/oauth2/token\",\n            access_token_method=\"POST\",\n            consumer_key=settings.GOOGLE_CLIENT_ID,\n            consumer_secret=settings.GOOGLE_CLIENT_SECRET,\n        )\n\n    return oauth.google\n\n\ndef get_user_profile(access_token):\n    headers = {\"Authorization\": \"OAuth {}\".format(access_token)}\n    response = requests.get(\n        \"https://www.googleapis.com/oauth2/v1/userinfo\", headers=headers\n    )\n\n    if response.status_code == 401:\n        logger.warning(\"Failed getting user profile (response code 401).\")\n        return None\n\n    return response.json()\n\n\ndef verify_profile(org, profile):\n    if org.is_public:\n        return True\n\n    email = profile[\"email\"]\n    domain = email.split(\"@\")[-1]\n\n    if domain in org.google_apps_domains:\n        return True\n\n    if org.has_user(email) == 1:\n        return True\n\n    return False\n\n\n@blueprint.route(\"/<org_slug>/oauth/google\", endpoint=\"authorize_org\")\ndef org_login(org_slug):\n    session[\"org_slug\"] = current_org.slug\n    return redirect(url_for(\".authorize\", next=request.args.get(\"next\", None)))\n\n\n@blueprint.route(\"/oauth/google\", endpoint=\"authorize\")\ndef login():\n    callback = url_for(\".callback\", _external=True)\n    next_path = request.args.get(\n        \"next\", url_for(\"redash.index\", org_slug=session.get(\"org_slug\"))\n    )\n    logger.debug(\"Callback url: %s\", callback)\n    logger.debug(\"Next is: %s\", next_path)\n    return google_remote_app().authorize(callback=callback, state=next_path)\n\n\n@blueprint.route(\"/oauth/google_callback\", endpoint=\"callback\")\ndef authorized():\n    resp = google_remote_app().authorized_response()\n    access_token = resp[\"access_token\"]\n\n    if access_token is None:\n        logger.warning(\"Access token missing in call back request.\")\n        flash(\"Validation error. Please retry.\")\n        return redirect(url_for(\"redash.login\"))\n\n    profile = get_user_profile(access_token)\n    if profile is None:\n        flash(\"Validation error. Please retry.\")\n        return redirect(url_for(\"redash.login\"))\n\n    if \"org_slug\" in session:\n        org = models.Organization.get_by_slug(session.pop(\"org_slug\"))\n    else:\n        org = current_org\n\n    if not verify_profile(org, profile):\n        logger.warning(\n            \"User tried to login with unauthorized domain name: %s (org: %s)\",\n            profile[\"email\"],\n            org,\n        )\n        flash(\"Your Google Apps account ({}) isn't allowed.\".format(profile[\"email\"]))\n        return redirect(url_for(\"redash.login\", org_slug=org.slug))\n\n    picture_url = \"%s?sz=40\" % profile[\"picture\"]\n    user = create_and_login_user(org, profile[\"name\"], profile[\"email\"], picture_url)\n    if user is None:\n        return logout_and_redirect_to_index()\n\n    unsafe_next_path = request.args.get(\"state\") or url_for(\n        \"redash.index\", org_slug=org.slug\n    )\n    next_path = get_next_path(unsafe_next_path)\n\n    return redirect(next_path)\n", "Flask==1.1.1\nJinja2==2.10.3\nitsdangerous==1.1.0\nclick==6.7\nMarkupSafe==1.1.1\npyOpenSSL==19.0.0\nhttplib2==0.14.0\nwtforms==2.2.1\nFlask-RESTful==0.3.7\nFlask-Login==0.4.1\nFlask-OAuthLib==0.9.5\n# pin this until https://github.com/lepture/flask-oauthlib/pull/388 is released\nrequests-oauthlib>=0.6.2,<1.2.0\nFlask-SQLAlchemy==2.4.1\nFlask-Migrate==2.5.2\nflask-mail==0.9.1\nflask-talisman==0.7.0\nFlask-Limiter==0.9.3\nFlask-WTF==0.14.3\npasslib==1.7.1\naniso8601==8.0.0\nblinker==1.4\npsycopg2==2.8.3\npython-dateutil==2.8.0\npytz>=2019.3\nPyYAML==5.1.2\nredis==3.5.0\nrequests==2.21.0\nSQLAlchemy==1.3.10\n# We can't upgrade SQLAlchemy-Searchable version as newer versions require PostgreSQL > 9.6, but we target older versions at the moment.\nSQLAlchemy-Searchable==0.10.6\n# We need to pin the version of pyparsing, as newer versions break SQLAlchemy-Searchable-10.0.6 (newer versions no longer depend on it)\npyparsing==2.3.0\nSQLAlchemy-Utils==0.34.2\nsqlparse==0.3.0\nstatsd==3.3.0\ngreenlet==0.4.16\ngunicorn==20.0.4\nrq==1.5.0\nrq-scheduler==0.9.1\njsonschema==3.1.1\nRestrictedPython==5.0\npysaml2==6.1.0\npycrypto==2.6.1\nfuncy==1.13\nsentry-sdk>=0.14.3,<0.15.0\nsemver==2.8.1\nxlsxwriter==1.2.2\npystache==0.5.4\nparsedatetime==2.4\nPyJWT==1.7.1\ncryptography==2.8\nsimplejson==3.16.0\nua-parser==0.8.0\nuser-agents==2.0\nmaxminddb-geolite2==2018.703\npypd==1.1.0\ndisposable-email-domains>=0.0.52\ngevent==1.4.0\nsshtunnel==0.1.5\nsupervisor==4.1.0\nsupervisor_checks==0.8.1\nwerkzeug==0.16.1\n# Install the dependencies of the bin/bundle-extensions script here.\n# It has its own requirements file to simplify the frontend client build process\n-r requirements_bundles.txt\n# Uncomment the requirement for ldap3 if using ldap.\n# It is not included by default because of the GPL license conflict.\n# ldap3==2.2.4\n"], "fixing_code": ["import hashlib\nimport hmac\nimport logging\nimport time\nfrom datetime import timedelta\nfrom urllib.parse import urlsplit, urlunsplit\n\nfrom flask import jsonify, redirect, request, url_for, session\nfrom flask_login import LoginManager, login_user, logout_user, user_logged_in\nfrom redash import models, settings\nfrom redash.authentication import jwt_auth\nfrom redash.authentication.org_resolving import current_org\nfrom redash.settings.organization import settings as org_settings\nfrom redash.tasks import record_event\nfrom sqlalchemy.orm.exc import NoResultFound\nfrom werkzeug.exceptions import Unauthorized\n\nlogin_manager = LoginManager()\nlogger = logging.getLogger(\"authentication\")\n\n\ndef get_login_url(external=False, next=\"/\"):\n    if settings.MULTI_ORG and current_org == None:\n        login_url = \"/\"\n    elif settings.MULTI_ORG:\n        login_url = url_for(\n            \"redash.login\", org_slug=current_org.slug, next=next, _external=external\n        )\n    else:\n        login_url = url_for(\"redash.login\", next=next, _external=external)\n\n    return login_url\n\n\ndef sign(key, path, expires):\n    if not key:\n        return None\n\n    h = hmac.new(key.encode(), msg=path.encode(), digestmod=hashlib.sha1)\n    h.update(str(expires).encode())\n\n    return h.hexdigest()\n\n\n@login_manager.user_loader\ndef load_user(user_id_with_identity):\n    user = api_key_load_user_from_request(request)\n    if user:\n        return user\n\n    org = current_org._get_current_object()\n\n    try:\n        user_id, _ = user_id_with_identity.split(\"-\")\n        user = models.User.get_by_id_and_org(user_id, org)\n        if user.is_disabled or user.get_id() != user_id_with_identity:\n            return None\n\n        return user\n    except (models.NoResultFound, ValueError, AttributeError):\n        return None\n\n\ndef request_loader(request):\n    user = None\n    if settings.AUTH_TYPE == \"hmac\":\n        user = hmac_load_user_from_request(request)\n    elif settings.AUTH_TYPE == \"api_key\":\n        user = api_key_load_user_from_request(request)\n    else:\n        logger.warning(\n            \"Unknown authentication type ({}). Using default (HMAC).\".format(\n                settings.AUTH_TYPE\n            )\n        )\n        user = hmac_load_user_from_request(request)\n\n    if org_settings[\"auth_jwt_login_enabled\"] and user is None:\n        user = jwt_token_load_user_from_request(request)\n    return user\n\n\ndef hmac_load_user_from_request(request):\n    signature = request.args.get(\"signature\")\n    expires = float(request.args.get(\"expires\") or 0)\n    query_id = request.view_args.get(\"query_id\", None)\n    user_id = request.args.get(\"user_id\", None)\n\n    # TODO: 3600 should be a setting\n    if signature and time.time() < expires <= time.time() + 3600:\n        if user_id:\n            user = models.User.query.get(user_id)\n            calculated_signature = sign(user.api_key, request.path, expires)\n\n            if user.api_key and signature == calculated_signature:\n                return user\n\n        if query_id:\n            query = models.Query.query.filter(models.Query.id == query_id).one()\n            calculated_signature = sign(query.api_key, request.path, expires)\n\n            if query.api_key and signature == calculated_signature:\n                return models.ApiUser(\n                    query.api_key,\n                    query.org,\n                    list(query.groups.keys()),\n                    name=\"ApiKey: Query {}\".format(query.id),\n                )\n\n    return None\n\n\ndef get_user_from_api_key(api_key, query_id):\n    if not api_key:\n        return None\n\n    user = None\n\n    # TODO: once we switch all api key storage into the ApiKey model, this code will be much simplified\n    org = current_org._get_current_object()\n    try:\n        user = models.User.get_by_api_key_and_org(api_key, org)\n        if user.is_disabled:\n            user = None\n    except models.NoResultFound:\n        try:\n            api_key = models.ApiKey.get_by_api_key(api_key)\n            user = models.ApiUser(api_key, api_key.org, [])\n        except models.NoResultFound:\n            if query_id:\n                query = models.Query.get_by_id_and_org(query_id, org)\n                if query and query.api_key == api_key:\n                    user = models.ApiUser(\n                        api_key,\n                        query.org,\n                        list(query.groups.keys()),\n                        name=\"ApiKey: Query {}\".format(query.id),\n                    )\n\n    return user\n\n\ndef get_api_key_from_request(request):\n    api_key = request.args.get(\"api_key\", None)\n\n    if api_key is not None:\n        return api_key\n\n    if request.headers.get(\"Authorization\"):\n        auth_header = request.headers.get(\"Authorization\")\n        api_key = auth_header.replace(\"Key \", \"\", 1)\n    elif request.view_args is not None and request.view_args.get(\"token\"):\n        api_key = request.view_args[\"token\"]\n\n    return api_key\n\n\ndef api_key_load_user_from_request(request):\n    api_key = get_api_key_from_request(request)\n    if request.view_args is not None:\n        query_id = request.view_args.get(\"query_id\", None)\n        user = get_user_from_api_key(api_key, query_id)\n    else:\n        user = None\n\n    return user\n\n\ndef jwt_token_load_user_from_request(request):\n    org = current_org._get_current_object()\n\n    payload = None\n\n    if org_settings[\"auth_jwt_auth_cookie_name\"]:\n        jwt_token = request.cookies.get(org_settings[\"auth_jwt_auth_cookie_name\"], None)\n    elif org_settings[\"auth_jwt_auth_header_name\"]:\n        jwt_token = request.headers.get(org_settings[\"auth_jwt_auth_header_name\"], None)\n    else:\n        return None\n\n    if jwt_token:\n        payload, token_is_valid = jwt_auth.verify_jwt_token(\n            jwt_token,\n            expected_issuer=org_settings[\"auth_jwt_auth_issuer\"],\n            expected_audience=org_settings[\"auth_jwt_auth_audience\"],\n            algorithms=org_settings[\"auth_jwt_auth_algorithms\"],\n            public_certs_url=org_settings[\"auth_jwt_auth_public_certs_url\"],\n        )\n        if not token_is_valid:\n            raise Unauthorized(\"Invalid JWT token\")\n\n    if not payload:\n        return\n\n    try:\n        user = models.User.get_by_email_and_org(payload[\"email\"], org)\n    except models.NoResultFound:\n        user = create_and_login_user(current_org, payload[\"email\"], payload[\"email\"])\n\n    return user\n\n\ndef log_user_logged_in(app, user):\n    event = {\n        \"org_id\": user.org_id,\n        \"user_id\": user.id,\n        \"action\": \"login\",\n        \"object_type\": \"redash\",\n        \"timestamp\": int(time.time()),\n        \"user_agent\": request.user_agent.string,\n        \"ip\": request.remote_addr,\n    }\n\n    record_event.delay(event)\n\n\n@login_manager.unauthorized_handler\ndef redirect_to_login():\n    if request.is_xhr or \"/api/\" in request.path:\n        response = jsonify(\n            {\"message\": \"Couldn't find resource. Please login and try again.\"}\n        )\n        response.status_code = 404\n        return response\n\n    login_url = get_login_url(next=request.url, external=False)\n\n    return redirect(login_url)\n\n\ndef logout_and_redirect_to_index():\n    logout_user()\n\n    if settings.MULTI_ORG and current_org == None:\n        index_url = \"/\"\n    elif settings.MULTI_ORG:\n        index_url = url_for(\"redash.index\", org_slug=current_org.slug, _external=False)\n    else:\n        index_url = url_for(\"redash.index\", _external=False)\n\n    return redirect(index_url)\n\n\ndef init_app(app):\n    from redash.authentication import (\n        saml_auth,\n        remote_user_auth,\n        ldap_auth,\n    )\n\n    from redash.authentication.google_oauth import create_google_oauth_blueprint\n\n    login_manager.init_app(app)\n    login_manager.anonymous_user = models.AnonymousUser\n    login_manager.REMEMBER_COOKIE_DURATION = settings.REMEMBER_COOKIE_DURATION\n\n    @app.before_request\n    def extend_session():\n        session.permanent = True\n        app.permanent_session_lifetime = timedelta(seconds=settings.SESSION_EXPIRY_TIME)\n\n    from redash.security import csrf\n\n    # Authlib's flask oauth client requires a Flask app to initialize\n    for blueprint in [create_google_oauth_blueprint(app), saml_auth.blueprint, remote_user_auth.blueprint, ldap_auth.blueprint, ]:\n        csrf.exempt(blueprint)\n        app.register_blueprint(blueprint)\n\n    user_logged_in.connect(log_user_logged_in)\n    login_manager.request_loader(request_loader)\n\n\ndef create_and_login_user(org, name, email, picture=None):\n    try:\n        user_object = models.User.get_by_email_and_org(email, org)\n        if user_object.is_disabled:\n            return None\n        if user_object.is_invitation_pending:\n            user_object.is_invitation_pending = False\n            models.db.session.commit()\n        if user_object.name != name:\n            logger.debug(\"Updating user name (%r -> %r)\", user_object.name, name)\n            user_object.name = name\n            models.db.session.commit()\n    except NoResultFound:\n        logger.debug(\"Creating user object (%r)\", name)\n        user_object = models.User(\n            org=org,\n            name=name,\n            email=email,\n            is_invitation_pending=False,\n            _profile_image_url=picture,\n            group_ids=[org.default_group.id],\n        )\n        models.db.session.add(user_object)\n        models.db.session.commit()\n\n    login_user(user_object, remember=True)\n\n    return user_object\n\n\ndef get_next_path(unsafe_next_path):\n    if not unsafe_next_path:\n        return \"\"\n\n    # Preventing open redirection attacks\n    parts = list(urlsplit(unsafe_next_path))\n    parts[0] = \"\"  # clear scheme\n    parts[1] = \"\"  # clear netloc\n    safe_next_path = urlunsplit(parts)\n\n    # If the original path was a URL, we might end up with an empty\n    # safe url, which will redirect to the login page. Changing to\n    # relative root to redirect to the app root after login.\n    if not safe_next_path:\n        safe_next_path = \"./\"\n\n    return safe_next_path\n", "import logging\nimport requests\nfrom flask import redirect, url_for, Blueprint, flash, request, session\n\n\nfrom redash import models, settings\nfrom redash.authentication import (\n    create_and_login_user,\n    logout_and_redirect_to_index,\n    get_next_path,\n)\nfrom redash.authentication.org_resolving import current_org\n\nfrom authlib.integrations.flask_client import OAuth\n\n\ndef verify_profile(org, profile):\n    if org.is_public:\n        return True\n\n    email = profile[\"email\"]\n    domain = email.split(\"@\")[-1]\n\n    if domain in org.google_apps_domains:\n        return True\n\n    if org.has_user(email) == 1:\n        return True\n\n    return False\n\n\ndef create_google_oauth_blueprint(app):\n    oauth = OAuth(app)\n\n    logger = logging.getLogger(\"google_oauth\")\n    blueprint = Blueprint(\"google_oauth\", __name__)\n\n    CONF_URL = \"https://accounts.google.com/.well-known/openid-configuration\"\n    oauth = OAuth(app)\n    oauth.register(\n        name=\"google\",\n        server_metadata_url=CONF_URL,\n        client_kwargs={\"scope\": \"openid email profile\"},\n    )\n\n    def get_user_profile(access_token):\n        headers = {\"Authorization\": \"OAuth {}\".format(access_token)}\n        response = requests.get(\n            \"https://www.googleapis.com/oauth2/v1/userinfo\", headers=headers\n        )\n\n        if response.status_code == 401:\n            logger.warning(\"Failed getting user profile (response code 401).\")\n            return None\n\n        return response.json()\n\n    @blueprint.route(\"/<org_slug>/oauth/google\", endpoint=\"authorize_org\")\n    def org_login(org_slug):\n        session[\"org_slug\"] = current_org.slug\n        return redirect(url_for(\".authorize\", next=request.args.get(\"next\", None)))\n\n    @blueprint.route(\"/oauth/google\", endpoint=\"authorize\")\n    def login():\n\n        redirect_uri = url_for(\".callback\", _external=True)\n\n        next_path = request.args.get(\n            \"next\", url_for(\"redash.index\", org_slug=session.get(\"org_slug\"))\n        )\n        logger.debug(\"Callback url: %s\", redirect_uri)\n        logger.debug(\"Next is: %s\", next_path)\n\n        session[\"next_url\"] = next_path\n\n        return oauth.google.authorize_redirect(redirect_uri)\n\n    @blueprint.route(\"/oauth/google_callback\", endpoint=\"callback\")\n    def authorized():\n\n        logger.debug(\"Authorized user inbound\")\n\n        resp = oauth.google.authorize_access_token()\n        user = resp.get(\"userinfo\")\n        if user:\n            session[\"user\"] = user\n\n        access_token = resp[\"access_token\"]\n\n        if access_token is None:\n            logger.warning(\"Access token missing in call back request.\")\n            flash(\"Validation error. Please retry.\")\n            return redirect(url_for(\"redash.login\"))\n\n        profile = get_user_profile(access_token)\n        if profile is None:\n            flash(\"Validation error. Please retry.\")\n            return redirect(url_for(\"redash.login\"))\n\n        if \"org_slug\" in session:\n            org = models.Organization.get_by_slug(session.pop(\"org_slug\"))\n        else:\n            org = current_org\n\n        if not verify_profile(org, profile):\n            logger.warning(\n                \"User tried to login with unauthorized domain name: %s (org: %s)\",\n                profile[\"email\"],\n                org,\n            )\n            flash(\n                \"Your Google Apps account ({}) isn't allowed.\".format(profile[\"email\"])\n            )\n            return redirect(url_for(\"redash.login\", org_slug=org.slug))\n\n        picture_url = \"%s?sz=40\" % profile[\"picture\"]\n        user = create_and_login_user(\n            org, profile[\"name\"], profile[\"email\"], picture_url\n        )\n        if user is None:\n            return logout_and_redirect_to_index()\n\n        unsafe_next_path = session.get(\"next_url\") or url_for(\n            \"redash.index\", org_slug=org.slug\n        )\n        next_path = get_next_path(unsafe_next_path)\n\n        return redirect(next_path)\n\n    return blueprint\n", "Flask==1.1.1\nJinja2==2.10.3\nitsdangerous==1.1.0\nclick==6.7\nMarkupSafe==1.1.1\npyOpenSSL==19.0.0\nhttplib2==0.14.0\nwtforms==2.2.1\nFlask-RESTful==0.3.7\nFlask-Login==0.4.1\nFlask-SQLAlchemy==2.4.1\nFlask-Migrate==2.5.2\nflask-mail==0.9.1\nflask-talisman==0.7.0\nFlask-Limiter==0.9.3\nFlask-WTF==0.14.3\npasslib==1.7.1\naniso8601==8.0.0\nblinker==1.4\npsycopg2==2.8.3\npython-dateutil==2.8.0\npytz>=2019.3\nPyYAML==5.1.2\nredis==3.5.0\nrequests==2.21.0\nSQLAlchemy==1.3.10\n# We can't upgrade SQLAlchemy-Searchable version as newer versions require PostgreSQL > 9.6, but we target older versions at the moment.\nSQLAlchemy-Searchable==0.10.6\n# We need to pin the version of pyparsing, as newer versions break SQLAlchemy-Searchable-10.0.6 (newer versions no longer depend on it)\npyparsing==2.3.0\nSQLAlchemy-Utils==0.34.2\nsqlparse==0.3.0\nstatsd==3.3.0\ngreenlet==0.4.16\ngunicorn==20.0.4\nrq==1.5.0\nrq-scheduler==0.9.1\njsonschema==3.1.1\nRestrictedPython==5.0\npysaml2==6.1.0\npycrypto==2.6.1\nfuncy==1.13\nsentry-sdk>=0.14.3,<0.15.0\nsemver==2.8.1\nxlsxwriter==1.2.2\npystache==0.5.4\nparsedatetime==2.4\nPyJWT==1.7.1\ncryptography==2.8\nsimplejson==3.16.0\nua-parser==0.8.0\nuser-agents==2.0\nmaxminddb-geolite2==2018.703\npypd==1.1.0\ndisposable-email-domains>=0.0.52\ngevent==1.4.0\nsshtunnel==0.1.5\nsupervisor==4.1.0\nsupervisor_checks==0.8.1\nwerkzeug==0.16.1\n# Install the dependencies of the bin/bundle-extensions script here.\n# It has its own requirements file to simplify the frontend client build process\n-r requirements_bundles.txt\n# Uncomment the requirement for ldap3 if using ldap.\n# It is not included by default because of the GPL license conflict.\n# ldap3==2.2.4\nAuthlib==0.15.5"], "filenames": ["redash/authentication/__init__.py", "redash/authentication/google_oauth.py", "requirements.txt"], "buggy_code_start_loc": [246, 4, 11], "buggy_code_end_loc": [264, 125, 69], "fixing_code_start_loc": [245, 4, 10], "fixing_code_end_loc": [266, 132, 68], "type": "CWE-601", "message": "Redash is a package for data visualization and sharing. In Redash version 10.0 and prior, the implementation of Google Login (via OAuth) incorrectly uses the `state` parameter to pass the next URL to redirect the user to after login. The `state` parameter should be used for a Cross-Site Request Forgery (CSRF) token, not a static and easily predicted value. This vulnerability does not affect users who do not use Google Login for their instance of Redash. A patch in the `master` and `release/10.x.x` branches addresses this by replacing `Flask-Oauthlib` with `Authlib` which automatically provides and validates a CSRF token for the state variable. The new implementation stores the next URL on the user session object. As a workaround, one may disable Google Login to mitigate the vulnerability.", "other": {"cve": {"id": "CVE-2021-43777", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-24T16:15:14.257", "lastModified": "2021-11-30T15:39:23.900", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redash is a package for data visualization and sharing. In Redash version 10.0 and prior, the implementation of Google Login (via OAuth) incorrectly uses the `state` parameter to pass the next URL to redirect the user to after login. The `state` parameter should be used for a Cross-Site Request Forgery (CSRF) token, not a static and easily predicted value. This vulnerability does not affect users who do not use Google Login for their instance of Redash. A patch in the `master` and `release/10.x.x` branches addresses this by replacing `Flask-Oauthlib` with `Authlib` which automatically provides and validates a CSRF token for the state variable. The new implementation stores the next URL on the user session object. As a workaround, one may disable Google Login to mitigate the vulnerability."}, {"lang": "es", "value": "Redash es un paquete para visualizar y compartir datos. En la versi\u00f3n 10.0 de Redash y anteriores, la implementaci\u00f3n de Google Login (por medio de OAuth) usa incorrectamente el par\u00e1metro \"state\" para pasar la siguiente URL a la que redirigir al usuario despu\u00e9s de iniciar sesi\u00f3n. El par\u00e1metro \"state\" deber\u00eda ser usado para un token de tipo Cross-Site Request Forgery (CSRF), no un valor est\u00e1tico y f\u00e1cilmente predecible. Esta vulnerabilidad no afecta a usuarios que no usan Google Login para su instancia de Redash. Un parche en las ramas \"master\" y \"release/10.x.x\" aborda esto sustituyendo \"Flask-Oauthlib\" por \"Authlib\" que proporciona y comprueba autom\u00e1ticamente un token CSRF para la variable de estado. La nueva implementaci\u00f3n almacena la siguiente URL en el objeto de sesi\u00f3n del usuario. Como soluci\u00f3n, puede ser deshabilitado Google Login para mitigar la vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redash:redash:*:*:*:*:*:*:*:*", "versionEndIncluding": "10.0.0", "matchCriteriaId": "5D326B6D-E6EE-4598-845F-63258E732F02"}]}]}], "references": [{"url": "https://github.com/getredash/redash/commit/da696ff7f84787cbf85967460fac52886cbe063e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/getredash/redash/security/advisories/GHSA-vhc7-w7r8-8m34", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/getredash/redash/commit/da696ff7f84787cbf85967460fac52886cbe063e"}}