{"buggy_code": ["/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Main program structure.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <sys/utsname.h>\n#include <sys/resource.h>\n#include <stdbool.h>\n#ifdef HAVE_SIGNALFD\n#include <sys/signalfd.h>\n#endif\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <linux/version.h>\n#include <ctype.h>\n\n#include \"main.h\"\n#include \"global_data.h\"\n#include \"daemon.h\"\n#include \"config.h\"\n#include \"git-commit.h\"\n#include \"utils.h\"\n#include \"signals.h\"\n#include \"pidfile.h\"\n#include \"bitops.h\"\n#include \"logger.h\"\n#include \"parser.h\"\n#include \"notify.h\"\n#include \"utils.h\"\n#ifdef _WITH_LVS_\n#include \"check_parser.h\"\n#include \"check_daemon.h\"\n#endif\n#ifdef _WITH_VRRP_\n#include \"vrrp_daemon.h\"\n#include \"vrrp_parser.h\"\n#include \"vrrp_if.h\"\n#ifdef _WITH_JSON_\n#include \"vrrp_json.h\"\n#endif\n#endif\n#ifdef _WITH_BFD_\n#include \"bfd_daemon.h\"\n#include \"bfd_parser.h\"\n#endif\n#include \"global_parser.h\"\n#if HAVE_DECL_CLONE_NEWNET\n#include \"namespaces.h\"\n#endif\n#include \"scheduler.h\"\n#include \"keepalived_netlink.h\"\n#include \"git-commit.h\"\n#if defined THREAD_DUMP || defined _EPOLL_DEBUG_ || defined _EPOLL_THREAD_DUMP_\n#include \"scheduler.h\"\n#endif\n#include \"process.h\"\n#ifdef _TIMER_CHECK_\n#include \"timer.h\"\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n#include \"smtp.h\"\n#endif\n#if defined _REGEX_DEBUG_ || defined _WITH_REGEX_TIMERS_\n#include \"check_http.h\"\n#endif\n#ifdef _TSM_DEBUG_\n#include \"vrrp_scheduler.h\"\n#endif\n\n/* musl libc doesn't define the following */\n#ifndef\tW_EXITCODE\n#define\tW_EXITCODE(ret, sig)\t((ret) << 8 | (sig))\n#endif\n#ifndef\tWCOREFLAG\n#define\tWCOREFLAG\t\t((int32_t)WCOREDUMP(0xffffffff))\n#endif\n\n#define\tVERSION_STRING\t\tPACKAGE_NAME \" v\" PACKAGE_VERSION \" (\" GIT_DATE \")\"\n#define COPYRIGHT_STRING\t\"Copyright(C) 2001-\" GIT_YEAR \" Alexandre Cassen, <acassen@gmail.com>\"\n\n#define CHILD_WAIT_SECS\t5\n\n/* global var */\nconst char *version_string = VERSION_STRING;\t\t/* keepalived version */\nchar *conf_file = KEEPALIVED_CONFIG_FILE;\t\t/* Configuration file */\nint log_facility = LOG_DAEMON;\t\t\t\t/* Optional logging facilities */\nbool reload;\t\t\t\t\t\t/* Set during a reload */\nchar *main_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_main_pidfile;\n#ifdef _WITH_LVS_\npid_t checkers_child;\t\t\t\t\t/* Healthcheckers child process ID */\nchar *checkers_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_checkers_pidfile;\n#endif\n#ifdef _WITH_VRRP_\npid_t vrrp_child;\t\t\t\t\t/* VRRP child process ID */\nchar *vrrp_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_vrrp_pidfile;\n#endif\n#ifdef _WITH_BFD_\npid_t bfd_child;\t\t\t\t\t/* BFD child process ID */\nchar *bfd_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_bfd_pidfile;\n#endif\nunsigned long daemon_mode;\t\t\t\t/* VRRP/CHECK/BFD subsystem selection */\n#ifdef _WITH_SNMP_\nbool snmp;\t\t\t\t\t\t/* Enable SNMP support */\nconst char *snmp_socket;\t\t\t\t/* Socket to use for SNMP agent */\n#endif\nstatic char *syslog_ident;\t\t\t\t/* syslog ident if not default */\nbool use_pid_dir;\t\t\t\t\t/* Put pid files in /var/run/keepalived or @localstatedir@/run/keepalived */\n\nunsigned os_major;\t\t\t\t\t/* Kernel version */\nunsigned os_minor;\nunsigned os_release;\nchar *hostname;\t\t\t\t\t\t/* Initial part of hostname */\n\n#if HAVE_DECL_CLONE_NEWNET\nstatic char *override_namespace;\t\t\t/* If namespace specified on command line */\n#endif\n\nunsigned child_wait_time = CHILD_WAIT_SECS;\t\t/* Time to wait for children to exit */\n\n/* Log facility table */\nstatic struct {\n\tint facility;\n} LOG_FACILITY[] = {\n\t{LOG_LOCAL0}, {LOG_LOCAL1}, {LOG_LOCAL2}, {LOG_LOCAL3},\n\t{LOG_LOCAL4}, {LOG_LOCAL5}, {LOG_LOCAL6}, {LOG_LOCAL7}\n};\n#define\tLOG_FACILITY_MAX\t((sizeof(LOG_FACILITY) / sizeof(LOG_FACILITY[0])) - 1)\n\n/* umask settings */\nbool umask_cmdline;\nstatic mode_t umask_val = S_IXUSR | S_IWGRP | S_IXGRP | S_IWOTH | S_IXOTH;\n\n/* Control producing core dumps */\nstatic bool set_core_dump_pattern = false;\nstatic bool create_core_dump = false;\nstatic const char *core_dump_pattern = \"core\";\nstatic char *orig_core_dump_pattern = NULL;\n\n/* debug flags */\n#if defined _TIMER_CHECK_ || defined _SMTP_ALERT_DEBUG_ || defined _EPOLL_DEBUG_ || defined _EPOLL_THREAD_DUMP_ || defined _REGEX_DEBUG_ || defined _WITH_REGEX_TIMERS_ || defined _TSM_DEBUG_ || defined _VRRP_FD_DEBUG_ || defined _NETLINK_TIMERS_\n#define WITH_DEBUG_OPTIONS 1\n#endif\n\n#ifdef _TIMER_CHECK_\nstatic char timer_debug;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\nstatic char smtp_debug;\n#endif\n#ifdef _EPOLL_DEBUG_\nstatic char epoll_debug;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\nstatic char epoll_thread_debug;\n#endif\n#ifdef _REGEX_DEBUG_\nstatic char regex_debug;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\nstatic char regex_timers;\n#endif\n#ifdef _TSM_DEBUG_\nstatic char tsm_debug;\n#endif\n#ifdef _VRRP_FD_DEBUG_\nstatic char vrrp_fd_debug;\n#endif\n#ifdef _NETLINK_TIMERS_\nstatic char netlink_timer_debug;\n#endif\n\nvoid\nfree_parent_mallocs_startup(bool am_child)\n{\n\tif (am_child) {\n#if HAVE_DECL_CLONE_NEWNET\n\t\tfree_dirname();\n#endif\n#ifndef _MEM_CHECK_LOG_\n\t\tFREE_PTR(syslog_ident);\n#else\n\t\tfree(syslog_ident);\n#endif\n\t\tsyslog_ident = NULL;\n\n\t\tFREE_PTR(orig_core_dump_pattern);\n\t}\n\n\tif (free_main_pidfile) {\n\t\tFREE_PTR(main_pidfile);\n\t\tfree_main_pidfile = false;\n\t}\n}\n\nvoid\nfree_parent_mallocs_exit(void)\n{\n#ifdef _WITH_VRRP_\n\tif (free_vrrp_pidfile)\n\t\tFREE_PTR(vrrp_pidfile);\n#endif\n#ifdef _WITH_LVS_\n\tif (free_checkers_pidfile)\n\t\tFREE_PTR(checkers_pidfile);\n#endif\n#ifdef _WITH_BFD_\n\tif (free_bfd_pidfile)\n\t\tFREE_PTR(bfd_pidfile);\n#endif\n\n\tFREE_PTR(config_id);\n}\n\nchar *\nmake_syslog_ident(const char* name)\n{\n\tsize_t ident_len = strlen(name) + 1;\n\tchar *ident;\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace)\n\t\tident_len += strlen(global_data->network_namespace) + 1;\n#endif\n\tif (global_data->instance_name)\n\t\tident_len += strlen(global_data->instance_name) + 1;\n\n\t/* If we are writing MALLOC/FREE info to the log, we have\n\t * trouble FREEing the syslog_ident */\n#ifndef _MEM_CHECK_LOG_\n\tident = MALLOC(ident_len);\n#else\n\tident = malloc(ident_len);\n#endif\n\n\tif (!ident)\n\t\treturn NULL;\n\n\tstrcpy(ident, name);\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace) {\n\t\tstrcat(ident, \"_\");\n\t\tstrcat(ident, global_data->network_namespace);\n\t}\n#endif\n\tif (global_data->instance_name) {\n\t\tstrcat(ident, \"_\");\n\t\tstrcat(ident, global_data->instance_name);\n\t}\n\n\treturn ident;\n}\n\nstatic char *\nmake_pidfile_name(const char* start, const char* instance, const char* extn)\n{\n\tsize_t len;\n\tchar *name;\n\n\tlen = strlen(start) + 1;\n\tif (instance)\n\t\tlen += strlen(instance) + 1;\n\tif (extn)\n\t\tlen += strlen(extn);\n\n\tname = MALLOC(len);\n\tif (!name) {\n\t\tlog_message(LOG_INFO, \"Unable to make pidfile name for %s\", start);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(name, start);\n\tif (instance) {\n\t\tstrcat(name, \"_\");\n\t\tstrcat(name, instance);\n\t}\n\tif (extn)\n\t\tstrcat(name, extn);\n\n\treturn name;\n}\n\n#ifdef _WITH_VRRP_\nbool\nrunning_vrrp(void)\n{\n\treturn (__test_bit(DAEMON_VRRP, &daemon_mode) &&\n\t    (global_data->have_vrrp_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\n#ifdef _WITH_LVS_\nbool\nrunning_checker(void)\n{\n\treturn (__test_bit(DAEMON_CHECKERS, &daemon_mode) &&\n\t    (global_data->have_checker_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\n#ifdef _WITH_BFD_\nbool\nrunning_bfd(void)\n{\n\treturn (__test_bit(DAEMON_BFD, &daemon_mode) &&\n\t    (global_data->have_bfd_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\nstatic char const *\nfind_keepalived_child_name(pid_t pid)\n{\n#ifdef _WITH_LVS_\n\tif (pid == checkers_child)\n\t\treturn PROG_CHECK;\n#endif\n#ifdef _WITH_VRRP_\n\tif (pid == vrrp_child)\n\t\treturn PROG_VRRP;\n#endif\n#ifdef _WITH_BFD_\n\tif (pid == bfd_child)\n\t\treturn PROG_BFD;\n#endif\n\n\treturn NULL;\n}\n\nstatic vector_t *\nglobal_init_keywords(void)\n{\n\t/* global definitions mapping */\n\tinit_global_keywords(true);\n\n#ifdef _WITH_VRRP_\n\tinit_vrrp_keywords(false);\n#endif\n#ifdef _WITH_LVS_\n\tinit_check_keywords(false);\n#endif\n#ifdef _WITH_BFD_\n\tinit_bfd_keywords(false);\n#endif\n\n\treturn keywords;\n}\n\nstatic void\nread_config_file(void)\n{\n\tinit_data(conf_file, global_init_keywords);\n}\n\n/* Daemon stop sequence */\nvoid\nstop_keepalived(void)\n{\n#ifndef _DEBUG_\n\t/* Just cleanup memory & exit */\n\tthread_destroy_master(master);\n\n#ifdef _WITH_VRRP_\n\tif (__test_bit(DAEMON_VRRP, &daemon_mode))\n\t\tpidfile_rm(vrrp_pidfile);\n#endif\n\n#ifdef _WITH_LVS_\n\tif (__test_bit(DAEMON_CHECKERS, &daemon_mode))\n\t\tpidfile_rm(checkers_pidfile);\n#endif\n\n#ifdef _WITH_BFD_\n\tif (__test_bit(DAEMON_BFD, &daemon_mode))\n\t\tpidfile_rm(bfd_pidfile);\n#endif\n\n\tpidfile_rm(main_pidfile);\n#endif\n}\n\n/* Daemon init sequence */\nstatic int\nstart_keepalived(void)\n{\n\tbool have_child = false;\n\n#ifdef _WITH_BFD_\n\t/* must be opened before vrrp and bfd start */\n\topen_bfd_pipes();\n#endif\n\n#ifdef _WITH_LVS_\n\t/* start healthchecker child */\n\tif (running_checker()) {\n\t\tstart_check_child();\n\t\thave_child = true;\n\t}\n#endif\n#ifdef _WITH_VRRP_\n\t/* start vrrp child */\n\tif (running_vrrp()) {\n\t\tstart_vrrp_child();\n\t\thave_child = true;\n\t}\n#endif\n#ifdef _WITH_BFD_\n\t/* start bfd child */\n\tif (running_bfd()) {\n\t\tstart_bfd_child();\n\t\thave_child = true;\n\t}\n#endif\n\n\treturn have_child;\n}\n\nstatic void\nvalidate_config(void)\n{\n#ifdef _WITH_VRRP_\n\tkernel_netlink_read_interfaces();\n#endif\n\n#ifdef _WITH_LVS_\n\t/* validate healthchecker config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_CHECKER;\n#endif\n\tcheck_validate_config();\n#endif\n#ifdef _WITH_VRRP_\n\t/* validate vrrp config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_VRRP;\n#endif\n\tvrrp_validate_config();\n#endif\n#ifdef _WITH_BFD_\n\t/* validate bfd config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_BFD;\n#endif\n\tbfd_validate_config();\n#endif\n}\n\nstatic void\nconfig_test_exit(void)\n{\n\tconfig_err_t config_err = get_config_status();\n\n\tswitch (config_err) {\n\tcase CONFIG_OK:\n\t\texit(KEEPALIVED_EXIT_OK);\n\tcase CONFIG_FILE_NOT_FOUND:\n\tcase CONFIG_BAD_IF:\n\tcase CONFIG_FATAL:\n\t\texit(KEEPALIVED_EXIT_CONFIG);\n\tcase CONFIG_SECURITY_ERROR:\n\t\texit(KEEPALIVED_EXIT_CONFIG_TEST_SECURITY);\n\tdefault:\n\t\texit(KEEPALIVED_EXIT_CONFIG_TEST);\n\t}\n}\n\n#ifndef _DEBUG_\nstatic bool reload_config(void)\n{\n\tbool unsupported_change = false;\n\n\tlog_message(LOG_INFO, \"Reloading ...\");\n\n\t/* Make sure there isn't an attempt to change the network namespace or instance name */\n\told_global_data = global_data;\n\tglobal_data = NULL;\n\tglobal_data = alloc_global_data();\n\n\tread_config_file();\n\n\tinit_global_data(global_data, old_global_data);\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (!!old_global_data->network_namespace != !!global_data->network_namespace ||\n\t    (global_data->network_namespace && strcmp(old_global_data->network_namespace, global_data->network_namespace))) {\n\t\tlog_message(LOG_INFO, \"Cannot change network namespace at a reload - please restart %s\", PACKAGE);\n\t\tunsupported_change = true;\n\t}\n\tFREE_PTR(global_data->network_namespace);\n\tglobal_data->network_namespace = old_global_data->network_namespace;\n\told_global_data->network_namespace = NULL;\n#endif\n\n\tif (!!old_global_data->instance_name != !!global_data->instance_name ||\n\t    (global_data->instance_name && strcmp(old_global_data->instance_name, global_data->instance_name))) {\n\t\tlog_message(LOG_INFO, \"Cannot change instance name at a reload - please restart %s\", PACKAGE);\n\t\tunsupported_change = true;\n\t}\n\tFREE_PTR(global_data->instance_name);\n\tglobal_data->instance_name = old_global_data->instance_name;\n\told_global_data->instance_name = NULL;\n\n\tif (unsupported_change) {\n\t\t/* We cannot reload the configuration, so continue with the old config */\n\t\tfree_global_data (global_data);\n\t\tglobal_data = old_global_data;\n\t}\n\telse\n\t\tfree_global_data (old_global_data);\n\n\treturn !unsupported_change;\n}\n\n/* SIGHUP/USR1/USR2 handler */\nstatic void\npropagate_signal(__attribute__((unused)) void *v, int sig)\n{\n\tif (sig == SIGHUP) {\n\t\tif (!reload_config())\n\t\t\treturn;\n\t}\n\n\t/* Signal child processes */\n#ifdef _WITH_VRRP_\n\tif (vrrp_child > 0)\n\t\tkill(vrrp_child, sig);\n\telse if (sig == SIGHUP && running_vrrp())\n\t\tstart_vrrp_child();\n#endif\n#ifdef _WITH_LVS_\n\tif (sig == SIGHUP) {\n\t\tif (checkers_child > 0)\n\t\t\tkill(checkers_child, sig);\n\t\telse if (running_checker())\n\t\t\tstart_check_child();\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (sig == SIGHUP) {\n\t\tif (bfd_child > 0)\n\t\t\tkill(bfd_child, sig);\n\t\telse if (running_bfd())\n\t\t\tstart_bfd_child();\n\t}\n#endif\n}\n\n/* Terminate handler */\nstatic void\nsigend(__attribute__((unused)) void *v, __attribute__((unused)) int sig)\n{\n\tint status;\n\tint ret;\n\tint wait_count = 0;\n\tstruct timeval start_time, now;\n#ifdef HAVE_SIGNALFD\n\tstruct timeval timeout = {\n\t\t.tv_sec = child_wait_time,\n\t\t.tv_usec = 0\n\t};\n\tint signal_fd = master->signal_fd;\n\tfd_set read_set;\n\tstruct signalfd_siginfo siginfo;\n\tsigset_t sigmask;\n#else\n\tsigset_t old_set, child_wait;\n\tstruct timespec timeout = {\n\t\t.tv_sec = child_wait_time,\n\t\t.tv_nsec = 0\n\t};\n#endif\n\n\t/* register the terminate thread */\n\tthread_add_terminate_event(master);\n\n\tlog_message(LOG_INFO, \"Stopping\");\n\n#ifdef HAVE_SIGNALFD\n\t/* We only want to receive SIGCHLD now */\n\tsigemptyset(&sigmask);\n\tsigaddset(&sigmask, SIGCHLD);\n\tsignalfd(signal_fd, &sigmask, 0);\n\tFD_ZERO(&read_set);\n#else\n\tsigmask_func(0, NULL, &old_set);\n\tif (!sigismember(&old_set, SIGCHLD)) {\n\t\tsigemptyset(&child_wait);\n\t\tsigaddset(&child_wait, SIGCHLD);\n\t\tsigmask_func(SIG_BLOCK, &child_wait, NULL);\n\t}\n#endif\n\n#ifdef _WITH_VRRP_\n\tif (vrrp_child > 0) {\n\t\tif (kill(vrrp_child, SIGTERM)) {\n\t\t\t/* ESRCH means no such process */\n\t\t\tif (errno == ESRCH)\n\t\t\t\tvrrp_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (checkers_child > 0) {\n\t\tif (kill(checkers_child, SIGTERM)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tcheckers_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (bfd_child > 0) {\n\t\tif (kill(bfd_child, SIGTERM)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tbfd_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n\n\tgettimeofday(&start_time, NULL);\n\twhile (wait_count) {\n#ifdef HAVE_SIGNALFD\n\t\tFD_SET(signal_fd, &read_set);\n\t\tret = select(signal_fd + 1, &read_set, NULL, NULL, &timeout);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tlog_message(LOG_INFO, \"Terminating select returned errno %d\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!FD_ISSET(signal_fd, &read_set)) {\n\t\t\tlog_message(LOG_INFO, \"Terminating select did not return select_fd\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (read(signal_fd, &siginfo, sizeof(siginfo)) != sizeof(siginfo)) {\n\t\t\tlog_message(LOG_INFO, \"Terminating signal read did not read entire siginfo\");\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = siginfo.ssi_code == CLD_EXITED ? W_EXITCODE(siginfo.ssi_status, 0) :\n\t\t\t siginfo.ssi_code == CLD_KILLED ? W_EXITCODE(0, siginfo.ssi_status) :\n\t\t\t\t\t\t\t   WCOREFLAG;\n\n#ifdef _WITH_VRRP_\n\t\tif (vrrp_child > 0 && vrrp_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, vrrp_child, PROG_VRRP);\n\t\t\tvrrp_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#ifdef _WITH_LVS_\n\t\tif (checkers_child > 0 && checkers_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, checkers_child, PROG_CHECK);\n\t\t\tcheckers_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n#ifdef _WITH_BFD_\n\t\tif (bfd_child > 0 && bfd_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, bfd_child, PROG_BFD);\n\t\t\tbfd_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#else\n\t\tret = sigtimedwait(&child_wait, NULL, &timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tbreak;\n\t\t}\n\n#ifdef _WITH_VRRP_\n\t\tif (vrrp_child > 0 && vrrp_child == waitpid(vrrp_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, vrrp_child, PROG_VRRP);\n\t\t\tvrrp_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#ifdef _WITH_LVS_\n\t\tif (checkers_child > 0 && checkers_child == waitpid(checkers_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, checkers_child, PROG_CHECK);\n\t\t\tcheckers_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n#ifdef _WITH_BFD_\n\t\tif (bfd_child > 0 && bfd_child == waitpid(bfd_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, bfd_child, PROG_BFD);\n\t\t\tbfd_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#endif\n\n\t\tif (wait_count) {\n\t\t\tgettimeofday(&now, NULL);\n\t\t\ttimeout.tv_sec = child_wait_time - (now.tv_sec - start_time.tv_sec);\n#ifdef HAVE_SIGNALFD\n\t\t\ttimeout.tv_usec = (start_time.tv_usec - now.tv_usec);\n\t\t\tif (timeout.tv_usec < 0) {\n\t\t\t\ttimeout.tv_usec += 1000000L;\n\t\t\t\ttimeout.tv_sec--;\n\t\t\t}\n#else\n\t\t\ttimeout.tv_nsec = (start_time.tv_usec - now.tv_usec) * 1000;\n\t\t\tif (timeout.tv_nsec < 0) {\n\t\t\t\ttimeout.tv_nsec += 1000000000L;\n\t\t\t\ttimeout.tv_sec--;\n\t\t\t}\n#endif\n\t\t\tif (timeout.tv_sec < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* A child may not have terminated, so force its termination */\n#ifdef _WITH_VRRP_\n\tif (vrrp_child) {\n\t\tlog_message(LOG_INFO, \"vrrp process failed to die - forcing termination\");\n\t\tkill(vrrp_child, SIGKILL);\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (checkers_child) {\n\t\tlog_message(LOG_INFO, \"checker process failed to die - forcing termination\");\n\t\tkill(checkers_child, SIGKILL);\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (bfd_child) {\n\t\tlog_message(LOG_INFO, \"bfd process failed to die - forcing termination\");\n\t\tkill(bfd_child, SIGKILL);\n\t}\n#endif\n\n#ifndef HAVE_SIGNALFD\n\tif (!sigismember(&old_set, SIGCHLD))\n\t\tsigmask_func(SIG_UNBLOCK, &child_wait, NULL);\n#endif\n}\n#endif\n\n/* Initialize signal handler */\nstatic void\nsignal_init(void)\n{\n#ifndef _DEBUG_\n\tsignal_set(SIGHUP, propagate_signal, NULL);\n\tsignal_set(SIGUSR1, propagate_signal, NULL);\n\tsignal_set(SIGUSR2, propagate_signal, NULL);\n#ifdef _WITH_JSON_\n\tsignal_set(SIGJSON, propagate_signal, NULL);\n#endif\n\tsignal_set(SIGINT, sigend, NULL);\n\tsignal_set(SIGTERM, sigend, NULL);\n#endif\n\tsignal_ignore(SIGPIPE);\n}\n\n/* To create a core file when abrt is running (a RedHat distribution),\n * and keepalived isn't installed from an RPM package, edit the file\n * \u201c/etc/abrt/abrt.conf\u201d, and change the value of the field\n * \u201cProcessUnpackaged\u201d to \u201cyes\u201d.\n *\n * Alternatively, use the -M command line option. */\nstatic void\nupdate_core_dump_pattern(const char *pattern_str)\n{\n\tint fd;\n\tbool initialising = (orig_core_dump_pattern == NULL);\n\n\t/* CORENAME_MAX_SIZE in kernel source include/linux/binfmts.h defines\n\t * the maximum string length, * see core_pattern[CORENAME_MAX_SIZE] in\n\t * fs/coredump.c. Currently (Linux 4.10) defines it to be 128, but the\n\t * definition is not exposed to user-space. */\n#define\tCORENAME_MAX_SIZE\t128\n\n\tif (initialising)\n\t\torig_core_dump_pattern = MALLOC(CORENAME_MAX_SIZE);\n\n\tfd = open (\"/proc/sys/kernel/core_pattern\", O_RDWR);\n\n\tif (fd == -1 ||\n\t    (initialising && read(fd, orig_core_dump_pattern, CORENAME_MAX_SIZE - 1) == -1) ||\n\t    write(fd, pattern_str, strlen(pattern_str)) == -1) {\n\t\tlog_message(LOG_INFO, \"Unable to read/write core_pattern\");\n\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\n\t\tFREE(orig_core_dump_pattern);\n\n\t\treturn;\n\t}\n\n\tclose(fd);\n\n\tif (!initialising)\n\t\tFREE_PTR(orig_core_dump_pattern);\n}\n\nstatic void\ncore_dump_init(void)\n{\n\tstruct rlimit orig_rlim, rlim;\n\n\tif (set_core_dump_pattern) {\n\t\t/* If we set the core_pattern here, we will attempt to restore it when we\n\t\t * exit. This will be fine if it is a child of ours that core dumps,\n\t\t * but if we ourself core dump, then the core_pattern will not be restored */\n\t\tupdate_core_dump_pattern(core_dump_pattern);\n\t}\n\n\tif (create_core_dump) {\n\t\trlim.rlim_cur = RLIM_INFINITY;\n\t\trlim.rlim_max = RLIM_INFINITY;\n\n\t\tif (getrlimit(RLIMIT_CORE, &orig_rlim) == -1)\n\t\t\tlog_message(LOG_INFO, \"Failed to get core file size\");\n\t\telse if (setrlimit(RLIMIT_CORE, &rlim) == -1)\n\t\t\tlog_message(LOG_INFO, \"Failed to set core file size\");\n\t\telse\n\t\t\tset_child_rlimit(RLIMIT_CORE, &orig_rlim);\n\t}\n}\n\nstatic mode_t\nset_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\n\tumask_long = strtoll(optarg, &endptr, 0);\n\n\tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n\t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn;\n\t}\n\n\tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\n\tumask_cmdline = true;\n\n\treturn umask_val;\n}\n\nvoid\ninitialise_debug_options(void)\n{\n#if defined WITH_DEBUG_OPTIONS && !defined _DEBUG_\n\tchar mask = 0;\n\n\tif (prog_type == PROG_TYPE_PARENT)\n\t\tmask = 1 << PROG_TYPE_PARENT;\n#if _WITH_BFD_\n\telse if (prog_type == PROG_TYPE_BFD)\n\t\tmask = 1 << PROG_TYPE_BFD;\n#endif\n#if _WITH_LVS_\n\telse if (prog_type == PROG_TYPE_CHECKER)\n\t\tmask = 1 << PROG_TYPE_CHECKER;\n#endif\n#if _WITH_VRRP_\n\telse if (prog_type == PROG_TYPE_VRRP)\n\t\tmask = 1 << PROG_TYPE_VRRP;\n#endif\n\n#ifdef _TIMER_CHECK_\n\tdo_timer_check = !!(timer_debug & mask);\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tdo_smtp_alert_debug = !!(smtp_debug & mask);\n#endif\n#ifdef _EPOLL_DEBUG_\n\tdo_epoll_debug = !!(epoll_debug & mask);\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tdo_epoll_thread_dump = !!(epoll_thread_debug & mask);\n#endif\n#ifdef _REGEX_DEBUG_\n\tdo_regex_debug = !!(regex_debug & mask);\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tdo_regex_timers = !!(regex_timers & mask);\n#endif\n#ifdef _TSM_DEBUG_\n\tdo_tsm_debug = !!(tsm_debug & mask);\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\tdo_vrrp_fd_debug = !!(vrrp_fd_debug & mask);\n#endif\n#ifdef _NETLINK_TIMERS_\n\tdo_netlink_timers = !!(netlink_timer_debug & mask);\n#endif\n#endif\n}\n\n#ifdef  WITH_DEBUG_OPTIONS\nstatic void\nset_debug_options(const char *options)\n{\n\tchar all_processes, processes;\n\tchar opt;\n\tconst char *opt_p = options;\n\n#ifdef _DEBUG_\n\tall_processes = 1;\n#else\n\tall_processes = (1 << PROG_TYPE_PARENT);\n#if _WITH_BFD_\n\tall_processes |= (1 << PROG_TYPE_BFD);\n#endif\n#if _WITH_LVS_\n\tall_processes |= (1 << PROG_TYPE_CHECKER);\n#endif\n#if _WITH_VRRP_\n\tall_processes |= (1 << PROG_TYPE_VRRP);\n#endif\n#endif\n\n\tif (!options) {\n#ifdef _TIMER_CHECK_\n\t\ttimer_debug = all_processes;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tsmtp_debug = all_processes;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tepoll_debug = all_processes;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tepoll_thread_debug = all_processes;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tregex_debug = all_processes;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tregex_timers = all_processes;\n#endif\n#ifdef _TSM_DEBUG_\n\t\ttsm_debug = all_processes;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tvrrp_fd_debug = all_processes;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tnetlink_timer_debug = all_processes;\n#endif\n\n\t\treturn;\n\t}\n\n\topt_p = options;\n\tdo {\n\t\tif (!isupper(*opt_p)) {\n\t\t\tfprintf(stderr, \"Unknown debug option'%c' in '%s'\\n\", *opt_p, options);\n\t\t\treturn;\n\t\t}\n\t\topt = *opt_p++;\n\n#ifdef _DEBUG_\n\t\tprocesses = all_processes;\n#else\n\t\tif (!*opt_p || isupper(*opt_p))\n\t\t\tprocesses = all_processes;\n\t\telse {\n\t\t\tprocesses = 0;\n\t\t\twhile (*opt_p && !isupper(*opt_p)) {\n\t\t\t\tswitch (*opt_p) {\n\t\t\t\tcase 'p':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_PARENT);\n\t\t\t\t\tbreak;\n#if _WITH_BFD_\n\t\t\t\tcase 'b':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_BFD);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_LVS_\n\t\t\t\tcase 'c':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_CHECKER);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_VRRP_\n\t\t\t\tcase 'v':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_VRRP);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr, \"Unknown debug process '%c' in '%s'\\n\", *opt_p, options);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\topt_p++;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tswitch (opt) {\n#ifdef _TIMER_CHECK_\n\t\tcase 'T':\n\t\t\ttimer_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tcase 'M':\n\t\t\tsmtp_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tcase 'E':\n\t\t\tepoll_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tcase 'D':\n\t\t\tepoll_thread_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tcase 'R':\n\t\t\tregex_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tcase 'X':\n\t\t\tregex_timers = processes;\n\t\t\tbreak;\n#endif\n#ifdef _TSM_DEBUG_\n\t\tcase 'S':\n\t\t\ttsm_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tcase 'F':\n\t\t\tvrrp_fd_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tcase 'N':\n\t\t\tnetlink_timer_debug = processes;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown debug type '%c' in '%s'\\n\", opt, options);\n\t\t\treturn;\n\t\t}\n\t} while (opt_p && *opt_p);\n}\n#endif\n\n/* Usage function */\nstatic void\nusage(const char *prog)\n{\n\tfprintf(stderr, \"Usage: %s [OPTION...]\\n\", prog);\n\tfprintf(stderr, \"  -f, --use-file=FILE          Use the specified configuration file\\n\");\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\tfprintf(stderr, \"  -P, --vrrp                   Only run with VRRP subsystem\\n\");\n\tfprintf(stderr, \"  -C, --check                  Only run with Health-checker subsystem\\n\");\n#endif\n#ifdef _WITH_BFD_\n\tfprintf(stderr, \"  -B, --no_bfd                 Don't run BFD subsystem\\n\");\n#endif\n\tfprintf(stderr, \"      --all                    Force all child processes to run, even if have no configuration\\n\");\n\tfprintf(stderr, \"  -l, --log-console            Log messages to local console\\n\");\n\tfprintf(stderr, \"  -D, --log-detail             Detailed log messages\\n\");\n\tfprintf(stderr, \"  -S, --log-facility=[0-7]     Set syslog facility to LOG_LOCAL[0-7]\\n\");\n\tfprintf(stderr, \"  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\\n\");\n\tfprintf(stderr, \"      --flush-log-file         Flush log file on write\\n\");\n\tfprintf(stderr, \"  -G, --no-syslog              Don't log via syslog\\n\");\n\tfprintf(stderr, \"  -u, --umask=MASK             umask for file creation (in numeric form)\\n\");\n#ifdef _WITH_VRRP_\n\tfprintf(stderr, \"  -X, --release-vips           Drop VIP on transition from signal.\\n\");\n\tfprintf(stderr, \"  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\\n\");\n#endif\n#ifdef _WITH_LVS_\n\tfprintf(stderr, \"  -I, --dont-release-ipvs      Don't remove IPVS topology on daemon stop\\n\");\n#endif\n\tfprintf(stderr, \"  -R, --dont-respawn           Don't respawn child processes\\n\");\n\tfprintf(stderr, \"  -n, --dont-fork              Don't fork the daemon process\\n\");\n\tfprintf(stderr, \"  -d, --dump-conf              Dump the configuration data\\n\");\n\tfprintf(stderr, \"  -p, --pid=FILE               Use specified pidfile for parent process\\n\");\n#ifdef _WITH_VRRP_\n\tfprintf(stderr, \"  -r, --vrrp_pid=FILE          Use specified pidfile for VRRP child process\\n\");\n#endif\n#ifdef _WITH_LVS_\n\tfprintf(stderr, \"  -c, --checkers_pid=FILE      Use specified pidfile for checkers child process\\n\");\n\tfprintf(stderr, \"  -a, --address-monitoring     Report all address additions/deletions notified via netlink\\n\");\n#endif\n#ifdef _WITH_BFD_\n\tfprintf(stderr, \"  -b, --bfd_pid=FILE           Use specified pidfile for BFD child process\\n\");\n#endif\n#ifdef _WITH_SNMP_\n\tfprintf(stderr, \"  -x, --snmp                   Enable SNMP subsystem\\n\");\n\tfprintf(stderr, \"  -A, --snmp-agent-socket=FILE Use the specified socket for master agent\\n\");\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\tfprintf(stderr, \"  -s, --namespace=NAME         Run in network namespace NAME (overrides config)\\n\");\n#endif\n\tfprintf(stderr, \"  -m, --core-dump              Produce core dump if terminate abnormally\\n\");\n\tfprintf(stderr, \"  -M, --core-dump-pattern=PATN Also set /proc/sys/kernel/core_pattern to PATN (default 'core')\\n\");\n#ifdef _MEM_CHECK_LOG_\n\tfprintf(stderr, \"  -L, --mem-check-log          Log malloc/frees to syslog\\n\");\n#endif\n\tfprintf(stderr, \"  -i, --config-id id           Skip any configuration lines beginning '@' that don't match id\\n\"\n\t\t\t\"                                or any lines beginning @^ that do match.\\n\"\n\t\t\t\"                                The config-id defaults to the node name if option not used\\n\");\n\tfprintf(stderr, \"      --signum=SIGFUNC         Return signal number for STOP, RELOAD, DATA, STATS\"\n#ifdef _WITH_JSON_\n\t\t\t\t\t\t\t\t\", JSON\"\n#endif\n\t\t\t\t\t\t\t\t\"\\n\");\n\tfprintf(stderr, \"  -t, --config-test[=LOG_FILE] Check the configuration for obvious errors, output to\\n\"\n\t\t\t\"                                stderr by default\\n\");\n#ifdef _WITH_PERF_\n\tfprintf(stderr, \"      --perf[=PERF_TYPE]       Collect perf data, PERF_TYPE=all, run(default) or end\\n\");\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\tfprintf(stderr, \"      --debug[=...]            Enable debug options. p, b, c, v specify parent, bfd, checker and vrrp processes\\n\");\n#ifdef _TIMER_CHECK_\n\tfprintf(stderr, \"                                   T - timer debug\\n\");\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tfprintf(stderr, \"                                   M - email alert debug\\n\");\n#endif\n#ifdef _EPOLL_DEBUG_\n\tfprintf(stderr, \"                                   E - epoll debug\\n\");\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tfprintf(stderr, \"                                   D - epoll thread dump debug\\n\");\n#endif\n#ifdef _VRRP_FD_DEBUG\n\tfprintf(stderr, \"                                   F - vrrp fd dump debug\\n\");\n#endif\n#ifdef _REGEX_DEBUG_\n\tfprintf(stderr, \"                                   R - regex debug\\n\");\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tfprintf(stderr, \"                                   X - regex timers\\n\");\n#endif\n#ifdef _TSM_DEBUG_\n\tfprintf(stderr, \"                                   S - TSM debug\\n\");\n#endif\n#ifdef _NETLINK_TIMERS_\n\tfprintf(stderr, \"                                   N - netlink timer debug\\n\");\n#endif\n\tfprintf(stderr, \"                                 Example --debug=TpMEvcp\\n\");\n#endif\n\tfprintf(stderr, \"  -v, --version                Display the version number\\n\");\n\tfprintf(stderr, \"  -h, --help                   Display this help message\\n\");\n}\n\n/* Command line parser */\nstatic bool\nparse_cmdline(int argc, char **argv)\n{\n\tint c;\n\tbool reopen_log = false;\n\tint signum;\n\tstruct utsname uname_buf;\n\tint longindex;\n\tint curind;\n\tbool bad_option = false;\n\tunsigned facility;\n\tmode_t new_umask_val;\n\n\tstruct option long_options[] = {\n\t\t{\"use-file\",\t\trequired_argument,\tNULL, 'f'},\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t{\"vrrp\",\t\tno_argument,\t\tNULL, 'P'},\n\t\t{\"check\",\t\tno_argument,\t\tNULL, 'C'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"no_bfd\",\t\tno_argument,\t\tNULL, 'B'},\n#endif\n\t\t{\"all\",\t\t\tno_argument,\t\tNULL,  3 },\n\t\t{\"log-console\",\t\tno_argument,\t\tNULL, 'l'},\n\t\t{\"log-detail\",\t\tno_argument,\t\tNULL, 'D'},\n\t\t{\"log-facility\",\trequired_argument,\tNULL, 'S'},\n\t\t{\"log-file\",\t\toptional_argument,\tNULL, 'g'},\n\t\t{\"flush-log-file\",\tno_argument,\t\tNULL,  2 },\n\t\t{\"no-syslog\",\t\tno_argument,\t\tNULL, 'G'},\n\t\t{\"umask\",\t\trequired_argument,\tNULL, 'u'},\n#ifdef _WITH_VRRP_\n\t\t{\"release-vips\",\tno_argument,\t\tNULL, 'X'},\n\t\t{\"dont-release-vrrp\",\tno_argument,\t\tNULL, 'V'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"dont-release-ipvs\",\tno_argument,\t\tNULL, 'I'},\n#endif\n\t\t{\"dont-respawn\",\tno_argument,\t\tNULL, 'R'},\n\t\t{\"dont-fork\",\t\tno_argument,\t\tNULL, 'n'},\n\t\t{\"dump-conf\",\t\tno_argument,\t\tNULL, 'd'},\n\t\t{\"pid\",\t\t\trequired_argument,\tNULL, 'p'},\n#ifdef _WITH_VRRP_\n\t\t{\"vrrp_pid\",\t\trequired_argument,\tNULL, 'r'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"checkers_pid\",\trequired_argument,\tNULL, 'c'},\n\t\t{\"address-monitoring\",\tno_argument,\t\tNULL, 'a'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"bfd_pid\",\t\trequired_argument,\tNULL, 'b'},\n#endif\n#ifdef _WITH_SNMP_\n\t\t{\"snmp\",\t\tno_argument,\t\tNULL, 'x'},\n\t\t{\"snmp-agent-socket\",\trequired_argument,\tNULL, 'A'},\n#endif\n\t\t{\"core-dump\",\t\tno_argument,\t\tNULL, 'm'},\n\t\t{\"core-dump-pattern\",\toptional_argument,\tNULL, 'M'},\n#ifdef _MEM_CHECK_LOG_\n\t\t{\"mem-check-log\",\tno_argument,\t\tNULL, 'L'},\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t{\"namespace\",\t\trequired_argument,\tNULL, 's'},\n#endif\n\t\t{\"config-id\",\t\trequired_argument,\tNULL, 'i'},\n\t\t{\"signum\",\t\trequired_argument,\tNULL,  4 },\n\t\t{\"config-test\",\t\toptional_argument,\tNULL, 't'},\n#ifdef _WITH_PERF_\n\t\t{\"perf\",\t\toptional_argument,\tNULL,  5 },\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\t{\"debug\",\t\toptional_argument,\tNULL,  6 },\n#endif\n\t\t{\"version\",\t\tno_argument,\t\tNULL, 'v'},\n\t\t{\"help\",\t\tno_argument,\t\tNULL, 'h'},\n\n\t\t{NULL,\t\t\t0,\t\t\tNULL,  0 }\n\t};\n\n\t/* Unfortunately, if a short option is used, getopt_long() doesn't change the value\n\t * of longindex, so we need to ensure that before calling getopt_long(), longindex\n\t * is set to a known invalid value */\n\tcurind = optind;\n\twhile (longindex = -1, (c = getopt_long(argc, argv, \":vhlndu:DRS:f:p:i:mM::g::Gt::\"\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t\t\t\t    \"PC\"\n#endif\n#ifdef _WITH_VRRP_\n\t\t\t\t\t    \"r:VX\"\n#endif\n#ifdef _WITH_LVS_\n\t\t\t\t\t    \"ac:I\"\n#endif\n#ifdef _WITH_BFD_\n\t\t\t\t\t    \"Bb:\"\n#endif\n#ifdef _WITH_SNMP_\n\t\t\t\t\t    \"xA:\"\n#endif\n#ifdef _MEM_CHECK_LOG_\n\t\t\t\t\t    \"L\"\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\t    \"s:\"\n#endif\n\t\t\t\t, long_options, &longindex)) != -1) {\n\n\t\t/* Check for an empty option argument. For example --use-file= returns\n\t\t * a 0 length option, which we don't want */\n\t\tif (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {\n\t\t\tc = ':';\n\t\t\toptarg = NULL;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tfprintf(stderr, \"%s\", version_string);\n#ifdef GIT_COMMIT\n\t\t\tfprintf(stderr, \", git commit %s\", GIT_COMMIT);\n#endif\n\t\t\tfprintf(stderr, \"\\n\\n%s\\n\\n\", COPYRIGHT_STRING);\n\t\t\tfprintf(stderr, \"Built with kernel headers for Linux %d.%d.%d\\n\",\n\t\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t\tuname(&uname_buf);\n\t\t\tfprintf(stderr, \"Running on %s %s %s\\n\\n\", uname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t\tfprintf(stderr, \"configure options: %s\\n\\n\", KEEPALIVED_CONFIGURE_OPTIONS);\n\t\t\tfprintf(stderr, \"Config options: %s\\n\\n\", CONFIGURATION_OPTIONS);\n\t\t\tfprintf(stderr, \"System options: %s\\n\", SYSTEM_OPTIONS);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t__set_bit(LOG_CONSOLE_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t__set_bit(DUMP_CONF_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'V':\n\t\t\t__set_bit(DONT_RELEASE_VRRP_BIT, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_LVS_\n\t\tcase 'I':\n\t\t\t__set_bit(DONT_RELEASE_IPVS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'D':\n\t\t\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\t\t\t__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);\n\t\t\telse\n\t\t\t\t__set_bit(LOG_DETAIL_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'X':\n\t\t\t__set_bit(RELEASE_VIPS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'S':\n\t\t\tif (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))\n\t\t\t\tfprintf(stderr, \"Invalid log facility '%s'\\n\", optarg);\n\t\t\telse {\n\t\t\t\tlog_facility = LOG_FACILITY[facility].facility;\n\t\t\t\treopen_log = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tlog_file_name = optarg;\n\t\t\telse\n\t\t\t\tlog_file_name = \"/tmp/keepalived.log\";\n\t\t\topen_log_file(log_file_name, NULL, NULL, NULL);\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tnew_umask_val = set_umask(optarg);\n\t\t\tif (umask_cmdline)\n\t\t\t\tumask_val = new_umask_val;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 2:\t\t/* --flush-log-file */\n\t\t\tset_flush_log_file();\n\t\t\tbreak;\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\tcase 'P':\n\t\t\t__clear_bit(DAEMON_CHECKERS, &daemon_mode);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t__clear_bit(DAEMON_VRRP, &daemon_mode);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'B':\n\t\t\t__clear_bit(DAEMON_BFD, &daemon_mode);\n\t\t\tbreak;\n#endif\n\t\tcase 'p':\n\t\t\tmain_pidfile = optarg;\n\t\t\tbreak;\n#ifdef _WITH_LVS_\n\t\tcase 'c':\n\t\t\tcheckers_pidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t__set_bit(LOG_ADDRESS_CHANGES, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_VRRP_\n\t\tcase 'r':\n\t\t\tvrrp_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'b':\n\t\t\tbfd_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_SNMP_\n\t\tcase 'x':\n\t\t\tsnmp = 1;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tsnmp_socket = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'M':\n\t\t\tset_core_dump_pattern = true;\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tcore_dump_pattern = optarg;\n\t\t\t/* ... falls through ... */\n\t\tcase 'm':\n\t\t\tcreate_core_dump = true;\n\t\t\tbreak;\n#ifdef _MEM_CHECK_LOG_\n\t\tcase 'L':\n\t\t\t__set_bit(MEM_CHECK_LOG_BIT, &debug);\n\t\t\tbreak;\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\tcase 's':\n\t\t\toverride_namespace = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(override_namespace, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'i':\n\t\t\tFREE_PTR(config_id);\n\t\t\tconfig_id = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(config_id, optarg);\n\t\t\tbreak;\n\t\tcase 4:\t\t\t/* --signum */\n\t\t\tsignum = get_signum(optarg);\n\t\t\tif (signum == -1) {\n\t\t\t\tfprintf(stderr, \"Unknown sigfunc %s\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\", signum);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 3:\t\t\t/* --all */\n\t\t\t__set_bit(RUN_ALL_CHILDREN, &daemon_mode);\n#ifdef _WITH_VRRP_\n\t\t\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t\t\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t\t\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\t\t\tbreak;\n#ifdef _WITH_PERF_\n\t\tcase 5:\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tif (!strcmp(optarg, \"run\"))\n\t\t\t\t\tperf_run = PERF_RUN;\n\t\t\t\telse if (!strcmp(optarg, \"all\"))\n\t\t\t\t\tperf_run = PERF_ALL;\n\t\t\t\telse if (!strcmp(optarg, \"end\"))\n\t\t\t\t\tperf_run = PERF_END;\n\t\t\t\telse\n\t\t\t\t\tlog_message(LOG_INFO, \"Unknown perf start point %s\", optarg);\n\t\t\t}\n\t\t\telse\n\t\t\t\tperf_run = PERF_RUN;\n\n\t\t\tbreak;\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\tcase 6:\n\t\t\tset_debug_options(optarg && optarg[0] ? optarg : NULL);\n\t\t\tbreak;\n#endif\n\t\tcase '?':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Unknown option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Unknown option %s\\n\", argv[curind]);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Missing parameter for option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Missing parameter for option --%s\\n\", long_options[longindex].name);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t\tcurind = optind;\n\t}\n\n\tif (optind < argc) {\n\t\tprintf(\"Unexpected argument(s): \");\n\t\twhile (optind < argc)\n\t\t\tprintf(\"%s \", argv[optind++]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (bad_option)\n\t\texit(1);\n\n\treturn reopen_log;\n}\n\n#ifdef THREAD_DUMP\nstatic void\nregister_parent_thread_addresses(void)\n{\n\tregister_scheduler_addresses();\n\tregister_signal_thread_addresses();\n\n#ifdef _WITH_LVS_\n\tregister_check_parent_addresses();\n#endif\n#ifdef _WITH_VRRP_\n\tregister_vrrp_parent_addresses();\n#endif\n#ifdef _WITH_BFD_\n\tregister_bfd_parent_addresses();\n#endif\n\n#ifndef _DEBUG_\n\tregister_signal_handler_address(\"propagate_signal\", propagate_signal);\n\tregister_signal_handler_address(\"sigend\", sigend);\n#endif\n\tregister_signal_handler_address(\"thread_child_handler\", thread_child_handler);\n}\n#endif\n\n/* Entry point */\nint\nkeepalived_main(int argc, char **argv)\n{\n\tbool report_stopped = true;\n\tstruct utsname uname_buf;\n\tchar *end;\n\n\t/* Ensure time_now is set. We then don't have to check anywhere\n\t * else if it is set. */\n\tset_time_now();\n\n\t/* Save command line options in case need to log them later */\n\tsave_cmd_line_options(argc, argv);\n\n\t/* Init debugging level */\n\tdebug = 0;\n\n\t/* We are the parent process */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_PARENT;\n#endif\n\n\t/* Initialise daemon_mode */\n#ifdef _WITH_VRRP_\n\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\n\t/* Set default file creation mask */\n\tumask(022);\n\n\t/* Open log with default settings so we can log initially */\n\topenlog(PACKAGE_NAME, LOG_PID, log_facility);\n\n#ifdef _MEM_CHECK_\n\tmem_log_init(PACKAGE_NAME, \"Parent process\");\n#endif\n\n\t/* Some functionality depends on kernel version, so get the version here */\n\tif (uname(&uname_buf))\n\t\tlog_message(LOG_INFO, \"Unable to get uname() information - error %d\", errno);\n\telse {\n\t\tos_major = (unsigned)strtoul(uname_buf.release, &end, 10);\n\t\tif (*end != '.')\n\t\t\tos_major = 0;\n\t\telse {\n\t\t\tos_minor = (unsigned)strtoul(end + 1, &end, 10);\n\t\t\tif (*end != '.')\n\t\t\t\tos_major = 0;\n\t\t\telse {\n\t\t\t\tif (!isdigit(end[1]))\n\t\t\t\t\tos_major = 0;\n\t\t\t\telse\n\t\t\t\t\tos_release = (unsigned)strtoul(end + 1, &end, 10);\n\t\t\t}\n\t\t}\n\t\tif (!os_major)\n\t\t\tlog_message(LOG_INFO, \"Unable to parse kernel version %s\", uname_buf.release);\n\n\t\t/* config_id defaults to hostname */\n\t\tif (!config_id) {\n\t\t\tend = strchrnul(uname_buf.nodename, '.');\n\t\t\tconfig_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);\n\t\t\tstrncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));\n\t\t\tconfig_id[end - uname_buf.nodename] = '\\0';\n\t\t}\n\t}\n\n\t/*\n\t * Parse command line and set debug level.\n\t * bits 0..7 reserved by main.c\n\t */\n\tif (parse_cmdline(argc, argv)) {\n\t\tcloselog();\n\t\tif (!__test_bit(NO_SYSLOG_BIT, &debug))\n\t\t\topenlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);\n\t}\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug))\n\t\tenable_console_log();\n\n#ifdef GIT_COMMIT\n\tlog_message(LOG_INFO, \"Starting %s, git commit %s\", version_string, GIT_COMMIT);\n#else\n\tlog_message(LOG_INFO, \"Starting %s\", version_string);\n#endif\n\n\t/* Handle any core file requirements */\n\tcore_dump_init();\n\n\tif (os_major) {\n\t\tif (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {\n\t\t\t/* keepalived was build for a later kernel version */\n\t\t\tlog_message(LOG_INFO, \"WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s\",\n\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff,\n\t\t\t\t\tuname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t} else {\n\t\t\t/* keepalived was build for a later kernel version */\n\t\t\tlog_message(LOG_INFO, \"Running on %s %s %s (built for Linux %d.%d.%d)\",\n\t\t\t\t\tuname_buf.sysname, uname_buf.release, uname_buf.version,\n\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t}\n\t}\n\n#ifndef _DEBUG_\n\tlog_command_line(0);\n#endif\n\n\t/* Check we can read the configuration file(s).\n\t   NOTE: the working directory will be / if we\n\t   forked, but will be the current working directory\n\t   when keepalived was run if we haven't forked.\n\t   This means that if any config file names are not\n\t   absolute file names, the behaviour will be different\n\t   depending on whether we forked or not. */\n\tif (!check_conf_file(conf_file)) {\n\t\tif (__test_bit(CONFIG_TEST_BIT, &debug))\n\t\t\tconfig_test_exit();\n\n\t\tgoto end;\n\t}\n\n\tglobal_data = alloc_global_data();\n\tglobal_data->umask = umask_val;\n\n\tread_config_file();\n\n\tinit_global_data(global_data, NULL);\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (override_namespace) {\n\t\tif (global_data->network_namespace) {\n\t\t\tlog_message(LOG_INFO, \"Overriding config net_namespace '%s' with command line namespace '%s'\", global_data->network_namespace, override_namespace);\n\t\t\tFREE(global_data->network_namespace);\n\t\t}\n\t\tglobal_data->network_namespace = override_namespace;\n\t\toverride_namespace = NULL;\n\t}\n#endif\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug) &&\n\t    (global_data->instance_name\n#if HAVE_DECL_CLONE_NEWNET\n\t     || global_data->network_namespace\n#endif\n\t\t\t\t\t      )) {\n\t\tif ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {\n\t\t\tlog_message(LOG_INFO, \"Changing syslog ident to %s\", syslog_ident);\n\t\t\tcloselog();\n\t\t\topenlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to change syslog ident\");\n\n\t\tuse_pid_dir = true;\n\n\t\topen_log_file(log_file_name,\n\t\t\t\tNULL,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\tNULL,\n#endif\n\t\t\t\tglobal_data->instance_name);\n\t}\n\n\t/* Initialise pointer to child finding function */\n\tset_child_finder_name(find_keepalived_child_name);\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif (use_pid_dir) {\n\t\t\t/* Create the directory for pid files */\n\t\t\tcreate_pid_dir();\n\t\t}\n\t}\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace) {\n\t\tif (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {\n\t\t\tlog_message(LOG_ERR, \"Unable to set network namespace %s - exiting\", global_data->network_namespace);\n\t\t\tgoto end;\n\t\t}\n\t}\n#endif\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif (global_data->instance_name) {\n\t\t\tif (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_main_pidfile = true;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_checkers_pidfile = true;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_vrrp_pidfile = true;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_bfd_pidfile = true;\n#endif\n\t\t}\n\n\t\tif (use_pid_dir) {\n\t\t\tif (!main_pidfile)\n\t\t\t\tmain_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile)\n\t\t\t\tcheckers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile)\n\t\t\t\tvrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile)\n\t\t\t\tbfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!main_pidfile)\n\t\t\t\tmain_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile)\n\t\t\t\tcheckers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile)\n\t\t\t\tvrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile)\n\t\t\t\tbfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n\t\t}\n\n\t\t/* Check if keepalived is already running */\n\t\tif (keepalived_running(daemon_mode)) {\n\t\t\tlog_message(LOG_INFO, \"daemon is already running\");\n\t\t\treport_stopped = false;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t/* daemonize process */\n\tif (!__test_bit(DONT_FORK_BIT, &debug) &&\n\t    xdaemon(false, false, true) > 0) {\n\t\tcloselog();\n\t\tFREE_PTR(config_id);\n\t\tFREE_PTR(orig_core_dump_pattern);\n\t\tclose_std_fd();\n\t\texit(0);\n\t}\n\n#ifdef _MEM_CHECK_\n\tenable_mem_log_termination();\n#endif\n\n\tif (__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tvalidate_config();\n\n\t\tconfig_test_exit();\n\t}\n\n\t/* write the father's pidfile */\n\tif (!pidfile_write(main_pidfile, getpid()))\n\t\tgoto end;\n\n\t/* Create the master thread */\n\tmaster = thread_make_master();\n\n\t/* Signal handling initialization  */\n\tsignal_init();\n\n\t/* Init daemon */\n\tif (!start_keepalived())\n\t\tlog_message(LOG_INFO, \"Warning - keepalived has no configuration to run\");\n\n\tinitialise_debug_options();\n\n#ifdef THREAD_DUMP\n\tregister_parent_thread_addresses();\n#endif\n\n\t/* Launch the scheduling I/O multiplexer */\n\tlaunch_thread_scheduler(master);\n\n\t/* Finish daemon process */\n\tstop_keepalived();\n\n#ifdef THREAD_DUMP\n\tderegister_thread_addresses();\n#endif\n\n\t/*\n\t * Reached when terminate signal catched.\n\t * finally return from system\n\t */\nend:\n\tif (report_stopped) {\n#ifdef GIT_COMMIT\n\t\tlog_message(LOG_INFO, \"Stopped %s, git commit %s\", version_string, GIT_COMMIT);\n#else\n\t\tlog_message(LOG_INFO, \"Stopped %s\", version_string);\n#endif\n\t}\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data && global_data->network_namespace)\n\t\tclear_namespaces();\n#endif\n\n\tif (use_pid_dir)\n\t\tremove_pid_dir();\n\n\t/* Restore original core_pattern if necessary */\n\tif (orig_core_dump_pattern)\n\t\tupdate_core_dump_pattern(orig_core_dump_pattern);\n\n\tfree_parent_mallocs_startup(false);\n\tfree_parent_mallocs_exit();\n\tfree_global_data(global_data);\n\n\tcloselog();\n\n#ifndef _MEM_CHECK_LOG_\n\tFREE_PTR(syslog_ident);\n#else\n\tif (syslog_ident)\n\t\tfree(syslog_ident);\n#endif\n\tclose_std_fd();\n\n\texit(KEEPALIVED_EXIT_OK);\n}\n"], "fixing_code": ["/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Main program structure.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <sys/utsname.h>\n#include <sys/resource.h>\n#include <stdbool.h>\n#ifdef HAVE_SIGNALFD\n#include <sys/signalfd.h>\n#endif\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <linux/version.h>\n#include <ctype.h>\n\n#include \"main.h\"\n#include \"global_data.h\"\n#include \"daemon.h\"\n#include \"config.h\"\n#include \"git-commit.h\"\n#include \"utils.h\"\n#include \"signals.h\"\n#include \"pidfile.h\"\n#include \"bitops.h\"\n#include \"logger.h\"\n#include \"parser.h\"\n#include \"notify.h\"\n#include \"utils.h\"\n#ifdef _WITH_LVS_\n#include \"check_parser.h\"\n#include \"check_daemon.h\"\n#endif\n#ifdef _WITH_VRRP_\n#include \"vrrp_daemon.h\"\n#include \"vrrp_parser.h\"\n#include \"vrrp_if.h\"\n#ifdef _WITH_JSON_\n#include \"vrrp_json.h\"\n#endif\n#endif\n#ifdef _WITH_BFD_\n#include \"bfd_daemon.h\"\n#include \"bfd_parser.h\"\n#endif\n#include \"global_parser.h\"\n#if HAVE_DECL_CLONE_NEWNET\n#include \"namespaces.h\"\n#endif\n#include \"scheduler.h\"\n#include \"keepalived_netlink.h\"\n#include \"git-commit.h\"\n#if defined THREAD_DUMP || defined _EPOLL_DEBUG_ || defined _EPOLL_THREAD_DUMP_\n#include \"scheduler.h\"\n#endif\n#include \"process.h\"\n#ifdef _TIMER_CHECK_\n#include \"timer.h\"\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n#include \"smtp.h\"\n#endif\n#if defined _REGEX_DEBUG_ || defined _WITH_REGEX_TIMERS_\n#include \"check_http.h\"\n#endif\n#ifdef _TSM_DEBUG_\n#include \"vrrp_scheduler.h\"\n#endif\n\n/* musl libc doesn't define the following */\n#ifndef\tW_EXITCODE\n#define\tW_EXITCODE(ret, sig)\t((ret) << 8 | (sig))\n#endif\n#ifndef\tWCOREFLAG\n#define\tWCOREFLAG\t\t((int32_t)WCOREDUMP(0xffffffff))\n#endif\n\n#define\tVERSION_STRING\t\tPACKAGE_NAME \" v\" PACKAGE_VERSION \" (\" GIT_DATE \")\"\n#define COPYRIGHT_STRING\t\"Copyright(C) 2001-\" GIT_YEAR \" Alexandre Cassen, <acassen@gmail.com>\"\n\n#define CHILD_WAIT_SECS\t5\n\n/* global var */\nconst char *version_string = VERSION_STRING;\t\t/* keepalived version */\nchar *conf_file = KEEPALIVED_CONFIG_FILE;\t\t/* Configuration file */\nint log_facility = LOG_DAEMON;\t\t\t\t/* Optional logging facilities */\nbool reload;\t\t\t\t\t\t/* Set during a reload */\nchar *main_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_main_pidfile;\n#ifdef _WITH_LVS_\npid_t checkers_child;\t\t\t\t\t/* Healthcheckers child process ID */\nchar *checkers_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_checkers_pidfile;\n#endif\n#ifdef _WITH_VRRP_\npid_t vrrp_child;\t\t\t\t\t/* VRRP child process ID */\nchar *vrrp_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_vrrp_pidfile;\n#endif\n#ifdef _WITH_BFD_\npid_t bfd_child;\t\t\t\t\t/* BFD child process ID */\nchar *bfd_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_bfd_pidfile;\n#endif\nunsigned long daemon_mode;\t\t\t\t/* VRRP/CHECK/BFD subsystem selection */\n#ifdef _WITH_SNMP_\nbool snmp;\t\t\t\t\t\t/* Enable SNMP support */\nconst char *snmp_socket;\t\t\t\t/* Socket to use for SNMP agent */\n#endif\nstatic char *syslog_ident;\t\t\t\t/* syslog ident if not default */\nbool use_pid_dir;\t\t\t\t\t/* Put pid files in /var/run/keepalived or @localstatedir@/run/keepalived */\n\nunsigned os_major;\t\t\t\t\t/* Kernel version */\nunsigned os_minor;\nunsigned os_release;\nchar *hostname;\t\t\t\t\t\t/* Initial part of hostname */\n\n#if HAVE_DECL_CLONE_NEWNET\nstatic char *override_namespace;\t\t\t/* If namespace specified on command line */\n#endif\n\nunsigned child_wait_time = CHILD_WAIT_SECS;\t\t/* Time to wait for children to exit */\n\n/* Log facility table */\nstatic struct {\n\tint facility;\n} LOG_FACILITY[] = {\n\t{LOG_LOCAL0}, {LOG_LOCAL1}, {LOG_LOCAL2}, {LOG_LOCAL3},\n\t{LOG_LOCAL4}, {LOG_LOCAL5}, {LOG_LOCAL6}, {LOG_LOCAL7}\n};\n#define\tLOG_FACILITY_MAX\t((sizeof(LOG_FACILITY) / sizeof(LOG_FACILITY[0])) - 1)\n\n/* umask settings */\nbool umask_cmdline;\nstatic mode_t umask_val = S_IXUSR | S_IWGRP | S_IXGRP | S_IWOTH | S_IXOTH;\n\n/* Control producing core dumps */\nstatic bool set_core_dump_pattern = false;\nstatic bool create_core_dump = false;\nstatic const char *core_dump_pattern = \"core\";\nstatic char *orig_core_dump_pattern = NULL;\n\n/* debug flags */\n#if defined _TIMER_CHECK_ || defined _SMTP_ALERT_DEBUG_ || defined _EPOLL_DEBUG_ || defined _EPOLL_THREAD_DUMP_ || defined _REGEX_DEBUG_ || defined _WITH_REGEX_TIMERS_ || defined _TSM_DEBUG_ || defined _VRRP_FD_DEBUG_ || defined _NETLINK_TIMERS_\n#define WITH_DEBUG_OPTIONS 1\n#endif\n\n#ifdef _TIMER_CHECK_\nstatic char timer_debug;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\nstatic char smtp_debug;\n#endif\n#ifdef _EPOLL_DEBUG_\nstatic char epoll_debug;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\nstatic char epoll_thread_debug;\n#endif\n#ifdef _REGEX_DEBUG_\nstatic char regex_debug;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\nstatic char regex_timers;\n#endif\n#ifdef _TSM_DEBUG_\nstatic char tsm_debug;\n#endif\n#ifdef _VRRP_FD_DEBUG_\nstatic char vrrp_fd_debug;\n#endif\n#ifdef _NETLINK_TIMERS_\nstatic char netlink_timer_debug;\n#endif\n\nvoid\nfree_parent_mallocs_startup(bool am_child)\n{\n\tif (am_child) {\n#if HAVE_DECL_CLONE_NEWNET\n\t\tfree_dirname();\n#endif\n#ifndef _MEM_CHECK_LOG_\n\t\tFREE_PTR(syslog_ident);\n#else\n\t\tfree(syslog_ident);\n#endif\n\t\tsyslog_ident = NULL;\n\n\t\tFREE_PTR(orig_core_dump_pattern);\n\t}\n\n\tif (free_main_pidfile) {\n\t\tFREE_PTR(main_pidfile);\n\t\tfree_main_pidfile = false;\n\t}\n}\n\nvoid\nfree_parent_mallocs_exit(void)\n{\n#ifdef _WITH_VRRP_\n\tif (free_vrrp_pidfile)\n\t\tFREE_PTR(vrrp_pidfile);\n#endif\n#ifdef _WITH_LVS_\n\tif (free_checkers_pidfile)\n\t\tFREE_PTR(checkers_pidfile);\n#endif\n#ifdef _WITH_BFD_\n\tif (free_bfd_pidfile)\n\t\tFREE_PTR(bfd_pidfile);\n#endif\n\n\tFREE_PTR(config_id);\n}\n\nchar *\nmake_syslog_ident(const char* name)\n{\n\tsize_t ident_len = strlen(name) + 1;\n\tchar *ident;\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace)\n\t\tident_len += strlen(global_data->network_namespace) + 1;\n#endif\n\tif (global_data->instance_name)\n\t\tident_len += strlen(global_data->instance_name) + 1;\n\n\t/* If we are writing MALLOC/FREE info to the log, we have\n\t * trouble FREEing the syslog_ident */\n#ifndef _MEM_CHECK_LOG_\n\tident = MALLOC(ident_len);\n#else\n\tident = malloc(ident_len);\n#endif\n\n\tif (!ident)\n\t\treturn NULL;\n\n\tstrcpy(ident, name);\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace) {\n\t\tstrcat(ident, \"_\");\n\t\tstrcat(ident, global_data->network_namespace);\n\t}\n#endif\n\tif (global_data->instance_name) {\n\t\tstrcat(ident, \"_\");\n\t\tstrcat(ident, global_data->instance_name);\n\t}\n\n\treturn ident;\n}\n\nstatic char *\nmake_pidfile_name(const char* start, const char* instance, const char* extn)\n{\n\tsize_t len;\n\tchar *name;\n\n\tlen = strlen(start) + 1;\n\tif (instance)\n\t\tlen += strlen(instance) + 1;\n\tif (extn)\n\t\tlen += strlen(extn);\n\n\tname = MALLOC(len);\n\tif (!name) {\n\t\tlog_message(LOG_INFO, \"Unable to make pidfile name for %s\", start);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(name, start);\n\tif (instance) {\n\t\tstrcat(name, \"_\");\n\t\tstrcat(name, instance);\n\t}\n\tif (extn)\n\t\tstrcat(name, extn);\n\n\treturn name;\n}\n\n#ifdef _WITH_VRRP_\nbool\nrunning_vrrp(void)\n{\n\treturn (__test_bit(DAEMON_VRRP, &daemon_mode) &&\n\t    (global_data->have_vrrp_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\n#ifdef _WITH_LVS_\nbool\nrunning_checker(void)\n{\n\treturn (__test_bit(DAEMON_CHECKERS, &daemon_mode) &&\n\t    (global_data->have_checker_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\n#ifdef _WITH_BFD_\nbool\nrunning_bfd(void)\n{\n\treturn (__test_bit(DAEMON_BFD, &daemon_mode) &&\n\t    (global_data->have_bfd_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\nstatic char const *\nfind_keepalived_child_name(pid_t pid)\n{\n#ifdef _WITH_LVS_\n\tif (pid == checkers_child)\n\t\treturn PROG_CHECK;\n#endif\n#ifdef _WITH_VRRP_\n\tif (pid == vrrp_child)\n\t\treturn PROG_VRRP;\n#endif\n#ifdef _WITH_BFD_\n\tif (pid == bfd_child)\n\t\treturn PROG_BFD;\n#endif\n\n\treturn NULL;\n}\n\nstatic vector_t *\nglobal_init_keywords(void)\n{\n\t/* global definitions mapping */\n\tinit_global_keywords(true);\n\n#ifdef _WITH_VRRP_\n\tinit_vrrp_keywords(false);\n#endif\n#ifdef _WITH_LVS_\n\tinit_check_keywords(false);\n#endif\n#ifdef _WITH_BFD_\n\tinit_bfd_keywords(false);\n#endif\n\n\treturn keywords;\n}\n\nstatic void\nread_config_file(void)\n{\n\tinit_data(conf_file, global_init_keywords);\n}\n\n/* Daemon stop sequence */\nvoid\nstop_keepalived(void)\n{\n#ifndef _DEBUG_\n\t/* Just cleanup memory & exit */\n\tthread_destroy_master(master);\n\n#ifdef _WITH_VRRP_\n\tif (__test_bit(DAEMON_VRRP, &daemon_mode))\n\t\tpidfile_rm(vrrp_pidfile);\n#endif\n\n#ifdef _WITH_LVS_\n\tif (__test_bit(DAEMON_CHECKERS, &daemon_mode))\n\t\tpidfile_rm(checkers_pidfile);\n#endif\n\n#ifdef _WITH_BFD_\n\tif (__test_bit(DAEMON_BFD, &daemon_mode))\n\t\tpidfile_rm(bfd_pidfile);\n#endif\n\n\tpidfile_rm(main_pidfile);\n#endif\n}\n\n/* Daemon init sequence */\nstatic int\nstart_keepalived(void)\n{\n\tbool have_child = false;\n\n#ifdef _WITH_BFD_\n\t/* must be opened before vrrp and bfd start */\n\topen_bfd_pipes();\n#endif\n\n#ifdef _WITH_LVS_\n\t/* start healthchecker child */\n\tif (running_checker()) {\n\t\tstart_check_child();\n\t\thave_child = true;\n\t}\n#endif\n#ifdef _WITH_VRRP_\n\t/* start vrrp child */\n\tif (running_vrrp()) {\n\t\tstart_vrrp_child();\n\t\thave_child = true;\n\t}\n#endif\n#ifdef _WITH_BFD_\n\t/* start bfd child */\n\tif (running_bfd()) {\n\t\tstart_bfd_child();\n\t\thave_child = true;\n\t}\n#endif\n\n\treturn have_child;\n}\n\nstatic void\nvalidate_config(void)\n{\n#ifdef _WITH_VRRP_\n\tkernel_netlink_read_interfaces();\n#endif\n\n#ifdef _WITH_LVS_\n\t/* validate healthchecker config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_CHECKER;\n#endif\n\tcheck_validate_config();\n#endif\n#ifdef _WITH_VRRP_\n\t/* validate vrrp config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_VRRP;\n#endif\n\tvrrp_validate_config();\n#endif\n#ifdef _WITH_BFD_\n\t/* validate bfd config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_BFD;\n#endif\n\tbfd_validate_config();\n#endif\n}\n\nstatic void\nconfig_test_exit(void)\n{\n\tconfig_err_t config_err = get_config_status();\n\n\tswitch (config_err) {\n\tcase CONFIG_OK:\n\t\texit(KEEPALIVED_EXIT_OK);\n\tcase CONFIG_FILE_NOT_FOUND:\n\tcase CONFIG_BAD_IF:\n\tcase CONFIG_FATAL:\n\t\texit(KEEPALIVED_EXIT_CONFIG);\n\tcase CONFIG_SECURITY_ERROR:\n\t\texit(KEEPALIVED_EXIT_CONFIG_TEST_SECURITY);\n\tdefault:\n\t\texit(KEEPALIVED_EXIT_CONFIG_TEST);\n\t}\n}\n\n#ifndef _DEBUG_\nstatic bool reload_config(void)\n{\n\tbool unsupported_change = false;\n\n\tlog_message(LOG_INFO, \"Reloading ...\");\n\n\t/* Make sure there isn't an attempt to change the network namespace or instance name */\n\told_global_data = global_data;\n\tglobal_data = NULL;\n\tglobal_data = alloc_global_data();\n\n\tread_config_file();\n\n\tinit_global_data(global_data, old_global_data);\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (!!old_global_data->network_namespace != !!global_data->network_namespace ||\n\t    (global_data->network_namespace && strcmp(old_global_data->network_namespace, global_data->network_namespace))) {\n\t\tlog_message(LOG_INFO, \"Cannot change network namespace at a reload - please restart %s\", PACKAGE);\n\t\tunsupported_change = true;\n\t}\n\tFREE_PTR(global_data->network_namespace);\n\tglobal_data->network_namespace = old_global_data->network_namespace;\n\told_global_data->network_namespace = NULL;\n#endif\n\n\tif (!!old_global_data->instance_name != !!global_data->instance_name ||\n\t    (global_data->instance_name && strcmp(old_global_data->instance_name, global_data->instance_name))) {\n\t\tlog_message(LOG_INFO, \"Cannot change instance name at a reload - please restart %s\", PACKAGE);\n\t\tunsupported_change = true;\n\t}\n\tFREE_PTR(global_data->instance_name);\n\tglobal_data->instance_name = old_global_data->instance_name;\n\told_global_data->instance_name = NULL;\n\n\tif (unsupported_change) {\n\t\t/* We cannot reload the configuration, so continue with the old config */\n\t\tfree_global_data (global_data);\n\t\tglobal_data = old_global_data;\n\t}\n\telse\n\t\tfree_global_data (old_global_data);\n\n\treturn !unsupported_change;\n}\n\n/* SIGHUP/USR1/USR2 handler */\nstatic void\npropagate_signal(__attribute__((unused)) void *v, int sig)\n{\n\tif (sig == SIGHUP) {\n\t\tif (!reload_config())\n\t\t\treturn;\n\t}\n\n\t/* Signal child processes */\n#ifdef _WITH_VRRP_\n\tif (vrrp_child > 0)\n\t\tkill(vrrp_child, sig);\n\telse if (sig == SIGHUP && running_vrrp())\n\t\tstart_vrrp_child();\n#endif\n#ifdef _WITH_LVS_\n\tif (sig == SIGHUP) {\n\t\tif (checkers_child > 0)\n\t\t\tkill(checkers_child, sig);\n\t\telse if (running_checker())\n\t\t\tstart_check_child();\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (sig == SIGHUP) {\n\t\tif (bfd_child > 0)\n\t\t\tkill(bfd_child, sig);\n\t\telse if (running_bfd())\n\t\t\tstart_bfd_child();\n\t}\n#endif\n}\n\n/* Terminate handler */\nstatic void\nsigend(__attribute__((unused)) void *v, __attribute__((unused)) int sig)\n{\n\tint status;\n\tint ret;\n\tint wait_count = 0;\n\tstruct timeval start_time, now;\n#ifdef HAVE_SIGNALFD\n\tstruct timeval timeout = {\n\t\t.tv_sec = child_wait_time,\n\t\t.tv_usec = 0\n\t};\n\tint signal_fd = master->signal_fd;\n\tfd_set read_set;\n\tstruct signalfd_siginfo siginfo;\n\tsigset_t sigmask;\n#else\n\tsigset_t old_set, child_wait;\n\tstruct timespec timeout = {\n\t\t.tv_sec = child_wait_time,\n\t\t.tv_nsec = 0\n\t};\n#endif\n\n\t/* register the terminate thread */\n\tthread_add_terminate_event(master);\n\n\tlog_message(LOG_INFO, \"Stopping\");\n\n#ifdef HAVE_SIGNALFD\n\t/* We only want to receive SIGCHLD now */\n\tsigemptyset(&sigmask);\n\tsigaddset(&sigmask, SIGCHLD);\n\tsignalfd(signal_fd, &sigmask, 0);\n\tFD_ZERO(&read_set);\n#else\n\tsigmask_func(0, NULL, &old_set);\n\tif (!sigismember(&old_set, SIGCHLD)) {\n\t\tsigemptyset(&child_wait);\n\t\tsigaddset(&child_wait, SIGCHLD);\n\t\tsigmask_func(SIG_BLOCK, &child_wait, NULL);\n\t}\n#endif\n\n#ifdef _WITH_VRRP_\n\tif (vrrp_child > 0) {\n\t\tif (kill(vrrp_child, SIGTERM)) {\n\t\t\t/* ESRCH means no such process */\n\t\t\tif (errno == ESRCH)\n\t\t\t\tvrrp_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (checkers_child > 0) {\n\t\tif (kill(checkers_child, SIGTERM)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tcheckers_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (bfd_child > 0) {\n\t\tif (kill(bfd_child, SIGTERM)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tbfd_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n\n\tgettimeofday(&start_time, NULL);\n\twhile (wait_count) {\n#ifdef HAVE_SIGNALFD\n\t\tFD_SET(signal_fd, &read_set);\n\t\tret = select(signal_fd + 1, &read_set, NULL, NULL, &timeout);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tlog_message(LOG_INFO, \"Terminating select returned errno %d\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!FD_ISSET(signal_fd, &read_set)) {\n\t\t\tlog_message(LOG_INFO, \"Terminating select did not return select_fd\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (read(signal_fd, &siginfo, sizeof(siginfo)) != sizeof(siginfo)) {\n\t\t\tlog_message(LOG_INFO, \"Terminating signal read did not read entire siginfo\");\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = siginfo.ssi_code == CLD_EXITED ? W_EXITCODE(siginfo.ssi_status, 0) :\n\t\t\t siginfo.ssi_code == CLD_KILLED ? W_EXITCODE(0, siginfo.ssi_status) :\n\t\t\t\t\t\t\t   WCOREFLAG;\n\n#ifdef _WITH_VRRP_\n\t\tif (vrrp_child > 0 && vrrp_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, vrrp_child, PROG_VRRP);\n\t\t\tvrrp_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#ifdef _WITH_LVS_\n\t\tif (checkers_child > 0 && checkers_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, checkers_child, PROG_CHECK);\n\t\t\tcheckers_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n#ifdef _WITH_BFD_\n\t\tif (bfd_child > 0 && bfd_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, bfd_child, PROG_BFD);\n\t\t\tbfd_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#else\n\t\tret = sigtimedwait(&child_wait, NULL, &timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tbreak;\n\t\t}\n\n#ifdef _WITH_VRRP_\n\t\tif (vrrp_child > 0 && vrrp_child == waitpid(vrrp_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, vrrp_child, PROG_VRRP);\n\t\t\tvrrp_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#ifdef _WITH_LVS_\n\t\tif (checkers_child > 0 && checkers_child == waitpid(checkers_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, checkers_child, PROG_CHECK);\n\t\t\tcheckers_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n#ifdef _WITH_BFD_\n\t\tif (bfd_child > 0 && bfd_child == waitpid(bfd_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, bfd_child, PROG_BFD);\n\t\t\tbfd_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#endif\n\n\t\tif (wait_count) {\n\t\t\tgettimeofday(&now, NULL);\n\t\t\ttimeout.tv_sec = child_wait_time - (now.tv_sec - start_time.tv_sec);\n#ifdef HAVE_SIGNALFD\n\t\t\ttimeout.tv_usec = (start_time.tv_usec - now.tv_usec);\n\t\t\tif (timeout.tv_usec < 0) {\n\t\t\t\ttimeout.tv_usec += 1000000L;\n\t\t\t\ttimeout.tv_sec--;\n\t\t\t}\n#else\n\t\t\ttimeout.tv_nsec = (start_time.tv_usec - now.tv_usec) * 1000;\n\t\t\tif (timeout.tv_nsec < 0) {\n\t\t\t\ttimeout.tv_nsec += 1000000000L;\n\t\t\t\ttimeout.tv_sec--;\n\t\t\t}\n#endif\n\t\t\tif (timeout.tv_sec < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* A child may not have terminated, so force its termination */\n#ifdef _WITH_VRRP_\n\tif (vrrp_child) {\n\t\tlog_message(LOG_INFO, \"vrrp process failed to die - forcing termination\");\n\t\tkill(vrrp_child, SIGKILL);\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (checkers_child) {\n\t\tlog_message(LOG_INFO, \"checker process failed to die - forcing termination\");\n\t\tkill(checkers_child, SIGKILL);\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (bfd_child) {\n\t\tlog_message(LOG_INFO, \"bfd process failed to die - forcing termination\");\n\t\tkill(bfd_child, SIGKILL);\n\t}\n#endif\n\n#ifndef HAVE_SIGNALFD\n\tif (!sigismember(&old_set, SIGCHLD))\n\t\tsigmask_func(SIG_UNBLOCK, &child_wait, NULL);\n#endif\n}\n#endif\n\n/* Initialize signal handler */\nstatic void\nsignal_init(void)\n{\n#ifndef _DEBUG_\n\tsignal_set(SIGHUP, propagate_signal, NULL);\n\tsignal_set(SIGUSR1, propagate_signal, NULL);\n\tsignal_set(SIGUSR2, propagate_signal, NULL);\n#ifdef _WITH_JSON_\n\tsignal_set(SIGJSON, propagate_signal, NULL);\n#endif\n\tsignal_set(SIGINT, sigend, NULL);\n\tsignal_set(SIGTERM, sigend, NULL);\n#endif\n\tsignal_ignore(SIGPIPE);\n}\n\n/* To create a core file when abrt is running (a RedHat distribution),\n * and keepalived isn't installed from an RPM package, edit the file\n * \u201c/etc/abrt/abrt.conf\u201d, and change the value of the field\n * \u201cProcessUnpackaged\u201d to \u201cyes\u201d.\n *\n * Alternatively, use the -M command line option. */\nstatic void\nupdate_core_dump_pattern(const char *pattern_str)\n{\n\tint fd;\n\tbool initialising = (orig_core_dump_pattern == NULL);\n\n\t/* CORENAME_MAX_SIZE in kernel source include/linux/binfmts.h defines\n\t * the maximum string length, * see core_pattern[CORENAME_MAX_SIZE] in\n\t * fs/coredump.c. Currently (Linux 4.10) defines it to be 128, but the\n\t * definition is not exposed to user-space. */\n#define\tCORENAME_MAX_SIZE\t128\n\n\tif (initialising)\n\t\torig_core_dump_pattern = MALLOC(CORENAME_MAX_SIZE);\n\n\tfd = open (\"/proc/sys/kernel/core_pattern\", O_RDWR);\n\n\tif (fd == -1 ||\n\t    (initialising && read(fd, orig_core_dump_pattern, CORENAME_MAX_SIZE - 1) == -1) ||\n\t    write(fd, pattern_str, strlen(pattern_str)) == -1) {\n\t\tlog_message(LOG_INFO, \"Unable to read/write core_pattern\");\n\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\n\t\tFREE(orig_core_dump_pattern);\n\n\t\treturn;\n\t}\n\n\tclose(fd);\n\n\tif (!initialising)\n\t\tFREE_PTR(orig_core_dump_pattern);\n}\n\nstatic void\ncore_dump_init(void)\n{\n\tstruct rlimit orig_rlim, rlim;\n\n\tif (set_core_dump_pattern) {\n\t\t/* If we set the core_pattern here, we will attempt to restore it when we\n\t\t * exit. This will be fine if it is a child of ours that core dumps,\n\t\t * but if we ourself core dump, then the core_pattern will not be restored */\n\t\tupdate_core_dump_pattern(core_dump_pattern);\n\t}\n\n\tif (create_core_dump) {\n\t\trlim.rlim_cur = RLIM_INFINITY;\n\t\trlim.rlim_max = RLIM_INFINITY;\n\n\t\tif (getrlimit(RLIMIT_CORE, &orig_rlim) == -1)\n\t\t\tlog_message(LOG_INFO, \"Failed to get core file size\");\n\t\telse if (setrlimit(RLIMIT_CORE, &rlim) == -1)\n\t\t\tlog_message(LOG_INFO, \"Failed to set core file size\");\n\t\telse\n\t\t\tset_child_rlimit(RLIMIT_CORE, &orig_rlim);\n\t}\n}\n\nstatic mode_t\nset_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\n\tumask_long = strtoll(optarg, &endptr, 0);\n\n\tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n\t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn 0;\n\t}\n\n\tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\n\tumask_cmdline = true;\n\n\treturn umask_val;\n}\n\nvoid\ninitialise_debug_options(void)\n{\n#if defined WITH_DEBUG_OPTIONS && !defined _DEBUG_\n\tchar mask = 0;\n\n\tif (prog_type == PROG_TYPE_PARENT)\n\t\tmask = 1 << PROG_TYPE_PARENT;\n#if _WITH_BFD_\n\telse if (prog_type == PROG_TYPE_BFD)\n\t\tmask = 1 << PROG_TYPE_BFD;\n#endif\n#if _WITH_LVS_\n\telse if (prog_type == PROG_TYPE_CHECKER)\n\t\tmask = 1 << PROG_TYPE_CHECKER;\n#endif\n#if _WITH_VRRP_\n\telse if (prog_type == PROG_TYPE_VRRP)\n\t\tmask = 1 << PROG_TYPE_VRRP;\n#endif\n\n#ifdef _TIMER_CHECK_\n\tdo_timer_check = !!(timer_debug & mask);\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tdo_smtp_alert_debug = !!(smtp_debug & mask);\n#endif\n#ifdef _EPOLL_DEBUG_\n\tdo_epoll_debug = !!(epoll_debug & mask);\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tdo_epoll_thread_dump = !!(epoll_thread_debug & mask);\n#endif\n#ifdef _REGEX_DEBUG_\n\tdo_regex_debug = !!(regex_debug & mask);\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tdo_regex_timers = !!(regex_timers & mask);\n#endif\n#ifdef _TSM_DEBUG_\n\tdo_tsm_debug = !!(tsm_debug & mask);\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\tdo_vrrp_fd_debug = !!(vrrp_fd_debug & mask);\n#endif\n#ifdef _NETLINK_TIMERS_\n\tdo_netlink_timers = !!(netlink_timer_debug & mask);\n#endif\n#endif\n}\n\n#ifdef  WITH_DEBUG_OPTIONS\nstatic void\nset_debug_options(const char *options)\n{\n\tchar all_processes, processes;\n\tchar opt;\n\tconst char *opt_p = options;\n\n#ifdef _DEBUG_\n\tall_processes = 1;\n#else\n\tall_processes = (1 << PROG_TYPE_PARENT);\n#if _WITH_BFD_\n\tall_processes |= (1 << PROG_TYPE_BFD);\n#endif\n#if _WITH_LVS_\n\tall_processes |= (1 << PROG_TYPE_CHECKER);\n#endif\n#if _WITH_VRRP_\n\tall_processes |= (1 << PROG_TYPE_VRRP);\n#endif\n#endif\n\n\tif (!options) {\n#ifdef _TIMER_CHECK_\n\t\ttimer_debug = all_processes;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tsmtp_debug = all_processes;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tepoll_debug = all_processes;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tepoll_thread_debug = all_processes;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tregex_debug = all_processes;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tregex_timers = all_processes;\n#endif\n#ifdef _TSM_DEBUG_\n\t\ttsm_debug = all_processes;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tvrrp_fd_debug = all_processes;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tnetlink_timer_debug = all_processes;\n#endif\n\n\t\treturn;\n\t}\n\n\topt_p = options;\n\tdo {\n\t\tif (!isupper(*opt_p)) {\n\t\t\tfprintf(stderr, \"Unknown debug option'%c' in '%s'\\n\", *opt_p, options);\n\t\t\treturn;\n\t\t}\n\t\topt = *opt_p++;\n\n#ifdef _DEBUG_\n\t\tprocesses = all_processes;\n#else\n\t\tif (!*opt_p || isupper(*opt_p))\n\t\t\tprocesses = all_processes;\n\t\telse {\n\t\t\tprocesses = 0;\n\t\t\twhile (*opt_p && !isupper(*opt_p)) {\n\t\t\t\tswitch (*opt_p) {\n\t\t\t\tcase 'p':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_PARENT);\n\t\t\t\t\tbreak;\n#if _WITH_BFD_\n\t\t\t\tcase 'b':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_BFD);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_LVS_\n\t\t\t\tcase 'c':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_CHECKER);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_VRRP_\n\t\t\t\tcase 'v':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_VRRP);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr, \"Unknown debug process '%c' in '%s'\\n\", *opt_p, options);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\topt_p++;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tswitch (opt) {\n#ifdef _TIMER_CHECK_\n\t\tcase 'T':\n\t\t\ttimer_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tcase 'M':\n\t\t\tsmtp_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tcase 'E':\n\t\t\tepoll_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tcase 'D':\n\t\t\tepoll_thread_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tcase 'R':\n\t\t\tregex_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tcase 'X':\n\t\t\tregex_timers = processes;\n\t\t\tbreak;\n#endif\n#ifdef _TSM_DEBUG_\n\t\tcase 'S':\n\t\t\ttsm_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tcase 'F':\n\t\t\tvrrp_fd_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tcase 'N':\n\t\t\tnetlink_timer_debug = processes;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown debug type '%c' in '%s'\\n\", opt, options);\n\t\t\treturn;\n\t\t}\n\t} while (opt_p && *opt_p);\n}\n#endif\n\n/* Usage function */\nstatic void\nusage(const char *prog)\n{\n\tfprintf(stderr, \"Usage: %s [OPTION...]\\n\", prog);\n\tfprintf(stderr, \"  -f, --use-file=FILE          Use the specified configuration file\\n\");\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\tfprintf(stderr, \"  -P, --vrrp                   Only run with VRRP subsystem\\n\");\n\tfprintf(stderr, \"  -C, --check                  Only run with Health-checker subsystem\\n\");\n#endif\n#ifdef _WITH_BFD_\n\tfprintf(stderr, \"  -B, --no_bfd                 Don't run BFD subsystem\\n\");\n#endif\n\tfprintf(stderr, \"      --all                    Force all child processes to run, even if have no configuration\\n\");\n\tfprintf(stderr, \"  -l, --log-console            Log messages to local console\\n\");\n\tfprintf(stderr, \"  -D, --log-detail             Detailed log messages\\n\");\n\tfprintf(stderr, \"  -S, --log-facility=[0-7]     Set syslog facility to LOG_LOCAL[0-7]\\n\");\n\tfprintf(stderr, \"  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\\n\");\n\tfprintf(stderr, \"      --flush-log-file         Flush log file on write\\n\");\n\tfprintf(stderr, \"  -G, --no-syslog              Don't log via syslog\\n\");\n\tfprintf(stderr, \"  -u, --umask=MASK             umask for file creation (in numeric form)\\n\");\n#ifdef _WITH_VRRP_\n\tfprintf(stderr, \"  -X, --release-vips           Drop VIP on transition from signal.\\n\");\n\tfprintf(stderr, \"  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\\n\");\n#endif\n#ifdef _WITH_LVS_\n\tfprintf(stderr, \"  -I, --dont-release-ipvs      Don't remove IPVS topology on daemon stop\\n\");\n#endif\n\tfprintf(stderr, \"  -R, --dont-respawn           Don't respawn child processes\\n\");\n\tfprintf(stderr, \"  -n, --dont-fork              Don't fork the daemon process\\n\");\n\tfprintf(stderr, \"  -d, --dump-conf              Dump the configuration data\\n\");\n\tfprintf(stderr, \"  -p, --pid=FILE               Use specified pidfile for parent process\\n\");\n#ifdef _WITH_VRRP_\n\tfprintf(stderr, \"  -r, --vrrp_pid=FILE          Use specified pidfile for VRRP child process\\n\");\n#endif\n#ifdef _WITH_LVS_\n\tfprintf(stderr, \"  -c, --checkers_pid=FILE      Use specified pidfile for checkers child process\\n\");\n\tfprintf(stderr, \"  -a, --address-monitoring     Report all address additions/deletions notified via netlink\\n\");\n#endif\n#ifdef _WITH_BFD_\n\tfprintf(stderr, \"  -b, --bfd_pid=FILE           Use specified pidfile for BFD child process\\n\");\n#endif\n#ifdef _WITH_SNMP_\n\tfprintf(stderr, \"  -x, --snmp                   Enable SNMP subsystem\\n\");\n\tfprintf(stderr, \"  -A, --snmp-agent-socket=FILE Use the specified socket for master agent\\n\");\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\tfprintf(stderr, \"  -s, --namespace=NAME         Run in network namespace NAME (overrides config)\\n\");\n#endif\n\tfprintf(stderr, \"  -m, --core-dump              Produce core dump if terminate abnormally\\n\");\n\tfprintf(stderr, \"  -M, --core-dump-pattern=PATN Also set /proc/sys/kernel/core_pattern to PATN (default 'core')\\n\");\n#ifdef _MEM_CHECK_LOG_\n\tfprintf(stderr, \"  -L, --mem-check-log          Log malloc/frees to syslog\\n\");\n#endif\n\tfprintf(stderr, \"  -i, --config-id id           Skip any configuration lines beginning '@' that don't match id\\n\"\n\t\t\t\"                                or any lines beginning @^ that do match.\\n\"\n\t\t\t\"                                The config-id defaults to the node name if option not used\\n\");\n\tfprintf(stderr, \"      --signum=SIGFUNC         Return signal number for STOP, RELOAD, DATA, STATS\"\n#ifdef _WITH_JSON_\n\t\t\t\t\t\t\t\t\", JSON\"\n#endif\n\t\t\t\t\t\t\t\t\"\\n\");\n\tfprintf(stderr, \"  -t, --config-test[=LOG_FILE] Check the configuration for obvious errors, output to\\n\"\n\t\t\t\"                                stderr by default\\n\");\n#ifdef _WITH_PERF_\n\tfprintf(stderr, \"      --perf[=PERF_TYPE]       Collect perf data, PERF_TYPE=all, run(default) or end\\n\");\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\tfprintf(stderr, \"      --debug[=...]            Enable debug options. p, b, c, v specify parent, bfd, checker and vrrp processes\\n\");\n#ifdef _TIMER_CHECK_\n\tfprintf(stderr, \"                                   T - timer debug\\n\");\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tfprintf(stderr, \"                                   M - email alert debug\\n\");\n#endif\n#ifdef _EPOLL_DEBUG_\n\tfprintf(stderr, \"                                   E - epoll debug\\n\");\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tfprintf(stderr, \"                                   D - epoll thread dump debug\\n\");\n#endif\n#ifdef _VRRP_FD_DEBUG\n\tfprintf(stderr, \"                                   F - vrrp fd dump debug\\n\");\n#endif\n#ifdef _REGEX_DEBUG_\n\tfprintf(stderr, \"                                   R - regex debug\\n\");\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tfprintf(stderr, \"                                   X - regex timers\\n\");\n#endif\n#ifdef _TSM_DEBUG_\n\tfprintf(stderr, \"                                   S - TSM debug\\n\");\n#endif\n#ifdef _NETLINK_TIMERS_\n\tfprintf(stderr, \"                                   N - netlink timer debug\\n\");\n#endif\n\tfprintf(stderr, \"                                 Example --debug=TpMEvcp\\n\");\n#endif\n\tfprintf(stderr, \"  -v, --version                Display the version number\\n\");\n\tfprintf(stderr, \"  -h, --help                   Display this help message\\n\");\n}\n\n/* Command line parser */\nstatic bool\nparse_cmdline(int argc, char **argv)\n{\n\tint c;\n\tbool reopen_log = false;\n\tint signum;\n\tstruct utsname uname_buf;\n\tint longindex;\n\tint curind;\n\tbool bad_option = false;\n\tunsigned facility;\n\tmode_t new_umask_val;\n\n\tstruct option long_options[] = {\n\t\t{\"use-file\",\t\trequired_argument,\tNULL, 'f'},\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t{\"vrrp\",\t\tno_argument,\t\tNULL, 'P'},\n\t\t{\"check\",\t\tno_argument,\t\tNULL, 'C'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"no_bfd\",\t\tno_argument,\t\tNULL, 'B'},\n#endif\n\t\t{\"all\",\t\t\tno_argument,\t\tNULL,  3 },\n\t\t{\"log-console\",\t\tno_argument,\t\tNULL, 'l'},\n\t\t{\"log-detail\",\t\tno_argument,\t\tNULL, 'D'},\n\t\t{\"log-facility\",\trequired_argument,\tNULL, 'S'},\n\t\t{\"log-file\",\t\toptional_argument,\tNULL, 'g'},\n\t\t{\"flush-log-file\",\tno_argument,\t\tNULL,  2 },\n\t\t{\"no-syslog\",\t\tno_argument,\t\tNULL, 'G'},\n\t\t{\"umask\",\t\trequired_argument,\tNULL, 'u'},\n#ifdef _WITH_VRRP_\n\t\t{\"release-vips\",\tno_argument,\t\tNULL, 'X'},\n\t\t{\"dont-release-vrrp\",\tno_argument,\t\tNULL, 'V'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"dont-release-ipvs\",\tno_argument,\t\tNULL, 'I'},\n#endif\n\t\t{\"dont-respawn\",\tno_argument,\t\tNULL, 'R'},\n\t\t{\"dont-fork\",\t\tno_argument,\t\tNULL, 'n'},\n\t\t{\"dump-conf\",\t\tno_argument,\t\tNULL, 'd'},\n\t\t{\"pid\",\t\t\trequired_argument,\tNULL, 'p'},\n#ifdef _WITH_VRRP_\n\t\t{\"vrrp_pid\",\t\trequired_argument,\tNULL, 'r'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"checkers_pid\",\trequired_argument,\tNULL, 'c'},\n\t\t{\"address-monitoring\",\tno_argument,\t\tNULL, 'a'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"bfd_pid\",\t\trequired_argument,\tNULL, 'b'},\n#endif\n#ifdef _WITH_SNMP_\n\t\t{\"snmp\",\t\tno_argument,\t\tNULL, 'x'},\n\t\t{\"snmp-agent-socket\",\trequired_argument,\tNULL, 'A'},\n#endif\n\t\t{\"core-dump\",\t\tno_argument,\t\tNULL, 'm'},\n\t\t{\"core-dump-pattern\",\toptional_argument,\tNULL, 'M'},\n#ifdef _MEM_CHECK_LOG_\n\t\t{\"mem-check-log\",\tno_argument,\t\tNULL, 'L'},\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t{\"namespace\",\t\trequired_argument,\tNULL, 's'},\n#endif\n\t\t{\"config-id\",\t\trequired_argument,\tNULL, 'i'},\n\t\t{\"signum\",\t\trequired_argument,\tNULL,  4 },\n\t\t{\"config-test\",\t\toptional_argument,\tNULL, 't'},\n#ifdef _WITH_PERF_\n\t\t{\"perf\",\t\toptional_argument,\tNULL,  5 },\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\t{\"debug\",\t\toptional_argument,\tNULL,  6 },\n#endif\n\t\t{\"version\",\t\tno_argument,\t\tNULL, 'v'},\n\t\t{\"help\",\t\tno_argument,\t\tNULL, 'h'},\n\n\t\t{NULL,\t\t\t0,\t\t\tNULL,  0 }\n\t};\n\n\t/* Unfortunately, if a short option is used, getopt_long() doesn't change the value\n\t * of longindex, so we need to ensure that before calling getopt_long(), longindex\n\t * is set to a known invalid value */\n\tcurind = optind;\n\twhile (longindex = -1, (c = getopt_long(argc, argv, \":vhlndu:DRS:f:p:i:mM::g::Gt::\"\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t\t\t\t    \"PC\"\n#endif\n#ifdef _WITH_VRRP_\n\t\t\t\t\t    \"r:VX\"\n#endif\n#ifdef _WITH_LVS_\n\t\t\t\t\t    \"ac:I\"\n#endif\n#ifdef _WITH_BFD_\n\t\t\t\t\t    \"Bb:\"\n#endif\n#ifdef _WITH_SNMP_\n\t\t\t\t\t    \"xA:\"\n#endif\n#ifdef _MEM_CHECK_LOG_\n\t\t\t\t\t    \"L\"\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\t    \"s:\"\n#endif\n\t\t\t\t, long_options, &longindex)) != -1) {\n\n\t\t/* Check for an empty option argument. For example --use-file= returns\n\t\t * a 0 length option, which we don't want */\n\t\tif (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {\n\t\t\tc = ':';\n\t\t\toptarg = NULL;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tfprintf(stderr, \"%s\", version_string);\n#ifdef GIT_COMMIT\n\t\t\tfprintf(stderr, \", git commit %s\", GIT_COMMIT);\n#endif\n\t\t\tfprintf(stderr, \"\\n\\n%s\\n\\n\", COPYRIGHT_STRING);\n\t\t\tfprintf(stderr, \"Built with kernel headers for Linux %d.%d.%d\\n\",\n\t\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t\tuname(&uname_buf);\n\t\t\tfprintf(stderr, \"Running on %s %s %s\\n\\n\", uname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t\tfprintf(stderr, \"configure options: %s\\n\\n\", KEEPALIVED_CONFIGURE_OPTIONS);\n\t\t\tfprintf(stderr, \"Config options: %s\\n\\n\", CONFIGURATION_OPTIONS);\n\t\t\tfprintf(stderr, \"System options: %s\\n\", SYSTEM_OPTIONS);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t__set_bit(LOG_CONSOLE_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t__set_bit(DUMP_CONF_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'V':\n\t\t\t__set_bit(DONT_RELEASE_VRRP_BIT, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_LVS_\n\t\tcase 'I':\n\t\t\t__set_bit(DONT_RELEASE_IPVS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'D':\n\t\t\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\t\t\t__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);\n\t\t\telse\n\t\t\t\t__set_bit(LOG_DETAIL_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'X':\n\t\t\t__set_bit(RELEASE_VIPS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'S':\n\t\t\tif (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))\n\t\t\t\tfprintf(stderr, \"Invalid log facility '%s'\\n\", optarg);\n\t\t\telse {\n\t\t\t\tlog_facility = LOG_FACILITY[facility].facility;\n\t\t\t\treopen_log = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tlog_file_name = optarg;\n\t\t\telse\n\t\t\t\tlog_file_name = \"/tmp/keepalived.log\";\n\t\t\topen_log_file(log_file_name, NULL, NULL, NULL);\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tnew_umask_val = set_umask(optarg);\n\t\t\tif (umask_cmdline)\n\t\t\t\tumask_val = new_umask_val;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 2:\t\t/* --flush-log-file */\n\t\t\tset_flush_log_file();\n\t\t\tbreak;\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\tcase 'P':\n\t\t\t__clear_bit(DAEMON_CHECKERS, &daemon_mode);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t__clear_bit(DAEMON_VRRP, &daemon_mode);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'B':\n\t\t\t__clear_bit(DAEMON_BFD, &daemon_mode);\n\t\t\tbreak;\n#endif\n\t\tcase 'p':\n\t\t\tmain_pidfile = optarg;\n\t\t\tbreak;\n#ifdef _WITH_LVS_\n\t\tcase 'c':\n\t\t\tcheckers_pidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t__set_bit(LOG_ADDRESS_CHANGES, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_VRRP_\n\t\tcase 'r':\n\t\t\tvrrp_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'b':\n\t\t\tbfd_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_SNMP_\n\t\tcase 'x':\n\t\t\tsnmp = 1;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tsnmp_socket = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'M':\n\t\t\tset_core_dump_pattern = true;\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tcore_dump_pattern = optarg;\n\t\t\t/* ... falls through ... */\n\t\tcase 'm':\n\t\t\tcreate_core_dump = true;\n\t\t\tbreak;\n#ifdef _MEM_CHECK_LOG_\n\t\tcase 'L':\n\t\t\t__set_bit(MEM_CHECK_LOG_BIT, &debug);\n\t\t\tbreak;\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\tcase 's':\n\t\t\toverride_namespace = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(override_namespace, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'i':\n\t\t\tFREE_PTR(config_id);\n\t\t\tconfig_id = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(config_id, optarg);\n\t\t\tbreak;\n\t\tcase 4:\t\t\t/* --signum */\n\t\t\tsignum = get_signum(optarg);\n\t\t\tif (signum == -1) {\n\t\t\t\tfprintf(stderr, \"Unknown sigfunc %s\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\", signum);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 3:\t\t\t/* --all */\n\t\t\t__set_bit(RUN_ALL_CHILDREN, &daemon_mode);\n#ifdef _WITH_VRRP_\n\t\t\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t\t\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t\t\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\t\t\tbreak;\n#ifdef _WITH_PERF_\n\t\tcase 5:\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tif (!strcmp(optarg, \"run\"))\n\t\t\t\t\tperf_run = PERF_RUN;\n\t\t\t\telse if (!strcmp(optarg, \"all\"))\n\t\t\t\t\tperf_run = PERF_ALL;\n\t\t\t\telse if (!strcmp(optarg, \"end\"))\n\t\t\t\t\tperf_run = PERF_END;\n\t\t\t\telse\n\t\t\t\t\tlog_message(LOG_INFO, \"Unknown perf start point %s\", optarg);\n\t\t\t}\n\t\t\telse\n\t\t\t\tperf_run = PERF_RUN;\n\n\t\t\tbreak;\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\tcase 6:\n\t\t\tset_debug_options(optarg && optarg[0] ? optarg : NULL);\n\t\t\tbreak;\n#endif\n\t\tcase '?':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Unknown option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Unknown option %s\\n\", argv[curind]);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Missing parameter for option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Missing parameter for option --%s\\n\", long_options[longindex].name);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t\tcurind = optind;\n\t}\n\n\tif (optind < argc) {\n\t\tprintf(\"Unexpected argument(s): \");\n\t\twhile (optind < argc)\n\t\t\tprintf(\"%s \", argv[optind++]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (bad_option)\n\t\texit(1);\n\n\treturn reopen_log;\n}\n\n#ifdef THREAD_DUMP\nstatic void\nregister_parent_thread_addresses(void)\n{\n\tregister_scheduler_addresses();\n\tregister_signal_thread_addresses();\n\n#ifdef _WITH_LVS_\n\tregister_check_parent_addresses();\n#endif\n#ifdef _WITH_VRRP_\n\tregister_vrrp_parent_addresses();\n#endif\n#ifdef _WITH_BFD_\n\tregister_bfd_parent_addresses();\n#endif\n\n#ifndef _DEBUG_\n\tregister_signal_handler_address(\"propagate_signal\", propagate_signal);\n\tregister_signal_handler_address(\"sigend\", sigend);\n#endif\n\tregister_signal_handler_address(\"thread_child_handler\", thread_child_handler);\n}\n#endif\n\n/* Entry point */\nint\nkeepalived_main(int argc, char **argv)\n{\n\tbool report_stopped = true;\n\tstruct utsname uname_buf;\n\tchar *end;\n\n\t/* Ensure time_now is set. We then don't have to check anywhere\n\t * else if it is set. */\n\tset_time_now();\n\n\t/* Save command line options in case need to log them later */\n\tsave_cmd_line_options(argc, argv);\n\n\t/* Init debugging level */\n\tdebug = 0;\n\n\t/* We are the parent process */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_PARENT;\n#endif\n\n\t/* Initialise daemon_mode */\n#ifdef _WITH_VRRP_\n\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\n\t/* Set default file creation mask */\n\tumask(022);\n\n\t/* Open log with default settings so we can log initially */\n\topenlog(PACKAGE_NAME, LOG_PID, log_facility);\n\n#ifdef _MEM_CHECK_\n\tmem_log_init(PACKAGE_NAME, \"Parent process\");\n#endif\n\n\t/* Some functionality depends on kernel version, so get the version here */\n\tif (uname(&uname_buf))\n\t\tlog_message(LOG_INFO, \"Unable to get uname() information - error %d\", errno);\n\telse {\n\t\tos_major = (unsigned)strtoul(uname_buf.release, &end, 10);\n\t\tif (*end != '.')\n\t\t\tos_major = 0;\n\t\telse {\n\t\t\tos_minor = (unsigned)strtoul(end + 1, &end, 10);\n\t\t\tif (*end != '.')\n\t\t\t\tos_major = 0;\n\t\t\telse {\n\t\t\t\tif (!isdigit(end[1]))\n\t\t\t\t\tos_major = 0;\n\t\t\t\telse\n\t\t\t\t\tos_release = (unsigned)strtoul(end + 1, &end, 10);\n\t\t\t}\n\t\t}\n\t\tif (!os_major)\n\t\t\tlog_message(LOG_INFO, \"Unable to parse kernel version %s\", uname_buf.release);\n\n\t\t/* config_id defaults to hostname */\n\t\tif (!config_id) {\n\t\t\tend = strchrnul(uname_buf.nodename, '.');\n\t\t\tconfig_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);\n\t\t\tstrncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));\n\t\t\tconfig_id[end - uname_buf.nodename] = '\\0';\n\t\t}\n\t}\n\n\t/*\n\t * Parse command line and set debug level.\n\t * bits 0..7 reserved by main.c\n\t */\n\tif (parse_cmdline(argc, argv)) {\n\t\tcloselog();\n\t\tif (!__test_bit(NO_SYSLOG_BIT, &debug))\n\t\t\topenlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);\n\t}\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug))\n\t\tenable_console_log();\n\n#ifdef GIT_COMMIT\n\tlog_message(LOG_INFO, \"Starting %s, git commit %s\", version_string, GIT_COMMIT);\n#else\n\tlog_message(LOG_INFO, \"Starting %s\", version_string);\n#endif\n\n\t/* Handle any core file requirements */\n\tcore_dump_init();\n\n\tif (os_major) {\n\t\tif (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {\n\t\t\t/* keepalived was build for a later kernel version */\n\t\t\tlog_message(LOG_INFO, \"WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s\",\n\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff,\n\t\t\t\t\tuname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t} else {\n\t\t\t/* keepalived was build for a later kernel version */\n\t\t\tlog_message(LOG_INFO, \"Running on %s %s %s (built for Linux %d.%d.%d)\",\n\t\t\t\t\tuname_buf.sysname, uname_buf.release, uname_buf.version,\n\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t}\n\t}\n\n#ifndef _DEBUG_\n\tlog_command_line(0);\n#endif\n\n\t/* Check we can read the configuration file(s).\n\t   NOTE: the working directory will be / if we\n\t   forked, but will be the current working directory\n\t   when keepalived was run if we haven't forked.\n\t   This means that if any config file names are not\n\t   absolute file names, the behaviour will be different\n\t   depending on whether we forked or not. */\n\tif (!check_conf_file(conf_file)) {\n\t\tif (__test_bit(CONFIG_TEST_BIT, &debug))\n\t\t\tconfig_test_exit();\n\n\t\tgoto end;\n\t}\n\n\tglobal_data = alloc_global_data();\n\tglobal_data->umask = umask_val;\n\n\tread_config_file();\n\n\tinit_global_data(global_data, NULL);\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (override_namespace) {\n\t\tif (global_data->network_namespace) {\n\t\t\tlog_message(LOG_INFO, \"Overriding config net_namespace '%s' with command line namespace '%s'\", global_data->network_namespace, override_namespace);\n\t\t\tFREE(global_data->network_namespace);\n\t\t}\n\t\tglobal_data->network_namespace = override_namespace;\n\t\toverride_namespace = NULL;\n\t}\n#endif\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug) &&\n\t    (global_data->instance_name\n#if HAVE_DECL_CLONE_NEWNET\n\t     || global_data->network_namespace\n#endif\n\t\t\t\t\t      )) {\n\t\tif ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {\n\t\t\tlog_message(LOG_INFO, \"Changing syslog ident to %s\", syslog_ident);\n\t\t\tcloselog();\n\t\t\topenlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to change syslog ident\");\n\n\t\tuse_pid_dir = true;\n\n\t\topen_log_file(log_file_name,\n\t\t\t\tNULL,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\tNULL,\n#endif\n\t\t\t\tglobal_data->instance_name);\n\t}\n\n\t/* Initialise pointer to child finding function */\n\tset_child_finder_name(find_keepalived_child_name);\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif (use_pid_dir) {\n\t\t\t/* Create the directory for pid files */\n\t\t\tcreate_pid_dir();\n\t\t}\n\t}\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace) {\n\t\tif (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {\n\t\t\tlog_message(LOG_ERR, \"Unable to set network namespace %s - exiting\", global_data->network_namespace);\n\t\t\tgoto end;\n\t\t}\n\t}\n#endif\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif (global_data->instance_name) {\n\t\t\tif (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_main_pidfile = true;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_checkers_pidfile = true;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_vrrp_pidfile = true;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_bfd_pidfile = true;\n#endif\n\t\t}\n\n\t\tif (use_pid_dir) {\n\t\t\tif (!main_pidfile)\n\t\t\t\tmain_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile)\n\t\t\t\tcheckers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile)\n\t\t\t\tvrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile)\n\t\t\t\tbfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!main_pidfile)\n\t\t\t\tmain_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile)\n\t\t\t\tcheckers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile)\n\t\t\t\tvrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile)\n\t\t\t\tbfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n\t\t}\n\n\t\t/* Check if keepalived is already running */\n\t\tif (keepalived_running(daemon_mode)) {\n\t\t\tlog_message(LOG_INFO, \"daemon is already running\");\n\t\t\treport_stopped = false;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t/* daemonize process */\n\tif (!__test_bit(DONT_FORK_BIT, &debug) &&\n\t    xdaemon(false, false, true) > 0) {\n\t\tcloselog();\n\t\tFREE_PTR(config_id);\n\t\tFREE_PTR(orig_core_dump_pattern);\n\t\tclose_std_fd();\n\t\texit(0);\n\t}\n\n#ifdef _MEM_CHECK_\n\tenable_mem_log_termination();\n#endif\n\n\tif (__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tvalidate_config();\n\n\t\tconfig_test_exit();\n\t}\n\n\t/* write the father's pidfile */\n\tif (!pidfile_write(main_pidfile, getpid()))\n\t\tgoto end;\n\n\t/* Create the master thread */\n\tmaster = thread_make_master();\n\n\t/* Signal handling initialization  */\n\tsignal_init();\n\n\t/* Init daemon */\n\tif (!start_keepalived())\n\t\tlog_message(LOG_INFO, \"Warning - keepalived has no configuration to run\");\n\n\tinitialise_debug_options();\n\n#ifdef THREAD_DUMP\n\tregister_parent_thread_addresses();\n#endif\n\n\t/* Launch the scheduling I/O multiplexer */\n\tlaunch_thread_scheduler(master);\n\n\t/* Finish daemon process */\n\tstop_keepalived();\n\n#ifdef THREAD_DUMP\n\tderegister_thread_addresses();\n#endif\n\n\t/*\n\t * Reached when terminate signal catched.\n\t * finally return from system\n\t */\nend:\n\tif (report_stopped) {\n#ifdef GIT_COMMIT\n\t\tlog_message(LOG_INFO, \"Stopped %s, git commit %s\", version_string, GIT_COMMIT);\n#else\n\t\tlog_message(LOG_INFO, \"Stopped %s\", version_string);\n#endif\n\t}\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data && global_data->network_namespace)\n\t\tclear_namespaces();\n#endif\n\n\tif (use_pid_dir)\n\t\tremove_pid_dir();\n\n\t/* Restore original core_pattern if necessary */\n\tif (orig_core_dump_pattern)\n\t\tupdate_core_dump_pattern(orig_core_dump_pattern);\n\n\tfree_parent_mallocs_startup(false);\n\tfree_parent_mallocs_exit();\n\tfree_global_data(global_data);\n\n\tcloselog();\n\n#ifndef _MEM_CHECK_LOG_\n\tFREE_PTR(syslog_ident);\n#else\n\tif (syslog_ident)\n\t\tfree(syslog_ident);\n#endif\n\tclose_std_fd();\n\n\texit(KEEPALIVED_EXIT_OK);\n}\n"], "filenames": ["keepalived/core/main.c"], "buggy_code_start_loc": [885], "buggy_code_end_loc": [886], "fixing_code_start_loc": [885], "fixing_code_end_loc": [886], "type": "CWE-200", "message": "keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information.", "other": {"cve": {"id": "CVE-2018-19045", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-08T20:29:00.400", "lastModified": "2019-03-12T14:13:28.923", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "keepalived 2.0.8 used mode 0666 when creating new temporary files upon a call to PrintData or PrintStats, potentially leaking sensitive information."}, {"lang": "es", "value": "keepalived 2.0.8 utilizaba el modo 0666 cuando se creaban nuevos archivos temporales tras una llamada a PrintData o PrintStats, con la posibilidad de que se filtrara informaci\u00f3n sensible."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keepalived:keepalived:2.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "41629AA7-851D-438F-8836-0574E4912DF1"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1015141", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/acassen/keepalived/commit/5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/acassen/keepalived/issues/1048", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201903-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/acassen/keepalived/commit/5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6"}}