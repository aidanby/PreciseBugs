{"buggy_code": ["2018-02-06  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* chmd.c: fixed an off-by-one error in the TOLOWER() macro, reported\n\tby Dmitry Glavatskikh. Thanks Dmitry!\n\n2017-11-26  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* kwajd_read_headers(): fix up the logic of reading the filename and\n\textension headers to avoid a one or two byte overwrite. Thanks to\n\tJakub Wilk for finding the issue.\n\n\t* test/kwajd_test.c: add tests for KWAJ filename.ext handling\n\n2017-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* test/cabd_test.c: update the short string tests to expect not only\n\tMSPACK_ERR_DATAFORMAT but also MSPACK_ERR_READ, because of the recent\n\tchange to cabd_read_string(). Thanks to maitreyee43 for spotting this.\n\n\t* test/msdecompile_md5: update the setup instructions for this script,\n\tand also change the script so it works with current Wine. Again, thanks\n\tto maitreyee43 for trying to use it and finding it not working.\n\n2017-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* src/chmextract.c: support MinGW one-arg mkdir(). Thanks to AntumDeluge\n\tfor reporting this.\n\n2017-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* read_spaninfo(): a CHM file can have no ResetTable and have a\n\tnegative length in SpanInfo, which then feeds a negative output length\n\tto lzxd_init(), which then sets frame_size to a value of your choosing,\n\tthe lower 32 bits of output length, larger than LZX_FRAME_SIZE. If the\n\tfirst LZX block is uncompressed, this writes data beyond the end of the\n\twindow. This issue was raised by ClamAV as CVE-2017-6419.  Thanks to\n\tSebastian Andrzej Siewior for finding this by chance!\n\n\t* lzxd_init(), lzxd_set_output_length(), mszipd_init(): due to the issue\n\tmentioned above, these functions now reject negative lengths\n\n2017-08-05  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* cabd_read_string(): add missing error check on result of read().\n\tIf an mspack_system implementation returns an error, it's interpreted\n\tas a huge positive integer, which leads to reading past the end of the\n\tstack-based buffer. Thanks to Sebastian Andrzej Siewior for explaining\n\tthe problem. This issue was raised by ClamAV as CVE-2017-11423\n\n2016-04-20  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* configure.ac: change my email address to kyzer@cabextract.org.uk\n\n2015-05-10  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_read_string(): correct rejection of empty strings. Thanks to\n\tHanno B\u00f6ck for finding the issue and providing a sample file.\n\n2015-05-10  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: Add subdir-objects option as suggested by autoreconf.\n\n\t* configure.ac: Add AM_PROG_AR as suggested by autoreconf.\n\n2015-01-29  Stuart Caie <kyzer@4u.net>\n\n\t* system.h: if C99 inttypes.h exists, use its PRI{d,u}{32,64} macros.\n\tThanks to Johnathan Kollasch for the suggestion.\n\n2015-01-18  Stuart Caie <kyzer@4u.net>\n\n\t* lzxd_decompress(): the byte-alignment code for reading uncompressed\n\tblock headers presumed it could wind i_ptr back 2 bytes, but this\n\thasn't been true since READ_BYTES was allowed to read bytes straddling\n\ttwo blocks, leaving just 1 byte in the read buffer. Thanks to Jakub\n\tWilk for finding the issue and providing a sample file.\n\n\t* inflate(): off-by-one error. Distance codes are 0-29, not 0-30.\n\tThanks to Jakub Wilk again.\n\n\t* chmd_read_headers(), search_chunk(): another fix for checking pointer\n\tis within a chunk, thanks again to Jakub Wilk.\n\n2015-01-17  Stuart Caie <kyzer@4u.net>\n\n\t* GET_UTF8_CHAR(): Remove 5/6-byte encoding support and check decoded\n\tchars are no more than U+10FFFF.\n\n\t* chmd_init_decomp(): A reset interval of 0 is invalid. Thanks to\n\tJakub Wilk for finding the issue and providing a sample and patch.\n\n2015-01-15  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_read_headers(): add a bounds check to prevent over-reading data,\n\twhich caused a segfault on 32-bit architectures. Thanks to Jakub Wilk.\n\n\t* search_chunk(): change the order of pointer arithmetic operations to\n\tavoid overflow during bounds checks, which lead to segfaults on 32-bit\n\tarchitectures. Again, thanks to Jakub Wilk for finding this issue,\n\tproviding sample files and a patch.\n\n2015-01-08  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_extract(): No longer uses broken state data if extracting from\n\tfolder 1, 2, 1 and setting up folder 2 fails. This prevents a jump to\n\tnull and thus segfault. Thanks to Jakub Wilk again.\n\n\t* cabd_read_string: reject empty strings. They are not found in any\n\tvalid CAB files. Thanks to Hanno B\u00f6ck for sending me an example.\n\n2015-01-05  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_can_merge_folders(): disallow folder merging if the combined\n\tfolder would have more than 65535 data blocks.\n\n\t* cabd_decompress(): disallow files if their offset, length or\n\toffset+length is more than 65535*32768, the maximum size of any\n\tfolder. Thanks to Jakub Wilk for identifying the problem and providing\n\ta sample file.\n\n2014-04-20  Stuart Caie <kyzer@4u.net>\n\n\t* readhuff.h: fixed the table overflow check, which allowed one more\n\tcode after capacity had been reached, resulting in a read of\n\tuninitialized data inside the decoding table. Thanks to Denis Kroshin\n\tfor identifying the problem and providing a sample file.\n\n2013-05-27  Stuart Caie <kyzer@4u.net>\n\n\t* test/oabx.c: added new example command for unpacking OAB files.\n\n2013-05-17  Stuart Caie <kyzer@4u.net>\n\n\t* mspack.h: Support for decompressing a new file format, the Exchange\n\tOffline Address Book (OAB). Thanks to David Woodhouse for writing\n\tthe implementation. I've bumped the version to 0.4alpha in celebration.\n\n2012-04-15  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_read_headers(): More thorough validation of CHM header values.\n\tThanks to Sergei Trofimovich for finding sample files.\n\n\t* read_reset_table(): Better test for overflow. Thanks again to\n\tSergei Trofimovich for generating a good example.\n\n\t* test/chminfo.c: this test program reads the reset table by itself\n\tand was also susceptible to the same overflow problems.\n\n2012-03-16  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am, configure.ac: make the GCC warning flags conditional\n\ton using the GCC compiler. Thanks to Dagobert Michelsen for letting\n\tme know.\n\n2011-11-25  Stuart Caie <kyzer@4u.net>\n\n\t* lzxd_decompress(): Prevent matches that go beyond the start\n\tof the LZX stream. Thanks to Sergei Trofimovich for testing\n\twith valgrind and finding a corrupt sample file that exercises\n\tthis scenario.\n\n2011-11-23  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_fast_find(): add a simple check against infinite PMGL\n\tloops. Thanks to Sergei Trofimovich for finding sample files.\n\tMulti-step PMGL/PMGI infinite loops remain possible.\n\n2011-06-17  Stuart Caie <kyzer@4u.net>\n\n\t* read_reset_table(): wasn't reading the right offset for getting\n\tthe LZX uncompressed length. Thanks to Sergei Trofimovich for\n\tfinding the bug.\n\n2011-05-31  Stuart Caie <kyzer@4u.net>\n\n\t* kwajd.c, mszipd.c: KWAJ type 4 files (MSZIP) are now supported.\n\tThanks to Clive Turvey for sending me the format details.\n\n\t* doc/szdd_kwaj_format.html: Updated documentation to cover\n\tKWAJ's MSZIP compression.\n\n2011-05-11  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_find(): rethought how large vs small file support is\n\thandled, as users were getting \"library not compiled to support\n\tlarge files\" message on some small files. Now checks for actual\n\toff_t overflow, rather than trying to preempt it.\n\n2011-05-10:  Stuart Caie <kyzer@4u.net>\n\n\t* chmd.c: implemented fast_find()\n\n\t* test/chmx.c: removed the multiple extraction orders, now it just\n\textracts in the fastest order\n\n\t* test/chmd_order.c: new program added to test that different\n\textraction orders don't affect the results of extraction\n\n\t* test/chmd_find.c: new program to test that fast_find() works.\n\tEither supply your own filename to find, or it will try finding\n\tevery file in the CHM.\n\n\t* configure.ac: because CHM fast find requires case-insensitive\n\tcomparisons, tolower() or towlower() are used where possible.\n\tThese functions and their headers are checked for.\n\n\t* mspack.h: exposed struct mschmd_sec_mscompressed's spaninfo\n\tand struct mschmd_header's first_pmgl, last_pmgl and chunk_cache\n\tto the world. Check that the CHM decoder version is v2 or higher\n\tbefore using them.\n\n\t* system.c: set CHM decoder version to v2\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: Made C++ compilers much happier with libmspack.\n\tChanged char * to const char * where possible.\n\n\t* mspack.h: Changed user-supplied char * to const char *.\n\tUnless you've written your own mspack_system implementation,\n\tyou will likely be unaffected.\n\tIf you have written your own mspack_system implementation:\n\t1: change open()    so it takes a const char *filename\n\t2: change message() so it takes a const char *format\n\tIf you cast your function into the mspack_system struct,\n\tyou can change the cast instead of the function.\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: changed CFLAGS from \"-Wsign-compare -Wconversion\n\t-pedantic\" to \"-W -Wno-unused\". This enables more warnings, and\n\tdisables these specific warnings which are now a hinderance.\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* test/cabrip.c, test/chminfo.c: used macros from system.h for\n\tprinting offsets and reading 64-bit values, rather than\n\treinvent the wheel.\n\n\t* cabd_can_merge_folders(): declare variables at the start of\n\ta block so older C compilers won't choke.\n\n\t* cabd_find(): avoid compiler complaints about non-initialised\n\tvariables. We know they'll get initialised before use, but the\n\tcompiler can't reverse a state machine to draw the same conclusion.\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* configure.ac, mspack/system.h: Added a configure test to get\n\tthe size of off_t. If off_t is 8 bytes or more, we presume this\n\tsystem has large file support. This fixes LFS detection for Fedora\n\tx86_64 and Darwin/Mac OS X, neither of which declare FILESIZEBITS in\n\t<limits.h>. It's not against the POSIX standard to do this: \"A\n\tdefinition of [FILESIZEBITS] shall be omitted from the <limits.h>\n\theader on specific implementations where the corresponding value is\n\tequal to or greater than the stated minimum, but where the value can\n\tvary depending on the file to which it is applied.\"\n\t(http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html)\n\tThanks to Edward Sheldrake for the patch.\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* chmd.c: all 64-bit integer reads are now consolidated into\n\tthe read_off64() function\n\n\t* chmd_read_headers(): this function has been made resilient\n\tagainst accessing memory past the end of a chunk. Thanks to\n\tSergei Trofimovich for sending me examples and analysis.\n\n\t* chmd_init_decomp(): this function now reads the SpanInfo file\n\tif the ResetTable file isn't available, it also checks that each\n\tsystem file it needs is large enough before accessing it, and\n\tsome of its code has been split into several new functions:\n\tfind_sys_file(), read_reset_table() and read_spaninfo()\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* mspack.h, chmd.c: now reads the SpanInfo system file if the\n\tResetTable file isn't available. This adds a new spaninfo pointer\n\tinto struct mschmd_sec_mscompressed\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* test/chminfo.c: more sanity checks for corrupted CHM files where\n\tentries go past the end of a PMGL/PMGI chunk, thanks to\n\tSergei Trofimovich for sending me examples and analysis.\n\n2011-04-25:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_merge():  Drew D'Addesio showed me spanning cabinets which\n\tdon't have all the CFFILE entries they should, but otherwise have\n\tall necessary data for extraction. Changed the merging folders\n\ttest to be less strict; if folders don't exactly match, warn which\n\tfiles are missing, but allow merging if at least one necessary\n\tfile is present.\n\n2010-09-24:  Stuart Caie <kyzer@4u.net>\n\n\t* readhuff.h: Don't let build_decode_table() allow empty trees.\n\tIt's meant to be special case just for the LZX length tree, so\n\tmove that logic out to the LZX code. Thanks to Danny Kroshin for\n\tdiscovering the bug.\n\n\t* lzxd.c: Allow empty length trees, but not other trees. If\n\tthe length tree is empty, fail if asked to decode a length symbol.\n\tAgain, thanks to Danny Kroshin for discovering the bug.\n\n2010-09-20:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: Set EXTRA_DIST so it doesn't include .svn\n\tdirectories in the distribution, but does include docs.\n\n2010-09-20:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am, configure.ac: Use modern auto* practises; turn on\n\tautomake silent rules where possible, use \"m4\" directory for libtool\n\tmacros, use LT_INIT instead of AC_PROG_LIBTOOL and use AM_CPPFLAGS\n\tinstead of INCLUDES. Thanks to Sergei Trofimovich for the patch.\n\n2010-09-15:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: Made the code compile with C++\n\t- Renamed all 'this' variables/parameters to 'self'\n\t- Added casts to all memory allocations.\n\t- Added extern \"C\" to header files with extern declarations.\n\t- Made system.c include system.h.\n\t- Changed the K&R-style headers to ANSI-style headers in md5.c\n\n2010-08-04:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: removed unnecessary <unistd.h> include\n\n2010-07-19:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_md5.c, chmd_md5.c: Replace writing files to disk then\n\tMD5summing them, with an MD5summer built into mspack_system.\n\tMuch, much faster results.\n\n\t* qtmd_decompress(): Robert Riebisch pointed out a Quantum\n\tdata integrity check that could never be tripped, because\n\tframe_todo is unsigned, so it will never be decremented\n\tbelow zero. Replaced the check with one that assumes that\n\tdecrementing past zero wraps frame_todo round to a number\n\tmore than its maximum value (QTM_FRAME_SIZE).\n\n2010-07-18:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd.c: Special logic to pass cabd_sys_read() errors back\n\tto cabd_extract() wasn't compatible with the decompressor\n\tlogic of returning the same error repeatedly once unpacking\n\tfails. This meant that if decompressing failed because of\n\ta read error, then the next file in the same folder would\n\tcome back as \"no error\", but the decompressed wouldn't have\n\teven attempted to decompress the file. Added a new state\n\tvariable, read_error, with the same lifespan as a decompressor,\n\tto pass the underlying reason for MSPACK_ERR_READ errors back.\n\n\t* mszipd.c: improve MS-ZIP recovery by saving all the bytes\n\tdecoded prior to a block failing. This requires remembering\n\thow far we got through the block, so the code has been made\n\tslightly slower (about 0.003 seconds slower per gigabyte\n\tunpacked) by removing the local variable window_posn\n\tand keeping it in the state structure instead.\n\n2010-07-16:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: strange interactions. When -std=c99 is used,\n\tmy Ubuntu's <stdio.h> (libc6-dev 2.11.1-0ubuntu7.2) does NOT\n\tdefine fseeko() unless _LARGEFILE_SOURCE is also defined. But\n\tconfigure always uses -std=gnu99, not -std=c99, so its test\n\tdetermines _LARGEFILE_SOURCE isn't needed but HAVE_FSEEKO is\n\ttrue. The implicit fseeko definition has a 32-bit rather than\n\t64-bit offset, which means the mode parameter is interpreted\n\tas part of the offset, and the mode is taken from the stack,\n\twhich is generally 0 (SEEK_SET). This breaks all SEEK_CURs.\n\tThe code works fine when -std=c99 is not set, so just remove\n\tit for the time being.\n\n2010-07-12:  Stuart Caie <kyzer@4u.net>\n\n\t* system.c: Reject reading/writing a negative number of bytes.\n\n\t* chmd.c: allow zero-length files to be seen. Previously they were\n\tskipped because they were mistaken for directory entries.\n\n2010-07-08:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd.c: Larry Frieson found an important bug in the Quantum\n\tdecoder. Window wraps flush all unwritten data to disk.\n\tHowever, sometimes less data is needed, which makes\n\tout_bytes negative, which is then passed to write(). Some\n\twrite() implementations treat negative sizes it as a large\n\tpositive integer and segfault trying to write the buffer.\n\n\t* Makefile.am, test/*.c: fixed automake file so that the\n\tpackage passes a \"make distcheck\".\n\n2010-07-07:  Stuart Caie <kyzer@4u.net>\n\n\t* doc/szdd_kwaj_format.html: explain SZDD/KWAJ file format.\n\n\t* lzssd.c: fixed SZDD decompression bugs.\n\n\t* test/chmd_compare: Add scripts for comparing chmd_md5 against\n\tMicrosoft's own code.\n\n\t* test/chmd_md5.c: remove the need to decompress everything\n\ttwice, as this is already in chmx.c if needed.\n\n2010-07-06:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: added SZDD and KWAJ decompression support.\n\n2010-06-18:  Stuart Caie  <kyzer@4u.net>\n\n\t* system.h: expanded the test for 64-bit largefile support so\n\tit also works on 64-bit native operating systems where you\n\tdon't have to define _FILE_OFFSET_BITS.\n\n2010-06-17:  Stuart Caie <kyzer@4u.net>\n\n\t* libmspack.pc.in: Added pkg-config support. Thanks to\n\tPatrice Dumas for the patch.\n\n2010-06-14:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd.c, lzxd.c, mszipd.c: created new headers, readbits.h and\n\treadhuff.h, which bundle up the bit-reading and huffman-reading\n\tcode found in the MSZIP, LZX and Quantum decoders.\n\n2010-06-11:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd_static_init(): Removed function in favour of static const\n\ttables, same rationale as for lzxd_static_init().\n\n\t* qtmd_read_input(), zipd_read_input(): After testing against my\n\tset of CABs from the wild, I've found both these functions _need_\n\tan extra EOF flag, like lzxd_read_input() has. So I've added\n\tit. This means CABs get decoded properly AND there's no reading\n\tfictional bytes.\n\n2010-06-03:  Stuart Caie  <kyzer@4u.net>\n\n\t* test/cabd_md5.c: updated this so it has better output and\n\tdoesn't need to be in the same directory as the files for multi-\n\tpart sets.\n\n2010-05-20:  Stuart Caie  <kyzer@4u.net>\n\n\t* qtmd_read_input(), zipd_read_input(): Both these functions are\n\tessentially copies of lzxd_read_input(), but that has a feature\n\tthey don't have - an extra EOF flag. So if EOF is\n\tencountered (sys->read() returns 0 bytes), these don't pass on the\n\terror. Their respective bit-reading functions that called them\n\tthen go on to access at least one byte of the input buffer, which\n\tdoesn't exist as sys->read() returned 0. Thanks to Michael\n\tVidrevich for spotting this and providing a test case.\n\n2010-05-20:  Stuart Caie  <kyzer@4u.net>\n\n\t* system.h: It turns out no configure.ac tests are needed to\n\tdecide between __func__ and __FUNCTION__, so I put the standard\n\tone (__func__) back into the D() macro, along with some\n\tspecial-case ifdefs for old versions of GCC.\n\n\t* lzxd_static_init(): Removed function in favour of static const\n\ttables.  Jorge Lodos thinks it causes multithreading problems, I\n\tdisagree. However, there are speed benefits to declaring the\n\ttables as static const.\n\n\t* cabd_init_decomp(): Fixed code which never runs but would write\n\tto a null pointer if it could. Changed it to an assert() as it\n\twill only trip if someone rewrites the internals of cabd.c. Thanks\n\tto Jorge Lodos for finding it.\n\n\t* inflate(): Fixed an off-by-one error: if the LITERAL table\n\temitted code 286, this would read one byte past the end of\n\tlit_extrabits[]. Thanks to Jorge Lodos for finding it.\n\n2010-05-06:  Stuart Caie  <kyzer@4u.net>\n\n\t* test/cabrip.c, test/chminfo.c: add fseeko() support\n\n2009-06-01:  Stuart Caie   <kyzer@4u.net>\n\n\t* README: clarify the extended license terms\n\n\t* doc, Makefile.am: make the doxygen makefile work when using\n\tan alternate build directory\n\n2006-09-20:  Stuart Caie   <kyzer@4u.net>\n\n\t* system.h: I had a choice of adding more to configure.ac to\n\ttest for __func__ and __FUNCTION__, or just removing __FUNCTION__\n\tfrom the D() macro. I chose the latter.\n\n\t* Makefile.am: Now the --enable-debug in configure will actually\n\tapply -DDEBUG to the sources.\n\n2006-09-20:  Stuart Caie   <kyzer@4u.net>\n\n\t* qtmd_decompress(): Fixed a major bug in the QTM decoder, as\n\treported by Tomasz Kojm last year. Removed the restriction on\n\twindow sizes as a result. Correctly decodes the XLVIEW cabinets.\n\n2006-08-31:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzxd_decompress(): Two major bugs fixed. Firstly, the R0/R1/R2\n\tlocal variables weren't set to 1 after lzxd_reset_state().\n\tSecondly, the LZX decompression stream can sometimes become\n\todd-aligned (after an uncompressed block) and the next 16 bit\n\tfetch needs to be split across two input buffers, ENSURE_BITS()\n\tdidn't cover this case. Many thanks to Igor Glucksmann for\n\tdiscovering both these bugs.\n\n2005-06-30:  Stuart Caie   <kyzer@4u.net>\n\n\t* cabd_search(): fixed problems with searching files > 4GB for\n\tcabinets.\n\n2005-06-23:  Stuart Caie   <kyzer@4u.net>\n\n\t* qtmd_init(): The QTM decoder is broken for QTM streams with a\n\twindow size less than the frame size. Until this is fixed, fail\n\tto initialise QTM window sizes less than 15. Thanks to Tomasz Kojm\n\tfor finding the bug.\n\n2005-03-22:  Stuart Caie   <kyzer@4u.net>\n\n\t* system.h: now undefs \"read\", as the latest glibc defines read()\n\tas a macro which messes everything up. Thanks to Ville Skytt\u00e4 for\n\tthe update.\n\n2005-03-14:  Stuart Caie   <kyzer@4u.net>\n\n\t* test/multifh.c: write an mspack_system implementation that can\n\thandle normal disk files, open file handles, open file descriptors\n\tand raw memory all at the same time.\n\n2005-02-24:  Stuart Caie   <kyzer@4u.net>\n\n\t* chmd_read_headers(): avoid infinite loop when chmhs1_ChunkSize is\n\tzero. Thanks to Serge Semashko for the research and discovery.\n\n2005-02-18:  Stuart Caie   <kyzer@4u.net>\n\n\t* mspack.h: renamed the \"interface\" parameter of mspack_version() to\n\t\"entity\", as interface is a reserved word in C++. Thanks to Yuriy Z\n\tfor the discovery.\n\n2004-12-09:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzss.h, szdd.h, szddd.h: more work on the SZDD/LZSS design.\n\t\n2004-06-12:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzxd_static_init(): removed write to lzxd_extra_bits[52], thanks\n\tto Nigel Horne from the ClamAV project.\n\n2004-04-23:  Stuart Caie   <kyzer@4u.net>\n\n\t* mspack.h: changed 'this' parameters to 'self' to allow compiling in\n\tC++ compilers, thanks to Michal Cihar for the suggestion.\n\n\t* mspack.h, system.h, mspack.def, winbuild.sh: integrated some changes\n\tfrom Petr Blahos to let libmspack build as a Win32 DLL.\n\n\t* chmd_fast_find(): added the first part of this code, and comments\n\tsufficient to finish it :)\n\n2004-04-08  Stuart Caie   <kyzer@4u.net>\n\n\t* test/chminfo.c: added a program for dumping useful data from CHM\n\tfiles, e.g. index entries and reset tables. I wrote this a while ago\n\tfor investigating a corrupt cabinet, but I never committed it.\n\n2004-03-26  Stuart Caie   <kyzer@4u.net>\n\n\t* test/cabd_memory.c: added a new test example which shows an\n\tmspack_system implementation that reads and writes from memory only,\n\tno file I/O. Even the source code has a little cab file embedded in it.\n\n2004-03-10  Stuart Caie   <kyzer@4u.net>\n\n\t* cabd.c: updated the location of the CAB SDK.\n\n\t* cabd.c: changed a couple of MSPACK_ERR_READ errors not based on\n\tread() failures into MSPACK_ERR_DATAFORMAT errors.\n\n\t* mszipd_decompress(): repair mode now aborts after writing a\n\trepaired block if the error was a hard error (e.g. read error, out\n\tof blocks, etc)\n\n2004-03-08  Stuart Caie   <kyzer@4u.net>\n\n\t* Makefile.am: now builds and installs a versioned library.\n\n\t* mszipd.c: completed a new MS-ZIP and inflate implementation.\n\n\t* system.c: added mspack_version() and committed to a versioned\n\tABI for the library.\n\n\t* cabd.c: made mszip repair functionality work correctly.\n\n\t* cabd.c: now identifies invalid block headers\n\n\t* doc/: API documentation is now included with the library, not\n\tjust on the web.\n\n\t* chmd.c: fixed error messages and 64-bit debug output.\n\n\t* chmd.c: now also catches NULL files in section 1.\n\n\t* test/chmx.c: now acts more like cabextract.\n\n2003-08-29  Stuart Caie   <kyzer@4u.net>\n\n\t* ChangeLog: started keeping a ChangeLog :)\n", "/* This file is part of libmspack.\n * (C) 2003-2011 Stuart Caie.\n *\n * libmspack is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License (LGPL) version 2.1\n *\n * For further details, see the file COPYING.LIB distributed with libmspack\n */\n\n/* CHM decompression implementation */\n\n#include <system.h>\n#include <chm.h>\n\n/* prototypes */\nstatic struct mschmd_header * chmd_open(\n  struct mschm_decompressor *base, const char *filename);\nstatic struct mschmd_header * chmd_fast_open(\n  struct mschm_decompressor *base, const char *filename);\nstatic struct mschmd_header *chmd_real_open(\n  struct mschm_decompressor *base, const char *filename, int entire);\nstatic void chmd_close(\n  struct mschm_decompressor *base, struct mschmd_header *chm);\nstatic int chmd_read_headers(\n  struct mspack_system *sys, struct mspack_file *fh,\n  struct mschmd_header *chm, int entire);\nstatic int chmd_fast_find(\n  struct mschm_decompressor *base, struct mschmd_header *chm,\n  const char *filename, struct mschmd_file *f_ptr, int f_size);\nstatic unsigned char *read_chunk(\n  struct mschm_decompressor_p *self, struct mschmd_header *chm,\n  struct mspack_file *fh, unsigned int chunk);\nstatic int search_chunk(\n  struct mschmd_header *chm, const unsigned char *chunk, const char *filename,\n  const unsigned char **result, const unsigned char **result_end);\nstatic inline int compare(\n  const char *s1, const char *s2, int l1, int l2);\nstatic int chmd_extract(\n  struct mschm_decompressor *base, struct mschmd_file *file,\n  const char *filename);\nstatic int chmd_sys_write(\n  struct mspack_file *file, void *buffer, int bytes);\nstatic int chmd_init_decomp(\n  struct mschm_decompressor_p *self, struct mschmd_file *file);\nstatic int read_reset_table(\n  struct mschm_decompressor_p *self, struct mschmd_sec_mscompressed *sec,\n  int entry, off_t *length_ptr, off_t *offset_ptr);\nstatic int read_spaninfo(\n  struct mschm_decompressor_p *self, struct mschmd_sec_mscompressed *sec,\n  off_t *length_ptr);\nstatic int find_sys_file(\n  struct mschm_decompressor_p *self, struct mschmd_sec_mscompressed *sec,\n  struct mschmd_file **f_ptr, const char *name);\nstatic unsigned char *read_sys_file(\n  struct mschm_decompressor_p *self, struct mschmd_file *file);\nstatic int chmd_error(\n  struct mschm_decompressor *base);\nstatic int read_off64(\n  off_t *var, unsigned char *mem, struct mspack_system *sys,\n  struct mspack_file *fh);\n\n/* filenames of the system files used for decompression.\n * Content and ControlData are essential.\n * ResetTable is preferred, but SpanInfo can be used if not available\n */\nstatic const char *content_name  = \"::DataSpace/Storage/MSCompressed/Content\";\nstatic const char *control_name  = \"::DataSpace/Storage/MSCompressed/ControlData\";\nstatic const char *spaninfo_name = \"::DataSpace/Storage/MSCompressed/SpanInfo\";\nstatic const char *rtable_name   = \"::DataSpace/Storage/MSCompressed/Transform/\"\n  \"{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable\";\n\n/***************************************\n * MSPACK_CREATE_CHM_DECOMPRESSOR\n ***************************************\n * constructor\n */\nstruct mschm_decompressor *\n  mspack_create_chm_decompressor(struct mspack_system *sys)\n{\n  struct mschm_decompressor_p *self = NULL;\n\n  if (!sys) sys = mspack_default_system;\n  if (!mspack_valid_system(sys)) return NULL;\n\n  if ((self = (struct mschm_decompressor_p *) sys->alloc(sys, sizeof(struct mschm_decompressor_p)))) {\n    self->base.open       = &chmd_open;\n    self->base.close      = &chmd_close;\n    self->base.extract    = &chmd_extract;\n    self->base.last_error = &chmd_error;\n    self->base.fast_open  = &chmd_fast_open;\n    self->base.fast_find  = &chmd_fast_find;\n    self->system          = sys;\n    self->error           = MSPACK_ERR_OK;\n    self->d               = NULL;\n  }\n  return (struct mschm_decompressor *) self;\n}\n\n/***************************************\n * MSPACK_DESTROY_CAB_DECOMPRESSOR\n ***************************************\n * destructor\n */\nvoid mspack_destroy_chm_decompressor(struct mschm_decompressor *base) {\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  if (self) {\n    struct mspack_system *sys = self->system;\n    if (self->d) {\n      if (self->d->infh)  sys->close(self->d->infh);\n      if (self->d->state) lzxd_free(self->d->state);\n      sys->free(self->d);\n    }\n    sys->free(self);\n  }\n}\n\n/***************************************\n * CHMD_OPEN\n ***************************************\n * opens a file and tries to read it as a CHM file.\n * Calls chmd_real_open() with entire=1.\n */\nstatic struct mschmd_header *chmd_open(struct mschm_decompressor *base,\n\t\t\t\t       const char *filename)\n{\n  return chmd_real_open(base, filename, 1);\n}\n\n/***************************************\n * CHMD_FAST_OPEN\n ***************************************\n * opens a file and tries to read it as a CHM file, but does not read\n * the file headers. Calls chmd_real_open() with entire=0\n */\nstatic struct mschmd_header *chmd_fast_open(struct mschm_decompressor *base,\n\t\t\t\t\t    const char *filename)\n{\n  return chmd_real_open(base, filename, 0);\n}\n\n/***************************************\n * CHMD_REAL_OPEN\n ***************************************\n * the real implementation of chmd_open() and chmd_fast_open(). It simply\n * passes the \"entire\" parameter to chmd_read_headers(), which will then\n * either read all headers, or a bare mininum.\n */\nstatic struct mschmd_header *chmd_real_open(struct mschm_decompressor *base,\n\t\t\t\t\t    const char *filename, int entire)\n{\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  struct mschmd_header *chm = NULL;\n  struct mspack_system *sys;\n  struct mspack_file *fh;\n  int error;\n\n  if (!base) return NULL;\n  sys = self->system;\n\n  if ((fh = sys->open(sys, filename, MSPACK_SYS_OPEN_READ))) {\n    if ((chm = (struct mschmd_header *) sys->alloc(sys, sizeof(struct mschmd_header)))) {\n      chm->filename = filename;\n      error = chmd_read_headers(sys, fh, chm, entire);\n      if (error) {\n\t/* if the error is DATAFORMAT, and there are some results, return\n\t * partial results with a warning, rather than nothing */\n\tif (error == MSPACK_ERR_DATAFORMAT && (chm->files || chm->sysfiles)) {\n\t  sys->message(fh, \"WARNING; contents are corrupt\");\n\t  error = MSPACK_ERR_OK;\n\t}\n\telse {\n\t  chmd_close(base, chm);\n\t  chm = NULL;\n\t}\n      }\n      self->error = error;\n    }\n    else {\n      self->error = MSPACK_ERR_NOMEMORY;\n    }\n    sys->close(fh);\n  }\n  else {\n    self->error = MSPACK_ERR_OPEN;\n  }\n  return chm;\n}\n\n/***************************************\n * CHMD_CLOSE\n ***************************************\n * frees all memory associated with a given mschmd_header\n */\nstatic void chmd_close(struct mschm_decompressor *base,\n\t\t       struct mschmd_header *chm)\n{\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  struct mschmd_file *fi, *nfi;\n  struct mspack_system *sys;\n  unsigned int i;\n\n  if (!base) return;\n  sys = self->system;\n\n  self->error = MSPACK_ERR_OK;\n\n  /* free files */\n  for (fi = chm->files; fi; fi = nfi) {\n    nfi = fi->next;\n    sys->free(fi);\n  }\n  for (fi = chm->sysfiles; fi; fi = nfi) {\n    nfi = fi->next;\n    sys->free(fi);\n  }\n\n  /* if this CHM was being decompressed, free decompression state */\n  if (self->d && (self->d->chm == chm)) {\n    if (self->d->infh) sys->close(self->d->infh);\n    if (self->d->state) lzxd_free(self->d->state);\n    sys->free(self->d);\n    self->d = NULL;\n  }\n\n  /* if this CHM had a chunk cache, free it and contents */\n  if (chm->chunk_cache) {\n      for (i = 0; i < chm->num_chunks; i++) sys->free(chm->chunk_cache[i]);\n      sys->free(chm->chunk_cache);\n  }\n\n  sys->free(chm);\n}\n\n/***************************************\n * CHMD_READ_HEADERS\n ***************************************\n * reads the basic CHM file headers. If the \"entire\" parameter is\n * non-zero, all file entries will also be read. fills out a pre-existing\n * mschmd_header structure, allocates memory for files as necessary\n */\n\n/* The GUIDs found in CHM headers */\nstatic const unsigned char guids[32] = {\n  /* {7C01FD10-7BAA-11D0-9E0C-00A0-C922-E6EC} */\n  0x10, 0xFD, 0x01, 0x7C, 0xAA, 0x7B, 0xD0, 0x11,\n  0x9E, 0x0C, 0x00, 0xA0, 0xC9, 0x22, 0xE6, 0xEC,\n  /* {7C01FD11-7BAA-11D0-9E0C-00A0-C922-E6EC} */\n  0x11, 0xFD, 0x01, 0x7C, 0xAA, 0x7B, 0xD0, 0x11,\n  0x9E, 0x0C, 0x00, 0xA0, 0xC9, 0x22, 0xE6, 0xEC\n};\n\n/* reads an encoded integer into a variable; 7 bits of data per byte,\n * the high bit is used to indicate that there is another byte */\n#define READ_ENCINT(var) do {\t\t\t\\\n    (var) = 0;\t\t\t\t\t\\\n    do {\t\t\t\t\t\\\n\tif (p >= end) goto chunk_end;\t\t\\\n\t(var) = ((var) << 7) | (*p & 0x7F);\t\\\n    } while (*p++ & 0x80);\t\t\t\\\n} while (0)\n\nstatic int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}\n\n/***************************************\n * CHMD_FAST_FIND\n ***************************************\n * uses PMGI index chunks and quickref data to quickly locate a file\n * directly from the on-disk index.\n *\n * TODO: protect against infinite loops in chunks (where pgml_NextChunk\n * or a PMGI index entry point to an already visited chunk)\n */\nstatic int chmd_fast_find(struct mschm_decompressor *base,\n\t\t\t  struct mschmd_header *chm, const char *filename,\n\t\t\t  struct mschmd_file *f_ptr, int f_size)\n{\n    struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n    struct mspack_system *sys;\n    struct mspack_file *fh;\n    const unsigned char *chunk, *p, *end;\n    int err = MSPACK_ERR_OK, result = -1;\n    unsigned int n, sec;\n\n    if (!self || !chm || !f_ptr || (f_size != sizeof(struct mschmd_file))) {\n\treturn MSPACK_ERR_ARGS;\n    }\n    sys = self->system;\n\n    /* clear the results structure */\n    memset(f_ptr, 0, f_size);\n\n    if (!(fh = sys->open(sys, chm->filename, MSPACK_SYS_OPEN_READ))) {\n\treturn MSPACK_ERR_OPEN;\n    }\n\n    /* go through PMGI chunk hierarchy to reach PMGL chunk */\n    if (chm->index_root < chm->num_chunks) {\n\tn = chm->index_root;\n\tfor (;;) {\n\t    if (!(chunk = read_chunk(self, chm, fh, n))) {\n\t\tsys->close(fh);\n\t\treturn self->error;\n\t    }\n\n\t    /* search PMGI/PMGL chunk. exit early if no entry found */\n\t    if ((result = search_chunk(chm, chunk, filename, &p, &end)) <= 0) {\n\t\tbreak;\n\t    }\n\n\t    /* found result. loop around for next chunk if this is PMGI */\n\t    if (chunk[3] == 0x4C) break; else READ_ENCINT(n);\n\t}\n    }\n    else {\n\t/* PMGL chunks only, search from first_pmgl to last_pmgl */\n\tfor (n = chm->first_pmgl; n <= chm->last_pmgl;\n\t     n = EndGetI32(&chunk[pmgl_NextChunk]))\n\t{\n\t    if (!(chunk = read_chunk(self, chm, fh, n))) {\n\t\terr = self->error;\n\t\tbreak;\n\t    }\n\n\t    /* search PMGL chunk. exit if file found */\n\t    if ((result = search_chunk(chm, chunk, filename, &p, &end)) > 0) {\n\t\tbreak;\n\t    }\n\n            /* stop simple infinite loops: can't visit the same chunk twice */\n            if ((int)n == EndGetI32(&chunk[pmgl_NextChunk])) {\n                break;\n            }\n\t}\n    }\n\n    /* if we found a file, read it */\n    if (result > 0) {\n\tREAD_ENCINT(sec);\n\tf_ptr->section  = (sec == 0) ? (struct mschmd_section *) &chm->sec0\n\t                             : (struct mschmd_section *) &chm->sec1;\n\tREAD_ENCINT(f_ptr->offset);\n\tREAD_ENCINT(f_ptr->length);\n    }\n    else if (result < 0) {\n\terr = MSPACK_ERR_DATAFORMAT;\n    }\n\n    sys->close(fh);\n    return self->error = err;\n\n chunk_end:\n    D((\"read beyond end of chunk entries\"))\n    sys->close(fh);\n    return self->error = MSPACK_ERR_DATAFORMAT;\n}\n\n/* reads the given chunk into memory, storing it in a chunk cache\n * so it doesn't need to be read from disk more than once\n */\nstatic unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num > chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}\n\n/* searches a PMGI/PMGL chunk for a given filename entry. Returns -1 on\n * data format error, 0 if entry definitely not found, 1 if entry\n * found. In the latter case, *result and *result_end are set pointing\n * to that entry's data (either the \"next chunk\" ENCINT for a PMGI or\n * the section, offset and length ENCINTs for a PMGL).\n *\n * In the case of PMGL chunks, the entry has definitely been\n * found. In the case of PMGI chunks, the entry which points to the\n * chunk that may eventually contain that entry has been found.\n */\nstatic int search_chunk(struct mschmd_header *chm,\n\t\t\tconst unsigned char *chunk,\n\t\t\tconst char *filename,\n\t\t\tconst unsigned char **result,\n\t\t\tconst unsigned char **result_end)\n{\n    const unsigned char *start, *end, *p;\n    unsigned int qr_size, num_entries, qr_entries, qr_density, name_len;\n    unsigned int L, R, M, fname_len, entries_off, is_pmgl;\n    int cmp;\n\n    fname_len = strlen(filename);\n\n    /* PMGL chunk or PMGI chunk? (note: read_chunk() has already\n     * checked the rest of the characters in the chunk signature) */\n    if (chunk[3] == 0x4C) {\n\tis_pmgl = 1;\n\tentries_off = pmgl_Entries;\n    }\n    else {\n\tis_pmgl = 0;\n\tentries_off = pmgi_Entries;\n    }\n\n    /*  Step 1: binary search first filename of each QR entry\n     *  - target filename == entry\n     *    found file\n     *  - target filename < all entries\n     *    file not found\n     *  - target filename > all entries\n     *    proceed to step 2 using final entry\n     *  - target filename between two searched entries\n     *    proceed to step 2\n     */\n    qr_size     = EndGetI32(&chunk[pmgl_QuickRefSize]);\n    start       = &chunk[chm->chunk_size - 2];\n    end         = &chunk[chm->chunk_size - qr_size];\n    num_entries = EndGetI16(start);\n    qr_density  = 1 + (1 << chm->density);\n    qr_entries  = (num_entries + qr_density-1) / qr_density;\n\n    if (num_entries == 0) {\n\tD((\"chunk has no entries\"))\n\treturn -1;\n    }\n\n    if (qr_size > chm->chunk_size) {\n\tD((\"quickref size > chunk size\"))\n\treturn -1;\n    }\n\n    *result_end = end;\n\n    if (((int)qr_entries * 2) > (start - end)) {\n\tD((\"WARNING; more quickrefs than quickref space\"))\n\tqr_entries = 0; /* but we can live with it */\n    }\n\n    if (qr_entries > 0) {\n\tL = 0;\n\tR = qr_entries - 1;\n\tdo {\n\t    /* pick new midpoint */\n\t    M = (L + R) >> 1;\n\n\t    /* compare filename with entry QR points to */\n\t    p = &chunk[entries_off + (M ? EndGetI16(start - (M << 1)) : 0)];\n\t    READ_ENCINT(name_len);\n\t    if (name_len > (unsigned int) (end - p)) goto chunk_end;\n\t    cmp = compare(filename, (char *)p, fname_len, name_len);\n\n\t    if (cmp == 0) break;\n\t    else if (cmp < 0) { if (M) R = M - 1; else return 0; }\n\t    else if (cmp > 0) L = M + 1;\n\t} while (L <= R);\n\tM = (L + R) >> 1;\n\n\tif (cmp == 0) {\n\t    /* exact match! */\n\t    p += name_len;\n\t    *result = p;\n\t    return 1;\n\t}\n\n\t/* otherwise, read the group of entries for QR entry M */\n\tp = &chunk[entries_off + (M ? EndGetI16(start - (M << 1)) : 0)];\n\tnum_entries -= (M * qr_density);\n\tif (num_entries > qr_density) num_entries = qr_density;\n    }\n    else {\n\tp = &chunk[entries_off];\n    }\n\n    /* Step 2: linear search through the set of entries reached in step 1.\n     * - filename == any entry\n     *   found entry\n     * - filename < all entries (PMGI) or any entry (PMGL)\n     *   entry not found, stop now\n     * - filename > all entries\n     *   entry not found (PMGL) / maybe found (PMGI)\n     * - \n     */\n    *result = NULL;\n    while (num_entries-- > 0) {\n\tREAD_ENCINT(name_len);\n\tif (name_len > (unsigned int) (end - p)) goto chunk_end;\n\tcmp = compare(filename, (char *)p, fname_len, name_len);\n\tp += name_len;\n\n\tif (cmp == 0) {\n\t    /* entry found */\n\t    *result = p;\n\t    return 1;\n\t}\n\n\tif (cmp < 0) {\n\t    /* entry not found (PMGL) / maybe found (PMGI) */\n\t    break;\n\t}\n\n\t/* read and ignore the rest of this entry */\n\tif (is_pmgl) {\n\t    READ_ENCINT(R); /* skip section */\n\t    READ_ENCINT(R); /* skip offset */\n\t    READ_ENCINT(R); /* skip length */\n\t}\n\telse {\n\t    *result = p; /* store potential final result */\n\t    READ_ENCINT(R); /* skip chunk number */\n\t}\n    }\n\n     /* PMGL? not found. PMGI? maybe found */\n     return (is_pmgl) ? 0 : (*result ? 1 : 0);\n\n chunk_end:\n    D((\"reached end of chunk data while searching\"))\n    return -1;\n}\n\n#if HAVE_TOWLOWER\n# if HAVE_WCTYPE_H\n#  include <wctype.h>\n# endif\n# define TOLOWER(x) towlower(x)\n#elif HAVE_TOLOWER\n# if HAVE_CTYPE_H\n#  include <ctype.h>\n# endif\n# define TOLOWER(x) tolower(x)\n#else\n# define TOLOWER(x) (((x)<0||(x)>255)?(x):mspack_tolower_map[(x)])\n/* Map of char -> lowercase char for the first 256 chars. Generated with:\n * LC_CTYPE=en_GB.utf-8 perl -Mlocale -le 'print map{ord(lc chr).\",\"} 0..255'\n */\nstatic const unsigned char mspack_tolower_map[256] = {\n    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,\n    53,54,55,56,57,58,59,60,61,62,63,64,97,98,99,100,101,102,103,104,105,106,\n    107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,91,92,93,94,\n    95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,\n    115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,\n    134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,\n    153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,\n    172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,\n    191,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,\n    242,243,244,245,246,215,248,249,250,251,252,253,254,223,224,225,226,227,228,\n    229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,\n    248,249,250,251,252,253,254,255\n};\n#endif\n\n/* decodes a UTF-8 character from s[] into c. Will not read past e. \n * doesn't test that extension bytes are %10xxxxxx.\n * allows some overlong encodings.\n */\n#define GET_UTF8_CHAR(s, e, c) do {\t\t\t\t\t\\\n    unsigned char x = *s++;\t\t\t\t\t\t\\\n    if (x < 0x80) c = x;\t\t\t\t\t\t\\\n    else if (x >= 0xC2 && x < 0xE0 && s < e) {\t\t\t\t\\\n\tc = (x & 0x1F) << 6 | (*s++ & 0x3F);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    else if (x >= 0xE0 && x < 0xF0 && s+1 < e) {\t\t\t\\\n\tc = (x & 0x0F) << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);\t\\\n\ts += 2;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    else if (x >= 0xF0 && x <= 0xF5 && s+2 < e) {\t\t\t\\\n\tc = (x & 0x07) << 18 | (s[0] & 0x3F) << 12 |\t\t\t\\\n\t    (s[1] & 0x3F) << 6 | (s[2] & 0x3F);\t\t\t\t\\\n\tif (c > 0x10FFFF) c = 0xFFFD;\t\t\t\t\t\\\n\ts += 3;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    else c = 0xFFFD;\t\t\t\t\t\t\t\\\n} while (0)\n\n/* case-insensitively compares two UTF8 encoded strings. String length for\n * both strings must be provided, null bytes are not terminators */\nstatic inline int compare(const char *s1, const char *s2, int l1, int l2) {\n    register const unsigned char *p1 = (const unsigned char *) s1;\n    register const unsigned char *p2 = (const unsigned char *) s2;\n    register const unsigned char *e1 = p1 + l1, *e2 = p2 + l2;\n    int c1, c2;\n\n    while (p1 < e1 && p2 < e2) {\n\tGET_UTF8_CHAR(p1, e1, c1);\n\tGET_UTF8_CHAR(p2, e2, c2);\n\tif (c1 == c2) continue;\n\tc1 = TOLOWER(c1);\n\tc2 = TOLOWER(c2);\n\tif (c1 != c2) return c1 - c2;\n    }\n    return l1 - l2;\n}\n\n\n/***************************************\n * CHMD_EXTRACT\n ***************************************\n * extracts a file from a CHM helpfile\n */\nstatic int chmd_extract(struct mschm_decompressor *base,\n\t\t\tstruct mschmd_file *file, const char *filename)\n{\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  struct mspack_system *sys;\n  struct mschmd_header *chm;\n  struct mspack_file *fh;\n  off_t bytes;\n\n  if (!self) return MSPACK_ERR_ARGS;\n  if (!file || !file->section) return self->error = MSPACK_ERR_ARGS;\n  sys = self->system;\n  chm = file->section->chm;\n\n  /* create decompression state if it doesn't exist */\n  if (!self->d) {\n    self->d = (struct mschmd_decompress_state *) sys->alloc(sys, sizeof(struct mschmd_decompress_state));\n    if (!self->d) return self->error = MSPACK_ERR_NOMEMORY;\n    self->d->chm       = chm;\n    self->d->offset    = 0;\n    self->d->state     = NULL;\n    self->d->sys       = *sys;\n    self->d->sys.write = &chmd_sys_write;\n    self->d->infh      = NULL;\n    self->d->outfh     = NULL;\n  }\n\n  /* open input chm file if not open, or the open one is a different chm */\n  if (!self->d->infh || (self->d->chm != chm)) {\n    if (self->d->infh)  sys->close(self->d->infh);\n    if (self->d->state) lzxd_free(self->d->state);\n    self->d->chm    = chm;\n    self->d->offset = 0;\n    self->d->state  = NULL;\n    self->d->infh   = sys->open(sys, chm->filename, MSPACK_SYS_OPEN_READ);\n    if (!self->d->infh) return self->error = MSPACK_ERR_OPEN;\n  }\n\n  /* open file for output */\n  if (!(fh = sys->open(sys, filename, MSPACK_SYS_OPEN_WRITE))) {\n    return self->error = MSPACK_ERR_OPEN;\n  }\n\n  /* if file is empty, simply creating it is enough */\n  if (!file->length) {\n    sys->close(fh);\n    return self->error = MSPACK_ERR_OK;\n  }\n\n  self->error = MSPACK_ERR_OK;\n\n  switch (file->section->id) {\n  case 0: /* Uncompressed section file */\n    /* simple seek + copy */\n    if (sys->seek(self->d->infh, file->section->chm->sec0.offset\n\t\t  + file->offset, MSPACK_SYS_SEEK_START))\n    {\n      self->error = MSPACK_ERR_SEEK;\n    }\n    else {\n      unsigned char buf[512];\n      off_t length = file->length;\n      while (length > 0) {\n\tint run = sizeof(buf);\n\tif ((off_t)run > length) run = (int)length;\n\tif (sys->read(self->d->infh, &buf[0], run) != run) {\n\t  self->error = MSPACK_ERR_READ;\n\t  break;\n\t}\n\tif (sys->write(fh, &buf[0], run) != run) {\n\t  self->error = MSPACK_ERR_WRITE;\n\t  break;\n\t}\n\tlength -= run;\n      }\n    }\n    break;\n\n  case 1: /* MSCompressed section file */\n    /* (re)initialise compression state if we it is not yet initialised,\n     * or we have advanced too far and have to backtrack\n     */\n    if (!self->d->state || (file->offset < self->d->offset)) {\n      if (self->d->state) {\n\tlzxd_free(self->d->state);\n\tself->d->state = NULL;\n      }\n      if (chmd_init_decomp(self, file)) break;\n    }\n\n    /* seek to input data */\n    if (sys->seek(self->d->infh, self->d->inoffset, MSPACK_SYS_SEEK_START)) {\n      self->error = MSPACK_ERR_SEEK;\n      break;\n    }\n\n    /* get to correct offset. */\n    self->d->outfh = NULL;\n    if ((bytes = file->offset - self->d->offset)) {\n      self->error = lzxd_decompress(self->d->state, bytes);\n    }\n\n    /* if getting to the correct offset was error free, unpack file */\n    if (!self->error) {\n      self->d->outfh = fh;\n      self->error = lzxd_decompress(self->d->state, file->length);\n    }\n\n    /* save offset in input source stream, in case there is a section 0\n     * file between now and the next section 1 file extracted */\n    self->d->inoffset = sys->tell(self->d->infh);\n\n    /* if an LZX error occured, the LZX decompressor is now useless */\n    if (self->error) {\n      if (self->d->state) lzxd_free(self->d->state);\n      self->d->state = NULL;\n    }\n    break;\n  }\n\n  sys->close(fh);\n  return self->error;\n}\n\n/***************************************\n * CHMD_SYS_WRITE\n ***************************************\n * chmd_sys_write is the internal writer function which the decompressor\n * uses. If either writes data to disk (self->d->outfh) with the real\n * sys->write() function, or does nothing with the data when\n * self->d->outfh == NULL. advances self->d->offset.\n */\nstatic int chmd_sys_write(struct mspack_file *file, void *buffer, int bytes) {\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) file;\n  self->d->offset += bytes;\n  if (self->d->outfh) {\n    return self->system->write(self->d->outfh, buffer, bytes);\n  }\n  return bytes;\n}\n\n/***************************************\n * CHMD_INIT_DECOMP\n ***************************************\n * Initialises the LZX decompressor to decompress the compressed stream,\n * from the nearest reset offset and length that is needed for the given\n * file.\n */\nstatic int chmd_init_decomp(struct mschm_decompressor_p *self,\n\t\t\t    struct mschmd_file *file)\n{\n  int window_size, window_bits, reset_interval, entry, err;\n  struct mspack_system *sys = self->system;\n  struct mschmd_sec_mscompressed *sec;\n  unsigned char *data;\n  off_t length, offset;\n\n  sec = (struct mschmd_sec_mscompressed *) file->section;\n\n  /* ensure we have a mscompressed content section */\n  err = find_sys_file(self, sec, &sec->content, content_name);\n  if (err) return self->error = err;\n\n  /* ensure we have a ControlData file */\n  err = find_sys_file(self, sec, &sec->control, control_name);\n  if (err) return self->error = err;\n\n  /* read ControlData */\n  if (sec->control->length < lzxcd_SIZEOF) {\n    D((\"ControlData file is too short\"))\n    return self->error = MSPACK_ERR_DATAFORMAT;\n  }\n  if (!(data = read_sys_file(self, sec->control))) {\n    D((\"can't read mscompressed control data file\"))\n    return self->error;\n  }\n\n  /* check LZXC signature */\n  if (EndGetI32(&data[lzxcd_Signature]) != 0x43585A4C) {\n    sys->free(data);\n    return self->error = MSPACK_ERR_SIGNATURE;\n  }\n\n  /* read reset_interval and window_size and validate version number */\n  switch (EndGetI32(&data[lzxcd_Version])) {\n  case 1:\n    reset_interval = EndGetI32(&data[lzxcd_ResetInterval]);\n    window_size    = EndGetI32(&data[lzxcd_WindowSize]);\n    break;\n  case 2:\n    reset_interval = EndGetI32(&data[lzxcd_ResetInterval]) * LZX_FRAME_SIZE;\n    window_size    = EndGetI32(&data[lzxcd_WindowSize])    * LZX_FRAME_SIZE;\n    break;\n  default:\n    D((\"bad controldata version\"))\n    sys->free(data);\n    return self->error = MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* free ControlData */\n  sys->free(data);\n\n  /* find window_bits from window_size */\n  switch (window_size) {\n  case 0x008000: window_bits = 15; break;\n  case 0x010000: window_bits = 16; break;\n  case 0x020000: window_bits = 17; break;\n  case 0x040000: window_bits = 18; break;\n  case 0x080000: window_bits = 19; break;\n  case 0x100000: window_bits = 20; break;\n  case 0x200000: window_bits = 21; break;\n  default:\n    D((\"bad controldata window size\"))\n    return self->error = MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* validate reset_interval */\n  if (reset_interval == 0 || reset_interval % LZX_FRAME_SIZE) {\n    D((\"bad controldata reset interval\"))\n    return self->error = MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* which reset table entry would we like? */\n  entry = file->offset / reset_interval;\n  /* convert from reset interval multiple (usually 64k) to 32k frames */\n  entry *= reset_interval / LZX_FRAME_SIZE;\n\n  /* read the reset table entry */\n  if (read_reset_table(self, sec, entry, &length, &offset)) {\n    /* the uncompressed length given in the reset table is dishonest.\n     * the uncompressed data is always padded out from the given\n     * uncompressed length up to the next reset interval */\n    length += reset_interval - 1;\n    length &= -reset_interval;\n  }\n  else {\n    /* if we can't read the reset table entry, just start from\n     * the beginning. Use spaninfo to get the uncompressed length */\n    entry = 0;\n    offset = 0;\n    err = read_spaninfo(self, sec, &length);\n  }\n  if (err) return self->error = err;\n\n  /* get offset of compressed data stream:\n   * = offset of uncompressed section from start of file\n   * + offset of compressed stream from start of uncompressed section\n   * + offset of chosen reset interval from start of compressed stream */\n  self->d->inoffset = file->section->chm->sec0.offset + sec->content->offset + offset;\n\n  /* set start offset and overall remaining stream length */\n  self->d->offset = entry * LZX_FRAME_SIZE;\n  length -= self->d->offset;\n\n  /* initialise LZX stream */\n  self->d->state = lzxd_init(&self->d->sys, self->d->infh,\n\t\t\t     (struct mspack_file *) self, window_bits,\n\t\t\t     reset_interval / LZX_FRAME_SIZE,\n\t\t\t     4096, length, 0);\n  if (!self->d->state) self->error = MSPACK_ERR_NOMEMORY;\n  return self->error;\n}\n\n/***************************************\n * READ_RESET_TABLE\n ***************************************\n * Reads one entry out of the reset table. Also reads the uncompressed\n * data length. Writes these to offset_ptr and length_ptr respectively.\n * Returns non-zero for success, zero for failure.\n */\nstatic int read_reset_table(struct mschm_decompressor_p *self,\n\t\t\t    struct mschmd_sec_mscompressed *sec,\n\t\t\t    int entry, off_t *length_ptr, off_t *offset_ptr)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *data;\n    unsigned int pos, entrysize;\n\n    /* do we have a ResetTable file? */\n    int err = find_sys_file(self, sec, &sec->rtable, rtable_name);\n    if (err) return 0;\n\n    /* read ResetTable file */\n    if (sec->rtable->length < lzxrt_headerSIZEOF) {\n\tD((\"ResetTable file is too short\"))\n\treturn 0;\n    }\n    if (!(data = read_sys_file(self, sec->rtable))) {\n\tD((\"can't read reset table\"))\n\treturn 0;\n    }\n\n    /* check sanity of reset table */\n    if (EndGetI32(&data[lzxrt_FrameLen]) != LZX_FRAME_SIZE) {\n\tD((\"bad reset table frame length\"))\n\tsys->free(data);\n\treturn 0;\n    }\n\n    /* get the uncompressed length of the LZX stream */\n    if (read_off64(length_ptr, &data[lzxrt_UncompLen], sys, self->d->infh)) {\n\tsys->free(data);\n\treturn 0;\n    }\n\n    entrysize = EndGetI32(&data[lzxrt_EntrySize]);\n    pos = EndGetI32(&data[lzxrt_TableOffset]) + (entry * entrysize);\n\n    /* ensure reset table entry for this offset exists */\n    if (entry < EndGetI32(&data[lzxrt_NumEntries]) &&\n\tpos <= (sec->rtable->length - entrysize))\n    {\n\tswitch (entrysize) {\n\tcase 4:\n\t    *offset_ptr = EndGetI32(&data[pos]);\n\t    err = 0;\n\t    break;\n\tcase 8:\n\t    err = read_off64(offset_ptr, &data[pos], sys, self->d->infh);\n\t    break;\n\tdefault:\n\t    D((\"reset table entry size neither 4 nor 8\"))\n\t    err = 1;\n\t    break;\n\t}\n    }\n    else {\n\tD((\"bad reset interval\"))\n\terr = 1;\n    }\n\n    /* free the reset table */\n    sys->free(data);\n\n    /* return success */\n    return (err == 0);\n}\n\n/***************************************\n * READ_SPANINFO\n ***************************************\n * Reads the uncompressed data length from the spaninfo file.\n * Returns zero for success or a non-zero error code for failure.\n */\nstatic int read_spaninfo(struct mschm_decompressor_p *self,\n\t\t\t struct mschmd_sec_mscompressed *sec,\n\t\t\t off_t *length_ptr)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *data;\n    \n    /* find SpanInfo file */\n    int err = find_sys_file(self, sec, &sec->spaninfo, spaninfo_name);\n    if (err) return MSPACK_ERR_DATAFORMAT;\n\n    /* check it's large enough */\n    if (sec->spaninfo->length != 8) {\n\tD((\"SpanInfo file is wrong size\"))\n\treturn MSPACK_ERR_DATAFORMAT;\n    }\n\n    /* read the SpanInfo file */\n    if (!(data = read_sys_file(self, sec->spaninfo))) {\n\tD((\"can't read SpanInfo file\"))\n\treturn self->error;\n    }\n\n    /* get the uncompressed length of the LZX stream */\n    err = read_off64(length_ptr, data, sys, self->d->infh);\n    sys->free(data);\n    if (err) return MSPACK_ERR_DATAFORMAT;\n\n    if (*length_ptr <= 0) {\n        D((\"output length is invalid\"))\n        return MSPACK_ERR_DATAFORMAT;\n    }\n\n    return MSPACK_ERR_OK;\n}\n\n/***************************************\n * FIND_SYS_FILE\n ***************************************\n * Uses chmd_fast_find to locate a system file, and fills out that system\n * file's entry and links it into the list of system files. Returns zero\n * for success, non-zero for both failure and the file not existing.\n */\nstatic int find_sys_file(struct mschm_decompressor_p *self,\n\t\t\t struct mschmd_sec_mscompressed *sec,\n\t\t\t struct mschmd_file **f_ptr, const char *name)\n{\n    struct mspack_system *sys = self->system;\n    struct mschmd_file result;\n\n    /* already loaded */\n    if (*f_ptr) return MSPACK_ERR_OK;\n\n    /* try using fast_find to find the file - return DATAFORMAT error if\n     * it fails, or successfully doesn't find the file */\n    if (chmd_fast_find((struct mschm_decompressor *) self, sec->base.chm,\n\t\t       name, &result, (int)sizeof(result)) || !result.section)\n    {\n\treturn MSPACK_ERR_DATAFORMAT;\n    }\n\n    if (!(*f_ptr = (struct mschmd_file *) sys->alloc(sys, sizeof(result)))) {\n\treturn MSPACK_ERR_NOMEMORY;\n    }\n\n    /* copy result */\n    *(*f_ptr) = result;\n    (*f_ptr)->filename = (char *) name;\n\n    /* link file into sysfiles list */\n    (*f_ptr)->next = sec->base.chm->sysfiles;\n    sec->base.chm->sysfiles = *f_ptr;\n    return MSPACK_ERR_OK;\n}\n\n/***************************************\n * READ_SYS_FILE\n ***************************************\n * Allocates memory for a section 0 (uncompressed) file and reads it into\n * memory.\n */\nstatic unsigned char *read_sys_file(struct mschm_decompressor_p *self,\n\t\t\t\t    struct mschmd_file *file)\n{\n  struct mspack_system *sys = self->system;\n  unsigned char *data = NULL;\n  int len;\n\n  if (!file || !file->section || (file->section->id != 0)) {\n    self->error = MSPACK_ERR_DATAFORMAT;\n    return NULL;\n  }\n\n  len = (int) file->length;\n\n  if (!(data = (unsigned char *) sys->alloc(sys, (size_t) len))) {\n    self->error = MSPACK_ERR_NOMEMORY;\n    return NULL;\n  }\n  if (sys->seek(self->d->infh, file->section->chm->sec0.offset\n\t\t+ file->offset, MSPACK_SYS_SEEK_START))\n  {\n    self->error = MSPACK_ERR_SEEK;\n    sys->free(data);\n    return NULL;\n  }\n  if (sys->read(self->d->infh, data, len) != len) {\n    self->error = MSPACK_ERR_READ;\n    sys->free(data);\n    return NULL;\n  }\n  return data;\n}\n\n/***************************************\n * CHMD_ERROR\n ***************************************\n * returns the last error that occurred\n */\nstatic int chmd_error(struct mschm_decompressor *base) {\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  return (self) ? self->error : MSPACK_ERR_ARGS;\n}\n\n/***************************************\n * READ_OFF64\n ***************************************\n * Reads a 64-bit signed integer from memory in Intel byte order.\n * If running on a system with a 64-bit off_t, this is simply done.\n * If running on a system with a 32-bit off_t, offsets up to 0x7FFFFFFF\n * are accepted, offsets beyond that cause an error message.\n */\nstatic int read_off64(off_t *var, unsigned char *mem,\n\t\t      struct mspack_system *sys, struct mspack_file *fh)\n{\n#ifdef LARGEFILE_SUPPORT\n    *var = EndGetI64(mem);\n#else\n    *var = EndGetI32(mem);\n    if ((*var & 0x80000000) || EndGetI32(mem+4)) {\n\tsys->message(fh, (char *)largefile_msg);\n\treturn 1;\n    }\n#endif\n    return 0;\n}\n"], "fixing_code": ["2018-04-26  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* read_chunk(): the test that chunk numbers are in bounds was off\n\tby one, so read_chunk() returned a pointer taken from outside\n\tallocated memory that usually crashes libmspack when accessed.\n\tThanks to Hanno B\u00f6ck for finding the issue and providing a sample.\n\n\t* chmd_read_headers(): reject files with blank filenames. Thanks\n\tagain to Hanno B\u00f6ck for finding the issue and providing a sample file.\n\n2018-02-06  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* chmd.c: fixed an off-by-one error in the TOLOWER() macro, reported\n\tby Dmitry Glavatskikh. Thanks Dmitry!\n\n2017-11-26  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* kwajd_read_headers(): fix up the logic of reading the filename and\n\textension headers to avoid a one or two byte overwrite. Thanks to\n\tJakub Wilk for finding the issue.\n\n\t* test/kwajd_test.c: add tests for KWAJ filename.ext handling\n\n2017-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* test/cabd_test.c: update the short string tests to expect not only\n\tMSPACK_ERR_DATAFORMAT but also MSPACK_ERR_READ, because of the recent\n\tchange to cabd_read_string(). Thanks to maitreyee43 for spotting this.\n\n\t* test/msdecompile_md5: update the setup instructions for this script,\n\tand also change the script so it works with current Wine. Again, thanks\n\tto maitreyee43 for trying to use it and finding it not working.\n\n2017-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* src/chmextract.c: support MinGW one-arg mkdir(). Thanks to AntumDeluge\n\tfor reporting this.\n\n2017-08-13  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* read_spaninfo(): a CHM file can have no ResetTable and have a\n\tnegative length in SpanInfo, which then feeds a negative output length\n\tto lzxd_init(), which then sets frame_size to a value of your choosing,\n\tthe lower 32 bits of output length, larger than LZX_FRAME_SIZE. If the\n\tfirst LZX block is uncompressed, this writes data beyond the end of the\n\twindow. This issue was raised by ClamAV as CVE-2017-6419.  Thanks to\n\tSebastian Andrzej Siewior for finding this by chance!\n\n\t* lzxd_init(), lzxd_set_output_length(), mszipd_init(): due to the issue\n\tmentioned above, these functions now reject negative lengths\n\n2017-08-05  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* cabd_read_string(): add missing error check on result of read().\n\tIf an mspack_system implementation returns an error, it's interpreted\n\tas a huge positive integer, which leads to reading past the end of the\n\tstack-based buffer. Thanks to Sebastian Andrzej Siewior for explaining\n\tthe problem. This issue was raised by ClamAV as CVE-2017-11423\n\n2016-04-20  Stuart Caie <kyzer@cabextract.org.uk>\n\n\t* configure.ac: change my email address to kyzer@cabextract.org.uk\n\n2015-05-10  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_read_string(): correct rejection of empty strings. Thanks to\n\tHanno B\u00f6ck for finding the issue and providing a sample file.\n\n2015-05-10  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: Add subdir-objects option as suggested by autoreconf.\n\n\t* configure.ac: Add AM_PROG_AR as suggested by autoreconf.\n\n2015-01-29  Stuart Caie <kyzer@4u.net>\n\n\t* system.h: if C99 inttypes.h exists, use its PRI{d,u}{32,64} macros.\n\tThanks to Johnathan Kollasch for the suggestion.\n\n2015-01-18  Stuart Caie <kyzer@4u.net>\n\n\t* lzxd_decompress(): the byte-alignment code for reading uncompressed\n\tblock headers presumed it could wind i_ptr back 2 bytes, but this\n\thasn't been true since READ_BYTES was allowed to read bytes straddling\n\ttwo blocks, leaving just 1 byte in the read buffer. Thanks to Jakub\n\tWilk for finding the issue and providing a sample file.\n\n\t* inflate(): off-by-one error. Distance codes are 0-29, not 0-30.\n\tThanks to Jakub Wilk again.\n\n\t* chmd_read_headers(), search_chunk(): another fix for checking pointer\n\tis within a chunk, thanks again to Jakub Wilk.\n\n2015-01-17  Stuart Caie <kyzer@4u.net>\n\n\t* GET_UTF8_CHAR(): Remove 5/6-byte encoding support and check decoded\n\tchars are no more than U+10FFFF.\n\n\t* chmd_init_decomp(): A reset interval of 0 is invalid. Thanks to\n\tJakub Wilk for finding the issue and providing a sample and patch.\n\n2015-01-15  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_read_headers(): add a bounds check to prevent over-reading data,\n\twhich caused a segfault on 32-bit architectures. Thanks to Jakub Wilk.\n\n\t* search_chunk(): change the order of pointer arithmetic operations to\n\tavoid overflow during bounds checks, which lead to segfaults on 32-bit\n\tarchitectures. Again, thanks to Jakub Wilk for finding this issue,\n\tproviding sample files and a patch.\n\n2015-01-08  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_extract(): No longer uses broken state data if extracting from\n\tfolder 1, 2, 1 and setting up folder 2 fails. This prevents a jump to\n\tnull and thus segfault. Thanks to Jakub Wilk again.\n\n\t* cabd_read_string: reject empty strings. They are not found in any\n\tvalid CAB files. Thanks to Hanno B\u00f6ck for sending me an example.\n\n2015-01-05  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_can_merge_folders(): disallow folder merging if the combined\n\tfolder would have more than 65535 data blocks.\n\n\t* cabd_decompress(): disallow files if their offset, length or\n\toffset+length is more than 65535*32768, the maximum size of any\n\tfolder. Thanks to Jakub Wilk for identifying the problem and providing\n\ta sample file.\n\n2014-04-20  Stuart Caie <kyzer@4u.net>\n\n\t* readhuff.h: fixed the table overflow check, which allowed one more\n\tcode after capacity had been reached, resulting in a read of\n\tuninitialized data inside the decoding table. Thanks to Denis Kroshin\n\tfor identifying the problem and providing a sample file.\n\n2013-05-27  Stuart Caie <kyzer@4u.net>\n\n\t* test/oabx.c: added new example command for unpacking OAB files.\n\n2013-05-17  Stuart Caie <kyzer@4u.net>\n\n\t* mspack.h: Support for decompressing a new file format, the Exchange\n\tOffline Address Book (OAB). Thanks to David Woodhouse for writing\n\tthe implementation. I've bumped the version to 0.4alpha in celebration.\n\n2012-04-15  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_read_headers(): More thorough validation of CHM header values.\n\tThanks to Sergei Trofimovich for finding sample files.\n\n\t* read_reset_table(): Better test for overflow. Thanks again to\n\tSergei Trofimovich for generating a good example.\n\n\t* test/chminfo.c: this test program reads the reset table by itself\n\tand was also susceptible to the same overflow problems.\n\n2012-03-16  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am, configure.ac: make the GCC warning flags conditional\n\ton using the GCC compiler. Thanks to Dagobert Michelsen for letting\n\tme know.\n\n2011-11-25  Stuart Caie <kyzer@4u.net>\n\n\t* lzxd_decompress(): Prevent matches that go beyond the start\n\tof the LZX stream. Thanks to Sergei Trofimovich for testing\n\twith valgrind and finding a corrupt sample file that exercises\n\tthis scenario.\n\n2011-11-23  Stuart Caie <kyzer@4u.net>\n\n\t* chmd_fast_find(): add a simple check against infinite PMGL\n\tloops. Thanks to Sergei Trofimovich for finding sample files.\n\tMulti-step PMGL/PMGI infinite loops remain possible.\n\n2011-06-17  Stuart Caie <kyzer@4u.net>\n\n\t* read_reset_table(): wasn't reading the right offset for getting\n\tthe LZX uncompressed length. Thanks to Sergei Trofimovich for\n\tfinding the bug.\n\n2011-05-31  Stuart Caie <kyzer@4u.net>\n\n\t* kwajd.c, mszipd.c: KWAJ type 4 files (MSZIP) are now supported.\n\tThanks to Clive Turvey for sending me the format details.\n\n\t* doc/szdd_kwaj_format.html: Updated documentation to cover\n\tKWAJ's MSZIP compression.\n\n2011-05-11  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_find(): rethought how large vs small file support is\n\thandled, as users were getting \"library not compiled to support\n\tlarge files\" message on some small files. Now checks for actual\n\toff_t overflow, rather than trying to preempt it.\n\n2011-05-10:  Stuart Caie <kyzer@4u.net>\n\n\t* chmd.c: implemented fast_find()\n\n\t* test/chmx.c: removed the multiple extraction orders, now it just\n\textracts in the fastest order\n\n\t* test/chmd_order.c: new program added to test that different\n\textraction orders don't affect the results of extraction\n\n\t* test/chmd_find.c: new program to test that fast_find() works.\n\tEither supply your own filename to find, or it will try finding\n\tevery file in the CHM.\n\n\t* configure.ac: because CHM fast find requires case-insensitive\n\tcomparisons, tolower() or towlower() are used where possible.\n\tThese functions and their headers are checked for.\n\n\t* mspack.h: exposed struct mschmd_sec_mscompressed's spaninfo\n\tand struct mschmd_header's first_pmgl, last_pmgl and chunk_cache\n\tto the world. Check that the CHM decoder version is v2 or higher\n\tbefore using them.\n\n\t* system.c: set CHM decoder version to v2\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: Made C++ compilers much happier with libmspack.\n\tChanged char * to const char * where possible.\n\n\t* mspack.h: Changed user-supplied char * to const char *.\n\tUnless you've written your own mspack_system implementation,\n\tyou will likely be unaffected.\n\tIf you have written your own mspack_system implementation:\n\t1: change open()    so it takes a const char *filename\n\t2: change message() so it takes a const char *format\n\tIf you cast your function into the mspack_system struct,\n\tyou can change the cast instead of the function.\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: changed CFLAGS from \"-Wsign-compare -Wconversion\n\t-pedantic\" to \"-W -Wno-unused\". This enables more warnings, and\n\tdisables these specific warnings which are now a hinderance.\n\n2011-04-27:  Stuart Caie <kyzer@4u.net>\n\n\t* test/cabrip.c, test/chminfo.c: used macros from system.h for\n\tprinting offsets and reading 64-bit values, rather than\n\treinvent the wheel.\n\n\t* cabd_can_merge_folders(): declare variables at the start of\n\ta block so older C compilers won't choke.\n\n\t* cabd_find(): avoid compiler complaints about non-initialised\n\tvariables. We know they'll get initialised before use, but the\n\tcompiler can't reverse a state machine to draw the same conclusion.\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* configure.ac, mspack/system.h: Added a configure test to get\n\tthe size of off_t. If off_t is 8 bytes or more, we presume this\n\tsystem has large file support. This fixes LFS detection for Fedora\n\tx86_64 and Darwin/Mac OS X, neither of which declare FILESIZEBITS in\n\t<limits.h>. It's not against the POSIX standard to do this: \"A\n\tdefinition of [FILESIZEBITS] shall be omitted from the <limits.h>\n\theader on specific implementations where the corresponding value is\n\tequal to or greater than the stated minimum, but where the value can\n\tvary depending on the file to which it is applied.\"\n\t(http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html)\n\tThanks to Edward Sheldrake for the patch.\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* chmd.c: all 64-bit integer reads are now consolidated into\n\tthe read_off64() function\n\n\t* chmd_read_headers(): this function has been made resilient\n\tagainst accessing memory past the end of a chunk. Thanks to\n\tSergei Trofimovich for sending me examples and analysis.\n\n\t* chmd_init_decomp(): this function now reads the SpanInfo file\n\tif the ResetTable file isn't available, it also checks that each\n\tsystem file it needs is large enough before accessing it, and\n\tsome of its code has been split into several new functions:\n\tfind_sys_file(), read_reset_table() and read_spaninfo()\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* mspack.h, chmd.c: now reads the SpanInfo system file if the\n\tResetTable file isn't available. This adds a new spaninfo pointer\n\tinto struct mschmd_sec_mscompressed\n\n2011-04-26:  Stuart Caie <kyzer@4u.net>\n\n\t* test/chminfo.c: more sanity checks for corrupted CHM files where\n\tentries go past the end of a PMGL/PMGI chunk, thanks to\n\tSergei Trofimovich for sending me examples and analysis.\n\n2011-04-25:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_merge():  Drew D'Addesio showed me spanning cabinets which\n\tdon't have all the CFFILE entries they should, but otherwise have\n\tall necessary data for extraction. Changed the merging folders\n\ttest to be less strict; if folders don't exactly match, warn which\n\tfiles are missing, but allow merging if at least one necessary\n\tfile is present.\n\n2010-09-24:  Stuart Caie <kyzer@4u.net>\n\n\t* readhuff.h: Don't let build_decode_table() allow empty trees.\n\tIt's meant to be special case just for the LZX length tree, so\n\tmove that logic out to the LZX code. Thanks to Danny Kroshin for\n\tdiscovering the bug.\n\n\t* lzxd.c: Allow empty length trees, but not other trees. If\n\tthe length tree is empty, fail if asked to decode a length symbol.\n\tAgain, thanks to Danny Kroshin for discovering the bug.\n\n2010-09-20:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: Set EXTRA_DIST so it doesn't include .svn\n\tdirectories in the distribution, but does include docs.\n\n2010-09-20:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am, configure.ac: Use modern auto* practises; turn on\n\tautomake silent rules where possible, use \"m4\" directory for libtool\n\tmacros, use LT_INIT instead of AC_PROG_LIBTOOL and use AM_CPPFLAGS\n\tinstead of INCLUDES. Thanks to Sergei Trofimovich for the patch.\n\n2010-09-15:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: Made the code compile with C++\n\t- Renamed all 'this' variables/parameters to 'self'\n\t- Added casts to all memory allocations.\n\t- Added extern \"C\" to header files with extern declarations.\n\t- Made system.c include system.h.\n\t- Changed the K&R-style headers to ANSI-style headers in md5.c\n\n2010-08-04:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: removed unnecessary <unistd.h> include\n\n2010-07-19:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd_md5.c, chmd_md5.c: Replace writing files to disk then\n\tMD5summing them, with an MD5summer built into mspack_system.\n\tMuch, much faster results.\n\n\t* qtmd_decompress(): Robert Riebisch pointed out a Quantum\n\tdata integrity check that could never be tripped, because\n\tframe_todo is unsigned, so it will never be decremented\n\tbelow zero. Replaced the check with one that assumes that\n\tdecrementing past zero wraps frame_todo round to a number\n\tmore than its maximum value (QTM_FRAME_SIZE).\n\n2010-07-18:  Stuart Caie <kyzer@4u.net>\n\n\t* cabd.c: Special logic to pass cabd_sys_read() errors back\n\tto cabd_extract() wasn't compatible with the decompressor\n\tlogic of returning the same error repeatedly once unpacking\n\tfails. This meant that if decompressing failed because of\n\ta read error, then the next file in the same folder would\n\tcome back as \"no error\", but the decompressed wouldn't have\n\teven attempted to decompress the file. Added a new state\n\tvariable, read_error, with the same lifespan as a decompressor,\n\tto pass the underlying reason for MSPACK_ERR_READ errors back.\n\n\t* mszipd.c: improve MS-ZIP recovery by saving all the bytes\n\tdecoded prior to a block failing. This requires remembering\n\thow far we got through the block, so the code has been made\n\tslightly slower (about 0.003 seconds slower per gigabyte\n\tunpacked) by removing the local variable window_posn\n\tand keeping it in the state structure instead.\n\n2010-07-16:  Stuart Caie <kyzer@4u.net>\n\n\t* Makefile.am: strange interactions. When -std=c99 is used,\n\tmy Ubuntu's <stdio.h> (libc6-dev 2.11.1-0ubuntu7.2) does NOT\n\tdefine fseeko() unless _LARGEFILE_SOURCE is also defined. But\n\tconfigure always uses -std=gnu99, not -std=c99, so its test\n\tdetermines _LARGEFILE_SOURCE isn't needed but HAVE_FSEEKO is\n\ttrue. The implicit fseeko definition has a 32-bit rather than\n\t64-bit offset, which means the mode parameter is interpreted\n\tas part of the offset, and the mode is taken from the stack,\n\twhich is generally 0 (SEEK_SET). This breaks all SEEK_CURs.\n\tThe code works fine when -std=c99 is not set, so just remove\n\tit for the time being.\n\n2010-07-12:  Stuart Caie <kyzer@4u.net>\n\n\t* system.c: Reject reading/writing a negative number of bytes.\n\n\t* chmd.c: allow zero-length files to be seen. Previously they were\n\tskipped because they were mistaken for directory entries.\n\n2010-07-08:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd.c: Larry Frieson found an important bug in the Quantum\n\tdecoder. Window wraps flush all unwritten data to disk.\n\tHowever, sometimes less data is needed, which makes\n\tout_bytes negative, which is then passed to write(). Some\n\twrite() implementations treat negative sizes it as a large\n\tpositive integer and segfault trying to write the buffer.\n\n\t* Makefile.am, test/*.c: fixed automake file so that the\n\tpackage passes a \"make distcheck\".\n\n2010-07-07:  Stuart Caie <kyzer@4u.net>\n\n\t* doc/szdd_kwaj_format.html: explain SZDD/KWAJ file format.\n\n\t* lzssd.c: fixed SZDD decompression bugs.\n\n\t* test/chmd_compare: Add scripts for comparing chmd_md5 against\n\tMicrosoft's own code.\n\n\t* test/chmd_md5.c: remove the need to decompress everything\n\ttwice, as this is already in chmx.c if needed.\n\n2010-07-06:  Stuart Caie <kyzer@4u.net>\n\n\t* many files: added SZDD and KWAJ decompression support.\n\n2010-06-18:  Stuart Caie  <kyzer@4u.net>\n\n\t* system.h: expanded the test for 64-bit largefile support so\n\tit also works on 64-bit native operating systems where you\n\tdon't have to define _FILE_OFFSET_BITS.\n\n2010-06-17:  Stuart Caie <kyzer@4u.net>\n\n\t* libmspack.pc.in: Added pkg-config support. Thanks to\n\tPatrice Dumas for the patch.\n\n2010-06-14:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd.c, lzxd.c, mszipd.c: created new headers, readbits.h and\n\treadhuff.h, which bundle up the bit-reading and huffman-reading\n\tcode found in the MSZIP, LZX and Quantum decoders.\n\n2010-06-11:  Stuart Caie <kyzer@4u.net>\n\n\t* qtmd_static_init(): Removed function in favour of static const\n\ttables, same rationale as for lzxd_static_init().\n\n\t* qtmd_read_input(), zipd_read_input(): After testing against my\n\tset of CABs from the wild, I've found both these functions _need_\n\tan extra EOF flag, like lzxd_read_input() has. So I've added\n\tit. This means CABs get decoded properly AND there's no reading\n\tfictional bytes.\n\n2010-06-03:  Stuart Caie  <kyzer@4u.net>\n\n\t* test/cabd_md5.c: updated this so it has better output and\n\tdoesn't need to be in the same directory as the files for multi-\n\tpart sets.\n\n2010-05-20:  Stuart Caie  <kyzer@4u.net>\n\n\t* qtmd_read_input(), zipd_read_input(): Both these functions are\n\tessentially copies of lzxd_read_input(), but that has a feature\n\tthey don't have - an extra EOF flag. So if EOF is\n\tencountered (sys->read() returns 0 bytes), these don't pass on the\n\terror. Their respective bit-reading functions that called them\n\tthen go on to access at least one byte of the input buffer, which\n\tdoesn't exist as sys->read() returned 0. Thanks to Michael\n\tVidrevich for spotting this and providing a test case.\n\n2010-05-20:  Stuart Caie  <kyzer@4u.net>\n\n\t* system.h: It turns out no configure.ac tests are needed to\n\tdecide between __func__ and __FUNCTION__, so I put the standard\n\tone (__func__) back into the D() macro, along with some\n\tspecial-case ifdefs for old versions of GCC.\n\n\t* lzxd_static_init(): Removed function in favour of static const\n\ttables.  Jorge Lodos thinks it causes multithreading problems, I\n\tdisagree. However, there are speed benefits to declaring the\n\ttables as static const.\n\n\t* cabd_init_decomp(): Fixed code which never runs but would write\n\tto a null pointer if it could. Changed it to an assert() as it\n\twill only trip if someone rewrites the internals of cabd.c. Thanks\n\tto Jorge Lodos for finding it.\n\n\t* inflate(): Fixed an off-by-one error: if the LITERAL table\n\temitted code 286, this would read one byte past the end of\n\tlit_extrabits[]. Thanks to Jorge Lodos for finding it.\n\n2010-05-06:  Stuart Caie  <kyzer@4u.net>\n\n\t* test/cabrip.c, test/chminfo.c: add fseeko() support\n\n2009-06-01:  Stuart Caie   <kyzer@4u.net>\n\n\t* README: clarify the extended license terms\n\n\t* doc, Makefile.am: make the doxygen makefile work when using\n\tan alternate build directory\n\n2006-09-20:  Stuart Caie   <kyzer@4u.net>\n\n\t* system.h: I had a choice of adding more to configure.ac to\n\ttest for __func__ and __FUNCTION__, or just removing __FUNCTION__\n\tfrom the D() macro. I chose the latter.\n\n\t* Makefile.am: Now the --enable-debug in configure will actually\n\tapply -DDEBUG to the sources.\n\n2006-09-20:  Stuart Caie   <kyzer@4u.net>\n\n\t* qtmd_decompress(): Fixed a major bug in the QTM decoder, as\n\treported by Tomasz Kojm last year. Removed the restriction on\n\twindow sizes as a result. Correctly decodes the XLVIEW cabinets.\n\n2006-08-31:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzxd_decompress(): Two major bugs fixed. Firstly, the R0/R1/R2\n\tlocal variables weren't set to 1 after lzxd_reset_state().\n\tSecondly, the LZX decompression stream can sometimes become\n\todd-aligned (after an uncompressed block) and the next 16 bit\n\tfetch needs to be split across two input buffers, ENSURE_BITS()\n\tdidn't cover this case. Many thanks to Igor Glucksmann for\n\tdiscovering both these bugs.\n\n2005-06-30:  Stuart Caie   <kyzer@4u.net>\n\n\t* cabd_search(): fixed problems with searching files > 4GB for\n\tcabinets.\n\n2005-06-23:  Stuart Caie   <kyzer@4u.net>\n\n\t* qtmd_init(): The QTM decoder is broken for QTM streams with a\n\twindow size less than the frame size. Until this is fixed, fail\n\tto initialise QTM window sizes less than 15. Thanks to Tomasz Kojm\n\tfor finding the bug.\n\n2005-03-22:  Stuart Caie   <kyzer@4u.net>\n\n\t* system.h: now undefs \"read\", as the latest glibc defines read()\n\tas a macro which messes everything up. Thanks to Ville Skytt\u00e4 for\n\tthe update.\n\n2005-03-14:  Stuart Caie   <kyzer@4u.net>\n\n\t* test/multifh.c: write an mspack_system implementation that can\n\thandle normal disk files, open file handles, open file descriptors\n\tand raw memory all at the same time.\n\n2005-02-24:  Stuart Caie   <kyzer@4u.net>\n\n\t* chmd_read_headers(): avoid infinite loop when chmhs1_ChunkSize is\n\tzero. Thanks to Serge Semashko for the research and discovery.\n\n2005-02-18:  Stuart Caie   <kyzer@4u.net>\n\n\t* mspack.h: renamed the \"interface\" parameter of mspack_version() to\n\t\"entity\", as interface is a reserved word in C++. Thanks to Yuriy Z\n\tfor the discovery.\n\n2004-12-09:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzss.h, szdd.h, szddd.h: more work on the SZDD/LZSS design.\n\t\n2004-06-12:  Stuart Caie   <kyzer@4u.net>\n\n\t* lzxd_static_init(): removed write to lzxd_extra_bits[52], thanks\n\tto Nigel Horne from the ClamAV project.\n\n2004-04-23:  Stuart Caie   <kyzer@4u.net>\n\n\t* mspack.h: changed 'this' parameters to 'self' to allow compiling in\n\tC++ compilers, thanks to Michal Cihar for the suggestion.\n\n\t* mspack.h, system.h, mspack.def, winbuild.sh: integrated some changes\n\tfrom Petr Blahos to let libmspack build as a Win32 DLL.\n\n\t* chmd_fast_find(): added the first part of this code, and comments\n\tsufficient to finish it :)\n\n2004-04-08  Stuart Caie   <kyzer@4u.net>\n\n\t* test/chminfo.c: added a program for dumping useful data from CHM\n\tfiles, e.g. index entries and reset tables. I wrote this a while ago\n\tfor investigating a corrupt cabinet, but I never committed it.\n\n2004-03-26  Stuart Caie   <kyzer@4u.net>\n\n\t* test/cabd_memory.c: added a new test example which shows an\n\tmspack_system implementation that reads and writes from memory only,\n\tno file I/O. Even the source code has a little cab file embedded in it.\n\n2004-03-10  Stuart Caie   <kyzer@4u.net>\n\n\t* cabd.c: updated the location of the CAB SDK.\n\n\t* cabd.c: changed a couple of MSPACK_ERR_READ errors not based on\n\tread() failures into MSPACK_ERR_DATAFORMAT errors.\n\n\t* mszipd_decompress(): repair mode now aborts after writing a\n\trepaired block if the error was a hard error (e.g. read error, out\n\tof blocks, etc)\n\n2004-03-08  Stuart Caie   <kyzer@4u.net>\n\n\t* Makefile.am: now builds and installs a versioned library.\n\n\t* mszipd.c: completed a new MS-ZIP and inflate implementation.\n\n\t* system.c: added mspack_version() and committed to a versioned\n\tABI for the library.\n\n\t* cabd.c: made mszip repair functionality work correctly.\n\n\t* cabd.c: now identifies invalid block headers\n\n\t* doc/: API documentation is now included with the library, not\n\tjust on the web.\n\n\t* chmd.c: fixed error messages and 64-bit debug output.\n\n\t* chmd.c: now also catches NULL files in section 1.\n\n\t* test/chmx.c: now acts more like cabextract.\n\n2003-08-29  Stuart Caie   <kyzer@4u.net>\n\n\t* ChangeLog: started keeping a ChangeLog :)\n", "/* This file is part of libmspack.\n * (C) 2003-2018 Stuart Caie.\n *\n * libmspack is free software; you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License (LGPL) version 2.1\n *\n * For further details, see the file COPYING.LIB distributed with libmspack\n */\n\n/* CHM decompression implementation */\n\n#include <system.h>\n#include <chm.h>\n\n/* prototypes */\nstatic struct mschmd_header * chmd_open(\n  struct mschm_decompressor *base, const char *filename);\nstatic struct mschmd_header * chmd_fast_open(\n  struct mschm_decompressor *base, const char *filename);\nstatic struct mschmd_header *chmd_real_open(\n  struct mschm_decompressor *base, const char *filename, int entire);\nstatic void chmd_close(\n  struct mschm_decompressor *base, struct mschmd_header *chm);\nstatic int chmd_read_headers(\n  struct mspack_system *sys, struct mspack_file *fh,\n  struct mschmd_header *chm, int entire);\nstatic int chmd_fast_find(\n  struct mschm_decompressor *base, struct mschmd_header *chm,\n  const char *filename, struct mschmd_file *f_ptr, int f_size);\nstatic unsigned char *read_chunk(\n  struct mschm_decompressor_p *self, struct mschmd_header *chm,\n  struct mspack_file *fh, unsigned int chunk);\nstatic int search_chunk(\n  struct mschmd_header *chm, const unsigned char *chunk, const char *filename,\n  const unsigned char **result, const unsigned char **result_end);\nstatic inline int compare(\n  const char *s1, const char *s2, int l1, int l2);\nstatic int chmd_extract(\n  struct mschm_decompressor *base, struct mschmd_file *file,\n  const char *filename);\nstatic int chmd_sys_write(\n  struct mspack_file *file, void *buffer, int bytes);\nstatic int chmd_init_decomp(\n  struct mschm_decompressor_p *self, struct mschmd_file *file);\nstatic int read_reset_table(\n  struct mschm_decompressor_p *self, struct mschmd_sec_mscompressed *sec,\n  int entry, off_t *length_ptr, off_t *offset_ptr);\nstatic int read_spaninfo(\n  struct mschm_decompressor_p *self, struct mschmd_sec_mscompressed *sec,\n  off_t *length_ptr);\nstatic int find_sys_file(\n  struct mschm_decompressor_p *self, struct mschmd_sec_mscompressed *sec,\n  struct mschmd_file **f_ptr, const char *name);\nstatic unsigned char *read_sys_file(\n  struct mschm_decompressor_p *self, struct mschmd_file *file);\nstatic int chmd_error(\n  struct mschm_decompressor *base);\nstatic int read_off64(\n  off_t *var, unsigned char *mem, struct mspack_system *sys,\n  struct mspack_file *fh);\n\n/* filenames of the system files used for decompression.\n * Content and ControlData are essential.\n * ResetTable is preferred, but SpanInfo can be used if not available\n */\nstatic const char *content_name  = \"::DataSpace/Storage/MSCompressed/Content\";\nstatic const char *control_name  = \"::DataSpace/Storage/MSCompressed/ControlData\";\nstatic const char *spaninfo_name = \"::DataSpace/Storage/MSCompressed/SpanInfo\";\nstatic const char *rtable_name   = \"::DataSpace/Storage/MSCompressed/Transform/\"\n  \"{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable\";\n\n/***************************************\n * MSPACK_CREATE_CHM_DECOMPRESSOR\n ***************************************\n * constructor\n */\nstruct mschm_decompressor *\n  mspack_create_chm_decompressor(struct mspack_system *sys)\n{\n  struct mschm_decompressor_p *self = NULL;\n\n  if (!sys) sys = mspack_default_system;\n  if (!mspack_valid_system(sys)) return NULL;\n\n  if ((self = (struct mschm_decompressor_p *) sys->alloc(sys, sizeof(struct mschm_decompressor_p)))) {\n    self->base.open       = &chmd_open;\n    self->base.close      = &chmd_close;\n    self->base.extract    = &chmd_extract;\n    self->base.last_error = &chmd_error;\n    self->base.fast_open  = &chmd_fast_open;\n    self->base.fast_find  = &chmd_fast_find;\n    self->system          = sys;\n    self->error           = MSPACK_ERR_OK;\n    self->d               = NULL;\n  }\n  return (struct mschm_decompressor *) self;\n}\n\n/***************************************\n * MSPACK_DESTROY_CAB_DECOMPRESSOR\n ***************************************\n * destructor\n */\nvoid mspack_destroy_chm_decompressor(struct mschm_decompressor *base) {\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  if (self) {\n    struct mspack_system *sys = self->system;\n    if (self->d) {\n      if (self->d->infh)  sys->close(self->d->infh);\n      if (self->d->state) lzxd_free(self->d->state);\n      sys->free(self->d);\n    }\n    sys->free(self);\n  }\n}\n\n/***************************************\n * CHMD_OPEN\n ***************************************\n * opens a file and tries to read it as a CHM file.\n * Calls chmd_real_open() with entire=1.\n */\nstatic struct mschmd_header *chmd_open(struct mschm_decompressor *base,\n\t\t\t\t       const char *filename)\n{\n  return chmd_real_open(base, filename, 1);\n}\n\n/***************************************\n * CHMD_FAST_OPEN\n ***************************************\n * opens a file and tries to read it as a CHM file, but does not read\n * the file headers. Calls chmd_real_open() with entire=0\n */\nstatic struct mschmd_header *chmd_fast_open(struct mschm_decompressor *base,\n\t\t\t\t\t    const char *filename)\n{\n  return chmd_real_open(base, filename, 0);\n}\n\n/***************************************\n * CHMD_REAL_OPEN\n ***************************************\n * the real implementation of chmd_open() and chmd_fast_open(). It simply\n * passes the \"entire\" parameter to chmd_read_headers(), which will then\n * either read all headers, or a bare mininum.\n */\nstatic struct mschmd_header *chmd_real_open(struct mschm_decompressor *base,\n\t\t\t\t\t    const char *filename, int entire)\n{\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  struct mschmd_header *chm = NULL;\n  struct mspack_system *sys;\n  struct mspack_file *fh;\n  int error;\n\n  if (!base) return NULL;\n  sys = self->system;\n\n  if ((fh = sys->open(sys, filename, MSPACK_SYS_OPEN_READ))) {\n    if ((chm = (struct mschmd_header *) sys->alloc(sys, sizeof(struct mschmd_header)))) {\n      chm->filename = filename;\n      error = chmd_read_headers(sys, fh, chm, entire);\n      if (error) {\n\t/* if the error is DATAFORMAT, and there are some results, return\n\t * partial results with a warning, rather than nothing */\n\tif (error == MSPACK_ERR_DATAFORMAT && (chm->files || chm->sysfiles)) {\n\t  sys->message(fh, \"WARNING; contents are corrupt\");\n\t  error = MSPACK_ERR_OK;\n\t}\n\telse {\n\t  chmd_close(base, chm);\n\t  chm = NULL;\n\t}\n      }\n      self->error = error;\n    }\n    else {\n      self->error = MSPACK_ERR_NOMEMORY;\n    }\n    sys->close(fh);\n  }\n  else {\n    self->error = MSPACK_ERR_OPEN;\n  }\n  return chm;\n}\n\n/***************************************\n * CHMD_CLOSE\n ***************************************\n * frees all memory associated with a given mschmd_header\n */\nstatic void chmd_close(struct mschm_decompressor *base,\n\t\t       struct mschmd_header *chm)\n{\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  struct mschmd_file *fi, *nfi;\n  struct mspack_system *sys;\n  unsigned int i;\n\n  if (!base) return;\n  sys = self->system;\n\n  self->error = MSPACK_ERR_OK;\n\n  /* free files */\n  for (fi = chm->files; fi; fi = nfi) {\n    nfi = fi->next;\n    sys->free(fi);\n  }\n  for (fi = chm->sysfiles; fi; fi = nfi) {\n    nfi = fi->next;\n    sys->free(fi);\n  }\n\n  /* if this CHM was being decompressed, free decompression state */\n  if (self->d && (self->d->chm == chm)) {\n    if (self->d->infh) sys->close(self->d->infh);\n    if (self->d->state) lzxd_free(self->d->state);\n    sys->free(self->d);\n    self->d = NULL;\n  }\n\n  /* if this CHM had a chunk cache, free it and contents */\n  if (chm->chunk_cache) {\n      for (i = 0; i < chm->num_chunks; i++) sys->free(chm->chunk_cache[i]);\n      sys->free(chm->chunk_cache);\n  }\n\n  sys->free(chm);\n}\n\n/***************************************\n * CHMD_READ_HEADERS\n ***************************************\n * reads the basic CHM file headers. If the \"entire\" parameter is\n * non-zero, all file entries will also be read. fills out a pre-existing\n * mschmd_header structure, allocates memory for files as necessary\n */\n\n/* The GUIDs found in CHM headers */\nstatic const unsigned char guids[32] = {\n  /* {7C01FD10-7BAA-11D0-9E0C-00A0-C922-E6EC} */\n  0x10, 0xFD, 0x01, 0x7C, 0xAA, 0x7B, 0xD0, 0x11,\n  0x9E, 0x0C, 0x00, 0xA0, 0xC9, 0x22, 0xE6, 0xEC,\n  /* {7C01FD11-7BAA-11D0-9E0C-00A0-C922-E6EC} */\n  0x11, 0xFD, 0x01, 0x7C, 0xAA, 0x7B, 0xD0, 0x11,\n  0x9E, 0x0C, 0x00, 0xA0, 0xC9, 0x22, 0xE6, 0xEC\n};\n\n/* reads an encoded integer into a variable; 7 bits of data per byte,\n * the high bit is used to indicate that there is another byte */\n#define READ_ENCINT(var) do {\t\t\t\\\n    (var) = 0;\t\t\t\t\t\\\n    do {\t\t\t\t\t\\\n\tif (p >= end) goto chunk_end;\t\t\\\n\t(var) = ((var) << 7) | (*p & 0x7F);\t\\\n    } while (*p++ & 0x80);\t\t\t\\\n} while (0)\n\nstatic int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      /* consider blank filenames to be an error */\n      if (name_len == 0) goto chunk_end;\n      name = p; p += name_len;\n\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}\n\n/***************************************\n * CHMD_FAST_FIND\n ***************************************\n * uses PMGI index chunks and quickref data to quickly locate a file\n * directly from the on-disk index.\n *\n * TODO: protect against infinite loops in chunks (where pgml_NextChunk\n * or a PMGI index entry point to an already visited chunk)\n */\nstatic int chmd_fast_find(struct mschm_decompressor *base,\n\t\t\t  struct mschmd_header *chm, const char *filename,\n\t\t\t  struct mschmd_file *f_ptr, int f_size)\n{\n    struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n    struct mspack_system *sys;\n    struct mspack_file *fh;\n    const unsigned char *chunk, *p, *end;\n    int err = MSPACK_ERR_OK, result = -1;\n    unsigned int n, sec;\n\n    if (!self || !chm || !f_ptr || (f_size != sizeof(struct mschmd_file))) {\n\treturn MSPACK_ERR_ARGS;\n    }\n    sys = self->system;\n\n    /* clear the results structure */\n    memset(f_ptr, 0, f_size);\n\n    if (!(fh = sys->open(sys, chm->filename, MSPACK_SYS_OPEN_READ))) {\n\treturn MSPACK_ERR_OPEN;\n    }\n\n    /* go through PMGI chunk hierarchy to reach PMGL chunk */\n    if (chm->index_root < chm->num_chunks) {\n\tn = chm->index_root;\n\tfor (;;) {\n\t    if (!(chunk = read_chunk(self, chm, fh, n))) {\n\t\tsys->close(fh);\n\t\treturn self->error;\n\t    }\n\n\t    /* search PMGI/PMGL chunk. exit early if no entry found */\n\t    if ((result = search_chunk(chm, chunk, filename, &p, &end)) <= 0) {\n\t\tbreak;\n\t    }\n\n\t    /* found result. loop around for next chunk if this is PMGI */\n\t    if (chunk[3] == 0x4C) break; else READ_ENCINT(n);\n\t}\n    }\n    else {\n\t/* PMGL chunks only, search from first_pmgl to last_pmgl */\n\tfor (n = chm->first_pmgl; n <= chm->last_pmgl;\n\t     n = EndGetI32(&chunk[pmgl_NextChunk]))\n\t{\n\t    if (!(chunk = read_chunk(self, chm, fh, n))) {\n\t\terr = self->error;\n\t\tbreak;\n\t    }\n\n\t    /* search PMGL chunk. exit if file found */\n\t    if ((result = search_chunk(chm, chunk, filename, &p, &end)) > 0) {\n\t\tbreak;\n\t    }\n\n            /* stop simple infinite loops: can't visit the same chunk twice */\n            if ((int)n == EndGetI32(&chunk[pmgl_NextChunk])) {\n                break;\n            }\n\t}\n    }\n\n    /* if we found a file, read it */\n    if (result > 0) {\n\tREAD_ENCINT(sec);\n\tf_ptr->section  = (sec == 0) ? (struct mschmd_section *) &chm->sec0\n\t                             : (struct mschmd_section *) &chm->sec1;\n\tREAD_ENCINT(f_ptr->offset);\n\tREAD_ENCINT(f_ptr->length);\n    }\n    else if (result < 0) {\n\terr = MSPACK_ERR_DATAFORMAT;\n    }\n\n    sys->close(fh);\n    return self->error = err;\n\n chunk_end:\n    D((\"read beyond end of chunk entries\"))\n    sys->close(fh);\n    return self->error = MSPACK_ERR_DATAFORMAT;\n}\n\n/* reads the given chunk into memory, storing it in a chunk cache\n * so it doesn't need to be read from disk more than once\n */\nstatic unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num >= chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}\n\n/* searches a PMGI/PMGL chunk for a given filename entry. Returns -1 on\n * data format error, 0 if entry definitely not found, 1 if entry\n * found. In the latter case, *result and *result_end are set pointing\n * to that entry's data (either the \"next chunk\" ENCINT for a PMGI or\n * the section, offset and length ENCINTs for a PMGL).\n *\n * In the case of PMGL chunks, the entry has definitely been\n * found. In the case of PMGI chunks, the entry which points to the\n * chunk that may eventually contain that entry has been found.\n */\nstatic int search_chunk(struct mschmd_header *chm,\n\t\t\tconst unsigned char *chunk,\n\t\t\tconst char *filename,\n\t\t\tconst unsigned char **result,\n\t\t\tconst unsigned char **result_end)\n{\n    const unsigned char *start, *end, *p;\n    unsigned int qr_size, num_entries, qr_entries, qr_density, name_len;\n    unsigned int L, R, M, fname_len, entries_off, is_pmgl;\n    int cmp;\n\n    fname_len = strlen(filename);\n\n    /* PMGL chunk or PMGI chunk? (note: read_chunk() has already\n     * checked the rest of the characters in the chunk signature) */\n    if (chunk[3] == 0x4C) {\n\tis_pmgl = 1;\n\tentries_off = pmgl_Entries;\n    }\n    else {\n\tis_pmgl = 0;\n\tentries_off = pmgi_Entries;\n    }\n\n    /*  Step 1: binary search first filename of each QR entry\n     *  - target filename == entry\n     *    found file\n     *  - target filename < all entries\n     *    file not found\n     *  - target filename > all entries\n     *    proceed to step 2 using final entry\n     *  - target filename between two searched entries\n     *    proceed to step 2\n     */\n    qr_size     = EndGetI32(&chunk[pmgl_QuickRefSize]);\n    start       = &chunk[chm->chunk_size - 2];\n    end         = &chunk[chm->chunk_size - qr_size];\n    num_entries = EndGetI16(start);\n    qr_density  = 1 + (1 << chm->density);\n    qr_entries  = (num_entries + qr_density-1) / qr_density;\n\n    if (num_entries == 0) {\n\tD((\"chunk has no entries\"))\n\treturn -1;\n    }\n\n    if (qr_size > chm->chunk_size) {\n\tD((\"quickref size > chunk size\"))\n\treturn -1;\n    }\n\n    *result_end = end;\n\n    if (((int)qr_entries * 2) > (start - end)) {\n\tD((\"WARNING; more quickrefs than quickref space\"))\n\tqr_entries = 0; /* but we can live with it */\n    }\n\n    if (qr_entries > 0) {\n\tL = 0;\n\tR = qr_entries - 1;\n\tdo {\n\t    /* pick new midpoint */\n\t    M = (L + R) >> 1;\n\n\t    /* compare filename with entry QR points to */\n\t    p = &chunk[entries_off + (M ? EndGetI16(start - (M << 1)) : 0)];\n\t    READ_ENCINT(name_len);\n\t    if (name_len > (unsigned int) (end - p)) goto chunk_end;\n\t    cmp = compare(filename, (char *)p, fname_len, name_len);\n\n\t    if (cmp == 0) break;\n\t    else if (cmp < 0) { if (M) R = M - 1; else return 0; }\n\t    else if (cmp > 0) L = M + 1;\n\t} while (L <= R);\n\tM = (L + R) >> 1;\n\n\tif (cmp == 0) {\n\t    /* exact match! */\n\t    p += name_len;\n\t    *result = p;\n\t    return 1;\n\t}\n\n\t/* otherwise, read the group of entries for QR entry M */\n\tp = &chunk[entries_off + (M ? EndGetI16(start - (M << 1)) : 0)];\n\tnum_entries -= (M * qr_density);\n\tif (num_entries > qr_density) num_entries = qr_density;\n    }\n    else {\n\tp = &chunk[entries_off];\n    }\n\n    /* Step 2: linear search through the set of entries reached in step 1.\n     * - filename == any entry\n     *   found entry\n     * - filename < all entries (PMGI) or any entry (PMGL)\n     *   entry not found, stop now\n     * - filename > all entries\n     *   entry not found (PMGL) / maybe found (PMGI)\n     * - \n     */\n    *result = NULL;\n    while (num_entries-- > 0) {\n\tREAD_ENCINT(name_len);\n\tif (name_len > (unsigned int) (end - p)) goto chunk_end;\n\tcmp = compare(filename, (char *)p, fname_len, name_len);\n\tp += name_len;\n\n\tif (cmp == 0) {\n\t    /* entry found */\n\t    *result = p;\n\t    return 1;\n\t}\n\n\tif (cmp < 0) {\n\t    /* entry not found (PMGL) / maybe found (PMGI) */\n\t    break;\n\t}\n\n\t/* read and ignore the rest of this entry */\n\tif (is_pmgl) {\n\t    READ_ENCINT(R); /* skip section */\n\t    READ_ENCINT(R); /* skip offset */\n\t    READ_ENCINT(R); /* skip length */\n\t}\n\telse {\n\t    *result = p; /* store potential final result */\n\t    READ_ENCINT(R); /* skip chunk number */\n\t}\n    }\n\n     /* PMGL? not found. PMGI? maybe found */\n     return (is_pmgl) ? 0 : (*result ? 1 : 0);\n\n chunk_end:\n    D((\"reached end of chunk data while searching\"))\n    return -1;\n}\n\n#if HAVE_TOWLOWER\n# if HAVE_WCTYPE_H\n#  include <wctype.h>\n# endif\n# define TOLOWER(x) towlower(x)\n#elif HAVE_TOLOWER\n# if HAVE_CTYPE_H\n#  include <ctype.h>\n# endif\n# define TOLOWER(x) tolower(x)\n#else\n# define TOLOWER(x) (((x)<0||(x)>255)?(x):mspack_tolower_map[(x)])\n/* Map of char -> lowercase char for the first 256 chars. Generated with:\n * LC_CTYPE=en_GB.utf-8 perl -Mlocale -le 'print map{ord(lc chr).\",\"} 0..255'\n */\nstatic const unsigned char mspack_tolower_map[256] = {\n    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,\n    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,\n    53,54,55,56,57,58,59,60,61,62,63,64,97,98,99,100,101,102,103,104,105,106,\n    107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,91,92,93,94,\n    95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,\n    115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,\n    134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,\n    153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,\n    172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,\n    191,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,\n    242,243,244,245,246,215,248,249,250,251,252,253,254,223,224,225,226,227,228,\n    229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,\n    248,249,250,251,252,253,254,255\n};\n#endif\n\n/* decodes a UTF-8 character from s[] into c. Will not read past e. \n * doesn't test that extension bytes are %10xxxxxx.\n * allows some overlong encodings.\n */\n#define GET_UTF8_CHAR(s, e, c) do {\t\t\t\t\t\\\n    unsigned char x = *s++;\t\t\t\t\t\t\\\n    if (x < 0x80) c = x;\t\t\t\t\t\t\\\n    else if (x >= 0xC2 && x < 0xE0 && s < e) {\t\t\t\t\\\n\tc = (x & 0x1F) << 6 | (*s++ & 0x3F);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    else if (x >= 0xE0 && x < 0xF0 && s+1 < e) {\t\t\t\\\n\tc = (x & 0x0F) << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);\t\\\n\ts += 2;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    else if (x >= 0xF0 && x <= 0xF5 && s+2 < e) {\t\t\t\\\n\tc = (x & 0x07) << 18 | (s[0] & 0x3F) << 12 |\t\t\t\\\n\t    (s[1] & 0x3F) << 6 | (s[2] & 0x3F);\t\t\t\t\\\n\tif (c > 0x10FFFF) c = 0xFFFD;\t\t\t\t\t\\\n\ts += 3;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    else c = 0xFFFD;\t\t\t\t\t\t\t\\\n} while (0)\n\n/* case-insensitively compares two UTF8 encoded strings. String length for\n * both strings must be provided, null bytes are not terminators */\nstatic inline int compare(const char *s1, const char *s2, int l1, int l2) {\n    register const unsigned char *p1 = (const unsigned char *) s1;\n    register const unsigned char *p2 = (const unsigned char *) s2;\n    register const unsigned char *e1 = p1 + l1, *e2 = p2 + l2;\n    int c1, c2;\n\n    while (p1 < e1 && p2 < e2) {\n\tGET_UTF8_CHAR(p1, e1, c1);\n\tGET_UTF8_CHAR(p2, e2, c2);\n\tif (c1 == c2) continue;\n\tc1 = TOLOWER(c1);\n\tc2 = TOLOWER(c2);\n\tif (c1 != c2) return c1 - c2;\n    }\n    return l1 - l2;\n}\n\n\n/***************************************\n * CHMD_EXTRACT\n ***************************************\n * extracts a file from a CHM helpfile\n */\nstatic int chmd_extract(struct mschm_decompressor *base,\n\t\t\tstruct mschmd_file *file, const char *filename)\n{\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  struct mspack_system *sys;\n  struct mschmd_header *chm;\n  struct mspack_file *fh;\n  off_t bytes;\n\n  if (!self) return MSPACK_ERR_ARGS;\n  if (!file || !file->section) return self->error = MSPACK_ERR_ARGS;\n  sys = self->system;\n  chm = file->section->chm;\n\n  /* create decompression state if it doesn't exist */\n  if (!self->d) {\n    self->d = (struct mschmd_decompress_state *) sys->alloc(sys, sizeof(struct mschmd_decompress_state));\n    if (!self->d) return self->error = MSPACK_ERR_NOMEMORY;\n    self->d->chm       = chm;\n    self->d->offset    = 0;\n    self->d->state     = NULL;\n    self->d->sys       = *sys;\n    self->d->sys.write = &chmd_sys_write;\n    self->d->infh      = NULL;\n    self->d->outfh     = NULL;\n  }\n\n  /* open input chm file if not open, or the open one is a different chm */\n  if (!self->d->infh || (self->d->chm != chm)) {\n    if (self->d->infh)  sys->close(self->d->infh);\n    if (self->d->state) lzxd_free(self->d->state);\n    self->d->chm    = chm;\n    self->d->offset = 0;\n    self->d->state  = NULL;\n    self->d->infh   = sys->open(sys, chm->filename, MSPACK_SYS_OPEN_READ);\n    if (!self->d->infh) return self->error = MSPACK_ERR_OPEN;\n  }\n\n  /* open file for output */\n  if (!(fh = sys->open(sys, filename, MSPACK_SYS_OPEN_WRITE))) {\n    return self->error = MSPACK_ERR_OPEN;\n  }\n\n  /* if file is empty, simply creating it is enough */\n  if (!file->length) {\n    sys->close(fh);\n    return self->error = MSPACK_ERR_OK;\n  }\n\n  self->error = MSPACK_ERR_OK;\n\n  switch (file->section->id) {\n  case 0: /* Uncompressed section file */\n    /* simple seek + copy */\n    if (sys->seek(self->d->infh, file->section->chm->sec0.offset\n\t\t  + file->offset, MSPACK_SYS_SEEK_START))\n    {\n      self->error = MSPACK_ERR_SEEK;\n    }\n    else {\n      unsigned char buf[512];\n      off_t length = file->length;\n      while (length > 0) {\n\tint run = sizeof(buf);\n\tif ((off_t)run > length) run = (int)length;\n\tif (sys->read(self->d->infh, &buf[0], run) != run) {\n\t  self->error = MSPACK_ERR_READ;\n\t  break;\n\t}\n\tif (sys->write(fh, &buf[0], run) != run) {\n\t  self->error = MSPACK_ERR_WRITE;\n\t  break;\n\t}\n\tlength -= run;\n      }\n    }\n    break;\n\n  case 1: /* MSCompressed section file */\n    /* (re)initialise compression state if we it is not yet initialised,\n     * or we have advanced too far and have to backtrack\n     */\n    if (!self->d->state || (file->offset < self->d->offset)) {\n      if (self->d->state) {\n\tlzxd_free(self->d->state);\n\tself->d->state = NULL;\n      }\n      if (chmd_init_decomp(self, file)) break;\n    }\n\n    /* seek to input data */\n    if (sys->seek(self->d->infh, self->d->inoffset, MSPACK_SYS_SEEK_START)) {\n      self->error = MSPACK_ERR_SEEK;\n      break;\n    }\n\n    /* get to correct offset. */\n    self->d->outfh = NULL;\n    if ((bytes = file->offset - self->d->offset)) {\n      self->error = lzxd_decompress(self->d->state, bytes);\n    }\n\n    /* if getting to the correct offset was error free, unpack file */\n    if (!self->error) {\n      self->d->outfh = fh;\n      self->error = lzxd_decompress(self->d->state, file->length);\n    }\n\n    /* save offset in input source stream, in case there is a section 0\n     * file between now and the next section 1 file extracted */\n    self->d->inoffset = sys->tell(self->d->infh);\n\n    /* if an LZX error occured, the LZX decompressor is now useless */\n    if (self->error) {\n      if (self->d->state) lzxd_free(self->d->state);\n      self->d->state = NULL;\n    }\n    break;\n  }\n\n  sys->close(fh);\n  return self->error;\n}\n\n/***************************************\n * CHMD_SYS_WRITE\n ***************************************\n * chmd_sys_write is the internal writer function which the decompressor\n * uses. If either writes data to disk (self->d->outfh) with the real\n * sys->write() function, or does nothing with the data when\n * self->d->outfh == NULL. advances self->d->offset.\n */\nstatic int chmd_sys_write(struct mspack_file *file, void *buffer, int bytes) {\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) file;\n  self->d->offset += bytes;\n  if (self->d->outfh) {\n    return self->system->write(self->d->outfh, buffer, bytes);\n  }\n  return bytes;\n}\n\n/***************************************\n * CHMD_INIT_DECOMP\n ***************************************\n * Initialises the LZX decompressor to decompress the compressed stream,\n * from the nearest reset offset and length that is needed for the given\n * file.\n */\nstatic int chmd_init_decomp(struct mschm_decompressor_p *self,\n\t\t\t    struct mschmd_file *file)\n{\n  int window_size, window_bits, reset_interval, entry, err;\n  struct mspack_system *sys = self->system;\n  struct mschmd_sec_mscompressed *sec;\n  unsigned char *data;\n  off_t length, offset;\n\n  sec = (struct mschmd_sec_mscompressed *) file->section;\n\n  /* ensure we have a mscompressed content section */\n  err = find_sys_file(self, sec, &sec->content, content_name);\n  if (err) return self->error = err;\n\n  /* ensure we have a ControlData file */\n  err = find_sys_file(self, sec, &sec->control, control_name);\n  if (err) return self->error = err;\n\n  /* read ControlData */\n  if (sec->control->length < lzxcd_SIZEOF) {\n    D((\"ControlData file is too short\"))\n    return self->error = MSPACK_ERR_DATAFORMAT;\n  }\n  if (!(data = read_sys_file(self, sec->control))) {\n    D((\"can't read mscompressed control data file\"))\n    return self->error;\n  }\n\n  /* check LZXC signature */\n  if (EndGetI32(&data[lzxcd_Signature]) != 0x43585A4C) {\n    sys->free(data);\n    return self->error = MSPACK_ERR_SIGNATURE;\n  }\n\n  /* read reset_interval and window_size and validate version number */\n  switch (EndGetI32(&data[lzxcd_Version])) {\n  case 1:\n    reset_interval = EndGetI32(&data[lzxcd_ResetInterval]);\n    window_size    = EndGetI32(&data[lzxcd_WindowSize]);\n    break;\n  case 2:\n    reset_interval = EndGetI32(&data[lzxcd_ResetInterval]) * LZX_FRAME_SIZE;\n    window_size    = EndGetI32(&data[lzxcd_WindowSize])    * LZX_FRAME_SIZE;\n    break;\n  default:\n    D((\"bad controldata version\"))\n    sys->free(data);\n    return self->error = MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* free ControlData */\n  sys->free(data);\n\n  /* find window_bits from window_size */\n  switch (window_size) {\n  case 0x008000: window_bits = 15; break;\n  case 0x010000: window_bits = 16; break;\n  case 0x020000: window_bits = 17; break;\n  case 0x040000: window_bits = 18; break;\n  case 0x080000: window_bits = 19; break;\n  case 0x100000: window_bits = 20; break;\n  case 0x200000: window_bits = 21; break;\n  default:\n    D((\"bad controldata window size\"))\n    return self->error = MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* validate reset_interval */\n  if (reset_interval == 0 || reset_interval % LZX_FRAME_SIZE) {\n    D((\"bad controldata reset interval\"))\n    return self->error = MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* which reset table entry would we like? */\n  entry = file->offset / reset_interval;\n  /* convert from reset interval multiple (usually 64k) to 32k frames */\n  entry *= reset_interval / LZX_FRAME_SIZE;\n\n  /* read the reset table entry */\n  if (read_reset_table(self, sec, entry, &length, &offset)) {\n    /* the uncompressed length given in the reset table is dishonest.\n     * the uncompressed data is always padded out from the given\n     * uncompressed length up to the next reset interval */\n    length += reset_interval - 1;\n    length &= -reset_interval;\n  }\n  else {\n    /* if we can't read the reset table entry, just start from\n     * the beginning. Use spaninfo to get the uncompressed length */\n    entry = 0;\n    offset = 0;\n    err = read_spaninfo(self, sec, &length);\n  }\n  if (err) return self->error = err;\n\n  /* get offset of compressed data stream:\n   * = offset of uncompressed section from start of file\n   * + offset of compressed stream from start of uncompressed section\n   * + offset of chosen reset interval from start of compressed stream */\n  self->d->inoffset = file->section->chm->sec0.offset + sec->content->offset + offset;\n\n  /* set start offset and overall remaining stream length */\n  self->d->offset = entry * LZX_FRAME_SIZE;\n  length -= self->d->offset;\n\n  /* initialise LZX stream */\n  self->d->state = lzxd_init(&self->d->sys, self->d->infh,\n\t\t\t     (struct mspack_file *) self, window_bits,\n\t\t\t     reset_interval / LZX_FRAME_SIZE,\n\t\t\t     4096, length, 0);\n  if (!self->d->state) self->error = MSPACK_ERR_NOMEMORY;\n  return self->error;\n}\n\n/***************************************\n * READ_RESET_TABLE\n ***************************************\n * Reads one entry out of the reset table. Also reads the uncompressed\n * data length. Writes these to offset_ptr and length_ptr respectively.\n * Returns non-zero for success, zero for failure.\n */\nstatic int read_reset_table(struct mschm_decompressor_p *self,\n\t\t\t    struct mschmd_sec_mscompressed *sec,\n\t\t\t    int entry, off_t *length_ptr, off_t *offset_ptr)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *data;\n    unsigned int pos, entrysize;\n\n    /* do we have a ResetTable file? */\n    int err = find_sys_file(self, sec, &sec->rtable, rtable_name);\n    if (err) return 0;\n\n    /* read ResetTable file */\n    if (sec->rtable->length < lzxrt_headerSIZEOF) {\n\tD((\"ResetTable file is too short\"))\n\treturn 0;\n    }\n    if (!(data = read_sys_file(self, sec->rtable))) {\n\tD((\"can't read reset table\"))\n\treturn 0;\n    }\n\n    /* check sanity of reset table */\n    if (EndGetI32(&data[lzxrt_FrameLen]) != LZX_FRAME_SIZE) {\n\tD((\"bad reset table frame length\"))\n\tsys->free(data);\n\treturn 0;\n    }\n\n    /* get the uncompressed length of the LZX stream */\n    if (read_off64(length_ptr, &data[lzxrt_UncompLen], sys, self->d->infh)) {\n\tsys->free(data);\n\treturn 0;\n    }\n\n    entrysize = EndGetI32(&data[lzxrt_EntrySize]);\n    pos = EndGetI32(&data[lzxrt_TableOffset]) + (entry * entrysize);\n\n    /* ensure reset table entry for this offset exists */\n    if (entry < EndGetI32(&data[lzxrt_NumEntries]) &&\n\tpos <= (sec->rtable->length - entrysize))\n    {\n\tswitch (entrysize) {\n\tcase 4:\n\t    *offset_ptr = EndGetI32(&data[pos]);\n\t    err = 0;\n\t    break;\n\tcase 8:\n\t    err = read_off64(offset_ptr, &data[pos], sys, self->d->infh);\n\t    break;\n\tdefault:\n\t    D((\"reset table entry size neither 4 nor 8\"))\n\t    err = 1;\n\t    break;\n\t}\n    }\n    else {\n\tD((\"bad reset interval\"))\n\terr = 1;\n    }\n\n    /* free the reset table */\n    sys->free(data);\n\n    /* return success */\n    return (err == 0);\n}\n\n/***************************************\n * READ_SPANINFO\n ***************************************\n * Reads the uncompressed data length from the spaninfo file.\n * Returns zero for success or a non-zero error code for failure.\n */\nstatic int read_spaninfo(struct mschm_decompressor_p *self,\n\t\t\t struct mschmd_sec_mscompressed *sec,\n\t\t\t off_t *length_ptr)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *data;\n    \n    /* find SpanInfo file */\n    int err = find_sys_file(self, sec, &sec->spaninfo, spaninfo_name);\n    if (err) return MSPACK_ERR_DATAFORMAT;\n\n    /* check it's large enough */\n    if (sec->spaninfo->length != 8) {\n\tD((\"SpanInfo file is wrong size\"))\n\treturn MSPACK_ERR_DATAFORMAT;\n    }\n\n    /* read the SpanInfo file */\n    if (!(data = read_sys_file(self, sec->spaninfo))) {\n\tD((\"can't read SpanInfo file\"))\n\treturn self->error;\n    }\n\n    /* get the uncompressed length of the LZX stream */\n    err = read_off64(length_ptr, data, sys, self->d->infh);\n    sys->free(data);\n    if (err) return MSPACK_ERR_DATAFORMAT;\n\n    if (*length_ptr <= 0) {\n        D((\"output length is invalid\"))\n        return MSPACK_ERR_DATAFORMAT;\n    }\n\n    return MSPACK_ERR_OK;\n}\n\n/***************************************\n * FIND_SYS_FILE\n ***************************************\n * Uses chmd_fast_find to locate a system file, and fills out that system\n * file's entry and links it into the list of system files. Returns zero\n * for success, non-zero for both failure and the file not existing.\n */\nstatic int find_sys_file(struct mschm_decompressor_p *self,\n\t\t\t struct mschmd_sec_mscompressed *sec,\n\t\t\t struct mschmd_file **f_ptr, const char *name)\n{\n    struct mspack_system *sys = self->system;\n    struct mschmd_file result;\n\n    /* already loaded */\n    if (*f_ptr) return MSPACK_ERR_OK;\n\n    /* try using fast_find to find the file - return DATAFORMAT error if\n     * it fails, or successfully doesn't find the file */\n    if (chmd_fast_find((struct mschm_decompressor *) self, sec->base.chm,\n\t\t       name, &result, (int)sizeof(result)) || !result.section)\n    {\n\treturn MSPACK_ERR_DATAFORMAT;\n    }\n\n    if (!(*f_ptr = (struct mschmd_file *) sys->alloc(sys, sizeof(result)))) {\n\treturn MSPACK_ERR_NOMEMORY;\n    }\n\n    /* copy result */\n    *(*f_ptr) = result;\n    (*f_ptr)->filename = (char *) name;\n\n    /* link file into sysfiles list */\n    (*f_ptr)->next = sec->base.chm->sysfiles;\n    sec->base.chm->sysfiles = *f_ptr;\n    return MSPACK_ERR_OK;\n}\n\n/***************************************\n * READ_SYS_FILE\n ***************************************\n * Allocates memory for a section 0 (uncompressed) file and reads it into\n * memory.\n */\nstatic unsigned char *read_sys_file(struct mschm_decompressor_p *self,\n\t\t\t\t    struct mschmd_file *file)\n{\n  struct mspack_system *sys = self->system;\n  unsigned char *data = NULL;\n  int len;\n\n  if (!file || !file->section || (file->section->id != 0)) {\n    self->error = MSPACK_ERR_DATAFORMAT;\n    return NULL;\n  }\n\n  len = (int) file->length;\n\n  if (!(data = (unsigned char *) sys->alloc(sys, (size_t) len))) {\n    self->error = MSPACK_ERR_NOMEMORY;\n    return NULL;\n  }\n  if (sys->seek(self->d->infh, file->section->chm->sec0.offset\n\t\t+ file->offset, MSPACK_SYS_SEEK_START))\n  {\n    self->error = MSPACK_ERR_SEEK;\n    sys->free(data);\n    return NULL;\n  }\n  if (sys->read(self->d->infh, data, len) != len) {\n    self->error = MSPACK_ERR_READ;\n    sys->free(data);\n    return NULL;\n  }\n  return data;\n}\n\n/***************************************\n * CHMD_ERROR\n ***************************************\n * returns the last error that occurred\n */\nstatic int chmd_error(struct mschm_decompressor *base) {\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  return (self) ? self->error : MSPACK_ERR_ARGS;\n}\n\n/***************************************\n * READ_OFF64\n ***************************************\n * Reads a 64-bit signed integer from memory in Intel byte order.\n * If running on a system with a 64-bit off_t, this is simply done.\n * If running on a system with a 32-bit off_t, offsets up to 0x7FFFFFFF\n * are accepted, offsets beyond that cause an error message.\n */\nstatic int read_off64(off_t *var, unsigned char *mem,\n\t\t      struct mspack_system *sys, struct mspack_file *fh)\n{\n#ifdef LARGEFILE_SUPPORT\n    *var = EndGetI64(mem);\n#else\n    *var = EndGetI32(mem);\n    if ((*var & 0x80000000) || EndGetI32(mem+4)) {\n\tsys->message(fh, (char *)largefile_msg);\n\treturn 1;\n    }\n#endif\n    return 0;\n}\n"], "filenames": ["libmspack/ChangeLog", "libmspack/mspack/chmd.c"], "buggy_code_start_loc": [0, 2], "buggy_code_end_loc": [0, 626], "fixing_code_start_loc": [1, 2], "fixing_code_end_loc": [11, 629], "type": "CWE-193", "message": "An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the CHM PMGI/PMGL chunk number validity checks, which could lead to denial of service (uninitialized data dereference and application crash).", "other": {"cve": {"id": "CVE-2018-14679", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-28T23:29:00.250", "lastModified": "2021-04-26T11:45:18.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the CHM PMGI/PMGL chunk number validity checks, which could lead to denial of service (uninitialized data dereference and application crash)."}, {"lang": "es", "value": "Se ha descubierto un problema en mspack/chmd.c en libmspack en versiones anteriores a la 0.7alpha.  Hay un error por un paso en las comprobaciones de validez de los n\u00fameros de chunk de CHM PMGI/PMGL que podr\u00eda conducir a una denegaci\u00f3n de servicio (referencia de datos no inicializados y cierre inesperado de la aplicaci\u00f3n)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cabextract:libmspack:0.0.20060920:alpha:*:*:*:*:*:*", "matchCriteriaId": "549E0616-8188-411B-9493-8E861AAEDBF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cabextract:libmspack:0.3:alpha:*:*:*:*:*:*", "matchCriteriaId": "32C98EEF-4AD0-4A72-85A1-77CF77EE9BE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cabextract:libmspack:0.4:alpha:*:*:*:*:*:*", "matchCriteriaId": "AA4A4DCD-E207-467D-9543-C8EDE71E32ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cabextract:libmspack:0.5:alpha:*:*:*:*:*:*", "matchCriteriaId": "120C65CB-4E1C-4972-8EA8-C4A6FC09D63A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cabextract:libmspack:0.6:alpha:*:*:*:*:*:*", "matchCriteriaId": "C7A513DB-0953-4749-9EB9-BB88F0138CF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cabextract_project:cabextract:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5", "matchCriteriaId": "0E0CEBA0-EE24-4721-98CC-0CD2E2350FDC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible_tower:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A5319543-0143-4E2E-AA77-B7F116C1336C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2018/07/26/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securitytracker.com/id/1041410", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3327", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3505", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.debian.org/904802", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201903-20", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3728-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3728-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3728-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3789-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4260", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a"}}