{"buggy_code": ["/*\n * MinIO Cloud Storage, (C) 2015, 2016, 2017, 2018 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/Azure/azure-storage-blob-go/azblob\"\n\t\"google.golang.org/api/googleapi\"\n\n\tminio \"github.com/minio/minio-go/v7\"\n\t\"github.com/minio/minio-go/v7/pkg/tags\"\n\t\"github.com/minio/minio/cmd/config/dns\"\n\t\"github.com/minio/minio/cmd/crypto\"\n\t\"github.com/minio/minio/cmd/logger\"\n\t\"github.com/minio/minio/pkg/auth\"\n\t\"github.com/minio/minio/pkg/bucket/lifecycle\"\n\t\"github.com/minio/minio/pkg/bucket/replication\"\n\n\tobjectlock \"github.com/minio/minio/pkg/bucket/object/lock\"\n\t\"github.com/minio/minio/pkg/bucket/policy\"\n\t\"github.com/minio/minio/pkg/bucket/versioning\"\n\t\"github.com/minio/minio/pkg/event\"\n\t\"github.com/minio/minio/pkg/hash\"\n)\n\n// APIError structure\ntype APIError struct {\n\tCode           string\n\tDescription    string\n\tHTTPStatusCode int\n}\n\n// APIErrorResponse - error response format\ntype APIErrorResponse struct {\n\tXMLName    xml.Name `xml:\"Error\" json:\"-\"`\n\tCode       string\n\tMessage    string\n\tKey        string `xml:\"Key,omitempty\" json:\"Key,omitempty\"`\n\tBucketName string `xml:\"BucketName,omitempty\" json:\"BucketName,omitempty\"`\n\tResource   string\n\tRegion     string `xml:\"Region,omitempty\" json:\"Region,omitempty\"`\n\tRequestID  string `xml:\"RequestId\" json:\"RequestId\"`\n\tHostID     string `xml:\"HostId\" json:\"HostId\"`\n}\n\n// APIErrorCode type of error status.\ntype APIErrorCode int\n\n// Error codes, non exhaustive list - http://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\nconst (\n\tErrNone APIErrorCode = iota\n\tErrAccessDenied\n\tErrBadDigest\n\tErrEntityTooSmall\n\tErrEntityTooLarge\n\tErrPolicyTooLarge\n\tErrIncompleteBody\n\tErrInternalError\n\tErrInvalidAccessKeyID\n\tErrInvalidBucketName\n\tErrInvalidDigest\n\tErrInvalidRange\n\tErrInvalidCopyPartRange\n\tErrInvalidCopyPartRangeSource\n\tErrInvalidMaxKeys\n\tErrInvalidEncodingMethod\n\tErrInvalidMaxUploads\n\tErrInvalidMaxParts\n\tErrInvalidPartNumberMarker\n\tErrInvalidPartNumber\n\tErrInvalidRequestBody\n\tErrInvalidCopySource\n\tErrInvalidMetadataDirective\n\tErrInvalidCopyDest\n\tErrInvalidPolicyDocument\n\tErrInvalidObjectState\n\tErrMalformedXML\n\tErrMissingContentLength\n\tErrMissingContentMD5\n\tErrMissingRequestBodyError\n\tErrMissingSecurityHeader\n\tErrNoSuchBucket\n\tErrNoSuchBucketPolicy\n\tErrNoSuchBucketLifecycle\n\tErrNoSuchLifecycleConfiguration\n\tErrNoSuchBucketSSEConfig\n\tErrNoSuchCORSConfiguration\n\tErrNoSuchWebsiteConfiguration\n\tErrReplicationConfigurationNotFoundError\n\tErrRemoteDestinationNotFoundError\n\tErrReplicationDestinationMissingLock\n\tErrRemoteTargetNotFoundError\n\tErrReplicationRemoteConnectionError\n\tErrBucketRemoteIdenticalToSource\n\tErrBucketRemoteAlreadyExists\n\tErrBucketRemoteLabelInUse\n\tErrBucketRemoteArnTypeInvalid\n\tErrBucketRemoteArnInvalid\n\tErrBucketRemoteRemoveDisallowed\n\tErrRemoteTargetNotVersionedError\n\tErrReplicationSourceNotVersionedError\n\tErrReplicationNeedsVersioningError\n\tErrReplicationBucketNeedsVersioningError\n\tErrObjectRestoreAlreadyInProgress\n\tErrNoSuchKey\n\tErrNoSuchUpload\n\tErrInvalidVersionID\n\tErrNoSuchVersion\n\tErrNotImplemented\n\tErrPreconditionFailed\n\tErrRequestTimeTooSkewed\n\tErrSignatureDoesNotMatch\n\tErrMethodNotAllowed\n\tErrInvalidPart\n\tErrInvalidPartOrder\n\tErrAuthorizationHeaderMalformed\n\tErrMalformedPOSTRequest\n\tErrPOSTFileRequired\n\tErrSignatureVersionNotSupported\n\tErrBucketNotEmpty\n\tErrAllAccessDisabled\n\tErrMalformedPolicy\n\tErrMissingFields\n\tErrMissingCredTag\n\tErrCredMalformed\n\tErrInvalidRegion\n\tErrInvalidServiceS3\n\tErrInvalidServiceSTS\n\tErrInvalidRequestVersion\n\tErrMissingSignTag\n\tErrMissingSignHeadersTag\n\tErrMalformedDate\n\tErrMalformedPresignedDate\n\tErrMalformedCredentialDate\n\tErrMalformedCredentialRegion\n\tErrMalformedExpires\n\tErrNegativeExpires\n\tErrAuthHeaderEmpty\n\tErrExpiredPresignRequest\n\tErrRequestNotReadyYet\n\tErrUnsignedHeaders\n\tErrMissingDateHeader\n\tErrInvalidQuerySignatureAlgo\n\tErrInvalidQueryParams\n\tErrBucketAlreadyOwnedByYou\n\tErrInvalidDuration\n\tErrBucketAlreadyExists\n\tErrMetadataTooLarge\n\tErrUnsupportedMetadata\n\tErrMaximumExpires\n\tErrSlowDown\n\tErrInvalidPrefixMarker\n\tErrBadRequest\n\tErrKeyTooLongError\n\tErrInvalidBucketObjectLockConfiguration\n\tErrObjectLockConfigurationNotFound\n\tErrObjectLockConfigurationNotAllowed\n\tErrNoSuchObjectLockConfiguration\n\tErrObjectLocked\n\tErrInvalidRetentionDate\n\tErrPastObjectLockRetainDate\n\tErrUnknownWORMModeDirective\n\tErrBucketTaggingNotFound\n\tErrObjectLockInvalidHeaders\n\tErrInvalidTagDirective\n\t// Add new error codes here.\n\n\t// SSE-S3 related API errors\n\tErrInvalidEncryptionMethod\n\n\t// Server-Side-Encryption (with Customer provided key) related API errors.\n\tErrInsecureSSECustomerRequest\n\tErrSSEMultipartEncrypted\n\tErrSSEEncryptedObject\n\tErrInvalidEncryptionParameters\n\tErrInvalidSSECustomerAlgorithm\n\tErrInvalidSSECustomerKey\n\tErrMissingSSECustomerKey\n\tErrMissingSSECustomerKeyMD5\n\tErrSSECustomerKeyMD5Mismatch\n\tErrInvalidSSECustomerParameters\n\tErrIncompatibleEncryptionMethod\n\tErrKMSNotConfigured\n\tErrKMSAuthFailure\n\n\tErrNoAccessKey\n\tErrInvalidToken\n\n\t// Bucket notification related errors.\n\tErrEventNotification\n\tErrARNNotification\n\tErrRegionNotification\n\tErrOverlappingFilterNotification\n\tErrFilterNameInvalid\n\tErrFilterNamePrefix\n\tErrFilterNameSuffix\n\tErrFilterValueInvalid\n\tErrOverlappingConfigs\n\tErrUnsupportedNotification\n\n\t// S3 extended errors.\n\tErrContentSHA256Mismatch\n\n\t// Add new extended error codes here.\n\n\t// MinIO extended errors.\n\tErrReadQuorum\n\tErrWriteQuorum\n\tErrParentIsObject\n\tErrStorageFull\n\tErrRequestBodyParse\n\tErrObjectExistsAsDirectory\n\tErrInvalidObjectName\n\tErrInvalidObjectNamePrefixSlash\n\tErrInvalidResourceName\n\tErrServerNotInitialized\n\tErrOperationTimedOut\n\tErrClientDisconnected\n\tErrOperationMaxedOut\n\tErrInvalidRequest\n\t// MinIO storage class error codes\n\tErrInvalidStorageClass\n\tErrBackendDown\n\t// Add new extended error codes here.\n\t// Please open a https://github.com/minio/minio/issues before adding\n\t// new error codes here.\n\n\tErrMalformedJSON\n\tErrAdminNoSuchUser\n\tErrAdminNoSuchGroup\n\tErrAdminGroupNotEmpty\n\tErrAdminNoSuchPolicy\n\tErrAdminInvalidArgument\n\tErrAdminInvalidAccessKey\n\tErrAdminInvalidSecretKey\n\tErrAdminConfigNoQuorum\n\tErrAdminConfigTooLarge\n\tErrAdminConfigBadJSON\n\tErrAdminConfigDuplicateKeys\n\tErrAdminCredentialsMismatch\n\tErrInsecureClientRequest\n\tErrObjectTampered\n\t// Bucket Quota error codes\n\tErrAdminBucketQuotaExceeded\n\tErrAdminNoSuchQuotaConfiguration\n\n\tErrHealNotImplemented\n\tErrHealNoSuchProcess\n\tErrHealInvalidClientToken\n\tErrHealMissingBucket\n\tErrHealAlreadyRunning\n\tErrHealOverlappingPaths\n\tErrIncorrectContinuationToken\n\n\t// S3 Select Errors\n\tErrEmptyRequestBody\n\tErrUnsupportedFunction\n\tErrInvalidExpressionType\n\tErrBusy\n\tErrUnauthorizedAccess\n\tErrExpressionTooLong\n\tErrIllegalSQLFunctionArgument\n\tErrInvalidKeyPath\n\tErrInvalidCompressionFormat\n\tErrInvalidFileHeaderInfo\n\tErrInvalidJSONType\n\tErrInvalidQuoteFields\n\tErrInvalidRequestParameter\n\tErrInvalidDataType\n\tErrInvalidTextEncoding\n\tErrInvalidDataSource\n\tErrInvalidTableAlias\n\tErrMissingRequiredParameter\n\tErrObjectSerializationConflict\n\tErrUnsupportedSQLOperation\n\tErrUnsupportedSQLStructure\n\tErrUnsupportedSyntax\n\tErrUnsupportedRangeHeader\n\tErrLexerInvalidChar\n\tErrLexerInvalidOperator\n\tErrLexerInvalidLiteral\n\tErrLexerInvalidIONLiteral\n\tErrParseExpectedDatePart\n\tErrParseExpectedKeyword\n\tErrParseExpectedTokenType\n\tErrParseExpected2TokenTypes\n\tErrParseExpectedNumber\n\tErrParseExpectedRightParenBuiltinFunctionCall\n\tErrParseExpectedTypeName\n\tErrParseExpectedWhenClause\n\tErrParseUnsupportedToken\n\tErrParseUnsupportedLiteralsGroupBy\n\tErrParseExpectedMember\n\tErrParseUnsupportedSelect\n\tErrParseUnsupportedCase\n\tErrParseUnsupportedCaseClause\n\tErrParseUnsupportedAlias\n\tErrParseUnsupportedSyntax\n\tErrParseUnknownOperator\n\tErrParseMissingIdentAfterAt\n\tErrParseUnexpectedOperator\n\tErrParseUnexpectedTerm\n\tErrParseUnexpectedToken\n\tErrParseUnexpectedKeyword\n\tErrParseExpectedExpression\n\tErrParseExpectedLeftParenAfterCast\n\tErrParseExpectedLeftParenValueConstructor\n\tErrParseExpectedLeftParenBuiltinFunctionCall\n\tErrParseExpectedArgumentDelimiter\n\tErrParseCastArity\n\tErrParseInvalidTypeParam\n\tErrParseEmptySelect\n\tErrParseSelectMissingFrom\n\tErrParseExpectedIdentForGroupName\n\tErrParseExpectedIdentForAlias\n\tErrParseUnsupportedCallWithStar\n\tErrParseNonUnaryAgregateFunctionCall\n\tErrParseMalformedJoin\n\tErrParseExpectedIdentForAt\n\tErrParseAsteriskIsNotAloneInSelectList\n\tErrParseCannotMixSqbAndWildcardInSelectList\n\tErrParseInvalidContextForWildcardInSelectList\n\tErrIncorrectSQLFunctionArgumentType\n\tErrValueParseFailure\n\tErrEvaluatorInvalidArguments\n\tErrIntegerOverflow\n\tErrLikeInvalidInputs\n\tErrCastFailed\n\tErrInvalidCast\n\tErrEvaluatorInvalidTimestampFormatPattern\n\tErrEvaluatorInvalidTimestampFormatPatternSymbolForParsing\n\tErrEvaluatorTimestampFormatPatternDuplicateFields\n\tErrEvaluatorTimestampFormatPatternHourClockAmPmMismatch\n\tErrEvaluatorUnterminatedTimestampFormatPatternToken\n\tErrEvaluatorInvalidTimestampFormatPatternToken\n\tErrEvaluatorInvalidTimestampFormatPatternSymbol\n\tErrEvaluatorBindingDoesNotExist\n\tErrMissingHeaders\n\tErrInvalidColumnIndex\n\n\tErrAdminConfigNotificationTargetsFailed\n\tErrAdminProfilerNotEnabled\n\tErrInvalidDecompressedSize\n\tErrAddUserInvalidArgument\n\tErrAdminAccountNotEligible\n\tErrAccountNotEligible\n\tErrServiceAccountNotFound\n\tErrPostPolicyConditionInvalidFormat\n)\n\ntype errorCodeMap map[APIErrorCode]APIError\n\nfunc (e errorCodeMap) ToAPIErrWithErr(errCode APIErrorCode, err error) APIError {\n\tapiErr, ok := e[errCode]\n\tif !ok {\n\t\tapiErr = e[ErrInternalError]\n\t}\n\tif err != nil {\n\t\tapiErr.Description = fmt.Sprintf(\"%s (%s)\", apiErr.Description, err)\n\t}\n\treturn apiErr\n}\n\nfunc (e errorCodeMap) ToAPIErr(errCode APIErrorCode) APIError {\n\treturn e.ToAPIErrWithErr(errCode, nil)\n}\n\n// error code to APIError structure, these fields carry respective\n// descriptions for all the error responses.\nvar errorCodes = errorCodeMap{\n\tErrInvalidCopyDest: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"This copy request is illegal because it is trying to copy an object to itself without changing the object's metadata, storage class, website redirect location or encryption attributes.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCopySource: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Copy Source must mention the source bucket and key: sourcebucket/sourcekey.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidMetadataDirective: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Unknown metadata directive.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidStorageClass: {\n\t\tCode:           \"InvalidStorageClass\",\n\t\tDescription:    \"Invalid storage class.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRequestBody: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Body shouldn't be set for this request.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidMaxUploads: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Argument max-uploads must be an integer between 0 and 2147483647\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidMaxKeys: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Argument maxKeys must be an integer between 0 and 2147483647\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidEncodingMethod: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Invalid Encoding Method specified in Request\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidMaxParts: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Argument max-parts must be an integer between 0 and 2147483647\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidPartNumberMarker: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Argument partNumberMarker must be an integer.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidPartNumber: {\n\t\tCode:           \"InvalidPartNumber\",\n\t\tDescription:    \"The requested partnumber is not satisfiable\",\n\t\tHTTPStatusCode: http.StatusRequestedRangeNotSatisfiable,\n\t},\n\tErrInvalidPolicyDocument: {\n\t\tCode:           \"InvalidPolicyDocument\",\n\t\tDescription:    \"The content of the form does not meet the conditions specified in the policy document.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAccessDenied: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"Access Denied.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrBadDigest: {\n\t\tCode:           \"BadDigest\",\n\t\tDescription:    \"The Content-Md5 you specified did not match what we received.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEntityTooSmall: {\n\t\tCode:           \"EntityTooSmall\",\n\t\tDescription:    \"Your proposed upload is smaller than the minimum allowed object size.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEntityTooLarge: {\n\t\tCode:           \"EntityTooLarge\",\n\t\tDescription:    \"Your proposed upload exceeds the maximum allowed object size.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrPolicyTooLarge: {\n\t\tCode:           \"PolicyTooLarge\",\n\t\tDescription:    \"Policy exceeds the maximum allowed document size.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIncompleteBody: {\n\t\tCode:           \"IncompleteBody\",\n\t\tDescription:    \"You did not provide the number of bytes specified by the Content-Length HTTP header.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInternalError: {\n\t\tCode:           \"InternalError\",\n\t\tDescription:    \"We encountered an internal error, please try again.\",\n\t\tHTTPStatusCode: http.StatusInternalServerError,\n\t},\n\tErrInvalidAccessKeyID: {\n\t\tCode:           \"InvalidAccessKeyId\",\n\t\tDescription:    \"The Access Key Id you provided does not exist in our records.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrInvalidBucketName: {\n\t\tCode:           \"InvalidBucketName\",\n\t\tDescription:    \"The specified bucket is not valid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidDigest: {\n\t\tCode:           \"InvalidDigest\",\n\t\tDescription:    \"The Content-Md5 you specified is not valid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRange: {\n\t\tCode:           \"InvalidRange\",\n\t\tDescription:    \"The requested range is not satisfiable\",\n\t\tHTTPStatusCode: http.StatusRequestedRangeNotSatisfiable,\n\t},\n\tErrMalformedXML: {\n\t\tCode:           \"MalformedXML\",\n\t\tDescription:    \"The XML you provided was not well-formed or did not validate against our published schema.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingContentLength: {\n\t\tCode:           \"MissingContentLength\",\n\t\tDescription:    \"You must provide the Content-Length HTTP header.\",\n\t\tHTTPStatusCode: http.StatusLengthRequired,\n\t},\n\tErrMissingContentMD5: {\n\t\tCode:           \"MissingContentMD5\",\n\t\tDescription:    \"Missing required header for this request: Content-Md5.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSecurityHeader: {\n\t\tCode:           \"MissingSecurityHeader\",\n\t\tDescription:    \"Your request was missing a required header\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingRequestBodyError: {\n\t\tCode:           \"MissingRequestBodyError\",\n\t\tDescription:    \"Request body is empty.\",\n\t\tHTTPStatusCode: http.StatusLengthRequired,\n\t},\n\tErrNoSuchBucket: {\n\t\tCode:           \"NoSuchBucket\",\n\t\tDescription:    \"The specified bucket does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchBucketPolicy: {\n\t\tCode:           \"NoSuchBucketPolicy\",\n\t\tDescription:    \"The bucket policy does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchBucketLifecycle: {\n\t\tCode:           \"NoSuchBucketLifecycle\",\n\t\tDescription:    \"The bucket lifecycle configuration does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchLifecycleConfiguration: {\n\t\tCode:           \"NoSuchLifecycleConfiguration\",\n\t\tDescription:    \"The lifecycle configuration does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchBucketSSEConfig: {\n\t\tCode:           \"ServerSideEncryptionConfigurationNotFoundError\",\n\t\tDescription:    \"The server side encryption configuration was not found\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchKey: {\n\t\tCode:           \"NoSuchKey\",\n\t\tDescription:    \"The specified key does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchUpload: {\n\t\tCode:           \"NoSuchUpload\",\n\t\tDescription:    \"The specified multipart upload does not exist. The upload ID may be invalid, or the upload may have been aborted or completed.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrInvalidVersionID: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Invalid version id specified\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrNoSuchVersion: {\n\t\tCode:           \"NoSuchVersion\",\n\t\tDescription:    \"The specified version does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNotImplemented: {\n\t\tCode:           \"NotImplemented\",\n\t\tDescription:    \"A header you provided implies functionality that is not implemented\",\n\t\tHTTPStatusCode: http.StatusNotImplemented,\n\t},\n\tErrPreconditionFailed: {\n\t\tCode:           \"PreconditionFailed\",\n\t\tDescription:    \"At least one of the pre-conditions you specified did not hold\",\n\t\tHTTPStatusCode: http.StatusPreconditionFailed,\n\t},\n\tErrRequestTimeTooSkewed: {\n\t\tCode:           \"RequestTimeTooSkewed\",\n\t\tDescription:    \"The difference between the request time and the server's time is too large.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrSignatureDoesNotMatch: {\n\t\tCode:           \"SignatureDoesNotMatch\",\n\t\tDescription:    \"The request signature we calculated does not match the signature you provided. Check your key and signing method.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrMethodNotAllowed: {\n\t\tCode:           \"MethodNotAllowed\",\n\t\tDescription:    \"The specified method is not allowed against this resource.\",\n\t\tHTTPStatusCode: http.StatusMethodNotAllowed,\n\t},\n\tErrInvalidPart: {\n\t\tCode:           \"InvalidPart\",\n\t\tDescription:    \"One or more of the specified parts could not be found.  The part may not have been uploaded, or the specified entity tag may not match the part's entity tag.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidPartOrder: {\n\t\tCode:           \"InvalidPartOrder\",\n\t\tDescription:    \"The list of parts was not in ascending order. The parts list must be specified in order by part number.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidObjectState: {\n\t\tCode:           \"InvalidObjectState\",\n\t\tDescription:    \"The operation is not valid for the current state of the object.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrAuthorizationHeaderMalformed: {\n\t\tCode:           \"AuthorizationHeaderMalformed\",\n\t\tDescription:    \"The authorization header is malformed; the region is wrong; expecting 'us-east-1'.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedPOSTRequest: {\n\t\tCode:           \"MalformedPOSTRequest\",\n\t\tDescription:    \"The body of your POST request is not well-formed multipart/form-data.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrPOSTFileRequired: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"POST requires exactly one file upload per request.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrSignatureVersionNotSupported: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The authorization mechanism you have provided is not supported. Please use AWS4-HMAC-SHA256.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketNotEmpty: {\n\t\tCode:           \"BucketNotEmpty\",\n\t\tDescription:    \"The bucket you tried to delete is not empty\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrBucketAlreadyExists: {\n\t\tCode:           \"BucketAlreadyExists\",\n\t\tDescription:    \"The requested bucket name is not available. The bucket namespace is shared by all users of the system. Please select a different name and try again.\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrAllAccessDisabled: {\n\t\tCode:           \"AllAccessDisabled\",\n\t\tDescription:    \"All access to this bucket has been disabled.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrMalformedPolicy: {\n\t\tCode:           \"MalformedPolicy\",\n\t\tDescription:    \"Policy has invalid resource.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingFields: {\n\t\tCode:           \"MissingFields\",\n\t\tDescription:    \"Missing fields in request.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingCredTag: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Missing Credential field for this request.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrCredMalformed: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"Error parsing the X-Amz-Credential parameter; the Credential is mal-formed; expecting \\\"<YOUR-AKID>/YYYYMMDD/REGION/SERVICE/aws4_request\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedDate: {\n\t\tCode:           \"MalformedDate\",\n\t\tDescription:    \"Invalid date format header, expected to be in ISO8601, RFC1123 or RFC1123Z time format.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedPresignedDate: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Date must be in the ISO8601 Long Format \\\"yyyyMMdd'T'HHmmss'Z'\\\"\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedCredentialDate: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"Error parsing the X-Amz-Credential parameter; incorrect date format. This date in the credential must be in the format \\\"yyyyMMdd\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRegion: {\n\t\tCode:           \"InvalidRegion\",\n\t\tDescription:    \"Region does not match.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidServiceS3: {\n\t\tCode:           \"AuthorizationParametersError\",\n\t\tDescription:    \"Error parsing the Credential/X-Amz-Credential parameter; incorrect service. This endpoint belongs to \\\"s3\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidServiceSTS: {\n\t\tCode:           \"AuthorizationParametersError\",\n\t\tDescription:    \"Error parsing the Credential parameter; incorrect service. This endpoint belongs to \\\"sts\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRequestVersion: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"Error parsing the X-Amz-Credential parameter; incorrect terminal. This endpoint uses \\\"aws4_request\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSignTag: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"Signature header missing Signature field.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSignHeadersTag: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Signature header missing SignedHeaders field.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedExpires: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Expires should be a number\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrNegativeExpires: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Expires must be non-negative\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAuthHeaderEmpty: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Authorization header is invalid -- one and only one ' ' (space) required.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingDateHeader: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"AWS authentication requires a valid Date or x-amz-date header\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidQuerySignatureAlgo: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Algorithm only supports \\\"AWS4-HMAC-SHA256\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrExpiredPresignRequest: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"Request has expired\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrRequestNotReadyYet: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"Request is not valid yet\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrSlowDown: {\n\t\tCode:           \"SlowDown\",\n\t\tDescription:    \"Please reduce your request\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrInvalidPrefixMarker: {\n\t\tCode:           \"InvalidPrefixMarker\",\n\t\tDescription:    \"Invalid marker prefix combination\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBadRequest: {\n\t\tCode:           \"BadRequest\",\n\t\tDescription:    \"400 BadRequest\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrKeyTooLongError: {\n\t\tCode:           \"KeyTooLongError\",\n\t\tDescription:    \"Your key is too long\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsignedHeaders: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"There were headers present in the request which were not signed\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidQueryParams: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"Query-string authentication version 4 requires the X-Amz-Algorithm, X-Amz-Credential, X-Amz-Signature, X-Amz-Date, X-Amz-SignedHeaders, and X-Amz-Expires parameters.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketAlreadyOwnedByYou: {\n\t\tCode:           \"BucketAlreadyOwnedByYou\",\n\t\tDescription:    \"Your previous request to create the named bucket succeeded and you already own it.\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrInvalidDuration: {\n\t\tCode:           \"InvalidDuration\",\n\t\tDescription:    \"Duration provided in the request is invalid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidBucketObjectLockConfiguration: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Bucket is missing ObjectLockConfiguration\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketTaggingNotFound: {\n\t\tCode:           \"NoSuchTagSet\",\n\t\tDescription:    \"The TagSet does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrObjectLockConfigurationNotFound: {\n\t\tCode:           \"ObjectLockConfigurationNotFoundError\",\n\t\tDescription:    \"Object Lock configuration does not exist for this bucket\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrObjectLockConfigurationNotAllowed: {\n\t\tCode:           \"InvalidBucketState\",\n\t\tDescription:    \"Object Lock configuration cannot be enabled on existing buckets\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrNoSuchCORSConfiguration: {\n\t\tCode:           \"NoSuchCORSConfiguration\",\n\t\tDescription:    \"The CORS configuration does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchWebsiteConfiguration: {\n\t\tCode:           \"NoSuchWebsiteConfiguration\",\n\t\tDescription:    \"The specified bucket does not have a website configuration\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrReplicationConfigurationNotFoundError: {\n\t\tCode:           \"ReplicationConfigurationNotFoundError\",\n\t\tDescription:    \"The replication configuration was not found\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrRemoteDestinationNotFoundError: {\n\t\tCode:           \"RemoteDestinationNotFoundError\",\n\t\tDescription:    \"The remote destination bucket does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrReplicationDestinationMissingLock: {\n\t\tCode:           \"ReplicationDestinationMissingLockError\",\n\t\tDescription:    \"The replication destination bucket does not have object locking enabled\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrRemoteTargetNotFoundError: {\n\t\tCode:           \"XMinioAdminRemoteTargetNotFoundError\",\n\t\tDescription:    \"The remote target does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrReplicationRemoteConnectionError: {\n\t\tCode:           \"XMinioAdminReplicationRemoteConnectionError\",\n\t\tDescription:    \"Remote service connection error - please check remote service credentials and target bucket\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrBucketRemoteIdenticalToSource: {\n\t\tCode:           \"XMinioAdminRemoteIdenticalToSource\",\n\t\tDescription:    \"The remote target cannot be identical to source\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteAlreadyExists: {\n\t\tCode:           \"XMinioAdminBucketRemoteAlreadyExists\",\n\t\tDescription:    \"The remote target already exists\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteLabelInUse: {\n\t\tCode:           \"XMinioAdminBucketRemoteLabelInUse\",\n\t\tDescription:    \"The remote target with this label already exists\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteRemoveDisallowed: {\n\t\tCode:           \"XMinioAdminRemoteRemoveDisallowed\",\n\t\tDescription:    \"This ARN is in use by an existing configuration\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteArnTypeInvalid: {\n\t\tCode:           \"XMinioAdminRemoteARNTypeInvalid\",\n\t\tDescription:    \"The bucket remote ARN type is not valid\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteArnInvalid: {\n\t\tCode:           \"XMinioAdminRemoteArnInvalid\",\n\t\tDescription:    \"The bucket remote ARN does not have correct format\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrRemoteTargetNotVersionedError: {\n\t\tCode:           \"RemoteTargetNotVersionedError\",\n\t\tDescription:    \"The remote target does not have versioning enabled\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrReplicationSourceNotVersionedError: {\n\t\tCode:           \"ReplicationSourceNotVersionedError\",\n\t\tDescription:    \"The replication source does not have versioning enabled\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrReplicationNeedsVersioningError: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Versioning must be 'Enabled' on the bucket to apply a replication configuration\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrReplicationBucketNeedsVersioningError: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Versioning must be 'Enabled' on the bucket to add a replication target\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrNoSuchObjectLockConfiguration: {\n\t\tCode:           \"NoSuchObjectLockConfiguration\",\n\t\tDescription:    \"The specified object does not have a ObjectLock configuration\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectLocked: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Object is WORM protected and cannot be overwritten\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRetentionDate: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Date must be provided in ISO 8601 format\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrPastObjectLockRetainDate: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"the retain until date must be in the future\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnknownWORMModeDirective: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"unknown wormMode directive\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectLockInvalidHeaders: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"x-amz-object-lock-retain-until-date and x-amz-object-lock-mode must both be supplied\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectRestoreAlreadyInProgress: {\n\t\tCode:           \"RestoreAlreadyInProgress\",\n\t\tDescription:    \"Object restore is already in progress\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\t/// Bucket notification related errors.\n\tErrEventNotification: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"A specified event is not supported for notifications.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrARNNotification: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"A specified destination ARN does not exist or is not well-formed. Verify the destination ARN.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrRegionNotification: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"A specified destination is in a different region than the bucket. You must use a destination that resides in the same region as the bucket.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrOverlappingFilterNotification: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"An object key name filtering rule defined with overlapping prefixes, overlapping suffixes, or overlapping combinations of prefixes and suffixes for the same event types.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrFilterNameInvalid: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"filter rule name must be either prefix or suffix\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrFilterNamePrefix: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Cannot specify more than one prefix rule in a filter.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrFilterNameSuffix: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Cannot specify more than one suffix rule in a filter.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrFilterValueInvalid: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Size of filter rule value cannot exceed 1024 bytes in UTF-8 representation\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrOverlappingConfigs: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Configurations overlap. Configurations on the same bucket cannot share a common event type.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedNotification: {\n\t\tCode:           \"UnsupportedNotification\",\n\t\tDescription:    \"MinIO server does not support Topic or Cloud Function based notifications.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCopyPartRange: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The x-amz-copy-source-range value must be of the form bytes=first-last where first and last are the zero-based offsets of the first and last bytes to copy\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCopyPartRangeSource: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Range specified is not valid for source object\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMetadataTooLarge: {\n\t\tCode:           \"MetadataTooLarge\",\n\t\tDescription:    \"Your metadata headers exceed the maximum allowed metadata size.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidTagDirective: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Unknown tag directive.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidEncryptionMethod: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The encryption method specified is not supported\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInsecureSSECustomerRequest: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Requests specifying Server Side Encryption with Customer provided keys must be made over a secure connection.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrSSEMultipartEncrypted: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The multipart upload initiate requested encryption. Subsequent part requests must include the appropriate encryption parameters.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrSSEEncryptedObject: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The object was stored using a form of Server Side Encryption. The correct parameters must be provided to retrieve the object.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidEncryptionParameters: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The encryption parameters are not applicable to this object.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidSSECustomerAlgorithm: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Requests specifying Server Side Encryption with Customer provided keys must provide a valid encryption algorithm.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidSSECustomerKey: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The secret key was invalid for the specified algorithm.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSSECustomerKey: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Requests specifying Server Side Encryption with Customer provided keys must provide an appropriate secret key.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSSECustomerKeyMD5: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Requests specifying Server Side Encryption with Customer provided keys must provide the client calculated MD5 of the secret key.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrSSECustomerKeyMD5Mismatch: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The calculated MD5 hash of the key did not match the hash that was provided.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidSSECustomerParameters: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The provided encryption parameters did not match the ones used originally.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIncompatibleEncryptionMethod: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Server side encryption specified with both SSE-C and SSE-S3 headers\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrKMSNotConfigured: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Server side encryption specified but KMS is not configured\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrKMSAuthFailure: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Server side encryption specified but KMS authorization failed\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrNoAccessKey: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"No AWSAccessKey was presented\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrInvalidToken: {\n\t\tCode:           \"InvalidTokenId\",\n\t\tDescription:    \"The security token included in the request is invalid\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\n\t/// S3 extensions.\n\tErrContentSHA256Mismatch: {\n\t\tCode:           \"XAmzContentSHA256Mismatch\",\n\t\tDescription:    \"The provided 'x-amz-content-sha256' header does not match what was computed.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\n\t/// MinIO extensions.\n\tErrStorageFull: {\n\t\tCode:           \"XMinioStorageFull\",\n\t\tDescription:    \"Storage backend has reached its minimum free disk threshold. Please delete a few objects to proceed.\",\n\t\tHTTPStatusCode: http.StatusInsufficientStorage,\n\t},\n\tErrParentIsObject: {\n\t\tCode:           \"XMinioParentIsObject\",\n\t\tDescription:    \"Object-prefix is already an object, please choose a different object-prefix name.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrRequestBodyParse: {\n\t\tCode:           \"XMinioRequestBodyParse\",\n\t\tDescription:    \"The request body failed to parse.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectExistsAsDirectory: {\n\t\tCode:           \"XMinioObjectExistsAsDirectory\",\n\t\tDescription:    \"Object name already exists as a directory.\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrInvalidObjectName: {\n\t\tCode:           \"XMinioInvalidObjectName\",\n\t\tDescription:    \"Object name contains unsupported characters.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidObjectNamePrefixSlash: {\n\t\tCode:           \"XMinioInvalidObjectName\",\n\t\tDescription:    \"Object name contains a leading slash.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidResourceName: {\n\t\tCode:           \"XMinioInvalidResourceName\",\n\t\tDescription:    \"Resource name contains bad components such as \\\"..\\\" or \\\".\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrServerNotInitialized: {\n\t\tCode:           \"XMinioServerNotInitialized\",\n\t\tDescription:    \"Server not initialized, please try again.\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrMalformedJSON: {\n\t\tCode:           \"XMinioMalformedJSON\",\n\t\tDescription:    \"The JSON you provided was not well-formed or did not validate against our published format.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminNoSuchUser: {\n\t\tCode:           \"XMinioAdminNoSuchUser\",\n\t\tDescription:    \"The specified user does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrAdminNoSuchGroup: {\n\t\tCode:           \"XMinioAdminNoSuchGroup\",\n\t\tDescription:    \"The specified group does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrAdminGroupNotEmpty: {\n\t\tCode:           \"XMinioAdminGroupNotEmpty\",\n\t\tDescription:    \"The specified group is not empty - cannot remove it.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminNoSuchPolicy: {\n\t\tCode:           \"XMinioAdminNoSuchPolicy\",\n\t\tDescription:    \"The canned policy does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrAdminInvalidArgument: {\n\t\tCode:           \"XMinioAdminInvalidArgument\",\n\t\tDescription:    \"Invalid arguments specified.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminInvalidAccessKey: {\n\t\tCode:           \"XMinioAdminInvalidAccessKey\",\n\t\tDescription:    \"The access key is invalid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminInvalidSecretKey: {\n\t\tCode:           \"XMinioAdminInvalidSecretKey\",\n\t\tDescription:    \"The secret key is invalid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminConfigNoQuorum: {\n\t\tCode:           \"XMinioAdminConfigNoQuorum\",\n\t\tDescription:    \"Configuration update failed because server quorum was not met\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrAdminConfigTooLarge: {\n\t\tCode: \"XMinioAdminConfigTooLarge\",\n\t\tDescription: fmt.Sprintf(\"Configuration data provided exceeds the allowed maximum of %d bytes\",\n\t\t\tmaxEConfigJSONSize),\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminConfigBadJSON: {\n\t\tCode:           \"XMinioAdminConfigBadJSON\",\n\t\tDescription:    \"JSON configuration provided is of incorrect format\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminConfigDuplicateKeys: {\n\t\tCode:           \"XMinioAdminConfigDuplicateKeys\",\n\t\tDescription:    \"JSON configuration provided has objects with duplicate keys\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminConfigNotificationTargetsFailed: {\n\t\tCode:           \"XMinioAdminNotificationTargetsTestFailed\",\n\t\tDescription:    \"Configuration update failed due an unsuccessful attempt to connect to one or more notification servers\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminProfilerNotEnabled: {\n\t\tCode:           \"XMinioAdminProfilerNotEnabled\",\n\t\tDescription:    \"Unable to perform the requested operation because profiling is not enabled\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminCredentialsMismatch: {\n\t\tCode:           \"XMinioAdminCredentialsMismatch\",\n\t\tDescription:    \"Credentials in config mismatch with server environment variables\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrAdminBucketQuotaExceeded: {\n\t\tCode:           \"XMinioAdminBucketQuotaExceeded\",\n\t\tDescription:    \"Bucket quota exceeded\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminNoSuchQuotaConfiguration: {\n\t\tCode:           \"XMinioAdminNoSuchQuotaConfiguration\",\n\t\tDescription:    \"The quota configuration does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrInsecureClientRequest: {\n\t\tCode:           \"XMinioInsecureClientRequest\",\n\t\tDescription:    \"Cannot respond to plain-text request from TLS-encrypted server\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrOperationTimedOut: {\n\t\tCode:           \"RequestTimeout\",\n\t\tDescription:    \"A timeout occurred while trying to lock a resource, please reduce your request rate\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrClientDisconnected: {\n\t\tCode:           \"ClientDisconnected\",\n\t\tDescription:    \"Client disconnected before response was ready\",\n\t\tHTTPStatusCode: 499, // No official code, use nginx value.\n\t},\n\tErrOperationMaxedOut: {\n\t\tCode:           \"SlowDown\",\n\t\tDescription:    \"A timeout exceeded while waiting to proceed with the request, please reduce your request rate\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrUnsupportedMetadata: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Your metadata headers are not supported.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectTampered: {\n\t\tCode:           \"XMinioObjectTampered\",\n\t\tDescription:    errObjectTampered.Error(),\n\t\tHTTPStatusCode: http.StatusPartialContent,\n\t},\n\tErrMaximumExpires: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Expires must be less than a week (in seconds); that is, the given X-Amz-Expires must be less than 604800 seconds\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\n\t// Generic Invalid-Request error. Should be used for response errors only for unlikely\n\t// corner case errors for which introducing new APIErrorCode is not worth it. LogIf()\n\t// should be used to log the error at the source of the error for debugging purposes.\n\tErrInvalidRequest: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Invalid Request\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealNotImplemented: {\n\t\tCode:           \"XMinioHealNotImplemented\",\n\t\tDescription:    \"This server does not implement heal functionality.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealNoSuchProcess: {\n\t\tCode:           \"XMinioHealNoSuchProcess\",\n\t\tDescription:    \"No such heal process is running on the server\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealInvalidClientToken: {\n\t\tCode:           \"XMinioHealInvalidClientToken\",\n\t\tDescription:    \"Client token mismatch\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealMissingBucket: {\n\t\tCode:           \"XMinioHealMissingBucket\",\n\t\tDescription:    \"A heal start request with a non-empty object-prefix parameter requires a bucket to be specified.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealAlreadyRunning: {\n\t\tCode:           \"XMinioHealAlreadyRunning\",\n\t\tDescription:    \"\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealOverlappingPaths: {\n\t\tCode:           \"XMinioHealOverlappingPaths\",\n\t\tDescription:    \"\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBackendDown: {\n\t\tCode:           \"XMinioBackendDown\",\n\t\tDescription:    \"Object storage backend is unreachable\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrIncorrectContinuationToken: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The continuation token provided is incorrect\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\t//S3 Select API Errors\n\tErrEmptyRequestBody: {\n\t\tCode:           \"EmptyRequestBody\",\n\t\tDescription:    \"Request body cannot be empty.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedFunction: {\n\t\tCode:           \"UnsupportedFunction\",\n\t\tDescription:    \"Encountered an unsupported SQL function.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidDataSource: {\n\t\tCode:           \"InvalidDataSource\",\n\t\tDescription:    \"Invalid data source type. Only CSV and JSON are supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidExpressionType: {\n\t\tCode:           \"InvalidExpressionType\",\n\t\tDescription:    \"The ExpressionType is invalid. Only SQL expressions are supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBusy: {\n\t\tCode:           \"Busy\",\n\t\tDescription:    \"The service is unavailable. Please retry.\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrUnauthorizedAccess: {\n\t\tCode:           \"UnauthorizedAccess\",\n\t\tDescription:    \"You are not authorized to perform this operation\",\n\t\tHTTPStatusCode: http.StatusUnauthorized,\n\t},\n\tErrExpressionTooLong: {\n\t\tCode:           \"ExpressionTooLong\",\n\t\tDescription:    \"The SQL expression is too long: The maximum byte-length for the SQL expression is 256 KB.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIllegalSQLFunctionArgument: {\n\t\tCode:           \"IllegalSqlFunctionArgument\",\n\t\tDescription:    \"Illegal argument was used in the SQL function.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidKeyPath: {\n\t\tCode:           \"InvalidKeyPath\",\n\t\tDescription:    \"Key path in the SQL expression is invalid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCompressionFormat: {\n\t\tCode:           \"InvalidCompressionFormat\",\n\t\tDescription:    \"The file is not in a supported compression format. Only GZIP is supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidFileHeaderInfo: {\n\t\tCode:           \"InvalidFileHeaderInfo\",\n\t\tDescription:    \"The FileHeaderInfo is invalid. Only NONE, USE, and IGNORE are supported.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidJSONType: {\n\t\tCode:           \"InvalidJsonType\",\n\t\tDescription:    \"The JsonType is invalid. Only DOCUMENT and LINES are supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidQuoteFields: {\n\t\tCode:           \"InvalidQuoteFields\",\n\t\tDescription:    \"The QuoteFields is invalid. Only ALWAYS and ASNEEDED are supported.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRequestParameter: {\n\t\tCode:           \"InvalidRequestParameter\",\n\t\tDescription:    \"The value of a parameter in SelectRequest element is invalid. Check the service API documentation and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidDataType: {\n\t\tCode:           \"InvalidDataType\",\n\t\tDescription:    \"The SQL expression contains an invalid data type.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidTextEncoding: {\n\t\tCode:           \"InvalidTextEncoding\",\n\t\tDescription:    \"Invalid encoding type. Only UTF-8 encoding is supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidTableAlias: {\n\t\tCode:           \"InvalidTableAlias\",\n\t\tDescription:    \"The SQL expression contains an invalid table alias.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingRequiredParameter: {\n\t\tCode:           \"MissingRequiredParameter\",\n\t\tDescription:    \"The SelectRequest entity is missing a required parameter. Check the service documentation and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectSerializationConflict: {\n\t\tCode:           \"ObjectSerializationConflict\",\n\t\tDescription:    \"The SelectRequest entity can only contain one of CSV or JSON. Check the service documentation and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedSQLOperation: {\n\t\tCode:           \"UnsupportedSqlOperation\",\n\t\tDescription:    \"Encountered an unsupported SQL operation.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedSQLStructure: {\n\t\tCode:           \"UnsupportedSqlStructure\",\n\t\tDescription:    \"Encountered an unsupported SQL structure. Check the SQL Reference.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedSyntax: {\n\t\tCode:           \"UnsupportedSyntax\",\n\t\tDescription:    \"Encountered invalid syntax.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedRangeHeader: {\n\t\tCode:           \"UnsupportedRangeHeader\",\n\t\tDescription:    \"Range header is not supported for this operation.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLexerInvalidChar: {\n\t\tCode:           \"LexerInvalidChar\",\n\t\tDescription:    \"The SQL expression contains an invalid character.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLexerInvalidOperator: {\n\t\tCode:           \"LexerInvalidOperator\",\n\t\tDescription:    \"The SQL expression contains an invalid literal.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLexerInvalidLiteral: {\n\t\tCode:           \"LexerInvalidLiteral\",\n\t\tDescription:    \"The SQL expression contains an invalid operator.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLexerInvalidIONLiteral: {\n\t\tCode:           \"LexerInvalidIONLiteral\",\n\t\tDescription:    \"The SQL expression contains an invalid operator.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedDatePart: {\n\t\tCode:           \"ParseExpectedDatePart\",\n\t\tDescription:    \"Did not find the expected date part in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedKeyword: {\n\t\tCode:           \"ParseExpectedKeyword\",\n\t\tDescription:    \"Did not find the expected keyword in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedTokenType: {\n\t\tCode:           \"ParseExpectedTokenType\",\n\t\tDescription:    \"Did not find the expected token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpected2TokenTypes: {\n\t\tCode:           \"ParseExpected2TokenTypes\",\n\t\tDescription:    \"Did not find the expected token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedNumber: {\n\t\tCode:           \"ParseExpectedNumber\",\n\t\tDescription:    \"Did not find the expected number in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedRightParenBuiltinFunctionCall: {\n\t\tCode:           \"ParseExpectedRightParenBuiltinFunctionCall\",\n\t\tDescription:    \"Did not find the expected right parenthesis character in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedTypeName: {\n\t\tCode:           \"ParseExpectedTypeName\",\n\t\tDescription:    \"Did not find the expected type name in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedWhenClause: {\n\t\tCode:           \"ParseExpectedWhenClause\",\n\t\tDescription:    \"Did not find the expected WHEN clause in the SQL expression. CASE is not supported.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedToken: {\n\t\tCode:           \"ParseUnsupportedToken\",\n\t\tDescription:    \"The SQL expression contains an unsupported token.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedLiteralsGroupBy: {\n\t\tCode:           \"ParseUnsupportedLiteralsGroupBy\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of GROUP BY.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedMember: {\n\t\tCode:           \"ParseExpectedMember\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of MEMBER.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedSelect: {\n\t\tCode:           \"ParseUnsupportedSelect\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of SELECT.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedCase: {\n\t\tCode:           \"ParseUnsupportedCase\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of CASE.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedCaseClause: {\n\t\tCode:           \"ParseUnsupportedCaseClause\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of CASE.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedAlias: {\n\t\tCode:           \"ParseUnsupportedAlias\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of ALIAS.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedSyntax: {\n\t\tCode:           \"ParseUnsupportedSyntax\",\n\t\tDescription:    \"The SQL expression contains unsupported syntax.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnknownOperator: {\n\t\tCode:           \"ParseUnknownOperator\",\n\t\tDescription:    \"The SQL expression contains an invalid operator.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseMissingIdentAfterAt: {\n\t\tCode:           \"ParseMissingIdentAfterAt\",\n\t\tDescription:    \"Did not find the expected identifier after the @ symbol in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnexpectedOperator: {\n\t\tCode:           \"ParseUnexpectedOperator\",\n\t\tDescription:    \"The SQL expression contains an unexpected operator.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnexpectedTerm: {\n\t\tCode:           \"ParseUnexpectedTerm\",\n\t\tDescription:    \"The SQL expression contains an unexpected term.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnexpectedToken: {\n\t\tCode:           \"ParseUnexpectedToken\",\n\t\tDescription:    \"The SQL expression contains an unexpected token.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnexpectedKeyword: {\n\t\tCode:           \"ParseUnexpectedKeyword\",\n\t\tDescription:    \"The SQL expression contains an unexpected keyword.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedExpression: {\n\t\tCode:           \"ParseExpectedExpression\",\n\t\tDescription:    \"Did not find the expected SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedLeftParenAfterCast: {\n\t\tCode:           \"ParseExpectedLeftParenAfterCast\",\n\t\tDescription:    \"Did not find expected the left parenthesis in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedLeftParenValueConstructor: {\n\t\tCode:           \"ParseExpectedLeftParenValueConstructor\",\n\t\tDescription:    \"Did not find expected the left parenthesis in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedLeftParenBuiltinFunctionCall: {\n\t\tCode:           \"ParseExpectedLeftParenBuiltinFunctionCall\",\n\t\tDescription:    \"Did not find the expected left parenthesis in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedArgumentDelimiter: {\n\t\tCode:           \"ParseExpectedArgumentDelimiter\",\n\t\tDescription:    \"Did not find the expected argument delimiter in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseCastArity: {\n\t\tCode:           \"ParseCastArity\",\n\t\tDescription:    \"The SQL expression CAST has incorrect arity.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseInvalidTypeParam: {\n\t\tCode:           \"ParseInvalidTypeParam\",\n\t\tDescription:    \"The SQL expression contains an invalid parameter value.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseEmptySelect: {\n\t\tCode:           \"ParseEmptySelect\",\n\t\tDescription:    \"The SQL expression contains an empty SELECT.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseSelectMissingFrom: {\n\t\tCode:           \"ParseSelectMissingFrom\",\n\t\tDescription:    \"GROUP is not supported in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedIdentForGroupName: {\n\t\tCode:           \"ParseExpectedIdentForGroupName\",\n\t\tDescription:    \"GROUP is not supported in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedIdentForAlias: {\n\t\tCode:           \"ParseExpectedIdentForAlias\",\n\t\tDescription:    \"Did not find the expected identifier for the alias in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedCallWithStar: {\n\t\tCode:           \"ParseUnsupportedCallWithStar\",\n\t\tDescription:    \"Only COUNT with (*) as a parameter is supported in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseNonUnaryAgregateFunctionCall: {\n\t\tCode:           \"ParseNonUnaryAgregateFunctionCall\",\n\t\tDescription:    \"Only one argument is supported for aggregate functions in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseMalformedJoin: {\n\t\tCode:           \"ParseMalformedJoin\",\n\t\tDescription:    \"JOIN is not supported in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedIdentForAt: {\n\t\tCode:           \"ParseExpectedIdentForAt\",\n\t\tDescription:    \"Did not find the expected identifier for AT name in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseAsteriskIsNotAloneInSelectList: {\n\t\tCode:           \"ParseAsteriskIsNotAloneInSelectList\",\n\t\tDescription:    \"Other expressions are not allowed in the SELECT list when '*' is used without dot notation in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseCannotMixSqbAndWildcardInSelectList: {\n\t\tCode:           \"ParseCannotMixSqbAndWildcardInSelectList\",\n\t\tDescription:    \"Cannot mix [] and * in the same expression in a SELECT list in SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseInvalidContextForWildcardInSelectList: {\n\t\tCode:           \"ParseInvalidContextForWildcardInSelectList\",\n\t\tDescription:    \"Invalid use of * in SELECT list in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIncorrectSQLFunctionArgumentType: {\n\t\tCode:           \"IncorrectSqlFunctionArgumentType\",\n\t\tDescription:    \"Incorrect type of arguments in function call in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrValueParseFailure: {\n\t\tCode:           \"ValueParseFailure\",\n\t\tDescription:    \"Time stamp parse failure in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidArguments: {\n\t\tCode:           \"EvaluatorInvalidArguments\",\n\t\tDescription:    \"Incorrect number of arguments in the function call in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIntegerOverflow: {\n\t\tCode:           \"IntegerOverflow\",\n\t\tDescription:    \"Int overflow or underflow in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLikeInvalidInputs: {\n\t\tCode:           \"LikeInvalidInputs\",\n\t\tDescription:    \"Invalid argument given to the LIKE clause in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrCastFailed: {\n\t\tCode:           \"CastFailed\",\n\t\tDescription:    \"Attempt to convert from one data type to another using CAST failed in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCast: {\n\t\tCode:           \"InvalidCast\",\n\t\tDescription:    \"Attempt to convert from one data type to another using CAST failed in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidTimestampFormatPattern: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPattern\",\n\t\tDescription:    \"Time stamp format pattern requires additional fields in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidTimestampFormatPatternSymbolForParsing: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPatternSymbolForParsing\",\n\t\tDescription:    \"Time stamp format pattern contains a valid format symbol that cannot be applied to time stamp parsing in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorTimestampFormatPatternDuplicateFields: {\n\t\tCode:           \"EvaluatorTimestampFormatPatternDuplicateFields\",\n\t\tDescription:    \"Time stamp format pattern contains multiple format specifiers representing the time stamp field in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorTimestampFormatPatternHourClockAmPmMismatch: {\n\t\tCode:           \"EvaluatorUnterminatedTimestampFormatPatternToken\",\n\t\tDescription:    \"Time stamp format pattern contains unterminated token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorUnterminatedTimestampFormatPatternToken: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPatternToken\",\n\t\tDescription:    \"Time stamp format pattern contains an invalid token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidTimestampFormatPatternToken: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPatternToken\",\n\t\tDescription:    \"Time stamp format pattern contains an invalid token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidTimestampFormatPatternSymbol: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPatternSymbol\",\n\t\tDescription:    \"Time stamp format pattern contains an invalid symbol in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorBindingDoesNotExist: {\n\t\tCode:           \"ErrEvaluatorBindingDoesNotExist\",\n\t\tDescription:    \"A column name or a path provided does not exist in the SQL expression\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingHeaders: {\n\t\tCode:           \"MissingHeaders\",\n\t\tDescription:    \"Some headers in the query are missing from the file. Check the file and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidColumnIndex: {\n\t\tCode:           \"InvalidColumnIndex\",\n\t\tDescription:    \"The column index is invalid. Please check the service documentation and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidDecompressedSize: {\n\t\tCode:           \"XMinioInvalidDecompressedSize\",\n\t\tDescription:    \"The data provided is unfit for decompression\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAddUserInvalidArgument: {\n\t\tCode:           \"XMinioInvalidIAMCredentials\",\n\t\tDescription:    \"User is not allowed to be same as admin access key\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrAdminAccountNotEligible: {\n\t\tCode:           \"XMinioInvalidIAMCredentials\",\n\t\tDescription:    \"The administrator key is not eligible for this operation\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrAccountNotEligible: {\n\t\tCode:           \"XMinioInvalidIAMCredentials\",\n\t\tDescription:    \"The account key is not eligible for this operation\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrServiceAccountNotFound: {\n\t\tCode:           \"XMinioInvalidIAMCredentials\",\n\t\tDescription:    \"The specified service account is not found\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrPostPolicyConditionInvalidFormat: {\n\t\tCode:           \"PostPolicyInvalidKeyName\",\n\t\tDescription:    \"Invalid according to Policy: Policy Condition failed\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\t// Add your error structure here.\n}\n\n// toAPIErrorCode - Converts embedded errors. Convenience\n// function written to handle all cases where we have known types of\n// errors returned by underlying layers.\nfunc toAPIErrorCode(ctx context.Context, err error) (apiErr APIErrorCode) {\n\tif err == nil {\n\t\treturn ErrNone\n\t}\n\n\t// Only return ErrClientDisconnected if the provided context is actually canceled.\n\t// This way downstream context.Canceled will still report ErrOperationTimedOut\n\tselect {\n\tcase <-ctx.Done():\n\t\tif ctx.Err() == context.Canceled {\n\t\t\treturn ErrClientDisconnected\n\t\t}\n\tdefault:\n\t}\n\n\tswitch err {\n\tcase errInvalidArgument:\n\t\tapiErr = ErrAdminInvalidArgument\n\tcase errNoSuchUser:\n\t\tapiErr = ErrAdminNoSuchUser\n\tcase errNoSuchGroup:\n\t\tapiErr = ErrAdminNoSuchGroup\n\tcase errGroupNotEmpty:\n\t\tapiErr = ErrAdminGroupNotEmpty\n\tcase errNoSuchPolicy:\n\t\tapiErr = ErrAdminNoSuchPolicy\n\tcase errSignatureMismatch:\n\t\tapiErr = ErrSignatureDoesNotMatch\n\tcase errInvalidRange:\n\t\tapiErr = ErrInvalidRange\n\tcase errDataTooLarge:\n\t\tapiErr = ErrEntityTooLarge\n\tcase errDataTooSmall:\n\t\tapiErr = ErrEntityTooSmall\n\tcase errAuthentication:\n\t\tapiErr = ErrAccessDenied\n\tcase auth.ErrInvalidAccessKeyLength:\n\t\tapiErr = ErrAdminInvalidAccessKey\n\tcase auth.ErrInvalidSecretKeyLength:\n\t\tapiErr = ErrAdminInvalidSecretKey\n\t// SSE errors\n\tcase errInvalidEncryptionParameters:\n\t\tapiErr = ErrInvalidEncryptionParameters\n\tcase crypto.ErrInvalidEncryptionMethod:\n\t\tapiErr = ErrInvalidEncryptionMethod\n\tcase crypto.ErrInvalidCustomerAlgorithm:\n\t\tapiErr = ErrInvalidSSECustomerAlgorithm\n\tcase crypto.ErrMissingCustomerKey:\n\t\tapiErr = ErrMissingSSECustomerKey\n\tcase crypto.ErrMissingCustomerKeyMD5:\n\t\tapiErr = ErrMissingSSECustomerKeyMD5\n\tcase crypto.ErrCustomerKeyMD5Mismatch:\n\t\tapiErr = ErrSSECustomerKeyMD5Mismatch\n\tcase errObjectTampered:\n\t\tapiErr = ErrObjectTampered\n\tcase errEncryptedObject:\n\t\tapiErr = ErrSSEEncryptedObject\n\tcase errInvalidSSEParameters:\n\t\tapiErr = ErrInvalidSSECustomerParameters\n\tcase crypto.ErrInvalidCustomerKey, crypto.ErrSecretKeyMismatch:\n\t\tapiErr = ErrAccessDenied // no access without correct key\n\tcase crypto.ErrIncompatibleEncryptionMethod:\n\t\tapiErr = ErrIncompatibleEncryptionMethod\n\tcase errKMSNotConfigured:\n\t\tapiErr = ErrKMSNotConfigured\n\tcase crypto.ErrKMSAuthLogin:\n\t\tapiErr = ErrKMSAuthFailure\n\tcase context.Canceled, context.DeadlineExceeded:\n\t\tapiErr = ErrOperationTimedOut\n\tcase errDiskNotFound:\n\t\tapiErr = ErrSlowDown\n\tcase objectlock.ErrInvalidRetentionDate:\n\t\tapiErr = ErrInvalidRetentionDate\n\tcase objectlock.ErrPastObjectLockRetainDate:\n\t\tapiErr = ErrPastObjectLockRetainDate\n\tcase objectlock.ErrUnknownWORMModeDirective:\n\t\tapiErr = ErrUnknownWORMModeDirective\n\tcase objectlock.ErrObjectLockInvalidHeaders:\n\t\tapiErr = ErrObjectLockInvalidHeaders\n\tcase objectlock.ErrMalformedXML:\n\t\tapiErr = ErrMalformedXML\n\t}\n\n\t// Compression errors\n\tswitch err {\n\tcase errInvalidDecompressedSize:\n\t\tapiErr = ErrInvalidDecompressedSize\n\t}\n\n\tif apiErr != ErrNone {\n\t\t// If there was a match in the above switch case.\n\t\treturn apiErr\n\t}\n\n\t// etcd specific errors, a key is always a bucket for us return\n\t// ErrNoSuchBucket in such a case.\n\tif err == dns.ErrNoEntriesFound {\n\t\treturn ErrNoSuchBucket\n\t}\n\n\tswitch err.(type) {\n\tcase StorageFull:\n\t\tapiErr = ErrStorageFull\n\tcase hash.BadDigest:\n\t\tapiErr = ErrBadDigest\n\tcase AllAccessDisabled:\n\t\tapiErr = ErrAllAccessDisabled\n\tcase IncompleteBody:\n\t\tapiErr = ErrIncompleteBody\n\tcase ObjectExistsAsDirectory:\n\t\tapiErr = ErrObjectExistsAsDirectory\n\tcase PrefixAccessDenied:\n\t\tapiErr = ErrAccessDenied\n\tcase ParentIsObject:\n\t\tapiErr = ErrParentIsObject\n\tcase BucketNameInvalid:\n\t\tapiErr = ErrInvalidBucketName\n\tcase BucketNotFound:\n\t\tapiErr = ErrNoSuchBucket\n\tcase BucketAlreadyOwnedByYou:\n\t\tapiErr = ErrBucketAlreadyOwnedByYou\n\tcase BucketNotEmpty:\n\t\tapiErr = ErrBucketNotEmpty\n\tcase BucketAlreadyExists:\n\t\tapiErr = ErrBucketAlreadyExists\n\tcase BucketExists:\n\t\tapiErr = ErrBucketAlreadyOwnedByYou\n\tcase ObjectNotFound:\n\t\tapiErr = ErrNoSuchKey\n\tcase MethodNotAllowed:\n\t\tapiErr = ErrMethodNotAllowed\n\tcase InvalidVersionID:\n\t\tapiErr = ErrInvalidVersionID\n\tcase VersionNotFound:\n\t\tapiErr = ErrNoSuchVersion\n\tcase ObjectAlreadyExists:\n\t\tapiErr = ErrMethodNotAllowed\n\tcase ObjectNameInvalid:\n\t\tapiErr = ErrInvalidObjectName\n\tcase ObjectNamePrefixAsSlash:\n\t\tapiErr = ErrInvalidObjectNamePrefixSlash\n\tcase InvalidUploadID:\n\t\tapiErr = ErrNoSuchUpload\n\tcase InvalidPart:\n\t\tapiErr = ErrInvalidPart\n\tcase InsufficientWriteQuorum:\n\t\tapiErr = ErrSlowDown\n\tcase InsufficientReadQuorum:\n\t\tapiErr = ErrSlowDown\n\tcase UnsupportedDelimiter:\n\t\tapiErr = ErrNotImplemented\n\tcase InvalidMarkerPrefixCombination:\n\t\tapiErr = ErrNotImplemented\n\tcase InvalidUploadIDKeyCombination:\n\t\tapiErr = ErrNotImplemented\n\tcase MalformedUploadID:\n\t\tapiErr = ErrNoSuchUpload\n\tcase PartTooSmall:\n\t\tapiErr = ErrEntityTooSmall\n\tcase SignatureDoesNotMatch:\n\t\tapiErr = ErrSignatureDoesNotMatch\n\tcase hash.SHA256Mismatch:\n\t\tapiErr = ErrContentSHA256Mismatch\n\tcase ObjectTooLarge:\n\t\tapiErr = ErrEntityTooLarge\n\tcase ObjectTooSmall:\n\t\tapiErr = ErrEntityTooSmall\n\tcase NotImplemented:\n\t\tapiErr = ErrNotImplemented\n\tcase PartTooBig:\n\t\tapiErr = ErrEntityTooLarge\n\tcase UnsupportedMetadata:\n\t\tapiErr = ErrUnsupportedMetadata\n\tcase BucketPolicyNotFound:\n\t\tapiErr = ErrNoSuchBucketPolicy\n\tcase BucketLifecycleNotFound:\n\t\tapiErr = ErrNoSuchLifecycleConfiguration\n\tcase BucketSSEConfigNotFound:\n\t\tapiErr = ErrNoSuchBucketSSEConfig\n\tcase BucketTaggingNotFound:\n\t\tapiErr = ErrBucketTaggingNotFound\n\tcase BucketObjectLockConfigNotFound:\n\t\tapiErr = ErrObjectLockConfigurationNotFound\n\tcase BucketQuotaConfigNotFound:\n\t\tapiErr = ErrAdminNoSuchQuotaConfiguration\n\tcase BucketReplicationConfigNotFound:\n\t\tapiErr = ErrReplicationConfigurationNotFoundError\n\tcase BucketRemoteDestinationNotFound:\n\t\tapiErr = ErrRemoteDestinationNotFoundError\n\tcase BucketReplicationDestinationMissingLock:\n\t\tapiErr = ErrReplicationDestinationMissingLock\n\tcase BucketRemoteTargetNotFound:\n\t\tapiErr = ErrRemoteTargetNotFoundError\n\tcase BucketRemoteConnectionErr:\n\t\tapiErr = ErrReplicationRemoteConnectionError\n\tcase BucketRemoteAlreadyExists:\n\t\tapiErr = ErrBucketRemoteAlreadyExists\n\tcase BucketRemoteLabelInUse:\n\t\tapiErr = ErrBucketRemoteLabelInUse\n\tcase BucketRemoteArnTypeInvalid:\n\t\tapiErr = ErrBucketRemoteArnTypeInvalid\n\tcase BucketRemoteArnInvalid:\n\t\tapiErr = ErrBucketRemoteArnInvalid\n\tcase BucketRemoteRemoveDisallowed:\n\t\tapiErr = ErrBucketRemoteRemoveDisallowed\n\tcase BucketRemoteTargetNotVersioned:\n\t\tapiErr = ErrRemoteTargetNotVersionedError\n\tcase BucketReplicationSourceNotVersioned:\n\t\tapiErr = ErrReplicationSourceNotVersionedError\n\tcase BucketQuotaExceeded:\n\t\tapiErr = ErrAdminBucketQuotaExceeded\n\tcase *event.ErrInvalidEventName:\n\t\tapiErr = ErrEventNotification\n\tcase *event.ErrInvalidARN:\n\t\tapiErr = ErrARNNotification\n\tcase *event.ErrARNNotFound:\n\t\tapiErr = ErrARNNotification\n\tcase *event.ErrUnknownRegion:\n\t\tapiErr = ErrRegionNotification\n\tcase *event.ErrInvalidFilterName:\n\t\tapiErr = ErrFilterNameInvalid\n\tcase *event.ErrFilterNamePrefix:\n\t\tapiErr = ErrFilterNamePrefix\n\tcase *event.ErrFilterNameSuffix:\n\t\tapiErr = ErrFilterNameSuffix\n\tcase *event.ErrInvalidFilterValue:\n\t\tapiErr = ErrFilterValueInvalid\n\tcase *event.ErrDuplicateEventName:\n\t\tapiErr = ErrOverlappingConfigs\n\tcase *event.ErrDuplicateQueueConfiguration:\n\t\tapiErr = ErrOverlappingFilterNotification\n\tcase *event.ErrUnsupportedConfiguration:\n\t\tapiErr = ErrUnsupportedNotification\n\tcase OperationTimedOut:\n\t\tapiErr = ErrOperationTimedOut\n\tcase BackendDown:\n\t\tapiErr = ErrBackendDown\n\tcase ObjectNameTooLong:\n\t\tapiErr = ErrKeyTooLongError\n\tcase dns.ErrInvalidBucketName:\n\t\tapiErr = ErrInvalidBucketName\n\tdefault:\n\t\tvar ie, iw int\n\t\t// This work-around is to handle the issue golang/go#30648\n\t\tif _, ferr := fmt.Fscanf(strings.NewReader(err.Error()),\n\t\t\t\"request declared a Content-Length of %d but only wrote %d bytes\",\n\t\t\t&ie, &iw); ferr != nil {\n\t\t\tapiErr = ErrInternalError\n\t\t\t// Make sure to log the errors which we cannot translate\n\t\t\t// to a meaningful S3 API errors. This is added to aid in\n\t\t\t// debugging unexpected/unhandled errors.\n\t\t\tlogger.LogIf(ctx, err)\n\t\t} else if ie > iw {\n\t\t\tapiErr = ErrIncompleteBody\n\t\t} else {\n\t\t\tapiErr = ErrInternalError\n\t\t\t// Make sure to log the errors which we cannot translate\n\t\t\t// to a meaningful S3 API errors. This is added to aid in\n\t\t\t// debugging unexpected/unhandled errors.\n\t\t\tlogger.LogIf(ctx, err)\n\t\t}\n\t}\n\n\treturn apiErr\n}\n\nvar noError = APIError{}\n\n// toAPIError - Converts embedded errors. Convenience\n// function written to handle all cases where we have known types of\n// errors returned by underlying layers.\nfunc toAPIError(ctx context.Context, err error) APIError {\n\tif err == nil {\n\t\treturn noError\n\t}\n\n\tvar apiErr = errorCodes.ToAPIErr(toAPIErrorCode(ctx, err))\n\te, ok := err.(dns.ErrInvalidBucketName)\n\tif ok {\n\t\tcode := toAPIErrorCode(ctx, e)\n\t\tapiErr = errorCodes.ToAPIErrWithErr(code, e)\n\t}\n\n\tif apiErr.Code == \"InternalError\" {\n\t\t// If we see an internal error try to interpret\n\t\t// any underlying errors if possible depending on\n\t\t// their internal error types. This code is only\n\t\t// useful with gateway implementations.\n\t\tswitch e := err.(type) {\n\t\tcase InvalidArgument:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"InvalidArgument\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: errorCodes[ErrInvalidRequest].HTTPStatusCode,\n\t\t\t}\n\t\tcase *xml.SyntaxError:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode: \"MalformedXML\",\n\t\t\t\tDescription: fmt.Sprintf(\"%s (%s)\", errorCodes[ErrMalformedXML].Description,\n\t\t\t\t\te.Error()),\n\t\t\t\tHTTPStatusCode: errorCodes[ErrMalformedXML].HTTPStatusCode,\n\t\t\t}\n\t\tcase url.EscapeError:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode: \"XMinioInvalidObjectName\",\n\t\t\t\tDescription: fmt.Sprintf(\"%s (%s)\", errorCodes[ErrInvalidObjectName].Description,\n\t\t\t\t\te.Error()),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase versioning.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"IllegalVersioningConfigurationException\",\n\t\t\t\tDescription:    fmt.Sprintf(\"Versioning configuration specified in the request is invalid. (%s)\", e.Error()),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase lifecycle.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"InvalidRequest\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase replication.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"MalformedXML\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase tags.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           e.Code(),\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase policy.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"MalformedPolicy\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase crypto.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"XMinIOEncryptionError\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase minio.ErrorResponse:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           e.Code,\n\t\t\t\tDescription:    e.Message,\n\t\t\t\tHTTPStatusCode: e.StatusCode,\n\t\t\t}\n\t\tcase *googleapi.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"XGCSInternalError\",\n\t\t\t\tDescription:    e.Message,\n\t\t\t\tHTTPStatusCode: e.Code,\n\t\t\t}\n\t\t\t// GCS may send multiple errors, just pick the first one\n\t\t\t// since S3 only sends one Error XML response.\n\t\t\tif len(e.Errors) >= 1 {\n\t\t\t\tapiErr.Code = e.Errors[0].Reason\n\n\t\t\t}\n\t\tcase azblob.StorageError:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           string(e.ServiceCode()),\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: e.Response().StatusCode,\n\t\t\t}\n\t\t\t// Add more Gateway SDKs here if any in future.\n\t\t}\n\t}\n\n\treturn apiErr\n}\n\n// getAPIError provides API Error for input API error code.\nfunc getAPIError(code APIErrorCode) APIError {\n\tif apiErr, ok := errorCodes[code]; ok {\n\t\treturn apiErr\n\t}\n\treturn errorCodes.ToAPIErr(ErrInternalError)\n}\n\n// getErrorResponse gets in standard error and resource value and\n// provides a encodable populated response values\nfunc getAPIErrorResponse(ctx context.Context, err APIError, resource, requestID, hostID string) APIErrorResponse {\n\treqInfo := logger.GetReqInfo(ctx)\n\treturn APIErrorResponse{\n\t\tCode:       err.Code,\n\t\tMessage:    err.Description,\n\t\tBucketName: reqInfo.BucketName,\n\t\tKey:        reqInfo.ObjectName,\n\t\tResource:   resource,\n\t\tRegion:     globalServerRegion,\n\t\tRequestID:  requestID,\n\t\tHostID:     hostID,\n\t}\n}\n", "/*\n * MinIO Cloud Storage, (C) 2016-2019 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/klauspost/compress/zip\"\n\t\"github.com/minio/minio-go/v7\"\n\tminiogo \"github.com/minio/minio-go/v7\"\n\tminiogopolicy \"github.com/minio/minio-go/v7/pkg/policy\"\n\t\"github.com/minio/minio-go/v7/pkg/s3utils\"\n\t\"github.com/minio/minio/browser\"\n\t\"github.com/minio/minio/cmd/config/dns\"\n\t\"github.com/minio/minio/cmd/config/identity/openid\"\n\t\"github.com/minio/minio/cmd/crypto\"\n\txhttp \"github.com/minio/minio/cmd/http\"\n\t\"github.com/minio/minio/cmd/logger\"\n\t\"github.com/minio/minio/pkg/auth\"\n\t\"github.com/minio/minio/pkg/bucket/lifecycle\"\n\tobjectlock \"github.com/minio/minio/pkg/bucket/object/lock\"\n\t\"github.com/minio/minio/pkg/bucket/policy\"\n\t\"github.com/minio/minio/pkg/bucket/replication\"\n\t\"github.com/minio/minio/pkg/event\"\n\t\"github.com/minio/minio/pkg/handlers\"\n\t\"github.com/minio/minio/pkg/hash\"\n\tiampolicy \"github.com/minio/minio/pkg/iam/policy\"\n\t\"github.com/minio/minio/pkg/ioutil\"\n\t\"github.com/minio/minio/pkg/rpc/json2\"\n)\n\nfunc extractBucketObject(args reflect.Value) (bucketName, objectName string) {\n\tswitch args.Kind() {\n\tcase reflect.Ptr:\n\t\ta := args.Elem()\n\t\tfor i := 0; i < a.NumField(); i++ {\n\t\t\tswitch a.Type().Field(i).Name {\n\t\t\tcase \"BucketName\":\n\t\t\t\tbucketName = a.Field(i).String()\n\t\t\tcase \"Prefix\":\n\t\t\t\tobjectName = a.Field(i).String()\n\t\t\tcase \"ObjectName\":\n\t\t\t\tobjectName = a.Field(i).String()\n\t\t\t}\n\t\t}\n\t}\n\treturn bucketName, objectName\n}\n\n// WebGenericArgs - empty struct for calls that don't accept arguments\n// for ex. ServerInfo, GenerateAuth\ntype WebGenericArgs struct{}\n\n// WebGenericRep - reply structure for calls for which reply is success/failure\n// for ex. RemoveObject MakeBucket\ntype WebGenericRep struct {\n\tUIVersion string `json:\"uiVersion\"`\n}\n\n// ServerInfoRep - server info reply.\ntype ServerInfoRep struct {\n\tMinioVersion    string\n\tMinioMemory     string\n\tMinioPlatform   string\n\tMinioRuntime    string\n\tMinioGlobalInfo map[string]interface{}\n\tMinioUserInfo   map[string]interface{}\n\tUIVersion       string `json:\"uiVersion\"`\n}\n\n// ServerInfo - get server info.\nfunc (web *webAPIHandlers) ServerInfo(r *http.Request, args *WebGenericArgs, reply *ServerInfoRep) error {\n\tctx := newWebContext(r, args, \"WebServerInfo\")\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\thost, err := os.Hostname()\n\tif err != nil {\n\t\thost = \"\"\n\t}\n\tplatform := fmt.Sprintf(\"Host: %s | OS: %s | Arch: %s\",\n\t\thost,\n\t\truntime.GOOS,\n\t\truntime.GOARCH)\n\tgoruntime := fmt.Sprintf(\"Version: %s | CPUs: %d\", runtime.Version(), runtime.NumCPU())\n\n\treply.MinioVersion = Version\n\treply.MinioGlobalInfo = getGlobalInfo()\n\n\t// Check if the user is IAM user.\n\treply.MinioUserInfo = map[string]interface{}{\n\t\t\"isIAMUser\": !owner,\n\t}\n\n\tif !owner {\n\t\tcreds, ok := globalIAMSys.GetUser(claims.AccessKey)\n\t\tif ok && creds.SessionToken != \"\" {\n\t\t\treply.MinioUserInfo[\"isTempUser\"] = true\n\t\t}\n\t}\n\n\treply.MinioPlatform = platform\n\treply.MinioRuntime = goruntime\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// StorageInfoRep - contains storage usage statistics.\ntype StorageInfoRep struct {\n\tUsed      uint64 `json:\"used\"`\n\tUIVersion string `json:\"uiVersion\"`\n}\n\n// StorageInfo - web call to gather storage usage statistics.\nfunc (web *webAPIHandlers) StorageInfo(r *http.Request, args *WebGenericArgs, reply *StorageInfoRep) error {\n\tctx := newWebContext(r, args, \"WebStorageInfo\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\t_, _, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\tdataUsageInfo, _ := loadDataUsageFromBackend(ctx, objectAPI)\n\treply.Used = dataUsageInfo.ObjectsTotalSize\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// MakeBucketArgs - make bucket args.\ntype MakeBucketArgs struct {\n\tBucketName string `json:\"bucketName\"`\n}\n\n// MakeBucket - creates a new bucket.\nfunc (web *webAPIHandlers) MakeBucket(r *http.Request, args *MakeBucketArgs, reply *WebGenericRep) error {\n\tctx := newWebContext(r, args, \"WebMakeBucket\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.CreateBucketAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, true) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\topts := BucketOptions{\n\t\tLocation:    globalServerRegion,\n\t\tLockEnabled: false,\n\t}\n\n\tif globalDNSConfig != nil {\n\t\tif _, err := globalDNSConfig.Get(args.BucketName); err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound || err == dns.ErrNotImplemented {\n\t\t\t\t// Proceed to creating a bucket.\n\t\t\t\tif err = objectAPI.MakeBucketWithLocation(ctx, args.BucketName, opts); err != nil {\n\t\t\t\t\treturn toJSONError(ctx, err)\n\t\t\t\t}\n\n\t\t\t\tif err = globalDNSConfig.Put(args.BucketName); err != nil {\n\t\t\t\t\tobjectAPI.DeleteBucket(ctx, args.BucketName, false)\n\t\t\t\t\treturn toJSONError(ctx, err)\n\t\t\t\t}\n\n\t\t\t\treply.UIVersion = browser.UIVersion\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t\treturn toJSONError(ctx, errBucketAlreadyExists)\n\t}\n\n\tif err := objectAPI.MakeBucketWithLocation(ctx, args.BucketName, opts); err != nil {\n\t\treturn toJSONError(ctx, err, args.BucketName)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\n\tsendEvent(eventArgs{\n\t\tEventName:  event.BucketCreated,\n\t\tBucketName: args.BucketName,\n\t\tReqParams:  extractReqParams(r),\n\t\tUserAgent:  r.UserAgent(),\n\t\tHost:       handlers.GetSourceIP(r),\n\t})\n\n\treturn nil\n}\n\n// RemoveBucketArgs - remove bucket args.\ntype RemoveBucketArgs struct {\n\tBucketName string `json:\"bucketName\"`\n}\n\n// DeleteBucket - removes a bucket, must be empty.\nfunc (web *webAPIHandlers) DeleteBucket(r *http.Request, args *RemoveBucketArgs, reply *WebGenericRep) error {\n\tctx := newWebContext(r, args, \"WebDeleteBucket\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.DeleteBucketAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, err := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tif err = core.RemoveBucket(ctx, args.BucketName); err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\treturn nil\n\t}\n\n\tdeleteBucket := objectAPI.DeleteBucket\n\n\tif err := deleteBucket(ctx, args.BucketName, false); err != nil {\n\t\treturn toJSONError(ctx, err, args.BucketName)\n\t}\n\n\tglobalNotificationSys.DeleteBucketMetadata(ctx, args.BucketName)\n\n\tif globalDNSConfig != nil {\n\t\tif err := globalDNSConfig.Delete(args.BucketName); err != nil {\n\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to delete bucket DNS entry %w, please delete it manually\", err))\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t}\n\n\tsendEvent(eventArgs{\n\t\tEventName:  event.BucketRemoved,\n\t\tBucketName: args.BucketName,\n\t\tReqParams:  extractReqParams(r),\n\t\tUserAgent:  r.UserAgent(),\n\t\tHost:       handlers.GetSourceIP(r),\n\t})\n\n\treturn nil\n}\n\n// ListBucketsRep - list buckets response\ntype ListBucketsRep struct {\n\tBuckets   []WebBucketInfo `json:\"buckets\"`\n\tUIVersion string          `json:\"uiVersion\"`\n}\n\n// WebBucketInfo container for list buckets metadata.\ntype WebBucketInfo struct {\n\t// The name of the bucket.\n\tName string `json:\"name\"`\n\t// Date the bucket was created.\n\tCreationDate time.Time `json:\"creationDate\"`\n}\n\n// ListBuckets - list buckets api.\nfunc (web *webAPIHandlers) ListBuckets(r *http.Request, args *WebGenericArgs, reply *ListBucketsRep) error {\n\tctx := newWebContext(r, args, \"WebListBuckets\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\tlistBuckets := objectAPI.ListBuckets\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\tr.Header.Set(\"prefix\", \"\")\n\n\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t// If etcd, dns federation configured list buckets from etcd.\n\tif globalDNSConfig != nil && globalBucketFederation {\n\t\tdnsBuckets, err := globalDNSConfig.List()\n\t\tif err != nil && err != dns.ErrNoEntriesFound {\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t\tfor _, dnsRecords := range dnsBuckets {\n\t\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\t\tBucketName:      dnsRecords[0].Key,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      \"\",\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\treply.Buckets = append(reply.Buckets, WebBucketInfo{\n\t\t\t\t\tName:         dnsRecords[0].Key,\n\t\t\t\t\tCreationDate: dnsRecords[0].CreationDate,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbuckets, err := listBuckets(ctx)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t\tfor _, bucket := range buckets {\n\t\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\t\tBucketName:      bucket.Name,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      \"\",\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\treply.Buckets = append(reply.Buckets, WebBucketInfo{\n\t\t\t\t\tName:         bucket.Name,\n\t\t\t\t\tCreationDate: bucket.Created,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// ListObjectsArgs - list object args.\ntype ListObjectsArgs struct {\n\tBucketName string `json:\"bucketName\"`\n\tPrefix     string `json:\"prefix\"`\n\tMarker     string `json:\"marker\"`\n}\n\n// ListObjectsRep - list objects response.\ntype ListObjectsRep struct {\n\tObjects   []WebObjectInfo `json:\"objects\"`\n\tWritable  bool            `json:\"writable\"` // Used by client to show \"upload file\" button.\n\tUIVersion string          `json:\"uiVersion\"`\n}\n\n// WebObjectInfo container for list objects metadata.\ntype WebObjectInfo struct {\n\t// Name of the object\n\tKey string `json:\"name\"`\n\t// Date and time the object was last modified.\n\tLastModified time.Time `json:\"lastModified\"`\n\t// Size in bytes of the object.\n\tSize int64 `json:\"size\"`\n\t// ContentType is mime type of the object.\n\tContentType string `json:\"contentType\"`\n}\n\n// ListObjects - list objects api.\nfunc (web *webAPIHandlers) ListObjects(r *http.Request, args *ListObjectsArgs, reply *ListObjectsRep) error {\n\tctx := newWebContext(r, args, \"WebListObjects\")\n\treply.UIVersion = browser.UIVersion\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tlistObjects := objectAPI.ListObjects\n\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, err := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tnextMarker := \"\"\n\t\t// Fetch all the objects\n\t\tfor {\n\t\t\t// Let listObjects reply back the maximum from server implementation\n\t\t\tresult, err := core.ListObjects(args.BucketName, args.Prefix, nextMarker, SlashSeparator, 1000)\n\t\t\tif err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\n\t\t\tfor _, obj := range result.Contents {\n\t\t\t\treply.Objects = append(reply.Objects, WebObjectInfo{\n\t\t\t\t\tKey:          obj.Key,\n\t\t\t\t\tLastModified: obj.LastModified,\n\t\t\t\t\tSize:         obj.Size,\n\t\t\t\t\tContentType:  obj.ContentType,\n\t\t\t\t})\n\t\t\t}\n\t\t\tfor _, p := range result.CommonPrefixes {\n\t\t\t\treply.Objects = append(reply.Objects, WebObjectInfo{\n\t\t\t\t\tKey: p.Prefix,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tnextMarker = result.NextMarker\n\n\t\t\t// Return when there are no more objects\n\t\t\tif !result.IsTruncated {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\t\t\tr.Header.Set(\"prefix\", args.Prefix)\n\n\t\t\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\t\t\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t\t\t// Check if anonymous (non-owner) has access to download objects.\n\t\t\treadable := globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.ListBucketAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t})\n\n\t\t\t// Check if anonymous (non-owner) has access to upload objects.\n\t\t\twritable := globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.PutObjectAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      args.Prefix + SlashSeparator,\n\t\t\t})\n\n\t\t\treply.Writable = writable\n\t\t\tif !readable {\n\t\t\t\t// Error out if anonymous user (non-owner) has no access to download or upload objects\n\t\t\t\tif !writable {\n\t\t\t\t\treturn errAccessDenied\n\t\t\t\t}\n\t\t\t\t// return empty object list if access is write only\n\t\t\t\treturn nil\n\t\t\t}\n\t\t} else {\n\t\t\treturn toJSONError(ctx, authErr)\n\t\t}\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif authErr == nil {\n\t\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\t\tr.Header.Set(\"prefix\", args.Prefix)\n\n\t\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\t\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t\treadable := globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\tBucketName:      args.BucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims.Map(),\n\t\t})\n\n\t\twritable := globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.PutObjectAction,\n\t\t\tBucketName:      args.BucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      args.Prefix + SlashSeparator,\n\t\t\tClaims:          claims.Map(),\n\t\t})\n\n\t\treply.Writable = writable\n\t\tif !readable {\n\t\t\t// Error out if anonymous user (non-owner) has no access to download or upload objects\n\t\t\tif !writable {\n\t\t\t\treturn errAccessDenied\n\t\t\t}\n\t\t\t// return empty object list if access is write only\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\tnextMarker := \"\"\n\t// Fetch all the objects\n\tfor {\n\t\t// Limit browser to '1000' batches to be more responsive, scrolling friendly.\n\t\t// Also don't change the maxKeys value silly GCS SDKs do not honor maxKeys\n\t\t// values to be '-1'\n\t\tlo, err := listObjects(ctx, args.BucketName, args.Prefix, nextMarker, SlashSeparator, 1000)\n\t\tif err != nil {\n\t\t\treturn &json2.Error{Message: err.Error()}\n\t\t}\n\n\t\tnextMarker = lo.NextMarker\n\t\tfor i := range lo.Objects {\n\t\t\tlo.Objects[i].Size, err = lo.Objects[i].GetActualSize()\n\t\t\tif err != nil {\n\t\t\t\treturn toJSONError(ctx, err)\n\t\t\t}\n\t\t}\n\n\t\tfor _, obj := range lo.Objects {\n\t\t\treply.Objects = append(reply.Objects, WebObjectInfo{\n\t\t\t\tKey:          obj.Name,\n\t\t\t\tLastModified: obj.ModTime,\n\t\t\t\tSize:         obj.Size,\n\t\t\t\tContentType:  obj.ContentType,\n\t\t\t})\n\t\t}\n\t\tfor _, prefix := range lo.Prefixes {\n\t\t\treply.Objects = append(reply.Objects, WebObjectInfo{\n\t\t\t\tKey: prefix,\n\t\t\t})\n\t\t}\n\n\t\t// Return when there are no more objects\n\t\tif !lo.IsTruncated {\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// RemoveObjectArgs - args to remove an object, JSON will look like.\n//\n// {\n//     \"bucketname\": \"testbucket\",\n//     \"objects\": [\n//         \"photos/hawaii/\",\n//         \"photos/maldives/\",\n//         \"photos/sanjose.jpg\"\n//     ]\n// }\ntype RemoveObjectArgs struct {\n\tObjects    []string `json:\"objects\"`    // Contains objects, prefixes.\n\tBucketName string   `json:\"bucketname\"` // Contains bucket name.\n}\n\n// RemoveObject - removes an object, or all the objects at a given prefix.\nfunc (web *webAPIHandlers) RemoveObject(r *http.Request, args *RemoveObjectArgs, reply *WebGenericRep) error {\n\tctx := newWebContext(r, args, \"WebRemoveObject\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tdeleteObjects := objectAPI.DeleteObjects\n\tif web.CacheAPI() != nil {\n\t\tdeleteObjects = web.CacheAPI().DeleteObjects\n\t}\n\tgetObjectInfoFn := objectAPI.GetObjectInfo\n\tif web.CacheAPI() != nil {\n\t\tgetObjectInfoFn = web.CacheAPI().GetObjectInfo\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Check if all objects are allowed to be deleted anonymously\n\t\t\tfor _, object := range args.Objects {\n\t\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.DeleteObjectAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      object,\n\t\t\t\t}) {\n\t\t\t\t\treturn toJSONError(ctx, errAuthentication)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn toJSONError(ctx, authErr)\n\t\t}\n\t}\n\n\tif args.BucketName == \"\" || len(args.Objects) == 0 {\n\t\treturn toJSONError(ctx, errInvalidArgument)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, err := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tobjectsCh := make(chan miniogo.ObjectInfo)\n\n\t\t// Send object names that are needed to be removed to objectsCh\n\t\tgo func() {\n\t\t\tdefer close(objectsCh)\n\n\t\t\tfor _, objectName := range args.Objects {\n\t\t\t\tobjectsCh <- miniogo.ObjectInfo{\n\t\t\t\t\tKey: objectName,\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tfor resp := range core.RemoveObjects(ctx, args.BucketName, objectsCh, minio.RemoveObjectsOptions{}) {\n\t\t\tif resp.Err != nil {\n\t\t\t\treturn toJSONError(ctx, resp.Err, args.BucketName, resp.ObjectName)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\topts := ObjectOptions{\n\t\tVersioned:        globalBucketVersioningSys.Enabled(args.BucketName),\n\t\tVersionSuspended: globalBucketVersioningSys.Suspended(args.BucketName),\n\t}\n\tvar (\n\t\terr           error\n\t\treplicateSync bool\n\t)\nnext:\n\tfor _, objectName := range args.Objects {\n\t\t// If not a directory, remove the object.\n\t\tif !HasSuffix(objectName, SlashSeparator) && objectName != \"\" {\n\t\t\t// Check permissions for non-anonymous user.\n\t\t\tif authErr != errNoAuthToken {\n\t\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\t\tAction:          iampolicy.DeleteObjectAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\t\tIsOwner:         owner,\n\t\t\t\t\tObjectName:      objectName,\n\t\t\t\t\tClaims:          claims.Map(),\n\t\t\t\t}) {\n\t\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif authErr == errNoAuthToken {\n\t\t\t\t// Check if object is allowed to be deleted anonymously.\n\t\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.DeleteObjectAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      objectName,\n\t\t\t\t}) {\n\t\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar (\n\t\t\t\treplicateDel, hasLifecycleConfig bool\n\t\t\t\tgoi                              ObjectInfo\n\t\t\t\tgerr                             error\n\t\t\t)\n\t\t\tif _, err := globalBucketMetadataSys.GetLifecycleConfig(args.BucketName); err == nil {\n\t\t\t\thasLifecycleConfig = true\n\t\t\t}\n\t\t\tif hasReplicationRules(ctx, args.BucketName, []ObjectToDelete{{ObjectName: objectName}}) || hasLifecycleConfig {\n\t\t\t\tgoi, gerr = getObjectInfoFn(ctx, args.BucketName, objectName, opts)\n\t\t\t\tif _, replicateDel, replicateSync = checkReplicateDelete(ctx, args.BucketName, ObjectToDelete{ObjectName: objectName, VersionID: goi.VersionID}, goi, gerr); replicateDel {\n\t\t\t\t\topts.DeleteMarkerReplicationStatus = string(replication.Pending)\n\t\t\t\t\topts.DeleteMarker = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toi, err := deleteObject(ctx, objectAPI, web.CacheAPI(), args.BucketName, objectName, nil, r, opts)\n\t\t\tif replicateDel && err == nil {\n\t\t\t\tdobj := DeletedObjectVersionInfo{\n\t\t\t\t\tDeletedObject: DeletedObject{\n\t\t\t\t\t\tObjectName:                    objectName,\n\t\t\t\t\t\tDeleteMarkerVersionID:         oi.VersionID,\n\t\t\t\t\t\tDeleteMarkerReplicationStatus: string(oi.ReplicationStatus),\n\t\t\t\t\t\tDeleteMarkerMTime:             DeleteMarkerMTime{oi.ModTime},\n\t\t\t\t\t\tDeleteMarker:                  oi.DeleteMarker,\n\t\t\t\t\t\tVersionPurgeStatus:            oi.VersionPurgeStatus,\n\t\t\t\t\t},\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}\n\t\t\t\tscheduleReplicationDelete(ctx, dobj, objectAPI, replicateSync)\n\t\t\t}\n\t\t\tif goi.TransitionStatus == lifecycle.TransitionComplete && err == nil && goi.VersionID == \"\" {\n\t\t\t\taction := lifecycle.DeleteAction\n\t\t\t\tif goi.VersionID != \"\" {\n\t\t\t\t\taction = lifecycle.DeleteVersionAction\n\t\t\t\t}\n\t\t\t\tdeleteTransitionedObject(ctx, newObjectLayerFn(), args.BucketName, objectName, lifecycle.ObjectOpts{\n\t\t\t\t\tName:         objectName,\n\t\t\t\t\tUserTags:     goi.UserTags,\n\t\t\t\t\tVersionID:    goi.VersionID,\n\t\t\t\t\tDeleteMarker: goi.DeleteMarker,\n\t\t\t\t\tIsLatest:     goi.IsLatest,\n\t\t\t\t}, action, true)\n\t\t\t}\n\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Check if object is allowed to be deleted anonymously\n\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          iampolicy.DeleteObjectAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      objectName,\n\t\t\t}) {\n\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t}\n\t\t} else {\n\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.DeleteObjectAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      objectName,\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t}\n\t\t}\n\n\t\t// Allocate new results channel to receive ObjectInfo.\n\t\tobjInfoCh := make(chan ObjectInfo)\n\n\t\t// Walk through all objects\n\t\tif err = objectAPI.Walk(ctx, args.BucketName, objectName, objInfoCh, ObjectOptions{}); err != nil {\n\t\t\tbreak next\n\t\t}\n\n\t\tfor {\n\t\t\tvar objects []ObjectToDelete\n\t\t\tfor obj := range objInfoCh {\n\t\t\t\tif len(objects) == maxDeleteList {\n\t\t\t\t\t// Reached maximum delete requests, attempt a delete for now.\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif obj.ReplicationStatus == replication.Replica {\n\t\t\t\t\tif authErr == errNoAuthToken {\n\t\t\t\t\t\t// Check if object is allowed to be deleted anonymously\n\t\t\t\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\t\t\tAction:          iampolicy.ReplicateDeleteAction,\n\t\t\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\t\t\tObjectName:      objectName,\n\t\t\t\t\t\t}) {\n\t\t\t\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\t\t\t\tAction:          iampolicy.ReplicateDeleteAction,\n\t\t\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\t\t\t\tIsOwner:         owner,\n\t\t\t\t\t\t\tObjectName:      objectName,\n\t\t\t\t\t\t\tClaims:          claims.Map(),\n\t\t\t\t\t\t}) {\n\t\t\t\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_, replicateDel, _ := checkReplicateDelete(ctx, args.BucketName, ObjectToDelete{ObjectName: obj.Name, VersionID: obj.VersionID}, obj, nil)\n\t\t\t\t// since versioned delete is not available on web browser, yet - this is a simple DeleteMarker replication\n\t\t\t\tobjToDel := ObjectToDelete{ObjectName: obj.Name}\n\t\t\t\tif replicateDel {\n\t\t\t\t\tobjToDel.DeleteMarkerReplicationStatus = string(replication.Pending)\n\t\t\t\t}\n\n\t\t\t\tobjects = append(objects, objToDel)\n\t\t\t}\n\n\t\t\t// Nothing to do.\n\t\t\tif len(objects) == 0 {\n\t\t\t\tbreak next\n\t\t\t}\n\n\t\t\t// Deletes a list of objects.\n\t\t\tdeletedObjects, errs := deleteObjects(ctx, args.BucketName, objects, opts)\n\t\t\tfor i, err := range errs {\n\t\t\t\tif err != nil && !isErrObjectNotFound(err) {\n\t\t\t\t\tdeletedObjects[i].DeleteMarkerReplicationStatus = objects[i].DeleteMarkerReplicationStatus\n\t\t\t\t\tdeletedObjects[i].VersionPurgeStatus = objects[i].VersionPurgeStatus\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\t\tbreak next\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Notify deleted event for objects.\n\t\t\tfor _, dobj := range deletedObjects {\n\t\t\t\tobjInfo := ObjectInfo{\n\t\t\t\t\tName:      dobj.ObjectName,\n\t\t\t\t\tVersionID: dobj.VersionID,\n\t\t\t\t}\n\t\t\t\tif dobj.DeleteMarker {\n\t\t\t\t\tobjInfo = ObjectInfo{\n\t\t\t\t\t\tName:         dobj.ObjectName,\n\t\t\t\t\t\tDeleteMarker: dobj.DeleteMarker,\n\t\t\t\t\t\tVersionID:    dobj.DeleteMarkerVersionID,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsendEvent(eventArgs{\n\t\t\t\t\tEventName:  event.ObjectRemovedDelete,\n\t\t\t\t\tBucketName: args.BucketName,\n\t\t\t\t\tObject:     objInfo,\n\t\t\t\t\tReqParams:  extractReqParams(r),\n\t\t\t\t\tUserAgent:  r.UserAgent(),\n\t\t\t\t\tHost:       handlers.GetSourceIP(r),\n\t\t\t\t})\n\t\t\t\tif dobj.DeleteMarkerReplicationStatus == string(replication.Pending) || dobj.VersionPurgeStatus == Pending {\n\t\t\t\t\tdv := DeletedObjectVersionInfo{\n\t\t\t\t\t\tDeletedObject: dobj,\n\t\t\t\t\t\tBucket:        args.BucketName,\n\t\t\t\t\t}\n\t\t\t\t\tscheduleReplicationDelete(ctx, dv, objectAPI, replicateSync)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif err != nil && !isErrObjectNotFound(err) && !isErrVersionNotFound(err) {\n\t\t// Ignore object not found error.\n\t\treturn toJSONError(ctx, err, args.BucketName, \"\")\n\t}\n\n\treturn nil\n}\n\n// LoginArgs - login arguments.\ntype LoginArgs struct {\n\tUsername string `json:\"username\" form:\"username\"`\n\tPassword string `json:\"password\" form:\"password\"`\n}\n\n// LoginRep - login reply.\ntype LoginRep struct {\n\tToken     string `json:\"token\"`\n\tUIVersion string `json:\"uiVersion\"`\n}\n\n// Login - user login handler.\nfunc (web *webAPIHandlers) Login(r *http.Request, args *LoginArgs, reply *LoginRep) error {\n\tctx := newWebContext(r, args, \"WebLogin\")\n\ttoken, err := authenticateWeb(args.Username, args.Password)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\treply.Token = token\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// GenerateAuthReply - reply for GenerateAuth\ntype GenerateAuthReply struct {\n\tAccessKey string `json:\"accessKey\"`\n\tSecretKey string `json:\"secretKey\"`\n\tUIVersion string `json:\"uiVersion\"`\n}\n\nfunc (web webAPIHandlers) GenerateAuth(r *http.Request, args *WebGenericArgs, reply *GenerateAuthReply) error {\n\tctx := newWebContext(r, args, \"WebGenerateAuth\")\n\t_, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\tif !owner {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\tcred, err := auth.GetNewCredentials()\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\treply.AccessKey = cred.AccessKey\n\treply.SecretKey = cred.SecretKey\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// SetAuthArgs - argument for SetAuth\ntype SetAuthArgs struct {\n\tCurrentAccessKey string `json:\"currentAccessKey\"`\n\tCurrentSecretKey string `json:\"currentSecretKey\"`\n\tNewAccessKey     string `json:\"newAccessKey\"`\n\tNewSecretKey     string `json:\"newSecretKey\"`\n}\n\n// SetAuthReply - reply for SetAuth\ntype SetAuthReply struct {\n\tToken       string            `json:\"token\"`\n\tUIVersion   string            `json:\"uiVersion\"`\n\tPeerErrMsgs map[string]string `json:\"peerErrMsgs\"`\n}\n\n// SetAuth - Set accessKey and secretKey credentials.\nfunc (web *webAPIHandlers) SetAuth(r *http.Request, args *SetAuthArgs, reply *SetAuthReply) error {\n\tctx := newWebContext(r, args, \"WebSetAuth\")\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\tif owner {\n\t\t// Owner is not allowed to change credentials through browser.\n\t\treturn toJSONError(ctx, errChangeCredNotAllowed)\n\t}\n\n\t// for IAM users, access key cannot be updated\n\t// claims.AccessKey is used instead of accesskey from args\n\tprevCred, ok := globalIAMSys.GetUser(claims.AccessKey)\n\tif !ok {\n\t\treturn errInvalidAccessKeyID\n\t}\n\n\t// Throw error when wrong secret key is provided\n\tif subtle.ConstantTimeCompare([]byte(prevCred.SecretKey), []byte(args.CurrentSecretKey)) != 1 {\n\t\treturn errIncorrectCreds\n\t}\n\n\tcreds, err := auth.CreateCredentials(claims.AccessKey, args.NewSecretKey)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\terr = globalIAMSys.SetUserSecretKey(creds.AccessKey, creds.SecretKey)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\treply.Token, err = authenticateWeb(creds.AccessKey, creds.SecretKey)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\n\treturn nil\n}\n\n// URLTokenReply contains the reply for CreateURLToken.\ntype URLTokenReply struct {\n\tToken     string `json:\"token\"`\n\tUIVersion string `json:\"uiVersion\"`\n}\n\n// CreateURLToken creates a URL token (short-lived) for GET requests.\nfunc (web *webAPIHandlers) CreateURLToken(r *http.Request, args *WebGenericArgs, reply *URLTokenReply) error {\n\tctx := newWebContext(r, args, \"WebCreateURLToken\")\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\tcreds := globalActiveCred\n\tif !owner {\n\t\tvar ok bool\n\t\tcreds, ok = globalIAMSys.GetUser(claims.AccessKey)\n\t\tif !ok {\n\t\t\treturn toJSONError(ctx, errInvalidAccessKeyID)\n\t\t}\n\t}\n\n\tif creds.SessionToken != \"\" {\n\t\t// Use the same session token for URL token.\n\t\treply.Token = creds.SessionToken\n\t} else {\n\t\ttoken, err := authenticateURL(creds.AccessKey, creds.SecretKey)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t\treply.Token = token\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// Upload - file upload handler.\nfunc (web *webAPIHandlers) Upload(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"WebUpload\")\n\n\t// obtain the claims here if possible, for audit logging.\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\n\tdefer logger.AuditLog(w, r, \"WebUpload\", claims.Map())\n\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\twriteWebErrorResponse(w, errServerNotInitialized)\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tbucket := vars[\"bucket\"]\n\tobject, err := url.PathUnescape(vars[\"object\"])\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\tretPerms := ErrAccessDenied\n\tholdPerms := ErrAccessDenied\n\treplPerms := ErrAccessDenied\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Check if anonymous (non-owner) has access to upload objects.\n\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.PutObjectAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\twriteWebErrorResponse(w, authErr)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif authErr == nil {\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.PutObjectAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\treturn\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.PutObjectRetentionAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\tretPerms = ErrNone\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.PutObjectLegalHoldAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\tholdPerms = ErrNone\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.GetReplicationConfigurationAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\treplPerms = ErrNone\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(bucket, false) {\n\t\twriteWebErrorResponse(w, errInvalidBucketName)\n\t\treturn\n\t}\n\n\t// Check if bucket encryption is enabled\n\t_, err = globalBucketSSEConfigSys.Get(bucket)\n\tif (globalAutoEncryption || err == nil) && !crypto.SSEC.IsRequested(r.Header) {\n\t\tr.Header.Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)\n\t}\n\n\t// Require Content-Length to be set in the request\n\tsize := r.ContentLength\n\tif size < 0 {\n\t\twriteWebErrorResponse(w, errSizeUnspecified)\n\t\treturn\n\t}\n\n\tif err := enforceBucketQuota(ctx, bucket, size); err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\t// Extract incoming metadata if any.\n\tmetadata, err := extractMetadata(ctx, r)\n\tif err != nil {\n\t\twriteErrorResponse(ctx, w, toAPIError(ctx, err), r.URL, guessIsBrowserReq(r))\n\t\treturn\n\t}\n\n\tvar pReader *PutObjReader\n\tvar reader io.Reader = r.Body\n\tactualSize := size\n\n\thashReader, err := hash.NewReader(reader, size, \"\", \"\", actualSize, globalCLIContext.StrictS3Compat)\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\tif objectAPI.IsCompressionSupported() && isCompressible(r.Header, object) && size > 0 {\n\t\t// Storing the compression metadata.\n\t\tmetadata[ReservedMetadataPrefix+\"compression\"] = compressionAlgorithmV2\n\t\tmetadata[ReservedMetadataPrefix+\"actual-size\"] = strconv.FormatInt(actualSize, 10)\n\n\t\tactualReader, err := hash.NewReader(reader, actualSize, \"\", \"\", actualSize, globalCLIContext.StrictS3Compat)\n\t\tif err != nil {\n\t\t\twriteWebErrorResponse(w, err)\n\t\t\treturn\n\t\t}\n\n\t\t// Set compression metrics.\n\t\tsize = -1 // Since compressed size is un-predictable.\n\t\ts2c := newS2CompressReader(actualReader, actualSize)\n\t\tdefer s2c.Close()\n\t\treader = s2c\n\t\thashReader, err = hash.NewReader(reader, size, \"\", \"\", actualSize, globalCLIContext.StrictS3Compat)\n\t\tif err != nil {\n\t\t\twriteWebErrorResponse(w, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tmustReplicate, sync := mustReplicateWeb(ctx, r, bucket, object, metadata, \"\", replPerms)\n\tif mustReplicate {\n\t\tmetadata[xhttp.AmzBucketReplicationStatus] = string(replication.Pending)\n\t}\n\tpReader = NewPutObjReader(hashReader, nil, nil)\n\t// get gateway encryption options\n\topts, err := putOpts(ctx, r, bucket, object, metadata)\n\tif err != nil {\n\t\twriteErrorResponseHeadersOnly(w, toAPIError(ctx, err))\n\t\treturn\n\t}\n\n\tif objectAPI.IsEncryptionSupported() {\n\t\tif _, ok := crypto.IsRequested(r.Header); ok && !HasSuffix(object, SlashSeparator) { // handle SSE requests\n\t\t\trawReader := hashReader\n\t\t\tvar objectEncryptionKey crypto.ObjectKey\n\t\t\treader, objectEncryptionKey, err = EncryptRequest(hashReader, r, bucket, object, metadata)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, toAPIError(ctx, err), r.URL, guessIsBrowserReq(r))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tinfo := ObjectInfo{Size: size}\n\t\t\t// do not try to verify encrypted content\n\t\t\thashReader, err = hash.NewReader(reader, info.EncryptedSize(), \"\", \"\", size, globalCLIContext.StrictS3Compat)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, toAPIError(ctx, err), r.URL, guessIsBrowserReq(r))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpReader = NewPutObjReader(rawReader, hashReader, &objectEncryptionKey)\n\t\t}\n\t}\n\n\t// Ensure that metadata does not contain sensitive information\n\tcrypto.RemoveSensitiveEntries(metadata)\n\n\tputObject := objectAPI.PutObject\n\tgetObjectInfo := objectAPI.GetObjectInfo\n\tif web.CacheAPI() != nil {\n\t\tputObject = web.CacheAPI().PutObject\n\t\tgetObjectInfo = web.CacheAPI().GetObjectInfo\n\t}\n\n\t// enforce object retention rules\n\tretentionMode, retentionDate, _, s3Err := checkPutObjectLockAllowed(ctx, r, bucket, object, getObjectInfo, retPerms, holdPerms)\n\tif s3Err != ErrNone {\n\t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL, guessIsBrowserReq(r))\n\t\treturn\n\t}\n\tif retentionMode != \"\" {\n\t\topts.UserDefined[xhttp.AmzObjectLockMode] = string(retentionMode)\n\t\topts.UserDefined[xhttp.AmzObjectLockRetainUntilDate] = retentionDate.UTC().Format(iso8601TimeFormat)\n\t}\n\n\tobjInfo, err := putObject(GlobalContext, bucket, object, pReader, opts)\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\tif objectAPI.IsEncryptionSupported() {\n\t\tif crypto.IsEncrypted(objInfo.UserDefined) {\n\t\t\tswitch {\n\t\t\tcase crypto.S3.IsEncrypted(objInfo.UserDefined):\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)\n\t\t\tcase crypto.SSEC.IsRequested(r.Header):\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryptionCustomerAlgorithm, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerAlgorithm))\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryptionCustomerKeyMD5, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerKeyMD5))\n\t\t\t}\n\t\t}\n\t}\n\tif mustReplicate {\n\t\tscheduleReplication(ctx, objInfo, objectAPI, sync)\n\t}\n\n\t// Notify object created event.\n\tsendEvent(eventArgs{\n\t\tEventName:    event.ObjectCreatedPut,\n\t\tBucketName:   bucket,\n\t\tObject:       objInfo,\n\t\tReqParams:    extractReqParams(r),\n\t\tRespElements: extractRespElements(w),\n\t\tUserAgent:    r.UserAgent(),\n\t\tHost:         handlers.GetSourceIP(r),\n\t})\n}\n\n// Download - file download handler.\nfunc (web *webAPIHandlers) Download(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"WebDownload\")\n\n\tvars := mux.Vars(r)\n\n\tclaims, owner, authErr := webTokenAuthenticate(r.URL.Query().Get(\"token\"))\n\tdefer logger.AuditLog(w, r, \"WebDownload\", claims.Map())\n\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\twriteWebErrorResponse(w, errServerNotInitialized)\n\t\treturn\n\t}\n\n\tbucket := vars[\"bucket\"]\n\tobject, err := url.PathUnescape(vars[\"object\"])\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\tgetRetPerms := ErrAccessDenied\n\tlegalHoldPerms := ErrAccessDenied\n\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Check if anonymous (non-owner) has access to download objects.\n\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.GetObjectAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.GetObjectRetentionAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\tgetRetPerms = ErrNone\n\t\t\t}\n\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.GetObjectLegalHoldAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\tlegalHoldPerms = ErrNone\n\t\t\t}\n\t\t} else {\n\t\t\twriteWebErrorResponse(w, authErr)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif authErr == nil {\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.GetObjectAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\treturn\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.GetObjectRetentionAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\tgetRetPerms = ErrNone\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.GetObjectLegalHoldAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\tlegalHoldPerms = ErrNone\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(bucket, false) {\n\t\twriteWebErrorResponse(w, errInvalidBucketName)\n\t\treturn\n\t}\n\n\tgetObjectNInfo := objectAPI.GetObjectNInfo\n\tif web.CacheAPI() != nil {\n\t\tgetObjectNInfo = web.CacheAPI().GetObjectNInfo\n\t}\n\n\tvar opts ObjectOptions\n\tgr, err := getObjectNInfo(ctx, bucket, object, nil, r.Header, readLock, opts)\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\tdefer gr.Close()\n\n\tobjInfo := gr.ObjInfo\n\n\t// filter object lock metadata if permission does not permit\n\tobjInfo.UserDefined = objectlock.FilterObjectLockMetadata(objInfo.UserDefined, getRetPerms != ErrNone, legalHoldPerms != ErrNone)\n\n\tif objectAPI.IsEncryptionSupported() {\n\t\tif _, err = DecryptObjectInfo(&objInfo, r); err != nil {\n\t\t\twriteWebErrorResponse(w, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Set encryption response headers\n\tif objectAPI.IsEncryptionSupported() {\n\t\tif crypto.IsEncrypted(objInfo.UserDefined) {\n\t\t\tswitch {\n\t\t\tcase crypto.S3.IsEncrypted(objInfo.UserDefined):\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)\n\t\t\tcase crypto.SSEC.IsEncrypted(objInfo.UserDefined):\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryptionCustomerAlgorithm, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerAlgorithm))\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryptionCustomerKeyMD5, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerKeyMD5))\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set Parts Count Header\n\tif opts.PartNumber > 0 && len(objInfo.Parts) > 0 {\n\t\tsetPartsCountHeaders(w, objInfo)\n\t}\n\n\tif err = setObjectHeaders(w, objInfo, nil, opts); err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\t// Add content disposition.\n\tw.Header().Set(xhttp.ContentDisposition, fmt.Sprintf(\"attachment; filename=\\\"%s\\\"\", path.Base(objInfo.Name)))\n\n\tsetHeadGetRespHeaders(w, r.URL.Query())\n\n\thttpWriter := ioutil.WriteOnClose(w)\n\n\t// Write object content to response body\n\tif _, err = io.Copy(httpWriter, gr); err != nil {\n\t\tif !httpWriter.HasWritten() { // write error response only if no data or headers has been written to client yet\n\t\t\twriteWebErrorResponse(w, err)\n\t\t}\n\t\treturn\n\t}\n\n\tif err = httpWriter.Close(); err != nil {\n\t\tif !httpWriter.HasWritten() { // write error response only if no data or headers has been written to client yet\n\t\t\twriteWebErrorResponse(w, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Notify object accessed via a GET request.\n\tsendEvent(eventArgs{\n\t\tEventName:    event.ObjectAccessedGet,\n\t\tBucketName:   bucket,\n\t\tObject:       objInfo,\n\t\tReqParams:    extractReqParams(r),\n\t\tRespElements: extractRespElements(w),\n\t\tUserAgent:    r.UserAgent(),\n\t\tHost:         handlers.GetSourceIP(r),\n\t})\n}\n\n// DownloadZipArgs - Argument for downloading a bunch of files as a zip file.\n// JSON will look like:\n// '{\"bucketname\":\"testbucket\",\"prefix\":\"john/pics/\",\"objects\":[\"hawaii/\",\"maldives/\",\"sanjose.jpg\"]}'\ntype DownloadZipArgs struct {\n\tObjects    []string `json:\"objects\"`    // can be files or sub-directories\n\tPrefix     string   `json:\"prefix\"`     // current directory in the browser-ui\n\tBucketName string   `json:\"bucketname\"` // bucket name.\n}\n\n// Takes a list of objects and creates a zip file that sent as the response body.\nfunc (web *webAPIHandlers) DownloadZip(w http.ResponseWriter, r *http.Request) {\n\thost := handlers.GetSourceIP(r)\n\n\tclaims, owner, authErr := webTokenAuthenticate(r.URL.Query().Get(\"token\"))\n\n\tctx := newContext(r, w, \"WebDownloadZip\")\n\tdefer logger.AuditLog(w, r, \"WebDownloadZip\", claims.Map())\n\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\twriteWebErrorResponse(w, errServerNotInitialized)\n\t\treturn\n\t}\n\n\t// Auth is done after reading the body to accommodate for anonymous requests\n\t// when bucket policy is enabled.\n\tvar args DownloadZipArgs\n\ttenKB := 10 * 1024 // To limit r.Body to take care of misbehaving anonymous client.\n\tdecodeErr := json.NewDecoder(io.LimitReader(r.Body, int64(tenKB))).Decode(&args)\n\tif decodeErr != nil {\n\t\twriteWebErrorResponse(w, decodeErr)\n\t\treturn\n\t}\n\n\tvar getRetPerms []APIErrorCode\n\tvar legalHoldPerms []APIErrorCode\n\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\tfor _, object := range args.Objects {\n\t\t\t\t// Check if anonymous (non-owner) has access to download objects.\n\t\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.GetObjectAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\t}) {\n\t\t\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tretentionPerm := ErrAccessDenied\n\t\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.GetObjectRetentionAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\t}) {\n\t\t\t\t\tretentionPerm = ErrNone\n\t\t\t\t}\n\t\t\t\tgetRetPerms = append(getRetPerms, retentionPerm)\n\n\t\t\t\tlegalHoldPerm := ErrAccessDenied\n\t\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.GetObjectLegalHoldAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\t}) {\n\t\t\t\t\tlegalHoldPerm = ErrNone\n\t\t\t\t}\n\t\t\t\tlegalHoldPerms = append(legalHoldPerms, legalHoldPerm)\n\t\t\t}\n\t\t} else {\n\t\t\twriteWebErrorResponse(w, authErr)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif authErr == nil {\n\t\tfor _, object := range args.Objects {\n\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.GetObjectAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tretentionPerm := ErrAccessDenied\n\t\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.GetObjectRetentionAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\tretentionPerm = ErrNone\n\t\t\t}\n\t\t\tgetRetPerms = append(getRetPerms, retentionPerm)\n\n\t\t\tlegalHoldPerm := ErrAccessDenied\n\t\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.GetObjectLegalHoldAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\tlegalHoldPerm = ErrNone\n\t\t\t}\n\t\t\tlegalHoldPerms = append(legalHoldPerms, legalHoldPerm)\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\twriteWebErrorResponse(w, errInvalidBucketName)\n\t\treturn\n\t}\n\n\tgetObjectNInfo := objectAPI.GetObjectNInfo\n\tif web.CacheAPI() != nil {\n\t\tgetObjectNInfo = web.CacheAPI().GetObjectNInfo\n\t}\n\n\tarchive := zip.NewWriter(w)\n\tdefer archive.Close()\n\n\tfor i, object := range args.Objects {\n\t\t// Writes compressed object file to the response.\n\t\tzipit := func(objectName string) error {\n\t\t\tvar opts ObjectOptions\n\t\t\tgr, err := getObjectNInfo(ctx, args.BucketName, objectName, nil, r.Header, readLock, opts)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer gr.Close()\n\n\t\t\tinfo := gr.ObjInfo\n\t\t\t// filter object lock metadata if permission does not permit\n\t\t\tinfo.UserDefined = objectlock.FilterObjectLockMetadata(info.UserDefined, getRetPerms[i] != ErrNone, legalHoldPerms[i] != ErrNone)\n\t\t\t// For reporting, set the file size to the uncompressed size.\n\t\t\tinfo.Size, err = info.GetActualSize()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\theader := &zip.FileHeader{\n\t\t\t\tName:     strings.TrimPrefix(objectName, args.Prefix),\n\t\t\t\tMethod:   zip.Deflate,\n\t\t\t\tFlags:    1 << 11,\n\t\t\t\tModified: info.ModTime,\n\t\t\t}\n\t\t\tif hasStringSuffixInSlice(info.Name, standardExcludeCompressExtensions) || hasPattern(standardExcludeCompressContentTypes, info.ContentType) {\n\t\t\t\t// We strictly disable compression for standard extensions/content-types.\n\t\t\t\theader.Method = zip.Store\n\t\t\t}\n\t\t\twriter, err := archive.CreateHeader(header)\n\t\t\tif err != nil {\n\t\t\t\twriteWebErrorResponse(w, errUnexpected)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thttpWriter := ioutil.WriteOnClose(writer)\n\n\t\t\t// Write object content to response body\n\t\t\tif _, err = io.Copy(httpWriter, gr); err != nil {\n\t\t\t\thttpWriter.Close()\n\t\t\t\tif !httpWriter.HasWritten() { // write error response only if no data or headers has been written to client yet\n\t\t\t\t\twriteWebErrorResponse(w, err)\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err = httpWriter.Close(); err != nil {\n\t\t\t\tif !httpWriter.HasWritten() { // write error response only if no data has been written to client yet\n\t\t\t\t\twriteWebErrorResponse(w, err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Notify object accessed via a GET request.\n\t\t\tsendEvent(eventArgs{\n\t\t\t\tEventName:    event.ObjectAccessedGet,\n\t\t\t\tBucketName:   args.BucketName,\n\t\t\t\tObject:       info,\n\t\t\t\tReqParams:    extractReqParams(r),\n\t\t\t\tRespElements: extractRespElements(w),\n\t\t\t\tUserAgent:    r.UserAgent(),\n\t\t\t\tHost:         host,\n\t\t\t})\n\n\t\t\treturn nil\n\t\t}\n\n\t\tif !HasSuffix(object, SlashSeparator) {\n\t\t\t// If not a directory, compress the file and write it to response.\n\t\t\terr := zipit(pathJoin(args.Prefix, object))\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tobjInfoCh := make(chan ObjectInfo)\n\n\t\t// Walk through all objects\n\t\tif err := objectAPI.Walk(ctx, args.BucketName, pathJoin(args.Prefix, object), objInfoCh, ObjectOptions{}); err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfor obj := range objInfoCh {\n\t\t\tif err := zipit(obj.Name); err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\n// GetBucketPolicyArgs - get bucket policy args.\ntype GetBucketPolicyArgs struct {\n\tBucketName string `json:\"bucketName\"`\n\tPrefix     string `json:\"prefix\"`\n}\n\n// GetBucketPolicyRep - get bucket policy reply.\ntype GetBucketPolicyRep struct {\n\tUIVersion string                     `json:\"uiVersion\"`\n\tPolicy    miniogopolicy.BucketPolicy `json:\"policy\"`\n}\n\n// GetBucketPolicy - get bucket policy for the requested prefix.\nfunc (web *webAPIHandlers) GetBucketPolicy(r *http.Request, args *GetBucketPolicyArgs, reply *GetBucketPolicyRep) error {\n\tctx := newWebContext(r, args, \"WebGetBucketPolicy\")\n\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.GetBucketPolicyAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\tvar policyInfo = &miniogopolicy.BucketAccessPolicy{Version: \"2012-10-17\"}\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tclient, rerr := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif rerr != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tpolicyStr, err := client.GetBucketPolicy(ctx, args.BucketName)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tbucketPolicy, err := policy.ParseConfig(strings.NewReader(policyStr), args.BucketName)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tpolicyInfo, err = PolicyToBucketAccessPolicy(bucketPolicy)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t} else {\n\t\tbucketPolicy, err := globalPolicySys.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(BucketPolicyNotFound); !ok {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\n\t\tpolicyInfo, err = PolicyToBucketAccessPolicy(bucketPolicy)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\treply.Policy = miniogopolicy.GetPolicy(policyInfo.Statements, args.BucketName, args.Prefix)\n\n\treturn nil\n}\n\n// ListAllBucketPoliciesArgs - get all bucket policies.\ntype ListAllBucketPoliciesArgs struct {\n\tBucketName string `json:\"bucketName\"`\n}\n\n// BucketAccessPolicy - Collection of canned bucket policy at a given prefix.\ntype BucketAccessPolicy struct {\n\tBucket string                     `json:\"bucket\"`\n\tPrefix string                     `json:\"prefix\"`\n\tPolicy miniogopolicy.BucketPolicy `json:\"policy\"`\n}\n\n// ListAllBucketPoliciesRep - get all bucket policy reply.\ntype ListAllBucketPoliciesRep struct {\n\tUIVersion string               `json:\"uiVersion\"`\n\tPolicies  []BucketAccessPolicy `json:\"policies\"`\n}\n\n// ListAllBucketPolicies - get all bucket policy.\nfunc (web *webAPIHandlers) ListAllBucketPolicies(r *http.Request, args *ListAllBucketPoliciesArgs, reply *ListAllBucketPoliciesRep) error {\n\tctx := newWebContext(r, args, \"WebListAllBucketPolicies\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.GetBucketPolicyAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\tvar policyInfo = new(miniogopolicy.BucketAccessPolicy)\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, rerr := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif rerr != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tvar policyStr string\n\t\tpolicyStr, err = core.Client.GetBucketPolicy(ctx, args.BucketName)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tif policyStr != \"\" {\n\t\t\tif err = json.Unmarshal([]byte(policyStr), policyInfo); err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbucketPolicy, err := globalPolicySys.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(BucketPolicyNotFound); !ok {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\t\tpolicyInfo, err = PolicyToBucketAccessPolicy(bucketPolicy)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\tfor prefix, policy := range miniogopolicy.GetPolicies(policyInfo.Statements, args.BucketName, \"\") {\n\t\tbucketName, objectPrefix := path2BucketObject(prefix)\n\t\tobjectPrefix = strings.TrimSuffix(objectPrefix, \"*\")\n\t\treply.Policies = append(reply.Policies, BucketAccessPolicy{\n\t\t\tBucket: bucketName,\n\t\t\tPrefix: objectPrefix,\n\t\t\tPolicy: policy,\n\t\t})\n\t}\n\n\treturn nil\n}\n\n// SetBucketPolicyWebArgs - set bucket policy args.\ntype SetBucketPolicyWebArgs struct {\n\tBucketName string `json:\"bucketName\"`\n\tPrefix     string `json:\"prefix\"`\n\tPolicy     string `json:\"policy\"`\n}\n\n// SetBucketPolicy - set bucket policy.\nfunc (web *webAPIHandlers) SetBucketPolicy(r *http.Request, args *SetBucketPolicyWebArgs, reply *WebGenericRep) error {\n\tctx := newWebContext(r, args, \"WebSetBucketPolicy\")\n\tobjectAPI := web.ObjectAPI()\n\treply.UIVersion = browser.UIVersion\n\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.PutBucketPolicyAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\tpolicyType := miniogopolicy.BucketPolicy(args.Policy)\n\tif !policyType.IsValidBucketPolicy() {\n\t\treturn &json2.Error{\n\t\t\tMessage: \"Invalid policy type \" + args.Policy,\n\t\t}\n\t}\n\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, rerr := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif rerr != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tvar policyStr string\n\t\t// Use the abstracted API instead of core, such that\n\t\t// NoSuchBucketPolicy errors are automatically handled.\n\t\tpolicyStr, err = core.Client.GetBucketPolicy(ctx, args.BucketName)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tvar policyInfo = &miniogopolicy.BucketAccessPolicy{Version: \"2012-10-17\"}\n\t\tif policyStr != \"\" {\n\t\t\tif err = json.Unmarshal([]byte(policyStr), policyInfo); err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\n\t\tpolicyInfo.Statements = miniogopolicy.SetPolicy(policyInfo.Statements, policyType, args.BucketName, args.Prefix)\n\t\tif len(policyInfo.Statements) == 0 {\n\t\t\tif err = core.SetBucketPolicy(ctx, args.BucketName, \"\"); err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tbucketPolicy, err := BucketAccessPolicyToPolicy(policyInfo)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tpolicyData, err := json.Marshal(bucketPolicy)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tif err = core.SetBucketPolicy(ctx, args.BucketName, string(policyData)); err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t} else {\n\t\tbucketPolicy, err := globalPolicySys.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(BucketPolicyNotFound); !ok {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\t\tpolicyInfo, err := PolicyToBucketAccessPolicy(bucketPolicy)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tpolicyInfo.Statements = miniogopolicy.SetPolicy(policyInfo.Statements, policyType, args.BucketName, args.Prefix)\n\t\tif len(policyInfo.Statements) == 0 {\n\t\t\tif err = globalBucketMetadataSys.Update(args.BucketName, bucketPolicyConfig, nil); err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\n\t\tbucketPolicy, err = BucketAccessPolicyToPolicy(policyInfo)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tconfigData, err := json.Marshal(bucketPolicy)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\t// Parse validate and save bucket policy.\n\t\tif err = globalBucketMetadataSys.Update(args.BucketName, bucketPolicyConfig, configData); err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// PresignedGetArgs - presigned-get API args.\ntype PresignedGetArgs struct {\n\t// Host header required for signed headers.\n\tHostName string `json:\"host\"`\n\n\t// Bucket name of the object to be presigned.\n\tBucketName string `json:\"bucket\"`\n\n\t// Object name to be presigned.\n\tObjectName string `json:\"object\"`\n\n\t// Expiry in seconds.\n\tExpiry int64 `json:\"expiry\"`\n}\n\n// PresignedGetRep - presigned-get URL reply.\ntype PresignedGetRep struct {\n\tUIVersion string `json:\"uiVersion\"`\n\t// Presigned URL of the object.\n\tURL string `json:\"url\"`\n}\n\n// PresignedGET - returns presigned-Get url.\nfunc (web *webAPIHandlers) PresignedGet(r *http.Request, args *PresignedGetArgs, reply *PresignedGetRep) error {\n\tctx := newWebContext(r, args, \"WebPresignedGet\")\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\tvar creds auth.Credentials\n\tif !owner {\n\t\tvar ok bool\n\t\tcreds, ok = globalIAMSys.GetUser(claims.AccessKey)\n\t\tif !ok {\n\t\t\treturn toJSONError(ctx, errInvalidAccessKeyID)\n\t\t}\n\t} else {\n\t\tcreds = globalActiveCred\n\t}\n\n\tregion := globalServerRegion\n\tif args.BucketName == \"\" || args.ObjectName == \"\" {\n\t\treturn &json2.Error{\n\t\t\tMessage: \"Bucket and Object are mandatory arguments.\",\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\t// Check if the user indeed has GetObject access,\n\t// if not we do not need to generate presigned URLs\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.GetObjectAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tObjectName:      args.ObjectName,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errPresignedNotAllowed)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\treply.URL = presignedGet(args.HostName, args.BucketName, args.ObjectName, args.Expiry, creds, region)\n\treturn nil\n}\n\n// Returns presigned url for GET method.\nfunc presignedGet(host, bucket, object string, expiry int64, creds auth.Credentials, region string) string {\n\taccessKey := creds.AccessKey\n\tsecretKey := creds.SecretKey\n\tsessionToken := creds.SessionToken\n\n\tdate := UTCNow()\n\tdateStr := date.Format(iso8601Format)\n\tcredential := fmt.Sprintf(\"%s/%s\", accessKey, getScope(date, region))\n\n\tvar expiryStr = \"604800\" // Default set to be expire in 7days.\n\tif expiry < 604800 && expiry > 0 {\n\t\texpiryStr = strconv.FormatInt(expiry, 10)\n\t}\n\n\tquery := url.Values{}\n\tquery.Set(xhttp.AmzAlgorithm, signV4Algorithm)\n\tquery.Set(xhttp.AmzCredential, credential)\n\tquery.Set(xhttp.AmzDate, dateStr)\n\tquery.Set(xhttp.AmzExpires, expiryStr)\n\t// Set session token if available.\n\tif sessionToken != \"\" {\n\t\tquery.Set(xhttp.AmzSecurityToken, sessionToken)\n\t}\n\tquery.Set(xhttp.AmzSignedHeaders, \"host\")\n\tqueryStr := s3utils.QueryEncode(query)\n\n\tpath := SlashSeparator + path.Join(bucket, object)\n\n\t// \"host\" is the only header required to be signed for Presigned URLs.\n\textractedSignedHeaders := make(http.Header)\n\textractedSignedHeaders.Set(\"host\", host)\n\tcanonicalRequest := getCanonicalRequest(extractedSignedHeaders, unsignedPayload, queryStr, path, http.MethodGet)\n\tstringToSign := getStringToSign(canonicalRequest, date, getScope(date, region))\n\tsigningKey := getSigningKey(secretKey, date, region, serviceS3)\n\tsignature := getSignature(signingKey, stringToSign)\n\n\treturn host + s3utils.EncodePath(path) + \"?\" + queryStr + \"&\" + xhttp.AmzSignature + \"=\" + signature\n}\n\n// DiscoveryDocResp - OpenID discovery document reply.\ntype DiscoveryDocResp struct {\n\tDiscoveryDoc openid.DiscoveryDoc\n\tUIVersion    string `json:\"uiVersion\"`\n\tClientID     string `json:\"clientId\"`\n}\n\n// GetDiscoveryDoc - returns parsed value of OpenID discovery document\nfunc (web *webAPIHandlers) GetDiscoveryDoc(r *http.Request, args *WebGenericArgs, reply *DiscoveryDocResp) error {\n\tif globalOpenIDConfig.DiscoveryDoc.AuthEndpoint != \"\" {\n\t\treply.DiscoveryDoc = globalOpenIDConfig.DiscoveryDoc\n\t\treply.ClientID = globalOpenIDConfig.ClientID\n\t}\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// LoginSTSArgs - login arguments.\ntype LoginSTSArgs struct {\n\tToken string `json:\"token\" form:\"token\"`\n}\n\n// LoginSTS - STS user login handler.\nfunc (web *webAPIHandlers) LoginSTS(r *http.Request, args *LoginSTSArgs, reply *LoginRep) error {\n\tctx := newWebContext(r, args, \"WebLoginSTS\")\n\n\tv := url.Values{}\n\tv.Set(\"Action\", webIdentity)\n\tv.Set(\"WebIdentityToken\", args.Token)\n\tv.Set(\"Version\", stsAPIVersion)\n\n\tscheme := \"http\"\n\tif sourceScheme := handlers.GetSourceScheme(r); sourceScheme != \"\" {\n\t\tscheme = sourceScheme\n\t}\n\tif globalIsTLS {\n\t\tscheme = \"https\"\n\t}\n\n\tu := &url.URL{\n\t\tScheme: scheme,\n\t\tHost:   r.Host,\n\t}\n\n\tu.RawQuery = v.Encode()\n\n\treq, err := http.NewRequest(http.MethodPost, u.String(), nil)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\tclnt := &http.Client{\n\t\tTransport: NewGatewayHTTPTransport(),\n\t}\n\tresp, err := clnt.Do(req)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\tdefer xhttp.DrainBody(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn toJSONError(ctx, errors.New(resp.Status))\n\t}\n\n\ta := AssumeRoleWithWebIdentityResponse{}\n\tif err = xml.NewDecoder(resp.Body).Decode(&a); err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\treply.Token = a.Result.Credentials.SessionToken\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// toJSONError converts regular errors into more user friendly\n// and consumable error message for the browser UI.\nfunc toJSONError(ctx context.Context, err error, params ...string) (jerr *json2.Error) {\n\tapiErr := toWebAPIError(ctx, err)\n\tjerr = &json2.Error{\n\t\tMessage: apiErr.Description,\n\t}\n\tswitch apiErr.Code {\n\t// Reserved bucket name provided.\n\tcase \"AllAccessDisabled\":\n\t\tif len(params) > 0 {\n\t\t\tjerr = &json2.Error{\n\t\t\t\tMessage: fmt.Sprintf(\"All access to this bucket %s has been disabled.\", params[0]),\n\t\t\t}\n\t\t}\n\t// Bucket name invalid with custom error message.\n\tcase \"InvalidBucketName\":\n\t\tif len(params) > 0 {\n\t\t\tjerr = &json2.Error{\n\t\t\t\tMessage: fmt.Sprintf(\"Bucket Name %s is invalid. Lowercase letters, period, hyphen, numerals are the only allowed characters and should be minimum 3 characters in length.\", params[0]),\n\t\t\t}\n\t\t}\n\t// Bucket not found custom error message.\n\tcase \"NoSuchBucket\":\n\t\tif len(params) > 0 {\n\t\t\tjerr = &json2.Error{\n\t\t\t\tMessage: fmt.Sprintf(\"The specified bucket %s does not exist.\", params[0]),\n\t\t\t}\n\t\t}\n\t// Object not found custom error message.\n\tcase \"NoSuchKey\":\n\t\tif len(params) > 1 {\n\t\t\tjerr = &json2.Error{\n\t\t\t\tMessage: fmt.Sprintf(\"The specified key %s does not exist\", params[1]),\n\t\t\t}\n\t\t}\n\t\t// Add more custom error messages here with more context.\n\t}\n\treturn jerr\n}\n\n// toWebAPIError - convert into error into APIError.\nfunc toWebAPIError(ctx context.Context, err error) APIError {\n\tswitch err {\n\tcase errNoAuthToken:\n\t\treturn APIError{\n\t\t\tCode:           \"WebTokenMissing\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errServerNotInitialized:\n\t\treturn APIError{\n\t\t\tCode:           \"XMinioServerNotInitialized\",\n\t\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errAuthentication, auth.ErrInvalidAccessKeyLength,\n\t\tauth.ErrInvalidSecretKeyLength, errInvalidAccessKeyID, errAccessDenied, errLockedObject:\n\t\treturn APIError{\n\t\t\tCode:           \"AccessDenied\",\n\t\t\tHTTPStatusCode: http.StatusForbidden,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errSizeUnspecified:\n\t\treturn APIError{\n\t\t\tCode:           \"InvalidRequest\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errChangeCredNotAllowed:\n\t\treturn APIError{\n\t\t\tCode:           \"MethodNotAllowed\",\n\t\t\tHTTPStatusCode: http.StatusMethodNotAllowed,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errInvalidBucketName:\n\t\treturn APIError{\n\t\t\tCode:           \"InvalidBucketName\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errInvalidArgument:\n\t\treturn APIError{\n\t\t\tCode:           \"InvalidArgument\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errEncryptedObject:\n\t\treturn getAPIError(ErrSSEEncryptedObject)\n\tcase errInvalidEncryptionParameters:\n\t\treturn getAPIError(ErrInvalidEncryptionParameters)\n\tcase errObjectTampered:\n\t\treturn getAPIError(ErrObjectTampered)\n\tcase errMethodNotAllowed:\n\t\treturn getAPIError(ErrMethodNotAllowed)\n\t}\n\n\t// Convert error type to api error code.\n\tswitch err.(type) {\n\tcase StorageFull:\n\t\treturn getAPIError(ErrStorageFull)\n\tcase BucketQuotaExceeded:\n\t\treturn getAPIError(ErrAdminBucketQuotaExceeded)\n\tcase BucketNotFound:\n\t\treturn getAPIError(ErrNoSuchBucket)\n\tcase BucketNotEmpty:\n\t\treturn getAPIError(ErrBucketNotEmpty)\n\tcase BucketExists:\n\t\treturn getAPIError(ErrBucketAlreadyOwnedByYou)\n\tcase BucketNameInvalid:\n\t\treturn getAPIError(ErrInvalidBucketName)\n\tcase hash.BadDigest:\n\t\treturn getAPIError(ErrBadDigest)\n\tcase IncompleteBody:\n\t\treturn getAPIError(ErrIncompleteBody)\n\tcase ObjectExistsAsDirectory:\n\t\treturn getAPIError(ErrObjectExistsAsDirectory)\n\tcase ObjectNotFound:\n\t\treturn getAPIError(ErrNoSuchKey)\n\tcase ObjectNameInvalid:\n\t\treturn getAPIError(ErrNoSuchKey)\n\tcase InsufficientWriteQuorum:\n\t\treturn getAPIError(ErrWriteQuorum)\n\tcase InsufficientReadQuorum:\n\t\treturn getAPIError(ErrReadQuorum)\n\tcase NotImplemented:\n\t\treturn APIError{\n\t\t\tCode:           \"NotImplemented\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    \"Functionality not implemented\",\n\t\t}\n\t}\n\n\t// Log unexpected and unhandled errors.\n\tlogger.LogIf(ctx, err)\n\treturn toAPIError(ctx, err)\n}\n\n// writeWebErrorResponse - set HTTP status code and write error description to the body.\nfunc writeWebErrorResponse(w http.ResponseWriter, err error) {\n\treqInfo := &logger.ReqInfo{\n\t\tDeploymentID: globalDeploymentID,\n\t}\n\tctx := logger.SetReqInfo(GlobalContext, reqInfo)\n\tapiErr := toWebAPIError(ctx, err)\n\tw.WriteHeader(apiErr.HTTPStatusCode)\n\tw.Write([]byte(apiErr.Description))\n}\n"], "fixing_code": ["/*\n * MinIO Cloud Storage, (C) 2015, 2016, 2017, 2018 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/Azure/azure-storage-blob-go/azblob\"\n\t\"google.golang.org/api/googleapi\"\n\n\tminio \"github.com/minio/minio-go/v7\"\n\t\"github.com/minio/minio-go/v7/pkg/tags\"\n\t\"github.com/minio/minio/cmd/config/dns\"\n\t\"github.com/minio/minio/cmd/crypto\"\n\t\"github.com/minio/minio/cmd/logger\"\n\t\"github.com/minio/minio/pkg/auth\"\n\t\"github.com/minio/minio/pkg/bucket/lifecycle\"\n\t\"github.com/minio/minio/pkg/bucket/replication\"\n\n\tobjectlock \"github.com/minio/minio/pkg/bucket/object/lock\"\n\t\"github.com/minio/minio/pkg/bucket/policy\"\n\t\"github.com/minio/minio/pkg/bucket/versioning\"\n\t\"github.com/minio/minio/pkg/event\"\n\t\"github.com/minio/minio/pkg/hash\"\n)\n\n// APIError structure\ntype APIError struct {\n\tCode           string\n\tDescription    string\n\tHTTPStatusCode int\n}\n\n// APIErrorResponse - error response format\ntype APIErrorResponse struct {\n\tXMLName    xml.Name `xml:\"Error\" json:\"-\"`\n\tCode       string\n\tMessage    string\n\tKey        string `xml:\"Key,omitempty\" json:\"Key,omitempty\"`\n\tBucketName string `xml:\"BucketName,omitempty\" json:\"BucketName,omitempty\"`\n\tResource   string\n\tRegion     string `xml:\"Region,omitempty\" json:\"Region,omitempty\"`\n\tRequestID  string `xml:\"RequestId\" json:\"RequestId\"`\n\tHostID     string `xml:\"HostId\" json:\"HostId\"`\n}\n\n// APIErrorCode type of error status.\ntype APIErrorCode int\n\n// Error codes, non exhaustive list - http://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\nconst (\n\tErrNone APIErrorCode = iota\n\tErrAccessDenied\n\tErrBadDigest\n\tErrEntityTooSmall\n\tErrEntityTooLarge\n\tErrPolicyTooLarge\n\tErrIncompleteBody\n\tErrInternalError\n\tErrInvalidAccessKeyID\n\tErrInvalidBucketName\n\tErrInvalidDigest\n\tErrInvalidRange\n\tErrInvalidCopyPartRange\n\tErrInvalidCopyPartRangeSource\n\tErrInvalidMaxKeys\n\tErrInvalidEncodingMethod\n\tErrInvalidMaxUploads\n\tErrInvalidMaxParts\n\tErrInvalidPartNumberMarker\n\tErrInvalidPartNumber\n\tErrInvalidRequestBody\n\tErrInvalidCopySource\n\tErrInvalidMetadataDirective\n\tErrInvalidCopyDest\n\tErrInvalidPolicyDocument\n\tErrInvalidObjectState\n\tErrMalformedXML\n\tErrMissingContentLength\n\tErrMissingContentMD5\n\tErrMissingRequestBodyError\n\tErrMissingSecurityHeader\n\tErrNoSuchBucket\n\tErrNoSuchBucketPolicy\n\tErrNoSuchBucketLifecycle\n\tErrNoSuchLifecycleConfiguration\n\tErrNoSuchBucketSSEConfig\n\tErrNoSuchCORSConfiguration\n\tErrNoSuchWebsiteConfiguration\n\tErrReplicationConfigurationNotFoundError\n\tErrRemoteDestinationNotFoundError\n\tErrReplicationDestinationMissingLock\n\tErrRemoteTargetNotFoundError\n\tErrReplicationRemoteConnectionError\n\tErrBucketRemoteIdenticalToSource\n\tErrBucketRemoteAlreadyExists\n\tErrBucketRemoteLabelInUse\n\tErrBucketRemoteArnTypeInvalid\n\tErrBucketRemoteArnInvalid\n\tErrBucketRemoteRemoveDisallowed\n\tErrRemoteTargetNotVersionedError\n\tErrReplicationSourceNotVersionedError\n\tErrReplicationNeedsVersioningError\n\tErrReplicationBucketNeedsVersioningError\n\tErrObjectRestoreAlreadyInProgress\n\tErrNoSuchKey\n\tErrNoSuchUpload\n\tErrInvalidVersionID\n\tErrNoSuchVersion\n\tErrNotImplemented\n\tErrPreconditionFailed\n\tErrRequestTimeTooSkewed\n\tErrSignatureDoesNotMatch\n\tErrMethodNotAllowed\n\tErrInvalidPart\n\tErrInvalidPartOrder\n\tErrAuthorizationHeaderMalformed\n\tErrMalformedPOSTRequest\n\tErrPOSTFileRequired\n\tErrSignatureVersionNotSupported\n\tErrBucketNotEmpty\n\tErrAllAccessDisabled\n\tErrMalformedPolicy\n\tErrMissingFields\n\tErrMissingCredTag\n\tErrCredMalformed\n\tErrInvalidRegion\n\tErrInvalidServiceS3\n\tErrInvalidServiceSTS\n\tErrInvalidRequestVersion\n\tErrMissingSignTag\n\tErrMissingSignHeadersTag\n\tErrMalformedDate\n\tErrMalformedPresignedDate\n\tErrMalformedCredentialDate\n\tErrMalformedCredentialRegion\n\tErrMalformedExpires\n\tErrNegativeExpires\n\tErrAuthHeaderEmpty\n\tErrExpiredPresignRequest\n\tErrRequestNotReadyYet\n\tErrUnsignedHeaders\n\tErrMissingDateHeader\n\tErrInvalidQuerySignatureAlgo\n\tErrInvalidQueryParams\n\tErrBucketAlreadyOwnedByYou\n\tErrInvalidDuration\n\tErrBucketAlreadyExists\n\tErrMetadataTooLarge\n\tErrUnsupportedMetadata\n\tErrMaximumExpires\n\tErrSlowDown\n\tErrInvalidPrefixMarker\n\tErrBadRequest\n\tErrKeyTooLongError\n\tErrInvalidBucketObjectLockConfiguration\n\tErrObjectLockConfigurationNotFound\n\tErrObjectLockConfigurationNotAllowed\n\tErrNoSuchObjectLockConfiguration\n\tErrObjectLocked\n\tErrInvalidRetentionDate\n\tErrPastObjectLockRetainDate\n\tErrUnknownWORMModeDirective\n\tErrBucketTaggingNotFound\n\tErrObjectLockInvalidHeaders\n\tErrInvalidTagDirective\n\t// Add new error codes here.\n\n\t// SSE-S3 related API errors\n\tErrInvalidEncryptionMethod\n\n\t// Server-Side-Encryption (with Customer provided key) related API errors.\n\tErrInsecureSSECustomerRequest\n\tErrSSEMultipartEncrypted\n\tErrSSEEncryptedObject\n\tErrInvalidEncryptionParameters\n\tErrInvalidSSECustomerAlgorithm\n\tErrInvalidSSECustomerKey\n\tErrMissingSSECustomerKey\n\tErrMissingSSECustomerKeyMD5\n\tErrSSECustomerKeyMD5Mismatch\n\tErrInvalidSSECustomerParameters\n\tErrIncompatibleEncryptionMethod\n\tErrKMSNotConfigured\n\tErrKMSAuthFailure\n\n\tErrNoAccessKey\n\tErrInvalidToken\n\n\t// Bucket notification related errors.\n\tErrEventNotification\n\tErrARNNotification\n\tErrRegionNotification\n\tErrOverlappingFilterNotification\n\tErrFilterNameInvalid\n\tErrFilterNamePrefix\n\tErrFilterNameSuffix\n\tErrFilterValueInvalid\n\tErrOverlappingConfigs\n\tErrUnsupportedNotification\n\n\t// S3 extended errors.\n\tErrContentSHA256Mismatch\n\n\t// Add new extended error codes here.\n\n\t// MinIO extended errors.\n\tErrReadQuorum\n\tErrWriteQuorum\n\tErrParentIsObject\n\tErrStorageFull\n\tErrRequestBodyParse\n\tErrObjectExistsAsDirectory\n\tErrInvalidObjectName\n\tErrInvalidObjectNamePrefixSlash\n\tErrInvalidResourceName\n\tErrServerNotInitialized\n\tErrOperationTimedOut\n\tErrClientDisconnected\n\tErrOperationMaxedOut\n\tErrInvalidRequest\n\t// MinIO storage class error codes\n\tErrInvalidStorageClass\n\tErrBackendDown\n\t// Add new extended error codes here.\n\t// Please open a https://github.com/minio/minio/issues before adding\n\t// new error codes here.\n\n\tErrMalformedJSON\n\tErrAdminNoSuchUser\n\tErrAdminNoSuchGroup\n\tErrAdminGroupNotEmpty\n\tErrAdminNoSuchPolicy\n\tErrAdminInvalidArgument\n\tErrAdminInvalidAccessKey\n\tErrAdminInvalidSecretKey\n\tErrAdminConfigNoQuorum\n\tErrAdminConfigTooLarge\n\tErrAdminConfigBadJSON\n\tErrAdminConfigDuplicateKeys\n\tErrAdminCredentialsMismatch\n\tErrInsecureClientRequest\n\tErrObjectTampered\n\t// Bucket Quota error codes\n\tErrAdminBucketQuotaExceeded\n\tErrAdminNoSuchQuotaConfiguration\n\n\tErrHealNotImplemented\n\tErrHealNoSuchProcess\n\tErrHealInvalidClientToken\n\tErrHealMissingBucket\n\tErrHealAlreadyRunning\n\tErrHealOverlappingPaths\n\tErrIncorrectContinuationToken\n\n\t// S3 Select Errors\n\tErrEmptyRequestBody\n\tErrUnsupportedFunction\n\tErrInvalidExpressionType\n\tErrBusy\n\tErrUnauthorizedAccess\n\tErrExpressionTooLong\n\tErrIllegalSQLFunctionArgument\n\tErrInvalidKeyPath\n\tErrInvalidCompressionFormat\n\tErrInvalidFileHeaderInfo\n\tErrInvalidJSONType\n\tErrInvalidQuoteFields\n\tErrInvalidRequestParameter\n\tErrInvalidDataType\n\tErrInvalidTextEncoding\n\tErrInvalidDataSource\n\tErrInvalidTableAlias\n\tErrMissingRequiredParameter\n\tErrObjectSerializationConflict\n\tErrUnsupportedSQLOperation\n\tErrUnsupportedSQLStructure\n\tErrUnsupportedSyntax\n\tErrUnsupportedRangeHeader\n\tErrLexerInvalidChar\n\tErrLexerInvalidOperator\n\tErrLexerInvalidLiteral\n\tErrLexerInvalidIONLiteral\n\tErrParseExpectedDatePart\n\tErrParseExpectedKeyword\n\tErrParseExpectedTokenType\n\tErrParseExpected2TokenTypes\n\tErrParseExpectedNumber\n\tErrParseExpectedRightParenBuiltinFunctionCall\n\tErrParseExpectedTypeName\n\tErrParseExpectedWhenClause\n\tErrParseUnsupportedToken\n\tErrParseUnsupportedLiteralsGroupBy\n\tErrParseExpectedMember\n\tErrParseUnsupportedSelect\n\tErrParseUnsupportedCase\n\tErrParseUnsupportedCaseClause\n\tErrParseUnsupportedAlias\n\tErrParseUnsupportedSyntax\n\tErrParseUnknownOperator\n\tErrParseMissingIdentAfterAt\n\tErrParseUnexpectedOperator\n\tErrParseUnexpectedTerm\n\tErrParseUnexpectedToken\n\tErrParseUnexpectedKeyword\n\tErrParseExpectedExpression\n\tErrParseExpectedLeftParenAfterCast\n\tErrParseExpectedLeftParenValueConstructor\n\tErrParseExpectedLeftParenBuiltinFunctionCall\n\tErrParseExpectedArgumentDelimiter\n\tErrParseCastArity\n\tErrParseInvalidTypeParam\n\tErrParseEmptySelect\n\tErrParseSelectMissingFrom\n\tErrParseExpectedIdentForGroupName\n\tErrParseExpectedIdentForAlias\n\tErrParseUnsupportedCallWithStar\n\tErrParseNonUnaryAgregateFunctionCall\n\tErrParseMalformedJoin\n\tErrParseExpectedIdentForAt\n\tErrParseAsteriskIsNotAloneInSelectList\n\tErrParseCannotMixSqbAndWildcardInSelectList\n\tErrParseInvalidContextForWildcardInSelectList\n\tErrIncorrectSQLFunctionArgumentType\n\tErrValueParseFailure\n\tErrEvaluatorInvalidArguments\n\tErrIntegerOverflow\n\tErrLikeInvalidInputs\n\tErrCastFailed\n\tErrInvalidCast\n\tErrEvaluatorInvalidTimestampFormatPattern\n\tErrEvaluatorInvalidTimestampFormatPatternSymbolForParsing\n\tErrEvaluatorTimestampFormatPatternDuplicateFields\n\tErrEvaluatorTimestampFormatPatternHourClockAmPmMismatch\n\tErrEvaluatorUnterminatedTimestampFormatPatternToken\n\tErrEvaluatorInvalidTimestampFormatPatternToken\n\tErrEvaluatorInvalidTimestampFormatPatternSymbol\n\tErrEvaluatorBindingDoesNotExist\n\tErrMissingHeaders\n\tErrInvalidColumnIndex\n\n\tErrAdminConfigNotificationTargetsFailed\n\tErrAdminProfilerNotEnabled\n\tErrInvalidDecompressedSize\n\tErrAddUserInvalidArgument\n\tErrAdminAccountNotEligible\n\tErrAccountNotEligible\n\tErrServiceAccountNotFound\n\tErrPostPolicyConditionInvalidFormat\n)\n\ntype errorCodeMap map[APIErrorCode]APIError\n\nfunc (e errorCodeMap) ToAPIErrWithErr(errCode APIErrorCode, err error) APIError {\n\tapiErr, ok := e[errCode]\n\tif !ok {\n\t\tapiErr = e[ErrInternalError]\n\t}\n\tif err != nil {\n\t\tapiErr.Description = fmt.Sprintf(\"%s (%s)\", apiErr.Description, err)\n\t}\n\treturn apiErr\n}\n\nfunc (e errorCodeMap) ToAPIErr(errCode APIErrorCode) APIError {\n\treturn e.ToAPIErrWithErr(errCode, nil)\n}\n\n// error code to APIError structure, these fields carry respective\n// descriptions for all the error responses.\nvar errorCodes = errorCodeMap{\n\tErrInvalidCopyDest: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"This copy request is illegal because it is trying to copy an object to itself without changing the object's metadata, storage class, website redirect location or encryption attributes.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCopySource: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Copy Source must mention the source bucket and key: sourcebucket/sourcekey.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidMetadataDirective: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Unknown metadata directive.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidStorageClass: {\n\t\tCode:           \"InvalidStorageClass\",\n\t\tDescription:    \"Invalid storage class.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRequestBody: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Body shouldn't be set for this request.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidMaxUploads: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Argument max-uploads must be an integer between 0 and 2147483647\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidMaxKeys: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Argument maxKeys must be an integer between 0 and 2147483647\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidEncodingMethod: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Invalid Encoding Method specified in Request\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidMaxParts: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Argument max-parts must be an integer between 0 and 2147483647\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidPartNumberMarker: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Argument partNumberMarker must be an integer.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidPartNumber: {\n\t\tCode:           \"InvalidPartNumber\",\n\t\tDescription:    \"The requested partnumber is not satisfiable\",\n\t\tHTTPStatusCode: http.StatusRequestedRangeNotSatisfiable,\n\t},\n\tErrInvalidPolicyDocument: {\n\t\tCode:           \"InvalidPolicyDocument\",\n\t\tDescription:    \"The content of the form does not meet the conditions specified in the policy document.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAccessDenied: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"Access Denied.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrBadDigest: {\n\t\tCode:           \"BadDigest\",\n\t\tDescription:    \"The Content-Md5 you specified did not match what we received.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEntityTooSmall: {\n\t\tCode:           \"EntityTooSmall\",\n\t\tDescription:    \"Your proposed upload is smaller than the minimum allowed object size.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEntityTooLarge: {\n\t\tCode:           \"EntityTooLarge\",\n\t\tDescription:    \"Your proposed upload exceeds the maximum allowed object size.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrPolicyTooLarge: {\n\t\tCode:           \"PolicyTooLarge\",\n\t\tDescription:    \"Policy exceeds the maximum allowed document size.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIncompleteBody: {\n\t\tCode:           \"IncompleteBody\",\n\t\tDescription:    \"You did not provide the number of bytes specified by the Content-Length HTTP header.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInternalError: {\n\t\tCode:           \"InternalError\",\n\t\tDescription:    \"We encountered an internal error, please try again.\",\n\t\tHTTPStatusCode: http.StatusInternalServerError,\n\t},\n\tErrInvalidAccessKeyID: {\n\t\tCode:           \"InvalidAccessKeyId\",\n\t\tDescription:    \"The Access Key Id you provided does not exist in our records.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrInvalidBucketName: {\n\t\tCode:           \"InvalidBucketName\",\n\t\tDescription:    \"The specified bucket is not valid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidDigest: {\n\t\tCode:           \"InvalidDigest\",\n\t\tDescription:    \"The Content-Md5 you specified is not valid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRange: {\n\t\tCode:           \"InvalidRange\",\n\t\tDescription:    \"The requested range is not satisfiable\",\n\t\tHTTPStatusCode: http.StatusRequestedRangeNotSatisfiable,\n\t},\n\tErrMalformedXML: {\n\t\tCode:           \"MalformedXML\",\n\t\tDescription:    \"The XML you provided was not well-formed or did not validate against our published schema.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingContentLength: {\n\t\tCode:           \"MissingContentLength\",\n\t\tDescription:    \"You must provide the Content-Length HTTP header.\",\n\t\tHTTPStatusCode: http.StatusLengthRequired,\n\t},\n\tErrMissingContentMD5: {\n\t\tCode:           \"MissingContentMD5\",\n\t\tDescription:    \"Missing required header for this request: Content-Md5.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSecurityHeader: {\n\t\tCode:           \"MissingSecurityHeader\",\n\t\tDescription:    \"Your request was missing a required header\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingRequestBodyError: {\n\t\tCode:           \"MissingRequestBodyError\",\n\t\tDescription:    \"Request body is empty.\",\n\t\tHTTPStatusCode: http.StatusLengthRequired,\n\t},\n\tErrNoSuchBucket: {\n\t\tCode:           \"NoSuchBucket\",\n\t\tDescription:    \"The specified bucket does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchBucketPolicy: {\n\t\tCode:           \"NoSuchBucketPolicy\",\n\t\tDescription:    \"The bucket policy does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchBucketLifecycle: {\n\t\tCode:           \"NoSuchBucketLifecycle\",\n\t\tDescription:    \"The bucket lifecycle configuration does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchLifecycleConfiguration: {\n\t\tCode:           \"NoSuchLifecycleConfiguration\",\n\t\tDescription:    \"The lifecycle configuration does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchBucketSSEConfig: {\n\t\tCode:           \"ServerSideEncryptionConfigurationNotFoundError\",\n\t\tDescription:    \"The server side encryption configuration was not found\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchKey: {\n\t\tCode:           \"NoSuchKey\",\n\t\tDescription:    \"The specified key does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchUpload: {\n\t\tCode:           \"NoSuchUpload\",\n\t\tDescription:    \"The specified multipart upload does not exist. The upload ID may be invalid, or the upload may have been aborted or completed.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrInvalidVersionID: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Invalid version id specified\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrNoSuchVersion: {\n\t\tCode:           \"NoSuchVersion\",\n\t\tDescription:    \"The specified version does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNotImplemented: {\n\t\tCode:           \"NotImplemented\",\n\t\tDescription:    \"A header you provided implies functionality that is not implemented\",\n\t\tHTTPStatusCode: http.StatusNotImplemented,\n\t},\n\tErrPreconditionFailed: {\n\t\tCode:           \"PreconditionFailed\",\n\t\tDescription:    \"At least one of the pre-conditions you specified did not hold\",\n\t\tHTTPStatusCode: http.StatusPreconditionFailed,\n\t},\n\tErrRequestTimeTooSkewed: {\n\t\tCode:           \"RequestTimeTooSkewed\",\n\t\tDescription:    \"The difference between the request time and the server's time is too large.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrSignatureDoesNotMatch: {\n\t\tCode:           \"SignatureDoesNotMatch\",\n\t\tDescription:    \"The request signature we calculated does not match the signature you provided. Check your key and signing method.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrMethodNotAllowed: {\n\t\tCode:           \"MethodNotAllowed\",\n\t\tDescription:    \"The specified method is not allowed against this resource.\",\n\t\tHTTPStatusCode: http.StatusMethodNotAllowed,\n\t},\n\tErrInvalidPart: {\n\t\tCode:           \"InvalidPart\",\n\t\tDescription:    \"One or more of the specified parts could not be found.  The part may not have been uploaded, or the specified entity tag may not match the part's entity tag.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidPartOrder: {\n\t\tCode:           \"InvalidPartOrder\",\n\t\tDescription:    \"The list of parts was not in ascending order. The parts list must be specified in order by part number.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidObjectState: {\n\t\tCode:           \"InvalidObjectState\",\n\t\tDescription:    \"The operation is not valid for the current state of the object.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrAuthorizationHeaderMalformed: {\n\t\tCode:           \"AuthorizationHeaderMalformed\",\n\t\tDescription:    \"The authorization header is malformed; the region is wrong; expecting 'us-east-1'.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedPOSTRequest: {\n\t\tCode:           \"MalformedPOSTRequest\",\n\t\tDescription:    \"The body of your POST request is not well-formed multipart/form-data.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrPOSTFileRequired: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"POST requires exactly one file upload per request.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrSignatureVersionNotSupported: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The authorization mechanism you have provided is not supported. Please use AWS4-HMAC-SHA256.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketNotEmpty: {\n\t\tCode:           \"BucketNotEmpty\",\n\t\tDescription:    \"The bucket you tried to delete is not empty\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrBucketAlreadyExists: {\n\t\tCode:           \"BucketAlreadyExists\",\n\t\tDescription:    \"The requested bucket name is not available. The bucket namespace is shared by all users of the system. Please select a different name and try again.\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrAllAccessDisabled: {\n\t\tCode:           \"AllAccessDisabled\",\n\t\tDescription:    \"All access to this bucket has been disabled.\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrMalformedPolicy: {\n\t\tCode:           \"MalformedPolicy\",\n\t\tDescription:    \"Policy has invalid resource.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingFields: {\n\t\tCode:           \"MissingFields\",\n\t\tDescription:    \"Missing fields in request.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingCredTag: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Missing Credential field for this request.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrCredMalformed: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"Error parsing the X-Amz-Credential parameter; the Credential is mal-formed; expecting \\\"<YOUR-AKID>/YYYYMMDD/REGION/SERVICE/aws4_request\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedDate: {\n\t\tCode:           \"MalformedDate\",\n\t\tDescription:    \"Invalid date format header, expected to be in ISO8601, RFC1123 or RFC1123Z time format.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedPresignedDate: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Date must be in the ISO8601 Long Format \\\"yyyyMMdd'T'HHmmss'Z'\\\"\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedCredentialDate: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"Error parsing the X-Amz-Credential parameter; incorrect date format. This date in the credential must be in the format \\\"yyyyMMdd\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRegion: {\n\t\tCode:           \"InvalidRegion\",\n\t\tDescription:    \"Region does not match.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidServiceS3: {\n\t\tCode:           \"AuthorizationParametersError\",\n\t\tDescription:    \"Error parsing the Credential/X-Amz-Credential parameter; incorrect service. This endpoint belongs to \\\"s3\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidServiceSTS: {\n\t\tCode:           \"AuthorizationParametersError\",\n\t\tDescription:    \"Error parsing the Credential parameter; incorrect service. This endpoint belongs to \\\"sts\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRequestVersion: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"Error parsing the X-Amz-Credential parameter; incorrect terminal. This endpoint uses \\\"aws4_request\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSignTag: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"Signature header missing Signature field.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSignHeadersTag: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Signature header missing SignedHeaders field.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMalformedExpires: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Expires should be a number\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrNegativeExpires: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Expires must be non-negative\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAuthHeaderEmpty: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Authorization header is invalid -- one and only one ' ' (space) required.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingDateHeader: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"AWS authentication requires a valid Date or x-amz-date header\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidQuerySignatureAlgo: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Algorithm only supports \\\"AWS4-HMAC-SHA256\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrExpiredPresignRequest: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"Request has expired\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrRequestNotReadyYet: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"Request is not valid yet\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrSlowDown: {\n\t\tCode:           \"SlowDown\",\n\t\tDescription:    \"Please reduce your request\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrInvalidPrefixMarker: {\n\t\tCode:           \"InvalidPrefixMarker\",\n\t\tDescription:    \"Invalid marker prefix combination\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBadRequest: {\n\t\tCode:           \"BadRequest\",\n\t\tDescription:    \"400 BadRequest\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrKeyTooLongError: {\n\t\tCode:           \"KeyTooLongError\",\n\t\tDescription:    \"Your key is too long\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsignedHeaders: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"There were headers present in the request which were not signed\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidQueryParams: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"Query-string authentication version 4 requires the X-Amz-Algorithm, X-Amz-Credential, X-Amz-Signature, X-Amz-Date, X-Amz-SignedHeaders, and X-Amz-Expires parameters.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketAlreadyOwnedByYou: {\n\t\tCode:           \"BucketAlreadyOwnedByYou\",\n\t\tDescription:    \"Your previous request to create the named bucket succeeded and you already own it.\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrInvalidDuration: {\n\t\tCode:           \"InvalidDuration\",\n\t\tDescription:    \"Duration provided in the request is invalid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidBucketObjectLockConfiguration: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Bucket is missing ObjectLockConfiguration\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketTaggingNotFound: {\n\t\tCode:           \"NoSuchTagSet\",\n\t\tDescription:    \"The TagSet does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrObjectLockConfigurationNotFound: {\n\t\tCode:           \"ObjectLockConfigurationNotFoundError\",\n\t\tDescription:    \"Object Lock configuration does not exist for this bucket\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrObjectLockConfigurationNotAllowed: {\n\t\tCode:           \"InvalidBucketState\",\n\t\tDescription:    \"Object Lock configuration cannot be enabled on existing buckets\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrNoSuchCORSConfiguration: {\n\t\tCode:           \"NoSuchCORSConfiguration\",\n\t\tDescription:    \"The CORS configuration does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrNoSuchWebsiteConfiguration: {\n\t\tCode:           \"NoSuchWebsiteConfiguration\",\n\t\tDescription:    \"The specified bucket does not have a website configuration\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrReplicationConfigurationNotFoundError: {\n\t\tCode:           \"ReplicationConfigurationNotFoundError\",\n\t\tDescription:    \"The replication configuration was not found\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrRemoteDestinationNotFoundError: {\n\t\tCode:           \"RemoteDestinationNotFoundError\",\n\t\tDescription:    \"The remote destination bucket does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrReplicationDestinationMissingLock: {\n\t\tCode:           \"ReplicationDestinationMissingLockError\",\n\t\tDescription:    \"The replication destination bucket does not have object locking enabled\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrRemoteTargetNotFoundError: {\n\t\tCode:           \"XMinioAdminRemoteTargetNotFoundError\",\n\t\tDescription:    \"The remote target does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrReplicationRemoteConnectionError: {\n\t\tCode:           \"XMinioAdminReplicationRemoteConnectionError\",\n\t\tDescription:    \"Remote service connection error - please check remote service credentials and target bucket\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrBucketRemoteIdenticalToSource: {\n\t\tCode:           \"XMinioAdminRemoteIdenticalToSource\",\n\t\tDescription:    \"The remote target cannot be identical to source\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteAlreadyExists: {\n\t\tCode:           \"XMinioAdminBucketRemoteAlreadyExists\",\n\t\tDescription:    \"The remote target already exists\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteLabelInUse: {\n\t\tCode:           \"XMinioAdminBucketRemoteLabelInUse\",\n\t\tDescription:    \"The remote target with this label already exists\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteRemoveDisallowed: {\n\t\tCode:           \"XMinioAdminRemoteRemoveDisallowed\",\n\t\tDescription:    \"This ARN is in use by an existing configuration\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteArnTypeInvalid: {\n\t\tCode:           \"XMinioAdminRemoteARNTypeInvalid\",\n\t\tDescription:    \"The bucket remote ARN type is not valid\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBucketRemoteArnInvalid: {\n\t\tCode:           \"XMinioAdminRemoteArnInvalid\",\n\t\tDescription:    \"The bucket remote ARN does not have correct format\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrRemoteTargetNotVersionedError: {\n\t\tCode:           \"RemoteTargetNotVersionedError\",\n\t\tDescription:    \"The remote target does not have versioning enabled\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrReplicationSourceNotVersionedError: {\n\t\tCode:           \"ReplicationSourceNotVersionedError\",\n\t\tDescription:    \"The replication source does not have versioning enabled\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrReplicationNeedsVersioningError: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Versioning must be 'Enabled' on the bucket to apply a replication configuration\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrReplicationBucketNeedsVersioningError: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Versioning must be 'Enabled' on the bucket to add a replication target\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrNoSuchObjectLockConfiguration: {\n\t\tCode:           \"NoSuchObjectLockConfiguration\",\n\t\tDescription:    \"The specified object does not have a ObjectLock configuration\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectLocked: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Object is WORM protected and cannot be overwritten\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRetentionDate: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Date must be provided in ISO 8601 format\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrPastObjectLockRetainDate: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"the retain until date must be in the future\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnknownWORMModeDirective: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"unknown wormMode directive\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectLockInvalidHeaders: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"x-amz-object-lock-retain-until-date and x-amz-object-lock-mode must both be supplied\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectRestoreAlreadyInProgress: {\n\t\tCode:           \"RestoreAlreadyInProgress\",\n\t\tDescription:    \"Object restore is already in progress\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\t/// Bucket notification related errors.\n\tErrEventNotification: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"A specified event is not supported for notifications.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrARNNotification: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"A specified destination ARN does not exist or is not well-formed. Verify the destination ARN.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrRegionNotification: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"A specified destination is in a different region than the bucket. You must use a destination that resides in the same region as the bucket.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrOverlappingFilterNotification: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"An object key name filtering rule defined with overlapping prefixes, overlapping suffixes, or overlapping combinations of prefixes and suffixes for the same event types.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrFilterNameInvalid: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"filter rule name must be either prefix or suffix\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrFilterNamePrefix: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Cannot specify more than one prefix rule in a filter.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrFilterNameSuffix: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Cannot specify more than one suffix rule in a filter.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrFilterValueInvalid: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Size of filter rule value cannot exceed 1024 bytes in UTF-8 representation\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrOverlappingConfigs: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Configurations overlap. Configurations on the same bucket cannot share a common event type.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedNotification: {\n\t\tCode:           \"UnsupportedNotification\",\n\t\tDescription:    \"MinIO server does not support Topic or Cloud Function based notifications.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCopyPartRange: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The x-amz-copy-source-range value must be of the form bytes=first-last where first and last are the zero-based offsets of the first and last bytes to copy\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCopyPartRangeSource: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Range specified is not valid for source object\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMetadataTooLarge: {\n\t\tCode:           \"MetadataTooLarge\",\n\t\tDescription:    \"Your metadata headers exceed the maximum allowed metadata size.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidTagDirective: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Unknown tag directive.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidEncryptionMethod: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The encryption method specified is not supported\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInsecureSSECustomerRequest: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Requests specifying Server Side Encryption with Customer provided keys must be made over a secure connection.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrSSEMultipartEncrypted: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The multipart upload initiate requested encryption. Subsequent part requests must include the appropriate encryption parameters.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrSSEEncryptedObject: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The object was stored using a form of Server Side Encryption. The correct parameters must be provided to retrieve the object.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidEncryptionParameters: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"The encryption parameters are not applicable to this object.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidSSECustomerAlgorithm: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Requests specifying Server Side Encryption with Customer provided keys must provide a valid encryption algorithm.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidSSECustomerKey: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The secret key was invalid for the specified algorithm.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSSECustomerKey: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Requests specifying Server Side Encryption with Customer provided keys must provide an appropriate secret key.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingSSECustomerKeyMD5: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Requests specifying Server Side Encryption with Customer provided keys must provide the client calculated MD5 of the secret key.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrSSECustomerKeyMD5Mismatch: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The calculated MD5 hash of the key did not match the hash that was provided.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidSSECustomerParameters: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The provided encryption parameters did not match the ones used originally.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIncompatibleEncryptionMethod: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Server side encryption specified with both SSE-C and SSE-S3 headers\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrKMSNotConfigured: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Server side encryption specified but KMS is not configured\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrKMSAuthFailure: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Server side encryption specified but KMS authorization failed\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrNoAccessKey: {\n\t\tCode:           \"AccessDenied\",\n\t\tDescription:    \"No AWSAccessKey was presented\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrInvalidToken: {\n\t\tCode:           \"InvalidTokenId\",\n\t\tDescription:    \"The security token included in the request is invalid\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\n\t/// S3 extensions.\n\tErrContentSHA256Mismatch: {\n\t\tCode:           \"XAmzContentSHA256Mismatch\",\n\t\tDescription:    \"The provided 'x-amz-content-sha256' header does not match what was computed.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\n\t/// MinIO extensions.\n\tErrStorageFull: {\n\t\tCode:           \"XMinioStorageFull\",\n\t\tDescription:    \"Storage backend has reached its minimum free disk threshold. Please delete a few objects to proceed.\",\n\t\tHTTPStatusCode: http.StatusInsufficientStorage,\n\t},\n\tErrParentIsObject: {\n\t\tCode:           \"XMinioParentIsObject\",\n\t\tDescription:    \"Object-prefix is already an object, please choose a different object-prefix name.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrRequestBodyParse: {\n\t\tCode:           \"XMinioRequestBodyParse\",\n\t\tDescription:    \"The request body failed to parse.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectExistsAsDirectory: {\n\t\tCode:           \"XMinioObjectExistsAsDirectory\",\n\t\tDescription:    \"Object name already exists as a directory.\",\n\t\tHTTPStatusCode: http.StatusConflict,\n\t},\n\tErrInvalidObjectName: {\n\t\tCode:           \"XMinioInvalidObjectName\",\n\t\tDescription:    \"Object name contains unsupported characters.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidObjectNamePrefixSlash: {\n\t\tCode:           \"XMinioInvalidObjectName\",\n\t\tDescription:    \"Object name contains a leading slash.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidResourceName: {\n\t\tCode:           \"XMinioInvalidResourceName\",\n\t\tDescription:    \"Resource name contains bad components such as \\\"..\\\" or \\\".\\\".\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrServerNotInitialized: {\n\t\tCode:           \"XMinioServerNotInitialized\",\n\t\tDescription:    \"Server not initialized, please try again.\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrMalformedJSON: {\n\t\tCode:           \"XMinioMalformedJSON\",\n\t\tDescription:    \"The JSON you provided was not well-formed or did not validate against our published format.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminNoSuchUser: {\n\t\tCode:           \"XMinioAdminNoSuchUser\",\n\t\tDescription:    \"The specified user does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrAdminNoSuchGroup: {\n\t\tCode:           \"XMinioAdminNoSuchGroup\",\n\t\tDescription:    \"The specified group does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrAdminGroupNotEmpty: {\n\t\tCode:           \"XMinioAdminGroupNotEmpty\",\n\t\tDescription:    \"The specified group is not empty - cannot remove it.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminNoSuchPolicy: {\n\t\tCode:           \"XMinioAdminNoSuchPolicy\",\n\t\tDescription:    \"The canned policy does not exist.\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrAdminInvalidArgument: {\n\t\tCode:           \"XMinioAdminInvalidArgument\",\n\t\tDescription:    \"Invalid arguments specified.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminInvalidAccessKey: {\n\t\tCode:           \"XMinioAdminInvalidAccessKey\",\n\t\tDescription:    \"The access key is invalid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminInvalidSecretKey: {\n\t\tCode:           \"XMinioAdminInvalidSecretKey\",\n\t\tDescription:    \"The secret key is invalid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminConfigNoQuorum: {\n\t\tCode:           \"XMinioAdminConfigNoQuorum\",\n\t\tDescription:    \"Configuration update failed because server quorum was not met\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrAdminConfigTooLarge: {\n\t\tCode: \"XMinioAdminConfigTooLarge\",\n\t\tDescription: fmt.Sprintf(\"Configuration data provided exceeds the allowed maximum of %d bytes\",\n\t\t\tmaxEConfigJSONSize),\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminConfigBadJSON: {\n\t\tCode:           \"XMinioAdminConfigBadJSON\",\n\t\tDescription:    \"JSON configuration provided is of incorrect format\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminConfigDuplicateKeys: {\n\t\tCode:           \"XMinioAdminConfigDuplicateKeys\",\n\t\tDescription:    \"JSON configuration provided has objects with duplicate keys\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminConfigNotificationTargetsFailed: {\n\t\tCode:           \"XMinioAdminNotificationTargetsTestFailed\",\n\t\tDescription:    \"Configuration update failed due an unsuccessful attempt to connect to one or more notification servers\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminProfilerNotEnabled: {\n\t\tCode:           \"XMinioAdminProfilerNotEnabled\",\n\t\tDescription:    \"Unable to perform the requested operation because profiling is not enabled\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminCredentialsMismatch: {\n\t\tCode:           \"XMinioAdminCredentialsMismatch\",\n\t\tDescription:    \"Credentials in config mismatch with server environment variables\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrAdminBucketQuotaExceeded: {\n\t\tCode:           \"XMinioAdminBucketQuotaExceeded\",\n\t\tDescription:    \"Bucket quota exceeded\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAdminNoSuchQuotaConfiguration: {\n\t\tCode:           \"XMinioAdminNoSuchQuotaConfiguration\",\n\t\tDescription:    \"The quota configuration does not exist\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrInsecureClientRequest: {\n\t\tCode:           \"XMinioInsecureClientRequest\",\n\t\tDescription:    \"Cannot respond to plain-text request from TLS-encrypted server\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrOperationTimedOut: {\n\t\tCode:           \"RequestTimeout\",\n\t\tDescription:    \"A timeout occurred while trying to lock a resource, please reduce your request rate\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrClientDisconnected: {\n\t\tCode:           \"ClientDisconnected\",\n\t\tDescription:    \"Client disconnected before response was ready\",\n\t\tHTTPStatusCode: 499, // No official code, use nginx value.\n\t},\n\tErrOperationMaxedOut: {\n\t\tCode:           \"SlowDown\",\n\t\tDescription:    \"A timeout exceeded while waiting to proceed with the request, please reduce your request rate\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrUnsupportedMetadata: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"Your metadata headers are not supported.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectTampered: {\n\t\tCode:           \"XMinioObjectTampered\",\n\t\tDescription:    errObjectTampered.Error(),\n\t\tHTTPStatusCode: http.StatusPartialContent,\n\t},\n\tErrMaximumExpires: {\n\t\tCode:           \"AuthorizationQueryParametersError\",\n\t\tDescription:    \"X-Amz-Expires must be less than a week (in seconds); that is, the given X-Amz-Expires must be less than 604800 seconds\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\n\t// Generic Invalid-Request error. Should be used for response errors only for unlikely\n\t// corner case errors for which introducing new APIErrorCode is not worth it. LogIf()\n\t// should be used to log the error at the source of the error for debugging purposes.\n\tErrInvalidRequest: {\n\t\tCode:           \"InvalidRequest\",\n\t\tDescription:    \"Invalid Request\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealNotImplemented: {\n\t\tCode:           \"XMinioHealNotImplemented\",\n\t\tDescription:    \"This server does not implement heal functionality.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealNoSuchProcess: {\n\t\tCode:           \"XMinioHealNoSuchProcess\",\n\t\tDescription:    \"No such heal process is running on the server\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealInvalidClientToken: {\n\t\tCode:           \"XMinioHealInvalidClientToken\",\n\t\tDescription:    \"Client token mismatch\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealMissingBucket: {\n\t\tCode:           \"XMinioHealMissingBucket\",\n\t\tDescription:    \"A heal start request with a non-empty object-prefix parameter requires a bucket to be specified.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealAlreadyRunning: {\n\t\tCode:           \"XMinioHealAlreadyRunning\",\n\t\tDescription:    \"\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrHealOverlappingPaths: {\n\t\tCode:           \"XMinioHealOverlappingPaths\",\n\t\tDescription:    \"\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBackendDown: {\n\t\tCode:           \"XMinioBackendDown\",\n\t\tDescription:    \"Object storage backend is unreachable\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrIncorrectContinuationToken: {\n\t\tCode:           \"InvalidArgument\",\n\t\tDescription:    \"The continuation token provided is incorrect\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\t//S3 Select API Errors\n\tErrEmptyRequestBody: {\n\t\tCode:           \"EmptyRequestBody\",\n\t\tDescription:    \"Request body cannot be empty.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedFunction: {\n\t\tCode:           \"UnsupportedFunction\",\n\t\tDescription:    \"Encountered an unsupported SQL function.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidDataSource: {\n\t\tCode:           \"InvalidDataSource\",\n\t\tDescription:    \"Invalid data source type. Only CSV and JSON are supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidExpressionType: {\n\t\tCode:           \"InvalidExpressionType\",\n\t\tDescription:    \"The ExpressionType is invalid. Only SQL expressions are supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrBusy: {\n\t\tCode:           \"Busy\",\n\t\tDescription:    \"The service is unavailable. Please retry.\",\n\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t},\n\tErrUnauthorizedAccess: {\n\t\tCode:           \"UnauthorizedAccess\",\n\t\tDescription:    \"You are not authorized to perform this operation\",\n\t\tHTTPStatusCode: http.StatusUnauthorized,\n\t},\n\tErrExpressionTooLong: {\n\t\tCode:           \"ExpressionTooLong\",\n\t\tDescription:    \"The SQL expression is too long: The maximum byte-length for the SQL expression is 256 KB.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIllegalSQLFunctionArgument: {\n\t\tCode:           \"IllegalSqlFunctionArgument\",\n\t\tDescription:    \"Illegal argument was used in the SQL function.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidKeyPath: {\n\t\tCode:           \"InvalidKeyPath\",\n\t\tDescription:    \"Key path in the SQL expression is invalid.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCompressionFormat: {\n\t\tCode:           \"InvalidCompressionFormat\",\n\t\tDescription:    \"The file is not in a supported compression format. Only GZIP is supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidFileHeaderInfo: {\n\t\tCode:           \"InvalidFileHeaderInfo\",\n\t\tDescription:    \"The FileHeaderInfo is invalid. Only NONE, USE, and IGNORE are supported.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidJSONType: {\n\t\tCode:           \"InvalidJsonType\",\n\t\tDescription:    \"The JsonType is invalid. Only DOCUMENT and LINES are supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidQuoteFields: {\n\t\tCode:           \"InvalidQuoteFields\",\n\t\tDescription:    \"The QuoteFields is invalid. Only ALWAYS and ASNEEDED are supported.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidRequestParameter: {\n\t\tCode:           \"InvalidRequestParameter\",\n\t\tDescription:    \"The value of a parameter in SelectRequest element is invalid. Check the service API documentation and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidDataType: {\n\t\tCode:           \"InvalidDataType\",\n\t\tDescription:    \"The SQL expression contains an invalid data type.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidTextEncoding: {\n\t\tCode:           \"InvalidTextEncoding\",\n\t\tDescription:    \"Invalid encoding type. Only UTF-8 encoding is supported at this time.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidTableAlias: {\n\t\tCode:           \"InvalidTableAlias\",\n\t\tDescription:    \"The SQL expression contains an invalid table alias.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingRequiredParameter: {\n\t\tCode:           \"MissingRequiredParameter\",\n\t\tDescription:    \"The SelectRequest entity is missing a required parameter. Check the service documentation and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrObjectSerializationConflict: {\n\t\tCode:           \"ObjectSerializationConflict\",\n\t\tDescription:    \"The SelectRequest entity can only contain one of CSV or JSON. Check the service documentation and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedSQLOperation: {\n\t\tCode:           \"UnsupportedSqlOperation\",\n\t\tDescription:    \"Encountered an unsupported SQL operation.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedSQLStructure: {\n\t\tCode:           \"UnsupportedSqlStructure\",\n\t\tDescription:    \"Encountered an unsupported SQL structure. Check the SQL Reference.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedSyntax: {\n\t\tCode:           \"UnsupportedSyntax\",\n\t\tDescription:    \"Encountered invalid syntax.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrUnsupportedRangeHeader: {\n\t\tCode:           \"UnsupportedRangeHeader\",\n\t\tDescription:    \"Range header is not supported for this operation.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLexerInvalidChar: {\n\t\tCode:           \"LexerInvalidChar\",\n\t\tDescription:    \"The SQL expression contains an invalid character.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLexerInvalidOperator: {\n\t\tCode:           \"LexerInvalidOperator\",\n\t\tDescription:    \"The SQL expression contains an invalid literal.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLexerInvalidLiteral: {\n\t\tCode:           \"LexerInvalidLiteral\",\n\t\tDescription:    \"The SQL expression contains an invalid operator.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLexerInvalidIONLiteral: {\n\t\tCode:           \"LexerInvalidIONLiteral\",\n\t\tDescription:    \"The SQL expression contains an invalid operator.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedDatePart: {\n\t\tCode:           \"ParseExpectedDatePart\",\n\t\tDescription:    \"Did not find the expected date part in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedKeyword: {\n\t\tCode:           \"ParseExpectedKeyword\",\n\t\tDescription:    \"Did not find the expected keyword in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedTokenType: {\n\t\tCode:           \"ParseExpectedTokenType\",\n\t\tDescription:    \"Did not find the expected token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpected2TokenTypes: {\n\t\tCode:           \"ParseExpected2TokenTypes\",\n\t\tDescription:    \"Did not find the expected token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedNumber: {\n\t\tCode:           \"ParseExpectedNumber\",\n\t\tDescription:    \"Did not find the expected number in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedRightParenBuiltinFunctionCall: {\n\t\tCode:           \"ParseExpectedRightParenBuiltinFunctionCall\",\n\t\tDescription:    \"Did not find the expected right parenthesis character in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedTypeName: {\n\t\tCode:           \"ParseExpectedTypeName\",\n\t\tDescription:    \"Did not find the expected type name in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedWhenClause: {\n\t\tCode:           \"ParseExpectedWhenClause\",\n\t\tDescription:    \"Did not find the expected WHEN clause in the SQL expression. CASE is not supported.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedToken: {\n\t\tCode:           \"ParseUnsupportedToken\",\n\t\tDescription:    \"The SQL expression contains an unsupported token.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedLiteralsGroupBy: {\n\t\tCode:           \"ParseUnsupportedLiteralsGroupBy\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of GROUP BY.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedMember: {\n\t\tCode:           \"ParseExpectedMember\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of MEMBER.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedSelect: {\n\t\tCode:           \"ParseUnsupportedSelect\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of SELECT.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedCase: {\n\t\tCode:           \"ParseUnsupportedCase\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of CASE.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedCaseClause: {\n\t\tCode:           \"ParseUnsupportedCaseClause\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of CASE.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedAlias: {\n\t\tCode:           \"ParseUnsupportedAlias\",\n\t\tDescription:    \"The SQL expression contains an unsupported use of ALIAS.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedSyntax: {\n\t\tCode:           \"ParseUnsupportedSyntax\",\n\t\tDescription:    \"The SQL expression contains unsupported syntax.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnknownOperator: {\n\t\tCode:           \"ParseUnknownOperator\",\n\t\tDescription:    \"The SQL expression contains an invalid operator.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseMissingIdentAfterAt: {\n\t\tCode:           \"ParseMissingIdentAfterAt\",\n\t\tDescription:    \"Did not find the expected identifier after the @ symbol in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnexpectedOperator: {\n\t\tCode:           \"ParseUnexpectedOperator\",\n\t\tDescription:    \"The SQL expression contains an unexpected operator.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnexpectedTerm: {\n\t\tCode:           \"ParseUnexpectedTerm\",\n\t\tDescription:    \"The SQL expression contains an unexpected term.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnexpectedToken: {\n\t\tCode:           \"ParseUnexpectedToken\",\n\t\tDescription:    \"The SQL expression contains an unexpected token.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnexpectedKeyword: {\n\t\tCode:           \"ParseUnexpectedKeyword\",\n\t\tDescription:    \"The SQL expression contains an unexpected keyword.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedExpression: {\n\t\tCode:           \"ParseExpectedExpression\",\n\t\tDescription:    \"Did not find the expected SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedLeftParenAfterCast: {\n\t\tCode:           \"ParseExpectedLeftParenAfterCast\",\n\t\tDescription:    \"Did not find expected the left parenthesis in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedLeftParenValueConstructor: {\n\t\tCode:           \"ParseExpectedLeftParenValueConstructor\",\n\t\tDescription:    \"Did not find expected the left parenthesis in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedLeftParenBuiltinFunctionCall: {\n\t\tCode:           \"ParseExpectedLeftParenBuiltinFunctionCall\",\n\t\tDescription:    \"Did not find the expected left parenthesis in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedArgumentDelimiter: {\n\t\tCode:           \"ParseExpectedArgumentDelimiter\",\n\t\tDescription:    \"Did not find the expected argument delimiter in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseCastArity: {\n\t\tCode:           \"ParseCastArity\",\n\t\tDescription:    \"The SQL expression CAST has incorrect arity.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseInvalidTypeParam: {\n\t\tCode:           \"ParseInvalidTypeParam\",\n\t\tDescription:    \"The SQL expression contains an invalid parameter value.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseEmptySelect: {\n\t\tCode:           \"ParseEmptySelect\",\n\t\tDescription:    \"The SQL expression contains an empty SELECT.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseSelectMissingFrom: {\n\t\tCode:           \"ParseSelectMissingFrom\",\n\t\tDescription:    \"GROUP is not supported in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedIdentForGroupName: {\n\t\tCode:           \"ParseExpectedIdentForGroupName\",\n\t\tDescription:    \"GROUP is not supported in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedIdentForAlias: {\n\t\tCode:           \"ParseExpectedIdentForAlias\",\n\t\tDescription:    \"Did not find the expected identifier for the alias in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseUnsupportedCallWithStar: {\n\t\tCode:           \"ParseUnsupportedCallWithStar\",\n\t\tDescription:    \"Only COUNT with (*) as a parameter is supported in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseNonUnaryAgregateFunctionCall: {\n\t\tCode:           \"ParseNonUnaryAgregateFunctionCall\",\n\t\tDescription:    \"Only one argument is supported for aggregate functions in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseMalformedJoin: {\n\t\tCode:           \"ParseMalformedJoin\",\n\t\tDescription:    \"JOIN is not supported in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseExpectedIdentForAt: {\n\t\tCode:           \"ParseExpectedIdentForAt\",\n\t\tDescription:    \"Did not find the expected identifier for AT name in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseAsteriskIsNotAloneInSelectList: {\n\t\tCode:           \"ParseAsteriskIsNotAloneInSelectList\",\n\t\tDescription:    \"Other expressions are not allowed in the SELECT list when '*' is used without dot notation in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseCannotMixSqbAndWildcardInSelectList: {\n\t\tCode:           \"ParseCannotMixSqbAndWildcardInSelectList\",\n\t\tDescription:    \"Cannot mix [] and * in the same expression in a SELECT list in SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrParseInvalidContextForWildcardInSelectList: {\n\t\tCode:           \"ParseInvalidContextForWildcardInSelectList\",\n\t\tDescription:    \"Invalid use of * in SELECT list in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIncorrectSQLFunctionArgumentType: {\n\t\tCode:           \"IncorrectSqlFunctionArgumentType\",\n\t\tDescription:    \"Incorrect type of arguments in function call in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrValueParseFailure: {\n\t\tCode:           \"ValueParseFailure\",\n\t\tDescription:    \"Time stamp parse failure in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidArguments: {\n\t\tCode:           \"EvaluatorInvalidArguments\",\n\t\tDescription:    \"Incorrect number of arguments in the function call in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrIntegerOverflow: {\n\t\tCode:           \"IntegerOverflow\",\n\t\tDescription:    \"Int overflow or underflow in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrLikeInvalidInputs: {\n\t\tCode:           \"LikeInvalidInputs\",\n\t\tDescription:    \"Invalid argument given to the LIKE clause in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrCastFailed: {\n\t\tCode:           \"CastFailed\",\n\t\tDescription:    \"Attempt to convert from one data type to another using CAST failed in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidCast: {\n\t\tCode:           \"InvalidCast\",\n\t\tDescription:    \"Attempt to convert from one data type to another using CAST failed in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidTimestampFormatPattern: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPattern\",\n\t\tDescription:    \"Time stamp format pattern requires additional fields in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidTimestampFormatPatternSymbolForParsing: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPatternSymbolForParsing\",\n\t\tDescription:    \"Time stamp format pattern contains a valid format symbol that cannot be applied to time stamp parsing in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorTimestampFormatPatternDuplicateFields: {\n\t\tCode:           \"EvaluatorTimestampFormatPatternDuplicateFields\",\n\t\tDescription:    \"Time stamp format pattern contains multiple format specifiers representing the time stamp field in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorTimestampFormatPatternHourClockAmPmMismatch: {\n\t\tCode:           \"EvaluatorUnterminatedTimestampFormatPatternToken\",\n\t\tDescription:    \"Time stamp format pattern contains unterminated token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorUnterminatedTimestampFormatPatternToken: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPatternToken\",\n\t\tDescription:    \"Time stamp format pattern contains an invalid token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidTimestampFormatPatternToken: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPatternToken\",\n\t\tDescription:    \"Time stamp format pattern contains an invalid token in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorInvalidTimestampFormatPatternSymbol: {\n\t\tCode:           \"EvaluatorInvalidTimestampFormatPatternSymbol\",\n\t\tDescription:    \"Time stamp format pattern contains an invalid symbol in the SQL expression.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrEvaluatorBindingDoesNotExist: {\n\t\tCode:           \"ErrEvaluatorBindingDoesNotExist\",\n\t\tDescription:    \"A column name or a path provided does not exist in the SQL expression\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrMissingHeaders: {\n\t\tCode:           \"MissingHeaders\",\n\t\tDescription:    \"Some headers in the query are missing from the file. Check the file and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidColumnIndex: {\n\t\tCode:           \"InvalidColumnIndex\",\n\t\tDescription:    \"The column index is invalid. Please check the service documentation and try again.\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrInvalidDecompressedSize: {\n\t\tCode:           \"XMinioInvalidDecompressedSize\",\n\t\tDescription:    \"The data provided is unfit for decompression\",\n\t\tHTTPStatusCode: http.StatusBadRequest,\n\t},\n\tErrAddUserInvalidArgument: {\n\t\tCode:           \"XMinioInvalidIAMCredentials\",\n\t\tDescription:    \"User is not allowed to be same as admin access key\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrAdminAccountNotEligible: {\n\t\tCode:           \"XMinioInvalidIAMCredentials\",\n\t\tDescription:    \"The administrator key is not eligible for this operation\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrAccountNotEligible: {\n\t\tCode:           \"XMinioInvalidIAMCredentials\",\n\t\tDescription:    \"The account key is not eligible for this operation\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\tErrServiceAccountNotFound: {\n\t\tCode:           \"XMinioInvalidIAMCredentials\",\n\t\tDescription:    \"The specified service account is not found\",\n\t\tHTTPStatusCode: http.StatusNotFound,\n\t},\n\tErrPostPolicyConditionInvalidFormat: {\n\t\tCode:           \"PostPolicyInvalidKeyName\",\n\t\tDescription:    \"Invalid according to Policy: Policy Condition failed\",\n\t\tHTTPStatusCode: http.StatusForbidden,\n\t},\n\t// Add your error structure here.\n}\n\n// toAPIErrorCode - Converts embedded errors. Convenience\n// function written to handle all cases where we have known types of\n// errors returned by underlying layers.\nfunc toAPIErrorCode(ctx context.Context, err error) (apiErr APIErrorCode) {\n\tif err == nil {\n\t\treturn ErrNone\n\t}\n\n\t// Only return ErrClientDisconnected if the provided context is actually canceled.\n\t// This way downstream context.Canceled will still report ErrOperationTimedOut\n\tselect {\n\tcase <-ctx.Done():\n\t\tif ctx.Err() == context.Canceled {\n\t\t\treturn ErrClientDisconnected\n\t\t}\n\tdefault:\n\t}\n\n\tswitch err {\n\tcase errInvalidArgument:\n\t\tapiErr = ErrAdminInvalidArgument\n\tcase errNoSuchUser:\n\t\tapiErr = ErrAdminNoSuchUser\n\tcase errNoSuchGroup:\n\t\tapiErr = ErrAdminNoSuchGroup\n\tcase errGroupNotEmpty:\n\t\tapiErr = ErrAdminGroupNotEmpty\n\tcase errNoSuchPolicy:\n\t\tapiErr = ErrAdminNoSuchPolicy\n\tcase errSignatureMismatch:\n\t\tapiErr = ErrSignatureDoesNotMatch\n\tcase errInvalidRange:\n\t\tapiErr = ErrInvalidRange\n\tcase errDataTooLarge:\n\t\tapiErr = ErrEntityTooLarge\n\tcase errDataTooSmall:\n\t\tapiErr = ErrEntityTooSmall\n\tcase errAuthentication:\n\t\tapiErr = ErrAccessDenied\n\tcase auth.ErrInvalidAccessKeyLength:\n\t\tapiErr = ErrAdminInvalidAccessKey\n\tcase auth.ErrInvalidSecretKeyLength:\n\t\tapiErr = ErrAdminInvalidSecretKey\n\t// SSE errors\n\tcase errInvalidEncryptionParameters:\n\t\tapiErr = ErrInvalidEncryptionParameters\n\tcase crypto.ErrInvalidEncryptionMethod:\n\t\tapiErr = ErrInvalidEncryptionMethod\n\tcase crypto.ErrInvalidCustomerAlgorithm:\n\t\tapiErr = ErrInvalidSSECustomerAlgorithm\n\tcase crypto.ErrMissingCustomerKey:\n\t\tapiErr = ErrMissingSSECustomerKey\n\tcase crypto.ErrMissingCustomerKeyMD5:\n\t\tapiErr = ErrMissingSSECustomerKeyMD5\n\tcase crypto.ErrCustomerKeyMD5Mismatch:\n\t\tapiErr = ErrSSECustomerKeyMD5Mismatch\n\tcase errObjectTampered:\n\t\tapiErr = ErrObjectTampered\n\tcase errEncryptedObject:\n\t\tapiErr = ErrSSEEncryptedObject\n\tcase errInvalidSSEParameters:\n\t\tapiErr = ErrInvalidSSECustomerParameters\n\tcase crypto.ErrInvalidCustomerKey, crypto.ErrSecretKeyMismatch:\n\t\tapiErr = ErrAccessDenied // no access without correct key\n\tcase crypto.ErrIncompatibleEncryptionMethod:\n\t\tapiErr = ErrIncompatibleEncryptionMethod\n\tcase errKMSNotConfigured:\n\t\tapiErr = ErrKMSNotConfigured\n\tcase crypto.ErrKMSAuthLogin:\n\t\tapiErr = ErrKMSAuthFailure\n\tcase context.Canceled, context.DeadlineExceeded:\n\t\tapiErr = ErrOperationTimedOut\n\tcase errDiskNotFound:\n\t\tapiErr = ErrSlowDown\n\tcase objectlock.ErrInvalidRetentionDate:\n\t\tapiErr = ErrInvalidRetentionDate\n\tcase objectlock.ErrPastObjectLockRetainDate:\n\t\tapiErr = ErrPastObjectLockRetainDate\n\tcase objectlock.ErrUnknownWORMModeDirective:\n\t\tapiErr = ErrUnknownWORMModeDirective\n\tcase objectlock.ErrObjectLockInvalidHeaders:\n\t\tapiErr = ErrObjectLockInvalidHeaders\n\tcase objectlock.ErrMalformedXML:\n\t\tapiErr = ErrMalformedXML\n\t}\n\n\t// Compression errors\n\tswitch err {\n\tcase errInvalidDecompressedSize:\n\t\tapiErr = ErrInvalidDecompressedSize\n\t}\n\n\tif apiErr != ErrNone {\n\t\t// If there was a match in the above switch case.\n\t\treturn apiErr\n\t}\n\n\t// etcd specific errors, a key is always a bucket for us return\n\t// ErrNoSuchBucket in such a case.\n\tif err == dns.ErrNoEntriesFound {\n\t\treturn ErrNoSuchBucket\n\t}\n\n\tswitch err.(type) {\n\tcase StorageFull:\n\t\tapiErr = ErrStorageFull\n\tcase hash.BadDigest:\n\t\tapiErr = ErrBadDigest\n\tcase AllAccessDisabled:\n\t\tapiErr = ErrAllAccessDisabled\n\tcase IncompleteBody:\n\t\tapiErr = ErrIncompleteBody\n\tcase ObjectExistsAsDirectory:\n\t\tapiErr = ErrObjectExistsAsDirectory\n\tcase PrefixAccessDenied:\n\t\tapiErr = ErrAccessDenied\n\tcase ParentIsObject:\n\t\tapiErr = ErrParentIsObject\n\tcase BucketNameInvalid:\n\t\tapiErr = ErrInvalidBucketName\n\tcase BucketNotFound:\n\t\tapiErr = ErrNoSuchBucket\n\tcase BucketAlreadyOwnedByYou:\n\t\tapiErr = ErrBucketAlreadyOwnedByYou\n\tcase BucketNotEmpty:\n\t\tapiErr = ErrBucketNotEmpty\n\tcase BucketAlreadyExists:\n\t\tapiErr = ErrBucketAlreadyExists\n\tcase BucketExists:\n\t\tapiErr = ErrBucketAlreadyOwnedByYou\n\tcase ObjectNotFound:\n\t\tapiErr = ErrNoSuchKey\n\tcase MethodNotAllowed:\n\t\tapiErr = ErrMethodNotAllowed\n\tcase InvalidVersionID:\n\t\tapiErr = ErrInvalidVersionID\n\tcase VersionNotFound:\n\t\tapiErr = ErrNoSuchVersion\n\tcase ObjectAlreadyExists:\n\t\tapiErr = ErrMethodNotAllowed\n\tcase ObjectNameInvalid:\n\t\tapiErr = ErrInvalidObjectName\n\tcase ObjectNamePrefixAsSlash:\n\t\tapiErr = ErrInvalidObjectNamePrefixSlash\n\tcase InvalidUploadID:\n\t\tapiErr = ErrNoSuchUpload\n\tcase InvalidPart:\n\t\tapiErr = ErrInvalidPart\n\tcase InsufficientWriteQuorum:\n\t\tapiErr = ErrSlowDown\n\tcase InsufficientReadQuorum:\n\t\tapiErr = ErrSlowDown\n\tcase UnsupportedDelimiter:\n\t\tapiErr = ErrNotImplemented\n\tcase InvalidMarkerPrefixCombination:\n\t\tapiErr = ErrNotImplemented\n\tcase InvalidUploadIDKeyCombination:\n\t\tapiErr = ErrNotImplemented\n\tcase MalformedUploadID:\n\t\tapiErr = ErrNoSuchUpload\n\tcase PartTooSmall:\n\t\tapiErr = ErrEntityTooSmall\n\tcase SignatureDoesNotMatch:\n\t\tapiErr = ErrSignatureDoesNotMatch\n\tcase hash.SHA256Mismatch:\n\t\tapiErr = ErrContentSHA256Mismatch\n\tcase ObjectTooLarge:\n\t\tapiErr = ErrEntityTooLarge\n\tcase ObjectTooSmall:\n\t\tapiErr = ErrEntityTooSmall\n\tcase NotImplemented:\n\t\tapiErr = ErrNotImplemented\n\tcase PartTooBig:\n\t\tapiErr = ErrEntityTooLarge\n\tcase UnsupportedMetadata:\n\t\tapiErr = ErrUnsupportedMetadata\n\tcase BucketPolicyNotFound:\n\t\tapiErr = ErrNoSuchBucketPolicy\n\tcase BucketLifecycleNotFound:\n\t\tapiErr = ErrNoSuchLifecycleConfiguration\n\tcase BucketSSEConfigNotFound:\n\t\tapiErr = ErrNoSuchBucketSSEConfig\n\tcase BucketTaggingNotFound:\n\t\tapiErr = ErrBucketTaggingNotFound\n\tcase BucketObjectLockConfigNotFound:\n\t\tapiErr = ErrObjectLockConfigurationNotFound\n\tcase BucketQuotaConfigNotFound:\n\t\tapiErr = ErrAdminNoSuchQuotaConfiguration\n\tcase BucketReplicationConfigNotFound:\n\t\tapiErr = ErrReplicationConfigurationNotFoundError\n\tcase BucketRemoteDestinationNotFound:\n\t\tapiErr = ErrRemoteDestinationNotFoundError\n\tcase BucketReplicationDestinationMissingLock:\n\t\tapiErr = ErrReplicationDestinationMissingLock\n\tcase BucketRemoteTargetNotFound:\n\t\tapiErr = ErrRemoteTargetNotFoundError\n\tcase BucketRemoteConnectionErr:\n\t\tapiErr = ErrReplicationRemoteConnectionError\n\tcase BucketRemoteAlreadyExists:\n\t\tapiErr = ErrBucketRemoteAlreadyExists\n\tcase BucketRemoteLabelInUse:\n\t\tapiErr = ErrBucketRemoteLabelInUse\n\tcase BucketRemoteArnTypeInvalid:\n\t\tapiErr = ErrBucketRemoteArnTypeInvalid\n\tcase BucketRemoteArnInvalid:\n\t\tapiErr = ErrBucketRemoteArnInvalid\n\tcase BucketRemoteRemoveDisallowed:\n\t\tapiErr = ErrBucketRemoteRemoveDisallowed\n\tcase BucketRemoteTargetNotVersioned:\n\t\tapiErr = ErrRemoteTargetNotVersionedError\n\tcase BucketReplicationSourceNotVersioned:\n\t\tapiErr = ErrReplicationSourceNotVersionedError\n\tcase BucketQuotaExceeded:\n\t\tapiErr = ErrAdminBucketQuotaExceeded\n\tcase *event.ErrInvalidEventName:\n\t\tapiErr = ErrEventNotification\n\tcase *event.ErrInvalidARN:\n\t\tapiErr = ErrARNNotification\n\tcase *event.ErrARNNotFound:\n\t\tapiErr = ErrARNNotification\n\tcase *event.ErrUnknownRegion:\n\t\tapiErr = ErrRegionNotification\n\tcase *event.ErrInvalidFilterName:\n\t\tapiErr = ErrFilterNameInvalid\n\tcase *event.ErrFilterNamePrefix:\n\t\tapiErr = ErrFilterNamePrefix\n\tcase *event.ErrFilterNameSuffix:\n\t\tapiErr = ErrFilterNameSuffix\n\tcase *event.ErrInvalidFilterValue:\n\t\tapiErr = ErrFilterValueInvalid\n\tcase *event.ErrDuplicateEventName:\n\t\tapiErr = ErrOverlappingConfigs\n\tcase *event.ErrDuplicateQueueConfiguration:\n\t\tapiErr = ErrOverlappingFilterNotification\n\tcase *event.ErrUnsupportedConfiguration:\n\t\tapiErr = ErrUnsupportedNotification\n\tcase OperationTimedOut:\n\t\tapiErr = ErrOperationTimedOut\n\tcase BackendDown:\n\t\tapiErr = ErrBackendDown\n\tcase ObjectNameTooLong:\n\t\tapiErr = ErrKeyTooLongError\n\tcase dns.ErrInvalidBucketName:\n\t\tapiErr = ErrInvalidBucketName\n\tdefault:\n\t\tvar ie, iw int\n\t\t// This work-around is to handle the issue golang/go#30648\n\t\tif _, ferr := fmt.Fscanf(strings.NewReader(err.Error()),\n\t\t\t\"request declared a Content-Length of %d but only wrote %d bytes\",\n\t\t\t&ie, &iw); ferr != nil {\n\t\t\tapiErr = ErrInternalError\n\t\t\t// Make sure to log the errors which we cannot translate\n\t\t\t// to a meaningful S3 API errors. This is added to aid in\n\t\t\t// debugging unexpected/unhandled errors.\n\t\t\tlogger.LogIf(ctx, err)\n\t\t} else if ie > iw {\n\t\t\tapiErr = ErrIncompleteBody\n\t\t} else {\n\t\t\tapiErr = ErrInternalError\n\t\t\t// Make sure to log the errors which we cannot translate\n\t\t\t// to a meaningful S3 API errors. This is added to aid in\n\t\t\t// debugging unexpected/unhandled errors.\n\t\t\tlogger.LogIf(ctx, err)\n\t\t}\n\t}\n\n\treturn apiErr\n}\n\nvar noError = APIError{}\n\n// toAPIError - Converts embedded errors. Convenience\n// function written to handle all cases where we have known types of\n// errors returned by underlying layers.\nfunc toAPIError(ctx context.Context, err error) APIError {\n\tif err == nil {\n\t\treturn noError\n\t}\n\n\tvar apiErr = errorCodes.ToAPIErr(toAPIErrorCode(ctx, err))\n\te, ok := err.(dns.ErrInvalidBucketName)\n\tif ok {\n\t\tcode := toAPIErrorCode(ctx, e)\n\t\tapiErr = errorCodes.ToAPIErrWithErr(code, e)\n\t}\n\n\tif apiErr.Code == \"InternalError\" {\n\t\t// If we see an internal error try to interpret\n\t\t// any underlying errors if possible depending on\n\t\t// their internal error types. This code is only\n\t\t// useful with gateway implementations.\n\t\tswitch e := err.(type) {\n\t\tcase InvalidArgument:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"InvalidArgument\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: errorCodes[ErrInvalidRequest].HTTPStatusCode,\n\t\t\t}\n\t\tcase *xml.SyntaxError:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode: \"MalformedXML\",\n\t\t\t\tDescription: fmt.Sprintf(\"%s (%s)\", errorCodes[ErrMalformedXML].Description,\n\t\t\t\t\te.Error()),\n\t\t\t\tHTTPStatusCode: errorCodes[ErrMalformedXML].HTTPStatusCode,\n\t\t\t}\n\t\tcase url.EscapeError:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode: \"XMinioInvalidObjectName\",\n\t\t\t\tDescription: fmt.Sprintf(\"%s (%s)\", errorCodes[ErrInvalidObjectName].Description,\n\t\t\t\t\te.Error()),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase versioning.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"IllegalVersioningConfigurationException\",\n\t\t\t\tDescription:    fmt.Sprintf(\"Versioning configuration specified in the request is invalid. (%s)\", e.Error()),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase lifecycle.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"InvalidRequest\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase replication.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"MalformedXML\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase tags.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           e.Code(),\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase policy.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"MalformedPolicy\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase crypto.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"XMinIOEncryptionError\",\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\t}\n\t\tcase minio.ErrorResponse:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           e.Code,\n\t\t\t\tDescription:    e.Message,\n\t\t\t\tHTTPStatusCode: e.StatusCode,\n\t\t\t}\n\t\tcase *googleapi.Error:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           \"XGCSInternalError\",\n\t\t\t\tDescription:    e.Message,\n\t\t\t\tHTTPStatusCode: e.Code,\n\t\t\t}\n\t\t\t// GCS may send multiple errors, just pick the first one\n\t\t\t// since S3 only sends one Error XML response.\n\t\t\tif len(e.Errors) >= 1 {\n\t\t\t\tapiErr.Code = e.Errors[0].Reason\n\n\t\t\t}\n\t\tcase azblob.StorageError:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           string(e.ServiceCode()),\n\t\t\t\tDescription:    e.Error(),\n\t\t\t\tHTTPStatusCode: e.Response().StatusCode,\n\t\t\t}\n\t\t\t// Add more Gateway SDKs here if any in future.\n\t\tdefault:\n\t\t\tapiErr = APIError{\n\t\t\t\tCode:           apiErr.Code,\n\t\t\t\tDescription:    fmt.Sprintf(\"%s: cause(%v)\", apiErr.Description, err),\n\t\t\t\tHTTPStatusCode: apiErr.HTTPStatusCode,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn apiErr\n}\n\n// getAPIError provides API Error for input API error code.\nfunc getAPIError(code APIErrorCode) APIError {\n\tif apiErr, ok := errorCodes[code]; ok {\n\t\treturn apiErr\n\t}\n\treturn errorCodes.ToAPIErr(ErrInternalError)\n}\n\n// getErrorResponse gets in standard error and resource value and\n// provides a encodable populated response values\nfunc getAPIErrorResponse(ctx context.Context, err APIError, resource, requestID, hostID string) APIErrorResponse {\n\treqInfo := logger.GetReqInfo(ctx)\n\treturn APIErrorResponse{\n\t\tCode:       err.Code,\n\t\tMessage:    err.Description,\n\t\tBucketName: reqInfo.BucketName,\n\t\tKey:        reqInfo.ObjectName,\n\t\tResource:   resource,\n\t\tRegion:     globalServerRegion,\n\t\tRequestID:  requestID,\n\t\tHostID:     hostID,\n\t}\n}\n", "/*\n * MinIO Cloud Storage, (C) 2016-2019 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"crypto/subtle\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/klauspost/compress/zip\"\n\t\"github.com/minio/minio-go/v7\"\n\tminiogo \"github.com/minio/minio-go/v7\"\n\tminiogopolicy \"github.com/minio/minio-go/v7/pkg/policy\"\n\t\"github.com/minio/minio-go/v7/pkg/s3utils\"\n\t\"github.com/minio/minio/browser\"\n\t\"github.com/minio/minio/cmd/config/dns\"\n\t\"github.com/minio/minio/cmd/config/identity/openid\"\n\t\"github.com/minio/minio/cmd/crypto\"\n\txhttp \"github.com/minio/minio/cmd/http\"\n\t\"github.com/minio/minio/cmd/logger\"\n\t\"github.com/minio/minio/pkg/auth\"\n\t\"github.com/minio/minio/pkg/bucket/lifecycle\"\n\tobjectlock \"github.com/minio/minio/pkg/bucket/object/lock\"\n\t\"github.com/minio/minio/pkg/bucket/policy\"\n\t\"github.com/minio/minio/pkg/bucket/replication\"\n\t\"github.com/minio/minio/pkg/event\"\n\t\"github.com/minio/minio/pkg/handlers\"\n\t\"github.com/minio/minio/pkg/hash\"\n\tiampolicy \"github.com/minio/minio/pkg/iam/policy\"\n\t\"github.com/minio/minio/pkg/ioutil\"\n\t\"github.com/minio/minio/pkg/rpc/json2\"\n)\n\nfunc extractBucketObject(args reflect.Value) (bucketName, objectName string) {\n\tswitch args.Kind() {\n\tcase reflect.Ptr:\n\t\ta := args.Elem()\n\t\tfor i := 0; i < a.NumField(); i++ {\n\t\t\tswitch a.Type().Field(i).Name {\n\t\t\tcase \"BucketName\":\n\t\t\t\tbucketName = a.Field(i).String()\n\t\t\tcase \"Prefix\":\n\t\t\t\tobjectName = a.Field(i).String()\n\t\t\tcase \"ObjectName\":\n\t\t\t\tobjectName = a.Field(i).String()\n\t\t\t}\n\t\t}\n\t}\n\treturn bucketName, objectName\n}\n\n// WebGenericArgs - empty struct for calls that don't accept arguments\n// for ex. ServerInfo, GenerateAuth\ntype WebGenericArgs struct{}\n\n// WebGenericRep - reply structure for calls for which reply is success/failure\n// for ex. RemoveObject MakeBucket\ntype WebGenericRep struct {\n\tUIVersion string `json:\"uiVersion\"`\n}\n\n// ServerInfoRep - server info reply.\ntype ServerInfoRep struct {\n\tMinioVersion    string\n\tMinioMemory     string\n\tMinioPlatform   string\n\tMinioRuntime    string\n\tMinioGlobalInfo map[string]interface{}\n\tMinioUserInfo   map[string]interface{}\n\tUIVersion       string `json:\"uiVersion\"`\n}\n\n// ServerInfo - get server info.\nfunc (web *webAPIHandlers) ServerInfo(r *http.Request, args *WebGenericArgs, reply *ServerInfoRep) error {\n\tctx := newWebContext(r, args, \"WebServerInfo\")\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\thost, err := os.Hostname()\n\tif err != nil {\n\t\thost = \"\"\n\t}\n\tplatform := fmt.Sprintf(\"Host: %s | OS: %s | Arch: %s\",\n\t\thost,\n\t\truntime.GOOS,\n\t\truntime.GOARCH)\n\tgoruntime := fmt.Sprintf(\"Version: %s | CPUs: %d\", runtime.Version(), runtime.NumCPU())\n\n\treply.MinioVersion = Version\n\treply.MinioGlobalInfo = getGlobalInfo()\n\n\t// Check if the user is IAM user.\n\treply.MinioUserInfo = map[string]interface{}{\n\t\t\"isIAMUser\": !owner,\n\t}\n\n\tif !owner {\n\t\tcreds, ok := globalIAMSys.GetUser(claims.AccessKey)\n\t\tif ok && creds.SessionToken != \"\" {\n\t\t\treply.MinioUserInfo[\"isTempUser\"] = true\n\t\t}\n\t}\n\n\treply.MinioPlatform = platform\n\treply.MinioRuntime = goruntime\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// StorageInfoRep - contains storage usage statistics.\ntype StorageInfoRep struct {\n\tUsed      uint64 `json:\"used\"`\n\tUIVersion string `json:\"uiVersion\"`\n}\n\n// StorageInfo - web call to gather storage usage statistics.\nfunc (web *webAPIHandlers) StorageInfo(r *http.Request, args *WebGenericArgs, reply *StorageInfoRep) error {\n\tctx := newWebContext(r, args, \"WebStorageInfo\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\t_, _, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\tdataUsageInfo, _ := loadDataUsageFromBackend(ctx, objectAPI)\n\treply.Used = dataUsageInfo.ObjectsTotalSize\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// MakeBucketArgs - make bucket args.\ntype MakeBucketArgs struct {\n\tBucketName string `json:\"bucketName\"`\n}\n\n// MakeBucket - creates a new bucket.\nfunc (web *webAPIHandlers) MakeBucket(r *http.Request, args *MakeBucketArgs, reply *WebGenericRep) error {\n\tctx := newWebContext(r, args, \"WebMakeBucket\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.CreateBucketAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, true) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\topts := BucketOptions{\n\t\tLocation:    globalServerRegion,\n\t\tLockEnabled: false,\n\t}\n\n\tif globalDNSConfig != nil {\n\t\tif _, err := globalDNSConfig.Get(args.BucketName); err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound || err == dns.ErrNotImplemented {\n\t\t\t\t// Proceed to creating a bucket.\n\t\t\t\tif err = objectAPI.MakeBucketWithLocation(ctx, args.BucketName, opts); err != nil {\n\t\t\t\t\treturn toJSONError(ctx, err)\n\t\t\t\t}\n\n\t\t\t\tif err = globalDNSConfig.Put(args.BucketName); err != nil {\n\t\t\t\t\tobjectAPI.DeleteBucket(ctx, args.BucketName, false)\n\t\t\t\t\treturn toJSONError(ctx, err)\n\t\t\t\t}\n\n\t\t\t\treply.UIVersion = browser.UIVersion\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t\treturn toJSONError(ctx, errBucketAlreadyExists)\n\t}\n\n\tif err := objectAPI.MakeBucketWithLocation(ctx, args.BucketName, opts); err != nil {\n\t\treturn toJSONError(ctx, err, args.BucketName)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\n\tsendEvent(eventArgs{\n\t\tEventName:  event.BucketCreated,\n\t\tBucketName: args.BucketName,\n\t\tReqParams:  extractReqParams(r),\n\t\tUserAgent:  r.UserAgent(),\n\t\tHost:       handlers.GetSourceIP(r),\n\t})\n\n\treturn nil\n}\n\n// RemoveBucketArgs - remove bucket args.\ntype RemoveBucketArgs struct {\n\tBucketName string `json:\"bucketName\"`\n}\n\n// DeleteBucket - removes a bucket, must be empty.\nfunc (web *webAPIHandlers) DeleteBucket(r *http.Request, args *RemoveBucketArgs, reply *WebGenericRep) error {\n\tctx := newWebContext(r, args, \"WebDeleteBucket\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.DeleteBucketAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, err := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tif err = core.RemoveBucket(ctx, args.BucketName); err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\treturn nil\n\t}\n\n\tdeleteBucket := objectAPI.DeleteBucket\n\n\tif err := deleteBucket(ctx, args.BucketName, false); err != nil {\n\t\treturn toJSONError(ctx, err, args.BucketName)\n\t}\n\n\tglobalNotificationSys.DeleteBucketMetadata(ctx, args.BucketName)\n\n\tif globalDNSConfig != nil {\n\t\tif err := globalDNSConfig.Delete(args.BucketName); err != nil {\n\t\t\tlogger.LogIf(ctx, fmt.Errorf(\"Unable to delete bucket DNS entry %w, please delete it manually\", err))\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t}\n\n\tsendEvent(eventArgs{\n\t\tEventName:  event.BucketRemoved,\n\t\tBucketName: args.BucketName,\n\t\tReqParams:  extractReqParams(r),\n\t\tUserAgent:  r.UserAgent(),\n\t\tHost:       handlers.GetSourceIP(r),\n\t})\n\n\treturn nil\n}\n\n// ListBucketsRep - list buckets response\ntype ListBucketsRep struct {\n\tBuckets   []WebBucketInfo `json:\"buckets\"`\n\tUIVersion string          `json:\"uiVersion\"`\n}\n\n// WebBucketInfo container for list buckets metadata.\ntype WebBucketInfo struct {\n\t// The name of the bucket.\n\tName string `json:\"name\"`\n\t// Date the bucket was created.\n\tCreationDate time.Time `json:\"creationDate\"`\n}\n\n// ListBuckets - list buckets api.\nfunc (web *webAPIHandlers) ListBuckets(r *http.Request, args *WebGenericArgs, reply *ListBucketsRep) error {\n\tctx := newWebContext(r, args, \"WebListBuckets\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\tlistBuckets := objectAPI.ListBuckets\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\tr.Header.Set(\"prefix\", \"\")\n\n\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t// If etcd, dns federation configured list buckets from etcd.\n\tif globalDNSConfig != nil && globalBucketFederation {\n\t\tdnsBuckets, err := globalDNSConfig.List()\n\t\tif err != nil && err != dns.ErrNoEntriesFound {\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t\tfor _, dnsRecords := range dnsBuckets {\n\t\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\t\tBucketName:      dnsRecords[0].Key,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      \"\",\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\treply.Buckets = append(reply.Buckets, WebBucketInfo{\n\t\t\t\t\tName:         dnsRecords[0].Key,\n\t\t\t\t\tCreationDate: dnsRecords[0].CreationDate,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbuckets, err := listBuckets(ctx)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t\tfor _, bucket := range buckets {\n\t\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\t\tBucketName:      bucket.Name,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      \"\",\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\treply.Buckets = append(reply.Buckets, WebBucketInfo{\n\t\t\t\t\tName:         bucket.Name,\n\t\t\t\t\tCreationDate: bucket.Created,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// ListObjectsArgs - list object args.\ntype ListObjectsArgs struct {\n\tBucketName string `json:\"bucketName\"`\n\tPrefix     string `json:\"prefix\"`\n\tMarker     string `json:\"marker\"`\n}\n\n// ListObjectsRep - list objects response.\ntype ListObjectsRep struct {\n\tObjects   []WebObjectInfo `json:\"objects\"`\n\tWritable  bool            `json:\"writable\"` // Used by client to show \"upload file\" button.\n\tUIVersion string          `json:\"uiVersion\"`\n}\n\n// WebObjectInfo container for list objects metadata.\ntype WebObjectInfo struct {\n\t// Name of the object\n\tKey string `json:\"name\"`\n\t// Date and time the object was last modified.\n\tLastModified time.Time `json:\"lastModified\"`\n\t// Size in bytes of the object.\n\tSize int64 `json:\"size\"`\n\t// ContentType is mime type of the object.\n\tContentType string `json:\"contentType\"`\n}\n\n// ListObjects - list objects api.\nfunc (web *webAPIHandlers) ListObjects(r *http.Request, args *ListObjectsArgs, reply *ListObjectsRep) error {\n\tctx := newWebContext(r, args, \"WebListObjects\")\n\treply.UIVersion = browser.UIVersion\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tlistObjects := objectAPI.ListObjects\n\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, err := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tnextMarker := \"\"\n\t\t// Fetch all the objects\n\t\tfor {\n\t\t\t// Let listObjects reply back the maximum from server implementation\n\t\t\tresult, err := core.ListObjects(args.BucketName, args.Prefix, nextMarker, SlashSeparator, 1000)\n\t\t\tif err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\n\t\t\tfor _, obj := range result.Contents {\n\t\t\t\treply.Objects = append(reply.Objects, WebObjectInfo{\n\t\t\t\t\tKey:          obj.Key,\n\t\t\t\t\tLastModified: obj.LastModified,\n\t\t\t\t\tSize:         obj.Size,\n\t\t\t\t\tContentType:  obj.ContentType,\n\t\t\t\t})\n\t\t\t}\n\t\t\tfor _, p := range result.CommonPrefixes {\n\t\t\t\treply.Objects = append(reply.Objects, WebObjectInfo{\n\t\t\t\t\tKey: p.Prefix,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tnextMarker = result.NextMarker\n\n\t\t\t// Return when there are no more objects\n\t\t\tif !result.IsTruncated {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\t\t\tr.Header.Set(\"prefix\", args.Prefix)\n\n\t\t\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\t\t\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t\t\t// Check if anonymous (non-owner) has access to download objects.\n\t\t\treadable := globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.ListBucketAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t})\n\n\t\t\t// Check if anonymous (non-owner) has access to upload objects.\n\t\t\twritable := globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.PutObjectAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      args.Prefix + SlashSeparator,\n\t\t\t})\n\n\t\t\treply.Writable = writable\n\t\t\tif !readable {\n\t\t\t\t// Error out if anonymous user (non-owner) has no access to download or upload objects\n\t\t\t\tif !writable {\n\t\t\t\t\treturn errAccessDenied\n\t\t\t\t}\n\t\t\t\t// return empty object list if access is write only\n\t\t\t\treturn nil\n\t\t\t}\n\t\t} else {\n\t\t\treturn toJSONError(ctx, authErr)\n\t\t}\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif authErr == nil {\n\t\t// Set prefix value for \"s3:prefix\" policy conditionals.\n\t\tr.Header.Set(\"prefix\", args.Prefix)\n\n\t\t// Set delimiter value for \"s3:delimiter\" policy conditionals.\n\t\tr.Header.Set(\"delimiter\", SlashSeparator)\n\n\t\treadable := globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.ListBucketAction,\n\t\t\tBucketName:      args.BucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tClaims:          claims.Map(),\n\t\t})\n\n\t\twritable := globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.PutObjectAction,\n\t\t\tBucketName:      args.BucketName,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      args.Prefix + SlashSeparator,\n\t\t\tClaims:          claims.Map(),\n\t\t})\n\n\t\treply.Writable = writable\n\t\tif !readable {\n\t\t\t// Error out if anonymous user (non-owner) has no access to download or upload objects\n\t\t\tif !writable {\n\t\t\t\treturn errAccessDenied\n\t\t\t}\n\t\t\t// return empty object list if access is write only\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\tnextMarker := \"\"\n\t// Fetch all the objects\n\tfor {\n\t\t// Limit browser to '1000' batches to be more responsive, scrolling friendly.\n\t\t// Also don't change the maxKeys value silly GCS SDKs do not honor maxKeys\n\t\t// values to be '-1'\n\t\tlo, err := listObjects(ctx, args.BucketName, args.Prefix, nextMarker, SlashSeparator, 1000)\n\t\tif err != nil {\n\t\t\treturn &json2.Error{Message: err.Error()}\n\t\t}\n\n\t\tnextMarker = lo.NextMarker\n\t\tfor i := range lo.Objects {\n\t\t\tlo.Objects[i].Size, err = lo.Objects[i].GetActualSize()\n\t\t\tif err != nil {\n\t\t\t\treturn toJSONError(ctx, err)\n\t\t\t}\n\t\t}\n\n\t\tfor _, obj := range lo.Objects {\n\t\t\treply.Objects = append(reply.Objects, WebObjectInfo{\n\t\t\t\tKey:          obj.Name,\n\t\t\t\tLastModified: obj.ModTime,\n\t\t\t\tSize:         obj.Size,\n\t\t\t\tContentType:  obj.ContentType,\n\t\t\t})\n\t\t}\n\t\tfor _, prefix := range lo.Prefixes {\n\t\t\treply.Objects = append(reply.Objects, WebObjectInfo{\n\t\t\t\tKey: prefix,\n\t\t\t})\n\t\t}\n\n\t\t// Return when there are no more objects\n\t\tif !lo.IsTruncated {\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// RemoveObjectArgs - args to remove an object, JSON will look like.\n//\n// {\n//     \"bucketname\": \"testbucket\",\n//     \"objects\": [\n//         \"photos/hawaii/\",\n//         \"photos/maldives/\",\n//         \"photos/sanjose.jpg\"\n//     ]\n// }\ntype RemoveObjectArgs struct {\n\tObjects    []string `json:\"objects\"`    // Contains objects, prefixes.\n\tBucketName string   `json:\"bucketname\"` // Contains bucket name.\n}\n\n// RemoveObject - removes an object, or all the objects at a given prefix.\nfunc (web *webAPIHandlers) RemoveObject(r *http.Request, args *RemoveObjectArgs, reply *WebGenericRep) error {\n\tctx := newWebContext(r, args, \"WebRemoveObject\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tdeleteObjects := objectAPI.DeleteObjects\n\tif web.CacheAPI() != nil {\n\t\tdeleteObjects = web.CacheAPI().DeleteObjects\n\t}\n\tgetObjectInfoFn := objectAPI.GetObjectInfo\n\tif web.CacheAPI() != nil {\n\t\tgetObjectInfoFn = web.CacheAPI().GetObjectInfo\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Check if all objects are allowed to be deleted anonymously\n\t\t\tfor _, object := range args.Objects {\n\t\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.DeleteObjectAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      object,\n\t\t\t\t}) {\n\t\t\t\t\treturn toJSONError(ctx, errAuthentication)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn toJSONError(ctx, authErr)\n\t\t}\n\t}\n\n\tif args.BucketName == \"\" || len(args.Objects) == 0 {\n\t\treturn toJSONError(ctx, errInvalidArgument)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, err := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tobjectsCh := make(chan miniogo.ObjectInfo)\n\n\t\t// Send object names that are needed to be removed to objectsCh\n\t\tgo func() {\n\t\t\tdefer close(objectsCh)\n\n\t\t\tfor _, objectName := range args.Objects {\n\t\t\t\tobjectsCh <- miniogo.ObjectInfo{\n\t\t\t\t\tKey: objectName,\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tfor resp := range core.RemoveObjects(ctx, args.BucketName, objectsCh, minio.RemoveObjectsOptions{}) {\n\t\t\tif resp.Err != nil {\n\t\t\t\treturn toJSONError(ctx, resp.Err, args.BucketName, resp.ObjectName)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\topts := ObjectOptions{\n\t\tVersioned:        globalBucketVersioningSys.Enabled(args.BucketName),\n\t\tVersionSuspended: globalBucketVersioningSys.Suspended(args.BucketName),\n\t}\n\tvar (\n\t\terr           error\n\t\treplicateSync bool\n\t)\nnext:\n\tfor _, objectName := range args.Objects {\n\t\t// If not a directory, remove the object.\n\t\tif !HasSuffix(objectName, SlashSeparator) && objectName != \"\" {\n\t\t\t// Check permissions for non-anonymous user.\n\t\t\tif authErr != errNoAuthToken {\n\t\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\t\tAction:          iampolicy.DeleteObjectAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\t\tIsOwner:         owner,\n\t\t\t\t\tObjectName:      objectName,\n\t\t\t\t\tClaims:          claims.Map(),\n\t\t\t\t}) {\n\t\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif authErr == errNoAuthToken {\n\t\t\t\t// Check if object is allowed to be deleted anonymously.\n\t\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.DeleteObjectAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      objectName,\n\t\t\t\t}) {\n\t\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar (\n\t\t\t\treplicateDel, hasLifecycleConfig bool\n\t\t\t\tgoi                              ObjectInfo\n\t\t\t\tgerr                             error\n\t\t\t)\n\t\t\tif _, err := globalBucketMetadataSys.GetLifecycleConfig(args.BucketName); err == nil {\n\t\t\t\thasLifecycleConfig = true\n\t\t\t}\n\t\t\tif hasReplicationRules(ctx, args.BucketName, []ObjectToDelete{{ObjectName: objectName}}) || hasLifecycleConfig {\n\t\t\t\tgoi, gerr = getObjectInfoFn(ctx, args.BucketName, objectName, opts)\n\t\t\t\tif _, replicateDel, replicateSync = checkReplicateDelete(ctx, args.BucketName, ObjectToDelete{ObjectName: objectName, VersionID: goi.VersionID}, goi, gerr); replicateDel {\n\t\t\t\t\topts.DeleteMarkerReplicationStatus = string(replication.Pending)\n\t\t\t\t\topts.DeleteMarker = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toi, err := deleteObject(ctx, objectAPI, web.CacheAPI(), args.BucketName, objectName, nil, r, opts)\n\t\t\tif replicateDel && err == nil {\n\t\t\t\tdobj := DeletedObjectVersionInfo{\n\t\t\t\t\tDeletedObject: DeletedObject{\n\t\t\t\t\t\tObjectName:                    objectName,\n\t\t\t\t\t\tDeleteMarkerVersionID:         oi.VersionID,\n\t\t\t\t\t\tDeleteMarkerReplicationStatus: string(oi.ReplicationStatus),\n\t\t\t\t\t\tDeleteMarkerMTime:             DeleteMarkerMTime{oi.ModTime},\n\t\t\t\t\t\tDeleteMarker:                  oi.DeleteMarker,\n\t\t\t\t\t\tVersionPurgeStatus:            oi.VersionPurgeStatus,\n\t\t\t\t\t},\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}\n\t\t\t\tscheduleReplicationDelete(ctx, dobj, objectAPI, replicateSync)\n\t\t\t}\n\t\t\tif goi.TransitionStatus == lifecycle.TransitionComplete && err == nil && goi.VersionID == \"\" {\n\t\t\t\taction := lifecycle.DeleteAction\n\t\t\t\tif goi.VersionID != \"\" {\n\t\t\t\t\taction = lifecycle.DeleteVersionAction\n\t\t\t\t}\n\t\t\t\tdeleteTransitionedObject(ctx, newObjectLayerFn(), args.BucketName, objectName, lifecycle.ObjectOpts{\n\t\t\t\t\tName:         objectName,\n\t\t\t\t\tUserTags:     goi.UserTags,\n\t\t\t\t\tVersionID:    goi.VersionID,\n\t\t\t\t\tDeleteMarker: goi.DeleteMarker,\n\t\t\t\t\tIsLatest:     goi.IsLatest,\n\t\t\t\t}, action, true)\n\t\t\t}\n\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Check if object is allowed to be deleted anonymously\n\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          iampolicy.DeleteObjectAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      objectName,\n\t\t\t}) {\n\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t}\n\t\t} else {\n\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.DeleteObjectAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      objectName,\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t}\n\t\t}\n\n\t\t// Allocate new results channel to receive ObjectInfo.\n\t\tobjInfoCh := make(chan ObjectInfo)\n\n\t\t// Walk through all objects\n\t\tif err = objectAPI.Walk(ctx, args.BucketName, objectName, objInfoCh, ObjectOptions{}); err != nil {\n\t\t\tbreak next\n\t\t}\n\n\t\tfor {\n\t\t\tvar objects []ObjectToDelete\n\t\t\tfor obj := range objInfoCh {\n\t\t\t\tif len(objects) == maxDeleteList {\n\t\t\t\t\t// Reached maximum delete requests, attempt a delete for now.\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif obj.ReplicationStatus == replication.Replica {\n\t\t\t\t\tif authErr == errNoAuthToken {\n\t\t\t\t\t\t// Check if object is allowed to be deleted anonymously\n\t\t\t\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\t\t\tAction:          iampolicy.ReplicateDeleteAction,\n\t\t\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\t\t\tObjectName:      objectName,\n\t\t\t\t\t\t}) {\n\t\t\t\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\t\t\t\tAction:          iampolicy.ReplicateDeleteAction,\n\t\t\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\t\t\t\tIsOwner:         owner,\n\t\t\t\t\t\t\tObjectName:      objectName,\n\t\t\t\t\t\t\tClaims:          claims.Map(),\n\t\t\t\t\t\t}) {\n\t\t\t\t\t\t\treturn toJSONError(ctx, errAccessDenied)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_, replicateDel, _ := checkReplicateDelete(ctx, args.BucketName, ObjectToDelete{ObjectName: obj.Name, VersionID: obj.VersionID}, obj, nil)\n\t\t\t\t// since versioned delete is not available on web browser, yet - this is a simple DeleteMarker replication\n\t\t\t\tobjToDel := ObjectToDelete{ObjectName: obj.Name}\n\t\t\t\tif replicateDel {\n\t\t\t\t\tobjToDel.DeleteMarkerReplicationStatus = string(replication.Pending)\n\t\t\t\t}\n\n\t\t\t\tobjects = append(objects, objToDel)\n\t\t\t}\n\n\t\t\t// Nothing to do.\n\t\t\tif len(objects) == 0 {\n\t\t\t\tbreak next\n\t\t\t}\n\n\t\t\t// Deletes a list of objects.\n\t\t\tdeletedObjects, errs := deleteObjects(ctx, args.BucketName, objects, opts)\n\t\t\tfor i, err := range errs {\n\t\t\t\tif err != nil && !isErrObjectNotFound(err) {\n\t\t\t\t\tdeletedObjects[i].DeleteMarkerReplicationStatus = objects[i].DeleteMarkerReplicationStatus\n\t\t\t\t\tdeletedObjects[i].VersionPurgeStatus = objects[i].VersionPurgeStatus\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\t\tbreak next\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Notify deleted event for objects.\n\t\t\tfor _, dobj := range deletedObjects {\n\t\t\t\tobjInfo := ObjectInfo{\n\t\t\t\t\tName:      dobj.ObjectName,\n\t\t\t\t\tVersionID: dobj.VersionID,\n\t\t\t\t}\n\t\t\t\tif dobj.DeleteMarker {\n\t\t\t\t\tobjInfo = ObjectInfo{\n\t\t\t\t\t\tName:         dobj.ObjectName,\n\t\t\t\t\t\tDeleteMarker: dobj.DeleteMarker,\n\t\t\t\t\t\tVersionID:    dobj.DeleteMarkerVersionID,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsendEvent(eventArgs{\n\t\t\t\t\tEventName:  event.ObjectRemovedDelete,\n\t\t\t\t\tBucketName: args.BucketName,\n\t\t\t\t\tObject:     objInfo,\n\t\t\t\t\tReqParams:  extractReqParams(r),\n\t\t\t\t\tUserAgent:  r.UserAgent(),\n\t\t\t\t\tHost:       handlers.GetSourceIP(r),\n\t\t\t\t})\n\t\t\t\tif dobj.DeleteMarkerReplicationStatus == string(replication.Pending) || dobj.VersionPurgeStatus == Pending {\n\t\t\t\t\tdv := DeletedObjectVersionInfo{\n\t\t\t\t\t\tDeletedObject: dobj,\n\t\t\t\t\t\tBucket:        args.BucketName,\n\t\t\t\t\t}\n\t\t\t\t\tscheduleReplicationDelete(ctx, dv, objectAPI, replicateSync)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif err != nil && !isErrObjectNotFound(err) && !isErrVersionNotFound(err) {\n\t\t// Ignore object not found error.\n\t\treturn toJSONError(ctx, err, args.BucketName, \"\")\n\t}\n\n\treturn nil\n}\n\n// LoginArgs - login arguments.\ntype LoginArgs struct {\n\tUsername string `json:\"username\" form:\"username\"`\n\tPassword string `json:\"password\" form:\"password\"`\n}\n\n// LoginRep - login reply.\ntype LoginRep struct {\n\tToken     string `json:\"token\"`\n\tUIVersion string `json:\"uiVersion\"`\n}\n\n// Login - user login handler.\nfunc (web *webAPIHandlers) Login(r *http.Request, args *LoginArgs, reply *LoginRep) error {\n\tctx := newWebContext(r, args, \"WebLogin\")\n\ttoken, err := authenticateWeb(args.Username, args.Password)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\treply.Token = token\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// GenerateAuthReply - reply for GenerateAuth\ntype GenerateAuthReply struct {\n\tAccessKey string `json:\"accessKey\"`\n\tSecretKey string `json:\"secretKey\"`\n\tUIVersion string `json:\"uiVersion\"`\n}\n\nfunc (web webAPIHandlers) GenerateAuth(r *http.Request, args *WebGenericArgs, reply *GenerateAuthReply) error {\n\tctx := newWebContext(r, args, \"WebGenerateAuth\")\n\t_, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\tif !owner {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\tcred, err := auth.GetNewCredentials()\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\treply.AccessKey = cred.AccessKey\n\treply.SecretKey = cred.SecretKey\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// SetAuthArgs - argument for SetAuth\ntype SetAuthArgs struct {\n\tCurrentAccessKey string `json:\"currentAccessKey\"`\n\tCurrentSecretKey string `json:\"currentSecretKey\"`\n\tNewAccessKey     string `json:\"newAccessKey\"`\n\tNewSecretKey     string `json:\"newSecretKey\"`\n}\n\n// SetAuthReply - reply for SetAuth\ntype SetAuthReply struct {\n\tToken       string            `json:\"token\"`\n\tUIVersion   string            `json:\"uiVersion\"`\n\tPeerErrMsgs map[string]string `json:\"peerErrMsgs\"`\n}\n\n// SetAuth - Set accessKey and secretKey credentials.\nfunc (web *webAPIHandlers) SetAuth(r *http.Request, args *SetAuthArgs, reply *SetAuthReply) error {\n\tctx := newWebContext(r, args, \"WebSetAuth\")\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\tif owner {\n\t\t// Owner is not allowed to change credentials through browser.\n\t\treturn toJSONError(ctx, errChangeCredNotAllowed)\n\t}\n\n\t// for IAM users, access key cannot be updated\n\t// claims.AccessKey is used instead of accesskey from args\n\tprevCred, ok := globalIAMSys.GetUser(claims.AccessKey)\n\tif !ok {\n\t\treturn errInvalidAccessKeyID\n\t}\n\n\t// Throw error when wrong secret key is provided\n\tif subtle.ConstantTimeCompare([]byte(prevCred.SecretKey), []byte(args.CurrentSecretKey)) != 1 {\n\t\treturn errIncorrectCreds\n\t}\n\n\tcreds, err := auth.CreateCredentials(claims.AccessKey, args.NewSecretKey)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\terr = globalIAMSys.SetUserSecretKey(creds.AccessKey, creds.SecretKey)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\treply.Token, err = authenticateWeb(creds.AccessKey, creds.SecretKey)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\n\treturn nil\n}\n\n// URLTokenReply contains the reply for CreateURLToken.\ntype URLTokenReply struct {\n\tToken     string `json:\"token\"`\n\tUIVersion string `json:\"uiVersion\"`\n}\n\n// CreateURLToken creates a URL token (short-lived) for GET requests.\nfunc (web *webAPIHandlers) CreateURLToken(r *http.Request, args *WebGenericArgs, reply *URLTokenReply) error {\n\tctx := newWebContext(r, args, \"WebCreateURLToken\")\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\tcreds := globalActiveCred\n\tif !owner {\n\t\tvar ok bool\n\t\tcreds, ok = globalIAMSys.GetUser(claims.AccessKey)\n\t\tif !ok {\n\t\t\treturn toJSONError(ctx, errInvalidAccessKeyID)\n\t\t}\n\t}\n\n\tif creds.SessionToken != \"\" {\n\t\t// Use the same session token for URL token.\n\t\treply.Token = creds.SessionToken\n\t} else {\n\t\ttoken, err := authenticateURL(creds.AccessKey, creds.SecretKey)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err)\n\t\t}\n\t\treply.Token = token\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// Upload - file upload handler.\nfunc (web *webAPIHandlers) Upload(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"WebUpload\")\n\n\t// obtain the claims here if possible, for audit logging.\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\n\tdefer logger.AuditLog(w, r, \"WebUpload\", claims.Map())\n\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\twriteWebErrorResponse(w, errServerNotInitialized)\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tbucket := vars[\"bucket\"]\n\tobject, err := url.PathUnescape(vars[\"object\"])\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\tretPerms := ErrAccessDenied\n\tholdPerms := ErrAccessDenied\n\treplPerms := ErrAccessDenied\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Check if anonymous (non-owner) has access to upload objects.\n\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.PutObjectAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\twriteWebErrorResponse(w, authErr)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif authErr == nil {\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.PutObjectAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\treturn\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.PutObjectRetentionAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\tretPerms = ErrNone\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.PutObjectLegalHoldAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\tholdPerms = ErrNone\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.GetReplicationConfigurationAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      \"\",\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\treplPerms = ErrNone\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(bucket, false) {\n\t\twriteWebErrorResponse(w, errInvalidBucketName)\n\t\treturn\n\t}\n\n\t// Check if bucket encryption is enabled\n\t_, err = globalBucketSSEConfigSys.Get(bucket)\n\tif (globalAutoEncryption || err == nil) && !crypto.SSEC.IsRequested(r.Header) {\n\t\tr.Header.Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)\n\t}\n\n\t// Require Content-Length to be set in the request\n\tsize := r.ContentLength\n\tif size < 0 {\n\t\twriteWebErrorResponse(w, errSizeUnspecified)\n\t\treturn\n\t}\n\n\tif err := enforceBucketQuota(ctx, bucket, size); err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\t// Extract incoming metadata if any.\n\tmetadata, err := extractMetadata(ctx, r)\n\tif err != nil {\n\t\twriteErrorResponse(ctx, w, toAPIError(ctx, err), r.URL, guessIsBrowserReq(r))\n\t\treturn\n\t}\n\n\tvar pReader *PutObjReader\n\tvar reader io.Reader = r.Body\n\tactualSize := size\n\n\thashReader, err := hash.NewReader(reader, size, \"\", \"\", actualSize, globalCLIContext.StrictS3Compat)\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\tif objectAPI.IsCompressionSupported() && isCompressible(r.Header, object) && size > 0 {\n\t\t// Storing the compression metadata.\n\t\tmetadata[ReservedMetadataPrefix+\"compression\"] = compressionAlgorithmV2\n\t\tmetadata[ReservedMetadataPrefix+\"actual-size\"] = strconv.FormatInt(actualSize, 10)\n\n\t\tactualReader, err := hash.NewReader(reader, actualSize, \"\", \"\", actualSize, globalCLIContext.StrictS3Compat)\n\t\tif err != nil {\n\t\t\twriteWebErrorResponse(w, err)\n\t\t\treturn\n\t\t}\n\n\t\t// Set compression metrics.\n\t\tsize = -1 // Since compressed size is un-predictable.\n\t\ts2c := newS2CompressReader(actualReader, actualSize)\n\t\tdefer s2c.Close()\n\t\treader = s2c\n\t\thashReader, err = hash.NewReader(reader, size, \"\", \"\", actualSize, globalCLIContext.StrictS3Compat)\n\t\tif err != nil {\n\t\t\twriteWebErrorResponse(w, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tmustReplicate, sync := mustReplicateWeb(ctx, r, bucket, object, metadata, \"\", replPerms)\n\tif mustReplicate {\n\t\tmetadata[xhttp.AmzBucketReplicationStatus] = string(replication.Pending)\n\t}\n\tpReader = NewPutObjReader(hashReader, nil, nil)\n\t// get gateway encryption options\n\topts, err := putOpts(ctx, r, bucket, object, metadata)\n\tif err != nil {\n\t\twriteErrorResponseHeadersOnly(w, toAPIError(ctx, err))\n\t\treturn\n\t}\n\n\tif objectAPI.IsEncryptionSupported() {\n\t\tif _, ok := crypto.IsRequested(r.Header); ok && !HasSuffix(object, SlashSeparator) { // handle SSE requests\n\t\t\trawReader := hashReader\n\t\t\tvar objectEncryptionKey crypto.ObjectKey\n\t\t\treader, objectEncryptionKey, err = EncryptRequest(hashReader, r, bucket, object, metadata)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, toAPIError(ctx, err), r.URL, guessIsBrowserReq(r))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tinfo := ObjectInfo{Size: size}\n\t\t\t// do not try to verify encrypted content\n\t\t\thashReader, err = hash.NewReader(reader, info.EncryptedSize(), \"\", \"\", size, globalCLIContext.StrictS3Compat)\n\t\t\tif err != nil {\n\t\t\t\twriteErrorResponse(ctx, w, toAPIError(ctx, err), r.URL, guessIsBrowserReq(r))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpReader = NewPutObjReader(rawReader, hashReader, &objectEncryptionKey)\n\t\t}\n\t}\n\n\t// Ensure that metadata does not contain sensitive information\n\tcrypto.RemoveSensitiveEntries(metadata)\n\n\tputObject := objectAPI.PutObject\n\tgetObjectInfo := objectAPI.GetObjectInfo\n\tif web.CacheAPI() != nil {\n\t\tputObject = web.CacheAPI().PutObject\n\t\tgetObjectInfo = web.CacheAPI().GetObjectInfo\n\t}\n\n\t// enforce object retention rules\n\tretentionMode, retentionDate, _, s3Err := checkPutObjectLockAllowed(ctx, r, bucket, object, getObjectInfo, retPerms, holdPerms)\n\tif s3Err != ErrNone {\n\t\twriteErrorResponse(ctx, w, errorCodes.ToAPIErr(s3Err), r.URL, guessIsBrowserReq(r))\n\t\treturn\n\t}\n\tif retentionMode != \"\" {\n\t\topts.UserDefined[xhttp.AmzObjectLockMode] = string(retentionMode)\n\t\topts.UserDefined[xhttp.AmzObjectLockRetainUntilDate] = retentionDate.UTC().Format(iso8601TimeFormat)\n\t}\n\n\tobjInfo, err := putObject(GlobalContext, bucket, object, pReader, opts)\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\tif objectAPI.IsEncryptionSupported() {\n\t\tif crypto.IsEncrypted(objInfo.UserDefined) {\n\t\t\tswitch {\n\t\t\tcase crypto.S3.IsEncrypted(objInfo.UserDefined):\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)\n\t\t\tcase crypto.SSEC.IsRequested(r.Header):\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryptionCustomerAlgorithm, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerAlgorithm))\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryptionCustomerKeyMD5, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerKeyMD5))\n\t\t\t}\n\t\t}\n\t}\n\tif mustReplicate {\n\t\tscheduleReplication(ctx, objInfo, objectAPI, sync)\n\t}\n\n\t// Notify object created event.\n\tsendEvent(eventArgs{\n\t\tEventName:    event.ObjectCreatedPut,\n\t\tBucketName:   bucket,\n\t\tObject:       objInfo,\n\t\tReqParams:    extractReqParams(r),\n\t\tRespElements: extractRespElements(w),\n\t\tUserAgent:    r.UserAgent(),\n\t\tHost:         handlers.GetSourceIP(r),\n\t})\n}\n\n// Download - file download handler.\nfunc (web *webAPIHandlers) Download(w http.ResponseWriter, r *http.Request) {\n\tctx := newContext(r, w, \"WebDownload\")\n\n\tvars := mux.Vars(r)\n\n\tclaims, owner, authErr := webTokenAuthenticate(r.URL.Query().Get(\"token\"))\n\tdefer logger.AuditLog(w, r, \"WebDownload\", claims.Map())\n\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\twriteWebErrorResponse(w, errServerNotInitialized)\n\t\treturn\n\t}\n\n\tbucket := vars[\"bucket\"]\n\tobject, err := url.PathUnescape(vars[\"object\"])\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\tgetRetPerms := ErrAccessDenied\n\tlegalHoldPerms := ErrAccessDenied\n\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\t// Check if anonymous (non-owner) has access to download objects.\n\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.GetObjectAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.GetObjectRetentionAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\tgetRetPerms = ErrNone\n\t\t\t}\n\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\tAction:          policy.GetObjectLegalHoldAction,\n\t\t\t\tBucketName:      bucket,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\tIsOwner:         false,\n\t\t\t\tObjectName:      object,\n\t\t\t}) {\n\t\t\t\tlegalHoldPerms = ErrNone\n\t\t\t}\n\t\t} else {\n\t\t\twriteWebErrorResponse(w, authErr)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif authErr == nil {\n\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.GetObjectAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\treturn\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.GetObjectRetentionAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\tgetRetPerms = ErrNone\n\t\t}\n\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\tAccountName:     claims.AccessKey,\n\t\t\tAction:          iampolicy.GetObjectLegalHoldAction,\n\t\t\tBucketName:      bucket,\n\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\tIsOwner:         owner,\n\t\t\tObjectName:      object,\n\t\t\tClaims:          claims.Map(),\n\t\t}) {\n\t\t\tlegalHoldPerms = ErrNone\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(bucket, false) {\n\t\twriteWebErrorResponse(w, errInvalidBucketName)\n\t\treturn\n\t}\n\n\tgetObjectNInfo := objectAPI.GetObjectNInfo\n\tif web.CacheAPI() != nil {\n\t\tgetObjectNInfo = web.CacheAPI().GetObjectNInfo\n\t}\n\n\tvar opts ObjectOptions\n\tgr, err := getObjectNInfo(ctx, bucket, object, nil, r.Header, readLock, opts)\n\tif err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\tdefer gr.Close()\n\n\tobjInfo := gr.ObjInfo\n\n\t// filter object lock metadata if permission does not permit\n\tobjInfo.UserDefined = objectlock.FilterObjectLockMetadata(objInfo.UserDefined, getRetPerms != ErrNone, legalHoldPerms != ErrNone)\n\n\tif objectAPI.IsEncryptionSupported() {\n\t\tif _, err = DecryptObjectInfo(&objInfo, r); err != nil {\n\t\t\twriteWebErrorResponse(w, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Set encryption response headers\n\tif objectAPI.IsEncryptionSupported() {\n\t\tif crypto.IsEncrypted(objInfo.UserDefined) {\n\t\t\tswitch {\n\t\t\tcase crypto.S3.IsEncrypted(objInfo.UserDefined):\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryption, xhttp.AmzEncryptionAES)\n\t\t\tcase crypto.SSEC.IsEncrypted(objInfo.UserDefined):\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryptionCustomerAlgorithm, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerAlgorithm))\n\t\t\t\tw.Header().Set(xhttp.AmzServerSideEncryptionCustomerKeyMD5, r.Header.Get(xhttp.AmzServerSideEncryptionCustomerKeyMD5))\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set Parts Count Header\n\tif opts.PartNumber > 0 && len(objInfo.Parts) > 0 {\n\t\tsetPartsCountHeaders(w, objInfo)\n\t}\n\n\tif err = setObjectHeaders(w, objInfo, nil, opts); err != nil {\n\t\twriteWebErrorResponse(w, err)\n\t\treturn\n\t}\n\n\t// Add content disposition.\n\tw.Header().Set(xhttp.ContentDisposition, fmt.Sprintf(\"attachment; filename=\\\"%s\\\"\", path.Base(objInfo.Name)))\n\n\tsetHeadGetRespHeaders(w, r.URL.Query())\n\n\thttpWriter := ioutil.WriteOnClose(w)\n\n\t// Write object content to response body\n\tif _, err = io.Copy(httpWriter, gr); err != nil {\n\t\tif !httpWriter.HasWritten() { // write error response only if no data or headers has been written to client yet\n\t\t\twriteWebErrorResponse(w, err)\n\t\t}\n\t\treturn\n\t}\n\n\tif err = httpWriter.Close(); err != nil {\n\t\tif !httpWriter.HasWritten() { // write error response only if no data or headers has been written to client yet\n\t\t\twriteWebErrorResponse(w, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Notify object accessed via a GET request.\n\tsendEvent(eventArgs{\n\t\tEventName:    event.ObjectAccessedGet,\n\t\tBucketName:   bucket,\n\t\tObject:       objInfo,\n\t\tReqParams:    extractReqParams(r),\n\t\tRespElements: extractRespElements(w),\n\t\tUserAgent:    r.UserAgent(),\n\t\tHost:         handlers.GetSourceIP(r),\n\t})\n}\n\n// DownloadZipArgs - Argument for downloading a bunch of files as a zip file.\n// JSON will look like:\n// '{\"bucketname\":\"testbucket\",\"prefix\":\"john/pics/\",\"objects\":[\"hawaii/\",\"maldives/\",\"sanjose.jpg\"]}'\ntype DownloadZipArgs struct {\n\tObjects    []string `json:\"objects\"`    // can be files or sub-directories\n\tPrefix     string   `json:\"prefix\"`     // current directory in the browser-ui\n\tBucketName string   `json:\"bucketname\"` // bucket name.\n}\n\n// Takes a list of objects and creates a zip file that sent as the response body.\nfunc (web *webAPIHandlers) DownloadZip(w http.ResponseWriter, r *http.Request) {\n\thost := handlers.GetSourceIP(r)\n\n\tclaims, owner, authErr := webTokenAuthenticate(r.URL.Query().Get(\"token\"))\n\n\tctx := newContext(r, w, \"WebDownloadZip\")\n\tdefer logger.AuditLog(w, r, \"WebDownloadZip\", claims.Map())\n\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\twriteWebErrorResponse(w, errServerNotInitialized)\n\t\treturn\n\t}\n\n\t// Auth is done after reading the body to accommodate for anonymous requests\n\t// when bucket policy is enabled.\n\tvar args DownloadZipArgs\n\ttenKB := 10 * 1024 // To limit r.Body to take care of misbehaving anonymous client.\n\tdecodeErr := json.NewDecoder(io.LimitReader(r.Body, int64(tenKB))).Decode(&args)\n\tif decodeErr != nil {\n\t\twriteWebErrorResponse(w, decodeErr)\n\t\treturn\n\t}\n\n\tvar getRetPerms []APIErrorCode\n\tvar legalHoldPerms []APIErrorCode\n\n\tif authErr != nil {\n\t\tif authErr == errNoAuthToken {\n\t\t\tfor _, object := range args.Objects {\n\t\t\t\t// Check if anonymous (non-owner) has access to download objects.\n\t\t\t\tif !globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.GetObjectAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\t}) {\n\t\t\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tretentionPerm := ErrAccessDenied\n\t\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.GetObjectRetentionAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\t}) {\n\t\t\t\t\tretentionPerm = ErrNone\n\t\t\t\t}\n\t\t\t\tgetRetPerms = append(getRetPerms, retentionPerm)\n\n\t\t\t\tlegalHoldPerm := ErrAccessDenied\n\t\t\t\tif globalPolicySys.IsAllowed(policy.Args{\n\t\t\t\t\tAction:          policy.GetObjectLegalHoldAction,\n\t\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\t\tConditionValues: getConditionValues(r, \"\", \"\", nil),\n\t\t\t\t\tIsOwner:         false,\n\t\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\t}) {\n\t\t\t\t\tlegalHoldPerm = ErrNone\n\t\t\t\t}\n\t\t\t\tlegalHoldPerms = append(legalHoldPerms, legalHoldPerm)\n\t\t\t}\n\t\t} else {\n\t\t\twriteWebErrorResponse(w, authErr)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif authErr == nil {\n\t\tfor _, object := range args.Objects {\n\t\t\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.GetObjectAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\twriteWebErrorResponse(w, errAuthentication)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tretentionPerm := ErrAccessDenied\n\t\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.GetObjectRetentionAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\tretentionPerm = ErrNone\n\t\t\t}\n\t\t\tgetRetPerms = append(getRetPerms, retentionPerm)\n\n\t\t\tlegalHoldPerm := ErrAccessDenied\n\t\t\tif globalIAMSys.IsAllowed(iampolicy.Args{\n\t\t\t\tAccountName:     claims.AccessKey,\n\t\t\t\tAction:          iampolicy.GetObjectLegalHoldAction,\n\t\t\t\tBucketName:      args.BucketName,\n\t\t\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\t\t\tIsOwner:         owner,\n\t\t\t\tObjectName:      pathJoin(args.Prefix, object),\n\t\t\t\tClaims:          claims.Map(),\n\t\t\t}) {\n\t\t\t\tlegalHoldPerm = ErrNone\n\t\t\t}\n\t\t\tlegalHoldPerms = append(legalHoldPerms, legalHoldPerm)\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\twriteWebErrorResponse(w, errInvalidBucketName)\n\t\treturn\n\t}\n\n\tgetObjectNInfo := objectAPI.GetObjectNInfo\n\tif web.CacheAPI() != nil {\n\t\tgetObjectNInfo = web.CacheAPI().GetObjectNInfo\n\t}\n\n\tarchive := zip.NewWriter(w)\n\tdefer archive.Close()\n\n\tfor i, object := range args.Objects {\n\t\t// Writes compressed object file to the response.\n\t\tzipit := func(objectName string) error {\n\t\t\tvar opts ObjectOptions\n\t\t\tgr, err := getObjectNInfo(ctx, args.BucketName, objectName, nil, r.Header, readLock, opts)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer gr.Close()\n\n\t\t\tinfo := gr.ObjInfo\n\t\t\t// filter object lock metadata if permission does not permit\n\t\t\tinfo.UserDefined = objectlock.FilterObjectLockMetadata(info.UserDefined, getRetPerms[i] != ErrNone, legalHoldPerms[i] != ErrNone)\n\t\t\t// For reporting, set the file size to the uncompressed size.\n\t\t\tinfo.Size, err = info.GetActualSize()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\theader := &zip.FileHeader{\n\t\t\t\tName:     strings.TrimPrefix(objectName, args.Prefix),\n\t\t\t\tMethod:   zip.Deflate,\n\t\t\t\tFlags:    1 << 11,\n\t\t\t\tModified: info.ModTime,\n\t\t\t}\n\t\t\tif hasStringSuffixInSlice(info.Name, standardExcludeCompressExtensions) || hasPattern(standardExcludeCompressContentTypes, info.ContentType) {\n\t\t\t\t// We strictly disable compression for standard extensions/content-types.\n\t\t\t\theader.Method = zip.Store\n\t\t\t}\n\t\t\twriter, err := archive.CreateHeader(header)\n\t\t\tif err != nil {\n\t\t\t\twriteWebErrorResponse(w, errUnexpected)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\thttpWriter := ioutil.WriteOnClose(writer)\n\n\t\t\t// Write object content to response body\n\t\t\tif _, err = io.Copy(httpWriter, gr); err != nil {\n\t\t\t\thttpWriter.Close()\n\t\t\t\tif !httpWriter.HasWritten() { // write error response only if no data or headers has been written to client yet\n\t\t\t\t\twriteWebErrorResponse(w, err)\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err = httpWriter.Close(); err != nil {\n\t\t\t\tif !httpWriter.HasWritten() { // write error response only if no data has been written to client yet\n\t\t\t\t\twriteWebErrorResponse(w, err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Notify object accessed via a GET request.\n\t\t\tsendEvent(eventArgs{\n\t\t\t\tEventName:    event.ObjectAccessedGet,\n\t\t\t\tBucketName:   args.BucketName,\n\t\t\t\tObject:       info,\n\t\t\t\tReqParams:    extractReqParams(r),\n\t\t\t\tRespElements: extractRespElements(w),\n\t\t\t\tUserAgent:    r.UserAgent(),\n\t\t\t\tHost:         host,\n\t\t\t})\n\n\t\t\treturn nil\n\t\t}\n\n\t\tif !HasSuffix(object, SlashSeparator) {\n\t\t\t// If not a directory, compress the file and write it to response.\n\t\t\terr := zipit(pathJoin(args.Prefix, object))\n\t\t\tif err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tobjInfoCh := make(chan ObjectInfo)\n\n\t\t// Walk through all objects\n\t\tif err := objectAPI.Walk(ctx, args.BucketName, pathJoin(args.Prefix, object), objInfoCh, ObjectOptions{}); err != nil {\n\t\t\tlogger.LogIf(ctx, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfor obj := range objInfoCh {\n\t\t\tif err := zipit(obj.Name); err != nil {\n\t\t\t\tlogger.LogIf(ctx, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\n// GetBucketPolicyArgs - get bucket policy args.\ntype GetBucketPolicyArgs struct {\n\tBucketName string `json:\"bucketName\"`\n\tPrefix     string `json:\"prefix\"`\n}\n\n// GetBucketPolicyRep - get bucket policy reply.\ntype GetBucketPolicyRep struct {\n\tUIVersion string                     `json:\"uiVersion\"`\n\tPolicy    miniogopolicy.BucketPolicy `json:\"policy\"`\n}\n\n// GetBucketPolicy - get bucket policy for the requested prefix.\nfunc (web *webAPIHandlers) GetBucketPolicy(r *http.Request, args *GetBucketPolicyArgs, reply *GetBucketPolicyRep) error {\n\tctx := newWebContext(r, args, \"WebGetBucketPolicy\")\n\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.GetBucketPolicyAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\tvar policyInfo = &miniogopolicy.BucketAccessPolicy{Version: \"2012-10-17\"}\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tclient, rerr := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif rerr != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tpolicyStr, err := client.GetBucketPolicy(ctx, args.BucketName)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tbucketPolicy, err := policy.ParseConfig(strings.NewReader(policyStr), args.BucketName)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tpolicyInfo, err = PolicyToBucketAccessPolicy(bucketPolicy)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t} else {\n\t\tbucketPolicy, err := globalPolicySys.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(BucketPolicyNotFound); !ok {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\n\t\tpolicyInfo, err = PolicyToBucketAccessPolicy(bucketPolicy)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\treply.Policy = miniogopolicy.GetPolicy(policyInfo.Statements, args.BucketName, args.Prefix)\n\n\treturn nil\n}\n\n// ListAllBucketPoliciesArgs - get all bucket policies.\ntype ListAllBucketPoliciesArgs struct {\n\tBucketName string `json:\"bucketName\"`\n}\n\n// BucketAccessPolicy - Collection of canned bucket policy at a given prefix.\ntype BucketAccessPolicy struct {\n\tBucket string                     `json:\"bucket\"`\n\tPrefix string                     `json:\"prefix\"`\n\tPolicy miniogopolicy.BucketPolicy `json:\"policy\"`\n}\n\n// ListAllBucketPoliciesRep - get all bucket policy reply.\ntype ListAllBucketPoliciesRep struct {\n\tUIVersion string               `json:\"uiVersion\"`\n\tPolicies  []BucketAccessPolicy `json:\"policies\"`\n}\n\n// ListAllBucketPolicies - get all bucket policy.\nfunc (web *webAPIHandlers) ListAllBucketPolicies(r *http.Request, args *ListAllBucketPoliciesArgs, reply *ListAllBucketPoliciesRep) error {\n\tctx := newWebContext(r, args, \"WebListAllBucketPolicies\")\n\tobjectAPI := web.ObjectAPI()\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.GetBucketPolicyAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\tvar policyInfo = new(miniogopolicy.BucketAccessPolicy)\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, rerr := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif rerr != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tvar policyStr string\n\t\tpolicyStr, err = core.Client.GetBucketPolicy(ctx, args.BucketName)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tif policyStr != \"\" {\n\t\t\tif err = json.Unmarshal([]byte(policyStr), policyInfo); err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbucketPolicy, err := globalPolicySys.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(BucketPolicyNotFound); !ok {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\t\tpolicyInfo, err = PolicyToBucketAccessPolicy(bucketPolicy)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\tfor prefix, policy := range miniogopolicy.GetPolicies(policyInfo.Statements, args.BucketName, \"\") {\n\t\tbucketName, objectPrefix := path2BucketObject(prefix)\n\t\tobjectPrefix = strings.TrimSuffix(objectPrefix, \"*\")\n\t\treply.Policies = append(reply.Policies, BucketAccessPolicy{\n\t\t\tBucket: bucketName,\n\t\t\tPrefix: objectPrefix,\n\t\t\tPolicy: policy,\n\t\t})\n\t}\n\n\treturn nil\n}\n\n// SetBucketPolicyWebArgs - set bucket policy args.\ntype SetBucketPolicyWebArgs struct {\n\tBucketName string `json:\"bucketName\"`\n\tPrefix     string `json:\"prefix\"`\n\tPolicy     string `json:\"policy\"`\n}\n\n// SetBucketPolicy - set bucket policy.\nfunc (web *webAPIHandlers) SetBucketPolicy(r *http.Request, args *SetBucketPolicyWebArgs, reply *WebGenericRep) error {\n\tctx := newWebContext(r, args, \"WebSetBucketPolicy\")\n\tobjectAPI := web.ObjectAPI()\n\treply.UIVersion = browser.UIVersion\n\n\tif objectAPI == nil {\n\t\treturn toJSONError(ctx, errServerNotInitialized)\n\t}\n\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\n\t// For authenticated users apply IAM policy.\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.PutBucketPolicyAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errAccessDenied)\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\tpolicyType := miniogopolicy.BucketPolicy(args.Policy)\n\tif !policyType.IsValidBucketPolicy() {\n\t\treturn &json2.Error{\n\t\t\tMessage: \"Invalid policy type \" + args.Policy,\n\t\t}\n\t}\n\n\tif isRemoteCallRequired(ctx, args.BucketName, objectAPI) {\n\t\tsr, err := globalDNSConfig.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\treturn toJSONError(ctx, BucketNotFound{\n\t\t\t\t\tBucket: args.BucketName,\n\t\t\t\t}, args.BucketName)\n\t\t\t}\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tcore, rerr := getRemoteInstanceClient(r, getHostFromSrv(sr))\n\t\tif rerr != nil {\n\t\t\treturn toJSONError(ctx, rerr, args.BucketName)\n\t\t}\n\t\tvar policyStr string\n\t\t// Use the abstracted API instead of core, such that\n\t\t// NoSuchBucketPolicy errors are automatically handled.\n\t\tpolicyStr, err = core.Client.GetBucketPolicy(ctx, args.BucketName)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t\tvar policyInfo = &miniogopolicy.BucketAccessPolicy{Version: \"2012-10-17\"}\n\t\tif policyStr != \"\" {\n\t\t\tif err = json.Unmarshal([]byte(policyStr), policyInfo); err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\n\t\tpolicyInfo.Statements = miniogopolicy.SetPolicy(policyInfo.Statements, policyType, args.BucketName, args.Prefix)\n\t\tif len(policyInfo.Statements) == 0 {\n\t\t\tif err = core.SetBucketPolicy(ctx, args.BucketName, \"\"); err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tbucketPolicy, err := BucketAccessPolicyToPolicy(policyInfo)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tpolicyData, err := json.Marshal(bucketPolicy)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tif err = core.SetBucketPolicy(ctx, args.BucketName, string(policyData)); err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t} else {\n\t\tbucketPolicy, err := globalPolicySys.Get(args.BucketName)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(BucketPolicyNotFound); !ok {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\t\t}\n\t\tpolicyInfo, err := PolicyToBucketAccessPolicy(bucketPolicy)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tpolicyInfo.Statements = miniogopolicy.SetPolicy(policyInfo.Statements, policyType, args.BucketName, args.Prefix)\n\t\tif len(policyInfo.Statements) == 0 {\n\t\t\tif err = globalBucketMetadataSys.Update(args.BucketName, bucketPolicyConfig, nil); err != nil {\n\t\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\n\t\tbucketPolicy, err = BucketAccessPolicyToPolicy(policyInfo)\n\t\tif err != nil {\n\t\t\t// This should not happen.\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\tconfigData, err := json.Marshal(bucketPolicy)\n\t\tif err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\n\t\t// Parse validate and save bucket policy.\n\t\tif err = globalBucketMetadataSys.Update(args.BucketName, bucketPolicyConfig, configData); err != nil {\n\t\t\treturn toJSONError(ctx, err, args.BucketName)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// PresignedGetArgs - presigned-get API args.\ntype PresignedGetArgs struct {\n\t// Host header required for signed headers.\n\tHostName string `json:\"host\"`\n\n\t// Bucket name of the object to be presigned.\n\tBucketName string `json:\"bucket\"`\n\n\t// Object name to be presigned.\n\tObjectName string `json:\"object\"`\n\n\t// Expiry in seconds.\n\tExpiry int64 `json:\"expiry\"`\n}\n\n// PresignedGetRep - presigned-get URL reply.\ntype PresignedGetRep struct {\n\tUIVersion string `json:\"uiVersion\"`\n\t// Presigned URL of the object.\n\tURL string `json:\"url\"`\n}\n\n// PresignedGET - returns presigned-Get url.\nfunc (web *webAPIHandlers) PresignedGet(r *http.Request, args *PresignedGetArgs, reply *PresignedGetRep) error {\n\tctx := newWebContext(r, args, \"WebPresignedGet\")\n\tclaims, owner, authErr := webRequestAuthenticate(r)\n\tif authErr != nil {\n\t\treturn toJSONError(ctx, authErr)\n\t}\n\tvar creds auth.Credentials\n\tif !owner {\n\t\tvar ok bool\n\t\tcreds, ok = globalIAMSys.GetUser(claims.AccessKey)\n\t\tif !ok {\n\t\t\treturn toJSONError(ctx, errInvalidAccessKeyID)\n\t\t}\n\t} else {\n\t\tcreds = globalActiveCred\n\t}\n\n\tregion := globalServerRegion\n\tif args.BucketName == \"\" || args.ObjectName == \"\" {\n\t\treturn &json2.Error{\n\t\t\tMessage: \"Bucket and Object are mandatory arguments.\",\n\t\t}\n\t}\n\n\t// Check if bucket is a reserved bucket name or invalid.\n\tif isReservedOrInvalidBucket(args.BucketName, false) {\n\t\treturn toJSONError(ctx, errInvalidBucketName, args.BucketName)\n\t}\n\n\t// Check if the user indeed has GetObject access,\n\t// if not we do not need to generate presigned URLs\n\tif !globalIAMSys.IsAllowed(iampolicy.Args{\n\t\tAccountName:     claims.AccessKey,\n\t\tAction:          iampolicy.GetObjectAction,\n\t\tBucketName:      args.BucketName,\n\t\tConditionValues: getConditionValues(r, \"\", claims.AccessKey, claims.Map()),\n\t\tIsOwner:         owner,\n\t\tObjectName:      args.ObjectName,\n\t\tClaims:          claims.Map(),\n\t}) {\n\t\treturn toJSONError(ctx, errPresignedNotAllowed)\n\t}\n\n\treply.UIVersion = browser.UIVersion\n\treply.URL = presignedGet(args.HostName, args.BucketName, args.ObjectName, args.Expiry, creds, region)\n\treturn nil\n}\n\n// Returns presigned url for GET method.\nfunc presignedGet(host, bucket, object string, expiry int64, creds auth.Credentials, region string) string {\n\taccessKey := creds.AccessKey\n\tsecretKey := creds.SecretKey\n\tsessionToken := creds.SessionToken\n\n\tdate := UTCNow()\n\tdateStr := date.Format(iso8601Format)\n\tcredential := fmt.Sprintf(\"%s/%s\", accessKey, getScope(date, region))\n\n\tvar expiryStr = \"604800\" // Default set to be expire in 7days.\n\tif expiry < 604800 && expiry > 0 {\n\t\texpiryStr = strconv.FormatInt(expiry, 10)\n\t}\n\n\tquery := url.Values{}\n\tquery.Set(xhttp.AmzAlgorithm, signV4Algorithm)\n\tquery.Set(xhttp.AmzCredential, credential)\n\tquery.Set(xhttp.AmzDate, dateStr)\n\tquery.Set(xhttp.AmzExpires, expiryStr)\n\t// Set session token if available.\n\tif sessionToken != \"\" {\n\t\tquery.Set(xhttp.AmzSecurityToken, sessionToken)\n\t}\n\tquery.Set(xhttp.AmzSignedHeaders, \"host\")\n\tqueryStr := s3utils.QueryEncode(query)\n\n\tpath := SlashSeparator + path.Join(bucket, object)\n\n\t// \"host\" is the only header required to be signed for Presigned URLs.\n\textractedSignedHeaders := make(http.Header)\n\textractedSignedHeaders.Set(\"host\", host)\n\tcanonicalRequest := getCanonicalRequest(extractedSignedHeaders, unsignedPayload, queryStr, path, http.MethodGet)\n\tstringToSign := getStringToSign(canonicalRequest, date, getScope(date, region))\n\tsigningKey := getSigningKey(secretKey, date, region, serviceS3)\n\tsignature := getSignature(signingKey, stringToSign)\n\n\treturn host + s3utils.EncodePath(path) + \"?\" + queryStr + \"&\" + xhttp.AmzSignature + \"=\" + signature\n}\n\n// DiscoveryDocResp - OpenID discovery document reply.\ntype DiscoveryDocResp struct {\n\tDiscoveryDoc openid.DiscoveryDoc\n\tUIVersion    string `json:\"uiVersion\"`\n\tClientID     string `json:\"clientId\"`\n}\n\n// GetDiscoveryDoc - returns parsed value of OpenID discovery document\nfunc (web *webAPIHandlers) GetDiscoveryDoc(r *http.Request, args *WebGenericArgs, reply *DiscoveryDocResp) error {\n\tif globalOpenIDConfig.DiscoveryDoc.AuthEndpoint != \"\" {\n\t\treply.DiscoveryDoc = globalOpenIDConfig.DiscoveryDoc\n\t\treply.ClientID = globalOpenIDConfig.ClientID\n\t}\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// LoginSTSArgs - login arguments.\ntype LoginSTSArgs struct {\n\tToken string `json:\"token\" form:\"token\"`\n}\n\nvar errSTSNotInitialized = errors.New(\"STS API not initialized, please configure STS support\")\n\n// LoginSTS - STS user login handler.\nfunc (web *webAPIHandlers) LoginSTS(r *http.Request, args *LoginSTSArgs, reply *LoginRep) error {\n\tctx := newWebContext(r, args, \"WebLoginSTS\")\n\n\tif globalOpenIDValidators == nil {\n\t\treturn toJSONError(ctx, errSTSNotInitialized)\n\t}\n\n\tv, err := globalOpenIDValidators.Get(\"jwt\")\n\tif err != nil {\n\t\tlogger.LogIf(ctx, err)\n\t\treturn toJSONError(ctx, errSTSNotInitialized)\n\t}\n\n\tm, err := v.Validate(args.Token, \"\")\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\t// JWT has requested a custom claim with policy value set.\n\t// This is a MinIO STS API specific value, this value should\n\t// be set and configured on your identity provider as part of\n\t// JWT custom claims.\n\tvar policyName string\n\tpolicySet, ok := iampolicy.GetPoliciesFromClaims(m, iamPolicyClaimNameOpenID())\n\tif ok {\n\t\tpolicyName = globalIAMSys.CurrentPolicies(strings.Join(policySet.ToSlice(), \",\"))\n\t}\n\tif policyName == \"\" && globalPolicyOPA == nil {\n\t\treturn toJSONError(ctx, fmt.Errorf(\"%s claim missing from the JWT token, credentials will not be generated\", iamPolicyClaimNameOpenID()))\n\t}\n\tm[iamPolicyClaimNameOpenID()] = policyName\n\n\tsecret := globalActiveCred.SecretKey\n\tcred, err := auth.GetNewCredentialsWithMetadata(m, secret)\n\tif err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\t// Set the newly generated credentials.\n\tif err = globalIAMSys.SetTempUser(cred.AccessKey, cred, policyName); err != nil {\n\t\treturn toJSONError(ctx, err)\n\t}\n\n\t// Notify all other MinIO peers to reload temp users\n\tfor _, nerr := range globalNotificationSys.LoadUser(cred.AccessKey, true) {\n\t\tif nerr.Err != nil {\n\t\t\tlogger.GetReqInfo(ctx).SetTags(\"peerAddress\", nerr.Host.String())\n\t\t\tlogger.LogIf(ctx, nerr.Err)\n\t\t}\n\t}\n\n\treply.Token = cred.SessionToken\n\treply.UIVersion = browser.UIVersion\n\treturn nil\n}\n\n// toJSONError converts regular errors into more user friendly\n// and consumable error message for the browser UI.\nfunc toJSONError(ctx context.Context, err error, params ...string) (jerr *json2.Error) {\n\tapiErr := toWebAPIError(ctx, err)\n\tjerr = &json2.Error{\n\t\tMessage: apiErr.Description,\n\t}\n\tswitch apiErr.Code {\n\t// Reserved bucket name provided.\n\tcase \"AllAccessDisabled\":\n\t\tif len(params) > 0 {\n\t\t\tjerr = &json2.Error{\n\t\t\t\tMessage: fmt.Sprintf(\"All access to this bucket %s has been disabled.\", params[0]),\n\t\t\t}\n\t\t}\n\t// Bucket name invalid with custom error message.\n\tcase \"InvalidBucketName\":\n\t\tif len(params) > 0 {\n\t\t\tjerr = &json2.Error{\n\t\t\t\tMessage: fmt.Sprintf(\"Bucket Name %s is invalid. Lowercase letters, period, hyphen, numerals are the only allowed characters and should be minimum 3 characters in length.\", params[0]),\n\t\t\t}\n\t\t}\n\t// Bucket not found custom error message.\n\tcase \"NoSuchBucket\":\n\t\tif len(params) > 0 {\n\t\t\tjerr = &json2.Error{\n\t\t\t\tMessage: fmt.Sprintf(\"The specified bucket %s does not exist.\", params[0]),\n\t\t\t}\n\t\t}\n\t// Object not found custom error message.\n\tcase \"NoSuchKey\":\n\t\tif len(params) > 1 {\n\t\t\tjerr = &json2.Error{\n\t\t\t\tMessage: fmt.Sprintf(\"The specified key %s does not exist\", params[1]),\n\t\t\t}\n\t\t}\n\t\t// Add more custom error messages here with more context.\n\t}\n\treturn jerr\n}\n\n// toWebAPIError - convert into error into APIError.\nfunc toWebAPIError(ctx context.Context, err error) APIError {\n\tswitch err {\n\tcase errNoAuthToken:\n\t\treturn APIError{\n\t\t\tCode:           \"WebTokenMissing\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errSTSNotInitialized:\n\t\treturn APIError(stsErrCodes.ToSTSErr(ErrSTSNotInitialized))\n\tcase errServerNotInitialized:\n\t\treturn APIError{\n\t\t\tCode:           \"XMinioServerNotInitialized\",\n\t\t\tHTTPStatusCode: http.StatusServiceUnavailable,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errAuthentication, auth.ErrInvalidAccessKeyLength,\n\t\tauth.ErrInvalidSecretKeyLength, errInvalidAccessKeyID, errAccessDenied, errLockedObject:\n\t\treturn APIError{\n\t\t\tCode:           \"AccessDenied\",\n\t\t\tHTTPStatusCode: http.StatusForbidden,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errSizeUnspecified:\n\t\treturn APIError{\n\t\t\tCode:           \"InvalidRequest\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errChangeCredNotAllowed:\n\t\treturn APIError{\n\t\t\tCode:           \"MethodNotAllowed\",\n\t\t\tHTTPStatusCode: http.StatusMethodNotAllowed,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errInvalidBucketName:\n\t\treturn APIError{\n\t\t\tCode:           \"InvalidBucketName\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errInvalidArgument:\n\t\treturn APIError{\n\t\t\tCode:           \"InvalidArgument\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    err.Error(),\n\t\t}\n\tcase errEncryptedObject:\n\t\treturn getAPIError(ErrSSEEncryptedObject)\n\tcase errInvalidEncryptionParameters:\n\t\treturn getAPIError(ErrInvalidEncryptionParameters)\n\tcase errObjectTampered:\n\t\treturn getAPIError(ErrObjectTampered)\n\tcase errMethodNotAllowed:\n\t\treturn getAPIError(ErrMethodNotAllowed)\n\t}\n\n\t// Convert error type to api error code.\n\tswitch err.(type) {\n\tcase StorageFull:\n\t\treturn getAPIError(ErrStorageFull)\n\tcase BucketQuotaExceeded:\n\t\treturn getAPIError(ErrAdminBucketQuotaExceeded)\n\tcase BucketNotFound:\n\t\treturn getAPIError(ErrNoSuchBucket)\n\tcase BucketNotEmpty:\n\t\treturn getAPIError(ErrBucketNotEmpty)\n\tcase BucketExists:\n\t\treturn getAPIError(ErrBucketAlreadyOwnedByYou)\n\tcase BucketNameInvalid:\n\t\treturn getAPIError(ErrInvalidBucketName)\n\tcase hash.BadDigest:\n\t\treturn getAPIError(ErrBadDigest)\n\tcase IncompleteBody:\n\t\treturn getAPIError(ErrIncompleteBody)\n\tcase ObjectExistsAsDirectory:\n\t\treturn getAPIError(ErrObjectExistsAsDirectory)\n\tcase ObjectNotFound:\n\t\treturn getAPIError(ErrNoSuchKey)\n\tcase ObjectNameInvalid:\n\t\treturn getAPIError(ErrNoSuchKey)\n\tcase InsufficientWriteQuorum:\n\t\treturn getAPIError(ErrWriteQuorum)\n\tcase InsufficientReadQuorum:\n\t\treturn getAPIError(ErrReadQuorum)\n\tcase NotImplemented:\n\t\treturn APIError{\n\t\t\tCode:           \"NotImplemented\",\n\t\t\tHTTPStatusCode: http.StatusBadRequest,\n\t\t\tDescription:    \"Functionality not implemented\",\n\t\t}\n\t}\n\n\t// Log unexpected and unhandled errors.\n\tlogger.LogIf(ctx, err)\n\treturn toAPIError(ctx, err)\n}\n\n// writeWebErrorResponse - set HTTP status code and write error description to the body.\nfunc writeWebErrorResponse(w http.ResponseWriter, err error) {\n\treqInfo := &logger.ReqInfo{\n\t\tDeploymentID: globalDeploymentID,\n\t}\n\tctx := logger.SetReqInfo(GlobalContext, reqInfo)\n\tapiErr := toWebAPIError(ctx, err)\n\tw.WriteHeader(apiErr.HTTPStatusCode)\n\tw.Write([]byte(apiErr.Description))\n}\n"], "filenames": ["cmd/api-errors.go", "cmd/web-handlers.go"], "buggy_code_start_loc": [2127, 23], "buggy_code_end_loc": [2127, 2306], "fixing_code_start_loc": [2128, 22], "fixing_code_end_loc": [2134, 2315], "type": "CWE-918", "message": "MinIO is a High Performance Object Storage released under Apache License v2.0. In MinIO before version RELEASE.2021-01-30T00-20-58Z there is a server-side request forgery vulnerability. The target application may have functionality for importing data from a URL, publishing data to a URL, or otherwise reading data from a URL that can be tampered with. The attacker modifies the calls to this functionality by supplying a completely different URL or by manipulating how URLs are built (path traversal etc.). In a Server-Side Request Forgery (SSRF) attack, the attacker can abuse functionality on the server to read or update internal resources. The attacker can supply or modify a URL which the code running on the server will read or submit data, and by carefully selecting the URLs, the attacker may be able to read server configuration such as AWS metadata, connect to internal services like HTTP enabled databases, or perform post requests towards internal services which are not intended to be exposed. This is fixed in version RELEASE.2021-01-30T00-20-58Z, all users are advised to upgrade. As a workaround you can disable the browser front-end with \"MINIO_BROWSER=off\" environment variable.", "other": {"cve": {"id": "CVE-2021-21287", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-01T18:15:13.890", "lastModified": "2021-02-05T20:44:53.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MinIO is a High Performance Object Storage released under Apache License v2.0. In MinIO before version RELEASE.2021-01-30T00-20-58Z there is a server-side request forgery vulnerability. The target application may have functionality for importing data from a URL, publishing data to a URL, or otherwise reading data from a URL that can be tampered with. The attacker modifies the calls to this functionality by supplying a completely different URL or by manipulating how URLs are built (path traversal etc.). In a Server-Side Request Forgery (SSRF) attack, the attacker can abuse functionality on the server to read or update internal resources. The attacker can supply or modify a URL which the code running on the server will read or submit data, and by carefully selecting the URLs, the attacker may be able to read server configuration such as AWS metadata, connect to internal services like HTTP enabled databases, or perform post requests towards internal services which are not intended to be exposed. This is fixed in version RELEASE.2021-01-30T00-20-58Z, all users are advised to upgrade. As a workaround you can disable the browser front-end with \"MINIO_BROWSER=off\" environment variable."}, {"lang": "es", "value": "MinIO es un Almacenamiento de Objetos de Alto Rendimiento publicado bajo la licencia Apache versi\u00f3n v2.0.&#xa0;En MinIO anterior a la versi\u00f3n RELEASE.2021-01-30T00-20-58Z, se presenta una vulnerabilidad de tipo server-side request forgery.&#xa0;La aplicaci\u00f3n objetivo puede tener una funcionalidad para importar datos de una URL, publicar datos en una URL o leer datos de una URL con que puedan ser alterada. El atacante modifica las llamadas a esta funcionalidad proporcionando una URL completamente diferente o al manipular c\u00f3mo se construyen las URL (salto de ruta, etc.).&#xa0;En un ataque de tipo Server-Side Request Forgery (SSRF), el atacante puede abusar de la funcionalidad en el servidor para leer o actualizar recursos internos.&#xa0;El atacante puede proporcionar o modificar una URL que el c\u00f3digo que se ejecuta en el servidor leer\u00e1 o enviar\u00e1 datos, y al seleccionar cuidadosamente las URL, el atacante puede leer la configuraci\u00f3n del servidor, como los metadatos de AWS,&#xa0;conectarse a servicios internos como bases de datos habilitadas para HTTP, o realizar peticiones posteriores a servicios internos que no est\u00e9n destinados a ser expuestos.&#xa0;Esto es corregido en la versi\u00f3n RELEASE.2021-01-30T00-20-58Z, se recomienda a todos los usuarios que actualicen.&#xa0;Como soluci\u00f3n alternativa, puede desactivar la interfaz del navegador con la variable de entorno \"MINIO_BROWSER = off\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-01-30t00-20-58z", "matchCriteriaId": "D3A143A4-A6FC-4BF5-B572-C66FF7D566FA"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/eb6871ecd960d570f70698877209e6db181bf276", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/pull/11337", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/releases/tag/RELEASE.2021-01-30T00-20-58Z", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-m4qq-5f7c-693q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/eb6871ecd960d570f70698877209e6db181bf276"}}