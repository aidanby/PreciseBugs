{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP6 Planar Codec\n *\n * Copyright 2013 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <freerdp/config.h>\n\n#include <winpr/crt.h>\n#include <winpr/assert.h>\n#include <winpr/print.h>\n\n#include <freerdp/primitives.h>\n#include <freerdp/log.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/codec/planar.h>\n\n#define TAG FREERDP_TAG(\"codec\")\n\n#define PLANAR_ALIGN(val, align) \\\n\t((val) % (align) == 0) ? (val) : ((val) + (align) - (val) % (align))\n\ntypedef struct\n{\n\t/**\n\t * controlByte:\n\t * [0-3]: nRunLength\n\t * [4-7]: cRawBytes\n\t */\n\tBYTE controlByte;\n\tBYTE* rawValues;\n} RDP6_RLE_SEGMENT;\n\ntypedef struct\n{\n\tUINT32 cSegments;\n\tRDP6_RLE_SEGMENT* segments;\n} RDP6_RLE_SEGMENTS;\n\ntypedef struct\n{\n\t/**\n\t * formatHeader:\n\t * [0-2]: Color Loss Level (CLL)\n\t *  [3] : Chroma Subsampling (CS)\n\t *  [4] : Run Length Encoding (RLE)\n\t *  [5] : No Alpha (NA)\n\t * [6-7]: Reserved\n\t */\n\tBYTE formatHeader;\n} RDP6_BITMAP_STREAM;\n\nstruct S_BITMAP_PLANAR_CONTEXT\n{\n\tUINT32 maxWidth;\n\tUINT32 maxHeight;\n\tUINT32 maxPlaneSize;\n\n\tBOOL AllowSkipAlpha;\n\tBOOL AllowRunLengthEncoding;\n\tBOOL AllowColorSubsampling;\n\tBOOL AllowDynamicColorFidelity;\n\n\tUINT32 ColorLossLevel;\n\n\tBYTE* planes[4];\n\tBYTE* planesBuffer;\n\n\tBYTE* deltaPlanes[4];\n\tBYTE* deltaPlanesBuffer;\n\n\tBYTE* rlePlanes[4];\n\tBYTE* rlePlanesBuffer;\n\n\tBYTE* pTempData;\n\tUINT32 nTempStep;\n\n\tBOOL bgr;\n\tBOOL topdown;\n};\n\nstatic INLINE UINT32 planar_invert_format(BITMAP_PLANAR_CONTEXT* planar, BOOL alpha,\n                                          UINT32 DstFormat)\n{\n\n\tif (planar->bgr && alpha)\n\t{\n\t\tswitch (DstFormat)\n\t\t{\n\t\t\tcase PIXEL_FORMAT_ARGB32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_ABGR32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_XRGB32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_XBGR32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_ABGR32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_ARGB32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_XBGR32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_XRGB32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGBA32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGBX32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGBA32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGRA32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGBX32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGRX32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGB24:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGR24;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGR24:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGB24;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGB16:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGR16;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGR16:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGB16;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_ARGB15:\n\t\t\t\tDstFormat = PIXEL_FORMAT_ABGR15;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGB15:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGR15;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_ABGR15:\n\t\t\t\tDstFormat = PIXEL_FORMAT_ARGB15;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGR15:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGB15;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn DstFormat;\n}\n\nstatic INLINE BOOL freerdp_bitmap_planar_compress_plane_rle(const BYTE* plane, UINT32 width,\n                                                            UINT32 height, BYTE* outPlane,\n                                                            UINT32* dstSize);\nstatic INLINE BYTE* freerdp_bitmap_planar_delta_encode_plane(const BYTE* inPlane, UINT32 width,\n                                                             UINT32 height, BYTE* outPlane);\n\nstatic INLINE INT32 planar_skip_plane_rle(const BYTE* pSrcData, UINT32 SrcSize, UINT32 nWidth,\n                                          UINT32 nHeight)\n{\n\tUINT32 used = 0;\n\tUINT32 x, y;\n\tBYTE controlByte;\n\n\tWINPR_ASSERT(pSrcData);\n\n\tfor (y = 0; y < nHeight; y++)\n\t{\n\t\tfor (x = 0; x < nWidth;)\n\t\t{\n\t\t\tint cRawBytes;\n\t\t\tint nRunLength;\n\n\t\t\tif (used >= SrcSize)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar plane used %\" PRIu32 \" exceeds SrcSize %\" PRIu32, used,\n\t\t\t\t         SrcSize);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcontrolByte = pSrcData[used++];\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\n\t\t\tused += cRawBytes;\n\t\t\tx += cRawBytes;\n\t\t\tx += nRunLength;\n\n\t\t\tif (x > nWidth)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar plane x %\" PRIu32 \" exceeds width %\" PRIu32, x, nWidth);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (used > SrcSize)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar plane used %\" PRIu32 \" exceeds SrcSize %\" PRIu32, used,\n\t\t\t\t         INT32_MAX);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (used > INT32_MAX)\n\t{\n\t\tWLog_ERR(TAG, \"planar plane used %\" PRIu32 \" exceeds SrcSize %\" PRIu32, used, SrcSize);\n\t\treturn -1;\n\t}\n\treturn (INT32)used;\n}\n\nstatic INLINE INT32 planar_decompress_plane_rle_only(const BYTE* pSrcData, UINT32 SrcSize,\n                                                     BYTE* pDstData, UINT32 nWidth, UINT32 nHeight)\n{\n\tINT32 x, y;\n\tUINT32 pixel;\n\tUINT32 cRawBytes;\n\tUINT32 nRunLength;\n\tINT32 deltaValue;\n\tBYTE controlByte;\n\tBYTE* currentScanline;\n\tBYTE* previousScanline;\n\tconst BYTE* srcp = pSrcData;\n\n\tWINPR_ASSERT(nHeight <= INT32_MAX);\n\tWINPR_ASSERT(nWidth <= INT32_MAX);\n\n\tpreviousScanline = NULL;\n\n\tfor (y = 0; y < (INT32)nHeight; y++)\n\t{\n\t\tBYTE* dstp = &pDstData[((y) * (INT32)nWidth)];\n\t\tpixel = 0;\n\t\tcurrentScanline = dstp;\n\n\t\tfor (x = 0; x < (INT32)nWidth;)\n\t\t{\n\t\t\tcontrolByte = *srcp;\n\t\t\tsrcp++;\n\n\t\t\tif ((srcp - pSrcData) > SrcSize * 1ll)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"error reading input buffer\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\n\t\t\tif (((dstp + (cRawBytes + nRunLength)) - currentScanline) > nWidth * 1ll)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"too many pixels in scanline\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!previousScanline)\n\t\t\t{\n\t\t\t\t/* first scanline, absolute values */\n\t\t\t\twhile (cRawBytes > 0)\n\t\t\t\t{\n\t\t\t\t\tpixel = *srcp;\n\t\t\t\t\tsrcp++;\n\t\t\t\t\t*dstp = pixel;\n\t\t\t\t\tdstp++;\n\t\t\t\t\tx++;\n\t\t\t\t\tcRawBytes--;\n\t\t\t\t}\n\n\t\t\t\twhile (nRunLength > 0)\n\t\t\t\t{\n\t\t\t\t\t*dstp = pixel;\n\t\t\t\t\tdstp++;\n\t\t\t\t\tx++;\n\t\t\t\t\tnRunLength--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* delta values relative to previous scanline */\n\t\t\t\twhile (cRawBytes > 0)\n\t\t\t\t{\n\t\t\t\t\tdeltaValue = *srcp;\n\t\t\t\t\tsrcp++;\n\n\t\t\t\t\tif (deltaValue & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeltaValue = deltaValue >> 1;\n\t\t\t\t\t\tdeltaValue = deltaValue + 1;\n\t\t\t\t\t\tpixel = -deltaValue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdeltaValue = deltaValue >> 1;\n\t\t\t\t\t\tpixel = deltaValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdeltaValue = previousScanline[x] + pixel;\n\t\t\t\t\t*dstp = deltaValue;\n\t\t\t\t\tdstp++;\n\t\t\t\t\tx++;\n\t\t\t\t\tcRawBytes--;\n\t\t\t\t}\n\n\t\t\t\twhile (nRunLength > 0)\n\t\t\t\t{\n\t\t\t\t\tdeltaValue = previousScanline[x] + pixel;\n\t\t\t\t\t*dstp = deltaValue;\n\t\t\t\t\tdstp++;\n\t\t\t\t\tx++;\n\t\t\t\t\tnRunLength--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpreviousScanline = currentScanline;\n\t}\n\n\treturn (INT32)(srcp - pSrcData);\n}\n\nstatic INLINE INT32 planar_decompress_plane_rle(const BYTE* pSrcData, UINT32 SrcSize,\n                                                BYTE* pDstData, INT32 nDstStep, UINT32 nXDst,\n                                                UINT32 nYDst, UINT32 nWidth, UINT32 nHeight,\n                                                UINT32 nChannel, BOOL vFlip)\n{\n\tINT32 x, y;\n\tUINT32 pixel;\n\tUINT32 cRawBytes;\n\tUINT32 nRunLength;\n\tINT32 deltaValue;\n\tINT32 beg, end, inc;\n\tBYTE controlByte;\n\tBYTE* currentScanline;\n\tBYTE* previousScanline;\n\tconst BYTE* srcp = pSrcData;\n\n\tWINPR_ASSERT(nHeight <= INT32_MAX);\n\tWINPR_ASSERT(nWidth <= INT32_MAX);\n\tWINPR_ASSERT(nDstStep <= INT32_MAX);\n\n\tpreviousScanline = NULL;\n\n\tif (vFlip)\n\t{\n\t\tbeg = (INT32)nHeight - 1;\n\t\tend = -1;\n\t\tinc = -1;\n\t}\n\telse\n\t{\n\t\tbeg = 0;\n\t\tend = (INT32)nHeight;\n\t\tinc = 1;\n\t}\n\n\tfor (y = beg; y != end; y += inc)\n\t{\n\t\tBYTE* dstp = &pDstData[((nYDst + y) * (INT32)nDstStep) + (nXDst * 4) + nChannel];\n\t\tpixel = 0;\n\t\tcurrentScanline = dstp;\n\n\t\tfor (x = 0; x < (INT32)nWidth;)\n\t\t{\n\t\t\tcontrolByte = *srcp;\n\t\t\tsrcp++;\n\n\t\t\tif ((srcp - pSrcData) > SrcSize * 1ll)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"error reading input buffer\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\n\t\t\tif (((dstp + (cRawBytes + nRunLength)) - currentScanline) > nWidth * 4ll)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"too many pixels in scanline\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!previousScanline)\n\t\t\t{\n\t\t\t\t/* first scanline, absolute values */\n\t\t\t\twhile (cRawBytes > 0)\n\t\t\t\t{\n\t\t\t\t\tpixel = *srcp;\n\t\t\t\t\tsrcp++;\n\t\t\t\t\t*dstp = pixel;\n\t\t\t\t\tdstp += 4;\n\t\t\t\t\tx++;\n\t\t\t\t\tcRawBytes--;\n\t\t\t\t}\n\n\t\t\t\twhile (nRunLength > 0)\n\t\t\t\t{\n\t\t\t\t\t*dstp = pixel;\n\t\t\t\t\tdstp += 4;\n\t\t\t\t\tx++;\n\t\t\t\t\tnRunLength--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* delta values relative to previous scanline */\n\t\t\t\twhile (cRawBytes > 0)\n\t\t\t\t{\n\t\t\t\t\tdeltaValue = *srcp;\n\t\t\t\t\tsrcp++;\n\n\t\t\t\t\tif (deltaValue & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeltaValue = deltaValue >> 1;\n\t\t\t\t\t\tdeltaValue = deltaValue + 1;\n\t\t\t\t\t\tpixel = -deltaValue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdeltaValue = deltaValue >> 1;\n\t\t\t\t\t\tpixel = deltaValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdeltaValue = previousScanline[x * 4] + pixel;\n\t\t\t\t\t*dstp = deltaValue;\n\t\t\t\t\tdstp += 4;\n\t\t\t\t\tx++;\n\t\t\t\t\tcRawBytes--;\n\t\t\t\t}\n\n\t\t\t\twhile (nRunLength > 0)\n\t\t\t\t{\n\t\t\t\t\tdeltaValue = previousScanline[x * 4] + pixel;\n\t\t\t\t\t*dstp = deltaValue;\n\t\t\t\t\tdstp += 4;\n\t\t\t\t\tx++;\n\t\t\t\t\tnRunLength--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpreviousScanline = currentScanline;\n\t}\n\n\treturn (INT32)(srcp - pSrcData);\n}\n\nstatic INLINE INT32 planar_set_plane(BYTE bValue, BYTE* pDstData, INT32 nDstStep, UINT32 nXDst,\n                                     UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, UINT32 nChannel,\n                                     BOOL vFlip)\n{\n\tINT32 x, y;\n\tINT32 beg, end, inc;\n\n\tWINPR_ASSERT(nHeight <= INT32_MAX);\n\tWINPR_ASSERT(nWidth <= INT32_MAX);\n\tWINPR_ASSERT(nDstStep <= INT32_MAX);\n\n\tif (vFlip)\n\t{\n\t\tbeg = (INT32)nHeight - 1;\n\t\tend = -1;\n\t\tinc = -1;\n\t}\n\telse\n\t{\n\t\tbeg = 0;\n\t\tend = (INT32)nHeight;\n\t\tinc = 1;\n\t}\n\n\tfor (y = beg; y != end; y += inc)\n\t{\n\t\tBYTE* dstp = &pDstData[((nYDst + y) * (INT32)nDstStep) + (nXDst * 4) + nChannel];\n\n\t\tfor (x = 0; x < (INT32)nWidth; ++x)\n\t\t{\n\t\t\t*dstp = bValue;\n\t\t\tdstp += 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic INLINE BOOL writeLine(BYTE** ppRgba, UINT32 DstFormat, UINT32 width, const BYTE** ppR,\n                             const BYTE** ppG, const BYTE** ppB, const BYTE** ppA)\n{\n\tUINT32 x;\n\n\tWINPR_ASSERT(ppRgba);\n\tWINPR_ASSERT(ppR);\n\tWINPR_ASSERT(ppG);\n\tWINPR_ASSERT(ppB);\n\n\tswitch (DstFormat)\n\t{\n\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\tfor (x = 0; x < width; x++)\n\t\t\t{\n\t\t\t\t*(*ppRgba)++ = *(*ppB)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppG)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppR)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppA)++;\n\t\t\t}\n\n\t\t\treturn TRUE;\n\n\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\tfor (x = 0; x < width; x++)\n\t\t\t{\n\t\t\t\t*(*ppRgba)++ = *(*ppB)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppG)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppR)++;\n\t\t\t\t*(*ppRgba)++ = 0xFF;\n\t\t\t}\n\n\t\t\treturn TRUE;\n\n\t\tdefault:\n\t\t\tif (ppA)\n\t\t\t{\n\t\t\t\tfor (x = 0; x < width; x++)\n\t\t\t\t{\n\t\t\t\t\tBYTE alpha = *(*ppA)++;\n\t\t\t\t\tUINT32 color =\n\t\t\t\t\t    FreeRDPGetColor(DstFormat, *(*ppR)++, *(*ppG)++, *(*ppB)++, alpha);\n\t\t\t\t\tFreeRDPWriteColor(*ppRgba, DstFormat, color);\n\t\t\t\t\t*ppRgba += FreeRDPGetBytesPerPixel(DstFormat);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst BYTE alpha = 0xFF;\n\n\t\t\t\tfor (x = 0; x < width; x++)\n\t\t\t\t{\n\t\t\t\t\tUINT32 color =\n\t\t\t\t\t    FreeRDPGetColor(DstFormat, *(*ppR)++, *(*ppG)++, *(*ppB)++, alpha);\n\t\t\t\t\tFreeRDPWriteColor(*ppRgba, DstFormat, color);\n\t\t\t\t\t*ppRgba += FreeRDPGetBytesPerPixel(DstFormat);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn TRUE;\n\t}\n}\n\nstatic INLINE BOOL planar_decompress_planes_raw(const BYTE* pSrcData[4], BYTE* pDstData,\n                                                UINT32 DstFormat, UINT32 nDstStep, UINT32 nXDst,\n                                                UINT32 nYDst, UINT32 nWidth, UINT32 nHeight,\n                                                BOOL vFlip, UINT32 totalHeight)\n{\n\tINT32 y;\n\tINT32 beg, end, inc;\n\tconst BYTE* pR = pSrcData[0];\n\tconst BYTE* pG = pSrcData[1];\n\tconst BYTE* pB = pSrcData[2];\n\tconst BYTE* pA = pSrcData[3];\n\tconst UINT32 bpp = FreeRDPGetBytesPerPixel(DstFormat);\n\n\tif (vFlip)\n\t{\n\t\tbeg = nHeight - 1;\n\t\tend = -1;\n\t\tinc = -1;\n\t}\n\telse\n\t{\n\t\tbeg = 0;\n\t\tend = nHeight;\n\t\tinc = 1;\n\t}\n\n\tif (nYDst + nHeight > totalHeight)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"planar plane destination Y %\" PRIu32 \" + height %\" PRIu32\n\t\t         \" exceeds totalHeight %\" PRIu32,\n\t\t         nYDst, nHeight, totalHeight);\n\t\treturn FALSE;\n\t}\n\n\tif ((nXDst + nWidth) * bpp > nDstStep)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"planar plane destination (X %\" PRIu32 \" + width %\" PRIu32 \") * bpp %\" PRIu32\n\t\t         \" exceeds stride %\" PRIu32,\n\t\t         nXDst, nWidth, bpp, nDstStep);\n\t\treturn FALSE;\n\t}\n\n\tfor (y = beg; y != end; y += inc)\n\t{\n\t\tBYTE* pRGB;\n\n\t\tif (y > (INT64)nHeight)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"planar plane destination Y %\" PRId32 \" exceeds height %\" PRIu32, y,\n\t\t\t         nHeight);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpRGB = &pDstData[((nYDst + y) * nDstStep) + (nXDst * bpp)];\n\n\t\tif (!writeLine(&pRGB, DstFormat, nWidth, &pR, &pG, &pB, &pA))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL planar_subsample_expand(const BYTE* plane, size_t planeLength, UINT32 nWidth,\n                                    UINT32 nHeight, UINT32 nPlaneWidth, UINT32 nPlaneHeight,\n                                    BYTE* deltaPlane)\n{\n\tsize_t pos = 0;\n\tUINT32 y;\n\tWINPR_UNUSED(planeLength);\n\n\tWINPR_ASSERT(plane);\n\tWINPR_ASSERT(deltaPlane);\n\n\tif (nWidth > nPlaneWidth * 2)\n\t{\n\t\tWLog_ERR(TAG, \"planar subsample width %\" PRIu32 \" > PlaneWidth %\" PRIu32 \" * 2\", nWidth,\n\t\t         nPlaneWidth);\n\t\treturn FALSE;\n\t}\n\n\tif (nHeight > nPlaneHeight * 2)\n\t{\n\t\tWLog_ERR(TAG, \"planar subsample height %\" PRIu32 \" > PlaneHeight %\" PRIu32 \" * 2\", nHeight,\n\t\t         nPlaneHeight);\n\t\treturn FALSE;\n\t}\n\n\tfor (y = 0; y < nHeight; y++)\n\t{\n\t\tconst BYTE* src = plane + y / 2 * nPlaneWidth;\n\t\tUINT32 x;\n\n\t\tfor (x = 0; x < nWidth; x++)\n\t\t{\n\t\t\tdeltaPlane[pos++] = src[x / 2];\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL planar_decompress(BITMAP_PLANAR_CONTEXT* planar, const BYTE* pSrcData, UINT32 SrcSize,\n                       UINT32 nSrcWidth, UINT32 nSrcHeight, BYTE* pDstData, UINT32 DstFormat,\n                       UINT32 nDstStep, UINT32 nXDst, UINT32 nYDst, UINT32 nDstWidth,\n                       UINT32 nDstHeight, BOOL vFlip)\n{\n\tBOOL cs;\n\tBOOL rle;\n\tUINT32 cll;\n\tBOOL alpha;\n\tBOOL useAlpha = FALSE;\n\tINT32 status;\n\tconst BYTE* srcp;\n\tUINT32 subSize;\n\tUINT32 subWidth;\n\tUINT32 subHeight;\n\tUINT32 planeSize;\n\tINT32 rleSizes[4] = { 0, 0, 0, 0 };\n\tUINT32 rawSizes[4];\n\tUINT32 rawWidths[4];\n\tUINT32 rawHeights[4];\n\tBYTE FormatHeader;\n\tconst BYTE* planes[4] = { 0 };\n\tconst UINT32 w = MIN(nSrcWidth, nDstWidth);\n\tconst UINT32 h = MIN(nSrcHeight, nDstHeight);\n\tconst primitives_t* prims = primitives_get();\n\n\tWINPR_ASSERT(planar);\n\tWINPR_ASSERT(prims);\n\n\tif (nDstStep <= 0)\n\t\tnDstStep = nDstWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\n\tsrcp = pSrcData;\n\n\tif (!pSrcData)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid argument pSrcData=NULL\");\n\t\treturn FALSE;\n\t}\n\n\tif (!pDstData)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid argument pDstData=NULL\");\n\t\treturn FALSE;\n\t}\n\n\tFormatHeader = *srcp++;\n\tcll = (FormatHeader & PLANAR_FORMAT_HEADER_CLL_MASK);\n\tcs = (FormatHeader & PLANAR_FORMAT_HEADER_CS) ? TRUE : FALSE;\n\trle = (FormatHeader & PLANAR_FORMAT_HEADER_RLE) ? TRUE : FALSE;\n\talpha = (FormatHeader & PLANAR_FORMAT_HEADER_NA) ? FALSE : TRUE;\n\n\tDstFormat = planar_invert_format(planar, alpha, DstFormat);\n\n\tif (alpha)\n\t\tuseAlpha = FreeRDPColorHasAlpha(DstFormat);\n\n\t// WLog_INFO(TAG, \"CLL: %\"PRIu32\" CS: %\"PRIu8\" RLE: %\"PRIu8\" ALPHA: %\"PRIu8\"\", cll, cs, rle,\n\t// alpha);\n\n\tif (!cll && cs)\n\t{\n\t\tWLog_ERR(TAG, \"Chroma subsampling requires YCoCg and does not work with RGB data\");\n\t\treturn FALSE; /* Chroma subsampling requires YCoCg */\n\t}\n\n\tsubWidth = (nSrcWidth / 2) + (nSrcWidth % 2);\n\tsubHeight = (nSrcHeight / 2) + (nSrcHeight % 2);\n\tplaneSize = nSrcWidth * nSrcHeight;\n\tsubSize = subWidth * subHeight;\n\n\tif (!cs)\n\t{\n\t\trawSizes[0] = planeSize; /* LumaOrRedPlane */\n\t\trawWidths[0] = nSrcWidth;\n\t\trawHeights[0] = nSrcHeight;\n\t\trawSizes[1] = planeSize; /* OrangeChromaOrGreenPlane */\n\t\trawWidths[1] = nSrcWidth;\n\t\trawHeights[1] = nSrcHeight;\n\t\trawSizes[2] = planeSize; /* GreenChromaOrBluePlane */\n\t\trawWidths[2] = nSrcWidth;\n\t\trawHeights[2] = nSrcHeight;\n\t\trawSizes[3] = planeSize; /* AlphaPlane */\n\t\trawWidths[3] = nSrcWidth;\n\t\trawHeights[3] = nSrcHeight;\n\t}\n\telse /* Chroma Subsampling */\n\t{\n\t\trawSizes[0] = planeSize; /* LumaOrRedPlane */\n\t\trawWidths[0] = nSrcWidth;\n\t\trawHeights[0] = nSrcHeight;\n\t\trawSizes[1] = subSize; /* OrangeChromaOrGreenPlane */\n\t\trawWidths[1] = subWidth;\n\t\trawHeights[1] = subHeight;\n\t\trawSizes[2] = subSize; /* GreenChromaOrBluePlane */\n\t\trawWidths[2] = subWidth;\n\t\trawHeights[2] = subHeight;\n\t\trawSizes[3] = planeSize; /* AlphaPlane */\n\t\trawWidths[3] = nSrcWidth;\n\t\trawHeights[3] = nSrcHeight;\n\t}\n\n\tif (!rle) /* RAW */\n\t{\n\t\tUINT32 base = planeSize * 3;\n\t\tif (cs)\n\t\t\tbase = planeSize + planeSize / 2;\n\n\t\tif (alpha)\n\t\t{\n\t\t\tif ((SrcSize - (srcp - pSrcData)) < (planeSize + base))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Alpha plane size mismatch %\" PRIu32 \" < %\" PRIu32,\n\t\t\t\t         SrcSize - (srcp - pSrcData), (planeSize + base));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tplanes[3] = srcp;                    /* AlphaPlane */\n\t\t\tplanes[0] = planes[3] + rawSizes[3]; /* LumaOrRedPlane */\n\t\t\tplanes[1] = planes[0] + rawSizes[0]; /* OrangeChromaOrGreenPlane */\n\t\t\tplanes[2] = planes[1] + rawSizes[1]; /* GreenChromaOrBluePlane */\n\n\t\t\tif ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %p + %\" PRIu32 \" > %p\", planes[2], rawSizes[2],\n\t\t\t\t         &pSrcData[SrcSize]);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((SrcSize - (srcp - pSrcData)) < base)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %\" PRIu32 \" < %\" PRIu32,\n\t\t\t\t         SrcSize - (srcp - pSrcData), base);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tplanes[0] = srcp;                    /* LumaOrRedPlane */\n\t\t\tplanes[1] = planes[0] + rawSizes[0]; /* OrangeChromaOrGreenPlane */\n\t\t\tplanes[2] = planes[1] + rawSizes[1]; /* GreenChromaOrBluePlane */\n\n\t\t\tif ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %p + %\" PRIu32 \" > %p\", planes[2], rawSizes[2],\n\t\t\t\t         &pSrcData[SrcSize]);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\telse /* RLE */\n\t{\n\t\tif (alpha)\n\t\t{\n\t\t\tplanes[3] = srcp;\n\t\t\trleSizes[3] = planar_skip_plane_rle(planes[3], SrcSize - (planes[3] - pSrcData),\n\t\t\t                                    rawWidths[3], rawHeights[3]); /* AlphaPlane */\n\n\t\t\tif (rleSizes[3] < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tplanes[0] = planes[3] + rleSizes[3];\n\t\t}\n\t\telse\n\t\t\tplanes[0] = srcp;\n\n\t\trleSizes[0] = planar_skip_plane_rle(planes[0], SrcSize - (planes[0] - pSrcData),\n\t\t                                    rawWidths[0], rawHeights[0]); /* RedPlane */\n\n\t\tif (rleSizes[0] < 0)\n\t\t\treturn FALSE;\n\n\t\tplanes[1] = planes[0] + rleSizes[0];\n\t\trleSizes[1] = planar_skip_plane_rle(planes[1], SrcSize - (planes[1] - pSrcData),\n\t\t                                    rawWidths[1], rawHeights[1]); /* GreenPlane */\n\n\t\tif (rleSizes[1] < 1)\n\t\t\treturn FALSE;\n\n\t\tplanes[2] = planes[1] + rleSizes[1];\n\t\trleSizes[2] = planar_skip_plane_rle(planes[2], SrcSize - (planes[2] - pSrcData),\n\t\t                                    rawWidths[2], rawHeights[2]); /* BluePlane */\n\n\t\tif (rleSizes[2] < 1)\n\t\t\treturn FALSE;\n\t}\n\n\tif (!cll) /* RGB */\n\t{\n\t\tUINT32 TempFormat;\n\t\tBYTE* pTempData = pDstData;\n\t\tUINT32 nTempStep = nDstStep;\n\t\tUINT32 nTotalHeight = nYDst + nDstHeight;\n\n\t\tif (useAlpha)\n\t\t\tTempFormat = PIXEL_FORMAT_BGRA32;\n\t\telse\n\t\t\tTempFormat = PIXEL_FORMAT_BGRX32;\n\n\t\tTempFormat = planar_invert_format(planar, alpha, TempFormat);\n\n\t\tif ((TempFormat != DstFormat) || (nSrcWidth != nDstWidth) || (nSrcHeight != nDstHeight))\n\t\t{\n\t\t\tpTempData = planar->pTempData;\n\t\t\tnTempStep = planar->nTempStep;\n\t\t\tnTotalHeight = planar->maxHeight;\n\t\t}\n\n\t\tif (!rle) /* RAW */\n\t\t{\n\t\t\tif (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,\n\t\t\t                                  nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];\n\t\t\telse /* NoAlpha */\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2];\n\n\t\t\tif ((SrcSize - (srcp - pSrcData)) == 1)\n\t\t\t\tsrcp++; /* pad */\n\t\t}\n\t\telse /* RLE */\n\t\t{\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle(planes[0], rleSizes[0], pTempData, nTempStep, nXDst,\n\t\t\t                                nYDst, nSrcWidth, nSrcHeight, 2, vFlip); /* RedPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus = planar_decompress_plane_rle(planes[1], rleSizes[1], pTempData, nTempStep,\n\t\t\t                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 1,\n\t\t\t                                     vFlip); /* GreenPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle(planes[2], rleSizes[2], pTempData, nTempStep, nXDst,\n\t\t\t                                nYDst, nSrcWidth, nSrcHeight, 0, vFlip); /* BluePlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tsrcp += rleSizes[0] + rleSizes[1] + rleSizes[2];\n\n\t\t\tif (useAlpha)\n\t\t\t{\n\t\t\t\tstatus = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep,\n\t\t\t\t                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 3,\n\t\t\t\t                                     vFlip); /* AlphaPlane */\n\t\t\t}\n\t\t\telse\n\t\t\t\tstatus = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth,\n\t\t\t\t                          nSrcHeight, 3, vFlip);\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rleSizes[3];\n\t\t}\n\n\t\tif (pTempData != pDstData)\n\t\t{\n\t\t\tif (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, w, h, pTempData,\n\t\t\t                        TempFormat, nTempStep, nXDst, nYDst, NULL, FREERDP_FLIP_NONE))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar image copy failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\telse /* YCoCg */\n\t{\n\t\tUINT32 TempFormat;\n\t\tBYTE* pTempData = planar->pTempData;\n\t\tUINT32 nTempStep = planar->nTempStep;\n\t\tUINT32 nTotalHeight = planar->maxHeight;\n\t\tBYTE* dst = &pDstData[nXDst * FreeRDPGetBytesPerPixel(DstFormat) + nYDst * nDstStep];\n\n\t\tif (useAlpha)\n\t\t\tTempFormat = PIXEL_FORMAT_BGRA32;\n\t\telse\n\t\t\tTempFormat = PIXEL_FORMAT_BGRX32;\n\n\t\tif (!pTempData)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (rle) /* RLE encoded data. Decode and handle it like raw data. */\n\t\t{\n\t\t\tBYTE* rleBuffer[4] = { 0 };\n\n\t\t\trleBuffer[3] = planar->rlePlanesBuffer;  /* AlphaPlane */\n\t\t\trleBuffer[0] = rleBuffer[3] + planeSize; /* LumaOrRedPlane */\n\t\t\trleBuffer[1] = rleBuffer[0] + planeSize; /* OrangeChromaOrGreenPlane */\n\t\t\trleBuffer[2] = rleBuffer[1] + planeSize; /* GreenChromaOrBluePlane */\n\t\t\tif (useAlpha)\n\t\t\t{\n\t\t\t\tstatus =\n\t\t\t\t    planar_decompress_plane_rle_only(planes[3], rleSizes[3], rleBuffer[3],\n\t\t\t\t                                     rawWidths[3], rawHeights[3]); /* AlphaPlane */\n\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rleSizes[3];\n\n\t\t\tstatus = planar_decompress_plane_rle_only(planes[0], rleSizes[0], rleBuffer[0],\n\t\t\t                                          rawWidths[0], rawHeights[0]); /* LumaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle_only(planes[1], rleSizes[1], rleBuffer[1], rawWidths[1],\n\t\t\t                                     rawHeights[1]); /* OrangeChromaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle_only(planes[2], rleSizes[2], rleBuffer[2], rawWidths[2],\n\t\t\t                                     rawHeights[2]); /* GreenChromaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tplanes[0] = rleBuffer[0];\n\t\t\tplanes[1] = rleBuffer[1];\n\t\t\tplanes[2] = rleBuffer[2];\n\t\t\tplanes[3] = rleBuffer[3];\n\t\t}\n\n\t\t/* RAW */\n\t\t{\n\t\t\tif (cs)\n\t\t\t{ /* Chroma subsampling for Co and Cg:\n\t\t\t   * Each pixel contains the value that should be expanded to\n\t\t\t   * [2x,2y;2x+1,2y;2x+1,2y+1;2x;2y+1] */\n\t\t\t\tif (!planar_subsample_expand(planes[1], rawSizes[1], nSrcWidth, nSrcHeight,\n\t\t\t\t                             rawWidths[1], rawHeights[1], planar->deltaPlanes[0]))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tplanes[1] = planar->deltaPlanes[0];\n\t\t\t\trawSizes[1] = planeSize; /* OrangeChromaOrGreenPlane */\n\t\t\t\trawWidths[1] = nSrcWidth;\n\t\t\t\trawHeights[1] = nSrcHeight;\n\n\t\t\t\tif (!planar_subsample_expand(planes[2], rawSizes[2], nSrcWidth, nSrcHeight,\n\t\t\t\t                             rawWidths[2], rawHeights[2], planar->deltaPlanes[1]))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tplanes[2] = planar->deltaPlanes[1];\n\t\t\t\trawSizes[2] = planeSize; /* GreenChromaOrBluePlane */\n\t\t\t\trawWidths[2] = nSrcWidth;\n\t\t\t\trawHeights[2] = nSrcHeight;\n\t\t\t}\n\n\t\t\tif (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,\n\t\t\t                                  nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];\n\t\t\telse /* NoAlpha */\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2];\n\n\t\t\tif ((SrcSize - (srcp - pSrcData)) == 1)\n\t\t\t\tsrcp++; /* pad */\n\t\t}\n\n\t\tWINPR_ASSERT(prims->YCoCgToRGB_8u_AC4R);\n\t\tint rc = prims->YCoCgToRGB_8u_AC4R(pTempData, nTempStep, dst, DstFormat, nDstStep, w, h,\n\t\t                                   cll, useAlpha);\n\t\tif (rc != PRIMITIVES_SUCCESS)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"YCoCgToRGB_8u_AC4R failed with %d\", rc);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tWINPR_UNUSED(srcp);\n\treturn TRUE;\n}\n\nstatic INLINE BOOL freerdp_split_color_planes(BITMAP_PLANAR_CONTEXT* planar, const BYTE* data,\n                                              UINT32 format, UINT32 width, UINT32 height,\n                                              UINT32 scanline, BYTE* planes[4])\n{\n\tWINPR_ASSERT(planar);\n\n\tif ((width > INT32_MAX) || (height > INT32_MAX) || (scanline > INT32_MAX))\n\t\treturn FALSE;\n\n\tif (scanline == 0)\n\t\tscanline = width * FreeRDPGetBytesPerPixel(format);\n\n\tif (planar->topdown)\n\t{\n\t\tUINT32 i, j, k = 0;\n\t\tfor (i = 0; i < height; i++)\n\t\t{\n\t\t\tconst BYTE* pixel = &data[scanline * (UINT32)i];\n\n\t\t\tfor (j = 0; j < width; j++)\n\t\t\t{\n\t\t\t\tconst UINT32 color = FreeRDPReadColor(pixel, format);\n\t\t\t\tpixel += FreeRDPGetBytesPerPixel(format);\n\t\t\t\tFreeRDPSplitColor(color, format, &planes[1][k], &planes[2][k], &planes[3][k],\n\t\t\t\t                  &planes[0][k], NULL);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tINT64 i;\n\t\tUINT32 j, k = 0;\n\n\t\tfor (i = (INT64)height - 1; i >= 0; i--)\n\t\t{\n\t\t\tconst BYTE* pixel = &data[scanline * (UINT32)i];\n\n\t\t\tfor (j = 0; j < width; j++)\n\t\t\t{\n\t\t\t\tconst UINT32 color = FreeRDPReadColor(pixel, format);\n\t\t\t\tpixel += FreeRDPGetBytesPerPixel(format);\n\t\t\t\tFreeRDPSplitColor(color, format, &planes[1][k], &planes[2][k], &planes[3][k],\n\t\t\t\t                  &planes[0][k], NULL);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nstatic INLINE UINT32 freerdp_bitmap_planar_write_rle_bytes(const BYTE* pInBuffer, UINT32 cRawBytes,\n                                                           UINT32 nRunLength, BYTE* pOutBuffer,\n                                                           UINT32 outBufferSize)\n{\n\tconst BYTE* pInput;\n\tBYTE* pOutput;\n\tBYTE controlByte;\n\tUINT32 nBytesToWrite;\n\tpInput = pInBuffer;\n\tpOutput = pOutBuffer;\n\n\tif (!cRawBytes && !nRunLength)\n\t\treturn 0;\n\n\tif (nRunLength < 3)\n\t{\n\t\tcRawBytes += nRunLength;\n\t\tnRunLength = 0;\n\t}\n\n\twhile (cRawBytes)\n\t{\n\t\tif (cRawBytes < 16)\n\t\t{\n\t\t\tif (nRunLength > 15)\n\t\t\t{\n\t\t\t\tif (nRunLength < 18)\n\t\t\t\t{\n\t\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(13, cRawBytes);\n\t\t\t\t\tnRunLength -= 13;\n\t\t\t\t\tcRawBytes = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(15, cRawBytes);\n\t\t\t\t\tnRunLength -= 15;\n\t\t\t\t\tcRawBytes = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(nRunLength, cRawBytes);\n\t\t\t\tnRunLength = 0;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(0, 15);\n\t\t\tcRawBytes -= 15;\n\t\t}\n\n\t\tif (outBufferSize < 1)\n\t\t\treturn 0;\n\n\t\toutBufferSize--;\n\t\t*pOutput = controlByte;\n\t\tpOutput++;\n\t\tnBytesToWrite = (int)(controlByte >> 4);\n\n\t\tif (nBytesToWrite)\n\t\t{\n\t\t\tif (outBufferSize < nBytesToWrite)\n\t\t\t\treturn 0;\n\n\t\t\toutBufferSize -= nBytesToWrite;\n\t\t\tCopyMemory(pOutput, pInput, nBytesToWrite);\n\t\t\tpOutput += nBytesToWrite;\n\t\t\tpInput += nBytesToWrite;\n\t\t}\n\t}\n\n\twhile (nRunLength)\n\t{\n\t\tif (nRunLength > 47)\n\t\t{\n\t\t\tif (nRunLength < 50)\n\t\t\t{\n\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(2, 13);\n\t\t\t\tnRunLength -= 45;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(2, 15);\n\t\t\t\tnRunLength -= 47;\n\t\t\t}\n\t\t}\n\t\telse if (nRunLength > 31)\n\t\t{\n\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(2, (nRunLength - 32));\n\t\t\tnRunLength = 0;\n\t\t}\n\t\telse if (nRunLength > 15)\n\t\t{\n\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(1, (nRunLength - 16));\n\t\t\tnRunLength = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(nRunLength, 0);\n\t\t\tnRunLength = 0;\n\t\t}\n\n\t\tif (outBufferSize < 1)\n\t\t\treturn 0;\n\n\t\t--outBufferSize;\n\t\t*pOutput = controlByte;\n\t\tpOutput++;\n\t}\n\n\treturn (pOutput - pOutBuffer);\n}\n\nstatic INLINE UINT32 freerdp_bitmap_planar_encode_rle_bytes(const BYTE* pInBuffer,\n                                                            UINT32 inBufferSize, BYTE* pOutBuffer,\n                                                            UINT32 outBufferSize)\n{\n\tBYTE symbol;\n\tconst BYTE* pInput;\n\tBYTE* pOutput;\n\tconst BYTE* pBytes;\n\tUINT32 cRawBytes;\n\tUINT32 nRunLength;\n\tUINT32 bSymbolMatch;\n\tUINT32 nBytesWritten;\n\tUINT32 nTotalBytesWritten;\n\tsymbol = 0;\n\tcRawBytes = 0;\n\tnRunLength = 0;\n\tpInput = pInBuffer;\n\tpOutput = pOutBuffer;\n\tnTotalBytesWritten = 0;\n\n\tif (!outBufferSize)\n\t\treturn 0;\n\n\tdo\n\t{\n\t\tif (!inBufferSize)\n\t\t\tbreak;\n\n\t\tbSymbolMatch = (symbol == *pInput) ? TRUE : FALSE;\n\t\tsymbol = *pInput;\n\t\tpInput++;\n\t\tinBufferSize--;\n\n\t\tif (nRunLength && !bSymbolMatch)\n\t\t{\n\t\t\tif (nRunLength < 3)\n\t\t\t{\n\t\t\t\tcRawBytes += nRunLength;\n\t\t\t\tnRunLength = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpBytes = pInput - (cRawBytes + nRunLength + 1);\n\t\t\t\tnBytesWritten = freerdp_bitmap_planar_write_rle_bytes(pBytes, cRawBytes, nRunLength,\n\t\t\t\t                                                      pOutput, outBufferSize);\n\t\t\t\tnRunLength = 0;\n\n\t\t\t\tif (!nBytesWritten || (nBytesWritten > outBufferSize))\n\t\t\t\t\treturn nRunLength;\n\n\t\t\t\tnTotalBytesWritten += nBytesWritten;\n\t\t\t\toutBufferSize -= nBytesWritten;\n\t\t\t\tpOutput += nBytesWritten;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t}\n\n\t\tnRunLength += bSymbolMatch;\n\t\tcRawBytes += (!bSymbolMatch) ? TRUE : FALSE;\n\t} while (outBufferSize);\n\n\tif (cRawBytes || nRunLength)\n\t{\n\t\tpBytes = pInput - (cRawBytes + nRunLength);\n\t\tnBytesWritten = freerdp_bitmap_planar_write_rle_bytes(pBytes, cRawBytes, nRunLength,\n\t\t                                                      pOutput, outBufferSize);\n\n\t\tif (!nBytesWritten)\n\t\t\treturn 0;\n\n\t\tnTotalBytesWritten += nBytesWritten;\n\t}\n\n\tif (inBufferSize)\n\t\treturn 0;\n\n\treturn nTotalBytesWritten;\n}\n\nBOOL freerdp_bitmap_planar_compress_plane_rle(const BYTE* inPlane, UINT32 width, UINT32 height,\n                                              BYTE* outPlane, UINT32* dstSize)\n{\n\tUINT32 index;\n\tconst BYTE* pInput;\n\tBYTE* pOutput;\n\tUINT32 outBufferSize;\n\tUINT32 nBytesWritten;\n\tUINT32 nTotalBytesWritten;\n\n\tif (!outPlane)\n\t\treturn FALSE;\n\n\tindex = 0;\n\tpInput = inPlane;\n\tpOutput = outPlane;\n\toutBufferSize = *dstSize;\n\tnTotalBytesWritten = 0;\n\n\twhile (outBufferSize)\n\t{\n\t\tnBytesWritten =\n\t\t    freerdp_bitmap_planar_encode_rle_bytes(pInput, width, pOutput, outBufferSize);\n\n\t\tif ((!nBytesWritten) || (nBytesWritten > outBufferSize))\n\t\t\treturn FALSE;\n\n\t\toutBufferSize -= nBytesWritten;\n\t\tnTotalBytesWritten += nBytesWritten;\n\t\tpOutput += nBytesWritten;\n\t\tpInput += width;\n\t\tindex++;\n\n\t\tif (index >= height)\n\t\t\tbreak;\n\t}\n\n\t*dstSize = nTotalBytesWritten;\n\treturn TRUE;\n}\n\nstatic INLINE BOOL freerdp_bitmap_planar_compress_planes_rle(BYTE* inPlanes[4], UINT32 width,\n                                                             UINT32 height, BYTE* outPlanes,\n                                                             UINT32* dstSizes, BOOL skipAlpha)\n{\n\tUINT32 outPlanesSize = width * height * 4;\n\n\t/* AlphaPlane */\n\tif (skipAlpha)\n\t{\n\t\tdstSizes[0] = 0;\n\t}\n\telse\n\t{\n\t\tdstSizes[0] = outPlanesSize;\n\n\t\tif (!freerdp_bitmap_planar_compress_plane_rle(inPlanes[0], width, height, outPlanes,\n\t\t                                              &dstSizes[0]))\n\t\t\treturn FALSE;\n\n\t\toutPlanes += dstSizes[0];\n\t\toutPlanesSize -= dstSizes[0];\n\t}\n\n\t/* LumaOrRedPlane */\n\tdstSizes[1] = outPlanesSize;\n\n\tif (!freerdp_bitmap_planar_compress_plane_rle(inPlanes[1], width, height, outPlanes,\n\t                                              &dstSizes[1]))\n\t\treturn FALSE;\n\n\toutPlanes += dstSizes[1];\n\toutPlanesSize -= dstSizes[1];\n\t/* OrangeChromaOrGreenPlane */\n\tdstSizes[2] = outPlanesSize;\n\n\tif (!freerdp_bitmap_planar_compress_plane_rle(inPlanes[2], width, height, outPlanes,\n\t                                              &dstSizes[2]))\n\t\treturn FALSE;\n\n\toutPlanes += dstSizes[2];\n\toutPlanesSize -= dstSizes[2];\n\t/* GreenChromeOrBluePlane */\n\tdstSizes[3] = outPlanesSize;\n\n\tif (!freerdp_bitmap_planar_compress_plane_rle(inPlanes[3], width, height, outPlanes,\n\t                                              &dstSizes[3]))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBYTE* freerdp_bitmap_planar_delta_encode_plane(const BYTE* inPlane, UINT32 width, UINT32 height,\n                                               BYTE* outPlane)\n{\n\tchar s2c;\n\tUINT32 y, x;\n\tBYTE* outPtr;\n\tconst BYTE *srcPtr, *prevLinePtr;\n\n\tif (!outPlane)\n\t{\n\t\tif (width * height == 0)\n\t\t\treturn NULL;\n\n\t\tif (!(outPlane = (BYTE*)calloc(height, width)))\n\t\t\treturn NULL;\n\t}\n\n\t// first line is copied as is\n\tCopyMemory(outPlane, inPlane, width);\n\toutPtr = outPlane + width;\n\tsrcPtr = inPlane + width;\n\tprevLinePtr = inPlane;\n\n\tfor (y = 1; y < height; y++)\n\t{\n\t\tfor (x = 0; x < width; x++, outPtr++, srcPtr++, prevLinePtr++)\n\t\t{\n\t\t\tINT32 delta = *srcPtr - *prevLinePtr;\n\t\t\ts2c = (delta >= 0) ? (char)delta : (char)(~((BYTE)(-delta)) + 1);\n\t\t\ts2c = (s2c >= 0) ? (char)((UINT32)s2c << 1)\n\t\t\t                 : (char)(((UINT32)(~((BYTE)s2c) + 1) << 1) - 1);\n\t\t\t*outPtr = (BYTE)s2c;\n\t\t}\n\t}\n\n\treturn outPlane;\n}\n\nstatic INLINE BOOL freerdp_bitmap_planar_delta_encode_planes(BYTE* inPlanes[4], UINT32 width,\n                                                             UINT32 height, BYTE* outPlanes[4])\n{\n\tUINT32 i;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toutPlanes[i] =\n\t\t    freerdp_bitmap_planar_delta_encode_plane(inPlanes[i], width, height, outPlanes[i]);\n\n\t\tif (!outPlanes[i])\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBYTE* freerdp_bitmap_compress_planar(BITMAP_PLANAR_CONTEXT* context, const BYTE* data,\n                                     UINT32 format, UINT32 width, UINT32 height, UINT32 scanline,\n                                     BYTE* dstData, UINT32* pDstSize)\n{\n\tUINT32 size;\n\tBYTE* dstp;\n\tUINT32 planeSize;\n\tUINT32 dstSizes[4] = { 0 };\n\tBYTE FormatHeader = 0;\n\n\tif (!context || !context->rlePlanesBuffer)\n\t\treturn NULL;\n\n\tif (context->AllowSkipAlpha)\n\t\tFormatHeader |= PLANAR_FORMAT_HEADER_NA;\n\n\tplaneSize = width * height;\n\n\tif (!context->AllowSkipAlpha)\n\t\tformat = planar_invert_format(context, TRUE, format);\n\n\tif (!freerdp_split_color_planes(context, data, format, width, height, scanline,\n\t                                context->planes))\n\t\treturn NULL;\n\n\tif (context->AllowRunLengthEncoding)\n\t{\n\t\tif (!freerdp_bitmap_planar_delta_encode_planes(context->planes, width, height,\n\t\t                                               context->deltaPlanes))\n\t\t\treturn NULL;\n\n\t\tif (!freerdp_bitmap_planar_compress_planes_rle(context->deltaPlanes, width, height,\n\t\t                                               context->rlePlanesBuffer, dstSizes,\n\t\t                                               context->AllowSkipAlpha))\n\t\t\treturn NULL;\n\n\t\t{\n\t\t\tint offset = 0;\n\t\t\tFormatHeader |= PLANAR_FORMAT_HEADER_RLE;\n\t\t\tcontext->rlePlanes[0] = &context->rlePlanesBuffer[offset];\n\t\t\toffset += dstSizes[0];\n\t\t\tcontext->rlePlanes[1] = &context->rlePlanesBuffer[offset];\n\t\t\toffset += dstSizes[1];\n\t\t\tcontext->rlePlanes[2] = &context->rlePlanesBuffer[offset];\n\t\t\toffset += dstSizes[2];\n\t\t\tcontext->rlePlanes[3] = &context->rlePlanesBuffer[offset];\n\n#if defined(WITH_DEBUG_CODECS)\n\t\t\tWLog_DBG(TAG,\n\t\t\t         \"R: [%\" PRIu32 \"/%\" PRIu32 \"] G: [%\" PRIu32 \"/%\" PRIu32 \"] B: [%\" PRIu32\n\t\t\t         \" / %\" PRIu32 \"] \",\n\t\t\t         dstSizes[1], planeSize, dstSizes[2], planeSize, dstSizes[3], planeSize);\n#endif\n\t\t}\n\t}\n\n\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t{\n\t\tif (!context->AllowRunLengthEncoding)\n\t\t\treturn NULL;\n\n\t\tif (context->rlePlanes[0] == NULL)\n\t\t\treturn NULL;\n\n\t\tif (context->rlePlanes[1] == NULL)\n\t\t\treturn NULL;\n\n\t\tif (context->rlePlanes[2] == NULL)\n\t\t\treturn NULL;\n\n\t\tif (context->rlePlanes[3] == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tif (!dstData)\n\t{\n\t\tsize = 1;\n\n\t\tif (!(FormatHeader & PLANAR_FORMAT_HEADER_NA))\n\t\t{\n\t\t\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t\t\t\tsize += dstSizes[0];\n\t\t\telse\n\t\t\t\tsize += planeSize;\n\t\t}\n\n\t\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t\t\tsize += (dstSizes[1] + dstSizes[2] + dstSizes[3]);\n\t\telse\n\t\t\tsize += (planeSize * 3);\n\n\t\tif (!(FormatHeader & PLANAR_FORMAT_HEADER_RLE))\n\t\t\tsize++;\n\n\t\tdstData = malloc(size);\n\n\t\tif (!dstData)\n\t\t\treturn NULL;\n\n\t\t*pDstSize = size;\n\t}\n\n\tdstp = dstData;\n\t*dstp = FormatHeader; /* FormatHeader */\n\tdstp++;\n\n\t/* AlphaPlane */\n\n\tif (!(FormatHeader & PLANAR_FORMAT_HEADER_NA))\n\t{\n\t\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t\t{\n\t\t\tCopyMemory(dstp, context->rlePlanes[0], dstSizes[0]); /* Alpha */\n\t\t\tdstp += dstSizes[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCopyMemory(dstp, context->planes[0], planeSize); /* Alpha */\n\t\t\tdstp += planeSize;\n\t\t}\n\t}\n\n\t/* LumaOrRedPlane */\n\n\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t{\n\t\tCopyMemory(dstp, context->rlePlanes[1], dstSizes[1]); /* Red */\n\t\tdstp += dstSizes[1];\n\t}\n\telse\n\t{\n\t\tCopyMemory(dstp, context->planes[1], planeSize); /* Red */\n\t\tdstp += planeSize;\n\t}\n\n\t/* OrangeChromaOrGreenPlane */\n\n\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t{\n\t\tCopyMemory(dstp, context->rlePlanes[2], dstSizes[2]); /* Green */\n\t\tdstp += dstSizes[2];\n\t}\n\telse\n\t{\n\t\tCopyMemory(dstp, context->planes[2], planeSize); /* Green */\n\t\tdstp += planeSize;\n\t}\n\n\t/* GreenChromeOrBluePlane */\n\n\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t{\n\t\tCopyMemory(dstp, context->rlePlanes[3], dstSizes[3]); /* Blue */\n\t\tdstp += dstSizes[3];\n\t}\n\telse\n\t{\n\t\tCopyMemory(dstp, context->planes[3], planeSize); /* Blue */\n\t\tdstp += planeSize;\n\t}\n\n\t/* Pad1 (1 byte) */\n\n\tif (!(FormatHeader & PLANAR_FORMAT_HEADER_RLE))\n\t{\n\t\t*dstp = 0;\n\t\tdstp++;\n\t}\n\n\tsize = (dstp - dstData);\n\t*pDstSize = size;\n\treturn dstData;\n}\n\nBOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\n\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->planesBuffer = tmp;\n\n\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->pTempData = tmp;\n\n\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->deltaPlanesBuffer = tmp;\n\n\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->rlePlanesBuffer = tmp;\n\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}\n\nBITMAP_PLANAR_CONTEXT* freerdp_bitmap_planar_context_new(DWORD flags, UINT32 maxWidth,\n                                                         UINT32 maxHeight)\n{\n\tBITMAP_PLANAR_CONTEXT* context =\n\t    (BITMAP_PLANAR_CONTEXT*)winpr_aligned_calloc(1, sizeof(BITMAP_PLANAR_CONTEXT), 32);\n\n\tif (!context)\n\t\treturn NULL;\n\n\tif (flags & PLANAR_FORMAT_HEADER_NA)\n\t\tcontext->AllowSkipAlpha = TRUE;\n\n\tif (flags & PLANAR_FORMAT_HEADER_RLE)\n\t\tcontext->AllowRunLengthEncoding = TRUE;\n\n\tif (flags & PLANAR_FORMAT_HEADER_CS)\n\t\tcontext->AllowColorSubsampling = TRUE;\n\n\tcontext->ColorLossLevel = flags & PLANAR_FORMAT_HEADER_CLL_MASK;\n\n\tif (context->ColorLossLevel)\n\t\tcontext->AllowDynamicColorFidelity = TRUE;\n\n\tif (!freerdp_bitmap_planar_context_reset(context, maxWidth, maxHeight))\n\t{\n\t\tfreerdp_bitmap_planar_context_free(context);\n\t\treturn NULL;\n\t}\n\n\treturn context;\n}\n\nvoid freerdp_bitmap_planar_context_free(BITMAP_PLANAR_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn;\n\n\twinpr_aligned_free(context->pTempData);\n\twinpr_aligned_free(context->planesBuffer);\n\twinpr_aligned_free(context->deltaPlanesBuffer);\n\twinpr_aligned_free(context->rlePlanesBuffer);\n\twinpr_aligned_free(context);\n}\n\nvoid freerdp_planar_switch_bgr(BITMAP_PLANAR_CONTEXT* planar, BOOL bgr)\n{\n\tWINPR_ASSERT(planar);\n\tplanar->bgr = bgr;\n}\n\nvoid freerdp_planar_topdown_image(BITMAP_PLANAR_CONTEXT* planar, BOOL topdown)\n{\n\tWINPR_ASSERT(planar);\n\tplanar->topdown = topdown;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP6 Planar Codec\n *\n * Copyright 2013 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <freerdp/config.h>\n\n#include <winpr/crt.h>\n#include <winpr/assert.h>\n#include <winpr/print.h>\n\n#include <freerdp/primitives.h>\n#include <freerdp/log.h>\n#include <freerdp/codec/bitmap.h>\n#include <freerdp/codec/planar.h>\n\n#define TAG FREERDP_TAG(\"codec\")\n\n#define PLANAR_ALIGN(val, align) \\\n\t((val) % (align) == 0) ? (val) : ((val) + (align) - (val) % (align))\n\ntypedef struct\n{\n\t/**\n\t * controlByte:\n\t * [0-3]: nRunLength\n\t * [4-7]: cRawBytes\n\t */\n\tBYTE controlByte;\n\tBYTE* rawValues;\n} RDP6_RLE_SEGMENT;\n\ntypedef struct\n{\n\tUINT32 cSegments;\n\tRDP6_RLE_SEGMENT* segments;\n} RDP6_RLE_SEGMENTS;\n\ntypedef struct\n{\n\t/**\n\t * formatHeader:\n\t * [0-2]: Color Loss Level (CLL)\n\t *  [3] : Chroma Subsampling (CS)\n\t *  [4] : Run Length Encoding (RLE)\n\t *  [5] : No Alpha (NA)\n\t * [6-7]: Reserved\n\t */\n\tBYTE formatHeader;\n} RDP6_BITMAP_STREAM;\n\nstruct S_BITMAP_PLANAR_CONTEXT\n{\n\tUINT32 maxWidth;\n\tUINT32 maxHeight;\n\tUINT32 maxPlaneSize;\n\n\tBOOL AllowSkipAlpha;\n\tBOOL AllowRunLengthEncoding;\n\tBOOL AllowColorSubsampling;\n\tBOOL AllowDynamicColorFidelity;\n\n\tUINT32 ColorLossLevel;\n\n\tBYTE* planes[4];\n\tBYTE* planesBuffer;\n\n\tBYTE* deltaPlanes[4];\n\tBYTE* deltaPlanesBuffer;\n\n\tBYTE* rlePlanes[4];\n\tBYTE* rlePlanesBuffer;\n\n\tBYTE* pTempData;\n\tUINT32 nTempStep;\n\n\tBOOL bgr;\n\tBOOL topdown;\n};\n\nstatic INLINE UINT32 planar_invert_format(BITMAP_PLANAR_CONTEXT* planar, BOOL alpha,\n                                          UINT32 DstFormat)\n{\n\n\tif (planar->bgr && alpha)\n\t{\n\t\tswitch (DstFormat)\n\t\t{\n\t\t\tcase PIXEL_FORMAT_ARGB32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_ABGR32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_XRGB32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_XBGR32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_ABGR32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_ARGB32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_XBGR32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_XRGB32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGBA32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGBX32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGBA32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGRA32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGBX32:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGRX32;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGB24:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGR24;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGR24:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGB24;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGB16:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGR16;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGR16:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGB16;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_ARGB15:\n\t\t\t\tDstFormat = PIXEL_FORMAT_ABGR15;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_RGB15:\n\t\t\t\tDstFormat = PIXEL_FORMAT_BGR15;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_ABGR15:\n\t\t\t\tDstFormat = PIXEL_FORMAT_ARGB15;\n\t\t\t\tbreak;\n\t\t\tcase PIXEL_FORMAT_BGR15:\n\t\t\t\tDstFormat = PIXEL_FORMAT_RGB15;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn DstFormat;\n}\n\nstatic INLINE BOOL freerdp_bitmap_planar_compress_plane_rle(const BYTE* plane, UINT32 width,\n                                                            UINT32 height, BYTE* outPlane,\n                                                            UINT32* dstSize);\nstatic INLINE BYTE* freerdp_bitmap_planar_delta_encode_plane(const BYTE* inPlane, UINT32 width,\n                                                             UINT32 height, BYTE* outPlane);\n\nstatic INLINE INT32 planar_skip_plane_rle(const BYTE* pSrcData, UINT32 SrcSize, UINT32 nWidth,\n                                          UINT32 nHeight)\n{\n\tUINT32 used = 0;\n\tUINT32 x, y;\n\tBYTE controlByte;\n\n\tWINPR_ASSERT(pSrcData);\n\n\tfor (y = 0; y < nHeight; y++)\n\t{\n\t\tfor (x = 0; x < nWidth;)\n\t\t{\n\t\t\tint cRawBytes;\n\t\t\tint nRunLength;\n\n\t\t\tif (used >= SrcSize)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar plane used %\" PRIu32 \" exceeds SrcSize %\" PRIu32, used,\n\t\t\t\t         SrcSize);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tcontrolByte = pSrcData[used++];\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\n\t\t\tused += cRawBytes;\n\t\t\tx += cRawBytes;\n\t\t\tx += nRunLength;\n\n\t\t\tif (x > nWidth)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar plane x %\" PRIu32 \" exceeds width %\" PRIu32, x, nWidth);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (used > SrcSize)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar plane used %\" PRIu32 \" exceeds SrcSize %\" PRIu32, used,\n\t\t\t\t         INT32_MAX);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (used > INT32_MAX)\n\t{\n\t\tWLog_ERR(TAG, \"planar plane used %\" PRIu32 \" exceeds SrcSize %\" PRIu32, used, SrcSize);\n\t\treturn -1;\n\t}\n\treturn (INT32)used;\n}\n\nstatic INLINE INT32 planar_decompress_plane_rle_only(const BYTE* pSrcData, UINT32 SrcSize,\n                                                     BYTE* pDstData, UINT32 nWidth, UINT32 nHeight)\n{\n\tINT32 x, y;\n\tUINT32 pixel;\n\tUINT32 cRawBytes;\n\tUINT32 nRunLength;\n\tINT32 deltaValue;\n\tBYTE controlByte;\n\tBYTE* currentScanline;\n\tBYTE* previousScanline;\n\tconst BYTE* srcp = pSrcData;\n\n\tWINPR_ASSERT(nHeight <= INT32_MAX);\n\tWINPR_ASSERT(nWidth <= INT32_MAX);\n\n\tpreviousScanline = NULL;\n\n\tfor (y = 0; y < (INT32)nHeight; y++)\n\t{\n\t\tBYTE* dstp = &pDstData[((y) * (INT32)nWidth)];\n\t\tpixel = 0;\n\t\tcurrentScanline = dstp;\n\n\t\tfor (x = 0; x < (INT32)nWidth;)\n\t\t{\n\t\t\tcontrolByte = *srcp;\n\t\t\tsrcp++;\n\n\t\t\tif ((srcp - pSrcData) > SrcSize * 1ll)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"error reading input buffer\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\n\t\t\tif (((dstp + (cRawBytes + nRunLength)) - currentScanline) > nWidth * 1ll)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"too many pixels in scanline\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!previousScanline)\n\t\t\t{\n\t\t\t\t/* first scanline, absolute values */\n\t\t\t\twhile (cRawBytes > 0)\n\t\t\t\t{\n\t\t\t\t\tpixel = *srcp;\n\t\t\t\t\tsrcp++;\n\t\t\t\t\t*dstp = pixel;\n\t\t\t\t\tdstp++;\n\t\t\t\t\tx++;\n\t\t\t\t\tcRawBytes--;\n\t\t\t\t}\n\n\t\t\t\twhile (nRunLength > 0)\n\t\t\t\t{\n\t\t\t\t\t*dstp = pixel;\n\t\t\t\t\tdstp++;\n\t\t\t\t\tx++;\n\t\t\t\t\tnRunLength--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* delta values relative to previous scanline */\n\t\t\t\twhile (cRawBytes > 0)\n\t\t\t\t{\n\t\t\t\t\tdeltaValue = *srcp;\n\t\t\t\t\tsrcp++;\n\n\t\t\t\t\tif (deltaValue & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeltaValue = deltaValue >> 1;\n\t\t\t\t\t\tdeltaValue = deltaValue + 1;\n\t\t\t\t\t\tpixel = -deltaValue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdeltaValue = deltaValue >> 1;\n\t\t\t\t\t\tpixel = deltaValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdeltaValue = previousScanline[x] + pixel;\n\t\t\t\t\t*dstp = deltaValue;\n\t\t\t\t\tdstp++;\n\t\t\t\t\tx++;\n\t\t\t\t\tcRawBytes--;\n\t\t\t\t}\n\n\t\t\t\twhile (nRunLength > 0)\n\t\t\t\t{\n\t\t\t\t\tdeltaValue = previousScanline[x] + pixel;\n\t\t\t\t\t*dstp = deltaValue;\n\t\t\t\t\tdstp++;\n\t\t\t\t\tx++;\n\t\t\t\t\tnRunLength--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpreviousScanline = currentScanline;\n\t}\n\n\treturn (INT32)(srcp - pSrcData);\n}\n\nstatic INLINE INT32 planar_decompress_plane_rle(const BYTE* pSrcData, UINT32 SrcSize,\n                                                BYTE* pDstData, INT32 nDstStep, UINT32 nXDst,\n                                                UINT32 nYDst, UINT32 nWidth, UINT32 nHeight,\n                                                UINT32 nChannel, BOOL vFlip)\n{\n\tINT32 x, y;\n\tUINT32 pixel;\n\tUINT32 cRawBytes;\n\tUINT32 nRunLength;\n\tINT32 deltaValue;\n\tINT32 beg, end, inc;\n\tBYTE controlByte;\n\tBYTE* currentScanline;\n\tBYTE* previousScanline;\n\tconst BYTE* srcp = pSrcData;\n\n\tWINPR_ASSERT(nHeight <= INT32_MAX);\n\tWINPR_ASSERT(nWidth <= INT32_MAX);\n\tWINPR_ASSERT(nDstStep <= INT32_MAX);\n\n\tpreviousScanline = NULL;\n\n\tif (vFlip)\n\t{\n\t\tbeg = (INT32)nHeight - 1;\n\t\tend = -1;\n\t\tinc = -1;\n\t}\n\telse\n\t{\n\t\tbeg = 0;\n\t\tend = (INT32)nHeight;\n\t\tinc = 1;\n\t}\n\n\tfor (y = beg; y != end; y += inc)\n\t{\n\t\tBYTE* dstp = &pDstData[((nYDst + y) * (INT32)nDstStep) + (nXDst * 4) + nChannel];\n\t\tpixel = 0;\n\t\tcurrentScanline = dstp;\n\n\t\tfor (x = 0; x < (INT32)nWidth;)\n\t\t{\n\t\t\tcontrolByte = *srcp;\n\t\t\tsrcp++;\n\n\t\t\tif ((srcp - pSrcData) > SrcSize * 1ll)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"error reading input buffer\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\n\t\t\tif (((dstp + (cRawBytes + nRunLength)) - currentScanline) > nWidth * 4ll)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"too many pixels in scanline\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!previousScanline)\n\t\t\t{\n\t\t\t\t/* first scanline, absolute values */\n\t\t\t\twhile (cRawBytes > 0)\n\t\t\t\t{\n\t\t\t\t\tpixel = *srcp;\n\t\t\t\t\tsrcp++;\n\t\t\t\t\t*dstp = pixel;\n\t\t\t\t\tdstp += 4;\n\t\t\t\t\tx++;\n\t\t\t\t\tcRawBytes--;\n\t\t\t\t}\n\n\t\t\t\twhile (nRunLength > 0)\n\t\t\t\t{\n\t\t\t\t\t*dstp = pixel;\n\t\t\t\t\tdstp += 4;\n\t\t\t\t\tx++;\n\t\t\t\t\tnRunLength--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* delta values relative to previous scanline */\n\t\t\t\twhile (cRawBytes > 0)\n\t\t\t\t{\n\t\t\t\t\tdeltaValue = *srcp;\n\t\t\t\t\tsrcp++;\n\n\t\t\t\t\tif (deltaValue & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdeltaValue = deltaValue >> 1;\n\t\t\t\t\t\tdeltaValue = deltaValue + 1;\n\t\t\t\t\t\tpixel = -deltaValue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdeltaValue = deltaValue >> 1;\n\t\t\t\t\t\tpixel = deltaValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdeltaValue = previousScanline[x * 4] + pixel;\n\t\t\t\t\t*dstp = deltaValue;\n\t\t\t\t\tdstp += 4;\n\t\t\t\t\tx++;\n\t\t\t\t\tcRawBytes--;\n\t\t\t\t}\n\n\t\t\t\twhile (nRunLength > 0)\n\t\t\t\t{\n\t\t\t\t\tdeltaValue = previousScanline[x * 4] + pixel;\n\t\t\t\t\t*dstp = deltaValue;\n\t\t\t\t\tdstp += 4;\n\t\t\t\t\tx++;\n\t\t\t\t\tnRunLength--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpreviousScanline = currentScanline;\n\t}\n\n\treturn (INT32)(srcp - pSrcData);\n}\n\nstatic INLINE INT32 planar_set_plane(BYTE bValue, BYTE* pDstData, INT32 nDstStep, UINT32 nXDst,\n                                     UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, UINT32 nChannel,\n                                     BOOL vFlip)\n{\n\tINT32 x, y;\n\tINT32 beg, end, inc;\n\n\tWINPR_ASSERT(nHeight <= INT32_MAX);\n\tWINPR_ASSERT(nWidth <= INT32_MAX);\n\tWINPR_ASSERT(nDstStep <= INT32_MAX);\n\n\tif (vFlip)\n\t{\n\t\tbeg = (INT32)nHeight - 1;\n\t\tend = -1;\n\t\tinc = -1;\n\t}\n\telse\n\t{\n\t\tbeg = 0;\n\t\tend = (INT32)nHeight;\n\t\tinc = 1;\n\t}\n\n\tfor (y = beg; y != end; y += inc)\n\t{\n\t\tBYTE* dstp = &pDstData[((nYDst + y) * (INT32)nDstStep) + (nXDst * 4) + nChannel];\n\n\t\tfor (x = 0; x < (INT32)nWidth; ++x)\n\t\t{\n\t\t\t*dstp = bValue;\n\t\t\tdstp += 4;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic INLINE BOOL writeLine(BYTE** ppRgba, UINT32 DstFormat, UINT32 width, const BYTE** ppR,\n                             const BYTE** ppG, const BYTE** ppB, const BYTE** ppA)\n{\n\tUINT32 x;\n\n\tWINPR_ASSERT(ppRgba);\n\tWINPR_ASSERT(ppR);\n\tWINPR_ASSERT(ppG);\n\tWINPR_ASSERT(ppB);\n\n\tswitch (DstFormat)\n\t{\n\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\tfor (x = 0; x < width; x++)\n\t\t\t{\n\t\t\t\t*(*ppRgba)++ = *(*ppB)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppG)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppR)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppA)++;\n\t\t\t}\n\n\t\t\treturn TRUE;\n\n\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\tfor (x = 0; x < width; x++)\n\t\t\t{\n\t\t\t\t*(*ppRgba)++ = *(*ppB)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppG)++;\n\t\t\t\t*(*ppRgba)++ = *(*ppR)++;\n\t\t\t\t*(*ppRgba)++ = 0xFF;\n\t\t\t}\n\n\t\t\treturn TRUE;\n\n\t\tdefault:\n\t\t\tif (ppA)\n\t\t\t{\n\t\t\t\tfor (x = 0; x < width; x++)\n\t\t\t\t{\n\t\t\t\t\tBYTE alpha = *(*ppA)++;\n\t\t\t\t\tUINT32 color =\n\t\t\t\t\t    FreeRDPGetColor(DstFormat, *(*ppR)++, *(*ppG)++, *(*ppB)++, alpha);\n\t\t\t\t\tFreeRDPWriteColor(*ppRgba, DstFormat, color);\n\t\t\t\t\t*ppRgba += FreeRDPGetBytesPerPixel(DstFormat);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst BYTE alpha = 0xFF;\n\n\t\t\t\tfor (x = 0; x < width; x++)\n\t\t\t\t{\n\t\t\t\t\tUINT32 color =\n\t\t\t\t\t    FreeRDPGetColor(DstFormat, *(*ppR)++, *(*ppG)++, *(*ppB)++, alpha);\n\t\t\t\t\tFreeRDPWriteColor(*ppRgba, DstFormat, color);\n\t\t\t\t\t*ppRgba += FreeRDPGetBytesPerPixel(DstFormat);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn TRUE;\n\t}\n}\n\nstatic INLINE BOOL planar_decompress_planes_raw(const BYTE* pSrcData[4], BYTE* pDstData,\n                                                UINT32 DstFormat, UINT32 nDstStep, UINT32 nXDst,\n                                                UINT32 nYDst, UINT32 nWidth, UINT32 nHeight,\n                                                BOOL vFlip, UINT32 totalHeight)\n{\n\tINT32 y;\n\tINT32 beg, end, inc;\n\tconst BYTE* pR = pSrcData[0];\n\tconst BYTE* pG = pSrcData[1];\n\tconst BYTE* pB = pSrcData[2];\n\tconst BYTE* pA = pSrcData[3];\n\tconst UINT32 bpp = FreeRDPGetBytesPerPixel(DstFormat);\n\n\tif (vFlip)\n\t{\n\t\tbeg = nHeight - 1;\n\t\tend = -1;\n\t\tinc = -1;\n\t}\n\telse\n\t{\n\t\tbeg = 0;\n\t\tend = nHeight;\n\t\tinc = 1;\n\t}\n\n\tif (nYDst + nHeight > totalHeight)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"planar plane destination Y %\" PRIu32 \" + height %\" PRIu32\n\t\t         \" exceeds totalHeight %\" PRIu32,\n\t\t         nYDst, nHeight, totalHeight);\n\t\treturn FALSE;\n\t}\n\n\tif ((nXDst + nWidth) * bpp > nDstStep)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"planar plane destination (X %\" PRIu32 \" + width %\" PRIu32 \") * bpp %\" PRIu32\n\t\t         \" exceeds stride %\" PRIu32,\n\t\t         nXDst, nWidth, bpp, nDstStep);\n\t\treturn FALSE;\n\t}\n\n\tfor (y = beg; y != end; y += inc)\n\t{\n\t\tBYTE* pRGB;\n\n\t\tif (y > (INT64)nHeight)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"planar plane destination Y %\" PRId32 \" exceeds height %\" PRIu32, y,\n\t\t\t         nHeight);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tpRGB = &pDstData[((nYDst + y) * nDstStep) + (nXDst * bpp)];\n\n\t\tif (!writeLine(&pRGB, DstFormat, nWidth, &pR, &pG, &pB, &pA))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL planar_subsample_expand(const BYTE* plane, size_t planeLength, UINT32 nWidth,\n                                    UINT32 nHeight, UINT32 nPlaneWidth, UINT32 nPlaneHeight,\n                                    BYTE* deltaPlane)\n{\n\tsize_t pos = 0;\n\tUINT32 y;\n\tWINPR_UNUSED(planeLength);\n\n\tWINPR_ASSERT(plane);\n\tWINPR_ASSERT(deltaPlane);\n\n\tif (nWidth > nPlaneWidth * 2)\n\t{\n\t\tWLog_ERR(TAG, \"planar subsample width %\" PRIu32 \" > PlaneWidth %\" PRIu32 \" * 2\", nWidth,\n\t\t         nPlaneWidth);\n\t\treturn FALSE;\n\t}\n\n\tif (nHeight > nPlaneHeight * 2)\n\t{\n\t\tWLog_ERR(TAG, \"planar subsample height %\" PRIu32 \" > PlaneHeight %\" PRIu32 \" * 2\", nHeight,\n\t\t         nPlaneHeight);\n\t\treturn FALSE;\n\t}\n\n\tfor (y = 0; y < nHeight; y++)\n\t{\n\t\tconst BYTE* src = plane + y / 2 * nPlaneWidth;\n\t\tUINT32 x;\n\n\t\tfor (x = 0; x < nWidth; x++)\n\t\t{\n\t\t\tdeltaPlane[pos++] = src[x / 2];\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL planar_decompress(BITMAP_PLANAR_CONTEXT* planar, const BYTE* pSrcData, UINT32 SrcSize,\n                       UINT32 nSrcWidth, UINT32 nSrcHeight, BYTE* pDstData, UINT32 DstFormat,\n                       UINT32 nDstStep, UINT32 nXDst, UINT32 nYDst, UINT32 nDstWidth,\n                       UINT32 nDstHeight, BOOL vFlip)\n{\n\tBOOL cs;\n\tBOOL rle;\n\tUINT32 cll;\n\tBOOL alpha;\n\tBOOL useAlpha = FALSE;\n\tINT32 status;\n\tconst BYTE* srcp;\n\tUINT32 subSize;\n\tUINT32 subWidth;\n\tUINT32 subHeight;\n\tUINT32 planeSize;\n\tINT32 rleSizes[4] = { 0, 0, 0, 0 };\n\tUINT32 rawSizes[4];\n\tUINT32 rawWidths[4];\n\tUINT32 rawHeights[4];\n\tBYTE FormatHeader;\n\tconst BYTE* planes[4] = { 0 };\n\tconst UINT32 w = MIN(nSrcWidth, nDstWidth);\n\tconst UINT32 h = MIN(nSrcHeight, nDstHeight);\n\tconst primitives_t* prims = primitives_get();\n\n\tWINPR_ASSERT(planar);\n\tWINPR_ASSERT(prims);\n\n\tif (nDstStep <= 0)\n\t\tnDstStep = nDstWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\n\tsrcp = pSrcData;\n\n\tif (!pSrcData)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid argument pSrcData=NULL\");\n\t\treturn FALSE;\n\t}\n\n\tif (!pDstData)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid argument pDstData=NULL\");\n\t\treturn FALSE;\n\t}\n\n\tFormatHeader = *srcp++;\n\tcll = (FormatHeader & PLANAR_FORMAT_HEADER_CLL_MASK);\n\tcs = (FormatHeader & PLANAR_FORMAT_HEADER_CS) ? TRUE : FALSE;\n\trle = (FormatHeader & PLANAR_FORMAT_HEADER_RLE) ? TRUE : FALSE;\n\talpha = (FormatHeader & PLANAR_FORMAT_HEADER_NA) ? FALSE : TRUE;\n\n\tDstFormat = planar_invert_format(planar, alpha, DstFormat);\n\n\tif (alpha)\n\t\tuseAlpha = FreeRDPColorHasAlpha(DstFormat);\n\n\t// WLog_INFO(TAG, \"CLL: %\"PRIu32\" CS: %\"PRIu8\" RLE: %\"PRIu8\" ALPHA: %\"PRIu8\"\", cll, cs, rle,\n\t// alpha);\n\n\tif (!cll && cs)\n\t{\n\t\tWLog_ERR(TAG, \"Chroma subsampling requires YCoCg and does not work with RGB data\");\n\t\treturn FALSE; /* Chroma subsampling requires YCoCg */\n\t}\n\n\tsubWidth = (nSrcWidth / 2) + (nSrcWidth % 2);\n\tsubHeight = (nSrcHeight / 2) + (nSrcHeight % 2);\n\tplaneSize = nSrcWidth * nSrcHeight;\n\tsubSize = subWidth * subHeight;\n\n\tif (!cs)\n\t{\n\t\trawSizes[0] = planeSize; /* LumaOrRedPlane */\n\t\trawWidths[0] = nSrcWidth;\n\t\trawHeights[0] = nSrcHeight;\n\t\trawSizes[1] = planeSize; /* OrangeChromaOrGreenPlane */\n\t\trawWidths[1] = nSrcWidth;\n\t\trawHeights[1] = nSrcHeight;\n\t\trawSizes[2] = planeSize; /* GreenChromaOrBluePlane */\n\t\trawWidths[2] = nSrcWidth;\n\t\trawHeights[2] = nSrcHeight;\n\t\trawSizes[3] = planeSize; /* AlphaPlane */\n\t\trawWidths[3] = nSrcWidth;\n\t\trawHeights[3] = nSrcHeight;\n\t}\n\telse /* Chroma Subsampling */\n\t{\n\t\trawSizes[0] = planeSize; /* LumaOrRedPlane */\n\t\trawWidths[0] = nSrcWidth;\n\t\trawHeights[0] = nSrcHeight;\n\t\trawSizes[1] = subSize; /* OrangeChromaOrGreenPlane */\n\t\trawWidths[1] = subWidth;\n\t\trawHeights[1] = subHeight;\n\t\trawSizes[2] = subSize; /* GreenChromaOrBluePlane */\n\t\trawWidths[2] = subWidth;\n\t\trawHeights[2] = subHeight;\n\t\trawSizes[3] = planeSize; /* AlphaPlane */\n\t\trawWidths[3] = nSrcWidth;\n\t\trawHeights[3] = nSrcHeight;\n\t}\n\n\tif (!rle) /* RAW */\n\t{\n\t\tUINT32 base = planeSize * 3;\n\t\tif (cs)\n\t\t\tbase = planeSize + planeSize / 2;\n\n\t\tif (alpha)\n\t\t{\n\t\t\tif ((SrcSize - (srcp - pSrcData)) < (planeSize + base))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Alpha plane size mismatch %\" PRIu32 \" < %\" PRIu32,\n\t\t\t\t         SrcSize - (srcp - pSrcData), (planeSize + base));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tplanes[3] = srcp;                    /* AlphaPlane */\n\t\t\tplanes[0] = planes[3] + rawSizes[3]; /* LumaOrRedPlane */\n\t\t\tplanes[1] = planes[0] + rawSizes[0]; /* OrangeChromaOrGreenPlane */\n\t\t\tplanes[2] = planes[1] + rawSizes[1]; /* GreenChromaOrBluePlane */\n\n\t\t\tif ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %p + %\" PRIu32 \" > %p\", planes[2], rawSizes[2],\n\t\t\t\t         &pSrcData[SrcSize]);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((SrcSize - (srcp - pSrcData)) < base)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %\" PRIu32 \" < %\" PRIu32,\n\t\t\t\t         SrcSize - (srcp - pSrcData), base);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tplanes[0] = srcp;                    /* LumaOrRedPlane */\n\t\t\tplanes[1] = planes[0] + rawSizes[0]; /* OrangeChromaOrGreenPlane */\n\t\t\tplanes[2] = planes[1] + rawSizes[1]; /* GreenChromaOrBluePlane */\n\n\t\t\tif ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize])\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"plane size mismatch %p + %\" PRIu32 \" > %p\", planes[2], rawSizes[2],\n\t\t\t\t         &pSrcData[SrcSize]);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\telse /* RLE */\n\t{\n\t\tif (alpha)\n\t\t{\n\t\t\tplanes[3] = srcp;\n\t\t\trleSizes[3] = planar_skip_plane_rle(planes[3], SrcSize - (planes[3] - pSrcData),\n\t\t\t                                    rawWidths[3], rawHeights[3]); /* AlphaPlane */\n\n\t\t\tif (rleSizes[3] < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tplanes[0] = planes[3] + rleSizes[3];\n\t\t}\n\t\telse\n\t\t\tplanes[0] = srcp;\n\n\t\trleSizes[0] = planar_skip_plane_rle(planes[0], SrcSize - (planes[0] - pSrcData),\n\t\t                                    rawWidths[0], rawHeights[0]); /* RedPlane */\n\n\t\tif (rleSizes[0] < 0)\n\t\t\treturn FALSE;\n\n\t\tplanes[1] = planes[0] + rleSizes[0];\n\t\trleSizes[1] = planar_skip_plane_rle(planes[1], SrcSize - (planes[1] - pSrcData),\n\t\t                                    rawWidths[1], rawHeights[1]); /* GreenPlane */\n\n\t\tif (rleSizes[1] < 1)\n\t\t\treturn FALSE;\n\n\t\tplanes[2] = planes[1] + rleSizes[1];\n\t\trleSizes[2] = planar_skip_plane_rle(planes[2], SrcSize - (planes[2] - pSrcData),\n\t\t                                    rawWidths[2], rawHeights[2]); /* BluePlane */\n\n\t\tif (rleSizes[2] < 1)\n\t\t\treturn FALSE;\n\t}\n\n\tif (!cll) /* RGB */\n\t{\n\t\tUINT32 TempFormat;\n\t\tBYTE* pTempData = pDstData;\n\t\tUINT32 nTempStep = nDstStep;\n\t\tUINT32 nTotalHeight = nYDst + nDstHeight;\n\n\t\tif (useAlpha)\n\t\t\tTempFormat = PIXEL_FORMAT_BGRA32;\n\t\telse\n\t\t\tTempFormat = PIXEL_FORMAT_BGRX32;\n\n\t\tTempFormat = planar_invert_format(planar, alpha, TempFormat);\n\n\t\tif ((TempFormat != DstFormat) || (nSrcWidth != nDstWidth) || (nSrcHeight != nDstHeight))\n\t\t{\n\t\t\tpTempData = planar->pTempData;\n\t\t\tnTempStep = planar->nTempStep;\n\t\t\tnTotalHeight = planar->maxHeight;\n\t\t}\n\n\t\tif (!rle) /* RAW */\n\t\t{\n\t\t\tif (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,\n\t\t\t                                  nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];\n\t\t\telse /* NoAlpha */\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2];\n\n\t\t\tif ((SrcSize - (srcp - pSrcData)) == 1)\n\t\t\t\tsrcp++; /* pad */\n\t\t}\n\t\telse /* RLE */\n\t\t{\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle(planes[0], rleSizes[0], pTempData, nTempStep, nXDst,\n\t\t\t                                nYDst, nSrcWidth, nSrcHeight, 2, vFlip); /* RedPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus = planar_decompress_plane_rle(planes[1], rleSizes[1], pTempData, nTempStep,\n\t\t\t                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 1,\n\t\t\t                                     vFlip); /* GreenPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle(planes[2], rleSizes[2], pTempData, nTempStep, nXDst,\n\t\t\t                                nYDst, nSrcWidth, nSrcHeight, 0, vFlip); /* BluePlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tsrcp += rleSizes[0] + rleSizes[1] + rleSizes[2];\n\n\t\t\tif (useAlpha)\n\t\t\t{\n\t\t\t\tstatus = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep,\n\t\t\t\t                                     nXDst, nYDst, nSrcWidth, nSrcHeight, 3,\n\t\t\t\t                                     vFlip); /* AlphaPlane */\n\t\t\t}\n\t\t\telse\n\t\t\t\tstatus = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth,\n\t\t\t\t                          nSrcHeight, 3, vFlip);\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rleSizes[3];\n\t\t}\n\n\t\tif (pTempData != pDstData)\n\t\t{\n\t\t\tif (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, w, h, pTempData,\n\t\t\t                        TempFormat, nTempStep, nXDst, nYDst, NULL, FREERDP_FLIP_NONE))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"planar image copy failed\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\telse /* YCoCg */\n\t{\n\t\tUINT32 TempFormat;\n\t\tBYTE* pTempData = planar->pTempData;\n\t\tUINT32 nTempStep = planar->nTempStep;\n\t\tUINT32 nTotalHeight = planar->maxHeight;\n\t\tBYTE* dst = &pDstData[nXDst * FreeRDPGetBytesPerPixel(DstFormat) + nYDst * nDstStep];\n\n\t\tif (useAlpha)\n\t\t\tTempFormat = PIXEL_FORMAT_BGRA32;\n\t\telse\n\t\t\tTempFormat = PIXEL_FORMAT_BGRX32;\n\n\t\tif (!pTempData)\n\t\t\treturn FALSE;\n\n\t\tif (rle) /* RLE encoded data. Decode and handle it like raw data. */\n\t\t{\n\t\t\tBYTE* rleBuffer[4] = { 0 };\n\n\t\t\tif (!planar->rlePlanesBuffer)\n\t\t\t\treturn FALSE;\n\n\t\t\trleBuffer[3] = planar->rlePlanesBuffer;  /* AlphaPlane */\n\t\t\trleBuffer[0] = rleBuffer[3] + planeSize; /* LumaOrRedPlane */\n\t\t\trleBuffer[1] = rleBuffer[0] + planeSize; /* OrangeChromaOrGreenPlane */\n\t\t\trleBuffer[2] = rleBuffer[1] + planeSize; /* GreenChromaOrBluePlane */\n\t\t\tif (useAlpha)\n\t\t\t{\n\t\t\t\tstatus =\n\t\t\t\t    planar_decompress_plane_rle_only(planes[3], rleSizes[3], rleBuffer[3],\n\t\t\t\t                                     rawWidths[3], rawHeights[3]); /* AlphaPlane */\n\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rleSizes[3];\n\n\t\t\tstatus = planar_decompress_plane_rle_only(planes[0], rleSizes[0], rleBuffer[0],\n\t\t\t                                          rawWidths[0], rawHeights[0]); /* LumaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle_only(planes[1], rleSizes[1], rleBuffer[1], rawWidths[1],\n\t\t\t                                     rawHeights[1]); /* OrangeChromaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tstatus =\n\t\t\t    planar_decompress_plane_rle_only(planes[2], rleSizes[2], rleBuffer[2], rawWidths[2],\n\t\t\t                                     rawHeights[2]); /* GreenChromaPlane */\n\n\t\t\tif (status < 0)\n\t\t\t\treturn FALSE;\n\n\t\t\tplanes[0] = rleBuffer[0];\n\t\t\tplanes[1] = rleBuffer[1];\n\t\t\tplanes[2] = rleBuffer[2];\n\t\t\tplanes[3] = rleBuffer[3];\n\t\t}\n\n\t\t/* RAW */\n\t\t{\n\t\t\tif (cs)\n\t\t\t{ /* Chroma subsampling for Co and Cg:\n\t\t\t   * Each pixel contains the value that should be expanded to\n\t\t\t   * [2x,2y;2x+1,2y;2x+1,2y+1;2x;2y+1] */\n\t\t\t\tif (!planar_subsample_expand(planes[1], rawSizes[1], nSrcWidth, nSrcHeight,\n\t\t\t\t                             rawWidths[1], rawHeights[1], planar->deltaPlanes[0]))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tplanes[1] = planar->deltaPlanes[0];\n\t\t\t\trawSizes[1] = planeSize; /* OrangeChromaOrGreenPlane */\n\t\t\t\trawWidths[1] = nSrcWidth;\n\t\t\t\trawHeights[1] = nSrcHeight;\n\n\t\t\t\tif (!planar_subsample_expand(planes[2], rawSizes[2], nSrcWidth, nSrcHeight,\n\t\t\t\t                             rawWidths[2], rawHeights[2], planar->deltaPlanes[1]))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tplanes[2] = planar->deltaPlanes[1];\n\t\t\t\trawSizes[2] = planeSize; /* GreenChromaOrBluePlane */\n\t\t\t\trawWidths[2] = nSrcWidth;\n\t\t\t\trawHeights[2] = nSrcHeight;\n\t\t\t}\n\n\t\t\tif (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst,\n\t\t\t                                  nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (alpha)\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3];\n\t\t\telse /* NoAlpha */\n\t\t\t\tsrcp += rawSizes[0] + rawSizes[1] + rawSizes[2];\n\n\t\t\tif ((SrcSize - (srcp - pSrcData)) == 1)\n\t\t\t\tsrcp++; /* pad */\n\t\t}\n\n\t\tWINPR_ASSERT(prims->YCoCgToRGB_8u_AC4R);\n\t\tint rc = prims->YCoCgToRGB_8u_AC4R(pTempData, nTempStep, dst, DstFormat, nDstStep, w, h,\n\t\t                                   cll, useAlpha);\n\t\tif (rc != PRIMITIVES_SUCCESS)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"YCoCgToRGB_8u_AC4R failed with %d\", rc);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tWINPR_UNUSED(srcp);\n\treturn TRUE;\n}\n\nstatic INLINE BOOL freerdp_split_color_planes(BITMAP_PLANAR_CONTEXT* planar, const BYTE* data,\n                                              UINT32 format, UINT32 width, UINT32 height,\n                                              UINT32 scanline, BYTE* planes[4])\n{\n\tWINPR_ASSERT(planar);\n\n\tif ((width > INT32_MAX) || (height > INT32_MAX) || (scanline > INT32_MAX))\n\t\treturn FALSE;\n\n\tif (scanline == 0)\n\t\tscanline = width * FreeRDPGetBytesPerPixel(format);\n\n\tif (planar->topdown)\n\t{\n\t\tUINT32 i, j, k = 0;\n\t\tfor (i = 0; i < height; i++)\n\t\t{\n\t\t\tconst BYTE* pixel = &data[scanline * (UINT32)i];\n\n\t\t\tfor (j = 0; j < width; j++)\n\t\t\t{\n\t\t\t\tconst UINT32 color = FreeRDPReadColor(pixel, format);\n\t\t\t\tpixel += FreeRDPGetBytesPerPixel(format);\n\t\t\t\tFreeRDPSplitColor(color, format, &planes[1][k], &planes[2][k], &planes[3][k],\n\t\t\t\t                  &planes[0][k], NULL);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tINT64 i;\n\t\tUINT32 j, k = 0;\n\n\t\tfor (i = (INT64)height - 1; i >= 0; i--)\n\t\t{\n\t\t\tconst BYTE* pixel = &data[scanline * (UINT32)i];\n\n\t\t\tfor (j = 0; j < width; j++)\n\t\t\t{\n\t\t\t\tconst UINT32 color = FreeRDPReadColor(pixel, format);\n\t\t\t\tpixel += FreeRDPGetBytesPerPixel(format);\n\t\t\t\tFreeRDPSplitColor(color, format, &planes[1][k], &planes[2][k], &planes[3][k],\n\t\t\t\t                  &planes[0][k], NULL);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nstatic INLINE UINT32 freerdp_bitmap_planar_write_rle_bytes(const BYTE* pInBuffer, UINT32 cRawBytes,\n                                                           UINT32 nRunLength, BYTE* pOutBuffer,\n                                                           UINT32 outBufferSize)\n{\n\tconst BYTE* pInput;\n\tBYTE* pOutput;\n\tBYTE controlByte;\n\tUINT32 nBytesToWrite;\n\tpInput = pInBuffer;\n\tpOutput = pOutBuffer;\n\n\tif (!cRawBytes && !nRunLength)\n\t\treturn 0;\n\n\tif (nRunLength < 3)\n\t{\n\t\tcRawBytes += nRunLength;\n\t\tnRunLength = 0;\n\t}\n\n\twhile (cRawBytes)\n\t{\n\t\tif (cRawBytes < 16)\n\t\t{\n\t\t\tif (nRunLength > 15)\n\t\t\t{\n\t\t\t\tif (nRunLength < 18)\n\t\t\t\t{\n\t\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(13, cRawBytes);\n\t\t\t\t\tnRunLength -= 13;\n\t\t\t\t\tcRawBytes = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(15, cRawBytes);\n\t\t\t\t\tnRunLength -= 15;\n\t\t\t\t\tcRawBytes = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(nRunLength, cRawBytes);\n\t\t\t\tnRunLength = 0;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(0, 15);\n\t\t\tcRawBytes -= 15;\n\t\t}\n\n\t\tif (outBufferSize < 1)\n\t\t\treturn 0;\n\n\t\toutBufferSize--;\n\t\t*pOutput = controlByte;\n\t\tpOutput++;\n\t\tnBytesToWrite = (int)(controlByte >> 4);\n\n\t\tif (nBytesToWrite)\n\t\t{\n\t\t\tif (outBufferSize < nBytesToWrite)\n\t\t\t\treturn 0;\n\n\t\t\toutBufferSize -= nBytesToWrite;\n\t\t\tCopyMemory(pOutput, pInput, nBytesToWrite);\n\t\t\tpOutput += nBytesToWrite;\n\t\t\tpInput += nBytesToWrite;\n\t\t}\n\t}\n\n\twhile (nRunLength)\n\t{\n\t\tif (nRunLength > 47)\n\t\t{\n\t\t\tif (nRunLength < 50)\n\t\t\t{\n\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(2, 13);\n\t\t\t\tnRunLength -= 45;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(2, 15);\n\t\t\t\tnRunLength -= 47;\n\t\t\t}\n\t\t}\n\t\telse if (nRunLength > 31)\n\t\t{\n\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(2, (nRunLength - 32));\n\t\t\tnRunLength = 0;\n\t\t}\n\t\telse if (nRunLength > 15)\n\t\t{\n\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(1, (nRunLength - 16));\n\t\t\tnRunLength = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontrolByte = PLANAR_CONTROL_BYTE(nRunLength, 0);\n\t\t\tnRunLength = 0;\n\t\t}\n\n\t\tif (outBufferSize < 1)\n\t\t\treturn 0;\n\n\t\t--outBufferSize;\n\t\t*pOutput = controlByte;\n\t\tpOutput++;\n\t}\n\n\treturn (pOutput - pOutBuffer);\n}\n\nstatic INLINE UINT32 freerdp_bitmap_planar_encode_rle_bytes(const BYTE* pInBuffer,\n                                                            UINT32 inBufferSize, BYTE* pOutBuffer,\n                                                            UINT32 outBufferSize)\n{\n\tBYTE symbol;\n\tconst BYTE* pInput;\n\tBYTE* pOutput;\n\tconst BYTE* pBytes;\n\tUINT32 cRawBytes;\n\tUINT32 nRunLength;\n\tUINT32 bSymbolMatch;\n\tUINT32 nBytesWritten;\n\tUINT32 nTotalBytesWritten;\n\tsymbol = 0;\n\tcRawBytes = 0;\n\tnRunLength = 0;\n\tpInput = pInBuffer;\n\tpOutput = pOutBuffer;\n\tnTotalBytesWritten = 0;\n\n\tif (!outBufferSize)\n\t\treturn 0;\n\n\tdo\n\t{\n\t\tif (!inBufferSize)\n\t\t\tbreak;\n\n\t\tbSymbolMatch = (symbol == *pInput) ? TRUE : FALSE;\n\t\tsymbol = *pInput;\n\t\tpInput++;\n\t\tinBufferSize--;\n\n\t\tif (nRunLength && !bSymbolMatch)\n\t\t{\n\t\t\tif (nRunLength < 3)\n\t\t\t{\n\t\t\t\tcRawBytes += nRunLength;\n\t\t\t\tnRunLength = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpBytes = pInput - (cRawBytes + nRunLength + 1);\n\t\t\t\tnBytesWritten = freerdp_bitmap_planar_write_rle_bytes(pBytes, cRawBytes, nRunLength,\n\t\t\t\t                                                      pOutput, outBufferSize);\n\t\t\t\tnRunLength = 0;\n\n\t\t\t\tif (!nBytesWritten || (nBytesWritten > outBufferSize))\n\t\t\t\t\treturn nRunLength;\n\n\t\t\t\tnTotalBytesWritten += nBytesWritten;\n\t\t\t\toutBufferSize -= nBytesWritten;\n\t\t\t\tpOutput += nBytesWritten;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t}\n\n\t\tnRunLength += bSymbolMatch;\n\t\tcRawBytes += (!bSymbolMatch) ? TRUE : FALSE;\n\t} while (outBufferSize);\n\n\tif (cRawBytes || nRunLength)\n\t{\n\t\tpBytes = pInput - (cRawBytes + nRunLength);\n\t\tnBytesWritten = freerdp_bitmap_planar_write_rle_bytes(pBytes, cRawBytes, nRunLength,\n\t\t                                                      pOutput, outBufferSize);\n\n\t\tif (!nBytesWritten)\n\t\t\treturn 0;\n\n\t\tnTotalBytesWritten += nBytesWritten;\n\t}\n\n\tif (inBufferSize)\n\t\treturn 0;\n\n\treturn nTotalBytesWritten;\n}\n\nBOOL freerdp_bitmap_planar_compress_plane_rle(const BYTE* inPlane, UINT32 width, UINT32 height,\n                                              BYTE* outPlane, UINT32* dstSize)\n{\n\tUINT32 index;\n\tconst BYTE* pInput;\n\tBYTE* pOutput;\n\tUINT32 outBufferSize;\n\tUINT32 nBytesWritten;\n\tUINT32 nTotalBytesWritten;\n\n\tif (!outPlane)\n\t\treturn FALSE;\n\n\tindex = 0;\n\tpInput = inPlane;\n\tpOutput = outPlane;\n\toutBufferSize = *dstSize;\n\tnTotalBytesWritten = 0;\n\n\twhile (outBufferSize)\n\t{\n\t\tnBytesWritten =\n\t\t    freerdp_bitmap_planar_encode_rle_bytes(pInput, width, pOutput, outBufferSize);\n\n\t\tif ((!nBytesWritten) || (nBytesWritten > outBufferSize))\n\t\t\treturn FALSE;\n\n\t\toutBufferSize -= nBytesWritten;\n\t\tnTotalBytesWritten += nBytesWritten;\n\t\tpOutput += nBytesWritten;\n\t\tpInput += width;\n\t\tindex++;\n\n\t\tif (index >= height)\n\t\t\tbreak;\n\t}\n\n\t*dstSize = nTotalBytesWritten;\n\treturn TRUE;\n}\n\nstatic INLINE BOOL freerdp_bitmap_planar_compress_planes_rle(BYTE* inPlanes[4], UINT32 width,\n                                                             UINT32 height, BYTE* outPlanes,\n                                                             UINT32* dstSizes, BOOL skipAlpha)\n{\n\tUINT32 outPlanesSize = width * height * 4;\n\n\t/* AlphaPlane */\n\tif (skipAlpha)\n\t{\n\t\tdstSizes[0] = 0;\n\t}\n\telse\n\t{\n\t\tdstSizes[0] = outPlanesSize;\n\n\t\tif (!freerdp_bitmap_planar_compress_plane_rle(inPlanes[0], width, height, outPlanes,\n\t\t                                              &dstSizes[0]))\n\t\t\treturn FALSE;\n\n\t\toutPlanes += dstSizes[0];\n\t\toutPlanesSize -= dstSizes[0];\n\t}\n\n\t/* LumaOrRedPlane */\n\tdstSizes[1] = outPlanesSize;\n\n\tif (!freerdp_bitmap_planar_compress_plane_rle(inPlanes[1], width, height, outPlanes,\n\t                                              &dstSizes[1]))\n\t\treturn FALSE;\n\n\toutPlanes += dstSizes[1];\n\toutPlanesSize -= dstSizes[1];\n\t/* OrangeChromaOrGreenPlane */\n\tdstSizes[2] = outPlanesSize;\n\n\tif (!freerdp_bitmap_planar_compress_plane_rle(inPlanes[2], width, height, outPlanes,\n\t                                              &dstSizes[2]))\n\t\treturn FALSE;\n\n\toutPlanes += dstSizes[2];\n\toutPlanesSize -= dstSizes[2];\n\t/* GreenChromeOrBluePlane */\n\tdstSizes[3] = outPlanesSize;\n\n\tif (!freerdp_bitmap_planar_compress_plane_rle(inPlanes[3], width, height, outPlanes,\n\t                                              &dstSizes[3]))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBYTE* freerdp_bitmap_planar_delta_encode_plane(const BYTE* inPlane, UINT32 width, UINT32 height,\n                                               BYTE* outPlane)\n{\n\tchar s2c;\n\tUINT32 y, x;\n\tBYTE* outPtr;\n\tconst BYTE *srcPtr, *prevLinePtr;\n\n\tif (!outPlane)\n\t{\n\t\tif (width * height == 0)\n\t\t\treturn NULL;\n\n\t\tif (!(outPlane = (BYTE*)calloc(height, width)))\n\t\t\treturn NULL;\n\t}\n\n\t// first line is copied as is\n\tCopyMemory(outPlane, inPlane, width);\n\toutPtr = outPlane + width;\n\tsrcPtr = inPlane + width;\n\tprevLinePtr = inPlane;\n\n\tfor (y = 1; y < height; y++)\n\t{\n\t\tfor (x = 0; x < width; x++, outPtr++, srcPtr++, prevLinePtr++)\n\t\t{\n\t\t\tINT32 delta = *srcPtr - *prevLinePtr;\n\t\t\ts2c = (delta >= 0) ? (char)delta : (char)(~((BYTE)(-delta)) + 1);\n\t\t\ts2c = (s2c >= 0) ? (char)((UINT32)s2c << 1)\n\t\t\t                 : (char)(((UINT32)(~((BYTE)s2c) + 1) << 1) - 1);\n\t\t\t*outPtr = (BYTE)s2c;\n\t\t}\n\t}\n\n\treturn outPlane;\n}\n\nstatic INLINE BOOL freerdp_bitmap_planar_delta_encode_planes(BYTE* inPlanes[4], UINT32 width,\n                                                             UINT32 height, BYTE* outPlanes[4])\n{\n\tUINT32 i;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toutPlanes[i] =\n\t\t    freerdp_bitmap_planar_delta_encode_plane(inPlanes[i], width, height, outPlanes[i]);\n\n\t\tif (!outPlanes[i])\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBYTE* freerdp_bitmap_compress_planar(BITMAP_PLANAR_CONTEXT* context, const BYTE* data,\n                                     UINT32 format, UINT32 width, UINT32 height, UINT32 scanline,\n                                     BYTE* dstData, UINT32* pDstSize)\n{\n\tUINT32 size;\n\tBYTE* dstp;\n\tUINT32 planeSize;\n\tUINT32 dstSizes[4] = { 0 };\n\tBYTE FormatHeader = 0;\n\n\tif (!context || !context->rlePlanesBuffer)\n\t\treturn NULL;\n\n\tif (context->AllowSkipAlpha)\n\t\tFormatHeader |= PLANAR_FORMAT_HEADER_NA;\n\n\tplaneSize = width * height;\n\n\tif (!context->AllowSkipAlpha)\n\t\tformat = planar_invert_format(context, TRUE, format);\n\n\tif (!freerdp_split_color_planes(context, data, format, width, height, scanline,\n\t                                context->planes))\n\t\treturn NULL;\n\n\tif (context->AllowRunLengthEncoding)\n\t{\n\t\tif (!freerdp_bitmap_planar_delta_encode_planes(context->planes, width, height,\n\t\t                                               context->deltaPlanes))\n\t\t\treturn NULL;\n\n\t\tif (!freerdp_bitmap_planar_compress_planes_rle(context->deltaPlanes, width, height,\n\t\t                                               context->rlePlanesBuffer, dstSizes,\n\t\t                                               context->AllowSkipAlpha))\n\t\t\treturn NULL;\n\n\t\t{\n\t\t\tint offset = 0;\n\t\t\tFormatHeader |= PLANAR_FORMAT_HEADER_RLE;\n\t\t\tcontext->rlePlanes[0] = &context->rlePlanesBuffer[offset];\n\t\t\toffset += dstSizes[0];\n\t\t\tcontext->rlePlanes[1] = &context->rlePlanesBuffer[offset];\n\t\t\toffset += dstSizes[1];\n\t\t\tcontext->rlePlanes[2] = &context->rlePlanesBuffer[offset];\n\t\t\toffset += dstSizes[2];\n\t\t\tcontext->rlePlanes[3] = &context->rlePlanesBuffer[offset];\n\n#if defined(WITH_DEBUG_CODECS)\n\t\t\tWLog_DBG(TAG,\n\t\t\t         \"R: [%\" PRIu32 \"/%\" PRIu32 \"] G: [%\" PRIu32 \"/%\" PRIu32 \"] B: [%\" PRIu32\n\t\t\t         \" / %\" PRIu32 \"] \",\n\t\t\t         dstSizes[1], planeSize, dstSizes[2], planeSize, dstSizes[3], planeSize);\n#endif\n\t\t}\n\t}\n\n\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t{\n\t\tif (!context->AllowRunLengthEncoding)\n\t\t\treturn NULL;\n\n\t\tif (context->rlePlanes[0] == NULL)\n\t\t\treturn NULL;\n\n\t\tif (context->rlePlanes[1] == NULL)\n\t\t\treturn NULL;\n\n\t\tif (context->rlePlanes[2] == NULL)\n\t\t\treturn NULL;\n\n\t\tif (context->rlePlanes[3] == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tif (!dstData)\n\t{\n\t\tsize = 1;\n\n\t\tif (!(FormatHeader & PLANAR_FORMAT_HEADER_NA))\n\t\t{\n\t\t\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t\t\t\tsize += dstSizes[0];\n\t\t\telse\n\t\t\t\tsize += planeSize;\n\t\t}\n\n\t\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t\t\tsize += (dstSizes[1] + dstSizes[2] + dstSizes[3]);\n\t\telse\n\t\t\tsize += (planeSize * 3);\n\n\t\tif (!(FormatHeader & PLANAR_FORMAT_HEADER_RLE))\n\t\t\tsize++;\n\n\t\tdstData = malloc(size);\n\n\t\tif (!dstData)\n\t\t\treturn NULL;\n\n\t\t*pDstSize = size;\n\t}\n\n\tdstp = dstData;\n\t*dstp = FormatHeader; /* FormatHeader */\n\tdstp++;\n\n\t/* AlphaPlane */\n\n\tif (!(FormatHeader & PLANAR_FORMAT_HEADER_NA))\n\t{\n\t\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t\t{\n\t\t\tCopyMemory(dstp, context->rlePlanes[0], dstSizes[0]); /* Alpha */\n\t\t\tdstp += dstSizes[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCopyMemory(dstp, context->planes[0], planeSize); /* Alpha */\n\t\t\tdstp += planeSize;\n\t\t}\n\t}\n\n\t/* LumaOrRedPlane */\n\n\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t{\n\t\tCopyMemory(dstp, context->rlePlanes[1], dstSizes[1]); /* Red */\n\t\tdstp += dstSizes[1];\n\t}\n\telse\n\t{\n\t\tCopyMemory(dstp, context->planes[1], planeSize); /* Red */\n\t\tdstp += planeSize;\n\t}\n\n\t/* OrangeChromaOrGreenPlane */\n\n\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t{\n\t\tCopyMemory(dstp, context->rlePlanes[2], dstSizes[2]); /* Green */\n\t\tdstp += dstSizes[2];\n\t}\n\telse\n\t{\n\t\tCopyMemory(dstp, context->planes[2], planeSize); /* Green */\n\t\tdstp += planeSize;\n\t}\n\n\t/* GreenChromeOrBluePlane */\n\n\tif (FormatHeader & PLANAR_FORMAT_HEADER_RLE)\n\t{\n\t\tCopyMemory(dstp, context->rlePlanes[3], dstSizes[3]); /* Blue */\n\t\tdstp += dstSizes[3];\n\t}\n\telse\n\t{\n\t\tCopyMemory(dstp, context->planes[3], planeSize); /* Blue */\n\t\tdstp += planeSize;\n\t}\n\n\t/* Pad1 (1 byte) */\n\n\tif (!(FormatHeader & PLANAR_FORMAT_HEADER_RLE))\n\t{\n\t\t*dstp = 0;\n\t\tdstp++;\n\t}\n\n\tsize = (dstp - dstData);\n\t*pDstSize = size;\n\treturn dstData;\n}\n\nBOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\n\tmemset(context->planes, 0, sizeof(context->planes));\n\tmemset(context->rlePlanes, 0, sizeof(context->rlePlanes));\n\tmemset(context->deltaPlanes, 0, sizeof(context->deltaPlanes));\n\n\tif (context->maxPlaneSize > 0)\n\t{\n\t\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->planesBuffer = tmp;\n\n\t\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->pTempData = tmp;\n\n\t\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->deltaPlanesBuffer = tmp;\n\n\t\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->rlePlanesBuffer = tmp;\n\n\t\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\t\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\t}\n\treturn TRUE;\n}\n\nBITMAP_PLANAR_CONTEXT* freerdp_bitmap_planar_context_new(DWORD flags, UINT32 maxWidth,\n                                                         UINT32 maxHeight)\n{\n\tBITMAP_PLANAR_CONTEXT* context =\n\t    (BITMAP_PLANAR_CONTEXT*)winpr_aligned_calloc(1, sizeof(BITMAP_PLANAR_CONTEXT), 32);\n\n\tif (!context)\n\t\treturn NULL;\n\n\tif (flags & PLANAR_FORMAT_HEADER_NA)\n\t\tcontext->AllowSkipAlpha = TRUE;\n\n\tif (flags & PLANAR_FORMAT_HEADER_RLE)\n\t\tcontext->AllowRunLengthEncoding = TRUE;\n\n\tif (flags & PLANAR_FORMAT_HEADER_CS)\n\t\tcontext->AllowColorSubsampling = TRUE;\n\n\tcontext->ColorLossLevel = flags & PLANAR_FORMAT_HEADER_CLL_MASK;\n\n\tif (context->ColorLossLevel)\n\t\tcontext->AllowDynamicColorFidelity = TRUE;\n\n\tif (!freerdp_bitmap_planar_context_reset(context, maxWidth, maxHeight))\n\t{\n\t\tfreerdp_bitmap_planar_context_free(context);\n\t\treturn NULL;\n\t}\n\n\treturn context;\n}\n\nvoid freerdp_bitmap_planar_context_free(BITMAP_PLANAR_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn;\n\n\twinpr_aligned_free(context->pTempData);\n\twinpr_aligned_free(context->planesBuffer);\n\twinpr_aligned_free(context->deltaPlanesBuffer);\n\twinpr_aligned_free(context->rlePlanesBuffer);\n\twinpr_aligned_free(context);\n}\n\nvoid freerdp_planar_switch_bgr(BITMAP_PLANAR_CONTEXT* planar, BOOL bgr)\n{\n\tWINPR_ASSERT(planar);\n\tplanar->bgr = bgr;\n}\n\nvoid freerdp_planar_topdown_image(BITMAP_PLANAR_CONTEXT* planar, BOOL topdown)\n{\n\tWINPR_ASSERT(planar);\n\tplanar->topdown = topdown;\n}\n"], "filenames": ["libfreerdp/codec/planar.c"], "buggy_code_start_loc": [980], "buggy_code_end_loc": [1688], "fixing_code_start_loc": [979], "fixing_code_end_loc": [1696], "type": "CWE-416", "message": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. Versions of FreeRDP on the 3.x release branch before beta3 are subject to a Use-After-Free in processing `RDPGFX_CMDID_RESETGRAPHICS` packets. If `context->maxPlaneSize` is 0, `context->planesBuffer` will be freed. However, without updating `context->planesBuffer`, this leads to a Use-After-Free exploit vector. In most environments this should only result in a crash. This issue has been addressed in version 3.0.0-beta3 and users of the beta 3.x releases are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-39355", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-31T20:15:08.457", "lastModified": "2024-01-12T13:15:10.440", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. Versions of FreeRDP on the 3.x release branch before beta3 are subject to a Use-After-Free in processing `RDPGFX_CMDID_RESETGRAPHICS` packets. If `context->maxPlaneSize` is 0, `context->planesBuffer` will be freed. However, without updating `context->planesBuffer`, this leads to a Use-After-Free exploit vector. In most environments this should only result in a crash. This issue has been addressed in version 3.0.0-beta3 and users of the beta 3.x releases are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:3.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "D8720D61-0B0D-40ED-B3C4-B452D83BF3C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:3.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "18A75D02-0E7A-4AAF-8E23-0CDCB1733FEA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/d6f9d33a7db0b346195b6a15b5b99944ba41beee", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-hvwj-vmg6-2f5h", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00008.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202401-16", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/d6f9d33a7db0b346195b6a15b5b99944ba41beee"}}