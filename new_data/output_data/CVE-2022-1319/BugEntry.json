{"buggy_code": ["/*\n * JBoss, Home of Professional Open Source.\n * Copyright 2014 Red Hat, Inc., and individual contributors\n * as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage io.undertow.server.protocol.ajp;\n\nimport io.undertow.UndertowLogger;\nimport io.undertow.UndertowOptions;\nimport io.undertow.conduits.ConduitListener;\nimport io.undertow.conduits.EmptyStreamSourceConduit;\nimport io.undertow.conduits.ReadDataStreamSourceConduit;\nimport io.undertow.server.AbstractServerConnection;\nimport io.undertow.server.ConnectorStatisticsImpl;\nimport io.undertow.server.Connectors;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.server.protocol.ParseTimeoutUpdater;\nimport io.undertow.util.HeaderMap;\nimport io.undertow.util.Headers;\nimport io.undertow.util.HttpString;\nimport io.undertow.util.Methods;\nimport org.xnio.ChannelListener;\nimport io.undertow.connector.PooledByteBuffer;\nimport io.undertow.util.StatusCodes;\nimport io.undertow.util.BadRequestException;\nimport org.xnio.StreamConnection;\nimport org.xnio.channels.StreamSinkChannel;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.ConduitStreamSourceChannel;\nimport org.xnio.conduits.StreamSourceConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport static org.xnio.IoUtils.safeClose;\n\n/**\n * @author Stuart Douglas\n */\n\nfinal class AjpReadListener implements ChannelListener<StreamSourceChannel> {\n\n    private static final byte[] CPONG = {'A', 'B', 0, 1, 9};\n    private static final byte[] SEND_HEADERS_INTERNAL_SERVER_ERROR_MSG = {'A', 'B', 0, 8, 4, (byte)((500 >> 8) & 0xFF) , (byte)(500 & 0xFF), 0, 0, '\\0', 0, 0};\n    private static final byte[] SEND_HEADERS_BAD_REQUEST_MSG = {'A', 'B', 0, 8, 4, (byte)((400 >> 8) & 0xFF) , (byte)(400 & 0xFF), 0, 0, '\\0', 0, 0};\n    private static final byte[] END_RESPONSE = {'A', 'B', 0, 2, 5, 1};\n\n    private final AjpServerConnection connection;\n    private final String scheme;\n    private final boolean recordRequestStartTime;\n    private AjpRequestParseState state = new AjpRequestParseState();\n    private HttpServerExchange httpServerExchange;\n\n    private volatile int read = 0;\n    private final int maxRequestSize;\n    private final long maxEntitySize;\n    private final AjpRequestParser parser;\n    private final ConnectorStatisticsImpl connectorStatistics;\n    private WriteReadyHandler.ChannelListenerHandler<ConduitStreamSinkChannel> writeReadyHandler;\n\n    private ParseTimeoutUpdater parseTimeoutUpdater;\n\n    AjpReadListener(final AjpServerConnection connection, final String scheme, AjpRequestParser parser, ConnectorStatisticsImpl connectorStatistics) {\n        this.connection = connection;\n        this.scheme = scheme;\n        this.parser = parser;\n        this.connectorStatistics = connectorStatistics;\n        this.maxRequestSize = connection.getUndertowOptions().get(UndertowOptions.MAX_HEADER_SIZE, UndertowOptions.DEFAULT_MAX_HEADER_SIZE);\n        this.maxEntitySize = connection.getUndertowOptions().get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);\n        this.writeReadyHandler = new WriteReadyHandler.ChannelListenerHandler<>(connection.getChannel().getSinkChannel());\n        this.recordRequestStartTime = connection.getUndertowOptions().get(UndertowOptions.RECORD_REQUEST_START_TIME, false);\n        int requestParseTimeout = connection.getUndertowOptions().get(UndertowOptions.REQUEST_PARSE_TIMEOUT, -1);\n        int requestIdleTimeout = connection.getUndertowOptions().get(UndertowOptions.NO_REQUEST_TIMEOUT, -1);\n        if(requestIdleTimeout < 0 && requestParseTimeout < 0) {\n            this.parseTimeoutUpdater = null;\n        } else {\n            this.parseTimeoutUpdater = new ParseTimeoutUpdater(connection, requestParseTimeout, requestIdleTimeout);\n            connection.addCloseListener(parseTimeoutUpdater);\n        }\n    }\n\n    public void startRequest() {\n        connection.resetChannel();\n        state = new AjpRequestParseState();\n        read = 0;\n        if(parseTimeoutUpdater != null) {\n            parseTimeoutUpdater.connectionIdle();\n        }\n        connection.setCurrentExchange(null);\n    }\n\n    public void handleEvent(final StreamSourceChannel channel) {\n        if(connection.getOriginalSinkConduit().isWriteShutdown() || connection.getOriginalSourceConduit().isReadShutdown()) {\n            safeClose(connection);\n            channel.suspendReads();\n            return;\n        }\n\n        PooledByteBuffer existing = connection.getExtraBytes();\n\n        final PooledByteBuffer pooled = existing == null ? connection.getByteBufferPool().allocate() : existing;\n        final ByteBuffer buffer = pooled.getBuffer();\n        boolean free = true;\n        boolean bytesRead = false;\n        try {\n            int res;\n            do {\n                if (existing == null) {\n                    buffer.clear();\n                    res = channel.read(buffer);\n                } else {\n                    res = buffer.remaining();\n                }\n                if (res == 0) {\n\n                    if(bytesRead && parseTimeoutUpdater != null) {\n                        parseTimeoutUpdater.failedParse();\n                    }\n                    if (!channel.isReadResumed()) {\n                        channel.getReadSetter().set(this);\n                        channel.resumeReads();\n                    }\n                    return;\n                }\n                if (res == -1) {\n                    channel.shutdownReads();\n                    final StreamSinkChannel responseChannel = connection.getChannel().getSinkChannel();\n                    responseChannel.shutdownWrites();\n                    safeClose(connection);\n                    return;\n                }\n                bytesRead = true;\n                //TODO: we need to handle parse errors\n                if (existing != null) {\n                    existing = null;\n                    connection.setExtraBytes(null);\n                } else {\n                    buffer.flip();\n                }\n                int begin = buffer.remaining();\n                if(httpServerExchange == null) {\n                    httpServerExchange = new HttpServerExchange(connection, maxEntitySize);\n                }\n                parser.parse(buffer, state, httpServerExchange);\n\n                read += begin - buffer.remaining();\n                if (buffer.hasRemaining()) {\n                    free = false;\n                    connection.setExtraBytes(pooled);\n                }\n                if (read > maxRequestSize) {\n                    UndertowLogger.REQUEST_LOGGER.requestHeaderWasTooLarge(connection.getPeerAddress(), maxRequestSize);\n                    safeClose(connection);\n                    return;\n                }\n            } while (!state.isComplete());\n\n            if(parseTimeoutUpdater != null) {\n                parseTimeoutUpdater.requestStarted();\n            }\n            if (state.prefix != AjpRequestParser.FORWARD_REQUEST) {\n                if (state.prefix == AjpRequestParser.CPING) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPING, sending CPONG\");\n                    handleCPing();\n                } else if (state.prefix == AjpRequestParser.CPONG) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPONG, starting next request\");\n                    state = new AjpRequestParseState();\n                    channel.getReadSetter().set(this);\n                    channel.resumeReads();\n                } else {\n                    UndertowLogger.REQUEST_LOGGER.ignoringAjpRequestWithPrefixCode(state.prefix);\n                    safeClose(connection);\n                }\n                return;\n            }\n\n            // we remove ourselves as the read listener from the channel;\n            // if the http handler doesn't set any then reads will suspend, which is the right thing to do\n            channel.getReadSetter().set(null);\n            channel.suspendReads();\n\n            final HttpServerExchange httpServerExchange = this.httpServerExchange;\n            final AjpServerResponseConduit responseConduit = new AjpServerResponseConduit(connection.getChannel().getSinkChannel().getConduit(), connection.getByteBufferPool(), httpServerExchange, new ConduitListener<AjpServerResponseConduit>() {\n                @Override\n                public void handleEvent(AjpServerResponseConduit channel) {\n                    Connectors.terminateResponse(httpServerExchange);\n                }\n            }, httpServerExchange.getRequestMethod().equals(Methods.HEAD));\n            connection.getChannel().getSinkChannel().setConduit(responseConduit);\n            connection.getChannel().getSourceChannel().setConduit(createSourceConduit(connection.getChannel().getSourceChannel().getConduit(), responseConduit, httpServerExchange));\n            //we need to set the write ready handler. This allows the response conduit to wrap it\n            responseConduit.setWriteReadyHandler(writeReadyHandler);\n\n            connection.setSSLSessionInfo(state.createSslSessionInfo());\n            httpServerExchange.setSourceAddress(state.createPeerAddress());\n            httpServerExchange.setDestinationAddress(state.createDestinationAddress());\n            if(scheme != null) {\n                httpServerExchange.setRequestScheme(scheme);\n            }\n            if(state.attributes != null) {\n                httpServerExchange.putAttachment(HttpServerExchange.REQUEST_ATTRIBUTES, state.attributes);\n            }\n            AjpRequestParseState oldState = state;\n            state = null;\n            this.httpServerExchange = null;\n            httpServerExchange.setPersistent(true);\n\n            if(recordRequestStartTime) {\n                Connectors.setRequestStartTime(httpServerExchange);\n            }\n            connection.setCurrentExchange(httpServerExchange);\n            if(connectorStatistics != null) {\n                connectorStatistics.setup(httpServerExchange);\n            }\n            if(!Connectors.areRequestHeadersValid(httpServerExchange.getRequestHeaders())) {\n                oldState.badRequest = true;\n                UndertowLogger.REQUEST_IO_LOGGER.debugf(\"Invalid AJP request from %s, request contained invalid headers\", connection.getPeerAddress());\n            }\n\n            if(oldState.badRequest) {\n                httpServerExchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                httpServerExchange.endExchange();\n                handleBadRequest();\n                safeClose(connection);\n            } else {\n                Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);\n            }\n        } catch (BadRequestException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.failedToParseRequest(e);\n            handleBadRequest();\n            safeClose(connection);\n        } catch (IOException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n            handleInternalServerError();\n            safeClose(connection);\n        } catch (Throwable t) {\n            UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(t);\n            handleInternalServerError();\n            safeClose(connection);\n        } finally {\n            if (free) pooled.close();\n        }\n    }\n\n    private void handleInternalServerError() {\n        sendMessages(SEND_HEADERS_INTERNAL_SERVER_ERROR_MSG, END_RESPONSE);\n    }\n\n    private void handleBadRequest() {\n        sendMessages(SEND_HEADERS_BAD_REQUEST_MSG, END_RESPONSE);\n    }\n\n    private void handleCPing() {\n        if (sendMessages(CPONG)) {\n            AjpReadListener.this.handleEvent(connection.getChannel().getSourceChannel());\n        }\n    }\n\n    private boolean sendMessages(final byte[]... rawMessages) {\n        state = new AjpRequestParseState();\n        final StreamConnection underlyingChannel = connection.getChannel();\n        underlyingChannel.getSourceChannel().suspendReads();\n        // detect buffer size\n        int bufferSize = 0;\n        for (int i = 0; i < rawMessages.length; i++) {\n            bufferSize += rawMessages[i].length;\n        }\n        // fill in buffer\n        final ByteBuffer buffer = ByteBuffer.allocate(bufferSize);\n        for (int i = 0; i < rawMessages.length; i++) {\n            buffer.put(rawMessages[i]);\n        }\n        buffer.flip();\n        // send buffer content\n        int res;\n        try {\n            do {\n                res = underlyingChannel.getSinkChannel().write(buffer);\n                if (res == 0) {\n                    underlyingChannel.getSinkChannel().setWriteListener(new ChannelListener<ConduitStreamSinkChannel>() {\n                        @Override\n                        public void handleEvent(ConduitStreamSinkChannel channel) {\n                            int res;\n                            do {\n                                try {\n                                    res = channel.write(buffer);\n                                    if (res == 0) {\n                                        return;\n                                    }\n                                } catch (IOException e) {\n                                    UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n                                    safeClose(connection);\n                                }\n                            } while (buffer.hasRemaining());\n                            channel.suspendWrites();\n                            AjpReadListener.this.handleEvent(underlyingChannel.getSourceChannel());\n                        }\n                    });\n                    underlyingChannel.getSinkChannel().resumeWrites();\n                    return false;\n                }\n            } while (buffer.hasRemaining());\n            return true;\n        } catch (IOException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n            safeClose(connection);\n            return false;\n        }\n    }\n\n    public void exchangeComplete(final HttpServerExchange exchange) {\n        if (!exchange.isUpgrade() && exchange.isPersistent()) {\n            startRequest();\n            ConduitStreamSourceChannel channel = ((AjpServerConnection) exchange.getConnection()).getChannel().getSourceChannel();\n            channel.getReadSetter().set(this);\n            channel.wakeupReads();\n        } else if(!exchange.isPersistent()) {\n            safeClose(exchange.getConnection());\n        }\n    }\n\n    private StreamSourceConduit createSourceConduit(StreamSourceConduit underlyingConduit, AjpServerResponseConduit responseConduit, final HttpServerExchange exchange) throws BadRequestException {\n\n        ReadDataStreamSourceConduit conduit = new ReadDataStreamSourceConduit(underlyingConduit, (AbstractServerConnection) exchange.getConnection());\n\n        final HeaderMap requestHeaders = exchange.getRequestHeaders();\n        HttpString transferEncoding = Headers.IDENTITY;\n        Long length;\n        final String teHeader = requestHeaders.getLast(Headers.TRANSFER_ENCODING);\n        boolean hasTransferEncoding = teHeader != null;\n        if (hasTransferEncoding) {\n            transferEncoding = new HttpString(teHeader);\n        }\n        final String requestContentLength = requestHeaders.getFirst(Headers.CONTENT_LENGTH);\n        if (hasTransferEncoding && !transferEncoding.equals(Headers.IDENTITY)) {\n            length = null; //unknown length\n        } else if (requestContentLength != null) {\n            try {\n                final long contentLength = Long.parseLong(requestContentLength);\n                if (contentLength == 0L) {\n                    UndertowLogger.REQUEST_LOGGER.trace(\"No content, starting next request\");\n                    // no content - immediately start the next request, returning an empty stream for this one\n                    Connectors.terminateRequest(httpServerExchange);\n                    return new EmptyStreamSourceConduit(conduit.getReadThread());\n                } else {\n                    length = contentLength;\n                }\n            } catch (NumberFormatException e) {\n                throw new BadRequestException(\"Invalid Content-Length header\", e);\n            }\n        } else {\n            UndertowLogger.REQUEST_LOGGER.trace(\"No content length or transfer coding, starting next request\");\n            // no content - immediately start the next request, returning an empty stream for this one\n            Connectors.terminateRequest(exchange);\n            return new EmptyStreamSourceConduit(conduit.getReadThread());\n        }\n        return new AjpServerRequestConduit(conduit, exchange, responseConduit, length, new ConduitListener<AjpServerRequestConduit>() {\n            @Override\n            public void handleEvent(AjpServerRequestConduit channel) {\n                Connectors.terminateRequest(exchange);\n            }\n        });\n    }\n\n}\n"], "fixing_code": ["/*\n * JBoss, Home of Professional Open Source.\n * Copyright 2014 Red Hat, Inc., and individual contributors\n * as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage io.undertow.server.protocol.ajp;\n\nimport io.undertow.UndertowLogger;\nimport io.undertow.UndertowOptions;\nimport io.undertow.conduits.ConduitListener;\nimport io.undertow.conduits.EmptyStreamSourceConduit;\nimport io.undertow.conduits.ReadDataStreamSourceConduit;\nimport io.undertow.server.AbstractServerConnection;\nimport io.undertow.server.ConnectorStatisticsImpl;\nimport io.undertow.server.Connectors;\nimport io.undertow.server.HttpServerExchange;\nimport io.undertow.server.protocol.ParseTimeoutUpdater;\nimport io.undertow.util.HeaderMap;\nimport io.undertow.util.Headers;\nimport io.undertow.util.HttpString;\nimport io.undertow.util.Methods;\nimport org.xnio.ChannelListener;\nimport io.undertow.connector.PooledByteBuffer;\nimport io.undertow.util.StatusCodes;\nimport io.undertow.util.BadRequestException;\nimport org.xnio.StreamConnection;\nimport org.xnio.channels.StreamSinkChannel;\nimport org.xnio.channels.StreamSourceChannel;\nimport org.xnio.conduits.ConduitStreamSinkChannel;\nimport org.xnio.conduits.ConduitStreamSourceChannel;\nimport org.xnio.conduits.StreamSourceConduit;\nimport org.xnio.conduits.WriteReadyHandler;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\n\nimport static org.xnio.IoUtils.safeClose;\n\n/**\n * @author Stuart Douglas\n */\n\nfinal class AjpReadListener implements ChannelListener<StreamSourceChannel> {\n\n    private static final byte[] CPONG = {'A', 'B', 0, 1, 9};\n    private static final byte[] SEND_HEADERS_INTERNAL_SERVER_ERROR_MSG = {'A', 'B', 0, 8, 4, (byte)((500 >> 8) & 0xFF) , (byte)(500 & 0xFF), 0, 0, '\\0', 0, 0};\n    private static final byte[] SEND_HEADERS_BAD_REQUEST_MSG = {'A', 'B', 0, 8, 4, (byte)((400 >> 8) & 0xFF) , (byte)(400 & 0xFF), 0, 0, '\\0', 0, 0};\n    private static final byte[] END_RESPONSE = {'A', 'B', 0, 2, 5, 0};\n\n    private final AjpServerConnection connection;\n    private final String scheme;\n    private final boolean recordRequestStartTime;\n    private AjpRequestParseState state = new AjpRequestParseState();\n    private HttpServerExchange httpServerExchange;\n\n    private volatile int read = 0;\n    private final int maxRequestSize;\n    private final long maxEntitySize;\n    private final AjpRequestParser parser;\n    private final ConnectorStatisticsImpl connectorStatistics;\n    private WriteReadyHandler.ChannelListenerHandler<ConduitStreamSinkChannel> writeReadyHandler;\n\n    private ParseTimeoutUpdater parseTimeoutUpdater;\n\n    AjpReadListener(final AjpServerConnection connection, final String scheme, AjpRequestParser parser, ConnectorStatisticsImpl connectorStatistics) {\n        this.connection = connection;\n        this.scheme = scheme;\n        this.parser = parser;\n        this.connectorStatistics = connectorStatistics;\n        this.maxRequestSize = connection.getUndertowOptions().get(UndertowOptions.MAX_HEADER_SIZE, UndertowOptions.DEFAULT_MAX_HEADER_SIZE);\n        this.maxEntitySize = connection.getUndertowOptions().get(UndertowOptions.MAX_ENTITY_SIZE, UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);\n        this.writeReadyHandler = new WriteReadyHandler.ChannelListenerHandler<>(connection.getChannel().getSinkChannel());\n        this.recordRequestStartTime = connection.getUndertowOptions().get(UndertowOptions.RECORD_REQUEST_START_TIME, false);\n        int requestParseTimeout = connection.getUndertowOptions().get(UndertowOptions.REQUEST_PARSE_TIMEOUT, -1);\n        int requestIdleTimeout = connection.getUndertowOptions().get(UndertowOptions.NO_REQUEST_TIMEOUT, -1);\n        if(requestIdleTimeout < 0 && requestParseTimeout < 0) {\n            this.parseTimeoutUpdater = null;\n        } else {\n            this.parseTimeoutUpdater = new ParseTimeoutUpdater(connection, requestParseTimeout, requestIdleTimeout);\n            connection.addCloseListener(parseTimeoutUpdater);\n        }\n    }\n\n    public void startRequest() {\n        connection.resetChannel();\n        state = new AjpRequestParseState();\n        read = 0;\n        if(parseTimeoutUpdater != null) {\n            parseTimeoutUpdater.connectionIdle();\n        }\n        connection.setCurrentExchange(null);\n    }\n\n    public void handleEvent(final StreamSourceChannel channel) {\n        if(connection.getOriginalSinkConduit().isWriteShutdown() || connection.getOriginalSourceConduit().isReadShutdown()) {\n            safeClose(connection);\n            channel.suspendReads();\n            return;\n        }\n\n        PooledByteBuffer existing = connection.getExtraBytes();\n\n        final PooledByteBuffer pooled = existing == null ? connection.getByteBufferPool().allocate() : existing;\n        final ByteBuffer buffer = pooled.getBuffer();\n        boolean free = true;\n        boolean bytesRead = false;\n        try {\n            int res;\n            do {\n                if (existing == null) {\n                    buffer.clear();\n                    res = channel.read(buffer);\n                } else {\n                    res = buffer.remaining();\n                }\n                if (res == 0) {\n\n                    if(bytesRead && parseTimeoutUpdater != null) {\n                        parseTimeoutUpdater.failedParse();\n                    }\n                    if (!channel.isReadResumed()) {\n                        channel.getReadSetter().set(this);\n                        channel.resumeReads();\n                    }\n                    return;\n                }\n                if (res == -1) {\n                    channel.shutdownReads();\n                    final StreamSinkChannel responseChannel = connection.getChannel().getSinkChannel();\n                    responseChannel.shutdownWrites();\n                    safeClose(connection);\n                    return;\n                }\n                bytesRead = true;\n                //TODO: we need to handle parse errors\n                if (existing != null) {\n                    existing = null;\n                    connection.setExtraBytes(null);\n                } else {\n                    buffer.flip();\n                }\n                int begin = buffer.remaining();\n                if(httpServerExchange == null) {\n                    httpServerExchange = new HttpServerExchange(connection, maxEntitySize);\n                }\n                parser.parse(buffer, state, httpServerExchange);\n\n                read += begin - buffer.remaining();\n                if (buffer.hasRemaining()) {\n                    free = false;\n                    connection.setExtraBytes(pooled);\n                }\n                if (read > maxRequestSize) {\n                    UndertowLogger.REQUEST_LOGGER.requestHeaderWasTooLarge(connection.getPeerAddress(), maxRequestSize);\n                    safeClose(connection);\n                    return;\n                }\n            } while (!state.isComplete());\n\n            if(parseTimeoutUpdater != null) {\n                parseTimeoutUpdater.requestStarted();\n            }\n            if (state.prefix != AjpRequestParser.FORWARD_REQUEST) {\n                if (state.prefix == AjpRequestParser.CPING) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPING, sending CPONG\");\n                    handleCPing();\n                } else if (state.prefix == AjpRequestParser.CPONG) {\n                    UndertowLogger.REQUEST_LOGGER.debug(\"Received CPONG, starting next request\");\n                    state = new AjpRequestParseState();\n                    channel.getReadSetter().set(this);\n                    channel.resumeReads();\n                } else {\n                    UndertowLogger.REQUEST_LOGGER.ignoringAjpRequestWithPrefixCode(state.prefix);\n                    safeClose(connection);\n                }\n                return;\n            }\n\n            // we remove ourselves as the read listener from the channel;\n            // if the http handler doesn't set any then reads will suspend, which is the right thing to do\n            channel.getReadSetter().set(null);\n            channel.suspendReads();\n\n            final HttpServerExchange httpServerExchange = this.httpServerExchange;\n            final AjpServerResponseConduit responseConduit = new AjpServerResponseConduit(connection.getChannel().getSinkChannel().getConduit(), connection.getByteBufferPool(), httpServerExchange, new ConduitListener<AjpServerResponseConduit>() {\n                @Override\n                public void handleEvent(AjpServerResponseConduit channel) {\n                    Connectors.terminateResponse(httpServerExchange);\n                }\n            }, httpServerExchange.getRequestMethod().equals(Methods.HEAD));\n            connection.getChannel().getSinkChannel().setConduit(responseConduit);\n            connection.getChannel().getSourceChannel().setConduit(createSourceConduit(connection.getChannel().getSourceChannel().getConduit(), responseConduit, httpServerExchange));\n            //we need to set the write ready handler. This allows the response conduit to wrap it\n            responseConduit.setWriteReadyHandler(writeReadyHandler);\n\n            connection.setSSLSessionInfo(state.createSslSessionInfo());\n            httpServerExchange.setSourceAddress(state.createPeerAddress());\n            httpServerExchange.setDestinationAddress(state.createDestinationAddress());\n            if(scheme != null) {\n                httpServerExchange.setRequestScheme(scheme);\n            }\n            if(state.attributes != null) {\n                httpServerExchange.putAttachment(HttpServerExchange.REQUEST_ATTRIBUTES, state.attributes);\n            }\n            AjpRequestParseState oldState = state;\n            state = null;\n            this.httpServerExchange = null;\n            httpServerExchange.setPersistent(true);\n\n            if(recordRequestStartTime) {\n                Connectors.setRequestStartTime(httpServerExchange);\n            }\n            connection.setCurrentExchange(httpServerExchange);\n            if(connectorStatistics != null) {\n                connectorStatistics.setup(httpServerExchange);\n            }\n            if(!Connectors.areRequestHeadersValid(httpServerExchange.getRequestHeaders())) {\n                oldState.badRequest = true;\n                UndertowLogger.REQUEST_IO_LOGGER.debugf(\"Invalid AJP request from %s, request contained invalid headers\", connection.getPeerAddress());\n            }\n\n            if(oldState.badRequest) {\n                httpServerExchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                httpServerExchange.endExchange();\n                safeClose(connection);\n            } else {\n                Connectors.executeRootHandler(connection.getRootHandler(), httpServerExchange);\n            }\n        } catch (BadRequestException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.failedToParseRequest(e);\n            handleBadRequest();\n            safeClose(connection);\n        } catch (IOException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n            handleInternalServerError();\n            safeClose(connection);\n        } catch (Throwable t) {\n            UndertowLogger.REQUEST_LOGGER.exceptionProcessingRequest(t);\n            handleInternalServerError();\n            safeClose(connection);\n        } finally {\n            if (free) pooled.close();\n        }\n    }\n\n    private void handleInternalServerError() {\n        sendMessages(SEND_HEADERS_INTERNAL_SERVER_ERROR_MSG, END_RESPONSE);\n    }\n\n    private void handleBadRequest() {\n        sendMessages(SEND_HEADERS_BAD_REQUEST_MSG, END_RESPONSE);\n    }\n\n    private void handleCPing() {\n        if (sendMessages(CPONG)) {\n            AjpReadListener.this.handleEvent(connection.getChannel().getSourceChannel());\n        }\n    }\n\n    private boolean sendMessages(final byte[]... rawMessages) {\n        state = new AjpRequestParseState();\n        final StreamConnection underlyingChannel = connection.getChannel();\n        underlyingChannel.getSourceChannel().suspendReads();\n        // detect buffer size\n        int bufferSize = 0;\n        for (int i = 0; i < rawMessages.length; i++) {\n            bufferSize += rawMessages[i].length;\n        }\n        // fill in buffer\n        final ByteBuffer buffer = ByteBuffer.allocate(bufferSize);\n        for (int i = 0; i < rawMessages.length; i++) {\n            buffer.put(rawMessages[i]);\n        }\n        buffer.flip();\n        // send buffer content\n        int res;\n        try {\n            do {\n                res = underlyingChannel.getSinkChannel().write(buffer);\n                if (res == 0) {\n                    underlyingChannel.getSinkChannel().setWriteListener(new ChannelListener<ConduitStreamSinkChannel>() {\n                        @Override\n                        public void handleEvent(ConduitStreamSinkChannel channel) {\n                            int res;\n                            do {\n                                try {\n                                    res = channel.write(buffer);\n                                    if (res == 0) {\n                                        return;\n                                    }\n                                } catch (IOException e) {\n                                    UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n                                    safeClose(connection);\n                                }\n                            } while (buffer.hasRemaining());\n                            channel.suspendWrites();\n                            AjpReadListener.this.handleEvent(underlyingChannel.getSourceChannel());\n                        }\n                    });\n                    underlyingChannel.getSinkChannel().resumeWrites();\n                    return false;\n                }\n            } while (buffer.hasRemaining());\n            return true;\n        } catch (IOException e) {\n            UndertowLogger.REQUEST_IO_LOGGER.ioException(e);\n            safeClose(connection);\n            return false;\n        }\n    }\n\n    public void exchangeComplete(final HttpServerExchange exchange) {\n        if (!exchange.isUpgrade() && exchange.isPersistent()) {\n            startRequest();\n            ConduitStreamSourceChannel channel = ((AjpServerConnection) exchange.getConnection()).getChannel().getSourceChannel();\n            channel.getReadSetter().set(this);\n            channel.wakeupReads();\n        } else if(!exchange.isPersistent()) {\n            safeClose(exchange.getConnection());\n        }\n    }\n\n    private StreamSourceConduit createSourceConduit(StreamSourceConduit underlyingConduit, AjpServerResponseConduit responseConduit, final HttpServerExchange exchange) throws BadRequestException {\n\n        ReadDataStreamSourceConduit conduit = new ReadDataStreamSourceConduit(underlyingConduit, (AbstractServerConnection) exchange.getConnection());\n\n        final HeaderMap requestHeaders = exchange.getRequestHeaders();\n        HttpString transferEncoding = Headers.IDENTITY;\n        Long length;\n        final String teHeader = requestHeaders.getLast(Headers.TRANSFER_ENCODING);\n        boolean hasTransferEncoding = teHeader != null;\n        if (hasTransferEncoding) {\n            transferEncoding = new HttpString(teHeader);\n        }\n        final String requestContentLength = requestHeaders.getFirst(Headers.CONTENT_LENGTH);\n        if (hasTransferEncoding && !transferEncoding.equals(Headers.IDENTITY)) {\n            length = null; //unknown length\n        } else if (requestContentLength != null) {\n            try {\n                final long contentLength = Long.parseLong(requestContentLength);\n                if (contentLength == 0L) {\n                    UndertowLogger.REQUEST_LOGGER.trace(\"No content, starting next request\");\n                    // no content - immediately start the next request, returning an empty stream for this one\n                    Connectors.terminateRequest(httpServerExchange);\n                    return new EmptyStreamSourceConduit(conduit.getReadThread());\n                } else {\n                    length = contentLength;\n                }\n            } catch (NumberFormatException e) {\n                throw new BadRequestException(\"Invalid Content-Length header\", e);\n            }\n        } else {\n            UndertowLogger.REQUEST_LOGGER.trace(\"No content length or transfer coding, starting next request\");\n            // no content - immediately start the next request, returning an empty stream for this one\n            Connectors.terminateRequest(exchange);\n            return new EmptyStreamSourceConduit(conduit.getReadThread());\n        }\n        return new AjpServerRequestConduit(conduit, exchange, responseConduit, length, new ConduitListener<AjpServerRequestConduit>() {\n            @Override\n            public void handleEvent(AjpServerRequestConduit channel) {\n                Connectors.terminateRequest(exchange);\n            }\n        });\n    }\n\n}\n"], "filenames": ["core/src/main/java/io/undertow/server/protocol/ajp/AjpReadListener.java"], "buggy_code_start_loc": [61], "buggy_code_end_loc": [239], "fixing_code_start_loc": [61], "fixing_code_end_loc": [237], "type": "CWE-252", "message": "A flaw was found in Undertow. For an AJP 400 response, EAP 7 is improperly sending two response packets, and those packets have the reuse flag set even though JBoss EAP closes the connection. A failure occurs when the connection is reused after a 400 by CPING since it reads in the second SEND_HEADERS response packet instead of a CPONG.", "other": {"cve": {"id": "CVE-2022-1319", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-31T16:15:09.410", "lastModified": "2022-11-07T19:09:46.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in Undertow. For an AJP 400 response, EAP 7 is improperly sending two response packets, and those packets have the reuse flag set even though JBoss EAP closes the connection. A failure occurs when the connection is reused after a 400 by CPING since it reads in the second SEND_HEADERS response packet instead of a CPONG."}, {"lang": "es", "value": "Se ha encontrado un fallo en Undertow. Para una respuesta AJP 400, EAP 7 env\u00eda inapropiadamente el flag de re\u00faso habilitado aunque JBoss EAP cierra la conexi\u00f3n. es producido un fallo cuando la conexi\u00f3n es reusada despu\u00e9s de un 400 por CPING ya que lee en el segundo paquete de respuesta SEND_HEADERS en lugar de un CPONG"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-252"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-252"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_application_runtimes:-:*:*:*:*:*:*:*", "matchCriteriaId": "A33441B3-B301-426C-A976-08CE5FE72EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:single_sign-on:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "9EFEC7CA-8DDA-48A6-A7B6-1F1D14792890"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.17", "matchCriteriaId": "B1470237-30DB-4A05-8148-621CEE66EA57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:2.2.17:-:*:*:*:*:*:*", "matchCriteriaId": "FB2B656E-2229-4D16-B063-4D9456AEBF63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:2.2.17:sp1:*:*:*:*:*:*", "matchCriteriaId": "04CA521E-1B46-44FB-AA69-309AC53A360A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:2.2.17:sp2:*:*:*:*:*:*", "matchCriteriaId": "005FB2BF-CF38-4F91-A24B-96D72222192C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:2.2.19:-:*:*:*:*:*:*", "matchCriteriaId": "269ECD35-C644-4B04-AAD3-D88F97CF0214"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:2.2.19:sp1:*:*:*:*:*:*", "matchCriteriaId": "C0692735-244D-415B-894C-1A64E0307FC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:undertow:2.3.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "F6DD3DE4-9C5D-4768-9414-C63D1D172B7F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:linux:*:*", "matchCriteriaId": "F3E0B672-3E06-4422-B2A4-0BD073AEC2A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:windows:*:*", "matchCriteriaId": "B55E8D50-99B4-47EC-86F9-699B67D473CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_secure_agent:-:*:*:*:*:*:*:*", "matchCriteriaId": "F0F202E8-97E6-4BBB-A0B6-4CA3F5803C08"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_insight:-:*:*:*:*:*:*:*", "matchCriteriaId": "F1BE6C1F-2565-4E97-92AA-16563E5660A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-1319", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2073890", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/undertow-io/undertow/commit/1443a1a2bbb8e32e56788109d8285db250d55c8b", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/undertow-io/undertow/commit/7c5b3ab885b5638fd3f1e8a935d5063d68aa2df3", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://issues.redhat.com/browse/UNDERTOW-2060", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221014-0006/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/undertow-io/undertow/commit/1443a1a2bbb8e32e56788109d8285db250d55c8b"}}