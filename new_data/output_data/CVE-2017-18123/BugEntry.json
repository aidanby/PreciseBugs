{"buggy_code": ["<?php\n/**\n * DokuWiki AJAX call handler\n *\n * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)\n * @author     Andreas Gohr <andi@splitbrain.org>\n */\n\nif(!defined('DOKU_INC')) define('DOKU_INC',dirname(__FILE__).'/../../');\nrequire_once(DOKU_INC.'inc/init.php');\n//close session\nsession_write_close();\n\nheader('Content-Type: text/html; charset=utf-8');\n\n//call the requested function\nif($INPUT->post->has('call')){\n    $call = $INPUT->post->str('call');\n}else if($INPUT->get->has('call')){\n    $call = $INPUT->get->str('call');\n}else{\n    exit;\n}\n$callfn = 'ajax_'.$call;\n\nif(function_exists($callfn)){\n    $callfn();\n}else{\n    $evt = new Doku_Event('AJAX_CALL_UNKNOWN', $call);\n    if ($evt->advise_before()) {\n        print \"AJAX call '\".htmlspecialchars($call).\"' unknown!\\n\";\n        exit;\n    }\n    $evt->advise_after();\n    unset($evt);\n}\n\n/**\n * Searches for matching pagenames\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_qsearch(){\n    global $lang;\n    global $INPUT;\n\n    $maxnumbersuggestions = 50;\n\n    $query = $INPUT->post->str('q');\n    if(empty($query)) $query = $INPUT->get->str('q');\n    if(empty($query)) return;\n\n    $query = urldecode($query);\n\n    $data = ft_pageLookup($query, true, useHeading('navigation'));\n\n    if(!count($data)) return;\n\n    print '<strong>'.$lang['quickhits'].'</strong>';\n    print '<ul>';\n    $counter = 0;\n    foreach($data as $id => $title){\n        if (useHeading('navigation')) {\n            $name = $title;\n        } else {\n            $ns = getNS($id);\n            if($ns){\n                $name = noNS($id).' ('.$ns.')';\n            }else{\n                $name = $id;\n            }\n        }\n        echo '<li>' . html_wikilink(':'.$id,$name) . '</li>';\n\n        $counter ++;\n        if($counter > $maxnumbersuggestions) {\n            echo '<li>...</li>';\n            break;\n        }\n    }\n    print '</ul>';\n}\n\n/**\n * Support OpenSearch suggestions\n *\n * @link   http://www.opensearch.org/Specifications/OpenSearch/Extensions/Suggestions/1.0\n * @author Mike Frysinger <vapier@gentoo.org>\n */\nfunction ajax_suggestions() {\n    global $INPUT;\n\n    $query = cleanID($INPUT->post->str('q'));\n    if(empty($query)) $query = cleanID($INPUT->get->str('q'));\n    if(empty($query)) return;\n\n    $data = ft_pageLookup($query);\n    if(!count($data)) return;\n    $data = array_keys($data);\n\n    // limit results to 15 hits\n    $data = array_slice($data, 0, 15);\n    $data = array_map('trim',$data);\n    $data = array_map('noNS',$data);\n    $data = array_unique($data);\n    sort($data);\n\n    /* now construct a json */\n    $suggestions = array(\n                        $query,  // the original query\n                        $data,   // some suggestions\n                        array(), // no description\n                        array()  // no urls\n                   );\n    $json = new JSON();\n\n    header('Content-Type: application/x-suggestions+json');\n    print $json->encode($suggestions);\n}\n\n/**\n * Refresh a page lock and save draft\n *\n * Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_lock(){\n    global $conf;\n    global $lang;\n    global $ID;\n    global $INFO;\n    global $INPUT;\n\n    $ID = cleanID($INPUT->post->str('id'));\n    if(empty($ID)) return;\n\n    $INFO = pageinfo();\n\n    if (!$INFO['writable']) {\n        echo 'Permission denied';\n        return;\n    }\n\n    if(!checklock($ID)){\n        lock($ID);\n        echo 1;\n    }\n\n    if($conf['usedraft'] && $INPUT->post->str('wikitext')){\n        $client = $_SERVER['REMOTE_USER'];\n        if(!$client) $client = clientIP(true);\n\n        $draft = array('id'     => $ID,\n                'prefix' => substr($INPUT->post->str('prefix'), 0, -1),\n                'text'   => $INPUT->post->str('wikitext'),\n                'suffix' => $INPUT->post->str('suffix'),\n                'date'   => $INPUT->post->int('date'),\n                'client' => $client,\n                );\n        $cname = getCacheName($draft['client'].$ID,'.draft');\n        if(io_saveFile($cname,serialize($draft))){\n            echo $lang['draftdate'].' '.dformat();\n        }\n    }\n\n}\n\n/**\n * Delete a draft\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_draftdel(){\n    global $INPUT;\n    $id = cleanID($INPUT->str('id'));\n    if(empty($id)) return;\n\n    $client = $_SERVER['REMOTE_USER'];\n    if(!$client) $client = clientIP(true);\n\n    $cname = getCacheName($client.$id,'.draft');\n    @unlink($cname);\n}\n\n/**\n * Return subnamespaces for the Mediamanager\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_medians(){\n    global $conf;\n    global $INPUT;\n\n    // wanted namespace\n    $ns  = cleanID($INPUT->post->str('ns'));\n    $dir  = utf8_encodeFN(str_replace(':','/',$ns));\n\n    $lvl = count(explode(':',$ns));\n\n    $data = array();\n    search($data,$conf['mediadir'],'search_index',array('nofiles' => true),$dir);\n    foreach(array_keys($data) as $item){\n        $data[$item]['level'] = $lvl+1;\n    }\n    echo html_buildlist($data, 'idx', 'media_nstree_item', 'media_nstree_li');\n}\n\n/**\n * Return list of files for the Mediamanager\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_medialist(){\n    global $NS;\n    global $INPUT;\n\n    $NS = cleanID($INPUT->post->str('ns'));\n    $sort = $INPUT->post->bool('recent') ? 'date' : 'natural';\n    if ($INPUT->post->str('do') == 'media') {\n        tpl_mediaFileList();\n    } else {\n        tpl_mediaContent(true, $sort);\n    }\n}\n\n/**\n * Return the content of the right column\n * (image details) for the Mediamanager\n *\n * @author Kate Arzamastseva <pshns@ukr.net>\n */\nfunction ajax_mediadetails(){\n    global $IMG, $JUMPTO, $REV, $fullscreen, $INPUT;\n    $fullscreen = true;\n    require_once(DOKU_INC.'lib/exe/mediamanager.php');\n\n    $image = '';\n    if ($INPUT->has('image')) $image = cleanID($INPUT->str('image'));\n    if (isset($IMG)) $image = $IMG;\n    if (isset($JUMPTO)) $image = $JUMPTO;\n    $rev = false;\n    if (isset($REV) && !$JUMPTO) $rev = $REV;\n\n    html_msgarea();\n    tpl_mediaFileDetails($image, $rev);\n}\n\n/**\n * Returns image diff representation for mediamanager\n * @author Kate Arzamastseva <pshns@ukr.net>\n */\nfunction ajax_mediadiff(){\n    global $NS;\n    global $INPUT;\n\n    $image = '';\n    if ($INPUT->has('image')) $image = cleanID($INPUT->str('image'));\n    $NS = getNS($image);\n    $auth = auth_quickaclcheck(\"$NS:*\");\n    media_diff($image, $NS, $auth, true);\n}\n\nfunction ajax_mediaupload(){\n    global $NS, $MSG, $INPUT;\n\n    $id = '';\n    if ($_FILES['qqfile']['tmp_name']) {\n        $id = $INPUT->post->str('mediaid', $_FILES['qqfile']['name']);\n    } elseif ($INPUT->get->has('qqfile')) {\n        $id = $INPUT->get->str('qqfile');\n    }\n\n    $id = cleanID($id);\n\n    $NS = $INPUT->str('ns');\n    $ns = $NS.':'.getNS($id);\n\n    $AUTH = auth_quickaclcheck(\"$ns:*\");\n    if($AUTH >= AUTH_UPLOAD) { io_createNamespace(\"$ns:xxx\", 'media'); }\n\n    if ($_FILES['qqfile']['error']) unset($_FILES['qqfile']);\n\n    $res = false;\n    if ($_FILES['qqfile']['tmp_name']) $res = media_upload($NS, $AUTH, $_FILES['qqfile']);\n    if ($INPUT->get->has('qqfile')) $res = media_upload_xhr($NS, $AUTH);\n\n    if($res) {\n        $result = array(\n            'success' => true,\n            'link' => media_managerURL(array('ns' => $ns, 'image' => $NS . ':' . $id), '&'),\n            'id' => $NS . ':' . $id,\n            'ns' => $NS\n        );\n    } else {\n        $error = '';\n        if(isset($MSG)) {\n            foreach($MSG as $msg) {\n                $error .= $msg['msg'];\n            }\n        }\n        $result = array(\n            'error' => $error,\n            'ns' => $NS\n        );\n    }\n    $json = new JSON;\n    header('Content-Type: application/json');\n    echo $json->encode($result);\n}\n\n/**\n * Return sub index for index view\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_index(){\n    global $conf;\n    global $INPUT;\n\n    // wanted namespace\n    $ns  = cleanID($INPUT->post->str('idx'));\n    $dir  = utf8_encodeFN(str_replace(':','/',$ns));\n\n    $lvl = count(explode(':',$ns));\n\n    $data = array();\n    search($data,$conf['datadir'],'search_index',array('ns' => $ns),$dir);\n    foreach(array_keys($data) as $item){\n        $data[$item]['level'] = $lvl+1;\n    }\n    echo html_buildlist($data, 'idx', 'html_list_index', 'html_li_index');\n}\n\n/**\n * List matching namespaces and pages for the link wizard\n *\n * @author Andreas Gohr <gohr@cosmocode.de>\n */\nfunction ajax_linkwiz(){\n    global $conf;\n    global $lang;\n    global $INPUT;\n\n    $q  = ltrim(trim($INPUT->post->str('q')),':');\n    $id = noNS($q);\n    $ns = getNS($q);\n\n    $ns = cleanID($ns);\n    $id = cleanID($id);\n\n    $nsd  = utf8_encodeFN(str_replace(':','/',$ns));\n\n    $data = array();\n    if($q && !$ns){\n\n        // use index to lookup matching pages\n        $pages = ft_pageLookup($id,true);\n\n        // result contains matches in pages and namespaces\n        // we now extract the matching namespaces to show\n        // them seperately\n        $dirs  = array();\n\n        foreach($pages as $pid => $title){\n            if(strpos(noNS($pid),$id) === false){\n                // match was in the namespace\n                $dirs[getNS($pid)] = 1; // assoc array avoids dupes\n            }else{\n                // it is a matching page, add it to the result\n                $data[] = array(\n                        'id'    => $pid,\n                        'title' => $title,\n                        'type'  => 'f',\n                        );\n            }\n            unset($pages[$pid]);\n        }\n        foreach($dirs as $dir => $junk){\n            $data[] = array(\n                    'id'   => $dir,\n                    'type' => 'd',\n                    );\n        }\n\n    }else{\n\n        $opts = array(\n                'depth' => 1,\n                'listfiles' => true,\n                'listdirs'  => true,\n                'pagesonly' => true,\n                'firsthead' => true,\n                'sneakyacl' => $conf['sneaky_index'],\n                );\n        if($id) $opts['filematch'] = '^.*\\/'.$id;\n        if($id) $opts['dirmatch']  = '^.*\\/'.$id;\n        search($data,$conf['datadir'],'search_universal',$opts,$nsd);\n\n        // add back to upper\n        if($ns){\n            array_unshift($data,array(\n                        'id'   => getNS($ns),\n                        'type' => 'u',\n                        ));\n        }\n    }\n\n    // fixme sort results in a useful way ?\n\n    if(!count($data)){\n        echo $lang['nothingfound'];\n        exit;\n    }\n\n    // output the found data\n    $even = 1;\n    foreach($data as $item){\n        $even *= -1; //zebra\n\n        if(($item['type'] == 'd' || $item['type'] == 'u') && $item['id']) $item['id'] .= ':';\n        $link = wl($item['id']);\n\n        echo '<div class=\"'.(($even > 0)?'even':'odd').' type_'.$item['type'].'\">';\n\n        if($item['type'] == 'u'){\n            $name = $lang['upperns'];\n        }else{\n            $name = htmlspecialchars($item['id']);\n        }\n\n        echo '<a href=\"'.$link.'\" title=\"'.htmlspecialchars($item['id']).'\" class=\"wikilink1\">'.$name.'</a>';\n\n        if(!blank($item['title'])){\n            echo '<span>'.htmlspecialchars($item['title']).'</span>';\n        }\n        echo '</div>';\n    }\n\n}\n\n//Setup VIM: ex: et ts=2 :\n"], "fixing_code": ["<?php\n/**\n * DokuWiki AJAX call handler\n *\n * @license    GPL 2 (http://www.gnu.org/licenses/gpl.html)\n * @author     Andreas Gohr <andi@splitbrain.org>\n */\n\nif(!defined('DOKU_INC')) define('DOKU_INC',dirname(__FILE__).'/../../');\nrequire_once(DOKU_INC.'inc/init.php');\n//close session\nsession_write_close();\n\nheader('Content-Type: text/html; charset=utf-8');\n\n//call the requested function\nif($INPUT->post->has('call')){\n    $call = $INPUT->post->filter('utf8_stripspecials')->str('call');\n}else if($INPUT->get->has('call')){\n    $call = $INPUT->get->filter('utf8_stripspecials')->str('call');\n}else{\n    exit;\n}\n$callfn = 'ajax_'.$call;\n\nif(function_exists($callfn)){\n    $callfn();\n}else{\n    $evt = new Doku_Event('AJAX_CALL_UNKNOWN', $call);\n    if ($evt->advise_before()) {\n        print \"AJAX call '\".htmlspecialchars($call).\"' unknown!\\n\";\n        exit;\n    }\n    $evt->advise_after();\n    unset($evt);\n}\n\n/**\n * Searches for matching pagenames\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_qsearch(){\n    global $lang;\n    global $INPUT;\n\n    $maxnumbersuggestions = 50;\n\n    $query = $INPUT->post->str('q');\n    if(empty($query)) $query = $INPUT->get->str('q');\n    if(empty($query)) return;\n\n    $query = urldecode($query);\n\n    $data = ft_pageLookup($query, true, useHeading('navigation'));\n\n    if(!count($data)) return;\n\n    print '<strong>'.$lang['quickhits'].'</strong>';\n    print '<ul>';\n    $counter = 0;\n    foreach($data as $id => $title){\n        if (useHeading('navigation')) {\n            $name = $title;\n        } else {\n            $ns = getNS($id);\n            if($ns){\n                $name = noNS($id).' ('.$ns.')';\n            }else{\n                $name = $id;\n            }\n        }\n        echo '<li>' . html_wikilink(':'.$id,$name) . '</li>';\n\n        $counter ++;\n        if($counter > $maxnumbersuggestions) {\n            echo '<li>...</li>';\n            break;\n        }\n    }\n    print '</ul>';\n}\n\n/**\n * Support OpenSearch suggestions\n *\n * @link   http://www.opensearch.org/Specifications/OpenSearch/Extensions/Suggestions/1.0\n * @author Mike Frysinger <vapier@gentoo.org>\n */\nfunction ajax_suggestions() {\n    global $INPUT;\n\n    $query = cleanID($INPUT->post->str('q'));\n    if(empty($query)) $query = cleanID($INPUT->get->str('q'));\n    if(empty($query)) return;\n\n    $data = ft_pageLookup($query);\n    if(!count($data)) return;\n    $data = array_keys($data);\n\n    // limit results to 15 hits\n    $data = array_slice($data, 0, 15);\n    $data = array_map('trim',$data);\n    $data = array_map('noNS',$data);\n    $data = array_unique($data);\n    sort($data);\n\n    /* now construct a json */\n    $suggestions = array(\n                        $query,  // the original query\n                        $data,   // some suggestions\n                        array(), // no description\n                        array()  // no urls\n                   );\n    $json = new JSON();\n\n    header('Content-Type: application/x-suggestions+json');\n    print $json->encode($suggestions);\n}\n\n/**\n * Refresh a page lock and save draft\n *\n * Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_lock(){\n    global $conf;\n    global $lang;\n    global $ID;\n    global $INFO;\n    global $INPUT;\n\n    $ID = cleanID($INPUT->post->str('id'));\n    if(empty($ID)) return;\n\n    $INFO = pageinfo();\n\n    if (!$INFO['writable']) {\n        echo 'Permission denied';\n        return;\n    }\n\n    if(!checklock($ID)){\n        lock($ID);\n        echo 1;\n    }\n\n    if($conf['usedraft'] && $INPUT->post->str('wikitext')){\n        $client = $_SERVER['REMOTE_USER'];\n        if(!$client) $client = clientIP(true);\n\n        $draft = array('id'     => $ID,\n                'prefix' => substr($INPUT->post->str('prefix'), 0, -1),\n                'text'   => $INPUT->post->str('wikitext'),\n                'suffix' => $INPUT->post->str('suffix'),\n                'date'   => $INPUT->post->int('date'),\n                'client' => $client,\n                );\n        $cname = getCacheName($draft['client'].$ID,'.draft');\n        if(io_saveFile($cname,serialize($draft))){\n            echo $lang['draftdate'].' '.dformat();\n        }\n    }\n\n}\n\n/**\n * Delete a draft\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_draftdel(){\n    global $INPUT;\n    $id = cleanID($INPUT->str('id'));\n    if(empty($id)) return;\n\n    $client = $_SERVER['REMOTE_USER'];\n    if(!$client) $client = clientIP(true);\n\n    $cname = getCacheName($client.$id,'.draft');\n    @unlink($cname);\n}\n\n/**\n * Return subnamespaces for the Mediamanager\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_medians(){\n    global $conf;\n    global $INPUT;\n\n    // wanted namespace\n    $ns  = cleanID($INPUT->post->str('ns'));\n    $dir  = utf8_encodeFN(str_replace(':','/',$ns));\n\n    $lvl = count(explode(':',$ns));\n\n    $data = array();\n    search($data,$conf['mediadir'],'search_index',array('nofiles' => true),$dir);\n    foreach(array_keys($data) as $item){\n        $data[$item]['level'] = $lvl+1;\n    }\n    echo html_buildlist($data, 'idx', 'media_nstree_item', 'media_nstree_li');\n}\n\n/**\n * Return list of files for the Mediamanager\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_medialist(){\n    global $NS;\n    global $INPUT;\n\n    $NS = cleanID($INPUT->post->str('ns'));\n    $sort = $INPUT->post->bool('recent') ? 'date' : 'natural';\n    if ($INPUT->post->str('do') == 'media') {\n        tpl_mediaFileList();\n    } else {\n        tpl_mediaContent(true, $sort);\n    }\n}\n\n/**\n * Return the content of the right column\n * (image details) for the Mediamanager\n *\n * @author Kate Arzamastseva <pshns@ukr.net>\n */\nfunction ajax_mediadetails(){\n    global $IMG, $JUMPTO, $REV, $fullscreen, $INPUT;\n    $fullscreen = true;\n    require_once(DOKU_INC.'lib/exe/mediamanager.php');\n\n    $image = '';\n    if ($INPUT->has('image')) $image = cleanID($INPUT->str('image'));\n    if (isset($IMG)) $image = $IMG;\n    if (isset($JUMPTO)) $image = $JUMPTO;\n    $rev = false;\n    if (isset($REV) && !$JUMPTO) $rev = $REV;\n\n    html_msgarea();\n    tpl_mediaFileDetails($image, $rev);\n}\n\n/**\n * Returns image diff representation for mediamanager\n * @author Kate Arzamastseva <pshns@ukr.net>\n */\nfunction ajax_mediadiff(){\n    global $NS;\n    global $INPUT;\n\n    $image = '';\n    if ($INPUT->has('image')) $image = cleanID($INPUT->str('image'));\n    $NS = getNS($image);\n    $auth = auth_quickaclcheck(\"$NS:*\");\n    media_diff($image, $NS, $auth, true);\n}\n\nfunction ajax_mediaupload(){\n    global $NS, $MSG, $INPUT;\n\n    $id = '';\n    if ($_FILES['qqfile']['tmp_name']) {\n        $id = $INPUT->post->str('mediaid', $_FILES['qqfile']['name']);\n    } elseif ($INPUT->get->has('qqfile')) {\n        $id = $INPUT->get->str('qqfile');\n    }\n\n    $id = cleanID($id);\n\n    $NS = $INPUT->str('ns');\n    $ns = $NS.':'.getNS($id);\n\n    $AUTH = auth_quickaclcheck(\"$ns:*\");\n    if($AUTH >= AUTH_UPLOAD) { io_createNamespace(\"$ns:xxx\", 'media'); }\n\n    if ($_FILES['qqfile']['error']) unset($_FILES['qqfile']);\n\n    $res = false;\n    if ($_FILES['qqfile']['tmp_name']) $res = media_upload($NS, $AUTH, $_FILES['qqfile']);\n    if ($INPUT->get->has('qqfile')) $res = media_upload_xhr($NS, $AUTH);\n\n    if($res) {\n        $result = array(\n            'success' => true,\n            'link' => media_managerURL(array('ns' => $ns, 'image' => $NS . ':' . $id), '&'),\n            'id' => $NS . ':' . $id,\n            'ns' => $NS\n        );\n    } else {\n        $error = '';\n        if(isset($MSG)) {\n            foreach($MSG as $msg) {\n                $error .= $msg['msg'];\n            }\n        }\n        $result = array(\n            'error' => $error,\n            'ns' => $NS\n        );\n    }\n    $json = new JSON;\n    header('Content-Type: application/json');\n    echo $json->encode($result);\n}\n\n/**\n * Return sub index for index view\n *\n * @author Andreas Gohr <andi@splitbrain.org>\n */\nfunction ajax_index(){\n    global $conf;\n    global $INPUT;\n\n    // wanted namespace\n    $ns  = cleanID($INPUT->post->str('idx'));\n    $dir  = utf8_encodeFN(str_replace(':','/',$ns));\n\n    $lvl = count(explode(':',$ns));\n\n    $data = array();\n    search($data,$conf['datadir'],'search_index',array('ns' => $ns),$dir);\n    foreach(array_keys($data) as $item){\n        $data[$item]['level'] = $lvl+1;\n    }\n    echo html_buildlist($data, 'idx', 'html_list_index', 'html_li_index');\n}\n\n/**\n * List matching namespaces and pages for the link wizard\n *\n * @author Andreas Gohr <gohr@cosmocode.de>\n */\nfunction ajax_linkwiz(){\n    global $conf;\n    global $lang;\n    global $INPUT;\n\n    $q  = ltrim(trim($INPUT->post->str('q')),':');\n    $id = noNS($q);\n    $ns = getNS($q);\n\n    $ns = cleanID($ns);\n    $id = cleanID($id);\n\n    $nsd  = utf8_encodeFN(str_replace(':','/',$ns));\n\n    $data = array();\n    if($q && !$ns){\n\n        // use index to lookup matching pages\n        $pages = ft_pageLookup($id,true);\n\n        // result contains matches in pages and namespaces\n        // we now extract the matching namespaces to show\n        // them seperately\n        $dirs  = array();\n\n        foreach($pages as $pid => $title){\n            if(strpos(noNS($pid),$id) === false){\n                // match was in the namespace\n                $dirs[getNS($pid)] = 1; // assoc array avoids dupes\n            }else{\n                // it is a matching page, add it to the result\n                $data[] = array(\n                        'id'    => $pid,\n                        'title' => $title,\n                        'type'  => 'f',\n                        );\n            }\n            unset($pages[$pid]);\n        }\n        foreach($dirs as $dir => $junk){\n            $data[] = array(\n                    'id'   => $dir,\n                    'type' => 'd',\n                    );\n        }\n\n    }else{\n\n        $opts = array(\n                'depth' => 1,\n                'listfiles' => true,\n                'listdirs'  => true,\n                'pagesonly' => true,\n                'firsthead' => true,\n                'sneakyacl' => $conf['sneaky_index'],\n                );\n        if($id) $opts['filematch'] = '^.*\\/'.$id;\n        if($id) $opts['dirmatch']  = '^.*\\/'.$id;\n        search($data,$conf['datadir'],'search_universal',$opts,$nsd);\n\n        // add back to upper\n        if($ns){\n            array_unshift($data,array(\n                        'id'   => getNS($ns),\n                        'type' => 'u',\n                        ));\n        }\n    }\n\n    // fixme sort results in a useful way ?\n\n    if(!count($data)){\n        echo $lang['nothingfound'];\n        exit;\n    }\n\n    // output the found data\n    $even = 1;\n    foreach($data as $item){\n        $even *= -1; //zebra\n\n        if(($item['type'] == 'd' || $item['type'] == 'u') && $item['id']) $item['id'] .= ':';\n        $link = wl($item['id']);\n\n        echo '<div class=\"'.(($even > 0)?'even':'odd').' type_'.$item['type'].'\">';\n\n        if($item['type'] == 'u'){\n            $name = $lang['upperns'];\n        }else{\n            $name = htmlspecialchars($item['id']);\n        }\n\n        echo '<a href=\"'.$link.'\" title=\"'.htmlspecialchars($item['id']).'\" class=\"wikilink1\">'.$name.'</a>';\n\n        if(!blank($item['title'])){\n            echo '<span>'.htmlspecialchars($item['title']).'</span>';\n        }\n        echo '</div>';\n    }\n\n}\n\n//Setup VIM: ex: et ts=2 :\n"], "filenames": ["lib/exe/ajax.php"], "buggy_code_start_loc": [18], "buggy_code_end_loc": [21], "fixing_code_start_loc": [18], "fixing_code_end_loc": [21], "type": "CWE-20", "message": "The call parameter of /lib/exe/ajax.php in DokuWiki through 2017-02-19e does not properly encode user input, which leads to a reflected file download vulnerability, and allows remote attackers to run arbitrary programs.", "other": {"cve": {"id": "CVE-2017-18123", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-03T15:29:00.577", "lastModified": "2018-07-07T01:29:01.080", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The call parameter of /lib/exe/ajax.php in DokuWiki through 2017-02-19e does not properly encode user input, which leads to a reflected file download vulnerability, and allows remote attackers to run arbitrary programs."}, {"lang": "es", "value": "El par\u00e1metro call de /lib/exe/ajax.php en DokuWiki hasta 2017-02-19e no cifra correctamente las entradas de usuario, lo que conduce a una vulnerabilidad de descarga de archivos reflejada y permite que atacantes remotos ejecuten programas arbitrarios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dokuwiki:dokuwiki:*:*:*:*:*:*:*:*", "versionEndIncluding": "2017-02-19e", "matchCriteriaId": "9CB0CE3C-3563-4C9B-B168-FD1FA7F960D1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "https://github.com/splitbrain/dokuwiki/commit/238b8e878ad48f370903465192b57c2072f65d86", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/splitbrain/dokuwiki/issues/2029", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/splitbrain/dokuwiki/pull/2019", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://hackerone.com/reports/238316", "source": "cve@mitre.org", "tags": ["Permissions Required"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/02/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://vulnhive.com/2018/000004", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/splitbrain/dokuwiki/commit/238b8e878ad48f370903465192b57c2072f65d86"}}