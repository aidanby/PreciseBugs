{"buggy_code": ["long2ip = (long) ->\n    a = (long & (0xff << 24)) >>> 24;\n    b = (long & (0xff << 16)) >>> 16;\n    c = (long & (0xff << 8)) >>> 8;\n    d = long & 0xff;\n    return [a, b, c, d].join('.')\n\nip2long = (ip) ->\n    b = (ip + '').split('.');\n    if b.length is 0 or b.length > 4 then throw new Error('Invalid IP')\n    for byte, i in b\n        if byte and byte[0] == '0'\n            if byte.length > 2 and (byte[1] == 'x' or byte[1] == 'x')\n                # make sure 0x prefixed bytes are parsed as hex\n                byte = parseInt(byte, 16)\n            else\n                # make sure 0 prefixed bytes are parsed as octal\n                byte = parseInt(byte, 8)\n        else if byte and (byte[0] == ' ' or byte[byte.length-1] == ' ')\n            throw new Error('Invalid IP')\n        else\n            byte = parseInt(byte, 10)\n        if isNaN(byte) then throw new Error(\"Invalid byte: #{byte}\")\n        if byte < 0 or byte > 255 then throw new Error(\"Invalid byte: #{byte}\")\n        b[i] = byte\n    while b.length < 4\n        b.unshift(0)\n    return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0\n\nclass Netmask\n    constructor: (net, mask) ->\n        throw new Error(\"Missing `net' parameter\") unless typeof net is 'string'\n        unless mask\n            # try to find the mask in the net (i.e.: 1.2.3.4/24 or 1.2.3.4/255.255.255.0)\n            [net, mask] = net.split('/', 2)\n        unless mask\n            mask = 32\n        if typeof mask is 'string' and mask.indexOf('.') > -1\n            # Compute bitmask, the netmask as a number of bits in the network portion of the address for this block (eg.: 24)\n            try\n                @maskLong = ip2long(mask)\n            catch error\n                throw new Error(\"Invalid mask: #{mask}\")\n            for i in [32..0]\n                if @maskLong == (0xffffffff << (32 - i)) >>> 0\n                    @bitmask = i\n                    break\n        else if mask or mask == 0\n            # The mask was passed as bitmask, compute the mask as long from it\n            @bitmask = parseInt(mask, 10)\n            @maskLong = 0\n            if @bitmask > 0\n                @maskLong = (0xffffffff << (32 - @bitmask)) >>> 0\n        else\n            throw new Error(\"Invalid mask: empty\")\n\n        try\n            @netLong = (ip2long(net) & @maskLong) >>> 0\n        catch error\n            throw new Error(\"Invalid net address: #{net}\")\n\n        throw new Error(\"Invalid mask for ip4: #{mask}\") unless @bitmask <= 32\n\n        # The number of IP address in the block (eg.: 254)\n        @size = Math.pow(2, 32 - @bitmask)\n        # The address of the network block as a string (eg.: 216.240.32.0)\n        @base = long2ip(@netLong)\n        # The netmask as a string (eg.: 255.255.255.0)\n        @mask = long2ip(@maskLong)\n        # The host mask, the opposite of the netmask (eg.: 0.0.0.255)\n        @hostmask = long2ip(~@maskLong)\n        # The first usable address of the block\n        @first = if @bitmask <= 30 then long2ip(@netLong + 1) else @base\n        # The last  usable address of the block\n        @last = if @bitmask <= 30 then long2ip(@netLong + @size - 2) else long2ip(@netLong + @size - 1)\n        # The block's broadcast address: the last address of the block (eg.: 192.168.1.255)\n        @broadcast = if @bitmask <= 30 then long2ip(@netLong + @size - 1)\n\n    # Returns true if the given ip or netmask is contained in the block\n    contains: (ip) ->\n        if typeof ip is 'string' and (ip.indexOf('/') > 0 or ip.split('.').length isnt 4)\n            ip = new Netmask(ip)\n\n        if ip instanceof Netmask\n            return @contains(ip.base) and @contains((ip.broadcast || ip.last))\n        else\n            return (ip2long(ip) & @maskLong) >>> 0 == ((@netLong & @maskLong)) >>> 0\n\n    # Returns the Netmask object for the block which follow this one\n    next: (count=1) ->\n        return new Netmask(long2ip(@netLong + (@size * count)), @mask)\n\n    forEach: (fn) ->\n        # this implementation is not idiomatic but avoids large memory allocations (2 arrays, one for range and one for the results) in cases when then netmask is large\n        long = ip2long(@first)\n        lastLong = ip2long(@last)\n        index = 0\n        while long <= lastLong\n          fn long2ip(long), long, index\n          index++\n          long++\n        return\n\n    # Returns the complete netmask formatted as `base/bitmask`\n    toString: ->\n        return @base + \"/\" + @bitmask\n\n\nexports.ip2long = ip2long\nexports.long2ip = long2ip\nexports.Netmask = Netmask\n", "vows = require 'vows'\nassert = require 'assert'\nNetmask = require('../lib/netmask').Netmask\n\nshouldFailWithError = (msg) ->\n    context =\n        topic: ->\n            try\n                return new Netmask(@context.name)\n            catch e\n                return e\n        'should fail': (e) ->\n            assert.ok isError(e), \"is an Error object #{e}\"\n        \"with error `#{msg}'\": (e) ->\n            assert.ok e.message?.toLowerCase().indexOf(msg.toLowerCase()) > -1, \"'#{e.message}' =~ #{msg}\"\n\n    return context\n\nisError = (e) ->\n    return typeof e == 'object' and Object.prototype.toString.call(e) == '[object Error]'\n\nvows.describe('IPs with bytes greater than 255')\n    .addBatch\n        '209.256.68.22/255.255.224.0': shouldFailWithError 'Invalid net'\n        '209.180.68.22/256.255.224.0': shouldFailWithError 'Invalid mask'\n        '209.500.70.33/19': shouldFailWithError 'Invalid net'\n        '140.999.82': shouldFailWithError 'Invalid net'\n        '899.174': shouldFailWithError 'Invalid net'\n        '900': shouldFailWithError 'Invalid net'\n        '209.157.300/19': shouldFailWithError 'Invalid net'\n        '209.300.64.0.10': shouldFailWithError 'Invalid net'\n        'garbage': shouldFailWithError 'Invalid net'\n    .export(module)\n\nvows.describe('Invalid IP format')\n    .addBatch\n        ' 1.2.3.4': shouldFailWithError 'Invalid net'\n        '1. 2.3.4': shouldFailWithError 'Invalid net'\n        '1.2. 3.4': shouldFailWithError 'Invalid net'\n        '1.2.3. 4': shouldFailWithError 'Invalid net'\n        '1.2.3.4 ': shouldFailWithError 'Invalid net'\n        '1 .2.3.4': shouldFailWithError 'Invalid net'\n    .export(module)\n\nvows.describe('Ranges that are a power-of-two big, but are not legal blocks')\n    .addBatch\n        '218.0.0.0/221.255.255.255': shouldFailWithError 'Invalid mask'\n        '218.0.0.4/218.0.0.11': shouldFailWithError 'Invalid mask'\n    .export(module)\n"], "fixing_code": ["long2ip = (long) ->\n    a = (long & (0xff << 24)) >>> 24;\n    b = (long & (0xff << 16)) >>> 16;\n    c = (long & (0xff << 8)) >>> 8;\n    d = long & 0xff;\n    return [a, b, c, d].join('.')\n\nip2long = (ip) ->\n    b = []\n    for i in [0..3]\n        if ip.length == 0\n            break\n        if i > 0\n            if ip[0] != '.'\n                throw new Error('Invalid IP')\n            ip = ip.substring(1)\n        [n, c] = atob(ip)\n        ip = ip.substring(c)\n        b.push(n)\n    if ip.length != 0\n        throw new Error('Invalid IP')\n    while b.length < 4\n        b.unshift(0)\n    return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0\n\natob = (s) ->\n    n = 0\n    base = 10\n    dmax = '9'\n    i = 0\n    if s.length > 1 and s[i] == '0'\n        if s[i+1] == 'x' or s[i+1] == 'X'\n            i+=2\n            base = 16\n        else if '0' <= s[i+1] and s[i+1] <= '7'\n            i++\n            base = 8\n            dmax = '7'\n    start = i\n    chr = (b) -> return b.charCodeAt(0)\n    while s.length > 0\n        if '0' <= s[i] and s[i] <= dmax\n            n = n*base + (chr(s[i])-chr('0'))\n        else if base == 16\n            if 'a' <= s[i] and s[i] <= 'f'\n                n = n*base + (10+chr(s[i])-chr('a'))\n            else if 'A' <= s[i] and s[i] <= 'F'\n                n = n*base + (10+chr(s[i])-chr('A'))\n            else\n                break\n        else\n            break\n        if n > 0xFF\n            throw new Error('byte overflow')\n        i++\n    if i == start\n        throw new Error('empty octet')\n    return [n, i]\n\nclass Netmask\n    constructor: (net, mask) ->\n        throw new Error(\"Missing `net' parameter\") unless typeof net is 'string'\n        unless mask\n            # try to find the mask in the net (i.e.: 1.2.3.4/24 or 1.2.3.4/255.255.255.0)\n            [net, mask] = net.split('/', 2)\n        unless mask\n            mask = 32\n        if typeof mask is 'string' and mask.indexOf('.') > -1\n            # Compute bitmask, the netmask as a number of bits in the network portion of the address for this block (eg.: 24)\n            try\n                @maskLong = ip2long(mask)\n            catch error\n                throw new Error(\"Invalid mask: #{mask}\")\n            for i in [32..0]\n                if @maskLong == (0xffffffff << (32 - i)) >>> 0\n                    @bitmask = i\n                    break\n        else if mask or mask == 0\n            # The mask was passed as bitmask, compute the mask as long from it\n            @bitmask = parseInt(mask, 10)\n            @maskLong = 0\n            if @bitmask > 0\n                @maskLong = (0xffffffff << (32 - @bitmask)) >>> 0\n        else\n            throw new Error(\"Invalid mask: empty\")\n\n        try\n            @netLong = (ip2long(net) & @maskLong) >>> 0\n        catch error\n            throw new Error(\"Invalid net address: #{net}\")\n\n        throw new Error(\"Invalid mask for ip4: #{mask}\") unless @bitmask <= 32\n\n        # The number of IP address in the block (eg.: 254)\n        @size = Math.pow(2, 32 - @bitmask)\n        # The address of the network block as a string (eg.: 216.240.32.0)\n        @base = long2ip(@netLong)\n        # The netmask as a string (eg.: 255.255.255.0)\n        @mask = long2ip(@maskLong)\n        # The host mask, the opposite of the netmask (eg.: 0.0.0.255)\n        @hostmask = long2ip(~@maskLong)\n        # The first usable address of the block\n        @first = if @bitmask <= 30 then long2ip(@netLong + 1) else @base\n        # The last  usable address of the block\n        @last = if @bitmask <= 30 then long2ip(@netLong + @size - 2) else long2ip(@netLong + @size - 1)\n        # The block's broadcast address: the last address of the block (eg.: 192.168.1.255)\n        @broadcast = if @bitmask <= 30 then long2ip(@netLong + @size - 1)\n\n    # Returns true if the given ip or netmask is contained in the block\n    contains: (ip) ->\n        if typeof ip is 'string' and (ip.indexOf('/') > 0 or ip.split('.').length isnt 4)\n            ip = new Netmask(ip)\n\n        if ip instanceof Netmask\n            return @contains(ip.base) and @contains((ip.broadcast || ip.last))\n        else\n            return (ip2long(ip) & @maskLong) >>> 0 == ((@netLong & @maskLong)) >>> 0\n\n    # Returns the Netmask object for the block which follow this one\n    next: (count=1) ->\n        return new Netmask(long2ip(@netLong + (@size * count)), @mask)\n\n    forEach: (fn) ->\n        # this implementation is not idiomatic but avoids large memory allocations (2 arrays, one for range and one for the results) in cases when then netmask is large\n        long = ip2long(@first)\n        lastLong = ip2long(@last)\n        index = 0\n        while long <= lastLong\n          fn long2ip(long), long, index\n          index++\n          long++\n        return\n\n    # Returns the complete netmask formatted as `base/bitmask`\n    toString: ->\n        return @base + \"/\" + @bitmask\n\n\nexports.ip2long = ip2long\nexports.long2ip = long2ip\nexports.Netmask = Netmask\n", "vows = require 'vows'\nassert = require 'assert'\nNetmask = require('../lib/netmask').Netmask\n\nshouldFailWithError = (msg) ->\n    context =\n        topic: ->\n            try\n                return new Netmask(@context.name)\n            catch e\n                return e\n        'should fail': (e) ->\n            assert.ok isError(e), \"is an Error object #{e}\"\n        \"with error `#{msg}'\": (e) ->\n            assert.ok e.message?.toLowerCase().indexOf(msg.toLowerCase()) > -1, \"'#{e.message}' =~ #{msg}\"\n\n    return context\n\nisError = (e) ->\n    return typeof e == 'object' and Object.prototype.toString.call(e) == '[object Error]'\n\nvows.describe('IPs with bytes greater than 255')\n    .addBatch\n        '209.256.68.22/255.255.224.0': shouldFailWithError 'Invalid net'\n        '209.180.68.22/256.255.224.0': shouldFailWithError 'Invalid mask'\n        '209.500.70.33/19': shouldFailWithError 'Invalid net'\n        '140.999.82': shouldFailWithError 'Invalid net'\n        '899.174': shouldFailWithError 'Invalid net'\n        '900': shouldFailWithError 'Invalid net'\n        '209.157.300/19': shouldFailWithError 'Invalid net'\n        '209.300.64.0.10': shouldFailWithError 'Invalid net'\n        'garbage': shouldFailWithError 'Invalid net'\n    .export(module)\n\nvows.describe('Invalid IP format')\n    .addBatch\n        ' 1.2.3.4': shouldFailWithError 'Invalid net'\n        '  1.2.3.4': shouldFailWithError 'Invalid net'\n        '1. 2.3.4': shouldFailWithError 'Invalid net'\n        '1.2. 3.4': shouldFailWithError 'Invalid net'\n        '1.2.3. 4': shouldFailWithError 'Invalid net'\n        '1.2.3.4 ': shouldFailWithError 'Invalid net'\n        '1 .2.3.4': shouldFailWithError 'Invalid net'\n        '018.0.0.0': shouldFailWithError 'Invalid net'\n        '0xfg.0.0.0': shouldFailWithError 'Invalid net'\n    .export(module)\n\nvows.describe('Ranges that are a power-of-two big, but are not legal blocks')\n    .addBatch\n        '218.0.0.0/221.255.255.255': shouldFailWithError 'Invalid mask'\n        '218.0.0.4/218.0.0.11': shouldFailWithError 'Invalid mask'\n    .export(module)\n"], "filenames": ["lib/netmask.coffee", "test/badnets.coffee"], "buggy_code_start_loc": [9, 37], "buggy_code_end_loc": [28, 42], "fixing_code_start_loc": [9, 38], "fixing_code_end_loc": [59, 46], "type": "CWE-20", "message": "The netmask package before 2.0.1 for Node.js mishandles certain unexpected characters in an IP address string, such as an octal digit of 9. This (in some situations) allows attackers to bypass access control that is based on IP addresses. NOTE: this issue exists because of an incomplete fix for CVE-2021-28918.", "other": {"cve": {"id": "CVE-2021-29418", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-30T07:15:13.113", "lastModified": "2021-06-08T13:52:16.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The netmask package before 2.0.1 for Node.js mishandles certain unexpected characters in an IP address string, such as an octal digit of 9. This (in some situations) allows attackers to bypass access control that is based on IP addresses. NOTE: this issue exists because of an incomplete fix for CVE-2021-28918."}, {"lang": "es", "value": "El paquete netmask versiones anteriores a 2.0.1 para Node.js, maneja inapropiadamente determinados caracteres inesperados en una cadena de direcciones IP, como un d\u00edgito octal de 9. Esto (en algunas situaciones) permite a atacantes omitir el control de acceso que es basado en direcciones IP.&#xa0;NOTA: este problema se presenta debido a una correcci\u00f3n incompleta para el CVE-2021-28918."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netmask_project:netmask:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.0.1", "matchCriteriaId": "3CFF67CA-6DE5-47E3-9D52-EA33D9F3B17C"}]}]}], "references": [{"url": "https://github.com/rs/node-netmask/commit/3f19a056c4eb808ea4a29f234274c67bc5a848f4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210604-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://vuln.ryotak.me/advisories/6", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rs/node-netmask/commit/3f19a056c4eb808ea4a29f234274c67bc5a848f4"}}