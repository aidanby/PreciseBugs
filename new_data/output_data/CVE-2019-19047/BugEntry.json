{"buggy_code": ["/*\n * Copyright (c) 2013-2015, Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/hardirq.h>\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/cmd.h>\n#include \"mlx5_core.h\"\n#include \"lib/eq.h\"\n#include \"lib/mlx5.h\"\n#include \"lib/pci_vsc.h\"\n#include \"diag/fw_tracer.h\"\n\nenum {\n\tMLX5_HEALTH_POLL_INTERVAL\t= 2 * HZ,\n\tMAX_MISSES\t\t\t= 3,\n};\n\nenum {\n\tMLX5_HEALTH_SYNDR_FW_ERR\t\t= 0x1,\n\tMLX5_HEALTH_SYNDR_IRISC_ERR\t\t= 0x7,\n\tMLX5_HEALTH_SYNDR_HW_UNRECOVERABLE_ERR\t= 0x8,\n\tMLX5_HEALTH_SYNDR_CRC_ERR\t\t= 0x9,\n\tMLX5_HEALTH_SYNDR_FETCH_PCI_ERR\t\t= 0xa,\n\tMLX5_HEALTH_SYNDR_HW_FTL_ERR\t\t= 0xb,\n\tMLX5_HEALTH_SYNDR_ASYNC_EQ_OVERRUN_ERR\t= 0xc,\n\tMLX5_HEALTH_SYNDR_EQ_ERR\t\t= 0xd,\n\tMLX5_HEALTH_SYNDR_EQ_INV\t\t= 0xe,\n\tMLX5_HEALTH_SYNDR_FFSER_ERR\t\t= 0xf,\n\tMLX5_HEALTH_SYNDR_HIGH_TEMP\t\t= 0x10\n};\n\nenum {\n\tMLX5_DROP_NEW_HEALTH_WORK,\n};\n\nenum  {\n\tMLX5_SENSOR_NO_ERR\t\t= 0,\n\tMLX5_SENSOR_PCI_COMM_ERR\t= 1,\n\tMLX5_SENSOR_PCI_ERR\t\t= 2,\n\tMLX5_SENSOR_NIC_DISABLED\t= 3,\n\tMLX5_SENSOR_NIC_SW_RESET\t= 4,\n\tMLX5_SENSOR_FW_SYND_RFR\t\t= 5,\n};\n\nu8 mlx5_get_nic_state(struct mlx5_core_dev *dev)\n{\n\treturn (ioread32be(&dev->iseg->cmdq_addr_l_sz) >> 8) & 7;\n}\n\nvoid mlx5_set_nic_state(struct mlx5_core_dev *dev, u8 state)\n{\n\tu32 cur_cmdq_addr_l_sz;\n\n\tcur_cmdq_addr_l_sz = ioread32be(&dev->iseg->cmdq_addr_l_sz);\n\tiowrite32be((cur_cmdq_addr_l_sz & 0xFFFFF000) |\n\t\t    state << MLX5_NIC_IFC_OFFSET,\n\t\t    &dev->iseg->cmdq_addr_l_sz);\n}\n\nstatic bool sensor_pci_not_working(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\n\t/* Offline PCI reads return 0xffffffff */\n\treturn (ioread32be(&h->fw_ver) == 0xffffffff);\n}\n\nstatic bool sensor_fw_synd_rfr(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu32 rfr = ioread32be(&h->rfr) >> MLX5_RFR_OFFSET;\n\tu8 synd = ioread8(&h->synd);\n\n\tif (rfr && synd)\n\t\tmlx5_core_dbg(dev, \"FW requests reset, synd: %d\\n\", synd);\n\treturn rfr && synd;\n}\n\nstatic u32 check_fatal_sensors(struct mlx5_core_dev *dev)\n{\n\tif (sensor_pci_not_working(dev))\n\t\treturn MLX5_SENSOR_PCI_COMM_ERR;\n\tif (pci_channel_offline(dev->pdev))\n\t\treturn MLX5_SENSOR_PCI_ERR;\n\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)\n\t\treturn MLX5_SENSOR_NIC_DISABLED;\n\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_SW_RESET)\n\t\treturn MLX5_SENSOR_NIC_SW_RESET;\n\tif (sensor_fw_synd_rfr(dev))\n\t\treturn MLX5_SENSOR_FW_SYND_RFR;\n\n\treturn MLX5_SENSOR_NO_ERR;\n}\n\nstatic int lock_sem_sw_reset(struct mlx5_core_dev *dev, bool lock)\n{\n\tenum mlx5_vsc_state state;\n\tint ret;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EBUSY;\n\n\t/* Try to lock GW access, this stage doesn't return\n\t * EBUSY because locked GW does not mean that other PF\n\t * already started the reset.\n\t */\n\tret = mlx5_vsc_gw_lock(dev);\n\tif (ret == -EBUSY)\n\t\treturn -EINVAL;\n\tif (ret)\n\t\treturn ret;\n\n\tstate = lock ? MLX5_VSC_LOCK : MLX5_VSC_UNLOCK;\n\t/* At this stage, if the return status == EBUSY, then we know\n\t * for sure that another PF started the reset, so don't allow\n\t * another reset.\n\t */\n\tret = mlx5_vsc_sem_set_space(dev, MLX5_SEMAPHORE_SW_RESET, state);\n\tif (ret)\n\t\tmlx5_core_warn(dev, \"Failed to lock SW reset semaphore\\n\");\n\n\t/* Unlock GW access */\n\tmlx5_vsc_gw_unlock(dev);\n\n\treturn ret;\n}\n\nstatic bool reset_fw_if_needed(struct mlx5_core_dev *dev)\n{\n\tbool supported = (ioread32be(&dev->iseg->initializing) >>\n\t\t\t  MLX5_FW_RESET_SUPPORTED_OFFSET) & 1;\n\tu32 fatal_error;\n\n\tif (!supported)\n\t\treturn false;\n\n\t/* The reset only needs to be issued by one PF. The health buffer is\n\t * shared between all functions, and will be cleared during a reset.\n\t * Check again to avoid a redundant 2nd reset. If the fatal erros was\n\t * PCI related a reset won't help.\n\t */\n\tfatal_error = check_fatal_sensors(dev);\n\tif (fatal_error == MLX5_SENSOR_PCI_COMM_ERR ||\n\t    fatal_error == MLX5_SENSOR_NIC_DISABLED ||\n\t    fatal_error == MLX5_SENSOR_NIC_SW_RESET) {\n\t\tmlx5_core_warn(dev, \"Not issuing FW reset. Either it's already done or won't help.\");\n\t\treturn false;\n\t}\n\n\tmlx5_core_warn(dev, \"Issuing FW Reset\\n\");\n\t/* Write the NIC interface field to initiate the reset, the command\n\t * interface address also resides here, don't overwrite it.\n\t */\n\tmlx5_set_nic_state(dev, MLX5_NIC_IFC_SW_RESET);\n\n\treturn true;\n}\n\nvoid mlx5_enter_error_state(struct mlx5_core_dev *dev, bool force)\n{\n\tmutex_lock(&dev->intf_state_mutex);\n\tif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto unlock;\n\tif (dev->state == MLX5_DEVICE_STATE_UNINITIALIZED) {\n\t\tdev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;\n\t\tgoto unlock;\n\t}\n\n\tif (check_fatal_sensors(dev) || force) {\n\t\tdev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;\n\t\tmlx5_cmd_flush(dev);\n\t}\n\n\tmlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_SYS_ERROR, (void *)1);\nunlock:\n\tmutex_unlock(&dev->intf_state_mutex);\n}\n\n#define MLX5_CRDUMP_WAIT_MS\t60000\n#define MLX5_FW_RESET_WAIT_MS\t1000\nvoid mlx5_error_sw_reset(struct mlx5_core_dev *dev)\n{\n\tunsigned long end, delay_ms = MLX5_FW_RESET_WAIT_MS;\n\tint lock = -EBUSY;\n\n\tmutex_lock(&dev->intf_state_mutex);\n\tif (dev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto unlock;\n\n\tmlx5_core_err(dev, \"start\\n\");\n\n\tif (check_fatal_sensors(dev) == MLX5_SENSOR_FW_SYND_RFR) {\n\t\t/* Get cr-dump and reset FW semaphore */\n\t\tlock = lock_sem_sw_reset(dev, true);\n\n\t\tif (lock == -EBUSY) {\n\t\t\tdelay_ms = MLX5_CRDUMP_WAIT_MS;\n\t\t\tgoto recover_from_sw_reset;\n\t\t}\n\t\t/* Execute SW reset */\n\t\treset_fw_if_needed(dev);\n\t}\n\nrecover_from_sw_reset:\n\t/* Recover from SW reset */\n\tend = jiffies + msecs_to_jiffies(delay_ms);\n\tdo {\n\t\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t} while (!time_after(jiffies, end));\n\n\tif (mlx5_get_nic_state(dev) != MLX5_NIC_IFC_DISABLED) {\n\t\tdev_err(&dev->pdev->dev, \"NIC IFC still %d after %lums.\\n\",\n\t\t\tmlx5_get_nic_state(dev), delay_ms);\n\t}\n\n\t/* Release FW semaphore if you are the lock owner */\n\tif (!lock)\n\t\tlock_sem_sw_reset(dev, false);\n\n\tmlx5_core_err(dev, \"end\\n\");\n\nunlock:\n\tmutex_unlock(&dev->intf_state_mutex);\n}\n\nstatic void mlx5_handle_bad_state(struct mlx5_core_dev *dev)\n{\n\tu8 nic_interface = mlx5_get_nic_state(dev);\n\n\tswitch (nic_interface) {\n\tcase MLX5_NIC_IFC_FULL:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is full driver\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_DISABLED:\n\t\tmlx5_core_warn(dev, \"starting teardown\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_NO_DRAM_NIC:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is no dram nic\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_SW_RESET:\n\t\t/* The IFC mode field is 3 bits, so it will read 0x7 in 2 cases:\n\t\t * 1. PCI has been disabled (ie. PCI-AER, PF driver unloaded\n\t\t *    and this is a VF), this is not recoverable by SW reset.\n\t\t *    Logging of this is handled elsewhere.\n\t\t * 2. FW reset has been issued by another function, driver can\n\t\t *    be reloaded to recover after the mode switches to\n\t\t *    MLX5_NIC_IFC_DISABLED.\n\t\t */\n\t\tif (dev->priv.health.fatal_error != MLX5_SENSOR_PCI_COMM_ERR)\n\t\t\tmlx5_core_warn(dev, \"NIC SW reset in progress\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is has invalid value %d\\n\",\n\t\t\t       nic_interface);\n\t}\n\n\tmlx5_disable_device(dev);\n}\n\n/* How much time to wait until health resetting the driver (in msecs) */\n#define MLX5_RECOVERY_WAIT_MSECS 60000\nstatic int mlx5_health_try_recover(struct mlx5_core_dev *dev)\n{\n\tunsigned long end;\n\n\tmlx5_core_warn(dev, \"handling bad device here\\n\");\n\tmlx5_handle_bad_state(dev);\n\tend = jiffies + msecs_to_jiffies(MLX5_RECOVERY_WAIT_MSECS);\n\twhile (sensor_pci_not_working(dev)) {\n\t\tif (time_after(jiffies, end)) {\n\t\t\tmlx5_core_err(dev,\n\t\t\t\t      \"health recovery flow aborted, PCI reads still not working\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tmsleep(100);\n\t}\n\n\tmlx5_core_err(dev, \"starting health recovery flow\\n\");\n\tmlx5_recover_device(dev);\n\tif (!test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state) ||\n\t    check_fatal_sensors(dev)) {\n\t\tmlx5_core_err(dev, \"health recovery failed\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic const char *hsynd_str(u8 synd)\n{\n\tswitch (synd) {\n\tcase MLX5_HEALTH_SYNDR_FW_ERR:\n\t\treturn \"firmware internal error\";\n\tcase MLX5_HEALTH_SYNDR_IRISC_ERR:\n\t\treturn \"irisc not responding\";\n\tcase MLX5_HEALTH_SYNDR_HW_UNRECOVERABLE_ERR:\n\t\treturn \"unrecoverable hardware error\";\n\tcase MLX5_HEALTH_SYNDR_CRC_ERR:\n\t\treturn \"firmware CRC error\";\n\tcase MLX5_HEALTH_SYNDR_FETCH_PCI_ERR:\n\t\treturn \"ICM fetch PCI error\";\n\tcase MLX5_HEALTH_SYNDR_HW_FTL_ERR:\n\t\treturn \"HW fatal error\\n\";\n\tcase MLX5_HEALTH_SYNDR_ASYNC_EQ_OVERRUN_ERR:\n\t\treturn \"async EQ buffer overrun\";\n\tcase MLX5_HEALTH_SYNDR_EQ_ERR:\n\t\treturn \"EQ error\";\n\tcase MLX5_HEALTH_SYNDR_EQ_INV:\n\t\treturn \"Invalid EQ referenced\";\n\tcase MLX5_HEALTH_SYNDR_FFSER_ERR:\n\t\treturn \"FFSER error\";\n\tcase MLX5_HEALTH_SYNDR_HIGH_TEMP:\n\t\treturn \"High temperature\";\n\tdefault:\n\t\treturn \"unrecognized error\";\n\t}\n}\n\nstatic void print_health_info(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tchar fw_str[18];\n\tu32 fw;\n\tint i;\n\n\t/* If the syndrome is 0, the device is OK and no need to print buffer */\n\tif (!ioread8(&h->synd))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(h->assert_var); i++)\n\t\tmlx5_core_err(dev, \"assert_var[%d] 0x%08x\\n\", i,\n\t\t\t      ioread32be(h->assert_var + i));\n\n\tmlx5_core_err(dev, \"assert_exit_ptr 0x%08x\\n\",\n\t\t      ioread32be(&h->assert_exit_ptr));\n\tmlx5_core_err(dev, \"assert_callra 0x%08x\\n\",\n\t\t      ioread32be(&h->assert_callra));\n\tsprintf(fw_str, \"%d.%d.%d\", fw_rev_maj(dev), fw_rev_min(dev), fw_rev_sub(dev));\n\tmlx5_core_err(dev, \"fw_ver %s\\n\", fw_str);\n\tmlx5_core_err(dev, \"hw_id 0x%08x\\n\", ioread32be(&h->hw_id));\n\tmlx5_core_err(dev, \"irisc_index %d\\n\", ioread8(&h->irisc_index));\n\tmlx5_core_err(dev, \"synd 0x%x: %s\\n\", ioread8(&h->synd),\n\t\t      hsynd_str(ioread8(&h->synd)));\n\tmlx5_core_err(dev, \"ext_synd 0x%04x\\n\", ioread16be(&h->ext_synd));\n\tfw = ioread32be(&h->fw_ver);\n\tmlx5_core_err(dev, \"raw fw_ver 0x%08x\\n\", fw);\n}\n\nstatic int\nmlx5_fw_reporter_diagnose(struct devlink_health_reporter *reporter,\n\t\t\t  struct devlink_fmsg *fmsg)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu8 synd;\n\tint err;\n\n\tsynd = ioread8(&h->synd);\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"Syndrome\", synd);\n\tif (err || !synd)\n\t\treturn err;\n\treturn devlink_fmsg_string_pair_put(fmsg, \"Description\", hsynd_str(synd));\n}\n\nstruct mlx5_fw_reporter_ctx {\n\tu8 err_synd;\n\tint miss_counter;\n};\n\nstatic int\nmlx5_fw_reporter_ctx_pairs_put(struct devlink_fmsg *fmsg,\n\t\t\t       struct mlx5_fw_reporter_ctx *fw_reporter_ctx)\n{\n\tint err;\n\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"syndrome\",\n\t\t\t\t       fw_reporter_ctx->err_synd);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"fw_miss_counter\",\n\t\t\t\t\tfw_reporter_ctx->miss_counter);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int\nmlx5_fw_reporter_heath_buffer_data_put(struct mlx5_core_dev *dev,\n\t\t\t\t       struct devlink_fmsg *fmsg)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tint err;\n\tint i;\n\n\tif (!ioread8(&h->synd))\n\t\treturn 0;\n\n\terr = devlink_fmsg_pair_nest_start(fmsg, \"health buffer\");\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_obj_nest_start(fmsg);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"assert_var\");\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(h->assert_var); i++) {\n\t\terr = devlink_fmsg_u32_put(fmsg, ioread32be(h->assert_var + i));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"assert_exit_ptr\",\n\t\t\t\t\tioread32be(&h->assert_exit_ptr));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"assert_callra\",\n\t\t\t\t\tioread32be(&h->assert_callra));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"hw_id\", ioread32be(&h->hw_id));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"irisc_index\",\n\t\t\t\t       ioread8(&h->irisc_index));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"synd\", ioread8(&h->synd));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"ext_synd\",\n\t\t\t\t\tioread16be(&h->ext_synd));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"raw_fw_ver\",\n\t\t\t\t\tioread32be(&h->fw_ver));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\treturn devlink_fmsg_pair_nest_end(fmsg);\n}\n\nstatic int\nmlx5_fw_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t      struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tint err;\n\n\terr = mlx5_fw_tracer_trigger_core_dump_general(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mlx5_fw_reporter_heath_buffer_data_put(dev, fmsg);\n\tif (err)\n\t\treturn err;\n\treturn mlx5_fw_tracer_get_saved_traces_objects(dev->tracer, fmsg);\n}\n\nstatic void mlx5_fw_reporter_err_work(struct work_struct *work)\n{\n\tstruct mlx5_fw_reporter_ctx fw_reporter_ctx;\n\tstruct mlx5_core_health *health;\n\n\thealth = container_of(work, struct mlx5_core_health, report_work);\n\n\tif (IS_ERR_OR_NULL(health->fw_reporter))\n\t\treturn;\n\n\tfw_reporter_ctx.err_synd = health->synd;\n\tfw_reporter_ctx.miss_counter = health->miss_counter;\n\tif (fw_reporter_ctx.err_synd) {\n\t\tdevlink_health_report(health->fw_reporter,\n\t\t\t\t      \"FW syndrom reported\", &fw_reporter_ctx);\n\t\treturn;\n\t}\n\tif (fw_reporter_ctx.miss_counter)\n\t\tdevlink_health_report(health->fw_reporter,\n\t\t\t\t      \"FW miss counter reported\",\n\t\t\t\t      &fw_reporter_ctx);\n}\n\nstatic const struct devlink_health_reporter_ops mlx5_fw_reporter_ops = {\n\t\t.name = \"fw\",\n\t\t.diagnose = mlx5_fw_reporter_diagnose,\n\t\t.dump = mlx5_fw_reporter_dump,\n};\n\nstatic int\nmlx5_fw_fatal_reporter_recover(struct devlink_health_reporter *reporter,\n\t\t\t       void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\n\treturn mlx5_health_try_recover(dev);\n}\n\n#define MLX5_CR_DUMP_CHUNK_SIZE 256\nstatic int\nmlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}\n\nstatic void mlx5_fw_fatal_reporter_err_work(struct work_struct *work)\n{\n\tstruct mlx5_fw_reporter_ctx fw_reporter_ctx;\n\tstruct mlx5_core_health *health;\n\tstruct mlx5_core_dev *dev;\n\tstruct mlx5_priv *priv;\n\n\thealth = container_of(work, struct mlx5_core_health, fatal_report_work);\n\tpriv = container_of(health, struct mlx5_priv, health);\n\tdev = container_of(priv, struct mlx5_core_dev, priv);\n\n\tmlx5_enter_error_state(dev, false);\n\tif (IS_ERR_OR_NULL(health->fw_fatal_reporter)) {\n\t\tif (mlx5_health_try_recover(dev))\n\t\t\tmlx5_core_err(dev, \"health recovery failed\\n\");\n\t\treturn;\n\t}\n\tfw_reporter_ctx.err_synd = health->synd;\n\tfw_reporter_ctx.miss_counter = health->miss_counter;\n\tdevlink_health_report(health->fw_fatal_reporter,\n\t\t\t      \"FW fatal error reported\", &fw_reporter_ctx);\n}\n\nstatic const struct devlink_health_reporter_ops mlx5_fw_fatal_reporter_ops = {\n\t\t.name = \"fw_fatal\",\n\t\t.recover = mlx5_fw_fatal_reporter_recover,\n\t\t.dump = mlx5_fw_fatal_reporter_dump,\n};\n\n#define MLX5_REPORTER_FW_GRACEFUL_PERIOD 1200000\nstatic void mlx5_fw_reporters_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct devlink *devlink = priv_to_devlink(dev);\n\n\thealth->fw_reporter =\n\t\tdevlink_health_reporter_create(devlink, &mlx5_fw_reporter_ops,\n\t\t\t\t\t       0, false, dev);\n\tif (IS_ERR(health->fw_reporter))\n\t\tmlx5_core_warn(dev, \"Failed to create fw reporter, err = %ld\\n\",\n\t\t\t       PTR_ERR(health->fw_reporter));\n\n\thealth->fw_fatal_reporter =\n\t\tdevlink_health_reporter_create(devlink,\n\t\t\t\t\t       &mlx5_fw_fatal_reporter_ops,\n\t\t\t\t\t       MLX5_REPORTER_FW_GRACEFUL_PERIOD,\n\t\t\t\t\t       true, dev);\n\tif (IS_ERR(health->fw_fatal_reporter))\n\t\tmlx5_core_warn(dev, \"Failed to create fw fatal reporter, err = %ld\\n\",\n\t\t\t       PTR_ERR(health->fw_fatal_reporter));\n}\n\nstatic void mlx5_fw_reporters_destroy(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tif (!IS_ERR_OR_NULL(health->fw_reporter))\n\t\tdevlink_health_reporter_destroy(health->fw_reporter);\n\n\tif (!IS_ERR_OR_NULL(health->fw_fatal_reporter))\n\t\tdevlink_health_reporter_destroy(health->fw_fatal_reporter);\n}\n\nstatic unsigned long get_next_poll_jiffies(void)\n{\n\tunsigned long next;\n\n\tget_random_bytes(&next, sizeof(next));\n\tnext %= HZ;\n\tnext += jiffies + MLX5_HEALTH_POLL_INTERVAL;\n\n\treturn next;\n}\n\nvoid mlx5_trigger_health_work(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&health->wq_lock, flags);\n\tif (!test_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags))\n\t\tqueue_work(health->wq, &health->fatal_report_work);\n\telse\n\t\tmlx5_core_err(dev, \"new health works are not permitted at this stage\\n\");\n\tspin_unlock_irqrestore(&health->wq_lock, flags);\n}\n\nstatic void poll_health(struct timer_list *t)\n{\n\tstruct mlx5_core_dev *dev = from_timer(dev, t, priv.health.timer);\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu32 fatal_error;\n\tu8 prev_synd;\n\tu32 count;\n\n\tif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto out;\n\n\tfatal_error = check_fatal_sensors(dev);\n\n\tif (fatal_error && !health->fatal_error) {\n\t\tmlx5_core_err(dev, \"Fatal error %u detected\\n\", fatal_error);\n\t\tdev->priv.health.fatal_error = fatal_error;\n\t\tprint_health_info(dev);\n\t\tmlx5_trigger_health_work(dev);\n\t\tgoto out;\n\t}\n\n\tcount = ioread32be(health->health_counter);\n\tif (count == health->prev)\n\t\t++health->miss_counter;\n\telse\n\t\thealth->miss_counter = 0;\n\n\thealth->prev = count;\n\tif (health->miss_counter == MAX_MISSES) {\n\t\tmlx5_core_err(dev, \"device's health compromised - reached miss count\\n\");\n\t\tprint_health_info(dev);\n\t\tqueue_work(health->wq, &health->report_work);\n\t}\n\n\tprev_synd = health->synd;\n\thealth->synd = ioread8(&h->synd);\n\tif (health->synd && health->synd != prev_synd)\n\t\tqueue_work(health->wq, &health->report_work);\n\nout:\n\tmod_timer(&health->timer, get_next_poll_jiffies());\n}\n\nvoid mlx5_start_health_poll(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\ttimer_setup(&health->timer, poll_health, 0);\n\thealth->fatal_error = MLX5_SENSOR_NO_ERR;\n\tclear_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);\n\thealth->health = &dev->iseg->health;\n\thealth->health_counter = &dev->iseg->health_counter;\n\n\thealth->timer.expires = round_jiffies(jiffies + MLX5_HEALTH_POLL_INTERVAL);\n\tadd_timer(&health->timer);\n}\n\nvoid mlx5_stop_health_poll(struct mlx5_core_dev *dev, bool disable_health)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tunsigned long flags;\n\n\tif (disable_health) {\n\t\tspin_lock_irqsave(&health->wq_lock, flags);\n\t\tset_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);\n\t\tspin_unlock_irqrestore(&health->wq_lock, flags);\n\t}\n\n\tdel_timer_sync(&health->timer);\n}\n\nvoid mlx5_drain_health_wq(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&health->wq_lock, flags);\n\tset_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);\n\tspin_unlock_irqrestore(&health->wq_lock, flags);\n\tcancel_work_sync(&health->report_work);\n\tcancel_work_sync(&health->fatal_report_work);\n}\n\nvoid mlx5_health_flush(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tflush_workqueue(health->wq);\n}\n\nvoid mlx5_health_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tdestroy_workqueue(health->wq);\n\tmlx5_fw_reporters_destroy(dev);\n}\n\nint mlx5_health_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health;\n\tchar *name;\n\n\tmlx5_fw_reporters_create(dev);\n\n\thealth = &dev->priv.health;\n\tname = kmalloc(64, GFP_KERNEL);\n\tif (!name)\n\t\tgoto out_err;\n\n\tstrcpy(name, \"mlx5_health\");\n\tstrcat(name, dev_name(dev->device));\n\thealth->wq = create_singlethread_workqueue(name);\n\tkfree(name);\n\tif (!health->wq)\n\t\tgoto out_err;\n\tspin_lock_init(&health->wq_lock);\n\tINIT_WORK(&health->fatal_report_work, mlx5_fw_fatal_reporter_err_work);\n\tINIT_WORK(&health->report_work, mlx5_fw_reporter_err_work);\n\n\treturn 0;\n\nout_err:\n\tmlx5_fw_reporters_destroy(dev);\n\treturn -ENOMEM;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2013-2015, Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/hardirq.h>\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/cmd.h>\n#include \"mlx5_core.h\"\n#include \"lib/eq.h\"\n#include \"lib/mlx5.h\"\n#include \"lib/pci_vsc.h\"\n#include \"diag/fw_tracer.h\"\n\nenum {\n\tMLX5_HEALTH_POLL_INTERVAL\t= 2 * HZ,\n\tMAX_MISSES\t\t\t= 3,\n};\n\nenum {\n\tMLX5_HEALTH_SYNDR_FW_ERR\t\t= 0x1,\n\tMLX5_HEALTH_SYNDR_IRISC_ERR\t\t= 0x7,\n\tMLX5_HEALTH_SYNDR_HW_UNRECOVERABLE_ERR\t= 0x8,\n\tMLX5_HEALTH_SYNDR_CRC_ERR\t\t= 0x9,\n\tMLX5_HEALTH_SYNDR_FETCH_PCI_ERR\t\t= 0xa,\n\tMLX5_HEALTH_SYNDR_HW_FTL_ERR\t\t= 0xb,\n\tMLX5_HEALTH_SYNDR_ASYNC_EQ_OVERRUN_ERR\t= 0xc,\n\tMLX5_HEALTH_SYNDR_EQ_ERR\t\t= 0xd,\n\tMLX5_HEALTH_SYNDR_EQ_INV\t\t= 0xe,\n\tMLX5_HEALTH_SYNDR_FFSER_ERR\t\t= 0xf,\n\tMLX5_HEALTH_SYNDR_HIGH_TEMP\t\t= 0x10\n};\n\nenum {\n\tMLX5_DROP_NEW_HEALTH_WORK,\n};\n\nenum  {\n\tMLX5_SENSOR_NO_ERR\t\t= 0,\n\tMLX5_SENSOR_PCI_COMM_ERR\t= 1,\n\tMLX5_SENSOR_PCI_ERR\t\t= 2,\n\tMLX5_SENSOR_NIC_DISABLED\t= 3,\n\tMLX5_SENSOR_NIC_SW_RESET\t= 4,\n\tMLX5_SENSOR_FW_SYND_RFR\t\t= 5,\n};\n\nu8 mlx5_get_nic_state(struct mlx5_core_dev *dev)\n{\n\treturn (ioread32be(&dev->iseg->cmdq_addr_l_sz) >> 8) & 7;\n}\n\nvoid mlx5_set_nic_state(struct mlx5_core_dev *dev, u8 state)\n{\n\tu32 cur_cmdq_addr_l_sz;\n\n\tcur_cmdq_addr_l_sz = ioread32be(&dev->iseg->cmdq_addr_l_sz);\n\tiowrite32be((cur_cmdq_addr_l_sz & 0xFFFFF000) |\n\t\t    state << MLX5_NIC_IFC_OFFSET,\n\t\t    &dev->iseg->cmdq_addr_l_sz);\n}\n\nstatic bool sensor_pci_not_working(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\n\t/* Offline PCI reads return 0xffffffff */\n\treturn (ioread32be(&h->fw_ver) == 0xffffffff);\n}\n\nstatic bool sensor_fw_synd_rfr(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu32 rfr = ioread32be(&h->rfr) >> MLX5_RFR_OFFSET;\n\tu8 synd = ioread8(&h->synd);\n\n\tif (rfr && synd)\n\t\tmlx5_core_dbg(dev, \"FW requests reset, synd: %d\\n\", synd);\n\treturn rfr && synd;\n}\n\nstatic u32 check_fatal_sensors(struct mlx5_core_dev *dev)\n{\n\tif (sensor_pci_not_working(dev))\n\t\treturn MLX5_SENSOR_PCI_COMM_ERR;\n\tif (pci_channel_offline(dev->pdev))\n\t\treturn MLX5_SENSOR_PCI_ERR;\n\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)\n\t\treturn MLX5_SENSOR_NIC_DISABLED;\n\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_SW_RESET)\n\t\treturn MLX5_SENSOR_NIC_SW_RESET;\n\tif (sensor_fw_synd_rfr(dev))\n\t\treturn MLX5_SENSOR_FW_SYND_RFR;\n\n\treturn MLX5_SENSOR_NO_ERR;\n}\n\nstatic int lock_sem_sw_reset(struct mlx5_core_dev *dev, bool lock)\n{\n\tenum mlx5_vsc_state state;\n\tint ret;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EBUSY;\n\n\t/* Try to lock GW access, this stage doesn't return\n\t * EBUSY because locked GW does not mean that other PF\n\t * already started the reset.\n\t */\n\tret = mlx5_vsc_gw_lock(dev);\n\tif (ret == -EBUSY)\n\t\treturn -EINVAL;\n\tif (ret)\n\t\treturn ret;\n\n\tstate = lock ? MLX5_VSC_LOCK : MLX5_VSC_UNLOCK;\n\t/* At this stage, if the return status == EBUSY, then we know\n\t * for sure that another PF started the reset, so don't allow\n\t * another reset.\n\t */\n\tret = mlx5_vsc_sem_set_space(dev, MLX5_SEMAPHORE_SW_RESET, state);\n\tif (ret)\n\t\tmlx5_core_warn(dev, \"Failed to lock SW reset semaphore\\n\");\n\n\t/* Unlock GW access */\n\tmlx5_vsc_gw_unlock(dev);\n\n\treturn ret;\n}\n\nstatic bool reset_fw_if_needed(struct mlx5_core_dev *dev)\n{\n\tbool supported = (ioread32be(&dev->iseg->initializing) >>\n\t\t\t  MLX5_FW_RESET_SUPPORTED_OFFSET) & 1;\n\tu32 fatal_error;\n\n\tif (!supported)\n\t\treturn false;\n\n\t/* The reset only needs to be issued by one PF. The health buffer is\n\t * shared between all functions, and will be cleared during a reset.\n\t * Check again to avoid a redundant 2nd reset. If the fatal erros was\n\t * PCI related a reset won't help.\n\t */\n\tfatal_error = check_fatal_sensors(dev);\n\tif (fatal_error == MLX5_SENSOR_PCI_COMM_ERR ||\n\t    fatal_error == MLX5_SENSOR_NIC_DISABLED ||\n\t    fatal_error == MLX5_SENSOR_NIC_SW_RESET) {\n\t\tmlx5_core_warn(dev, \"Not issuing FW reset. Either it's already done or won't help.\");\n\t\treturn false;\n\t}\n\n\tmlx5_core_warn(dev, \"Issuing FW Reset\\n\");\n\t/* Write the NIC interface field to initiate the reset, the command\n\t * interface address also resides here, don't overwrite it.\n\t */\n\tmlx5_set_nic_state(dev, MLX5_NIC_IFC_SW_RESET);\n\n\treturn true;\n}\n\nvoid mlx5_enter_error_state(struct mlx5_core_dev *dev, bool force)\n{\n\tmutex_lock(&dev->intf_state_mutex);\n\tif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto unlock;\n\tif (dev->state == MLX5_DEVICE_STATE_UNINITIALIZED) {\n\t\tdev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;\n\t\tgoto unlock;\n\t}\n\n\tif (check_fatal_sensors(dev) || force) {\n\t\tdev->state = MLX5_DEVICE_STATE_INTERNAL_ERROR;\n\t\tmlx5_cmd_flush(dev);\n\t}\n\n\tmlx5_notifier_call_chain(dev->priv.events, MLX5_DEV_EVENT_SYS_ERROR, (void *)1);\nunlock:\n\tmutex_unlock(&dev->intf_state_mutex);\n}\n\n#define MLX5_CRDUMP_WAIT_MS\t60000\n#define MLX5_FW_RESET_WAIT_MS\t1000\nvoid mlx5_error_sw_reset(struct mlx5_core_dev *dev)\n{\n\tunsigned long end, delay_ms = MLX5_FW_RESET_WAIT_MS;\n\tint lock = -EBUSY;\n\n\tmutex_lock(&dev->intf_state_mutex);\n\tif (dev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto unlock;\n\n\tmlx5_core_err(dev, \"start\\n\");\n\n\tif (check_fatal_sensors(dev) == MLX5_SENSOR_FW_SYND_RFR) {\n\t\t/* Get cr-dump and reset FW semaphore */\n\t\tlock = lock_sem_sw_reset(dev, true);\n\n\t\tif (lock == -EBUSY) {\n\t\t\tdelay_ms = MLX5_CRDUMP_WAIT_MS;\n\t\t\tgoto recover_from_sw_reset;\n\t\t}\n\t\t/* Execute SW reset */\n\t\treset_fw_if_needed(dev);\n\t}\n\nrecover_from_sw_reset:\n\t/* Recover from SW reset */\n\tend = jiffies + msecs_to_jiffies(delay_ms);\n\tdo {\n\t\tif (mlx5_get_nic_state(dev) == MLX5_NIC_IFC_DISABLED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t} while (!time_after(jiffies, end));\n\n\tif (mlx5_get_nic_state(dev) != MLX5_NIC_IFC_DISABLED) {\n\t\tdev_err(&dev->pdev->dev, \"NIC IFC still %d after %lums.\\n\",\n\t\t\tmlx5_get_nic_state(dev), delay_ms);\n\t}\n\n\t/* Release FW semaphore if you are the lock owner */\n\tif (!lock)\n\t\tlock_sem_sw_reset(dev, false);\n\n\tmlx5_core_err(dev, \"end\\n\");\n\nunlock:\n\tmutex_unlock(&dev->intf_state_mutex);\n}\n\nstatic void mlx5_handle_bad_state(struct mlx5_core_dev *dev)\n{\n\tu8 nic_interface = mlx5_get_nic_state(dev);\n\n\tswitch (nic_interface) {\n\tcase MLX5_NIC_IFC_FULL:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is full driver\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_DISABLED:\n\t\tmlx5_core_warn(dev, \"starting teardown\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_NO_DRAM_NIC:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is no dram nic\\n\");\n\t\tbreak;\n\n\tcase MLX5_NIC_IFC_SW_RESET:\n\t\t/* The IFC mode field is 3 bits, so it will read 0x7 in 2 cases:\n\t\t * 1. PCI has been disabled (ie. PCI-AER, PF driver unloaded\n\t\t *    and this is a VF), this is not recoverable by SW reset.\n\t\t *    Logging of this is handled elsewhere.\n\t\t * 2. FW reset has been issued by another function, driver can\n\t\t *    be reloaded to recover after the mode switches to\n\t\t *    MLX5_NIC_IFC_DISABLED.\n\t\t */\n\t\tif (dev->priv.health.fatal_error != MLX5_SENSOR_PCI_COMM_ERR)\n\t\t\tmlx5_core_warn(dev, \"NIC SW reset in progress\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tmlx5_core_warn(dev, \"Expected to see disabled NIC but it is has invalid value %d\\n\",\n\t\t\t       nic_interface);\n\t}\n\n\tmlx5_disable_device(dev);\n}\n\n/* How much time to wait until health resetting the driver (in msecs) */\n#define MLX5_RECOVERY_WAIT_MSECS 60000\nstatic int mlx5_health_try_recover(struct mlx5_core_dev *dev)\n{\n\tunsigned long end;\n\n\tmlx5_core_warn(dev, \"handling bad device here\\n\");\n\tmlx5_handle_bad_state(dev);\n\tend = jiffies + msecs_to_jiffies(MLX5_RECOVERY_WAIT_MSECS);\n\twhile (sensor_pci_not_working(dev)) {\n\t\tif (time_after(jiffies, end)) {\n\t\t\tmlx5_core_err(dev,\n\t\t\t\t      \"health recovery flow aborted, PCI reads still not working\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tmsleep(100);\n\t}\n\n\tmlx5_core_err(dev, \"starting health recovery flow\\n\");\n\tmlx5_recover_device(dev);\n\tif (!test_bit(MLX5_INTERFACE_STATE_UP, &dev->intf_state) ||\n\t    check_fatal_sensors(dev)) {\n\t\tmlx5_core_err(dev, \"health recovery failed\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic const char *hsynd_str(u8 synd)\n{\n\tswitch (synd) {\n\tcase MLX5_HEALTH_SYNDR_FW_ERR:\n\t\treturn \"firmware internal error\";\n\tcase MLX5_HEALTH_SYNDR_IRISC_ERR:\n\t\treturn \"irisc not responding\";\n\tcase MLX5_HEALTH_SYNDR_HW_UNRECOVERABLE_ERR:\n\t\treturn \"unrecoverable hardware error\";\n\tcase MLX5_HEALTH_SYNDR_CRC_ERR:\n\t\treturn \"firmware CRC error\";\n\tcase MLX5_HEALTH_SYNDR_FETCH_PCI_ERR:\n\t\treturn \"ICM fetch PCI error\";\n\tcase MLX5_HEALTH_SYNDR_HW_FTL_ERR:\n\t\treturn \"HW fatal error\\n\";\n\tcase MLX5_HEALTH_SYNDR_ASYNC_EQ_OVERRUN_ERR:\n\t\treturn \"async EQ buffer overrun\";\n\tcase MLX5_HEALTH_SYNDR_EQ_ERR:\n\t\treturn \"EQ error\";\n\tcase MLX5_HEALTH_SYNDR_EQ_INV:\n\t\treturn \"Invalid EQ referenced\";\n\tcase MLX5_HEALTH_SYNDR_FFSER_ERR:\n\t\treturn \"FFSER error\";\n\tcase MLX5_HEALTH_SYNDR_HIGH_TEMP:\n\t\treturn \"High temperature\";\n\tdefault:\n\t\treturn \"unrecognized error\";\n\t}\n}\n\nstatic void print_health_info(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tchar fw_str[18];\n\tu32 fw;\n\tint i;\n\n\t/* If the syndrome is 0, the device is OK and no need to print buffer */\n\tif (!ioread8(&h->synd))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(h->assert_var); i++)\n\t\tmlx5_core_err(dev, \"assert_var[%d] 0x%08x\\n\", i,\n\t\t\t      ioread32be(h->assert_var + i));\n\n\tmlx5_core_err(dev, \"assert_exit_ptr 0x%08x\\n\",\n\t\t      ioread32be(&h->assert_exit_ptr));\n\tmlx5_core_err(dev, \"assert_callra 0x%08x\\n\",\n\t\t      ioread32be(&h->assert_callra));\n\tsprintf(fw_str, \"%d.%d.%d\", fw_rev_maj(dev), fw_rev_min(dev), fw_rev_sub(dev));\n\tmlx5_core_err(dev, \"fw_ver %s\\n\", fw_str);\n\tmlx5_core_err(dev, \"hw_id 0x%08x\\n\", ioread32be(&h->hw_id));\n\tmlx5_core_err(dev, \"irisc_index %d\\n\", ioread8(&h->irisc_index));\n\tmlx5_core_err(dev, \"synd 0x%x: %s\\n\", ioread8(&h->synd),\n\t\t      hsynd_str(ioread8(&h->synd)));\n\tmlx5_core_err(dev, \"ext_synd 0x%04x\\n\", ioread16be(&h->ext_synd));\n\tfw = ioread32be(&h->fw_ver);\n\tmlx5_core_err(dev, \"raw fw_ver 0x%08x\\n\", fw);\n}\n\nstatic int\nmlx5_fw_reporter_diagnose(struct devlink_health_reporter *reporter,\n\t\t\t  struct devlink_fmsg *fmsg)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu8 synd;\n\tint err;\n\n\tsynd = ioread8(&h->synd);\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"Syndrome\", synd);\n\tif (err || !synd)\n\t\treturn err;\n\treturn devlink_fmsg_string_pair_put(fmsg, \"Description\", hsynd_str(synd));\n}\n\nstruct mlx5_fw_reporter_ctx {\n\tu8 err_synd;\n\tint miss_counter;\n};\n\nstatic int\nmlx5_fw_reporter_ctx_pairs_put(struct devlink_fmsg *fmsg,\n\t\t\t       struct mlx5_fw_reporter_ctx *fw_reporter_ctx)\n{\n\tint err;\n\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"syndrome\",\n\t\t\t\t       fw_reporter_ctx->err_synd);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"fw_miss_counter\",\n\t\t\t\t\tfw_reporter_ctx->miss_counter);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int\nmlx5_fw_reporter_heath_buffer_data_put(struct mlx5_core_dev *dev,\n\t\t\t\t       struct devlink_fmsg *fmsg)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tint err;\n\tint i;\n\n\tif (!ioread8(&h->synd))\n\t\treturn 0;\n\n\terr = devlink_fmsg_pair_nest_start(fmsg, \"health buffer\");\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_obj_nest_start(fmsg);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"assert_var\");\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(h->assert_var); i++) {\n\t\terr = devlink_fmsg_u32_put(fmsg, ioread32be(h->assert_var + i));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"assert_exit_ptr\",\n\t\t\t\t\tioread32be(&h->assert_exit_ptr));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"assert_callra\",\n\t\t\t\t\tioread32be(&h->assert_callra));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"hw_id\", ioread32be(&h->hw_id));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"irisc_index\",\n\t\t\t\t       ioread8(&h->irisc_index));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"synd\", ioread8(&h->synd));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"ext_synd\",\n\t\t\t\t\tioread16be(&h->ext_synd));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"raw_fw_ver\",\n\t\t\t\t\tioread32be(&h->fw_ver));\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\treturn devlink_fmsg_pair_nest_end(fmsg);\n}\n\nstatic int\nmlx5_fw_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t      struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tint err;\n\n\terr = mlx5_fw_tracer_trigger_core_dump_general(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mlx5_fw_reporter_heath_buffer_data_put(dev, fmsg);\n\tif (err)\n\t\treturn err;\n\treturn mlx5_fw_tracer_get_saved_traces_objects(dev->tracer, fmsg);\n}\n\nstatic void mlx5_fw_reporter_err_work(struct work_struct *work)\n{\n\tstruct mlx5_fw_reporter_ctx fw_reporter_ctx;\n\tstruct mlx5_core_health *health;\n\n\thealth = container_of(work, struct mlx5_core_health, report_work);\n\n\tif (IS_ERR_OR_NULL(health->fw_reporter))\n\t\treturn;\n\n\tfw_reporter_ctx.err_synd = health->synd;\n\tfw_reporter_ctx.miss_counter = health->miss_counter;\n\tif (fw_reporter_ctx.err_synd) {\n\t\tdevlink_health_report(health->fw_reporter,\n\t\t\t\t      \"FW syndrom reported\", &fw_reporter_ctx);\n\t\treturn;\n\t}\n\tif (fw_reporter_ctx.miss_counter)\n\t\tdevlink_health_report(health->fw_reporter,\n\t\t\t\t      \"FW miss counter reported\",\n\t\t\t\t      &fw_reporter_ctx);\n}\n\nstatic const struct devlink_health_reporter_ops mlx5_fw_reporter_ops = {\n\t\t.name = \"fw\",\n\t\t.diagnose = mlx5_fw_reporter_diagnose,\n\t\t.dump = mlx5_fw_reporter_dump,\n};\n\nstatic int\nmlx5_fw_fatal_reporter_recover(struct devlink_health_reporter *reporter,\n\t\t\t       void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\n\treturn mlx5_health_try_recover(dev);\n}\n\n#define MLX5_CR_DUMP_CHUNK_SIZE 256\nstatic int\nmlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\tgoto free_data;\n\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}\n\nstatic void mlx5_fw_fatal_reporter_err_work(struct work_struct *work)\n{\n\tstruct mlx5_fw_reporter_ctx fw_reporter_ctx;\n\tstruct mlx5_core_health *health;\n\tstruct mlx5_core_dev *dev;\n\tstruct mlx5_priv *priv;\n\n\thealth = container_of(work, struct mlx5_core_health, fatal_report_work);\n\tpriv = container_of(health, struct mlx5_priv, health);\n\tdev = container_of(priv, struct mlx5_core_dev, priv);\n\n\tmlx5_enter_error_state(dev, false);\n\tif (IS_ERR_OR_NULL(health->fw_fatal_reporter)) {\n\t\tif (mlx5_health_try_recover(dev))\n\t\t\tmlx5_core_err(dev, \"health recovery failed\\n\");\n\t\treturn;\n\t}\n\tfw_reporter_ctx.err_synd = health->synd;\n\tfw_reporter_ctx.miss_counter = health->miss_counter;\n\tdevlink_health_report(health->fw_fatal_reporter,\n\t\t\t      \"FW fatal error reported\", &fw_reporter_ctx);\n}\n\nstatic const struct devlink_health_reporter_ops mlx5_fw_fatal_reporter_ops = {\n\t\t.name = \"fw_fatal\",\n\t\t.recover = mlx5_fw_fatal_reporter_recover,\n\t\t.dump = mlx5_fw_fatal_reporter_dump,\n};\n\n#define MLX5_REPORTER_FW_GRACEFUL_PERIOD 1200000\nstatic void mlx5_fw_reporters_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct devlink *devlink = priv_to_devlink(dev);\n\n\thealth->fw_reporter =\n\t\tdevlink_health_reporter_create(devlink, &mlx5_fw_reporter_ops,\n\t\t\t\t\t       0, false, dev);\n\tif (IS_ERR(health->fw_reporter))\n\t\tmlx5_core_warn(dev, \"Failed to create fw reporter, err = %ld\\n\",\n\t\t\t       PTR_ERR(health->fw_reporter));\n\n\thealth->fw_fatal_reporter =\n\t\tdevlink_health_reporter_create(devlink,\n\t\t\t\t\t       &mlx5_fw_fatal_reporter_ops,\n\t\t\t\t\t       MLX5_REPORTER_FW_GRACEFUL_PERIOD,\n\t\t\t\t\t       true, dev);\n\tif (IS_ERR(health->fw_fatal_reporter))\n\t\tmlx5_core_warn(dev, \"Failed to create fw fatal reporter, err = %ld\\n\",\n\t\t\t       PTR_ERR(health->fw_fatal_reporter));\n}\n\nstatic void mlx5_fw_reporters_destroy(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tif (!IS_ERR_OR_NULL(health->fw_reporter))\n\t\tdevlink_health_reporter_destroy(health->fw_reporter);\n\n\tif (!IS_ERR_OR_NULL(health->fw_fatal_reporter))\n\t\tdevlink_health_reporter_destroy(health->fw_fatal_reporter);\n}\n\nstatic unsigned long get_next_poll_jiffies(void)\n{\n\tunsigned long next;\n\n\tget_random_bytes(&next, sizeof(next));\n\tnext %= HZ;\n\tnext += jiffies + MLX5_HEALTH_POLL_INTERVAL;\n\n\treturn next;\n}\n\nvoid mlx5_trigger_health_work(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&health->wq_lock, flags);\n\tif (!test_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags))\n\t\tqueue_work(health->wq, &health->fatal_report_work);\n\telse\n\t\tmlx5_core_err(dev, \"new health works are not permitted at this stage\\n\");\n\tspin_unlock_irqrestore(&health->wq_lock, flags);\n}\n\nstatic void poll_health(struct timer_list *t)\n{\n\tstruct mlx5_core_dev *dev = from_timer(dev, t, priv.health.timer);\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tstruct health_buffer __iomem *h = health->health;\n\tu32 fatal_error;\n\tu8 prev_synd;\n\tu32 count;\n\n\tif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto out;\n\n\tfatal_error = check_fatal_sensors(dev);\n\n\tif (fatal_error && !health->fatal_error) {\n\t\tmlx5_core_err(dev, \"Fatal error %u detected\\n\", fatal_error);\n\t\tdev->priv.health.fatal_error = fatal_error;\n\t\tprint_health_info(dev);\n\t\tmlx5_trigger_health_work(dev);\n\t\tgoto out;\n\t}\n\n\tcount = ioread32be(health->health_counter);\n\tif (count == health->prev)\n\t\t++health->miss_counter;\n\telse\n\t\thealth->miss_counter = 0;\n\n\thealth->prev = count;\n\tif (health->miss_counter == MAX_MISSES) {\n\t\tmlx5_core_err(dev, \"device's health compromised - reached miss count\\n\");\n\t\tprint_health_info(dev);\n\t\tqueue_work(health->wq, &health->report_work);\n\t}\n\n\tprev_synd = health->synd;\n\thealth->synd = ioread8(&h->synd);\n\tif (health->synd && health->synd != prev_synd)\n\t\tqueue_work(health->wq, &health->report_work);\n\nout:\n\tmod_timer(&health->timer, get_next_poll_jiffies());\n}\n\nvoid mlx5_start_health_poll(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\ttimer_setup(&health->timer, poll_health, 0);\n\thealth->fatal_error = MLX5_SENSOR_NO_ERR;\n\tclear_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);\n\thealth->health = &dev->iseg->health;\n\thealth->health_counter = &dev->iseg->health_counter;\n\n\thealth->timer.expires = round_jiffies(jiffies + MLX5_HEALTH_POLL_INTERVAL);\n\tadd_timer(&health->timer);\n}\n\nvoid mlx5_stop_health_poll(struct mlx5_core_dev *dev, bool disable_health)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tunsigned long flags;\n\n\tif (disable_health) {\n\t\tspin_lock_irqsave(&health->wq_lock, flags);\n\t\tset_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);\n\t\tspin_unlock_irqrestore(&health->wq_lock, flags);\n\t}\n\n\tdel_timer_sync(&health->timer);\n}\n\nvoid mlx5_drain_health_wq(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&health->wq_lock, flags);\n\tset_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);\n\tspin_unlock_irqrestore(&health->wq_lock, flags);\n\tcancel_work_sync(&health->report_work);\n\tcancel_work_sync(&health->fatal_report_work);\n}\n\nvoid mlx5_health_flush(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tflush_workqueue(health->wq);\n}\n\nvoid mlx5_health_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health = &dev->priv.health;\n\n\tdestroy_workqueue(health->wq);\n\tmlx5_fw_reporters_destroy(dev);\n}\n\nint mlx5_health_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_core_health *health;\n\tchar *name;\n\n\tmlx5_fw_reporters_create(dev);\n\n\thealth = &dev->priv.health;\n\tname = kmalloc(64, GFP_KERNEL);\n\tif (!name)\n\t\tgoto out_err;\n\n\tstrcpy(name, \"mlx5_health\");\n\tstrcat(name, dev_name(dev->device));\n\thealth->wq = create_singlethread_workqueue(name);\n\tkfree(name);\n\tif (!health->wq)\n\t\tgoto out_err;\n\tspin_lock_init(&health->wq_lock);\n\tINIT_WORK(&health->fatal_report_work, mlx5_fw_fatal_reporter_err_work);\n\tINIT_WORK(&health->report_work, mlx5_fw_reporter_err_work);\n\n\treturn 0;\n\nout_err:\n\tmlx5_fw_reporters_destroy(dev);\n\treturn -ENOMEM;\n}\n"], "filenames": ["drivers/net/ethernet/mellanox/mlx5/core/health.c"], "buggy_code_start_loc": [575], "buggy_code_end_loc": [576], "fixing_code_start_loc": [575], "fixing_code_end_loc": [576], "type": "CWE-401", "message": "A memory leak in the mlx5_fw_fatal_reporter_dump() function in drivers/net/ethernet/mellanox/mlx5/core/health.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_crdump_collect() failures, aka CID-c7ed6d0183d5.", "other": {"cve": {"id": "CVE-2019-19047", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.497", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the mlx5_fw_fatal_reporter_dump() function in drivers/net/ethernet/mellanox/mlx5/core/health.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering mlx5_crdump_collect() failures, aka CID-c7ed6d0183d5."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n mlx5_fw_fatal_reporter_dump() en el archivo drivers/net/ethernet/mellanox/mlx5/core/health.c en el kernel de Linux versiones anteriores a la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n mlx5_crdump_collect(), tambi\u00e9n se conoce como CID-c7ed6d0183d5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.11", "matchCriteriaId": "AFBC7FC6-5284-45A6-AEF0-98EE91D9A0A5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c7ed6d0183d5ea9bc31bcaeeba4070bd62546471", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c7ed6d0183d5ea9bc31bcaeeba4070bd62546471"}}