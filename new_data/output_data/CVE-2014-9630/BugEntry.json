{"buggy_code": ["/*****************************************************************************\n * rtpfmt.c: RTP payload formats\n *****************************************************************************\n * Copyright (C) 2003-2004 VLC authors and VideoLAN\n * Copyright \u00a9 2007 R\u00e9mi Denis-Courmont\n * $Id$\n *\n * Authors: Laurent Aimar <fenrir@via.ecp.fr>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.\n *****************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <vlc_common.h>\n#include <vlc_sout.h>\n#include <vlc_block.h>\n#include <vlc_strings.h>\n\n#include \"rtp.h\"\n#include \"../demux/xiph.h\"\n\n#include <assert.h>\n\nstatic int rtp_packetize_mpa  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_mpv  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_ac3  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_simple(sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_split(sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_pcm(sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_swab (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_mp4a (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_mp4a_latm (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_h263 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_h264 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_amr  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_spx  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_t140 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_g726_16 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_g726_24 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_g726_32 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_g726_40 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_xiph (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_vp8 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_jpeg (sout_stream_id_sys_t *, block_t *);\n\n#define XIPH_IDENT (0)\n\n/* Helpers common to xiph codecs (vorbis and theora) */\n\nstatic int rtp_xiph_pack_headers(size_t room, void *p_extra, size_t i_extra,\n                                 uint8_t **p_buffer, size_t *i_buffer,\n                                 uint8_t *theora_pixel_fmt)\n{\n    unsigned packet_size[XIPH_MAX_HEADER_COUNT];\n    void *packet[XIPH_MAX_HEADER_COUNT];\n    unsigned packet_count;\n    if (xiph_SplitHeaders(packet_size, packet, &packet_count,\n                                i_extra, p_extra))\n        return VLC_EGENERIC;;\n    if (packet_count < 3)\n        return VLC_EGENERIC;;\n\n    if (theora_pixel_fmt != NULL)\n    {\n        if (packet_size[0] < 42)\n            return VLC_EGENERIC;\n        *theora_pixel_fmt = (((uint8_t *)packet[0])[41] >> 3) & 0x03;\n    }\n\n    unsigned length_size[2] = { 0, 0 };\n    for (int i = 0; i < 2; i++)\n    {\n        unsigned size = packet_size[i];\n        while (size > 0)\n        {\n            length_size[i]++;\n            size >>= 7;\n        }\n    }\n\n    *i_buffer = room + 1 + length_size[0] + length_size[1]\n                + packet_size[0] + packet_size[1] + packet_size[2];\n    *p_buffer = malloc(*i_buffer);\n    if (*p_buffer == NULL)\n        return VLC_ENOMEM;\n\n    uint8_t *p = *p_buffer + room;\n    /* Number of headers */\n    *p++ = 2;\n\n    for (int i = 0; i < 2; i++)\n    {\n        unsigned size = length_size[i];\n        while (size > 0)\n        {\n            *p = (packet_size[i] >> (7 * (size - 1))) & 0x7f;\n            if (--size > 0)\n                *p |= 0x80;\n            p++;\n        }\n    }\n    for (int i = 0; i < 3; i++)\n    {\n        memcpy(p, packet[i], packet_size[i]);\n        p += packet_size[i];\n    }\n\n    return VLC_SUCCESS;\n}\n\nstatic char *rtp_xiph_b64_oob_config(void *p_extra, size_t i_extra,\n                                     uint8_t *theora_pixel_fmt)\n{\n    uint8_t *p_buffer;\n    size_t i_buffer;\n    if (rtp_xiph_pack_headers(9, p_extra, i_extra, &p_buffer, &i_buffer,\n                              theora_pixel_fmt) != VLC_SUCCESS)\n        return NULL;\n\n    /* Number of packed headers */\n    SetDWBE(p_buffer, 1);\n    /* Ident */\n    uint32_t ident = XIPH_IDENT;\n    SetWBE(p_buffer + 4, ident >> 8);\n    p_buffer[6] = ident & 0xff;\n    /* Length field */\n    SetWBE(p_buffer + 7, i_buffer);\n\n    char *config = vlc_b64_encode_binary(p_buffer, i_buffer);\n    free(p_buffer);\n    return config;\n}\n\nstatic void sprintf_hexa( char *s, uint8_t *p_data, int i_data )\n{\n    static const char hex[16] = \"0123456789abcdef\";\n\n    for( int i = 0; i < i_data; i++ )\n    {\n        s[2*i+0] = hex[(p_data[i]>>4)&0xf];\n        s[2*i+1] = hex[(p_data[i]   )&0xf];\n    }\n    s[2*i_data] = '\\0';\n}\n\n/* TODO: make this into something more clever than a big switch? */\nint rtp_get_fmt( vlc_object_t *obj, es_format_t *p_fmt, const char *mux,\n                  rtp_format_t *rtp_fmt )\n{\n    assert( p_fmt != NULL || mux != NULL );\n\n    /* Dynamic payload type. Payload types are scoped to the RTP\n     * session, and we put each ES in its own session, so no risk of\n     * conflict. */\n    rtp_fmt->payload_type = 96;\n    rtp_fmt->cat = mux != NULL ? VIDEO_ES : p_fmt->i_cat;\n    if( rtp_fmt->cat == AUDIO_ES )\n    {\n        rtp_fmt->clock_rate = p_fmt->audio.i_rate;\n        rtp_fmt->channels = p_fmt->audio.i_channels;\n    }\n    else\n        rtp_fmt->clock_rate = 90000; /* most common case for video */\n    /* Stream bitrate in kbps */\n    rtp_fmt->bitrate = p_fmt != NULL ? p_fmt->i_bitrate/1000 : 0;\n    rtp_fmt->fmtp = NULL;\n\n    if( mux != NULL )\n    {\n        if( strncmp( mux, \"ts\", 2 ) == 0 )\n        {\n            rtp_fmt->payload_type = 33;\n            rtp_fmt->ptname = \"MP2T\";\n        }\n        else\n            rtp_fmt->ptname = \"MP2P\";\n        return VLC_SUCCESS;\n    }\n\n    switch( p_fmt->i_codec )\n    {\n        case VLC_CODEC_MULAW:\n            if( p_fmt->audio.i_channels == 1 && p_fmt->audio.i_rate == 8000 )\n                rtp_fmt->payload_type = 0;\n            rtp_fmt->ptname = \"PCMU\";\n            rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            break;\n        case VLC_CODEC_ALAW:\n            if( p_fmt->audio.i_channels == 1 && p_fmt->audio.i_rate == 8000 )\n                rtp_fmt->payload_type = 8;\n            rtp_fmt->ptname = \"PCMA\";\n            rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            break;\n        case VLC_CODEC_S16B:\n        case VLC_CODEC_S16L:\n            if( p_fmt->audio.i_channels == 1 && p_fmt->audio.i_rate == 44100 )\n            {\n                rtp_fmt->payload_type = 11;\n            }\n            else if( p_fmt->audio.i_channels == 2 &&\n                     p_fmt->audio.i_rate == 44100 )\n            {\n                rtp_fmt->payload_type = 10;\n            }\n            rtp_fmt->ptname = \"L16\";\n            if( p_fmt->i_codec == VLC_CODEC_S16B )\n                rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            else\n                rtp_fmt->pf_packetize = rtp_packetize_swab;\n            break;\n        case VLC_CODEC_U8:\n            rtp_fmt->ptname = \"L8\";\n            rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            break;\n        case VLC_CODEC_S24B:\n            rtp_fmt->ptname = \"L24\";\n            rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            break;\n        case VLC_CODEC_MPGA:\n            rtp_fmt->payload_type = 14;\n            rtp_fmt->ptname = \"MPA\";\n            rtp_fmt->clock_rate = 90000; /* not 44100 */\n            rtp_fmt->pf_packetize = rtp_packetize_mpa;\n            break;\n        case VLC_CODEC_MPGV:\n            rtp_fmt->payload_type = 32;\n            rtp_fmt->ptname = \"MPV\";\n            rtp_fmt->pf_packetize = rtp_packetize_mpv;\n            break;\n        case VLC_CODEC_ADPCM_G726:\n            switch( p_fmt->i_bitrate / 1000 )\n            {\n            case 16:\n                rtp_fmt->ptname = \"G726-16\";\n                rtp_fmt->pf_packetize = rtp_packetize_g726_16;\n                break;\n            case 24:\n                rtp_fmt->ptname = \"G726-24\";\n                rtp_fmt->pf_packetize = rtp_packetize_g726_24;\n                break;\n            case 32:\n                rtp_fmt->ptname = \"G726-32\";\n                rtp_fmt->pf_packetize = rtp_packetize_g726_32;\n                break;\n            case 40:\n                rtp_fmt->ptname = \"G726-40\";\n                rtp_fmt->pf_packetize = rtp_packetize_g726_40;\n                break;\n            default:\n                msg_Err( obj, \"cannot add this stream (unsupported \"\n                         \"G.726 bit rate: %u)\", p_fmt->i_bitrate );\n                return VLC_EGENERIC;\n            }\n            break;\n        case VLC_CODEC_A52:\n            rtp_fmt->ptname = \"ac3\";\n            rtp_fmt->pf_packetize = rtp_packetize_ac3;\n            break;\n        case VLC_CODEC_H263:\n            rtp_fmt->ptname = \"H263-1998\";\n            rtp_fmt->pf_packetize = rtp_packetize_h263;\n            break;\n        case VLC_CODEC_H264:\n            rtp_fmt->ptname = \"H264\";\n            rtp_fmt->pf_packetize = rtp_packetize_h264;\n            rtp_fmt->fmtp = NULL;\n\n            if( p_fmt->i_extra > 0 )\n            {\n                uint8_t *p_buffer = p_fmt->p_extra;\n                int     i_buffer = p_fmt->i_extra;\n                char    *p_64_sps = NULL;\n                char    *p_64_pps = NULL;\n                char    hexa[6+1];\n\n                while( i_buffer > 4 )\n                {\n                    int i_offset    = 0;\n                    int i_size      = 0;\n\n                    while( p_buffer[0] != 0 || p_buffer[1] != 0 ||\n                           p_buffer[2] != 1 )\n                    {\n                        p_buffer++;\n                        i_buffer--;\n                        if( i_buffer == 0 ) break;\n                    }\n\n                    if( i_buffer < 4 || memcmp(p_buffer, \"\\x00\\x00\\x01\", 3 ) )\n                    {\n                        msg_Dbg( obj, \"No startcode found..\");\n                        break;\n                    }\n                    p_buffer += 3;\n                    i_buffer -= 3;\n\n                    const int i_nal_type = p_buffer[0]&0x1f;\n\n                    msg_Dbg( obj, \"we found a startcode for NAL with TYPE:%d\", i_nal_type );\n\n                    i_size = i_buffer;\n                    for( i_offset = 0; i_offset+2 < i_buffer ; i_offset++)\n                    {\n                        if( !memcmp(p_buffer + i_offset, \"\\x00\\x00\\x01\", 3 ) )\n                        {\n                            /* we found another startcode */\n                            while( i_offset > 0 && 0 == p_buffer[ i_offset - 1 ] )\n                                i_offset--;\n                            i_size = i_offset;\n                            break;\n                        }\n                    }\n\n                    if( i_size == 0 )\n                    {\n                        msg_Dbg( obj, \"No-info found in nal \");\n                        continue;\n                    }\n\n                    if( i_nal_type == 7 )\n                    {\n                        free( p_64_sps );\n                        p_64_sps = vlc_b64_encode_binary( p_buffer, i_size );\n                        /* XXX: nothing ensures that i_size >= 4 ?? */\n                        sprintf_hexa( hexa, &p_buffer[1], 3 );\n                    }\n                    else if( i_nal_type == 8 )\n                    {\n                        free( p_64_pps );\n                        p_64_pps = vlc_b64_encode_binary( p_buffer, i_size );\n                    }\n                    i_buffer -= i_size;\n                    p_buffer += i_size;\n                }\n                /* */\n                if( p_64_sps && p_64_pps &&\n                    ( asprintf( &rtp_fmt->fmtp,\n                                \"packetization-mode=1;profile-level-id=%s;\"\n                                \"sprop-parameter-sets=%s,%s;\", hexa, p_64_sps,\n                                p_64_pps ) == -1 ) )\n                    rtp_fmt->fmtp = NULL;\n                free( p_64_sps );\n                free( p_64_pps );\n            }\n            if( rtp_fmt->fmtp == NULL )\n                rtp_fmt->fmtp = strdup( \"packetization-mode=1\" );\n            break;\n\n        case VLC_CODEC_MP4V:\n        {\n            rtp_fmt->ptname = \"MP4V-ES\";\n            rtp_fmt->pf_packetize = rtp_packetize_split;\n            if( p_fmt->i_extra > 0 )\n            {\n                char hexa[2*p_fmt->i_extra +1];\n                sprintf_hexa( hexa, p_fmt->p_extra, p_fmt->i_extra );\n                if( asprintf( &rtp_fmt->fmtp,\n                              \"profile-level-id=3; config=%s;\", hexa ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n            }\n            break;\n        }\n        case VLC_CODEC_MP4A:\n        {\n            if( ! var_InheritBool( obj, \"sout-rtp-mp4a-latm\" ) )\n            {\n                char hexa[2*p_fmt->i_extra +1];\n\n                rtp_fmt->ptname = \"mpeg4-generic\";\n                rtp_fmt->pf_packetize = rtp_packetize_mp4a;\n                sprintf_hexa( hexa, p_fmt->p_extra, p_fmt->i_extra );\n                if( asprintf( &rtp_fmt->fmtp,\n                              \"streamtype=5; profile-level-id=15; \"\n                              \"mode=AAC-hbr; config=%s; SizeLength=13; \"\n                              \"IndexLength=3; IndexDeltaLength=3; Profile=1;\",\n                              hexa ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n            }\n            else\n            {\n                char hexa[13];\n                int i;\n                unsigned char config[6];\n                unsigned int aacsrates[15] = {\n                    96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,\n                    16000, 12000, 11025, 8000, 7350, 0, 0 };\n\n                for( i = 0; i < 15; i++ )\n                    if( p_fmt->audio.i_rate == aacsrates[i] )\n                        break;\n\n                config[0]=0x40;\n                config[1]=0;\n                config[2]=0x20|i;\n                config[3]=p_fmt->audio.i_channels<<4;\n                config[4]=0x3f;\n                config[5]=0xc0;\n\n                rtp_fmt->ptname = \"MP4A-LATM\";\n                rtp_fmt->pf_packetize = rtp_packetize_mp4a_latm;\n                sprintf_hexa( hexa, config, 6 );\n                if( asprintf( &rtp_fmt->fmtp, \"profile-level-id=15; \"\n                              \"object=2; cpresent=0; config=%s\", hexa ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n            }\n            break;\n        }\n        case VLC_CODEC_AMR_NB:\n            rtp_fmt->ptname = \"AMR\";\n            rtp_fmt->fmtp = strdup( \"octet-align=1\" );\n            rtp_fmt->pf_packetize = rtp_packetize_amr;\n            break;\n        case VLC_CODEC_AMR_WB:\n            rtp_fmt->ptname = \"AMR-WB\";\n            rtp_fmt->fmtp = strdup( \"octet-align=1\" );\n            rtp_fmt->pf_packetize = rtp_packetize_amr;\n            break;\n        case VLC_CODEC_SPEEX:\n            rtp_fmt->ptname = \"SPEEX\";\n            rtp_fmt->pf_packetize = rtp_packetize_spx;\n            break;\n        case VLC_CODEC_VORBIS:\n            rtp_fmt->ptname = \"vorbis\";\n            rtp_fmt->pf_packetize = rtp_packetize_xiph;\n            if( p_fmt->i_extra > 0 )\n            {\n                rtp_fmt->fmtp = NULL;\n                char *config = rtp_xiph_b64_oob_config(p_fmt->p_extra,\n                                                       p_fmt->i_extra, NULL);\n                if (config == NULL)\n                    break;\n                if( asprintf( &rtp_fmt->fmtp,\n                              \"configuration=%s;\", config ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n                free(config);\n            }\n            break;\n        case VLC_CODEC_THEORA:\n            rtp_fmt->ptname = \"theora\";\n            rtp_fmt->pf_packetize = rtp_packetize_xiph;\n            if( p_fmt->i_extra > 0 )\n            {\n                rtp_fmt->fmtp = NULL;\n                uint8_t pixel_fmt, c1, c2;\n                char *config = rtp_xiph_b64_oob_config(p_fmt->p_extra,\n                                                       p_fmt->i_extra,\n                                                       &pixel_fmt);\n                if (config == NULL)\n                    break;\n\n                if (pixel_fmt == 1)\n                {\n                    /* reserved */\n                    free(config);\n                    break;\n                }\n                switch (pixel_fmt)\n                {\n                    case 0:\n                        c1 = 2;\n                        c2 = 0;\n                        break;\n                    case 2:\n                        c1 = c2 = 2;\n                        break;\n                    case 3:\n                        c1 = c2 = 4;\n                        break;\n                    default:\n                        assert(0);\n                }\n\n                if( asprintf( &rtp_fmt->fmtp,\n                              \"sampling=YCbCr-4:%d:%d; width=%d; height=%d; \"\n                              \"delivery-method=inline; configuration=%s; \"\n                              \"delivery-method=in_band;\", c1, c2,\n                              p_fmt->video.i_width, p_fmt->video.i_height,\n                              config ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n                free(config);\n            }\n            break;\n        case VLC_CODEC_ITU_T140:\n            rtp_fmt->ptname = \"t140\" ;\n            rtp_fmt->clock_rate = 1000;\n            rtp_fmt->pf_packetize = rtp_packetize_t140;\n            break;\n        case VLC_CODEC_GSM:\n            rtp_fmt->payload_type = 3;\n            rtp_fmt->ptname = \"GSM\";\n            rtp_fmt->pf_packetize = rtp_packetize_split;\n            break;\n        case VLC_CODEC_OPUS:\n            if (p_fmt->audio.i_channels > 2)\n            {\n                msg_Err( obj, \"Multistream opus not supported in RTP\"\n                         \" (having %d channels input)\",\n                         p_fmt->audio.i_channels );\n                return VLC_EGENERIC;\n            }\n            rtp_fmt->ptname = \"opus\";\n            rtp_fmt->pf_packetize = rtp_packetize_simple;\n            rtp_fmt->clock_rate = 48000;\n            rtp_fmt->channels = 2;\n            if (p_fmt->audio.i_channels == 2)\n                rtp_fmt->fmtp = strdup( \"sprop-stereo=1\" );\n            break;\n        case VLC_CODEC_VP8:\n            rtp_fmt->ptname = \"VP8\";\n            rtp_fmt->pf_packetize = rtp_packetize_vp8;\n            break;\n        case VLC_CODEC_MJPG:\n        case VLC_CODEC_JPEG:\n            rtp_fmt->ptname = \"JPEG\";\n            rtp_fmt->payload_type = 26;\n            rtp_fmt->pf_packetize = rtp_packetize_jpeg;\n            break;\n\n        default:\n            msg_Err( obj, \"cannot add this stream (unsupported \"\n                     \"codec: %4.4s)\", (char*)&p_fmt->i_codec );\n            return VLC_EGENERIC;\n    }\n\n    return VLC_SUCCESS;\n}\n\n\nstatic int\nrtp_packetize_h264_nal( sout_stream_id_sys_t *id,\n                        const uint8_t *p_data, int i_data, int64_t i_pts,\n                        int64_t i_dts, bool b_last, int64_t i_length );\n\nint rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n\n    /* extract base64 configuration from fmtp */\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n    char b64[len + 1];\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n\n    int     i_max   = rtp_mtu (id) - 6; /* payload max in one packet */\n\n    uint8_t *p_orig, *p_data;\n    int i_data;\n\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        /* Ident:24, Fragment type:2, Vorbis/Theora Data Type:2, # of pkts:4 */\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, 0, i_pts );\n\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n\n        out->i_dts    = i_pts;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    free(p_orig);\n\n    return VLC_SUCCESS;\n}\n\n/* rfc5215 */\nstatic int rtp_packetize_xiph( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 6; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            /* No fragmentation */\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            /* Fragmentation */\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        /* Ident:24, Fragment type:2, Vorbis/Theora Data Type:2, # of pkts:4 */\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (0 << 4) | numpkts;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, 0, in->i_pts);\n\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_mpa( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 4; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 16 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0, in->i_pts );\n        /* mbz set to 0 */\n        SetWBE( out->p_buffer + 12, 0 );\n        /* fragment offset in the current frame */\n        SetWBE( out->p_buffer + 14, i * i_max );\n        memcpy( &out->p_buffer[16], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n/* rfc2250 */\nstatic int rtp_packetize_mpv( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 4; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n    int     b_sequence_start = 0;\n    int     i_temporal_ref = 0;\n    int     i_picture_coding_type = 0;\n    int     i_fbv = 0, i_bfc = 0, i_ffv = 0, i_ffc = 0;\n    int     b_start_slice = 0;\n\n    /* preparse this packet to get some info */\n    if( in->i_buffer > 4 )\n    {\n        uint8_t *p = p_data;\n        int      i_rest = in->i_buffer;\n\n        for( ;; )\n        {\n            while( i_rest > 4 &&\n                   ( p[0] != 0x00 || p[1] != 0x00 || p[2] != 0x01 ) )\n            {\n                p++;\n                i_rest--;\n            }\n            if( i_rest <= 4 )\n            {\n                break;\n            }\n            p += 3;\n            i_rest -= 4;\n\n            if( *p == 0xb3 )\n            {\n                /* sequence start code */\n                b_sequence_start = 1;\n            }\n            else if( *p == 0x00 && i_rest >= 4 )\n            {\n                /* picture */\n                i_temporal_ref = ( p[1] << 2) |((p[2]>>6)&0x03);\n                i_picture_coding_type = (p[2] >> 3)&0x07;\n\n                if( i_rest >= 4 && ( i_picture_coding_type == 2 ||\n                                    i_picture_coding_type == 3 ) )\n                {\n                    i_ffv = (p[3] >> 2)&0x01;\n                    i_ffc = ((p[3]&0x03) << 1)|((p[4]>>7)&0x01);\n                    if( i_rest > 4 && i_picture_coding_type == 3 )\n                    {\n                        i_fbv = (p[4]>>6)&0x01;\n                        i_bfc = (p[4]>>3)&0x07;\n                    }\n                }\n            }\n            else if( *p <= 0xaf )\n            {\n                b_start_slice = 1;\n            }\n        }\n    }\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 16 + i_payload );\n        /* MBZ:5 T:1 TR:10 AN:1 N:1 S:1 B:1 E:1 P:3 FBV:1 BFC:3 FFV:1 FFC:3 */\n        uint32_t      h = ( i_temporal_ref << 16 )|\n                          ( b_sequence_start << 13 )|\n                          ( b_start_slice << 12 )|\n                          ( i == i_count - 1 ? 1 << 11 : 0 )|\n                          ( i_picture_coding_type << 8 )|\n                          ( i_fbv << 7 )|( i_bfc << 4 )|( i_ffv << 3 )|i_ffc;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0,\n                          in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts );\n\n        SetDWBE( out->p_buffer + 12, h );\n\n        memcpy( &out->p_buffer[16], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_ac3( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 2; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 14 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0, in->i_pts );\n        /* unit count */\n        out->p_buffer[12] = 1;\n        /* unit header */\n        out->p_buffer[13] = 0x00;\n        /* data */\n        memcpy( &out->p_buffer[14], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_simple(sout_stream_id_sys_t *id, block_t *block)\n{\n    bool marker = (block->i_flags & BLOCK_FLAG_DISCONTINUITY) != 0;\n\n    block = block_Realloc(block, 12, block->i_buffer);\n    if (unlikely(block == NULL))\n        return VLC_ENOMEM;\n\n    rtp_packetize_common(id, block, marker, block->i_pts);\n    rtp_packetize_send(id, block);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_split( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id); /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 12 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        memcpy( &out->p_buffer[12], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_pcm(sout_stream_id_sys_t *id, block_t *in)\n{\n    unsigned max = rtp_mtu(id);\n\n    while (in->i_buffer > max)\n    {\n        unsigned duration = (in->i_length * max) / in->i_buffer;\n        bool marker = (in->i_flags & BLOCK_FLAG_DISCONTINUITY) != 0;\n\n        block_t *out = block_Alloc(12 + max);\n        if (unlikely(out == NULL))\n        {\n            block_Release(in);\n            return VLC_ENOMEM;\n        }\n\n        rtp_packetize_common(id, out, marker, in->i_pts);\n        memcpy(out->p_buffer + 12, in->p_buffer, max);\n        rtp_packetize_send(id, out);\n\n        in->p_buffer += max;\n        in->i_buffer -= max;\n        in->i_pts += duration;\n        in->i_length -= duration;\n        in->i_flags &= ~BLOCK_FLAG_DISCONTINUITY;\n    }\n\n    return rtp_packetize_simple(id, in); /* zero copy for the last frame */\n}\n\n/* split and convert from little endian to network byte order */\nstatic int rtp_packetize_swab(sout_stream_id_sys_t *id, block_t *in)\n{\n    unsigned max = rtp_mtu(id);\n\n    while (in->i_buffer > 0)\n    {\n        unsigned payload = (max < in->i_buffer) ? max : in->i_buffer;\n        unsigned duration = (in->i_length * payload) / in->i_buffer;\n        bool marker = (in->i_flags & BLOCK_FLAG_DISCONTINUITY) != 0;\n\n        block_t *out = block_Alloc(12 + payload);\n        if (unlikely(out == NULL))\n        {\n            block_Release(in);\n            return VLC_ENOMEM;\n        }\n\n        rtp_packetize_common(id, out, marker, in->i_pts);\n        swab(in->p_buffer, out->p_buffer + 12, payload);\n        rtp_packetize_send(id, out);\n\n        in->p_buffer += payload;\n        in->i_buffer -= payload;\n        in->i_pts += duration;\n        in->i_length -= duration;\n        in->i_flags &= ~BLOCK_FLAG_DISCONTINUITY;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n/* rfc3016 */\nstatic int rtp_packetize_mp4a_latm( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 2;              /* payload max in one packet */\n    int     latmhdrsize = in->i_buffer / 0xff + 1;\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer, *p_header = NULL;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int     i_payload = __MIN( i_max, i_data );\n        block_t *out;\n\n        if( i != 0 )\n            latmhdrsize = 0;\n        out = block_Alloc( 12 + latmhdrsize + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, ((i == i_count - 1) ? 1 : 0),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n\n        if( i == 0 )\n        {\n            int tmp = in->i_buffer;\n\n            p_header=out->p_buffer+12;\n            while( tmp > 0xfe )\n            {\n                *p_header = 0xff;\n                p_header++;\n                tmp -= 0xff;\n            }\n            *p_header = tmp;\n        }\n\n        memcpy( &out->p_buffer[12+latmhdrsize], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_mp4a( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 4; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 16 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, ((i == i_count - 1)?1:0),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        /* AU headers */\n        /* AU headers length (bits) */\n        out->p_buffer[12] = 0;\n        out->p_buffer[13] = 2*8;\n        /* for each AU length 13 bits + idx 3bits, */\n        SetWBE( out->p_buffer + 14, (in->i_buffer << 3) | 0 );\n\n        memcpy( &out->p_buffer[16], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n\n/* rfc2429 */\n#define RTP_H263_HEADER_SIZE (2)  // plen = 0\n#define RTP_H263_PAYLOAD_START (14)  // plen = 0\nstatic int rtp_packetize_h263( sout_stream_id_sys_t *id, block_t *in )\n{\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n    int     i_max   = rtp_mtu (id) - RTP_H263_HEADER_SIZE; /* payload max in one packet */\n    int     i_count;\n    int     b_p_bit;\n    int     b_v_bit = 0; // no pesky error resilience\n    int     i_plen = 0; // normally plen=0 for PSC packet\n    int     i_pebit = 0; // because plen=0\n    uint16_t h;\n\n    if( i_data < 2 )\n    {\n        block_Release(in);\n        return VLC_EGENERIC;\n    }\n    if( p_data[0] || p_data[1] )\n    {\n        block_Release(in);\n        return VLC_EGENERIC;\n    }\n    /* remove 2 leading 0 bytes */\n    p_data += 2;\n    i_data -= 2;\n    i_count = ( i_data + i_max - 1 ) / i_max;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int      i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( RTP_H263_PAYLOAD_START + i_payload );\n        b_p_bit = (i == 0) ? 1 : 0;\n        h = ( b_p_bit << 10 )|\n            ( b_v_bit << 9  )|\n            ( i_plen  << 3  )|\n              i_pebit;\n\n        /* rtp common header */\n        //b_m_bit = 1; // always contains end of frame\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0,\n                          in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts );\n\n        /* h263 header */\n        SetWBE( out->p_buffer + 12, h );\n        memcpy( &out->p_buffer[RTP_H263_PAYLOAD_START], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n/* rfc3984 */\nstatic int\nrtp_packetize_h264_nal( sout_stream_id_sys_t *id,\n                        const uint8_t *p_data, int i_data, int64_t i_pts,\n                        int64_t i_dts, bool b_last, int64_t i_length )\n{\n    const int i_max = rtp_mtu (id); /* payload max in one packet */\n    int i_nal_hdr;\n    int i_nal_type;\n\n    if( i_data < 5 )\n        return VLC_SUCCESS;\n\n    i_nal_hdr = p_data[3];\n    i_nal_type = i_nal_hdr&0x1f;\n\n    /* Skip start code */\n    p_data += 3;\n    i_data -= 3;\n\n    /* */\n    if( i_data <= i_max )\n    {\n        /* Single NAL unit packet */\n        block_t *out = block_Alloc( 12 + i_data );\n        out->i_dts    = i_dts;\n        out->i_length = i_length;\n\n        /* */\n        rtp_packetize_common( id, out, b_last, i_pts );\n\n        memcpy( &out->p_buffer[12], p_data, i_data );\n\n        rtp_packetize_send( id, out );\n    }\n    else\n    {\n        /* FU-A Fragmentation Unit without interleaving */\n        const int i_count = ( i_data-1 + i_max-2 - 1 ) / (i_max-2);\n        int i;\n\n        p_data++;\n        i_data--;\n\n        for( i = 0; i < i_count; i++ )\n        {\n            const int i_payload = __MIN( i_data, i_max-2 );\n            block_t *out = block_Alloc( 12 + 2 + i_payload );\n            out->i_dts    = i_dts + i * i_length / i_count;\n            out->i_length = i_length / i_count;\n\n            /* */\n            rtp_packetize_common( id, out, (b_last && i_payload == i_data),\n                                    i_pts );\n            /* FU indicator */\n            out->p_buffer[12] = 0x00 | (i_nal_hdr & 0x60) | 28;\n            /* FU header */\n            out->p_buffer[13] = ( i == 0 ? 0x80 : 0x00 ) | ( (i == i_count-1) ? 0x40 : 0x00 )  | i_nal_type;\n            memcpy( &out->p_buffer[14], p_data, i_payload );\n\n            rtp_packetize_send( id, out );\n\n            i_data -= i_payload;\n            p_data += i_payload;\n        }\n    }\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_h264( sout_stream_id_sys_t *id, block_t *in )\n{\n    const uint8_t *p_buffer = in->p_buffer;\n    int i_buffer = in->i_buffer;\n\n    while( i_buffer > 4 && ( p_buffer[0] != 0 || p_buffer[1] != 0 || p_buffer[2] != 1 ) )\n    {\n        i_buffer--;\n        p_buffer++;\n    }\n\n    /* Split nal units */\n    while( i_buffer > 4 )\n    {\n        int i_offset;\n        int i_size = i_buffer;\n        int i_skip = i_buffer;\n\n        /* search nal end */\n        for( i_offset = 4; i_offset+2 < i_buffer ; i_offset++)\n        {\n            if( p_buffer[i_offset] == 0 && p_buffer[i_offset+1] == 0 && p_buffer[i_offset+2] == 1 )\n            {\n                /* we found another startcode */\n                i_size = i_offset - ( p_buffer[i_offset-1] == 0 ? 1 : 0);\n                i_skip = i_offset;\n                break;\n            }\n        }\n        /* TODO add STAP-A to remove a lot of overhead with small slice/sei/... */\n        rtp_packetize_h264_nal( id, p_buffer, i_size,\n                (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts), in->i_dts,\n                (i_size >= i_buffer), in->i_length * i_size / in->i_buffer );\n\n        i_buffer -= i_skip;\n        p_buffer += i_skip;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_amr( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 2; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    /* Only supports octet-aligned mode */\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 14 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, ((i == i_count - 1)?1:0),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        /* Payload header */\n        out->p_buffer[12] = 0xF0; /* CMR */\n        out->p_buffer[13] = p_data[0]&0x7C; /* ToC */ /* FIXME: frame type */\n\n        /* FIXME: are we fed multiple frames ? */\n        memcpy( &out->p_buffer[14], p_data+1, i_payload-1 );\n\n        out->i_buffer--; /* FIXME? */\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_t140( sout_stream_id_sys_t *id, block_t *in )\n{\n    const size_t   i_max  = rtp_mtu (id);\n    const uint8_t *p_data = in->p_buffer;\n    size_t         i_data = in->i_buffer;\n\n    for( unsigned i_packet = 0; i_data > 0; i_packet++ )\n    {\n        size_t i_payload = i_data;\n\n        /* Make sure we stop on an UTF-8 character boundary\n         * (assuming the input is valid UTF-8) */\n        if( i_data > i_max )\n        {\n            i_payload = i_max;\n\n            while( ( p_data[i_payload] & 0xC0 ) == 0x80 )\n            {\n                if( i_payload == 0 )\n                 {\n                    block_Release(in);\n                    return VLC_SUCCESS; /* fishy input! */\n                }\n                i_payload--;\n            }\n        }\n\n        block_t *out = block_Alloc( 12 + i_payload );\n        if( out == NULL )\n        {\n            block_Release(in);\n            return VLC_SUCCESS;\n        }\n\n        rtp_packetize_common( id, out, 0, in->i_pts + i_packet );\n        memcpy( out->p_buffer + 12, p_data, i_payload );\n\n        out->i_dts    = in->i_pts;\n        out->i_length = 0;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n\nstatic int rtp_packetize_spx( sout_stream_id_sys_t *id, block_t *in )\n{\n    uint8_t *p_buffer = in->p_buffer;\n    int i_data_size, i_payload_size, i_payload_padding;\n    i_data_size = i_payload_size = in->i_buffer;\n    i_payload_padding = 0;\n    block_t *p_out;\n\n    if ( in->i_buffer > rtp_mtu (id) )\n    {\n        block_Release(in);\n        return VLC_SUCCESS;\n    }\n\n    /*\n      RFC for Speex in RTP says that each packet must end on an octet\n      boundary. So, we check to see if the number of bytes % 4 is zero.\n      If not, we have to add some padding.\n\n      This MAY be overkill since packetization is handled elsewhere and\n      appears to ensure the octet boundary. However, better safe than\n      sorry.\n    */\n    if ( i_payload_size % 4 )\n    {\n        i_payload_padding = 4 - ( i_payload_size % 4 );\n        i_payload_size += i_payload_padding;\n    }\n\n    /*\n      Allocate a new RTP p_output block of the appropriate size.\n      Allow for 12 extra bytes of RTP header.\n    */\n    p_out = block_Alloc( 12 + i_payload_size );\n\n    if ( i_payload_padding )\n    {\n    /*\n      The padding is required to be a zero followed by all 1s.\n    */\n        char c_first_pad, c_remaining_pad;\n        c_first_pad = 0x7F;\n        c_remaining_pad = 0xFF;\n\n        /*\n          Allow for 12 bytes before the i_data_size because\n          of the expected RTP header added during\n          rtp_packetize_common.\n        */\n        p_out->p_buffer[12 + i_data_size] = c_first_pad;\n        switch (i_payload_padding)\n        {\n          case 2:\n            p_out->p_buffer[12 + i_data_size + 1] = c_remaining_pad;\n            break;\n          case 3:\n            p_out->p_buffer[12 + i_data_size + 1] = c_remaining_pad;\n            p_out->p_buffer[12 + i_data_size + 2] = c_remaining_pad;\n            break;\n        }\n    }\n\n    /* Add the RTP header to our p_output buffer. */\n    rtp_packetize_common( id, p_out, 0,\n                        (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n    /* Copy the Speex payload to the p_output buffer */\n    memcpy( &p_out->p_buffer[12], p_buffer, i_data_size );\n\n    p_out->i_dts = in->i_dts;\n    p_out->i_length = in->i_length;\n    block_Release(in);\n\n    /* Queue the buffer for actual transmission. */\n    rtp_packetize_send( id, p_out );\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_g726( sout_stream_id_sys_t *id, block_t *in, int i_pad )\n{\n    int     i_max   = (rtp_mtu( id )- 12 + i_pad - 1) & ~i_pad;\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i_packet = 0;\n\n    while( i_data > 0 )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 12 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, 0,\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n\n        memcpy( &out->p_buffer[12], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i_packet++ * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_g726_16( sout_stream_id_sys_t *id, block_t *in )\n{\n    return rtp_packetize_g726( id, in, 4 );\n}\n\nstatic int rtp_packetize_g726_24( sout_stream_id_sys_t *id, block_t *in )\n{\n    return rtp_packetize_g726( id, in, 8 );\n}\n\nstatic int rtp_packetize_g726_32( sout_stream_id_sys_t *id, block_t *in )\n{\n    return rtp_packetize_g726( id, in, 2 );\n}\n\nstatic int rtp_packetize_g726_40( sout_stream_id_sys_t *id, block_t *in )\n{\n    return rtp_packetize_g726( id, in, 8 );\n}\n\n#define RTP_VP8_HEADER_SIZE 1\n#define RTP_VP8_PAYLOAD_START (12 + RTP_VP8_HEADER_SIZE)\n\nstatic int rtp_packetize_vp8( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - RTP_VP8_HEADER_SIZE;\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n\n    if ( i_max <= 0 )\n    {\n        block_Release(in);\n        return VLC_EGENERIC;\n    }\n\n    for( int i = 0; i < i_count; i++ )\n    {\n        int i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( RTP_VP8_PAYLOAD_START + i_payload );\n        if ( out == NULL )\n        {\n            block_Release(in);\n            return VLC_ENOMEM;\n        }\n\n        /* VP8 payload header */\n        /* All frames are marked as reference ones */\n        if (i == 0)\n            out->p_buffer[12] = 0x10; // partition start\n        else\n            out->p_buffer[12] = 0;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        memcpy( &out->p_buffer[RTP_VP8_PAYLOAD_START], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_jpeg( sout_stream_id_sys_t *id, block_t *in )\n{\n    uint8_t *p_data = in->p_buffer;\n    int      i_data = in->i_buffer;\n    uint8_t *bufend = p_data + i_data;\n\n    const uint8_t *qtables = NULL;\n    int nb_qtables = 0;\n    int off = 0; // fragment offset in frame\n    int y_sampling_factor;\n    // type is set by pixel format (determined by y_sampling_factor):\n    // 0 for yuvj422p\n    // 1 for yuvj420p\n    // += 64 if DRI present\n    int type;\n    int w = 0; // Width in multiples of 8\n    int h = 0; // Height in multiples of 8\n    int restart_interval;\n    int dri_found = 0;\n\n    // Skip SOI\n    if (GetWBE(p_data) != 0xffd8)\n        goto error;\n    p_data += 2;\n    i_data -= 2;\n\n    /* parse the header to get necessary info */\n    int header_finished = 0;\n    while (!header_finished && p_data + 4 <= bufend) {\n        uint16_t marker = GetWBE(p_data);\n        uint8_t *section = p_data + 2;\n        int section_size = GetWBE(section);\n        uint8_t *section_body = p_data + 4;\n        if (section + section_size > bufend)\n            goto error;\n\n        assert((marker & 0xff00) == 0xff00);\n        switch (marker)\n        {\n            case 0xffdb /*DQT*/:\n                if (section_body[0])\n                    goto error; // Only 8-bit precision is supported\n\n                /* a quantization table is 64 bytes long */\n                nb_qtables = section_size / 65;\n                qtables = section_body;\n                break;\n            case 0xffc0 /*SOF0*/:\n            {\n                int height = GetWBE(&section_body[1]);\n                int width = GetWBE(&section_body[3]);\n                if (width > 2040 || height > 2040)\n                {\n                    // larger than limit supported by RFC 2435\n                    goto error;\n                }\n                // Round up by 8, divide by 8\n                w = ((width+7)&~7) >> 3;\n                h = ((height+7)&~7) >> 3;\n\n                // Get components sampling to determine type\n                // Y has component ID 1\n                // Possible configurations of sampling factors:\n                // Y - 0x22, Cb - 0x11, Cr - 0x11 => yuvj420p\n                // Y - 0x21, Cb - 0x11, Cr - 0x11 => yuvj422p\n\n                // Only 3 components are supported by RFC 2435\n                if (section_body[5] != 3) // Number of components\n                    goto error;\n                for (int j = 0; j < 3; j++)\n                {\n                    if (section_body[6 + j * 3] == 1 /* Y */)\n                    {\n                        y_sampling_factor = section_body[6 + j * 3 + 1];\n                    }\n                    else if (section_body[6 + j * 3 + 1] != 0x11)\n                    {\n                        // Sampling factor is unsupported by RFC 2435\n                        goto error;\n                    }\n                }\n                break;\n            }\n            case 0xffdd /*DRI*/:\n                restart_interval = GetWBE(section_body);\n                dri_found = 1;\n                break;\n            case 0xffda /*SOS*/:\n                /* SOS is last marker in the header */\n                header_finished = 1;\n                break;\n        }\n        // Step over marker, 16bit length and section body\n        p_data += 2 + section_size;\n        i_data -= 2 + section_size;\n    }\n    if (!header_finished)\n        goto error;\n    if (!w || !h)\n        goto error;\n\n    switch (y_sampling_factor)\n    {\n        case 0x22: // yuvj420p\n            type = 1;\n            break;\n        case 0x21: // yuvj422p\n            type = 0;\n            break;\n        default:\n            goto error; // Sampling format unsupported by RFC 2435\n    }\n\n    if (dri_found)\n        type += 64;\n\n    while ( i_data )\n    {\n        int hdr_size = 8 + dri_found * 4;\n        if (off == 0 && nb_qtables)\n            hdr_size += 4 + 64 * nb_qtables;\n\n        int i_payload = __MIN( i_data, (int)(rtp_mtu (id) - hdr_size) );\n        if ( i_payload <= 0 )\n            return VLC_EGENERIC;\n\n        block_t *out = block_Alloc( 12 + hdr_size + i_payload );\n        if( out == NULL )\n            return VLC_ENOMEM;\n\n        uint8_t *p = out->p_buffer + 12;\n        /* set main header */\n        /* set type-specific=0, set offset in following 24 bits: */\n        SetDWBE(p, off & 0x00ffffff);\n        p += 4;\n        *p++ = type;\n        *p++ = 255;  // Quant value\n        *p++ = w;\n        *p++ = h;\n\n        // Write restart_marker_hdr if needed\n        if (dri_found)\n        {\n            SetWBE(p, restart_interval);\n            p += 2;\n            // restart_count. Hardcoded same value as in gstreamer implementation\n            SetWBE(p, 0xffff);\n            p += 2;\n        }\n\n        if (off == 0 && nb_qtables)\n        {\n            /* set quantization tables header */\n            *p++ = 0;\n            *p++ = 0;\n            SetWBE (p, 64 * nb_qtables);\n            p += 2;\n            for (int i = 0; i < nb_qtables; i++)\n            {\n                memcpy (p, &qtables[65 * i + 1], 64);\n                p += 64;\n            }\n        }\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i_payload == i_data),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        memcpy( p, p_data, i_payload );\n\n        out->i_dts    = in->i_dts;\n        out->i_length = in->i_length;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n        off    += i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\nerror:\n    block_Release(in);\n    return VLC_EGENERIC;\n}\n"], "fixing_code": ["/*****************************************************************************\n * rtpfmt.c: RTP payload formats\n *****************************************************************************\n * Copyright (C) 2003-2004 VLC authors and VideoLAN\n * Copyright \u00a9 2007 R\u00e9mi Denis-Courmont\n * $Id$\n *\n * Authors: Laurent Aimar <fenrir@via.ecp.fr>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.\n *****************************************************************************/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <vlc_common.h>\n#include <vlc_sout.h>\n#include <vlc_block.h>\n#include <vlc_strings.h>\n\n#include \"rtp.h\"\n#include \"../demux/xiph.h\"\n\n#include <assert.h>\n\nstatic int rtp_packetize_mpa  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_mpv  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_ac3  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_simple(sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_split(sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_pcm(sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_swab (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_mp4a (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_mp4a_latm (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_h263 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_h264 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_amr  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_spx  (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_t140 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_g726_16 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_g726_24 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_g726_32 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_g726_40 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_xiph (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_vp8 (sout_stream_id_sys_t *, block_t *);\nstatic int rtp_packetize_jpeg (sout_stream_id_sys_t *, block_t *);\n\n#define XIPH_IDENT (0)\n\n/* Helpers common to xiph codecs (vorbis and theora) */\n\nstatic int rtp_xiph_pack_headers(size_t room, void *p_extra, size_t i_extra,\n                                 uint8_t **p_buffer, size_t *i_buffer,\n                                 uint8_t *theora_pixel_fmt)\n{\n    unsigned packet_size[XIPH_MAX_HEADER_COUNT];\n    void *packet[XIPH_MAX_HEADER_COUNT];\n    unsigned packet_count;\n    if (xiph_SplitHeaders(packet_size, packet, &packet_count,\n                                i_extra, p_extra))\n        return VLC_EGENERIC;;\n    if (packet_count < 3)\n        return VLC_EGENERIC;;\n\n    if (theora_pixel_fmt != NULL)\n    {\n        if (packet_size[0] < 42)\n            return VLC_EGENERIC;\n        *theora_pixel_fmt = (((uint8_t *)packet[0])[41] >> 3) & 0x03;\n    }\n\n    unsigned length_size[2] = { 0, 0 };\n    for (int i = 0; i < 2; i++)\n    {\n        unsigned size = packet_size[i];\n        while (size > 0)\n        {\n            length_size[i]++;\n            size >>= 7;\n        }\n    }\n\n    *i_buffer = room + 1 + length_size[0] + length_size[1]\n                + packet_size[0] + packet_size[1] + packet_size[2];\n    *p_buffer = malloc(*i_buffer);\n    if (*p_buffer == NULL)\n        return VLC_ENOMEM;\n\n    uint8_t *p = *p_buffer + room;\n    /* Number of headers */\n    *p++ = 2;\n\n    for (int i = 0; i < 2; i++)\n    {\n        unsigned size = length_size[i];\n        while (size > 0)\n        {\n            *p = (packet_size[i] >> (7 * (size - 1))) & 0x7f;\n            if (--size > 0)\n                *p |= 0x80;\n            p++;\n        }\n    }\n    for (int i = 0; i < 3; i++)\n    {\n        memcpy(p, packet[i], packet_size[i]);\n        p += packet_size[i];\n    }\n\n    return VLC_SUCCESS;\n}\n\nstatic char *rtp_xiph_b64_oob_config(void *p_extra, size_t i_extra,\n                                     uint8_t *theora_pixel_fmt)\n{\n    uint8_t *p_buffer;\n    size_t i_buffer;\n    if (rtp_xiph_pack_headers(9, p_extra, i_extra, &p_buffer, &i_buffer,\n                              theora_pixel_fmt) != VLC_SUCCESS)\n        return NULL;\n\n    /* Number of packed headers */\n    SetDWBE(p_buffer, 1);\n    /* Ident */\n    uint32_t ident = XIPH_IDENT;\n    SetWBE(p_buffer + 4, ident >> 8);\n    p_buffer[6] = ident & 0xff;\n    /* Length field */\n    SetWBE(p_buffer + 7, i_buffer);\n\n    char *config = vlc_b64_encode_binary(p_buffer, i_buffer);\n    free(p_buffer);\n    return config;\n}\n\nstatic void sprintf_hexa( char *s, uint8_t *p_data, int i_data )\n{\n    static const char hex[16] = \"0123456789abcdef\";\n\n    for( int i = 0; i < i_data; i++ )\n    {\n        s[2*i+0] = hex[(p_data[i]>>4)&0xf];\n        s[2*i+1] = hex[(p_data[i]   )&0xf];\n    }\n    s[2*i_data] = '\\0';\n}\n\n/* TODO: make this into something more clever than a big switch? */\nint rtp_get_fmt( vlc_object_t *obj, es_format_t *p_fmt, const char *mux,\n                  rtp_format_t *rtp_fmt )\n{\n    assert( p_fmt != NULL || mux != NULL );\n\n    /* Dynamic payload type. Payload types are scoped to the RTP\n     * session, and we put each ES in its own session, so no risk of\n     * conflict. */\n    rtp_fmt->payload_type = 96;\n    rtp_fmt->cat = mux != NULL ? VIDEO_ES : p_fmt->i_cat;\n    if( rtp_fmt->cat == AUDIO_ES )\n    {\n        rtp_fmt->clock_rate = p_fmt->audio.i_rate;\n        rtp_fmt->channels = p_fmt->audio.i_channels;\n    }\n    else\n        rtp_fmt->clock_rate = 90000; /* most common case for video */\n    /* Stream bitrate in kbps */\n    rtp_fmt->bitrate = p_fmt != NULL ? p_fmt->i_bitrate/1000 : 0;\n    rtp_fmt->fmtp = NULL;\n\n    if( mux != NULL )\n    {\n        if( strncmp( mux, \"ts\", 2 ) == 0 )\n        {\n            rtp_fmt->payload_type = 33;\n            rtp_fmt->ptname = \"MP2T\";\n        }\n        else\n            rtp_fmt->ptname = \"MP2P\";\n        return VLC_SUCCESS;\n    }\n\n    switch( p_fmt->i_codec )\n    {\n        case VLC_CODEC_MULAW:\n            if( p_fmt->audio.i_channels == 1 && p_fmt->audio.i_rate == 8000 )\n                rtp_fmt->payload_type = 0;\n            rtp_fmt->ptname = \"PCMU\";\n            rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            break;\n        case VLC_CODEC_ALAW:\n            if( p_fmt->audio.i_channels == 1 && p_fmt->audio.i_rate == 8000 )\n                rtp_fmt->payload_type = 8;\n            rtp_fmt->ptname = \"PCMA\";\n            rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            break;\n        case VLC_CODEC_S16B:\n        case VLC_CODEC_S16L:\n            if( p_fmt->audio.i_channels == 1 && p_fmt->audio.i_rate == 44100 )\n            {\n                rtp_fmt->payload_type = 11;\n            }\n            else if( p_fmt->audio.i_channels == 2 &&\n                     p_fmt->audio.i_rate == 44100 )\n            {\n                rtp_fmt->payload_type = 10;\n            }\n            rtp_fmt->ptname = \"L16\";\n            if( p_fmt->i_codec == VLC_CODEC_S16B )\n                rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            else\n                rtp_fmt->pf_packetize = rtp_packetize_swab;\n            break;\n        case VLC_CODEC_U8:\n            rtp_fmt->ptname = \"L8\";\n            rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            break;\n        case VLC_CODEC_S24B:\n            rtp_fmt->ptname = \"L24\";\n            rtp_fmt->pf_packetize = rtp_packetize_pcm;\n            break;\n        case VLC_CODEC_MPGA:\n            rtp_fmt->payload_type = 14;\n            rtp_fmt->ptname = \"MPA\";\n            rtp_fmt->clock_rate = 90000; /* not 44100 */\n            rtp_fmt->pf_packetize = rtp_packetize_mpa;\n            break;\n        case VLC_CODEC_MPGV:\n            rtp_fmt->payload_type = 32;\n            rtp_fmt->ptname = \"MPV\";\n            rtp_fmt->pf_packetize = rtp_packetize_mpv;\n            break;\n        case VLC_CODEC_ADPCM_G726:\n            switch( p_fmt->i_bitrate / 1000 )\n            {\n            case 16:\n                rtp_fmt->ptname = \"G726-16\";\n                rtp_fmt->pf_packetize = rtp_packetize_g726_16;\n                break;\n            case 24:\n                rtp_fmt->ptname = \"G726-24\";\n                rtp_fmt->pf_packetize = rtp_packetize_g726_24;\n                break;\n            case 32:\n                rtp_fmt->ptname = \"G726-32\";\n                rtp_fmt->pf_packetize = rtp_packetize_g726_32;\n                break;\n            case 40:\n                rtp_fmt->ptname = \"G726-40\";\n                rtp_fmt->pf_packetize = rtp_packetize_g726_40;\n                break;\n            default:\n                msg_Err( obj, \"cannot add this stream (unsupported \"\n                         \"G.726 bit rate: %u)\", p_fmt->i_bitrate );\n                return VLC_EGENERIC;\n            }\n            break;\n        case VLC_CODEC_A52:\n            rtp_fmt->ptname = \"ac3\";\n            rtp_fmt->pf_packetize = rtp_packetize_ac3;\n            break;\n        case VLC_CODEC_H263:\n            rtp_fmt->ptname = \"H263-1998\";\n            rtp_fmt->pf_packetize = rtp_packetize_h263;\n            break;\n        case VLC_CODEC_H264:\n            rtp_fmt->ptname = \"H264\";\n            rtp_fmt->pf_packetize = rtp_packetize_h264;\n            rtp_fmt->fmtp = NULL;\n\n            if( p_fmt->i_extra > 0 )\n            {\n                uint8_t *p_buffer = p_fmt->p_extra;\n                int     i_buffer = p_fmt->i_extra;\n                char    *p_64_sps = NULL;\n                char    *p_64_pps = NULL;\n                char    hexa[6+1];\n\n                while( i_buffer > 4 )\n                {\n                    int i_offset    = 0;\n                    int i_size      = 0;\n\n                    while( p_buffer[0] != 0 || p_buffer[1] != 0 ||\n                           p_buffer[2] != 1 )\n                    {\n                        p_buffer++;\n                        i_buffer--;\n                        if( i_buffer == 0 ) break;\n                    }\n\n                    if( i_buffer < 4 || memcmp(p_buffer, \"\\x00\\x00\\x01\", 3 ) )\n                    {\n                        msg_Dbg( obj, \"No startcode found..\");\n                        break;\n                    }\n                    p_buffer += 3;\n                    i_buffer -= 3;\n\n                    const int i_nal_type = p_buffer[0]&0x1f;\n\n                    msg_Dbg( obj, \"we found a startcode for NAL with TYPE:%d\", i_nal_type );\n\n                    i_size = i_buffer;\n                    for( i_offset = 0; i_offset+2 < i_buffer ; i_offset++)\n                    {\n                        if( !memcmp(p_buffer + i_offset, \"\\x00\\x00\\x01\", 3 ) )\n                        {\n                            /* we found another startcode */\n                            while( i_offset > 0 && 0 == p_buffer[ i_offset - 1 ] )\n                                i_offset--;\n                            i_size = i_offset;\n                            break;\n                        }\n                    }\n\n                    if( i_size == 0 )\n                    {\n                        msg_Dbg( obj, \"No-info found in nal \");\n                        continue;\n                    }\n\n                    if( i_nal_type == 7 )\n                    {\n                        free( p_64_sps );\n                        p_64_sps = vlc_b64_encode_binary( p_buffer, i_size );\n                        /* XXX: nothing ensures that i_size >= 4 ?? */\n                        sprintf_hexa( hexa, &p_buffer[1], 3 );\n                    }\n                    else if( i_nal_type == 8 )\n                    {\n                        free( p_64_pps );\n                        p_64_pps = vlc_b64_encode_binary( p_buffer, i_size );\n                    }\n                    i_buffer -= i_size;\n                    p_buffer += i_size;\n                }\n                /* */\n                if( p_64_sps && p_64_pps &&\n                    ( asprintf( &rtp_fmt->fmtp,\n                                \"packetization-mode=1;profile-level-id=%s;\"\n                                \"sprop-parameter-sets=%s,%s;\", hexa, p_64_sps,\n                                p_64_pps ) == -1 ) )\n                    rtp_fmt->fmtp = NULL;\n                free( p_64_sps );\n                free( p_64_pps );\n            }\n            if( rtp_fmt->fmtp == NULL )\n                rtp_fmt->fmtp = strdup( \"packetization-mode=1\" );\n            break;\n\n        case VLC_CODEC_MP4V:\n        {\n            rtp_fmt->ptname = \"MP4V-ES\";\n            rtp_fmt->pf_packetize = rtp_packetize_split;\n            if( p_fmt->i_extra > 0 )\n            {\n                char hexa[2*p_fmt->i_extra +1];\n                sprintf_hexa( hexa, p_fmt->p_extra, p_fmt->i_extra );\n                if( asprintf( &rtp_fmt->fmtp,\n                              \"profile-level-id=3; config=%s;\", hexa ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n            }\n            break;\n        }\n        case VLC_CODEC_MP4A:\n        {\n            if( ! var_InheritBool( obj, \"sout-rtp-mp4a-latm\" ) )\n            {\n                char hexa[2*p_fmt->i_extra +1];\n\n                rtp_fmt->ptname = \"mpeg4-generic\";\n                rtp_fmt->pf_packetize = rtp_packetize_mp4a;\n                sprintf_hexa( hexa, p_fmt->p_extra, p_fmt->i_extra );\n                if( asprintf( &rtp_fmt->fmtp,\n                              \"streamtype=5; profile-level-id=15; \"\n                              \"mode=AAC-hbr; config=%s; SizeLength=13; \"\n                              \"IndexLength=3; IndexDeltaLength=3; Profile=1;\",\n                              hexa ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n            }\n            else\n            {\n                char hexa[13];\n                int i;\n                unsigned char config[6];\n                unsigned int aacsrates[15] = {\n                    96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,\n                    16000, 12000, 11025, 8000, 7350, 0, 0 };\n\n                for( i = 0; i < 15; i++ )\n                    if( p_fmt->audio.i_rate == aacsrates[i] )\n                        break;\n\n                config[0]=0x40;\n                config[1]=0;\n                config[2]=0x20|i;\n                config[3]=p_fmt->audio.i_channels<<4;\n                config[4]=0x3f;\n                config[5]=0xc0;\n\n                rtp_fmt->ptname = \"MP4A-LATM\";\n                rtp_fmt->pf_packetize = rtp_packetize_mp4a_latm;\n                sprintf_hexa( hexa, config, 6 );\n                if( asprintf( &rtp_fmt->fmtp, \"profile-level-id=15; \"\n                              \"object=2; cpresent=0; config=%s\", hexa ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n            }\n            break;\n        }\n        case VLC_CODEC_AMR_NB:\n            rtp_fmt->ptname = \"AMR\";\n            rtp_fmt->fmtp = strdup( \"octet-align=1\" );\n            rtp_fmt->pf_packetize = rtp_packetize_amr;\n            break;\n        case VLC_CODEC_AMR_WB:\n            rtp_fmt->ptname = \"AMR-WB\";\n            rtp_fmt->fmtp = strdup( \"octet-align=1\" );\n            rtp_fmt->pf_packetize = rtp_packetize_amr;\n            break;\n        case VLC_CODEC_SPEEX:\n            rtp_fmt->ptname = \"SPEEX\";\n            rtp_fmt->pf_packetize = rtp_packetize_spx;\n            break;\n        case VLC_CODEC_VORBIS:\n            rtp_fmt->ptname = \"vorbis\";\n            rtp_fmt->pf_packetize = rtp_packetize_xiph;\n            if( p_fmt->i_extra > 0 )\n            {\n                rtp_fmt->fmtp = NULL;\n                char *config = rtp_xiph_b64_oob_config(p_fmt->p_extra,\n                                                       p_fmt->i_extra, NULL);\n                if (config == NULL)\n                    break;\n                if( asprintf( &rtp_fmt->fmtp,\n                              \"configuration=%s;\", config ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n                free(config);\n            }\n            break;\n        case VLC_CODEC_THEORA:\n            rtp_fmt->ptname = \"theora\";\n            rtp_fmt->pf_packetize = rtp_packetize_xiph;\n            if( p_fmt->i_extra > 0 )\n            {\n                rtp_fmt->fmtp = NULL;\n                uint8_t pixel_fmt, c1, c2;\n                char *config = rtp_xiph_b64_oob_config(p_fmt->p_extra,\n                                                       p_fmt->i_extra,\n                                                       &pixel_fmt);\n                if (config == NULL)\n                    break;\n\n                if (pixel_fmt == 1)\n                {\n                    /* reserved */\n                    free(config);\n                    break;\n                }\n                switch (pixel_fmt)\n                {\n                    case 0:\n                        c1 = 2;\n                        c2 = 0;\n                        break;\n                    case 2:\n                        c1 = c2 = 2;\n                        break;\n                    case 3:\n                        c1 = c2 = 4;\n                        break;\n                    default:\n                        assert(0);\n                }\n\n                if( asprintf( &rtp_fmt->fmtp,\n                              \"sampling=YCbCr-4:%d:%d; width=%d; height=%d; \"\n                              \"delivery-method=inline; configuration=%s; \"\n                              \"delivery-method=in_band;\", c1, c2,\n                              p_fmt->video.i_width, p_fmt->video.i_height,\n                              config ) == -1 )\n                    rtp_fmt->fmtp = NULL;\n                free(config);\n            }\n            break;\n        case VLC_CODEC_ITU_T140:\n            rtp_fmt->ptname = \"t140\" ;\n            rtp_fmt->clock_rate = 1000;\n            rtp_fmt->pf_packetize = rtp_packetize_t140;\n            break;\n        case VLC_CODEC_GSM:\n            rtp_fmt->payload_type = 3;\n            rtp_fmt->ptname = \"GSM\";\n            rtp_fmt->pf_packetize = rtp_packetize_split;\n            break;\n        case VLC_CODEC_OPUS:\n            if (p_fmt->audio.i_channels > 2)\n            {\n                msg_Err( obj, \"Multistream opus not supported in RTP\"\n                         \" (having %d channels input)\",\n                         p_fmt->audio.i_channels );\n                return VLC_EGENERIC;\n            }\n            rtp_fmt->ptname = \"opus\";\n            rtp_fmt->pf_packetize = rtp_packetize_simple;\n            rtp_fmt->clock_rate = 48000;\n            rtp_fmt->channels = 2;\n            if (p_fmt->audio.i_channels == 2)\n                rtp_fmt->fmtp = strdup( \"sprop-stereo=1\" );\n            break;\n        case VLC_CODEC_VP8:\n            rtp_fmt->ptname = \"VP8\";\n            rtp_fmt->pf_packetize = rtp_packetize_vp8;\n            break;\n        case VLC_CODEC_MJPG:\n        case VLC_CODEC_JPEG:\n            rtp_fmt->ptname = \"JPEG\";\n            rtp_fmt->payload_type = 26;\n            rtp_fmt->pf_packetize = rtp_packetize_jpeg;\n            break;\n\n        default:\n            msg_Err( obj, \"cannot add this stream (unsupported \"\n                     \"codec: %4.4s)\", (char*)&p_fmt->i_codec );\n            return VLC_EGENERIC;\n    }\n\n    return VLC_SUCCESS;\n}\n\n\nstatic int\nrtp_packetize_h264_nal( sout_stream_id_sys_t *id,\n                        const uint8_t *p_data, int i_data, int64_t i_pts,\n                        int64_t i_dts, bool b_last, int64_t i_length );\n\nint rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n\n    /* extract base64 configuration from fmtp */\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n\n    char *b64 = malloc(len + 1);\n    if(!b64)\n        return VLC_EGENERIC;\n\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n\n    int     i_max   = rtp_mtu (id) - 6; /* payload max in one packet */\n\n    uint8_t *p_orig, *p_data;\n    int i_data;\n\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    free(b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        /* Ident:24, Fragment type:2, Vorbis/Theora Data Type:2, # of pkts:4 */\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, 0, i_pts );\n\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n\n        out->i_dts    = i_pts;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    free(p_orig);\n\n    return VLC_SUCCESS;\n}\n\n/* rfc5215 */\nstatic int rtp_packetize_xiph( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 6; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            /* No fragmentation */\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            /* Fragmentation */\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        /* Ident:24, Fragment type:2, Vorbis/Theora Data Type:2, # of pkts:4 */\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (0 << 4) | numpkts;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, 0, in->i_pts);\n\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_mpa( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 4; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 16 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0, in->i_pts );\n        /* mbz set to 0 */\n        SetWBE( out->p_buffer + 12, 0 );\n        /* fragment offset in the current frame */\n        SetWBE( out->p_buffer + 14, i * i_max );\n        memcpy( &out->p_buffer[16], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n/* rfc2250 */\nstatic int rtp_packetize_mpv( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 4; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n    int     b_sequence_start = 0;\n    int     i_temporal_ref = 0;\n    int     i_picture_coding_type = 0;\n    int     i_fbv = 0, i_bfc = 0, i_ffv = 0, i_ffc = 0;\n    int     b_start_slice = 0;\n\n    /* preparse this packet to get some info */\n    if( in->i_buffer > 4 )\n    {\n        uint8_t *p = p_data;\n        int      i_rest = in->i_buffer;\n\n        for( ;; )\n        {\n            while( i_rest > 4 &&\n                   ( p[0] != 0x00 || p[1] != 0x00 || p[2] != 0x01 ) )\n            {\n                p++;\n                i_rest--;\n            }\n            if( i_rest <= 4 )\n            {\n                break;\n            }\n            p += 3;\n            i_rest -= 4;\n\n            if( *p == 0xb3 )\n            {\n                /* sequence start code */\n                b_sequence_start = 1;\n            }\n            else if( *p == 0x00 && i_rest >= 4 )\n            {\n                /* picture */\n                i_temporal_ref = ( p[1] << 2) |((p[2]>>6)&0x03);\n                i_picture_coding_type = (p[2] >> 3)&0x07;\n\n                if( i_rest >= 4 && ( i_picture_coding_type == 2 ||\n                                    i_picture_coding_type == 3 ) )\n                {\n                    i_ffv = (p[3] >> 2)&0x01;\n                    i_ffc = ((p[3]&0x03) << 1)|((p[4]>>7)&0x01);\n                    if( i_rest > 4 && i_picture_coding_type == 3 )\n                    {\n                        i_fbv = (p[4]>>6)&0x01;\n                        i_bfc = (p[4]>>3)&0x07;\n                    }\n                }\n            }\n            else if( *p <= 0xaf )\n            {\n                b_start_slice = 1;\n            }\n        }\n    }\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 16 + i_payload );\n        /* MBZ:5 T:1 TR:10 AN:1 N:1 S:1 B:1 E:1 P:3 FBV:1 BFC:3 FFV:1 FFC:3 */\n        uint32_t      h = ( i_temporal_ref << 16 )|\n                          ( b_sequence_start << 13 )|\n                          ( b_start_slice << 12 )|\n                          ( i == i_count - 1 ? 1 << 11 : 0 )|\n                          ( i_picture_coding_type << 8 )|\n                          ( i_fbv << 7 )|( i_bfc << 4 )|( i_ffv << 3 )|i_ffc;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0,\n                          in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts );\n\n        SetDWBE( out->p_buffer + 12, h );\n\n        memcpy( &out->p_buffer[16], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_ac3( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 2; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 14 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0, in->i_pts );\n        /* unit count */\n        out->p_buffer[12] = 1;\n        /* unit header */\n        out->p_buffer[13] = 0x00;\n        /* data */\n        memcpy( &out->p_buffer[14], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_simple(sout_stream_id_sys_t *id, block_t *block)\n{\n    bool marker = (block->i_flags & BLOCK_FLAG_DISCONTINUITY) != 0;\n\n    block = block_Realloc(block, 12, block->i_buffer);\n    if (unlikely(block == NULL))\n        return VLC_ENOMEM;\n\n    rtp_packetize_common(id, block, marker, block->i_pts);\n    rtp_packetize_send(id, block);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_split( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id); /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 12 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        memcpy( &out->p_buffer[12], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_pcm(sout_stream_id_sys_t *id, block_t *in)\n{\n    unsigned max = rtp_mtu(id);\n\n    while (in->i_buffer > max)\n    {\n        unsigned duration = (in->i_length * max) / in->i_buffer;\n        bool marker = (in->i_flags & BLOCK_FLAG_DISCONTINUITY) != 0;\n\n        block_t *out = block_Alloc(12 + max);\n        if (unlikely(out == NULL))\n        {\n            block_Release(in);\n            return VLC_ENOMEM;\n        }\n\n        rtp_packetize_common(id, out, marker, in->i_pts);\n        memcpy(out->p_buffer + 12, in->p_buffer, max);\n        rtp_packetize_send(id, out);\n\n        in->p_buffer += max;\n        in->i_buffer -= max;\n        in->i_pts += duration;\n        in->i_length -= duration;\n        in->i_flags &= ~BLOCK_FLAG_DISCONTINUITY;\n    }\n\n    return rtp_packetize_simple(id, in); /* zero copy for the last frame */\n}\n\n/* split and convert from little endian to network byte order */\nstatic int rtp_packetize_swab(sout_stream_id_sys_t *id, block_t *in)\n{\n    unsigned max = rtp_mtu(id);\n\n    while (in->i_buffer > 0)\n    {\n        unsigned payload = (max < in->i_buffer) ? max : in->i_buffer;\n        unsigned duration = (in->i_length * payload) / in->i_buffer;\n        bool marker = (in->i_flags & BLOCK_FLAG_DISCONTINUITY) != 0;\n\n        block_t *out = block_Alloc(12 + payload);\n        if (unlikely(out == NULL))\n        {\n            block_Release(in);\n            return VLC_ENOMEM;\n        }\n\n        rtp_packetize_common(id, out, marker, in->i_pts);\n        swab(in->p_buffer, out->p_buffer + 12, payload);\n        rtp_packetize_send(id, out);\n\n        in->p_buffer += payload;\n        in->i_buffer -= payload;\n        in->i_pts += duration;\n        in->i_length -= duration;\n        in->i_flags &= ~BLOCK_FLAG_DISCONTINUITY;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n/* rfc3016 */\nstatic int rtp_packetize_mp4a_latm( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 2;              /* payload max in one packet */\n    int     latmhdrsize = in->i_buffer / 0xff + 1;\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer, *p_header = NULL;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int     i_payload = __MIN( i_max, i_data );\n        block_t *out;\n\n        if( i != 0 )\n            latmhdrsize = 0;\n        out = block_Alloc( 12 + latmhdrsize + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, ((i == i_count - 1) ? 1 : 0),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n\n        if( i == 0 )\n        {\n            int tmp = in->i_buffer;\n\n            p_header=out->p_buffer+12;\n            while( tmp > 0xfe )\n            {\n                *p_header = 0xff;\n                p_header++;\n                tmp -= 0xff;\n            }\n            *p_header = tmp;\n        }\n\n        memcpy( &out->p_buffer[12+latmhdrsize], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_mp4a( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 4; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 16 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, ((i == i_count - 1)?1:0),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        /* AU headers */\n        /* AU headers length (bits) */\n        out->p_buffer[12] = 0;\n        out->p_buffer[13] = 2*8;\n        /* for each AU length 13 bits + idx 3bits, */\n        SetWBE( out->p_buffer + 14, (in->i_buffer << 3) | 0 );\n\n        memcpy( &out->p_buffer[16], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n\n/* rfc2429 */\n#define RTP_H263_HEADER_SIZE (2)  // plen = 0\n#define RTP_H263_PAYLOAD_START (14)  // plen = 0\nstatic int rtp_packetize_h263( sout_stream_id_sys_t *id, block_t *in )\n{\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n    int     i_max   = rtp_mtu (id) - RTP_H263_HEADER_SIZE; /* payload max in one packet */\n    int     i_count;\n    int     b_p_bit;\n    int     b_v_bit = 0; // no pesky error resilience\n    int     i_plen = 0; // normally plen=0 for PSC packet\n    int     i_pebit = 0; // because plen=0\n    uint16_t h;\n\n    if( i_data < 2 )\n    {\n        block_Release(in);\n        return VLC_EGENERIC;\n    }\n    if( p_data[0] || p_data[1] )\n    {\n        block_Release(in);\n        return VLC_EGENERIC;\n    }\n    /* remove 2 leading 0 bytes */\n    p_data += 2;\n    i_data -= 2;\n    i_count = ( i_data + i_max - 1 ) / i_max;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int      i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( RTP_H263_PAYLOAD_START + i_payload );\n        b_p_bit = (i == 0) ? 1 : 0;\n        h = ( b_p_bit << 10 )|\n            ( b_v_bit << 9  )|\n            ( i_plen  << 3  )|\n              i_pebit;\n\n        /* rtp common header */\n        //b_m_bit = 1; // always contains end of frame\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0,\n                          in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts );\n\n        /* h263 header */\n        SetWBE( out->p_buffer + 12, h );\n        memcpy( &out->p_buffer[RTP_H263_PAYLOAD_START], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n/* rfc3984 */\nstatic int\nrtp_packetize_h264_nal( sout_stream_id_sys_t *id,\n                        const uint8_t *p_data, int i_data, int64_t i_pts,\n                        int64_t i_dts, bool b_last, int64_t i_length )\n{\n    const int i_max = rtp_mtu (id); /* payload max in one packet */\n    int i_nal_hdr;\n    int i_nal_type;\n\n    if( i_data < 5 )\n        return VLC_SUCCESS;\n\n    i_nal_hdr = p_data[3];\n    i_nal_type = i_nal_hdr&0x1f;\n\n    /* Skip start code */\n    p_data += 3;\n    i_data -= 3;\n\n    /* */\n    if( i_data <= i_max )\n    {\n        /* Single NAL unit packet */\n        block_t *out = block_Alloc( 12 + i_data );\n        out->i_dts    = i_dts;\n        out->i_length = i_length;\n\n        /* */\n        rtp_packetize_common( id, out, b_last, i_pts );\n\n        memcpy( &out->p_buffer[12], p_data, i_data );\n\n        rtp_packetize_send( id, out );\n    }\n    else\n    {\n        /* FU-A Fragmentation Unit without interleaving */\n        const int i_count = ( i_data-1 + i_max-2 - 1 ) / (i_max-2);\n        int i;\n\n        p_data++;\n        i_data--;\n\n        for( i = 0; i < i_count; i++ )\n        {\n            const int i_payload = __MIN( i_data, i_max-2 );\n            block_t *out = block_Alloc( 12 + 2 + i_payload );\n            out->i_dts    = i_dts + i * i_length / i_count;\n            out->i_length = i_length / i_count;\n\n            /* */\n            rtp_packetize_common( id, out, (b_last && i_payload == i_data),\n                                    i_pts );\n            /* FU indicator */\n            out->p_buffer[12] = 0x00 | (i_nal_hdr & 0x60) | 28;\n            /* FU header */\n            out->p_buffer[13] = ( i == 0 ? 0x80 : 0x00 ) | ( (i == i_count-1) ? 0x40 : 0x00 )  | i_nal_type;\n            memcpy( &out->p_buffer[14], p_data, i_payload );\n\n            rtp_packetize_send( id, out );\n\n            i_data -= i_payload;\n            p_data += i_payload;\n        }\n    }\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_h264( sout_stream_id_sys_t *id, block_t *in )\n{\n    const uint8_t *p_buffer = in->p_buffer;\n    int i_buffer = in->i_buffer;\n\n    while( i_buffer > 4 && ( p_buffer[0] != 0 || p_buffer[1] != 0 || p_buffer[2] != 1 ) )\n    {\n        i_buffer--;\n        p_buffer++;\n    }\n\n    /* Split nal units */\n    while( i_buffer > 4 )\n    {\n        int i_offset;\n        int i_size = i_buffer;\n        int i_skip = i_buffer;\n\n        /* search nal end */\n        for( i_offset = 4; i_offset+2 < i_buffer ; i_offset++)\n        {\n            if( p_buffer[i_offset] == 0 && p_buffer[i_offset+1] == 0 && p_buffer[i_offset+2] == 1 )\n            {\n                /* we found another startcode */\n                i_size = i_offset - ( p_buffer[i_offset-1] == 0 ? 1 : 0);\n                i_skip = i_offset;\n                break;\n            }\n        }\n        /* TODO add STAP-A to remove a lot of overhead with small slice/sei/... */\n        rtp_packetize_h264_nal( id, p_buffer, i_size,\n                (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts), in->i_dts,\n                (i_size >= i_buffer), in->i_length * i_size / in->i_buffer );\n\n        i_buffer -= i_skip;\n        p_buffer += i_skip;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_amr( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 2; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    /* Only supports octet-aligned mode */\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 14 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, ((i == i_count - 1)?1:0),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        /* Payload header */\n        out->p_buffer[12] = 0xF0; /* CMR */\n        out->p_buffer[13] = p_data[0]&0x7C; /* ToC */ /* FIXME: frame type */\n\n        /* FIXME: are we fed multiple frames ? */\n        memcpy( &out->p_buffer[14], p_data+1, i_payload-1 );\n\n        out->i_buffer--; /* FIXME? */\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_t140( sout_stream_id_sys_t *id, block_t *in )\n{\n    const size_t   i_max  = rtp_mtu (id);\n    const uint8_t *p_data = in->p_buffer;\n    size_t         i_data = in->i_buffer;\n\n    for( unsigned i_packet = 0; i_data > 0; i_packet++ )\n    {\n        size_t i_payload = i_data;\n\n        /* Make sure we stop on an UTF-8 character boundary\n         * (assuming the input is valid UTF-8) */\n        if( i_data > i_max )\n        {\n            i_payload = i_max;\n\n            while( ( p_data[i_payload] & 0xC0 ) == 0x80 )\n            {\n                if( i_payload == 0 )\n                 {\n                    block_Release(in);\n                    return VLC_SUCCESS; /* fishy input! */\n                }\n                i_payload--;\n            }\n        }\n\n        block_t *out = block_Alloc( 12 + i_payload );\n        if( out == NULL )\n        {\n            block_Release(in);\n            return VLC_SUCCESS;\n        }\n\n        rtp_packetize_common( id, out, 0, in->i_pts + i_packet );\n        memcpy( out->p_buffer + 12, p_data, i_payload );\n\n        out->i_dts    = in->i_pts;\n        out->i_length = 0;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\n\nstatic int rtp_packetize_spx( sout_stream_id_sys_t *id, block_t *in )\n{\n    uint8_t *p_buffer = in->p_buffer;\n    int i_data_size, i_payload_size, i_payload_padding;\n    i_data_size = i_payload_size = in->i_buffer;\n    i_payload_padding = 0;\n    block_t *p_out;\n\n    if ( in->i_buffer > rtp_mtu (id) )\n    {\n        block_Release(in);\n        return VLC_SUCCESS;\n    }\n\n    /*\n      RFC for Speex in RTP says that each packet must end on an octet\n      boundary. So, we check to see if the number of bytes % 4 is zero.\n      If not, we have to add some padding.\n\n      This MAY be overkill since packetization is handled elsewhere and\n      appears to ensure the octet boundary. However, better safe than\n      sorry.\n    */\n    if ( i_payload_size % 4 )\n    {\n        i_payload_padding = 4 - ( i_payload_size % 4 );\n        i_payload_size += i_payload_padding;\n    }\n\n    /*\n      Allocate a new RTP p_output block of the appropriate size.\n      Allow for 12 extra bytes of RTP header.\n    */\n    p_out = block_Alloc( 12 + i_payload_size );\n\n    if ( i_payload_padding )\n    {\n    /*\n      The padding is required to be a zero followed by all 1s.\n    */\n        char c_first_pad, c_remaining_pad;\n        c_first_pad = 0x7F;\n        c_remaining_pad = 0xFF;\n\n        /*\n          Allow for 12 bytes before the i_data_size because\n          of the expected RTP header added during\n          rtp_packetize_common.\n        */\n        p_out->p_buffer[12 + i_data_size] = c_first_pad;\n        switch (i_payload_padding)\n        {\n          case 2:\n            p_out->p_buffer[12 + i_data_size + 1] = c_remaining_pad;\n            break;\n          case 3:\n            p_out->p_buffer[12 + i_data_size + 1] = c_remaining_pad;\n            p_out->p_buffer[12 + i_data_size + 2] = c_remaining_pad;\n            break;\n        }\n    }\n\n    /* Add the RTP header to our p_output buffer. */\n    rtp_packetize_common( id, p_out, 0,\n                        (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n    /* Copy the Speex payload to the p_output buffer */\n    memcpy( &p_out->p_buffer[12], p_buffer, i_data_size );\n\n    p_out->i_dts = in->i_dts;\n    p_out->i_length = in->i_length;\n    block_Release(in);\n\n    /* Queue the buffer for actual transmission. */\n    rtp_packetize_send( id, p_out );\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_g726( sout_stream_id_sys_t *id, block_t *in, int i_pad )\n{\n    int     i_max   = (rtp_mtu( id )- 12 + i_pad - 1) & ~i_pad;\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i_packet = 0;\n\n    while( i_data > 0 )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 12 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, 0,\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n\n        memcpy( &out->p_buffer[12], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i_packet++ * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_g726_16( sout_stream_id_sys_t *id, block_t *in )\n{\n    return rtp_packetize_g726( id, in, 4 );\n}\n\nstatic int rtp_packetize_g726_24( sout_stream_id_sys_t *id, block_t *in )\n{\n    return rtp_packetize_g726( id, in, 8 );\n}\n\nstatic int rtp_packetize_g726_32( sout_stream_id_sys_t *id, block_t *in )\n{\n    return rtp_packetize_g726( id, in, 2 );\n}\n\nstatic int rtp_packetize_g726_40( sout_stream_id_sys_t *id, block_t *in )\n{\n    return rtp_packetize_g726( id, in, 8 );\n}\n\n#define RTP_VP8_HEADER_SIZE 1\n#define RTP_VP8_PAYLOAD_START (12 + RTP_VP8_HEADER_SIZE)\n\nstatic int rtp_packetize_vp8( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - RTP_VP8_HEADER_SIZE;\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n\n    if ( i_max <= 0 )\n    {\n        block_Release(in);\n        return VLC_EGENERIC;\n    }\n\n    for( int i = 0; i < i_count; i++ )\n    {\n        int i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( RTP_VP8_PAYLOAD_START + i_payload );\n        if ( out == NULL )\n        {\n            block_Release(in);\n            return VLC_ENOMEM;\n        }\n\n        /* VP8 payload header */\n        /* All frames are marked as reference ones */\n        if (i == 0)\n            out->p_buffer[12] = 0x10; // partition start\n        else\n            out->p_buffer[12] = 0;\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        memcpy( &out->p_buffer[RTP_VP8_PAYLOAD_START], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}\n\nstatic int rtp_packetize_jpeg( sout_stream_id_sys_t *id, block_t *in )\n{\n    uint8_t *p_data = in->p_buffer;\n    int      i_data = in->i_buffer;\n    uint8_t *bufend = p_data + i_data;\n\n    const uint8_t *qtables = NULL;\n    int nb_qtables = 0;\n    int off = 0; // fragment offset in frame\n    int y_sampling_factor;\n    // type is set by pixel format (determined by y_sampling_factor):\n    // 0 for yuvj422p\n    // 1 for yuvj420p\n    // += 64 if DRI present\n    int type;\n    int w = 0; // Width in multiples of 8\n    int h = 0; // Height in multiples of 8\n    int restart_interval;\n    int dri_found = 0;\n\n    // Skip SOI\n    if (GetWBE(p_data) != 0xffd8)\n        goto error;\n    p_data += 2;\n    i_data -= 2;\n\n    /* parse the header to get necessary info */\n    int header_finished = 0;\n    while (!header_finished && p_data + 4 <= bufend) {\n        uint16_t marker = GetWBE(p_data);\n        uint8_t *section = p_data + 2;\n        int section_size = GetWBE(section);\n        uint8_t *section_body = p_data + 4;\n        if (section + section_size > bufend)\n            goto error;\n\n        assert((marker & 0xff00) == 0xff00);\n        switch (marker)\n        {\n            case 0xffdb /*DQT*/:\n                if (section_body[0])\n                    goto error; // Only 8-bit precision is supported\n\n                /* a quantization table is 64 bytes long */\n                nb_qtables = section_size / 65;\n                qtables = section_body;\n                break;\n            case 0xffc0 /*SOF0*/:\n            {\n                int height = GetWBE(&section_body[1]);\n                int width = GetWBE(&section_body[3]);\n                if (width > 2040 || height > 2040)\n                {\n                    // larger than limit supported by RFC 2435\n                    goto error;\n                }\n                // Round up by 8, divide by 8\n                w = ((width+7)&~7) >> 3;\n                h = ((height+7)&~7) >> 3;\n\n                // Get components sampling to determine type\n                // Y has component ID 1\n                // Possible configurations of sampling factors:\n                // Y - 0x22, Cb - 0x11, Cr - 0x11 => yuvj420p\n                // Y - 0x21, Cb - 0x11, Cr - 0x11 => yuvj422p\n\n                // Only 3 components are supported by RFC 2435\n                if (section_body[5] != 3) // Number of components\n                    goto error;\n                for (int j = 0; j < 3; j++)\n                {\n                    if (section_body[6 + j * 3] == 1 /* Y */)\n                    {\n                        y_sampling_factor = section_body[6 + j * 3 + 1];\n                    }\n                    else if (section_body[6 + j * 3 + 1] != 0x11)\n                    {\n                        // Sampling factor is unsupported by RFC 2435\n                        goto error;\n                    }\n                }\n                break;\n            }\n            case 0xffdd /*DRI*/:\n                restart_interval = GetWBE(section_body);\n                dri_found = 1;\n                break;\n            case 0xffda /*SOS*/:\n                /* SOS is last marker in the header */\n                header_finished = 1;\n                break;\n        }\n        // Step over marker, 16bit length and section body\n        p_data += 2 + section_size;\n        i_data -= 2 + section_size;\n    }\n    if (!header_finished)\n        goto error;\n    if (!w || !h)\n        goto error;\n\n    switch (y_sampling_factor)\n    {\n        case 0x22: // yuvj420p\n            type = 1;\n            break;\n        case 0x21: // yuvj422p\n            type = 0;\n            break;\n        default:\n            goto error; // Sampling format unsupported by RFC 2435\n    }\n\n    if (dri_found)\n        type += 64;\n\n    while ( i_data )\n    {\n        int hdr_size = 8 + dri_found * 4;\n        if (off == 0 && nb_qtables)\n            hdr_size += 4 + 64 * nb_qtables;\n\n        int i_payload = __MIN( i_data, (int)(rtp_mtu (id) - hdr_size) );\n        if ( i_payload <= 0 )\n            return VLC_EGENERIC;\n\n        block_t *out = block_Alloc( 12 + hdr_size + i_payload );\n        if( out == NULL )\n            return VLC_ENOMEM;\n\n        uint8_t *p = out->p_buffer + 12;\n        /* set main header */\n        /* set type-specific=0, set offset in following 24 bits: */\n        SetDWBE(p, off & 0x00ffffff);\n        p += 4;\n        *p++ = type;\n        *p++ = 255;  // Quant value\n        *p++ = w;\n        *p++ = h;\n\n        // Write restart_marker_hdr if needed\n        if (dri_found)\n        {\n            SetWBE(p, restart_interval);\n            p += 2;\n            // restart_count. Hardcoded same value as in gstreamer implementation\n            SetWBE(p, 0xffff);\n            p += 2;\n        }\n\n        if (off == 0 && nb_qtables)\n        {\n            /* set quantization tables header */\n            *p++ = 0;\n            *p++ = 0;\n            SetWBE (p, 64 * nb_qtables);\n            p += 2;\n            for (int i = 0; i < nb_qtables; i++)\n            {\n                memcpy (p, &qtables[65 * i + 1], 64);\n                p += 64;\n            }\n        }\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i_payload == i_data),\n                      (in->i_pts > VLC_TS_INVALID ? in->i_pts : in->i_dts) );\n        memcpy( p, p_data, i_payload );\n\n        out->i_dts    = in->i_dts;\n        out->i_length = in->i_length;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n        off    += i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\nerror:\n    block_Release(in);\n    return VLC_EGENERIC;\n}\n"], "filenames": ["modules/stream_out/rtpfmt.c"], "buggy_code_start_loc": [562], "buggy_code_end_loc": [571], "fixing_code_start_loc": [562], "fixing_code_end_loc": [577], "type": "CWE-119", "message": "The rtp_packetize_xiph_config function in modules/stream_out/rtpfmt.c in VideoLAN VLC media player before 2.1.6 uses a stack-allocation approach with a size determined by arbitrary input data, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted length value.", "other": {"cve": {"id": "CVE-2014-9630", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-24T22:15:12.660", "lastModified": "2020-01-29T16:17:38.310", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The rtp_packetize_xiph_config function in modules/stream_out/rtpfmt.c in VideoLAN VLC media player before 2.1.6 uses a stack-allocation approach with a size determined by arbitrary input data, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted length value."}, {"lang": "es", "value": "La funci\u00f3n rtp_packetize_xiph_config en el archivo modules/stream_out/rtpfmt.c en el reproductor multimedia VLC de VideoLAN versiones anteriores a 2.1.6, utiliza un enfoque de asignaci\u00f3n de pila con un tama\u00f1o determinado por datos de entrada arbitrarios, que permite a atacantes remotos causar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria) posiblemente tenga otro impacto no especificado por medio de un valor de longitud dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:videolan:vlc_media_player:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.6", "matchCriteriaId": "6E9B8F06-93FB-4A2B-B550-A30BD8F1C5D6"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2015/01/20/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/videolan/vlc/commit/204291467724867b79735c0ee3aeb0dbc2200f97", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.videolan.org/security/sa1501.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/videolan/vlc/commit/204291467724867b79735c0ee3aeb0dbc2200f97"}}