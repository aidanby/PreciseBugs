{"buggy_code": ["\" Test commands that are not compiled in a :def function\n\nsource check.vim\nimport './vim9.vim' as v9\nsource term_util.vim\nsource view_util.vim\n\ndef Test_vim9cmd()\n  var lines =<< trim END\n    vim9cmd var x = 123\n    let s:y = 'yes'\n    vim9c assert_equal(123, x)\n    vim9cm assert_equal('yes', y)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  assert_fails('vim9cmd', 'E1164:')\n  assert_fails('legacy', 'E1234:')\n  assert_fails('vim9cmd echo \"con\" . \"cat\"', 'E15:')\n\n  lines =<< trim END\n      let str = 'con'\n      vim9cmd str .= 'cat'\n  END\n  v9.CheckScriptFailure(lines, 'E492:')\n\n  lines =<< trim END\n      vim9script\n      legacy echo \"con\" . \"cat\"\n      legacy let str = 'con'\n      legacy let str .= 'cat'\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo()\n        g:found_bar = \"bar\"\n      enddef\n      nmap ,; :vim9cmd <SID>Foo()<CR>\n  END\n  v9.CheckScriptSuccess(lines)\n\n  feedkeys(',;', 'xt')\n  assert_equal(\"bar\", g:found_bar)\n  nunmap ,;\n  unlet g:found_bar\n\n  lines =<< trim END\n      vim9script\n      legacy echo 1'000\n  END\n  v9.CheckScriptFailure(lines, 'E115:')\n\n  if has('float')\n    lines =<< trim END\n        vim9script\n        echo .10\n    END\n    v9.CheckScriptSuccess(lines)\n    lines =<< trim END\n        vim9cmd echo .10\n    END\n    v9.CheckScriptSuccess(lines)\n    lines =<< trim END\n        vim9script\n        legacy echo .10\n    END\n    v9.CheckScriptFailure(lines, 'E15:')\n  endif\n\n  echo v:version\n  assert_fails('vim9cmd echo version', 'E121:')\n  lines =<< trim END\n      vim9script\n      echo version\n  END\n  v9.CheckScriptFailure(lines, 'E121:')\n  lines =<< trim END\n      vim9script\n      legacy echo version\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_defcompile_fails()\n  assert_fails('defcompile NotExists', 'E1061:')\n  assert_fails('defcompile debug debug Test_defcompile_fails', 'E488:')\n  assert_fails('defcompile profile profile Test_defcompile_fails', 'E488:')\nenddef\n\ndefcompile Test_defcompile_fails\ndefcompile debug Test_defcompile_fails\ndefcompile profile Test_defcompile_fails\n\ndef Test_cmdmod_execute()\n  # \"legacy\" applies not only to the \"exe\" argument but also to the commands\n  var lines =<< trim END\n      vim9script\n\n      b:undo = 'let g:undone = 1 | let g:undtwo = 2'\n      legacy exe b:undo\n      assert_equal(1, g:undone)\n      assert_equal(2, g:undtwo)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # same for \"vim9cmd\" modifier\n  lines =<< trim END\n      let b:undo = 'g:undone = 11 | g:undtwo = 22'\n      vim9cmd exe b:undo\n      call assert_equal(11, g:undone)\n      call assert_equal(22, g:undtwo)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet b:undo\n  unlet g:undone\n  unlet g:undtwo\n\n  # \"legacy\" does not apply to a loaded script\n  lines =<< trim END\n      vim9script\n      export var exported = 'x'\n  END\n  writefile(lines, 'Xvim9import.vim')\n  lines =<< trim END\n      legacy exe \"import './Xvim9import.vim'\"\n  END\n  v9.CheckScriptSuccess(lines)\n  delete('Xvim9import.vim')\n\n  # \"legacy\" does not aply to a called function\n  lines =<< trim END\n      vim9script\n\n      def g:TheFunc()\n        if exists('something')\n          echo 'yes'\n        endif\n      enddef\n      legacy exe 'call g:TheFunc()'\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:TheFunc\n\n  # vim9cmd execute(cmd) executes code in vim9 script context\n  lines =<< trim END\n    vim9cmd execute(\"g:vim9executetest = 'bar'\")\n    call assert_equal('bar', g:vim9executetest)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:vim9executetest\n\n  lines =<< trim END\n    vim9cmd execute([\"g:vim9executetest1 = 'baz'\", \"g:vim9executetest2 = 'foo'\"])\n    call assert_equal('baz', g:vim9executetest1)\n    call assert_equal('foo', g:vim9executetest2)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:vim9executetest1\n  unlet g:vim9executetest2\n\n  # legacy call execute(cmd) executes code in vim script context\n  lines =<< trim END\n    vim9script\n    legacy call execute(\"let g:vim9executetest = 'bar'\")\n    assert_equal('bar', g:vim9executetest)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:vim9executetest\n\n  lines =<< trim END\n    vim9script\n    legacy call execute([\"let g:vim9executetest1 = 'baz'\", \"let g:vim9executetest2 = 'foo'\"])\n    assert_equal('baz', g:vim9executetest1)\n    assert_equal('foo', g:vim9executetest2)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:vim9executetest1\n  unlet g:vim9executetest2\nenddef\n\ndef Test_edit_wildcards()\n  var filename = 'Xtest'\n  edit `=filename`\n  assert_equal('Xtest', bufname())\n\n  var filenr = 123\n  edit Xtest`=filenr`\n  assert_equal('Xtest123', bufname())\n\n  filenr = 77\n  edit `=filename``=filenr`\n  assert_equal('Xtest77', bufname())\n\n  edit X`=filename`xx`=filenr`yy\n  assert_equal('XXtestxx77yy', bufname())\n\n  v9.CheckDefFailure(['edit `=xxx`'], 'E1001:')\n  v9.CheckDefFailure(['edit `=\"foo\"'], 'E1083:')\n\n  var files = ['file 1', 'file%2', 'file# 3']\n  args `=files`\n  assert_equal(files, argv())\n\n  filename = 'Xwindo'\n  windo edit `=filename`\n  assert_equal('Xwindo', bufname())\n\n  filename = 'Xtabdo'\n  tabdo edit `=filename`\n  assert_equal('Xtabdo', bufname())\n\n  filename = 'Xargdo'\n  argdo edit `=filename`\n  assert_equal('Xargdo', bufname())\n\n  :%bwipe!\n  filename = 'Xbufdo'\n  bufdo file `=filename`\n  assert_equal('Xbufdo', bufname())\nenddef\n\ndef Test_expand_alternate_file()\n  var lines =<< trim END\n    edit Xfileone\n    var bone = bufnr()\n    edit Xfiletwo\n    var btwo = bufnr()\n    edit Xfilethree\n    var bthree = bufnr()\n\n    edit #\n    assert_equal(bthree, bufnr())\n    edit %%\n    assert_equal(btwo, bufnr())\n    edit %% # comment\n    assert_equal(bthree, bufnr())\n    edit %%yy\n    assert_equal('Xfiletwoyy', bufname())\n\n    exe \"edit %%\" .. bone\n    assert_equal(bone, bufnr())\n    exe \"edit %%\" .. btwo .. \"xx\"\n    assert_equal('Xfiletwoxx', bufname())\n\n    next Xfileone Xfiletwo Xfilethree\n    assert_equal('Xfileone', argv(0))\n    assert_equal('Xfiletwo', argv(1))\n    assert_equal('Xfilethree', argv(2))\n    next %%%zz\n    assert_equal('Xfileone', argv(0))\n    assert_equal('Xfiletwo', argv(1))\n    assert_equal('Xfilethreezz', argv(2))\n\n    v:oldfiles = ['Xonefile', 'Xtwofile']\n    edit %%<1\n    assert_equal('Xonefile', bufname())\n    edit %%<2\n    assert_equal('Xtwofile', bufname())\n    assert_fails('edit %%<3', 'E684:')\n\n    edit Xfileone.vim\n    edit Xfiletwo\n    edit %%:r\n    assert_equal('Xfileone', bufname())\n\n    assert_false(bufexists('altfoo'))\n    edit altfoo\n    edit bar\n    assert_true(bufexists('altfoo'))\n    assert_true(buflisted('altfoo'))\n    bdel %%\n    assert_true(bufexists('altfoo'))\n    assert_false(buflisted('altfoo'))\n    bwipe! altfoo\n    bwipe! bar\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_global_backtick_expansion()\n  var name = 'xxx'\n  new\n  setline(1, ['one', 'two', 'three'])\n  set nomod\n  g/two/edit `=name`\n  assert_equal('xxx', bufname())\n  bwipe!\n\n  new\n  setline(1, ['one', 'two', 'three'])\n  g/two/s/^/`=name`/\n  assert_equal('`=name`two', getline(2))\n  bwipe!\nenddef\n\ndef Test_folddo_backtick_expansion()\n  new\n  var name = 'xxx'\n  folddoopen edit `=name`\n  assert_equal('xxx', bufname())\n  bwipe!\n\n  new\n  setline(1, ['one', 'two'])\n  set nomodified\n  :1,2fold\n  foldclose\n  folddoclose edit `=name`\n  assert_equal('xxx', bufname())\n  bwipe!\n\n  var lines =<< trim END\n      g:val = 'value'\n      def Test()\n        folddoopen echo `=g:val`\n      enddef\n      call Test()\n  END\n  v9.CheckScriptFailure(lines, 'E15: Invalid expression: \"`=g:val`\"')\nenddef\n\ndef Test_hardcopy_wildcards()\n  CheckUnix\n  CheckFeature postscript\n\n  var outfile = 'print'\n  hardcopy > X`=outfile`.ps\n  assert_true(filereadable('Xprint.ps'))\n\n  delete('Xprint.ps')\nenddef\n\ndef Test_syn_include_wildcards()\n  writefile(['syn keyword Found found'], 'Xthemine.vim')\n  var save_rtp = &rtp\n  &rtp = '.'\n\n  var fname = 'mine'\n  syn include @Group Xthe`=fname`.vim\n  assert_match('Found.* contained found', execute('syn list Found'))\n\n  &rtp = save_rtp\n  delete('Xthemine.vim')\nenddef\n\ndef Test_echo_linebreak()\n  var lines =<< trim END\n      vim9script\n      redir @a\n      echo 'one'\n            .. 'two'\n      redir END\n      assert_equal(\"\\nonetwo\", @a)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      redir @a\n      echo 11 +\n            77\n            - 22\n      redir END\n      assert_equal(\"\\n66\", @a)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_condition_types()\n  var lines =<< trim END\n      if 'text'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1135:', 1)\n\n  lines =<< trim END\n      if [1]\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E1012:', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E745:', 2)\n\n  lines =<< trim END\n      g:cond = 'text'\n      if g:cond\n      endif\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1135:', 2)\n\n  lines =<< trim END\n      g:cond = 0\n      if g:cond\n      elseif 'text'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1135:', 3)\n\n  lines =<< trim END\n      g:cond = 0\n      if g:cond\n      elseif 'text' garbage\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E488:', 3)\n\n  lines =<< trim END\n      g:cond = 0\n      if g:cond\n      elseif [1]\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E1012:', 3)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E745:', 4)\n\n  lines =<< trim END\n      g:cond = 'text'\n      if 0\n      elseif g:cond\n      endif\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1135:', 3)\n\n  lines =<< trim END\n      while 'text'\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E1012:', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E1135:', 2)\n\n  lines =<< trim END\n      while [1]\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E1012:', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E745:', 2)\n\n  lines =<< trim END\n      g:cond = 'text'\n      while g:cond\n      endwhile\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1135:', 2)\nenddef\n\ndef Test_if_linebreak()\n  var lines =<< trim END\n      vim9script\n      if 1 &&\n            true\n            || 1\n        g:res = 42\n      endif\n      assert_equal(42, g:res)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:res\n\n  lines =<< trim END\n      vim9script\n      if 1 &&\n            0\n        g:res = 0\n      elseif 0 ||\n              0\n              || 1\n        g:res = 12\n      endif\n      assert_equal(12, g:res)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:res\nenddef\n\ndef Test_while_linebreak()\n  var lines =<< trim END\n      vim9script\n      var nr = 0\n      while nr <\n              10 + 3\n            nr = nr\n                  + 4\n      endwhile\n      assert_equal(16, nr)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      var nr = 0\n      while nr\n            <\n              10\n              +\n              3\n            nr = nr\n                  +\n                  4\n      endwhile\n      assert_equal(16, nr)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_for_linebreak()\n  var lines =<< trim END\n      vim9script\n      var nr = 0\n      for x\n            in\n              [1, 2, 3, 4]\n          nr = nr + x\n      endfor\n      assert_equal(10, nr)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      var nr = 0\n      for x\n            in\n              [1, 2,\n                  3, 4\n                  ]\n          nr = nr\n                 +\n                  x\n      endfor\n      assert_equal(10, nr)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:MethodAfterLinebreak(arg: string)\n  arg\n    ->setline(1)\nenddef\n\ndef Test_method_call_linebreak()\n  var lines =<< trim END\n      vim9script\n      var res = []\n      func RetArg(\n            arg\n            )\n            let s:res = a:arg\n      endfunc\n      [1,\n          2,\n          3]->RetArg()\n      assert_equal([1, 2, 3], res)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      new\n      var name = [1, 2]\n      name\n          ->copy()\n          ->setline(1)\n      assert_equal(['1', '2'], getline(1, 2))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      new\n      def Foo(): string\n        return 'the text'\n      enddef\n      def Bar(F: func): string\n        return F()\n      enddef\n      def Test()\n        Foo  ->Bar()\n             ->setline(1)\n      enddef\n      Test()\n      assert_equal('the text', getline(1))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      new\n      g:shortlist\n          ->copy()\n          ->setline(1)\n      assert_equal(['1', '2'], getline(1, 2))\n      bwipe!\n  END\n  g:shortlist = [1, 2]\n  v9.CheckDefAndScriptSuccess(lines)\n  unlet g:shortlist\n\n  new\n  MethodAfterLinebreak('foobar')\n  assert_equal('foobar', getline(1))\n  bwipe!\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n          return '# some text'\n      enddef\n\n      def Bar(F: func): string\n          return F()\n      enddef\n\n      Foo->Bar()\n         ->setline(1)\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('# some text', getline(1))\n  bwipe!\nenddef\n\ndef Test_method_call_whitespace()\n  var lines =<< trim END\n    new\n    var yank = 'text'\n    yank->setline(1)\n    yank  ->setline(2)\n    yank->  setline(3)\n    yank  ->  setline(4)\n    assert_equal(['text', 'text', 'text', 'text'], getline(1, 4))\n    bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_method_and_user_command()\n  var lines =<< trim END\n      vim9script\n      def Cmd()\n        g:didFunc = 1\n      enddef\n      command Cmd g:didCmd = 1\n      Cmd\n      assert_equal(1, g:didCmd)\n      Cmd()\n      assert_equal(1, g:didFunc)\n      unlet g:didFunc\n      unlet g:didCmd\n\n      def InDefFunc()\n        Cmd\n        assert_equal(1, g:didCmd)\n        Cmd()\n        assert_equal(1, g:didFunc)\n        unlet g:didFunc\n        unlet g:didCmd\n      enddef\n      InDefFunc()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_option_use_linebreak()\n  var lines =<< trim END\n      new\n      &matchpairs = '(:)'\n      &matchpairs->setline(1)\n      &matchpairs = '[:]'\n      &matchpairs   ->setline(2)\n      &matchpairs = '{:}'\n      &matchpairs  \n          ->setline(3)\n      assert_equal(['(:)', '[:]', '{:}'], getline(1, '$'))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_use_register()\n  var lines =<< trim END\n      new\n      @a = 'one'\n      @a->setline(1)\n      @b = 'two'\n      @b   ->setline(2)\n      @c = 'three'\n      @c  \n          ->setline(3)\n      assert_equal(['one', 'two', 'three'], getline(1, '$'))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      @a = 'echo \"text\"'\n      @a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n\n  lines =<< trim END\n      @a = 'echo \"text\"'\n      @a\n\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n\n  lines =<< trim END\n      @a = 'echo \"text\"'\n      @a\n          # comment\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n\n  lines =<< trim END\n      @/ = 'pattern'\n      @/\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n\n  lines =<< trim END\n      &opfunc = 'nothing'\n      &opfunc\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n  &opfunc = ''\n\n  lines =<< trim END\n      &l:showbreak = 'nothing'\n      &l:showbreak\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n  &l:showbreak = ''\n\n  lines =<< trim END\n      &g:showbreak = 'nothing'\n      &g:showbreak\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n  &g:showbreak = ''\n\n  lines =<< trim END\n      $SomeEnv = 'value'\n      $SomeEnv\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n  $SomeEnv = ''\n\n  lines =<< trim END\n      eval 'value'\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 1)\n\n  lines =<< trim END\n      eval \"value\"\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 1)\nenddef\n\ndef Test_environment_use_linebreak()\n  var lines =<< trim END\n      new\n      $TESTENV = 'one'\n      $TESTENV->setline(1)\n      $TESTENV = 'two'\n      $TESTENV  ->setline(2)\n      $TESTENV = 'three'\n      $TESTENV  \n          ->setline(3)\n      assert_equal(['one', 'two', 'three'], getline(1, '$'))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_skipped_expr_linebreak()\n  if 0\n    var x = []\n               ->map(() => 0)\n  endif\nenddef\n\ndef Test_dict_member()\n   var test: dict<list<number>> = {data: [3, 1, 2]}\n   test.data->sort()\n   assert_equal({data: [1, 2, 3]}, test)\n   test.data\n      ->reverse()\n   assert_equal({data: [3, 2, 1]}, test)\n\n  var lines =<< trim END\n      vim9script\n      var test: dict<list<number>> = {data: [3, 1, 2]}\n      test.data->sort()\n      assert_equal({data: [1, 2, 3]}, test)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_bar_after_command()\n  def RedrawAndEcho()\n    var x = 'did redraw'\n    redraw | echo x\n  enddef\n  RedrawAndEcho()\n  assert_match('did redraw', g:Screenline(&lines))\n\n  def CallAndEcho()\n    var x = 'did redraw'\n    reg_executing() | echo x\n  enddef\n  CallAndEcho()\n  assert_match('did redraw', g:Screenline(&lines))\n\n  if has('unix')\n    # bar in filter write command does not start new command\n    def WriteToShell()\n      new\n      setline(1, 'some text')\n      w !cat | cat > Xoutfile\n      bwipe!\n    enddef\n    WriteToShell()\n    assert_equal(['some text'], readfile('Xoutfile'))\n    delete('Xoutfile')\n\n    # bar in filter read command does not start new command\n    def ReadFromShell()\n      new\n      r! echo hello there | cat > Xoutfile\n      r !echo again | cat >> Xoutfile\n      bwipe!\n    enddef\n    ReadFromShell()\n    assert_equal(['hello there', 'again'], readfile('Xoutfile'))\n    delete('Xoutfile')\n  endif\nenddef\n\ndef Test_filter_is_not_modifier()\n  var tags = [{a: 1, b: 2}, {x: 3, y: 4}]\n  filter(tags, ( _, v) => has_key(v, 'x') ? 1 : 0 )\n  assert_equal([{x: 3, y: 4}], tags)\nenddef\n\ndef Test_command_modifier_filter()\n  var lines =<< trim END\n    final expected = \"\\nType Name Content\\n  c  \\\"c   piyo\"\n    @a = 'hoge'\n    @b = 'fuga'\n    @c = 'piyo'\n\n    assert_equal(execute('filter /piyo/ registers abc'), expected)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # also do this compiled\n  lines =<< trim END\n      @a = 'very specific z3d37dh234 string'\n      filter z3d37dh234 registers\n      assert_match('very specific z3d37dh234 string', g:Screenline(&lines))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      edit foobar\n      redir => g:filter_out\n      filter #foobar# ls\n      redir END\n      assert_match('\"foobar\"', g:filter_out)\n      unlet g:filter_out\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_win_command_modifiers()\n  assert_equal(1, winnr('$'))\n\n  set splitright\n  vsplit\n  assert_equal(2, winnr())\n  close\n  aboveleft vsplit\n  assert_equal(1, winnr())\n  close\n  set splitright&\n\n  vsplit\n  assert_equal(1, winnr())\n  close\n  belowright vsplit\n  assert_equal(2, winnr())\n  close\n  rightbelow vsplit\n  assert_equal(2, winnr())\n  close\n\n  if has('browse')\n    browse set\n    assert_equal('option-window', expand('%'))\n    close\n  endif\n\n  vsplit\n  botright split\n  assert_equal(3, winnr())\n  assert_equal(&columns, winwidth(0))\n  close\n  close\n\n  vsplit\n  topleft split\n  assert_equal(1, winnr())\n  assert_equal(&columns, winwidth(0))\n  close\n  close\n\n  gettabinfo()->len()->assert_equal(1)\n  tab split\n  gettabinfo()->len()->assert_equal(2)\n  tabclose\n\n  vertical new\n  assert_inrange(&columns / 2 - 2, &columns / 2 + 1, winwidth(0))\n  close\nenddef\n\nfunc Test_command_modifier_confirm()\n  CheckNotGui\n  CheckRunVimInTerminal\n\n  \" Test for saving all the modified buffers\n  let lines =<< trim END\n    call setline(1, 'changed')\n    def Getout()\n      confirm write Xfile\n    enddef\n  END\n  call writefile(lines, 'Xconfirmscript')\n  call writefile(['empty'], 'Xfile')\n  let buf = RunVimInTerminal('-S Xconfirmscript', {'rows': 8})\n  call term_sendkeys(buf, \":call Getout()\\n\")\n  call WaitForAssert({-> assert_match('(Y)es, \\[N\\]o: ', term_getline(buf, 8))}, 1000)\n  call term_sendkeys(buf, \"y\")\n  call WaitForAssert({-> assert_match('(Y)es, \\[N\\]o: ', term_getline(buf, 8))}, 1000)\n  call term_sendkeys(buf, \"\\<CR>\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n\n  call assert_equal(['changed'], readfile('Xfile'))\n  call delete('Xfile')\n  call delete('.Xfile.swp')  \" in case Vim was killed\n  call delete('Xconfirmscript')\nendfunc\n\ndef Test_command_modifiers_keep()\n  if has('unix')\n    def DoTest(addRflag: bool, keepMarks: bool, hasMarks: bool)\n      new\n      setline(1, ['one', 'two', 'three'])\n      normal 1Gma\n      normal 2Gmb\n      normal 3Gmc\n      if addRflag\n        set cpo+=R\n      else\n        set cpo-=R\n      endif\n      if keepMarks\n        keepmarks :%!cat\n      else\n        :%!cat\n      endif\n      if hasMarks\n        assert_equal(1, line(\"'a\"))\n        assert_equal(2, line(\"'b\"))\n        assert_equal(3, line(\"'c\"))\n      else\n        assert_equal(0, line(\"'a\"))\n        assert_equal(0, line(\"'b\"))\n        assert_equal(0, line(\"'c\"))\n      endif\n      quit!\n    enddef\n    DoTest(false, false, true)\n    DoTest(true, false, false)\n    DoTest(false, true, true)\n    DoTest(true, true, true)\n    set cpo&vim\n\n    new\n    setline(1, ['one', 'two', 'three', 'four'])\n    assert_equal(4, line(\"$\"))\n    normal 1Gma\n    normal 2Gmb\n    normal 3Gmc\n    lockmarks :1,2!wc\n    # line is deleted, marks don't move\n    assert_equal(3, line(\"$\"))\n    assert_equal('four', getline(3))\n    assert_equal(1, line(\"'a\"))\n    assert_equal(2, line(\"'b\"))\n    assert_equal(3, line(\"'c\"))\n    quit!\n  endif\n\n  edit Xone\n  edit Xtwo\n  assert_equal('Xone', expand('#'))\n  keepalt edit Xthree\n  assert_equal('Xone', expand('#'))\n\n  normal /a*b*\n  assert_equal('a*b*', histget(\"search\"))\n  keeppatterns normal /c*d*\n  assert_equal('a*b*', histget(\"search\"))\n\n  new\n  setline(1, range(10))\n  :10\n  normal gg\n  assert_equal(10, getpos(\"''\")[1])\n  keepjumps normal 5G\n  assert_equal(10, getpos(\"''\")[1])\n  quit!\nenddef\n\ndef Test_bar_line_continuation()\n  var lines =<< trim END\n      au BufNewFile Xfile g:readFile = 1\n          | g:readExtra = 2\n      g:readFile = 0\n      g:readExtra = 0\n      edit Xfile\n      assert_equal(1, g:readFile)\n      assert_equal(2, g:readExtra)\n      bwipe!\n      au! BufNewFile\n\n      au BufNewFile Xfile g:readFile = 1\n          | g:readExtra = 2\n          | g:readMore = 3\n      g:readFile = 0\n      g:readExtra = 0\n      g:readMore = 0\n      edit Xfile\n      assert_equal(1, g:readFile)\n      assert_equal(2, g:readExtra)\n      assert_equal(3, g:readMore)\n      bwipe!\n      au! BufNewFile\n      unlet g:readFile\n      unlet g:readExtra\n      unlet g:readMore\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_command_modifier_other()\n  new Xsomefile\n  setline(1, 'changed')\n  var buf = bufnr()\n  hide edit Xotherfile\n  var info = getbufinfo(buf)\n  assert_equal(1, info[0].hidden)\n  assert_equal(1, info[0].changed)\n  edit Xsomefile\n  bwipe!\n\n  au BufNewFile Xfile g:readFile = 1\n  g:readFile = 0\n  edit Xfile\n  assert_equal(1, g:readFile)\n  bwipe!\n  g:readFile = 0\n  noautocmd edit Xfile\n  assert_equal(0, g:readFile)\n  au! BufNewFile\n  unlet g:readFile\n\n  noswapfile edit XnoSwap\n  assert_equal(false, &l:swapfile)\n  bwipe!\n\n  var caught = false\n  try\n    sandbox !ls\n  catch /E48:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  :8verbose g:verbose_now = &verbose\n  assert_equal(8, g:verbose_now)\n  unlet g:verbose_now\nenddef\n\ndef s:EchoHere()\n  echomsg 'here'\nenddef\ndef s:EchoThere()\n  unsilent echomsg 'there'\nenddef\n\ndef Test_modifier_silent_unsilent()\n  echomsg 'last one'\n  silent echomsg \"text\"\n  assert_equal(\"\\nlast one\", execute(':1messages'))\n\n  silent! echoerr \"error\"\n\n  echomsg 'last one'\n  silent EchoHere()\n  assert_equal(\"\\nlast one\", execute(':1messages'))\n\n  silent EchoThere()\n  assert_equal(\"\\nthere\", execute(':1messages'))\n\n  try\n    silent eval [][0]\n  catch\n    echomsg \"caught\"\n  endtry\n  assert_equal(\"\\ncaught\", execute(':1messages'))\n\n  var lines =<< trim END\n      vim9script\n      set history=11\n      silent! while 0\n        set history=22\n      silent! endwhile\n      assert_equal(11, &history)\n      set history&\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_range_after_command_modifier()\n  v9.CheckScriptFailure(['vim9script', 'silent keepjump 1d _'], 'E1050: Colon required before a range: 1d _', 2)\n  new\n  setline(1, 'xxx')\n  v9.CheckScriptSuccess(['vim9script', 'silent keepjump :1d _'])\n  assert_equal('', getline(1))\n  bwipe!\n\n  var lines =<< trim END\n      legacy /pat/\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E486: Pattern not found: pat')\nenddef\n\ndef Test_silent_pattern()\n  new\n  silent! :/pat/put _\n  bwipe!\nenddef\n\ndef Test_useless_command_modifier()\n  g:maybe = true\n  var lines =<< trim END\n      if g:maybe\n      silent endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 2)\n\n  lines =<< trim END\n      for i in [0]\n      silent endfor\n  END\n  v9.CheckDefFailure(lines, 'E1176:', 2)\n  v9.CheckScriptSuccess(['vim9script'] + lines)\n\n  lines =<< trim END\n      while g:maybe\n      silent endwhile\n  END\n  v9.CheckDefFailure(lines, 'E1176:', 2)\n  g:maybe = false\n  v9.CheckScriptSuccess(['vim9script'] + lines)\n\n  lines =<< trim END\n      silent try\n      finally\n      endtry\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 1)\n\n  lines =<< trim END\n      try\n      silent catch\n      endtry\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 2)\n\n  lines =<< trim END\n      try\n      silent finally\n      endtry\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 2)\n\n  lines =<< trim END\n      try\n      finally\n      silent endtry\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 3)\n\n  lines =<< trim END\n      leftabove\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1082:', 1)\n\n  lines =<< trim END\n      leftabove # comment\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1082:', 1)\nenddef\n\ndef Test_eval_command()\n  var from = 3\n  var to = 5\n  g:val = 111\n  def Increment(nrs: list<number>)\n    for nr in nrs\n      g:val += nr\n    endfor\n  enddef\n  eval range(from, to)\n        ->Increment()\n  assert_equal(111 + 3 + 4 + 5, g:val)\n  unlet g:val\n\n  var lines =<< trim END\n    vim9script\n    g:caught = 'no'\n    try\n      eval 123 || 0\n    catch\n      g:caught = 'yes'\n    endtry\n    assert_equal('yes', g:caught)\n    unlet g:caught\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_map_command()\n  var lines =<< trim END\n      nnoremap <F3> :echo 'hit F3 #'<CR>\n      assert_equal(\":echo 'hit F3 #'<CR>\", maparg(\"<F3>\", \"n\"))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # backslash before bar is not removed\n  lines =<< trim END\n      vim9script\n\n      def Init()\n        noremap <buffer> <F5> <ScriptCmd>MyFunc('a') \\| MyFunc('b')<CR>\n      enddef\n      Init()\n      unmap <buffer> <F5>\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_normal_command()\n  new\n  setline(1, 'doesnotexist')\n  var caught = 0\n  try\n    exe \"norm! \\<C-]>\"\n  catch /E433/\n    caught = 2\n  endtry\n  assert_equal(2, caught)\n\n  try\n    exe \"norm! 3\\<C-]>\"\n  catch /E433/\n    caught = 3\n  endtry\n  assert_equal(3, caught)\n  bwipe!\nenddef\n\ndef Test_put_command()\n  new\n  @p = 'ppp'\n  put p\n  assert_equal('ppp', getline(2))\n\n  put ='below'\n  assert_equal('below', getline(3))\n  put! ='above'\n  assert_equal('above', getline(3))\n  assert_equal('below', getline(4))\n\n  :2put =['a', 'b', 'c']\n  assert_equal(['ppp', 'a', 'b', 'c', 'above'], getline(2, 6))\n\n  :0put =  'first'\n  assert_equal('first', getline(1))\n  :1put! ='first again'\n  assert_equal('first again', getline(1))\n\n  # compute range at runtime\n  :%del\n  setline(1, range(1, 8))\n  @a = 'aaa'\n  :$-2put a\n  assert_equal('aaa', getline(7))\n\n  setline(1, range(1, 8))\n  :2\n  :+2put! a\n  assert_equal('aaa', getline(4))\n\n  []->mapnew(() => 0)\n  :$put ='end'\n  assert_equal('end', getline('$'))\n\n  bwipe!\n\n  v9.CheckDefFailure(['put =xxx'], 'E1001:')\nenddef\n\ndef Test_put_with_linebreak()\n  new\n  var lines =<< trim END\n    vim9script\n    pu =split('abc', '\\zs')\n            ->join()\n  END\n  v9.CheckScriptSuccess(lines)\n  getline(2)->assert_equal('a b c')\n  bwipe!\nenddef\n\ndef Test_command_star_range()\n  new\n  setline(1, ['xxx foo xxx', 'xxx bar xxx', 'xxx foo xx bar'])\n  setpos(\"'<\", [0, 1, 0, 0])\n  setpos(\"'>\", [0, 3, 0, 0])\n  :*s/\\(foo\\|bar\\)/baz/g\n  getline(1, 3)->assert_equal(['xxx baz xxx', 'xxx baz xxx', 'xxx baz xx baz'])\n\n  bwipe!\nenddef\n\ndef Test_f_args()\n  var lines =<< trim END\n    vim9script\n\n    func SaveCmdArgs(...)\n      let g:args = a:000\n    endfunc\n\n    command -nargs=* TestFArgs call SaveCmdArgs(<f-args>)\n\n    TestFArgs\n    assert_equal([], g:args)\n\n    TestFArgs one two three\n    assert_equal(['one', 'two', 'three'], g:args)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_user_command_comment()\n  command -nargs=1 Comd echom <q-args>\n\n  var lines =<< trim END\n      vim9script\n      Comd # comment\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      Comd# comment\n  END\n  v9.CheckScriptFailure(lines, 'E1144:')\n  delcommand Comd\n\n  lines =<< trim END\n      vim9script\n      command Foo echo 'Foo'\n      Foo3Bar\n  END\n  v9.CheckScriptFailure(lines, 'E1144: Command \"Foo\" is not followed by white space: Foo3Bar')\n\n  delcommand Foo\nenddef\n\ndef Test_star_command()\n  var lines =<< trim END\n    vim9script\n    @s = 'g:success = 8'\n    set cpo+=*\n    exe '*s'\n    assert_equal(8, g:success)\n    unlet g:success\n    set cpo-=*\n    assert_fails(\"exe '*s'\", 'E1050:')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmd_argument_without_colon()\n  new Xfile\n  setline(1, ['a', 'b', 'c', 'd'])\n  write\n  edit +3 %\n  assert_equal(3, getcurpos()[1])\n  edit +/a %\n  assert_equal(1, getcurpos()[1])\n  bwipe\n  delete('Xfile')\nenddef\n\ndef Test_ambiguous_user_cmd()\n  command Cmd1 eval 0\n  command Cmd2 eval 0\n  var lines =<< trim END\n      Cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E464:', 1)\n  delcommand Cmd1\n  delcommand Cmd2\nenddef\n\ndef Test_command_not_recognized()\n  var lines =<< trim END\n    d.key = 'asdf'\n  END\n  v9.CheckDefFailure(lines, 'E1089: Unknown variable: d', 1)\n\n  lines =<< trim END\n    d['key'] = 'asdf'\n  END\n  v9.CheckDefFailure(lines, 'E1089: Unknown variable: d', 1)\n\n  lines =<< trim END\n    if 0\n      d.key = 'asdf'\n    endif\n  END\n  v9.CheckDefSuccess(lines)\nenddef\n\ndef Test_magic_not_used()\n  new\n  for cmd in ['set magic', 'set nomagic']\n    exe cmd\n    setline(1, 'aaa')\n    s/.../bbb/\n    assert_equal('bbb', getline(1))\n  endfor\n\n  set magic\n  setline(1, 'aaa')\n  assert_fails('s/.\\M../bbb/', 'E486:')\n  assert_fails('snomagic/.../bbb/', 'E486:')\n  assert_equal('aaa', getline(1))\n\n  bwipe!\nenddef\n\ndef Test_gdefault_not_used()\n  new\n  for cmd in ['set gdefault', 'set nogdefault']\n    exe cmd\n    setline(1, 'aaa')\n    s/./b/\n    assert_equal('baa', getline(1))\n  endfor\n\n  set nogdefault\n  bwipe!\nenddef\n\ndef s:SomeComplFunc(findstart: number, base: string): any\n  if findstart\n    return 0\n  else\n    return ['aaa', 'bbb']\n  endif\nenddef\n\ndef Test_insert_complete()\n  # this was running into an error with the matchparen hack\n  new\n  set completefunc=SomeComplFunc\n  feedkeys(\"i\\<c-x>\\<c-u>\\<Esc>\", 'ntx')\n  assert_equal('aaa', getline(1))\n\n  set completefunc=\n  bwipe!\nenddef\n\ndef Test_wincmd()\n  split\n  var id1 = win_getid()\n  if true\n    try | wincmd w | catch | endtry\n  endif\n  assert_notequal(id1, win_getid())\n  close\n\n  split\n  var id = win_getid()\n  split\n  :2wincmd o\n  assert_equal(id, win_getid())\n  only\n\n  split\n  split\n  assert_equal(3, winnr('$'))\n  :2wincmd c\n  assert_equal(2, winnr('$'))\n  only\n\n  split\n  split\n  assert_equal(3, winnr('$'))\n  :2wincmd q\n  assert_equal(2, winnr('$'))\n  only\nenddef\n\ndef Test_windo_missing_endif()\n  var lines =<< trim END\n      windo if 1\n  END\n  v9.CheckDefExecFailure(lines, 'E171:', 1)\nenddef\n\nlet s:theList = [1, 2, 3]\n\ndef Test_lockvar()\n  s:theList[1] = 22\n  assert_equal([1, 22, 3], s:theList)\n  lockvar s:theList\n  assert_fails('theList[1] = 77', 'E741:')\n  unlockvar s:theList\n  s:theList[1] = 44\n  assert_equal([1, 44, 3], s:theList)\n\n  if 0\n    lockvar whatever\n  endif\n\n  g:lockme = [1, 2, 3]\n  lockvar 1 g:lockme\n  g:lockme[1] = 77\n  assert_equal([1, 77, 3], g:lockme)\n\n  lockvar 2 g:lockme\n  var caught = false\n  try\n    g:lockme[1] = 99\n  catch /E1119:/\n    caught = true\n  endtry\n  assert_true(caught)\n  assert_equal([1, 77, 3], g:lockme)\n  unlet g:lockme\n\n  # also for non-materialized list\n  g:therange = range(3)\n  lockvar 2 g:therange\n  caught = false\n  try\n    g:therange[1] = 99\n  catch /E1119:/\n    caught = true\n  endtry\n  assert_true(caught)\n  assert_equal([0, 1, 2], g:therange)\n  unlet g:therange\n\n  # use exclamation mark for locking deeper\n  g:nestedlist = [1, [2, 3], 4]\n  lockvar! g:nestedlist\n  try\n    g:nestedlist[1][0] = 9\n  catch /E1119:/\n    caught = true\n  endtry\n  assert_true(caught)\n  unlet g:nestedlist\n\n  var d = {a: 1, b: 2}\n  d.a = 3\n  d.b = 4\n  assert_equal({a: 3, b: 4}, d)\n  lockvar d.a\n  d.b = 5\n  var ex = ''\n  try\n    d.a = 6\n  catch\n    ex = v:exception\n  endtry\n  assert_match('E1121:', ex)\n  unlockvar d['a']\n  d.a = 7\n  assert_equal({a: 7, b: 5}, d)\n\n  caught = false\n  try\n    lockvar d.c\n  catch /E716/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  var lines =<< trim END\n      vim9script\n      g:bl = 0z1122\n      lockvar g:bl\n      def Tryit()\n        g:bl[1] = 99\n      enddef\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E741:', 1)\n\n  lines =<< trim END\n      vim9script\n      var theList = [1, 2, 3]\n      def SetList()\n        theList[1] = 22\n        assert_equal([1, 22, 3], theList)\n        lockvar theList\n        theList[1] = 77\n      enddef\n      SetList()\n  END\n  v9.CheckScriptFailure(lines, 'E1119', 4)\n\n  lines =<< trim END\n      vim9script\n      var theList = [1, 2, 3]\n      def AddToList()\n        lockvar theList\n        theList += [4]\n      enddef\n      AddToList()\n  END\n  v9.CheckScriptFailure(lines, 'E741', 2)\n\n  lines =<< trim END\n      vim9script\n      var theList = [1, 2, 3]\n      def AddToList()\n        lockvar theList\n        add(theList, 4)\n      enddef\n      AddToList()\n  END\n  v9.CheckScriptFailure(lines, 'E741', 2)\n\n  # can unlet a locked list item but not change it\n  lines =<< trim END\n    var ll = [1, 2, 3]\n    lockvar ll[1]\n    unlet ll[1]\n    assert_equal([1, 3], ll)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  lines =<< trim END\n    var ll = [1, 2, 3]\n    lockvar ll[1]\n    ll[1] = 9\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1119:', 'E741'], 3)\n\n  # can unlet a locked dict item but not change it\n  lines =<< trim END\n    var dd = {a: 1, b: 2}\n    lockvar dd.a\n    unlet dd.a\n    assert_equal({b: 2}, dd)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  lines =<< trim END\n    var dd = {a: 1, b: 2}\n    lockvar dd.a\n    dd.a = 3\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1121:', 'E741'], 3)\n\n  lines =<< trim END\n      var theList = [1, 2, 3]\n      lockvar theList\n  END\n  v9.CheckDefFailure(lines, 'E1178', 2)\n\n  lines =<< trim END\n      var theList = [1, 2, 3]\n      unlockvar theList\n  END\n  v9.CheckDefFailure(lines, 'E1178', 2)\n\n  lines =<< trim END\n      vim9script\n      var name = 'john'\n      lockvar nameX\n  END\n  v9.CheckScriptFailure(lines, 'E1246', 3)\n\n  lines =<< trim END\n      vim9script\n      var name = 'john'\n      def LockIt()\n        lockvar nameX\n      enddef\n      LockIt()\n  END\n  v9.CheckScriptFailure(lines, 'E1246', 1)\n\n  lines =<< trim END\n      vim9script\n      const name = 'john'\n      unlockvar name\n  END\n  v9.CheckScriptFailure(lines, 'E46', 3)\n\n  lines =<< trim END\n      vim9script\n      const name = 'john'\n      def UnLockIt()\n        unlockvar name\n      enddef\n      UnLockIt()\n  END\n  v9.CheckScriptFailure(lines, 'E46', 1)\n\n  lines =<< trim END\n      def _()\n        s:0([], s:0)\n        lockv\n      enddef\n      defcomp\n  END\n  v9.CheckScriptFailure(lines, 'E179', 2)\nenddef\n\ndef Test_substitute_expr()\n  var to = 'repl'\n  new\n  setline(1, 'one from two')\n  s/from/\\=to\n  assert_equal('one repl two', getline(1))\n\n  setline(1, 'one from two')\n  s/from/\\=to .. '_x'\n  assert_equal('one repl_x two', getline(1))\n\n  setline(1, 'one from two from three')\n  var also = 'also'\n  s/from/\\=to .. '_' .. also/g#e\n  assert_equal('one repl_also two repl_also three', getline(1))\n\n  setline(1, 'abc abc abc')\n  for choice in [true, false]\n    :1s/abc/\\=choice ? 'yes' : 'no'/\n  endfor\n  assert_equal('yes no abc', getline(1))\n\n  setline(1, 'from')\n  v9.CheckDefExecFailure(['s/from/\\=g:notexist/'], 'E121: Undefined variable: g:notexist')\n\n  bwipe!\n\n  v9.CheckDefFailure(['s/from/\\=\"x\")/'], 'E488:')\n  v9.CheckDefFailure(['s/from/\\=\"x\"/9'], 'E488:')\n\n  v9.CheckDefExecFailure(['s/this/\\=\"that\"/'], 'E486:')\n\n  # When calling a function the right instruction list needs to be restored.\n  g:cond = true\n  var lines =<< trim END\n      vim9script\n      def Foo()\n          Bar([])\n      enddef\n      def Bar(l: list<number>)\n        if g:cond\n          s/^/\\=Rep()/\n          for n in l[:]\n          endfor\n        endif\n      enddef\n      def Rep(): string\n          return 'rep'\n      enddef\n      new\n      Foo()\n      assert_equal('rep', getline(1))\n      bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:cond\n\n  # List results in multiple lines\n  new\n  setline(1, 'some text here')\n  s/text/\\=['aaa', 'bbb', 'ccc']/\n  assert_equal(['some aaa', 'bbb', 'ccc', ' here'], getline(1, '$'))\n  bwipe!\n\n  # inside \"if 0\" substitute is ignored\n  if 0\n    s/a/\\=nothing/ and | some more\n  endif\nenddef\n\ndef Test_redir_to_var()\n  var result: string\n  redir => result\n    echo 'something'\n  redir END\n  assert_equal(\"\\nsomething\", result)\n\n  redir =>> result\n    echo 'more'\n  redir END\n  assert_equal(\"\\nsomething\\nmore\", result)\n\n  var d: dict<string>\n  redir => d.redir\n    echo 'dict'\n  redir END\n  assert_equal({redir: \"\\ndict\"}, d)\n\n  var l = ['a', 'b', 'c']\n  redir => l[1]\n    echo 'list'\n  redir END\n  assert_equal(['a', \"\\nlist\", 'c'], l)\n\n  var dl = {l: ['x']}\n  redir => dl.l[0]\n    echo 'dict-list'\n  redir END\n  assert_equal({l: [\"\\ndict-list\"]}, dl)\n\n  redir =>> d.redir\n    echo 'more'\n  redir END\n  assert_equal({redir: \"\\ndict\\nmore\"}, d)\n\n  var lines =<< trim END\n    redir => notexist\n  END\n  v9.CheckDefFailure(lines, 'E1089:')\n\n  lines =<< trim END\n    var text: string\n    redir => text\n  END\n  v9.CheckDefFailure(lines, 'E1185:')\n\n  lines =<< trim END\n    var ls = 'asdf'\n    redir => ls[1]\n    redir END\n  END\n  v9.CheckDefFailure(lines, 'E1141:')\n\n  lines =<< trim END\n      var text: string\n      redir => text\n        echo 'hello'\n        redir > Xfile\n      redir END\n  END\n  v9.CheckDefFailure(lines, 'E1092:')\n\n  lines =<< trim END\n      var text: number\n      redir => text\n        echo 'hello'\n      redir END\n  END\n  v9.CheckDefFailure(lines, 'E1012:')\nenddef\n\ndef Test_echo_void()\n  var lines =<< trim END\n      vim9script\n      def NoReturn()\n        echo 'nothing'\n      enddef\n      echo NoReturn()\n  END\n  v9.CheckScriptFailure(lines, 'E1186:', 5)\n\n  lines =<< trim END\n      vim9script\n      def NoReturn()\n        echo 'nothing'\n      enddef\n      def Try()\n        echo NoReturn()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1186:', 1)\nenddef\n\ndef Test_cmdwin_block()\n  augroup justTesting\n    autocmd BufEnter * {\n      echomsg 'in block'\n    }\n  augroup END\n  feedkeys('q:', 'xt')\n  redraw\n  feedkeys(\"aclose\\<CR>\", 'xt')\n\n  au! justTesting\nenddef\n\ndef Test_var_not_cmd()\n  var lines =<< trim END\n      g:notexist:cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E488: Trailing characters: :cmd', 'E121: Undefined variable: g:notexist'], 1)\n\n  lines =<< trim END\n      g-pat-cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1241:', 1)\n  lines =<< trim END\n      g.pat.cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1001: Variable not found: g', 'E121: Undefined variable: g'], 1)\n\n  lines =<< trim END\n      s:notexist:repl\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E488: Trailing characters: :repl', 'E1268:'], 1)\n\n  lines =<< trim END\n      notexist:repl\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'], 1)\n\n  lines =<< trim END\n      s-pat-repl\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1241:', 1)\n  lines =<< trim END\n      s.pat.repl\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1001: Variable not found: s', 'E121: Undefined variable: s'], 1)\n\n  lines =<< trim END\n      w:notexist->len()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E121: Undefined variable: w:notexist', 1)\n\n  lines =<< trim END\n      b:notexist->len()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E121: Undefined variable: b:notexist', 1)\n\n  lines =<< trim END\n      t:notexist->len()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E121: Undefined variable: t:notexist', 1)\nenddef\n\ndef Test_no_space_after_command()\n  var lines =<< trim END\n      g /pat/cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1242:', 1)\n  lines =<< trim END\n      g #pat#cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1242:', 1)\n\n  new\n  setline(1, 'some pat')\n  lines =<< trim END\n      g#pat#print\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  lines =<< trim END\n      g# pat#print\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  bwipe!\n\n  lines =<< trim END\n      s /pat/repl\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1242:', 1)\n  lines =<< trim END\n      s #pat#repl\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1242:', 1)\n  lines =<< trim END\n      s#pat#repl\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E486:', 1)\n  lines =<< trim END\n      s# pat#repl\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E486:', 1)\nenddef\n\n\" Test for the 'previewpopup' option\ndef Test_previewpopup()\n  set previewpopup=height:10,width:60\n  pedit Xfile\n  var id = popup_findpreview()\n  assert_notequal(id, 0)\n  assert_match('Xfile', popup_getoptions(id).title)\n  popup_clear()\n  set previewpopup&\nenddef\n\ndef Test_syntax_enable_clear()\n  syntax clear\n  syntax enable\n  highlight clear String\n  assert_equal(true, hlget('String')->get(0, {})->get('default', false))\n  syntax clear\nenddef\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9cmds.c: Dealing with commands of a compiled function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n/*\n * Get the index of the current instruction.\n * This compensates for a preceding ISN_CMDMOD and ISN_PROF_START.\n */\n    static int\ncurrent_instr_idx(cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tidx = instr->ga_len;\n\n    while (idx > 0)\n    {\n\tif (cctx->ctx_has_cmdmod && ((isn_T *)instr->ga_data)[idx - 1]\n\t\t\t\t\t\t       .isn_type == ISN_CMDMOD)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n#ifdef FEAT_PROFILE\n\tif (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_PROF_START)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n#endif\n\tif (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_DEBUG)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n\tbreak;\n    }\n    return idx;\n}\n/*\n * Remove local variables above \"new_top\".\n */\n    static void\nunwind_locals(cctx_T *cctx, int new_top)\n{\n    if (cctx->ctx_locals.ga_len > new_top)\n    {\n\tint\tidx;\n\tlvar_T\t*lvar;\n\n\tfor (idx = new_top; idx < cctx->ctx_locals.ga_len; ++idx)\n\t{\n\t    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\t    vim_free(lvar->lv_name);\n\t}\n    }\n    cctx->ctx_locals.ga_len = new_top;\n}\n\n/*\n * Free all local variables.\n */\n    void\nfree_locals(cctx_T *cctx)\n{\n    unwind_locals(cctx, 0);\n    ga_clear(&cctx->ctx_locals);\n}\n\n\n/*\n * Check if \"name\" can be \"unlet\".\n */\n    int\ncheck_vim9_unlet(char_u *name)\n{\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\t// \"unlet s:var\" is allowed in legacy script.\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Callback passed to ex_unletlock().\n */\n    static int\ncompile_unlet(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep UNUSED,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    char_u\t*p = lvp->ll_name;\n    int\t\tcc = *name_end;\n    int\t\tret = OK;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    *name_end = NUL;\n    if (*p == '$')\n    {\n\t// :unlet $ENV_VAR\n\tret = generate_UNLET(cctx, ISN_UNLETENV, p + 1, eap->forceit);\n    }\n    else if (vim_strchr(p, '.') != NULL || vim_strchr(p, '[') != NULL)\n    {\n\tlhs_T\t    lhs;\n\n\t// This is similar to assigning: lookup the list/dict, compile the\n\t// idx/key.  Then instead of storing the value unlet the item.\n\t// unlet {list}[idx]\n\t// unlet {dict}[key]  dict.key\n\t//\n\t// Figure out the LHS type and other properties.\n\t//\n\tret = compile_lhs(p, &lhs, CMD_unlet, FALSE, FALSE, 0, cctx);\n\n\t// Use the info in \"lhs\" to unlet the item at the index in the\n\t// list or dict.\n\tif (ret == OK)\n\t{\n\t    if (!lhs.lhs_has_index)\n\t    {\n\t\tsemsg(_(e_cannot_unlet_imported_item_str), p);\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = compile_assign_unlet(p, &lhs, FALSE, &t_void, cctx);\n\t}\n\n\tvim_free(lhs.lhs_name);\n    }\n    else if (check_vim9_unlet(p) == FAIL)\n    {\n\tret = FAIL;\n    }\n    else\n    {\n\t// Normal name.  Only supports g:, w:, t: and b: namespaces.\n\tret = generate_UNLET(cctx, ISN_UNLET, p, eap->forceit);\n    }\n\n    *name_end = cc;\n    return ret;\n}\n\n/*\n * Callback passed to ex_unletlock().\n */\n    static int\ncompile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (*p == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), cmd);\n\treturn FAIL;\n    }\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\n\t    // For \"d.member\" put the local variable on the stack, it will be\n\t    // passed to ex_lockvar() indirectly.\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n\n    // Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}\n\n/*\n * compile \"unlet var\", \"lock var\" and \"unlock var\"\n * \"arg\" points to \"var\".\n */\n    char_u *\ncompile_unletlock(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    int\t    deep = 0;\n    char_u  *p = arg;\n\n    if (eap->cmdidx != CMD_unlet)\n    {\n\tif (eap->forceit)\n\t    deep = -1;\n\telse if (vim_isdigit(*p))\n\t{\n\t    deep = getdigits(&p);\n\t    p = skipwhite(p);\n\t}\n\telse\n\t    deep = 2;\n    }\n\n    ex_unletlock(eap, p, deep, GLV_NO_AUTOLOAD | GLV_COMPILING,\n\t    eap->cmdidx == CMD_unlet ? compile_unlet : compile_lock_unlock,\n\t    cctx);\n    return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n}\n\n/*\n * generate a jump to the \":endif\"/\":endfor\"/\":endwhile\"/\":finally\"/\":endtry\".\n */\n    static int\ncompile_jump_to_end(endlabel_T **el, jumpwhen_T when, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    endlabel_T  *endlabel = ALLOC_CLEAR_ONE(endlabel_T);\n\n    if (endlabel == NULL)\n\treturn FAIL;\n    endlabel->el_next = *el;\n    *el = endlabel;\n    endlabel->el_end_label = instr->ga_len;\n\n    generate_JUMP(cctx, when, 0);\n    return OK;\n}\n\n    static void\ncompile_fill_jump_to_end(endlabel_T **el, int jump_where, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    while (*el != NULL)\n    {\n\tendlabel_T  *cur = (*el);\n\tisn_T\t    *isn;\n\n\tisn = ((isn_T *)instr->ga_data) + cur->el_end_label;\n\tisn->isn_arg.jump.jump_where = jump_where;\n\t*el = cur->el_next;\n\tvim_free(cur);\n    }\n}\n\n    static void\ncompile_free_jump_to_end(endlabel_T **el)\n{\n    while (*el != NULL)\n    {\n\tendlabel_T  *cur = (*el);\n\n\t*el = cur->el_next;\n\tvim_free(cur);\n    }\n}\n\n/*\n * Create a new scope and set up the generic items.\n */\n    static scope_T *\nnew_scope(cctx_T *cctx, scopetype_T type)\n{\n    scope_T *scope = ALLOC_CLEAR_ONE(scope_T);\n\n    if (scope == NULL)\n\treturn NULL;\n    scope->se_outer = cctx->ctx_scope;\n    cctx->ctx_scope = scope;\n    scope->se_type = type;\n    scope->se_local_count = cctx->ctx_locals.ga_len;\n    return scope;\n}\n\n/*\n * Free the current scope and go back to the outer scope.\n */\n    void\ndrop_scope(cctx_T *cctx)\n{\n    scope_T *scope = cctx->ctx_scope;\n\n    if (scope == NULL)\n    {\n\tiemsg(\"calling drop_scope() without a scope\");\n\treturn;\n    }\n    cctx->ctx_scope = scope->se_outer;\n    switch (scope->se_type)\n    {\n\tcase IF_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_if.is_end_label); break;\n\tcase FOR_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_for.fs_end_label); break;\n\tcase WHILE_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_while.ws_end_label); break;\n\tcase TRY_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_try.ts_end_label); break;\n\tcase NO_SCOPE:\n\tcase BLOCK_SCOPE:\n\t    break;\n    }\n    vim_free(scope);\n}\n\n    static int\nmisplaced_cmdmod(cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    if (cctx->ctx_has_cmdmod\n\t    && ((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type\n\t\t\t\t\t\t\t\t == ISN_CMDMOD)\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * compile \"if expr\"\n *\n * \"if expr\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE end\n *\t... body ...\n * end:\n *\n * \"if expr | else\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE else\n *\t... body ...\n *\tJUMP_ALWAYS end\n * else:\n *\t... body ...\n * end:\n *\n * \"if expr1 | elseif expr2 | else\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE elseif\n *\t... body ...\n *\tJUMP_ALWAYS end\n * elseif:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE else\n *\t... body ...\n *\tJUMP_ALWAYS end\n * else:\n *\t... body ...\n * end:\n */\n    char_u *\ncompile_if(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tinstr_count = instr->ga_len;\n    scope_T\t*scope;\n    skip_T\tskip_save = cctx->ctx_skip;\n    ppconst_T\tppconst;\n\n    CLEAR_FIELD(ppconst);\n    if (compile_expr1(&p, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn NULL;\n    }\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip == SKIP_YES)\n\tclear_ppconst(&ppconst);\n    else if (instr->ga_len == instr_count && ppconst.pp_used == 1)\n    {\n\tint error = FALSE;\n\tint v;\n\n\t// The expression results in a constant.\n\tv = tv_get_bool_chk(&ppconst.pp_tv[0], &error);\n\tclear_ppconst(&ppconst);\n\tif (error)\n\t    return NULL;\n\tcctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;\n    }\n    else\n    {\n\t// Not a constant, generate instructions for the expression.\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n\tif (generate_ppconst(cctx, &ppconst) == FAIL)\n\t    return NULL;\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return NULL;\n    }\n\n    // CMDMOD_REV must come before the jump\n    generate_undo_cmdmods(cctx);\n\n    scope = new_scope(cctx, IF_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n    scope->se_skip_save = skip_save;\n    // \"is_had_return\" will be reset if any block does not end in :return\n    scope->se_u.se_if.is_had_return = TRUE;\n\n    if (cctx->ctx_skip == SKIP_UNKNOWN)\n    {\n\t// \"where\" is set when \":elseif\", \"else\" or \":endif\" is found\n\tscope->se_u.se_if.is_if_label = instr->ga_len;\n\tgenerate_JUMP(cctx, JUMP_IF_FALSE, 0);\n    }\n    else\n\tscope->se_u.se_if.is_if_label = -1;\n\n#ifdef FEAT_PROFILE\n    if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES\n\t\t\t\t\t\t      && skip_save != SKIP_YES)\n    {\n\t// generated a profile start, need to generate a profile end, since it\n\t// won't be done after returning\n\tcctx->ctx_skip = SKIP_NOT;\n\tgenerate_instr(cctx, ISN_PROF_END);\n\tcctx->ctx_skip = SKIP_YES;\n    }\n#endif\n\n    return p;\n}\n\n    char_u *\ncompile_elseif(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tinstr_count;\n    isn_T\t*isn;\n    scope_T\t*scope = cctx->ctx_scope;\n    ppconst_T\tppconst;\n    skip_T\tsave_skip = cctx->ctx_skip;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_elseif_without_if));\n\treturn NULL;\n    }\n    unwind_locals(cctx, scope->se_local_count);\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_if.is_had_return = FALSE;\n\n    if (cctx->ctx_skip == SKIP_NOT)\n    {\n\t// previous block was executed, this one and following will not\n\tcctx->ctx_skip = SKIP_YES;\n\tscope->se_u.se_if.is_seen_skip_not = TRUE;\n    }\n    if (scope->se_u.se_if.is_seen_skip_not)\n    {\n\t// A previous block was executed, skip over expression and bail out.\n\t// Do not count the \"elseif\" for profiling and cmdmod\n\tinstr->ga_len = current_instr_idx(cctx);\n\n\tskip_expr_cctx(&p, cctx);\n\treturn p;\n    }\n\n    if (cctx->ctx_skip == SKIP_UNKNOWN)\n    {\n\tint\t    moved_cmdmod = FALSE;\n\tint\t    saved_debug = FALSE;\n\tisn_T\t    debug_isn;\n\n\t// Move any CMDMOD instruction to after the jump\n\tif (((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type == ISN_CMDMOD)\n\t{\n\t    if (GA_GROW_FAILS(instr, 1))\n\t\treturn NULL;\n\t    ((isn_T *)instr->ga_data)[instr->ga_len] =\n\t\t\t\t  ((isn_T *)instr->ga_data)[instr->ga_len - 1];\n\t    --instr->ga_len;\n\t    moved_cmdmod = TRUE;\n\t}\n\n\t// Remove the already generated ISN_DEBUG, it is written below the\n\t// ISN_FOR instruction.\n\tif (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t\t.isn_type == ISN_DEBUG)\n\t{\n\t    --instr->ga_len;\n\t    debug_isn = ((isn_T *)instr->ga_data)[instr->ga_len];\n\t    saved_debug = TRUE;\n\t}\n\n\tif (compile_jump_to_end(&scope->se_u.se_if.is_end_label,\n\t\t\t\t\t\t    JUMP_ALWAYS, cctx) == FAIL)\n\t    return NULL;\n\t// previous \"if\" or \"elseif\" jumps here\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\n\tif (moved_cmdmod)\n\t    ++instr->ga_len;\n\n\tif (saved_debug)\n\t{\n\t    // move the debug instruction here\n\t    if (GA_GROW_FAILS(instr, 1))\n\t\treturn NULL;\n\t    ((isn_T *)instr->ga_data)[instr->ga_len] = debug_isn;\n\t    ++instr->ga_len;\n\t}\n    }\n\n    // compile \"expr\"; if we know it evaluates to FALSE skip the block\n    CLEAR_FIELD(ppconst);\n    if (cctx->ctx_skip == SKIP_YES)\n    {\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t    // the previous block was skipped, need to profile this line\n\t    generate_instr(cctx, ISN_PROF_START);\n#endif\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t    // the previous block was skipped, may want to debug this line\n\t    generate_instr_debug(cctx);\n    }\n\n    instr_count = instr->ga_len;\n    if (compile_expr1(&p, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn NULL;\n    }\n    cctx->ctx_skip = save_skip;\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tclear_ppconst(&ppconst);\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n    if (scope->se_skip_save == SKIP_YES)\n\tclear_ppconst(&ppconst);\n    else if (instr->ga_len == instr_count && ppconst.pp_used == 1)\n    {\n\tint error = FALSE;\n\tint v;\n\n\t// The expression result is a constant.\n\tv = tv_get_bool_chk(&ppconst.pp_tv[0], &error);\n\tif (error)\n\t{\n\t    clear_ppconst(&ppconst);\n\t    return NULL;\n\t}\n\tcctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;\n\tclear_ppconst(&ppconst);\n\tscope->se_u.se_if.is_if_label = -1;\n    }\n    else\n    {\n\t// Not a constant, generate instructions for the expression.\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n\tif (generate_ppconst(cctx, &ppconst) == FAIL)\n\t    return NULL;\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return NULL;\n\n\t// CMDMOD_REV must come before the jump\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"where\" is set when \":elseif\", \"else\" or \":endif\" is found\n\tscope->se_u.se_if.is_if_label = instr->ga_len;\n\tgenerate_JUMP(cctx, JUMP_IF_FALSE, 0);\n    }\n\n    return p;\n}\n\n    char_u *\ncompile_else(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n    scope_T\t*scope = cctx->ctx_scope;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_else_without_if));\n\treturn NULL;\n    }\n    unwind_locals(cctx, scope->se_local_count);\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_if.is_had_return = FALSE;\n    scope->se_u.se_if.is_seen_else = TRUE;\n\n#ifdef FEAT_PROFILE\n    if (cctx->ctx_compile_type == CT_PROFILE)\n    {\n\tif (cctx->ctx_skip == SKIP_NOT\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t    // the previous block was executed, do not count \"else\" for\n\t    // profiling\n\t    --instr->ga_len;\n\tif (cctx->ctx_skip == SKIP_YES && !scope->se_u.se_if.is_seen_skip_not)\n\t{\n\t    // the previous block was not executed, this one will, do count the\n\t    // \"else\" for profiling\n\t    cctx->ctx_skip = SKIP_NOT;\n\t    generate_instr(cctx, ISN_PROF_END);\n\t    generate_instr(cctx, ISN_PROF_START);\n\t    cctx->ctx_skip = SKIP_YES;\n\t}\n    }\n#endif\n\n    if (!scope->se_u.se_if.is_seen_skip_not && scope->se_skip_save != SKIP_YES)\n    {\n\t// jump from previous block to the end, unless the else block is empty\n\tif (cctx->ctx_skip == SKIP_UNKNOWN)\n\t{\n\t    if (!cctx->ctx_had_return\n\t\t    && compile_jump_to_end(&scope->se_u.se_if.is_end_label,\n\t\t\t\t\t\t    JUMP_ALWAYS, cctx) == FAIL)\n\t\treturn NULL;\n\t}\n\n\tif (cctx->ctx_skip == SKIP_UNKNOWN)\n\t{\n\t    if (scope->se_u.se_if.is_if_label >= 0)\n\t    {\n\t\t// previous \"if\" or \"elseif\" jumps here\n\t\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\t\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\t\tscope->se_u.se_if.is_if_label = -1;\n\t    }\n\t}\n\n\tif (cctx->ctx_skip != SKIP_UNKNOWN)\n\t    cctx->ctx_skip = cctx->ctx_skip == SKIP_YES ? SKIP_NOT : SKIP_YES;\n    }\n\n    return p;\n}\n\n    char_u *\ncompile_endif(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    ifscope_T\t*ifscope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_endif_without_if));\n\treturn NULL;\n    }\n    ifscope = &scope->se_u.se_if;\n    unwind_locals(cctx, scope->se_local_count);\n    if (!cctx->ctx_had_return)\n\tifscope->is_had_return = FALSE;\n\n    if (scope->se_u.se_if.is_if_label >= 0)\n    {\n\t// previous \"if\" or \"elseif\" jumps here\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\tisn->isn_arg.jump.jump_where = instr->ga_len;\n    }\n    // Fill in the \"end\" label in jumps at the end of the blocks.\n    compile_fill_jump_to_end(&ifscope->is_end_label, instr->ga_len, cctx);\n\n#ifdef FEAT_PROFILE\n    // even when skipping we count the endif as executed, unless the block it's\n    // in is skipped\n    if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES\n\t\t\t\t\t    && scope->se_skip_save != SKIP_YES)\n    {\n\tcctx->ctx_skip = SKIP_NOT;\n\tgenerate_instr(cctx, ISN_PROF_START);\n    }\n#endif\n    cctx->ctx_skip = scope->se_skip_save;\n\n    // If all the blocks end in :return and there is an :else then the\n    // had_return flag is set.\n    cctx->ctx_had_return = ifscope->is_had_return && ifscope->is_seen_else;\n\n    drop_scope(cctx);\n    return arg;\n}\n\n/*\n * Compile \"for var in expr\":\n *\n * Produces instructions:\n *       PUSHNR -1\n *       STORE loop-idx\t\tSet index to -1\n *       EVAL expr\t\tresult of \"expr\" on top of stack\n * top:  FOR loop-idx, end\tIncrement index, use list on bottom of stack\n *\t\t\t\t- if beyond end, jump to \"end\"\n *\t\t\t\t- otherwise get item from list and push it\n *       STORE var\t\tStore item in \"var\"\n *       ... body ...\n *       JUMP top\t\tJump back to repeat\n * end:\t DROP\t\t\tDrop the result of \"expr\"\n *\n * Compile \"for [var1, var2] in expr\" - as above, but instead of \"STORE var\":\n *\t UNPACK 2\t\tSplit item in 2\n *       STORE var1\t\tStore item in \"var1\"\n *       STORE var2\t\tStore item in \"var2\"\n */\n    char_u *\ncompile_for(char_u *arg_start, cctx_T *cctx)\n{\n    char_u\t*arg;\n    char_u\t*arg_end;\n    char_u\t*name = NULL;\n    char_u\t*p;\n    char_u\t*wp;\n    int\t\tvar_count = 0;\n    int\t\tvar_list = FALSE;\n    int\t\tsemicolon = FALSE;\n    size_t\tvarlen;\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*scope;\n    lvar_T\t*loop_lvar;\t// loop iteration variable\n    lvar_T\t*var_lvar;\t// variable for \"var\"\n    type_T\t*vartype;\n    type_T\t*item_type = &t_any;\n    int\t\tidx;\n    int\t\tprev_lnum = cctx->ctx_prev_lnum;\n\n    p = skip_var_list(arg_start, TRUE, &var_count, &semicolon, FALSE);\n    if (p == NULL)\n\treturn NULL;\n    if (var_count == 0)\n\tvar_count = 1;\n    else\n\tvar_list = TRUE;  // can also be a list of one variable\n\n    // consume \"in\"\n    wp = p;\n    if (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\treturn NULL;\n    if (STRNCMP(p, \"in\", 2) != 0 || !IS_WHITE_OR_NUL(p[2]))\n    {\n\tif (*p == ':' && wp != p)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), p);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn NULL;\n    }\n    wp = p + 2;\n    if (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\treturn NULL;\n\n    // Find the already generated ISN_DEBUG to get the line number for the\n    // instruction written below the ISN_FOR instruction.\n    if (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0\n\t    && ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t\t.isn_type == ISN_DEBUG)\n    {\n\tprev_lnum = ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t .isn_arg.debug.dbg_break_lnum;\n    }\n\n    scope = new_scope(cctx, FOR_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n\n    // Reserve a variable to store the loop iteration counter and initialize it\n    // to -1.\n    loop_lvar = reserve_local(cctx, (char_u *)\"\", 0, FALSE, &t_number);\n    if (loop_lvar == NULL)\n    {\n\t// out of memory\n\tdrop_scope(cctx);\n\treturn NULL;\n    }\n    generate_STORENR(cctx, loop_lvar->lv_idx, -1);\n\n    // compile \"expr\", it remains on the stack until \"endfor\"\n    arg = p;\n    if (compile_expr0(&arg, cctx) == FAIL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;\n    }\n    arg_end = arg;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// If we know the type of \"var\" and it is not a supported type we can\n\t// give an error now.\n\tvartype = get_type_on_stack(cctx, 0);\n\tif (vartype->tt_type != VAR_LIST\n\t\t&& vartype->tt_type != VAR_STRING\n\t\t&& vartype->tt_type != VAR_BLOB\n\t\t&& vartype->tt_type != VAR_ANY\n\t\t&& vartype->tt_type != VAR_UNKNOWN)\n\t{\n\t    semsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t       vartype_name(vartype->tt_type));\n\t    drop_scope(cctx);\n\t    return NULL;\n\t}\n\n\tif (vartype->tt_type == VAR_STRING)\n\t    item_type = &t_string;\n\telse if (vartype->tt_type == VAR_BLOB)\n\t    item_type = &t_number;\n\telse if (vartype->tt_type == VAR_LIST\n\t\t\t\t     && vartype->tt_member->tt_type != VAR_ANY)\n\t{\n\t    if (!var_list)\n\t\titem_type = vartype->tt_member;\n\t    else if (vartype->tt_member->tt_type == VAR_LIST\n\t\t\t  && vartype->tt_member->tt_member->tt_type != VAR_ANY)\n\t\titem_type = vartype->tt_member->tt_member;\n\t}\n\n\t// CMDMOD_REV must come before the FOR instruction.\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"for_end\" is set when \":endfor\" is found\n\tscope->se_u.se_for.fs_top_label = current_instr_idx(cctx);\n\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t{\n\t    int\t\tsave_prev_lnum = cctx->ctx_prev_lnum;\n\t    isn_T\t*isn;\n\n\t    // Add ISN_DEBUG here, before deciding to end the loop.  There will\n\t    // be another ISN_DEBUG before the next instruction.\n\t    // Use the prev_lnum from the ISN_DEBUG instruction removed above.\n\t    // Increment the variable count so that the loop variable can be\n\t    // inspected.\n\t    cctx->ctx_prev_lnum = prev_lnum;\n\t    isn = generate_instr_debug(cctx);\n\t    ++isn->isn_arg.debug.dbg_var_names_len;\n\t    cctx->ctx_prev_lnum = save_prev_lnum;\n\t}\n\n\tgenerate_FOR(cctx, loop_lvar->lv_idx);\n\n\targ = arg_start;\n\tif (var_list)\n\t{\n\t    generate_UNPACK(cctx, var_count, semicolon);\n\t    arg = skipwhite(arg + 1);\t// skip white after '['\n\n\t    // drop the list item\n\t    --cctx->ctx_type_stack.ga_len;\n\n\t    // add type of the items\n\t    for (idx = 0; idx < var_count; ++idx)\n\t    {\n\t\ttype_T *type = (semicolon && idx == 0) ? vartype : item_type;\n\n\t\tif (push_type_stack(cctx, type) == FAIL)\n\t\t{\n\t\t    drop_scope(cctx);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t}\n\n\tfor (idx = 0; idx < var_count; ++idx)\n\t{\n\t    assign_dest_T\tdest = dest_local;\n\t    int\t\t\topt_flags = 0;\n\t    int\t\t\tvimvaridx = -1;\n\t    type_T\t\t*type = &t_any;\n\t    type_T\t\t*lhs_type = &t_any;\n\t    where_T\t\twhere = WHERE_INIT;\n\n\t    p = skip_var_one(arg, FALSE);\n\t    varlen = p - arg;\n\t    name = vim_strnsave(arg, varlen);\n\t    if (name == NULL)\n\t\tgoto failed;\n\t    if (*p == ':')\n\t    {\n\t\tp = skipwhite(p + 1);\n\t\tlhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    }\n\n\t    if (get_var_dest(name, &dest, CMD_for, &opt_flags,\n\t\t\t\t\t      &vimvaridx, &type, cctx) == FAIL)\n\t\tgoto failed;\n\t    if (dest != dest_local)\n\t    {\n\t\tif (generate_store_var(cctx, dest, opt_flags, vimvaridx,\n\t\t\t\t\t\t     0, 0, type, name) == FAIL)\n\t\t    goto failed;\n\t    }\n\t    else if (varlen == 1 && *arg == '_')\n\t    {\n\t\t// Assigning to \"_\": drop the value.\n\t\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t\t    goto failed;\n\t    }\n\t    else\n\t    {\n\t\t// Script var is not supported.\n\t\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t\t{\n\t\t    emsg(_(e_cannot_use_script_variable_in_for_loop));\n\t\t    goto failed;\n\t\t}\n\n\t\tif (!valid_varname(arg, (int)varlen, FALSE))\n\t\t    goto failed;\n\t\tif (lookup_local(arg, varlen, NULL, cctx) == OK)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), arg);\n\t\t    goto failed;\n\t\t}\n\n\t\t// Reserve a variable to store \"var\".\n\t\twhere.wt_index = var_list ? idx + 1 : 0;\n\t\twhere.wt_variable = TRUE;\n\t\tif (lhs_type == &t_any)\n\t\t    lhs_type = item_type;\n\t\telse if (item_type != &t_unknown\n\t\t\t&& need_type_where(item_type, lhs_type, -1,\n\t\t\t\t\t    where, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto failed;\n\t\tvar_lvar = reserve_local(cctx, arg, varlen, TRUE, lhs_type);\n\t\tif (var_lvar == NULL)\n\t\t    // out of memory or used as an argument\n\t\t    goto failed;\n\n\t\tif (semicolon && idx == var_count - 1)\n\t\t    var_lvar->lv_type = vartype;\n\t\tgenerate_STORE(cctx, ISN_STORE, var_lvar->lv_idx, NULL);\n\t    }\n\n\t    if (*p == ',' || *p == ';')\n\t\t++p;\n\t    arg = skipwhite(p);\n\t    vim_free(name);\n\t}\n    }\n\n    return arg_end;\n\nfailed:\n    vim_free(name);\n    drop_scope(cctx);\n    return NULL;\n}\n\n/*\n * compile \"endfor\"\n */\n    char_u *\ncompile_endfor(char_u *arg, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*scope = cctx->ctx_scope;\n    forscope_T\t*forscope;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    if (scope == NULL || scope->se_type != FOR_SCOPE)\n    {\n\temsg(_(e_endfor_without_for));\n\treturn NULL;\n    }\n    forscope = &scope->se_u.se_for;\n    cctx->ctx_scope = scope->se_outer;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tunwind_locals(cctx, scope->se_local_count);\n\n\t// At end of \":for\" scope jump back to the FOR instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, forscope->fs_top_label);\n\n\t// Fill in the \"end\" label in the FOR statement so it can jump here.\n\t// In debug mode an ISN_DEBUG was inserted.\n\tisn = ((isn_T *)instr->ga_data) + forscope->fs_top_label\n\t\t\t\t+ (cctx->ctx_compile_type == CT_DEBUG ? 1 : 0);\n\tisn->isn_arg.forloop.for_end = instr->ga_len;\n\n\t// Fill in the \"end\" label any BREAK statements\n\tcompile_fill_jump_to_end(&forscope->fs_end_label, instr->ga_len, cctx);\n\n\t// Below the \":for\" scope drop the \"expr\" list from the stack.\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    return NULL;\n    }\n\n    vim_free(scope);\n\n    return arg;\n}\n\n/*\n * compile \"while expr\"\n *\n * Produces instructions:\n * top:  EVAL expr\t\tPush result of \"expr\"\n *       JUMP_IF_FALSE end\tjump if false\n *       ... body ...\n *       JUMP top\t\tJump back to repeat\n * end:\n *\n */\n    char_u *\ncompile_while(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    scope_T\t*scope;\n\n    scope = new_scope(cctx, WHILE_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n\n    // \"endwhile\" jumps back here, one before when profiling or using cmdmods\n    scope->se_u.se_while.ws_top_label = current_instr_idx(cctx);\n\n    // compile \"expr\"\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return FAIL;\n\n\t// CMDMOD_REV must come before the jump\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"while_end\" is set when \":endwhile\" is found\n\tif (compile_jump_to_end(&scope->se_u.se_while.ws_end_label,\n\t\t\t\t\t\t  JUMP_IF_FALSE, cctx) == FAIL)\n\t    return FAIL;\n    }\n\n    return p;\n}\n\n/*\n * compile \"endwhile\"\n */\n    char_u *\ncompile_endwhile(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n    if (scope == NULL || scope->se_type != WHILE_SCOPE)\n    {\n\temsg(_(e_endwhile_without_while));\n\treturn NULL;\n    }\n    cctx->ctx_scope = scope->se_outer;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tunwind_locals(cctx, scope->se_local_count);\n\n#ifdef FEAT_PROFILE\n\t// count the endwhile before jumping\n\tmay_generate_prof_end(cctx, cctx->ctx_lnum);\n#endif\n\n\t// At end of \":for\" scope jump back to the FOR instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, scope->se_u.se_while.ws_top_label);\n\n\t// Fill in the \"end\" label in the WHILE statement so it can jump here.\n\t// And in any jumps for \":break\"\n\tcompile_fill_jump_to_end(&scope->se_u.se_while.ws_end_label,\n\t\t\t\t\t\t\t  instr->ga_len, cctx);\n    }\n\n    vim_free(scope);\n\n    return arg;\n}\n\n/*\n * compile \"continue\"\n */\n    char_u *\ncompile_continue(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    int\t\ttry_scopes = 0;\n    int\t\tloop_label;\n\n    for (;;)\n    {\n\tif (scope == NULL)\n\t{\n\t    emsg(_(e_continue_without_while_or_for));\n\t    return NULL;\n\t}\n\tif (scope->se_type == FOR_SCOPE)\n\t{\n\t    loop_label = scope->se_u.se_for.fs_top_label;\n\t    break;\n\t}\n\tif (scope->se_type == WHILE_SCOPE)\n\t{\n\t    loop_label = scope->se_u.se_while.ws_top_label;\n\t    break;\n\t}\n\tif (scope->se_type == TRY_SCOPE)\n\t    ++try_scopes;\n\tscope = scope->se_outer;\n    }\n\n    if (try_scopes > 0)\n\t// Inside one or more try/catch blocks we first need to jump to the\n\t// \"finally\" or \"endtry\" to cleanup.\n\tgenerate_TRYCONT(cctx, try_scopes, loop_label);\n    else\n\t// Jump back to the FOR or WHILE instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, loop_label);\n\n    return arg;\n}\n\n/*\n * compile \"break\"\n */\n    char_u *\ncompile_break(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    int\t\ttry_scopes = 0;\n    endlabel_T\t**el;\n\n    for (;;)\n    {\n\tif (scope == NULL)\n\t{\n\t    emsg(_(e_break_without_while_or_for));\n\t    return NULL;\n\t}\n\tif (scope->se_type == FOR_SCOPE)\n\t{\n\t    el = &scope->se_u.se_for.fs_end_label;\n\t    break;\n\t}\n\tif (scope->se_type == WHILE_SCOPE)\n\t{\n\t    el = &scope->se_u.se_while.ws_end_label;\n\t    break;\n\t}\n\tif (scope->se_type == TRY_SCOPE)\n\t    ++try_scopes;\n\tscope = scope->se_outer;\n    }\n\n    if (try_scopes > 0)\n\t// Inside one or more try/catch blocks we first need to jump to the\n\t// \"finally\" or \"endtry\" to cleanup.  Then come to the next JUMP\n\t// intruction, which we don't know the index of yet.\n\tgenerate_TRYCONT(cctx, try_scopes, cctx->ctx_instr.ga_len + 1);\n\n    // Jump to the end of the FOR or WHILE loop.  The instruction index will be\n    // filled in later.\n    if (compile_jump_to_end(el, JUMP_ALWAYS, cctx) == FAIL)\n\treturn FAIL;\n\n    return arg;\n}\n\n/*\n * compile \"{\" start of block\n */\n    char_u *\ncompile_block(char_u *arg, cctx_T *cctx)\n{\n    if (new_scope(cctx, BLOCK_SCOPE) == NULL)\n\treturn NULL;\n    return skipwhite(arg + 1);\n}\n\n/*\n * compile end of block: drop one scope\n */\n    void\ncompile_endblock(cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n\n    cctx->ctx_scope = scope->se_outer;\n    unwind_locals(cctx, scope->se_local_count);\n    vim_free(scope);\n}\n\n/*\n * Compile \"try\".\n * Creates a new scope for the try-endtry, pointing to the first catch and\n * finally.\n * Creates another scope for the \"try\" block itself.\n * TRY instruction sets up exception handling at runtime.\n *\n *\t\"try\"\n *\t    TRY -> catch1, -> finally  push trystack entry\n *\t    ... try block\n *\t\"throw {exception}\"\n *\t    EVAL {exception}\n *\t    THROW\t\tcreate exception\n *\t    ... try block\n *\t\" catch {expr}\"\n *\t    JUMP -> finally\n * catch1:  PUSH exception\n *\t    EVAL {expr}\n *\t    MATCH\n *\t    JUMP nomatch -> catch2\n *\t    CATCH   remove exception\n *\t    ... catch block\n *\t\" catch\"\n *\t    JUMP -> finally\n * catch2:  CATCH   remove exception\n *\t    ... catch block\n *\t\" finally\"\n * finally:\n *\t    ... finally block\n *\t\" endtry\"\n *\t    ENDTRY  pop trystack entry, may rethrow\n */\n    char_u *\ncompile_try(char_u *arg, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*try_scope;\n    scope_T\t*scope;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // scope that holds the jumps that go to catch/finally/endtry\n    try_scope = new_scope(cctx, TRY_SCOPE);\n    if (try_scope == NULL)\n\treturn NULL;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tisn_T\t*isn;\n\n\t// \"try_catch\" is set when the first \":catch\" is found or when no catch\n\t// is found and \":finally\" is found.\n\t// \"try_finally\" is set when \":finally\" is found\n\t// \"try_endtry\" is set when \":endtry\" is found\n\ttry_scope->se_u.se_try.ts_try_label = instr->ga_len;\n\tif ((isn = generate_instr(cctx, ISN_TRY)) == NULL)\n\t    return NULL;\n\tisn->isn_arg.tryref.try_ref = ALLOC_CLEAR_ONE(tryref_T);\n\tif (isn->isn_arg.tryref.try_ref == NULL)\n\t    return NULL;\n    }\n\n    // scope for the try block itself\n    scope = new_scope(cctx, BLOCK_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n\n    return arg;\n}\n\n/*\n * Compile \"catch {expr}\".\n */\n    char_u *\ncompile_catch(char_u *arg, cctx_T *cctx UNUSED)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*p;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :try or :catch\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\temsg(_(e_catch_without_try));\n\treturn NULL;\n    }\n\n    if (scope->se_u.se_try.ts_caught_all)\n    {\n\temsg(_(e_catch_unreachable_after_catch_all));\n\treturn NULL;\n    }\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_try.ts_no_return = TRUE;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n#ifdef FEAT_PROFILE\n\t// the profile-start should be after the jump\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& instr->ga_len > 0\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t    --instr->ga_len;\n#endif\n\t// Jump from end of previous block to :finally or :endtry\n\tif (compile_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t    JUMP_ALWAYS, cctx) == FAIL)\n\t    return NULL;\n\n\t// End :try or :catch scope: set value in ISN_TRY instruction\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n\tif (isn->isn_arg.tryref.try_ref->try_catch == 0)\n\t    isn->isn_arg.tryref.try_ref->try_catch = instr->ga_len;\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Previous catch without match jumps here\n\t    isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t{\n\t    // a \"throw\" that jumps here needs to be counted\n\t    generate_instr(cctx, ISN_PROF_END);\n\t    // the \"catch\" is also counted\n\t    generate_instr(cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t    generate_instr_debug(cctx);\n    }\n\n    p = skipwhite(arg);\n    if (ends_excmd2(arg, p))\n    {\n\tscope->se_u.se_try.ts_caught_all = TRUE;\n\tscope->se_u.se_try.ts_catch_label = 0;\n    }\n    else\n    {\n\tchar_u *end;\n\tchar_u *pat;\n\tchar_u *tofree = NULL;\n\tint\tdropped = 0;\n\tint\tlen;\n\n\t// Push v:exception, push {expr} and MATCH\n\tgenerate_instr_type(cctx, ISN_PUSHEXC, &t_string);\n\n\tend = skip_regexp_ex(p + 1, *p, TRUE, &tofree, &dropped, NULL);\n\tif (*end != *p)\n\t{\n\t    semsg(_(e_separator_mismatch_str), p);\n\t    vim_free(tofree);\n\t    return NULL;\n\t}\n\tif (tofree == NULL)\n\t    len = (int)(end - (p + 1));\n\telse\n\t    len = (int)(end - tofree);\n\tpat = vim_strnsave(tofree == NULL ? p + 1 : tofree, len);\n\tvim_free(tofree);\n\tp += len + 2 + dropped;\n\tif (pat == NULL)\n\t    return NULL;\n\tif (generate_PUSHS(cctx, &pat) == FAIL)\n\t    return NULL;\n\n\tif (generate_COMPARE(cctx, EXPR_MATCH, FALSE) == FAIL)\n\t    return NULL;\n\n\tscope->se_u.se_try.ts_catch_label = instr->ga_len;\n\tif (generate_JUMP(cctx, JUMP_IF_FALSE, 0) == FAIL)\n\t    return NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_CATCH) == NULL)\n\treturn NULL;\n\n    if (new_scope(cctx, BLOCK_SCOPE) == NULL)\n\treturn NULL;\n    return p;\n}\n\n    char_u *\ncompile_finally(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n    int\t\tthis_instr;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :try or :catch\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\temsg(_(e_finally_without_try));\n\treturn NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// End :catch or :finally scope: set value in ISN_TRY instruction\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n\tif (isn->isn_arg.tryref.try_ref->try_finally != 0)\n\t{\n\t    emsg(_(e_multiple_finally));\n\t    return NULL;\n\t}\n\n\tthis_instr = instr->ga_len;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& ((isn_T *)instr->ga_data)[this_instr - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t{\n\t    // jump to the profile start of the \"finally\"\n\t    --this_instr;\n\n\t    // jump to the profile end above it\n\t    if (this_instr > 0 && ((isn_T *)instr->ga_data)[this_instr - 1]\n\t\t\t\t\t\t     .isn_type == ISN_PROF_END)\n\t\t--this_instr;\n\t}\n#endif\n\n\t// Fill in the \"end\" label in jumps at the end of the blocks.\n\tcompile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t\t     this_instr, cctx);\n\n\t// If there is no :catch then an exception jumps to :finally.\n\tif (isn->isn_arg.tryref.try_ref->try_catch == 0)\n\t    isn->isn_arg.tryref.try_ref->try_catch = this_instr;\n\tisn->isn_arg.tryref.try_ref->try_finally = this_instr;\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Previous catch without match jumps here\n\t    isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = this_instr;\n\t    scope->se_u.se_try.ts_catch_label = 0;\n\t}\n\tscope->se_u.se_try.ts_has_finally = TRUE;\n\tif (generate_instr(cctx, ISN_FINALLY) == NULL)\n\t    return NULL;\n    }\n\n    return arg;\n}\n\n    char_u *\ncompile_endtry(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*try_isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :catch or :finally\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\tif (scope == NULL)\n\t    emsg(_(e_endtry_without_try));\n\telse if (scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_endif));\n\treturn NULL;\n    }\n\n    try_isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tif (try_isn->isn_arg.tryref.try_ref->try_catch == 0\n\t\t\t  && try_isn->isn_arg.tryref.try_ref->try_finally == 0)\n\t{\n\t    emsg(_(e_missing_catch_or_finally));\n\t    return NULL;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t.isn_type == ISN_PROF_START)\n\t    // move the profile start after \"endtry\" so that it's not counted when\n\t    // the exception is rethrown.\n\t    --instr->ga_len;\n#endif\n\n\t// Fill in the \"end\" label in jumps at the end of the blocks, if not\n\t// done by \":finally\".\n\tcompile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t\t  instr->ga_len, cctx);\n\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Last catch without match jumps here\n\t    isn_T *isn = ((isn_T *)instr->ga_data)\n\t\t\t\t\t   + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n    }\n\n    // If there is a finally clause that ends in return then we will return.\n    // If one of the blocks didn't end in \"return\" or we did not catch all\n    // exceptions reset the had_return flag.\n    if (!(scope->se_u.se_try.ts_has_finally && cctx->ctx_had_return)\n\t    && (scope->se_u.se_try.ts_no_return\n\t\t|| !scope->se_u.se_try.ts_caught_all))\n\tcctx->ctx_had_return = FALSE;\n\n    compile_endblock(cctx);\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// End :catch or :finally scope: set instruction index in ISN_TRY\n\t// instruction\n\ttry_isn->isn_arg.tryref.try_ref->try_endtry = instr->ga_len;\n\tif (generate_instr(cctx, ISN_ENDTRY) == NULL)\n\t    return NULL;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t    generate_instr(cctx, ISN_PROF_START);\n#endif\n    }\n    return arg;\n}\n\n/*\n * compile \"throw {expr}\"\n */\n    char_u *\ncompile_throw(char_u *arg, cctx_T *cctx UNUSED)\n{\n    char_u *p = skipwhite(arg);\n\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn p;\n    if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\treturn NULL;\n    if (generate_instr_drop(cctx, ISN_THROW, 1) == NULL)\n\treturn NULL;\n\n    return p;\n}\n\n    char_u *\ncompile_eval(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    int\t\tname_only;\n    long\tlnum = SOURCING_LNUM;\n\n    // find_ex_command() will consider a variable name an expression, assuming\n    // that something follows on the next line.  Check that something actually\n    // follows, otherwise it's probably a misplaced command.\n    name_only = cmd_is_name_only(arg);\n\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    if (name_only && lnum == SOURCING_LNUM)\n    {\n\tsemsg(_(e_expression_without_effect_str), arg);\n\treturn NULL;\n    }\n\n    // drop the result\n    generate_instr_drop(cctx, ISN_DROP, 1);\n\n    return skipwhite(p);\n}\n\n/*\n * compile \"echo expr\"\n * compile \"echomsg expr\"\n * compile \"echoerr expr\"\n * compile \"echoconsole expr\"\n * compile \"execute expr\"\n */\n    char_u *\ncompile_mult_expr(char_u *arg, int cmdidx, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    char_u\t*prev = arg;\n    char_u\t*expr_start;\n    int\t\tcount = 0;\n    int\t\tstart_ctx_lnum = cctx->ctx_lnum;\n    type_T\t*type;\n\n    for (;;)\n    {\n\tif (ends_excmd2(prev, p))\n\t    break;\n\texpr_start = p;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // check for non-void type\n\t    type = get_type_on_stack(cctx, 0);\n\t    if (type->tt_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), expr_start);\n\t\treturn NULL;\n\t    }\n\t}\n\n\t++count;\n\tprev = p;\n\tp = skipwhite(p);\n    }\n\n    if (count > 0)\n    {\n\tlong save_lnum = cctx->ctx_lnum;\n\n\t// Use the line number where the command started.\n\tcctx->ctx_lnum = start_ctx_lnum;\n\n\tif (cmdidx == CMD_echo || cmdidx == CMD_echon)\n\t    generate_ECHO(cctx, cmdidx == CMD_echo, count);\n\telse if (cmdidx == CMD_execute)\n\t    generate_MULT_EXPR(cctx, ISN_EXECUTE, count);\n\telse if (cmdidx == CMD_echomsg)\n\t    generate_MULT_EXPR(cctx, ISN_ECHOMSG, count);\n\telse if (cmdidx == CMD_echoconsole)\n\t    generate_MULT_EXPR(cctx, ISN_ECHOCONSOLE, count);\n\telse\n\t    generate_MULT_EXPR(cctx, ISN_ECHOERR, count);\n\n\tcctx->ctx_lnum = save_lnum;\n    }\n    return p;\n}\n\n/*\n * If \"eap\" has a range that is not a constant generate an ISN_RANGE\n * instruction to compute it and return OK.\n * Otherwise return FAIL, the caller must deal with any range.\n */\n    static int\ncompile_variable_range(exarg_T *eap, cctx_T *cctx)\n{\n    char_u *range_end = skip_range(eap->cmd, TRUE, NULL);\n    char_u *p = skipdigits(eap->cmd);\n\n    if (p == range_end)\n\treturn FAIL;\n    return generate_RANGE(cctx, vim_strnsave(eap->cmd, range_end - eap->cmd));\n}\n\n/*\n * :put r\n * :put ={expr}\n */\n    char_u *\ncompile_put(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u\t*line = arg;\n    linenr_T\tlnum;\n    char\t*errormsg;\n    int\t\tabove = eap->forceit;\n\n    eap->regname = *line;\n\n    if (eap->regname == '=')\n    {\n\tchar_u *p = skipwhite(line + 1);\n\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tline = p;\n    }\n    else if (eap->regname != NUL)\n\t++line;\n\n    if (compile_variable_range(eap, cctx) == OK)\n    {\n\tlnum = above ? LNUM_VARIABLE_RANGE_ABOVE : LNUM_VARIABLE_RANGE;\n    }\n    else\n    {\n\t// Either no range or a number.\n\t// \"errormsg\" will not be set because the range is ADDR_LINES.\n\tif (parse_cmd_address(eap, &errormsg, FALSE) == FAIL)\n\t    // cannot happen\n\t    return NULL;\n\tif (eap->addr_count == 0)\n\t    lnum = -1;\n\telse\n\t    lnum = eap->line2;\n\tif (above)\n\t    --lnum;\n    }\n\n    generate_PUT(cctx, eap->regname, lnum);\n    return line;\n}\n\n/*\n * A command that is not compiled, execute with legacy code.\n */\n    char_u *\ncompile_exec(char_u *line_arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u\t*line = line_arg;\n    char_u\t*p;\n    int\t\thas_expr = FALSE;\n    char_u\t*nextcmd = (char_u *)\"\";\n    char_u\t*tofree = NULL;\n    char_u\t*cmd_arg = NULL;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\tgoto theend;\n\n    // If there was a prececing command modifier, drop it and include it in the\n    // EXEC command.\n    if (cctx->ctx_has_cmdmod)\n    {\n\tgarray_T\t*instr = &cctx->ctx_instr;\n\tisn_T\t\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\tif (isn->isn_type == ISN_CMDMOD)\n\t{\n\t    vim_regfree(isn->isn_arg.cmdmod.cf_cmdmod\n\t\t\t\t\t       ->cmod_filter_regmatch.regprog);\n\t    vim_free(isn->isn_arg.cmdmod.cf_cmdmod);\n\t    --instr->ga_len;\n\t    cctx->ctx_has_cmdmod = FALSE;\n\t}\n    }\n\n    if (eap->cmdidx >= 0 && eap->cmdidx < CMD_SIZE)\n    {\n\tlong\targt = eap->argt;\n\tint\tusefilter = FALSE;\n\n\thas_expr = argt & (EX_XFILE | EX_EXPAND);\n\n\t// If the command can be followed by a bar, find the bar and truncate\n\t// it, so that the following command can be compiled.\n\t// The '|' is overwritten with a NUL, it is put back below.\n\tif ((eap->cmdidx == CMD_write || eap->cmdidx == CMD_read)\n\t\t\t\t\t\t\t   && *eap->arg == '!')\n\t    // :w !filter or :r !filter or :r! filter\n\t    usefilter = TRUE;\n\tif ((argt & EX_TRLBAR) && !usefilter)\n\t{\n\t    eap->argt = argt;\n\t    separate_nextcmd(eap, TRUE);\n\t    if (eap->nextcmd != NULL)\n\t\tnextcmd = eap->nextcmd;\n\t}\n\telse if (eap->cmdidx == CMD_wincmd)\n\t{\n\t    p = eap->arg;\n\t    if (*p != NUL)\n\t\t++p;\n\t    if (*p == 'g' || *p == Ctrl_G)\n\t\t++p;\n\t    p = skipwhite(p);\n\t    if (*p == '|')\n\t    {\n\t\t*p = NUL;\n\t\tnextcmd = p + 1;\n\t    }\n\t}\n\telse if (eap->cmdidx == CMD_command || eap->cmdidx == CMD_autocmd)\n\t{\n\t    // If there is a trailing '{' read lines until the '}'\n\t    p = eap->arg + STRLEN(eap->arg) - 1;\n\t    while (p > eap->arg && VIM_ISWHITE(*p))\n\t\t--p;\n\t    if (*p == '{')\n\t    {\n\t\texarg_T ea;\n\t\tint\tflags = 0;  // unused\n\t\tint\tstart_lnum = SOURCING_LNUM;\n\n\t\tCLEAR_FIELD(ea);\n\t\tea.arg = eap->arg;\n\t\tfill_exarg_from_cctx(&ea, cctx);\n\t\t(void)may_get_cmd_block(&ea, p, &tofree, &flags);\n\t\tif (tofree != NULL)\n\t\t{\n\t\t    *p = NUL;\n\t\t    line = concat_str(line, tofree);\n\t\t    if (line == NULL)\n\t\t\tgoto theend;\n\t\t    vim_free(tofree);\n\t\t    tofree = line;\n\t\t    SOURCING_LNUM = start_lnum;\n\t\t}\n\t    }\n\t}\n    }\n\n    if (eap->cmdidx == CMD_syntax && STRNCMP(eap->arg, \"include \", 8) == 0)\n    {\n\t// expand filename in \"syntax include [@group] filename\"\n\thas_expr = TRUE;\n\teap->arg = skipwhite(eap->arg + 7);\n\tif (*eap->arg == '@')\n\t    eap->arg = skiptowhite(eap->arg);\n    }\n\n    if ((eap->cmdidx == CMD_global || eap->cmdidx == CMD_vglobal)\n\t\t\t\t\t\t       && STRLEN(eap->arg) > 4)\n    {\n\tint delim = *eap->arg;\n\n\tp = skip_regexp_ex(eap->arg + 1, delim, TRUE, NULL, NULL, NULL);\n\tif (*p == delim)\n\t    cmd_arg = p + 1;\n    }\n\n    if (eap->cmdidx == CMD_folddoopen || eap->cmdidx == CMD_folddoclosed)\n\tcmd_arg = eap->arg;\n\n    if (cmd_arg != NULL)\n    {\n\texarg_T nea;\n\n\tCLEAR_FIELD(nea);\n\tnea.cmd = cmd_arg;\n\tp = find_ex_command(&nea, NULL, lookup_scriptitem, NULL);\n\tif (nea.cmdidx < CMD_SIZE)\n\t{\n\t    has_expr = excmd_get_argt(nea.cmdidx) & (EX_XFILE | EX_EXPAND);\n\t    if (has_expr)\n\t\teap->arg = skiptowhite(eap->arg);\n\t}\n    }\n\n    if (has_expr && (p = (char_u *)strstr((char *)eap->arg, \"`=\")) != NULL)\n    {\n\tint\tcount = 0;\n\tchar_u\t*start = skipwhite(line);\n\n\t// :cmd xxx`=expr1`yyy`=expr2`zzz\n\t// PUSHS \":cmd xxx\"\n\t// eval expr1\n\t// PUSHS \"yyy\"\n\t// eval expr2\n\t// PUSHS \"zzz\"\n\t// EXECCONCAT 5\n\tfor (;;)\n\t{\n\t    if (p > start)\n\t    {\n\t\tchar_u *val = vim_strnsave(start, p - start);\n\n\t\tgenerate_PUSHS(cctx, &val);\n\t\t++count;\n\t    }\n\t    p += 2;\n\t    if (compile_expr0(&p, cctx) == FAIL)\n\t\treturn NULL;\n\t    may_generate_2STRING(-1, TRUE, cctx);\n\t    ++count;\n\t    p = skipwhite(p);\n\t    if (*p != '`')\n\t    {\n\t\temsg(_(e_missing_backtick));\n\t\treturn NULL;\n\t    }\n\t    start = p + 1;\n\n\t    p = (char_u *)strstr((char *)start, \"`=\");\n\t    if (p == NULL)\n\t    {\n\t\tif (*skipwhite(start) != NUL)\n\t\t{\n\t\t    char_u *val = vim_strsave(start);\n\n\t\t    generate_PUSHS(cctx, &val);\n\t\t    ++count;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tgenerate_EXECCONCAT(cctx, count);\n    }\n    else\n\tgenerate_EXEC_copy(cctx, ISN_EXEC, line);\n\ntheend:\n    if (*nextcmd != NUL)\n    {\n\t// the parser expects a pointer to the bar, put it back\n\t--nextcmd;\n\t*nextcmd = '|';\n    }\n    vim_free(tofree);\n\n    return nextcmd;\n}\n\n/*\n * A script command with heredoc, e.g.\n *\truby << EOF\n *\t   command\n *\tEOF\n * Has been turned into one long line with NL characters by\n * get_function_body():\n *\truby << EOF<NL>   command<NL>EOF\n */\n    char_u *\ncompile_script(char_u *line, cctx_T *cctx)\n{\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tisn_T\t*isn;\n\n\tif ((isn = generate_instr(cctx, ISN_EXEC_SPLIT)) == NULL)\n\t    return NULL;\n\tisn->isn_arg.string = vim_strsave(line);\n    }\n    return (char_u *)\"\";\n}\n\n\n/*\n * :s/pat/repl/\n */\n    char_u *\ncompile_substitute(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *cmd = eap->arg;\n    char_u  *expr = (char_u *)strstr((char *)cmd, \"\\\\=\");\n\n    if (expr != NULL)\n    {\n\tint delimiter = *cmd++;\n\n\t// There is a \\=expr, find it in the substitute part.\n\tcmd = skip_regexp_ex(cmd, delimiter, magic_isset(), NULL, NULL, NULL);\n\tif (cmd[0] == delimiter && cmd[1] == '\\\\' && cmd[2] == '=')\n\t{\n\t    garray_T\tsave_ga = cctx->ctx_instr;\n\t    char_u\t*end;\n\t    int\t\texpr_res;\n\t    int\t\ttrailing_error;\n\t    int\t\tinstr_count;\n\t    isn_T\t*instr;\n\t    isn_T\t*isn;\n\n\t    cmd += 3;\n\t    end = skip_substitute(cmd, delimiter);\n\n\t    // Temporarily reset the list of instructions so that the jump\n\t    // labels are correct.\n\t    cctx->ctx_instr.ga_len = 0;\n\t    cctx->ctx_instr.ga_maxlen = 0;\n\t    cctx->ctx_instr.ga_data = NULL;\n\t    expr_res = compile_expr0(&cmd, cctx);\n\t    if (end[-1] == NUL)\n\t\tend[-1] = delimiter;\n\t    cmd = skipwhite(cmd);\n\t    trailing_error = *cmd != delimiter && *cmd != NUL;\n\n\t    if (expr_res == FAIL || trailing_error\n\t\t\t\t       || GA_GROW_FAILS(&cctx->ctx_instr, 1))\n\t    {\n\t\tif (trailing_error)\n\t\t    semsg(_(e_trailing_characters_str), cmd);\n\t\tclear_instr_ga(&cctx->ctx_instr);\n\t\tcctx->ctx_instr = save_ga;\n\t\treturn NULL;\n\t    }\n\n\t    // Move the generated instructions into the ISN_SUBSTITUTE\n\t    // instructions, then restore the list of instructions before\n\t    // adding the ISN_SUBSTITUTE instruction.\n\t    instr_count = cctx->ctx_instr.ga_len;\n\t    instr = cctx->ctx_instr.ga_data;\n\t    instr[instr_count].isn_type = ISN_FINISH;\n\n\t    cctx->ctx_instr = save_ga;\n\t    if ((isn = generate_instr(cctx, ISN_SUBSTITUTE)) == NULL)\n\t    {\n\t\tint idx;\n\n\t\tfor (idx = 0; idx < instr_count; ++idx)\n\t\t    delete_instr(instr + idx);\n\t\tvim_free(instr);\n\t\treturn NULL;\n\t    }\n\t    isn->isn_arg.subs.subs_cmd = vim_strsave(arg);\n\t    isn->isn_arg.subs.subs_instr = instr;\n\n\t    // skip over flags\n\t    if (*end == '&')\n\t\t++end;\n\t    while (ASCII_ISALPHA(*end) || *end == '#')\n\t\t++end;\n\t    return end;\n\t}\n    }\n\n    return compile_exec(arg, eap, cctx);\n}\n\n    char_u *\ncompile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *arg = eap->arg;\n    lhs_T   *lhs = &cctx->ctx_redir_lhs;\n\n    if (lhs->lhs_name != NULL)\n    {\n\tif (STRNCMP(arg, \"END\", 3) == 0)\n\t{\n\t    if (lhs->lhs_append)\n\t    {\n\t\t// First load the current variable value.\n\t\tif (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    // Gets the redirected text and put it on the stack, then store it\n\t    // in the variable.\n\t    generate_instr_type(cctx, ISN_REDIREND, &t_string);\n\n\t    if (lhs->lhs_append)\n\t\tgenerate_CONCAT(cctx, 2);\n\n\t    if (lhs->lhs_has_index)\n\t    {\n\t\t// Use the info in \"lhs\" to store the value at the index in the\n\t\t// list or dict.\n\t\tif (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n\t\t    return NULL;\n\t    }\n\t    else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n\t\treturn NULL;\n\n\t    VIM_CLEAR(lhs->lhs_name);\n\t    VIM_CLEAR(lhs->lhs_whole);\n\t    return arg + 3;\n\t}\n\temsg(_(e_cannot_nest_redir));\n\treturn NULL;\n    }\n\n    if (arg[0] == '=' && arg[1] == '>')\n    {\n\tint\t    append = FALSE;\n\n\t// redirect to a variable is compiled\n\targ += 2;\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    append = TRUE;\n\t}\n\targ = skipwhite(arg);\n\n\tif (compile_assign_lhs(arg, lhs, CMD_redir,\n\t\t\t\t\t FALSE, FALSE, FALSE, 1, cctx) == FAIL)\n\t    return NULL;\n\tif (need_type(&t_string, lhs->lhs_member_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return NULL;\n\tgenerate_instr(cctx, ISN_REDIRSTART);\n\tlhs->lhs_append = append;\n\tif (lhs->lhs_has_index)\n\t{\n\t    lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n\t    if (lhs->lhs_whole == NULL)\n\t\treturn NULL;\n\t}\n\n\treturn arg + lhs->lhs_varlen_total;\n    }\n\n    // other redirects are handled like at script level\n    return compile_exec(line, eap, cctx);\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    char_u *\ncompile_cexpr(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    isn_T\t*isn;\n    char_u\t*p;\n\n    isn = generate_instr(cctx, ISN_CEXPR_AUCMD);\n    if (isn == NULL)\n\treturn NULL;\n    isn->isn_arg.number = eap->cmdidx;\n\n    p = eap->arg;\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    isn = generate_instr(cctx, ISN_CEXPR_CORE);\n    if (isn == NULL)\n\treturn NULL;\n    isn->isn_arg.cexpr.cexpr_ref = ALLOC_ONE(cexprref_T);\n    if (isn->isn_arg.cexpr.cexpr_ref == NULL)\n\treturn NULL;\n    isn->isn_arg.cexpr.cexpr_ref->cer_cmdidx = eap->cmdidx;\n    isn->isn_arg.cexpr.cexpr_ref->cer_forceit = eap->forceit;\n    isn->isn_arg.cexpr.cexpr_ref->cer_cmdline = vim_strsave(skipwhite(line));\n\n    return p;\n}\n#endif\n\n/*\n * Compile \"return [expr]\".\n * When \"legacy\" is TRUE evaluate [expr] with legacy syntax\n */\n    char_u *\ncompile_return(char_u *arg, int check_return_type, int legacy, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    type_T\t*stack_type;\n\n    if (*p != NUL && *p != '|' && *p != '\\n')\n    {\n\t// For a lambda, \"return expr\" is always used, also when \"expr\" results\n\t// in a void.\n\tif (cctx->ctx_ufunc->uf_ret_type->tt_type == VAR_VOID\n\t\t&& (cctx->ctx_ufunc->uf_flags & FC_LAMBDA) == 0)\n\t{\n\t    emsg(_(e_returning_value_in_function_without_return_type));\n\t    return NULL;\n\t}\n\tif (legacy)\n\t{\n\t    int save_flags = cmdmod.cmod_flags;\n\n\t    generate_LEGACY_EVAL(cctx, p);\n\t    if (need_type(&t_any, cctx->ctx_ufunc->uf_ret_type, -1,\n\t\t\t\t\t\t0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn NULL;\n\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t    (void)skip_expr(&p, NULL);\n\t    cmdmod.cmod_flags = save_flags;\n\t}\n\telse\n\t{\n\t    // compile return argument into instructions\n\t    if (compile_expr0(&p, cctx) == FAIL)\n\t\treturn NULL;\n\t}\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // \"check_return_type\" with uf_ret_type set to &t_unknown is used\n\t    // for an inline function without a specified return type.  Set the\n\t    // return type here.\n\t    stack_type = get_type_on_stack(cctx, 0);\n\t    if ((check_return_type && (cctx->ctx_ufunc->uf_ret_type == NULL\n\t\t\t\t|| cctx->ctx_ufunc->uf_ret_type == &t_unknown))\n\t\t    || (!check_return_type\n\t\t\t\t&& cctx->ctx_ufunc->uf_ret_type == &t_unknown))\n\t    {\n\t\tcctx->ctx_ufunc->uf_ret_type = stack_type;\n\t    }\n\t    else\n\t    {\n\t\tif (need_type(stack_type, cctx->ctx_ufunc->uf_ret_type, -1,\n\t\t\t\t\t\t0, cctx, FALSE, FALSE) == FAIL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\t// \"check_return_type\" cannot be TRUE, only used for a lambda which\n\t// always has an argument.\n\tif (cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_VOID\n\t\t&& cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_UNKNOWN)\n\t{\n\t    emsg(_(e_missing_return_value));\n\t    return NULL;\n\t}\n\n\t// No argument, return zero.\n\tgenerate_PUSHNR(cctx, 0);\n    }\n\n    // Undo any command modifiers.\n    generate_undo_cmdmods(cctx);\n\n    if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_RETURN) == NULL)\n\treturn NULL;\n\n    // \"return val | endif\" is possible\n    return skipwhite(p);\n}\n\n/*\n * Check if the separator for a :global or :substitute command is OK.\n */\n    int\ncheck_global_and_subst(char_u *cmd, char_u *arg)\n{\n    if (arg == cmd + 1 && vim_strchr((char_u *)\":-.\", *arg) != NULL)\n    {\n\tsemsg(_(e_separator_not_supported_str), arg);\n\treturn FAIL;\n    }\n    if (VIM_ISWHITE(cmd[1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_separator_str), cmd);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n\n#endif  // defined(FEAT_EVAL)\n"], "fixing_code": ["\" Test commands that are not compiled in a :def function\n\nsource check.vim\nimport './vim9.vim' as v9\nsource term_util.vim\nsource view_util.vim\n\ndef Test_vim9cmd()\n  var lines =<< trim END\n    vim9cmd var x = 123\n    let s:y = 'yes'\n    vim9c assert_equal(123, x)\n    vim9cm assert_equal('yes', y)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  assert_fails('vim9cmd', 'E1164:')\n  assert_fails('legacy', 'E1234:')\n  assert_fails('vim9cmd echo \"con\" . \"cat\"', 'E15:')\n\n  lines =<< trim END\n      let str = 'con'\n      vim9cmd str .= 'cat'\n  END\n  v9.CheckScriptFailure(lines, 'E492:')\n\n  lines =<< trim END\n      vim9script\n      legacy echo \"con\" . \"cat\"\n      legacy let str = 'con'\n      legacy let str .= 'cat'\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo()\n        g:found_bar = \"bar\"\n      enddef\n      nmap ,; :vim9cmd <SID>Foo()<CR>\n  END\n  v9.CheckScriptSuccess(lines)\n\n  feedkeys(',;', 'xt')\n  assert_equal(\"bar\", g:found_bar)\n  nunmap ,;\n  unlet g:found_bar\n\n  lines =<< trim END\n      vim9script\n      legacy echo 1'000\n  END\n  v9.CheckScriptFailure(lines, 'E115:')\n\n  if has('float')\n    lines =<< trim END\n        vim9script\n        echo .10\n    END\n    v9.CheckScriptSuccess(lines)\n    lines =<< trim END\n        vim9cmd echo .10\n    END\n    v9.CheckScriptSuccess(lines)\n    lines =<< trim END\n        vim9script\n        legacy echo .10\n    END\n    v9.CheckScriptFailure(lines, 'E15:')\n  endif\n\n  echo v:version\n  assert_fails('vim9cmd echo version', 'E121:')\n  lines =<< trim END\n      vim9script\n      echo version\n  END\n  v9.CheckScriptFailure(lines, 'E121:')\n  lines =<< trim END\n      vim9script\n      legacy echo version\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_defcompile_fails()\n  assert_fails('defcompile NotExists', 'E1061:')\n  assert_fails('defcompile debug debug Test_defcompile_fails', 'E488:')\n  assert_fails('defcompile profile profile Test_defcompile_fails', 'E488:')\nenddef\n\ndefcompile Test_defcompile_fails\ndefcompile debug Test_defcompile_fails\ndefcompile profile Test_defcompile_fails\n\ndef Test_cmdmod_execute()\n  # \"legacy\" applies not only to the \"exe\" argument but also to the commands\n  var lines =<< trim END\n      vim9script\n\n      b:undo = 'let g:undone = 1 | let g:undtwo = 2'\n      legacy exe b:undo\n      assert_equal(1, g:undone)\n      assert_equal(2, g:undtwo)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # same for \"vim9cmd\" modifier\n  lines =<< trim END\n      let b:undo = 'g:undone = 11 | g:undtwo = 22'\n      vim9cmd exe b:undo\n      call assert_equal(11, g:undone)\n      call assert_equal(22, g:undtwo)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet b:undo\n  unlet g:undone\n  unlet g:undtwo\n\n  # \"legacy\" does not apply to a loaded script\n  lines =<< trim END\n      vim9script\n      export var exported = 'x'\n  END\n  writefile(lines, 'Xvim9import.vim')\n  lines =<< trim END\n      legacy exe \"import './Xvim9import.vim'\"\n  END\n  v9.CheckScriptSuccess(lines)\n  delete('Xvim9import.vim')\n\n  # \"legacy\" does not aply to a called function\n  lines =<< trim END\n      vim9script\n\n      def g:TheFunc()\n        if exists('something')\n          echo 'yes'\n        endif\n      enddef\n      legacy exe 'call g:TheFunc()'\n  END\n  v9.CheckScriptSuccess(lines)\n  delfunc g:TheFunc\n\n  # vim9cmd execute(cmd) executes code in vim9 script context\n  lines =<< trim END\n    vim9cmd execute(\"g:vim9executetest = 'bar'\")\n    call assert_equal('bar', g:vim9executetest)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:vim9executetest\n\n  lines =<< trim END\n    vim9cmd execute([\"g:vim9executetest1 = 'baz'\", \"g:vim9executetest2 = 'foo'\"])\n    call assert_equal('baz', g:vim9executetest1)\n    call assert_equal('foo', g:vim9executetest2)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:vim9executetest1\n  unlet g:vim9executetest2\n\n  # legacy call execute(cmd) executes code in vim script context\n  lines =<< trim END\n    vim9script\n    legacy call execute(\"let g:vim9executetest = 'bar'\")\n    assert_equal('bar', g:vim9executetest)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:vim9executetest\n\n  lines =<< trim END\n    vim9script\n    legacy call execute([\"let g:vim9executetest1 = 'baz'\", \"let g:vim9executetest2 = 'foo'\"])\n    assert_equal('baz', g:vim9executetest1)\n    assert_equal('foo', g:vim9executetest2)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:vim9executetest1\n  unlet g:vim9executetest2\nenddef\n\ndef Test_edit_wildcards()\n  var filename = 'Xtest'\n  edit `=filename`\n  assert_equal('Xtest', bufname())\n\n  var filenr = 123\n  edit Xtest`=filenr`\n  assert_equal('Xtest123', bufname())\n\n  filenr = 77\n  edit `=filename``=filenr`\n  assert_equal('Xtest77', bufname())\n\n  edit X`=filename`xx`=filenr`yy\n  assert_equal('XXtestxx77yy', bufname())\n\n  v9.CheckDefFailure(['edit `=xxx`'], 'E1001:')\n  v9.CheckDefFailure(['edit `=\"foo\"'], 'E1083:')\n\n  var files = ['file 1', 'file%2', 'file# 3']\n  args `=files`\n  assert_equal(files, argv())\n\n  filename = 'Xwindo'\n  windo edit `=filename`\n  assert_equal('Xwindo', bufname())\n\n  filename = 'Xtabdo'\n  tabdo edit `=filename`\n  assert_equal('Xtabdo', bufname())\n\n  filename = 'Xargdo'\n  argdo edit `=filename`\n  assert_equal('Xargdo', bufname())\n\n  :%bwipe!\n  filename = 'Xbufdo'\n  bufdo file `=filename`\n  assert_equal('Xbufdo', bufname())\nenddef\n\ndef Test_expand_alternate_file()\n  var lines =<< trim END\n    edit Xfileone\n    var bone = bufnr()\n    edit Xfiletwo\n    var btwo = bufnr()\n    edit Xfilethree\n    var bthree = bufnr()\n\n    edit #\n    assert_equal(bthree, bufnr())\n    edit %%\n    assert_equal(btwo, bufnr())\n    edit %% # comment\n    assert_equal(bthree, bufnr())\n    edit %%yy\n    assert_equal('Xfiletwoyy', bufname())\n\n    exe \"edit %%\" .. bone\n    assert_equal(bone, bufnr())\n    exe \"edit %%\" .. btwo .. \"xx\"\n    assert_equal('Xfiletwoxx', bufname())\n\n    next Xfileone Xfiletwo Xfilethree\n    assert_equal('Xfileone', argv(0))\n    assert_equal('Xfiletwo', argv(1))\n    assert_equal('Xfilethree', argv(2))\n    next %%%zz\n    assert_equal('Xfileone', argv(0))\n    assert_equal('Xfiletwo', argv(1))\n    assert_equal('Xfilethreezz', argv(2))\n\n    v:oldfiles = ['Xonefile', 'Xtwofile']\n    edit %%<1\n    assert_equal('Xonefile', bufname())\n    edit %%<2\n    assert_equal('Xtwofile', bufname())\n    assert_fails('edit %%<3', 'E684:')\n\n    edit Xfileone.vim\n    edit Xfiletwo\n    edit %%:r\n    assert_equal('Xfileone', bufname())\n\n    assert_false(bufexists('altfoo'))\n    edit altfoo\n    edit bar\n    assert_true(bufexists('altfoo'))\n    assert_true(buflisted('altfoo'))\n    bdel %%\n    assert_true(bufexists('altfoo'))\n    assert_false(buflisted('altfoo'))\n    bwipe! altfoo\n    bwipe! bar\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_global_backtick_expansion()\n  var name = 'xxx'\n  new\n  setline(1, ['one', 'two', 'three'])\n  set nomod\n  g/two/edit `=name`\n  assert_equal('xxx', bufname())\n  bwipe!\n\n  new\n  setline(1, ['one', 'two', 'three'])\n  g/two/s/^/`=name`/\n  assert_equal('`=name`two', getline(2))\n  bwipe!\nenddef\n\ndef Test_folddo_backtick_expansion()\n  new\n  var name = 'xxx'\n  folddoopen edit `=name`\n  assert_equal('xxx', bufname())\n  bwipe!\n\n  new\n  setline(1, ['one', 'two'])\n  set nomodified\n  :1,2fold\n  foldclose\n  folddoclose edit `=name`\n  assert_equal('xxx', bufname())\n  bwipe!\n\n  var lines =<< trim END\n      g:val = 'value'\n      def Test()\n        folddoopen echo `=g:val`\n      enddef\n      call Test()\n  END\n  v9.CheckScriptFailure(lines, 'E15: Invalid expression: \"`=g:val`\"')\nenddef\n\ndef Test_hardcopy_wildcards()\n  CheckUnix\n  CheckFeature postscript\n\n  var outfile = 'print'\n  hardcopy > X`=outfile`.ps\n  assert_true(filereadable('Xprint.ps'))\n\n  delete('Xprint.ps')\nenddef\n\ndef Test_syn_include_wildcards()\n  writefile(['syn keyword Found found'], 'Xthemine.vim')\n  var save_rtp = &rtp\n  &rtp = '.'\n\n  var fname = 'mine'\n  syn include @Group Xthe`=fname`.vim\n  assert_match('Found.* contained found', execute('syn list Found'))\n\n  &rtp = save_rtp\n  delete('Xthemine.vim')\nenddef\n\ndef Test_echo_linebreak()\n  var lines =<< trim END\n      vim9script\n      redir @a\n      echo 'one'\n            .. 'two'\n      redir END\n      assert_equal(\"\\nonetwo\", @a)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      redir @a\n      echo 11 +\n            77\n            - 22\n      redir END\n      assert_equal(\"\\n66\", @a)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_condition_types()\n  var lines =<< trim END\n      if 'text'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1135:', 1)\n\n  lines =<< trim END\n      if [1]\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E1012:', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E745:', 2)\n\n  lines =<< trim END\n      g:cond = 'text'\n      if g:cond\n      endif\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1135:', 2)\n\n  lines =<< trim END\n      g:cond = 0\n      if g:cond\n      elseif 'text'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1135:', 3)\n\n  lines =<< trim END\n      g:cond = 0\n      if g:cond\n      elseif 'text' garbage\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E488:', 3)\n\n  lines =<< trim END\n      g:cond = 0\n      if g:cond\n      elseif [1]\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E1012:', 3)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E745:', 4)\n\n  lines =<< trim END\n      g:cond = 'text'\n      if 0\n      elseif g:cond\n      endif\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1135:', 3)\n\n  lines =<< trim END\n      while 'text'\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E1012:', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E1135:', 2)\n\n  lines =<< trim END\n      while [1]\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E1012:', 1)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E745:', 2)\n\n  lines =<< trim END\n      g:cond = 'text'\n      while g:cond\n      endwhile\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1135:', 2)\nenddef\n\ndef Test_if_linebreak()\n  var lines =<< trim END\n      vim9script\n      if 1 &&\n            true\n            || 1\n        g:res = 42\n      endif\n      assert_equal(42, g:res)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:res\n\n  lines =<< trim END\n      vim9script\n      if 1 &&\n            0\n        g:res = 0\n      elseif 0 ||\n              0\n              || 1\n        g:res = 12\n      endif\n      assert_equal(12, g:res)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:res\nenddef\n\ndef Test_while_linebreak()\n  var lines =<< trim END\n      vim9script\n      var nr = 0\n      while nr <\n              10 + 3\n            nr = nr\n                  + 4\n      endwhile\n      assert_equal(16, nr)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      var nr = 0\n      while nr\n            <\n              10\n              +\n              3\n            nr = nr\n                  +\n                  4\n      endwhile\n      assert_equal(16, nr)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_for_linebreak()\n  var lines =<< trim END\n      vim9script\n      var nr = 0\n      for x\n            in\n              [1, 2, 3, 4]\n          nr = nr + x\n      endfor\n      assert_equal(10, nr)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      var nr = 0\n      for x\n            in\n              [1, 2,\n                  3, 4\n                  ]\n          nr = nr\n                 +\n                  x\n      endfor\n      assert_equal(10, nr)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef s:MethodAfterLinebreak(arg: string)\n  arg\n    ->setline(1)\nenddef\n\ndef Test_method_call_linebreak()\n  var lines =<< trim END\n      vim9script\n      var res = []\n      func RetArg(\n            arg\n            )\n            let s:res = a:arg\n      endfunc\n      [1,\n          2,\n          3]->RetArg()\n      assert_equal([1, 2, 3], res)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      new\n      var name = [1, 2]\n      name\n          ->copy()\n          ->setline(1)\n      assert_equal(['1', '2'], getline(1, 2))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      new\n      def Foo(): string\n        return 'the text'\n      enddef\n      def Bar(F: func): string\n        return F()\n      enddef\n      def Test()\n        Foo  ->Bar()\n             ->setline(1)\n      enddef\n      Test()\n      assert_equal('the text', getline(1))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      new\n      g:shortlist\n          ->copy()\n          ->setline(1)\n      assert_equal(['1', '2'], getline(1, 2))\n      bwipe!\n  END\n  g:shortlist = [1, 2]\n  v9.CheckDefAndScriptSuccess(lines)\n  unlet g:shortlist\n\n  new\n  MethodAfterLinebreak('foobar')\n  assert_equal('foobar', getline(1))\n  bwipe!\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n          return '# some text'\n      enddef\n\n      def Bar(F: func): string\n          return F()\n      enddef\n\n      Foo->Bar()\n         ->setline(1)\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('# some text', getline(1))\n  bwipe!\nenddef\n\ndef Test_method_call_whitespace()\n  var lines =<< trim END\n    new\n    var yank = 'text'\n    yank->setline(1)\n    yank  ->setline(2)\n    yank->  setline(3)\n    yank  ->  setline(4)\n    assert_equal(['text', 'text', 'text', 'text'], getline(1, 4))\n    bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_method_and_user_command()\n  var lines =<< trim END\n      vim9script\n      def Cmd()\n        g:didFunc = 1\n      enddef\n      command Cmd g:didCmd = 1\n      Cmd\n      assert_equal(1, g:didCmd)\n      Cmd()\n      assert_equal(1, g:didFunc)\n      unlet g:didFunc\n      unlet g:didCmd\n\n      def InDefFunc()\n        Cmd\n        assert_equal(1, g:didCmd)\n        Cmd()\n        assert_equal(1, g:didFunc)\n        unlet g:didFunc\n        unlet g:didCmd\n      enddef\n      InDefFunc()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_option_use_linebreak()\n  var lines =<< trim END\n      new\n      &matchpairs = '(:)'\n      &matchpairs->setline(1)\n      &matchpairs = '[:]'\n      &matchpairs   ->setline(2)\n      &matchpairs = '{:}'\n      &matchpairs  \n          ->setline(3)\n      assert_equal(['(:)', '[:]', '{:}'], getline(1, '$'))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_use_register()\n  var lines =<< trim END\n      new\n      @a = 'one'\n      @a->setline(1)\n      @b = 'two'\n      @b   ->setline(2)\n      @c = 'three'\n      @c  \n          ->setline(3)\n      assert_equal(['one', 'two', 'three'], getline(1, '$'))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      @a = 'echo \"text\"'\n      @a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n\n  lines =<< trim END\n      @a = 'echo \"text\"'\n      @a\n\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n\n  lines =<< trim END\n      @a = 'echo \"text\"'\n      @a\n          # comment\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n\n  lines =<< trim END\n      @/ = 'pattern'\n      @/\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n\n  lines =<< trim END\n      &opfunc = 'nothing'\n      &opfunc\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n  &opfunc = ''\n\n  lines =<< trim END\n      &l:showbreak = 'nothing'\n      &l:showbreak\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n  &l:showbreak = ''\n\n  lines =<< trim END\n      &g:showbreak = 'nothing'\n      &g:showbreak\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n  &g:showbreak = ''\n\n  lines =<< trim END\n      $SomeEnv = 'value'\n      $SomeEnv\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\n  $SomeEnv = ''\n\n  lines =<< trim END\n      eval 'value'\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 1)\n\n  lines =<< trim END\n      eval \"value\"\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 1)\nenddef\n\ndef Test_environment_use_linebreak()\n  var lines =<< trim END\n      new\n      $TESTENV = 'one'\n      $TESTENV->setline(1)\n      $TESTENV = 'two'\n      $TESTENV  ->setline(2)\n      $TESTENV = 'three'\n      $TESTENV  \n          ->setline(3)\n      assert_equal(['one', 'two', 'three'], getline(1, '$'))\n      bwipe!\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_skipped_expr_linebreak()\n  if 0\n    var x = []\n               ->map(() => 0)\n  endif\nenddef\n\ndef Test_dict_member()\n   var test: dict<list<number>> = {data: [3, 1, 2]}\n   test.data->sort()\n   assert_equal({data: [1, 2, 3]}, test)\n   test.data\n      ->reverse()\n   assert_equal({data: [3, 2, 1]}, test)\n\n  var lines =<< trim END\n      vim9script\n      var test: dict<list<number>> = {data: [3, 1, 2]}\n      test.data->sort()\n      assert_equal({data: [1, 2, 3]}, test)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_bar_after_command()\n  def RedrawAndEcho()\n    var x = 'did redraw'\n    redraw | echo x\n  enddef\n  RedrawAndEcho()\n  assert_match('did redraw', g:Screenline(&lines))\n\n  def CallAndEcho()\n    var x = 'did redraw'\n    reg_executing() | echo x\n  enddef\n  CallAndEcho()\n  assert_match('did redraw', g:Screenline(&lines))\n\n  if has('unix')\n    # bar in filter write command does not start new command\n    def WriteToShell()\n      new\n      setline(1, 'some text')\n      w !cat | cat > Xoutfile\n      bwipe!\n    enddef\n    WriteToShell()\n    assert_equal(['some text'], readfile('Xoutfile'))\n    delete('Xoutfile')\n\n    # bar in filter read command does not start new command\n    def ReadFromShell()\n      new\n      r! echo hello there | cat > Xoutfile\n      r !echo again | cat >> Xoutfile\n      bwipe!\n    enddef\n    ReadFromShell()\n    assert_equal(['hello there', 'again'], readfile('Xoutfile'))\n    delete('Xoutfile')\n  endif\nenddef\n\ndef Test_filter_is_not_modifier()\n  var tags = [{a: 1, b: 2}, {x: 3, y: 4}]\n  filter(tags, ( _, v) => has_key(v, 'x') ? 1 : 0 )\n  assert_equal([{x: 3, y: 4}], tags)\nenddef\n\ndef Test_command_modifier_filter()\n  var lines =<< trim END\n    final expected = \"\\nType Name Content\\n  c  \\\"c   piyo\"\n    @a = 'hoge'\n    @b = 'fuga'\n    @c = 'piyo'\n\n    assert_equal(execute('filter /piyo/ registers abc'), expected)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # also do this compiled\n  lines =<< trim END\n      @a = 'very specific z3d37dh234 string'\n      filter z3d37dh234 registers\n      assert_match('very specific z3d37dh234 string', g:Screenline(&lines))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      edit foobar\n      redir => g:filter_out\n      filter #foobar# ls\n      redir END\n      assert_match('\"foobar\"', g:filter_out)\n      unlet g:filter_out\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_win_command_modifiers()\n  assert_equal(1, winnr('$'))\n\n  set splitright\n  vsplit\n  assert_equal(2, winnr())\n  close\n  aboveleft vsplit\n  assert_equal(1, winnr())\n  close\n  set splitright&\n\n  vsplit\n  assert_equal(1, winnr())\n  close\n  belowright vsplit\n  assert_equal(2, winnr())\n  close\n  rightbelow vsplit\n  assert_equal(2, winnr())\n  close\n\n  if has('browse')\n    browse set\n    assert_equal('option-window', expand('%'))\n    close\n  endif\n\n  vsplit\n  botright split\n  assert_equal(3, winnr())\n  assert_equal(&columns, winwidth(0))\n  close\n  close\n\n  vsplit\n  topleft split\n  assert_equal(1, winnr())\n  assert_equal(&columns, winwidth(0))\n  close\n  close\n\n  gettabinfo()->len()->assert_equal(1)\n  tab split\n  gettabinfo()->len()->assert_equal(2)\n  tabclose\n\n  vertical new\n  assert_inrange(&columns / 2 - 2, &columns / 2 + 1, winwidth(0))\n  close\nenddef\n\nfunc Test_command_modifier_confirm()\n  CheckNotGui\n  CheckRunVimInTerminal\n\n  \" Test for saving all the modified buffers\n  let lines =<< trim END\n    call setline(1, 'changed')\n    def Getout()\n      confirm write Xfile\n    enddef\n  END\n  call writefile(lines, 'Xconfirmscript')\n  call writefile(['empty'], 'Xfile')\n  let buf = RunVimInTerminal('-S Xconfirmscript', {'rows': 8})\n  call term_sendkeys(buf, \":call Getout()\\n\")\n  call WaitForAssert({-> assert_match('(Y)es, \\[N\\]o: ', term_getline(buf, 8))}, 1000)\n  call term_sendkeys(buf, \"y\")\n  call WaitForAssert({-> assert_match('(Y)es, \\[N\\]o: ', term_getline(buf, 8))}, 1000)\n  call term_sendkeys(buf, \"\\<CR>\")\n  call TermWait(buf)\n  call StopVimInTerminal(buf)\n\n  call assert_equal(['changed'], readfile('Xfile'))\n  call delete('Xfile')\n  call delete('.Xfile.swp')  \" in case Vim was killed\n  call delete('Xconfirmscript')\nendfunc\n\ndef Test_command_modifiers_keep()\n  if has('unix')\n    def DoTest(addRflag: bool, keepMarks: bool, hasMarks: bool)\n      new\n      setline(1, ['one', 'two', 'three'])\n      normal 1Gma\n      normal 2Gmb\n      normal 3Gmc\n      if addRflag\n        set cpo+=R\n      else\n        set cpo-=R\n      endif\n      if keepMarks\n        keepmarks :%!cat\n      else\n        :%!cat\n      endif\n      if hasMarks\n        assert_equal(1, line(\"'a\"))\n        assert_equal(2, line(\"'b\"))\n        assert_equal(3, line(\"'c\"))\n      else\n        assert_equal(0, line(\"'a\"))\n        assert_equal(0, line(\"'b\"))\n        assert_equal(0, line(\"'c\"))\n      endif\n      quit!\n    enddef\n    DoTest(false, false, true)\n    DoTest(true, false, false)\n    DoTest(false, true, true)\n    DoTest(true, true, true)\n    set cpo&vim\n\n    new\n    setline(1, ['one', 'two', 'three', 'four'])\n    assert_equal(4, line(\"$\"))\n    normal 1Gma\n    normal 2Gmb\n    normal 3Gmc\n    lockmarks :1,2!wc\n    # line is deleted, marks don't move\n    assert_equal(3, line(\"$\"))\n    assert_equal('four', getline(3))\n    assert_equal(1, line(\"'a\"))\n    assert_equal(2, line(\"'b\"))\n    assert_equal(3, line(\"'c\"))\n    quit!\n  endif\n\n  edit Xone\n  edit Xtwo\n  assert_equal('Xone', expand('#'))\n  keepalt edit Xthree\n  assert_equal('Xone', expand('#'))\n\n  normal /a*b*\n  assert_equal('a*b*', histget(\"search\"))\n  keeppatterns normal /c*d*\n  assert_equal('a*b*', histget(\"search\"))\n\n  new\n  setline(1, range(10))\n  :10\n  normal gg\n  assert_equal(10, getpos(\"''\")[1])\n  keepjumps normal 5G\n  assert_equal(10, getpos(\"''\")[1])\n  quit!\nenddef\n\ndef Test_bar_line_continuation()\n  var lines =<< trim END\n      au BufNewFile Xfile g:readFile = 1\n          | g:readExtra = 2\n      g:readFile = 0\n      g:readExtra = 0\n      edit Xfile\n      assert_equal(1, g:readFile)\n      assert_equal(2, g:readExtra)\n      bwipe!\n      au! BufNewFile\n\n      au BufNewFile Xfile g:readFile = 1\n          | g:readExtra = 2\n          | g:readMore = 3\n      g:readFile = 0\n      g:readExtra = 0\n      g:readMore = 0\n      edit Xfile\n      assert_equal(1, g:readFile)\n      assert_equal(2, g:readExtra)\n      assert_equal(3, g:readMore)\n      bwipe!\n      au! BufNewFile\n      unlet g:readFile\n      unlet g:readExtra\n      unlet g:readMore\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_command_modifier_other()\n  new Xsomefile\n  setline(1, 'changed')\n  var buf = bufnr()\n  hide edit Xotherfile\n  var info = getbufinfo(buf)\n  assert_equal(1, info[0].hidden)\n  assert_equal(1, info[0].changed)\n  edit Xsomefile\n  bwipe!\n\n  au BufNewFile Xfile g:readFile = 1\n  g:readFile = 0\n  edit Xfile\n  assert_equal(1, g:readFile)\n  bwipe!\n  g:readFile = 0\n  noautocmd edit Xfile\n  assert_equal(0, g:readFile)\n  au! BufNewFile\n  unlet g:readFile\n\n  noswapfile edit XnoSwap\n  assert_equal(false, &l:swapfile)\n  bwipe!\n\n  var caught = false\n  try\n    sandbox !ls\n  catch /E48:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  :8verbose g:verbose_now = &verbose\n  assert_equal(8, g:verbose_now)\n  unlet g:verbose_now\nenddef\n\ndef s:EchoHere()\n  echomsg 'here'\nenddef\ndef s:EchoThere()\n  unsilent echomsg 'there'\nenddef\n\ndef Test_modifier_silent_unsilent()\n  echomsg 'last one'\n  silent echomsg \"text\"\n  assert_equal(\"\\nlast one\", execute(':1messages'))\n\n  silent! echoerr \"error\"\n\n  echomsg 'last one'\n  silent EchoHere()\n  assert_equal(\"\\nlast one\", execute(':1messages'))\n\n  silent EchoThere()\n  assert_equal(\"\\nthere\", execute(':1messages'))\n\n  try\n    silent eval [][0]\n  catch\n    echomsg \"caught\"\n  endtry\n  assert_equal(\"\\ncaught\", execute(':1messages'))\n\n  var lines =<< trim END\n      vim9script\n      set history=11\n      silent! while 0\n        set history=22\n      silent! endwhile\n      assert_equal(11, &history)\n      set history&\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_range_after_command_modifier()\n  v9.CheckScriptFailure(['vim9script', 'silent keepjump 1d _'], 'E1050: Colon required before a range: 1d _', 2)\n  new\n  setline(1, 'xxx')\n  v9.CheckScriptSuccess(['vim9script', 'silent keepjump :1d _'])\n  assert_equal('', getline(1))\n  bwipe!\n\n  var lines =<< trim END\n      legacy /pat/\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E486: Pattern not found: pat')\nenddef\n\ndef Test_silent_pattern()\n  new\n  silent! :/pat/put _\n  bwipe!\nenddef\n\ndef Test_useless_command_modifier()\n  g:maybe = true\n  var lines =<< trim END\n      if g:maybe\n      silent endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 2)\n\n  lines =<< trim END\n      for i in [0]\n      silent endfor\n  END\n  v9.CheckDefFailure(lines, 'E1176:', 2)\n  v9.CheckScriptSuccess(['vim9script'] + lines)\n\n  lines =<< trim END\n      while g:maybe\n      silent endwhile\n  END\n  v9.CheckDefFailure(lines, 'E1176:', 2)\n  g:maybe = false\n  v9.CheckScriptSuccess(['vim9script'] + lines)\n\n  lines =<< trim END\n      silent try\n      finally\n      endtry\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 1)\n\n  lines =<< trim END\n      try\n      silent catch\n      endtry\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 2)\n\n  lines =<< trim END\n      try\n      silent finally\n      endtry\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 2)\n\n  lines =<< trim END\n      try\n      finally\n      silent endtry\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1176:', 3)\n\n  lines =<< trim END\n      leftabove\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1082:', 1)\n\n  lines =<< trim END\n      leftabove # comment\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1082:', 1)\nenddef\n\ndef Test_eval_command()\n  var from = 3\n  var to = 5\n  g:val = 111\n  def Increment(nrs: list<number>)\n    for nr in nrs\n      g:val += nr\n    endfor\n  enddef\n  eval range(from, to)\n        ->Increment()\n  assert_equal(111 + 3 + 4 + 5, g:val)\n  unlet g:val\n\n  var lines =<< trim END\n    vim9script\n    g:caught = 'no'\n    try\n      eval 123 || 0\n    catch\n      g:caught = 'yes'\n    endtry\n    assert_equal('yes', g:caught)\n    unlet g:caught\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_map_command()\n  var lines =<< trim END\n      nnoremap <F3> :echo 'hit F3 #'<CR>\n      assert_equal(\":echo 'hit F3 #'<CR>\", maparg(\"<F3>\", \"n\"))\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # backslash before bar is not removed\n  lines =<< trim END\n      vim9script\n\n      def Init()\n        noremap <buffer> <F5> <ScriptCmd>MyFunc('a') \\| MyFunc('b')<CR>\n      enddef\n      Init()\n      unmap <buffer> <F5>\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_normal_command()\n  new\n  setline(1, 'doesnotexist')\n  var caught = 0\n  try\n    exe \"norm! \\<C-]>\"\n  catch /E433/\n    caught = 2\n  endtry\n  assert_equal(2, caught)\n\n  try\n    exe \"norm! 3\\<C-]>\"\n  catch /E433/\n    caught = 3\n  endtry\n  assert_equal(3, caught)\n  bwipe!\nenddef\n\ndef Test_put_command()\n  new\n  @p = 'ppp'\n  put p\n  assert_equal('ppp', getline(2))\n\n  put ='below'\n  assert_equal('below', getline(3))\n  put! ='above'\n  assert_equal('above', getline(3))\n  assert_equal('below', getline(4))\n\n  :2put =['a', 'b', 'c']\n  assert_equal(['ppp', 'a', 'b', 'c', 'above'], getline(2, 6))\n\n  :0put =  'first'\n  assert_equal('first', getline(1))\n  :1put! ='first again'\n  assert_equal('first again', getline(1))\n\n  # compute range at runtime\n  :%del\n  setline(1, range(1, 8))\n  @a = 'aaa'\n  :$-2put a\n  assert_equal('aaa', getline(7))\n\n  setline(1, range(1, 8))\n  :2\n  :+2put! a\n  assert_equal('aaa', getline(4))\n\n  []->mapnew(() => 0)\n  :$put ='end'\n  assert_equal('end', getline('$'))\n\n  bwipe!\n\n  v9.CheckDefFailure(['put =xxx'], 'E1001:')\nenddef\n\ndef Test_put_with_linebreak()\n  new\n  var lines =<< trim END\n    vim9script\n    pu =split('abc', '\\zs')\n            ->join()\n  END\n  v9.CheckScriptSuccess(lines)\n  getline(2)->assert_equal('a b c')\n  bwipe!\nenddef\n\ndef Test_command_star_range()\n  new\n  setline(1, ['xxx foo xxx', 'xxx bar xxx', 'xxx foo xx bar'])\n  setpos(\"'<\", [0, 1, 0, 0])\n  setpos(\"'>\", [0, 3, 0, 0])\n  :*s/\\(foo\\|bar\\)/baz/g\n  getline(1, 3)->assert_equal(['xxx baz xxx', 'xxx baz xxx', 'xxx baz xx baz'])\n\n  bwipe!\nenddef\n\ndef Test_f_args()\n  var lines =<< trim END\n    vim9script\n\n    func SaveCmdArgs(...)\n      let g:args = a:000\n    endfunc\n\n    command -nargs=* TestFArgs call SaveCmdArgs(<f-args>)\n\n    TestFArgs\n    assert_equal([], g:args)\n\n    TestFArgs one two three\n    assert_equal(['one', 'two', 'three'], g:args)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_user_command_comment()\n  command -nargs=1 Comd echom <q-args>\n\n  var lines =<< trim END\n      vim9script\n      Comd # comment\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      Comd# comment\n  END\n  v9.CheckScriptFailure(lines, 'E1144:')\n  delcommand Comd\n\n  lines =<< trim END\n      vim9script\n      command Foo echo 'Foo'\n      Foo3Bar\n  END\n  v9.CheckScriptFailure(lines, 'E1144: Command \"Foo\" is not followed by white space: Foo3Bar')\n\n  delcommand Foo\nenddef\n\ndef Test_star_command()\n  var lines =<< trim END\n    vim9script\n    @s = 'g:success = 8'\n    set cpo+=*\n    exe '*s'\n    assert_equal(8, g:success)\n    unlet g:success\n    set cpo-=*\n    assert_fails(\"exe '*s'\", 'E1050:')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmd_argument_without_colon()\n  new Xfile\n  setline(1, ['a', 'b', 'c', 'd'])\n  write\n  edit +3 %\n  assert_equal(3, getcurpos()[1])\n  edit +/a %\n  assert_equal(1, getcurpos()[1])\n  bwipe\n  delete('Xfile')\nenddef\n\ndef Test_ambiguous_user_cmd()\n  command Cmd1 eval 0\n  command Cmd2 eval 0\n  var lines =<< trim END\n      Cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E464:', 1)\n  delcommand Cmd1\n  delcommand Cmd2\nenddef\n\ndef Test_command_not_recognized()\n  var lines =<< trim END\n    d.key = 'asdf'\n  END\n  v9.CheckDefFailure(lines, 'E1089: Unknown variable: d', 1)\n\n  lines =<< trim END\n    d['key'] = 'asdf'\n  END\n  v9.CheckDefFailure(lines, 'E1089: Unknown variable: d', 1)\n\n  lines =<< trim END\n    if 0\n      d.key = 'asdf'\n    endif\n  END\n  v9.CheckDefSuccess(lines)\nenddef\n\ndef Test_magic_not_used()\n  new\n  for cmd in ['set magic', 'set nomagic']\n    exe cmd\n    setline(1, 'aaa')\n    s/.../bbb/\n    assert_equal('bbb', getline(1))\n  endfor\n\n  set magic\n  setline(1, 'aaa')\n  assert_fails('s/.\\M../bbb/', 'E486:')\n  assert_fails('snomagic/.../bbb/', 'E486:')\n  assert_equal('aaa', getline(1))\n\n  bwipe!\nenddef\n\ndef Test_gdefault_not_used()\n  new\n  for cmd in ['set gdefault', 'set nogdefault']\n    exe cmd\n    setline(1, 'aaa')\n    s/./b/\n    assert_equal('baa', getline(1))\n  endfor\n\n  set nogdefault\n  bwipe!\nenddef\n\ndef s:SomeComplFunc(findstart: number, base: string): any\n  if findstart\n    return 0\n  else\n    return ['aaa', 'bbb']\n  endif\nenddef\n\ndef Test_insert_complete()\n  # this was running into an error with the matchparen hack\n  new\n  set completefunc=SomeComplFunc\n  feedkeys(\"i\\<c-x>\\<c-u>\\<Esc>\", 'ntx')\n  assert_equal('aaa', getline(1))\n\n  set completefunc=\n  bwipe!\nenddef\n\ndef Test_wincmd()\n  split\n  var id1 = win_getid()\n  if true\n    try | wincmd w | catch | endtry\n  endif\n  assert_notequal(id1, win_getid())\n  close\n\n  split\n  var id = win_getid()\n  split\n  :2wincmd o\n  assert_equal(id, win_getid())\n  only\n\n  split\n  split\n  assert_equal(3, winnr('$'))\n  :2wincmd c\n  assert_equal(2, winnr('$'))\n  only\n\n  split\n  split\n  assert_equal(3, winnr('$'))\n  :2wincmd q\n  assert_equal(2, winnr('$'))\n  only\nenddef\n\ndef Test_windo_missing_endif()\n  var lines =<< trim END\n      windo if 1\n  END\n  v9.CheckDefExecFailure(lines, 'E171:', 1)\nenddef\n\nlet s:theList = [1, 2, 3]\n\ndef Test_lockvar()\n  s:theList[1] = 22\n  assert_equal([1, 22, 3], s:theList)\n  lockvar s:theList\n  assert_fails('theList[1] = 77', 'E741:')\n  unlockvar s:theList\n  s:theList[1] = 44\n  assert_equal([1, 44, 3], s:theList)\n\n  if 0\n    lockvar whatever\n  endif\n\n  g:lockme = [1, 2, 3]\n  lockvar 1 g:lockme\n  g:lockme[1] = 77\n  assert_equal([1, 77, 3], g:lockme)\n\n  lockvar 2 g:lockme\n  var caught = false\n  try\n    g:lockme[1] = 99\n  catch /E1119:/\n    caught = true\n  endtry\n  assert_true(caught)\n  assert_equal([1, 77, 3], g:lockme)\n  unlet g:lockme\n\n  # also for non-materialized list\n  g:therange = range(3)\n  lockvar 2 g:therange\n  caught = false\n  try\n    g:therange[1] = 99\n  catch /E1119:/\n    caught = true\n  endtry\n  assert_true(caught)\n  assert_equal([0, 1, 2], g:therange)\n  unlet g:therange\n\n  # use exclamation mark for locking deeper\n  g:nestedlist = [1, [2, 3], 4]\n  lockvar! g:nestedlist\n  try\n    g:nestedlist[1][0] = 9\n  catch /E1119:/\n    caught = true\n  endtry\n  assert_true(caught)\n  unlet g:nestedlist\n\n  var d = {a: 1, b: 2}\n  d.a = 3\n  d.b = 4\n  assert_equal({a: 3, b: 4}, d)\n  lockvar d.a\n  d.b = 5\n  var ex = ''\n  try\n    d.a = 6\n  catch\n    ex = v:exception\n  endtry\n  assert_match('E1121:', ex)\n  unlockvar d['a']\n  d.a = 7\n  assert_equal({a: 7, b: 5}, d)\n\n  caught = false\n  try\n    lockvar d.c\n  catch /E716/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  var lines =<< trim END\n      vim9script\n      g:bl = 0z1122\n      lockvar g:bl\n      def Tryit()\n        g:bl[1] = 99\n      enddef\n      Tryit()\n  END\n  v9.CheckScriptFailure(lines, 'E741:', 1)\n\n  lines =<< trim END\n      vim9script\n      var theList = [1, 2, 3]\n      def SetList()\n        theList[1] = 22\n        assert_equal([1, 22, 3], theList)\n        lockvar theList\n        theList[1] = 77\n      enddef\n      SetList()\n  END\n  v9.CheckScriptFailure(lines, 'E1119', 4)\n\n  lines =<< trim END\n      vim9script\n      var theList = [1, 2, 3]\n      def AddToList()\n        lockvar theList\n        theList += [4]\n      enddef\n      AddToList()\n  END\n  v9.CheckScriptFailure(lines, 'E741', 2)\n\n  lines =<< trim END\n      vim9script\n      var theList = [1, 2, 3]\n      def AddToList()\n        lockvar theList\n        add(theList, 4)\n      enddef\n      AddToList()\n  END\n  v9.CheckScriptFailure(lines, 'E741', 2)\n\n  # can unlet a locked list item but not change it\n  lines =<< trim END\n    var ll = [1, 2, 3]\n    lockvar ll[1]\n    unlet ll[1]\n    assert_equal([1, 3], ll)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  lines =<< trim END\n    var ll = [1, 2, 3]\n    lockvar ll[1]\n    ll[1] = 9\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1119:', 'E741'], 3)\n\n  # can unlet a locked dict item but not change it\n  lines =<< trim END\n    var dd = {a: 1, b: 2}\n    lockvar dd.a\n    unlet dd.a\n    assert_equal({b: 2}, dd)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  lines =<< trim END\n    var dd = {a: 1, b: 2}\n    lockvar dd.a\n    dd.a = 3\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1121:', 'E741'], 3)\n\n  lines =<< trim END\n      var theList = [1, 2, 3]\n      lockvar theList\n  END\n  v9.CheckDefFailure(lines, 'E1178', 2)\n\n  lines =<< trim END\n      var theList = [1, 2, 3]\n      unlockvar theList\n  END\n  v9.CheckDefFailure(lines, 'E1178', 2)\n\n  lines =<< trim END\n      vim9script\n      var name = 'john'\n      lockvar nameX\n  END\n  v9.CheckScriptFailure(lines, 'E1246', 3)\n\n  lines =<< trim END\n      vim9script\n      var name = 'john'\n      def LockIt()\n        lockvar nameX\n      enddef\n      LockIt()\n  END\n  v9.CheckScriptFailure(lines, 'E1246', 1)\n\n  lines =<< trim END\n      vim9script\n      const name = 'john'\n      unlockvar name\n  END\n  v9.CheckScriptFailure(lines, 'E46', 3)\n\n  lines =<< trim END\n      vim9script\n      const name = 'john'\n      def UnLockIt()\n        unlockvar name\n      enddef\n      UnLockIt()\n  END\n  v9.CheckScriptFailure(lines, 'E46', 1)\n\n  lines =<< trim END\n      def _()\n        lockv\n      enddef\n      defcomp\n  END\n  v9.CheckScriptFailure(lines, 'E179', 1)\n\n  lines =<< trim END\n      def T()\n        unlet\n      enddef\n      defcomp\n  END\n  v9.CheckScriptFailure(lines, 'E179', 1)\nenddef\n\ndef Test_substitute_expr()\n  var to = 'repl'\n  new\n  setline(1, 'one from two')\n  s/from/\\=to\n  assert_equal('one repl two', getline(1))\n\n  setline(1, 'one from two')\n  s/from/\\=to .. '_x'\n  assert_equal('one repl_x two', getline(1))\n\n  setline(1, 'one from two from three')\n  var also = 'also'\n  s/from/\\=to .. '_' .. also/g#e\n  assert_equal('one repl_also two repl_also three', getline(1))\n\n  setline(1, 'abc abc abc')\n  for choice in [true, false]\n    :1s/abc/\\=choice ? 'yes' : 'no'/\n  endfor\n  assert_equal('yes no abc', getline(1))\n\n  setline(1, 'from')\n  v9.CheckDefExecFailure(['s/from/\\=g:notexist/'], 'E121: Undefined variable: g:notexist')\n\n  bwipe!\n\n  v9.CheckDefFailure(['s/from/\\=\"x\")/'], 'E488:')\n  v9.CheckDefFailure(['s/from/\\=\"x\"/9'], 'E488:')\n\n  v9.CheckDefExecFailure(['s/this/\\=\"that\"/'], 'E486:')\n\n  # When calling a function the right instruction list needs to be restored.\n  g:cond = true\n  var lines =<< trim END\n      vim9script\n      def Foo()\n          Bar([])\n      enddef\n      def Bar(l: list<number>)\n        if g:cond\n          s/^/\\=Rep()/\n          for n in l[:]\n          endfor\n        endif\n      enddef\n      def Rep(): string\n          return 'rep'\n      enddef\n      new\n      Foo()\n      assert_equal('rep', getline(1))\n      bwipe!\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:cond\n\n  # List results in multiple lines\n  new\n  setline(1, 'some text here')\n  s/text/\\=['aaa', 'bbb', 'ccc']/\n  assert_equal(['some aaa', 'bbb', 'ccc', ' here'], getline(1, '$'))\n  bwipe!\n\n  # inside \"if 0\" substitute is ignored\n  if 0\n    s/a/\\=nothing/ and | some more\n  endif\nenddef\n\ndef Test_redir_to_var()\n  var result: string\n  redir => result\n    echo 'something'\n  redir END\n  assert_equal(\"\\nsomething\", result)\n\n  redir =>> result\n    echo 'more'\n  redir END\n  assert_equal(\"\\nsomething\\nmore\", result)\n\n  var d: dict<string>\n  redir => d.redir\n    echo 'dict'\n  redir END\n  assert_equal({redir: \"\\ndict\"}, d)\n\n  var l = ['a', 'b', 'c']\n  redir => l[1]\n    echo 'list'\n  redir END\n  assert_equal(['a', \"\\nlist\", 'c'], l)\n\n  var dl = {l: ['x']}\n  redir => dl.l[0]\n    echo 'dict-list'\n  redir END\n  assert_equal({l: [\"\\ndict-list\"]}, dl)\n\n  redir =>> d.redir\n    echo 'more'\n  redir END\n  assert_equal({redir: \"\\ndict\\nmore\"}, d)\n\n  var lines =<< trim END\n    redir => notexist\n  END\n  v9.CheckDefFailure(lines, 'E1089:')\n\n  lines =<< trim END\n    var text: string\n    redir => text\n  END\n  v9.CheckDefFailure(lines, 'E1185:')\n\n  lines =<< trim END\n    var ls = 'asdf'\n    redir => ls[1]\n    redir END\n  END\n  v9.CheckDefFailure(lines, 'E1141:')\n\n  lines =<< trim END\n      var text: string\n      redir => text\n        echo 'hello'\n        redir > Xfile\n      redir END\n  END\n  v9.CheckDefFailure(lines, 'E1092:')\n\n  lines =<< trim END\n      var text: number\n      redir => text\n        echo 'hello'\n      redir END\n  END\n  v9.CheckDefFailure(lines, 'E1012:')\nenddef\n\ndef Test_echo_void()\n  var lines =<< trim END\n      vim9script\n      def NoReturn()\n        echo 'nothing'\n      enddef\n      echo NoReturn()\n  END\n  v9.CheckScriptFailure(lines, 'E1186:', 5)\n\n  lines =<< trim END\n      vim9script\n      def NoReturn()\n        echo 'nothing'\n      enddef\n      def Try()\n        echo NoReturn()\n      enddef\n      defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1186:', 1)\nenddef\n\ndef Test_cmdwin_block()\n  augroup justTesting\n    autocmd BufEnter * {\n      echomsg 'in block'\n    }\n  augroup END\n  feedkeys('q:', 'xt')\n  redraw\n  feedkeys(\"aclose\\<CR>\", 'xt')\n\n  au! justTesting\nenddef\n\ndef Test_var_not_cmd()\n  var lines =<< trim END\n      g:notexist:cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E488: Trailing characters: :cmd', 'E121: Undefined variable: g:notexist'], 1)\n\n  lines =<< trim END\n      g-pat-cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1241:', 1)\n  lines =<< trim END\n      g.pat.cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1001: Variable not found: g', 'E121: Undefined variable: g'], 1)\n\n  lines =<< trim END\n      s:notexist:repl\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E488: Trailing characters: :repl', 'E1268:'], 1)\n\n  lines =<< trim END\n      notexist:repl\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'], 1)\n\n  lines =<< trim END\n      s-pat-repl\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1241:', 1)\n  lines =<< trim END\n      s.pat.repl\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1001: Variable not found: s', 'E121: Undefined variable: s'], 1)\n\n  lines =<< trim END\n      w:notexist->len()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E121: Undefined variable: w:notexist', 1)\n\n  lines =<< trim END\n      b:notexist->len()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E121: Undefined variable: b:notexist', 1)\n\n  lines =<< trim END\n      t:notexist->len()\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E121: Undefined variable: t:notexist', 1)\nenddef\n\ndef Test_no_space_after_command()\n  var lines =<< trim END\n      g /pat/cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1242:', 1)\n  lines =<< trim END\n      g #pat#cmd\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1242:', 1)\n\n  new\n  setline(1, 'some pat')\n  lines =<< trim END\n      g#pat#print\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  lines =<< trim END\n      g# pat#print\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n  bwipe!\n\n  lines =<< trim END\n      s /pat/repl\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1242:', 1)\n  lines =<< trim END\n      s #pat#repl\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1242:', 1)\n  lines =<< trim END\n      s#pat#repl\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E486:', 1)\n  lines =<< trim END\n      s# pat#repl\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E486:', 1)\nenddef\n\n\" Test for the 'previewpopup' option\ndef Test_previewpopup()\n  set previewpopup=height:10,width:60\n  pedit Xfile\n  var id = popup_findpreview()\n  assert_notequal(id, 0)\n  assert_match('Xfile', popup_getoptions(id).title)\n  popup_clear()\n  set previewpopup&\nenddef\n\ndef Test_syntax_enable_clear()\n  syntax clear\n  syntax enable\n  highlight clear String\n  assert_equal(true, hlget('String')->get(0, {})->get('default', false))\n  syntax clear\nenddef\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9cmds.c: Dealing with commands of a compiled function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n/*\n * Get the index of the current instruction.\n * This compensates for a preceding ISN_CMDMOD and ISN_PROF_START.\n */\n    static int\ncurrent_instr_idx(cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tidx = instr->ga_len;\n\n    while (idx > 0)\n    {\n\tif (cctx->ctx_has_cmdmod && ((isn_T *)instr->ga_data)[idx - 1]\n\t\t\t\t\t\t       .isn_type == ISN_CMDMOD)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n#ifdef FEAT_PROFILE\n\tif (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_PROF_START)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n#endif\n\tif (((isn_T *)instr->ga_data)[idx - 1].isn_type == ISN_DEBUG)\n\t{\n\t    --idx;\n\t    continue;\n\t}\n\tbreak;\n    }\n    return idx;\n}\n/*\n * Remove local variables above \"new_top\".\n */\n    static void\nunwind_locals(cctx_T *cctx, int new_top)\n{\n    if (cctx->ctx_locals.ga_len > new_top)\n    {\n\tint\tidx;\n\tlvar_T\t*lvar;\n\n\tfor (idx = new_top; idx < cctx->ctx_locals.ga_len; ++idx)\n\t{\n\t    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\t    vim_free(lvar->lv_name);\n\t}\n    }\n    cctx->ctx_locals.ga_len = new_top;\n}\n\n/*\n * Free all local variables.\n */\n    void\nfree_locals(cctx_T *cctx)\n{\n    unwind_locals(cctx, 0);\n    ga_clear(&cctx->ctx_locals);\n}\n\n\n/*\n * Check if \"name\" can be \"unlet\".\n */\n    int\ncheck_vim9_unlet(char_u *name)\n{\n    if (*name == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), \"unlet\");\n\treturn FAIL;\n    }\n\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\t// \"unlet s:var\" is allowed in legacy script.\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Callback passed to ex_unletlock().\n */\n    static int\ncompile_unlet(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep UNUSED,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    char_u\t*p = lvp->ll_name;\n    int\t\tcc = *name_end;\n    int\t\tret = OK;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    *name_end = NUL;\n    if (*p == '$')\n    {\n\t// :unlet $ENV_VAR\n\tret = generate_UNLET(cctx, ISN_UNLETENV, p + 1, eap->forceit);\n    }\n    else if (vim_strchr(p, '.') != NULL || vim_strchr(p, '[') != NULL)\n    {\n\tlhs_T\t    lhs;\n\n\t// This is similar to assigning: lookup the list/dict, compile the\n\t// idx/key.  Then instead of storing the value unlet the item.\n\t// unlet {list}[idx]\n\t// unlet {dict}[key]  dict.key\n\t//\n\t// Figure out the LHS type and other properties.\n\t//\n\tret = compile_lhs(p, &lhs, CMD_unlet, FALSE, FALSE, 0, cctx);\n\n\t// Use the info in \"lhs\" to unlet the item at the index in the\n\t// list or dict.\n\tif (ret == OK)\n\t{\n\t    if (!lhs.lhs_has_index)\n\t    {\n\t\tsemsg(_(e_cannot_unlet_imported_item_str), p);\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = compile_assign_unlet(p, &lhs, FALSE, &t_void, cctx);\n\t}\n\n\tvim_free(lhs.lhs_name);\n    }\n    else if (check_vim9_unlet(p) == FAIL)\n    {\n\tret = FAIL;\n    }\n    else\n    {\n\t// Normal name.  Only supports g:, w:, t: and b: namespaces.\n\tret = generate_UNLET(cctx, ISN_UNLET, p, eap->forceit);\n    }\n\n    *name_end = cc;\n    return ret;\n}\n\n/*\n * Callback passed to ex_unletlock().\n */\n    static int\ncompile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (*p == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), cmd);\n\treturn FAIL;\n    }\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\n\t    // For \"d.member\" put the local variable on the stack, it will be\n\t    // passed to ex_lockvar() indirectly.\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n\n    // Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}\n\n/*\n * compile \"unlet var\", \"lock var\" and \"unlock var\"\n * \"arg\" points to \"var\".\n */\n    char_u *\ncompile_unletlock(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    int\t    deep = 0;\n    char_u  *p = arg;\n\n    if (eap->cmdidx != CMD_unlet)\n    {\n\tif (eap->forceit)\n\t    deep = -1;\n\telse if (vim_isdigit(*p))\n\t{\n\t    deep = getdigits(&p);\n\t    p = skipwhite(p);\n\t}\n\telse\n\t    deep = 2;\n    }\n\n    ex_unletlock(eap, p, deep, GLV_NO_AUTOLOAD | GLV_COMPILING,\n\t    eap->cmdidx == CMD_unlet ? compile_unlet : compile_lock_unlock,\n\t    cctx);\n    return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n}\n\n/*\n * generate a jump to the \":endif\"/\":endfor\"/\":endwhile\"/\":finally\"/\":endtry\".\n */\n    static int\ncompile_jump_to_end(endlabel_T **el, jumpwhen_T when, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    endlabel_T  *endlabel = ALLOC_CLEAR_ONE(endlabel_T);\n\n    if (endlabel == NULL)\n\treturn FAIL;\n    endlabel->el_next = *el;\n    *el = endlabel;\n    endlabel->el_end_label = instr->ga_len;\n\n    generate_JUMP(cctx, when, 0);\n    return OK;\n}\n\n    static void\ncompile_fill_jump_to_end(endlabel_T **el, int jump_where, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    while (*el != NULL)\n    {\n\tendlabel_T  *cur = (*el);\n\tisn_T\t    *isn;\n\n\tisn = ((isn_T *)instr->ga_data) + cur->el_end_label;\n\tisn->isn_arg.jump.jump_where = jump_where;\n\t*el = cur->el_next;\n\tvim_free(cur);\n    }\n}\n\n    static void\ncompile_free_jump_to_end(endlabel_T **el)\n{\n    while (*el != NULL)\n    {\n\tendlabel_T  *cur = (*el);\n\n\t*el = cur->el_next;\n\tvim_free(cur);\n    }\n}\n\n/*\n * Create a new scope and set up the generic items.\n */\n    static scope_T *\nnew_scope(cctx_T *cctx, scopetype_T type)\n{\n    scope_T *scope = ALLOC_CLEAR_ONE(scope_T);\n\n    if (scope == NULL)\n\treturn NULL;\n    scope->se_outer = cctx->ctx_scope;\n    cctx->ctx_scope = scope;\n    scope->se_type = type;\n    scope->se_local_count = cctx->ctx_locals.ga_len;\n    return scope;\n}\n\n/*\n * Free the current scope and go back to the outer scope.\n */\n    void\ndrop_scope(cctx_T *cctx)\n{\n    scope_T *scope = cctx->ctx_scope;\n\n    if (scope == NULL)\n    {\n\tiemsg(\"calling drop_scope() without a scope\");\n\treturn;\n    }\n    cctx->ctx_scope = scope->se_outer;\n    switch (scope->se_type)\n    {\n\tcase IF_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_if.is_end_label); break;\n\tcase FOR_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_for.fs_end_label); break;\n\tcase WHILE_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_while.ws_end_label); break;\n\tcase TRY_SCOPE:\n\t    compile_free_jump_to_end(&scope->se_u.se_try.ts_end_label); break;\n\tcase NO_SCOPE:\n\tcase BLOCK_SCOPE:\n\t    break;\n    }\n    vim_free(scope);\n}\n\n    static int\nmisplaced_cmdmod(cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    if (cctx->ctx_has_cmdmod\n\t    && ((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type\n\t\t\t\t\t\t\t\t == ISN_CMDMOD)\n    {\n\temsg(_(e_misplaced_command_modifier));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * compile \"if expr\"\n *\n * \"if expr\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE end\n *\t... body ...\n * end:\n *\n * \"if expr | else\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE else\n *\t... body ...\n *\tJUMP_ALWAYS end\n * else:\n *\t... body ...\n * end:\n *\n * \"if expr1 | elseif expr2 | else\" Produces instructions:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE elseif\n *\t... body ...\n *\tJUMP_ALWAYS end\n * elseif:\n *\tEVAL expr\t\tPush result of \"expr\"\n *\tJUMP_IF_FALSE else\n *\t... body ...\n *\tJUMP_ALWAYS end\n * else:\n *\t... body ...\n * end:\n */\n    char_u *\ncompile_if(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tinstr_count = instr->ga_len;\n    scope_T\t*scope;\n    skip_T\tskip_save = cctx->ctx_skip;\n    ppconst_T\tppconst;\n\n    CLEAR_FIELD(ppconst);\n    if (compile_expr1(&p, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn NULL;\n    }\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n    if (cctx->ctx_skip == SKIP_YES)\n\tclear_ppconst(&ppconst);\n    else if (instr->ga_len == instr_count && ppconst.pp_used == 1)\n    {\n\tint error = FALSE;\n\tint v;\n\n\t// The expression results in a constant.\n\tv = tv_get_bool_chk(&ppconst.pp_tv[0], &error);\n\tclear_ppconst(&ppconst);\n\tif (error)\n\t    return NULL;\n\tcctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;\n    }\n    else\n    {\n\t// Not a constant, generate instructions for the expression.\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n\tif (generate_ppconst(cctx, &ppconst) == FAIL)\n\t    return NULL;\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return NULL;\n    }\n\n    // CMDMOD_REV must come before the jump\n    generate_undo_cmdmods(cctx);\n\n    scope = new_scope(cctx, IF_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n    scope->se_skip_save = skip_save;\n    // \"is_had_return\" will be reset if any block does not end in :return\n    scope->se_u.se_if.is_had_return = TRUE;\n\n    if (cctx->ctx_skip == SKIP_UNKNOWN)\n    {\n\t// \"where\" is set when \":elseif\", \"else\" or \":endif\" is found\n\tscope->se_u.se_if.is_if_label = instr->ga_len;\n\tgenerate_JUMP(cctx, JUMP_IF_FALSE, 0);\n    }\n    else\n\tscope->se_u.se_if.is_if_label = -1;\n\n#ifdef FEAT_PROFILE\n    if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES\n\t\t\t\t\t\t      && skip_save != SKIP_YES)\n    {\n\t// generated a profile start, need to generate a profile end, since it\n\t// won't be done after returning\n\tcctx->ctx_skip = SKIP_NOT;\n\tgenerate_instr(cctx, ISN_PROF_END);\n\tcctx->ctx_skip = SKIP_YES;\n    }\n#endif\n\n    return p;\n}\n\n    char_u *\ncompile_elseif(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tinstr_count;\n    isn_T\t*isn;\n    scope_T\t*scope = cctx->ctx_scope;\n    ppconst_T\tppconst;\n    skip_T\tsave_skip = cctx->ctx_skip;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_elseif_without_if));\n\treturn NULL;\n    }\n    unwind_locals(cctx, scope->se_local_count);\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_if.is_had_return = FALSE;\n\n    if (cctx->ctx_skip == SKIP_NOT)\n    {\n\t// previous block was executed, this one and following will not\n\tcctx->ctx_skip = SKIP_YES;\n\tscope->se_u.se_if.is_seen_skip_not = TRUE;\n    }\n    if (scope->se_u.se_if.is_seen_skip_not)\n    {\n\t// A previous block was executed, skip over expression and bail out.\n\t// Do not count the \"elseif\" for profiling and cmdmod\n\tinstr->ga_len = current_instr_idx(cctx);\n\n\tskip_expr_cctx(&p, cctx);\n\treturn p;\n    }\n\n    if (cctx->ctx_skip == SKIP_UNKNOWN)\n    {\n\tint\t    moved_cmdmod = FALSE;\n\tint\t    saved_debug = FALSE;\n\tisn_T\t    debug_isn;\n\n\t// Move any CMDMOD instruction to after the jump\n\tif (((isn_T *)instr->ga_data)[instr->ga_len - 1].isn_type == ISN_CMDMOD)\n\t{\n\t    if (GA_GROW_FAILS(instr, 1))\n\t\treturn NULL;\n\t    ((isn_T *)instr->ga_data)[instr->ga_len] =\n\t\t\t\t  ((isn_T *)instr->ga_data)[instr->ga_len - 1];\n\t    --instr->ga_len;\n\t    moved_cmdmod = TRUE;\n\t}\n\n\t// Remove the already generated ISN_DEBUG, it is written below the\n\t// ISN_FOR instruction.\n\tif (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t\t.isn_type == ISN_DEBUG)\n\t{\n\t    --instr->ga_len;\n\t    debug_isn = ((isn_T *)instr->ga_data)[instr->ga_len];\n\t    saved_debug = TRUE;\n\t}\n\n\tif (compile_jump_to_end(&scope->se_u.se_if.is_end_label,\n\t\t\t\t\t\t    JUMP_ALWAYS, cctx) == FAIL)\n\t    return NULL;\n\t// previous \"if\" or \"elseif\" jumps here\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\n\tif (moved_cmdmod)\n\t    ++instr->ga_len;\n\n\tif (saved_debug)\n\t{\n\t    // move the debug instruction here\n\t    if (GA_GROW_FAILS(instr, 1))\n\t\treturn NULL;\n\t    ((isn_T *)instr->ga_data)[instr->ga_len] = debug_isn;\n\t    ++instr->ga_len;\n\t}\n    }\n\n    // compile \"expr\"; if we know it evaluates to FALSE skip the block\n    CLEAR_FIELD(ppconst);\n    if (cctx->ctx_skip == SKIP_YES)\n    {\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t    // the previous block was skipped, need to profile this line\n\t    generate_instr(cctx, ISN_PROF_START);\n#endif\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t    // the previous block was skipped, may want to debug this line\n\t    generate_instr_debug(cctx);\n    }\n\n    instr_count = instr->ga_len;\n    if (compile_expr1(&p, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn NULL;\n    }\n    cctx->ctx_skip = save_skip;\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tclear_ppconst(&ppconst);\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n    if (scope->se_skip_save == SKIP_YES)\n\tclear_ppconst(&ppconst);\n    else if (instr->ga_len == instr_count && ppconst.pp_used == 1)\n    {\n\tint error = FALSE;\n\tint v;\n\n\t// The expression result is a constant.\n\tv = tv_get_bool_chk(&ppconst.pp_tv[0], &error);\n\tif (error)\n\t{\n\t    clear_ppconst(&ppconst);\n\t    return NULL;\n\t}\n\tcctx->ctx_skip = v ? SKIP_NOT : SKIP_YES;\n\tclear_ppconst(&ppconst);\n\tscope->se_u.se_if.is_if_label = -1;\n    }\n    else\n    {\n\t// Not a constant, generate instructions for the expression.\n\tcctx->ctx_skip = SKIP_UNKNOWN;\n\tif (generate_ppconst(cctx, &ppconst) == FAIL)\n\t    return NULL;\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return NULL;\n\n\t// CMDMOD_REV must come before the jump\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"where\" is set when \":elseif\", \"else\" or \":endif\" is found\n\tscope->se_u.se_if.is_if_label = instr->ga_len;\n\tgenerate_JUMP(cctx, JUMP_IF_FALSE, 0);\n    }\n\n    return p;\n}\n\n    char_u *\ncompile_else(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n    scope_T\t*scope = cctx->ctx_scope;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_else_without_if));\n\treturn NULL;\n    }\n    unwind_locals(cctx, scope->se_local_count);\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_if.is_had_return = FALSE;\n    scope->se_u.se_if.is_seen_else = TRUE;\n\n#ifdef FEAT_PROFILE\n    if (cctx->ctx_compile_type == CT_PROFILE)\n    {\n\tif (cctx->ctx_skip == SKIP_NOT\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t    // the previous block was executed, do not count \"else\" for\n\t    // profiling\n\t    --instr->ga_len;\n\tif (cctx->ctx_skip == SKIP_YES && !scope->se_u.se_if.is_seen_skip_not)\n\t{\n\t    // the previous block was not executed, this one will, do count the\n\t    // \"else\" for profiling\n\t    cctx->ctx_skip = SKIP_NOT;\n\t    generate_instr(cctx, ISN_PROF_END);\n\t    generate_instr(cctx, ISN_PROF_START);\n\t    cctx->ctx_skip = SKIP_YES;\n\t}\n    }\n#endif\n\n    if (!scope->se_u.se_if.is_seen_skip_not && scope->se_skip_save != SKIP_YES)\n    {\n\t// jump from previous block to the end, unless the else block is empty\n\tif (cctx->ctx_skip == SKIP_UNKNOWN)\n\t{\n\t    if (!cctx->ctx_had_return\n\t\t    && compile_jump_to_end(&scope->se_u.se_if.is_end_label,\n\t\t\t\t\t\t    JUMP_ALWAYS, cctx) == FAIL)\n\t\treturn NULL;\n\t}\n\n\tif (cctx->ctx_skip == SKIP_UNKNOWN)\n\t{\n\t    if (scope->se_u.se_if.is_if_label >= 0)\n\t    {\n\t\t// previous \"if\" or \"elseif\" jumps here\n\t\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\t\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\t\tscope->se_u.se_if.is_if_label = -1;\n\t    }\n\t}\n\n\tif (cctx->ctx_skip != SKIP_UNKNOWN)\n\t    cctx->ctx_skip = cctx->ctx_skip == SKIP_YES ? SKIP_NOT : SKIP_YES;\n    }\n\n    return p;\n}\n\n    char_u *\ncompile_endif(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    ifscope_T\t*ifscope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    if (scope == NULL || scope->se_type != IF_SCOPE)\n    {\n\temsg(_(e_endif_without_if));\n\treturn NULL;\n    }\n    ifscope = &scope->se_u.se_if;\n    unwind_locals(cctx, scope->se_local_count);\n    if (!cctx->ctx_had_return)\n\tifscope->is_had_return = FALSE;\n\n    if (scope->se_u.se_if.is_if_label >= 0)\n    {\n\t// previous \"if\" or \"elseif\" jumps here\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_if.is_if_label;\n\tisn->isn_arg.jump.jump_where = instr->ga_len;\n    }\n    // Fill in the \"end\" label in jumps at the end of the blocks.\n    compile_fill_jump_to_end(&ifscope->is_end_label, instr->ga_len, cctx);\n\n#ifdef FEAT_PROFILE\n    // even when skipping we count the endif as executed, unless the block it's\n    // in is skipped\n    if (cctx->ctx_compile_type == CT_PROFILE && cctx->ctx_skip == SKIP_YES\n\t\t\t\t\t    && scope->se_skip_save != SKIP_YES)\n    {\n\tcctx->ctx_skip = SKIP_NOT;\n\tgenerate_instr(cctx, ISN_PROF_START);\n    }\n#endif\n    cctx->ctx_skip = scope->se_skip_save;\n\n    // If all the blocks end in :return and there is an :else then the\n    // had_return flag is set.\n    cctx->ctx_had_return = ifscope->is_had_return && ifscope->is_seen_else;\n\n    drop_scope(cctx);\n    return arg;\n}\n\n/*\n * Compile \"for var in expr\":\n *\n * Produces instructions:\n *       PUSHNR -1\n *       STORE loop-idx\t\tSet index to -1\n *       EVAL expr\t\tresult of \"expr\" on top of stack\n * top:  FOR loop-idx, end\tIncrement index, use list on bottom of stack\n *\t\t\t\t- if beyond end, jump to \"end\"\n *\t\t\t\t- otherwise get item from list and push it\n *       STORE var\t\tStore item in \"var\"\n *       ... body ...\n *       JUMP top\t\tJump back to repeat\n * end:\t DROP\t\t\tDrop the result of \"expr\"\n *\n * Compile \"for [var1, var2] in expr\" - as above, but instead of \"STORE var\":\n *\t UNPACK 2\t\tSplit item in 2\n *       STORE var1\t\tStore item in \"var1\"\n *       STORE var2\t\tStore item in \"var2\"\n */\n    char_u *\ncompile_for(char_u *arg_start, cctx_T *cctx)\n{\n    char_u\t*arg;\n    char_u\t*arg_end;\n    char_u\t*name = NULL;\n    char_u\t*p;\n    char_u\t*wp;\n    int\t\tvar_count = 0;\n    int\t\tvar_list = FALSE;\n    int\t\tsemicolon = FALSE;\n    size_t\tvarlen;\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*scope;\n    lvar_T\t*loop_lvar;\t// loop iteration variable\n    lvar_T\t*var_lvar;\t// variable for \"var\"\n    type_T\t*vartype;\n    type_T\t*item_type = &t_any;\n    int\t\tidx;\n    int\t\tprev_lnum = cctx->ctx_prev_lnum;\n\n    p = skip_var_list(arg_start, TRUE, &var_count, &semicolon, FALSE);\n    if (p == NULL)\n\treturn NULL;\n    if (var_count == 0)\n\tvar_count = 1;\n    else\n\tvar_list = TRUE;  // can also be a list of one variable\n\n    // consume \"in\"\n    wp = p;\n    if (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\treturn NULL;\n    if (STRNCMP(p, \"in\", 2) != 0 || !IS_WHITE_OR_NUL(p[2]))\n    {\n\tif (*p == ':' && wp != p)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), p);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn NULL;\n    }\n    wp = p + 2;\n    if (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\treturn NULL;\n\n    // Find the already generated ISN_DEBUG to get the line number for the\n    // instruction written below the ISN_FOR instruction.\n    if (cctx->ctx_compile_type == CT_DEBUG && instr->ga_len > 0\n\t    && ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t\t.isn_type == ISN_DEBUG)\n    {\n\tprev_lnum = ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t .isn_arg.debug.dbg_break_lnum;\n    }\n\n    scope = new_scope(cctx, FOR_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n\n    // Reserve a variable to store the loop iteration counter and initialize it\n    // to -1.\n    loop_lvar = reserve_local(cctx, (char_u *)\"\", 0, FALSE, &t_number);\n    if (loop_lvar == NULL)\n    {\n\t// out of memory\n\tdrop_scope(cctx);\n\treturn NULL;\n    }\n    generate_STORENR(cctx, loop_lvar->lv_idx, -1);\n\n    // compile \"expr\", it remains on the stack until \"endfor\"\n    arg = p;\n    if (compile_expr0(&arg, cctx) == FAIL)\n    {\n\tdrop_scope(cctx);\n\treturn NULL;\n    }\n    arg_end = arg;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// If we know the type of \"var\" and it is not a supported type we can\n\t// give an error now.\n\tvartype = get_type_on_stack(cctx, 0);\n\tif (vartype->tt_type != VAR_LIST\n\t\t&& vartype->tt_type != VAR_STRING\n\t\t&& vartype->tt_type != VAR_BLOB\n\t\t&& vartype->tt_type != VAR_ANY\n\t\t&& vartype->tt_type != VAR_UNKNOWN)\n\t{\n\t    semsg(_(e_for_loop_on_str_not_supported),\n\t\t\t\t\t       vartype_name(vartype->tt_type));\n\t    drop_scope(cctx);\n\t    return NULL;\n\t}\n\n\tif (vartype->tt_type == VAR_STRING)\n\t    item_type = &t_string;\n\telse if (vartype->tt_type == VAR_BLOB)\n\t    item_type = &t_number;\n\telse if (vartype->tt_type == VAR_LIST\n\t\t\t\t     && vartype->tt_member->tt_type != VAR_ANY)\n\t{\n\t    if (!var_list)\n\t\titem_type = vartype->tt_member;\n\t    else if (vartype->tt_member->tt_type == VAR_LIST\n\t\t\t  && vartype->tt_member->tt_member->tt_type != VAR_ANY)\n\t\titem_type = vartype->tt_member->tt_member;\n\t}\n\n\t// CMDMOD_REV must come before the FOR instruction.\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"for_end\" is set when \":endfor\" is found\n\tscope->se_u.se_for.fs_top_label = current_instr_idx(cctx);\n\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t{\n\t    int\t\tsave_prev_lnum = cctx->ctx_prev_lnum;\n\t    isn_T\t*isn;\n\n\t    // Add ISN_DEBUG here, before deciding to end the loop.  There will\n\t    // be another ISN_DEBUG before the next instruction.\n\t    // Use the prev_lnum from the ISN_DEBUG instruction removed above.\n\t    // Increment the variable count so that the loop variable can be\n\t    // inspected.\n\t    cctx->ctx_prev_lnum = prev_lnum;\n\t    isn = generate_instr_debug(cctx);\n\t    ++isn->isn_arg.debug.dbg_var_names_len;\n\t    cctx->ctx_prev_lnum = save_prev_lnum;\n\t}\n\n\tgenerate_FOR(cctx, loop_lvar->lv_idx);\n\n\targ = arg_start;\n\tif (var_list)\n\t{\n\t    generate_UNPACK(cctx, var_count, semicolon);\n\t    arg = skipwhite(arg + 1);\t// skip white after '['\n\n\t    // drop the list item\n\t    --cctx->ctx_type_stack.ga_len;\n\n\t    // add type of the items\n\t    for (idx = 0; idx < var_count; ++idx)\n\t    {\n\t\ttype_T *type = (semicolon && idx == 0) ? vartype : item_type;\n\n\t\tif (push_type_stack(cctx, type) == FAIL)\n\t\t{\n\t\t    drop_scope(cctx);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t}\n\n\tfor (idx = 0; idx < var_count; ++idx)\n\t{\n\t    assign_dest_T\tdest = dest_local;\n\t    int\t\t\topt_flags = 0;\n\t    int\t\t\tvimvaridx = -1;\n\t    type_T\t\t*type = &t_any;\n\t    type_T\t\t*lhs_type = &t_any;\n\t    where_T\t\twhere = WHERE_INIT;\n\n\t    p = skip_var_one(arg, FALSE);\n\t    varlen = p - arg;\n\t    name = vim_strnsave(arg, varlen);\n\t    if (name == NULL)\n\t\tgoto failed;\n\t    if (*p == ':')\n\t    {\n\t\tp = skipwhite(p + 1);\n\t\tlhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    }\n\n\t    if (get_var_dest(name, &dest, CMD_for, &opt_flags,\n\t\t\t\t\t      &vimvaridx, &type, cctx) == FAIL)\n\t\tgoto failed;\n\t    if (dest != dest_local)\n\t    {\n\t\tif (generate_store_var(cctx, dest, opt_flags, vimvaridx,\n\t\t\t\t\t\t     0, 0, type, name) == FAIL)\n\t\t    goto failed;\n\t    }\n\t    else if (varlen == 1 && *arg == '_')\n\t    {\n\t\t// Assigning to \"_\": drop the value.\n\t\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t\t    goto failed;\n\t    }\n\t    else\n\t    {\n\t\t// Script var is not supported.\n\t\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t\t{\n\t\t    emsg(_(e_cannot_use_script_variable_in_for_loop));\n\t\t    goto failed;\n\t\t}\n\n\t\tif (!valid_varname(arg, (int)varlen, FALSE))\n\t\t    goto failed;\n\t\tif (lookup_local(arg, varlen, NULL, cctx) == OK)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), arg);\n\t\t    goto failed;\n\t\t}\n\n\t\t// Reserve a variable to store \"var\".\n\t\twhere.wt_index = var_list ? idx + 1 : 0;\n\t\twhere.wt_variable = TRUE;\n\t\tif (lhs_type == &t_any)\n\t\t    lhs_type = item_type;\n\t\telse if (item_type != &t_unknown\n\t\t\t&& need_type_where(item_type, lhs_type, -1,\n\t\t\t\t\t    where, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto failed;\n\t\tvar_lvar = reserve_local(cctx, arg, varlen, TRUE, lhs_type);\n\t\tif (var_lvar == NULL)\n\t\t    // out of memory or used as an argument\n\t\t    goto failed;\n\n\t\tif (semicolon && idx == var_count - 1)\n\t\t    var_lvar->lv_type = vartype;\n\t\tgenerate_STORE(cctx, ISN_STORE, var_lvar->lv_idx, NULL);\n\t    }\n\n\t    if (*p == ',' || *p == ';')\n\t\t++p;\n\t    arg = skipwhite(p);\n\t    vim_free(name);\n\t}\n    }\n\n    return arg_end;\n\nfailed:\n    vim_free(name);\n    drop_scope(cctx);\n    return NULL;\n}\n\n/*\n * compile \"endfor\"\n */\n    char_u *\ncompile_endfor(char_u *arg, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*scope = cctx->ctx_scope;\n    forscope_T\t*forscope;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    if (scope == NULL || scope->se_type != FOR_SCOPE)\n    {\n\temsg(_(e_endfor_without_for));\n\treturn NULL;\n    }\n    forscope = &scope->se_u.se_for;\n    cctx->ctx_scope = scope->se_outer;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tunwind_locals(cctx, scope->se_local_count);\n\n\t// At end of \":for\" scope jump back to the FOR instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, forscope->fs_top_label);\n\n\t// Fill in the \"end\" label in the FOR statement so it can jump here.\n\t// In debug mode an ISN_DEBUG was inserted.\n\tisn = ((isn_T *)instr->ga_data) + forscope->fs_top_label\n\t\t\t\t+ (cctx->ctx_compile_type == CT_DEBUG ? 1 : 0);\n\tisn->isn_arg.forloop.for_end = instr->ga_len;\n\n\t// Fill in the \"end\" label any BREAK statements\n\tcompile_fill_jump_to_end(&forscope->fs_end_label, instr->ga_len, cctx);\n\n\t// Below the \":for\" scope drop the \"expr\" list from the stack.\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    return NULL;\n    }\n\n    vim_free(scope);\n\n    return arg;\n}\n\n/*\n * compile \"while expr\"\n *\n * Produces instructions:\n * top:  EVAL expr\t\tPush result of \"expr\"\n *       JUMP_IF_FALSE end\tjump if false\n *       ... body ...\n *       JUMP top\t\tJump back to repeat\n * end:\n *\n */\n    char_u *\ncompile_while(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    scope_T\t*scope;\n\n    scope = new_scope(cctx, WHILE_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n\n    // \"endwhile\" jumps back here, one before when profiling or using cmdmods\n    scope->se_u.se_while.ws_top_label = current_instr_idx(cctx);\n\n    // compile \"expr\"\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    if (!ends_excmd2(arg, skipwhite(p)))\n    {\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tif (bool_on_stack(cctx) == FAIL)\n\t    return FAIL;\n\n\t// CMDMOD_REV must come before the jump\n\tgenerate_undo_cmdmods(cctx);\n\n\t// \"while_end\" is set when \":endwhile\" is found\n\tif (compile_jump_to_end(&scope->se_u.se_while.ws_end_label,\n\t\t\t\t\t\t  JUMP_IF_FALSE, cctx) == FAIL)\n\t    return FAIL;\n    }\n\n    return p;\n}\n\n/*\n * compile \"endwhile\"\n */\n    char_u *\ncompile_endwhile(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n    if (scope == NULL || scope->se_type != WHILE_SCOPE)\n    {\n\temsg(_(e_endwhile_without_while));\n\treturn NULL;\n    }\n    cctx->ctx_scope = scope->se_outer;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tunwind_locals(cctx, scope->se_local_count);\n\n#ifdef FEAT_PROFILE\n\t// count the endwhile before jumping\n\tmay_generate_prof_end(cctx, cctx->ctx_lnum);\n#endif\n\n\t// At end of \":for\" scope jump back to the FOR instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, scope->se_u.se_while.ws_top_label);\n\n\t// Fill in the \"end\" label in the WHILE statement so it can jump here.\n\t// And in any jumps for \":break\"\n\tcompile_fill_jump_to_end(&scope->se_u.se_while.ws_end_label,\n\t\t\t\t\t\t\t  instr->ga_len, cctx);\n    }\n\n    vim_free(scope);\n\n    return arg;\n}\n\n/*\n * compile \"continue\"\n */\n    char_u *\ncompile_continue(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    int\t\ttry_scopes = 0;\n    int\t\tloop_label;\n\n    for (;;)\n    {\n\tif (scope == NULL)\n\t{\n\t    emsg(_(e_continue_without_while_or_for));\n\t    return NULL;\n\t}\n\tif (scope->se_type == FOR_SCOPE)\n\t{\n\t    loop_label = scope->se_u.se_for.fs_top_label;\n\t    break;\n\t}\n\tif (scope->se_type == WHILE_SCOPE)\n\t{\n\t    loop_label = scope->se_u.se_while.ws_top_label;\n\t    break;\n\t}\n\tif (scope->se_type == TRY_SCOPE)\n\t    ++try_scopes;\n\tscope = scope->se_outer;\n    }\n\n    if (try_scopes > 0)\n\t// Inside one or more try/catch blocks we first need to jump to the\n\t// \"finally\" or \"endtry\" to cleanup.\n\tgenerate_TRYCONT(cctx, try_scopes, loop_label);\n    else\n\t// Jump back to the FOR or WHILE instruction.\n\tgenerate_JUMP(cctx, JUMP_ALWAYS, loop_label);\n\n    return arg;\n}\n\n/*\n * compile \"break\"\n */\n    char_u *\ncompile_break(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    int\t\ttry_scopes = 0;\n    endlabel_T\t**el;\n\n    for (;;)\n    {\n\tif (scope == NULL)\n\t{\n\t    emsg(_(e_break_without_while_or_for));\n\t    return NULL;\n\t}\n\tif (scope->se_type == FOR_SCOPE)\n\t{\n\t    el = &scope->se_u.se_for.fs_end_label;\n\t    break;\n\t}\n\tif (scope->se_type == WHILE_SCOPE)\n\t{\n\t    el = &scope->se_u.se_while.ws_end_label;\n\t    break;\n\t}\n\tif (scope->se_type == TRY_SCOPE)\n\t    ++try_scopes;\n\tscope = scope->se_outer;\n    }\n\n    if (try_scopes > 0)\n\t// Inside one or more try/catch blocks we first need to jump to the\n\t// \"finally\" or \"endtry\" to cleanup.  Then come to the next JUMP\n\t// intruction, which we don't know the index of yet.\n\tgenerate_TRYCONT(cctx, try_scopes, cctx->ctx_instr.ga_len + 1);\n\n    // Jump to the end of the FOR or WHILE loop.  The instruction index will be\n    // filled in later.\n    if (compile_jump_to_end(el, JUMP_ALWAYS, cctx) == FAIL)\n\treturn FAIL;\n\n    return arg;\n}\n\n/*\n * compile \"{\" start of block\n */\n    char_u *\ncompile_block(char_u *arg, cctx_T *cctx)\n{\n    if (new_scope(cctx, BLOCK_SCOPE) == NULL)\n\treturn NULL;\n    return skipwhite(arg + 1);\n}\n\n/*\n * compile end of block: drop one scope\n */\n    void\ncompile_endblock(cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n\n    cctx->ctx_scope = scope->se_outer;\n    unwind_locals(cctx, scope->se_local_count);\n    vim_free(scope);\n}\n\n/*\n * Compile \"try\".\n * Creates a new scope for the try-endtry, pointing to the first catch and\n * finally.\n * Creates another scope for the \"try\" block itself.\n * TRY instruction sets up exception handling at runtime.\n *\n *\t\"try\"\n *\t    TRY -> catch1, -> finally  push trystack entry\n *\t    ... try block\n *\t\"throw {exception}\"\n *\t    EVAL {exception}\n *\t    THROW\t\tcreate exception\n *\t    ... try block\n *\t\" catch {expr}\"\n *\t    JUMP -> finally\n * catch1:  PUSH exception\n *\t    EVAL {expr}\n *\t    MATCH\n *\t    JUMP nomatch -> catch2\n *\t    CATCH   remove exception\n *\t    ... catch block\n *\t\" catch\"\n *\t    JUMP -> finally\n * catch2:  CATCH   remove exception\n *\t    ... catch block\n *\t\" finally\"\n * finally:\n *\t    ... finally block\n *\t\" endtry\"\n *\t    ENDTRY  pop trystack entry, may rethrow\n */\n    char_u *\ncompile_try(char_u *arg, cctx_T *cctx)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    scope_T\t*try_scope;\n    scope_T\t*scope;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // scope that holds the jumps that go to catch/finally/endtry\n    try_scope = new_scope(cctx, TRY_SCOPE);\n    if (try_scope == NULL)\n\treturn NULL;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tisn_T\t*isn;\n\n\t// \"try_catch\" is set when the first \":catch\" is found or when no catch\n\t// is found and \":finally\" is found.\n\t// \"try_finally\" is set when \":finally\" is found\n\t// \"try_endtry\" is set when \":endtry\" is found\n\ttry_scope->se_u.se_try.ts_try_label = instr->ga_len;\n\tif ((isn = generate_instr(cctx, ISN_TRY)) == NULL)\n\t    return NULL;\n\tisn->isn_arg.tryref.try_ref = ALLOC_CLEAR_ONE(tryref_T);\n\tif (isn->isn_arg.tryref.try_ref == NULL)\n\t    return NULL;\n    }\n\n    // scope for the try block itself\n    scope = new_scope(cctx, BLOCK_SCOPE);\n    if (scope == NULL)\n\treturn NULL;\n\n    return arg;\n}\n\n/*\n * Compile \"catch {expr}\".\n */\n    char_u *\ncompile_catch(char_u *arg, cctx_T *cctx UNUSED)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*p;\n    isn_T\t*isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :try or :catch\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\temsg(_(e_catch_without_try));\n\treturn NULL;\n    }\n\n    if (scope->se_u.se_try.ts_caught_all)\n    {\n\temsg(_(e_catch_unreachable_after_catch_all));\n\treturn NULL;\n    }\n    if (!cctx->ctx_had_return)\n\tscope->se_u.se_try.ts_no_return = TRUE;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n#ifdef FEAT_PROFILE\n\t// the profile-start should be after the jump\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& instr->ga_len > 0\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t    --instr->ga_len;\n#endif\n\t// Jump from end of previous block to :finally or :endtry\n\tif (compile_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t    JUMP_ALWAYS, cctx) == FAIL)\n\t    return NULL;\n\n\t// End :try or :catch scope: set value in ISN_TRY instruction\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n\tif (isn->isn_arg.tryref.try_ref->try_catch == 0)\n\t    isn->isn_arg.tryref.try_ref->try_catch = instr->ga_len;\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Previous catch without match jumps here\n\t    isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t{\n\t    // a \"throw\" that jumps here needs to be counted\n\t    generate_instr(cctx, ISN_PROF_END);\n\t    // the \"catch\" is also counted\n\t    generate_instr(cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx->ctx_compile_type == CT_DEBUG)\n\t    generate_instr_debug(cctx);\n    }\n\n    p = skipwhite(arg);\n    if (ends_excmd2(arg, p))\n    {\n\tscope->se_u.se_try.ts_caught_all = TRUE;\n\tscope->se_u.se_try.ts_catch_label = 0;\n    }\n    else\n    {\n\tchar_u *end;\n\tchar_u *pat;\n\tchar_u *tofree = NULL;\n\tint\tdropped = 0;\n\tint\tlen;\n\n\t// Push v:exception, push {expr} and MATCH\n\tgenerate_instr_type(cctx, ISN_PUSHEXC, &t_string);\n\n\tend = skip_regexp_ex(p + 1, *p, TRUE, &tofree, &dropped, NULL);\n\tif (*end != *p)\n\t{\n\t    semsg(_(e_separator_mismatch_str), p);\n\t    vim_free(tofree);\n\t    return NULL;\n\t}\n\tif (tofree == NULL)\n\t    len = (int)(end - (p + 1));\n\telse\n\t    len = (int)(end - tofree);\n\tpat = vim_strnsave(tofree == NULL ? p + 1 : tofree, len);\n\tvim_free(tofree);\n\tp += len + 2 + dropped;\n\tif (pat == NULL)\n\t    return NULL;\n\tif (generate_PUSHS(cctx, &pat) == FAIL)\n\t    return NULL;\n\n\tif (generate_COMPARE(cctx, EXPR_MATCH, FALSE) == FAIL)\n\t    return NULL;\n\n\tscope->se_u.se_try.ts_catch_label = instr->ga_len;\n\tif (generate_JUMP(cctx, JUMP_IF_FALSE, 0) == FAIL)\n\t    return NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_CATCH) == NULL)\n\treturn NULL;\n\n    if (new_scope(cctx, BLOCK_SCOPE) == NULL)\n\treturn NULL;\n    return p;\n}\n\n    char_u *\ncompile_finally(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*isn;\n    int\t\tthis_instr;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :try or :catch\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\temsg(_(e_finally_without_try));\n\treturn NULL;\n    }\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// End :catch or :finally scope: set value in ISN_TRY instruction\n\tisn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n\tif (isn->isn_arg.tryref.try_ref->try_finally != 0)\n\t{\n\t    emsg(_(e_multiple_finally));\n\t    return NULL;\n\t}\n\n\tthis_instr = instr->ga_len;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& ((isn_T *)instr->ga_data)[this_instr - 1]\n\t\t\t\t\t\t   .isn_type == ISN_PROF_START)\n\t{\n\t    // jump to the profile start of the \"finally\"\n\t    --this_instr;\n\n\t    // jump to the profile end above it\n\t    if (this_instr > 0 && ((isn_T *)instr->ga_data)[this_instr - 1]\n\t\t\t\t\t\t     .isn_type == ISN_PROF_END)\n\t\t--this_instr;\n\t}\n#endif\n\n\t// Fill in the \"end\" label in jumps at the end of the blocks.\n\tcompile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t\t     this_instr, cctx);\n\n\t// If there is no :catch then an exception jumps to :finally.\n\tif (isn->isn_arg.tryref.try_ref->try_catch == 0)\n\t    isn->isn_arg.tryref.try_ref->try_catch = this_instr;\n\tisn->isn_arg.tryref.try_ref->try_finally = this_instr;\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Previous catch without match jumps here\n\t    isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = this_instr;\n\t    scope->se_u.se_try.ts_catch_label = 0;\n\t}\n\tscope->se_u.se_try.ts_has_finally = TRUE;\n\tif (generate_instr(cctx, ISN_FINALLY) == NULL)\n\t    return NULL;\n    }\n\n    return arg;\n}\n\n    char_u *\ncompile_endtry(char_u *arg, cctx_T *cctx)\n{\n    scope_T\t*scope = cctx->ctx_scope;\n    garray_T\t*instr = &cctx->ctx_instr;\n    isn_T\t*try_isn;\n\n    if (misplaced_cmdmod(cctx))\n\treturn NULL;\n\n    // end block scope from :catch or :finally\n    if (scope != NULL && scope->se_type == BLOCK_SCOPE)\n\tcompile_endblock(cctx);\n    scope = cctx->ctx_scope;\n\n    // Error if not in a :try scope\n    if (scope == NULL || scope->se_type != TRY_SCOPE)\n    {\n\tif (scope == NULL)\n\t    emsg(_(e_endtry_without_try));\n\telse if (scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_endif));\n\treturn NULL;\n    }\n\n    try_isn = ((isn_T *)instr->ga_data) + scope->se_u.se_try.ts_try_label;\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tif (try_isn->isn_arg.tryref.try_ref->try_catch == 0\n\t\t\t  && try_isn->isn_arg.tryref.try_ref->try_finally == 0)\n\t{\n\t    emsg(_(e_missing_catch_or_finally));\n\t    return NULL;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE\n\t\t&& ((isn_T *)instr->ga_data)[instr->ga_len - 1]\n\t\t\t\t\t\t.isn_type == ISN_PROF_START)\n\t    // move the profile start after \"endtry\" so that it's not counted when\n\t    // the exception is rethrown.\n\t    --instr->ga_len;\n#endif\n\n\t// Fill in the \"end\" label in jumps at the end of the blocks, if not\n\t// done by \":finally\".\n\tcompile_fill_jump_to_end(&scope->se_u.se_try.ts_end_label,\n\t\t\t\t\t\t\t  instr->ga_len, cctx);\n\n\tif (scope->se_u.se_try.ts_catch_label != 0)\n\t{\n\t    // Last catch without match jumps here\n\t    isn_T *isn = ((isn_T *)instr->ga_data)\n\t\t\t\t\t   + scope->se_u.se_try.ts_catch_label;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n    }\n\n    // If there is a finally clause that ends in return then we will return.\n    // If one of the blocks didn't end in \"return\" or we did not catch all\n    // exceptions reset the had_return flag.\n    if (!(scope->se_u.se_try.ts_has_finally && cctx->ctx_had_return)\n\t    && (scope->se_u.se_try.ts_no_return\n\t\t|| !scope->se_u.se_try.ts_caught_all))\n\tcctx->ctx_had_return = FALSE;\n\n    compile_endblock(cctx);\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\t// End :catch or :finally scope: set instruction index in ISN_TRY\n\t// instruction\n\ttry_isn->isn_arg.tryref.try_ref->try_endtry = instr->ga_len;\n\tif (generate_instr(cctx, ISN_ENDTRY) == NULL)\n\t    return NULL;\n#ifdef FEAT_PROFILE\n\tif (cctx->ctx_compile_type == CT_PROFILE)\n\t    generate_instr(cctx, ISN_PROF_START);\n#endif\n    }\n    return arg;\n}\n\n/*\n * compile \"throw {expr}\"\n */\n    char_u *\ncompile_throw(char_u *arg, cctx_T *cctx UNUSED)\n{\n    char_u *p = skipwhite(arg);\n\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn p;\n    if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\treturn NULL;\n    if (generate_instr_drop(cctx, ISN_THROW, 1) == NULL)\n\treturn NULL;\n\n    return p;\n}\n\n    char_u *\ncompile_eval(char_u *arg, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    int\t\tname_only;\n    long\tlnum = SOURCING_LNUM;\n\n    // find_ex_command() will consider a variable name an expression, assuming\n    // that something follows on the next line.  Check that something actually\n    // follows, otherwise it's probably a misplaced command.\n    name_only = cmd_is_name_only(arg);\n\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    if (name_only && lnum == SOURCING_LNUM)\n    {\n\tsemsg(_(e_expression_without_effect_str), arg);\n\treturn NULL;\n    }\n\n    // drop the result\n    generate_instr_drop(cctx, ISN_DROP, 1);\n\n    return skipwhite(p);\n}\n\n/*\n * compile \"echo expr\"\n * compile \"echomsg expr\"\n * compile \"echoerr expr\"\n * compile \"echoconsole expr\"\n * compile \"execute expr\"\n */\n    char_u *\ncompile_mult_expr(char_u *arg, int cmdidx, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    char_u\t*prev = arg;\n    char_u\t*expr_start;\n    int\t\tcount = 0;\n    int\t\tstart_ctx_lnum = cctx->ctx_lnum;\n    type_T\t*type;\n\n    for (;;)\n    {\n\tif (ends_excmd2(prev, p))\n\t    break;\n\texpr_start = p;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // check for non-void type\n\t    type = get_type_on_stack(cctx, 0);\n\t    if (type->tt_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), expr_start);\n\t\treturn NULL;\n\t    }\n\t}\n\n\t++count;\n\tprev = p;\n\tp = skipwhite(p);\n    }\n\n    if (count > 0)\n    {\n\tlong save_lnum = cctx->ctx_lnum;\n\n\t// Use the line number where the command started.\n\tcctx->ctx_lnum = start_ctx_lnum;\n\n\tif (cmdidx == CMD_echo || cmdidx == CMD_echon)\n\t    generate_ECHO(cctx, cmdidx == CMD_echo, count);\n\telse if (cmdidx == CMD_execute)\n\t    generate_MULT_EXPR(cctx, ISN_EXECUTE, count);\n\telse if (cmdidx == CMD_echomsg)\n\t    generate_MULT_EXPR(cctx, ISN_ECHOMSG, count);\n\telse if (cmdidx == CMD_echoconsole)\n\t    generate_MULT_EXPR(cctx, ISN_ECHOCONSOLE, count);\n\telse\n\t    generate_MULT_EXPR(cctx, ISN_ECHOERR, count);\n\n\tcctx->ctx_lnum = save_lnum;\n    }\n    return p;\n}\n\n/*\n * If \"eap\" has a range that is not a constant generate an ISN_RANGE\n * instruction to compute it and return OK.\n * Otherwise return FAIL, the caller must deal with any range.\n */\n    static int\ncompile_variable_range(exarg_T *eap, cctx_T *cctx)\n{\n    char_u *range_end = skip_range(eap->cmd, TRUE, NULL);\n    char_u *p = skipdigits(eap->cmd);\n\n    if (p == range_end)\n\treturn FAIL;\n    return generate_RANGE(cctx, vim_strnsave(eap->cmd, range_end - eap->cmd));\n}\n\n/*\n * :put r\n * :put ={expr}\n */\n    char_u *\ncompile_put(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u\t*line = arg;\n    linenr_T\tlnum;\n    char\t*errormsg;\n    int\t\tabove = eap->forceit;\n\n    eap->regname = *line;\n\n    if (eap->regname == '=')\n    {\n\tchar_u *p = skipwhite(line + 1);\n\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tline = p;\n    }\n    else if (eap->regname != NUL)\n\t++line;\n\n    if (compile_variable_range(eap, cctx) == OK)\n    {\n\tlnum = above ? LNUM_VARIABLE_RANGE_ABOVE : LNUM_VARIABLE_RANGE;\n    }\n    else\n    {\n\t// Either no range or a number.\n\t// \"errormsg\" will not be set because the range is ADDR_LINES.\n\tif (parse_cmd_address(eap, &errormsg, FALSE) == FAIL)\n\t    // cannot happen\n\t    return NULL;\n\tif (eap->addr_count == 0)\n\t    lnum = -1;\n\telse\n\t    lnum = eap->line2;\n\tif (above)\n\t    --lnum;\n    }\n\n    generate_PUT(cctx, eap->regname, lnum);\n    return line;\n}\n\n/*\n * A command that is not compiled, execute with legacy code.\n */\n    char_u *\ncompile_exec(char_u *line_arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u\t*line = line_arg;\n    char_u\t*p;\n    int\t\thas_expr = FALSE;\n    char_u\t*nextcmd = (char_u *)\"\";\n    char_u\t*tofree = NULL;\n    char_u\t*cmd_arg = NULL;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\tgoto theend;\n\n    // If there was a prececing command modifier, drop it and include it in the\n    // EXEC command.\n    if (cctx->ctx_has_cmdmod)\n    {\n\tgarray_T\t*instr = &cctx->ctx_instr;\n\tisn_T\t\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\tif (isn->isn_type == ISN_CMDMOD)\n\t{\n\t    vim_regfree(isn->isn_arg.cmdmod.cf_cmdmod\n\t\t\t\t\t       ->cmod_filter_regmatch.regprog);\n\t    vim_free(isn->isn_arg.cmdmod.cf_cmdmod);\n\t    --instr->ga_len;\n\t    cctx->ctx_has_cmdmod = FALSE;\n\t}\n    }\n\n    if (eap->cmdidx >= 0 && eap->cmdidx < CMD_SIZE)\n    {\n\tlong\targt = eap->argt;\n\tint\tusefilter = FALSE;\n\n\thas_expr = argt & (EX_XFILE | EX_EXPAND);\n\n\t// If the command can be followed by a bar, find the bar and truncate\n\t// it, so that the following command can be compiled.\n\t// The '|' is overwritten with a NUL, it is put back below.\n\tif ((eap->cmdidx == CMD_write || eap->cmdidx == CMD_read)\n\t\t\t\t\t\t\t   && *eap->arg == '!')\n\t    // :w !filter or :r !filter or :r! filter\n\t    usefilter = TRUE;\n\tif ((argt & EX_TRLBAR) && !usefilter)\n\t{\n\t    eap->argt = argt;\n\t    separate_nextcmd(eap, TRUE);\n\t    if (eap->nextcmd != NULL)\n\t\tnextcmd = eap->nextcmd;\n\t}\n\telse if (eap->cmdidx == CMD_wincmd)\n\t{\n\t    p = eap->arg;\n\t    if (*p != NUL)\n\t\t++p;\n\t    if (*p == 'g' || *p == Ctrl_G)\n\t\t++p;\n\t    p = skipwhite(p);\n\t    if (*p == '|')\n\t    {\n\t\t*p = NUL;\n\t\tnextcmd = p + 1;\n\t    }\n\t}\n\telse if (eap->cmdidx == CMD_command || eap->cmdidx == CMD_autocmd)\n\t{\n\t    // If there is a trailing '{' read lines until the '}'\n\t    p = eap->arg + STRLEN(eap->arg) - 1;\n\t    while (p > eap->arg && VIM_ISWHITE(*p))\n\t\t--p;\n\t    if (*p == '{')\n\t    {\n\t\texarg_T ea;\n\t\tint\tflags = 0;  // unused\n\t\tint\tstart_lnum = SOURCING_LNUM;\n\n\t\tCLEAR_FIELD(ea);\n\t\tea.arg = eap->arg;\n\t\tfill_exarg_from_cctx(&ea, cctx);\n\t\t(void)may_get_cmd_block(&ea, p, &tofree, &flags);\n\t\tif (tofree != NULL)\n\t\t{\n\t\t    *p = NUL;\n\t\t    line = concat_str(line, tofree);\n\t\t    if (line == NULL)\n\t\t\tgoto theend;\n\t\t    vim_free(tofree);\n\t\t    tofree = line;\n\t\t    SOURCING_LNUM = start_lnum;\n\t\t}\n\t    }\n\t}\n    }\n\n    if (eap->cmdidx == CMD_syntax && STRNCMP(eap->arg, \"include \", 8) == 0)\n    {\n\t// expand filename in \"syntax include [@group] filename\"\n\thas_expr = TRUE;\n\teap->arg = skipwhite(eap->arg + 7);\n\tif (*eap->arg == '@')\n\t    eap->arg = skiptowhite(eap->arg);\n    }\n\n    if ((eap->cmdidx == CMD_global || eap->cmdidx == CMD_vglobal)\n\t\t\t\t\t\t       && STRLEN(eap->arg) > 4)\n    {\n\tint delim = *eap->arg;\n\n\tp = skip_regexp_ex(eap->arg + 1, delim, TRUE, NULL, NULL, NULL);\n\tif (*p == delim)\n\t    cmd_arg = p + 1;\n    }\n\n    if (eap->cmdidx == CMD_folddoopen || eap->cmdidx == CMD_folddoclosed)\n\tcmd_arg = eap->arg;\n\n    if (cmd_arg != NULL)\n    {\n\texarg_T nea;\n\n\tCLEAR_FIELD(nea);\n\tnea.cmd = cmd_arg;\n\tp = find_ex_command(&nea, NULL, lookup_scriptitem, NULL);\n\tif (nea.cmdidx < CMD_SIZE)\n\t{\n\t    has_expr = excmd_get_argt(nea.cmdidx) & (EX_XFILE | EX_EXPAND);\n\t    if (has_expr)\n\t\teap->arg = skiptowhite(eap->arg);\n\t}\n    }\n\n    if (has_expr && (p = (char_u *)strstr((char *)eap->arg, \"`=\")) != NULL)\n    {\n\tint\tcount = 0;\n\tchar_u\t*start = skipwhite(line);\n\n\t// :cmd xxx`=expr1`yyy`=expr2`zzz\n\t// PUSHS \":cmd xxx\"\n\t// eval expr1\n\t// PUSHS \"yyy\"\n\t// eval expr2\n\t// PUSHS \"zzz\"\n\t// EXECCONCAT 5\n\tfor (;;)\n\t{\n\t    if (p > start)\n\t    {\n\t\tchar_u *val = vim_strnsave(start, p - start);\n\n\t\tgenerate_PUSHS(cctx, &val);\n\t\t++count;\n\t    }\n\t    p += 2;\n\t    if (compile_expr0(&p, cctx) == FAIL)\n\t\treturn NULL;\n\t    may_generate_2STRING(-1, TRUE, cctx);\n\t    ++count;\n\t    p = skipwhite(p);\n\t    if (*p != '`')\n\t    {\n\t\temsg(_(e_missing_backtick));\n\t\treturn NULL;\n\t    }\n\t    start = p + 1;\n\n\t    p = (char_u *)strstr((char *)start, \"`=\");\n\t    if (p == NULL)\n\t    {\n\t\tif (*skipwhite(start) != NUL)\n\t\t{\n\t\t    char_u *val = vim_strsave(start);\n\n\t\t    generate_PUSHS(cctx, &val);\n\t\t    ++count;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tgenerate_EXECCONCAT(cctx, count);\n    }\n    else\n\tgenerate_EXEC_copy(cctx, ISN_EXEC, line);\n\ntheend:\n    if (*nextcmd != NUL)\n    {\n\t// the parser expects a pointer to the bar, put it back\n\t--nextcmd;\n\t*nextcmd = '|';\n    }\n    vim_free(tofree);\n\n    return nextcmd;\n}\n\n/*\n * A script command with heredoc, e.g.\n *\truby << EOF\n *\t   command\n *\tEOF\n * Has been turned into one long line with NL characters by\n * get_function_body():\n *\truby << EOF<NL>   command<NL>EOF\n */\n    char_u *\ncompile_script(char_u *line, cctx_T *cctx)\n{\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tisn_T\t*isn;\n\n\tif ((isn = generate_instr(cctx, ISN_EXEC_SPLIT)) == NULL)\n\t    return NULL;\n\tisn->isn_arg.string = vim_strsave(line);\n    }\n    return (char_u *)\"\";\n}\n\n\n/*\n * :s/pat/repl/\n */\n    char_u *\ncompile_substitute(char_u *arg, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *cmd = eap->arg;\n    char_u  *expr = (char_u *)strstr((char *)cmd, \"\\\\=\");\n\n    if (expr != NULL)\n    {\n\tint delimiter = *cmd++;\n\n\t// There is a \\=expr, find it in the substitute part.\n\tcmd = skip_regexp_ex(cmd, delimiter, magic_isset(), NULL, NULL, NULL);\n\tif (cmd[0] == delimiter && cmd[1] == '\\\\' && cmd[2] == '=')\n\t{\n\t    garray_T\tsave_ga = cctx->ctx_instr;\n\t    char_u\t*end;\n\t    int\t\texpr_res;\n\t    int\t\ttrailing_error;\n\t    int\t\tinstr_count;\n\t    isn_T\t*instr;\n\t    isn_T\t*isn;\n\n\t    cmd += 3;\n\t    end = skip_substitute(cmd, delimiter);\n\n\t    // Temporarily reset the list of instructions so that the jump\n\t    // labels are correct.\n\t    cctx->ctx_instr.ga_len = 0;\n\t    cctx->ctx_instr.ga_maxlen = 0;\n\t    cctx->ctx_instr.ga_data = NULL;\n\t    expr_res = compile_expr0(&cmd, cctx);\n\t    if (end[-1] == NUL)\n\t\tend[-1] = delimiter;\n\t    cmd = skipwhite(cmd);\n\t    trailing_error = *cmd != delimiter && *cmd != NUL;\n\n\t    if (expr_res == FAIL || trailing_error\n\t\t\t\t       || GA_GROW_FAILS(&cctx->ctx_instr, 1))\n\t    {\n\t\tif (trailing_error)\n\t\t    semsg(_(e_trailing_characters_str), cmd);\n\t\tclear_instr_ga(&cctx->ctx_instr);\n\t\tcctx->ctx_instr = save_ga;\n\t\treturn NULL;\n\t    }\n\n\t    // Move the generated instructions into the ISN_SUBSTITUTE\n\t    // instructions, then restore the list of instructions before\n\t    // adding the ISN_SUBSTITUTE instruction.\n\t    instr_count = cctx->ctx_instr.ga_len;\n\t    instr = cctx->ctx_instr.ga_data;\n\t    instr[instr_count].isn_type = ISN_FINISH;\n\n\t    cctx->ctx_instr = save_ga;\n\t    if ((isn = generate_instr(cctx, ISN_SUBSTITUTE)) == NULL)\n\t    {\n\t\tint idx;\n\n\t\tfor (idx = 0; idx < instr_count; ++idx)\n\t\t    delete_instr(instr + idx);\n\t\tvim_free(instr);\n\t\treturn NULL;\n\t    }\n\t    isn->isn_arg.subs.subs_cmd = vim_strsave(arg);\n\t    isn->isn_arg.subs.subs_instr = instr;\n\n\t    // skip over flags\n\t    if (*end == '&')\n\t\t++end;\n\t    while (ASCII_ISALPHA(*end) || *end == '#')\n\t\t++end;\n\t    return end;\n\t}\n    }\n\n    return compile_exec(arg, eap, cctx);\n}\n\n    char_u *\ncompile_redir(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    char_u  *arg = eap->arg;\n    lhs_T   *lhs = &cctx->ctx_redir_lhs;\n\n    if (lhs->lhs_name != NULL)\n    {\n\tif (STRNCMP(arg, \"END\", 3) == 0)\n\t{\n\t    if (lhs->lhs_append)\n\t    {\n\t\t// First load the current variable value.\n\t\tif (compile_load_lhs_with_index(lhs, lhs->lhs_whole,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    // Gets the redirected text and put it on the stack, then store it\n\t    // in the variable.\n\t    generate_instr_type(cctx, ISN_REDIREND, &t_string);\n\n\t    if (lhs->lhs_append)\n\t\tgenerate_CONCAT(cctx, 2);\n\n\t    if (lhs->lhs_has_index)\n\t    {\n\t\t// Use the info in \"lhs\" to store the value at the index in the\n\t\t// list or dict.\n\t\tif (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE,\n\t\t\t\t\t\t      &t_string, cctx) == FAIL)\n\t\t    return NULL;\n\t    }\n\t    else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL)\n\t\treturn NULL;\n\n\t    VIM_CLEAR(lhs->lhs_name);\n\t    VIM_CLEAR(lhs->lhs_whole);\n\t    return arg + 3;\n\t}\n\temsg(_(e_cannot_nest_redir));\n\treturn NULL;\n    }\n\n    if (arg[0] == '=' && arg[1] == '>')\n    {\n\tint\t    append = FALSE;\n\n\t// redirect to a variable is compiled\n\targ += 2;\n\tif (*arg == '>')\n\t{\n\t    ++arg;\n\t    append = TRUE;\n\t}\n\targ = skipwhite(arg);\n\n\tif (compile_assign_lhs(arg, lhs, CMD_redir,\n\t\t\t\t\t FALSE, FALSE, FALSE, 1, cctx) == FAIL)\n\t    return NULL;\n\tif (need_type(&t_string, lhs->lhs_member_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return NULL;\n\tgenerate_instr(cctx, ISN_REDIRSTART);\n\tlhs->lhs_append = append;\n\tif (lhs->lhs_has_index)\n\t{\n\t    lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total);\n\t    if (lhs->lhs_whole == NULL)\n\t\treturn NULL;\n\t}\n\n\treturn arg + lhs->lhs_varlen_total;\n    }\n\n    // other redirects are handled like at script level\n    return compile_exec(line, eap, cctx);\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    char_u *\ncompile_cexpr(char_u *line, exarg_T *eap, cctx_T *cctx)\n{\n    isn_T\t*isn;\n    char_u\t*p;\n\n    isn = generate_instr(cctx, ISN_CEXPR_AUCMD);\n    if (isn == NULL)\n\treturn NULL;\n    isn->isn_arg.number = eap->cmdidx;\n\n    p = eap->arg;\n    if (compile_expr0(&p, cctx) == FAIL)\n\treturn NULL;\n\n    isn = generate_instr(cctx, ISN_CEXPR_CORE);\n    if (isn == NULL)\n\treturn NULL;\n    isn->isn_arg.cexpr.cexpr_ref = ALLOC_ONE(cexprref_T);\n    if (isn->isn_arg.cexpr.cexpr_ref == NULL)\n\treturn NULL;\n    isn->isn_arg.cexpr.cexpr_ref->cer_cmdidx = eap->cmdidx;\n    isn->isn_arg.cexpr.cexpr_ref->cer_forceit = eap->forceit;\n    isn->isn_arg.cexpr.cexpr_ref->cer_cmdline = vim_strsave(skipwhite(line));\n\n    return p;\n}\n#endif\n\n/*\n * Compile \"return [expr]\".\n * When \"legacy\" is TRUE evaluate [expr] with legacy syntax\n */\n    char_u *\ncompile_return(char_u *arg, int check_return_type, int legacy, cctx_T *cctx)\n{\n    char_u\t*p = arg;\n    type_T\t*stack_type;\n\n    if (*p != NUL && *p != '|' && *p != '\\n')\n    {\n\t// For a lambda, \"return expr\" is always used, also when \"expr\" results\n\t// in a void.\n\tif (cctx->ctx_ufunc->uf_ret_type->tt_type == VAR_VOID\n\t\t&& (cctx->ctx_ufunc->uf_flags & FC_LAMBDA) == 0)\n\t{\n\t    emsg(_(e_returning_value_in_function_without_return_type));\n\t    return NULL;\n\t}\n\tif (legacy)\n\t{\n\t    int save_flags = cmdmod.cmod_flags;\n\n\t    generate_LEGACY_EVAL(cctx, p);\n\t    if (need_type(&t_any, cctx->ctx_ufunc->uf_ret_type, -1,\n\t\t\t\t\t\t0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn NULL;\n\t    cmdmod.cmod_flags |= CMOD_LEGACY;\n\t    (void)skip_expr(&p, NULL);\n\t    cmdmod.cmod_flags = save_flags;\n\t}\n\telse\n\t{\n\t    // compile return argument into instructions\n\t    if (compile_expr0(&p, cctx) == FAIL)\n\t\treturn NULL;\n\t}\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // \"check_return_type\" with uf_ret_type set to &t_unknown is used\n\t    // for an inline function without a specified return type.  Set the\n\t    // return type here.\n\t    stack_type = get_type_on_stack(cctx, 0);\n\t    if ((check_return_type && (cctx->ctx_ufunc->uf_ret_type == NULL\n\t\t\t\t|| cctx->ctx_ufunc->uf_ret_type == &t_unknown))\n\t\t    || (!check_return_type\n\t\t\t\t&& cctx->ctx_ufunc->uf_ret_type == &t_unknown))\n\t    {\n\t\tcctx->ctx_ufunc->uf_ret_type = stack_type;\n\t    }\n\t    else\n\t    {\n\t\tif (need_type(stack_type, cctx->ctx_ufunc->uf_ret_type, -1,\n\t\t\t\t\t\t0, cctx, FALSE, FALSE) == FAIL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\t// \"check_return_type\" cannot be TRUE, only used for a lambda which\n\t// always has an argument.\n\tif (cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_VOID\n\t\t&& cctx->ctx_ufunc->uf_ret_type->tt_type != VAR_UNKNOWN)\n\t{\n\t    emsg(_(e_missing_return_value));\n\t    return NULL;\n\t}\n\n\t// No argument, return zero.\n\tgenerate_PUSHNR(cctx, 0);\n    }\n\n    // Undo any command modifiers.\n    generate_undo_cmdmods(cctx);\n\n    if (cctx->ctx_skip != SKIP_YES && generate_instr(cctx, ISN_RETURN) == NULL)\n\treturn NULL;\n\n    // \"return val | endif\" is possible\n    return skipwhite(p);\n}\n\n/*\n * Check if the separator for a :global or :substitute command is OK.\n */\n    int\ncheck_global_and_subst(char_u *cmd, char_u *arg)\n{\n    if (arg == cmd + 1 && vim_strchr((char_u *)\":-.\", *arg) != NULL)\n    {\n\tsemsg(_(e_separator_not_supported_str), arg);\n\treturn FAIL;\n    }\n    if (VIM_ISWHITE(cmd[1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_separator_str), cmd);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n\n#endif  // defined(FEAT_EVAL)\n"], "filenames": ["src/testdir/test_vim9_cmd.vim", "src/version.c", "src/vim9cmds.c"], "buggy_code_start_loc": [1743, 737, 94], "buggy_code_end_loc": [1749, 737, 94], "fixing_code_start_loc": [1742, 738, 95], "fixing_code_end_loc": [1756, 740, 101], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0212.", "other": {"cve": {"id": "CVE-2022-2816", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-15T22:15:08.293", "lastModified": "2023-05-03T12:16:01.593", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0212."}, {"lang": "es", "value": "Una Lectura Fuera de L\u00edmites en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0212."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0212", "matchCriteriaId": "10161268-4163-466C-AA35-3D9C1FD216C4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/dbdd16b62560413abcc3c8e893cc3010ccf31666", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/e2a83037-fcf9-4218-b2b9-b7507dacde58", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CHFAR6OY6G77M6GXCJT75A4KITLNR6GO/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/dbdd16b62560413abcc3c8e893cc3010ccf31666"}}