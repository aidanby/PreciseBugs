{"buggy_code": ["# frozen_string_literal: false\n#\n# httprequest.rb -- HTTPRequest Class\n#\n# Author: IPR -- Internet Programming with Ruby -- writers\n# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou\n# Copyright (c) 2002 Internet Programming with Ruby writers. All rights\n# reserved.\n#\n# $IPR: httprequest.rb,v 1.64 2003/07/13 17:18:22 gotoyuzo Exp $\n\nrequire 'fiber'\nrequire 'uri'\nrequire_relative 'httpversion'\nrequire_relative 'httpstatus'\nrequire_relative 'httputils'\nrequire_relative 'cookie'\n\nmodule WEBrick\n\n  ##\n  # An HTTP request.  This is consumed by service and do_* methods in\n  # WEBrick servlets\n\n  class HTTPRequest\n\n    BODY_CONTAINABLE_METHODS = [ \"POST\", \"PUT\" ] # :nodoc:\n\n    # :section: Request line\n\n    ##\n    # The complete request line such as:\n    #\n    #   GET / HTTP/1.1\n\n    attr_reader :request_line\n\n    ##\n    # The request method, GET, POST, PUT, etc.\n\n    attr_reader :request_method\n\n    ##\n    # The unparsed URI of the request\n\n    attr_reader :unparsed_uri\n\n    ##\n    # The HTTP version of the request\n\n    attr_reader :http_version\n\n    # :section: Request-URI\n\n    ##\n    # The parsed URI of the request\n\n    attr_reader :request_uri\n\n    ##\n    # The request path\n\n    attr_reader :path\n\n    ##\n    # The script name (CGI variable)\n\n    attr_accessor :script_name\n\n    ##\n    # The path info (CGI variable)\n\n    attr_accessor :path_info\n\n    ##\n    # The query from the URI of the request\n\n    attr_accessor :query_string\n\n    # :section: Header and entity body\n\n    ##\n    # The raw header of the request\n\n    attr_reader :raw_header\n\n    ##\n    # The parsed header of the request\n\n    attr_reader :header\n\n    ##\n    # The parsed request cookies\n\n    attr_reader :cookies\n\n    ##\n    # The Accept header value\n\n    attr_reader :accept\n\n    ##\n    # The Accept-Charset header value\n\n    attr_reader :accept_charset\n\n    ##\n    # The Accept-Encoding header value\n\n    attr_reader :accept_encoding\n\n    ##\n    # The Accept-Language header value\n\n    attr_reader :accept_language\n\n    # :section:\n\n    ##\n    # The remote user (CGI variable)\n\n    attr_accessor :user\n\n    ##\n    # The socket address of the server\n\n    attr_reader :addr\n\n    ##\n    # The socket address of the client\n\n    attr_reader :peeraddr\n\n    ##\n    # Hash of request attributes\n\n    attr_reader :attributes\n\n    ##\n    # Is this a keep-alive connection?\n\n    attr_reader :keep_alive\n\n    ##\n    # The local time this request was received\n\n    attr_reader :request_time\n\n    ##\n    # Creates a new HTTP request.  WEBrick::Config::HTTP is the default\n    # configuration.\n\n    def initialize(config)\n      @config = config\n      @buffer_size = @config[:InputBufferSize]\n      @logger = config[:Logger]\n\n      @request_line = @request_method =\n        @unparsed_uri = @http_version = nil\n\n      @request_uri = @host = @port = @path = nil\n      @script_name = @path_info = nil\n      @query_string = nil\n      @query = nil\n      @form_data = nil\n\n      @raw_header = Array.new\n      @header = nil\n      @cookies = []\n      @accept = []\n      @accept_charset = []\n      @accept_encoding = []\n      @accept_language = []\n      @body = \"\"\n\n      @addr = @peeraddr = nil\n      @attributes = {}\n      @user = nil\n      @keep_alive = false\n      @request_time = nil\n\n      @remaining_size = nil\n      @socket = nil\n\n      @forwarded_proto = @forwarded_host = @forwarded_port =\n        @forwarded_server = @forwarded_for = nil\n    end\n\n    ##\n    # Parses a request from +socket+.  This is called internally by\n    # WEBrick::HTTPServer.\n\n    def parse(socket=nil)\n      @socket = socket\n      begin\n        @peeraddr = socket.respond_to?(:peeraddr) ? socket.peeraddr : []\n        @addr = socket.respond_to?(:addr) ? socket.addr : []\n      rescue Errno::ENOTCONN\n        raise HTTPStatus::EOFError\n      end\n\n      read_request_line(socket)\n      if @http_version.major > 0\n        read_header(socket)\n        @header['cookie'].each{|cookie|\n          @cookies += Cookie::parse(cookie)\n        }\n        @accept = HTTPUtils.parse_qvalues(self['accept'])\n        @accept_charset = HTTPUtils.parse_qvalues(self['accept-charset'])\n        @accept_encoding = HTTPUtils.parse_qvalues(self['accept-encoding'])\n        @accept_language = HTTPUtils.parse_qvalues(self['accept-language'])\n      end\n      return if @request_method == \"CONNECT\"\n      return if @unparsed_uri == \"*\"\n\n      begin\n        setup_forwarded_info\n        @request_uri = parse_uri(@unparsed_uri)\n        @path = HTTPUtils::unescape(@request_uri.path)\n        @path = HTTPUtils::normalize_path(@path)\n        @host = @request_uri.host\n        @port = @request_uri.port\n        @query_string = @request_uri.query\n        @script_name = \"\"\n        @path_info = @path.dup\n      rescue\n        raise HTTPStatus::BadRequest, \"bad URI `#{@unparsed_uri}'.\"\n      end\n\n      if /close/io =~ self[\"connection\"]\n        @keep_alive = false\n      elsif /keep-alive/io =~ self[\"connection\"]\n        @keep_alive = true\n      elsif @http_version < \"1.1\"\n        @keep_alive = false\n      else\n        @keep_alive = true\n      end\n    end\n\n    ##\n    # Generate HTTP/1.1 100 continue response if the client expects it,\n    # otherwise does nothing.\n\n    def continue # :nodoc:\n      if self['expect'] == '100-continue' && @config[:HTTPVersion] >= \"1.1\"\n        @socket << \"HTTP/#{@config[:HTTPVersion]} 100 continue#{CRLF}#{CRLF}\"\n        @header.delete('expect')\n      end\n    end\n\n    ##\n    # Returns the request body.\n\n    def body(&block) # :yields: body_chunk\n      block ||= Proc.new{|chunk| @body << chunk }\n      read_body(@socket, block)\n      @body.empty? ? nil : @body\n    end\n\n    ##\n    # Prepares the HTTPRequest object for use as the\n    # source for IO.copy_stream\n\n    def body_reader\n      @body_tmp = []\n      @body_rd = Fiber.new do\n        body do |buf|\n          @body_tmp << buf\n          Fiber.yield\n        end\n      end\n      @body_rd.resume # grab the first chunk and yield\n      self\n    end\n\n    # for IO.copy_stream.\n    def readpartial(size, buf = ''.b) # :nodoc\n      res = @body_tmp.shift or raise EOFError, 'end of file reached'\n      if res.length > size\n        @body_tmp.unshift(res[size..-1])\n        res = res[0..size - 1]\n      end\n      buf.replace(res)\n      res.clear\n      # get more chunks - check alive? because we can take a partial chunk\n      @body_rd.resume if @body_rd.alive?\n      buf\n    end\n\n    ##\n    # Request query as a Hash\n\n    def query\n      unless @query\n        parse_query()\n      end\n      @query\n    end\n\n    ##\n    # The content-length header\n\n    def content_length\n      return Integer(self['content-length'])\n    end\n\n    ##\n    # The content-type header\n\n    def content_type\n      return self['content-type']\n    end\n\n    ##\n    # Retrieves +header_name+\n\n    def [](header_name)\n      if @header\n        value = @header[header_name.downcase]\n        value.empty? ? nil : value.join(\", \")\n      end\n    end\n\n    ##\n    # Iterates over the request headers\n\n    def each\n      if @header\n        @header.each{|k, v|\n          value = @header[k]\n          yield(k, value.empty? ? nil : value.join(\", \"))\n        }\n      end\n    end\n\n    ##\n    # The host this request is for\n\n    def host\n      return @forwarded_host || @host\n    end\n\n    ##\n    # The port this request is for\n\n    def port\n      return @forwarded_port || @port\n    end\n\n    ##\n    # The server name this request is for\n\n    def server_name\n      return @forwarded_server || @config[:ServerName]\n    end\n\n    ##\n    # The client's IP address\n\n    def remote_ip\n      return self[\"client-ip\"] || @forwarded_for || @peeraddr[3]\n    end\n\n    ##\n    # Is this an SSL request?\n\n    def ssl?\n      return @request_uri.scheme == \"https\"\n    end\n\n    ##\n    # Should the connection this request was made on be kept alive?\n\n    def keep_alive?\n      @keep_alive\n    end\n\n    def to_s # :nodoc:\n      ret = @request_line.dup\n      @raw_header.each{|line| ret << line }\n      ret << CRLF\n      ret << body if body\n      ret\n    end\n\n    ##\n    # Consumes any remaining body and updates keep-alive status\n\n    def fixup() # :nodoc:\n      begin\n        body{|chunk| }   # read remaining body\n      rescue HTTPStatus::Error => ex\n        @logger.error(\"HTTPRequest#fixup: #{ex.class} occurred.\")\n        @keep_alive = false\n      rescue => ex\n        @logger.error(ex)\n        @keep_alive = false\n      end\n    end\n\n    # This method provides the metavariables defined by the revision 3\n    # of \"The WWW Common Gateway Interface Version 1.1\"\n    # To browse the current document of CGI Version 1.1, see below:\n    # http://tools.ietf.org/html/rfc3875\n\n    def meta_vars\n      meta = Hash.new\n\n      cl = self[\"Content-Length\"]\n      ct = self[\"Content-Type\"]\n      meta[\"CONTENT_LENGTH\"]    = cl if cl.to_i > 0\n      meta[\"CONTENT_TYPE\"]      = ct.dup if ct\n      meta[\"GATEWAY_INTERFACE\"] = \"CGI/1.1\"\n      meta[\"PATH_INFO\"]         = @path_info ? @path_info.dup : \"\"\n     #meta[\"PATH_TRANSLATED\"]   = nil      # no plan to be provided\n      meta[\"QUERY_STRING\"]      = @query_string ? @query_string.dup : \"\"\n      meta[\"REMOTE_ADDR\"]       = @peeraddr[3]\n      meta[\"REMOTE_HOST\"]       = @peeraddr[2]\n     #meta[\"REMOTE_IDENT\"]      = nil      # no plan to be provided\n      meta[\"REMOTE_USER\"]       = @user\n      meta[\"REQUEST_METHOD\"]    = @request_method.dup\n      meta[\"REQUEST_URI\"]       = @request_uri.to_s\n      meta[\"SCRIPT_NAME\"]       = @script_name.dup\n      meta[\"SERVER_NAME\"]       = @host\n      meta[\"SERVER_PORT\"]       = @port.to_s\n      meta[\"SERVER_PROTOCOL\"]   = \"HTTP/\" + @config[:HTTPVersion].to_s\n      meta[\"SERVER_SOFTWARE\"]   = @config[:ServerSoftware].dup\n\n      self.each{|key, val|\n        next if /^content-type$/i =~ key\n        next if /^content-length$/i =~ key\n        name = \"HTTP_\" + key\n        name.gsub!(/-/o, \"_\")\n        name.upcase!\n        meta[name] = val\n      }\n\n      meta\n    end\n\n    private\n\n    # :stopdoc:\n\n    MAX_URI_LENGTH = 2083 # :nodoc:\n\n    # same as Mongrel, Thin and Puma\n    MAX_HEADER_LENGTH = (112 * 1024) # :nodoc:\n\n    def read_request_line(socket)\n      @request_line = read_line(socket, MAX_URI_LENGTH) if socket\n      raise HTTPStatus::EOFError unless @request_line\n\n      @request_bytes = @request_line.bytesize\n      if @request_bytes >= MAX_URI_LENGTH and @request_line[-1, 1] != LF\n        raise HTTPStatus::RequestURITooLarge\n      end\n\n      @request_time = Time.now\n      if /^(\\S+)\\s+(\\S++)(?:\\s+HTTP\\/(\\d+\\.\\d+))?\\r?\\n/mo =~ @request_line\n        @request_method = $1\n        @unparsed_uri   = $2\n        @http_version   = HTTPVersion.new($3 ? $3 : \"0.9\")\n      else\n        rl = @request_line.sub(/\\x0d?\\x0a\\z/o, '')\n        raise HTTPStatus::BadRequest, \"bad Request-Line `#{rl}'.\"\n      end\n    end\n\n    def read_header(socket)\n      if socket\n        while line = read_line(socket)\n          break if /\\A(#{CRLF}|#{LF})\\z/om =~ line\n          if (@request_bytes += line.bytesize) > MAX_HEADER_LENGTH\n            raise HTTPStatus::RequestEntityTooLarge, 'headers too large'\n          end\n          @raw_header << line\n        end\n      end\n      @header = HTTPUtils::parse_header(@raw_header.join)\n    end\n\n    def parse_uri(str, scheme=\"http\")\n      if @config[:Escape8bitURI]\n        str = HTTPUtils::escape8bit(str)\n      end\n      str.sub!(%r{\\A/+}o, '/')\n      uri = URI::parse(str)\n      return uri if uri.absolute?\n      if @forwarded_host\n        host, port = @forwarded_host, @forwarded_port\n      elsif self[\"host\"]\n        pattern = /\\A(#{URI::REGEXP::PATTERN::HOST})(?::(\\d+))?\\z/n\n        host, port = *self['host'].scan(pattern)[0]\n      elsif @addr.size > 0\n        host, port = @addr[2], @addr[1]\n      else\n        host, port = @config[:ServerName], @config[:Port]\n      end\n      uri.scheme = @forwarded_proto || scheme\n      uri.host = host\n      uri.port = port ? port.to_i : nil\n      return URI::parse(uri.to_s)\n    end\n\n    def read_body(socket, block)\n      return unless socket\n      if tc = self['transfer-encoding']\n        case tc\n        when /chunked/io then read_chunked(socket, block)\n        else raise HTTPStatus::NotImplemented, \"Transfer-Encoding: #{tc}.\"\n        end\n      elsif self['content-length'] || @remaining_size\n        @remaining_size ||= self['content-length'].to_i\n        while @remaining_size > 0\n          sz = [@buffer_size, @remaining_size].min\n          break unless buf = read_data(socket, sz)\n          @remaining_size -= buf.bytesize\n          block.call(buf)\n        end\n        if @remaining_size > 0 && @socket.eof?\n          raise HTTPStatus::BadRequest, \"invalid body size.\"\n        end\n      elsif BODY_CONTAINABLE_METHODS.member?(@request_method) && !@socket.eof\n        raise HTTPStatus::LengthRequired\n      end\n      return @body\n    end\n\n    def read_chunk_size(socket)\n      line = read_line(socket)\n      if /^([0-9a-fA-F]+)(?:;(\\S+))?/ =~ line\n        chunk_size = $1.hex\n        chunk_ext = $2\n        [ chunk_size, chunk_ext ]\n      else\n        raise HTTPStatus::BadRequest, \"bad chunk `#{line}'.\"\n      end\n    end\n\n    def read_chunked(socket, block)\n      chunk_size, = read_chunk_size(socket)\n      while chunk_size > 0\n        begin\n          sz = [ chunk_size, @buffer_size ].min\n          data = read_data(socket, sz) # read chunk-data\n          if data.nil? || data.bytesize != sz\n            raise HTTPStatus::BadRequest, \"bad chunk data size.\"\n          end\n          block.call(data)\n        end while (chunk_size -= sz) > 0\n\n        read_line(socket)                    # skip CRLF\n        chunk_size, = read_chunk_size(socket)\n      end\n      read_header(socket)                    # trailer + CRLF\n      @header.delete(\"transfer-encoding\")\n      @remaining_size = 0\n    end\n\n    def _read_data(io, method, *arg)\n      begin\n        WEBrick::Utils.timeout(@config[:RequestTimeout]){\n          return io.__send__(method, *arg)\n        }\n      rescue Errno::ECONNRESET\n        return nil\n      rescue Timeout::Error\n        raise HTTPStatus::RequestTimeout\n      end\n    end\n\n    def read_line(io, size=4096)\n      _read_data(io, :gets, LF, size)\n    end\n\n    def read_data(io, size)\n      _read_data(io, :read, size)\n    end\n\n    def parse_query()\n      begin\n        if @request_method == \"GET\" || @request_method == \"HEAD\"\n          @query = HTTPUtils::parse_query(@query_string)\n        elsif self['content-type'] =~ /^application\\/x-www-form-urlencoded/\n          @query = HTTPUtils::parse_query(body)\n        elsif self['content-type'] =~ /^multipart\\/form-data; boundary=(.+)/\n          boundary = HTTPUtils::dequote($1)\n          @query = HTTPUtils::parse_form_data(body, boundary)\n        else\n          @query = Hash.new\n        end\n      rescue => ex\n        raise HTTPStatus::BadRequest, ex.message\n      end\n    end\n\n    PrivateNetworkRegexp = /\n      ^unknown$|\n      ^((::ffff:)?127.0.0.1|::1)$|\n      ^(::ffff:)?(10|172\\.(1[6-9]|2[0-9]|3[01])|192\\.168)\\.\n    /ixo\n\n    # It's said that all X-Forwarded-* headers will contain more than one\n    # (comma-separated) value if the original request already contained one of\n    # these headers. Since we could use these values as Host header, we choose\n    # the initial(first) value. (apr_table_mergen() adds new value after the\n    # existing value with \", \" prefix)\n    def setup_forwarded_info\n      if @forwarded_server = self[\"x-forwarded-server\"]\n        @forwarded_server = @forwarded_server.split(\",\", 2).first\n      end\n      if @forwarded_proto = self[\"x-forwarded-proto\"]\n        @forwarded_proto = @forwarded_proto.split(\",\", 2).first\n      end\n      if host_port = self[\"x-forwarded-host\"]\n        host_port = host_port.split(\",\", 2).first\n        if host_port =~ /\\A(\\[[0-9a-fA-F:]+\\])(?::(\\d+))?\\z/\n          @forwarded_host = $1\n          tmp = $2\n        else\n          @forwarded_host, tmp = host_port.split(\":\", 2)\n        end\n        @forwarded_port = (tmp || (@forwarded_proto == \"https\" ? 443 : 80)).to_i\n      end\n      if addrs = self[\"x-forwarded-for\"]\n        addrs = addrs.split(\",\").collect(&:strip)\n        addrs.reject!{|ip| PrivateNetworkRegexp =~ ip }\n        @forwarded_for = addrs.first\n      end\n    end\n\n    # :startdoc:\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: false\n#\n# httprequest.rb -- HTTPRequest Class\n#\n# Author: IPR -- Internet Programming with Ruby -- writers\n# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou\n# Copyright (c) 2002 Internet Programming with Ruby writers. All rights\n# reserved.\n#\n# $IPR: httprequest.rb,v 1.64 2003/07/13 17:18:22 gotoyuzo Exp $\n\nrequire 'fiber'\nrequire 'uri'\nrequire_relative 'httpversion'\nrequire_relative 'httpstatus'\nrequire_relative 'httputils'\nrequire_relative 'cookie'\n\nmodule WEBrick\n\n  ##\n  # An HTTP request.  This is consumed by service and do_* methods in\n  # WEBrick servlets\n\n  class HTTPRequest\n\n    BODY_CONTAINABLE_METHODS = [ \"POST\", \"PUT\" ] # :nodoc:\n\n    # :section: Request line\n\n    ##\n    # The complete request line such as:\n    #\n    #   GET / HTTP/1.1\n\n    attr_reader :request_line\n\n    ##\n    # The request method, GET, POST, PUT, etc.\n\n    attr_reader :request_method\n\n    ##\n    # The unparsed URI of the request\n\n    attr_reader :unparsed_uri\n\n    ##\n    # The HTTP version of the request\n\n    attr_reader :http_version\n\n    # :section: Request-URI\n\n    ##\n    # The parsed URI of the request\n\n    attr_reader :request_uri\n\n    ##\n    # The request path\n\n    attr_reader :path\n\n    ##\n    # The script name (CGI variable)\n\n    attr_accessor :script_name\n\n    ##\n    # The path info (CGI variable)\n\n    attr_accessor :path_info\n\n    ##\n    # The query from the URI of the request\n\n    attr_accessor :query_string\n\n    # :section: Header and entity body\n\n    ##\n    # The raw header of the request\n\n    attr_reader :raw_header\n\n    ##\n    # The parsed header of the request\n\n    attr_reader :header\n\n    ##\n    # The parsed request cookies\n\n    attr_reader :cookies\n\n    ##\n    # The Accept header value\n\n    attr_reader :accept\n\n    ##\n    # The Accept-Charset header value\n\n    attr_reader :accept_charset\n\n    ##\n    # The Accept-Encoding header value\n\n    attr_reader :accept_encoding\n\n    ##\n    # The Accept-Language header value\n\n    attr_reader :accept_language\n\n    # :section:\n\n    ##\n    # The remote user (CGI variable)\n\n    attr_accessor :user\n\n    ##\n    # The socket address of the server\n\n    attr_reader :addr\n\n    ##\n    # The socket address of the client\n\n    attr_reader :peeraddr\n\n    ##\n    # Hash of request attributes\n\n    attr_reader :attributes\n\n    ##\n    # Is this a keep-alive connection?\n\n    attr_reader :keep_alive\n\n    ##\n    # The local time this request was received\n\n    attr_reader :request_time\n\n    ##\n    # Creates a new HTTP request.  WEBrick::Config::HTTP is the default\n    # configuration.\n\n    def initialize(config)\n      @config = config\n      @buffer_size = @config[:InputBufferSize]\n      @logger = config[:Logger]\n\n      @request_line = @request_method =\n        @unparsed_uri = @http_version = nil\n\n      @request_uri = @host = @port = @path = nil\n      @script_name = @path_info = nil\n      @query_string = nil\n      @query = nil\n      @form_data = nil\n\n      @raw_header = Array.new\n      @header = nil\n      @cookies = []\n      @accept = []\n      @accept_charset = []\n      @accept_encoding = []\n      @accept_language = []\n      @body = \"\"\n\n      @addr = @peeraddr = nil\n      @attributes = {}\n      @user = nil\n      @keep_alive = false\n      @request_time = nil\n\n      @remaining_size = nil\n      @socket = nil\n\n      @forwarded_proto = @forwarded_host = @forwarded_port =\n        @forwarded_server = @forwarded_for = nil\n    end\n\n    ##\n    # Parses a request from +socket+.  This is called internally by\n    # WEBrick::HTTPServer.\n\n    def parse(socket=nil)\n      @socket = socket\n      begin\n        @peeraddr = socket.respond_to?(:peeraddr) ? socket.peeraddr : []\n        @addr = socket.respond_to?(:addr) ? socket.addr : []\n      rescue Errno::ENOTCONN\n        raise HTTPStatus::EOFError\n      end\n\n      read_request_line(socket)\n      if @http_version.major > 0\n        read_header(socket)\n        @header['cookie'].each{|cookie|\n          @cookies += Cookie::parse(cookie)\n        }\n        @accept = HTTPUtils.parse_qvalues(self['accept'])\n        @accept_charset = HTTPUtils.parse_qvalues(self['accept-charset'])\n        @accept_encoding = HTTPUtils.parse_qvalues(self['accept-encoding'])\n        @accept_language = HTTPUtils.parse_qvalues(self['accept-language'])\n      end\n      return if @request_method == \"CONNECT\"\n      return if @unparsed_uri == \"*\"\n\n      begin\n        setup_forwarded_info\n        @request_uri = parse_uri(@unparsed_uri)\n        @path = HTTPUtils::unescape(@request_uri.path)\n        @path = HTTPUtils::normalize_path(@path)\n        @host = @request_uri.host\n        @port = @request_uri.port\n        @query_string = @request_uri.query\n        @script_name = \"\"\n        @path_info = @path.dup\n      rescue\n        raise HTTPStatus::BadRequest, \"bad URI `#{@unparsed_uri}'.\"\n      end\n\n      if /\\Aclose\\z/io =~ self[\"connection\"]\n        @keep_alive = false\n      elsif /\\Akeep-alive\\z/io =~ self[\"connection\"]\n        @keep_alive = true\n      elsif @http_version < \"1.1\"\n        @keep_alive = false\n      else\n        @keep_alive = true\n      end\n    end\n\n    ##\n    # Generate HTTP/1.1 100 continue response if the client expects it,\n    # otherwise does nothing.\n\n    def continue # :nodoc:\n      if self['expect'] == '100-continue' && @config[:HTTPVersion] >= \"1.1\"\n        @socket << \"HTTP/#{@config[:HTTPVersion]} 100 continue#{CRLF}#{CRLF}\"\n        @header.delete('expect')\n      end\n    end\n\n    ##\n    # Returns the request body.\n\n    def body(&block) # :yields: body_chunk\n      block ||= Proc.new{|chunk| @body << chunk }\n      read_body(@socket, block)\n      @body.empty? ? nil : @body\n    end\n\n    ##\n    # Prepares the HTTPRequest object for use as the\n    # source for IO.copy_stream\n\n    def body_reader\n      @body_tmp = []\n      @body_rd = Fiber.new do\n        body do |buf|\n          @body_tmp << buf\n          Fiber.yield\n        end\n      end\n      @body_rd.resume # grab the first chunk and yield\n      self\n    end\n\n    # for IO.copy_stream.\n    def readpartial(size, buf = ''.b) # :nodoc\n      res = @body_tmp.shift or raise EOFError, 'end of file reached'\n      if res.length > size\n        @body_tmp.unshift(res[size..-1])\n        res = res[0..size - 1]\n      end\n      buf.replace(res)\n      res.clear\n      # get more chunks - check alive? because we can take a partial chunk\n      @body_rd.resume if @body_rd.alive?\n      buf\n    end\n\n    ##\n    # Request query as a Hash\n\n    def query\n      unless @query\n        parse_query()\n      end\n      @query\n    end\n\n    ##\n    # The content-length header\n\n    def content_length\n      return Integer(self['content-length'])\n    end\n\n    ##\n    # The content-type header\n\n    def content_type\n      return self['content-type']\n    end\n\n    ##\n    # Retrieves +header_name+\n\n    def [](header_name)\n      if @header\n        value = @header[header_name.downcase]\n        value.empty? ? nil : value.join(\", \")\n      end\n    end\n\n    ##\n    # Iterates over the request headers\n\n    def each\n      if @header\n        @header.each{|k, v|\n          value = @header[k]\n          yield(k, value.empty? ? nil : value.join(\", \"))\n        }\n      end\n    end\n\n    ##\n    # The host this request is for\n\n    def host\n      return @forwarded_host || @host\n    end\n\n    ##\n    # The port this request is for\n\n    def port\n      return @forwarded_port || @port\n    end\n\n    ##\n    # The server name this request is for\n\n    def server_name\n      return @forwarded_server || @config[:ServerName]\n    end\n\n    ##\n    # The client's IP address\n\n    def remote_ip\n      return self[\"client-ip\"] || @forwarded_for || @peeraddr[3]\n    end\n\n    ##\n    # Is this an SSL request?\n\n    def ssl?\n      return @request_uri.scheme == \"https\"\n    end\n\n    ##\n    # Should the connection this request was made on be kept alive?\n\n    def keep_alive?\n      @keep_alive\n    end\n\n    def to_s # :nodoc:\n      ret = @request_line.dup\n      @raw_header.each{|line| ret << line }\n      ret << CRLF\n      ret << body if body\n      ret\n    end\n\n    ##\n    # Consumes any remaining body and updates keep-alive status\n\n    def fixup() # :nodoc:\n      begin\n        body{|chunk| }   # read remaining body\n      rescue HTTPStatus::Error => ex\n        @logger.error(\"HTTPRequest#fixup: #{ex.class} occurred.\")\n        @keep_alive = false\n      rescue => ex\n        @logger.error(ex)\n        @keep_alive = false\n      end\n    end\n\n    # This method provides the metavariables defined by the revision 3\n    # of \"The WWW Common Gateway Interface Version 1.1\"\n    # To browse the current document of CGI Version 1.1, see below:\n    # http://tools.ietf.org/html/rfc3875\n\n    def meta_vars\n      meta = Hash.new\n\n      cl = self[\"Content-Length\"]\n      ct = self[\"Content-Type\"]\n      meta[\"CONTENT_LENGTH\"]    = cl if cl.to_i > 0\n      meta[\"CONTENT_TYPE\"]      = ct.dup if ct\n      meta[\"GATEWAY_INTERFACE\"] = \"CGI/1.1\"\n      meta[\"PATH_INFO\"]         = @path_info ? @path_info.dup : \"\"\n     #meta[\"PATH_TRANSLATED\"]   = nil      # no plan to be provided\n      meta[\"QUERY_STRING\"]      = @query_string ? @query_string.dup : \"\"\n      meta[\"REMOTE_ADDR\"]       = @peeraddr[3]\n      meta[\"REMOTE_HOST\"]       = @peeraddr[2]\n     #meta[\"REMOTE_IDENT\"]      = nil      # no plan to be provided\n      meta[\"REMOTE_USER\"]       = @user\n      meta[\"REQUEST_METHOD\"]    = @request_method.dup\n      meta[\"REQUEST_URI\"]       = @request_uri.to_s\n      meta[\"SCRIPT_NAME\"]       = @script_name.dup\n      meta[\"SERVER_NAME\"]       = @host\n      meta[\"SERVER_PORT\"]       = @port.to_s\n      meta[\"SERVER_PROTOCOL\"]   = \"HTTP/\" + @config[:HTTPVersion].to_s\n      meta[\"SERVER_SOFTWARE\"]   = @config[:ServerSoftware].dup\n\n      self.each{|key, val|\n        next if /^content-type$/i =~ key\n        next if /^content-length$/i =~ key\n        name = \"HTTP_\" + key\n        name.gsub!(/-/o, \"_\")\n        name.upcase!\n        meta[name] = val\n      }\n\n      meta\n    end\n\n    private\n\n    # :stopdoc:\n\n    MAX_URI_LENGTH = 2083 # :nodoc:\n\n    # same as Mongrel, Thin and Puma\n    MAX_HEADER_LENGTH = (112 * 1024) # :nodoc:\n\n    def read_request_line(socket)\n      @request_line = read_line(socket, MAX_URI_LENGTH) if socket\n      raise HTTPStatus::EOFError unless @request_line\n\n      @request_bytes = @request_line.bytesize\n      if @request_bytes >= MAX_URI_LENGTH and @request_line[-1, 1] != LF\n        raise HTTPStatus::RequestURITooLarge\n      end\n\n      @request_time = Time.now\n      if /^(\\S+)\\s+(\\S++)(?:\\s+HTTP\\/(\\d+\\.\\d+))?\\r?\\n/mo =~ @request_line\n        @request_method = $1\n        @unparsed_uri   = $2\n        @http_version   = HTTPVersion.new($3 ? $3 : \"0.9\")\n      else\n        rl = @request_line.sub(/\\x0d?\\x0a\\z/o, '')\n        raise HTTPStatus::BadRequest, \"bad Request-Line `#{rl}'.\"\n      end\n    end\n\n    def read_header(socket)\n      if socket\n        while line = read_line(socket)\n          break if /\\A(#{CRLF}|#{LF})\\z/om =~ line\n          if (@request_bytes += line.bytesize) > MAX_HEADER_LENGTH\n            raise HTTPStatus::RequestEntityTooLarge, 'headers too large'\n          end\n          @raw_header << line\n        end\n      end\n      @header = HTTPUtils::parse_header(@raw_header.join)\n    end\n\n    def parse_uri(str, scheme=\"http\")\n      if @config[:Escape8bitURI]\n        str = HTTPUtils::escape8bit(str)\n      end\n      str.sub!(%r{\\A/+}o, '/')\n      uri = URI::parse(str)\n      return uri if uri.absolute?\n      if @forwarded_host\n        host, port = @forwarded_host, @forwarded_port\n      elsif self[\"host\"]\n        pattern = /\\A(#{URI::REGEXP::PATTERN::HOST})(?::(\\d+))?\\z/n\n        host, port = *self['host'].scan(pattern)[0]\n      elsif @addr.size > 0\n        host, port = @addr[2], @addr[1]\n      else\n        host, port = @config[:ServerName], @config[:Port]\n      end\n      uri.scheme = @forwarded_proto || scheme\n      uri.host = host\n      uri.port = port ? port.to_i : nil\n      return URI::parse(uri.to_s)\n    end\n\n    def read_body(socket, block)\n      return unless socket\n      if tc = self['transfer-encoding']\n        case tc\n        when /\\Achunked\\z/io then read_chunked(socket, block)\n        else raise HTTPStatus::NotImplemented, \"Transfer-Encoding: #{tc}.\"\n        end\n      elsif self['content-length'] || @remaining_size\n        @remaining_size ||= self['content-length'].to_i\n        while @remaining_size > 0\n          sz = [@buffer_size, @remaining_size].min\n          break unless buf = read_data(socket, sz)\n          @remaining_size -= buf.bytesize\n          block.call(buf)\n        end\n        if @remaining_size > 0 && @socket.eof?\n          raise HTTPStatus::BadRequest, \"invalid body size.\"\n        end\n      elsif BODY_CONTAINABLE_METHODS.member?(@request_method) && !@socket.eof\n        raise HTTPStatus::LengthRequired\n      end\n      return @body\n    end\n\n    def read_chunk_size(socket)\n      line = read_line(socket)\n      if /^([0-9a-fA-F]+)(?:;(\\S+))?/ =~ line\n        chunk_size = $1.hex\n        chunk_ext = $2\n        [ chunk_size, chunk_ext ]\n      else\n        raise HTTPStatus::BadRequest, \"bad chunk `#{line}'.\"\n      end\n    end\n\n    def read_chunked(socket, block)\n      chunk_size, = read_chunk_size(socket)\n      while chunk_size > 0\n        begin\n          sz = [ chunk_size, @buffer_size ].min\n          data = read_data(socket, sz) # read chunk-data\n          if data.nil? || data.bytesize != sz\n            raise HTTPStatus::BadRequest, \"bad chunk data size.\"\n          end\n          block.call(data)\n        end while (chunk_size -= sz) > 0\n\n        read_line(socket)                    # skip CRLF\n        chunk_size, = read_chunk_size(socket)\n      end\n      read_header(socket)                    # trailer + CRLF\n      @header.delete(\"transfer-encoding\")\n      @remaining_size = 0\n    end\n\n    def _read_data(io, method, *arg)\n      begin\n        WEBrick::Utils.timeout(@config[:RequestTimeout]){\n          return io.__send__(method, *arg)\n        }\n      rescue Errno::ECONNRESET\n        return nil\n      rescue Timeout::Error\n        raise HTTPStatus::RequestTimeout\n      end\n    end\n\n    def read_line(io, size=4096)\n      _read_data(io, :gets, LF, size)\n    end\n\n    def read_data(io, size)\n      _read_data(io, :read, size)\n    end\n\n    def parse_query()\n      begin\n        if @request_method == \"GET\" || @request_method == \"HEAD\"\n          @query = HTTPUtils::parse_query(@query_string)\n        elsif self['content-type'] =~ /^application\\/x-www-form-urlencoded/\n          @query = HTTPUtils::parse_query(body)\n        elsif self['content-type'] =~ /^multipart\\/form-data; boundary=(.+)/\n          boundary = HTTPUtils::dequote($1)\n          @query = HTTPUtils::parse_form_data(body, boundary)\n        else\n          @query = Hash.new\n        end\n      rescue => ex\n        raise HTTPStatus::BadRequest, ex.message\n      end\n    end\n\n    PrivateNetworkRegexp = /\n      ^unknown$|\n      ^((::ffff:)?127.0.0.1|::1)$|\n      ^(::ffff:)?(10|172\\.(1[6-9]|2[0-9]|3[01])|192\\.168)\\.\n    /ixo\n\n    # It's said that all X-Forwarded-* headers will contain more than one\n    # (comma-separated) value if the original request already contained one of\n    # these headers. Since we could use these values as Host header, we choose\n    # the initial(first) value. (apr_table_mergen() adds new value after the\n    # existing value with \", \" prefix)\n    def setup_forwarded_info\n      if @forwarded_server = self[\"x-forwarded-server\"]\n        @forwarded_server = @forwarded_server.split(\",\", 2).first\n      end\n      if @forwarded_proto = self[\"x-forwarded-proto\"]\n        @forwarded_proto = @forwarded_proto.split(\",\", 2).first\n      end\n      if host_port = self[\"x-forwarded-host\"]\n        host_port = host_port.split(\",\", 2).first\n        if host_port =~ /\\A(\\[[0-9a-fA-F:]+\\])(?::(\\d+))?\\z/\n          @forwarded_host = $1\n          tmp = $2\n        else\n          @forwarded_host, tmp = host_port.split(\":\", 2)\n        end\n        @forwarded_port = (tmp || (@forwarded_proto == \"https\" ? 443 : 80)).to_i\n      end\n      if addrs = self[\"x-forwarded-for\"]\n        addrs = addrs.split(\",\").collect(&:strip)\n        addrs.reject!{|ip| PrivateNetworkRegexp =~ ip }\n        @forwarded_for = addrs.first\n      end\n    end\n\n    # :startdoc:\n  end\nend\n"], "filenames": ["lib/webrick/httprequest.rb"], "buggy_code_start_loc": [230], "buggy_code_end_loc": [512], "fixing_code_start_loc": [230], "fixing_code_end_loc": [512], "type": "CWE-444", "message": "An issue was discovered in Ruby through 2.5.8, 2.6.x through 2.6.6, and 2.7.x through 2.7.1. WEBrick, a simple HTTP server bundled with Ruby, had not checked the transfer-encoding header value rigorously. An attacker may potentially exploit this issue to bypass a reverse proxy (which also has a poor header check), which may lead to an HTTP Request Smuggling attack.", "other": {"cve": {"id": "CVE-2020-25613", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-06T13:15:13.823", "lastModified": "2023-04-30T23:15:44.907", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in Ruby through 2.5.8, 2.6.x through 2.6.6, and 2.7.x through 2.7.1. WEBrick, a simple HTTP server bundled with Ruby, had not checked the transfer-encoding header value rigorously. An attacker may potentially exploit this issue to bypass a reverse proxy (which also has a poor header check), which may lead to an HTTP Request Smuggling attack."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Ruby versiones hasta 2.5.8, versiones 2.6.x hasta 2.6.6 y versiones 2.7.x hasta 2.7.1.&#xa0;WEBrick, un simple servidor HTTP integrado con Ruby, no hab\u00eda comprobado rigurosamente el valor del encabezado transfer-encoding.&#xa0;Un atacante puede explotar potencialmente este problema para omitir un proxy inverso (que tambi\u00e9n presenta una comprobaci\u00f3n de encabezado deficiente), que puede conllevar a un ataque de Trafico Inapropiado de Peticiones HTTP"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.8", "matchCriteriaId": "D2D8FEE5-99D0-413E-8482-0479BBC81443"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndIncluding": "2.6.6", "matchCriteriaId": "D79041FB-E10A-4907-805C-45FA8428FF29"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:ruby:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndIncluding": "2.7.1", "matchCriteriaId": "3908BC67-A30E-4F56-9836-81FBB0754110"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ruby-lang:webrick:*:*:*:*:*:ruby:*:*", "versionEndIncluding": "1.6.0", "matchCriteriaId": "5A33AE4F-9A47-4D28-8BBC-9DF4CCDA8915"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/ruby/webrick/commit/8946bb38b4d87549f0d99ed73c62c41933f97cc7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/965267", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/04/msg00033.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PFP3E7KXXT3H3KA6CBZPUOGA5VPFARRJ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YTZURYROG3FFED3TYCQOBV66BS4K6WOV/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210115-0008/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.ruby-lang.org/en/news/2020/09/29/http-request-smuggling-cve-2020-25613/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ruby/webrick/commit/8946bb38b4d87549f0d99ed73c62c41933f97cc7"}}