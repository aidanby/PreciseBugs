{"buggy_code": ["<?php\n/**\n\t@version   v5.20.6  31-Aug-2016\n\t@copyright (c) 2000-2013 John Lim (jlim#natsoft.com). All rights reserved.\n\t@copyright (c) 2014      Damien Regad, Mark Newnham and the ADOdb community\n\n\tReleased under both BSD license and Lesser GPL library license.\n\tWhenever there is any discrepancy between the two licenses,\n\tthe BSD license will take precedence.\n\n\tSet tabs to 4 for best viewing.\n\n\tLatest version is available at http://adodb.sourceforge.net\n\n\tRequires ODBC. Works on Windows and Unix.\n\n\tProblems:\n\t\tWhere is float/decimal type in pdo_param_type\n\t\tLOB handling for CLOB/BLOB differs significantly\n*/\n\n// security - hide paths\nif (!defined('ADODB_DIR')) die();\n\n\n/*\nenum pdo_param_type {\nPDO::PARAM_NULL, 0\n\n/* int as in long (the php native int type).\n * If you mark a column as an int, PDO expects get_col to return\n * a pointer to a long\nPDO::PARAM_INT, 1\n\n/* get_col ptr should point to start of the string buffer\nPDO::PARAM_STR, 2\n\n/* get_col: when len is 0 ptr should point to a php_stream *,\n * otherwise it should behave like a string. Indicate a NULL field\n * value by setting the ptr to NULL\nPDO::PARAM_LOB, 3\n\n/* get_col: will expect the ptr to point to a new PDOStatement object handle,\n * but this isn't wired up yet\nPDO::PARAM_STMT, 4 /* hierarchical result set\n\n/* get_col ptr should point to a zend_bool\nPDO::PARAM_BOOL, 5\n\n\n/* magic flag to denote a parameter as being input/output\nPDO::PARAM_INPUT_OUTPUT = 0x80000000\n};\n*/\n\nfunction adodb_pdo_type($t)\n{\n\tswitch($t) {\n\tcase 2: return 'VARCHAR';\n\tcase 3: return 'BLOB';\n\tdefault: return 'NUMERIC';\n\t}\n}\n\n/*----------------------------------------------------------------------------*/\n\n\nclass ADODB_pdo extends ADOConnection {\n\tvar $databaseType = \"pdo\";\n\tvar $dataProvider = \"pdo\";\n\tvar $fmtDate = \"'Y-m-d'\";\n\tvar $fmtTimeStamp = \"'Y-m-d, h:i:sA'\";\n\tvar $replaceQuote = \"''\"; // string to use to replace quotes\n\tvar $hasAffectedRows = true;\n\tvar $_bindInputArray = true;\n\tvar $_genIDSQL;\n\tvar $_genSeqSQL = \"create table %s (id integer)\";\n\tvar $_dropSeqSQL;\n\tvar $_autocommit = true;\n\tvar $_haserrorfunctions = true;\n\tvar $_lastAffectedRows = 0;\n\n\tvar $_errormsg = false;\n\tvar $_errorno = false;\n\n\tvar $dsnType = '';\n\tvar $stmt = false;\n\tvar $_driver;\n\n\tfunction __construct()\n\t{\n\t}\n\n\tfunction _UpdatePDO()\n\t{\n\t\t$d = $this->_driver;\n\t\t$this->fmtDate = $d->fmtDate;\n\t\t$this->fmtTimeStamp = $d->fmtTimeStamp;\n\t\t$this->replaceQuote = $d->replaceQuote;\n\t\t$this->sysDate = $d->sysDate;\n\t\t$this->sysTimeStamp = $d->sysTimeStamp;\n\t\t$this->random = $d->random;\n\t\t$this->concat_operator = $d->concat_operator;\n\t\t$this->nameQuote = $d->nameQuote;\n\n\t\t$this->hasGenID = $d->hasGenID;\n\t\t$this->_genIDSQL = $d->_genIDSQL;\n\t\t$this->_genSeqSQL = $d->_genSeqSQL;\n\t\t$this->_dropSeqSQL = $d->_dropSeqSQL;\n\n\t\t$d->_init($this);\n\t}\n\n\tfunction Time()\n\t{\n\t\tif (!empty($this->_driver->_hasdual)) {\n\t\t\t$sql = \"select $this->sysTimeStamp from dual\";\n\t\t}\n\t\telse {\n\t\t\t$sql = \"select $this->sysTimeStamp\";\n\t\t}\n\n\t\t$rs = $this->_Execute($sql);\n\t\tif ($rs && !$rs->EOF) {\n\t\t\treturn $this->UnixTimeStamp(reset($rs->fields));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// returns true or false\n\tfunction _connect($argDSN, $argUsername, $argPassword, $argDatabasename, $persist=false)\n\t{\n\t\t$at = strpos($argDSN,':');\n\t\t$this->dsnType = substr($argDSN,0,$at);\n\n\t\tif ($argDatabasename) {\n\t\t\tswitch($this->dsnType){\n\t\t\t\tcase 'sqlsrv':\n\t\t\t\t\t$argDSN .= ';database='.$argDatabasename;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mssql':\n\t\t\t\tcase 'mysql':\n\t\t\t\tcase 'oci':\n\t\t\t\tcase 'pgsql':\n\t\t\t\tcase 'sqlite':\n\t\t\t\tdefault:\n\t\t\t\t\t$argDSN .= ';dbname='.$argDatabasename;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\t$this->_connectionID = new PDO($argDSN, $argUsername, $argPassword);\n\t\t} catch (Exception $e) {\n\t\t\t$this->_connectionID = false;\n\t\t\t$this->_errorno = -1;\n\t\t\t//var_dump($e);\n\t\t\t$this->_errormsg = 'Connection attempt failed: '.$e->getMessage();\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($this->_connectionID) {\n\t\t\tswitch(ADODB_ASSOC_CASE){\n\t\t\t\tcase ADODB_ASSOC_CASE_LOWER:\n\t\t\t\t\t$m = PDO::CASE_LOWER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ADODB_ASSOC_CASE_UPPER:\n\t\t\t\t\t$m = PDO::CASE_UPPER;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase ADODB_ASSOC_CASE_NATIVE:\n\t\t\t\t\t$m = PDO::CASE_NATURAL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//$this->_connectionID->setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_SILENT );\n\t\t\t$this->_connectionID->setAttribute(PDO::ATTR_CASE,$m);\n\n\t\t\t$class = 'ADODB_pdo_'.$this->dsnType;\n\t\t\t//$this->_connectionID->setAttribute(PDO::ATTR_AUTOCOMMIT,true);\n\t\t\tswitch($this->dsnType) {\n\t\t\t\tcase 'mssql':\n\t\t\t\tcase 'mysql':\n\t\t\t\tcase 'oci':\n\t\t\t\tcase 'pgsql':\n\t\t\t\tcase 'sqlite':\n\t\t\t\tcase 'sqlsrv':\n\t\t\t\t\tinclude_once(ADODB_DIR.'/drivers/adodb-pdo_'.$this->dsnType.'.inc.php');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (class_exists($class)) {\n\t\t\t\t$this->_driver = new $class();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$this->_driver = new ADODB_pdo_base();\n\t\t\t}\n\n\t\t\t$this->_driver->_connectionID = $this->_connectionID;\n\t\t\t$this->_UpdatePDO();\n\t\t\t$this->_driver->database = $this->database;\n\t\t\treturn true;\n\t\t}\n\t\t$this->_driver = new ADODB_pdo_base();\n\t\treturn false;\n\t}\n\n\tfunction Concat()\n\t{\n\t\t$args = func_get_args();\n\t\tif(method_exists($this->_driver, 'Concat')) {\n\t\t\treturn call_user_func_array(array($this->_driver, 'Concat'), $args);\n\t\t}\n\n\t\tif (PHP_VERSION >= 5.3) {\n\t\t\treturn call_user_func_array('parent::Concat', $args);\n\t\t}\n\t\treturn call_user_func_array(array($this,'parent::Concat'), $args);\n\t}\n\n\t// returns true or false\n\tfunction _pconnect($argDSN, $argUsername, $argPassword, $argDatabasename)\n\t{\n\t\treturn $this->_connect($argDSN, $argUsername, $argPassword, $argDatabasename, true);\n\t}\n\n\t/*------------------------------------------------------------------------------*/\n\n\n\tfunction SelectLimit($sql,$nrows=-1,$offset=-1,$inputarr=false,$secs2cache=0)\n\t{\n\t\t$save = $this->_driver->fetchMode;\n\t\t$this->_driver->fetchMode = $this->fetchMode;\n\t\t$this->_driver->debug = $this->debug;\n\t\t$ret = $this->_driver->SelectLimit($sql,$nrows,$offset,$inputarr,$secs2cache);\n\t\t$this->_driver->fetchMode = $save;\n\t\treturn $ret;\n\t}\n\n\n\tfunction ServerInfo()\n\t{\n\t\treturn $this->_driver->ServerInfo();\n\t}\n\n\tfunction MetaTables($ttype=false,$showSchema=false,$mask=false)\n\t{\n\t\treturn $this->_driver->MetaTables($ttype,$showSchema,$mask);\n\t}\n\n\tfunction MetaColumns($table,$normalize=true)\n\t{\n\t\treturn $this->_driver->MetaColumns($table,$normalize);\n\t}\n\n\tfunction InParameter(&$stmt,&$var,$name,$maxLen=4000,$type=false)\n\t{\n\t\t$obj = $stmt[1];\n\t\tif ($type) {\n\t\t\t$obj->bindParam($name, $var, $type, $maxLen);\n\t\t}\n\t\telse {\n\t\t\t$obj->bindParam($name, $var);\n\t\t}\n\t}\n\n\tfunction OffsetDate($dayFraction,$date=false)\n\t{\n\t\treturn $this->_driver->OffsetDate($dayFraction,$date);\n\t}\n\n\tfunction SelectDB($dbName)\n\t{\n\t\treturn $this->_driver->SelectDB($dbName);\n\t}\n\n\tfunction SQLDate($fmt, $col=false)\n\t{\n\t\treturn $this->_driver->SQLDate($fmt, $col);\n\t}\n\n\tfunction ErrorMsg()\n\t{\n\t\tif ($this->_errormsg !== false) {\n\t\t\treturn $this->_errormsg;\n\t\t}\n\t\tif (!empty($this->_stmt)) {\n\t\t\t$arr = $this->_stmt->errorInfo();\n\t\t}\n\t\telse if (!empty($this->_connectionID)) {\n\t\t\t$arr = $this->_connectionID->errorInfo();\n\t\t}\n\t\telse {\n\t\t\treturn 'No Connection Established';\n\t\t}\n\n\t\tif ($arr) {\n\t\t\tif (sizeof($arr)<2) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tif ((integer)$arr[0]) {\n\t\t\t\treturn $arr[2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn '-1';\n\t\t}\n\t}\n\n\n\tfunction ErrorNo()\n\t{\n\t\tif ($this->_errorno !== false) {\n\t\t\treturn $this->_errorno;\n\t\t}\n\t\tif (!empty($this->_stmt)) {\n\t\t\t$err = $this->_stmt->errorCode();\n\t\t}\n\t\telse if (!empty($this->_connectionID)) {\n\t\t\t$arr = $this->_connectionID->errorInfo();\n\t\t\tif (isset($arr[0])) {\n\t\t\t\t$err = $arr[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$err = -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ($err == '00000') {\n\t\t\treturn 0; // allows empty check\n\t\t}\n\t\treturn $err;\n\t}\n\n\tfunction SetTransactionMode($transaction_mode)\n\t{\n\t\tif(method_exists($this->_driver, 'SetTransactionMode')) {\n\t\t\treturn $this->_driver->SetTransactionMode($transaction_mode);\n\t\t}\n\n\t\treturn parent::SetTransactionMode($seqname);\n\t}\n\n\tfunction BeginTrans()\n\t{\n\t\tif(method_exists($this->_driver, 'BeginTrans')) {\n\t\t\treturn $this->_driver->BeginTrans();\n\t\t}\n\n\t\tif (!$this->hasTransactions) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($this->transOff) {\n\t\t\treturn true;\n\t\t}\n\t\t$this->transCnt += 1;\n\t\t$this->_autocommit = false;\n\t\t$this->_connectionID->setAttribute(PDO::ATTR_AUTOCOMMIT,false);\n\n\t\treturn $this->_connectionID->beginTransaction();\n\t}\n\n\tfunction CommitTrans($ok=true)\n\t{\n\t\tif(method_exists($this->_driver, 'CommitTrans')) {\n\t\t\treturn $this->_driver->CommitTrans($ok);\n\t\t}\n\n\t\tif (!$this->hasTransactions) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($this->transOff) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!$ok) {\n\t\t\treturn $this->RollbackTrans();\n\t\t}\n\t\tif ($this->transCnt) {\n\t\t\t$this->transCnt -= 1;\n\t\t}\n\t\t$this->_autocommit = true;\n\n\t\t$ret = $this->_connectionID->commit();\n\t\t$this->_connectionID->setAttribute(PDO::ATTR_AUTOCOMMIT,true);\n\t\treturn $ret;\n\t}\n\n\tfunction RollbackTrans()\n\t{\n\t\tif(method_exists($this->_driver, 'RollbackTrans')) {\n\t\t\treturn $this->_driver->RollbackTrans();\n\t\t}\n\n\t\tif (!$this->hasTransactions) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($this->transOff) {\n\t\t\treturn true;\n\t\t}\n\t\tif ($this->transCnt) {\n\t\t\t$this->transCnt -= 1;\n\t\t}\n\t\t$this->_autocommit = true;\n\n\t\t$ret = $this->_connectionID->rollback();\n\t\t$this->_connectionID->setAttribute(PDO::ATTR_AUTOCOMMIT,true);\n\t\treturn $ret;\n\t}\n\n\tfunction Prepare($sql)\n\t{\n\t\t$this->_stmt = $this->_connectionID->prepare($sql);\n\t\tif ($this->_stmt) {\n\t\t\treturn array($sql,$this->_stmt);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction PrepareStmt($sql)\n\t{\n\t\t$stmt = $this->_connectionID->prepare($sql);\n\t\tif (!$stmt) {\n\t\t\treturn false;\n\t\t}\n\t\t$obj = new ADOPDOStatement($stmt,$this);\n\t\treturn $obj;\n\t}\n\n\tfunction CreateSequence($seqname='adodbseq',$startID=1)\n\t{\n\t\tif(method_exists($this->_driver, 'CreateSequence')) {\n\t\t\treturn $this->_driver->CreateSequence($seqname, $startID);\n\t\t}\n\n\t\treturn parent::CreateSequence($seqname, $startID);\n\t}\n\n\tfunction DropSequence($seqname='adodbseq')\n\t{\n\t\tif(method_exists($this->_driver, 'DropSequence')) {\n\t\t\treturn $this->_driver->DropSequence($seqname);\n\t\t}\n\n\t\treturn parent::DropSequence($seqname);\n\t}\n\n\tfunction GenID($seqname='adodbseq',$startID=1)\n\t{\n\t\tif(method_exists($this->_driver, 'GenID')) {\n\t\t\treturn $this->_driver->GenID($seqname, $startID);\n\t\t}\n\n\t\treturn parent::GenID($seqname, $startID);\n\t}\n\n\n\t/* returns queryID or false */\n\tfunction _query($sql,$inputarr=false)\n\t{\n\t\tif (is_array($sql)) {\n\t\t\t$stmt = $sql[1];\n\t\t} else {\n\t\t\t$stmt = $this->_connectionID->prepare($sql);\n\t\t}\n\t\t#adodb_backtrace();\n\t\t#var_dump($this->_bindInputArray);\n\t\tif ($stmt) {\n\t\t\t$this->_driver->debug = $this->debug;\n\t\t\tif ($inputarr) {\n\t\t\t\t$ok = $stmt->execute($inputarr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$ok = $stmt->execute();\n\t\t\t}\n\t\t}\n\n\n\t\t$this->_errormsg = false;\n\t\t$this->_errorno = false;\n\n\t\tif ($ok) {\n\t\t\t$this->_stmt = $stmt;\n\t\t\treturn $stmt;\n\t\t}\n\n\t\tif ($stmt) {\n\n\t\t\t$arr = $stmt->errorinfo();\n\t\t\tif ((integer)$arr[1]) {\n\t\t\t\t$this->_errormsg = $arr[2];\n\t\t\t\t$this->_errorno = $arr[1];\n\t\t\t}\n\n\t\t} else {\n\t\t\t$this->_errormsg = false;\n\t\t\t$this->_errorno = false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// returns true or false\n\tfunction _close()\n\t{\n\t\t$this->_stmt = false;\n\t\treturn true;\n\t}\n\n\tfunction _affectedrows()\n\t{\n\t\treturn ($this->_stmt) ? $this->_stmt->rowCount() : 0;\n\t}\n\n\tfunction _insertid()\n\t{\n\t\treturn ($this->_connectionID) ? $this->_connectionID->lastInsertId() : 0;\n\t}\n}\n\nclass ADODB_pdo_base extends ADODB_pdo {\n\n\tvar $sysDate = \"'?'\";\n\tvar $sysTimeStamp = \"'?'\";\n\n\n\tfunction _init($parentDriver)\n\t{\n\t\t$parentDriver->_bindInputArray = true;\n\t\t#$parentDriver->_connectionID->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY,true);\n\t}\n\n\tfunction ServerInfo()\n\t{\n\t\treturn ADOConnection::ServerInfo();\n\t}\n\n\tfunction SelectLimit($sql,$nrows=-1,$offset=-1,$inputarr=false,$secs2cache=0)\n\t{\n\t\t$ret = ADOConnection::SelectLimit($sql,$nrows,$offset,$inputarr,$secs2cache);\n\t\treturn $ret;\n\t}\n\n\tfunction MetaTables($ttype=false,$showSchema=false,$mask=false)\n\t{\n\t\treturn false;\n\t}\n\n\tfunction MetaColumns($table,$normalize=true)\n\t{\n\t\treturn false;\n\t}\n}\n\nclass ADOPDOStatement {\n\n\tvar $databaseType = \"pdo\";\n\tvar $dataProvider = \"pdo\";\n\tvar $_stmt;\n\tvar $_connectionID;\n\n\tfunction __construct($stmt,$connection)\n\t{\n\t\t$this->_stmt = $stmt;\n\t\t$this->_connectionID = $connection;\n\t}\n\n\tfunction Execute($inputArr=false)\n\t{\n\t\t$savestmt = $this->_connectionID->_stmt;\n\t\t$rs = $this->_connectionID->Execute(array(false,$this->_stmt),$inputArr);\n\t\t$this->_connectionID->_stmt = $savestmt;\n\t\treturn $rs;\n\t}\n\n\tfunction InParameter(&$var,$name,$maxLen=4000,$type=false)\n\t{\n\n\t\tif ($type) {\n\t\t\t$this->_stmt->bindParam($name,$var,$type,$maxLen);\n\t\t}\n\t\telse {\n\t\t\t$this->_stmt->bindParam($name, $var);\n\t\t}\n\t}\n\n\tfunction Affected_Rows()\n\t{\n\t\treturn ($this->_stmt) ? $this->_stmt->rowCount() : 0;\n\t}\n\n\tfunction ErrorMsg()\n\t{\n\t\tif ($this->_stmt) {\n\t\t\t$arr = $this->_stmt->errorInfo();\n\t\t}\n\t\telse {\n\t\t\t$arr = $this->_connectionID->errorInfo();\n\t\t}\n\n\t\tif (is_array($arr)) {\n\t\t\tif ((integer) $arr[0] && isset($arr[2])) {\n\t\t\t\treturn $arr[2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else {\n\t\t\treturn '-1';\n\t\t}\n\t}\n\n\tfunction NumCols()\n\t{\n\t\treturn ($this->_stmt) ? $this->_stmt->columnCount() : 0;\n\t}\n\n\tfunction ErrorNo()\n\t{\n\t\tif ($this->_stmt) {\n\t\t\treturn $this->_stmt->errorCode();\n\t\t}\n\t\telse {\n\t\t\treturn $this->_connectionID->errorInfo();\n\t\t}\n\t}\n}\n\n/*--------------------------------------------------------------------------------------\n\tClass Name: Recordset\n--------------------------------------------------------------------------------------*/\n\nclass ADORecordSet_pdo extends ADORecordSet {\n\n\tvar $bind = false;\n\tvar $databaseType = \"pdo\";\n\tvar $dataProvider = \"pdo\";\n\n\tfunction __construct($id,$mode=false)\n\t{\n\t\tif ($mode === false) {\n\t\t\tglobal $ADODB_FETCH_MODE;\n\t\t\t$mode = $ADODB_FETCH_MODE;\n\t\t}\n\t\t$this->adodbFetchMode = $mode;\n\t\tswitch($mode) {\n\t\tcase ADODB_FETCH_NUM: $mode = PDO::FETCH_NUM; break;\n\t\tcase ADODB_FETCH_ASSOC:  $mode = PDO::FETCH_ASSOC; break;\n\n\t\tcase ADODB_FETCH_BOTH:\n\t\tdefault: $mode = PDO::FETCH_BOTH; break;\n\t\t}\n\t\t$this->fetchMode = $mode;\n\n\t\t$this->_queryID = $id;\n\t\tparent::__construct($id);\n\t}\n\n\n\tfunction Init()\n\t{\n\t\tif ($this->_inited) {\n\t\t\treturn;\n\t\t}\n\t\t$this->_inited = true;\n\t\tif ($this->_queryID) {\n\t\t\t@$this->_initrs();\n\t\t}\n\t\telse {\n\t\t\t$this->_numOfRows = 0;\n\t\t\t$this->_numOfFields = 0;\n\t\t}\n\t\tif ($this->_numOfRows != 0 && $this->_currentRow == -1) {\n\t\t\t$this->_currentRow = 0;\n\t\t\tif ($this->EOF = ($this->_fetch() === false)) {\n\t\t\t\t$this->_numOfRows = 0; // _numOfRows could be -1\n\t\t\t}\n\t\t} else {\n\t\t\t$this->EOF = true;\n\t\t}\n\t}\n\n\tfunction _initrs()\n\t{\n\tglobal $ADODB_COUNTRECS;\n\n\t\t$this->_numOfRows = ($ADODB_COUNTRECS) ? @$this->_queryID->rowCount() : -1;\n\t\tif (!$this->_numOfRows) {\n\t\t\t$this->_numOfRows = -1;\n\t\t}\n\t\t$this->_numOfFields = $this->_queryID->columnCount();\n\t}\n\n\t// returns the field object\n\tfunction FetchField($fieldOffset = -1)\n\t{\n\t\t$off=$fieldOffset+1; // offsets begin at 1\n\n\t\t$o= new ADOFieldObject();\n\t\t$arr = @$this->_queryID->getColumnMeta($fieldOffset);\n\t\tif (!$arr) {\n\t\t\t$o->name = 'bad getColumnMeta()';\n\t\t\t$o->max_length = -1;\n\t\t\t$o->type = 'VARCHAR';\n\t\t\t$o->precision = 0;\n\t#\t\t$false = false;\n\t\t\treturn $o;\n\t\t}\n\t\t//adodb_pr($arr);\n\t\t$o->name = $arr['name'];\n\t\tif (isset($arr['sqlsrv:decl_type']) && $arr['sqlsrv:decl_type'] <> \"null\") \n\t\t{\n\t\t    /*\n\t\t    * If the database is SQL server, use the native built-ins\n\t\t    */\n\t\t    $o->type = $arr['sqlsrv:decl_type'];\n\t\t}\n\t\telseif (isset($arr['native_type']) && $arr['native_type'] <> \"null\") \n\t\t{\n\t\t    $o->type = $arr['native_type'];\n\t\t}\n\t\telse \n\t\t{\n\t\t     $o->type = adodb_pdo_type($arr['pdo_type']);\n\t\t}\n\t\t\n\t\t$o->max_length = $arr['len'];\n\t\t$o->precision = $arr['precision'];\n\n\t\tswitch(ADODB_ASSOC_CASE) {\n\t\t\tcase ADODB_ASSOC_CASE_LOWER:\n\t\t\t\t$o->name = strtolower($o->name);\n\t\t\t\tbreak;\n\t\t\tcase ADODB_ASSOC_CASE_UPPER:\n\t\t\t\t$o->name = strtoupper($o->name);\n\t\t\t\tbreak;\n\t\t}\n\t\treturn $o;\n\t}\n\n\tfunction _seek($row)\n\t{\n\t\treturn false;\n\t}\n\n\tfunction _fetch()\n\t{\n\t\tif (!$this->_queryID) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$this->fields = $this->_queryID->fetch($this->fetchMode);\n\t\treturn !empty($this->fields);\n\t}\n\n\tfunction _close()\n\t{\n\t\t$this->_queryID = false;\n\t}\n\n\tfunction Fields($colname)\n\t{\n\t\tif ($this->adodbFetchMode != ADODB_FETCH_NUM) {\n\t\t\treturn @$this->fields[$colname];\n\t\t}\n\n\t\tif (!$this->bind) {\n\t\t\t$this->bind = array();\n\t\t\tfor ($i=0; $i < $this->_numOfFields; $i++) {\n\t\t\t\t$o = $this->FetchField($i);\n\t\t\t\t$this->bind[strtoupper($o->name)] = $i;\n\t\t\t}\n\t\t}\n\t\treturn $this->fields[$this->bind[strtoupper($colname)]];\n\t}\n\n}\n"], "fixing_code": ["<?php\n/**\n\t@version   v5.20.6  31-Aug-2016\n\t@copyright (c) 2000-2013 John Lim (jlim#natsoft.com). All rights reserved.\n\t@copyright (c) 2014      Damien Regad, Mark Newnham and the ADOdb community\n\n\tReleased under both BSD license and Lesser GPL library license.\n\tWhenever there is any discrepancy between the two licenses,\n\tthe BSD license will take precedence.\n\n\tSet tabs to 4 for best viewing.\n\n\tLatest version is available at http://adodb.sourceforge.net\n\n\tRequires ODBC. Works on Windows and Unix.\n\n\tProblems:\n\t\tWhere is float/decimal type in pdo_param_type\n\t\tLOB handling for CLOB/BLOB differs significantly\n*/\n\n// security - hide paths\nif (!defined('ADODB_DIR')) die();\n\n\n/*\nenum pdo_param_type {\nPDO::PARAM_NULL, 0\n\n/* int as in long (the php native int type).\n * If you mark a column as an int, PDO expects get_col to return\n * a pointer to a long\nPDO::PARAM_INT, 1\n\n/* get_col ptr should point to start of the string buffer\nPDO::PARAM_STR, 2\n\n/* get_col: when len is 0 ptr should point to a php_stream *,\n * otherwise it should behave like a string. Indicate a NULL field\n * value by setting the ptr to NULL\nPDO::PARAM_LOB, 3\n\n/* get_col: will expect the ptr to point to a new PDOStatement object handle,\n * but this isn't wired up yet\nPDO::PARAM_STMT, 4 /* hierarchical result set\n\n/* get_col ptr should point to a zend_bool\nPDO::PARAM_BOOL, 5\n\n\n/* magic flag to denote a parameter as being input/output\nPDO::PARAM_INPUT_OUTPUT = 0x80000000\n};\n*/\n\nfunction adodb_pdo_type($t)\n{\n\tswitch($t) {\n\tcase 2: return 'VARCHAR';\n\tcase 3: return 'BLOB';\n\tdefault: return 'NUMERIC';\n\t}\n}\n\n/*----------------------------------------------------------------------------*/\n\n\nclass ADODB_pdo extends ADOConnection {\n\tvar $databaseType = \"pdo\";\n\tvar $dataProvider = \"pdo\";\n\tvar $fmtDate = \"'Y-m-d'\";\n\tvar $fmtTimeStamp = \"'Y-m-d, h:i:sA'\";\n\tvar $replaceQuote = \"''\"; // string to use to replace quotes\n\tvar $hasAffectedRows = true;\n\tvar $_bindInputArray = true;\n\tvar $_genIDSQL;\n\tvar $_genSeqSQL = \"create table %s (id integer)\";\n\tvar $_dropSeqSQL;\n\tvar $_autocommit = true;\n\tvar $_haserrorfunctions = true;\n\tvar $_lastAffectedRows = 0;\n\n\tvar $_errormsg = false;\n\tvar $_errorno = false;\n\n\tvar $dsnType = '';\n\tvar $stmt = false;\n\tvar $_driver;\n\n\tfunction __construct()\n\t{\n\t}\n\n\tfunction _UpdatePDO()\n\t{\n\t\t$d = $this->_driver;\n\t\t$this->fmtDate = $d->fmtDate;\n\t\t$this->fmtTimeStamp = $d->fmtTimeStamp;\n\t\t$this->replaceQuote = $d->replaceQuote;\n\t\t$this->sysDate = $d->sysDate;\n\t\t$this->sysTimeStamp = $d->sysTimeStamp;\n\t\t$this->random = $d->random;\n\t\t$this->concat_operator = $d->concat_operator;\n\t\t$this->nameQuote = $d->nameQuote;\n\n\t\t$this->hasGenID = $d->hasGenID;\n\t\t$this->_genIDSQL = $d->_genIDSQL;\n\t\t$this->_genSeqSQL = $d->_genSeqSQL;\n\t\t$this->_dropSeqSQL = $d->_dropSeqSQL;\n\n\t\t$d->_init($this);\n\t}\n\n\tfunction Time()\n\t{\n\t\tif (!empty($this->_driver->_hasdual)) {\n\t\t\t$sql = \"select $this->sysTimeStamp from dual\";\n\t\t}\n\t\telse {\n\t\t\t$sql = \"select $this->sysTimeStamp\";\n\t\t}\n\n\t\t$rs = $this->_Execute($sql);\n\t\tif ($rs && !$rs->EOF) {\n\t\t\treturn $this->UnixTimeStamp(reset($rs->fields));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// returns true or false\n\tfunction _connect($argDSN, $argUsername, $argPassword, $argDatabasename, $persist=false)\n\t{\n\t\t$at = strpos($argDSN,':');\n\t\t$this->dsnType = substr($argDSN,0,$at);\n\n\t\tif ($argDatabasename) {\n\t\t\tswitch($this->dsnType){\n\t\t\t\tcase 'sqlsrv':\n\t\t\t\t\t$argDSN .= ';database='.$argDatabasename;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mssql':\n\t\t\t\tcase 'mysql':\n\t\t\t\tcase 'oci':\n\t\t\t\tcase 'pgsql':\n\t\t\t\tcase 'sqlite':\n\t\t\t\tdefault:\n\t\t\t\t\t$argDSN .= ';dbname='.$argDatabasename;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\t$this->_connectionID = new PDO($argDSN, $argUsername, $argPassword);\n\t\t} catch (Exception $e) {\n\t\t\t$this->_connectionID = false;\n\t\t\t$this->_errorno = -1;\n\t\t\t//var_dump($e);\n\t\t\t$this->_errormsg = 'Connection attempt failed: '.$e->getMessage();\n\t\t\treturn false;\n\t\t}\n\n\t\tif ($this->_connectionID) {\n\t\t\tswitch(ADODB_ASSOC_CASE){\n\t\t\t\tcase ADODB_ASSOC_CASE_LOWER:\n\t\t\t\t\t$m = PDO::CASE_LOWER;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ADODB_ASSOC_CASE_UPPER:\n\t\t\t\t\t$m = PDO::CASE_UPPER;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase ADODB_ASSOC_CASE_NATIVE:\n\t\t\t\t\t$m = PDO::CASE_NATURAL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//$this->_connectionID->setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_SILENT );\n\t\t\t$this->_connectionID->setAttribute(PDO::ATTR_CASE,$m);\n\n\t\t\t$class = 'ADODB_pdo_'.$this->dsnType;\n\t\t\t//$this->_connectionID->setAttribute(PDO::ATTR_AUTOCOMMIT,true);\n\t\t\tswitch($this->dsnType) {\n\t\t\t\tcase 'mssql':\n\t\t\t\tcase 'mysql':\n\t\t\t\tcase 'oci':\n\t\t\t\tcase 'pgsql':\n\t\t\t\tcase 'sqlite':\n\t\t\t\tcase 'sqlsrv':\n\t\t\t\t\tinclude_once(ADODB_DIR.'/drivers/adodb-pdo_'.$this->dsnType.'.inc.php');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (class_exists($class)) {\n\t\t\t\t$this->_driver = new $class();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$this->_driver = new ADODB_pdo_base();\n\t\t\t}\n\n\t\t\t$this->_driver->_connectionID = $this->_connectionID;\n\t\t\t$this->_UpdatePDO();\n\t\t\t$this->_driver->database = $this->database;\n\t\t\treturn true;\n\t\t}\n\t\t$this->_driver = new ADODB_pdo_base();\n\t\treturn false;\n\t}\n\n\tfunction Concat()\n\t{\n\t\t$args = func_get_args();\n\t\tif(method_exists($this->_driver, 'Concat')) {\n\t\t\treturn call_user_func_array(array($this->_driver, 'Concat'), $args);\n\t\t}\n\n\t\tif (PHP_VERSION >= 5.3) {\n\t\t\treturn call_user_func_array('parent::Concat', $args);\n\t\t}\n\t\treturn call_user_func_array(array($this,'parent::Concat'), $args);\n\t}\n\n\t// returns true or false\n\tfunction _pconnect($argDSN, $argUsername, $argPassword, $argDatabasename)\n\t{\n\t\treturn $this->_connect($argDSN, $argUsername, $argPassword, $argDatabasename, true);\n\t}\n\n\t/*------------------------------------------------------------------------------*/\n\n\n\tfunction SelectLimit($sql,$nrows=-1,$offset=-1,$inputarr=false,$secs2cache=0)\n\t{\n\t\t$save = $this->_driver->fetchMode;\n\t\t$this->_driver->fetchMode = $this->fetchMode;\n\t\t$this->_driver->debug = $this->debug;\n\t\t$ret = $this->_driver->SelectLimit($sql,$nrows,$offset,$inputarr,$secs2cache);\n\t\t$this->_driver->fetchMode = $save;\n\t\treturn $ret;\n\t}\n\n\n\tfunction ServerInfo()\n\t{\n\t\treturn $this->_driver->ServerInfo();\n\t}\n\n\tfunction MetaTables($ttype=false,$showSchema=false,$mask=false)\n\t{\n\t\treturn $this->_driver->MetaTables($ttype,$showSchema,$mask);\n\t}\n\n\tfunction MetaColumns($table,$normalize=true)\n\t{\n\t\treturn $this->_driver->MetaColumns($table,$normalize);\n\t}\n\n\tfunction InParameter(&$stmt,&$var,$name,$maxLen=4000,$type=false)\n\t{\n\t\t$obj = $stmt[1];\n\t\tif ($type) {\n\t\t\t$obj->bindParam($name, $var, $type, $maxLen);\n\t\t}\n\t\telse {\n\t\t\t$obj->bindParam($name, $var);\n\t\t}\n\t}\n\n\tfunction OffsetDate($dayFraction,$date=false)\n\t{\n\t\treturn $this->_driver->OffsetDate($dayFraction,$date);\n\t}\n\n\tfunction SelectDB($dbName)\n\t{\n\t\treturn $this->_driver->SelectDB($dbName);\n\t}\n\n\tfunction SQLDate($fmt, $col=false)\n\t{\n\t\treturn $this->_driver->SQLDate($fmt, $col);\n\t}\n\n\tfunction ErrorMsg()\n\t{\n\t\tif ($this->_errormsg !== false) {\n\t\t\treturn $this->_errormsg;\n\t\t}\n\t\tif (!empty($this->_stmt)) {\n\t\t\t$arr = $this->_stmt->errorInfo();\n\t\t}\n\t\telse if (!empty($this->_connectionID)) {\n\t\t\t$arr = $this->_connectionID->errorInfo();\n\t\t}\n\t\telse {\n\t\t\treturn 'No Connection Established';\n\t\t}\n\n\t\tif ($arr) {\n\t\t\tif (sizeof($arr)<2) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tif ((integer)$arr[0]) {\n\t\t\t\treturn $arr[2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn '-1';\n\t\t}\n\t}\n\n\n\tfunction ErrorNo()\n\t{\n\t\tif ($this->_errorno !== false) {\n\t\t\treturn $this->_errorno;\n\t\t}\n\t\tif (!empty($this->_stmt)) {\n\t\t\t$err = $this->_stmt->errorCode();\n\t\t}\n\t\telse if (!empty($this->_connectionID)) {\n\t\t\t$arr = $this->_connectionID->errorInfo();\n\t\t\tif (isset($arr[0])) {\n\t\t\t\t$err = $arr[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$err = -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ($err == '00000') {\n\t\t\treturn 0; // allows empty check\n\t\t}\n\t\treturn $err;\n\t}\n\n\tfunction SetTransactionMode($transaction_mode)\n\t{\n\t\tif(method_exists($this->_driver, 'SetTransactionMode')) {\n\t\t\treturn $this->_driver->SetTransactionMode($transaction_mode);\n\t\t}\n\n\t\treturn parent::SetTransactionMode($seqname);\n\t}\n\n\tfunction BeginTrans()\n\t{\n\t\tif(method_exists($this->_driver, 'BeginTrans')) {\n\t\t\treturn $this->_driver->BeginTrans();\n\t\t}\n\n\t\tif (!$this->hasTransactions) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($this->transOff) {\n\t\t\treturn true;\n\t\t}\n\t\t$this->transCnt += 1;\n\t\t$this->_autocommit = false;\n\t\t$this->_connectionID->setAttribute(PDO::ATTR_AUTOCOMMIT,false);\n\n\t\treturn $this->_connectionID->beginTransaction();\n\t}\n\n\tfunction CommitTrans($ok=true)\n\t{\n\t\tif(method_exists($this->_driver, 'CommitTrans')) {\n\t\t\treturn $this->_driver->CommitTrans($ok);\n\t\t}\n\n\t\tif (!$this->hasTransactions) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($this->transOff) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!$ok) {\n\t\t\treturn $this->RollbackTrans();\n\t\t}\n\t\tif ($this->transCnt) {\n\t\t\t$this->transCnt -= 1;\n\t\t}\n\t\t$this->_autocommit = true;\n\n\t\t$ret = $this->_connectionID->commit();\n\t\t$this->_connectionID->setAttribute(PDO::ATTR_AUTOCOMMIT,true);\n\t\treturn $ret;\n\t}\n\n\tfunction RollbackTrans()\n\t{\n\t\tif(method_exists($this->_driver, 'RollbackTrans')) {\n\t\t\treturn $this->_driver->RollbackTrans();\n\t\t}\n\n\t\tif (!$this->hasTransactions) {\n\t\t\treturn false;\n\t\t}\n\t\tif ($this->transOff) {\n\t\t\treturn true;\n\t\t}\n\t\tif ($this->transCnt) {\n\t\t\t$this->transCnt -= 1;\n\t\t}\n\t\t$this->_autocommit = true;\n\n\t\t$ret = $this->_connectionID->rollback();\n\t\t$this->_connectionID->setAttribute(PDO::ATTR_AUTOCOMMIT,true);\n\t\treturn $ret;\n\t}\n\n\tfunction Prepare($sql)\n\t{\n\t\t$this->_stmt = $this->_connectionID->prepare($sql);\n\t\tif ($this->_stmt) {\n\t\t\treturn array($sql,$this->_stmt);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction PrepareStmt($sql)\n\t{\n\t\t$stmt = $this->_connectionID->prepare($sql);\n\t\tif (!$stmt) {\n\t\t\treturn false;\n\t\t}\n\t\t$obj = new ADOPDOStatement($stmt,$this);\n\t\treturn $obj;\n\t}\n\n\tfunction CreateSequence($seqname='adodbseq',$startID=1)\n\t{\n\t\tif(method_exists($this->_driver, 'CreateSequence')) {\n\t\t\treturn $this->_driver->CreateSequence($seqname, $startID);\n\t\t}\n\n\t\treturn parent::CreateSequence($seqname, $startID);\n\t}\n\n\tfunction DropSequence($seqname='adodbseq')\n\t{\n\t\tif(method_exists($this->_driver, 'DropSequence')) {\n\t\t\treturn $this->_driver->DropSequence($seqname);\n\t\t}\n\n\t\treturn parent::DropSequence($seqname);\n\t}\n\n\tfunction GenID($seqname='adodbseq',$startID=1)\n\t{\n\t\tif(method_exists($this->_driver, 'GenID')) {\n\t\t\treturn $this->_driver->GenID($seqname, $startID);\n\t\t}\n\n\t\treturn parent::GenID($seqname, $startID);\n\t}\n\n\n\t/* returns queryID or false */\n\tfunction _query($sql,$inputarr=false)\n\t{\n\t\tif (is_array($sql)) {\n\t\t\t$stmt = $sql[1];\n\t\t} else {\n\t\t\t$stmt = $this->_connectionID->prepare($sql);\n\t\t}\n\t\t#adodb_backtrace();\n\t\t#var_dump($this->_bindInputArray);\n\t\tif ($stmt) {\n\t\t\t$this->_driver->debug = $this->debug;\n\t\t\tif ($inputarr) {\n\t\t\t\t$ok = $stmt->execute($inputarr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$ok = $stmt->execute();\n\t\t\t}\n\t\t}\n\n\n\t\t$this->_errormsg = false;\n\t\t$this->_errorno = false;\n\n\t\tif ($ok) {\n\t\t\t$this->_stmt = $stmt;\n\t\t\treturn $stmt;\n\t\t}\n\n\t\tif ($stmt) {\n\n\t\t\t$arr = $stmt->errorinfo();\n\t\t\tif ((integer)$arr[1]) {\n\t\t\t\t$this->_errormsg = $arr[2];\n\t\t\t\t$this->_errorno = $arr[1];\n\t\t\t}\n\n\t\t} else {\n\t\t\t$this->_errormsg = false;\n\t\t\t$this->_errorno = false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// returns true or false\n\tfunction _close()\n\t{\n\t\t$this->_stmt = false;\n\t\treturn true;\n\t}\n\n\tfunction _affectedrows()\n\t{\n\t\treturn ($this->_stmt) ? $this->_stmt->rowCount() : 0;\n\t}\n\n\tfunction _insertid()\n\t{\n\t\treturn ($this->_connectionID) ? $this->_connectionID->lastInsertId() : 0;\n\t}\n\n\t/**\n\t * Quotes a string to be sent to the database.\n\t * If we have an active connection, delegates quoting to the underlying\n\t * PDO object. Otherwise, replace \"'\" by the value of $replaceQuote (same\n\t * behavior as mysqli driver)\n\t * @param string  $s            The string to quote\n\t * @param boolean $magic_quotes If false, use PDO::quote().\n\t * @return string Quoted string\n\t */\n\tfunction qstr($s, $magic_quotes = false)\n\t{\n\t\tif (!$magic_quotes) {\n\t\t\tif ($this->_connectionID) {\n\t\t\t\treturn $this->_connectionID->quote($s);\n\t\t\t}\n\t\t\treturn \"'\" . str_replace(\"'\", $this->replaceQuote, $s) . \"'\";\n\t\t}\n\n\t\t// undo magic quotes for \"\n\t\t$s = str_replace('\\\\\"', '\"', $s);\n\t\treturn \"'$s'\";\n\t}\n\n}\n\nclass ADODB_pdo_base extends ADODB_pdo {\n\n\tvar $sysDate = \"'?'\";\n\tvar $sysTimeStamp = \"'?'\";\n\n\n\tfunction _init($parentDriver)\n\t{\n\t\t$parentDriver->_bindInputArray = true;\n\t\t#$parentDriver->_connectionID->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY,true);\n\t}\n\n\tfunction ServerInfo()\n\t{\n\t\treturn ADOConnection::ServerInfo();\n\t}\n\n\tfunction SelectLimit($sql,$nrows=-1,$offset=-1,$inputarr=false,$secs2cache=0)\n\t{\n\t\t$ret = ADOConnection::SelectLimit($sql,$nrows,$offset,$inputarr,$secs2cache);\n\t\treturn $ret;\n\t}\n\n\tfunction MetaTables($ttype=false,$showSchema=false,$mask=false)\n\t{\n\t\treturn false;\n\t}\n\n\tfunction MetaColumns($table,$normalize=true)\n\t{\n\t\treturn false;\n\t}\n}\n\nclass ADOPDOStatement {\n\n\tvar $databaseType = \"pdo\";\n\tvar $dataProvider = \"pdo\";\n\tvar $_stmt;\n\tvar $_connectionID;\n\n\tfunction __construct($stmt,$connection)\n\t{\n\t\t$this->_stmt = $stmt;\n\t\t$this->_connectionID = $connection;\n\t}\n\n\tfunction Execute($inputArr=false)\n\t{\n\t\t$savestmt = $this->_connectionID->_stmt;\n\t\t$rs = $this->_connectionID->Execute(array(false,$this->_stmt),$inputArr);\n\t\t$this->_connectionID->_stmt = $savestmt;\n\t\treturn $rs;\n\t}\n\n\tfunction InParameter(&$var,$name,$maxLen=4000,$type=false)\n\t{\n\n\t\tif ($type) {\n\t\t\t$this->_stmt->bindParam($name,$var,$type,$maxLen);\n\t\t}\n\t\telse {\n\t\t\t$this->_stmt->bindParam($name, $var);\n\t\t}\n\t}\n\n\tfunction Affected_Rows()\n\t{\n\t\treturn ($this->_stmt) ? $this->_stmt->rowCount() : 0;\n\t}\n\n\tfunction ErrorMsg()\n\t{\n\t\tif ($this->_stmt) {\n\t\t\t$arr = $this->_stmt->errorInfo();\n\t\t}\n\t\telse {\n\t\t\t$arr = $this->_connectionID->errorInfo();\n\t\t}\n\n\t\tif (is_array($arr)) {\n\t\t\tif ((integer) $arr[0] && isset($arr[2])) {\n\t\t\t\treturn $arr[2];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else {\n\t\t\treturn '-1';\n\t\t}\n\t}\n\n\tfunction NumCols()\n\t{\n\t\treturn ($this->_stmt) ? $this->_stmt->columnCount() : 0;\n\t}\n\n\tfunction ErrorNo()\n\t{\n\t\tif ($this->_stmt) {\n\t\t\treturn $this->_stmt->errorCode();\n\t\t}\n\t\telse {\n\t\t\treturn $this->_connectionID->errorInfo();\n\t\t}\n\t}\n}\n\n/*--------------------------------------------------------------------------------------\n\tClass Name: Recordset\n--------------------------------------------------------------------------------------*/\n\nclass ADORecordSet_pdo extends ADORecordSet {\n\n\tvar $bind = false;\n\tvar $databaseType = \"pdo\";\n\tvar $dataProvider = \"pdo\";\n\n\tfunction __construct($id,$mode=false)\n\t{\n\t\tif ($mode === false) {\n\t\t\tglobal $ADODB_FETCH_MODE;\n\t\t\t$mode = $ADODB_FETCH_MODE;\n\t\t}\n\t\t$this->adodbFetchMode = $mode;\n\t\tswitch($mode) {\n\t\tcase ADODB_FETCH_NUM: $mode = PDO::FETCH_NUM; break;\n\t\tcase ADODB_FETCH_ASSOC:  $mode = PDO::FETCH_ASSOC; break;\n\n\t\tcase ADODB_FETCH_BOTH:\n\t\tdefault: $mode = PDO::FETCH_BOTH; break;\n\t\t}\n\t\t$this->fetchMode = $mode;\n\n\t\t$this->_queryID = $id;\n\t\tparent::__construct($id);\n\t}\n\n\n\tfunction Init()\n\t{\n\t\tif ($this->_inited) {\n\t\t\treturn;\n\t\t}\n\t\t$this->_inited = true;\n\t\tif ($this->_queryID) {\n\t\t\t@$this->_initrs();\n\t\t}\n\t\telse {\n\t\t\t$this->_numOfRows = 0;\n\t\t\t$this->_numOfFields = 0;\n\t\t}\n\t\tif ($this->_numOfRows != 0 && $this->_currentRow == -1) {\n\t\t\t$this->_currentRow = 0;\n\t\t\tif ($this->EOF = ($this->_fetch() === false)) {\n\t\t\t\t$this->_numOfRows = 0; // _numOfRows could be -1\n\t\t\t}\n\t\t} else {\n\t\t\t$this->EOF = true;\n\t\t}\n\t}\n\n\tfunction _initrs()\n\t{\n\tglobal $ADODB_COUNTRECS;\n\n\t\t$this->_numOfRows = ($ADODB_COUNTRECS) ? @$this->_queryID->rowCount() : -1;\n\t\tif (!$this->_numOfRows) {\n\t\t\t$this->_numOfRows = -1;\n\t\t}\n\t\t$this->_numOfFields = $this->_queryID->columnCount();\n\t}\n\n\t// returns the field object\n\tfunction FetchField($fieldOffset = -1)\n\t{\n\t\t$off=$fieldOffset+1; // offsets begin at 1\n\n\t\t$o= new ADOFieldObject();\n\t\t$arr = @$this->_queryID->getColumnMeta($fieldOffset);\n\t\tif (!$arr) {\n\t\t\t$o->name = 'bad getColumnMeta()';\n\t\t\t$o->max_length = -1;\n\t\t\t$o->type = 'VARCHAR';\n\t\t\t$o->precision = 0;\n\t#\t\t$false = false;\n\t\t\treturn $o;\n\t\t}\n\t\t//adodb_pr($arr);\n\t\t$o->name = $arr['name'];\n\t\tif (isset($arr['sqlsrv:decl_type']) && $arr['sqlsrv:decl_type'] <> \"null\") \n\t\t{\n\t\t    /*\n\t\t    * If the database is SQL server, use the native built-ins\n\t\t    */\n\t\t    $o->type = $arr['sqlsrv:decl_type'];\n\t\t}\n\t\telseif (isset($arr['native_type']) && $arr['native_type'] <> \"null\") \n\t\t{\n\t\t    $o->type = $arr['native_type'];\n\t\t}\n\t\telse \n\t\t{\n\t\t     $o->type = adodb_pdo_type($arr['pdo_type']);\n\t\t}\n\t\t\n\t\t$o->max_length = $arr['len'];\n\t\t$o->precision = $arr['precision'];\n\n\t\tswitch(ADODB_ASSOC_CASE) {\n\t\t\tcase ADODB_ASSOC_CASE_LOWER:\n\t\t\t\t$o->name = strtolower($o->name);\n\t\t\t\tbreak;\n\t\t\tcase ADODB_ASSOC_CASE_UPPER:\n\t\t\t\t$o->name = strtoupper($o->name);\n\t\t\t\tbreak;\n\t\t}\n\t\treturn $o;\n\t}\n\n\tfunction _seek($row)\n\t{\n\t\treturn false;\n\t}\n\n\tfunction _fetch()\n\t{\n\t\tif (!$this->_queryID) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$this->fields = $this->_queryID->fetch($this->fetchMode);\n\t\treturn !empty($this->fields);\n\t}\n\n\tfunction _close()\n\t{\n\t\t$this->_queryID = false;\n\t}\n\n\tfunction Fields($colname)\n\t{\n\t\tif ($this->adodbFetchMode != ADODB_FETCH_NUM) {\n\t\t\treturn @$this->fields[$colname];\n\t\t}\n\n\t\tif (!$this->bind) {\n\t\t\t$this->bind = array();\n\t\t\tfor ($i=0; $i < $this->_numOfFields; $i++) {\n\t\t\t\t$o = $this->FetchField($i);\n\t\t\t\t$this->bind[strtoupper($o->name)] = $i;\n\t\t\t}\n\t\t}\n\t\treturn $this->fields[$this->bind[strtoupper($colname)]];\n\t}\n\n}\n"], "filenames": ["drivers/adodb-pdo.inc.php"], "buggy_code_start_loc": [520], "buggy_code_end_loc": [520], "fixing_code_start_loc": [521], "fixing_code_end_loc": [545], "type": "CWE-89", "message": "The qstr method in the PDO driver in the ADOdb Library for PHP before 5.x before 5.20.7 might allow remote attackers to conduct SQL injection attacks via vectors related to incorrect quoting.", "other": {"cve": {"id": "CVE-2016-7405", "sourceIdentifier": "cve@mitre.org", "published": "2016-10-03T18:59:14.150", "lastModified": "2017-07-01T01:30:06.063", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The qstr method in the PDO driver in the ADOdb Library for PHP before 5.x before 5.20.7 might allow remote attackers to conduct SQL injection attacks via vectors related to incorrect quoting."}, {"lang": "es", "value": "El m\u00e9todo qstr en el controlador PDO en el ADOdb Library para PHP en versiones anteriores a 5.x en versiones anteriores a 5.20.7 podr\u00eda permitir a atacantes llevar a cabo ataques de inyecci\u00f3n SQL a trav\u00e9s de vectores relacionados con una citaci\u00f3n incorrecta."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.00:beta:*:*:*:*:*:*", "matchCriteriaId": "2ECFB1B6-732D-413A-9C17-4ACD9CBA3589"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.01:beta:*:*:*:*:*:*", "matchCriteriaId": "88114530-BCBB-400E-843E-2F94B1CACC2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.02:*:*:*:*:*:*:*", "matchCriteriaId": "77223E35-5E7E-4151-BB15-C7ADFE4B86B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.02:a:*:*:*:*:*:*", "matchCriteriaId": "7DB61C0F-1FAD-4C3B-9357-43C70A80D018"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.03:*:*:*:*:*:*:*", "matchCriteriaId": "96AF2750-E764-4DF9-B812-E4F84C2DA273"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.04:*:*:*:*:*:*:*", "matchCriteriaId": "09AE12CB-6E89-4382-BD15-CC87EB7E8289"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.04:a:*:*:*:*:*:*", "matchCriteriaId": "FAE026E2-8A7C-41E6-B5BC-C41D7C19A5F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.05:*:*:*:*:*:*:*", "matchCriteriaId": "9EFEE9B0-7BBC-4029-9A8A-16D71CFEFACE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.06:*:*:*:*:*:*:*", "matchCriteriaId": "6212181D-E9B3-499C-854C-A82638DBFCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.06:a:*:*:*:*:*:*", "matchCriteriaId": "372CB285-FE6C-43EB-BD47-4516C3A7ED71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.07:*:*:*:*:*:*:*", "matchCriteriaId": "1FA2E5C8-B64F-48E5-ADCA-3C152554F60D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.08:*:*:*:*:*:*:*", "matchCriteriaId": "E48DFB5E-931D-426A-AF91-7ACEFC7C9FC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.08:a:*:*:*:*:*:*", "matchCriteriaId": "681D942A-24A2-4A86-9200-9E9933612B9C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.09:*:*:*:*:*:*:*", "matchCriteriaId": "95D5E76C-7015-43E9-92E8-C39E421095DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.09:a:*:*:*:*:*:*", "matchCriteriaId": "781839DE-D14B-467B-95A4-1D516C53A650"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.10:*:*:*:*:*:*:*", "matchCriteriaId": "1F80E2D4-7B28-4E3C-A68F-2321DEEAA225"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.11:*:*:*:*:*:*:*", "matchCriteriaId": "5EB6CF54-9531-430D-BBBA-A61148BC2637"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.12:*:*:*:*:*:*:*", "matchCriteriaId": "043417B3-BD61-4169-ABBA-91C6A0A831DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.13:*:*:*:*:*:*:*", "matchCriteriaId": "629829F0-10C0-4B36-8979-3EBAA80F4F57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.14:*:*:*:*:*:*:*", "matchCriteriaId": "710EF645-0060-43CB-9C75-1F8D074FB6DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.15:*:*:*:*:*:*:*", "matchCriteriaId": "0AAB8C30-7B19-4A9B-A067-52D72540AC3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.16:*:*:*:*:*:*:*", "matchCriteriaId": "BB858175-650F-4CFB-B0F2-BE58C2FA7DD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.16:a:*:*:*:*:*:*", "matchCriteriaId": "1E55E92C-301B-429F-9962-676992D0382E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.17:*:*:*:*:*:*:*", "matchCriteriaId": "70C32C6B-5FC3-4329-BDC3-9A16AA84E65F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.18:*:*:*:*:*:*:*", "matchCriteriaId": "914644A3-7D1D-412F-8972-87F73DB03F04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.18:a:*:*:*:*:*:*", "matchCriteriaId": "7D45DEB9-B9C4-44BB-A055-430BF1592597"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.19:*:*:*:*:*:*:*", "matchCriteriaId": "D48D93CC-AD55-4A45-BEF0-4B51F974DD1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.20.0:*:*:*:*:*:*:*", "matchCriteriaId": "055B0185-CEC1-436E-A5CB-6D81C140DDD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.20.1:*:*:*:*:*:*:*", "matchCriteriaId": "AC376C69-63DD-49CF-B1ED-CB58CB9DA59C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.20.2:*:*:*:*:*:*:*", "matchCriteriaId": "2416EB90-A876-485E-A1B7-DD2D3B596EB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.20.3:*:*:*:*:*:*:*", "matchCriteriaId": "E7B26715-C83E-4AF9-AC16-EA1CB50EF6B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.20.4:*:*:*:*:*:*:*", "matchCriteriaId": "8B7A81D1-EAF9-49D0-95B9-187222EE3C57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.20.5:*:*:*:*:*:*:*", "matchCriteriaId": "9E7E9704-58E3-4BD2-822D-44E0C118ABDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:adodb_project:adodb:5.20.6:*:*:*:*:*:*:*", "matchCriteriaId": "F32E9FFE-99AA-41CF-A6D8-176C151779ED"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:php:php:-:*:*:*:*:*:*:*", "matchCriteriaId": "029B5A37-BA8D-4FEC-BE90-856BB9D0D0E1"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/07/8", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/15/1", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "http://www.securityfocus.com/bid/92969", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ADOdb/ADOdb/blob/v5.20.7/docs/changelog.md", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/ADOdb/ADOdb/commit/bd9eca9f40220f9918ec3cc7ae9ef422b3e448b8", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ADOdb/ADOdb/issues/226", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LT3WU77BRUJREZUYQ3ZQBMUIVIVIND4Y/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201701-59", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ADOdb/ADOdb/commit/bd9eca9f40220f9918ec3cc7ae9ef422b3e448b8"}}