{"buggy_code": ["Forge ChangeLog\n===============\n\n## 0.11.0 - 2021-xx-xx\n\n### Removed\n- **SECURITY**, **BREAKING**: Remove `forge.debug` API. The API has the\n  potential for prototype pollution. This API was only briefly used by the\n  maintainers for internal project debug purposes and was never intended to be\n  used with untrusted user inputs. This API was not documented or advertised\n  and is being removed rather than fixed.\n- **BREAKING**: Remove `forge.task` API. This API was never used, documented,\n  or advertised by the maintainers. If anyone was using this API and wishes to\n  continue development it in other project, please let the maintainers know.\n  Due to use in the test suite, a modified version is located in\n  `tests/support/`.\n\n### Added\n- OIDs for `surname`, `title`, and `givenName`.\n\n### Fixed\n- **BREAKING**: OID 2.5.4.5 name fixed from `serialName` to `serialNumber`.\n  Depending on how applications used this id to name association it could cause\n  compatibility issues.\n\n## 0.10.0 - 2020-09-01\n\n### Changed\n- **BREAKING**: Node.js 4 no longer supported. The code *may* still work, and\n  non-invasive patches to keep it working will be considered. However, more\n  modern tools no longer support old Node.js versions making testing difficult.\n\n### Removed\n- **BREAKING**: Remove `util.getPath`, `util.setPath`, and `util.deletePath`.\n  `util.setPath` had a potential prototype pollution security issue when used\n  with unsafe inputs. These functions are not used by `forge` itself. They date\n  from an early time when `forge` was targeted at providing general helper\n  functions. The library direction changed to be more focused on cryptography.\n  Many other excellent libraries are more suitable for general utilities. If\n  you need a replacement for these functions, consider `get`, `set`, and `unset`\n  from [lodash](https://lodash.com/). But also consider the potential similar\n  security issues with those APIs.\n\n## 0.9.2 - 2020-09-01\n\n### Changed\n- Added `util.setPath` security note to function docs and to README.\n\n### Notes\n- **SECURITY**: The `util.setPath` function has the potential to cause\n  prototype pollution if used with unsafe input.\n  - This function is **not** used internally by `forge`.\n  - The rest of the library is unaffected by this issue.\n  - **Do not** use unsafe input with this function.\n  - Usage with known input should function as expected. (Including input\n    intentionally using potentially problematic keys.)\n  - No code changes will be made to address this issue in 0.9.x. The current\n    behavior *could* be considered a feature rather than a security issue.\n    0.10.0 will be released that removes `util.getPath` and `util.setPath`.\n    Consider `get` and `set` from [lodash](https://lodash.com/) if you need\n    replacements. But also consider the potential similar security issues with\n    those APIs.\n  - https://snyk.io/vuln/SNYK-JS-NODEFORGE-598677\n  - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7720\n\n## 0.9.1 - 2019-09-26\n\n### Fixed\n- Ensure DES-CBC given IV is long enough for block size.\n\n## 0.9.0 - 2019-09-04\n\n### Added\n- Add ed25519.publicKeyFromAsn1 and ed25519.privateKeyFromAsn1 APIs.\n- A few OIDs used in EV certs.\n\n### Fixed\n- Improve ed25519 NativeBuffer check.\n\n## 0.8.5 - 2019-06-18\n\n### Fixed\n- Remove use of `const`.\n\n## 0.8.4 - 2019-05-22\n\n### Changed\n- Replace all instances of Node.js `new Buffer` with `Buffer.from` and `Buffer.alloc`.\n\n## 0.8.3 - 2019-05-15\n\n### Fixed\n- Use basic character set for code.\n\n## 0.8.2 - 2019-03-18\n\n### Fixed\n- Fix tag calculation when continuing an AES-GCM block.\n\n### Changed\n- Switch to eslint.\n\n## 0.8.1 - 2019-02-23\n\n### Fixed\n- Fix off-by-1 bug with kem random generation.\n\n## 0.8.0 - 2019-01-31\n\n### Fixed\n- Handle creation of certificates with `notBefore` and `notAfter` dates less\n  than Jan 1, 1950 or greater than or equal to Jan 1, 2050.\n\n### Added\n- Add OID 2.5.4.13 \"description\".\n- Add OID 2.16.840.1.113730.1.13 \"nsComment\".\n  - Also handle extension when creating a certificate.\n- `pki.verifyCertificateChain`:\n  - Add `validityCheckDate` option to allow checking the certificate validity\n    period against an arbitrary `Date` or `null` for no check at all. The\n    current date is used by default.\n- `tls.createConnection`:\n  - Add `verifyOptions` option that passes through to\n    `pki.verifyCertificateChain`. Can be used for the above `validityCheckDate`\n    option.\n\n### Changed\n- Support WebCrypto API in web workers.\n- `rsa.generateKeyPair`:\n  - Use `crypto.generateKeyPair`/`crypto.generateKeyPairSync` on Node.js if\n    available (10.12.0+) and not in pure JS mode.\n  - Use JS fallback in `rsa.generateKeyPair` if `prng` option specified since\n    this isn't supported by current native APIs.\n  - Only run key generation comparison tests if keys will be deterministic.\n- PhantomJS is deprecated, now using Headless Chrome with Karma.\n- **Note**: Using Headless Chrome vs PhantomJS may cause newer JS features to\n  slip into releases without proper support for older runtimes and browsers.\n  Please report such issues and they will be addressed.\n- `pki.verifyCertificateChain`:\n  - Signature changed to `(caStore, chain, options)`. Older `(caStore, chain,\n    verify)` signature is still supported. New style is to to pass in a\n    `verify` option.\n\n## 0.7.6 - 2018-08-14\n\n### Added\n- Test on Node.js 10.x.\n- Support for PKCS#7 detached signatures.\n\n### Changed\n- Improve webpack/browser detection.\n\n## 0.7.5 - 2018-03-30\n\n### Fixed\n- Remove use of `const`.\n\n## 0.7.4 - 2018-03-07\n\n### Fixed\n- Potential regex denial of service in form.js.\n\n### Added\n- Support for ED25519.\n- Support for baseN/base58.\n\n## 0.7.3 - 2018-03-05\n\n- Re-publish with npm 5.6.0 due to file timestamp issues.\n\n## 0.7.2 - 2018-02-27\n\n### Added\n- Support verification of SHA-384 certificates.\n- `1.2.840.10040.4.3'`/`dsa-with-sha1` OID.\n\n### Fixed\n- Support importing PKCS#7 data with no certificates. RFC 2315 sec 9.1 states\n  certificates are optional.\n- `asn1.equals` loop bug.\n- Fortuna implementation bugs.\n\n## 0.7.1 - 2017-03-27\n\n### Fixed\n\n- Fix digestLength for hashes based on SHA-512.\n\n## 0.7.0 - 2017-02-07\n\n### Fixed\n\n- Fix test looping bugs so all tests are run.\n- Improved ASN.1 parsing. Many failure cases eliminated. More sanity checks.\n  Better behavior in default mode of parsing BIT STRINGs. Better handling of\n  parsed BIT STRINGs in `toDer()`. More tests.\n- Improve X.509 BIT STRING handling by using new capture modes.\n\n### Changed\n\n- Major refactor to use CommonJS plus a browser build system.\n- Updated tests, examples, docs.\n- Updated dependencies.\n- Updated flash build system.\n- Improve OID mapping code.\n- Change test servers from Python to JavaScript.\n- Improve PhantomJS support.\n- Move Bower/bundle support to\n  [forge-dist](https://github.com/digitalbazaar/forge-dist).\n- **BREAKING**: Require minimal digest algorithm dependencies from individual\n  modules.\n- Enforce currently supported bit param values for byte buffer access. May be\n  **BREAKING** for code that depended on unspecified and/or incorrect behavior.\n- Improve `asn1.prettyPrint()` BIT STRING display.\n\n### Added\n\n- webpack bundler support via `npm run build`:\n  - Builds `.js`, `.min.js`, and basic sourcemaps.\n  - Basic build: `forge.js`.\n  - Build with extra utils and networking support: `forge.all.js`.\n  - Build WebWorker support: `prime.worker.js`.\n- Browserify support in package.json.\n- Karma browser testing.\n- `forge.options` field.\n- `forge.options.usePureJavaScript` flag.\n- `forge.util.isNodejs` flag (used to select \"native\" APIs).\n- Run PhantomJS tests in Travis-CI.\n- Add \"Donations\" section to README.\n- Add IRC to \"Contact\" section of README.\n- Add \"Security Considerations\" section to README.\n- Add pbkdf2 usePureJavaScript test.\n- Add rsa.generateKeyPair async and usePureJavaScript tests.\n- Add .editorconfig support.\n- Add `md.all.js` which includes all digest algorithms.\n- Add asn1 `equals()` and `copy()`.\n- Add asn1 `validate()` capture options for BIT STRING contents and value.\n\n### Removed\n\n- **BREAKING**: Can no longer call `forge({...})` to create new instances.\n- Remove a large amount of old cruft.\n\n### Migration from 0.6.x to 0.7.x\n\n- (all) If you used the feature to create a new forge instance with new\n  configuration options you will need to rework your code. That ability has\n  been removed due to implementation complexity. The main rare use was to set\n  the option to use pure JavaScript. That is now available as a library global\n  flag `forge.options.usePureJavaScript`.\n- (npm,bower) If you used the default main file there is little to nothing to\n  change.\n- (npm) If you accessed a sub-resource like `forge/js/pki` you should either\n  switch to just using the main `forge` and access `forge.pki` or update to\n  `forge/lib/pki`.\n- (bower) If you used a sub-resource like `forge/js/pki` you should switch to\n  just using `forge` and access `forge.pki`. The bower release bundles\n  everything in one minified file.\n- (bower) A configured workerScript like\n  `/bower_components/forge/js/prime.worker.js` will need to change to\n  `/bower_components/forge/dist/prime.worker.min.js`.\n- (all) If you used the networking support or flash socket support, you will\n  need to use a custom build and/or adjust where files are loaded from. This\n  functionality is not included in the bower distribution by default and is\n  also now in a different directory.\n- (all) The library should now directly support building custom bundles with\n  webpack, browserify, or similar.\n- (all) If building a custom bundle ensure the correct dependencies are\n  included. In particular, note there is now a `md.all.js` file to include all\n  digest algorithms. Individual files limit what they include by default to\n  allow smaller custom builds. For instance, `pbdkf2.js` has a `sha1` default\n  but does not include any algorithm files by default. This allows the\n  possibility to include only `sha256` without the overhead of `sha1` and\n  `sha512`.\n\n### Notes\n\n- This major update requires updating the version to 0.7.x. The existing\n  work-in-progress \"0.7.x\" branch will be painfully rebased on top of this new\n  0.7.x and moved forward to 0.8.x or later as needed.\n- 0.7.x is a start of simplifying forge based on common issues and what has\n  appeared to be the most common usage. Please file issues with feedback if the\n  changes are problematic for your use cases.\n\n## 0.6.x - 2016 and earlier\n\n- See Git commit log or https://github.com/digitalbazaar/forge.\n", "# Forge\n\n[![npm package](https://nodei.co/npm/node-forge.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/node-forge/)\n\n[![Build Status](https://github.com/digitalbazaar/forge/workflows/Main%20Checks/badge.svg)](https://github.com/digitalbazaar/forge/actions?query=workflow%3A%22Main+Checks%22)\n\nA native implementation of [TLS][] (and various other cryptographic tools) in\n[JavaScript][].\n\nIntroduction\n------------\n\nThe Forge software is a fully native implementation of the [TLS][] protocol\nin JavaScript, a set of cryptography utilities, and a set of tools for\ndeveloping Web Apps that utilize many network resources.\n\nPerformance\n------------\n\nForge is fast. Benchmarks against other popular JavaScript cryptography\nlibraries can be found here:\n\n* http://dominictarr.github.io/crypto-bench/\n* http://cryptojs.altervista.org/test/simulate-threading-speed_test.html\n\nDocumentation\n-------------\n\n* [Introduction](#introduction)\n* [Performance](#performance)\n* [Installation](#installation)\n* [Testing](#testing)\n* [Contributing](#contributing)\n\n### API\n\n* [Options](#options)\n\n### Transports\n\n* [TLS](#tls)\n* [HTTP](#http)\n* [SSH](#ssh)\n* [XHR](#xhr)\n* [Sockets](#socket)\n\n### Ciphers\n\n* [CIPHER](#cipher)\n* [AES](#aes)\n* [DES](#des)\n* [RC2](#rc2)\n\n### PKI\n\n* [ED25519](#ed25519)\n* [RSA](#rsa)\n* [RSA-KEM](#rsakem)\n* [X.509](#x509)\n* [PKCS#5](#pkcs5)\n* [PKCS#7](#pkcs7)\n* [PKCS#8](#pkcs8)\n* [PKCS#10](#pkcs10)\n* [PKCS#12](#pkcs12)\n* [ASN.1](#asn)\n\n### Message Digests\n\n* [SHA1](#sha1)\n* [SHA256](#sha256)\n* [SHA384](#sha384)\n* [SHA512](#sha512)\n* [MD5](#md5)\n* [HMAC](#hmac)\n\n### Utilities\n\n* [Prime](#prime)\n* [PRNG](#prng)\n* [Tasks](#task)\n* [Utilities](#util)\n* [Logging](#log)\n* [Flash Networking Support](#flash)\n\n### Other\n\n* [Security Considerations](#security-considerations)\n* [Library Background](#library-background)\n* [Contact](#contact)\n* [Donations](#donations)\n\n---------------------------------------\n\nInstallation\n------------\n\n**Note**: Please see the [Security Considerations](#security-considerations)\nsection before using packaging systems and pre-built files.\n\nForge uses a [CommonJS][] module structure with a build process for browser\nbundles. The older [0.6.x][] branch with standalone files is available but will\nnot be regularly updated.\n\n### Node.js\n\nIf you want to use forge with [Node.js][], it is available through `npm`:\n\nhttps://npmjs.org/package/node-forge\n\nInstallation:\n\n    npm install node-forge\n\nYou can then use forge as a regular module:\n\n```js\nvar forge = require('node-forge');\n```\n\nThe npm package includes pre-built `forge.min.js`, `forge.all.min.js`, and\n`prime.worker.min.js` using the [UMD][] format.\n\n### Bundle / Bower\n\nEach release is published in a separate repository as pre-built and minimized\nbasic forge bundles using the [UMD][] format.\n\nhttps://github.com/digitalbazaar/forge-dist\n\nThis bundle can be used in many environments. In particular it can be installed\nwith [Bower][]:\n\n    bower install forge\n\n### jsDelivr CDN\n\nTo use it via [jsDelivr](https://www.jsdelivr.com/package/npm/node-forge) include this in your html:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/node-forge@0.7.0/dist/forge.min.js\"></script>\n```\n\n### unpkg CDN\n\nTo use it via [unpkg](https://unpkg.com/#/) include this in your html:\n\n```html\n<script src=\"https://unpkg.com/node-forge@0.7.0/dist/forge.min.js\"></script>\n```\n\n### Development Requirements\n\nThe core JavaScript has the following requirements to build and test:\n\n* Building a browser bundle:\n  * Node.js\n  * npm\n* Testing\n  * Node.js\n  * npm\n  * Chrome, Firefox, Safari (optional)\n\nSome special networking features can optionally use a Flash component.  See the\n[Flash README](./flash/README.md) for details.\n\n### Building for a web browser\n\nTo create single file bundles for use with browsers run the following:\n\n    npm install\n    npm run build\n\nThis will create single non-minimized and minimized files that can be\nincluded in the browser:\n\n    dist/forge.js\n    dist/forge.min.js\n\nA bundle that adds some utilities and networking support is also available:\n\n    dist/forge.all.js\n    dist/forge.all.min.js\n\nInclude the file via:\n\n```html\n<script src=\"YOUR_SCRIPT_PATH/forge.js\"></script>\n```\nor\n```html\n<script src=\"YOUR_SCRIPT_PATH/forge.min.js\"></script>\n```\n\nThe above bundles will synchronously create a global 'forge' object.\n\n**Note**: These bundles will not include any WebWorker scripts (eg:\n`dist/prime.worker.js`), so these will need to be accessible from the browser\nif any WebWorkers are used.\n\n### Building a custom browser bundle\n\nThe build process uses [webpack][] and the [config](./webpack.config.js) file\ncan be modified to generate a file or files that only contain the parts of\nforge you need.\n\n[Browserify][] override support is also present in `package.json`.\n\nTesting\n-------\n\n### Prepare to run tests\n\n    npm install\n\n### Running automated tests with Node.js\n\nForge natively runs in a [Node.js][] environment:\n\n    npm test\n\n### Running automated tests with Headless Chrome\n\nAutomated testing is done via [Karma][]. By default it will run the tests with\nHeadless Chrome.\n\n    npm run test-karma\n\nIs 'mocha' reporter output too verbose? Other reporters are available. Try\n'dots', 'progress', or 'tap'.\n\n    npm run test-karma -- --reporters progress\n\nBy default [webpack][] is used. [Browserify][] can also be used.\n\n    BUNDLER=browserify npm run test-karma\n\n### Running automated tests with one or more browsers\n\nYou can also specify one or more browsers to use.\n\n    npm run test-karma -- --browsers Chrome,Firefox,Safari,ChromeHeadless\n\nThe reporter option and `BUNDLER` environment variable can also be used.\n\n### Running manual tests in a browser\n\nTesting in a browser uses [webpack][] to combine forge and all tests and then\nloading the result in a browser. A simple web server is provided that will\noutput the HTTP or HTTPS URLs to load. It also will start a simple Flash Policy\nServer. Unit tests and older legacy tests are provided. Custom ports can be\nused by running `node tests/server.js` manually.\n\nTo run the unit tests in a browser a special forge build is required:\n\n    npm run test-build\n\nTo run legacy browser based tests the main forge build is required:\n\n    npm run build\n\nThe tests are run with a custom server that prints out the URLs to use:\n\n    npm run test-server\n\n### Running other tests\n\nThere are some other random tests and benchmarks available in the tests\ndirectory.\n\n### Coverage testing\n\nTo perform coverage testing of the unit tests, run the following. The results\nwill be put in the `coverage/` directory. Note that coverage testing can slow\ndown some tests considerably.\n\n    npm install\n    npm run coverage\n\nContributing\n------------\n\nAny contributions (eg: PRs) that are accepted will be brought under the same\nlicense used by the rest of the Forge project. This license allows Forge to\nbe used under the terms of either the BSD License or the GNU General Public\nLicense (GPL) Version 2.\n\nSee: [LICENSE](https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE)\n\nIf a contribution contains 3rd party source code with its own license, it\nmay retain it, so long as that license is compatible with the Forge license.\n\nAPI\n---\n\n<a name=\"options\" />\n\n### Options\n\nIf at any time you wish to disable the use of native code, where available,\nfor particular forge features like its secure random number generator, you\nmay set the ```forge.options.usePureJavaScript``` flag to ```true```. It is\nnot recommended that you set this flag as native code is typically more\nperformant and may have stronger security properties. It may be useful to\nset this flag to test certain features that you plan to run in environments\nthat are different from your testing environment.\n\nTo disable native code when including forge in the browser:\n\n```js\n// run this *after* including the forge script\nforge.options.usePureJavaScript = true;\n```\n\nTo disable native code when using Node.js:\n\n```js\nvar forge = require('node-forge');\nforge.options.usePureJavaScript = true;\n```\n\nTransports\n----------\n\n<a name=\"tls\" />\n\n### TLS\n\nProvides a native javascript client and server-side [TLS][] implementation.\n\n__Examples__\n\n```js\n// create TLS client\nvar client = forge.tls.createConnection({\n  server: false,\n  caStore: /* Array of PEM-formatted certs or a CA store object */,\n  sessionCache: {},\n  // supported cipher suites in order of preference\n  cipherSuites: [\n    forge.tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA,\n    forge.tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA],\n  virtualHost: 'example.com',\n  verify: function(connection, verified, depth, certs) {\n    if(depth === 0) {\n      var cn = certs[0].subject.getField('CN').value;\n      if(cn !== 'example.com') {\n        verified = {\n          alert: forge.tls.Alert.Description.bad_certificate,\n          message: 'Certificate common name does not match hostname.'\n        };\n      }\n    }\n    return verified;\n  },\n  connected: function(connection) {\n    console.log('connected');\n    // send message to server\n    connection.prepare(forge.util.encodeUtf8('Hi server!'));\n    /* NOTE: experimental, start heartbeat retransmission timer\n    myHeartbeatTimer = setInterval(function() {\n      connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));\n    }, 5*60*1000);*/\n  },\n  /* provide a client-side cert if you want\n  getCertificate: function(connection, hint) {\n    return myClientCertificate;\n  },\n  /* the private key for the client-side cert if provided */\n  getPrivateKey: function(connection, cert) {\n    return myClientPrivateKey;\n  },\n  tlsDataReady: function(connection) {\n    // TLS data (encrypted) is ready to be sent to the server\n    sendToServerSomehow(connection.tlsData.getBytes());\n    // if you were communicating with the server below, you'd do:\n    // server.process(connection.tlsData.getBytes());\n  },\n  dataReady: function(connection) {\n    // clear data from the server is ready\n    console.log('the server sent: ' +\n      forge.util.decodeUtf8(connection.data.getBytes()));\n    // close connection\n    connection.close();\n  },\n  /* NOTE: experimental\n  heartbeatReceived: function(connection, payload) {\n    // restart retransmission timer, look at payload\n    clearInterval(myHeartbeatTimer);\n    myHeartbeatTimer = setInterval(function() {\n      connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));\n    }, 5*60*1000);\n    payload.getBytes();\n  },*/\n  closed: function(connection) {\n    console.log('disconnected');\n  },\n  error: function(connection, error) {\n    console.log('uh oh', error);\n  }\n});\n\n// start the handshake process\nclient.handshake();\n\n// when encrypted TLS data is received from the server, process it\nclient.process(encryptedBytesFromServer);\n\n// create TLS server\nvar server = forge.tls.createConnection({\n  server: true,\n  caStore: /* Array of PEM-formatted certs or a CA store object */,\n  sessionCache: {},\n  // supported cipher suites in order of preference\n  cipherSuites: [\n    forge.tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA,\n    forge.tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA],\n  // require a client-side certificate if you want\n  verifyClient: true,\n  verify: function(connection, verified, depth, certs) {\n    if(depth === 0) {\n      var cn = certs[0].subject.getField('CN').value;\n      if(cn !== 'the-client') {\n        verified = {\n          alert: forge.tls.Alert.Description.bad_certificate,\n          message: 'Certificate common name does not match expected client.'\n        };\n      }\n    }\n    return verified;\n  },\n  connected: function(connection) {\n    console.log('connected');\n    // send message to client\n    connection.prepare(forge.util.encodeUtf8('Hi client!'));\n    /* NOTE: experimental, start heartbeat retransmission timer\n    myHeartbeatTimer = setInterval(function() {\n      connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));\n    }, 5*60*1000);*/\n  },\n  getCertificate: function(connection, hint) {\n    return myServerCertificate;\n  },\n  getPrivateKey: function(connection, cert) {\n    return myServerPrivateKey;\n  },\n  tlsDataReady: function(connection) {\n    // TLS data (encrypted) is ready to be sent to the client\n    sendToClientSomehow(connection.tlsData.getBytes());\n    // if you were communicating with the client above you'd do:\n    // client.process(connection.tlsData.getBytes());\n  },\n  dataReady: function(connection) {\n    // clear data from the client is ready\n    console.log('the client sent: ' +\n      forge.util.decodeUtf8(connection.data.getBytes()));\n    // close connection\n    connection.close();\n  },\n  /* NOTE: experimental\n  heartbeatReceived: function(connection, payload) {\n    // restart retransmission timer, look at payload\n    clearInterval(myHeartbeatTimer);\n    myHeartbeatTimer = setInterval(function() {\n      connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));\n    }, 5*60*1000);\n    payload.getBytes();\n  },*/\n  closed: function(connection) {\n    console.log('disconnected');\n  },\n  error: function(connection, error) {\n    console.log('uh oh', error);\n  }\n});\n\n// when encrypted TLS data is received from the client, process it\nserver.process(encryptedBytesFromClient);\n```\n\nConnect to a TLS server using node's net.Socket:\n\n```js\nvar socket = new net.Socket();\n\nvar client = forge.tls.createConnection({\n  server: false,\n  verify: function(connection, verified, depth, certs) {\n    // skip verification for testing\n    console.log('[tls] server certificate verified');\n    return true;\n  },\n  connected: function(connection) {\n    console.log('[tls] connected');\n    // prepare some data to send (note that the string is interpreted as\n    // 'binary' encoded, which works for HTTP which only uses ASCII, use\n    // forge.util.encodeUtf8(str) otherwise\n    client.prepare('GET / HTTP/1.0\\r\\n\\r\\n');\n  },\n  tlsDataReady: function(connection) {\n    // encrypted data is ready to be sent to the server\n    var data = connection.tlsData.getBytes();\n    socket.write(data, 'binary'); // encoding should be 'binary'\n  },\n  dataReady: function(connection) {\n    // clear data from the server is ready\n    var data = connection.data.getBytes();\n    console.log('[tls] data received from the server: ' + data);\n  },\n  closed: function() {\n    console.log('[tls] disconnected');\n  },\n  error: function(connection, error) {\n    console.log('[tls] error', error);\n  }\n});\n\nsocket.on('connect', function() {\n  console.log('[socket] connected');\n  client.handshake();\n});\nsocket.on('data', function(data) {\n  client.process(data.toString('binary')); // encoding should be 'binary'\n});\nsocket.on('end', function() {\n  console.log('[socket] disconnected');\n});\n\n// connect to google.com\nsocket.connect(443, 'google.com');\n\n// or connect to gmail's imap server (but don't send the HTTP header above)\n//socket.connect(993, 'imap.gmail.com');\n```\n\n<a name=\"http\" />\n\n### HTTP\n\nProvides a native [JavaScript][] mini-implementation of an http client that\nuses pooled sockets.\n\n__Examples__\n\n```js\n// create an HTTP GET request\nvar request = forge.http.createRequest({method: 'GET', path: url.path});\n\n// send the request somewhere\nsendSomehow(request.toString());\n\n// receive response\nvar buffer = forge.util.createBuffer();\nvar response = forge.http.createResponse();\nvar someAsyncDataHandler = function(bytes) {\n  if(!response.bodyReceived) {\n    buffer.putBytes(bytes);\n    if(!response.headerReceived) {\n      if(response.readHeader(buffer)) {\n        console.log('HTTP response header: ' + response.toString());\n      }\n    }\n    if(response.headerReceived && !response.bodyReceived) {\n      if(response.readBody(buffer)) {\n        console.log('HTTP response body: ' + response.body);\n      }\n    }\n  }\n};\n```\n\n<a name=\"ssh\" />\n\n### SSH\n\nProvides some SSH utility functions.\n\n__Examples__\n\n```js\n// encodes (and optionally encrypts) a private RSA key as a Putty PPK file\nforge.ssh.privateKeyToPutty(privateKey, passphrase, comment);\n\n// encodes a public RSA key as an OpenSSH file\nforge.ssh.publicKeyToOpenSSH(key, comment);\n\n// encodes a private RSA key as an OpenSSH file\nforge.ssh.privateKeyToOpenSSH(privateKey, passphrase);\n\n// gets the SSH public key fingerprint in a byte buffer\nforge.ssh.getPublicKeyFingerprint(key);\n\n// gets a hex-encoded, colon-delimited SSH public key fingerprint\nforge.ssh.getPublicKeyFingerprint(key, {encoding: 'hex', delimiter: ':'});\n```\n\n<a name=\"xhr\" />\n\n### XHR\n\nProvides an XmlHttpRequest implementation using forge.http as a backend.\n\n__Examples__\n\n```js\n// TODO\n```\n\n<a name=\"socket\" />\n\n### Sockets\n\nProvides an interface to create and use raw sockets provided via Flash.\n\n__Examples__\n\n```js\n// TODO\n```\n\nCiphers\n-------\n\n<a name=\"cipher\" />\n\n### CIPHER\n\nProvides a basic API for block encryption and decryption. There is built-in\nsupport for the ciphers: [AES][], [3DES][], and [DES][], and for the modes\nof operation: [ECB][], [CBC][], [CFB][], [OFB][], [CTR][], and [GCM][].\n\nThese algorithms are currently supported:\n\n* AES-ECB\n* AES-CBC\n* AES-CFB\n* AES-OFB\n* AES-CTR\n* AES-GCM\n* 3DES-ECB\n* 3DES-CBC\n* DES-ECB\n* DES-CBC\n\nWhen using an [AES][] algorithm, the key size will determine whether\nAES-128, AES-192, or AES-256 is used (all are supported). When a [DES][]\nalgorithm is used, the key size will determine whether [3DES][] or regular\n[DES][] is used. Use a [3DES][] algorithm to enforce Triple-DES.\n\n__Examples__\n\n```js\n// generate a random key and IV\n// Note: a key size of 16 bytes will use AES-128, 24 => AES-192, 32 => AES-256\nvar key = forge.random.getBytesSync(16);\nvar iv = forge.random.getBytesSync(16);\n\n/* alternatively, generate a password-based 16-byte key\nvar salt = forge.random.getBytesSync(128);\nvar key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);\n*/\n\n// encrypt some bytes using CBC mode\n// (other modes include: ECB, CFB, OFB, CTR, and GCM)\n// Note: CBC and ECB modes use PKCS#7 padding as default\nvar cipher = forge.cipher.createCipher('AES-CBC', key);\ncipher.start({iv: iv});\ncipher.update(forge.util.createBuffer(someBytes));\ncipher.finish();\nvar encrypted = cipher.output;\n// outputs encrypted hex\nconsole.log(encrypted.toHex());\n\n// decrypt some bytes using CBC mode\n// (other modes include: CFB, OFB, CTR, and GCM)\nvar decipher = forge.cipher.createDecipher('AES-CBC', key);\ndecipher.start({iv: iv});\ndecipher.update(encrypted);\nvar result = decipher.finish(); // check 'result' for true/false\n// outputs decrypted hex\nconsole.log(decipher.output.toHex());\n\n// decrypt bytes using CBC mode and streaming\n// Performance can suffer for large multi-MB inputs due to buffer\n// manipulations. Stream processing in chunks can offer significant\n// improvement. CPU intensive update() calls could also be performed with\n// setImmediate/setTimeout to avoid blocking the main browser UI thread (not\n// shown here). Optimal block size depends on the JavaScript VM and other\n// factors. Encryption can use a simple technique for increased performance.\nvar encryptedBytes = encrypted.bytes();\nvar decipher = forge.cipher.createDecipher('AES-CBC', key);\ndecipher.start({iv: iv});\nvar length = encryptedBytes.length;\nvar chunkSize = 1024 * 64;\nvar index = 0;\nvar decrypted = '';\ndo {\n  decrypted += decipher.output.getBytes();\n  var buf = forge.util.createBuffer(encryptedBytes.substr(index, chunkSize));\n  decipher.update(buf);\n  index += chunkSize;\n} while(index < length);\nvar result = decipher.finish();\nassert(result);\ndecrypted += decipher.output.getBytes();\nconsole.log(forge.util.bytesToHex(decrypted));\n\n// encrypt some bytes using GCM mode\nvar cipher = forge.cipher.createCipher('AES-GCM', key);\ncipher.start({\n  iv: iv, // should be a 12-byte binary-encoded string or byte buffer\n  additionalData: 'binary-encoded string', // optional\n  tagLength: 128 // optional, defaults to 128 bits\n});\ncipher.update(forge.util.createBuffer(someBytes));\ncipher.finish();\nvar encrypted = cipher.output;\nvar tag = cipher.mode.tag;\n// outputs encrypted hex\nconsole.log(encrypted.toHex());\n// outputs authentication tag\nconsole.log(tag.toHex());\n\n// decrypt some bytes using GCM mode\nvar decipher = forge.cipher.createDecipher('AES-GCM', key);\ndecipher.start({\n  iv: iv,\n  additionalData: 'binary-encoded string', // optional\n  tagLength: 128, // optional, defaults to 128 bits\n  tag: tag // authentication tag from encryption\n});\ndecipher.update(encrypted);\nvar pass = decipher.finish();\n// pass is false if there was a failure (eg: authentication tag didn't match)\nif(pass) {\n  // outputs decrypted hex\n  console.log(decipher.output.toHex());\n}\n```\n\nUsing forge in Node.js to match openssl's \"enc\" command line tool (**Note**: OpenSSL \"enc\" uses a non-standard file format with a custom key derivation function and a fixed iteration count of 1, which some consider less secure than alternatives such as [OpenPGP](https://tools.ietf.org/html/rfc4880)/[GnuPG](https://www.gnupg.org/)):\n\n```js\nvar forge = require('node-forge');\nvar fs = require('fs');\n\n// openssl enc -des3 -in input.txt -out input.enc\nfunction encrypt(password) {\n  var input = fs.readFileSync('input.txt', {encoding: 'binary'});\n\n  // 3DES key and IV sizes\n  var keySize = 24;\n  var ivSize = 8;\n\n  // get derived bytes\n  // Notes:\n  // 1. If using an alternative hash (eg: \"-md sha1\") pass\n  //   \"forge.md.sha1.create()\" as the final parameter.\n  // 2. If using \"-nosalt\", set salt to null.\n  var salt = forge.random.getBytesSync(8);\n  // var md = forge.md.sha1.create(); // \"-md sha1\"\n  var derivedBytes = forge.pbe.opensslDeriveBytes(\n    password, salt, keySize + ivSize/*, md*/);\n  var buffer = forge.util.createBuffer(derivedBytes);\n  var key = buffer.getBytes(keySize);\n  var iv = buffer.getBytes(ivSize);\n\n  var cipher = forge.cipher.createCipher('3DES-CBC', key);\n  cipher.start({iv: iv});\n  cipher.update(forge.util.createBuffer(input, 'binary'));\n  cipher.finish();\n\n  var output = forge.util.createBuffer();\n\n  // if using a salt, prepend this to the output:\n  if(salt !== null) {\n    output.putBytes('Salted__'); // (add to match openssl tool output)\n    output.putBytes(salt);\n  }\n  output.putBuffer(cipher.output);\n\n  fs.writeFileSync('input.enc', output.getBytes(), {encoding: 'binary'});\n}\n\n// openssl enc -d -des3 -in input.enc -out input.dec.txt\nfunction decrypt(password) {\n  var input = fs.readFileSync('input.enc', {encoding: 'binary'});\n\n  // parse salt from input\n  input = forge.util.createBuffer(input, 'binary');\n  // skip \"Salted__\" (if known to be present)\n  input.getBytes('Salted__'.length);\n  // read 8-byte salt\n  var salt = input.getBytes(8);\n\n  // Note: if using \"-nosalt\", skip above parsing and use\n  // var salt = null;\n\n  // 3DES key and IV sizes\n  var keySize = 24;\n  var ivSize = 8;\n\n  var derivedBytes = forge.pbe.opensslDeriveBytes(\n    password, salt, keySize + ivSize);\n  var buffer = forge.util.createBuffer(derivedBytes);\n  var key = buffer.getBytes(keySize);\n  var iv = buffer.getBytes(ivSize);\n\n  var decipher = forge.cipher.createDecipher('3DES-CBC', key);\n  decipher.start({iv: iv});\n  decipher.update(input);\n  var result = decipher.finish(); // check 'result' for true/false\n\n  fs.writeFileSync(\n    'input.dec.txt', decipher.output.getBytes(), {encoding: 'binary'});\n}\n```\n\n<a name=\"aes\" />\n\n### AES\n\nProvides [AES][] encryption and decryption in [CBC][], [CFB][], [OFB][],\n[CTR][], and [GCM][] modes. See [CIPHER](#cipher) for examples.\n\n<a name=\"des\" />\n\n### DES\n\nProvides [3DES][] and [DES][] encryption and decryption in [ECB][] and\n[CBC][] modes. See [CIPHER](#cipher) for examples.\n\n<a name=\"rc2\" />\n\n### RC2\n\n__Examples__\n\n```js\n// generate a random key and IV\nvar key = forge.random.getBytesSync(16);\nvar iv = forge.random.getBytesSync(8);\n\n// encrypt some bytes\nvar cipher = forge.rc2.createEncryptionCipher(key);\ncipher.start(iv);\ncipher.update(forge.util.createBuffer(someBytes));\ncipher.finish();\nvar encrypted = cipher.output;\n// outputs encrypted hex\nconsole.log(encrypted.toHex());\n\n// decrypt some bytes\nvar cipher = forge.rc2.createDecryptionCipher(key);\ncipher.start(iv);\ncipher.update(encrypted);\ncipher.finish();\n// outputs decrypted hex\nconsole.log(cipher.output.toHex());\n```\n\nPKI\n---\n\nProvides [X.509][] certificate support, ED25519 key generation and\nsigning/verifying, and RSA public and private key encoding, decoding,\nencryption/decryption, and signing/verifying.\n\n<a name=\"ed25519\" />\n\n### ED25519\n\nSpecial thanks to [TweetNaCl.js][] for providing the bulk of the implementation.\n\n__Examples__\n\n```js\nvar ed25519 = forge.pki.ed25519;\n\n// generate a random ED25519 keypair\nvar keypair = ed25519.generateKeyPair();\n// `keypair.publicKey` is a node.js Buffer or Uint8Array\n// `keypair.privateKey` is a node.js Buffer or Uint8Array\n\n// generate a random ED25519 keypair based on a random 32-byte seed\nvar seed = forge.random.getBytesSync(32);\nvar keypair = ed25519.generateKeyPair({seed: seed});\n\n// generate a random ED25519 keypair based on a \"password\" 32-byte seed\nvar password = 'Mai9ohgh6ahxee0jutheew0pungoozil';\nvar seed = new forge.util.ByteBuffer(password, 'utf8');\nvar keypair = ed25519.generateKeyPair({seed: seed});\n\n// sign a UTF-8 message\nvar signature = ED25519.sign({\n  message: 'test',\n  // also accepts `binary` if you want to pass a binary string\n  encoding: 'utf8',\n  // node.js Buffer, Uint8Array, forge ByteBuffer, binary string\n  privateKey: privateKey\n});\n// `signature` is a node.js Buffer or Uint8Array\n\n// sign a message passed as a buffer\nvar signature = ED25519.sign({\n  // also accepts a forge ByteBuffer or Uint8Array\n  message: Buffer.from('test', 'utf8'),\n  privateKey: privateKey\n});\n\n// sign a message digest (shorter \"message\" == better performance)\nvar md = forge.md.sha256.create();\nmd.update('test', 'utf8');\nvar signature = ED25519.sign({\n  md: md,\n  privateKey: privateKey\n});\n\n// verify a signature on a UTF-8 message\nvar verified = ED25519.verify({\n  message: 'test',\n  encoding: 'utf8',\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  signature: signature,\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  publicKey: publicKey\n});\n// `verified` is true/false\n\n// sign a message passed as a buffer\nvar verified = ED25519.verify({\n  // also accepts a forge ByteBuffer or Uint8Array\n  message: Buffer.from('test', 'utf8'),\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  signature: signature,\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  publicKey: publicKey\n});\n\n// verify a signature on a message digest\nvar md = forge.md.sha256.create();\nmd.update('test', 'utf8');\nvar verified = ED25519.verify({\n  md: md,\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  signature: signature,\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  publicKey: publicKey\n});\n```\n\n<a name=\"rsa\" />\n\n### RSA\n\n__Examples__\n\n```js\nvar rsa = forge.pki.rsa;\n\n// generate an RSA key pair synchronously\n// *NOT RECOMMENDED*: Can be significantly slower than async and may block\n// JavaScript execution. Will use native Node.js 10.12.0+ API if possible.\nvar keypair = rsa.generateKeyPair({bits: 2048, e: 0x10001});\n\n// generate an RSA key pair asynchronously (uses web workers if available)\n// use workers: -1 to run a fast core estimator to optimize # of workers\n// *RECOMMENDED*: Can be significantly faster than sync. Will use native\n// Node.js 10.12.0+ or WebCrypto API if possible.\nrsa.generateKeyPair({bits: 2048, workers: 2}, function(err, keypair) {\n  // keypair.privateKey, keypair.publicKey\n});\n\n// generate an RSA key pair in steps that attempt to run for a specified period\n// of time on the main JS thread\nvar state = rsa.createKeyPairGenerationState(2048, 0x10001);\nvar step = function() {\n  // run for 100 ms\n  if(!rsa.stepKeyPairGenerationState(state, 100)) {\n    setTimeout(step, 1);\n  }\n  else {\n    // done, turn off progress indicator, use state.keys\n  }\n};\n// turn on progress indicator, schedule generation to run\nsetTimeout(step);\n\n// sign data with a private key and output DigestInfo DER-encoded bytes\n// (defaults to RSASSA PKCS#1 v1.5)\nvar md = forge.md.sha1.create();\nmd.update('sign this', 'utf8');\nvar signature = privateKey.sign(md);\n\n// verify data with a public key\n// (defaults to RSASSA PKCS#1 v1.5)\nvar verified = publicKey.verify(md.digest().bytes(), signature);\n\n// sign data using RSASSA-PSS where PSS uses a SHA-1 hash, a SHA-1 based\n// masking function MGF1, and a 20 byte salt\nvar md = forge.md.sha1.create();\nmd.update('sign this', 'utf8');\nvar pss = forge.pss.create({\n  md: forge.md.sha1.create(),\n  mgf: forge.mgf.mgf1.create(forge.md.sha1.create()),\n  saltLength: 20\n  // optionally pass 'prng' with a custom PRNG implementation\n  // optionalls pass 'salt' with a forge.util.ByteBuffer w/custom salt\n});\nvar signature = privateKey.sign(md, pss);\n\n// verify RSASSA-PSS signature\nvar pss = forge.pss.create({\n  md: forge.md.sha1.create(),\n  mgf: forge.mgf.mgf1.create(forge.md.sha1.create()),\n  saltLength: 20\n  // optionally pass 'prng' with a custom PRNG implementation\n});\nvar md = forge.md.sha1.create();\nmd.update('sign this', 'utf8');\npublicKey.verify(md.digest().getBytes(), signature, pss);\n\n// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)\nvar encrypted = publicKey.encrypt(bytes);\n\n// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)\nvar decrypted = privateKey.decrypt(encrypted);\n\n// encrypt data with a public key using RSAES PKCS#1 v1.5\nvar encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');\n\n// decrypt data with a private key using RSAES PKCS#1 v1.5\nvar decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');\n\n// encrypt data with a public key using RSAES-OAEP\nvar encrypted = publicKey.encrypt(bytes, 'RSA-OAEP');\n\n// decrypt data with a private key using RSAES-OAEP\nvar decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP');\n\n// encrypt data with a public key using RSAES-OAEP/SHA-256\nvar encrypted = publicKey.encrypt(bytes, 'RSA-OAEP', {\n  md: forge.md.sha256.create()\n});\n\n// decrypt data with a private key using RSAES-OAEP/SHA-256\nvar decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP', {\n  md: forge.md.sha256.create()\n});\n\n// encrypt data with a public key using RSAES-OAEP/SHA-256/MGF1-SHA-1\n// compatible with Java's RSA/ECB/OAEPWithSHA-256AndMGF1Padding\nvar encrypted = publicKey.encrypt(bytes, 'RSA-OAEP', {\n  md: forge.md.sha256.create(),\n  mgf1: {\n    md: forge.md.sha1.create()\n  }\n});\n\n// decrypt data with a private key using RSAES-OAEP/SHA-256/MGF1-SHA-1\n// compatible with Java's RSA/ECB/OAEPWithSHA-256AndMGF1Padding\nvar decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP', {\n  md: forge.md.sha256.create(),\n  mgf1: {\n    md: forge.md.sha1.create()\n  }\n});\n\n```\n\n<a name=\"rsakem\" />\n\n### RSA-KEM\n\n__Examples__\n\n```js\n// generate an RSA key pair asynchronously (uses web workers if available)\n// use workers: -1 to run a fast core estimator to optimize # of workers\nforge.rsa.generateKeyPair({bits: 2048, workers: -1}, function(err, keypair) {\n  // keypair.privateKey, keypair.publicKey\n});\n\n// generate and encapsulate a 16-byte secret key\nvar kdf1 = new forge.kem.kdf1(forge.md.sha1.create());\nvar kem = forge.kem.rsa.create(kdf1);\nvar result = kem.encrypt(keypair.publicKey, 16);\n// result has 'encapsulation' and 'key'\n\n// encrypt some bytes\nvar iv = forge.random.getBytesSync(12);\nvar someBytes = 'hello world!';\nvar cipher = forge.cipher.createCipher('AES-GCM', result.key);\ncipher.start({iv: iv});\ncipher.update(forge.util.createBuffer(someBytes));\ncipher.finish();\nvar encrypted = cipher.output.getBytes();\nvar tag = cipher.mode.tag.getBytes();\n\n// send 'encrypted', 'iv', 'tag', and result.encapsulation to recipient\n\n// decrypt encapsulated 16-byte secret key\nvar kdf1 = new forge.kem.kdf1(forge.md.sha1.create());\nvar kem = forge.kem.rsa.create(kdf1);\nvar key = kem.decrypt(keypair.privateKey, result.encapsulation, 16);\n\n// decrypt some bytes\nvar decipher = forge.cipher.createDecipher('AES-GCM', key);\ndecipher.start({iv: iv, tag: tag});\ndecipher.update(forge.util.createBuffer(encrypted));\nvar pass = decipher.finish();\n// pass is false if there was a failure (eg: authentication tag didn't match)\nif(pass) {\n  // outputs 'hello world!'\n  console.log(decipher.output.getBytes());\n}\n\n```\n\n<a name=\"x509\" />\n\n### X.509\n\n__Examples__\n\n```js\nvar pki = forge.pki;\n\n// convert a PEM-formatted public key to a Forge public key\nvar publicKey = pki.publicKeyFromPem(pem);\n\n// convert a Forge public key to PEM-format\nvar pem = pki.publicKeyToPem(publicKey);\n\n// convert an ASN.1 SubjectPublicKeyInfo to a Forge public key\nvar publicKey = pki.publicKeyFromAsn1(subjectPublicKeyInfo);\n\n// convert a Forge public key to an ASN.1 SubjectPublicKeyInfo\nvar subjectPublicKeyInfo = pki.publicKeyToAsn1(publicKey);\n\n// gets a SHA-1 RSAPublicKey fingerprint a byte buffer\npki.getPublicKeyFingerprint(key);\n\n// gets a SHA-1 SubjectPublicKeyInfo fingerprint a byte buffer\npki.getPublicKeyFingerprint(key, {type: 'SubjectPublicKeyInfo'});\n\n// gets a hex-encoded, colon-delimited SHA-1 RSAPublicKey public key fingerprint\npki.getPublicKeyFingerprint(key, {encoding: 'hex', delimiter: ':'});\n\n// gets a hex-encoded, colon-delimited SHA-1 SubjectPublicKeyInfo public key fingerprint\npki.getPublicKeyFingerprint(key, {\n  type: 'SubjectPublicKeyInfo',\n  encoding: 'hex',\n  delimiter: ':'\n});\n\n// gets a hex-encoded, colon-delimited MD5 RSAPublicKey public key fingerprint\npki.getPublicKeyFingerprint(key, {\n  md: forge.md.md5.create(),\n  encoding: 'hex',\n  delimiter: ':'\n});\n\n// creates a CA store\nvar caStore = pki.createCaStore([/* PEM-encoded cert */, ...]);\n\n// add a certificate to the CA store\ncaStore.addCertificate(certObjectOrPemString);\n\n// gets the issuer (its certificate) for the given certificate\nvar issuerCert = caStore.getIssuer(subjectCert);\n\n// verifies a certificate chain against a CA store\npki.verifyCertificateChain(caStore, chain, customVerifyCallback);\n\n// signs a certificate using the given private key\ncert.sign(privateKey);\n\n// signs a certificate using SHA-256 instead of SHA-1\ncert.sign(privateKey, forge.md.sha256.create());\n\n// verifies an issued certificate using the certificates public key\nvar verified = issuer.verify(issued);\n\n// generate a keypair and create an X.509v3 certificate\nvar keys = pki.rsa.generateKeyPair(2048);\nvar cert = pki.createCertificate();\ncert.publicKey = keys.publicKey;\n// alternatively set public key from a csr\n//cert.publicKey = csr.publicKey;\n// NOTE: serialNumber is the hex encoded value of an ASN.1 INTEGER.\n// Conforming CAs should ensure serialNumber is:\n// - no more than 20 octets\n// - non-negative (prefix a '00' if your value starts with a '1' bit)\ncert.serialNumber = '01';\ncert.validity.notBefore = new Date();\ncert.validity.notAfter = new Date();\ncert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);\nvar attrs = [{\n  name: 'commonName',\n  value: 'example.org'\n}, {\n  name: 'countryName',\n  value: 'US'\n}, {\n  shortName: 'ST',\n  value: 'Virginia'\n}, {\n  name: 'localityName',\n  value: 'Blacksburg'\n}, {\n  name: 'organizationName',\n  value: 'Test'\n}, {\n  shortName: 'OU',\n  value: 'Test'\n}];\ncert.setSubject(attrs);\n// alternatively set subject from a csr\n//cert.setSubject(csr.subject.attributes);\ncert.setIssuer(attrs);\ncert.setExtensions([{\n  name: 'basicConstraints',\n  cA: true\n}, {\n  name: 'keyUsage',\n  keyCertSign: true,\n  digitalSignature: true,\n  nonRepudiation: true,\n  keyEncipherment: true,\n  dataEncipherment: true\n}, {\n  name: 'extKeyUsage',\n  serverAuth: true,\n  clientAuth: true,\n  codeSigning: true,\n  emailProtection: true,\n  timeStamping: true\n}, {\n  name: 'nsCertType',\n  client: true,\n  server: true,\n  email: true,\n  objsign: true,\n  sslCA: true,\n  emailCA: true,\n  objCA: true\n}, {\n  name: 'subjectAltName',\n  altNames: [{\n    type: 6, // URI\n    value: 'http://example.org/webid#me'\n  }, {\n    type: 7, // IP\n    ip: '127.0.0.1'\n  }]\n}, {\n  name: 'subjectKeyIdentifier'\n}]);\n/* alternatively set extensions from a csr\nvar extensions = csr.getAttribute({name: 'extensionRequest'}).extensions;\n// optionally add more extensions\nextensions.push.apply(extensions, [{\n  name: 'basicConstraints',\n  cA: true\n}, {\n  name: 'keyUsage',\n  keyCertSign: true,\n  digitalSignature: true,\n  nonRepudiation: true,\n  keyEncipherment: true,\n  dataEncipherment: true\n}]);\ncert.setExtensions(extensions);\n*/\n// self-sign certificate\ncert.sign(keys.privateKey);\n\n// convert a Forge certificate to PEM\nvar pem = pki.certificateToPem(cert);\n\n// convert a Forge certificate from PEM\nvar cert = pki.certificateFromPem(pem);\n\n// convert an ASN.1 X.509x3 object to a Forge certificate\nvar cert = pki.certificateFromAsn1(obj);\n\n// convert a Forge certificate to an ASN.1 X.509v3 object\nvar asn1Cert = pki.certificateToAsn1(cert);\n```\n\n<a name=\"pkcs5\" />\n\n### PKCS#5\n\nProvides the password-based key-derivation function from [PKCS#5][].\n\n__Examples__\n\n```js\n// generate a password-based 16-byte key\n// note an optional message digest can be passed as the final parameter\nvar salt = forge.random.getBytesSync(128);\nvar derivedKey = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);\n\n// generate key asynchronously\n// note an optional message digest can be passed before the callback\nforge.pkcs5.pbkdf2('password', salt, numIterations, 16, function(err, derivedKey) {\n  // do something w/derivedKey\n});\n```\n\n<a name=\"pkcs7\" />\n\n### PKCS#7\n\nProvides cryptographically protected messages from [PKCS#7][].\n\n__Examples__\n\n```js\n// convert a message from PEM\nvar p7 = forge.pkcs7.messageFromPem(pem);\n// look at p7.recipients\n\n// find a recipient by the issuer of a certificate\nvar recipient = p7.findRecipient(cert);\n\n// decrypt\np7.decrypt(p7.recipients[0], privateKey);\n\n// create a p7 enveloped message\nvar p7 = forge.pkcs7.createEnvelopedData();\n\n// add a recipient\nvar cert = forge.pki.certificateFromPem(certPem);\np7.addRecipient(cert);\n\n// set content\np7.content = forge.util.createBuffer('Hello');\n\n// encrypt\np7.encrypt();\n\n// convert message to PEM\nvar pem = forge.pkcs7.messageToPem(p7);\n\n// create a degenerate PKCS#7 certificate container\n// (CRLs not currently supported, only certificates)\nvar p7 = forge.pkcs7.createSignedData();\np7.addCertificate(certOrCertPem1);\np7.addCertificate(certOrCertPem2);\nvar pem = forge.pkcs7.messageToPem(p7);\n\n// create PKCS#7 signed data with authenticatedAttributes\n// attributes include: PKCS#9 content-type, message-digest, and signing-time\nvar p7 = forge.pkcs7.createSignedData();\np7.content = forge.util.createBuffer('Some content to be signed.', 'utf8');\np7.addCertificate(certOrCertPem);\np7.addSigner({\n  key: privateKeyAssociatedWithCert,\n  certificate: certOrCertPem,\n  digestAlgorithm: forge.pki.oids.sha256,\n  authenticatedAttributes: [{\n    type: forge.pki.oids.contentType,\n    value: forge.pki.oids.data\n  }, {\n    type: forge.pki.oids.messageDigest\n    // value will be auto-populated at signing time\n  }, {\n    type: forge.pki.oids.signingTime,\n    // value can also be auto-populated at signing time\n    value: new Date()\n  }]\n});\np7.sign();\nvar pem = forge.pkcs7.messageToPem(p7);\n\n// PKCS#7 Sign in detached mode.\n// Includes the signature and certificate without the signed data.\np7.sign({detached: true});\n\n```\n\n<a name=\"pkcs8\" />\n\n### PKCS#8\n\n__Examples__\n\n```js\nvar pki = forge.pki;\n\n// convert a PEM-formatted private key to a Forge private key\nvar privateKey = pki.privateKeyFromPem(pem);\n\n// convert a Forge private key to PEM-format\nvar pem = pki.privateKeyToPem(privateKey);\n\n// convert an ASN.1 PrivateKeyInfo or RSAPrivateKey to a Forge private key\nvar privateKey = pki.privateKeyFromAsn1(rsaPrivateKey);\n\n// convert a Forge private key to an ASN.1 RSAPrivateKey\nvar rsaPrivateKey = pki.privateKeyToAsn1(privateKey);\n\n// wrap an RSAPrivateKey ASN.1 object in a PKCS#8 ASN.1 PrivateKeyInfo\nvar privateKeyInfo = pki.wrapRsaPrivateKey(rsaPrivateKey);\n\n// convert a PKCS#8 ASN.1 PrivateKeyInfo to PEM\nvar pem = pki.privateKeyInfoToPem(privateKeyInfo);\n\n// encrypts a PrivateKeyInfo using a custom password and\n// outputs an EncryptedPrivateKeyInfo\nvar encryptedPrivateKeyInfo = pki.encryptPrivateKeyInfo(\n  privateKeyInfo, 'myCustomPasswordHere', {\n    algorithm: 'aes256', // 'aes128', 'aes192', 'aes256', '3des'\n  });\n\n// decrypts an ASN.1 EncryptedPrivateKeyInfo that was encrypted\n// with a custom password\nvar privateKeyInfo = pki.decryptPrivateKeyInfo(\n  encryptedPrivateKeyInfo, 'myCustomPasswordHere');\n\n// converts an EncryptedPrivateKeyInfo to PEM\nvar pem = pki.encryptedPrivateKeyToPem(encryptedPrivateKeyInfo);\n\n// converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format\nvar encryptedPrivateKeyInfo = pki.encryptedPrivateKeyFromPem(pem);\n\n// wraps and encrypts a Forge private key and outputs it in PEM format\nvar pem = pki.encryptRsaPrivateKey(privateKey, 'password');\n\n// encrypts a Forge private key and outputs it in PEM format using OpenSSL's\n// proprietary legacy format + encapsulated PEM headers (DEK-Info)\nvar pem = pki.encryptRsaPrivateKey(privateKey, 'password', {legacy: true});\n\n// decrypts a PEM-formatted, encrypted private key\nvar privateKey = pki.decryptRsaPrivateKey(pem, 'password');\n\n// sets an RSA public key from a private key\nvar publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);\n```\n\n<a name=\"pkcs10\" />\n\n### PKCS#10\n\nProvides certification requests or certificate signing requests (CSR) from\n[PKCS#10][].\n\n__Examples__\n\n```js\n// generate a key pair\nvar keys = forge.pki.rsa.generateKeyPair(2048);\n\n// create a certification request (CSR)\nvar csr = forge.pki.createCertificationRequest();\ncsr.publicKey = keys.publicKey;\ncsr.setSubject([{\n  name: 'commonName',\n  value: 'example.org'\n}, {\n  name: 'countryName',\n  value: 'US'\n}, {\n  shortName: 'ST',\n  value: 'Virginia'\n}, {\n  name: 'localityName',\n  value: 'Blacksburg'\n}, {\n  name: 'organizationName',\n  value: 'Test'\n}, {\n  shortName: 'OU',\n  value: 'Test'\n}]);\n// set (optional) attributes\ncsr.setAttributes([{\n  name: 'challengePassword',\n  value: 'password'\n}, {\n  name: 'unstructuredName',\n  value: 'My Company, Inc.'\n}, {\n  name: 'extensionRequest',\n  extensions: [{\n    name: 'subjectAltName',\n    altNames: [{\n      // 2 is DNS type\n      type: 2,\n      value: 'test.domain.com'\n    }, {\n      type: 2,\n      value: 'other.domain.com',\n    }, {\n      type: 2,\n      value: 'www.domain.net'\n    }]\n  }]\n}]);\n\n// sign certification request\ncsr.sign(keys.privateKey);\n\n// verify certification request\nvar verified = csr.verify();\n\n// convert certification request to PEM-format\nvar pem = forge.pki.certificationRequestToPem(csr);\n\n// convert a Forge certification request from PEM-format\nvar csr = forge.pki.certificationRequestFromPem(pem);\n\n// get an attribute\ncsr.getAttribute({name: 'challengePassword'});\n\n// get extensions array\ncsr.getAttribute({name: 'extensionRequest'}).extensions;\n\n```\n\n<a name=\"pkcs12\" />\n\n### PKCS#12\n\nProvides the cryptographic archive file format from [PKCS#12][].\n\n**Note for Chrome/Firefox/iOS/similar users**: If you have trouble importing\na PKCS#12 container, try using the TripleDES algorithm. It can be passed\nto `forge.pkcs12.toPkcs12Asn1` using the `{algorithm: '3des'}` option.\n\n__Examples__\n\n```js\n// decode p12 from base64\nvar p12Der = forge.util.decode64(p12b64);\n// get p12 as ASN.1 object\nvar p12Asn1 = forge.asn1.fromDer(p12Der);\n// decrypt p12 using the password 'password'\nvar p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, 'password');\n// decrypt p12 using non-strict parsing mode (resolves some ASN.1 parse errors)\nvar p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, false, 'password');\n// decrypt p12 using literally no password (eg: Mac OS X/apple push)\nvar p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1);\n// decrypt p12 using an \"empty\" password (eg: OpenSSL with no password input)\nvar p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, '');\n// p12.safeContents is an array of safe contents, each of\n// which contains an array of safeBags\n\n// get bags by friendlyName\nvar bags = p12.getBags({friendlyName: 'test'});\n// bags are key'd by attribute type (here \"friendlyName\")\n// and the key values are an array of matching objects\nvar cert = bags.friendlyName[0];\n\n// get bags by localKeyId\nvar bags = p12.getBags({localKeyId: buffer});\n// bags are key'd by attribute type (here \"localKeyId\")\n// and the key values are an array of matching objects\nvar cert = bags.localKeyId[0];\n\n// get bags by localKeyId (input in hex)\nvar bags = p12.getBags({localKeyIdHex: '7b59377ff142d0be4565e9ac3d396c01401cd879'});\n// bags are key'd by attribute type (here \"localKeyId\", *not* \"localKeyIdHex\")\n// and the key values are an array of matching objects\nvar cert = bags.localKeyId[0];\n\n// get bags by type\nvar bags = p12.getBags({bagType: forge.pki.oids.certBag});\n// bags are key'd by bagType and each bagType key's value\n// is an array of matches (in this case, certificate objects)\nvar cert = bags[forge.pki.oids.certBag][0];\n\n// get bags by friendlyName and filter on bag type\nvar bags = p12.getBags({\n  friendlyName: 'test',\n  bagType: forge.pki.oids.certBag\n});\n\n// get key bags\nvar bags = p12.getBags({bagType: forge.pki.oids.keyBag});\n// get key\nvar bag = bags[forge.pki.oids.keyBag][0];\nvar key = bag.key;\n// if the key is in a format unrecognized by forge then\n// bag.key will be `null`, use bag.asn1 to get the ASN.1\n// representation of the key\nif(bag.key === null) {\n  var keyAsn1 = bag.asn1;\n  // can now convert back to DER/PEM/etc for export\n}\n\n// generate a p12 using AES (default)\nvar p12Asn1 = forge.pkcs12.toPkcs12Asn1(\n  privateKey, certificateChain, 'password');\n\n// generate a p12 that can be imported by Chrome/Firefox/iOS\n// (requires the use of Triple DES instead of AES)\nvar p12Asn1 = forge.pkcs12.toPkcs12Asn1(\n  privateKey, certificateChain, 'password',\n  {algorithm: '3des'});\n\n// base64-encode p12\nvar p12Der = forge.asn1.toDer(p12Asn1).getBytes();\nvar p12b64 = forge.util.encode64(p12Der);\n\n// create download link for p12\nvar a = document.createElement('a');\na.download = 'example.p12';\na.setAttribute('href', 'data:application/x-pkcs12;base64,' + p12b64);\na.appendChild(document.createTextNode('Download'));\n```\n\n<a name=\"asn\" />\n\n### ASN.1\n\nProvides [ASN.1][] DER encoding and decoding.\n\n__Examples__\n\n```js\nvar asn1 = forge.asn1;\n\n// create a SubjectPublicKeyInfo\nvar subjectPublicKeyInfo =\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // AlgorithmIdentifier\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(pki.oids['rsaEncryption']).getBytes()),\n      // parameters (null)\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n    ]),\n    // subjectPublicKey\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\n      // RSAPublicKey\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // modulus (n)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n          _bnToBytes(key.n)),\n        // publicExponent (e)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n          _bnToBytes(key.e))\n      ])\n    ])\n  ]);\n\n// serialize an ASN.1 object to DER format\nvar derBuffer = asn1.toDer(subjectPublicKeyInfo);\n\n// deserialize to an ASN.1 object from a byte buffer filled with DER data\nvar object = asn1.fromDer(derBuffer);\n\n// convert an OID dot-separated string to a byte buffer\nvar derOidBuffer = asn1.oidToDer('1.2.840.113549.1.1.5');\n\n// convert a byte buffer with a DER-encoded OID to a dot-separated string\nconsole.log(asn1.derToOid(derOidBuffer));\n// output: 1.2.840.113549.1.1.5\n\n// validates that an ASN.1 object matches a particular ASN.1 structure and\n// captures data of interest from that structure for easy access\nvar publicKeyValidator = {\n  name: 'SubjectPublicKeyInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  captureAsn1: 'subjectPublicKeyInfo',\n  value: [{\n    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'AlgorithmIdentifier.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'publicKeyOid'\n    }]\n  }, {\n    // subjectPublicKey\n    name: 'SubjectPublicKeyInfo.subjectPublicKey',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.BITSTRING,\n    constructed: false,\n    value: [{\n      // RSAPublicKey\n      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      optional: true,\n      captureAsn1: 'rsaPublicKey'\n    }]\n  }]\n};\n\nvar capture = {};\nvar errors = [];\nif(!asn1.validate(\n  publicKeyValidator, subjectPublicKeyInfo, validator, capture, errors)) {\n  throw 'ASN.1 object is not a SubjectPublicKeyInfo.';\n}\n// capture.subjectPublicKeyInfo contains the full ASN.1 object\n// capture.rsaPublicKey contains the full ASN.1 object for the RSA public key\n// capture.publicKeyOid only contains the value for the OID\nvar oid = asn1.derToOid(capture.publicKeyOid);\nif(oid !== pki.oids['rsaEncryption']) {\n  throw 'Unsupported OID.';\n}\n\n// pretty print an ASN.1 object to a string for debugging purposes\nasn1.prettyPrint(object);\n```\n\nMessage Digests\n----------------\n\n<a name=\"sha1\" />\n\n### SHA1\n\nProvides [SHA-1][] message digests.\n\n__Examples__\n\n```js\nvar md = forge.md.sha1.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\n```\n\n<a name=\"sha256\" />\n\n### SHA256\n\nProvides [SHA-256][] message digests.\n\n__Examples__\n\n```js\nvar md = forge.md.sha256.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\n```\n\n<a name=\"sha384\" />\n\n### SHA384\n\nProvides [SHA-384][] message digests.\n\n__Examples__\n\n```js\nvar md = forge.md.sha384.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: ca737f1014a48f4c0b6dd43cb177b0afd9e5169367544c494011e3317dbf9a509cb1e5dc1e85a941bbee3d7f2afbc9b1\n```\n\n<a name=\"sha512\" />\n\n### SHA512\n\nProvides [SHA-512][] message digests.\n\n__Examples__\n\n```js\n// SHA-512\nvar md = forge.md.sha512.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: 07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb642e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6\n\n// SHA-512/224\nvar md = forge.md.sha512.sha224.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: 944cd2847fb54558d4775db0485a50003111c8e5daa63fe722c6aa37\n\n// SHA-512/256\nvar md = forge.md.sha512.sha256.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: dd9d67b371519c339ed8dbd25af90e976a1eeefd4ad3d889005e532fc5bef04d\n```\n\n<a name=\"md5\" />\n\n### MD5\n\nProvides [MD5][] message digests.\n\n__Examples__\n\n```js\nvar md = forge.md.md5.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: 9e107d9d372bb6826bd81d3542a419d6\n```\n\n<a name=\"hmac\" />\n\n### HMAC\n\nProvides [HMAC][] w/any supported message digest algorithm.\n\n__Examples__\n\n```js\nvar hmac = forge.hmac.create();\nhmac.start('sha1', 'Jefe');\nhmac.update('what do ya want for nothing?');\nconsole.log(hmac.digest().toHex());\n// output: effcdf6ae5eb2fa2d27416d5f184df9c259a7c79\n```\n\nUtilities\n---------\n\n<a name=\"prime\" />\n\n### Prime\n\nProvides an API for generating large, random, probable primes.\n\n__Examples__\n\n```js\n// generate a random prime on the main JS thread\nvar bits = 1024;\nforge.prime.generateProbablePrime(bits, function(err, num) {\n  console.log('random prime', num.toString(16));\n});\n\n// generate a random prime using Web Workers (if available, otherwise\n// falls back to the main thread)\nvar bits = 1024;\nvar options = {\n  algorithm: {\n    name: 'PRIMEINC',\n    workers: -1 // auto-optimize # of workers\n  }\n};\nforge.prime.generateProbablePrime(bits, options, function(err, num) {\n  console.log('random prime', num.toString(16));\n});\n```\n\n<a name=\"prng\" />\n\n### PRNG\n\nProvides a [Fortuna][]-based cryptographically-secure pseudo-random number\ngenerator, to be used with a cryptographic function backend, e.g. [AES][]. An\nimplementation using [AES][] as a backend is provided. An API for collecting\nentropy is given, though if window.crypto.getRandomValues is available, it will\nbe used automatically.\n\n__Examples__\n\n```js\n// get some random bytes synchronously\nvar bytes = forge.random.getBytesSync(32);\nconsole.log(forge.util.bytesToHex(bytes));\n\n// get some random bytes asynchronously\nforge.random.getBytes(32, function(err, bytes) {\n  console.log(forge.util.bytesToHex(bytes));\n});\n\n// collect some entropy if you'd like\nforge.random.collect(someRandomBytes);\njQuery().mousemove(function(e) {\n  forge.random.collectInt(e.clientX, 16);\n  forge.random.collectInt(e.clientY, 16);\n});\n\n// specify a seed file for use with the synchronous API if you'd like\nforge.random.seedFileSync = function(needed) {\n  // get 'needed' number of random bytes from somewhere\n  return fetchedRandomBytes;\n};\n\n// specify a seed file for use with the asynchronous API if you'd like\nforge.random.seedFile = function(needed, callback) {\n  // get the 'needed' number of random bytes from somewhere\n  callback(null, fetchedRandomBytes);\n});\n\n// register the main thread to send entropy or a Web Worker to receive\n// entropy on demand from the main thread\nforge.random.registerWorker(self);\n\n// generate a new instance of a PRNG with no collected entropy\nvar myPrng = forge.random.createInstance();\n```\n\n<a name=\"task\" />\n\n### Tasks\n\nProvides queuing and synchronizing tasks in a web application.\n\n__Examples__\n\n```js\n// TODO\n```\n\n<a name=\"util\" />\n\n### Utilities\n\nProvides utility functions, including byte buffer support, base64,\nbytes to/from hex, zlib inflate/deflate, etc.\n\n__Examples__\n\n```js\n// encode/decode base64\nvar encoded = forge.util.encode64(str);\nvar str = forge.util.decode64(encoded);\n\n// encode/decode UTF-8\nvar encoded = forge.util.encodeUtf8(str);\nvar str = forge.util.decodeUtf8(encoded);\n\n// bytes to/from hex\nvar bytes = forge.util.hexToBytes(hex);\nvar hex = forge.util.bytesToHex(bytes);\n\n// create an empty byte buffer\nvar buffer = forge.util.createBuffer();\n// create a byte buffer from raw binary bytes\nvar buffer = forge.util.createBuffer(input, 'raw');\n// create a byte buffer from utf8 bytes\nvar buffer = forge.util.createBuffer(input, 'utf8');\n\n// get the length of the buffer in bytes\nbuffer.length();\n// put bytes into the buffer\nbuffer.putBytes(bytes);\n// put a 32-bit integer into the buffer\nbuffer.putInt32(10);\n// buffer to hex\nbuffer.toHex();\n// get a copy of the bytes in the buffer\nbytes.bytes(/* count */);\n// empty this buffer and get its contents\nbytes.getBytes(/* count */);\n\n// convert a forge buffer into a Node.js Buffer\n// make sure you specify the encoding as 'binary'\nvar forgeBuffer = forge.util.createBuffer();\nvar nodeBuffer = Buffer.from(forgeBuffer.getBytes(), 'binary');\n\n// convert a Node.js Buffer into a forge buffer\n// make sure you specify the encoding as 'binary'\nvar nodeBuffer = Buffer.from('CAFE', 'hex');\nvar forgeBuffer = forge.util.createBuffer(nodeBuffer.toString('binary'));\n\n// parse a URL\nvar parsed = forge.util.parseUrl('http://example.com/foo?bar=baz');\n// parsed.scheme, parsed.host, parsed.port, parsed.path, parsed.fullHost\n```\n\n<a name=\"log\" />\n\n### Logging\n\nProvides logging to a javascript console using various categories and\nlevels of verbosity.\n\n__Examples__\n\n```js\n// TODO\n```\n\n<a name=\"flash\" />\n\n### Flash Networking Support\n\nThe [flash README](./flash/README.md) provides details on rebuilding the\noptional Flash component used for networking. It also provides details on\nPolicy Server support.\n\nSecurity Considerations\n-----------------------\n\nWhen using this code please keep the following in mind:\n\n- Cryptography is hard. Please review and test this code before depending on it\n  for critical functionality.\n- The nature of JavaScript is that execution of this code depends on trusting a\n  very large set of JavaScript tools and systems. Consider runtime variations,\n  runtime characteristics, runtime optimization, code optimization, code\n  minimization, code obfuscation, bundling tools, possible bugs, the Forge code\n  itself, and so on.\n- If using pre-built bundles from [Bower][] or similar be aware someone else\n  ran the tools to create those files.\n- Use a secure transport channel such as [TLS][] to load scripts and consider\n  using additional security mechanisms such as [Subresource Integrity][] script\n  attributes.\n- Use \"native\" functionality where possible. This can be critical when dealing\n  with performance and random number generation. Note that the JavaScript\n  random number algorithms should perform well if given suitable entropy.\n- Understand possible attacks against cryptographic systems. For instance side\n  channel and timing attacks may be possible due to the difficulty in\n  implementing constant time algorithms in pure JavaScript.\n- Certain features in this library are less susceptible to attacks depending on\n  usage. This primarily includes features that deal with data format\n  manipulation or those that are not involved in communication.\n\nLibrary Background\n------------------\n\n* https://digitalbazaar.com/2010/07/20/javascript-tls-1/\n* https://digitalbazaar.com/2010/07/20/javascript-tls-2/\n\nContact\n-------\n\n* Code: https://github.com/digitalbazaar/forge\n* Bugs: https://github.com/digitalbazaar/forge/issues\n* Email: support@digitalbazaar.com\n* IRC: [#forgejs][] on [freenode][]\n\nDonations\n---------\n\nFinancial support is welcome and helps contribute to futher development:\n\n* For [PayPal][] please send to paypal@digitalbazaar.com.\n* Something else? Please contact support@digitalbazaar.com.\n\n[#forgejs]: https://webchat.freenode.net/?channels=#forgejs\n[0.6.x]: https://github.com/digitalbazaar/forge/tree/0.6.x\n[3DES]: https://en.wikipedia.org/wiki/Triple_DES\n[AES]: https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n[ASN.1]: https://en.wikipedia.org/wiki/ASN.1\n[Bower]: https://bower.io/\n[Browserify]: http://browserify.org/\n[CBC]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[CFB]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[CTR]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[CommonJS]: https://en.wikipedia.org/wiki/CommonJS\n[DES]: https://en.wikipedia.org/wiki/Data_Encryption_Standard\n[ECB]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[Fortuna]: https://en.wikipedia.org/wiki/Fortuna_(PRNG)\n[GCM]: https://en.wikipedia.org/wiki/GCM_mode\n[HMAC]: https://en.wikipedia.org/wiki/HMAC\n[JavaScript]: https://en.wikipedia.org/wiki/JavaScript\n[Karma]: https://karma-runner.github.io/\n[MD5]: https://en.wikipedia.org/wiki/MD5\n[Node.js]: https://nodejs.org/\n[OFB]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[PKCS#10]: https://en.wikipedia.org/wiki/Certificate_signing_request\n[PKCS#12]: https://en.wikipedia.org/wiki/PKCS_%E2%99%AF12\n[PKCS#5]: https://en.wikipedia.org/wiki/PKCS\n[PKCS#7]: https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax\n[PayPal]: https://www.paypal.com/\n[RC2]: https://en.wikipedia.org/wiki/RC2\n[SHA-1]: https://en.wikipedia.org/wiki/SHA-1\n[SHA-256]: https://en.wikipedia.org/wiki/SHA-256\n[SHA-384]: https://en.wikipedia.org/wiki/SHA-384\n[SHA-512]: https://en.wikipedia.org/wiki/SHA-512\n[Subresource Integrity]: https://www.w3.org/TR/SRI/\n[TLS]: https://en.wikipedia.org/wiki/Transport_Layer_Security\n[UMD]: https://github.com/umdjs/umd\n[X.509]: https://en.wikipedia.org/wiki/X.509\n[freenode]: https://freenode.net/\n[unpkg]: https://unpkg.com/\n[webpack]: https://webpack.github.io/\n[TweetNaCl.js]: https://github.com/dchest/tweetnacl-js\n", "/**\n * HTTP client-side implementation that uses forge.net sockets.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\nrequire('./tls');\nrequire('./util');\n\n// define http namespace\nvar http = module.exports = forge.http = forge.http || {};\n\n// logging category\nvar cat = 'forge.http';\n\n// normalizes an http header field name\nvar _normalize = function(name) {\n  return name.toLowerCase().replace(/(^.)|(-.)/g,\n    function(a) {return a.toUpperCase();});\n};\n\n/**\n * Gets the local storage ID for the given client.\n *\n * @param client the client to get the local storage ID for.\n *\n * @return the local storage ID to use.\n */\nvar _getStorageId = function(client) {\n  // TODO: include browser in ID to avoid sharing cookies between\n  // browsers (if this is undesirable)\n  // navigator.userAgent\n  return 'forge.http.' +\n    client.url.scheme + '.' +\n    client.url.host + '.' +\n    client.url.port;\n};\n\n/**\n * Loads persistent cookies from disk for the given client.\n *\n * @param client the client.\n */\nvar _loadCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      var cookies = forge.util.getItem(\n        client.socketPool.flashApi,\n        _getStorageId(client), 'cookies');\n      client.cookies = cookies || {};\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n\n/**\n * Saves persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\nvar _saveCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      forge.util.setItem(\n        client.socketPool.flashApi,\n        _getStorageId(client), 'cookies', client.cookies);\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n\n  // FIXME: remove me\n  _loadCookies(client);\n};\n\n/**\n * Clears persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\nvar _clearCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      // only thing stored is 'cookies', so clear whole storage\n      forge.util.clearItems(\n        client.socketPool.flashApi,\n        _getStorageId(client));\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n\n/**\n * Connects and sends a request.\n *\n * @param client the http client.\n * @param socket the socket to use.\n */\nvar _doRequest = function(client, socket) {\n  if(socket.isConnected()) {\n    // already connected\n    socket.options.request.connectTime = +new Date();\n    socket.connected({\n      type: 'connect',\n      id: socket.id\n    });\n  } else {\n    // connect\n    socket.options.request.connectTime = +new Date();\n    socket.connect({\n      host: client.url.host,\n      port: client.url.port,\n      policyPort: client.policyPort,\n      policyUrl: client.policyUrl\n    });\n  }\n};\n\n/**\n * Handles the next request or marks a socket as idle.\n *\n * @param client the http client.\n * @param socket the socket.\n */\nvar _handleNextRequest = function(client, socket) {\n  // clear buffer\n  socket.buffer.clear();\n\n  // get pending request\n  var pending = null;\n  while(pending === null && client.requests.length > 0) {\n    pending = client.requests.shift();\n    if(pending.request.aborted) {\n      pending = null;\n    }\n  }\n\n  // mark socket idle if no pending requests\n  if(pending === null) {\n    if(socket.options !== null) {\n      socket.options = null;\n    }\n    client.idle.push(socket);\n  } else {\n    // handle pending request, allow 1 retry\n    socket.retries = 1;\n    socket.options = pending;\n    _doRequest(client, socket);\n  }\n};\n\n/**\n * Sets up a socket for use with an http client.\n *\n * @param client the parent http client.\n * @param socket the socket to set up.\n * @param tlsOptions if the socket must use TLS, the TLS options.\n */\nvar _initSocket = function(client, socket, tlsOptions) {\n  // no socket options yet\n  socket.options = null;\n\n  // set up handlers\n  socket.connected = function(e) {\n    // socket primed by caching TLS session, handle next request\n    if(socket.options === null) {\n      _handleNextRequest(client, socket);\n    } else {\n      // socket in use\n      var request = socket.options.request;\n      request.connectTime = +new Date() - request.connectTime;\n      e.socket = socket;\n      socket.options.connected(e);\n      if(request.aborted) {\n        socket.close();\n      } else {\n        var out = request.toString();\n        if(request.body) {\n          out += request.body;\n        }\n        request.time = +new Date();\n        socket.send(out);\n        request.time = +new Date() - request.time;\n        socket.options.response.time = +new Date();\n        socket.sending = true;\n      }\n    }\n  };\n  socket.closed = function(e) {\n    if(socket.sending) {\n      socket.sending = false;\n      if(socket.retries > 0) {\n        --socket.retries;\n        _doRequest(client, socket);\n      } else {\n        // error, closed during send\n        socket.error({\n          id: socket.id,\n          type: 'ioError',\n          message: 'Connection closed during send. Broken pipe.',\n          bytesAvailable: 0\n        });\n      }\n    } else {\n      // handle unspecified content-length transfer\n      var response = socket.options.response;\n      if(response.readBodyUntilClose) {\n        response.time = +new Date() - response.time;\n        response.bodyReceived = true;\n        socket.options.bodyReady({\n          request: socket.options.request,\n          response: response,\n          socket: socket\n        });\n      }\n      socket.options.closed(e);\n      _handleNextRequest(client, socket);\n    }\n  };\n  socket.data = function(e) {\n    socket.sending = false;\n    var request = socket.options.request;\n    if(request.aborted) {\n      socket.close();\n    } else {\n      // receive all bytes available\n      var response = socket.options.response;\n      var bytes = socket.receive(e.bytesAvailable);\n      if(bytes !== null) {\n        // receive header and then body\n        socket.buffer.putBytes(bytes);\n        if(!response.headerReceived) {\n          response.readHeader(socket.buffer);\n          if(response.headerReceived) {\n            socket.options.headerReady({\n              request: socket.options.request,\n              response: response,\n              socket: socket\n            });\n          }\n        }\n        if(response.headerReceived && !response.bodyReceived) {\n          response.readBody(socket.buffer);\n        }\n        if(response.bodyReceived) {\n          socket.options.bodyReady({\n            request: socket.options.request,\n            response: response,\n            socket: socket\n          });\n          // close connection if requested or by default on http/1.0\n          var value = response.getField('Connection') || '';\n          if(value.indexOf('close') != -1 ||\n            (response.version === 'HTTP/1.0' &&\n            response.getField('Keep-Alive') === null)) {\n            socket.close();\n          } else {\n            _handleNextRequest(client, socket);\n          }\n        }\n      }\n    }\n  };\n  socket.error = function(e) {\n    // do error callback, include request\n    socket.options.error({\n      type: e.type,\n      message: e.message,\n      request: socket.options.request,\n      response: socket.options.response,\n      socket: socket\n    });\n    socket.close();\n  };\n\n  // wrap socket for TLS\n  if(tlsOptions) {\n    socket = forge.tls.wrapSocket({\n      sessionId: null,\n      sessionCache: {},\n      caStore: tlsOptions.caStore,\n      cipherSuites: tlsOptions.cipherSuites,\n      socket: socket,\n      virtualHost: tlsOptions.virtualHost,\n      verify: tlsOptions.verify,\n      getCertificate: tlsOptions.getCertificate,\n      getPrivateKey: tlsOptions.getPrivateKey,\n      getSignature: tlsOptions.getSignature,\n      deflate: tlsOptions.deflate || null,\n      inflate: tlsOptions.inflate || null\n    });\n\n    socket.options = null;\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    if(tlsOptions.prime) {\n      // prime socket by connecting and caching TLS session, will do\n      // next request from there\n      socket.connect({\n        host: client.url.host,\n        port: client.url.port,\n        policyPort: client.policyPort,\n        policyUrl: client.policyUrl\n      });\n    } else {\n      // do not prime socket, just add as idle\n      client.idle.push(socket);\n    }\n  } else {\n    // no need to prime non-TLS sockets\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    client.idle.push(socket);\n  }\n};\n\n/**\n * Checks to see if the given cookie has expired. If the cookie's max-age\n * plus its created time is less than the time now, it has expired, unless\n * its max-age is set to -1 which indicates it will never expire.\n *\n * @param cookie the cookie to check.\n *\n * @return true if it has expired, false if not.\n */\nvar _hasCookieExpired = function(cookie) {\n  var rval = false;\n\n  if(cookie.maxAge !== -1) {\n    var now = _getUtcTime(new Date());\n    var expires = cookie.created + cookie.maxAge;\n    if(expires <= now) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Adds cookies in the given client to the given request.\n *\n * @param client the client.\n * @param request the request.\n */\nvar _writeCookies = function(client, request) {\n  var expired = [];\n  var url = client.url;\n  var cookies = client.cookies;\n  for(var name in cookies) {\n    // get cookie paths\n    var paths = cookies[name];\n    for(var p in paths) {\n      var cookie = paths[p];\n      if(_hasCookieExpired(cookie)) {\n        // store for clean up\n        expired.push(cookie);\n      } else if(request.path.indexOf(cookie.path) === 0) {\n        // path or path's ancestor must match cookie.path\n        request.addCookie(cookie);\n      }\n    }\n  }\n\n  // clean up expired cookies\n  for(var i = 0; i < expired.length; ++i) {\n    var cookie = expired[i];\n    client.removeCookie(cookie.name, cookie.path);\n  }\n};\n\n/**\n * Gets cookies from the given response and adds the to the given client.\n *\n * @param client the client.\n * @param response the response.\n */\nvar _readCookies = function(client, response) {\n  var cookies = response.getCookies();\n  for(var i = 0; i < cookies.length; ++i) {\n    try {\n      client.setCookie(cookies[i]);\n    } catch(ex) {\n      // ignore failure to add other-domain, etc. cookies\n    }\n  }\n};\n\n/**\n * Creates an http client that uses forge.net sockets as a backend and\n * forge.tls for security.\n *\n * @param options:\n *   url: the url to connect to (scheme://host:port).\n *     socketPool: the flash socket pool to use.\n *   policyPort: the flash policy port to use (if other than the\n *     socket pool default), use 0 for flash default.\n *   policyUrl: the flash policy file URL to use (if provided will\n *     be used instead of a policy port).\n *   connections: number of connections to use to handle requests.\n *   caCerts: an array of certificates to trust for TLS, certs may\n *     be PEM-formatted or cert objects produced via forge.pki.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   virtualHost: the virtual server name to use in a TLS SNI\n *     extension, if not provided the url host will be used.\n *   verify: a custom TLS certificate verify callback to use.\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side\n *     private key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side\n *     signature (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local\n *     storage, false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on\n *     their creation so that they will cache TLS sessions for reuse.\n *\n * @return the client.\n */\nhttp.createClient = function(options) {\n  // create CA store to share with all TLS connections\n  var caStore = null;\n  if(options.caCerts) {\n    caStore = forge.pki.createCaStore(options.caCerts);\n  }\n\n  // get scheme, host, and port from url\n  options.url = (options.url ||\n    window.location.protocol + '//' + window.location.host);\n  var url = http.parseUrl(options.url);\n  if(!url) {\n    var error = new Error('Invalid url.');\n    error.details = {url: options.url};\n    throw error;\n  }\n\n  // default to 1 connection\n  options.connections = options.connections || 1;\n\n  // create client\n  var sp = options.socketPool;\n  var client = {\n    // url\n    url: url,\n    // socket pool\n    socketPool: sp,\n    // the policy port to use\n    policyPort: options.policyPort,\n    // policy url to use\n    policyUrl: options.policyUrl,\n    // queue of requests to service\n    requests: [],\n    // all sockets\n    sockets: [],\n    // idle sockets\n    idle: [],\n    // whether or not the connections are secure\n    secure: (url.scheme === 'https'),\n    // cookie jar (key'd off of name and then path, there is only 1 domain\n    // and one setting for secure per client so name+path is unique)\n    cookies: {},\n    // default to flash storage of cookies\n    persistCookies: (typeof(options.persistCookies) === 'undefined') ?\n      true : options.persistCookies\n  };\n\n  // load cookies from disk\n  _loadCookies(client);\n\n  /**\n   * A default certificate verify function that checks a certificate common\n   * name against the client's URL host.\n   *\n   * @param c the TLS connection.\n   * @param verified true if cert is verified, otherwise alert number.\n   * @param depth the chain depth.\n   * @param certs the cert chain.\n   *\n   * @return true if verified and the common name matches the host, error\n   *         otherwise.\n   */\n  var _defaultCertificateVerify = function(c, verified, depth, certs) {\n    if(depth === 0 && verified === true) {\n      // compare common name to url host\n      var cn = certs[depth].subject.getField('CN');\n      if(cn === null || client.url.host !== cn.value) {\n        verified = {\n          message: 'Certificate common name does not match url host.'\n        };\n      }\n    }\n    return verified;\n  };\n\n  // determine if TLS is used\n  var tlsOptions = null;\n  if(client.secure) {\n    tlsOptions = {\n      caStore: caStore,\n      cipherSuites: options.cipherSuites || null,\n      virtualHost: options.virtualHost || url.host,\n      verify: options.verify || _defaultCertificateVerify,\n      getCertificate: options.getCertificate || null,\n      getPrivateKey: options.getPrivateKey || null,\n      getSignature: options.getSignature || null,\n      prime: options.primeTlsSockets || false\n    };\n\n    // if socket pool uses a flash api, then add deflate support to TLS\n    if(sp.flashApi !== null) {\n      tlsOptions.deflate = function(bytes) {\n        // strip 2 byte zlib header and 4 byte trailer\n        return forge.util.deflate(sp.flashApi, bytes, true);\n      };\n      tlsOptions.inflate = function(bytes) {\n        return forge.util.inflate(sp.flashApi, bytes, true);\n      };\n    }\n  }\n\n  // create and initialize sockets\n  for(var i = 0; i < options.connections; ++i) {\n    _initSocket(client, sp.createSocket(), tlsOptions);\n  }\n\n  /**\n   * Sends a request. A method 'abort' will be set on the request that\n   * can be called to attempt to abort the request.\n   *\n   * @param options:\n   *          request: the request to send.\n   *          connected: a callback for when the connection is open.\n   *          closed: a callback for when the connection is closed.\n   *          headerReady: a callback for when the response header arrives.\n   *          bodyReady: a callback for when the response body arrives.\n   *          error: a callback for if an error occurs.\n   */\n  client.send = function(options) {\n    // add host header if not set\n    if(options.request.getField('Host') === null) {\n      options.request.setField('Host', client.url.fullHost);\n    }\n\n    // set default dummy handlers\n    var opts = {};\n    opts.request = options.request;\n    opts.connected = options.connected || function() {};\n    opts.closed = options.close || function() {};\n    opts.headerReady = function(e) {\n      // read cookies\n      _readCookies(client, e.response);\n      if(options.headerReady) {\n        options.headerReady(e);\n      }\n    };\n    opts.bodyReady = options.bodyReady || function() {};\n    opts.error = options.error || function() {};\n\n    // create response\n    opts.response = http.createResponse();\n    opts.response.time = 0;\n    opts.response.flashApi = client.socketPool.flashApi;\n    opts.request.flashApi = client.socketPool.flashApi;\n\n    // create abort function\n    opts.request.abort = function() {\n      // set aborted, clear handlers\n      opts.request.aborted = true;\n      opts.connected = function() {};\n      opts.closed = function() {};\n      opts.headerReady = function() {};\n      opts.bodyReady = function() {};\n      opts.error = function() {};\n    };\n\n    // add cookies to request\n    _writeCookies(client, opts.request);\n\n    // queue request options if there are no idle sockets\n    if(client.idle.length === 0) {\n      client.requests.push(opts);\n    } else {\n      // use an idle socket, prefer an idle *connected* socket first\n      var socket = null;\n      var len = client.idle.length;\n      for(var i = 0; socket === null && i < len; ++i) {\n        socket = client.idle[i];\n        if(socket.isConnected()) {\n          client.idle.splice(i, 1);\n        } else {\n          socket = null;\n        }\n      }\n      // no connected socket available, get unconnected socket\n      if(socket === null) {\n        socket = client.idle.pop();\n      }\n      socket.options = opts;\n      _doRequest(client, socket);\n    }\n  };\n\n  /**\n   * Destroys this client.\n   */\n  client.destroy = function() {\n    // clear pending requests, close and destroy sockets\n    client.requests = [];\n    for(var i = 0; i < client.sockets.length; ++i) {\n      client.sockets[i].close();\n      client.sockets[i].destroy();\n    }\n    client.socketPool = null;\n    client.sockets = [];\n    client.idle = [];\n  };\n\n  /**\n   * Sets a cookie for use with all connections made by this client. Any\n   * cookie with the same name will be replaced. If the cookie's value\n   * is undefined, null, or the blank string, the cookie will be removed.\n   *\n   * If the cookie's domain doesn't match this client's url host or the\n   * cookie's secure flag doesn't match this client's url scheme, then\n   * setting the cookie will fail with an exception.\n   *\n   * @param cookie the cookie with parameters:\n   *   name: the name of the cookie.\n   *   value: the value of the cookie.\n   *   comment: an optional comment string.\n   *   maxAge: the age of the cookie in seconds relative to created time.\n   *   secure: true if the cookie must be sent over a secure protocol.\n   *   httpOnly: true to restrict access to the cookie from javascript\n   *     (inaffective since the cookies are stored in javascript).\n   *   path: the path for the cookie.\n   *   domain: optional domain the cookie belongs to (must start with dot).\n   *   version: optional version of the cookie.\n   *   created: creation time, in UTC seconds, of the cookie.\n   */\n  client.setCookie = function(cookie) {\n    var rval;\n    if(typeof(cookie.name) !== 'undefined') {\n      if(cookie.value === null || typeof(cookie.value) === 'undefined' ||\n        cookie.value === '') {\n        // remove cookie\n        rval = client.removeCookie(cookie.name, cookie.path);\n      } else {\n        // set cookie defaults\n        cookie.comment = cookie.comment || '';\n        cookie.maxAge = cookie.maxAge || 0;\n        cookie.secure = (typeof(cookie.secure) === 'undefined') ?\n          true : cookie.secure;\n        cookie.httpOnly = cookie.httpOnly || true;\n        cookie.path = cookie.path || '/';\n        cookie.domain = cookie.domain || null;\n        cookie.version = cookie.version || null;\n        cookie.created = _getUtcTime(new Date());\n\n        // do secure check\n        if(cookie.secure !== client.secure) {\n          var error = new Error('Http client url scheme is incompatible ' +\n            'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        }\n        // make sure url host is within cookie.domain\n        if(!http.withinCookieDomain(client.url, cookie)) {\n          var error = new Error('Http client url scheme is incompatible ' +\n            'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        }\n\n        // add new cookie\n        if(!(cookie.name in client.cookies)) {\n          client.cookies[cookie.name] = {};\n        }\n        client.cookies[cookie.name][cookie.path] = cookie;\n        rval = true;\n\n        // save cookies\n        _saveCookies(client);\n      }\n    }\n\n    return rval;\n  };\n\n  /**\n   * Gets a cookie by its name.\n   *\n   * @param name the name of the cookie to retrieve.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return the cookie or null if not found.\n   */\n  client.getCookie = function(name, path) {\n    var rval = null;\n    if(name in client.cookies) {\n      var paths = client.cookies[name];\n\n      // get path-specific cookie\n      if(path) {\n        if(path in paths) {\n          rval = paths[path];\n        }\n      } else {\n        // get first cookie\n        for(var p in paths) {\n          rval = paths[p];\n          break;\n        }\n      }\n    }\n    return rval;\n  };\n\n  /**\n   * Removes a cookie.\n   *\n   * @param name the name of the cookie to remove.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return true if a cookie was removed, false if not.\n   */\n  client.removeCookie = function(name, path) {\n    var rval = false;\n    if(name in client.cookies) {\n      // delete the specific path\n      if(path) {\n        var paths = client.cookies[name];\n        if(path in paths) {\n          rval = true;\n          delete client.cookies[name][path];\n          // clean up entry if empty\n          var empty = true;\n          for(var i in client.cookies[name]) {\n            empty = false;\n            break;\n          }\n          if(empty) {\n            delete client.cookies[name];\n          }\n        }\n      } else {\n        // delete all cookies with the given name\n        rval = true;\n        delete client.cookies[name];\n      }\n    }\n    if(rval) {\n      // save cookies\n      _saveCookies(client);\n    }\n    return rval;\n  };\n\n  /**\n   * Clears all cookies stored in this client.\n   */\n  client.clearCookies = function() {\n    client.cookies = {};\n    _clearCookies(client);\n  };\n\n  if(forge.log) {\n    forge.log.debug('forge.http', 'created client', options);\n  }\n\n  return client;\n};\n\n/**\n * Trims the whitespace off of the beginning and end of a string.\n *\n * @param str the string to trim.\n *\n * @return the trimmed string.\n */\nvar _trimString = function(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n};\n\n/**\n * Creates an http header object.\n *\n * @return the http header object.\n */\nvar _createHeader = function() {\n  var header = {\n    fields: {},\n    setField: function(name, value) {\n      // normalize field name, trim value\n      header.fields[_normalize(name)] = [_trimString('' + value)];\n    },\n    appendField: function(name, value) {\n      name = _normalize(name);\n      if(!(name in header.fields)) {\n        header.fields[name] = [];\n      }\n      header.fields[name].push(_trimString('' + value));\n    },\n    getField: function(name, index) {\n      var rval = null;\n      name = _normalize(name);\n      if(name in header.fields) {\n        index = index || 0;\n        rval = header.fields[name][index];\n      }\n      return rval;\n    }\n  };\n  return header;\n};\n\n/**\n * Gets the time in utc seconds given a date.\n *\n * @param d the date to use.\n *\n * @return the time in utc seconds.\n */\nvar _getUtcTime = function(d) {\n  var utc = +d + d.getTimezoneOffset() * 60000;\n  return Math.floor(+new Date() / 1000);\n};\n\n/**\n * Creates an http request.\n *\n * @param options:\n *          version: the version.\n *          method: the method.\n *          path: the path.\n *          body: the body.\n *          headers: custom header fields to add,\n *            eg: [{'Content-Length': 0}].\n *\n * @return the http request.\n */\nhttp.createRequest = function(options) {\n  options = options || {};\n  var request = _createHeader();\n  request.version = options.version || 'HTTP/1.1';\n  request.method = options.method || null;\n  request.path = options.path || null;\n  request.body = options.body || null;\n  request.bodyDeflated = false;\n  request.flashApi = null;\n\n  // add custom headers\n  var headers = options.headers || [];\n  if(!forge.util.isArray(headers)) {\n    headers = [headers];\n  }\n  for(var i = 0; i < headers.length; ++i) {\n    for(var name in headers[i]) {\n      request.appendField(name, headers[i][name]);\n    }\n  }\n\n  /**\n   * Adds a cookie to the request 'Cookie' header.\n   *\n   * @param cookie a cookie to add.\n   */\n  request.addCookie = function(cookie) {\n    var value = '';\n    var field = request.getField('Cookie');\n    if(field !== null) {\n      // separate cookies by semi-colons\n      value = field + '; ';\n    }\n\n    // get current time in utc seconds\n    var now = _getUtcTime(new Date());\n\n    // output cookie name and value\n    value += cookie.name + '=' + cookie.value;\n    request.setField('Cookie', value);\n  };\n\n  /**\n   * Converts an http request into a string that can be sent as an\n   * HTTP request. Does not include any data.\n   *\n   * @return the string representation of the request.\n   */\n  request.toString = function() {\n    /* Sample request header:\n      GET /some/path/?query HTTP/1.1\n      Host: www.someurl.com\n      Connection: close\n      Accept-Encoding: deflate\n      Accept: image/gif, text/html\n      User-Agent: Mozilla 4.0\n     */\n\n    // set default headers\n    if(request.getField('User-Agent') === null) {\n      request.setField('User-Agent', 'forge.http 1.0');\n    }\n    if(request.getField('Accept') === null) {\n      request.setField('Accept', '*/*');\n    }\n    if(request.getField('Connection') === null) {\n      request.setField('Connection', 'keep-alive');\n      request.setField('Keep-Alive', '115');\n    }\n\n    // add Accept-Encoding if not specified\n    if(request.flashApi !== null &&\n      request.getField('Accept-Encoding') === null) {\n      request.setField('Accept-Encoding', 'deflate');\n    }\n\n    // if the body isn't null, deflate it if its larger than 100 bytes\n    if(request.flashApi !== null && request.body !== null &&\n      request.getField('Content-Encoding') === null &&\n      !request.bodyDeflated && request.body.length > 100) {\n      // use flash to compress data\n      request.body = forge.util.deflate(request.flashApi, request.body);\n      request.bodyDeflated = true;\n      request.setField('Content-Encoding', 'deflate');\n      request.setField('Content-Length', request.body.length);\n    } else if(request.body !== null) {\n      // set content length for body\n      request.setField('Content-Length', request.body.length);\n    }\n\n    // build start line\n    var rval =\n      request.method.toUpperCase() + ' ' + request.path + ' ' +\n      request.version + '\\r\\n';\n\n    // add each header\n    for(var name in request.fields) {\n      var fields = request.fields[name];\n      for(var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    }\n    // final terminating CRLF\n    rval += '\\r\\n';\n\n    return rval;\n  };\n\n  return request;\n};\n\n/**\n * Creates an empty http response header.\n *\n * @return the empty http response header.\n */\nhttp.createResponse = function() {\n  // private vars\n  var _first = true;\n  var _chunkSize = 0;\n  var _chunksFinished = false;\n\n  // create response\n  var response = _createHeader();\n  response.version = null;\n  response.code = 0;\n  response.message = null;\n  response.body = null;\n  response.headerReceived = false;\n  response.bodyReceived = false;\n  response.flashApi = null;\n\n  /**\n   * Reads a line that ends in CRLF from a byte buffer.\n   *\n   * @param b the byte buffer.\n   *\n   * @return the line or null if none was found.\n   */\n  var _readCrlf = function(b) {\n    var line = null;\n    var i = b.data.indexOf('\\r\\n', b.read);\n    if(i != -1) {\n      // read line, skip CRLF\n      line = b.getBytes(i - b.read);\n      b.getBytes(2);\n    }\n    return line;\n  };\n\n  /**\n   * Parses a header field and appends it to the response.\n   *\n   * @param line the header field line.\n   */\n  var _parseHeader = function(line) {\n    var tmp = line.indexOf(':');\n    var name = line.substring(0, tmp++);\n    response.appendField(\n      name, (tmp < line.length) ? line.substring(tmp) : '');\n  };\n\n  /**\n   * Reads an http response header from a buffer of bytes.\n   *\n   * @param b the byte buffer to parse the header from.\n   *\n   * @return true if the whole header was read, false if not.\n   */\n  response.readHeader = function(b) {\n    // read header lines (each ends in CRLF)\n    var line = '';\n    while(!response.headerReceived && line !== null) {\n      line = _readCrlf(b);\n      if(line !== null) {\n        // parse first line\n        if(_first) {\n          _first = false;\n          var tmp = line.split(' ');\n          if(tmp.length >= 3) {\n            response.version = tmp[0];\n            response.code = parseInt(tmp[1], 10);\n            response.message = tmp.slice(2).join(' ');\n          } else {\n            // invalid header\n            var error = new Error('Invalid http response header.');\n            error.details = {'line': line};\n            throw error;\n          }\n        } else if(line.length === 0) {\n          // handle final line, end of header\n          response.headerReceived = true;\n        } else {\n          _parseHeader(line);\n        }\n      }\n    }\n\n    return response.headerReceived;\n  };\n\n  /**\n   * Reads some chunked http response entity-body from the given buffer of\n   * bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n  var _readChunkedBody = function(b) {\n    /* Chunked transfer-encoding sends data in a series of chunks,\n      followed by a set of 0-N http trailers.\n      The format is as follows:\n\n      chunk-size (in hex) CRLF\n      chunk data (with \"chunk-size\" many bytes) CRLF\n      ... (N many chunks)\n      chunk-size (of 0 indicating the last chunk) CRLF\n      N many http trailers followed by CRLF\n      blank line + CRLF (terminates the trailers)\n\n      If there are no http trailers, then after the chunk-size of 0,\n      there is still a single CRLF (indicating the blank line + CRLF\n      that terminates the trailers). In other words, you always terminate\n      the trailers with blank line + CRLF, regardless of 0-N trailers. */\n\n      /* From RFC-2616, section 3.6.1, here is the pseudo-code for\n      implementing chunked transfer-encoding:\n\n      length := 0\n      read chunk-size, chunk-extension (if any) and CRLF\n      while (chunk-size > 0) {\n        read chunk-data and CRLF\n        append chunk-data to entity-body\n        length := length + chunk-size\n        read chunk-size and CRLF\n      }\n      read entity-header\n      while (entity-header not empty) {\n        append entity-header to existing header fields\n        read entity-header\n      }\n      Content-Length := length\n      Remove \"chunked\" from Transfer-Encoding\n    */\n\n    var line = '';\n    while(line !== null && b.length() > 0) {\n      // if in the process of reading a chunk\n      if(_chunkSize > 0) {\n        // if there are not enough bytes to read chunk and its\n        // trailing CRLF,  we must wait for more data to be received\n        if(_chunkSize + 2 > b.length()) {\n          break;\n        }\n\n        // read chunk data, skip CRLF\n        response.body += b.getBytes(_chunkSize);\n        b.getBytes(2);\n        _chunkSize = 0;\n      } else if(!_chunksFinished) {\n        // more chunks, read next chunk-size line\n        line = _readCrlf(b);\n        if(line !== null) {\n          // parse chunk-size (ignore any chunk extension)\n          _chunkSize = parseInt(line.split(';', 1)[0], 16);\n          _chunksFinished = (_chunkSize === 0);\n        }\n      } else {\n        // chunks finished, read next trailer\n        line = _readCrlf(b);\n        while(line !== null) {\n          if(line.length > 0) {\n            // parse trailer\n            _parseHeader(line);\n            // read next trailer\n            line = _readCrlf(b);\n          } else {\n            // body received\n            response.bodyReceived = true;\n            line = null;\n          }\n        }\n      }\n    }\n\n    return response.bodyReceived;\n  };\n\n  /**\n   * Reads an http response body from a buffer of bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n  response.readBody = function(b) {\n    var contentLength = response.getField('Content-Length');\n    var transferEncoding = response.getField('Transfer-Encoding');\n    if(contentLength !== null) {\n      contentLength = parseInt(contentLength);\n    }\n\n    // read specified length\n    if(contentLength !== null && contentLength >= 0) {\n      response.body = response.body || '';\n      response.body += b.getBytes(contentLength);\n      response.bodyReceived = (response.body.length === contentLength);\n    } else if(transferEncoding !== null) {\n      // read chunked encoding\n      if(transferEncoding.indexOf('chunked') != -1) {\n        response.body = response.body || '';\n        _readChunkedBody(b);\n      } else {\n        var error = new Error('Unknown Transfer-Encoding.');\n        error.details = {'transferEncoding': transferEncoding};\n        throw error;\n      }\n    } else if((contentLength !== null && contentLength < 0) ||\n      (contentLength === null &&\n      response.getField('Content-Type') !== null)) {\n      // read all data in the buffer\n      response.body = response.body || '';\n      response.body += b.getBytes();\n      response.readBodyUntilClose = true;\n    } else {\n      // no body\n      response.body = null;\n      response.bodyReceived = true;\n    }\n\n    if(response.bodyReceived) {\n      response.time = +new Date() - response.time;\n    }\n\n    if(response.flashApi !== null &&\n      response.bodyReceived && response.body !== null &&\n      response.getField('Content-Encoding') === 'deflate') {\n      // inflate using flash api\n      response.body = forge.util.inflate(\n        response.flashApi, response.body);\n    }\n\n    return response.bodyReceived;\n  };\n\n   /**\n    * Parses an array of cookies from the 'Set-Cookie' field, if present.\n    *\n    * @return the array of cookies.\n    */\n   response.getCookies = function() {\n     var rval = [];\n\n     // get Set-Cookie field\n     if('Set-Cookie' in response.fields) {\n       var field = response.fields['Set-Cookie'];\n\n       // get current local time in seconds\n       var now = +new Date() / 1000;\n\n       // regex for parsing 'name1=value1; name2=value2; name3'\n       var regex = /\\s*([^=]*)=?([^;]*)(;|$)/g;\n\n       // examples:\n       // Set-Cookie: cookie1_name=cookie1_value; max-age=0; path=/\n       // Set-Cookie: c2=v2; expires=Thu, 21-Aug-2008 23:47:25 GMT; path=/\n       for(var i = 0; i < field.length; ++i) {\n         var fv = field[i];\n         var m;\n         regex.lastIndex = 0;\n         var first = true;\n         var cookie = {};\n         do {\n           m = regex.exec(fv);\n           if(m !== null) {\n             var name = _trimString(m[1]);\n             var value = _trimString(m[2]);\n\n             // cookie_name=value\n             if(first) {\n               cookie.name = name;\n               cookie.value = value;\n               first = false;\n             } else {\n               // property_name=value\n               name = name.toLowerCase();\n               switch(name) {\n               case 'expires':\n                 // replace hyphens w/spaces so date will parse\n                 value = value.replace(/-/g, ' ');\n                 var secs = Date.parse(value) / 1000;\n                 cookie.maxAge = Math.max(0, secs - now);\n                 break;\n               case 'max-age':\n                 cookie.maxAge = parseInt(value, 10);\n                 break;\n               case 'secure':\n                 cookie.secure = true;\n                 break;\n               case 'httponly':\n                 cookie.httpOnly = true;\n                 break;\n               default:\n                 if(name !== '') {\n                   cookie[name] = value;\n                 }\n               }\n             }\n           }\n         } while(m !== null && m[0] !== '');\n         rval.push(cookie);\n       }\n     }\n\n     return rval;\n  };\n\n  /**\n   * Converts an http response into a string that can be sent as an\n   * HTTP response. Does not include any data.\n   *\n   * @return the string representation of the response.\n   */\n  response.toString = function() {\n    /* Sample response header:\n      HTTP/1.0 200 OK\n      Host: www.someurl.com\n      Connection: close\n     */\n\n    // build start line\n    var rval =\n      response.version + ' ' + response.code + ' ' + response.message + '\\r\\n';\n\n    // add each header\n    for(var name in response.fields) {\n      var fields = response.fields[name];\n      for(var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    }\n    // final terminating CRLF\n    rval += '\\r\\n';\n\n    return rval;\n  };\n\n  return response;\n};\n\n/**\n * Parses the scheme, host, and port from an http(s) url.\n *\n * @param str the url string.\n *\n * @return the parsed url object or null if the url is invalid.\n */\nhttp.parseUrl = forge.util.parseUrl;\n\n/**\n * Returns true if the given url is within the given cookie's domain.\n *\n * @param url the url to check.\n * @param cookie the cookie or cookie domain to check.\n */\nhttp.withinCookieDomain = function(url, cookie) {\n  var rval = false;\n\n  // cookie may be null, a cookie object, or a domain string\n  var domain = (cookie === null || typeof cookie === 'string') ?\n    cookie : cookie.domain;\n\n  // any domain will do\n  if(domain === null) {\n    rval = true;\n  } else if(domain.charAt(0) === '.') {\n    // ensure domain starts with a '.'\n    // parse URL as necessary\n    if(typeof url === 'string') {\n      url = http.parseUrl(url);\n    }\n\n    // add '.' to front of URL host to match against domain\n    var host = '.' + url.host;\n\n    // if the host ends with domain then it falls within it\n    var idx = host.lastIndexOf(domain);\n    if(idx !== -1 && (idx + domain.length === host.length)) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n", "/**\n * Utility functions for web applications.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2018 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nvar baseN = require('./baseN');\n\n/* Utilities API */\nvar util = module.exports = forge.util = forge.util || {};\n\n// define setImmediate and nextTick\n(function() {\n  // use native nextTick (unless we're in webpack)\n  // webpack (or better node-libs-browser polyfill) sets process.browser.\n  // this way we can detect webpack properly\n  if(typeof process !== 'undefined' && process.nextTick && !process.browser) {\n    util.nextTick = process.nextTick;\n    if(typeof setImmediate === 'function') {\n      util.setImmediate = setImmediate;\n    } else {\n      // polyfill setImmediate with nextTick, older versions of node\n      // (those w/o setImmediate) won't totally starve IO\n      util.setImmediate = util.nextTick;\n    }\n    return;\n  }\n\n  // polyfill nextTick with native setImmediate\n  if(typeof setImmediate === 'function') {\n    util.setImmediate = function() { return setImmediate.apply(undefined, arguments); };\n    util.nextTick = function(callback) {\n      return setImmediate(callback);\n    };\n    return;\n  }\n\n  /* Note: A polyfill upgrade pattern is used here to allow combining\n  polyfills. For example, MutationObserver is fast, but blocks UI updates,\n  so it needs to allow UI updates periodically, so it falls back on\n  postMessage or setTimeout. */\n\n  // polyfill with setTimeout\n  util.setImmediate = function(callback) {\n    setTimeout(callback, 0);\n  };\n\n  // upgrade polyfill to use postMessage\n  if(typeof window !== 'undefined' &&\n    typeof window.postMessage === 'function') {\n    var msg = 'forge.setImmediate';\n    var callbacks = [];\n    util.setImmediate = function(callback) {\n      callbacks.push(callback);\n      // only send message when one hasn't been sent in\n      // the current turn of the event loop\n      if(callbacks.length === 1) {\n        window.postMessage(msg, '*');\n      }\n    };\n    function handler(event) {\n      if(event.source === window && event.data === msg) {\n        event.stopPropagation();\n        var copy = callbacks.slice();\n        callbacks.length = 0;\n        copy.forEach(function(callback) {\n          callback();\n        });\n      }\n    }\n    window.addEventListener('message', handler, true);\n  }\n\n  // upgrade polyfill to use MutationObserver\n  if(typeof MutationObserver !== 'undefined') {\n    // polyfill with MutationObserver\n    var now = Date.now();\n    var attr = true;\n    var div = document.createElement('div');\n    var callbacks = [];\n    new MutationObserver(function() {\n      var copy = callbacks.slice();\n      callbacks.length = 0;\n      copy.forEach(function(callback) {\n        callback();\n      });\n    }).observe(div, {attributes: true});\n    var oldSetImmediate = util.setImmediate;\n    util.setImmediate = function(callback) {\n      if(Date.now() - now > 15) {\n        now = Date.now();\n        oldSetImmediate(callback);\n      } else {\n        callbacks.push(callback);\n        // only trigger observer when it hasn't been triggered in\n        // the current turn of the event loop\n        if(callbacks.length === 1) {\n          div.setAttribute('a', attr = !attr);\n        }\n      }\n    };\n  }\n\n  util.nextTick = util.setImmediate;\n})();\n\n// check if running under Node.js\nutil.isNodejs =\n  typeof process !== 'undefined' && process.versions && process.versions.node;\n\n\n// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while\n// it will point to `window` in the main thread.\n// To remain compatible with older browsers, we fall back to 'window' if 'self'\n// is not available.\nutil.globalScope = (function() {\n  if(util.isNodejs) {\n    return global;\n  }\n\n  return typeof self === 'undefined' ? window : self;\n})();\n\n// define isArray\nutil.isArray = Array.isArray || function(x) {\n  return Object.prototype.toString.call(x) === '[object Array]';\n};\n\n// define isArrayBuffer\nutil.isArrayBuffer = function(x) {\n  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;\n};\n\n// define isArrayBufferView\nutil.isArrayBufferView = function(x) {\n  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;\n};\n\n/**\n * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for\n * algorithms where bit manipulation, JavaScript limitations, and/or algorithm\n * design only allow for byte operations of a limited size.\n *\n * @param n number of bits.\n *\n * Throw Error if n invalid.\n */\nfunction _checkBitsParam(n) {\n  if(!(n === 8 || n === 16 || n === 24 || n === 32)) {\n    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);\n  }\n}\n\n// TODO: set ByteBuffer to best available backing\nutil.ByteBuffer = ByteStringBuffer;\n\n/** Buffer w/BinaryString backing */\n\n/**\n * Constructor for a binary string backed byte buffer.\n *\n * @param [b] the bytes to wrap (either encoded as string, one byte per\n *          character, or as an ArrayBuffer or Typed Array).\n */\nfunction ByteStringBuffer(b) {\n  // TODO: update to match DataBuffer API\n\n  // the data in this buffer\n  this.data = '';\n  // the pointer for reading from this buffer\n  this.read = 0;\n\n  if(typeof b === 'string') {\n    this.data = b;\n  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {\n    if(typeof Buffer !== 'undefined' && b instanceof Buffer) {\n      this.data = b.toString('binary');\n    } else {\n      // convert native buffer to forge buffer\n      // FIXME: support native buffers internally instead\n      var arr = new Uint8Array(b);\n      try {\n        this.data = String.fromCharCode.apply(null, arr);\n      } catch(e) {\n        for(var i = 0; i < arr.length; ++i) {\n          this.putByte(arr[i]);\n        }\n      }\n    }\n  } else if(b instanceof ByteStringBuffer ||\n    (typeof b === 'object' && typeof b.data === 'string' &&\n    typeof b.read === 'number')) {\n    // copy existing buffer\n    this.data = b.data;\n    this.read = b.read;\n  }\n\n  // used for v8 optimization\n  this._constructedStringLength = 0;\n}\nutil.ByteStringBuffer = ByteStringBuffer;\n\n/* Note: This is an optimization for V8-based browsers. When V8 concatenates\n  a string, the strings are only joined logically using a \"cons string\" or\n  \"constructed/concatenated string\". These containers keep references to one\n  another and can result in very large memory usage. For example, if a 2MB\n  string is constructed by concatenating 4 bytes together at a time, the\n  memory usage will be ~44MB; so ~22x increase. The strings are only joined\n  together when an operation requiring their joining takes place, such as\n  substr(). This function is called when adding data to this buffer to ensure\n  these types of strings are periodically joined to reduce the memory\n  footprint. */\nvar _MAX_CONSTRUCTED_STRING_LENGTH = 4096;\nutil.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {\n  this._constructedStringLength += x;\n  if(this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {\n    // this substr() should cause the constructed string to join\n    this.data.substr(0, 1);\n    this._constructedStringLength = 0;\n  }\n};\n\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */\nutil.ByteStringBuffer.prototype.length = function() {\n  return this.data.length - this.read;\n};\n\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */\nutil.ByteStringBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putByte = function(b) {\n  return this.putBytes(String.fromCharCode(b));\n};\n\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.fillWithByte = function(b, n) {\n  b = String.fromCharCode(b);\n  var d = this.data;\n  while(n > 0) {\n    if(n & 1) {\n      d += b;\n    }\n    n >>>= 1;\n    if(n > 0) {\n      b += b;\n    }\n  }\n  this.data = d;\n  this._optimizeConstructedString(n);\n  return this;\n};\n\n/**\n * Puts bytes in this buffer.\n *\n * @param bytes the bytes (as a binary encoded string) to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putBytes = function(bytes) {\n  this.data += bytes;\n  this._optimizeConstructedString(bytes.length);\n  return this;\n};\n\n/**\n * Puts a UTF-16 encoded string into this buffer.\n *\n * @param str the string to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putString = function(str) {\n  return this.putBytes(util.encodeUtf8(str));\n};\n\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt16 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt24 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt32 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 24 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt16Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF));\n};\n\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt24Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF));\n};\n\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt32Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 24 & 0xFF));\n};\n\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt = function(i, n) {\n  _checkBitsParam(n);\n  var bytes = '';\n  do {\n    n -= 8;\n    bytes += String.fromCharCode((i >> n) & 0xFF);\n  } while(n > 0);\n  return this.putBytes(bytes);\n};\n\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putSignedInt = function(i, n) {\n  // putInt checks n\n  if(i < 0) {\n    i += 2 << (n - 1);\n  }\n  return this.putInt(i, n);\n};\n\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putBuffer = function(buffer) {\n  return this.putBytes(buffer.getBytes());\n};\n\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */\nutil.ByteStringBuffer.prototype.getByte = function() {\n  return this.data.charCodeAt(this.read++);\n};\n\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.ByteStringBuffer.prototype.getInt16 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 8 ^\n    this.data.charCodeAt(this.read + 1));\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.ByteStringBuffer.prototype.getInt24 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 16 ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2));\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.ByteStringBuffer.prototype.getInt32 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 24 ^\n    this.data.charCodeAt(this.read + 1) << 16 ^\n    this.data.charCodeAt(this.read + 2) << 8 ^\n    this.data.charCodeAt(this.read + 3));\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.ByteStringBuffer.prototype.getInt16Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.ByteStringBuffer.prototype.getInt24Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2) << 16);\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.ByteStringBuffer.prototype.getInt32Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2) << 16 ^\n    this.data.charCodeAt(this.read + 3) << 24);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by ceil(n/8).\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.ByteStringBuffer.prototype.getInt = function(n) {\n  _checkBitsParam(n);\n  var rval = 0;\n  do {\n    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n    rval = (rval << 8) + this.data.charCodeAt(this.read++);\n    n -= 8;\n  } while(n > 0);\n  return rval;\n};\n\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.ByteStringBuffer.prototype.getSignedInt = function(n) {\n  // getInt checks n\n  var x = this.getInt(n);\n  var max = 2 << (n - 2);\n  if(x >= max) {\n    x -= max << 1;\n  }\n  return x;\n};\n\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer. Note that the resulting string is binary encoded (in node.js this\n * encoding is referred to as `binary`, it is *not* `utf8`).\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */\nutil.ByteStringBuffer.prototype.getBytes = function(count) {\n  var rval;\n  if(count) {\n    // read count bytes\n    count = Math.min(this.length(), count);\n    rval = this.data.slice(this.read, this.read + count);\n    this.read += count;\n  } else if(count === 0) {\n    rval = '';\n  } else {\n    // read all bytes, optimize to only copy when needed\n    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\n    this.clear();\n  }\n  return rval;\n};\n\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */\nutil.ByteStringBuffer.prototype.bytes = function(count) {\n  return (typeof(count) === 'undefined' ?\n    this.data.slice(this.read) :\n    this.data.slice(this.read, this.read + count));\n};\n\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */\nutil.ByteStringBuffer.prototype.at = function(i) {\n  return this.data.charCodeAt(this.read + i);\n};\n\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.setAt = function(i, b) {\n  this.data = this.data.substr(0, this.read + i) +\n    String.fromCharCode(b) +\n    this.data.substr(this.read + i + 1);\n  return this;\n};\n\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */\nutil.ByteStringBuffer.prototype.last = function() {\n  return this.data.charCodeAt(this.data.length - 1);\n};\n\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */\nutil.ByteStringBuffer.prototype.copy = function() {\n  var c = util.createBuffer(this.data);\n  c.read = this.read;\n  return c;\n};\n\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.compact = function() {\n  if(this.read > 0) {\n    this.data = this.data.slice(this.read);\n    this.read = 0;\n  }\n  return this;\n};\n\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.clear = function() {\n  this.data = '';\n  this.read = 0;\n  return this;\n};\n\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.truncate = function(count) {\n  var len = Math.max(0, this.length() - count);\n  this.data = this.data.substr(this.read, len);\n  this.read = 0;\n  return this;\n};\n\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */\nutil.ByteStringBuffer.prototype.toHex = function() {\n  var rval = '';\n  for(var i = this.read; i < this.data.length; ++i) {\n    var b = this.data.charCodeAt(i);\n    if(b < 16) {\n      rval += '0';\n    }\n    rval += b.toString(16);\n  }\n  return rval;\n};\n\n/**\n * Converts this buffer to a UTF-16 string (standard JavaScript string).\n *\n * @return a UTF-16 string.\n */\nutil.ByteStringBuffer.prototype.toString = function() {\n  return util.decodeUtf8(this.bytes());\n};\n\n/** End Buffer w/BinaryString backing */\n\n/** Buffer w/UInt8Array backing */\n\n/**\n * FIXME: Experimental. Do not use yet.\n *\n * Constructor for an ArrayBuffer-backed byte buffer.\n *\n * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a\n * TypedArray.\n *\n * If a string is given, its encoding should be provided as an option,\n * otherwise it will default to 'binary'. A 'binary' string is encoded such\n * that each character is one byte in length and size.\n *\n * If an ArrayBuffer, DataView, or TypedArray is given, it will be used\n * *directly* without any copying. Note that, if a write to the buffer requires\n * more space, the buffer will allocate a new backing ArrayBuffer to\n * accommodate. The starting read and write offsets for the buffer may be\n * given as options.\n *\n * @param [b] the initial bytes for this buffer.\n * @param options the options to use:\n *          [readOffset] the starting read offset to use (default: 0).\n *          [writeOffset] the starting write offset to use (default: the\n *            length of the first parameter).\n *          [growSize] the minimum amount, in bytes, to grow the buffer by to\n *            accommodate writes (default: 1024).\n *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the\n *            first parameter, if it is a string (default: 'binary').\n */\nfunction DataBuffer(b, options) {\n  // default options\n  options = options || {};\n\n  // pointers for read from/write to buffer\n  this.read = options.readOffset || 0;\n  this.growSize = options.growSize || 1024;\n\n  var isArrayBuffer = util.isArrayBuffer(b);\n  var isArrayBufferView = util.isArrayBufferView(b);\n  if(isArrayBuffer || isArrayBufferView) {\n    // use ArrayBuffer directly\n    if(isArrayBuffer) {\n      this.data = new DataView(b);\n    } else {\n      // TODO: adjust read/write offset based on the type of view\n      // or specify that this must be done in the options ... that the\n      // offsets are byte-based\n      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    }\n    this.write = ('writeOffset' in options ?\n      options.writeOffset : this.data.byteLength);\n    return;\n  }\n\n  // initialize to empty array buffer and add any given bytes using putBytes\n  this.data = new DataView(new ArrayBuffer(0));\n  this.write = 0;\n\n  if(b !== null && b !== undefined) {\n    this.putBytes(b);\n  }\n\n  if('writeOffset' in options) {\n    this.write = options.writeOffset;\n  }\n}\nutil.DataBuffer = DataBuffer;\n\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */\nutil.DataBuffer.prototype.length = function() {\n  return this.write - this.read;\n};\n\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */\nutil.DataBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\n/**\n * Ensures this buffer has enough empty space to accommodate the given number\n * of bytes. An optional parameter may be given that indicates a minimum\n * amount to grow the buffer if necessary. If the parameter is not given,\n * the buffer will be grown by some previously-specified default amount\n * or heuristic.\n *\n * @param amount the number of bytes to accommodate.\n * @param [growSize] the minimum amount, in bytes, to grow the buffer by if\n *          necessary.\n */\nutil.DataBuffer.prototype.accommodate = function(amount, growSize) {\n  if(this.length() >= amount) {\n    return this;\n  }\n  growSize = Math.max(growSize || this.growSize, amount);\n\n  // grow buffer\n  var src = new Uint8Array(\n    this.data.buffer, this.data.byteOffset, this.data.byteLength);\n  var dst = new Uint8Array(this.length() + growSize);\n  dst.set(src);\n  this.data = new DataView(dst.buffer);\n\n  return this;\n};\n\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putByte = function(b) {\n  this.accommodate(1);\n  this.data.setUint8(this.write++, b);\n  return this;\n};\n\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.fillWithByte = function(b, n) {\n  this.accommodate(n);\n  for(var i = 0; i < n; ++i) {\n    this.data.setUint8(b);\n  }\n  return this;\n};\n\n/**\n * Puts bytes in this buffer. The bytes may be given as a string, an\n * ArrayBuffer, a DataView, or a TypedArray.\n *\n * @param bytes the bytes to put.\n * @param [encoding] the encoding for the first parameter ('binary', 'utf8',\n *          'utf16', 'hex'), if it is a string (default: 'binary').\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putBytes = function(bytes, encoding) {\n  if(util.isArrayBufferView(bytes)) {\n    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    var len = src.byteLength - src.byteOffset;\n    this.accommodate(len);\n    var dst = new Uint8Array(this.data.buffer, this.write);\n    dst.set(src);\n    this.write += len;\n    return this;\n  }\n\n  if(util.isArrayBuffer(bytes)) {\n    var src = new Uint8Array(bytes);\n    this.accommodate(src.byteLength);\n    var dst = new Uint8Array(this.data.buffer);\n    dst.set(src, this.write);\n    this.write += src.byteLength;\n    return this;\n  }\n\n  // bytes is a util.DataBuffer or equivalent\n  if(bytes instanceof util.DataBuffer ||\n    (typeof bytes === 'object' &&\n    typeof bytes.read === 'number' && typeof bytes.write === 'number' &&\n    util.isArrayBufferView(bytes.data))) {\n    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());\n    this.accommodate(src.byteLength);\n    var dst = new Uint8Array(bytes.data.byteLength, this.write);\n    dst.set(src);\n    this.write += src.byteLength;\n    return this;\n  }\n\n  if(bytes instanceof util.ByteStringBuffer) {\n    // copy binary string and process as the same as a string parameter below\n    bytes = bytes.data;\n    encoding = 'binary';\n  }\n\n  // string conversion\n  encoding = encoding || 'binary';\n  if(typeof bytes === 'string') {\n    var view;\n\n    // decode from string\n    if(encoding === 'hex') {\n      this.accommodate(Math.ceil(bytes.length / 2));\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.hex.decode(bytes, view, this.write);\n      return this;\n    }\n    if(encoding === 'base64') {\n      this.accommodate(Math.ceil(bytes.length / 4) * 3);\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.base64.decode(bytes, view, this.write);\n      return this;\n    }\n\n    // encode text as UTF-8 bytes\n    if(encoding === 'utf8') {\n      // encode as UTF-8 then decode string as raw binary\n      bytes = util.encodeUtf8(bytes);\n      encoding = 'binary';\n    }\n\n    // decode string as raw binary\n    if(encoding === 'binary' || encoding === 'raw') {\n      // one byte per character\n      this.accommodate(bytes.length);\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.raw.decode(view);\n      return this;\n    }\n\n    // encode text as UTF-16 bytes\n    if(encoding === 'utf16') {\n      // two bytes per character\n      this.accommodate(bytes.length * 2);\n      view = new Uint16Array(this.data.buffer, this.write);\n      this.write += util.text.utf16.encode(view);\n      return this;\n    }\n\n    throw new Error('Invalid encoding: ' + encoding);\n  }\n\n  throw Error('Invalid parameter: ' + bytes);\n};\n\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putBuffer = function(buffer) {\n  this.putBytes(buffer);\n  buffer.clear();\n  return this;\n};\n\n/**\n * Puts a string into this buffer.\n *\n * @param str the string to put.\n * @param [encoding] the encoding for the string (default: 'utf16').\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putString = function(str) {\n  return this.putBytes(str, 'utf16');\n};\n\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt16 = function(i) {\n  this.accommodate(2);\n  this.data.setInt16(this.write, i);\n  this.write += 2;\n  return this;\n};\n\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt24 = function(i) {\n  this.accommodate(3);\n  this.data.setInt16(this.write, i >> 8 & 0xFFFF);\n  this.data.setInt8(this.write, i >> 16 & 0xFF);\n  this.write += 3;\n  return this;\n};\n\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt32 = function(i) {\n  this.accommodate(4);\n  this.data.setInt32(this.write, i);\n  this.write += 4;\n  return this;\n};\n\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt16Le = function(i) {\n  this.accommodate(2);\n  this.data.setInt16(this.write, i, true);\n  this.write += 2;\n  return this;\n};\n\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt24Le = function(i) {\n  this.accommodate(3);\n  this.data.setInt8(this.write, i >> 16 & 0xFF);\n  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);\n  this.write += 3;\n  return this;\n};\n\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt32Le = function(i) {\n  this.accommodate(4);\n  this.data.setInt32(this.write, i, true);\n  this.write += 4;\n  return this;\n};\n\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt = function(i, n) {\n  _checkBitsParam(n);\n  this.accommodate(n / 8);\n  do {\n    n -= 8;\n    this.data.setInt8(this.write++, (i >> n) & 0xFF);\n  } while(n > 0);\n  return this;\n};\n\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putSignedInt = function(i, n) {\n  _checkBitsParam(n);\n  this.accommodate(n / 8);\n  if(i < 0) {\n    i += 2 << (n - 1);\n  }\n  return this.putInt(i, n);\n};\n\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */\nutil.DataBuffer.prototype.getByte = function() {\n  return this.data.getInt8(this.read++);\n};\n\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.DataBuffer.prototype.getInt16 = function() {\n  var rval = this.data.getInt16(this.read);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.DataBuffer.prototype.getInt24 = function() {\n  var rval = (\n    this.data.getInt16(this.read) << 8 ^\n    this.data.getInt8(this.read + 2));\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.DataBuffer.prototype.getInt32 = function() {\n  var rval = this.data.getInt32(this.read);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.DataBuffer.prototype.getInt16Le = function() {\n  var rval = this.data.getInt16(this.read, true);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.DataBuffer.prototype.getInt24Le = function() {\n  var rval = (\n    this.data.getInt8(this.read) ^\n    this.data.getInt16(this.read + 1, true) << 8);\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.DataBuffer.prototype.getInt32Le = function() {\n  var rval = this.data.getInt32(this.read, true);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.DataBuffer.prototype.getInt = function(n) {\n  _checkBitsParam(n);\n  var rval = 0;\n  do {\n    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n    rval = (rval << 8) + this.data.getInt8(this.read++);\n    n -= 8;\n  } while(n > 0);\n  return rval;\n};\n\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.DataBuffer.prototype.getSignedInt = function(n) {\n  // getInt checks n\n  var x = this.getInt(n);\n  var max = 2 << (n - 2);\n  if(x >= max) {\n    x -= max << 1;\n  }\n  return x;\n};\n\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer.\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */\nutil.DataBuffer.prototype.getBytes = function(count) {\n  // TODO: deprecate this method, it is poorly named and\n  // this.toString('binary') replaces it\n  // add a toTypedArray()/toArrayBuffer() function\n  var rval;\n  if(count) {\n    // read count bytes\n    count = Math.min(this.length(), count);\n    rval = this.data.slice(this.read, this.read + count);\n    this.read += count;\n  } else if(count === 0) {\n    rval = '';\n  } else {\n    // read all bytes, optimize to only copy when needed\n    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\n    this.clear();\n  }\n  return rval;\n};\n\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */\nutil.DataBuffer.prototype.bytes = function(count) {\n  // TODO: deprecate this method, it is poorly named, add \"getString()\"\n  return (typeof(count) === 'undefined' ?\n    this.data.slice(this.read) :\n    this.data.slice(this.read, this.read + count));\n};\n\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */\nutil.DataBuffer.prototype.at = function(i) {\n  return this.data.getUint8(this.read + i);\n};\n\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.setAt = function(i, b) {\n  this.data.setUint8(i, b);\n  return this;\n};\n\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */\nutil.DataBuffer.prototype.last = function() {\n  return this.data.getUint8(this.write - 1);\n};\n\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */\nutil.DataBuffer.prototype.copy = function() {\n  return new util.DataBuffer(this);\n};\n\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.compact = function() {\n  if(this.read > 0) {\n    var src = new Uint8Array(this.data.buffer, this.read);\n    var dst = new Uint8Array(src.byteLength);\n    dst.set(src);\n    this.data = new DataView(dst);\n    this.write -= this.read;\n    this.read = 0;\n  }\n  return this;\n};\n\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.clear = function() {\n  this.data = new DataView(new ArrayBuffer(0));\n  this.read = this.write = 0;\n  return this;\n};\n\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.truncate = function(count) {\n  this.write = Math.max(0, this.length() - count);\n  this.read = Math.min(this.read, this.write);\n  return this;\n};\n\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */\nutil.DataBuffer.prototype.toHex = function() {\n  var rval = '';\n  for(var i = this.read; i < this.data.byteLength; ++i) {\n    var b = this.data.getUint8(i);\n    if(b < 16) {\n      rval += '0';\n    }\n    rval += b.toString(16);\n  }\n  return rval;\n};\n\n/**\n * Converts this buffer to a string, using the given encoding. If no\n * encoding is given, 'utf8' (UTF-8) is used.\n *\n * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',\n *          'base64' (default: 'utf8').\n *\n * @return a string representation of the bytes in this buffer.\n */\nutil.DataBuffer.prototype.toString = function(encoding) {\n  var view = new Uint8Array(this.data, this.read, this.length());\n  encoding = encoding || 'utf8';\n\n  // encode to string\n  if(encoding === 'binary' || encoding === 'raw') {\n    return util.binary.raw.encode(view);\n  }\n  if(encoding === 'hex') {\n    return util.binary.hex.encode(view);\n  }\n  if(encoding === 'base64') {\n    return util.binary.base64.encode(view);\n  }\n\n  // decode to text\n  if(encoding === 'utf8') {\n    return util.text.utf8.decode(view);\n  }\n  if(encoding === 'utf16') {\n    return util.text.utf16.decode(view);\n  }\n\n  throw new Error('Invalid encoding: ' + encoding);\n};\n\n/** End Buffer w/UInt8Array backing */\n\n/**\n * Creates a buffer that stores bytes. A value may be given to populate the\n * buffer with data. This value can either be string of encoded bytes or a\n * regular string of characters. When passing a string of binary encoded\n * bytes, the encoding `raw` should be given. This is also the default. When\n * passing a string of characters, the encoding `utf8` should be given.\n *\n * @param [input] a string with encoded bytes to store in the buffer.\n * @param [encoding] (default: 'raw', other: 'utf8').\n */\nutil.createBuffer = function(input, encoding) {\n  // TODO: deprecate, use new ByteBuffer() instead\n  encoding = encoding || 'raw';\n  if(input !== undefined && encoding === 'utf8') {\n    input = util.encodeUtf8(input);\n  }\n  return new util.ByteBuffer(input);\n};\n\n/**\n * Fills a string with a particular value. If you want the string to be a byte\n * string, pass in String.fromCharCode(theByte).\n *\n * @param c the character to fill the string with, use String.fromCharCode\n *          to fill the string with a byte value.\n * @param n the number of characters of value c to fill with.\n *\n * @return the filled string.\n */\nutil.fillString = function(c, n) {\n  var s = '';\n  while(n > 0) {\n    if(n & 1) {\n      s += c;\n    }\n    n >>>= 1;\n    if(n > 0) {\n      c += c;\n    }\n  }\n  return s;\n};\n\n/**\n * Performs a per byte XOR between two byte strings and returns the result as a\n * string of bytes.\n *\n * @param s1 first string of bytes.\n * @param s2 second string of bytes.\n * @param n the number of bytes to XOR.\n *\n * @return the XOR'd result.\n */\nutil.xorBytes = function(s1, s2, n) {\n  var s3 = '';\n  var b = '';\n  var t = '';\n  var i = 0;\n  var c = 0;\n  for(; n > 0; --n, ++i) {\n    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\n    if(c >= 10) {\n      s3 += t;\n      t = '';\n      c = 0;\n    }\n    t += String.fromCharCode(b);\n    ++c;\n  }\n  s3 += t;\n  return s3;\n};\n\n/**\n * Converts a hex string into a 'binary' encoded string of bytes.\n *\n * @param hex the hexadecimal string to convert.\n *\n * @return the binary-encoded string of bytes.\n */\nutil.hexToBytes = function(hex) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.hex.decode instead.\"\n  var rval = '';\n  var i = 0;\n  if(hex.length & 1 == 1) {\n    // odd number of characters, convert first character alone\n    i = 1;\n    rval += String.fromCharCode(parseInt(hex[0], 16));\n  }\n  // convert 2 characters (1 byte) at a time\n  for(; i < hex.length; i += 2) {\n    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n  }\n  return rval;\n};\n\n/**\n * Converts a 'binary' encoded string of bytes to hex.\n *\n * @param bytes the byte string to convert.\n *\n * @return the string of hexadecimal characters.\n */\nutil.bytesToHex = function(bytes) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.hex.encode instead.\"\n  return util.createBuffer(bytes).toHex();\n};\n\n/**\n * Converts an 32-bit integer to 4-big-endian byte string.\n *\n * @param i the integer.\n *\n * @return the byte string.\n */\nutil.int32ToBytes = function(i) {\n  return (\n    String.fromCharCode(i >> 24 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n// base64 characters, reverse mapping\nvar _base64 =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nvar _base64Idx = [\n/*43 -43 = 0*/\n/*'+',  1,  2,  3,'/' */\n   62, -1, -1, -1, 63,\n\n/*'0','1','2','3','4','5','6','7','8','9' */\n   52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n\n/*15, 16, 17,'=', 19, 20, 21 */\n  -1, -1, -1, 64, -1, -1, -1,\n\n/*65 - 43 = 22*/\n/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */\n   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,\n\n/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */\n   13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n\n/*91 - 43 = 48 */\n/*48, 49, 50, 51, 52, 53 */\n  -1, -1, -1, -1, -1, -1,\n\n/*97 - 43 = 54*/\n/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */\n   26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\n\n/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */\n   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n];\n\n// base58 characters (Bitcoin alphabet)\nvar _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Base64 encodes a 'binary' encoded string of bytes.\n *\n * @param input the binary encoded string of bytes to base64-encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output.\n */\nutil.encode64 = function(input, maxline) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.base64.encode instead.\"\n  var line = '';\n  var output = '';\n  var chr1, chr2, chr3;\n  var i = 0;\n  while(i < input.length) {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    // encode 4 character group\n    line += _base64.charAt(chr1 >> 2);\n    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\n    if(isNaN(chr2)) {\n      line += '==';\n    } else {\n      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\n      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\n    }\n\n    if(maxline && line.length > maxline) {\n      output += line.substr(0, maxline) + '\\r\\n';\n      line = line.substr(maxline);\n    }\n  }\n  output += line;\n  return output;\n};\n\n/**\n * Base64 decodes a string into a 'binary' encoded string of bytes.\n *\n * @param input the base64-encoded input.\n *\n * @return the binary encoded string.\n */\nutil.decode64 = function(input) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.base64.decode instead.\"\n\n  // remove all non-base64 characters\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n  var output = '';\n  var enc1, enc2, enc3, enc4;\n  var i = 0;\n\n  while(i < input.length) {\n    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n\n    output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));\n    if(enc3 !== 64) {\n      // decoded at least 2 bytes\n      output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));\n      if(enc4 !== 64) {\n        // decoded 3 bytes\n        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);\n      }\n    }\n  }\n\n  return output;\n};\n\n/**\n * Encodes the given string of characters (a standard JavaScript\n * string) as a binary encoded string where the bytes represent\n * a UTF-8 encoded string of characters. Non-ASCII characters will be\n * encoded as multiple bytes according to UTF-8.\n *\n * @param str a standard string of characters to encode.\n *\n * @return the binary encoded string.\n */\nutil.encodeUtf8 = function(str) {\n  return unescape(encodeURIComponent(str));\n};\n\n/**\n * Decodes a binary encoded string that contains bytes that\n * represent a UTF-8 encoded string of characters -- into a\n * string of characters (a standard JavaScript string).\n *\n * @param str the binary encoded string to decode.\n *\n * @return the resulting standard string of characters.\n */\nutil.decodeUtf8 = function(str) {\n  return decodeURIComponent(escape(str));\n};\n\n// binary encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.binary = {\n  raw: {},\n  hex: {},\n  base64: {},\n  base58: {},\n  baseN : {\n    encode: baseN.encode,\n    decode: baseN.decode\n  }\n};\n\n/**\n * Encodes a Uint8Array as a binary-encoded string. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param bytes the Uint8Array to encode.\n *\n * @return the binary-encoded string.\n */\nutil.binary.raw.encode = function(bytes) {\n  return String.fromCharCode.apply(null, bytes);\n};\n\n/**\n * Decodes a binary-encoded string to a Uint8Array. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param str the binary-encoded string to decode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.raw.decode = function(str, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length);\n  }\n  offset = offset || 0;\n  var j = offset;\n  for(var i = 0; i < str.length; ++i) {\n    out[j++] = str.charCodeAt(i);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or\n * ByteBuffer as a string of hexadecimal characters.\n *\n * @param bytes the bytes to convert.\n *\n * @return the string of hexadecimal characters.\n */\nutil.binary.hex.encode = util.bytesToHex;\n\n/**\n * Decodes a hex-encoded string to a Uint8Array.\n *\n * @param hex the hexadecimal string to convert.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.hex.decode = function(hex, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(Math.ceil(hex.length / 2));\n  }\n  offset = offset || 0;\n  var i = 0, j = offset;\n  if(hex.length & 1) {\n    // odd number of characters, convert first character alone\n    i = 1;\n    out[j++] = parseInt(hex[0], 16);\n  }\n  // convert 2 characters (1 byte) at a time\n  for(; i < hex.length; i += 2) {\n    out[j++] = parseInt(hex.substr(i, 2), 16);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Base64-encodes a Uint8Array.\n *\n * @param input the Uint8Array to encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output string.\n */\nutil.binary.base64.encode = function(input, maxline) {\n  var line = '';\n  var output = '';\n  var chr1, chr2, chr3;\n  var i = 0;\n  while(i < input.byteLength) {\n    chr1 = input[i++];\n    chr2 = input[i++];\n    chr3 = input[i++];\n\n    // encode 4 character group\n    line += _base64.charAt(chr1 >> 2);\n    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\n    if(isNaN(chr2)) {\n      line += '==';\n    } else {\n      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\n      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\n    }\n\n    if(maxline && line.length > maxline) {\n      output += line.substr(0, maxline) + '\\r\\n';\n      line = line.substr(maxline);\n    }\n  }\n  output += line;\n  return output;\n};\n\n/**\n * Decodes a base64-encoded string to a Uint8Array.\n *\n * @param input the base64-encoded input string.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.base64.decode = function(input, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(Math.ceil(input.length / 4) * 3);\n  }\n\n  // remove all non-base64 characters\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n  offset = offset || 0;\n  var enc1, enc2, enc3, enc4;\n  var i = 0, j = offset;\n\n  while(i < input.length) {\n    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n\n    out[j++] = (enc1 << 2) | (enc2 >> 4);\n    if(enc3 !== 64) {\n      // decoded at least 2 bytes\n      out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);\n      if(enc4 !== 64) {\n        // decoded 3 bytes\n        out[j++] = ((enc3 & 3) << 6) | enc4;\n      }\n    }\n  }\n\n  // make sure result is the exact decoded length\n  return output ? (j - offset) : out.subarray(0, j);\n};\n\n// add support for base58 encoding/decoding with Bitcoin alphabet\nutil.binary.base58.encode = function(input, maxline) {\n  return util.binary.baseN.encode(input, _base58, maxline);\n};\nutil.binary.base58.decode = function(input, maxline) {\n  return util.binary.baseN.decode(input, _base58, maxline);\n};\n\n// text encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.text = {\n  utf8: {},\n  utf16: {}\n};\n\n/**\n * Encodes the given string as UTF-8 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.text.utf8.encode = function(str, output, offset) {\n  str = util.encodeUtf8(str);\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length);\n  }\n  offset = offset || 0;\n  var j = offset;\n  for(var i = 0; i < str.length; ++i) {\n    out[j++] = str.charCodeAt(i);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Decodes the UTF-8 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */\nutil.text.utf8.decode = function(bytes) {\n  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));\n};\n\n/**\n * Encodes the given string as UTF-16 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.text.utf16.encode = function(str, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length * 2);\n  }\n  var view = new Uint16Array(out.buffer);\n  offset = offset || 0;\n  var j = offset;\n  var k = offset;\n  for(var i = 0; i < str.length; ++i) {\n    view[k++] = str.charCodeAt(i);\n    j += 2;\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Decodes the UTF-16 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */\nutil.text.utf16.decode = function(bytes) {\n  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n};\n\n/**\n * Deflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true to return only raw deflate data, false to include zlib\n *          header and trailer.\n *\n * @return the deflated data as a string.\n */\nutil.deflate = function(api, bytes, raw) {\n  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);\n\n  // strip zlib header and trailer if necessary\n  if(raw) {\n    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that\n    // there is a 4-byte DICT (alder-32) block before the data if\n    // its 5th bit is set\n    var start = 2;\n    var flg = bytes.charCodeAt(1);\n    if(flg & 0x20) {\n      start = 6;\n    }\n    // zlib trailer is 4 bytes of adler-32\n    bytes = bytes.substring(start, bytes.length - 4);\n  }\n\n  return bytes;\n};\n\n/**\n * Inflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true if the incoming data has no zlib header or trailer and is\n *          raw DEFLATE data.\n *\n * @return the inflated data as a string, null on error.\n */\nutil.inflate = function(api, bytes, raw) {\n  // TODO: add zlib header and trailer if necessary/possible\n  var rval = api.inflate(util.encode64(bytes)).rval;\n  return (rval === null) ? null : util.decode64(rval);\n};\n\n/**\n * Sets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param obj the storage object, null to remove.\n */\nvar _setStorageObject = function(api, id, obj) {\n  if(!api) {\n    throw new Error('WebStorage not available.');\n  }\n\n  var rval;\n  if(obj === null) {\n    rval = api.removeItem(id);\n  } else {\n    // json-encode and base64-encode object\n    obj = util.encode64(JSON.stringify(obj));\n    rval = api.setItem(id, obj);\n  }\n\n  // handle potential flash error\n  if(typeof(rval) !== 'undefined' && rval.rval !== true) {\n    var error = new Error(rval.error.message);\n    error.id = rval.error.id;\n    error.name = rval.error.name;\n    throw error;\n  }\n};\n\n/**\n * Gets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n *\n * @return the storage object entry or null if none exists.\n */\nvar _getStorageObject = function(api, id) {\n  if(!api) {\n    throw new Error('WebStorage not available.');\n  }\n\n  // get the existing entry\n  var rval = api.getItem(id);\n\n  /* Note: We check api.init because we can't do (api == localStorage)\n    on IE because of \"Class doesn't support Automation\" exception. Only\n    the flash api has an init method so this works too, but we need a\n    better solution in the future. */\n\n  // flash returns item wrapped in an object, handle special case\n  if(api.init) {\n    if(rval.rval === null) {\n      if(rval.error) {\n        var error = new Error(rval.error.message);\n        error.id = rval.error.id;\n        error.name = rval.error.name;\n        throw error;\n      }\n      // no error, but also no item\n      rval = null;\n    } else {\n      rval = rval.rval;\n    }\n  }\n\n  // handle decoding\n  if(rval !== null) {\n    // base64-decode and json-decode data\n    rval = JSON.parse(util.decode64(rval));\n  }\n\n  return rval;\n};\n\n/**\n * Stores an item in local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n */\nvar _setItem = function(api, id, key, data) {\n  // get storage object\n  var obj = _getStorageObject(api, id);\n  if(obj === null) {\n    // create a new storage object\n    obj = {};\n  }\n  // update key\n  obj[key] = data;\n\n  // set storage object\n  _setStorageObject(api, id, obj);\n};\n\n/**\n * Gets an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n *\n * @return the item.\n */\nvar _getItem = function(api, id, key) {\n  // get storage object\n  var rval = _getStorageObject(api, id);\n  if(rval !== null) {\n    // return data at key\n    rval = (key in rval) ? rval[key] : null;\n  }\n\n  return rval;\n};\n\n/**\n * Removes an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n */\nvar _removeItem = function(api, id, key) {\n  // get storage object\n  var obj = _getStorageObject(api, id);\n  if(obj !== null && key in obj) {\n    // remove key\n    delete obj[key];\n\n    // see if entry has no keys remaining\n    var empty = true;\n    for(var prop in obj) {\n      empty = false;\n      break;\n    }\n    if(empty) {\n      // remove entry entirely if no keys are left\n      obj = null;\n    }\n\n    // set storage object\n    _setStorageObject(api, id, obj);\n  }\n};\n\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n */\nvar _clearItems = function(api, id) {\n  _setStorageObject(api, id, null);\n};\n\n/**\n * Calls a storage function.\n *\n * @param func the function to call.\n * @param args the arguments for the function.\n * @param location the location argument.\n *\n * @return the return value from the function.\n */\nvar _callStorageFunction = function(func, args, location) {\n  var rval = null;\n\n  // default storage types\n  if(typeof(location) === 'undefined') {\n    location = ['web', 'flash'];\n  }\n\n  // apply storage types in order of preference\n  var type;\n  var done = false;\n  var exception = null;\n  for(var idx in location) {\n    type = location[idx];\n    try {\n      if(type === 'flash' || type === 'both') {\n        if(args[0] === null) {\n          throw new Error('Flash local storage not available.');\n        }\n        rval = func.apply(this, args);\n        done = (type === 'flash');\n      }\n      if(type === 'web' || type === 'both') {\n        args[0] = localStorage;\n        rval = func.apply(this, args);\n        done = true;\n      }\n    } catch(ex) {\n      exception = ex;\n    }\n    if(done) {\n      break;\n    }\n  }\n\n  if(!done) {\n    throw exception;\n  }\n\n  return rval;\n};\n\n/**\n * Stores an item on local disk.\n *\n * The available types of local storage include 'flash', 'web', and 'both'.\n *\n * The type 'flash' refers to flash local storage (SharedObject). In order\n * to use flash local storage, the 'api' parameter must be valid. The type\n * 'web' refers to WebStorage, if supported by the browser. The type 'both'\n * refers to storing using both 'flash' and 'web', not just one or the\n * other.\n *\n * The location array should list the storage types to use in order of\n * preference:\n *\n * ['flash']: flash only storage\n * ['web']: web only storage\n * ['both']: try to store in both\n * ['flash','web']: store in flash first, but if not available, 'web'\n * ['web','flash']: store in web first, but if not available, 'flash'\n *\n * The location array defaults to: ['web', 'flash']\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n * @param location an array with the preferred types of storage to use.\n */\nutil.setItem = function(api, id, key, data, location) {\n  _callStorageFunction(_setItem, arguments, location);\n};\n\n/**\n * Gets an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n *\n * @return the item.\n */\nutil.getItem = function(api, id, key, location) {\n  return _callStorageFunction(_getItem, arguments, location);\n};\n\n/**\n * Removes an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n */\nutil.removeItem = function(api, id, key, location) {\n  _callStorageFunction(_removeItem, arguments, location);\n};\n\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface if flash is available.\n * @param id the storage ID to use.\n * @param location an array with the preferred types of storage to use.\n */\nutil.clearItems = function(api, id, location) {\n  _callStorageFunction(_clearItems, arguments, location);\n};\n\n/**\n * Parses the scheme, host, and port from an http(s) url.\n *\n * @param str the url string.\n *\n * @return the parsed url object or null if the url is invalid.\n */\nutil.parseUrl = function(str) {\n  // FIXME: this regex looks a bit broken\n  var regex = /^(https?):\\/\\/([^:&^\\/]*):?(\\d*)(.*)$/g;\n  regex.lastIndex = 0;\n  var m = regex.exec(str);\n  var url = (m === null) ? null : {\n    full: str,\n    scheme: m[1],\n    host: m[2],\n    port: m[3],\n    path: m[4]\n  };\n  if(url) {\n    url.fullHost = url.host;\n    if(url.port) {\n      if(url.port !== 80 && url.scheme === 'http') {\n        url.fullHost += ':' + url.port;\n      } else if(url.port !== 443 && url.scheme === 'https') {\n        url.fullHost += ':' + url.port;\n      }\n    } else if(url.scheme === 'http') {\n      url.port = 80;\n    } else if(url.scheme === 'https') {\n      url.port = 443;\n    }\n    url.full = url.scheme + '://' + url.fullHost;\n  }\n  return url;\n};\n\n/* Storage for query variables */\nvar _queryVariables = null;\n\n/**\n * Returns the window location query variables. Query is parsed on the first\n * call and the same object is returned on subsequent calls. The mapping\n * is from keys to an array of values. Parameters without values will have\n * an object key set but no value added to the value array. Values are\n * unescaped.\n *\n * ...?k1=v1&k2=v2:\n * {\n *   \"k1\": [\"v1\"],\n *   \"k2\": [\"v2\"]\n * }\n *\n * ...?k1=v1&k1=v2:\n * {\n *   \"k1\": [\"v1\", \"v2\"]\n * }\n *\n * ...?k1=v1&k2:\n * {\n *   \"k1\": [\"v1\"],\n *   \"k2\": []\n * }\n *\n * ...?k1=v1&k1:\n * {\n *   \"k1\": [\"v1\"]\n * }\n *\n * ...?k1&k1:\n * {\n *   \"k1\": []\n * }\n *\n * @param query the query string to parse (optional, default to cached\n *          results from parsing window location search query).\n *\n * @return object mapping keys to variables.\n */\nutil.getQueryVariables = function(query) {\n  var parse = function(q) {\n    var rval = {};\n    var kvpairs = q.split('&');\n    for(var i = 0; i < kvpairs.length; i++) {\n      var pos = kvpairs[i].indexOf('=');\n      var key;\n      var val;\n      if(pos > 0) {\n        key = kvpairs[i].substring(0, pos);\n        val = kvpairs[i].substring(pos + 1);\n      } else {\n        key = kvpairs[i];\n        val = null;\n      }\n      if(!(key in rval)) {\n        rval[key] = [];\n      }\n      // disallow overriding object prototype keys\n      if(!(key in Object.prototype) && val !== null) {\n        rval[key].push(unescape(val));\n      }\n    }\n    return rval;\n  };\n\n   var rval;\n   if(typeof(query) === 'undefined') {\n     // set cached variables if needed\n     if(_queryVariables === null) {\n       if(typeof(window) !== 'undefined' && window.location && window.location.search) {\n          // parse window search query\n          _queryVariables = parse(window.location.search.substring(1));\n       } else {\n          // no query variables available\n          _queryVariables = {};\n       }\n     }\n     rval = _queryVariables;\n   } else {\n     // parse given query\n     rval = parse(query);\n   }\n   return rval;\n};\n\n/**\n * Parses a fragment into a path and query. This method will take a URI\n * fragment and break it up as if it were the main URI. For example:\n *    /bar/baz?a=1&b=2\n * results in:\n *    {\n *       path: [\"bar\", \"baz\"],\n *       query: {\"k1\": [\"v1\"], \"k2\": [\"v2\"]}\n *    }\n *\n * @return object with a path array and query object.\n */\nutil.parseFragment = function(fragment) {\n  // default to whole fragment\n  var fp = fragment;\n  var fq = '';\n  // split into path and query if possible at the first '?'\n  var pos = fragment.indexOf('?');\n  if(pos > 0) {\n    fp = fragment.substring(0, pos);\n    fq = fragment.substring(pos + 1);\n  }\n  // split path based on '/' and ignore first element if empty\n  var path = fp.split('/');\n  if(path.length > 0 && path[0] === '') {\n    path.shift();\n  }\n  // convert query into object\n  var query = (fq === '') ? {} : util.getQueryVariables(fq);\n\n  return {\n    pathString: fp,\n    queryString: fq,\n    path: path,\n    query: query\n  };\n};\n\n/**\n * Makes a request out of a URI-like request string. This is intended to\n * be used where a fragment id (after a URI '#') is parsed as a URI with\n * path and query parts. The string should have a path beginning and\n * delimited by '/' and optional query parameters following a '?'. The\n * query should be a standard URL set of key value pairs delimited by\n * '&'. For backwards compatibility the initial '/' on the path is not\n * required. The request object has the following API, (fully described\n * in the method code):\n *    {\n *       path: <the path string part>.\n *       query: <the query string part>,\n *       getPath(i): get part or all of the split path array,\n *       getQuery(k, i): get part or all of a query key array,\n *       getQueryLast(k, _default): get last element of a query key array.\n *    }\n *\n * @return object with request parameters.\n */\nutil.makeRequest = function(reqString) {\n  var frag = util.parseFragment(reqString);\n  var req = {\n    // full path string\n    path: frag.pathString,\n    // full query string\n    query: frag.queryString,\n    /**\n     * Get path or element in path.\n     *\n     * @param i optional path index.\n     *\n     * @return path or part of path if i provided.\n     */\n    getPath: function(i) {\n      return (typeof(i) === 'undefined') ? frag.path : frag.path[i];\n    },\n    /**\n     * Get query, values for a key, or value for a key index.\n     *\n     * @param k optional query key.\n     * @param i optional query key index.\n     *\n     * @return query, values for a key, or value for a key index.\n     */\n    getQuery: function(k, i) {\n      var rval;\n      if(typeof(k) === 'undefined') {\n        rval = frag.query;\n      } else {\n        rval = frag.query[k];\n        if(rval && typeof(i) !== 'undefined') {\n           rval = rval[i];\n        }\n      }\n      return rval;\n    },\n    getQueryLast: function(k, _default) {\n      var rval;\n      var vals = req.getQuery(k);\n      if(vals) {\n        rval = vals[vals.length - 1];\n      } else {\n        rval = _default;\n      }\n      return rval;\n    }\n  };\n  return req;\n};\n\n/**\n * Makes a URI out of a path, an object with query parameters, and a\n * fragment. Uses jQuery.param() internally for query string creation.\n * If the path is an array, it will be joined with '/'.\n *\n * @param path string path or array of strings.\n * @param query object with query parameters. (optional)\n * @param fragment fragment string. (optional)\n *\n * @return string object with request parameters.\n */\nutil.makeLink = function(path, query, fragment) {\n  // join path parts if needed\n  path = jQuery.isArray(path) ? path.join('/') : path;\n\n  var qstr = jQuery.param(query || {});\n  fragment = fragment || '';\n  return path +\n    ((qstr.length > 0) ? ('?' + qstr) : '') +\n    ((fragment.length > 0) ? ('#' + fragment) : '');\n};\n\n/**\n * Check if an object is empty.\n *\n * Taken from:\n * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937\n *\n * @param object the object to check.\n */\nutil.isEmpty = function(obj) {\n  for(var prop in obj) {\n    if(obj.hasOwnProperty(prop)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Format with simple printf-style interpolation.\n *\n * %%: literal '%'\n * %s,%o: convert next argument into a string.\n *\n * @param format the string to format.\n * @param ... arguments to interpolate into the format string.\n */\nutil.format = function(format) {\n  var re = /%./g;\n  // current match\n  var match;\n  // current part\n  var part;\n  // current arg index\n  var argi = 0;\n  // collected parts to recombine later\n  var parts = [];\n  // last index found\n  var last = 0;\n  // loop while matches remain\n  while((match = re.exec(format))) {\n    part = format.substring(last, re.lastIndex - 2);\n    // don't add empty strings (ie, parts between %s%s)\n    if(part.length > 0) {\n      parts.push(part);\n    }\n    last = re.lastIndex;\n    // switch on % code\n    var code = match[0][1];\n    switch(code) {\n    case 's':\n    case 'o':\n      // check if enough arguments were given\n      if(argi < arguments.length) {\n        parts.push(arguments[argi++ + 1]);\n      } else {\n        parts.push('<?>');\n      }\n      break;\n    // FIXME: do proper formating for numbers, etc\n    //case 'f':\n    //case 'd':\n    case '%':\n      parts.push('%');\n      break;\n    default:\n      parts.push('<%' + code + '?>');\n    }\n  }\n  // add trailing part of format string\n  parts.push(format.substring(last));\n  return parts.join('');\n};\n\n/**\n * Formats a number.\n *\n * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/\n */\nutil.formatNumber = function(number, decimals, dec_point, thousands_sep) {\n  // http://kevin.vanzonneveld.net\n  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +     bugfix by: Michael White (http://crestidg.com)\n  // +     bugfix by: Benjamin Lupton\n  // +     bugfix by: Allan Jensen (http://www.winternet.no)\n  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // *     example 1: number_format(1234.5678, 2, '.', '');\n  // *     returns 1: 1234.57\n\n  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\n  var d = dec_point === undefined ? ',' : dec_point;\n  var t = thousands_sep === undefined ?\n   '.' : thousands_sep, s = n < 0 ? '-' : '';\n  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';\n  var j = (i.length > 3) ? i.length % 3 : 0;\n  return s + (j ? i.substr(0, j) + t : '') +\n    i.substr(j).replace(/(\\d{3})(?=\\d)/g, '$1' + t) +\n    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');\n};\n\n/**\n * Formats a byte size.\n *\n * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/\n */\nutil.formatSize = function(size) {\n  if(size >= 1073741824) {\n    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';\n  } else if(size >= 1048576) {\n    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';\n  } else if(size >= 1024) {\n    size = util.formatNumber(size / 1024, 0) + ' KiB';\n  } else {\n    size = util.formatNumber(size, 0) + ' bytes';\n  }\n  return size;\n};\n\n/**\n * Converts an IPv4 or IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv4 or IPv6 address to convert.\n *\n * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't\n *         be parsed.\n */\nutil.bytesFromIP = function(ip) {\n  if(ip.indexOf('.') !== -1) {\n    return util.bytesFromIPv4(ip);\n  }\n  if(ip.indexOf(':') !== -1) {\n    return util.bytesFromIPv6(ip);\n  }\n  return null;\n};\n\n/**\n * Converts an IPv4 string representation into bytes (in network order).\n *\n * @param ip the IPv4 address to convert.\n *\n * @return the 4-byte address or null if the address can't be parsed.\n */\nutil.bytesFromIPv4 = function(ip) {\n  ip = ip.split('.');\n  if(ip.length !== 4) {\n    return null;\n  }\n  var b = util.createBuffer();\n  for(var i = 0; i < ip.length; ++i) {\n    var num = parseInt(ip[i], 10);\n    if(isNaN(num)) {\n      return null;\n    }\n    b.putByte(num);\n  }\n  return b.getBytes();\n};\n\n/**\n * Converts an IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv6 address to convert.\n *\n * @return the 16-byte address or null if the address can't be parsed.\n */\nutil.bytesFromIPv6 = function(ip) {\n  var blanks = 0;\n  ip = ip.split(':').filter(function(e) {\n    if(e.length === 0) ++blanks;\n    return true;\n  });\n  var zeros = (8 - ip.length + blanks) * 2;\n  var b = util.createBuffer();\n  for(var i = 0; i < 8; ++i) {\n    if(!ip[i] || ip[i].length === 0) {\n      b.fillWithByte(0, zeros);\n      zeros = 0;\n      continue;\n    }\n    var bytes = util.hexToBytes(ip[i]);\n    if(bytes.length < 2) {\n      b.putByte(0);\n    }\n    b.putBytes(bytes);\n  }\n  return b.getBytes();\n};\n\n/**\n * Converts 4-bytes into an IPv4 string representation or 16-bytes into\n * an IPv6 string representation. The bytes must be in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,\n *         respectively, are given, otherwise null.\n */\nutil.bytesToIP = function(bytes) {\n  if(bytes.length === 4) {\n    return util.bytesToIPv4(bytes);\n  }\n  if(bytes.length === 16) {\n    return util.bytesToIPv6(bytes);\n  }\n  return null;\n};\n\n/**\n * Converts 4-bytes into an IPv4 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 string representation or null for an invalid # of bytes.\n */\nutil.bytesToIPv4 = function(bytes) {\n  if(bytes.length !== 4) {\n    return null;\n  }\n  var ip = [];\n  for(var i = 0; i < bytes.length; ++i) {\n    ip.push(bytes.charCodeAt(i));\n  }\n  return ip.join('.');\n};\n\n/**\n * Converts 16-bytes into an IPv16 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv16 string representation or null for an invalid # of bytes.\n */\nutil.bytesToIPv6 = function(bytes) {\n  if(bytes.length !== 16) {\n    return null;\n  }\n  var ip = [];\n  var zeroGroups = [];\n  var zeroMaxGroup = 0;\n  for(var i = 0; i < bytes.length; i += 2) {\n    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);\n    // canonicalize zero representation\n    while(hex[0] === '0' && hex !== '0') {\n      hex = hex.substr(1);\n    }\n    if(hex === '0') {\n      var last = zeroGroups[zeroGroups.length - 1];\n      var idx = ip.length;\n      if(!last || idx !== last.end + 1) {\n        zeroGroups.push({start: idx, end: idx});\n      } else {\n        last.end = idx;\n        if((last.end - last.start) >\n          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {\n          zeroMaxGroup = zeroGroups.length - 1;\n        }\n      }\n    }\n    ip.push(hex);\n  }\n  if(zeroGroups.length > 0) {\n    var group = zeroGroups[zeroMaxGroup];\n    // only shorten group of length > 0\n    if(group.end - group.start > 0) {\n      ip.splice(group.start, group.end - group.start + 1, '');\n      if(group.start === 0) {\n        ip.unshift('');\n      }\n      if(group.end === 7) {\n        ip.push('');\n      }\n    }\n  }\n  return ip.join(':');\n};\n\n/**\n * Estimates the number of processes that can be run concurrently. If\n * creating Web Workers, keep in mind that the main JavaScript process needs\n * its own core.\n *\n * @param options the options to use:\n *          update true to force an update (not use the cached value).\n * @param callback(err, max) called once the operation completes.\n */\nutil.estimateCores = function(options, callback) {\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  if('cores' in util && !options.update) {\n    return callback(null, util.cores);\n  }\n  if(typeof navigator !== 'undefined' &&\n    'hardwareConcurrency' in navigator &&\n    navigator.hardwareConcurrency > 0) {\n    util.cores = navigator.hardwareConcurrency;\n    return callback(null, util.cores);\n  }\n  if(typeof Worker === 'undefined') {\n    // workers not available\n    util.cores = 1;\n    return callback(null, util.cores);\n  }\n  if(typeof Blob === 'undefined') {\n    // can't estimate, default to 2\n    util.cores = 2;\n    return callback(null, util.cores);\n  }\n\n  // create worker concurrency estimation code as blob\n  var blobUrl = URL.createObjectURL(new Blob(['(',\n    function() {\n      self.addEventListener('message', function(e) {\n        // run worker for 4 ms\n        var st = Date.now();\n        var et = st + 4;\n        while(Date.now() < et);\n        self.postMessage({st: st, et: et});\n      });\n    }.toString(),\n  ')()'], {type: 'application/javascript'}));\n\n  // take 5 samples using 16 workers\n  sample([], 5, 16);\n\n  function sample(max, samples, numWorkers) {\n    if(samples === 0) {\n      // get overlap average\n      var avg = Math.floor(max.reduce(function(avg, x) {\n        return avg + x;\n      }, 0) / max.length);\n      util.cores = Math.max(1, avg);\n      URL.revokeObjectURL(blobUrl);\n      return callback(null, util.cores);\n    }\n    map(numWorkers, function(err, results) {\n      max.push(reduce(numWorkers, results));\n      sample(max, samples - 1, numWorkers);\n    });\n  }\n\n  function map(numWorkers, callback) {\n    var workers = [];\n    var results = [];\n    for(var i = 0; i < numWorkers; ++i) {\n      var worker = new Worker(blobUrl);\n      worker.addEventListener('message', function(e) {\n        results.push(e.data);\n        if(results.length === numWorkers) {\n          for(var i = 0; i < numWorkers; ++i) {\n            workers[i].terminate();\n          }\n          callback(null, results);\n        }\n      });\n      workers.push(worker);\n    }\n    for(var i = 0; i < numWorkers; ++i) {\n      workers[i].postMessage(i);\n    }\n  }\n\n  function reduce(numWorkers, results) {\n    // find overlapping time windows\n    var overlaps = [];\n    for(var n = 0; n < numWorkers; ++n) {\n      var r1 = results[n];\n      var overlap = overlaps[n] = [];\n      for(var i = 0; i < numWorkers; ++i) {\n        if(n === i) {\n          continue;\n        }\n        var r2 = results[i];\n        if((r1.st > r2.st && r1.st < r2.et) ||\n          (r2.st > r1.st && r2.st < r1.et)) {\n          overlap.push(i);\n        }\n      }\n    }\n    // get maximum overlaps ... don't include overlapping worker itself\n    // as the main JS process was also being scheduled during the work and\n    // would have to be subtracted from the estimate anyway\n    return overlaps.reduce(function(max, overlap) {\n      return Math.max(max, overlap.length);\n    }, 0);\n  }\n};\n", "/**\n * XmlHttpRequest implementation that uses TLS and flash SocketPool.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./socket');\nrequire('./http');\n\n/* XHR API */\nvar xhrApi = module.exports = forge.xhr = forge.xhr || {};\n\n(function($) {\n\n// logging category\nvar cat = 'forge.xhr';\n\n/*\nXMLHttpRequest interface definition from:\nhttp://www.w3.org/TR/XMLHttpRequest\n\ninterface XMLHttpRequest {\n  // event handler\n  attribute EventListener onreadystatechange;\n\n  // state\n  const unsigned short UNSENT = 0;\n  const unsigned short OPENED = 1;\n  const unsigned short HEADERS_RECEIVED = 2;\n  const unsigned short LOADING = 3;\n  const unsigned short DONE = 4;\n  readonly attribute unsigned short readyState;\n\n  // request\n  void open(in DOMString method, in DOMString url);\n  void open(in DOMString method, in DOMString url, in boolean async);\n  void open(in DOMString method, in DOMString url,\n            in boolean async, in DOMString user);\n  void open(in DOMString method, in DOMString url,\n            in boolean async, in DOMString user, in DOMString password);\n  void setRequestHeader(in DOMString header, in DOMString value);\n  void send();\n  void send(in DOMString data);\n  void send(in Document data);\n  void abort();\n\n  // response\n  DOMString getAllResponseHeaders();\n  DOMString getResponseHeader(in DOMString header);\n  readonly attribute DOMString responseText;\n  readonly attribute Document responseXML;\n  readonly attribute unsigned short status;\n  readonly attribute DOMString statusText;\n};\n*/\n\n// readyStates\nvar UNSENT = 0;\nvar OPENED = 1;\nvar HEADERS_RECEIVED = 2;\nvar LOADING = 3;\nvar DONE = 4;\n\n// exceptions\nvar INVALID_STATE_ERR = 11;\nvar SYNTAX_ERR = 12;\nvar SECURITY_ERR = 18;\nvar NETWORK_ERR = 19;\nvar ABORT_ERR = 20;\n\n// private flash socket pool vars\nvar _sp = null;\nvar _policyPort = 0;\nvar _policyUrl = null;\n\n// default client (used if no special URL provided when creating an XHR)\nvar _client = null;\n\n// all clients including the default, key'd by full base url\n// (multiple cross-domain http clients are permitted so there may be more\n// than one client in this map)\n// TODO: provide optional clean up API for non-default clients\nvar _clients = {};\n\n// the default maximum number of concurrents connections per client\nvar _maxConnections = 10;\n\nvar net = forge.net;\nvar http = forge.http;\n\n/**\n * Initializes flash XHR support.\n *\n * @param options:\n *   url: the default base URL to connect to if xhr URLs are relative,\n *     ie: https://myserver.com.\n *   flashId: the dom ID of the flash SocketPool.\n *   policyPort: the port that provides the server's flash policy, 0 to use\n *     the flash default.\n *   policyUrl: the policy file URL to use instead of a policy port.\n *   msie: true if browser is internet explorer, false if not.\n *   connections: the maximum number of concurrent connections.\n *   caCerts: a list of PEM-formatted certificates to trust.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   verify: optional TLS certificate verify callback to use (see forge.tls\n *     for details).\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side private\n *     key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side signature\n *     (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local storage,\n *     false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on their\n *     creation so that they will cache TLS sessions for reuse.\n */\nxhrApi.init = function(options) {\n  forge.log.debug(cat, 'initializing', options);\n\n  // update default policy port and max connections\n  _policyPort = options.policyPort || _policyPort;\n  _policyUrl = options.policyUrl || _policyUrl;\n  _maxConnections = options.connections || _maxConnections;\n\n  // create the flash socket pool\n  _sp = net.createSocketPool({\n    flashId: options.flashId,\n    policyPort: _policyPort,\n    policyUrl: _policyUrl,\n    msie: options.msie || false\n  });\n\n  // create default http client\n  _client = http.createClient({\n    url: options.url || (\n      window.location.protocol + '//' + window.location.host),\n    socketPool: _sp,\n    policyPort: _policyPort,\n    policyUrl: _policyUrl,\n    connections: options.connections || _maxConnections,\n    caCerts: options.caCerts,\n    cipherSuites: options.cipherSuites,\n    persistCookies: options.persistCookies || true,\n    primeTlsSockets: options.primeTlsSockets || false,\n    verify: options.verify,\n    getCertificate: options.getCertificate,\n    getPrivateKey: options.getPrivateKey,\n    getSignature: options.getSignature\n  });\n  _clients[_client.url.full] = _client;\n\n  forge.log.debug(cat, 'ready');\n};\n\n/**\n * Called to clean up the clients and socket pool.\n */\nxhrApi.cleanup = function() {\n  // destroy all clients\n  for(var key in _clients) {\n    _clients[key].destroy();\n  }\n  _clients = {};\n  _client = null;\n\n  // destroy socket pool\n  _sp.destroy();\n  _sp = null;\n};\n\n/**\n * Sets a cookie.\n *\n * @param cookie the cookie with parameters:\n *   name: the name of the cookie.\n *   value: the value of the cookie.\n *   comment: an optional comment string.\n *   maxAge: the age of the cookie in seconds relative to created time.\n *   secure: true if the cookie must be sent over a secure protocol.\n *   httpOnly: true to restrict access to the cookie from javascript\n *     (inaffective since the cookies are stored in javascript).\n *   path: the path for the cookie.\n *   domain: optional domain the cookie belongs to (must start with dot).\n *   version: optional version of the cookie.\n *   created: creation time, in UTC seconds, of the cookie.\n */\nxhrApi.setCookie = function(cookie) {\n  // default cookie expiration to never\n  cookie.maxAge = cookie.maxAge || -1;\n\n  // if the cookie's domain is set, use the appropriate client\n  if(cookie.domain) {\n    // add the cookies to the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, cookie) &&\n        client.secure === cookie.secure) {\n        client.setCookie(cookie);\n      }\n    }\n  } else {\n    // use the default domain\n    // FIXME: should a null domain cookie be added to all clients? should\n    // this be an option?\n    _client.setCookie(cookie);\n  }\n};\n\n/**\n * Gets a cookie.\n *\n * @param name the name of the cookie.\n * @param path an optional path for the cookie (if there are multiple cookies\n *          with the same name but different paths).\n * @param domain an optional domain for the cookie (if not using the default\n *          domain).\n *\n * @return the cookie, cookies (if multiple matches), or null if not found.\n */\nxhrApi.getCookie = function(name, path, domain) {\n  var rval = null;\n\n  if(domain) {\n    // get the cookies from the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, domain)) {\n        var cookie = client.getCookie(name, path);\n        if(cookie !== null) {\n          if(rval === null) {\n            rval = cookie;\n          } else if(!forge.util.isArray(rval)) {\n            rval = [rval, cookie];\n          } else {\n            rval.push(cookie);\n          }\n        }\n      }\n    }\n  } else {\n    // get cookie from default domain\n    rval = _client.getCookie(name, path);\n  }\n\n  return rval;\n};\n\n/**\n * Removes a cookie.\n *\n * @param name the name of the cookie.\n * @param path an optional path for the cookie (if there are multiple cookies\n *          with the same name but different paths).\n * @param domain an optional domain for the cookie (if not using the default\n *          domain).\n *\n * @return true if a cookie was removed, false if not.\n */\nxhrApi.removeCookie = function(name, path, domain) {\n  var rval = false;\n\n  if(domain) {\n    // remove the cookies from the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, domain)) {\n        if(client.removeCookie(name, path)) {\n           rval = true;\n        }\n      }\n    }\n  } else {\n    // remove cookie from default domain\n    rval = _client.removeCookie(name, path);\n  }\n\n  return rval;\n};\n\n/**\n * Creates a new XmlHttpRequest. By default the base URL, flash policy port,\n * etc, will be used. However, an XHR can be created to point at another\n * cross-domain URL.\n *\n * @param options:\n *   logWarningOnError: If true and an HTTP error status code is received then\n *     log a warning, otherwise log a verbose message.\n *   verbose: If true be very verbose in the output including the response\n *     event and response body, otherwise only include status, timing, and\n *     data size.\n *   logError: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logWarning: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logDebug: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logVerbose: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   url: the default base URL to connect to if xhr URLs are relative,\n *     eg: https://myserver.com, and note that the following options will be\n *     ignored if the URL is absent or the same as the default base URL.\n *   policyPort: the port that provides the server's flash policy, 0 to use\n *     the flash default.\n *   policyUrl: the policy file URL to use instead of a policy port.\n *   connections: the maximum number of concurrent connections.\n *   caCerts: a list of PEM-formatted certificates to trust.\n *   cipherSuites: an optional array of cipher suites to use, see\n *     forge.tls.CipherSuites.\n *   verify: optional TLS certificate verify callback to use (see forge.tls\n *     for details).\n *   getCertificate: an optional callback used to get a client-side\n *     certificate.\n *   getPrivateKey: an optional callback used to get a client-side private key.\n *   getSignature: an optional callback used to get a client-side signature.\n *   persistCookies: true to use persistent cookies via flash local storage,\n *     false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on their\n *     creation so that they will cache TLS sessions for reuse.\n *\n * @return the XmlHttpRequest.\n */\nxhrApi.create = function(options) {\n  // set option defaults\n  options = $.extend({\n    logWarningOnError: true,\n    verbose: false,\n    logError: function() {},\n    logWarning: function() {},\n    logDebug: function() {},\n    logVerbose: function() {},\n    url: null\n  }, options || {});\n\n  // private xhr state\n  var _state = {\n    // the http client to use\n    client: null,\n    // request storage\n    request: null,\n    // response storage\n    response: null,\n    // asynchronous, true if doing asynchronous communication\n    asynchronous: true,\n    // sendFlag, true if send has been called\n    sendFlag: false,\n    // errorFlag, true if a network error occurred\n    errorFlag: false\n  };\n\n  // private log functions\n  var _log = {\n    error: options.logError || forge.log.error,\n    warning: options.logWarning || forge.log.warning,\n    debug: options.logDebug || forge.log.debug,\n    verbose: options.logVerbose || forge.log.verbose\n  };\n\n  // create public xhr interface\n  var xhr = {\n    // an EventListener\n    onreadystatechange: null,\n    // readonly, the current readyState\n    readyState: UNSENT,\n    // a string with the response entity-body\n    responseText: '',\n    // a Document for response entity-bodies that are XML\n    responseXML: null,\n    // readonly, returns the HTTP status code (i.e. 404)\n    status: 0,\n    // readonly, returns the HTTP status message (i.e. 'Not Found')\n    statusText: ''\n  };\n\n  // determine which http client to use\n  if(options.url === null) {\n    // use default\n    _state.client = _client;\n  } else {\n    var url = http.parseUrl(options.url);\n    if(!url) {\n      var error = new Error('Invalid url.');\n      error.details = {\n        url: options.url\n      };\n    }\n\n    // find client\n    if(url.full in _clients) {\n      // client found\n      _state.client = _clients[url.full];\n    } else {\n      // create client\n      _state.client = http.createClient({\n        url: options.url,\n        socketPool: _sp,\n        policyPort: options.policyPort || _policyPort,\n        policyUrl: options.policyUrl || _policyUrl,\n        connections: options.connections || _maxConnections,\n        caCerts: options.caCerts,\n        cipherSuites: options.cipherSuites,\n        persistCookies: options.persistCookies || true,\n        primeTlsSockets: options.primeTlsSockets || false,\n        verify: options.verify,\n        getCertificate: options.getCertificate,\n        getPrivateKey: options.getPrivateKey,\n        getSignature: options.getSignature\n      });\n      _clients[url.full] = _state.client;\n    }\n  }\n\n  /**\n   * Opens the request. This method will create the HTTP request to send.\n   *\n   * @param method the HTTP method (i.e. 'GET').\n   * @param url the relative url (the HTTP request path).\n   * @param async always true, ignored.\n   * @param user always null, ignored.\n   * @param password always null, ignored.\n   */\n  xhr.open = function(method, url, async, user, password) {\n    // 1. validate Document if one is associated\n    // TODO: not implemented (not used yet)\n\n    // 2. validate method token\n    // 3. change method to uppercase if it matches a known\n    // method (here we just require it to be uppercase, and\n    // we do not allow the standard methods)\n    // 4. disallow CONNECT, TRACE, or TRACK with a security error\n    switch(method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'PATCH':\n    case 'POST':\n    case 'PUT':\n      // valid method\n      break;\n    case 'CONNECT':\n    case 'TRACE':\n    case 'TRACK':\n      throw new Error('CONNECT, TRACE and TRACK methods are disallowed');\n    default:\n      throw new Error('Invalid method: ' + method);\n    }\n\n    // TODO: other validation steps in algorithm are not implemented\n\n    // 19. set send flag to false\n    // set response body to null\n    // empty list of request headers\n    // set request method to given method\n    // set request URL\n    // set username, password\n    // set asychronous flag\n    _state.sendFlag = false;\n    xhr.responseText = '';\n    xhr.responseXML = null;\n\n    // custom: reset status and statusText\n    xhr.status = 0;\n    xhr.statusText = '';\n\n    // create the HTTP request\n    _state.request = http.createRequest({\n      method: method,\n      path: url\n    });\n\n    // 20. set state to OPENED\n    xhr.readyState = OPENED;\n\n    // 21. dispatch onreadystatechange\n    if(xhr.onreadystatechange) {\n       xhr.onreadystatechange();\n    }\n  };\n\n  /**\n   * Adds an HTTP header field to the request.\n   *\n   * @param header the name of the header field.\n   * @param value the value of the header field.\n   */\n  xhr.setRequestHeader = function(header, value) {\n    // 1. if state is not OPENED or send flag is true, raise exception\n    if(xhr.readyState != OPENED || _state.sendFlag) {\n      throw new Error('XHR not open or sending');\n    }\n\n    // TODO: other validation steps in spec aren't implemented\n\n    // set header\n    _state.request.setField(header, value);\n  };\n\n  /**\n   * Sends the request and any associated data.\n   *\n   * @param data a string or Document object to send, null to send no data.\n   */\n  xhr.send = function(data) {\n    // 1. if state is not OPENED or 2. send flag is true, raise\n    // an invalid state exception\n    if(xhr.readyState != OPENED || _state.sendFlag) {\n      throw new Error('XHR not open or sending');\n    }\n\n    // 3. ignore data if method is GET or HEAD\n    if(data &&\n      _state.request.method !== 'GET' &&\n      _state.request.method !== 'HEAD') {\n      // handle non-IE case\n      if(typeof(XMLSerializer) !== 'undefined') {\n        if(data instanceof Document) {\n          var xs = new XMLSerializer();\n          _state.request.body = xs.serializeToString(data);\n        } else {\n          _state.request.body = data;\n        }\n      } else {\n        // poorly implemented IE case\n        if(typeof(data.xml) !== 'undefined') {\n          _state.request.body = data.xml;\n        } else {\n          _state.request.body = data;\n        }\n      }\n    }\n\n    // 4. release storage mutex (not used)\n\n    // 5. set error flag to false\n    _state.errorFlag = false;\n\n    // 6. if asynchronous is true (must be in this implementation)\n\n    // 6.1 set send flag to true\n    _state.sendFlag = true;\n\n    // 6.2 dispatch onreadystatechange\n    if(xhr.onreadystatechange) {\n      xhr.onreadystatechange();\n    }\n\n    // create send options\n    var options = {};\n    options.request = _state.request;\n    options.headerReady = function(e) {\n      // make cookies available for ease of use/iteration\n      xhr.cookies = _state.client.cookies;\n\n      // TODO: update document.cookie with any cookies where the\n      // script's domain matches\n\n      // headers received\n      xhr.readyState = HEADERS_RECEIVED;\n      xhr.status = e.response.code;\n      xhr.statusText = e.response.message;\n      _state.response = e.response;\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n      if(!_state.response.aborted) {\n        // now loading body\n        xhr.readyState = LOADING;\n        if(xhr.onreadystatechange) {\n           xhr.onreadystatechange();\n        }\n      }\n    };\n    options.bodyReady = function(e) {\n      xhr.readyState = DONE;\n      var ct = e.response.getField('Content-Type');\n      // Note: this null/undefined check is done outside because IE\n      // dies otherwise on a \"'null' is null\" error\n      if(ct) {\n        if(ct.indexOf('text/xml') === 0 ||\n          ct.indexOf('application/xml') === 0 ||\n          ct.indexOf('+xml') !== -1) {\n          try {\n            var doc = new ActiveXObject('MicrosoftXMLDOM');\n            doc.async = false;\n            doc.loadXML(e.response.body);\n            xhr.responseXML = doc;\n          } catch(ex) {\n            var parser = new DOMParser();\n            xhr.responseXML = parser.parseFromString(ex.body, 'text/xml');\n          }\n        }\n      }\n\n      var length = 0;\n      if(e.response.body !== null) {\n        xhr.responseText = e.response.body;\n        length = e.response.body.length;\n      }\n      // build logging output\n      var req = _state.request;\n      var output =\n        req.method + ' ' + req.path + ' ' +\n        xhr.status + ' ' + xhr.statusText + ' ' +\n        length + 'B ' +\n        (e.request.connectTime + e.request.time + e.response.time) +\n        'ms';\n      var lFunc;\n      if(options.verbose) {\n        lFunc = (xhr.status >= 400 && options.logWarningOnError) ?\n          _log.warning : _log.verbose;\n        lFunc(cat, output,\n          e, e.response.body ? '\\n' + e.response.body : '\\nNo content');\n      } else {\n        lFunc = (xhr.status >= 400 && options.logWarningOnError) ?\n          _log.warning : _log.debug;\n        lFunc(cat, output);\n      }\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n    options.error = function(e) {\n      var req = _state.request;\n      _log.error(cat, req.method + ' ' + req.path, e);\n\n      // 1. set response body to null\n      xhr.responseText = '';\n      xhr.responseXML = null;\n\n      // 2. set error flag to true (and reset status)\n      _state.errorFlag = true;\n      xhr.status = 0;\n      xhr.statusText = '';\n\n      // 3. set state to done\n      xhr.readyState = DONE;\n\n      // 4. asyc flag is always true, so dispatch onreadystatechange\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n\n    // 7. send request\n    _state.client.send(options);\n  };\n\n  /**\n   * Aborts the request.\n   */\n  xhr.abort = function() {\n    // 1. abort send\n    // 2. stop network activity\n    _state.request.abort();\n\n    // 3. set response to null\n    xhr.responseText = '';\n    xhr.responseXML = null;\n\n    // 4. set error flag to true (and reset status)\n    _state.errorFlag = true;\n    xhr.status = 0;\n    xhr.statusText = '';\n\n    // 5. clear user headers\n    _state.request = null;\n    _state.response = null;\n\n    // 6. if state is DONE or UNSENT, or if OPENED and send flag is false\n    if(xhr.readyState === DONE || xhr.readyState === UNSENT ||\n     (xhr.readyState === OPENED && !_state.sendFlag)) {\n      // 7. set ready state to unsent\n      xhr.readyState = UNSENT;\n    } else {\n      // 6.1 set state to DONE\n      xhr.readyState = DONE;\n\n      // 6.2 set send flag to false\n      _state.sendFlag = false;\n\n      // 6.3 dispatch onreadystatechange\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n\n      // 7. set state to UNSENT\n      xhr.readyState = UNSENT;\n    }\n  };\n\n  /**\n   * Gets all response headers as a string.\n   *\n   * @return the HTTP-encoded response header fields.\n   */\n  xhr.getAllResponseHeaders = function() {\n    var rval = '';\n    if(_state.response !== null) {\n      var fields = _state.response.fields;\n      $.each(fields, function(name, array) {\n        $.each(array, function(i, value) {\n          rval += name + ': ' + value + '\\r\\n';\n        });\n      });\n    }\n    return rval;\n  };\n\n  /**\n   * Gets a single header field value or, if there are multiple\n   * fields with the same name, a comma-separated list of header\n   * values.\n   *\n   * @return the header field value(s) or null.\n   */\n  xhr.getResponseHeader = function(header) {\n    var rval = null;\n    if(_state.response !== null) {\n      if(header in _state.response.fields) {\n        rval = _state.response.fields[header];\n        if(forge.util.isArray(rval)) {\n          rval = rval.join();\n        }\n      }\n    }\n    return rval;\n  };\n\n  return xhr;\n};\n\n})(jQuery);\n", "{\n  \"name\": \"node-forge\",\n  \"version\": \"0.10.1-dev\",\n  \"description\": \"JavaScript implementations of network transports, cryptography, ciphers, PKI, message digests, and various utilities.\",\n  \"homepage\": \"https://github.com/digitalbazaar/forge\",\n  \"author\": {\n    \"name\": \"Digital Bazaar, Inc.\",\n    \"email\": \"support@digitalbazaar.com\",\n    \"url\": \"http://digitalbazaar.com/\"\n  },\n  \"contributors\": [\n    \"Dave Longley <dlongley@digitalbazaar.com>\",\n    \"David I. Lehn <dlehn@digitalbazaar.com>\",\n    \"Stefan Siegl <stesie@brokenpipe.de>\",\n    \"Christoph Dorn <christoph@christophdorn.com>\"\n  ],\n  \"devDependencies\": {\n    \"browserify\": \"^16.5.2\",\n    \"commander\": \"^2.20.0\",\n    \"cross-env\": \"^5.2.1\",\n    \"eslint\": \"^7.27.0\",\n    \"eslint-config-digitalbazaar\": \"^2.8.0\",\n    \"express\": \"^4.16.2\",\n    \"karma\": \"^4.4.1\",\n    \"karma-browserify\": \"^7.0.0\",\n    \"karma-chrome-launcher\": \"^3.1.0\",\n    \"karma-edge-launcher\": \"^0.4.2\",\n    \"karma-firefox-launcher\": \"^1.3.0\",\n    \"karma-ie-launcher\": \"^1.0.0\",\n    \"karma-mocha\": \"^1.3.0\",\n    \"karma-mocha-reporter\": \"^2.2.5\",\n    \"karma-safari-launcher\": \"^1.0.0\",\n    \"karma-sauce-launcher\": \"^2.0.2\",\n    \"karma-sourcemap-loader\": \"^0.3.8\",\n    \"karma-tap-reporter\": \"0.0.6\",\n    \"karma-webpack\": \"^4.0.2\",\n    \"mocha\": \"^5.2.0\",\n    \"mocha-lcov-reporter\": \"^1.2.0\",\n    \"nodejs-websocket\": \"^1.7.1\",\n    \"nyc\": \"^15.1.0\",\n    \"opts\": \"^1.2.7\",\n    \"webpack\": \"^4.44.1\",\n    \"webpack-cli\": \"^3.3.12\",\n    \"worker-loader\": \"^2.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/digitalbazaar/forge\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/digitalbazaar/forge/issues\",\n    \"email\": \"support@digitalbazaar.com\"\n  },\n  \"license\": \"(BSD-3-Clause OR GPL-2.0)\",\n  \"main\": \"lib/index.js\",\n  \"files\": [\n    \"lib/*.js\",\n    \"flash/swf/*.swf\",\n    \"dist/*.min.js\",\n    \"dist/*.min.js.map\"\n  ],\n  \"engines\": {\n    \"node\": \">= 6.0.0\"\n  },\n  \"keywords\": [\n    \"aes\",\n    \"asn\",\n    \"asn.1\",\n    \"cbc\",\n    \"crypto\",\n    \"cryptography\",\n    \"csr\",\n    \"des\",\n    \"gcm\",\n    \"hmac\",\n    \"http\",\n    \"https\",\n    \"md5\",\n    \"network\",\n    \"pkcs\",\n    \"pki\",\n    \"prng\",\n    \"rc2\",\n    \"rsa\",\n    \"sha1\",\n    \"sha256\",\n    \"sha384\",\n    \"sha512\",\n    \"ssh\",\n    \"tls\",\n    \"x.509\",\n    \"x509\"\n  ],\n  \"scripts\": {\n    \"prepublish\": \"npm run build\",\n    \"build\": \"webpack\",\n    \"test-build\": \"webpack --config webpack-tests.config.js\",\n    \"test\": \"npm run test-node\",\n    \"test-node\": \"cross-env NODE_ENV=test mocha -t 30000 -R ${REPORTER:-spec} tests/unit/index.js\",\n    \"test-karma\": \"karma start\",\n    \"test-karma-sauce\": \"karma start karma-sauce.conf\",\n    \"test-server\": \"node tests/server.js\",\n    \"test-server-ws\": \"node tests/websockets/server-ws.js\",\n    \"test-server-webid\": \"node tests/websockets/server-webid.js\",\n    \"coverage\": \"rm -rf coverage && nyc --reporter=lcov --reporter=text-summary npm test\",\n    \"coverage-ci\": \"rm -rf coverage && nyc --reporter=lcovonly npm test\",\n    \"coverage-report\": \"nyc report\",\n    \"lint\": \"eslint *.js lib/*.js tests/*.js tests/**/*.js examples/*.js flash/*.js\"\n  },\n  \"nyc\": {\n    \"exclude\": [\n      \"tests\"\n    ]\n  },\n  \"jspm\": {\n    \"format\": \"amd\"\n  },\n  \"browser\": {\n    \"buffer\": false,\n    \"crypto\": false,\n    \"process\": false\n  }\n}\n", "// Forge WebID Test Server\nvar forge = require('../..');\nvar fs = require('fs');\nvar http = require('http');\n//var rdf = require('./rdflib');\nvar urllib = require('url');\nvar ws = require('nodejs-websocket');\n\n// remove xmlns from input\nvar normalizeNs = function(input, ns) {\n  var rval = null;\n\n  // primitive\n  if(typeof input === 'string' ||\n    typeof input === 'number' ||\n    typeof input === 'boolean') {\n    rval = input;\n  }\n  // array\n  else if(forge.util.isArray(input)) {\n    rval = [];\n    for(var i = 0; i < input.length; ++i) {\n      rval.push(normalizeNs(input[i], ns));\n    }\n  }\n  // object\n  else {\n    if('@' in input) {\n      // copy namespace map\n      var newNs = {};\n      for(var key in ns) {\n        newNs[key] = ns[key];\n      }\n      ns = newNs;\n\n      // update namespace map\n      for(var key in input['@']) {\n        if(key.indexOf('xmlns:') === 0) {\n          ns[key.substr(6)] = input['@'][key];\n        }\n      }\n    }\n\n    rval = {};\n    for(var key in input) {\n      if(key.indexOf('xmlns:') !== 0) {\n        var value = input[key];\n        var colon = key.indexOf(':');\n        if(colon !== -1) {\n          var prefix = key.substr(0, colon);\n          if(prefix in ns) {\n            key = ns[prefix] + key.substr(colon + 1);\n          }\n        }\n        rval[key] = normalizeNs(value, ns);\n      }\n    }\n  }\n\n  return rval;\n};\n\n// gets public key from WebID rdf\nvar getPublicKey = function(data, uri, callback) {\n  // FIXME: use RDF library to simplify code below\n  //var kb = new rdf.RDFParser(rdf.IndexedFormula(), uri).loadBuf(data);\n  //var CERT = rdf.Namespace('http://www.w3.org/ns/auth/cert#');\n  //var RSA  = rdf.Namespace('http://www.w3.org/ns/auth/rsa#');\n  var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n  var CERT = 'http://www.w3.org/ns/auth/cert#';\n  var RSA = 'http://www.w3.org/ns/auth/rsa#';\n  var desc = RDF + 'Description';\n  var about = RDF + 'about';\n  var type = RDF + 'type';\n  var resource = RDF + 'resource';\n  var publicKey = RSA + 'RSAPublicKey';\n  var modulus = RSA + 'modulus';\n  var exponent = RSA + 'public_exponent';\n  var identity = CERT + 'identity';\n  var hex = CERT + 'hex';\n  var decimal = CERT + 'decimal';\n\n  // gets a resource identifer from a node\n  var getResource = function(node, key) {\n    var rval = null;\n\n    // special case 'about'\n    if(key === about) {\n      if('@' in node && about in node['@']) {\n        rval = node['@'][about];\n      }\n    }\n    // any other resource\n    else if(\n      key in node &&\n      typeof node[key] === 'object' && !forge.util.isArray(node[key]) &&\n      '@' in node[key] && resource in node[key]['@']) {\n      rval = node[key]['@'][resource];\n    }\n\n    return rval;\n  };\n\n  // parse XML\n  uri = urllib.parse(uri);\n  var xml2js = require('./xml2js');\n  var parser = new xml2js.Parser();\n  parser.addListener('end', function(result) {\n    // normalize namespaces\n    result = normalizeNs(result, {});\n\n    // find grab all public keys whose identity matches hash from uri\n    var keys = [];\n    if(desc in result) {\n      // normalize RDF descriptions to array\n      if(!forge.util.isArray(result[desc])) {\n        desc = [result[desc]];\n      } else {\n        desc = result[desc];\n      }\n\n      // collect properties for all resources\n      var graph = {};\n      for(var i = 0; i < desc.length; ++i) {\n        var node = desc[i];\n        var res = {};\n        for(var key in node) {\n          var obj = getResource(node, key);\n          res[key] = (obj === null) ? node[key] : obj;\n        }\n        graph[getResource(node, about) || ''] = res;\n      }\n\n      // for every public key w/identity that matches the uri hash\n      // save the public key modulus and exponent\n      for(var r in graph) {\n        var props = graph[r];\n        if(identity in props &&\n          type in props &&\n          props[type] === publicKey &&\n          props[identity] === uri.hash &&\n          modulus in props &&\n          exponent in props &&\n          props[modulus] in graph &&\n          props[exponent] in graph &&\n          hex in graph[props[modulus]] &&\n          decimal in graph[props[exponent]]) {\n          keys.push({\n            modulus: graph[props[modulus]][hex],\n            exponent: graph[props[exponent]][decimal]\n          });\n        }\n      }\n    }\n\n    console.log('Public keys from RDF: ' + JSON.stringify(keys));\n    callback(keys);\n  });\n  parser.parseString(data);\n};\n\n// compares two public keys for equality\nvar comparePublicKeys = function(key1, key2) {\n  return key1.modulus === key2.modulus && key1.exponent === key2.exponent;\n};\n\n// gets the RDF data from a URL\nvar fetchUrl = function(url, callback, redirects) {\n  // allow 3 redirects by default\n  if(typeof(redirects) === 'undefined') {\n    redirects = 3;\n  }\n\n  console.log('Fetching URL: \\\"' + url + '\\\"');\n\n  // parse URL\n  url = forge.util.parseUrl(url);\n  var client = http.createClient(\n    url.port, url.fullHost, url.scheme === 'https');\n  var request = client.request('GET', url.path, {\n    Host: url.host,\n    Accept: 'application/rdf+xml'\n  });\n  request.addListener('response', function(response) {\n    var body = '';\n\n    // error, return empty body\n    if(response.statusCode >= 400) {\n      callback(body);\n    }\n    // follow redirect\n    else if(response.statusCode === 302) {\n      if(redirects > 0) {\n        // follow redirect\n        fetchUrl(response.headers.location, callback, --redirects);\n      } else {\n        // return empty body\n        callback(body);\n      }\n    }\n    // handle data\n    else {\n      response.setEncoding('utf8');\n      response.addListener('data', function(chunk) {\n        body += chunk;\n      });\n      response.addListener('end', function() {\n        callback(body);\n      });\n    }\n  });\n  request.end();\n};\n\n// does WebID authentication\nvar authenticateWebId = function(c, state) {\n  var auth = false;\n\n  // get client-certificate\n  var cert = c.peerCertificate;\n\n  // get public key from certificate\n  var publicKey = {\n    modulus: cert.publicKey.n.toString(16).toLowerCase(),\n    exponent: cert.publicKey.e.toString(10)\n  };\n\n  console.log(\n    'Server verifying certificate w/CN: \\\"' +\n    cert.subject.getField('CN').value + '\\\"\\n' +\n    'Public Key: ' + JSON.stringify(publicKey));\n\n  // build queue of subject alternative names to authenticate with\n  var altNames = [];\n  var ext = cert.getExtension({name: 'subjectAltName'});\n  if(ext !== null && ext.altNames) {\n    for(var i = 0; i < ext.altNames.length; ++i) {\n      var altName = ext.altNames[i];\n      if(altName.type === 6) {\n        altNames.push(altName.value);\n      }\n    }\n  }\n\n  // create authentication processor\n  var authNext = function() {\n    if(!auth) {\n      // no more alt names, auth failed\n      if(altNames.length === 0) {\n        console.log('WebID authentication FAILED.');\n        c.prepare(JSON.stringify({\n          success: false,\n          error: 'Not Authenticated'\n        }));\n        c.close();\n      }\n      // try next alt name\n      else {\n        // fetch URL\n        var url = altNames.shift();\n        fetchUrl(url, function(body) {\n          // get public key\n          getPublicKey(body, url, function(keys) {\n            // compare public keys from RDF until one matches\n            for(var i = 0; !auth && i < keys.length; ++i) {\n              auth = comparePublicKeys(keys[i], publicKey);\n            }\n            if(auth) {\n              // send authenticated notice to client\n              console.log('WebID authentication PASSED.');\n              state.authenticated = true;\n              c.prepare(JSON.stringify({\n                success: true,\n                cert: forge.pki.certificateToPem(cert),\n                webID: url,\n                rdf: forge.util.encode64(body)\n              }));\n            } else {\n              // try next alt name\n              authNext();\n            }\n          });\n        });\n      }\n    }\n  };\n\n  // do auth\n  authNext();\n};\n\n// creates credentials (private key + certificate)\nvar createCredentials = function(cn, credentials) {\n  console.log(\n    'Generating 512-bit key-pair and certificate for \\\"' + cn + '\\\".');\n  var keys = forge.pki.rsa.generateKeyPair(512);\n  console.log('key-pair created.');\n\n  var cert = forge.pki.createCertificate();\n  cert.serialNumber = '01';\n  cert.validity.notBefore = new Date();\n  cert.validity.notAfter = new Date();\n  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);\n  var attrs = [{\n    name: 'commonName',\n    value: cn\n  }, {\n    name: 'countryName',\n    value: 'US'\n  }, {\n    shortName: 'ST',\n    value: 'Virginia'\n  }, {\n    name: 'localityName',\n    value: 'Blacksburg'\n  }, {\n    name: 'organizationName',\n    value: 'Test'\n  }, {\n    shortName: 'OU',\n    value: 'Test'\n  }];\n  cert.setSubject(attrs);\n  cert.setIssuer(attrs);\n  cert.setExtensions([{\n    name: 'basicConstraints',\n    cA: true\n  }, {\n    name: 'keyUsage',\n    keyCertSign: true,\n    digitalSignature: true,\n    nonRepudiation: true,\n    keyEncipherment: true,\n    dataEncipherment: true\n  }, {\n    name: 'subjectAltName',\n    altNames: [{\n      type: 6, // URI\n      value: 'http://myuri.com/webid#me'\n    }]\n  }]);\n  // FIXME: add subjectKeyIdentifier extension\n  // FIXME: add authorityKeyIdentifier extension\n  cert.publicKey = keys.publicKey;\n\n  // self-sign certificate\n  cert.sign(keys.privateKey);\n\n  // save credentials\n  credentials.key = forge.pki.privateKeyToPem(keys.privateKey);\n  credentials.cert = forge.pki.certificateToPem(cert);\n\n  console.log('Certificate created for \\\"' + cn + '\\\": \\n' + credentials.cert);\n};\n\n// initialize credentials\nvar credentials = {\n  key: null,\n  cert: null\n};\n\n// read private key from file\nvar readPrivateKey = function(filename) {\n  credentials.key = fs.readFileSync(filename);\n  // try to parse from PEM as test\n  forge.pki.privateKeyFromPem(credentials.key);\n};\n\n// read certificate from file\nvar readCertificate = function(filename) {\n  credentials.cert = fs.readFileSync(filename);\n  // try to parse from PEM as test\n  forge.pki.certificateFromPem(credentials.cert);\n};\n\n// parse command line options\nvar opts = require('opts');\nvar options = [\n{ short       : 'v'\n, long        : 'version'\n, description : 'Show version and exit'\n, callback    : function() { console.log('v1.0'); process.exit(1); }\n},\n{ short       : 'p'\n, long        : 'port'\n, description : 'The port to listen for WebSocket connections on'\n, value       : true\n},\n{ long        : 'key'\n, description : 'The server private key file to use in PEM format'\n, value       : true\n, callback    : readPrivateKey\n},\n{ long        : 'cert'\n, description : 'The server certificate file to use in PEM format'\n, value       : true\n, callback    : readCertificate\n}\n];\nopts.parse(options, true);\n\n// create credentials for server\nif(credentials.key === null || credentials.cert === null) {\n  createCredentials('server', credentials);\n}\n\n// function to create TLS server connection\nvar createTls = function(websocket) {\n  var state = {\n    authenticated: false\n  };\n  return forge.tls.createConnection({\n    server: true,\n    caStore: [],\n    sessionCache: {},\n    // supported cipher suites in order of preference\n    cipherSuites: [\n      forge.tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA,\n      forge.tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA],\n    connected: function(c) {\n      console.log('Server connected');\n\n      // do WebID authentication\n      try {\n        authenticateWebId(c, state);\n      } catch(ex) {\n        c.close();\n      }\n    },\n    verifyClient: true,\n    verify: function(c, verified, depth, certs) {\n      // accept certs w/unknown-CA (48)\n      if(verified === 48) {\n        verified = true;\n      }\n      return verified;\n    },\n    getCertificate: function(c, hint) {\n      console.log('Server using certificate for \\\"' + hint[0] + '\\\"');\n      return credentials.cert;\n    },\n    getPrivateKey: function(c, cert) {\n      return credentials.key;\n    },\n    tlsDataReady: function(c) {\n      // send base64-encoded TLS data over websocket\n      websocket.send(forge.util.encode64(c.tlsData.getBytes()));\n    },\n    dataReady: function(c) {\n      // ignore any data until connection is authenticated\n      if(state.authenticated) {\n        console.log('Server received \\\"' + c.data.getBytes() + '\\\"');\n      }\n    },\n    closed: function(c) {\n      console.log('Server disconnected');\n      websocket.close();\n    },\n    error: function(c, error) {\n      console.log('Server error: ' + error.message);\n    }\n  });\n};\n\n// create websocket server\nlet port = opts.get('port') || 8080;\nlet wsServer = ws\n  .createServer({port: port/*, secure: true*/}, function(websocket) {\n    console.log('[ws-server] connection:', websocket.socket.address());\n\n    // create TLS server connection\n    var tls = createTls(websocket);\n\n    // close connection after 30 seconds\n    let toId = setTimeout(websocket.close, 30 * 1000);\n\n    websocket.on('text', function(data) {\n      //console.log('[ws-server] data:', data);\n      // base64-decode data and process it\n      tls.process(forge.util.decode64(data));\n    });\n\n    websocket.on('close', function() {\n      clearTimeout(toId);\n      console.log('[ws-server]: closed');\n    });\n\n    websocket.on('error', function(err) {\n      console.error('[ws-server]: error:', err);\n    });\n  });\nwsServer.listen(port, () => {\n  console.log('[ws-server] listening:', wsServer.socket.address());\n});\n"], "fixing_code": ["Forge ChangeLog\n===============\n\n## 0.11.0 - 2021-xx-xx\n\n### Removed\n- **SECURITY**, **BREAKING**: Remove `forge.debug` API. The API has the\n  potential for prototype pollution. This API was only briefly used by the\n  maintainers for internal project debug purposes and was never intended to be\n  used with untrusted user inputs. This API was not documented or advertised\n  and is being removed rather than fixed.\n- **SECURITY**, **BREAKING**: Remove `forge.util.parseUrl()` (and\n  `forge.http.parseUrl` alias) and use the [WHATWG URL\n  Standard](https://url.spec.whatwg.org/). `URL` is supported by modern browers\n  and modern Node.js. This change is needed to address URL parsing security\n  issues. If `forge.util.parseUrl()` is used directly or through `forge.xhr` or\n  `forge.http` APIs, and support is needed for environments without `URL`\n  support, then a polyfill must be used.\n- **BREAKING**: Remove `forge.task` API. This API was never used, documented,\n  or advertised by the maintainers. If anyone was using this API and wishes to\n  continue development it in other project, please let the maintainers know.\n  Due to use in the test suite, a modified version is located in\n  `tests/support/`.\n\n### Changed\n- **BREAKING**: Increase supported Node.js version to 6.13.0 for URL support.\n\n### Added\n- OIDs for `surname`, `title`, and `givenName`.\n\n### Fixed\n- **BREAKING**: OID 2.5.4.5 name fixed from `serialName` to `serialNumber`.\n  Depending on how applications used this id to name association it could cause\n  compatibility issues.\n\n### Notes\n- The URL related changes may expose bugs in some of the networking related\n  code (unrelated to the much wider used cryptography code). The automated and\n  manual test coverage for this code is weak at best. Issues or patches to\n  update the code or tests would be appriciated.\n\n## 0.10.0 - 2020-09-01\n\n### Changed\n- **BREAKING**: Node.js 4 no longer supported. The code *may* still work, and\n  non-invasive patches to keep it working will be considered. However, more\n  modern tools no longer support old Node.js versions making testing difficult.\n\n### Removed\n- **BREAKING**: Remove `util.getPath`, `util.setPath`, and `util.deletePath`.\n  `util.setPath` had a potential prototype pollution security issue when used\n  with unsafe inputs. These functions are not used by `forge` itself. They date\n  from an early time when `forge` was targeted at providing general helper\n  functions. The library direction changed to be more focused on cryptography.\n  Many other excellent libraries are more suitable for general utilities. If\n  you need a replacement for these functions, consider `get`, `set`, and `unset`\n  from [lodash](https://lodash.com/). But also consider the potential similar\n  security issues with those APIs.\n\n## 0.9.2 - 2020-09-01\n\n### Changed\n- Added `util.setPath` security note to function docs and to README.\n\n### Notes\n- **SECURITY**: The `util.setPath` function has the potential to cause\n  prototype pollution if used with unsafe input.\n  - This function is **not** used internally by `forge`.\n  - The rest of the library is unaffected by this issue.\n  - **Do not** use unsafe input with this function.\n  - Usage with known input should function as expected. (Including input\n    intentionally using potentially problematic keys.)\n  - No code changes will be made to address this issue in 0.9.x. The current\n    behavior *could* be considered a feature rather than a security issue.\n    0.10.0 will be released that removes `util.getPath` and `util.setPath`.\n    Consider `get` and `set` from [lodash](https://lodash.com/) if you need\n    replacements. But also consider the potential similar security issues with\n    those APIs.\n  - https://snyk.io/vuln/SNYK-JS-NODEFORGE-598677\n  - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-7720\n\n## 0.9.1 - 2019-09-26\n\n### Fixed\n- Ensure DES-CBC given IV is long enough for block size.\n\n## 0.9.0 - 2019-09-04\n\n### Added\n- Add ed25519.publicKeyFromAsn1 and ed25519.privateKeyFromAsn1 APIs.\n- A few OIDs used in EV certs.\n\n### Fixed\n- Improve ed25519 NativeBuffer check.\n\n## 0.8.5 - 2019-06-18\n\n### Fixed\n- Remove use of `const`.\n\n## 0.8.4 - 2019-05-22\n\n### Changed\n- Replace all instances of Node.js `new Buffer` with `Buffer.from` and `Buffer.alloc`.\n\n## 0.8.3 - 2019-05-15\n\n### Fixed\n- Use basic character set for code.\n\n## 0.8.2 - 2019-03-18\n\n### Fixed\n- Fix tag calculation when continuing an AES-GCM block.\n\n### Changed\n- Switch to eslint.\n\n## 0.8.1 - 2019-02-23\n\n### Fixed\n- Fix off-by-1 bug with kem random generation.\n\n## 0.8.0 - 2019-01-31\n\n### Fixed\n- Handle creation of certificates with `notBefore` and `notAfter` dates less\n  than Jan 1, 1950 or greater than or equal to Jan 1, 2050.\n\n### Added\n- Add OID 2.5.4.13 \"description\".\n- Add OID 2.16.840.1.113730.1.13 \"nsComment\".\n  - Also handle extension when creating a certificate.\n- `pki.verifyCertificateChain`:\n  - Add `validityCheckDate` option to allow checking the certificate validity\n    period against an arbitrary `Date` or `null` for no check at all. The\n    current date is used by default.\n- `tls.createConnection`:\n  - Add `verifyOptions` option that passes through to\n    `pki.verifyCertificateChain`. Can be used for the above `validityCheckDate`\n    option.\n\n### Changed\n- Support WebCrypto API in web workers.\n- `rsa.generateKeyPair`:\n  - Use `crypto.generateKeyPair`/`crypto.generateKeyPairSync` on Node.js if\n    available (10.12.0+) and not in pure JS mode.\n  - Use JS fallback in `rsa.generateKeyPair` if `prng` option specified since\n    this isn't supported by current native APIs.\n  - Only run key generation comparison tests if keys will be deterministic.\n- PhantomJS is deprecated, now using Headless Chrome with Karma.\n- **Note**: Using Headless Chrome vs PhantomJS may cause newer JS features to\n  slip into releases without proper support for older runtimes and browsers.\n  Please report such issues and they will be addressed.\n- `pki.verifyCertificateChain`:\n  - Signature changed to `(caStore, chain, options)`. Older `(caStore, chain,\n    verify)` signature is still supported. New style is to to pass in a\n    `verify` option.\n\n## 0.7.6 - 2018-08-14\n\n### Added\n- Test on Node.js 10.x.\n- Support for PKCS#7 detached signatures.\n\n### Changed\n- Improve webpack/browser detection.\n\n## 0.7.5 - 2018-03-30\n\n### Fixed\n- Remove use of `const`.\n\n## 0.7.4 - 2018-03-07\n\n### Fixed\n- Potential regex denial of service in form.js.\n\n### Added\n- Support for ED25519.\n- Support for baseN/base58.\n\n## 0.7.3 - 2018-03-05\n\n- Re-publish with npm 5.6.0 due to file timestamp issues.\n\n## 0.7.2 - 2018-02-27\n\n### Added\n- Support verification of SHA-384 certificates.\n- `1.2.840.10040.4.3'`/`dsa-with-sha1` OID.\n\n### Fixed\n- Support importing PKCS#7 data with no certificates. RFC 2315 sec 9.1 states\n  certificates are optional.\n- `asn1.equals` loop bug.\n- Fortuna implementation bugs.\n\n## 0.7.1 - 2017-03-27\n\n### Fixed\n\n- Fix digestLength for hashes based on SHA-512.\n\n## 0.7.0 - 2017-02-07\n\n### Fixed\n\n- Fix test looping bugs so all tests are run.\n- Improved ASN.1 parsing. Many failure cases eliminated. More sanity checks.\n  Better behavior in default mode of parsing BIT STRINGs. Better handling of\n  parsed BIT STRINGs in `toDer()`. More tests.\n- Improve X.509 BIT STRING handling by using new capture modes.\n\n### Changed\n\n- Major refactor to use CommonJS plus a browser build system.\n- Updated tests, examples, docs.\n- Updated dependencies.\n- Updated flash build system.\n- Improve OID mapping code.\n- Change test servers from Python to JavaScript.\n- Improve PhantomJS support.\n- Move Bower/bundle support to\n  [forge-dist](https://github.com/digitalbazaar/forge-dist).\n- **BREAKING**: Require minimal digest algorithm dependencies from individual\n  modules.\n- Enforce currently supported bit param values for byte buffer access. May be\n  **BREAKING** for code that depended on unspecified and/or incorrect behavior.\n- Improve `asn1.prettyPrint()` BIT STRING display.\n\n### Added\n\n- webpack bundler support via `npm run build`:\n  - Builds `.js`, `.min.js`, and basic sourcemaps.\n  - Basic build: `forge.js`.\n  - Build with extra utils and networking support: `forge.all.js`.\n  - Build WebWorker support: `prime.worker.js`.\n- Browserify support in package.json.\n- Karma browser testing.\n- `forge.options` field.\n- `forge.options.usePureJavaScript` flag.\n- `forge.util.isNodejs` flag (used to select \"native\" APIs).\n- Run PhantomJS tests in Travis-CI.\n- Add \"Donations\" section to README.\n- Add IRC to \"Contact\" section of README.\n- Add \"Security Considerations\" section to README.\n- Add pbkdf2 usePureJavaScript test.\n- Add rsa.generateKeyPair async and usePureJavaScript tests.\n- Add .editorconfig support.\n- Add `md.all.js` which includes all digest algorithms.\n- Add asn1 `equals()` and `copy()`.\n- Add asn1 `validate()` capture options for BIT STRING contents and value.\n\n### Removed\n\n- **BREAKING**: Can no longer call `forge({...})` to create new instances.\n- Remove a large amount of old cruft.\n\n### Migration from 0.6.x to 0.7.x\n\n- (all) If you used the feature to create a new forge instance with new\n  configuration options you will need to rework your code. That ability has\n  been removed due to implementation complexity. The main rare use was to set\n  the option to use pure JavaScript. That is now available as a library global\n  flag `forge.options.usePureJavaScript`.\n- (npm,bower) If you used the default main file there is little to nothing to\n  change.\n- (npm) If you accessed a sub-resource like `forge/js/pki` you should either\n  switch to just using the main `forge` and access `forge.pki` or update to\n  `forge/lib/pki`.\n- (bower) If you used a sub-resource like `forge/js/pki` you should switch to\n  just using `forge` and access `forge.pki`. The bower release bundles\n  everything in one minified file.\n- (bower) A configured workerScript like\n  `/bower_components/forge/js/prime.worker.js` will need to change to\n  `/bower_components/forge/dist/prime.worker.min.js`.\n- (all) If you used the networking support or flash socket support, you will\n  need to use a custom build and/or adjust where files are loaded from. This\n  functionality is not included in the bower distribution by default and is\n  also now in a different directory.\n- (all) The library should now directly support building custom bundles with\n  webpack, browserify, or similar.\n- (all) If building a custom bundle ensure the correct dependencies are\n  included. In particular, note there is now a `md.all.js` file to include all\n  digest algorithms. Individual files limit what they include by default to\n  allow smaller custom builds. For instance, `pbdkf2.js` has a `sha1` default\n  but does not include any algorithm files by default. This allows the\n  possibility to include only `sha256` without the overhead of `sha1` and\n  `sha512`.\n\n### Notes\n\n- This major update requires updating the version to 0.7.x. The existing\n  work-in-progress \"0.7.x\" branch will be painfully rebased on top of this new\n  0.7.x and moved forward to 0.8.x or later as needed.\n- 0.7.x is a start of simplifying forge based on common issues and what has\n  appeared to be the most common usage. Please file issues with feedback if the\n  changes are problematic for your use cases.\n\n## 0.6.x - 2016 and earlier\n\n- See Git commit log or https://github.com/digitalbazaar/forge.\n", "# Forge\n\n[![npm package](https://nodei.co/npm/node-forge.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/node-forge/)\n\n[![Build Status](https://github.com/digitalbazaar/forge/workflows/Main%20Checks/badge.svg)](https://github.com/digitalbazaar/forge/actions?query=workflow%3A%22Main+Checks%22)\n\nA native implementation of [TLS][] (and various other cryptographic tools) in\n[JavaScript][].\n\nIntroduction\n------------\n\nThe Forge software is a fully native implementation of the [TLS][] protocol\nin JavaScript, a set of cryptography utilities, and a set of tools for\ndeveloping Web Apps that utilize many network resources.\n\nPerformance\n------------\n\nForge is fast. Benchmarks against other popular JavaScript cryptography\nlibraries can be found here:\n\n* http://dominictarr.github.io/crypto-bench/\n* http://cryptojs.altervista.org/test/simulate-threading-speed_test.html\n\nDocumentation\n-------------\n\n* [Introduction](#introduction)\n* [Performance](#performance)\n* [Installation](#installation)\n* [Testing](#testing)\n* [Contributing](#contributing)\n\n### API\n\n* [Options](#options)\n\n### Transports\n\n* [TLS](#tls)\n* [HTTP](#http)\n* [SSH](#ssh)\n* [XHR](#xhr)\n* [Sockets](#socket)\n\n### Ciphers\n\n* [CIPHER](#cipher)\n* [AES](#aes)\n* [DES](#des)\n* [RC2](#rc2)\n\n### PKI\n\n* [ED25519](#ed25519)\n* [RSA](#rsa)\n* [RSA-KEM](#rsakem)\n* [X.509](#x509)\n* [PKCS#5](#pkcs5)\n* [PKCS#7](#pkcs7)\n* [PKCS#8](#pkcs8)\n* [PKCS#10](#pkcs10)\n* [PKCS#12](#pkcs12)\n* [ASN.1](#asn)\n\n### Message Digests\n\n* [SHA1](#sha1)\n* [SHA256](#sha256)\n* [SHA384](#sha384)\n* [SHA512](#sha512)\n* [MD5](#md5)\n* [HMAC](#hmac)\n\n### Utilities\n\n* [Prime](#prime)\n* [PRNG](#prng)\n* [Tasks](#task)\n* [Utilities](#util)\n* [Logging](#log)\n* [Flash Networking Support](#flash)\n\n### Other\n\n* [Security Considerations](#security-considerations)\n* [Library Background](#library-background)\n* [Contact](#contact)\n* [Donations](#donations)\n\n---------------------------------------\n\nInstallation\n------------\n\n**Note**: Please see the [Security Considerations](#security-considerations)\nsection before using packaging systems and pre-built files.\n\nForge uses a [CommonJS][] module structure with a build process for browser\nbundles. The older [0.6.x][] branch with standalone files is available but will\nnot be regularly updated.\n\n### Node.js\n\nIf you want to use forge with [Node.js][], it is available through `npm`:\n\nhttps://npmjs.org/package/node-forge\n\nInstallation:\n\n    npm install node-forge\n\nYou can then use forge as a regular module:\n\n```js\nvar forge = require('node-forge');\n```\n\nThe npm package includes pre-built `forge.min.js`, `forge.all.min.js`, and\n`prime.worker.min.js` using the [UMD][] format.\n\n### Bundle / Bower\n\nEach release is published in a separate repository as pre-built and minimized\nbasic forge bundles using the [UMD][] format.\n\nhttps://github.com/digitalbazaar/forge-dist\n\nThis bundle can be used in many environments. In particular it can be installed\nwith [Bower][]:\n\n    bower install forge\n\n### jsDelivr CDN\n\nTo use it via [jsDelivr](https://www.jsdelivr.com/package/npm/node-forge) include this in your html:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/node-forge@0.7.0/dist/forge.min.js\"></script>\n```\n\n### unpkg CDN\n\nTo use it via [unpkg](https://unpkg.com/#/) include this in your html:\n\n```html\n<script src=\"https://unpkg.com/node-forge@0.7.0/dist/forge.min.js\"></script>\n```\n\n### Development Requirements\n\nThe core JavaScript has the following requirements to build and test:\n\n* Building a browser bundle:\n  * Node.js\n  * npm\n* Testing\n  * Node.js\n  * npm\n  * Chrome, Firefox, Safari (optional)\n\nSome special networking features can optionally use a Flash component.  See the\n[Flash README](./flash/README.md) for details.\n\n### Building for a web browser\n\nTo create single file bundles for use with browsers run the following:\n\n    npm install\n    npm run build\n\nThis will create single non-minimized and minimized files that can be\nincluded in the browser:\n\n    dist/forge.js\n    dist/forge.min.js\n\nA bundle that adds some utilities and networking support is also available:\n\n    dist/forge.all.js\n    dist/forge.all.min.js\n\nInclude the file via:\n\n```html\n<script src=\"YOUR_SCRIPT_PATH/forge.js\"></script>\n```\nor\n```html\n<script src=\"YOUR_SCRIPT_PATH/forge.min.js\"></script>\n```\n\nThe above bundles will synchronously create a global 'forge' object.\n\n**Note**: These bundles will not include any WebWorker scripts (eg:\n`dist/prime.worker.js`), so these will need to be accessible from the browser\nif any WebWorkers are used.\n\n### Building a custom browser bundle\n\nThe build process uses [webpack][] and the [config](./webpack.config.js) file\ncan be modified to generate a file or files that only contain the parts of\nforge you need.\n\n[Browserify][] override support is also present in `package.json`.\n\nTesting\n-------\n\n### Prepare to run tests\n\n    npm install\n\n### Running automated tests with Node.js\n\nForge natively runs in a [Node.js][] environment:\n\n    npm test\n\n### Running automated tests with Headless Chrome\n\nAutomated testing is done via [Karma][]. By default it will run the tests with\nHeadless Chrome.\n\n    npm run test-karma\n\nIs 'mocha' reporter output too verbose? Other reporters are available. Try\n'dots', 'progress', or 'tap'.\n\n    npm run test-karma -- --reporters progress\n\nBy default [webpack][] is used. [Browserify][] can also be used.\n\n    BUNDLER=browserify npm run test-karma\n\n### Running automated tests with one or more browsers\n\nYou can also specify one or more browsers to use.\n\n    npm run test-karma -- --browsers Chrome,Firefox,Safari,ChromeHeadless\n\nThe reporter option and `BUNDLER` environment variable can also be used.\n\n### Running manual tests in a browser\n\nTesting in a browser uses [webpack][] to combine forge and all tests and then\nloading the result in a browser. A simple web server is provided that will\noutput the HTTP or HTTPS URLs to load. It also will start a simple Flash Policy\nServer. Unit tests and older legacy tests are provided. Custom ports can be\nused by running `node tests/server.js` manually.\n\nTo run the unit tests in a browser a special forge build is required:\n\n    npm run test-build\n\nTo run legacy browser based tests the main forge build is required:\n\n    npm run build\n\nThe tests are run with a custom server that prints out the URLs to use:\n\n    npm run test-server\n\n### Running other tests\n\nThere are some other random tests and benchmarks available in the tests\ndirectory.\n\n### Coverage testing\n\nTo perform coverage testing of the unit tests, run the following. The results\nwill be put in the `coverage/` directory. Note that coverage testing can slow\ndown some tests considerably.\n\n    npm install\n    npm run coverage\n\nContributing\n------------\n\nAny contributions (eg: PRs) that are accepted will be brought under the same\nlicense used by the rest of the Forge project. This license allows Forge to\nbe used under the terms of either the BSD License or the GNU General Public\nLicense (GPL) Version 2.\n\nSee: [LICENSE](https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE)\n\nIf a contribution contains 3rd party source code with its own license, it\nmay retain it, so long as that license is compatible with the Forge license.\n\nAPI\n---\n\n<a name=\"options\" />\n\n### Options\n\nIf at any time you wish to disable the use of native code, where available,\nfor particular forge features like its secure random number generator, you\nmay set the ```forge.options.usePureJavaScript``` flag to ```true```. It is\nnot recommended that you set this flag as native code is typically more\nperformant and may have stronger security properties. It may be useful to\nset this flag to test certain features that you plan to run in environments\nthat are different from your testing environment.\n\nTo disable native code when including forge in the browser:\n\n```js\n// run this *after* including the forge script\nforge.options.usePureJavaScript = true;\n```\n\nTo disable native code when using Node.js:\n\n```js\nvar forge = require('node-forge');\nforge.options.usePureJavaScript = true;\n```\n\nTransports\n----------\n\n<a name=\"tls\" />\n\n### TLS\n\nProvides a native javascript client and server-side [TLS][] implementation.\n\n__Examples__\n\n```js\n// create TLS client\nvar client = forge.tls.createConnection({\n  server: false,\n  caStore: /* Array of PEM-formatted certs or a CA store object */,\n  sessionCache: {},\n  // supported cipher suites in order of preference\n  cipherSuites: [\n    forge.tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA,\n    forge.tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA],\n  virtualHost: 'example.com',\n  verify: function(connection, verified, depth, certs) {\n    if(depth === 0) {\n      var cn = certs[0].subject.getField('CN').value;\n      if(cn !== 'example.com') {\n        verified = {\n          alert: forge.tls.Alert.Description.bad_certificate,\n          message: 'Certificate common name does not match hostname.'\n        };\n      }\n    }\n    return verified;\n  },\n  connected: function(connection) {\n    console.log('connected');\n    // send message to server\n    connection.prepare(forge.util.encodeUtf8('Hi server!'));\n    /* NOTE: experimental, start heartbeat retransmission timer\n    myHeartbeatTimer = setInterval(function() {\n      connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));\n    }, 5*60*1000);*/\n  },\n  /* provide a client-side cert if you want\n  getCertificate: function(connection, hint) {\n    return myClientCertificate;\n  },\n  /* the private key for the client-side cert if provided */\n  getPrivateKey: function(connection, cert) {\n    return myClientPrivateKey;\n  },\n  tlsDataReady: function(connection) {\n    // TLS data (encrypted) is ready to be sent to the server\n    sendToServerSomehow(connection.tlsData.getBytes());\n    // if you were communicating with the server below, you'd do:\n    // server.process(connection.tlsData.getBytes());\n  },\n  dataReady: function(connection) {\n    // clear data from the server is ready\n    console.log('the server sent: ' +\n      forge.util.decodeUtf8(connection.data.getBytes()));\n    // close connection\n    connection.close();\n  },\n  /* NOTE: experimental\n  heartbeatReceived: function(connection, payload) {\n    // restart retransmission timer, look at payload\n    clearInterval(myHeartbeatTimer);\n    myHeartbeatTimer = setInterval(function() {\n      connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));\n    }, 5*60*1000);\n    payload.getBytes();\n  },*/\n  closed: function(connection) {\n    console.log('disconnected');\n  },\n  error: function(connection, error) {\n    console.log('uh oh', error);\n  }\n});\n\n// start the handshake process\nclient.handshake();\n\n// when encrypted TLS data is received from the server, process it\nclient.process(encryptedBytesFromServer);\n\n// create TLS server\nvar server = forge.tls.createConnection({\n  server: true,\n  caStore: /* Array of PEM-formatted certs or a CA store object */,\n  sessionCache: {},\n  // supported cipher suites in order of preference\n  cipherSuites: [\n    forge.tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA,\n    forge.tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA],\n  // require a client-side certificate if you want\n  verifyClient: true,\n  verify: function(connection, verified, depth, certs) {\n    if(depth === 0) {\n      var cn = certs[0].subject.getField('CN').value;\n      if(cn !== 'the-client') {\n        verified = {\n          alert: forge.tls.Alert.Description.bad_certificate,\n          message: 'Certificate common name does not match expected client.'\n        };\n      }\n    }\n    return verified;\n  },\n  connected: function(connection) {\n    console.log('connected');\n    // send message to client\n    connection.prepare(forge.util.encodeUtf8('Hi client!'));\n    /* NOTE: experimental, start heartbeat retransmission timer\n    myHeartbeatTimer = setInterval(function() {\n      connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));\n    }, 5*60*1000);*/\n  },\n  getCertificate: function(connection, hint) {\n    return myServerCertificate;\n  },\n  getPrivateKey: function(connection, cert) {\n    return myServerPrivateKey;\n  },\n  tlsDataReady: function(connection) {\n    // TLS data (encrypted) is ready to be sent to the client\n    sendToClientSomehow(connection.tlsData.getBytes());\n    // if you were communicating with the client above you'd do:\n    // client.process(connection.tlsData.getBytes());\n  },\n  dataReady: function(connection) {\n    // clear data from the client is ready\n    console.log('the client sent: ' +\n      forge.util.decodeUtf8(connection.data.getBytes()));\n    // close connection\n    connection.close();\n  },\n  /* NOTE: experimental\n  heartbeatReceived: function(connection, payload) {\n    // restart retransmission timer, look at payload\n    clearInterval(myHeartbeatTimer);\n    myHeartbeatTimer = setInterval(function() {\n      connection.prepareHeartbeatRequest(forge.util.createBuffer('1234'));\n    }, 5*60*1000);\n    payload.getBytes();\n  },*/\n  closed: function(connection) {\n    console.log('disconnected');\n  },\n  error: function(connection, error) {\n    console.log('uh oh', error);\n  }\n});\n\n// when encrypted TLS data is received from the client, process it\nserver.process(encryptedBytesFromClient);\n```\n\nConnect to a TLS server using node's net.Socket:\n\n```js\nvar socket = new net.Socket();\n\nvar client = forge.tls.createConnection({\n  server: false,\n  verify: function(connection, verified, depth, certs) {\n    // skip verification for testing\n    console.log('[tls] server certificate verified');\n    return true;\n  },\n  connected: function(connection) {\n    console.log('[tls] connected');\n    // prepare some data to send (note that the string is interpreted as\n    // 'binary' encoded, which works for HTTP which only uses ASCII, use\n    // forge.util.encodeUtf8(str) otherwise\n    client.prepare('GET / HTTP/1.0\\r\\n\\r\\n');\n  },\n  tlsDataReady: function(connection) {\n    // encrypted data is ready to be sent to the server\n    var data = connection.tlsData.getBytes();\n    socket.write(data, 'binary'); // encoding should be 'binary'\n  },\n  dataReady: function(connection) {\n    // clear data from the server is ready\n    var data = connection.data.getBytes();\n    console.log('[tls] data received from the server: ' + data);\n  },\n  closed: function() {\n    console.log('[tls] disconnected');\n  },\n  error: function(connection, error) {\n    console.log('[tls] error', error);\n  }\n});\n\nsocket.on('connect', function() {\n  console.log('[socket] connected');\n  client.handshake();\n});\nsocket.on('data', function(data) {\n  client.process(data.toString('binary')); // encoding should be 'binary'\n});\nsocket.on('end', function() {\n  console.log('[socket] disconnected');\n});\n\n// connect to google.com\nsocket.connect(443, 'google.com');\n\n// or connect to gmail's imap server (but don't send the HTTP header above)\n//socket.connect(993, 'imap.gmail.com');\n```\n\n<a name=\"http\" />\n\n### HTTP\n\nProvides a native [JavaScript][] mini-implementation of an http client that\nuses pooled sockets.\n\n__Examples__\n\n```js\n// create an HTTP GET request\nvar request = forge.http.createRequest({method: 'GET', path: url.path});\n\n// send the request somewhere\nsendSomehow(request.toString());\n\n// receive response\nvar buffer = forge.util.createBuffer();\nvar response = forge.http.createResponse();\nvar someAsyncDataHandler = function(bytes) {\n  if(!response.bodyReceived) {\n    buffer.putBytes(bytes);\n    if(!response.headerReceived) {\n      if(response.readHeader(buffer)) {\n        console.log('HTTP response header: ' + response.toString());\n      }\n    }\n    if(response.headerReceived && !response.bodyReceived) {\n      if(response.readBody(buffer)) {\n        console.log('HTTP response body: ' + response.body);\n      }\n    }\n  }\n};\n```\n\n<a name=\"ssh\" />\n\n### SSH\n\nProvides some SSH utility functions.\n\n__Examples__\n\n```js\n// encodes (and optionally encrypts) a private RSA key as a Putty PPK file\nforge.ssh.privateKeyToPutty(privateKey, passphrase, comment);\n\n// encodes a public RSA key as an OpenSSH file\nforge.ssh.publicKeyToOpenSSH(key, comment);\n\n// encodes a private RSA key as an OpenSSH file\nforge.ssh.privateKeyToOpenSSH(privateKey, passphrase);\n\n// gets the SSH public key fingerprint in a byte buffer\nforge.ssh.getPublicKeyFingerprint(key);\n\n// gets a hex-encoded, colon-delimited SSH public key fingerprint\nforge.ssh.getPublicKeyFingerprint(key, {encoding: 'hex', delimiter: ':'});\n```\n\n<a name=\"xhr\" />\n\n### XHR\n\nProvides an XmlHttpRequest implementation using forge.http as a backend.\n\n__Examples__\n\n```js\n// TODO\n```\n\n<a name=\"socket\" />\n\n### Sockets\n\nProvides an interface to create and use raw sockets provided via Flash.\n\n__Examples__\n\n```js\n// TODO\n```\n\nCiphers\n-------\n\n<a name=\"cipher\" />\n\n### CIPHER\n\nProvides a basic API for block encryption and decryption. There is built-in\nsupport for the ciphers: [AES][], [3DES][], and [DES][], and for the modes\nof operation: [ECB][], [CBC][], [CFB][], [OFB][], [CTR][], and [GCM][].\n\nThese algorithms are currently supported:\n\n* AES-ECB\n* AES-CBC\n* AES-CFB\n* AES-OFB\n* AES-CTR\n* AES-GCM\n* 3DES-ECB\n* 3DES-CBC\n* DES-ECB\n* DES-CBC\n\nWhen using an [AES][] algorithm, the key size will determine whether\nAES-128, AES-192, or AES-256 is used (all are supported). When a [DES][]\nalgorithm is used, the key size will determine whether [3DES][] or regular\n[DES][] is used. Use a [3DES][] algorithm to enforce Triple-DES.\n\n__Examples__\n\n```js\n// generate a random key and IV\n// Note: a key size of 16 bytes will use AES-128, 24 => AES-192, 32 => AES-256\nvar key = forge.random.getBytesSync(16);\nvar iv = forge.random.getBytesSync(16);\n\n/* alternatively, generate a password-based 16-byte key\nvar salt = forge.random.getBytesSync(128);\nvar key = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);\n*/\n\n// encrypt some bytes using CBC mode\n// (other modes include: ECB, CFB, OFB, CTR, and GCM)\n// Note: CBC and ECB modes use PKCS#7 padding as default\nvar cipher = forge.cipher.createCipher('AES-CBC', key);\ncipher.start({iv: iv});\ncipher.update(forge.util.createBuffer(someBytes));\ncipher.finish();\nvar encrypted = cipher.output;\n// outputs encrypted hex\nconsole.log(encrypted.toHex());\n\n// decrypt some bytes using CBC mode\n// (other modes include: CFB, OFB, CTR, and GCM)\nvar decipher = forge.cipher.createDecipher('AES-CBC', key);\ndecipher.start({iv: iv});\ndecipher.update(encrypted);\nvar result = decipher.finish(); // check 'result' for true/false\n// outputs decrypted hex\nconsole.log(decipher.output.toHex());\n\n// decrypt bytes using CBC mode and streaming\n// Performance can suffer for large multi-MB inputs due to buffer\n// manipulations. Stream processing in chunks can offer significant\n// improvement. CPU intensive update() calls could also be performed with\n// setImmediate/setTimeout to avoid blocking the main browser UI thread (not\n// shown here). Optimal block size depends on the JavaScript VM and other\n// factors. Encryption can use a simple technique for increased performance.\nvar encryptedBytes = encrypted.bytes();\nvar decipher = forge.cipher.createDecipher('AES-CBC', key);\ndecipher.start({iv: iv});\nvar length = encryptedBytes.length;\nvar chunkSize = 1024 * 64;\nvar index = 0;\nvar decrypted = '';\ndo {\n  decrypted += decipher.output.getBytes();\n  var buf = forge.util.createBuffer(encryptedBytes.substr(index, chunkSize));\n  decipher.update(buf);\n  index += chunkSize;\n} while(index < length);\nvar result = decipher.finish();\nassert(result);\ndecrypted += decipher.output.getBytes();\nconsole.log(forge.util.bytesToHex(decrypted));\n\n// encrypt some bytes using GCM mode\nvar cipher = forge.cipher.createCipher('AES-GCM', key);\ncipher.start({\n  iv: iv, // should be a 12-byte binary-encoded string or byte buffer\n  additionalData: 'binary-encoded string', // optional\n  tagLength: 128 // optional, defaults to 128 bits\n});\ncipher.update(forge.util.createBuffer(someBytes));\ncipher.finish();\nvar encrypted = cipher.output;\nvar tag = cipher.mode.tag;\n// outputs encrypted hex\nconsole.log(encrypted.toHex());\n// outputs authentication tag\nconsole.log(tag.toHex());\n\n// decrypt some bytes using GCM mode\nvar decipher = forge.cipher.createDecipher('AES-GCM', key);\ndecipher.start({\n  iv: iv,\n  additionalData: 'binary-encoded string', // optional\n  tagLength: 128, // optional, defaults to 128 bits\n  tag: tag // authentication tag from encryption\n});\ndecipher.update(encrypted);\nvar pass = decipher.finish();\n// pass is false if there was a failure (eg: authentication tag didn't match)\nif(pass) {\n  // outputs decrypted hex\n  console.log(decipher.output.toHex());\n}\n```\n\nUsing forge in Node.js to match openssl's \"enc\" command line tool (**Note**: OpenSSL \"enc\" uses a non-standard file format with a custom key derivation function and a fixed iteration count of 1, which some consider less secure than alternatives such as [OpenPGP](https://tools.ietf.org/html/rfc4880)/[GnuPG](https://www.gnupg.org/)):\n\n```js\nvar forge = require('node-forge');\nvar fs = require('fs');\n\n// openssl enc -des3 -in input.txt -out input.enc\nfunction encrypt(password) {\n  var input = fs.readFileSync('input.txt', {encoding: 'binary'});\n\n  // 3DES key and IV sizes\n  var keySize = 24;\n  var ivSize = 8;\n\n  // get derived bytes\n  // Notes:\n  // 1. If using an alternative hash (eg: \"-md sha1\") pass\n  //   \"forge.md.sha1.create()\" as the final parameter.\n  // 2. If using \"-nosalt\", set salt to null.\n  var salt = forge.random.getBytesSync(8);\n  // var md = forge.md.sha1.create(); // \"-md sha1\"\n  var derivedBytes = forge.pbe.opensslDeriveBytes(\n    password, salt, keySize + ivSize/*, md*/);\n  var buffer = forge.util.createBuffer(derivedBytes);\n  var key = buffer.getBytes(keySize);\n  var iv = buffer.getBytes(ivSize);\n\n  var cipher = forge.cipher.createCipher('3DES-CBC', key);\n  cipher.start({iv: iv});\n  cipher.update(forge.util.createBuffer(input, 'binary'));\n  cipher.finish();\n\n  var output = forge.util.createBuffer();\n\n  // if using a salt, prepend this to the output:\n  if(salt !== null) {\n    output.putBytes('Salted__'); // (add to match openssl tool output)\n    output.putBytes(salt);\n  }\n  output.putBuffer(cipher.output);\n\n  fs.writeFileSync('input.enc', output.getBytes(), {encoding: 'binary'});\n}\n\n// openssl enc -d -des3 -in input.enc -out input.dec.txt\nfunction decrypt(password) {\n  var input = fs.readFileSync('input.enc', {encoding: 'binary'});\n\n  // parse salt from input\n  input = forge.util.createBuffer(input, 'binary');\n  // skip \"Salted__\" (if known to be present)\n  input.getBytes('Salted__'.length);\n  // read 8-byte salt\n  var salt = input.getBytes(8);\n\n  // Note: if using \"-nosalt\", skip above parsing and use\n  // var salt = null;\n\n  // 3DES key and IV sizes\n  var keySize = 24;\n  var ivSize = 8;\n\n  var derivedBytes = forge.pbe.opensslDeriveBytes(\n    password, salt, keySize + ivSize);\n  var buffer = forge.util.createBuffer(derivedBytes);\n  var key = buffer.getBytes(keySize);\n  var iv = buffer.getBytes(ivSize);\n\n  var decipher = forge.cipher.createDecipher('3DES-CBC', key);\n  decipher.start({iv: iv});\n  decipher.update(input);\n  var result = decipher.finish(); // check 'result' for true/false\n\n  fs.writeFileSync(\n    'input.dec.txt', decipher.output.getBytes(), {encoding: 'binary'});\n}\n```\n\n<a name=\"aes\" />\n\n### AES\n\nProvides [AES][] encryption and decryption in [CBC][], [CFB][], [OFB][],\n[CTR][], and [GCM][] modes. See [CIPHER](#cipher) for examples.\n\n<a name=\"des\" />\n\n### DES\n\nProvides [3DES][] and [DES][] encryption and decryption in [ECB][] and\n[CBC][] modes. See [CIPHER](#cipher) for examples.\n\n<a name=\"rc2\" />\n\n### RC2\n\n__Examples__\n\n```js\n// generate a random key and IV\nvar key = forge.random.getBytesSync(16);\nvar iv = forge.random.getBytesSync(8);\n\n// encrypt some bytes\nvar cipher = forge.rc2.createEncryptionCipher(key);\ncipher.start(iv);\ncipher.update(forge.util.createBuffer(someBytes));\ncipher.finish();\nvar encrypted = cipher.output;\n// outputs encrypted hex\nconsole.log(encrypted.toHex());\n\n// decrypt some bytes\nvar cipher = forge.rc2.createDecryptionCipher(key);\ncipher.start(iv);\ncipher.update(encrypted);\ncipher.finish();\n// outputs decrypted hex\nconsole.log(cipher.output.toHex());\n```\n\nPKI\n---\n\nProvides [X.509][] certificate support, ED25519 key generation and\nsigning/verifying, and RSA public and private key encoding, decoding,\nencryption/decryption, and signing/verifying.\n\n<a name=\"ed25519\" />\n\n### ED25519\n\nSpecial thanks to [TweetNaCl.js][] for providing the bulk of the implementation.\n\n__Examples__\n\n```js\nvar ed25519 = forge.pki.ed25519;\n\n// generate a random ED25519 keypair\nvar keypair = ed25519.generateKeyPair();\n// `keypair.publicKey` is a node.js Buffer or Uint8Array\n// `keypair.privateKey` is a node.js Buffer or Uint8Array\n\n// generate a random ED25519 keypair based on a random 32-byte seed\nvar seed = forge.random.getBytesSync(32);\nvar keypair = ed25519.generateKeyPair({seed: seed});\n\n// generate a random ED25519 keypair based on a \"password\" 32-byte seed\nvar password = 'Mai9ohgh6ahxee0jutheew0pungoozil';\nvar seed = new forge.util.ByteBuffer(password, 'utf8');\nvar keypair = ed25519.generateKeyPair({seed: seed});\n\n// sign a UTF-8 message\nvar signature = ED25519.sign({\n  message: 'test',\n  // also accepts `binary` if you want to pass a binary string\n  encoding: 'utf8',\n  // node.js Buffer, Uint8Array, forge ByteBuffer, binary string\n  privateKey: privateKey\n});\n// `signature` is a node.js Buffer or Uint8Array\n\n// sign a message passed as a buffer\nvar signature = ED25519.sign({\n  // also accepts a forge ByteBuffer or Uint8Array\n  message: Buffer.from('test', 'utf8'),\n  privateKey: privateKey\n});\n\n// sign a message digest (shorter \"message\" == better performance)\nvar md = forge.md.sha256.create();\nmd.update('test', 'utf8');\nvar signature = ED25519.sign({\n  md: md,\n  privateKey: privateKey\n});\n\n// verify a signature on a UTF-8 message\nvar verified = ED25519.verify({\n  message: 'test',\n  encoding: 'utf8',\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  signature: signature,\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  publicKey: publicKey\n});\n// `verified` is true/false\n\n// sign a message passed as a buffer\nvar verified = ED25519.verify({\n  // also accepts a forge ByteBuffer or Uint8Array\n  message: Buffer.from('test', 'utf8'),\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  signature: signature,\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  publicKey: publicKey\n});\n\n// verify a signature on a message digest\nvar md = forge.md.sha256.create();\nmd.update('test', 'utf8');\nvar verified = ED25519.verify({\n  md: md,\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  signature: signature,\n  // node.js Buffer, Uint8Array, forge ByteBuffer, or binary string\n  publicKey: publicKey\n});\n```\n\n<a name=\"rsa\" />\n\n### RSA\n\n__Examples__\n\n```js\nvar rsa = forge.pki.rsa;\n\n// generate an RSA key pair synchronously\n// *NOT RECOMMENDED*: Can be significantly slower than async and may block\n// JavaScript execution. Will use native Node.js 10.12.0+ API if possible.\nvar keypair = rsa.generateKeyPair({bits: 2048, e: 0x10001});\n\n// generate an RSA key pair asynchronously (uses web workers if available)\n// use workers: -1 to run a fast core estimator to optimize # of workers\n// *RECOMMENDED*: Can be significantly faster than sync. Will use native\n// Node.js 10.12.0+ or WebCrypto API if possible.\nrsa.generateKeyPair({bits: 2048, workers: 2}, function(err, keypair) {\n  // keypair.privateKey, keypair.publicKey\n});\n\n// generate an RSA key pair in steps that attempt to run for a specified period\n// of time on the main JS thread\nvar state = rsa.createKeyPairGenerationState(2048, 0x10001);\nvar step = function() {\n  // run for 100 ms\n  if(!rsa.stepKeyPairGenerationState(state, 100)) {\n    setTimeout(step, 1);\n  }\n  else {\n    // done, turn off progress indicator, use state.keys\n  }\n};\n// turn on progress indicator, schedule generation to run\nsetTimeout(step);\n\n// sign data with a private key and output DigestInfo DER-encoded bytes\n// (defaults to RSASSA PKCS#1 v1.5)\nvar md = forge.md.sha1.create();\nmd.update('sign this', 'utf8');\nvar signature = privateKey.sign(md);\n\n// verify data with a public key\n// (defaults to RSASSA PKCS#1 v1.5)\nvar verified = publicKey.verify(md.digest().bytes(), signature);\n\n// sign data using RSASSA-PSS where PSS uses a SHA-1 hash, a SHA-1 based\n// masking function MGF1, and a 20 byte salt\nvar md = forge.md.sha1.create();\nmd.update('sign this', 'utf8');\nvar pss = forge.pss.create({\n  md: forge.md.sha1.create(),\n  mgf: forge.mgf.mgf1.create(forge.md.sha1.create()),\n  saltLength: 20\n  // optionally pass 'prng' with a custom PRNG implementation\n  // optionalls pass 'salt' with a forge.util.ByteBuffer w/custom salt\n});\nvar signature = privateKey.sign(md, pss);\n\n// verify RSASSA-PSS signature\nvar pss = forge.pss.create({\n  md: forge.md.sha1.create(),\n  mgf: forge.mgf.mgf1.create(forge.md.sha1.create()),\n  saltLength: 20\n  // optionally pass 'prng' with a custom PRNG implementation\n});\nvar md = forge.md.sha1.create();\nmd.update('sign this', 'utf8');\npublicKey.verify(md.digest().getBytes(), signature, pss);\n\n// encrypt data with a public key (defaults to RSAES PKCS#1 v1.5)\nvar encrypted = publicKey.encrypt(bytes);\n\n// decrypt data with a private key (defaults to RSAES PKCS#1 v1.5)\nvar decrypted = privateKey.decrypt(encrypted);\n\n// encrypt data with a public key using RSAES PKCS#1 v1.5\nvar encrypted = publicKey.encrypt(bytes, 'RSAES-PKCS1-V1_5');\n\n// decrypt data with a private key using RSAES PKCS#1 v1.5\nvar decrypted = privateKey.decrypt(encrypted, 'RSAES-PKCS1-V1_5');\n\n// encrypt data with a public key using RSAES-OAEP\nvar encrypted = publicKey.encrypt(bytes, 'RSA-OAEP');\n\n// decrypt data with a private key using RSAES-OAEP\nvar decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP');\n\n// encrypt data with a public key using RSAES-OAEP/SHA-256\nvar encrypted = publicKey.encrypt(bytes, 'RSA-OAEP', {\n  md: forge.md.sha256.create()\n});\n\n// decrypt data with a private key using RSAES-OAEP/SHA-256\nvar decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP', {\n  md: forge.md.sha256.create()\n});\n\n// encrypt data with a public key using RSAES-OAEP/SHA-256/MGF1-SHA-1\n// compatible with Java's RSA/ECB/OAEPWithSHA-256AndMGF1Padding\nvar encrypted = publicKey.encrypt(bytes, 'RSA-OAEP', {\n  md: forge.md.sha256.create(),\n  mgf1: {\n    md: forge.md.sha1.create()\n  }\n});\n\n// decrypt data with a private key using RSAES-OAEP/SHA-256/MGF1-SHA-1\n// compatible with Java's RSA/ECB/OAEPWithSHA-256AndMGF1Padding\nvar decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP', {\n  md: forge.md.sha256.create(),\n  mgf1: {\n    md: forge.md.sha1.create()\n  }\n});\n\n```\n\n<a name=\"rsakem\" />\n\n### RSA-KEM\n\n__Examples__\n\n```js\n// generate an RSA key pair asynchronously (uses web workers if available)\n// use workers: -1 to run a fast core estimator to optimize # of workers\nforge.rsa.generateKeyPair({bits: 2048, workers: -1}, function(err, keypair) {\n  // keypair.privateKey, keypair.publicKey\n});\n\n// generate and encapsulate a 16-byte secret key\nvar kdf1 = new forge.kem.kdf1(forge.md.sha1.create());\nvar kem = forge.kem.rsa.create(kdf1);\nvar result = kem.encrypt(keypair.publicKey, 16);\n// result has 'encapsulation' and 'key'\n\n// encrypt some bytes\nvar iv = forge.random.getBytesSync(12);\nvar someBytes = 'hello world!';\nvar cipher = forge.cipher.createCipher('AES-GCM', result.key);\ncipher.start({iv: iv});\ncipher.update(forge.util.createBuffer(someBytes));\ncipher.finish();\nvar encrypted = cipher.output.getBytes();\nvar tag = cipher.mode.tag.getBytes();\n\n// send 'encrypted', 'iv', 'tag', and result.encapsulation to recipient\n\n// decrypt encapsulated 16-byte secret key\nvar kdf1 = new forge.kem.kdf1(forge.md.sha1.create());\nvar kem = forge.kem.rsa.create(kdf1);\nvar key = kem.decrypt(keypair.privateKey, result.encapsulation, 16);\n\n// decrypt some bytes\nvar decipher = forge.cipher.createDecipher('AES-GCM', key);\ndecipher.start({iv: iv, tag: tag});\ndecipher.update(forge.util.createBuffer(encrypted));\nvar pass = decipher.finish();\n// pass is false if there was a failure (eg: authentication tag didn't match)\nif(pass) {\n  // outputs 'hello world!'\n  console.log(decipher.output.getBytes());\n}\n\n```\n\n<a name=\"x509\" />\n\n### X.509\n\n__Examples__\n\n```js\nvar pki = forge.pki;\n\n// convert a PEM-formatted public key to a Forge public key\nvar publicKey = pki.publicKeyFromPem(pem);\n\n// convert a Forge public key to PEM-format\nvar pem = pki.publicKeyToPem(publicKey);\n\n// convert an ASN.1 SubjectPublicKeyInfo to a Forge public key\nvar publicKey = pki.publicKeyFromAsn1(subjectPublicKeyInfo);\n\n// convert a Forge public key to an ASN.1 SubjectPublicKeyInfo\nvar subjectPublicKeyInfo = pki.publicKeyToAsn1(publicKey);\n\n// gets a SHA-1 RSAPublicKey fingerprint a byte buffer\npki.getPublicKeyFingerprint(key);\n\n// gets a SHA-1 SubjectPublicKeyInfo fingerprint a byte buffer\npki.getPublicKeyFingerprint(key, {type: 'SubjectPublicKeyInfo'});\n\n// gets a hex-encoded, colon-delimited SHA-1 RSAPublicKey public key fingerprint\npki.getPublicKeyFingerprint(key, {encoding: 'hex', delimiter: ':'});\n\n// gets a hex-encoded, colon-delimited SHA-1 SubjectPublicKeyInfo public key fingerprint\npki.getPublicKeyFingerprint(key, {\n  type: 'SubjectPublicKeyInfo',\n  encoding: 'hex',\n  delimiter: ':'\n});\n\n// gets a hex-encoded, colon-delimited MD5 RSAPublicKey public key fingerprint\npki.getPublicKeyFingerprint(key, {\n  md: forge.md.md5.create(),\n  encoding: 'hex',\n  delimiter: ':'\n});\n\n// creates a CA store\nvar caStore = pki.createCaStore([/* PEM-encoded cert */, ...]);\n\n// add a certificate to the CA store\ncaStore.addCertificate(certObjectOrPemString);\n\n// gets the issuer (its certificate) for the given certificate\nvar issuerCert = caStore.getIssuer(subjectCert);\n\n// verifies a certificate chain against a CA store\npki.verifyCertificateChain(caStore, chain, customVerifyCallback);\n\n// signs a certificate using the given private key\ncert.sign(privateKey);\n\n// signs a certificate using SHA-256 instead of SHA-1\ncert.sign(privateKey, forge.md.sha256.create());\n\n// verifies an issued certificate using the certificates public key\nvar verified = issuer.verify(issued);\n\n// generate a keypair and create an X.509v3 certificate\nvar keys = pki.rsa.generateKeyPair(2048);\nvar cert = pki.createCertificate();\ncert.publicKey = keys.publicKey;\n// alternatively set public key from a csr\n//cert.publicKey = csr.publicKey;\n// NOTE: serialNumber is the hex encoded value of an ASN.1 INTEGER.\n// Conforming CAs should ensure serialNumber is:\n// - no more than 20 octets\n// - non-negative (prefix a '00' if your value starts with a '1' bit)\ncert.serialNumber = '01';\ncert.validity.notBefore = new Date();\ncert.validity.notAfter = new Date();\ncert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);\nvar attrs = [{\n  name: 'commonName',\n  value: 'example.org'\n}, {\n  name: 'countryName',\n  value: 'US'\n}, {\n  shortName: 'ST',\n  value: 'Virginia'\n}, {\n  name: 'localityName',\n  value: 'Blacksburg'\n}, {\n  name: 'organizationName',\n  value: 'Test'\n}, {\n  shortName: 'OU',\n  value: 'Test'\n}];\ncert.setSubject(attrs);\n// alternatively set subject from a csr\n//cert.setSubject(csr.subject.attributes);\ncert.setIssuer(attrs);\ncert.setExtensions([{\n  name: 'basicConstraints',\n  cA: true\n}, {\n  name: 'keyUsage',\n  keyCertSign: true,\n  digitalSignature: true,\n  nonRepudiation: true,\n  keyEncipherment: true,\n  dataEncipherment: true\n}, {\n  name: 'extKeyUsage',\n  serverAuth: true,\n  clientAuth: true,\n  codeSigning: true,\n  emailProtection: true,\n  timeStamping: true\n}, {\n  name: 'nsCertType',\n  client: true,\n  server: true,\n  email: true,\n  objsign: true,\n  sslCA: true,\n  emailCA: true,\n  objCA: true\n}, {\n  name: 'subjectAltName',\n  altNames: [{\n    type: 6, // URI\n    value: 'http://example.org/webid#me'\n  }, {\n    type: 7, // IP\n    ip: '127.0.0.1'\n  }]\n}, {\n  name: 'subjectKeyIdentifier'\n}]);\n/* alternatively set extensions from a csr\nvar extensions = csr.getAttribute({name: 'extensionRequest'}).extensions;\n// optionally add more extensions\nextensions.push.apply(extensions, [{\n  name: 'basicConstraints',\n  cA: true\n}, {\n  name: 'keyUsage',\n  keyCertSign: true,\n  digitalSignature: true,\n  nonRepudiation: true,\n  keyEncipherment: true,\n  dataEncipherment: true\n}]);\ncert.setExtensions(extensions);\n*/\n// self-sign certificate\ncert.sign(keys.privateKey);\n\n// convert a Forge certificate to PEM\nvar pem = pki.certificateToPem(cert);\n\n// convert a Forge certificate from PEM\nvar cert = pki.certificateFromPem(pem);\n\n// convert an ASN.1 X.509x3 object to a Forge certificate\nvar cert = pki.certificateFromAsn1(obj);\n\n// convert a Forge certificate to an ASN.1 X.509v3 object\nvar asn1Cert = pki.certificateToAsn1(cert);\n```\n\n<a name=\"pkcs5\" />\n\n### PKCS#5\n\nProvides the password-based key-derivation function from [PKCS#5][].\n\n__Examples__\n\n```js\n// generate a password-based 16-byte key\n// note an optional message digest can be passed as the final parameter\nvar salt = forge.random.getBytesSync(128);\nvar derivedKey = forge.pkcs5.pbkdf2('password', salt, numIterations, 16);\n\n// generate key asynchronously\n// note an optional message digest can be passed before the callback\nforge.pkcs5.pbkdf2('password', salt, numIterations, 16, function(err, derivedKey) {\n  // do something w/derivedKey\n});\n```\n\n<a name=\"pkcs7\" />\n\n### PKCS#7\n\nProvides cryptographically protected messages from [PKCS#7][].\n\n__Examples__\n\n```js\n// convert a message from PEM\nvar p7 = forge.pkcs7.messageFromPem(pem);\n// look at p7.recipients\n\n// find a recipient by the issuer of a certificate\nvar recipient = p7.findRecipient(cert);\n\n// decrypt\np7.decrypt(p7.recipients[0], privateKey);\n\n// create a p7 enveloped message\nvar p7 = forge.pkcs7.createEnvelopedData();\n\n// add a recipient\nvar cert = forge.pki.certificateFromPem(certPem);\np7.addRecipient(cert);\n\n// set content\np7.content = forge.util.createBuffer('Hello');\n\n// encrypt\np7.encrypt();\n\n// convert message to PEM\nvar pem = forge.pkcs7.messageToPem(p7);\n\n// create a degenerate PKCS#7 certificate container\n// (CRLs not currently supported, only certificates)\nvar p7 = forge.pkcs7.createSignedData();\np7.addCertificate(certOrCertPem1);\np7.addCertificate(certOrCertPem2);\nvar pem = forge.pkcs7.messageToPem(p7);\n\n// create PKCS#7 signed data with authenticatedAttributes\n// attributes include: PKCS#9 content-type, message-digest, and signing-time\nvar p7 = forge.pkcs7.createSignedData();\np7.content = forge.util.createBuffer('Some content to be signed.', 'utf8');\np7.addCertificate(certOrCertPem);\np7.addSigner({\n  key: privateKeyAssociatedWithCert,\n  certificate: certOrCertPem,\n  digestAlgorithm: forge.pki.oids.sha256,\n  authenticatedAttributes: [{\n    type: forge.pki.oids.contentType,\n    value: forge.pki.oids.data\n  }, {\n    type: forge.pki.oids.messageDigest\n    // value will be auto-populated at signing time\n  }, {\n    type: forge.pki.oids.signingTime,\n    // value can also be auto-populated at signing time\n    value: new Date()\n  }]\n});\np7.sign();\nvar pem = forge.pkcs7.messageToPem(p7);\n\n// PKCS#7 Sign in detached mode.\n// Includes the signature and certificate without the signed data.\np7.sign({detached: true});\n\n```\n\n<a name=\"pkcs8\" />\n\n### PKCS#8\n\n__Examples__\n\n```js\nvar pki = forge.pki;\n\n// convert a PEM-formatted private key to a Forge private key\nvar privateKey = pki.privateKeyFromPem(pem);\n\n// convert a Forge private key to PEM-format\nvar pem = pki.privateKeyToPem(privateKey);\n\n// convert an ASN.1 PrivateKeyInfo or RSAPrivateKey to a Forge private key\nvar privateKey = pki.privateKeyFromAsn1(rsaPrivateKey);\n\n// convert a Forge private key to an ASN.1 RSAPrivateKey\nvar rsaPrivateKey = pki.privateKeyToAsn1(privateKey);\n\n// wrap an RSAPrivateKey ASN.1 object in a PKCS#8 ASN.1 PrivateKeyInfo\nvar privateKeyInfo = pki.wrapRsaPrivateKey(rsaPrivateKey);\n\n// convert a PKCS#8 ASN.1 PrivateKeyInfo to PEM\nvar pem = pki.privateKeyInfoToPem(privateKeyInfo);\n\n// encrypts a PrivateKeyInfo using a custom password and\n// outputs an EncryptedPrivateKeyInfo\nvar encryptedPrivateKeyInfo = pki.encryptPrivateKeyInfo(\n  privateKeyInfo, 'myCustomPasswordHere', {\n    algorithm: 'aes256', // 'aes128', 'aes192', 'aes256', '3des'\n  });\n\n// decrypts an ASN.1 EncryptedPrivateKeyInfo that was encrypted\n// with a custom password\nvar privateKeyInfo = pki.decryptPrivateKeyInfo(\n  encryptedPrivateKeyInfo, 'myCustomPasswordHere');\n\n// converts an EncryptedPrivateKeyInfo to PEM\nvar pem = pki.encryptedPrivateKeyToPem(encryptedPrivateKeyInfo);\n\n// converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format\nvar encryptedPrivateKeyInfo = pki.encryptedPrivateKeyFromPem(pem);\n\n// wraps and encrypts a Forge private key and outputs it in PEM format\nvar pem = pki.encryptRsaPrivateKey(privateKey, 'password');\n\n// encrypts a Forge private key and outputs it in PEM format using OpenSSL's\n// proprietary legacy format + encapsulated PEM headers (DEK-Info)\nvar pem = pki.encryptRsaPrivateKey(privateKey, 'password', {legacy: true});\n\n// decrypts a PEM-formatted, encrypted private key\nvar privateKey = pki.decryptRsaPrivateKey(pem, 'password');\n\n// sets an RSA public key from a private key\nvar publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);\n```\n\n<a name=\"pkcs10\" />\n\n### PKCS#10\n\nProvides certification requests or certificate signing requests (CSR) from\n[PKCS#10][].\n\n__Examples__\n\n```js\n// generate a key pair\nvar keys = forge.pki.rsa.generateKeyPair(2048);\n\n// create a certification request (CSR)\nvar csr = forge.pki.createCertificationRequest();\ncsr.publicKey = keys.publicKey;\ncsr.setSubject([{\n  name: 'commonName',\n  value: 'example.org'\n}, {\n  name: 'countryName',\n  value: 'US'\n}, {\n  shortName: 'ST',\n  value: 'Virginia'\n}, {\n  name: 'localityName',\n  value: 'Blacksburg'\n}, {\n  name: 'organizationName',\n  value: 'Test'\n}, {\n  shortName: 'OU',\n  value: 'Test'\n}]);\n// set (optional) attributes\ncsr.setAttributes([{\n  name: 'challengePassword',\n  value: 'password'\n}, {\n  name: 'unstructuredName',\n  value: 'My Company, Inc.'\n}, {\n  name: 'extensionRequest',\n  extensions: [{\n    name: 'subjectAltName',\n    altNames: [{\n      // 2 is DNS type\n      type: 2,\n      value: 'test.domain.com'\n    }, {\n      type: 2,\n      value: 'other.domain.com',\n    }, {\n      type: 2,\n      value: 'www.domain.net'\n    }]\n  }]\n}]);\n\n// sign certification request\ncsr.sign(keys.privateKey);\n\n// verify certification request\nvar verified = csr.verify();\n\n// convert certification request to PEM-format\nvar pem = forge.pki.certificationRequestToPem(csr);\n\n// convert a Forge certification request from PEM-format\nvar csr = forge.pki.certificationRequestFromPem(pem);\n\n// get an attribute\ncsr.getAttribute({name: 'challengePassword'});\n\n// get extensions array\ncsr.getAttribute({name: 'extensionRequest'}).extensions;\n\n```\n\n<a name=\"pkcs12\" />\n\n### PKCS#12\n\nProvides the cryptographic archive file format from [PKCS#12][].\n\n**Note for Chrome/Firefox/iOS/similar users**: If you have trouble importing\na PKCS#12 container, try using the TripleDES algorithm. It can be passed\nto `forge.pkcs12.toPkcs12Asn1` using the `{algorithm: '3des'}` option.\n\n__Examples__\n\n```js\n// decode p12 from base64\nvar p12Der = forge.util.decode64(p12b64);\n// get p12 as ASN.1 object\nvar p12Asn1 = forge.asn1.fromDer(p12Der);\n// decrypt p12 using the password 'password'\nvar p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, 'password');\n// decrypt p12 using non-strict parsing mode (resolves some ASN.1 parse errors)\nvar p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, false, 'password');\n// decrypt p12 using literally no password (eg: Mac OS X/apple push)\nvar p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1);\n// decrypt p12 using an \"empty\" password (eg: OpenSSL with no password input)\nvar p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, '');\n// p12.safeContents is an array of safe contents, each of\n// which contains an array of safeBags\n\n// get bags by friendlyName\nvar bags = p12.getBags({friendlyName: 'test'});\n// bags are key'd by attribute type (here \"friendlyName\")\n// and the key values are an array of matching objects\nvar cert = bags.friendlyName[0];\n\n// get bags by localKeyId\nvar bags = p12.getBags({localKeyId: buffer});\n// bags are key'd by attribute type (here \"localKeyId\")\n// and the key values are an array of matching objects\nvar cert = bags.localKeyId[0];\n\n// get bags by localKeyId (input in hex)\nvar bags = p12.getBags({localKeyIdHex: '7b59377ff142d0be4565e9ac3d396c01401cd879'});\n// bags are key'd by attribute type (here \"localKeyId\", *not* \"localKeyIdHex\")\n// and the key values are an array of matching objects\nvar cert = bags.localKeyId[0];\n\n// get bags by type\nvar bags = p12.getBags({bagType: forge.pki.oids.certBag});\n// bags are key'd by bagType and each bagType key's value\n// is an array of matches (in this case, certificate objects)\nvar cert = bags[forge.pki.oids.certBag][0];\n\n// get bags by friendlyName and filter on bag type\nvar bags = p12.getBags({\n  friendlyName: 'test',\n  bagType: forge.pki.oids.certBag\n});\n\n// get key bags\nvar bags = p12.getBags({bagType: forge.pki.oids.keyBag});\n// get key\nvar bag = bags[forge.pki.oids.keyBag][0];\nvar key = bag.key;\n// if the key is in a format unrecognized by forge then\n// bag.key will be `null`, use bag.asn1 to get the ASN.1\n// representation of the key\nif(bag.key === null) {\n  var keyAsn1 = bag.asn1;\n  // can now convert back to DER/PEM/etc for export\n}\n\n// generate a p12 using AES (default)\nvar p12Asn1 = forge.pkcs12.toPkcs12Asn1(\n  privateKey, certificateChain, 'password');\n\n// generate a p12 that can be imported by Chrome/Firefox/iOS\n// (requires the use of Triple DES instead of AES)\nvar p12Asn1 = forge.pkcs12.toPkcs12Asn1(\n  privateKey, certificateChain, 'password',\n  {algorithm: '3des'});\n\n// base64-encode p12\nvar p12Der = forge.asn1.toDer(p12Asn1).getBytes();\nvar p12b64 = forge.util.encode64(p12Der);\n\n// create download link for p12\nvar a = document.createElement('a');\na.download = 'example.p12';\na.setAttribute('href', 'data:application/x-pkcs12;base64,' + p12b64);\na.appendChild(document.createTextNode('Download'));\n```\n\n<a name=\"asn\" />\n\n### ASN.1\n\nProvides [ASN.1][] DER encoding and decoding.\n\n__Examples__\n\n```js\nvar asn1 = forge.asn1;\n\n// create a SubjectPublicKeyInfo\nvar subjectPublicKeyInfo =\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // AlgorithmIdentifier\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(pki.oids['rsaEncryption']).getBytes()),\n      // parameters (null)\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n    ]),\n    // subjectPublicKey\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\n      // RSAPublicKey\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        // modulus (n)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n          _bnToBytes(key.n)),\n        // publicExponent (e)\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n          _bnToBytes(key.e))\n      ])\n    ])\n  ]);\n\n// serialize an ASN.1 object to DER format\nvar derBuffer = asn1.toDer(subjectPublicKeyInfo);\n\n// deserialize to an ASN.1 object from a byte buffer filled with DER data\nvar object = asn1.fromDer(derBuffer);\n\n// convert an OID dot-separated string to a byte buffer\nvar derOidBuffer = asn1.oidToDer('1.2.840.113549.1.1.5');\n\n// convert a byte buffer with a DER-encoded OID to a dot-separated string\nconsole.log(asn1.derToOid(derOidBuffer));\n// output: 1.2.840.113549.1.1.5\n\n// validates that an ASN.1 object matches a particular ASN.1 structure and\n// captures data of interest from that structure for easy access\nvar publicKeyValidator = {\n  name: 'SubjectPublicKeyInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  captureAsn1: 'subjectPublicKeyInfo',\n  value: [{\n    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'AlgorithmIdentifier.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'publicKeyOid'\n    }]\n  }, {\n    // subjectPublicKey\n    name: 'SubjectPublicKeyInfo.subjectPublicKey',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.BITSTRING,\n    constructed: false,\n    value: [{\n      // RSAPublicKey\n      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      optional: true,\n      captureAsn1: 'rsaPublicKey'\n    }]\n  }]\n};\n\nvar capture = {};\nvar errors = [];\nif(!asn1.validate(\n  publicKeyValidator, subjectPublicKeyInfo, validator, capture, errors)) {\n  throw 'ASN.1 object is not a SubjectPublicKeyInfo.';\n}\n// capture.subjectPublicKeyInfo contains the full ASN.1 object\n// capture.rsaPublicKey contains the full ASN.1 object for the RSA public key\n// capture.publicKeyOid only contains the value for the OID\nvar oid = asn1.derToOid(capture.publicKeyOid);\nif(oid !== pki.oids['rsaEncryption']) {\n  throw 'Unsupported OID.';\n}\n\n// pretty print an ASN.1 object to a string for debugging purposes\nasn1.prettyPrint(object);\n```\n\nMessage Digests\n----------------\n\n<a name=\"sha1\" />\n\n### SHA1\n\nProvides [SHA-1][] message digests.\n\n__Examples__\n\n```js\nvar md = forge.md.sha1.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: 2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\n```\n\n<a name=\"sha256\" />\n\n### SHA256\n\nProvides [SHA-256][] message digests.\n\n__Examples__\n\n```js\nvar md = forge.md.sha256.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\n```\n\n<a name=\"sha384\" />\n\n### SHA384\n\nProvides [SHA-384][] message digests.\n\n__Examples__\n\n```js\nvar md = forge.md.sha384.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: ca737f1014a48f4c0b6dd43cb177b0afd9e5169367544c494011e3317dbf9a509cb1e5dc1e85a941bbee3d7f2afbc9b1\n```\n\n<a name=\"sha512\" />\n\n### SHA512\n\nProvides [SHA-512][] message digests.\n\n__Examples__\n\n```js\n// SHA-512\nvar md = forge.md.sha512.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: 07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb642e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6\n\n// SHA-512/224\nvar md = forge.md.sha512.sha224.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: 944cd2847fb54558d4775db0485a50003111c8e5daa63fe722c6aa37\n\n// SHA-512/256\nvar md = forge.md.sha512.sha256.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: dd9d67b371519c339ed8dbd25af90e976a1eeefd4ad3d889005e532fc5bef04d\n```\n\n<a name=\"md5\" />\n\n### MD5\n\nProvides [MD5][] message digests.\n\n__Examples__\n\n```js\nvar md = forge.md.md5.create();\nmd.update('The quick brown fox jumps over the lazy dog');\nconsole.log(md.digest().toHex());\n// output: 9e107d9d372bb6826bd81d3542a419d6\n```\n\n<a name=\"hmac\" />\n\n### HMAC\n\nProvides [HMAC][] w/any supported message digest algorithm.\n\n__Examples__\n\n```js\nvar hmac = forge.hmac.create();\nhmac.start('sha1', 'Jefe');\nhmac.update('what do ya want for nothing?');\nconsole.log(hmac.digest().toHex());\n// output: effcdf6ae5eb2fa2d27416d5f184df9c259a7c79\n```\n\nUtilities\n---------\n\n<a name=\"prime\" />\n\n### Prime\n\nProvides an API for generating large, random, probable primes.\n\n__Examples__\n\n```js\n// generate a random prime on the main JS thread\nvar bits = 1024;\nforge.prime.generateProbablePrime(bits, function(err, num) {\n  console.log('random prime', num.toString(16));\n});\n\n// generate a random prime using Web Workers (if available, otherwise\n// falls back to the main thread)\nvar bits = 1024;\nvar options = {\n  algorithm: {\n    name: 'PRIMEINC',\n    workers: -1 // auto-optimize # of workers\n  }\n};\nforge.prime.generateProbablePrime(bits, options, function(err, num) {\n  console.log('random prime', num.toString(16));\n});\n```\n\n<a name=\"prng\" />\n\n### PRNG\n\nProvides a [Fortuna][]-based cryptographically-secure pseudo-random number\ngenerator, to be used with a cryptographic function backend, e.g. [AES][]. An\nimplementation using [AES][] as a backend is provided. An API for collecting\nentropy is given, though if window.crypto.getRandomValues is available, it will\nbe used automatically.\n\n__Examples__\n\n```js\n// get some random bytes synchronously\nvar bytes = forge.random.getBytesSync(32);\nconsole.log(forge.util.bytesToHex(bytes));\n\n// get some random bytes asynchronously\nforge.random.getBytes(32, function(err, bytes) {\n  console.log(forge.util.bytesToHex(bytes));\n});\n\n// collect some entropy if you'd like\nforge.random.collect(someRandomBytes);\njQuery().mousemove(function(e) {\n  forge.random.collectInt(e.clientX, 16);\n  forge.random.collectInt(e.clientY, 16);\n});\n\n// specify a seed file for use with the synchronous API if you'd like\nforge.random.seedFileSync = function(needed) {\n  // get 'needed' number of random bytes from somewhere\n  return fetchedRandomBytes;\n};\n\n// specify a seed file for use with the asynchronous API if you'd like\nforge.random.seedFile = function(needed, callback) {\n  // get the 'needed' number of random bytes from somewhere\n  callback(null, fetchedRandomBytes);\n});\n\n// register the main thread to send entropy or a Web Worker to receive\n// entropy on demand from the main thread\nforge.random.registerWorker(self);\n\n// generate a new instance of a PRNG with no collected entropy\nvar myPrng = forge.random.createInstance();\n```\n\n<a name=\"task\" />\n\n### Tasks\n\nProvides queuing and synchronizing tasks in a web application.\n\n__Examples__\n\n```js\n// TODO\n```\n\n<a name=\"util\" />\n\n### Utilities\n\nProvides utility functions, including byte buffer support, base64,\nbytes to/from hex, zlib inflate/deflate, etc.\n\n__Examples__\n\n```js\n// encode/decode base64\nvar encoded = forge.util.encode64(str);\nvar str = forge.util.decode64(encoded);\n\n// encode/decode UTF-8\nvar encoded = forge.util.encodeUtf8(str);\nvar str = forge.util.decodeUtf8(encoded);\n\n// bytes to/from hex\nvar bytes = forge.util.hexToBytes(hex);\nvar hex = forge.util.bytesToHex(bytes);\n\n// create an empty byte buffer\nvar buffer = forge.util.createBuffer();\n// create a byte buffer from raw binary bytes\nvar buffer = forge.util.createBuffer(input, 'raw');\n// create a byte buffer from utf8 bytes\nvar buffer = forge.util.createBuffer(input, 'utf8');\n\n// get the length of the buffer in bytes\nbuffer.length();\n// put bytes into the buffer\nbuffer.putBytes(bytes);\n// put a 32-bit integer into the buffer\nbuffer.putInt32(10);\n// buffer to hex\nbuffer.toHex();\n// get a copy of the bytes in the buffer\nbytes.bytes(/* count */);\n// empty this buffer and get its contents\nbytes.getBytes(/* count */);\n\n// convert a forge buffer into a Node.js Buffer\n// make sure you specify the encoding as 'binary'\nvar forgeBuffer = forge.util.createBuffer();\nvar nodeBuffer = Buffer.from(forgeBuffer.getBytes(), 'binary');\n\n// convert a Node.js Buffer into a forge buffer\n// make sure you specify the encoding as 'binary'\nvar nodeBuffer = Buffer.from('CAFE', 'hex');\nvar forgeBuffer = forge.util.createBuffer(nodeBuffer.toString('binary'));\n```\n\n<a name=\"log\" />\n\n### Logging\n\nProvides logging to a javascript console using various categories and\nlevels of verbosity.\n\n__Examples__\n\n```js\n// TODO\n```\n\n<a name=\"flash\" />\n\n### Flash Networking Support\n\nThe [flash README](./flash/README.md) provides details on rebuilding the\noptional Flash component used for networking. It also provides details on\nPolicy Server support.\n\nSecurity Considerations\n-----------------------\n\nWhen using this code please keep the following in mind:\n\n- Cryptography is hard. Please review and test this code before depending on it\n  for critical functionality.\n- The nature of JavaScript is that execution of this code depends on trusting a\n  very large set of JavaScript tools and systems. Consider runtime variations,\n  runtime characteristics, runtime optimization, code optimization, code\n  minimization, code obfuscation, bundling tools, possible bugs, the Forge code\n  itself, and so on.\n- If using pre-built bundles from [Bower][] or similar be aware someone else\n  ran the tools to create those files.\n- Use a secure transport channel such as [TLS][] to load scripts and consider\n  using additional security mechanisms such as [Subresource Integrity][] script\n  attributes.\n- Use \"native\" functionality where possible. This can be critical when dealing\n  with performance and random number generation. Note that the JavaScript\n  random number algorithms should perform well if given suitable entropy.\n- Understand possible attacks against cryptographic systems. For instance side\n  channel and timing attacks may be possible due to the difficulty in\n  implementing constant time algorithms in pure JavaScript.\n- Certain features in this library are less susceptible to attacks depending on\n  usage. This primarily includes features that deal with data format\n  manipulation or those that are not involved in communication.\n\nLibrary Background\n------------------\n\n* https://digitalbazaar.com/2010/07/20/javascript-tls-1/\n* https://digitalbazaar.com/2010/07/20/javascript-tls-2/\n\nContact\n-------\n\n* Code: https://github.com/digitalbazaar/forge\n* Bugs: https://github.com/digitalbazaar/forge/issues\n* Email: support@digitalbazaar.com\n* IRC: [#forgejs][] on [freenode][]\n\nDonations\n---------\n\nFinancial support is welcome and helps contribute to futher development:\n\n* For [PayPal][] please send to paypal@digitalbazaar.com.\n* Something else? Please contact support@digitalbazaar.com.\n\n[#forgejs]: https://webchat.freenode.net/?channels=#forgejs\n[0.6.x]: https://github.com/digitalbazaar/forge/tree/0.6.x\n[3DES]: https://en.wikipedia.org/wiki/Triple_DES\n[AES]: https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n[ASN.1]: https://en.wikipedia.org/wiki/ASN.1\n[Bower]: https://bower.io/\n[Browserify]: http://browserify.org/\n[CBC]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[CFB]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[CTR]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[CommonJS]: https://en.wikipedia.org/wiki/CommonJS\n[DES]: https://en.wikipedia.org/wiki/Data_Encryption_Standard\n[ECB]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[Fortuna]: https://en.wikipedia.org/wiki/Fortuna_(PRNG)\n[GCM]: https://en.wikipedia.org/wiki/GCM_mode\n[HMAC]: https://en.wikipedia.org/wiki/HMAC\n[JavaScript]: https://en.wikipedia.org/wiki/JavaScript\n[Karma]: https://karma-runner.github.io/\n[MD5]: https://en.wikipedia.org/wiki/MD5\n[Node.js]: https://nodejs.org/\n[OFB]: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n[PKCS#10]: https://en.wikipedia.org/wiki/Certificate_signing_request\n[PKCS#12]: https://en.wikipedia.org/wiki/PKCS_%E2%99%AF12\n[PKCS#5]: https://en.wikipedia.org/wiki/PKCS\n[PKCS#7]: https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax\n[PayPal]: https://www.paypal.com/\n[RC2]: https://en.wikipedia.org/wiki/RC2\n[SHA-1]: https://en.wikipedia.org/wiki/SHA-1\n[SHA-256]: https://en.wikipedia.org/wiki/SHA-256\n[SHA-384]: https://en.wikipedia.org/wiki/SHA-384\n[SHA-512]: https://en.wikipedia.org/wiki/SHA-512\n[Subresource Integrity]: https://www.w3.org/TR/SRI/\n[TLS]: https://en.wikipedia.org/wiki/Transport_Layer_Security\n[UMD]: https://github.com/umdjs/umd\n[X.509]: https://en.wikipedia.org/wiki/X.509\n[freenode]: https://freenode.net/\n[unpkg]: https://unpkg.com/\n[webpack]: https://webpack.github.io/\n[TweetNaCl.js]: https://github.com/dchest/tweetnacl-js\n", "/**\n * HTTP client-side implementation that uses forge.net sockets.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\nrequire('./tls');\nrequire('./util');\n\n// define http namespace\nvar http = module.exports = forge.http = forge.http || {};\n\n// logging category\nvar cat = 'forge.http';\n\n// normalizes an http header field name\nvar _normalize = function(name) {\n  return name.toLowerCase().replace(/(^.)|(-.)/g,\n    function(a) {return a.toUpperCase();});\n};\n\n/**\n * Gets the local storage ID for the given client.\n *\n * @param client the client to get the local storage ID for.\n *\n * @return the local storage ID to use.\n */\nvar _getStorageId = function(client) {\n  // TODO: include browser in ID to avoid sharing cookies between\n  // browsers (if this is undesirable)\n  // navigator.userAgent\n  return 'forge.http.' +\n    client.url.protocol.slice(0, -1) + '.' +\n    client.url.hostname + '.' +\n    client.url.port;\n};\n\n/**\n * Loads persistent cookies from disk for the given client.\n *\n * @param client the client.\n */\nvar _loadCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      var cookies = forge.util.getItem(\n        client.socketPool.flashApi,\n        _getStorageId(client), 'cookies');\n      client.cookies = cookies || {};\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n\n/**\n * Saves persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\nvar _saveCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      forge.util.setItem(\n        client.socketPool.flashApi,\n        _getStorageId(client), 'cookies', client.cookies);\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n\n  // FIXME: remove me\n  _loadCookies(client);\n};\n\n/**\n * Clears persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\nvar _clearCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      // only thing stored is 'cookies', so clear whole storage\n      forge.util.clearItems(\n        client.socketPool.flashApi,\n        _getStorageId(client));\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n\n/**\n * Connects and sends a request.\n *\n * @param client the http client.\n * @param socket the socket to use.\n */\nvar _doRequest = function(client, socket) {\n  if(socket.isConnected()) {\n    // already connected\n    socket.options.request.connectTime = +new Date();\n    socket.connected({\n      type: 'connect',\n      id: socket.id\n    });\n  } else {\n    // connect\n    socket.options.request.connectTime = +new Date();\n    socket.connect({\n      host: client.url.hostname,\n      port: client.url.port,\n      policyPort: client.policyPort,\n      policyUrl: client.policyUrl\n    });\n  }\n};\n\n/**\n * Handles the next request or marks a socket as idle.\n *\n * @param client the http client.\n * @param socket the socket.\n */\nvar _handleNextRequest = function(client, socket) {\n  // clear buffer\n  socket.buffer.clear();\n\n  // get pending request\n  var pending = null;\n  while(pending === null && client.requests.length > 0) {\n    pending = client.requests.shift();\n    if(pending.request.aborted) {\n      pending = null;\n    }\n  }\n\n  // mark socket idle if no pending requests\n  if(pending === null) {\n    if(socket.options !== null) {\n      socket.options = null;\n    }\n    client.idle.push(socket);\n  } else {\n    // handle pending request, allow 1 retry\n    socket.retries = 1;\n    socket.options = pending;\n    _doRequest(client, socket);\n  }\n};\n\n/**\n * Sets up a socket for use with an http client.\n *\n * @param client the parent http client.\n * @param socket the socket to set up.\n * @param tlsOptions if the socket must use TLS, the TLS options.\n */\nvar _initSocket = function(client, socket, tlsOptions) {\n  // no socket options yet\n  socket.options = null;\n\n  // set up handlers\n  socket.connected = function(e) {\n    // socket primed by caching TLS session, handle next request\n    if(socket.options === null) {\n      _handleNextRequest(client, socket);\n    } else {\n      // socket in use\n      var request = socket.options.request;\n      request.connectTime = +new Date() - request.connectTime;\n      e.socket = socket;\n      socket.options.connected(e);\n      if(request.aborted) {\n        socket.close();\n      } else {\n        var out = request.toString();\n        if(request.body) {\n          out += request.body;\n        }\n        request.time = +new Date();\n        socket.send(out);\n        request.time = +new Date() - request.time;\n        socket.options.response.time = +new Date();\n        socket.sending = true;\n      }\n    }\n  };\n  socket.closed = function(e) {\n    if(socket.sending) {\n      socket.sending = false;\n      if(socket.retries > 0) {\n        --socket.retries;\n        _doRequest(client, socket);\n      } else {\n        // error, closed during send\n        socket.error({\n          id: socket.id,\n          type: 'ioError',\n          message: 'Connection closed during send. Broken pipe.',\n          bytesAvailable: 0\n        });\n      }\n    } else {\n      // handle unspecified content-length transfer\n      var response = socket.options.response;\n      if(response.readBodyUntilClose) {\n        response.time = +new Date() - response.time;\n        response.bodyReceived = true;\n        socket.options.bodyReady({\n          request: socket.options.request,\n          response: response,\n          socket: socket\n        });\n      }\n      socket.options.closed(e);\n      _handleNextRequest(client, socket);\n    }\n  };\n  socket.data = function(e) {\n    socket.sending = false;\n    var request = socket.options.request;\n    if(request.aborted) {\n      socket.close();\n    } else {\n      // receive all bytes available\n      var response = socket.options.response;\n      var bytes = socket.receive(e.bytesAvailable);\n      if(bytes !== null) {\n        // receive header and then body\n        socket.buffer.putBytes(bytes);\n        if(!response.headerReceived) {\n          response.readHeader(socket.buffer);\n          if(response.headerReceived) {\n            socket.options.headerReady({\n              request: socket.options.request,\n              response: response,\n              socket: socket\n            });\n          }\n        }\n        if(response.headerReceived && !response.bodyReceived) {\n          response.readBody(socket.buffer);\n        }\n        if(response.bodyReceived) {\n          socket.options.bodyReady({\n            request: socket.options.request,\n            response: response,\n            socket: socket\n          });\n          // close connection if requested or by default on http/1.0\n          var value = response.getField('Connection') || '';\n          if(value.indexOf('close') != -1 ||\n            (response.version === 'HTTP/1.0' &&\n            response.getField('Keep-Alive') === null)) {\n            socket.close();\n          } else {\n            _handleNextRequest(client, socket);\n          }\n        }\n      }\n    }\n  };\n  socket.error = function(e) {\n    // do error callback, include request\n    socket.options.error({\n      type: e.type,\n      message: e.message,\n      request: socket.options.request,\n      response: socket.options.response,\n      socket: socket\n    });\n    socket.close();\n  };\n\n  // wrap socket for TLS\n  if(tlsOptions) {\n    socket = forge.tls.wrapSocket({\n      sessionId: null,\n      sessionCache: {},\n      caStore: tlsOptions.caStore,\n      cipherSuites: tlsOptions.cipherSuites,\n      socket: socket,\n      virtualHost: tlsOptions.virtualHost,\n      verify: tlsOptions.verify,\n      getCertificate: tlsOptions.getCertificate,\n      getPrivateKey: tlsOptions.getPrivateKey,\n      getSignature: tlsOptions.getSignature,\n      deflate: tlsOptions.deflate || null,\n      inflate: tlsOptions.inflate || null\n    });\n\n    socket.options = null;\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    if(tlsOptions.prime) {\n      // prime socket by connecting and caching TLS session, will do\n      // next request from there\n      socket.connect({\n        host: client.url.hostname,\n        port: client.url.port,\n        policyPort: client.policyPort,\n        policyUrl: client.policyUrl\n      });\n    } else {\n      // do not prime socket, just add as idle\n      client.idle.push(socket);\n    }\n  } else {\n    // no need to prime non-TLS sockets\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    client.idle.push(socket);\n  }\n};\n\n/**\n * Checks to see if the given cookie has expired. If the cookie's max-age\n * plus its created time is less than the time now, it has expired, unless\n * its max-age is set to -1 which indicates it will never expire.\n *\n * @param cookie the cookie to check.\n *\n * @return true if it has expired, false if not.\n */\nvar _hasCookieExpired = function(cookie) {\n  var rval = false;\n\n  if(cookie.maxAge !== -1) {\n    var now = _getUtcTime(new Date());\n    var expires = cookie.created + cookie.maxAge;\n    if(expires <= now) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Adds cookies in the given client to the given request.\n *\n * @param client the client.\n * @param request the request.\n */\nvar _writeCookies = function(client, request) {\n  var expired = [];\n  var url = client.url;\n  var cookies = client.cookies;\n  for(var name in cookies) {\n    // get cookie paths\n    var paths = cookies[name];\n    for(var p in paths) {\n      var cookie = paths[p];\n      if(_hasCookieExpired(cookie)) {\n        // store for clean up\n        expired.push(cookie);\n      } else if(request.path.indexOf(cookie.path) === 0) {\n        // path or path's ancestor must match cookie.path\n        request.addCookie(cookie);\n      }\n    }\n  }\n\n  // clean up expired cookies\n  for(var i = 0; i < expired.length; ++i) {\n    var cookie = expired[i];\n    client.removeCookie(cookie.name, cookie.path);\n  }\n};\n\n/**\n * Gets cookies from the given response and adds the to the given client.\n *\n * @param client the client.\n * @param response the response.\n */\nvar _readCookies = function(client, response) {\n  var cookies = response.getCookies();\n  for(var i = 0; i < cookies.length; ++i) {\n    try {\n      client.setCookie(cookies[i]);\n    } catch(ex) {\n      // ignore failure to add other-domain, etc. cookies\n    }\n  }\n};\n\n/**\n * Creates an http client that uses forge.net sockets as a backend and\n * forge.tls for security.\n *\n * @param options:\n *   url: the url to connect to (scheme://host:port).\n *   socketPool: the flash socket pool to use.\n *   policyPort: the flash policy port to use (if other than the\n *     socket pool default), use 0 for flash default.\n *   policyUrl: the flash policy file URL to use (if provided will\n *     be used instead of a policy port).\n *   connections: number of connections to use to handle requests.\n *   caCerts: an array of certificates to trust for TLS, certs may\n *     be PEM-formatted or cert objects produced via forge.pki.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   virtualHost: the virtual server name to use in a TLS SNI\n *     extension, if not provided the url host will be used.\n *   verify: a custom TLS certificate verify callback to use.\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side\n *     private key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side\n *     signature (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local\n *     storage, false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on\n *     their creation so that they will cache TLS sessions for reuse.\n *\n * @return the client.\n */\nhttp.createClient = function(options) {\n  // create CA store to share with all TLS connections\n  var caStore = null;\n  if(options.caCerts) {\n    caStore = forge.pki.createCaStore(options.caCerts);\n  }\n\n  // get scheme, host, and port from url\n  options.url = (options.url ||\n    window.location.protocol + '//' + window.location.host);\n  var url;\n  try {\n    url = new URL(options.url);\n  } catch(e) {\n    var error = new Error('Invalid url.');\n    error.details = {url: options.url};\n    throw error;\n  }\n\n  // default to 1 connection\n  options.connections = options.connections || 1;\n\n  // create client\n  var sp = options.socketPool;\n  var client = {\n    // url\n    url: url,\n    // socket pool\n    socketPool: sp,\n    // the policy port to use\n    policyPort: options.policyPort,\n    // policy url to use\n    policyUrl: options.policyUrl,\n    // queue of requests to service\n    requests: [],\n    // all sockets\n    sockets: [],\n    // idle sockets\n    idle: [],\n    // whether or not the connections are secure\n    secure: (url.protocol === 'https:'),\n    // cookie jar (key'd off of name and then path, there is only 1 domain\n    // and one setting for secure per client so name+path is unique)\n    cookies: {},\n    // default to flash storage of cookies\n    persistCookies: (typeof(options.persistCookies) === 'undefined') ?\n      true : options.persistCookies\n  };\n\n  // load cookies from disk\n  _loadCookies(client);\n\n  /**\n   * A default certificate verify function that checks a certificate common\n   * name against the client's URL host.\n   *\n   * @param c the TLS connection.\n   * @param verified true if cert is verified, otherwise alert number.\n   * @param depth the chain depth.\n   * @param certs the cert chain.\n   *\n   * @return true if verified and the common name matches the host, error\n   *         otherwise.\n   */\n  var _defaultCertificateVerify = function(c, verified, depth, certs) {\n    if(depth === 0 && verified === true) {\n      // compare common name to url host\n      var cn = certs[depth].subject.getField('CN');\n      if(cn === null || client.url.hostname !== cn.value) {\n        verified = {\n          message: 'Certificate common name does not match url host.'\n        };\n      }\n    }\n    return verified;\n  };\n\n  // determine if TLS is used\n  var tlsOptions = null;\n  if(client.secure) {\n    tlsOptions = {\n      caStore: caStore,\n      cipherSuites: options.cipherSuites || null,\n      virtualHost: options.virtualHost || url.hostname,\n      verify: options.verify || _defaultCertificateVerify,\n      getCertificate: options.getCertificate || null,\n      getPrivateKey: options.getPrivateKey || null,\n      getSignature: options.getSignature || null,\n      prime: options.primeTlsSockets || false\n    };\n\n    // if socket pool uses a flash api, then add deflate support to TLS\n    if(sp.flashApi !== null) {\n      tlsOptions.deflate = function(bytes) {\n        // strip 2 byte zlib header and 4 byte trailer\n        return forge.util.deflate(sp.flashApi, bytes, true);\n      };\n      tlsOptions.inflate = function(bytes) {\n        return forge.util.inflate(sp.flashApi, bytes, true);\n      };\n    }\n  }\n\n  // create and initialize sockets\n  for(var i = 0; i < options.connections; ++i) {\n    _initSocket(client, sp.createSocket(), tlsOptions);\n  }\n\n  /**\n   * Sends a request. A method 'abort' will be set on the request that\n   * can be called to attempt to abort the request.\n   *\n   * @param options:\n   *          request: the request to send.\n   *          connected: a callback for when the connection is open.\n   *          closed: a callback for when the connection is closed.\n   *          headerReady: a callback for when the response header arrives.\n   *          bodyReady: a callback for when the response body arrives.\n   *          error: a callback for if an error occurs.\n   */\n  client.send = function(options) {\n    // add host header if not set\n    if(options.request.getField('Host') === null) {\n      options.request.setField('Host', client.url.origin);\n    }\n\n    // set default dummy handlers\n    var opts = {};\n    opts.request = options.request;\n    opts.connected = options.connected || function() {};\n    opts.closed = options.close || function() {};\n    opts.headerReady = function(e) {\n      // read cookies\n      _readCookies(client, e.response);\n      if(options.headerReady) {\n        options.headerReady(e);\n      }\n    };\n    opts.bodyReady = options.bodyReady || function() {};\n    opts.error = options.error || function() {};\n\n    // create response\n    opts.response = http.createResponse();\n    opts.response.time = 0;\n    opts.response.flashApi = client.socketPool.flashApi;\n    opts.request.flashApi = client.socketPool.flashApi;\n\n    // create abort function\n    opts.request.abort = function() {\n      // set aborted, clear handlers\n      opts.request.aborted = true;\n      opts.connected = function() {};\n      opts.closed = function() {};\n      opts.headerReady = function() {};\n      opts.bodyReady = function() {};\n      opts.error = function() {};\n    };\n\n    // add cookies to request\n    _writeCookies(client, opts.request);\n\n    // queue request options if there are no idle sockets\n    if(client.idle.length === 0) {\n      client.requests.push(opts);\n    } else {\n      // use an idle socket, prefer an idle *connected* socket first\n      var socket = null;\n      var len = client.idle.length;\n      for(var i = 0; socket === null && i < len; ++i) {\n        socket = client.idle[i];\n        if(socket.isConnected()) {\n          client.idle.splice(i, 1);\n        } else {\n          socket = null;\n        }\n      }\n      // no connected socket available, get unconnected socket\n      if(socket === null) {\n        socket = client.idle.pop();\n      }\n      socket.options = opts;\n      _doRequest(client, socket);\n    }\n  };\n\n  /**\n   * Destroys this client.\n   */\n  client.destroy = function() {\n    // clear pending requests, close and destroy sockets\n    client.requests = [];\n    for(var i = 0; i < client.sockets.length; ++i) {\n      client.sockets[i].close();\n      client.sockets[i].destroy();\n    }\n    client.socketPool = null;\n    client.sockets = [];\n    client.idle = [];\n  };\n\n  /**\n   * Sets a cookie for use with all connections made by this client. Any\n   * cookie with the same name will be replaced. If the cookie's value\n   * is undefined, null, or the blank string, the cookie will be removed.\n   *\n   * If the cookie's domain doesn't match this client's url host or the\n   * cookie's secure flag doesn't match this client's url scheme, then\n   * setting the cookie will fail with an exception.\n   *\n   * @param cookie the cookie with parameters:\n   *   name: the name of the cookie.\n   *   value: the value of the cookie.\n   *   comment: an optional comment string.\n   *   maxAge: the age of the cookie in seconds relative to created time.\n   *   secure: true if the cookie must be sent over a secure protocol.\n   *   httpOnly: true to restrict access to the cookie from javascript\n   *     (inaffective since the cookies are stored in javascript).\n   *   path: the path for the cookie.\n   *   domain: optional domain the cookie belongs to (must start with dot).\n   *   version: optional version of the cookie.\n   *   created: creation time, in UTC seconds, of the cookie.\n   */\n  client.setCookie = function(cookie) {\n    var rval;\n    if(typeof(cookie.name) !== 'undefined') {\n      if(cookie.value === null || typeof(cookie.value) === 'undefined' ||\n        cookie.value === '') {\n        // remove cookie\n        rval = client.removeCookie(cookie.name, cookie.path);\n      } else {\n        // set cookie defaults\n        cookie.comment = cookie.comment || '';\n        cookie.maxAge = cookie.maxAge || 0;\n        cookie.secure = (typeof(cookie.secure) === 'undefined') ?\n          true : cookie.secure;\n        cookie.httpOnly = cookie.httpOnly || true;\n        cookie.path = cookie.path || '/';\n        cookie.domain = cookie.domain || null;\n        cookie.version = cookie.version || null;\n        cookie.created = _getUtcTime(new Date());\n\n        // do secure check\n        if(cookie.secure !== client.secure) {\n          var error = new Error('Http client url scheme is incompatible ' +\n            'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        }\n        // make sure url host is within cookie.domain\n        if(!http.withinCookieDomain(client.url, cookie)) {\n          var error = new Error('Http client url scheme is incompatible ' +\n            'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        }\n\n        // add new cookie\n        if(!(cookie.name in client.cookies)) {\n          client.cookies[cookie.name] = {};\n        }\n        client.cookies[cookie.name][cookie.path] = cookie;\n        rval = true;\n\n        // save cookies\n        _saveCookies(client);\n      }\n    }\n\n    return rval;\n  };\n\n  /**\n   * Gets a cookie by its name.\n   *\n   * @param name the name of the cookie to retrieve.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return the cookie or null if not found.\n   */\n  client.getCookie = function(name, path) {\n    var rval = null;\n    if(name in client.cookies) {\n      var paths = client.cookies[name];\n\n      // get path-specific cookie\n      if(path) {\n        if(path in paths) {\n          rval = paths[path];\n        }\n      } else {\n        // get first cookie\n        for(var p in paths) {\n          rval = paths[p];\n          break;\n        }\n      }\n    }\n    return rval;\n  };\n\n  /**\n   * Removes a cookie.\n   *\n   * @param name the name of the cookie to remove.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return true if a cookie was removed, false if not.\n   */\n  client.removeCookie = function(name, path) {\n    var rval = false;\n    if(name in client.cookies) {\n      // delete the specific path\n      if(path) {\n        var paths = client.cookies[name];\n        if(path in paths) {\n          rval = true;\n          delete client.cookies[name][path];\n          // clean up entry if empty\n          var empty = true;\n          for(var i in client.cookies[name]) {\n            empty = false;\n            break;\n          }\n          if(empty) {\n            delete client.cookies[name];\n          }\n        }\n      } else {\n        // delete all cookies with the given name\n        rval = true;\n        delete client.cookies[name];\n      }\n    }\n    if(rval) {\n      // save cookies\n      _saveCookies(client);\n    }\n    return rval;\n  };\n\n  /**\n   * Clears all cookies stored in this client.\n   */\n  client.clearCookies = function() {\n    client.cookies = {};\n    _clearCookies(client);\n  };\n\n  if(forge.log) {\n    forge.log.debug('forge.http', 'created client', options);\n  }\n\n  return client;\n};\n\n/**\n * Trims the whitespace off of the beginning and end of a string.\n *\n * @param str the string to trim.\n *\n * @return the trimmed string.\n */\nvar _trimString = function(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n};\n\n/**\n * Creates an http header object.\n *\n * @return the http header object.\n */\nvar _createHeader = function() {\n  var header = {\n    fields: {},\n    setField: function(name, value) {\n      // normalize field name, trim value\n      header.fields[_normalize(name)] = [_trimString('' + value)];\n    },\n    appendField: function(name, value) {\n      name = _normalize(name);\n      if(!(name in header.fields)) {\n        header.fields[name] = [];\n      }\n      header.fields[name].push(_trimString('' + value));\n    },\n    getField: function(name, index) {\n      var rval = null;\n      name = _normalize(name);\n      if(name in header.fields) {\n        index = index || 0;\n        rval = header.fields[name][index];\n      }\n      return rval;\n    }\n  };\n  return header;\n};\n\n/**\n * Gets the time in utc seconds given a date.\n *\n * @param d the date to use.\n *\n * @return the time in utc seconds.\n */\nvar _getUtcTime = function(d) {\n  var utc = +d + d.getTimezoneOffset() * 60000;\n  return Math.floor(+new Date() / 1000);\n};\n\n/**\n * Creates an http request.\n *\n * @param options:\n *          version: the version.\n *          method: the method.\n *          path: the path.\n *          body: the body.\n *          headers: custom header fields to add,\n *            eg: [{'Content-Length': 0}].\n *\n * @return the http request.\n */\nhttp.createRequest = function(options) {\n  options = options || {};\n  var request = _createHeader();\n  request.version = options.version || 'HTTP/1.1';\n  request.method = options.method || null;\n  request.path = options.path || null;\n  request.body = options.body || null;\n  request.bodyDeflated = false;\n  request.flashApi = null;\n\n  // add custom headers\n  var headers = options.headers || [];\n  if(!forge.util.isArray(headers)) {\n    headers = [headers];\n  }\n  for(var i = 0; i < headers.length; ++i) {\n    for(var name in headers[i]) {\n      request.appendField(name, headers[i][name]);\n    }\n  }\n\n  /**\n   * Adds a cookie to the request 'Cookie' header.\n   *\n   * @param cookie a cookie to add.\n   */\n  request.addCookie = function(cookie) {\n    var value = '';\n    var field = request.getField('Cookie');\n    if(field !== null) {\n      // separate cookies by semi-colons\n      value = field + '; ';\n    }\n\n    // get current time in utc seconds\n    var now = _getUtcTime(new Date());\n\n    // output cookie name and value\n    value += cookie.name + '=' + cookie.value;\n    request.setField('Cookie', value);\n  };\n\n  /**\n   * Converts an http request into a string that can be sent as an\n   * HTTP request. Does not include any data.\n   *\n   * @return the string representation of the request.\n   */\n  request.toString = function() {\n    /* Sample request header:\n      GET /some/path/?query HTTP/1.1\n      Host: www.someurl.com\n      Connection: close\n      Accept-Encoding: deflate\n      Accept: image/gif, text/html\n      User-Agent: Mozilla 4.0\n     */\n\n    // set default headers\n    if(request.getField('User-Agent') === null) {\n      request.setField('User-Agent', 'forge.http 1.0');\n    }\n    if(request.getField('Accept') === null) {\n      request.setField('Accept', '*/*');\n    }\n    if(request.getField('Connection') === null) {\n      request.setField('Connection', 'keep-alive');\n      request.setField('Keep-Alive', '115');\n    }\n\n    // add Accept-Encoding if not specified\n    if(request.flashApi !== null &&\n      request.getField('Accept-Encoding') === null) {\n      request.setField('Accept-Encoding', 'deflate');\n    }\n\n    // if the body isn't null, deflate it if its larger than 100 bytes\n    if(request.flashApi !== null && request.body !== null &&\n      request.getField('Content-Encoding') === null &&\n      !request.bodyDeflated && request.body.length > 100) {\n      // use flash to compress data\n      request.body = forge.util.deflate(request.flashApi, request.body);\n      request.bodyDeflated = true;\n      request.setField('Content-Encoding', 'deflate');\n      request.setField('Content-Length', request.body.length);\n    } else if(request.body !== null) {\n      // set content length for body\n      request.setField('Content-Length', request.body.length);\n    }\n\n    // build start line\n    var rval =\n      request.method.toUpperCase() + ' ' + request.path + ' ' +\n      request.version + '\\r\\n';\n\n    // add each header\n    for(var name in request.fields) {\n      var fields = request.fields[name];\n      for(var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    }\n    // final terminating CRLF\n    rval += '\\r\\n';\n\n    return rval;\n  };\n\n  return request;\n};\n\n/**\n * Creates an empty http response header.\n *\n * @return the empty http response header.\n */\nhttp.createResponse = function() {\n  // private vars\n  var _first = true;\n  var _chunkSize = 0;\n  var _chunksFinished = false;\n\n  // create response\n  var response = _createHeader();\n  response.version = null;\n  response.code = 0;\n  response.message = null;\n  response.body = null;\n  response.headerReceived = false;\n  response.bodyReceived = false;\n  response.flashApi = null;\n\n  /**\n   * Reads a line that ends in CRLF from a byte buffer.\n   *\n   * @param b the byte buffer.\n   *\n   * @return the line or null if none was found.\n   */\n  var _readCrlf = function(b) {\n    var line = null;\n    var i = b.data.indexOf('\\r\\n', b.read);\n    if(i != -1) {\n      // read line, skip CRLF\n      line = b.getBytes(i - b.read);\n      b.getBytes(2);\n    }\n    return line;\n  };\n\n  /**\n   * Parses a header field and appends it to the response.\n   *\n   * @param line the header field line.\n   */\n  var _parseHeader = function(line) {\n    var tmp = line.indexOf(':');\n    var name = line.substring(0, tmp++);\n    response.appendField(\n      name, (tmp < line.length) ? line.substring(tmp) : '');\n  };\n\n  /**\n   * Reads an http response header from a buffer of bytes.\n   *\n   * @param b the byte buffer to parse the header from.\n   *\n   * @return true if the whole header was read, false if not.\n   */\n  response.readHeader = function(b) {\n    // read header lines (each ends in CRLF)\n    var line = '';\n    while(!response.headerReceived && line !== null) {\n      line = _readCrlf(b);\n      if(line !== null) {\n        // parse first line\n        if(_first) {\n          _first = false;\n          var tmp = line.split(' ');\n          if(tmp.length >= 3) {\n            response.version = tmp[0];\n            response.code = parseInt(tmp[1], 10);\n            response.message = tmp.slice(2).join(' ');\n          } else {\n            // invalid header\n            var error = new Error('Invalid http response header.');\n            error.details = {'line': line};\n            throw error;\n          }\n        } else if(line.length === 0) {\n          // handle final line, end of header\n          response.headerReceived = true;\n        } else {\n          _parseHeader(line);\n        }\n      }\n    }\n\n    return response.headerReceived;\n  };\n\n  /**\n   * Reads some chunked http response entity-body from the given buffer of\n   * bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n  var _readChunkedBody = function(b) {\n    /* Chunked transfer-encoding sends data in a series of chunks,\n      followed by a set of 0-N http trailers.\n      The format is as follows:\n\n      chunk-size (in hex) CRLF\n      chunk data (with \"chunk-size\" many bytes) CRLF\n      ... (N many chunks)\n      chunk-size (of 0 indicating the last chunk) CRLF\n      N many http trailers followed by CRLF\n      blank line + CRLF (terminates the trailers)\n\n      If there are no http trailers, then after the chunk-size of 0,\n      there is still a single CRLF (indicating the blank line + CRLF\n      that terminates the trailers). In other words, you always terminate\n      the trailers with blank line + CRLF, regardless of 0-N trailers. */\n\n      /* From RFC-2616, section 3.6.1, here is the pseudo-code for\n      implementing chunked transfer-encoding:\n\n      length := 0\n      read chunk-size, chunk-extension (if any) and CRLF\n      while (chunk-size > 0) {\n        read chunk-data and CRLF\n        append chunk-data to entity-body\n        length := length + chunk-size\n        read chunk-size and CRLF\n      }\n      read entity-header\n      while (entity-header not empty) {\n        append entity-header to existing header fields\n        read entity-header\n      }\n      Content-Length := length\n      Remove \"chunked\" from Transfer-Encoding\n    */\n\n    var line = '';\n    while(line !== null && b.length() > 0) {\n      // if in the process of reading a chunk\n      if(_chunkSize > 0) {\n        // if there are not enough bytes to read chunk and its\n        // trailing CRLF,  we must wait for more data to be received\n        if(_chunkSize + 2 > b.length()) {\n          break;\n        }\n\n        // read chunk data, skip CRLF\n        response.body += b.getBytes(_chunkSize);\n        b.getBytes(2);\n        _chunkSize = 0;\n      } else if(!_chunksFinished) {\n        // more chunks, read next chunk-size line\n        line = _readCrlf(b);\n        if(line !== null) {\n          // parse chunk-size (ignore any chunk extension)\n          _chunkSize = parseInt(line.split(';', 1)[0], 16);\n          _chunksFinished = (_chunkSize === 0);\n        }\n      } else {\n        // chunks finished, read next trailer\n        line = _readCrlf(b);\n        while(line !== null) {\n          if(line.length > 0) {\n            // parse trailer\n            _parseHeader(line);\n            // read next trailer\n            line = _readCrlf(b);\n          } else {\n            // body received\n            response.bodyReceived = true;\n            line = null;\n          }\n        }\n      }\n    }\n\n    return response.bodyReceived;\n  };\n\n  /**\n   * Reads an http response body from a buffer of bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n  response.readBody = function(b) {\n    var contentLength = response.getField('Content-Length');\n    var transferEncoding = response.getField('Transfer-Encoding');\n    if(contentLength !== null) {\n      contentLength = parseInt(contentLength);\n    }\n\n    // read specified length\n    if(contentLength !== null && contentLength >= 0) {\n      response.body = response.body || '';\n      response.body += b.getBytes(contentLength);\n      response.bodyReceived = (response.body.length === contentLength);\n    } else if(transferEncoding !== null) {\n      // read chunked encoding\n      if(transferEncoding.indexOf('chunked') != -1) {\n        response.body = response.body || '';\n        _readChunkedBody(b);\n      } else {\n        var error = new Error('Unknown Transfer-Encoding.');\n        error.details = {'transferEncoding': transferEncoding};\n        throw error;\n      }\n    } else if((contentLength !== null && contentLength < 0) ||\n      (contentLength === null &&\n      response.getField('Content-Type') !== null)) {\n      // read all data in the buffer\n      response.body = response.body || '';\n      response.body += b.getBytes();\n      response.readBodyUntilClose = true;\n    } else {\n      // no body\n      response.body = null;\n      response.bodyReceived = true;\n    }\n\n    if(response.bodyReceived) {\n      response.time = +new Date() - response.time;\n    }\n\n    if(response.flashApi !== null &&\n      response.bodyReceived && response.body !== null &&\n      response.getField('Content-Encoding') === 'deflate') {\n      // inflate using flash api\n      response.body = forge.util.inflate(\n        response.flashApi, response.body);\n    }\n\n    return response.bodyReceived;\n  };\n\n   /**\n    * Parses an array of cookies from the 'Set-Cookie' field, if present.\n    *\n    * @return the array of cookies.\n    */\n   response.getCookies = function() {\n     var rval = [];\n\n     // get Set-Cookie field\n     if('Set-Cookie' in response.fields) {\n       var field = response.fields['Set-Cookie'];\n\n       // get current local time in seconds\n       var now = +new Date() / 1000;\n\n       // regex for parsing 'name1=value1; name2=value2; name3'\n       var regex = /\\s*([^=]*)=?([^;]*)(;|$)/g;\n\n       // examples:\n       // Set-Cookie: cookie1_name=cookie1_value; max-age=0; path=/\n       // Set-Cookie: c2=v2; expires=Thu, 21-Aug-2008 23:47:25 GMT; path=/\n       for(var i = 0; i < field.length; ++i) {\n         var fv = field[i];\n         var m;\n         regex.lastIndex = 0;\n         var first = true;\n         var cookie = {};\n         do {\n           m = regex.exec(fv);\n           if(m !== null) {\n             var name = _trimString(m[1]);\n             var value = _trimString(m[2]);\n\n             // cookie_name=value\n             if(first) {\n               cookie.name = name;\n               cookie.value = value;\n               first = false;\n             } else {\n               // property_name=value\n               name = name.toLowerCase();\n               switch(name) {\n               case 'expires':\n                 // replace hyphens w/spaces so date will parse\n                 value = value.replace(/-/g, ' ');\n                 var secs = Date.parse(value) / 1000;\n                 cookie.maxAge = Math.max(0, secs - now);\n                 break;\n               case 'max-age':\n                 cookie.maxAge = parseInt(value, 10);\n                 break;\n               case 'secure':\n                 cookie.secure = true;\n                 break;\n               case 'httponly':\n                 cookie.httpOnly = true;\n                 break;\n               default:\n                 if(name !== '') {\n                   cookie[name] = value;\n                 }\n               }\n             }\n           }\n         } while(m !== null && m[0] !== '');\n         rval.push(cookie);\n       }\n     }\n\n     return rval;\n  };\n\n  /**\n   * Converts an http response into a string that can be sent as an\n   * HTTP response. Does not include any data.\n   *\n   * @return the string representation of the response.\n   */\n  response.toString = function() {\n    /* Sample response header:\n      HTTP/1.0 200 OK\n      Host: www.someurl.com\n      Connection: close\n     */\n\n    // build start line\n    var rval =\n      response.version + ' ' + response.code + ' ' + response.message + '\\r\\n';\n\n    // add each header\n    for(var name in response.fields) {\n      var fields = response.fields[name];\n      for(var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    }\n    // final terminating CRLF\n    rval += '\\r\\n';\n\n    return rval;\n  };\n\n  return response;\n};\n\n/**\n * Returns true if the given url is within the given cookie's domain.\n *\n * @param url the url to check.\n * @param cookie the cookie or cookie domain to check.\n */\nhttp.withinCookieDomain = function(url, cookie) {\n  var rval = false;\n\n  // cookie may be null, a cookie object, or a domain string\n  var domain = (cookie === null || typeof cookie === 'string') ?\n    cookie : cookie.domain;\n\n  // any domain will do\n  if(domain === null) {\n    rval = true;\n  } else if(domain.charAt(0) === '.') {\n    // ensure domain starts with a '.'\n    // parse URL as necessary\n    if(typeof url === 'string') {\n      url = new URL(url);\n    }\n\n    // add '.' to front of URL hostname to match against domain\n    var host = '.' + url.hostname;\n\n    // if the host ends with domain then it falls within it\n    var idx = host.lastIndexOf(domain);\n    if(idx !== -1 && (idx + domain.length === host.length)) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n", "/**\n * Utility functions for web applications.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2018 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nvar baseN = require('./baseN');\n\n/* Utilities API */\nvar util = module.exports = forge.util = forge.util || {};\n\n// define setImmediate and nextTick\n(function() {\n  // use native nextTick (unless we're in webpack)\n  // webpack (or better node-libs-browser polyfill) sets process.browser.\n  // this way we can detect webpack properly\n  if(typeof process !== 'undefined' && process.nextTick && !process.browser) {\n    util.nextTick = process.nextTick;\n    if(typeof setImmediate === 'function') {\n      util.setImmediate = setImmediate;\n    } else {\n      // polyfill setImmediate with nextTick, older versions of node\n      // (those w/o setImmediate) won't totally starve IO\n      util.setImmediate = util.nextTick;\n    }\n    return;\n  }\n\n  // polyfill nextTick with native setImmediate\n  if(typeof setImmediate === 'function') {\n    util.setImmediate = function() { return setImmediate.apply(undefined, arguments); };\n    util.nextTick = function(callback) {\n      return setImmediate(callback);\n    };\n    return;\n  }\n\n  /* Note: A polyfill upgrade pattern is used here to allow combining\n  polyfills. For example, MutationObserver is fast, but blocks UI updates,\n  so it needs to allow UI updates periodically, so it falls back on\n  postMessage or setTimeout. */\n\n  // polyfill with setTimeout\n  util.setImmediate = function(callback) {\n    setTimeout(callback, 0);\n  };\n\n  // upgrade polyfill to use postMessage\n  if(typeof window !== 'undefined' &&\n    typeof window.postMessage === 'function') {\n    var msg = 'forge.setImmediate';\n    var callbacks = [];\n    util.setImmediate = function(callback) {\n      callbacks.push(callback);\n      // only send message when one hasn't been sent in\n      // the current turn of the event loop\n      if(callbacks.length === 1) {\n        window.postMessage(msg, '*');\n      }\n    };\n    function handler(event) {\n      if(event.source === window && event.data === msg) {\n        event.stopPropagation();\n        var copy = callbacks.slice();\n        callbacks.length = 0;\n        copy.forEach(function(callback) {\n          callback();\n        });\n      }\n    }\n    window.addEventListener('message', handler, true);\n  }\n\n  // upgrade polyfill to use MutationObserver\n  if(typeof MutationObserver !== 'undefined') {\n    // polyfill with MutationObserver\n    var now = Date.now();\n    var attr = true;\n    var div = document.createElement('div');\n    var callbacks = [];\n    new MutationObserver(function() {\n      var copy = callbacks.slice();\n      callbacks.length = 0;\n      copy.forEach(function(callback) {\n        callback();\n      });\n    }).observe(div, {attributes: true});\n    var oldSetImmediate = util.setImmediate;\n    util.setImmediate = function(callback) {\n      if(Date.now() - now > 15) {\n        now = Date.now();\n        oldSetImmediate(callback);\n      } else {\n        callbacks.push(callback);\n        // only trigger observer when it hasn't been triggered in\n        // the current turn of the event loop\n        if(callbacks.length === 1) {\n          div.setAttribute('a', attr = !attr);\n        }\n      }\n    };\n  }\n\n  util.nextTick = util.setImmediate;\n})();\n\n// check if running under Node.js\nutil.isNodejs =\n  typeof process !== 'undefined' && process.versions && process.versions.node;\n\n\n// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while\n// it will point to `window` in the main thread.\n// To remain compatible with older browsers, we fall back to 'window' if 'self'\n// is not available.\nutil.globalScope = (function() {\n  if(util.isNodejs) {\n    return global;\n  }\n\n  return typeof self === 'undefined' ? window : self;\n})();\n\n// define isArray\nutil.isArray = Array.isArray || function(x) {\n  return Object.prototype.toString.call(x) === '[object Array]';\n};\n\n// define isArrayBuffer\nutil.isArrayBuffer = function(x) {\n  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;\n};\n\n// define isArrayBufferView\nutil.isArrayBufferView = function(x) {\n  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;\n};\n\n/**\n * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for\n * algorithms where bit manipulation, JavaScript limitations, and/or algorithm\n * design only allow for byte operations of a limited size.\n *\n * @param n number of bits.\n *\n * Throw Error if n invalid.\n */\nfunction _checkBitsParam(n) {\n  if(!(n === 8 || n === 16 || n === 24 || n === 32)) {\n    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);\n  }\n}\n\n// TODO: set ByteBuffer to best available backing\nutil.ByteBuffer = ByteStringBuffer;\n\n/** Buffer w/BinaryString backing */\n\n/**\n * Constructor for a binary string backed byte buffer.\n *\n * @param [b] the bytes to wrap (either encoded as string, one byte per\n *          character, or as an ArrayBuffer or Typed Array).\n */\nfunction ByteStringBuffer(b) {\n  // TODO: update to match DataBuffer API\n\n  // the data in this buffer\n  this.data = '';\n  // the pointer for reading from this buffer\n  this.read = 0;\n\n  if(typeof b === 'string') {\n    this.data = b;\n  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {\n    if(typeof Buffer !== 'undefined' && b instanceof Buffer) {\n      this.data = b.toString('binary');\n    } else {\n      // convert native buffer to forge buffer\n      // FIXME: support native buffers internally instead\n      var arr = new Uint8Array(b);\n      try {\n        this.data = String.fromCharCode.apply(null, arr);\n      } catch(e) {\n        for(var i = 0; i < arr.length; ++i) {\n          this.putByte(arr[i]);\n        }\n      }\n    }\n  } else if(b instanceof ByteStringBuffer ||\n    (typeof b === 'object' && typeof b.data === 'string' &&\n    typeof b.read === 'number')) {\n    // copy existing buffer\n    this.data = b.data;\n    this.read = b.read;\n  }\n\n  // used for v8 optimization\n  this._constructedStringLength = 0;\n}\nutil.ByteStringBuffer = ByteStringBuffer;\n\n/* Note: This is an optimization for V8-based browsers. When V8 concatenates\n  a string, the strings are only joined logically using a \"cons string\" or\n  \"constructed/concatenated string\". These containers keep references to one\n  another and can result in very large memory usage. For example, if a 2MB\n  string is constructed by concatenating 4 bytes together at a time, the\n  memory usage will be ~44MB; so ~22x increase. The strings are only joined\n  together when an operation requiring their joining takes place, such as\n  substr(). This function is called when adding data to this buffer to ensure\n  these types of strings are periodically joined to reduce the memory\n  footprint. */\nvar _MAX_CONSTRUCTED_STRING_LENGTH = 4096;\nutil.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {\n  this._constructedStringLength += x;\n  if(this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {\n    // this substr() should cause the constructed string to join\n    this.data.substr(0, 1);\n    this._constructedStringLength = 0;\n  }\n};\n\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */\nutil.ByteStringBuffer.prototype.length = function() {\n  return this.data.length - this.read;\n};\n\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */\nutil.ByteStringBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putByte = function(b) {\n  return this.putBytes(String.fromCharCode(b));\n};\n\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.fillWithByte = function(b, n) {\n  b = String.fromCharCode(b);\n  var d = this.data;\n  while(n > 0) {\n    if(n & 1) {\n      d += b;\n    }\n    n >>>= 1;\n    if(n > 0) {\n      b += b;\n    }\n  }\n  this.data = d;\n  this._optimizeConstructedString(n);\n  return this;\n};\n\n/**\n * Puts bytes in this buffer.\n *\n * @param bytes the bytes (as a binary encoded string) to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putBytes = function(bytes) {\n  this.data += bytes;\n  this._optimizeConstructedString(bytes.length);\n  return this;\n};\n\n/**\n * Puts a UTF-16 encoded string into this buffer.\n *\n * @param str the string to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putString = function(str) {\n  return this.putBytes(util.encodeUtf8(str));\n};\n\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt16 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt24 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt32 = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i >> 24 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt16Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF));\n};\n\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt24Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF));\n};\n\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt32Le = function(i) {\n  return this.putBytes(\n    String.fromCharCode(i & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 24 & 0xFF));\n};\n\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putInt = function(i, n) {\n  _checkBitsParam(n);\n  var bytes = '';\n  do {\n    n -= 8;\n    bytes += String.fromCharCode((i >> n) & 0xFF);\n  } while(n > 0);\n  return this.putBytes(bytes);\n};\n\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putSignedInt = function(i, n) {\n  // putInt checks n\n  if(i < 0) {\n    i += 2 << (n - 1);\n  }\n  return this.putInt(i, n);\n};\n\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.putBuffer = function(buffer) {\n  return this.putBytes(buffer.getBytes());\n};\n\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */\nutil.ByteStringBuffer.prototype.getByte = function() {\n  return this.data.charCodeAt(this.read++);\n};\n\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.ByteStringBuffer.prototype.getInt16 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 8 ^\n    this.data.charCodeAt(this.read + 1));\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.ByteStringBuffer.prototype.getInt24 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 16 ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2));\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.ByteStringBuffer.prototype.getInt32 = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) << 24 ^\n    this.data.charCodeAt(this.read + 1) << 16 ^\n    this.data.charCodeAt(this.read + 2) << 8 ^\n    this.data.charCodeAt(this.read + 3));\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.ByteStringBuffer.prototype.getInt16Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.ByteStringBuffer.prototype.getInt24Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2) << 16);\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.ByteStringBuffer.prototype.getInt32Le = function() {\n  var rval = (\n    this.data.charCodeAt(this.read) ^\n    this.data.charCodeAt(this.read + 1) << 8 ^\n    this.data.charCodeAt(this.read + 2) << 16 ^\n    this.data.charCodeAt(this.read + 3) << 24);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by ceil(n/8).\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.ByteStringBuffer.prototype.getInt = function(n) {\n  _checkBitsParam(n);\n  var rval = 0;\n  do {\n    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n    rval = (rval << 8) + this.data.charCodeAt(this.read++);\n    n -= 8;\n  } while(n > 0);\n  return rval;\n};\n\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.ByteStringBuffer.prototype.getSignedInt = function(n) {\n  // getInt checks n\n  var x = this.getInt(n);\n  var max = 2 << (n - 2);\n  if(x >= max) {\n    x -= max << 1;\n  }\n  return x;\n};\n\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer. Note that the resulting string is binary encoded (in node.js this\n * encoding is referred to as `binary`, it is *not* `utf8`).\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */\nutil.ByteStringBuffer.prototype.getBytes = function(count) {\n  var rval;\n  if(count) {\n    // read count bytes\n    count = Math.min(this.length(), count);\n    rval = this.data.slice(this.read, this.read + count);\n    this.read += count;\n  } else if(count === 0) {\n    rval = '';\n  } else {\n    // read all bytes, optimize to only copy when needed\n    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\n    this.clear();\n  }\n  return rval;\n};\n\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */\nutil.ByteStringBuffer.prototype.bytes = function(count) {\n  return (typeof(count) === 'undefined' ?\n    this.data.slice(this.read) :\n    this.data.slice(this.read, this.read + count));\n};\n\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */\nutil.ByteStringBuffer.prototype.at = function(i) {\n  return this.data.charCodeAt(this.read + i);\n};\n\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.setAt = function(i, b) {\n  this.data = this.data.substr(0, this.read + i) +\n    String.fromCharCode(b) +\n    this.data.substr(this.read + i + 1);\n  return this;\n};\n\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */\nutil.ByteStringBuffer.prototype.last = function() {\n  return this.data.charCodeAt(this.data.length - 1);\n};\n\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */\nutil.ByteStringBuffer.prototype.copy = function() {\n  var c = util.createBuffer(this.data);\n  c.read = this.read;\n  return c;\n};\n\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.compact = function() {\n  if(this.read > 0) {\n    this.data = this.data.slice(this.read);\n    this.read = 0;\n  }\n  return this;\n};\n\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.clear = function() {\n  this.data = '';\n  this.read = 0;\n  return this;\n};\n\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */\nutil.ByteStringBuffer.prototype.truncate = function(count) {\n  var len = Math.max(0, this.length() - count);\n  this.data = this.data.substr(this.read, len);\n  this.read = 0;\n  return this;\n};\n\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */\nutil.ByteStringBuffer.prototype.toHex = function() {\n  var rval = '';\n  for(var i = this.read; i < this.data.length; ++i) {\n    var b = this.data.charCodeAt(i);\n    if(b < 16) {\n      rval += '0';\n    }\n    rval += b.toString(16);\n  }\n  return rval;\n};\n\n/**\n * Converts this buffer to a UTF-16 string (standard JavaScript string).\n *\n * @return a UTF-16 string.\n */\nutil.ByteStringBuffer.prototype.toString = function() {\n  return util.decodeUtf8(this.bytes());\n};\n\n/** End Buffer w/BinaryString backing */\n\n/** Buffer w/UInt8Array backing */\n\n/**\n * FIXME: Experimental. Do not use yet.\n *\n * Constructor for an ArrayBuffer-backed byte buffer.\n *\n * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a\n * TypedArray.\n *\n * If a string is given, its encoding should be provided as an option,\n * otherwise it will default to 'binary'. A 'binary' string is encoded such\n * that each character is one byte in length and size.\n *\n * If an ArrayBuffer, DataView, or TypedArray is given, it will be used\n * *directly* without any copying. Note that, if a write to the buffer requires\n * more space, the buffer will allocate a new backing ArrayBuffer to\n * accommodate. The starting read and write offsets for the buffer may be\n * given as options.\n *\n * @param [b] the initial bytes for this buffer.\n * @param options the options to use:\n *          [readOffset] the starting read offset to use (default: 0).\n *          [writeOffset] the starting write offset to use (default: the\n *            length of the first parameter).\n *          [growSize] the minimum amount, in bytes, to grow the buffer by to\n *            accommodate writes (default: 1024).\n *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the\n *            first parameter, if it is a string (default: 'binary').\n */\nfunction DataBuffer(b, options) {\n  // default options\n  options = options || {};\n\n  // pointers for read from/write to buffer\n  this.read = options.readOffset || 0;\n  this.growSize = options.growSize || 1024;\n\n  var isArrayBuffer = util.isArrayBuffer(b);\n  var isArrayBufferView = util.isArrayBufferView(b);\n  if(isArrayBuffer || isArrayBufferView) {\n    // use ArrayBuffer directly\n    if(isArrayBuffer) {\n      this.data = new DataView(b);\n    } else {\n      // TODO: adjust read/write offset based on the type of view\n      // or specify that this must be done in the options ... that the\n      // offsets are byte-based\n      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    }\n    this.write = ('writeOffset' in options ?\n      options.writeOffset : this.data.byteLength);\n    return;\n  }\n\n  // initialize to empty array buffer and add any given bytes using putBytes\n  this.data = new DataView(new ArrayBuffer(0));\n  this.write = 0;\n\n  if(b !== null && b !== undefined) {\n    this.putBytes(b);\n  }\n\n  if('writeOffset' in options) {\n    this.write = options.writeOffset;\n  }\n}\nutil.DataBuffer = DataBuffer;\n\n/**\n * Gets the number of bytes in this buffer.\n *\n * @return the number of bytes in this buffer.\n */\nutil.DataBuffer.prototype.length = function() {\n  return this.write - this.read;\n};\n\n/**\n * Gets whether or not this buffer is empty.\n *\n * @return true if this buffer is empty, false if not.\n */\nutil.DataBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\n/**\n * Ensures this buffer has enough empty space to accommodate the given number\n * of bytes. An optional parameter may be given that indicates a minimum\n * amount to grow the buffer if necessary. If the parameter is not given,\n * the buffer will be grown by some previously-specified default amount\n * or heuristic.\n *\n * @param amount the number of bytes to accommodate.\n * @param [growSize] the minimum amount, in bytes, to grow the buffer by if\n *          necessary.\n */\nutil.DataBuffer.prototype.accommodate = function(amount, growSize) {\n  if(this.length() >= amount) {\n    return this;\n  }\n  growSize = Math.max(growSize || this.growSize, amount);\n\n  // grow buffer\n  var src = new Uint8Array(\n    this.data.buffer, this.data.byteOffset, this.data.byteLength);\n  var dst = new Uint8Array(this.length() + growSize);\n  dst.set(src);\n  this.data = new DataView(dst.buffer);\n\n  return this;\n};\n\n/**\n * Puts a byte in this buffer.\n *\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putByte = function(b) {\n  this.accommodate(1);\n  this.data.setUint8(this.write++, b);\n  return this;\n};\n\n/**\n * Puts a byte in this buffer N times.\n *\n * @param b the byte to put.\n * @param n the number of bytes of value b to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.fillWithByte = function(b, n) {\n  this.accommodate(n);\n  for(var i = 0; i < n; ++i) {\n    this.data.setUint8(b);\n  }\n  return this;\n};\n\n/**\n * Puts bytes in this buffer. The bytes may be given as a string, an\n * ArrayBuffer, a DataView, or a TypedArray.\n *\n * @param bytes the bytes to put.\n * @param [encoding] the encoding for the first parameter ('binary', 'utf8',\n *          'utf16', 'hex'), if it is a string (default: 'binary').\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putBytes = function(bytes, encoding) {\n  if(util.isArrayBufferView(bytes)) {\n    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    var len = src.byteLength - src.byteOffset;\n    this.accommodate(len);\n    var dst = new Uint8Array(this.data.buffer, this.write);\n    dst.set(src);\n    this.write += len;\n    return this;\n  }\n\n  if(util.isArrayBuffer(bytes)) {\n    var src = new Uint8Array(bytes);\n    this.accommodate(src.byteLength);\n    var dst = new Uint8Array(this.data.buffer);\n    dst.set(src, this.write);\n    this.write += src.byteLength;\n    return this;\n  }\n\n  // bytes is a util.DataBuffer or equivalent\n  if(bytes instanceof util.DataBuffer ||\n    (typeof bytes === 'object' &&\n    typeof bytes.read === 'number' && typeof bytes.write === 'number' &&\n    util.isArrayBufferView(bytes.data))) {\n    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());\n    this.accommodate(src.byteLength);\n    var dst = new Uint8Array(bytes.data.byteLength, this.write);\n    dst.set(src);\n    this.write += src.byteLength;\n    return this;\n  }\n\n  if(bytes instanceof util.ByteStringBuffer) {\n    // copy binary string and process as the same as a string parameter below\n    bytes = bytes.data;\n    encoding = 'binary';\n  }\n\n  // string conversion\n  encoding = encoding || 'binary';\n  if(typeof bytes === 'string') {\n    var view;\n\n    // decode from string\n    if(encoding === 'hex') {\n      this.accommodate(Math.ceil(bytes.length / 2));\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.hex.decode(bytes, view, this.write);\n      return this;\n    }\n    if(encoding === 'base64') {\n      this.accommodate(Math.ceil(bytes.length / 4) * 3);\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.base64.decode(bytes, view, this.write);\n      return this;\n    }\n\n    // encode text as UTF-8 bytes\n    if(encoding === 'utf8') {\n      // encode as UTF-8 then decode string as raw binary\n      bytes = util.encodeUtf8(bytes);\n      encoding = 'binary';\n    }\n\n    // decode string as raw binary\n    if(encoding === 'binary' || encoding === 'raw') {\n      // one byte per character\n      this.accommodate(bytes.length);\n      view = new Uint8Array(this.data.buffer, this.write);\n      this.write += util.binary.raw.decode(view);\n      return this;\n    }\n\n    // encode text as UTF-16 bytes\n    if(encoding === 'utf16') {\n      // two bytes per character\n      this.accommodate(bytes.length * 2);\n      view = new Uint16Array(this.data.buffer, this.write);\n      this.write += util.text.utf16.encode(view);\n      return this;\n    }\n\n    throw new Error('Invalid encoding: ' + encoding);\n  }\n\n  throw Error('Invalid parameter: ' + bytes);\n};\n\n/**\n * Puts the given buffer into this buffer.\n *\n * @param buffer the buffer to put into this one.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putBuffer = function(buffer) {\n  this.putBytes(buffer);\n  buffer.clear();\n  return this;\n};\n\n/**\n * Puts a string into this buffer.\n *\n * @param str the string to put.\n * @param [encoding] the encoding for the string (default: 'utf16').\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putString = function(str) {\n  return this.putBytes(str, 'utf16');\n};\n\n/**\n * Puts a 16-bit integer in this buffer in big-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt16 = function(i) {\n  this.accommodate(2);\n  this.data.setInt16(this.write, i);\n  this.write += 2;\n  return this;\n};\n\n/**\n * Puts a 24-bit integer in this buffer in big-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt24 = function(i) {\n  this.accommodate(3);\n  this.data.setInt16(this.write, i >> 8 & 0xFFFF);\n  this.data.setInt8(this.write, i >> 16 & 0xFF);\n  this.write += 3;\n  return this;\n};\n\n/**\n * Puts a 32-bit integer in this buffer in big-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt32 = function(i) {\n  this.accommodate(4);\n  this.data.setInt32(this.write, i);\n  this.write += 4;\n  return this;\n};\n\n/**\n * Puts a 16-bit integer in this buffer in little-endian order.\n *\n * @param i the 16-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt16Le = function(i) {\n  this.accommodate(2);\n  this.data.setInt16(this.write, i, true);\n  this.write += 2;\n  return this;\n};\n\n/**\n * Puts a 24-bit integer in this buffer in little-endian order.\n *\n * @param i the 24-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt24Le = function(i) {\n  this.accommodate(3);\n  this.data.setInt8(this.write, i >> 16 & 0xFF);\n  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);\n  this.write += 3;\n  return this;\n};\n\n/**\n * Puts a 32-bit integer in this buffer in little-endian order.\n *\n * @param i the 32-bit integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt32Le = function(i) {\n  this.accommodate(4);\n  this.data.setInt32(this.write, i, true);\n  this.write += 4;\n  return this;\n};\n\n/**\n * Puts an n-bit integer in this buffer in big-endian order.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putInt = function(i, n) {\n  _checkBitsParam(n);\n  this.accommodate(n / 8);\n  do {\n    n -= 8;\n    this.data.setInt8(this.write++, (i >> n) & 0xFF);\n  } while(n > 0);\n  return this;\n};\n\n/**\n * Puts a signed n-bit integer in this buffer in big-endian order. Two's\n * complement representation is used.\n *\n * @param i the n-bit integer.\n * @param n the number of bits in the integer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.putSignedInt = function(i, n) {\n  _checkBitsParam(n);\n  this.accommodate(n / 8);\n  if(i < 0) {\n    i += 2 << (n - 1);\n  }\n  return this.putInt(i, n);\n};\n\n/**\n * Gets a byte from this buffer and advances the read pointer by 1.\n *\n * @return the byte.\n */\nutil.DataBuffer.prototype.getByte = function() {\n  return this.data.getInt8(this.read++);\n};\n\n/**\n * Gets a uint16 from this buffer in big-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.DataBuffer.prototype.getInt16 = function() {\n  var rval = this.data.getInt16(this.read);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in big-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.DataBuffer.prototype.getInt24 = function() {\n  var rval = (\n    this.data.getInt16(this.read) << 8 ^\n    this.data.getInt8(this.read + 2));\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in big-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.DataBuffer.prototype.getInt32 = function() {\n  var rval = this.data.getInt32(this.read);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets a uint16 from this buffer in little-endian order and advances the read\n * pointer by 2.\n *\n * @return the uint16.\n */\nutil.DataBuffer.prototype.getInt16Le = function() {\n  var rval = this.data.getInt16(this.read, true);\n  this.read += 2;\n  return rval;\n};\n\n/**\n * Gets a uint24 from this buffer in little-endian order and advances the read\n * pointer by 3.\n *\n * @return the uint24.\n */\nutil.DataBuffer.prototype.getInt24Le = function() {\n  var rval = (\n    this.data.getInt8(this.read) ^\n    this.data.getInt16(this.read + 1, true) << 8);\n  this.read += 3;\n  return rval;\n};\n\n/**\n * Gets a uint32 from this buffer in little-endian order and advances the read\n * pointer by 4.\n *\n * @return the word.\n */\nutil.DataBuffer.prototype.getInt32Le = function() {\n  var rval = this.data.getInt32(this.read, true);\n  this.read += 4;\n  return rval;\n};\n\n/**\n * Gets an n-bit integer from this buffer in big-endian order and advances the\n * read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.DataBuffer.prototype.getInt = function(n) {\n  _checkBitsParam(n);\n  var rval = 0;\n  do {\n    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.\n    rval = (rval << 8) + this.data.getInt8(this.read++);\n    n -= 8;\n  } while(n > 0);\n  return rval;\n};\n\n/**\n * Gets a signed n-bit integer from this buffer in big-endian order, using\n * two's complement, and advances the read pointer by n/8.\n *\n * @param n the number of bits in the integer (8, 16, 24, or 32).\n *\n * @return the integer.\n */\nutil.DataBuffer.prototype.getSignedInt = function(n) {\n  // getInt checks n\n  var x = this.getInt(n);\n  var max = 2 << (n - 2);\n  if(x >= max) {\n    x -= max << 1;\n  }\n  return x;\n};\n\n/**\n * Reads bytes out as a binary encoded string and clears them from the\n * buffer.\n *\n * @param count the number of bytes to read, undefined or null for all.\n *\n * @return a binary encoded string of bytes.\n */\nutil.DataBuffer.prototype.getBytes = function(count) {\n  // TODO: deprecate this method, it is poorly named and\n  // this.toString('binary') replaces it\n  // add a toTypedArray()/toArrayBuffer() function\n  var rval;\n  if(count) {\n    // read count bytes\n    count = Math.min(this.length(), count);\n    rval = this.data.slice(this.read, this.read + count);\n    this.read += count;\n  } else if(count === 0) {\n    rval = '';\n  } else {\n    // read all bytes, optimize to only copy when needed\n    rval = (this.read === 0) ? this.data : this.data.slice(this.read);\n    this.clear();\n  }\n  return rval;\n};\n\n/**\n * Gets a binary encoded string of the bytes from this buffer without\n * modifying the read pointer.\n *\n * @param count the number of bytes to get, omit to get all.\n *\n * @return a string full of binary encoded characters.\n */\nutil.DataBuffer.prototype.bytes = function(count) {\n  // TODO: deprecate this method, it is poorly named, add \"getString()\"\n  return (typeof(count) === 'undefined' ?\n    this.data.slice(this.read) :\n    this.data.slice(this.read, this.read + count));\n};\n\n/**\n * Gets a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n *\n * @return the byte.\n */\nutil.DataBuffer.prototype.at = function(i) {\n  return this.data.getUint8(this.read + i);\n};\n\n/**\n * Puts a byte at the given index without modifying the read pointer.\n *\n * @param i the byte index.\n * @param b the byte to put.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.setAt = function(i, b) {\n  this.data.setUint8(i, b);\n  return this;\n};\n\n/**\n * Gets the last byte without modifying the read pointer.\n *\n * @return the last byte.\n */\nutil.DataBuffer.prototype.last = function() {\n  return this.data.getUint8(this.write - 1);\n};\n\n/**\n * Creates a copy of this buffer.\n *\n * @return the copy.\n */\nutil.DataBuffer.prototype.copy = function() {\n  return new util.DataBuffer(this);\n};\n\n/**\n * Compacts this buffer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.compact = function() {\n  if(this.read > 0) {\n    var src = new Uint8Array(this.data.buffer, this.read);\n    var dst = new Uint8Array(src.byteLength);\n    dst.set(src);\n    this.data = new DataView(dst);\n    this.write -= this.read;\n    this.read = 0;\n  }\n  return this;\n};\n\n/**\n * Clears this buffer.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.clear = function() {\n  this.data = new DataView(new ArrayBuffer(0));\n  this.read = this.write = 0;\n  return this;\n};\n\n/**\n * Shortens this buffer by triming bytes off of the end of this buffer.\n *\n * @param count the number of bytes to trim off.\n *\n * @return this buffer.\n */\nutil.DataBuffer.prototype.truncate = function(count) {\n  this.write = Math.max(0, this.length() - count);\n  this.read = Math.min(this.read, this.write);\n  return this;\n};\n\n/**\n * Converts this buffer to a hexadecimal string.\n *\n * @return a hexadecimal string.\n */\nutil.DataBuffer.prototype.toHex = function() {\n  var rval = '';\n  for(var i = this.read; i < this.data.byteLength; ++i) {\n    var b = this.data.getUint8(i);\n    if(b < 16) {\n      rval += '0';\n    }\n    rval += b.toString(16);\n  }\n  return rval;\n};\n\n/**\n * Converts this buffer to a string, using the given encoding. If no\n * encoding is given, 'utf8' (UTF-8) is used.\n *\n * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',\n *          'base64' (default: 'utf8').\n *\n * @return a string representation of the bytes in this buffer.\n */\nutil.DataBuffer.prototype.toString = function(encoding) {\n  var view = new Uint8Array(this.data, this.read, this.length());\n  encoding = encoding || 'utf8';\n\n  // encode to string\n  if(encoding === 'binary' || encoding === 'raw') {\n    return util.binary.raw.encode(view);\n  }\n  if(encoding === 'hex') {\n    return util.binary.hex.encode(view);\n  }\n  if(encoding === 'base64') {\n    return util.binary.base64.encode(view);\n  }\n\n  // decode to text\n  if(encoding === 'utf8') {\n    return util.text.utf8.decode(view);\n  }\n  if(encoding === 'utf16') {\n    return util.text.utf16.decode(view);\n  }\n\n  throw new Error('Invalid encoding: ' + encoding);\n};\n\n/** End Buffer w/UInt8Array backing */\n\n/**\n * Creates a buffer that stores bytes. A value may be given to populate the\n * buffer with data. This value can either be string of encoded bytes or a\n * regular string of characters. When passing a string of binary encoded\n * bytes, the encoding `raw` should be given. This is also the default. When\n * passing a string of characters, the encoding `utf8` should be given.\n *\n * @param [input] a string with encoded bytes to store in the buffer.\n * @param [encoding] (default: 'raw', other: 'utf8').\n */\nutil.createBuffer = function(input, encoding) {\n  // TODO: deprecate, use new ByteBuffer() instead\n  encoding = encoding || 'raw';\n  if(input !== undefined && encoding === 'utf8') {\n    input = util.encodeUtf8(input);\n  }\n  return new util.ByteBuffer(input);\n};\n\n/**\n * Fills a string with a particular value. If you want the string to be a byte\n * string, pass in String.fromCharCode(theByte).\n *\n * @param c the character to fill the string with, use String.fromCharCode\n *          to fill the string with a byte value.\n * @param n the number of characters of value c to fill with.\n *\n * @return the filled string.\n */\nutil.fillString = function(c, n) {\n  var s = '';\n  while(n > 0) {\n    if(n & 1) {\n      s += c;\n    }\n    n >>>= 1;\n    if(n > 0) {\n      c += c;\n    }\n  }\n  return s;\n};\n\n/**\n * Performs a per byte XOR between two byte strings and returns the result as a\n * string of bytes.\n *\n * @param s1 first string of bytes.\n * @param s2 second string of bytes.\n * @param n the number of bytes to XOR.\n *\n * @return the XOR'd result.\n */\nutil.xorBytes = function(s1, s2, n) {\n  var s3 = '';\n  var b = '';\n  var t = '';\n  var i = 0;\n  var c = 0;\n  for(; n > 0; --n, ++i) {\n    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);\n    if(c >= 10) {\n      s3 += t;\n      t = '';\n      c = 0;\n    }\n    t += String.fromCharCode(b);\n    ++c;\n  }\n  s3 += t;\n  return s3;\n};\n\n/**\n * Converts a hex string into a 'binary' encoded string of bytes.\n *\n * @param hex the hexadecimal string to convert.\n *\n * @return the binary-encoded string of bytes.\n */\nutil.hexToBytes = function(hex) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.hex.decode instead.\"\n  var rval = '';\n  var i = 0;\n  if(hex.length & 1 == 1) {\n    // odd number of characters, convert first character alone\n    i = 1;\n    rval += String.fromCharCode(parseInt(hex[0], 16));\n  }\n  // convert 2 characters (1 byte) at a time\n  for(; i < hex.length; i += 2) {\n    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n  }\n  return rval;\n};\n\n/**\n * Converts a 'binary' encoded string of bytes to hex.\n *\n * @param bytes the byte string to convert.\n *\n * @return the string of hexadecimal characters.\n */\nutil.bytesToHex = function(bytes) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.hex.encode instead.\"\n  return util.createBuffer(bytes).toHex();\n};\n\n/**\n * Converts an 32-bit integer to 4-big-endian byte string.\n *\n * @param i the integer.\n *\n * @return the byte string.\n */\nutil.int32ToBytes = function(i) {\n  return (\n    String.fromCharCode(i >> 24 & 0xFF) +\n    String.fromCharCode(i >> 16 & 0xFF) +\n    String.fromCharCode(i >> 8 & 0xFF) +\n    String.fromCharCode(i & 0xFF));\n};\n\n// base64 characters, reverse mapping\nvar _base64 =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nvar _base64Idx = [\n/*43 -43 = 0*/\n/*'+',  1,  2,  3,'/' */\n   62, -1, -1, -1, 63,\n\n/*'0','1','2','3','4','5','6','7','8','9' */\n   52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n\n/*15, 16, 17,'=', 19, 20, 21 */\n  -1, -1, -1, 64, -1, -1, -1,\n\n/*65 - 43 = 22*/\n/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */\n   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,\n\n/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */\n   13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n\n/*91 - 43 = 48 */\n/*48, 49, 50, 51, 52, 53 */\n  -1, -1, -1, -1, -1, -1,\n\n/*97 - 43 = 54*/\n/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */\n   26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\n\n/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */\n   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n];\n\n// base58 characters (Bitcoin alphabet)\nvar _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Base64 encodes a 'binary' encoded string of bytes.\n *\n * @param input the binary encoded string of bytes to base64-encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output.\n */\nutil.encode64 = function(input, maxline) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.base64.encode instead.\"\n  var line = '';\n  var output = '';\n  var chr1, chr2, chr3;\n  var i = 0;\n  while(i < input.length) {\n    chr1 = input.charCodeAt(i++);\n    chr2 = input.charCodeAt(i++);\n    chr3 = input.charCodeAt(i++);\n\n    // encode 4 character group\n    line += _base64.charAt(chr1 >> 2);\n    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\n    if(isNaN(chr2)) {\n      line += '==';\n    } else {\n      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\n      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\n    }\n\n    if(maxline && line.length > maxline) {\n      output += line.substr(0, maxline) + '\\r\\n';\n      line = line.substr(maxline);\n    }\n  }\n  output += line;\n  return output;\n};\n\n/**\n * Base64 decodes a string into a 'binary' encoded string of bytes.\n *\n * @param input the base64-encoded input.\n *\n * @return the binary encoded string.\n */\nutil.decode64 = function(input) {\n  // TODO: deprecate: \"Deprecated. Use util.binary.base64.decode instead.\"\n\n  // remove all non-base64 characters\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n  var output = '';\n  var enc1, enc2, enc3, enc4;\n  var i = 0;\n\n  while(i < input.length) {\n    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n\n    output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));\n    if(enc3 !== 64) {\n      // decoded at least 2 bytes\n      output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));\n      if(enc4 !== 64) {\n        // decoded 3 bytes\n        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);\n      }\n    }\n  }\n\n  return output;\n};\n\n/**\n * Encodes the given string of characters (a standard JavaScript\n * string) as a binary encoded string where the bytes represent\n * a UTF-8 encoded string of characters. Non-ASCII characters will be\n * encoded as multiple bytes according to UTF-8.\n *\n * @param str a standard string of characters to encode.\n *\n * @return the binary encoded string.\n */\nutil.encodeUtf8 = function(str) {\n  return unescape(encodeURIComponent(str));\n};\n\n/**\n * Decodes a binary encoded string that contains bytes that\n * represent a UTF-8 encoded string of characters -- into a\n * string of characters (a standard JavaScript string).\n *\n * @param str the binary encoded string to decode.\n *\n * @return the resulting standard string of characters.\n */\nutil.decodeUtf8 = function(str) {\n  return decodeURIComponent(escape(str));\n};\n\n// binary encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.binary = {\n  raw: {},\n  hex: {},\n  base64: {},\n  base58: {},\n  baseN : {\n    encode: baseN.encode,\n    decode: baseN.decode\n  }\n};\n\n/**\n * Encodes a Uint8Array as a binary-encoded string. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param bytes the Uint8Array to encode.\n *\n * @return the binary-encoded string.\n */\nutil.binary.raw.encode = function(bytes) {\n  return String.fromCharCode.apply(null, bytes);\n};\n\n/**\n * Decodes a binary-encoded string to a Uint8Array. This encoding uses\n * a value between 0 and 255 for each character.\n *\n * @param str the binary-encoded string to decode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.raw.decode = function(str, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length);\n  }\n  offset = offset || 0;\n  var j = offset;\n  for(var i = 0; i < str.length; ++i) {\n    out[j++] = str.charCodeAt(i);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or\n * ByteBuffer as a string of hexadecimal characters.\n *\n * @param bytes the bytes to convert.\n *\n * @return the string of hexadecimal characters.\n */\nutil.binary.hex.encode = util.bytesToHex;\n\n/**\n * Decodes a hex-encoded string to a Uint8Array.\n *\n * @param hex the hexadecimal string to convert.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.hex.decode = function(hex, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(Math.ceil(hex.length / 2));\n  }\n  offset = offset || 0;\n  var i = 0, j = offset;\n  if(hex.length & 1) {\n    // odd number of characters, convert first character alone\n    i = 1;\n    out[j++] = parseInt(hex[0], 16);\n  }\n  // convert 2 characters (1 byte) at a time\n  for(; i < hex.length; i += 2) {\n    out[j++] = parseInt(hex.substr(i, 2), 16);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Base64-encodes a Uint8Array.\n *\n * @param input the Uint8Array to encode.\n * @param maxline the maximum number of encoded characters per line to use,\n *          defaults to none.\n *\n * @return the base64-encoded output string.\n */\nutil.binary.base64.encode = function(input, maxline) {\n  var line = '';\n  var output = '';\n  var chr1, chr2, chr3;\n  var i = 0;\n  while(i < input.byteLength) {\n    chr1 = input[i++];\n    chr2 = input[i++];\n    chr3 = input[i++];\n\n    // encode 4 character group\n    line += _base64.charAt(chr1 >> 2);\n    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\n    if(isNaN(chr2)) {\n      line += '==';\n    } else {\n      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\n      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);\n    }\n\n    if(maxline && line.length > maxline) {\n      output += line.substr(0, maxline) + '\\r\\n';\n      line = line.substr(maxline);\n    }\n  }\n  output += line;\n  return output;\n};\n\n/**\n * Decodes a base64-encoded string to a Uint8Array.\n *\n * @param input the base64-encoded input string.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.binary.base64.decode = function(input, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(Math.ceil(input.length / 4) * 3);\n  }\n\n  // remove all non-base64 characters\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n  offset = offset || 0;\n  var enc1, enc2, enc3, enc4;\n  var i = 0, j = offset;\n\n  while(i < input.length) {\n    enc1 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc2 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc3 = _base64Idx[input.charCodeAt(i++) - 43];\n    enc4 = _base64Idx[input.charCodeAt(i++) - 43];\n\n    out[j++] = (enc1 << 2) | (enc2 >> 4);\n    if(enc3 !== 64) {\n      // decoded at least 2 bytes\n      out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);\n      if(enc4 !== 64) {\n        // decoded 3 bytes\n        out[j++] = ((enc3 & 3) << 6) | enc4;\n      }\n    }\n  }\n\n  // make sure result is the exact decoded length\n  return output ? (j - offset) : out.subarray(0, j);\n};\n\n// add support for base58 encoding/decoding with Bitcoin alphabet\nutil.binary.base58.encode = function(input, maxline) {\n  return util.binary.baseN.encode(input, _base58, maxline);\n};\nutil.binary.base58.decode = function(input, maxline) {\n  return util.binary.baseN.decode(input, _base58, maxline);\n};\n\n// text encoding/decoding tools\n// FIXME: Experimental. Do not use yet.\nutil.text = {\n  utf8: {},\n  utf16: {}\n};\n\n/**\n * Encodes the given string as UTF-8 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.text.utf8.encode = function(str, output, offset) {\n  str = util.encodeUtf8(str);\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length);\n  }\n  offset = offset || 0;\n  var j = offset;\n  for(var i = 0; i < str.length; ++i) {\n    out[j++] = str.charCodeAt(i);\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Decodes the UTF-8 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */\nutil.text.utf8.decode = function(bytes) {\n  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));\n};\n\n/**\n * Encodes the given string as UTF-16 in a Uint8Array.\n *\n * @param str the string to encode.\n * @param [output] an optional Uint8Array to write the output to; if it\n *          is too small, an exception will be thrown.\n * @param [offset] the start offset for writing to the output (default: 0).\n *\n * @return the Uint8Array or the number of bytes written if output was given.\n */\nutil.text.utf16.encode = function(str, output, offset) {\n  var out = output;\n  if(!out) {\n    out = new Uint8Array(str.length * 2);\n  }\n  var view = new Uint16Array(out.buffer);\n  offset = offset || 0;\n  var j = offset;\n  var k = offset;\n  for(var i = 0; i < str.length; ++i) {\n    view[k++] = str.charCodeAt(i);\n    j += 2;\n  }\n  return output ? (j - offset) : out;\n};\n\n/**\n * Decodes the UTF-16 contents from a Uint8Array.\n *\n * @param bytes the Uint8Array to decode.\n *\n * @return the resulting string.\n */\nutil.text.utf16.decode = function(bytes) {\n  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));\n};\n\n/**\n * Deflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true to return only raw deflate data, false to include zlib\n *          header and trailer.\n *\n * @return the deflated data as a string.\n */\nutil.deflate = function(api, bytes, raw) {\n  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);\n\n  // strip zlib header and trailer if necessary\n  if(raw) {\n    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that\n    // there is a 4-byte DICT (alder-32) block before the data if\n    // its 5th bit is set\n    var start = 2;\n    var flg = bytes.charCodeAt(1);\n    if(flg & 0x20) {\n      start = 6;\n    }\n    // zlib trailer is 4 bytes of adler-32\n    bytes = bytes.substring(start, bytes.length - 4);\n  }\n\n  return bytes;\n};\n\n/**\n * Inflates the given data using a flash interface.\n *\n * @param api the flash interface.\n * @param bytes the data.\n * @param raw true if the incoming data has no zlib header or trailer and is\n *          raw DEFLATE data.\n *\n * @return the inflated data as a string, null on error.\n */\nutil.inflate = function(api, bytes, raw) {\n  // TODO: add zlib header and trailer if necessary/possible\n  var rval = api.inflate(util.encode64(bytes)).rval;\n  return (rval === null) ? null : util.decode64(rval);\n};\n\n/**\n * Sets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param obj the storage object, null to remove.\n */\nvar _setStorageObject = function(api, id, obj) {\n  if(!api) {\n    throw new Error('WebStorage not available.');\n  }\n\n  var rval;\n  if(obj === null) {\n    rval = api.removeItem(id);\n  } else {\n    // json-encode and base64-encode object\n    obj = util.encode64(JSON.stringify(obj));\n    rval = api.setItem(id, obj);\n  }\n\n  // handle potential flash error\n  if(typeof(rval) !== 'undefined' && rval.rval !== true) {\n    var error = new Error(rval.error.message);\n    error.id = rval.error.id;\n    error.name = rval.error.name;\n    throw error;\n  }\n};\n\n/**\n * Gets a storage object.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n *\n * @return the storage object entry or null if none exists.\n */\nvar _getStorageObject = function(api, id) {\n  if(!api) {\n    throw new Error('WebStorage not available.');\n  }\n\n  // get the existing entry\n  var rval = api.getItem(id);\n\n  /* Note: We check api.init because we can't do (api == localStorage)\n    on IE because of \"Class doesn't support Automation\" exception. Only\n    the flash api has an init method so this works too, but we need a\n    better solution in the future. */\n\n  // flash returns item wrapped in an object, handle special case\n  if(api.init) {\n    if(rval.rval === null) {\n      if(rval.error) {\n        var error = new Error(rval.error.message);\n        error.id = rval.error.id;\n        error.name = rval.error.name;\n        throw error;\n      }\n      // no error, but also no item\n      rval = null;\n    } else {\n      rval = rval.rval;\n    }\n  }\n\n  // handle decoding\n  if(rval !== null) {\n    // base64-decode and json-decode data\n    rval = JSON.parse(util.decode64(rval));\n  }\n\n  return rval;\n};\n\n/**\n * Stores an item in local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n */\nvar _setItem = function(api, id, key, data) {\n  // get storage object\n  var obj = _getStorageObject(api, id);\n  if(obj === null) {\n    // create a new storage object\n    obj = {};\n  }\n  // update key\n  obj[key] = data;\n\n  // set storage object\n  _setStorageObject(api, id, obj);\n};\n\n/**\n * Gets an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n *\n * @return the item.\n */\nvar _getItem = function(api, id, key) {\n  // get storage object\n  var rval = _getStorageObject(api, id);\n  if(rval !== null) {\n    // return data at key\n    rval = (key in rval) ? rval[key] : null;\n  }\n\n  return rval;\n};\n\n/**\n * Removes an item from local storage.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n */\nvar _removeItem = function(api, id, key) {\n  // get storage object\n  var obj = _getStorageObject(api, id);\n  if(obj !== null && key in obj) {\n    // remove key\n    delete obj[key];\n\n    // see if entry has no keys remaining\n    var empty = true;\n    for(var prop in obj) {\n      empty = false;\n      break;\n    }\n    if(empty) {\n      // remove entry entirely if no keys are left\n      obj = null;\n    }\n\n    // set storage object\n    _setStorageObject(api, id, obj);\n  }\n};\n\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * @param api the storage interface.\n * @param id the storage ID to use.\n */\nvar _clearItems = function(api, id) {\n  _setStorageObject(api, id, null);\n};\n\n/**\n * Calls a storage function.\n *\n * @param func the function to call.\n * @param args the arguments for the function.\n * @param location the location argument.\n *\n * @return the return value from the function.\n */\nvar _callStorageFunction = function(func, args, location) {\n  var rval = null;\n\n  // default storage types\n  if(typeof(location) === 'undefined') {\n    location = ['web', 'flash'];\n  }\n\n  // apply storage types in order of preference\n  var type;\n  var done = false;\n  var exception = null;\n  for(var idx in location) {\n    type = location[idx];\n    try {\n      if(type === 'flash' || type === 'both') {\n        if(args[0] === null) {\n          throw new Error('Flash local storage not available.');\n        }\n        rval = func.apply(this, args);\n        done = (type === 'flash');\n      }\n      if(type === 'web' || type === 'both') {\n        args[0] = localStorage;\n        rval = func.apply(this, args);\n        done = true;\n      }\n    } catch(ex) {\n      exception = ex;\n    }\n    if(done) {\n      break;\n    }\n  }\n\n  if(!done) {\n    throw exception;\n  }\n\n  return rval;\n};\n\n/**\n * Stores an item on local disk.\n *\n * The available types of local storage include 'flash', 'web', and 'both'.\n *\n * The type 'flash' refers to flash local storage (SharedObject). In order\n * to use flash local storage, the 'api' parameter must be valid. The type\n * 'web' refers to WebStorage, if supported by the browser. The type 'both'\n * refers to storing using both 'flash' and 'web', not just one or the\n * other.\n *\n * The location array should list the storage types to use in order of\n * preference:\n *\n * ['flash']: flash only storage\n * ['web']: web only storage\n * ['both']: try to store in both\n * ['flash','web']: store in flash first, but if not available, 'web'\n * ['web','flash']: store in web first, but if not available, 'flash'\n *\n * The location array defaults to: ['web', 'flash']\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param data the data for the item (any javascript object/primitive).\n * @param location an array with the preferred types of storage to use.\n */\nutil.setItem = function(api, id, key, data, location) {\n  _callStorageFunction(_setItem, arguments, location);\n};\n\n/**\n * Gets an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface, null to use only WebStorage.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n *\n * @return the item.\n */\nutil.getItem = function(api, id, key, location) {\n  return _callStorageFunction(_getItem, arguments, location);\n};\n\n/**\n * Removes an item on local disk.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface.\n * @param id the storage ID to use.\n * @param key the key for the item.\n * @param location an array with the preferred types of storage to use.\n */\nutil.removeItem = function(api, id, key, location) {\n  _callStorageFunction(_removeItem, arguments, location);\n};\n\n/**\n * Clears the local disk storage identified by the given ID.\n *\n * Set setItem() for details on storage types.\n *\n * @param api the flash interface if flash is available.\n * @param id the storage ID to use.\n * @param location an array with the preferred types of storage to use.\n */\nutil.clearItems = function(api, id, location) {\n  _callStorageFunction(_clearItems, arguments, location);\n};\n\n/* Storage for query variables */\nvar _queryVariables = null;\n\n/**\n * Returns the window location query variables. Query is parsed on the first\n * call and the same object is returned on subsequent calls. The mapping\n * is from keys to an array of values. Parameters without values will have\n * an object key set but no value added to the value array. Values are\n * unescaped.\n *\n * ...?k1=v1&k2=v2:\n * {\n *   \"k1\": [\"v1\"],\n *   \"k2\": [\"v2\"]\n * }\n *\n * ...?k1=v1&k1=v2:\n * {\n *   \"k1\": [\"v1\", \"v2\"]\n * }\n *\n * ...?k1=v1&k2:\n * {\n *   \"k1\": [\"v1\"],\n *   \"k2\": []\n * }\n *\n * ...?k1=v1&k1:\n * {\n *   \"k1\": [\"v1\"]\n * }\n *\n * ...?k1&k1:\n * {\n *   \"k1\": []\n * }\n *\n * @param query the query string to parse (optional, default to cached\n *          results from parsing window location search query).\n *\n * @return object mapping keys to variables.\n */\nutil.getQueryVariables = function(query) {\n  var parse = function(q) {\n    var rval = {};\n    var kvpairs = q.split('&');\n    for(var i = 0; i < kvpairs.length; i++) {\n      var pos = kvpairs[i].indexOf('=');\n      var key;\n      var val;\n      if(pos > 0) {\n        key = kvpairs[i].substring(0, pos);\n        val = kvpairs[i].substring(pos + 1);\n      } else {\n        key = kvpairs[i];\n        val = null;\n      }\n      if(!(key in rval)) {\n        rval[key] = [];\n      }\n      // disallow overriding object prototype keys\n      if(!(key in Object.prototype) && val !== null) {\n        rval[key].push(unescape(val));\n      }\n    }\n    return rval;\n  };\n\n   var rval;\n   if(typeof(query) === 'undefined') {\n     // set cached variables if needed\n     if(_queryVariables === null) {\n       if(typeof(window) !== 'undefined' && window.location && window.location.search) {\n          // parse window search query\n          _queryVariables = parse(window.location.search.substring(1));\n       } else {\n          // no query variables available\n          _queryVariables = {};\n       }\n     }\n     rval = _queryVariables;\n   } else {\n     // parse given query\n     rval = parse(query);\n   }\n   return rval;\n};\n\n/**\n * Parses a fragment into a path and query. This method will take a URI\n * fragment and break it up as if it were the main URI. For example:\n *    /bar/baz?a=1&b=2\n * results in:\n *    {\n *       path: [\"bar\", \"baz\"],\n *       query: {\"k1\": [\"v1\"], \"k2\": [\"v2\"]}\n *    }\n *\n * @return object with a path array and query object.\n */\nutil.parseFragment = function(fragment) {\n  // default to whole fragment\n  var fp = fragment;\n  var fq = '';\n  // split into path and query if possible at the first '?'\n  var pos = fragment.indexOf('?');\n  if(pos > 0) {\n    fp = fragment.substring(0, pos);\n    fq = fragment.substring(pos + 1);\n  }\n  // split path based on '/' and ignore first element if empty\n  var path = fp.split('/');\n  if(path.length > 0 && path[0] === '') {\n    path.shift();\n  }\n  // convert query into object\n  var query = (fq === '') ? {} : util.getQueryVariables(fq);\n\n  return {\n    pathString: fp,\n    queryString: fq,\n    path: path,\n    query: query\n  };\n};\n\n/**\n * Makes a request out of a URI-like request string. This is intended to\n * be used where a fragment id (after a URI '#') is parsed as a URI with\n * path and query parts. The string should have a path beginning and\n * delimited by '/' and optional query parameters following a '?'. The\n * query should be a standard URL set of key value pairs delimited by\n * '&'. For backwards compatibility the initial '/' on the path is not\n * required. The request object has the following API, (fully described\n * in the method code):\n *    {\n *       path: <the path string part>.\n *       query: <the query string part>,\n *       getPath(i): get part or all of the split path array,\n *       getQuery(k, i): get part or all of a query key array,\n *       getQueryLast(k, _default): get last element of a query key array.\n *    }\n *\n * @return object with request parameters.\n */\nutil.makeRequest = function(reqString) {\n  var frag = util.parseFragment(reqString);\n  var req = {\n    // full path string\n    path: frag.pathString,\n    // full query string\n    query: frag.queryString,\n    /**\n     * Get path or element in path.\n     *\n     * @param i optional path index.\n     *\n     * @return path or part of path if i provided.\n     */\n    getPath: function(i) {\n      return (typeof(i) === 'undefined') ? frag.path : frag.path[i];\n    },\n    /**\n     * Get query, values for a key, or value for a key index.\n     *\n     * @param k optional query key.\n     * @param i optional query key index.\n     *\n     * @return query, values for a key, or value for a key index.\n     */\n    getQuery: function(k, i) {\n      var rval;\n      if(typeof(k) === 'undefined') {\n        rval = frag.query;\n      } else {\n        rval = frag.query[k];\n        if(rval && typeof(i) !== 'undefined') {\n           rval = rval[i];\n        }\n      }\n      return rval;\n    },\n    getQueryLast: function(k, _default) {\n      var rval;\n      var vals = req.getQuery(k);\n      if(vals) {\n        rval = vals[vals.length - 1];\n      } else {\n        rval = _default;\n      }\n      return rval;\n    }\n  };\n  return req;\n};\n\n/**\n * Makes a URI out of a path, an object with query parameters, and a\n * fragment. Uses jQuery.param() internally for query string creation.\n * If the path is an array, it will be joined with '/'.\n *\n * @param path string path or array of strings.\n * @param query object with query parameters. (optional)\n * @param fragment fragment string. (optional)\n *\n * @return string object with request parameters.\n */\nutil.makeLink = function(path, query, fragment) {\n  // join path parts if needed\n  path = jQuery.isArray(path) ? path.join('/') : path;\n\n  var qstr = jQuery.param(query || {});\n  fragment = fragment || '';\n  return path +\n    ((qstr.length > 0) ? ('?' + qstr) : '') +\n    ((fragment.length > 0) ? ('#' + fragment) : '');\n};\n\n/**\n * Check if an object is empty.\n *\n * Taken from:\n * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937\n *\n * @param object the object to check.\n */\nutil.isEmpty = function(obj) {\n  for(var prop in obj) {\n    if(obj.hasOwnProperty(prop)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Format with simple printf-style interpolation.\n *\n * %%: literal '%'\n * %s,%o: convert next argument into a string.\n *\n * @param format the string to format.\n * @param ... arguments to interpolate into the format string.\n */\nutil.format = function(format) {\n  var re = /%./g;\n  // current match\n  var match;\n  // current part\n  var part;\n  // current arg index\n  var argi = 0;\n  // collected parts to recombine later\n  var parts = [];\n  // last index found\n  var last = 0;\n  // loop while matches remain\n  while((match = re.exec(format))) {\n    part = format.substring(last, re.lastIndex - 2);\n    // don't add empty strings (ie, parts between %s%s)\n    if(part.length > 0) {\n      parts.push(part);\n    }\n    last = re.lastIndex;\n    // switch on % code\n    var code = match[0][1];\n    switch(code) {\n    case 's':\n    case 'o':\n      // check if enough arguments were given\n      if(argi < arguments.length) {\n        parts.push(arguments[argi++ + 1]);\n      } else {\n        parts.push('<?>');\n      }\n      break;\n    // FIXME: do proper formating for numbers, etc\n    //case 'f':\n    //case 'd':\n    case '%':\n      parts.push('%');\n      break;\n    default:\n      parts.push('<%' + code + '?>');\n    }\n  }\n  // add trailing part of format string\n  parts.push(format.substring(last));\n  return parts.join('');\n};\n\n/**\n * Formats a number.\n *\n * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/\n */\nutil.formatNumber = function(number, decimals, dec_point, thousands_sep) {\n  // http://kevin.vanzonneveld.net\n  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +     bugfix by: Michael White (http://crestidg.com)\n  // +     bugfix by: Benjamin Lupton\n  // +     bugfix by: Allan Jensen (http://www.winternet.no)\n  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // *     example 1: number_format(1234.5678, 2, '.', '');\n  // *     returns 1: 1234.57\n\n  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;\n  var d = dec_point === undefined ? ',' : dec_point;\n  var t = thousands_sep === undefined ?\n   '.' : thousands_sep, s = n < 0 ? '-' : '';\n  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';\n  var j = (i.length > 3) ? i.length % 3 : 0;\n  return s + (j ? i.substr(0, j) + t : '') +\n    i.substr(j).replace(/(\\d{3})(?=\\d)/g, '$1' + t) +\n    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');\n};\n\n/**\n * Formats a byte size.\n *\n * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/\n */\nutil.formatSize = function(size) {\n  if(size >= 1073741824) {\n    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';\n  } else if(size >= 1048576) {\n    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';\n  } else if(size >= 1024) {\n    size = util.formatNumber(size / 1024, 0) + ' KiB';\n  } else {\n    size = util.formatNumber(size, 0) + ' bytes';\n  }\n  return size;\n};\n\n/**\n * Converts an IPv4 or IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv4 or IPv6 address to convert.\n *\n * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't\n *         be parsed.\n */\nutil.bytesFromIP = function(ip) {\n  if(ip.indexOf('.') !== -1) {\n    return util.bytesFromIPv4(ip);\n  }\n  if(ip.indexOf(':') !== -1) {\n    return util.bytesFromIPv6(ip);\n  }\n  return null;\n};\n\n/**\n * Converts an IPv4 string representation into bytes (in network order).\n *\n * @param ip the IPv4 address to convert.\n *\n * @return the 4-byte address or null if the address can't be parsed.\n */\nutil.bytesFromIPv4 = function(ip) {\n  ip = ip.split('.');\n  if(ip.length !== 4) {\n    return null;\n  }\n  var b = util.createBuffer();\n  for(var i = 0; i < ip.length; ++i) {\n    var num = parseInt(ip[i], 10);\n    if(isNaN(num)) {\n      return null;\n    }\n    b.putByte(num);\n  }\n  return b.getBytes();\n};\n\n/**\n * Converts an IPv6 string representation into bytes (in network order).\n *\n * @param ip the IPv6 address to convert.\n *\n * @return the 16-byte address or null if the address can't be parsed.\n */\nutil.bytesFromIPv6 = function(ip) {\n  var blanks = 0;\n  ip = ip.split(':').filter(function(e) {\n    if(e.length === 0) ++blanks;\n    return true;\n  });\n  var zeros = (8 - ip.length + blanks) * 2;\n  var b = util.createBuffer();\n  for(var i = 0; i < 8; ++i) {\n    if(!ip[i] || ip[i].length === 0) {\n      b.fillWithByte(0, zeros);\n      zeros = 0;\n      continue;\n    }\n    var bytes = util.hexToBytes(ip[i]);\n    if(bytes.length < 2) {\n      b.putByte(0);\n    }\n    b.putBytes(bytes);\n  }\n  return b.getBytes();\n};\n\n/**\n * Converts 4-bytes into an IPv4 string representation or 16-bytes into\n * an IPv6 string representation. The bytes must be in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,\n *         respectively, are given, otherwise null.\n */\nutil.bytesToIP = function(bytes) {\n  if(bytes.length === 4) {\n    return util.bytesToIPv4(bytes);\n  }\n  if(bytes.length === 16) {\n    return util.bytesToIPv6(bytes);\n  }\n  return null;\n};\n\n/**\n * Converts 4-bytes into an IPv4 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv4 string representation or null for an invalid # of bytes.\n */\nutil.bytesToIPv4 = function(bytes) {\n  if(bytes.length !== 4) {\n    return null;\n  }\n  var ip = [];\n  for(var i = 0; i < bytes.length; ++i) {\n    ip.push(bytes.charCodeAt(i));\n  }\n  return ip.join('.');\n};\n\n/**\n * Converts 16-bytes into an IPv16 string representation. The bytes must be\n * in network order.\n *\n * @param bytes the bytes to convert.\n *\n * @return the IPv16 string representation or null for an invalid # of bytes.\n */\nutil.bytesToIPv6 = function(bytes) {\n  if(bytes.length !== 16) {\n    return null;\n  }\n  var ip = [];\n  var zeroGroups = [];\n  var zeroMaxGroup = 0;\n  for(var i = 0; i < bytes.length; i += 2) {\n    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);\n    // canonicalize zero representation\n    while(hex[0] === '0' && hex !== '0') {\n      hex = hex.substr(1);\n    }\n    if(hex === '0') {\n      var last = zeroGroups[zeroGroups.length - 1];\n      var idx = ip.length;\n      if(!last || idx !== last.end + 1) {\n        zeroGroups.push({start: idx, end: idx});\n      } else {\n        last.end = idx;\n        if((last.end - last.start) >\n          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {\n          zeroMaxGroup = zeroGroups.length - 1;\n        }\n      }\n    }\n    ip.push(hex);\n  }\n  if(zeroGroups.length > 0) {\n    var group = zeroGroups[zeroMaxGroup];\n    // only shorten group of length > 0\n    if(group.end - group.start > 0) {\n      ip.splice(group.start, group.end - group.start + 1, '');\n      if(group.start === 0) {\n        ip.unshift('');\n      }\n      if(group.end === 7) {\n        ip.push('');\n      }\n    }\n  }\n  return ip.join(':');\n};\n\n/**\n * Estimates the number of processes that can be run concurrently. If\n * creating Web Workers, keep in mind that the main JavaScript process needs\n * its own core.\n *\n * @param options the options to use:\n *          update true to force an update (not use the cached value).\n * @param callback(err, max) called once the operation completes.\n */\nutil.estimateCores = function(options, callback) {\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  if('cores' in util && !options.update) {\n    return callback(null, util.cores);\n  }\n  if(typeof navigator !== 'undefined' &&\n    'hardwareConcurrency' in navigator &&\n    navigator.hardwareConcurrency > 0) {\n    util.cores = navigator.hardwareConcurrency;\n    return callback(null, util.cores);\n  }\n  if(typeof Worker === 'undefined') {\n    // workers not available\n    util.cores = 1;\n    return callback(null, util.cores);\n  }\n  if(typeof Blob === 'undefined') {\n    // can't estimate, default to 2\n    util.cores = 2;\n    return callback(null, util.cores);\n  }\n\n  // create worker concurrency estimation code as blob\n  var blobUrl = URL.createObjectURL(new Blob(['(',\n    function() {\n      self.addEventListener('message', function(e) {\n        // run worker for 4 ms\n        var st = Date.now();\n        var et = st + 4;\n        while(Date.now() < et);\n        self.postMessage({st: st, et: et});\n      });\n    }.toString(),\n  ')()'], {type: 'application/javascript'}));\n\n  // take 5 samples using 16 workers\n  sample([], 5, 16);\n\n  function sample(max, samples, numWorkers) {\n    if(samples === 0) {\n      // get overlap average\n      var avg = Math.floor(max.reduce(function(avg, x) {\n        return avg + x;\n      }, 0) / max.length);\n      util.cores = Math.max(1, avg);\n      URL.revokeObjectURL(blobUrl);\n      return callback(null, util.cores);\n    }\n    map(numWorkers, function(err, results) {\n      max.push(reduce(numWorkers, results));\n      sample(max, samples - 1, numWorkers);\n    });\n  }\n\n  function map(numWorkers, callback) {\n    var workers = [];\n    var results = [];\n    for(var i = 0; i < numWorkers; ++i) {\n      var worker = new Worker(blobUrl);\n      worker.addEventListener('message', function(e) {\n        results.push(e.data);\n        if(results.length === numWorkers) {\n          for(var i = 0; i < numWorkers; ++i) {\n            workers[i].terminate();\n          }\n          callback(null, results);\n        }\n      });\n      workers.push(worker);\n    }\n    for(var i = 0; i < numWorkers; ++i) {\n      workers[i].postMessage(i);\n    }\n  }\n\n  function reduce(numWorkers, results) {\n    // find overlapping time windows\n    var overlaps = [];\n    for(var n = 0; n < numWorkers; ++n) {\n      var r1 = results[n];\n      var overlap = overlaps[n] = [];\n      for(var i = 0; i < numWorkers; ++i) {\n        if(n === i) {\n          continue;\n        }\n        var r2 = results[i];\n        if((r1.st > r2.st && r1.st < r2.et) ||\n          (r2.st > r1.st && r2.st < r1.et)) {\n          overlap.push(i);\n        }\n      }\n    }\n    // get maximum overlaps ... don't include overlapping worker itself\n    // as the main JS process was also being scheduled during the work and\n    // would have to be subtracted from the estimate anyway\n    return overlaps.reduce(function(max, overlap) {\n      return Math.max(max, overlap.length);\n    }, 0);\n  }\n};\n", "/**\n * XmlHttpRequest implementation that uses TLS and flash SocketPool.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./socket');\nrequire('./http');\n\n/* XHR API */\nvar xhrApi = module.exports = forge.xhr = forge.xhr || {};\n\n(function($) {\n\n// logging category\nvar cat = 'forge.xhr';\n\n/*\nXMLHttpRequest interface definition from:\nhttp://www.w3.org/TR/XMLHttpRequest\n\ninterface XMLHttpRequest {\n  // event handler\n  attribute EventListener onreadystatechange;\n\n  // state\n  const unsigned short UNSENT = 0;\n  const unsigned short OPENED = 1;\n  const unsigned short HEADERS_RECEIVED = 2;\n  const unsigned short LOADING = 3;\n  const unsigned short DONE = 4;\n  readonly attribute unsigned short readyState;\n\n  // request\n  void open(in DOMString method, in DOMString url);\n  void open(in DOMString method, in DOMString url, in boolean async);\n  void open(in DOMString method, in DOMString url,\n            in boolean async, in DOMString user);\n  void open(in DOMString method, in DOMString url,\n            in boolean async, in DOMString user, in DOMString password);\n  void setRequestHeader(in DOMString header, in DOMString value);\n  void send();\n  void send(in DOMString data);\n  void send(in Document data);\n  void abort();\n\n  // response\n  DOMString getAllResponseHeaders();\n  DOMString getResponseHeader(in DOMString header);\n  readonly attribute DOMString responseText;\n  readonly attribute Document responseXML;\n  readonly attribute unsigned short status;\n  readonly attribute DOMString statusText;\n};\n*/\n\n// readyStates\nvar UNSENT = 0;\nvar OPENED = 1;\nvar HEADERS_RECEIVED = 2;\nvar LOADING = 3;\nvar DONE = 4;\n\n// exceptions\nvar INVALID_STATE_ERR = 11;\nvar SYNTAX_ERR = 12;\nvar SECURITY_ERR = 18;\nvar NETWORK_ERR = 19;\nvar ABORT_ERR = 20;\n\n// private flash socket pool vars\nvar _sp = null;\nvar _policyPort = 0;\nvar _policyUrl = null;\n\n// default client (used if no special URL provided when creating an XHR)\nvar _client = null;\n\n// all clients including the default, key'd by full base url\n// (multiple cross-domain http clients are permitted so there may be more\n// than one client in this map)\n// TODO: provide optional clean up API for non-default clients\nvar _clients = {};\n\n// the default maximum number of concurrents connections per client\nvar _maxConnections = 10;\n\nvar net = forge.net;\nvar http = forge.http;\n\n/**\n * Initializes flash XHR support.\n *\n * @param options:\n *   url: the default base URL to connect to if xhr URLs are relative,\n *     ie: https://myserver.com.\n *   flashId: the dom ID of the flash SocketPool.\n *   policyPort: the port that provides the server's flash policy, 0 to use\n *     the flash default.\n *   policyUrl: the policy file URL to use instead of a policy port.\n *   msie: true if browser is internet explorer, false if not.\n *   connections: the maximum number of concurrent connections.\n *   caCerts: a list of PEM-formatted certificates to trust.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   verify: optional TLS certificate verify callback to use (see forge.tls\n *     for details).\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side private\n *     key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side signature\n *     (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local storage,\n *     false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on their\n *     creation so that they will cache TLS sessions for reuse.\n */\nxhrApi.init = function(options) {\n  forge.log.debug(cat, 'initializing', options);\n\n  // update default policy port and max connections\n  _policyPort = options.policyPort || _policyPort;\n  _policyUrl = options.policyUrl || _policyUrl;\n  _maxConnections = options.connections || _maxConnections;\n\n  // create the flash socket pool\n  _sp = net.createSocketPool({\n    flashId: options.flashId,\n    policyPort: _policyPort,\n    policyUrl: _policyUrl,\n    msie: options.msie || false\n  });\n\n  // create default http client\n  _client = http.createClient({\n    url: options.url || (\n      window.location.protocol + '//' + window.location.host),\n    socketPool: _sp,\n    policyPort: _policyPort,\n    policyUrl: _policyUrl,\n    connections: options.connections || _maxConnections,\n    caCerts: options.caCerts,\n    cipherSuites: options.cipherSuites,\n    persistCookies: options.persistCookies || true,\n    primeTlsSockets: options.primeTlsSockets || false,\n    verify: options.verify,\n    getCertificate: options.getCertificate,\n    getPrivateKey: options.getPrivateKey,\n    getSignature: options.getSignature\n  });\n  _clients[_client.url.origin] = _client;\n\n  forge.log.debug(cat, 'ready');\n};\n\n/**\n * Called to clean up the clients and socket pool.\n */\nxhrApi.cleanup = function() {\n  // destroy all clients\n  for(var key in _clients) {\n    _clients[key].destroy();\n  }\n  _clients = {};\n  _client = null;\n\n  // destroy socket pool\n  _sp.destroy();\n  _sp = null;\n};\n\n/**\n * Sets a cookie.\n *\n * @param cookie the cookie with parameters:\n *   name: the name of the cookie.\n *   value: the value of the cookie.\n *   comment: an optional comment string.\n *   maxAge: the age of the cookie in seconds relative to created time.\n *   secure: true if the cookie must be sent over a secure protocol.\n *   httpOnly: true to restrict access to the cookie from javascript\n *     (inaffective since the cookies are stored in javascript).\n *   path: the path for the cookie.\n *   domain: optional domain the cookie belongs to (must start with dot).\n *   version: optional version of the cookie.\n *   created: creation time, in UTC seconds, of the cookie.\n */\nxhrApi.setCookie = function(cookie) {\n  // default cookie expiration to never\n  cookie.maxAge = cookie.maxAge || -1;\n\n  // if the cookie's domain is set, use the appropriate client\n  if(cookie.domain) {\n    // add the cookies to the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, cookie) &&\n        client.secure === cookie.secure) {\n        client.setCookie(cookie);\n      }\n    }\n  } else {\n    // use the default domain\n    // FIXME: should a null domain cookie be added to all clients? should\n    // this be an option?\n    _client.setCookie(cookie);\n  }\n};\n\n/**\n * Gets a cookie.\n *\n * @param name the name of the cookie.\n * @param path an optional path for the cookie (if there are multiple cookies\n *          with the same name but different paths).\n * @param domain an optional domain for the cookie (if not using the default\n *          domain).\n *\n * @return the cookie, cookies (if multiple matches), or null if not found.\n */\nxhrApi.getCookie = function(name, path, domain) {\n  var rval = null;\n\n  if(domain) {\n    // get the cookies from the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, domain)) {\n        var cookie = client.getCookie(name, path);\n        if(cookie !== null) {\n          if(rval === null) {\n            rval = cookie;\n          } else if(!forge.util.isArray(rval)) {\n            rval = [rval, cookie];\n          } else {\n            rval.push(cookie);\n          }\n        }\n      }\n    }\n  } else {\n    // get cookie from default domain\n    rval = _client.getCookie(name, path);\n  }\n\n  return rval;\n};\n\n/**\n * Removes a cookie.\n *\n * @param name the name of the cookie.\n * @param path an optional path for the cookie (if there are multiple cookies\n *          with the same name but different paths).\n * @param domain an optional domain for the cookie (if not using the default\n *          domain).\n *\n * @return true if a cookie was removed, false if not.\n */\nxhrApi.removeCookie = function(name, path, domain) {\n  var rval = false;\n\n  if(domain) {\n    // remove the cookies from the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, domain)) {\n        if(client.removeCookie(name, path)) {\n           rval = true;\n        }\n      }\n    }\n  } else {\n    // remove cookie from default domain\n    rval = _client.removeCookie(name, path);\n  }\n\n  return rval;\n};\n\n/**\n * Creates a new XmlHttpRequest. By default the base URL, flash policy port,\n * etc, will be used. However, an XHR can be created to point at another\n * cross-domain URL.\n *\n * @param options:\n *   logWarningOnError: If true and an HTTP error status code is received then\n *     log a warning, otherwise log a verbose message.\n *   verbose: If true be very verbose in the output including the response\n *     event and response body, otherwise only include status, timing, and\n *     data size.\n *   logError: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logWarning: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logDebug: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logVerbose: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   url: the default base URL to connect to if xhr URLs are relative,\n *     eg: https://myserver.com, and note that the following options will be\n *     ignored if the URL is absent or the same as the default base URL.\n *   policyPort: the port that provides the server's flash policy, 0 to use\n *     the flash default.\n *   policyUrl: the policy file URL to use instead of a policy port.\n *   connections: the maximum number of concurrent connections.\n *   caCerts: a list of PEM-formatted certificates to trust.\n *   cipherSuites: an optional array of cipher suites to use, see\n *     forge.tls.CipherSuites.\n *   verify: optional TLS certificate verify callback to use (see forge.tls\n *     for details).\n *   getCertificate: an optional callback used to get a client-side\n *     certificate.\n *   getPrivateKey: an optional callback used to get a client-side private key.\n *   getSignature: an optional callback used to get a client-side signature.\n *   persistCookies: true to use persistent cookies via flash local storage,\n *     false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on their\n *     creation so that they will cache TLS sessions for reuse.\n *\n * @return the XmlHttpRequest.\n */\nxhrApi.create = function(options) {\n  // set option defaults\n  options = $.extend({\n    logWarningOnError: true,\n    verbose: false,\n    logError: function() {},\n    logWarning: function() {},\n    logDebug: function() {},\n    logVerbose: function() {},\n    url: null\n  }, options || {});\n\n  // private xhr state\n  var _state = {\n    // the http client to use\n    client: null,\n    // request storage\n    request: null,\n    // response storage\n    response: null,\n    // asynchronous, true if doing asynchronous communication\n    asynchronous: true,\n    // sendFlag, true if send has been called\n    sendFlag: false,\n    // errorFlag, true if a network error occurred\n    errorFlag: false\n  };\n\n  // private log functions\n  var _log = {\n    error: options.logError || forge.log.error,\n    warning: options.logWarning || forge.log.warning,\n    debug: options.logDebug || forge.log.debug,\n    verbose: options.logVerbose || forge.log.verbose\n  };\n\n  // create public xhr interface\n  var xhr = {\n    // an EventListener\n    onreadystatechange: null,\n    // readonly, the current readyState\n    readyState: UNSENT,\n    // a string with the response entity-body\n    responseText: '',\n    // a Document for response entity-bodies that are XML\n    responseXML: null,\n    // readonly, returns the HTTP status code (i.e. 404)\n    status: 0,\n    // readonly, returns the HTTP status message (i.e. 'Not Found')\n    statusText: ''\n  };\n\n  // determine which http client to use\n  if(options.url === null) {\n    // use default\n    _state.client = _client;\n  } else {\n    var url;\n    try {\n      url = new URL(options.url);\n    } catch(e) {\n      var error = new Error('Invalid url.');\n      error.details = {\n        url: options.url\n      };\n    }\n\n    // find client\n    if(url.origin in _clients) {\n      // client found\n      _state.client = _clients[url.origin];\n    } else {\n      // create client\n      _state.client = http.createClient({\n        url: options.url,\n        socketPool: _sp,\n        policyPort: options.policyPort || _policyPort,\n        policyUrl: options.policyUrl || _policyUrl,\n        connections: options.connections || _maxConnections,\n        caCerts: options.caCerts,\n        cipherSuites: options.cipherSuites,\n        persistCookies: options.persistCookies || true,\n        primeTlsSockets: options.primeTlsSockets || false,\n        verify: options.verify,\n        getCertificate: options.getCertificate,\n        getPrivateKey: options.getPrivateKey,\n        getSignature: options.getSignature\n      });\n      _clients[url.origin] = _state.client;\n    }\n  }\n\n  /**\n   * Opens the request. This method will create the HTTP request to send.\n   *\n   * @param method the HTTP method (i.e. 'GET').\n   * @param url the relative url (the HTTP request path).\n   * @param async always true, ignored.\n   * @param user always null, ignored.\n   * @param password always null, ignored.\n   */\n  xhr.open = function(method, url, async, user, password) {\n    // 1. validate Document if one is associated\n    // TODO: not implemented (not used yet)\n\n    // 2. validate method token\n    // 3. change method to uppercase if it matches a known\n    // method (here we just require it to be uppercase, and\n    // we do not allow the standard methods)\n    // 4. disallow CONNECT, TRACE, or TRACK with a security error\n    switch(method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'PATCH':\n    case 'POST':\n    case 'PUT':\n      // valid method\n      break;\n    case 'CONNECT':\n    case 'TRACE':\n    case 'TRACK':\n      throw new Error('CONNECT, TRACE and TRACK methods are disallowed');\n    default:\n      throw new Error('Invalid method: ' + method);\n    }\n\n    // TODO: other validation steps in algorithm are not implemented\n\n    // 19. set send flag to false\n    // set response body to null\n    // empty list of request headers\n    // set request method to given method\n    // set request URL\n    // set username, password\n    // set asychronous flag\n    _state.sendFlag = false;\n    xhr.responseText = '';\n    xhr.responseXML = null;\n\n    // custom: reset status and statusText\n    xhr.status = 0;\n    xhr.statusText = '';\n\n    // create the HTTP request\n    _state.request = http.createRequest({\n      method: method,\n      path: url\n    });\n\n    // 20. set state to OPENED\n    xhr.readyState = OPENED;\n\n    // 21. dispatch onreadystatechange\n    if(xhr.onreadystatechange) {\n       xhr.onreadystatechange();\n    }\n  };\n\n  /**\n   * Adds an HTTP header field to the request.\n   *\n   * @param header the name of the header field.\n   * @param value the value of the header field.\n   */\n  xhr.setRequestHeader = function(header, value) {\n    // 1. if state is not OPENED or send flag is true, raise exception\n    if(xhr.readyState != OPENED || _state.sendFlag) {\n      throw new Error('XHR not open or sending');\n    }\n\n    // TODO: other validation steps in spec aren't implemented\n\n    // set header\n    _state.request.setField(header, value);\n  };\n\n  /**\n   * Sends the request and any associated data.\n   *\n   * @param data a string or Document object to send, null to send no data.\n   */\n  xhr.send = function(data) {\n    // 1. if state is not OPENED or 2. send flag is true, raise\n    // an invalid state exception\n    if(xhr.readyState != OPENED || _state.sendFlag) {\n      throw new Error('XHR not open or sending');\n    }\n\n    // 3. ignore data if method is GET or HEAD\n    if(data &&\n      _state.request.method !== 'GET' &&\n      _state.request.method !== 'HEAD') {\n      // handle non-IE case\n      if(typeof(XMLSerializer) !== 'undefined') {\n        if(data instanceof Document) {\n          var xs = new XMLSerializer();\n          _state.request.body = xs.serializeToString(data);\n        } else {\n          _state.request.body = data;\n        }\n      } else {\n        // poorly implemented IE case\n        if(typeof(data.xml) !== 'undefined') {\n          _state.request.body = data.xml;\n        } else {\n          _state.request.body = data;\n        }\n      }\n    }\n\n    // 4. release storage mutex (not used)\n\n    // 5. set error flag to false\n    _state.errorFlag = false;\n\n    // 6. if asynchronous is true (must be in this implementation)\n\n    // 6.1 set send flag to true\n    _state.sendFlag = true;\n\n    // 6.2 dispatch onreadystatechange\n    if(xhr.onreadystatechange) {\n      xhr.onreadystatechange();\n    }\n\n    // create send options\n    var options = {};\n    options.request = _state.request;\n    options.headerReady = function(e) {\n      // make cookies available for ease of use/iteration\n      xhr.cookies = _state.client.cookies;\n\n      // TODO: update document.cookie with any cookies where the\n      // script's domain matches\n\n      // headers received\n      xhr.readyState = HEADERS_RECEIVED;\n      xhr.status = e.response.code;\n      xhr.statusText = e.response.message;\n      _state.response = e.response;\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n      if(!_state.response.aborted) {\n        // now loading body\n        xhr.readyState = LOADING;\n        if(xhr.onreadystatechange) {\n           xhr.onreadystatechange();\n        }\n      }\n    };\n    options.bodyReady = function(e) {\n      xhr.readyState = DONE;\n      var ct = e.response.getField('Content-Type');\n      // Note: this null/undefined check is done outside because IE\n      // dies otherwise on a \"'null' is null\" error\n      if(ct) {\n        if(ct.indexOf('text/xml') === 0 ||\n          ct.indexOf('application/xml') === 0 ||\n          ct.indexOf('+xml') !== -1) {\n          try {\n            var doc = new ActiveXObject('MicrosoftXMLDOM');\n            doc.async = false;\n            doc.loadXML(e.response.body);\n            xhr.responseXML = doc;\n          } catch(ex) {\n            var parser = new DOMParser();\n            xhr.responseXML = parser.parseFromString(ex.body, 'text/xml');\n          }\n        }\n      }\n\n      var length = 0;\n      if(e.response.body !== null) {\n        xhr.responseText = e.response.body;\n        length = e.response.body.length;\n      }\n      // build logging output\n      var req = _state.request;\n      var output =\n        req.method + ' ' + req.path + ' ' +\n        xhr.status + ' ' + xhr.statusText + ' ' +\n        length + 'B ' +\n        (e.request.connectTime + e.request.time + e.response.time) +\n        'ms';\n      var lFunc;\n      if(options.verbose) {\n        lFunc = (xhr.status >= 400 && options.logWarningOnError) ?\n          _log.warning : _log.verbose;\n        lFunc(cat, output,\n          e, e.response.body ? '\\n' + e.response.body : '\\nNo content');\n      } else {\n        lFunc = (xhr.status >= 400 && options.logWarningOnError) ?\n          _log.warning : _log.debug;\n        lFunc(cat, output);\n      }\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n    options.error = function(e) {\n      var req = _state.request;\n      _log.error(cat, req.method + ' ' + req.path, e);\n\n      // 1. set response body to null\n      xhr.responseText = '';\n      xhr.responseXML = null;\n\n      // 2. set error flag to true (and reset status)\n      _state.errorFlag = true;\n      xhr.status = 0;\n      xhr.statusText = '';\n\n      // 3. set state to done\n      xhr.readyState = DONE;\n\n      // 4. asyc flag is always true, so dispatch onreadystatechange\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n\n    // 7. send request\n    _state.client.send(options);\n  };\n\n  /**\n   * Aborts the request.\n   */\n  xhr.abort = function() {\n    // 1. abort send\n    // 2. stop network activity\n    _state.request.abort();\n\n    // 3. set response to null\n    xhr.responseText = '';\n    xhr.responseXML = null;\n\n    // 4. set error flag to true (and reset status)\n    _state.errorFlag = true;\n    xhr.status = 0;\n    xhr.statusText = '';\n\n    // 5. clear user headers\n    _state.request = null;\n    _state.response = null;\n\n    // 6. if state is DONE or UNSENT, or if OPENED and send flag is false\n    if(xhr.readyState === DONE || xhr.readyState === UNSENT ||\n     (xhr.readyState === OPENED && !_state.sendFlag)) {\n      // 7. set ready state to unsent\n      xhr.readyState = UNSENT;\n    } else {\n      // 6.1 set state to DONE\n      xhr.readyState = DONE;\n\n      // 6.2 set send flag to false\n      _state.sendFlag = false;\n\n      // 6.3 dispatch onreadystatechange\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n\n      // 7. set state to UNSENT\n      xhr.readyState = UNSENT;\n    }\n  };\n\n  /**\n   * Gets all response headers as a string.\n   *\n   * @return the HTTP-encoded response header fields.\n   */\n  xhr.getAllResponseHeaders = function() {\n    var rval = '';\n    if(_state.response !== null) {\n      var fields = _state.response.fields;\n      $.each(fields, function(name, array) {\n        $.each(array, function(i, value) {\n          rval += name + ': ' + value + '\\r\\n';\n        });\n      });\n    }\n    return rval;\n  };\n\n  /**\n   * Gets a single header field value or, if there are multiple\n   * fields with the same name, a comma-separated list of header\n   * values.\n   *\n   * @return the header field value(s) or null.\n   */\n  xhr.getResponseHeader = function(header) {\n    var rval = null;\n    if(_state.response !== null) {\n      if(header in _state.response.fields) {\n        rval = _state.response.fields[header];\n        if(forge.util.isArray(rval)) {\n          rval = rval.join();\n        }\n      }\n    }\n    return rval;\n  };\n\n  return xhr;\n};\n\n})(jQuery);\n", "{\n  \"name\": \"node-forge\",\n  \"version\": \"0.10.1-dev\",\n  \"description\": \"JavaScript implementations of network transports, cryptography, ciphers, PKI, message digests, and various utilities.\",\n  \"homepage\": \"https://github.com/digitalbazaar/forge\",\n  \"author\": {\n    \"name\": \"Digital Bazaar, Inc.\",\n    \"email\": \"support@digitalbazaar.com\",\n    \"url\": \"http://digitalbazaar.com/\"\n  },\n  \"contributors\": [\n    \"Dave Longley <dlongley@digitalbazaar.com>\",\n    \"David I. Lehn <dlehn@digitalbazaar.com>\",\n    \"Stefan Siegl <stesie@brokenpipe.de>\",\n    \"Christoph Dorn <christoph@christophdorn.com>\"\n  ],\n  \"devDependencies\": {\n    \"browserify\": \"^16.5.2\",\n    \"commander\": \"^2.20.0\",\n    \"cross-env\": \"^5.2.1\",\n    \"eslint\": \"^7.27.0\",\n    \"eslint-config-digitalbazaar\": \"^2.8.0\",\n    \"express\": \"^4.16.2\",\n    \"karma\": \"^4.4.1\",\n    \"karma-browserify\": \"^7.0.0\",\n    \"karma-chrome-launcher\": \"^3.1.0\",\n    \"karma-edge-launcher\": \"^0.4.2\",\n    \"karma-firefox-launcher\": \"^1.3.0\",\n    \"karma-ie-launcher\": \"^1.0.0\",\n    \"karma-mocha\": \"^1.3.0\",\n    \"karma-mocha-reporter\": \"^2.2.5\",\n    \"karma-safari-launcher\": \"^1.0.0\",\n    \"karma-sauce-launcher\": \"^2.0.2\",\n    \"karma-sourcemap-loader\": \"^0.3.8\",\n    \"karma-tap-reporter\": \"0.0.6\",\n    \"karma-webpack\": \"^4.0.2\",\n    \"mocha\": \"^5.2.0\",\n    \"mocha-lcov-reporter\": \"^1.2.0\",\n    \"nodejs-websocket\": \"^1.7.1\",\n    \"nyc\": \"^15.1.0\",\n    \"opts\": \"^1.2.7\",\n    \"webpack\": \"^4.44.1\",\n    \"webpack-cli\": \"^3.3.12\",\n    \"worker-loader\": \"^2.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/digitalbazaar/forge\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/digitalbazaar/forge/issues\",\n    \"email\": \"support@digitalbazaar.com\"\n  },\n  \"license\": \"(BSD-3-Clause OR GPL-2.0)\",\n  \"main\": \"lib/index.js\",\n  \"files\": [\n    \"lib/*.js\",\n    \"flash/swf/*.swf\",\n    \"dist/*.min.js\",\n    \"dist/*.min.js.map\"\n  ],\n  \"engines\": {\n    \"node\": \">= 6.13.0\"\n  },\n  \"keywords\": [\n    \"aes\",\n    \"asn\",\n    \"asn.1\",\n    \"cbc\",\n    \"crypto\",\n    \"cryptography\",\n    \"csr\",\n    \"des\",\n    \"gcm\",\n    \"hmac\",\n    \"http\",\n    \"https\",\n    \"md5\",\n    \"network\",\n    \"pkcs\",\n    \"pki\",\n    \"prng\",\n    \"rc2\",\n    \"rsa\",\n    \"sha1\",\n    \"sha256\",\n    \"sha384\",\n    \"sha512\",\n    \"ssh\",\n    \"tls\",\n    \"x.509\",\n    \"x509\"\n  ],\n  \"scripts\": {\n    \"prepublish\": \"npm run build\",\n    \"build\": \"webpack\",\n    \"test-build\": \"webpack --config webpack-tests.config.js\",\n    \"test\": \"npm run test-node\",\n    \"test-node\": \"cross-env NODE_ENV=test mocha -t 30000 -R ${REPORTER:-spec} tests/unit/index.js\",\n    \"test-karma\": \"karma start\",\n    \"test-karma-sauce\": \"karma start karma-sauce.conf\",\n    \"test-server\": \"node tests/server.js\",\n    \"test-server-ws\": \"node tests/websockets/server-ws.js\",\n    \"test-server-webid\": \"node tests/websockets/server-webid.js\",\n    \"coverage\": \"rm -rf coverage && nyc --reporter=lcov --reporter=text-summary npm test\",\n    \"coverage-ci\": \"rm -rf coverage && nyc --reporter=lcovonly npm test\",\n    \"coverage-report\": \"nyc report\",\n    \"lint\": \"eslint *.js lib/*.js tests/*.js tests/**/*.js examples/*.js flash/*.js\"\n  },\n  \"nyc\": {\n    \"exclude\": [\n      \"tests\"\n    ]\n  },\n  \"jspm\": {\n    \"format\": \"amd\"\n  },\n  \"browser\": {\n    \"buffer\": false,\n    \"crypto\": false,\n    \"process\": false\n  }\n}\n", "// Forge WebID Test Server\nvar forge = require('../..');\nvar fs = require('fs');\nvar http = require('http');\n//var rdf = require('./rdflib');\nvar urllib = require('url');\nvar ws = require('nodejs-websocket');\n\n// remove xmlns from input\nvar normalizeNs = function(input, ns) {\n  var rval = null;\n\n  // primitive\n  if(typeof input === 'string' ||\n    typeof input === 'number' ||\n    typeof input === 'boolean') {\n    rval = input;\n  }\n  // array\n  else if(forge.util.isArray(input)) {\n    rval = [];\n    for(var i = 0; i < input.length; ++i) {\n      rval.push(normalizeNs(input[i], ns));\n    }\n  }\n  // object\n  else {\n    if('@' in input) {\n      // copy namespace map\n      var newNs = {};\n      for(var key in ns) {\n        newNs[key] = ns[key];\n      }\n      ns = newNs;\n\n      // update namespace map\n      for(var key in input['@']) {\n        if(key.indexOf('xmlns:') === 0) {\n          ns[key.substr(6)] = input['@'][key];\n        }\n      }\n    }\n\n    rval = {};\n    for(var key in input) {\n      if(key.indexOf('xmlns:') !== 0) {\n        var value = input[key];\n        var colon = key.indexOf(':');\n        if(colon !== -1) {\n          var prefix = key.substr(0, colon);\n          if(prefix in ns) {\n            key = ns[prefix] + key.substr(colon + 1);\n          }\n        }\n        rval[key] = normalizeNs(value, ns);\n      }\n    }\n  }\n\n  return rval;\n};\n\n// gets public key from WebID rdf\nvar getPublicKey = function(data, uri, callback) {\n  // FIXME: use RDF library to simplify code below\n  //var kb = new rdf.RDFParser(rdf.IndexedFormula(), uri).loadBuf(data);\n  //var CERT = rdf.Namespace('http://www.w3.org/ns/auth/cert#');\n  //var RSA  = rdf.Namespace('http://www.w3.org/ns/auth/rsa#');\n  var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n  var CERT = 'http://www.w3.org/ns/auth/cert#';\n  var RSA = 'http://www.w3.org/ns/auth/rsa#';\n  var desc = RDF + 'Description';\n  var about = RDF + 'about';\n  var type = RDF + 'type';\n  var resource = RDF + 'resource';\n  var publicKey = RSA + 'RSAPublicKey';\n  var modulus = RSA + 'modulus';\n  var exponent = RSA + 'public_exponent';\n  var identity = CERT + 'identity';\n  var hex = CERT + 'hex';\n  var decimal = CERT + 'decimal';\n\n  // gets a resource identifer from a node\n  var getResource = function(node, key) {\n    var rval = null;\n\n    // special case 'about'\n    if(key === about) {\n      if('@' in node && about in node['@']) {\n        rval = node['@'][about];\n      }\n    }\n    // any other resource\n    else if(\n      key in node &&\n      typeof node[key] === 'object' && !forge.util.isArray(node[key]) &&\n      '@' in node[key] && resource in node[key]['@']) {\n      rval = node[key]['@'][resource];\n    }\n\n    return rval;\n  };\n\n  // parse XML\n  uri = urllib.parse(uri);\n  var xml2js = require('./xml2js');\n  var parser = new xml2js.Parser();\n  parser.addListener('end', function(result) {\n    // normalize namespaces\n    result = normalizeNs(result, {});\n\n    // find grab all public keys whose identity matches hash from uri\n    var keys = [];\n    if(desc in result) {\n      // normalize RDF descriptions to array\n      if(!forge.util.isArray(result[desc])) {\n        desc = [result[desc]];\n      } else {\n        desc = result[desc];\n      }\n\n      // collect properties for all resources\n      var graph = {};\n      for(var i = 0; i < desc.length; ++i) {\n        var node = desc[i];\n        var res = {};\n        for(var key in node) {\n          var obj = getResource(node, key);\n          res[key] = (obj === null) ? node[key] : obj;\n        }\n        graph[getResource(node, about) || ''] = res;\n      }\n\n      // for every public key w/identity that matches the uri hash\n      // save the public key modulus and exponent\n      for(var r in graph) {\n        var props = graph[r];\n        if(identity in props &&\n          type in props &&\n          props[type] === publicKey &&\n          props[identity] === uri.hash &&\n          modulus in props &&\n          exponent in props &&\n          props[modulus] in graph &&\n          props[exponent] in graph &&\n          hex in graph[props[modulus]] &&\n          decimal in graph[props[exponent]]) {\n          keys.push({\n            modulus: graph[props[modulus]][hex],\n            exponent: graph[props[exponent]][decimal]\n          });\n        }\n      }\n    }\n\n    console.log('Public keys from RDF: ' + JSON.stringify(keys));\n    callback(keys);\n  });\n  parser.parseString(data);\n};\n\n// compares two public keys for equality\nvar comparePublicKeys = function(key1, key2) {\n  return key1.modulus === key2.modulus && key1.exponent === key2.exponent;\n};\n\n// gets the RDF data from a URL\nvar fetchUrl = function(url, callback, redirects) {\n  // allow 3 redirects by default\n  if(typeof(redirects) === 'undefined') {\n    redirects = 3;\n  }\n\n  console.log('Fetching URL: \\\"' + url + '\\\"');\n\n  // parse URL\n  url = new URL(url);\n  var client = http.createClient({\n    url: url\n  });\n  var request = client.request('GET', url.path, {\n    Host: url.host,\n    Accept: 'application/rdf+xml'\n  });\n  request.addListener('response', function(response) {\n    var body = '';\n\n    // error, return empty body\n    if(response.statusCode >= 400) {\n      callback(body);\n    }\n    // follow redirect\n    else if(response.statusCode === 302) {\n      if(redirects > 0) {\n        // follow redirect\n        fetchUrl(response.headers.location, callback, --redirects);\n      } else {\n        // return empty body\n        callback(body);\n      }\n    }\n    // handle data\n    else {\n      response.setEncoding('utf8');\n      response.addListener('data', function(chunk) {\n        body += chunk;\n      });\n      response.addListener('end', function() {\n        callback(body);\n      });\n    }\n  });\n  request.end();\n};\n\n// does WebID authentication\nvar authenticateWebId = function(c, state) {\n  var auth = false;\n\n  // get client-certificate\n  var cert = c.peerCertificate;\n\n  // get public key from certificate\n  var publicKey = {\n    modulus: cert.publicKey.n.toString(16).toLowerCase(),\n    exponent: cert.publicKey.e.toString(10)\n  };\n\n  console.log(\n    'Server verifying certificate w/CN: \\\"' +\n    cert.subject.getField('CN').value + '\\\"\\n' +\n    'Public Key: ' + JSON.stringify(publicKey));\n\n  // build queue of subject alternative names to authenticate with\n  var altNames = [];\n  var ext = cert.getExtension({name: 'subjectAltName'});\n  if(ext !== null && ext.altNames) {\n    for(var i = 0; i < ext.altNames.length; ++i) {\n      var altName = ext.altNames[i];\n      if(altName.type === 6) {\n        altNames.push(altName.value);\n      }\n    }\n  }\n\n  // create authentication processor\n  var authNext = function() {\n    if(!auth) {\n      // no more alt names, auth failed\n      if(altNames.length === 0) {\n        console.log('WebID authentication FAILED.');\n        c.prepare(JSON.stringify({\n          success: false,\n          error: 'Not Authenticated'\n        }));\n        c.close();\n      }\n      // try next alt name\n      else {\n        // fetch URL\n        var url = altNames.shift();\n        fetchUrl(url, function(body) {\n          // get public key\n          getPublicKey(body, url, function(keys) {\n            // compare public keys from RDF until one matches\n            for(var i = 0; !auth && i < keys.length; ++i) {\n              auth = comparePublicKeys(keys[i], publicKey);\n            }\n            if(auth) {\n              // send authenticated notice to client\n              console.log('WebID authentication PASSED.');\n              state.authenticated = true;\n              c.prepare(JSON.stringify({\n                success: true,\n                cert: forge.pki.certificateToPem(cert),\n                webID: url,\n                rdf: forge.util.encode64(body)\n              }));\n            } else {\n              // try next alt name\n              authNext();\n            }\n          });\n        });\n      }\n    }\n  };\n\n  // do auth\n  authNext();\n};\n\n// creates credentials (private key + certificate)\nvar createCredentials = function(cn, credentials) {\n  console.log(\n    'Generating 512-bit key-pair and certificate for \\\"' + cn + '\\\".');\n  var keys = forge.pki.rsa.generateKeyPair(512);\n  console.log('key-pair created.');\n\n  var cert = forge.pki.createCertificate();\n  cert.serialNumber = '01';\n  cert.validity.notBefore = new Date();\n  cert.validity.notAfter = new Date();\n  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);\n  var attrs = [{\n    name: 'commonName',\n    value: cn\n  }, {\n    name: 'countryName',\n    value: 'US'\n  }, {\n    shortName: 'ST',\n    value: 'Virginia'\n  }, {\n    name: 'localityName',\n    value: 'Blacksburg'\n  }, {\n    name: 'organizationName',\n    value: 'Test'\n  }, {\n    shortName: 'OU',\n    value: 'Test'\n  }];\n  cert.setSubject(attrs);\n  cert.setIssuer(attrs);\n  cert.setExtensions([{\n    name: 'basicConstraints',\n    cA: true\n  }, {\n    name: 'keyUsage',\n    keyCertSign: true,\n    digitalSignature: true,\n    nonRepudiation: true,\n    keyEncipherment: true,\n    dataEncipherment: true\n  }, {\n    name: 'subjectAltName',\n    altNames: [{\n      type: 6, // URI\n      value: 'http://myuri.com/webid#me'\n    }]\n  }]);\n  // FIXME: add subjectKeyIdentifier extension\n  // FIXME: add authorityKeyIdentifier extension\n  cert.publicKey = keys.publicKey;\n\n  // self-sign certificate\n  cert.sign(keys.privateKey);\n\n  // save credentials\n  credentials.key = forge.pki.privateKeyToPem(keys.privateKey);\n  credentials.cert = forge.pki.certificateToPem(cert);\n\n  console.log('Certificate created for \\\"' + cn + '\\\": \\n' + credentials.cert);\n};\n\n// initialize credentials\nvar credentials = {\n  key: null,\n  cert: null\n};\n\n// read private key from file\nvar readPrivateKey = function(filename) {\n  credentials.key = fs.readFileSync(filename);\n  // try to parse from PEM as test\n  forge.pki.privateKeyFromPem(credentials.key);\n};\n\n// read certificate from file\nvar readCertificate = function(filename) {\n  credentials.cert = fs.readFileSync(filename);\n  // try to parse from PEM as test\n  forge.pki.certificateFromPem(credentials.cert);\n};\n\n// parse command line options\nvar opts = require('opts');\nvar options = [\n{ short       : 'v'\n, long        : 'version'\n, description : 'Show version and exit'\n, callback    : function() { console.log('v1.0'); process.exit(1); }\n},\n{ short       : 'p'\n, long        : 'port'\n, description : 'The port to listen for WebSocket connections on'\n, value       : true\n},\n{ long        : 'key'\n, description : 'The server private key file to use in PEM format'\n, value       : true\n, callback    : readPrivateKey\n},\n{ long        : 'cert'\n, description : 'The server certificate file to use in PEM format'\n, value       : true\n, callback    : readCertificate\n}\n];\nopts.parse(options, true);\n\n// create credentials for server\nif(credentials.key === null || credentials.cert === null) {\n  createCredentials('server', credentials);\n}\n\n// function to create TLS server connection\nvar createTls = function(websocket) {\n  var state = {\n    authenticated: false\n  };\n  return forge.tls.createConnection({\n    server: true,\n    caStore: [],\n    sessionCache: {},\n    // supported cipher suites in order of preference\n    cipherSuites: [\n      forge.tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA,\n      forge.tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA],\n    connected: function(c) {\n      console.log('Server connected');\n\n      // do WebID authentication\n      try {\n        authenticateWebId(c, state);\n      } catch(ex) {\n        c.close();\n      }\n    },\n    verifyClient: true,\n    verify: function(c, verified, depth, certs) {\n      // accept certs w/unknown-CA (48)\n      if(verified === 48) {\n        verified = true;\n      }\n      return verified;\n    },\n    getCertificate: function(c, hint) {\n      console.log('Server using certificate for \\\"' + hint[0] + '\\\"');\n      return credentials.cert;\n    },\n    getPrivateKey: function(c, cert) {\n      return credentials.key;\n    },\n    tlsDataReady: function(c) {\n      // send base64-encoded TLS data over websocket\n      websocket.send(forge.util.encode64(c.tlsData.getBytes()));\n    },\n    dataReady: function(c) {\n      // ignore any data until connection is authenticated\n      if(state.authenticated) {\n        console.log('Server received \\\"' + c.data.getBytes() + '\\\"');\n      }\n    },\n    closed: function(c) {\n      console.log('Server disconnected');\n      websocket.close();\n    },\n    error: function(c, error) {\n      console.log('Server error: ' + error.message);\n    }\n  });\n};\n\n// create websocket server\nlet port = opts.get('port') || 8080;\nlet wsServer = ws\n  .createServer({port: port/*, secure: true*/}, function(websocket) {\n    console.log('[ws-server] connection:', websocket.socket.address());\n\n    // create TLS server connection\n    var tls = createTls(websocket);\n\n    // close connection after 30 seconds\n    let toId = setTimeout(websocket.close, 30 * 1000);\n\n    websocket.on('text', function(data) {\n      //console.log('[ws-server] data:', data);\n      // base64-decode data and process it\n      tls.process(forge.util.decode64(data));\n    });\n\n    websocket.on('close', function() {\n      clearTimeout(toId);\n      console.log('[ws-server]: closed');\n    });\n\n    websocket.on('error', function(err) {\n      console.error('[ws-server]: error:', err);\n    });\n  });\nwsServer.listen(port, () => {\n  console.log('[ws-server] listening:', wsServer.socket.address());\n});\n"], "filenames": ["CHANGELOG.md", "README.md", "lib/http.js", "lib/util.js", "lib/xhr.js", "package.json", "tests/websockets/server-webid.js"], "buggy_code_start_loc": [11, 1971, 36, 2259, 154, 63, 177], "buggy_code_end_loc": [24, 1975, 1344, 2296, 413, 64, 180], "fixing_code_start_loc": [12, 1970, 36, 2258, 154, 63, 177], "fixing_code_end_loc": [41, 1970, 1337, 2258, 415, 64, 181], "type": "CWE-601", "message": "forge is vulnerable to URL Redirection to Untrusted Site", "other": {"cve": {"id": "CVE-2022-0122", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-06T05:15:09.490", "lastModified": "2022-01-12T20:14:22.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "forge is vulnerable to URL Redirection to Untrusted Site"}, {"lang": "es", "value": "forge es vulnerable a una Redirecci\u00f3n de URLs a Sitios no Confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:digitalbazaar:forge:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "A368CA04-F4BA-4F1C-B75D-54369D44E72B"}]}]}], "references": [{"url": "https://github.com/digitalbazaar/forge/commit/db8016c805371e72b06d8e2edfe0ace0df934a5e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/41852c50-3c6d-4703-8c55-4db27164a4ae", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/digitalbazaar/forge/commit/db8016c805371e72b06d8e2edfe0ace0df934a5e"}}