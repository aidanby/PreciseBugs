{"buggy_code": ["## 1.12.1 (2020-11-06)\n\n* Fix format fallback for files ending with a dot on Ruby 2.7+ (@coding-chimp)\n\n## 1.12.0 (2020-09-20)\n\n* Add instrumentation support via `#instrumenter` (@janko)\n\n## 1.11.0 (2020-05-17)\n\n* [minimagick] Handle destination format having no file extension (@janko)\n\n* [minimagick] Disable sharpening on `#resize_*` operators by default (@flori)\n\n* [minimagick] Add `#crop` which accepts `left, top, width, height` arguments (@janko)\n\n## 1.10.3 (2020-01-12)\n\n* [vips] Fix auto-rotation not working in certain cases on libvips 8.9.0 (@janko)\n\n## 1.10.2 (2020-01-11)\n\n* Fix Ruby 2.7 warnings for separation of positional and keyword arguments (@kamipo, @janko)\n\n## 1.10.1 (2020-01-07)\n\n* [vips] Fix compatibility with ruby-vips 2.0.17+ (@janko)\n\n## 1.10.0 (2019-12-18)\n\n* [minimagick] Add `:loader` option for explicitly setting input file type (@janko)\n\n## 1.9.3 (2019-08-11)\n\n* [vips] Use integer precision when sharpening for better quality (@metaskills)\n\n## 1.9.2 (2019-07-22)\n\n* Bump `mini_magick` dependency to `>= 4.9.5` (@chioreandan)\n\n## 1.9.1 (2019-07-20)\n\n* Bring back support for MRI 2.3 (@janko)\n\n## 1.9.0 (2019-04-09)\n\n* Drop support for MRI 2.2 and 2.3 (@janko)\n\n* [vips] Allow forcing a specific loader or saver (@janko)\n\n## 1.8.0 (2019-02-25)\n\n* [vips] Perform resize-on-load when possible, significantly improving resizing speed (@janko)\n\n## 1.7.1 (2018-09-27)\n\n* [vips] Make `#remove` that's used for removing image metadata chainable (@janko)\n\n## 1.7.0 (2018-09-20)\n\n* [vips] `#rotate` now always calls `vips_similarity()` and forwards all options to it (@janko)\n\n## 1.6.0 (2018-07-13)\n\n* [vips] In `#composite` accept `:offset` option for the position of the overlay image (@janko)\n\n* [vips] In `#composite` accept `:gravity` option for the direction of the overlay image (@janko)\n\n* [vips] In `#composite` accept blend mode as an optional `:mode` parameter which defaults to `:over` (@janko)\n\n* [minimagick] In `#composite` rename `:compose` option to `:mode` (@janko)\n\n* [minimagick] In `#composite` replace `:geometry` option with `:offset` which accepts an array (@janko)\n\n## 1.5.0 (2018-07-10)\n\n* [minimagick, vips] Add `#composite` method (@janko)\n\n* [core] Allow operations to accept blocks (janko-m)\n\n## 1.4.0 (2018-06-14)\n\n* [minimagick] Accept RGB(A) arrays for color names for `:background` (@janko)\n\n* [minimagick] Don't add empty `-background` option in `#rotate` when `:background` is not given (@janko)\n\n* [vips] Modify `#rotate` to accept only `:background` and not other `vips_similarity()` options (@janko)\n\n## 1.3.0 (2018-06-13)\n\n* [minimagick, vips] Add `#rotate` method (@janko)\n\n* [vips] Use native `vips_image_hasalpha()` and `vips_addalpha()` functions in `#resize_and_pad` (@janko)\n\n## 1.2.0 (2018-04-18)\n\n* [minimagick] Allow appending \"+\" operators in `#loader` and `#saver` using the value `false` (@janko)\n\n* [core] Fix `#apply` not accepting a Hash as an argument (@janko)\n\n* [core] Allow sending any builder commands via `#apply`, not just operations (@janko)\n\n* [minimagick] Add `#define` as a wrapper around `-define` (@janko)\n\n## 1.1.0 (2018-04-05)\n\n* [minimagick] Disallow splitting multi-layer images into multiple single-layer\n  images by default to avoid unexpected behaviour, but can be re-enabled with\n  the `:allow_splitting` saver option (@janko)\n\n* [core] Add `#apply` for applying a list of operations (@janko)\n\n## 1.0.0 (2018-04-04)\n\n* Depend on `mini_magick` and `ruby-vips` gems (@janko, @mokolabs)\n\n* [minimagick] Remove deprecated API in favor of the chainable API (@janko)\n\n* [core] Rename `Builder#default_options` to `Builder#options` (@janko)\n\n* [minimagick] Remove `:fail` loader option in favor of the existing `:regard_warnings` (@janko)\n\n* [vips, minimagick] Don't fail on warnings when loading the image (@janko)\n\n* [vips] Don't apply `Vips::Image#autorot` if `:autorotate` loader option was passed in (@janko)\n\n* [minimagick] Allow using value `nil` to add ImageMagick options that don't have a value (@janko)\n\n* [vips] Accept `:quality` saver option as an alias to `:Q` (@janko)\n\n* [minimagick] Automatically sharpen thumbnails after resizing (@janko, @mokolabs)\n\n* [vips] Automatically sharpen thumbnails after resizing (@janko, @mokolabs)\n\n## 0.11.2 (2018-03-31)\n\n* [minimagick] Avoid `#resize_*` operations stripping data by switching back to `-resize` (@janko)\n\n* [core] Make sure an empty destination file doesn't remain on processing errors when `:destination` is used (@janko)\n\n* [vips] Fix `:alpha` not correctly adding alpha for certain types of images (@janko)\n\n## 0.11.1 (2018-03-27)\n\n* [minimagick] Rename `#limit` to `#limits` to still allow adding `-limit` arguments directly (@janko)\n\n## 0.11.0 (2018-03-27)\n\n* [minimagick] Fix broken deprecated `#convert` (@janko)\n\n* [minimagick] Add `#limit` for specifying resource limits using `-limit` (@janko)\n\n* [minimagick] Use `-thumbnail` instead of `-resize` in `#resize_*` methods (@janko)\n\n* [minimagick] Add loader and saver options (@janko)\n\n## 0.10.3 (2018-03-24)\n\n* [minimagick] Fix bang methods in deprecated API calling nondestructive versions (@janko)\n\n## 0.10.2 (2018-03-22)\n\n* [minimagick] Add back default offset arguments to deprecated `#crop` (@janko)\n\n## 0.10.1 (2018-03-22)\n\n* [minimagick] Don't print deprecation warning for old API twice when IO objects are used (@janko)\n\n## 0.10.0 (2018-03-21)\n\n* [minimagick] Rewrite MiniMagick module to use the chainable API (@janko)\n\n* [minimagick] Deprecate the old API (@janko)\n\n* [minimagick] Raise an exception on processing warnings (@janko)\n\n* [minimagick] Speed up `.valid_image?` by an order of magnitude (@janko)\n\n* [minimagick] Don't accept arbitrary IO object anymore (@janko)\n\n* [minimagick] Removed unnecessary `#crop` and `#resample` macros (@janko)\n\n* [vips] Ignore undefined loader/saver options (@janko)\n\n* [vips] Preserve transparent background in `#resize_to_pad` (@janko)\n\n* [vips] Remove the ability to specify colors using names (@janko)\n\n* [minimagick, vips] Autorotate images after loading them (@janko)\n\n* [core] Delete result `Tempfile` object in case of processing errors (@janko)\n\n* [core] Allow returning `nil` in the `#custom` block (@janko)\n\n* [core] Allow specifying a path string as source file (@janko)\n\n* [core] Allow saving to a specific location with the `:destination` call option (@janko)\n\n## 0.9.0 (2018-03-16)\n\n* Added libvips module (@GustavoCaso, @janko)\n\n* Drop official support for MRI 2.0 and 2.1\n\n## 0.4.5 (2017-09-08)\n\n* Add `lib/image_processing.rb` to allow loading via `Bundler.require` (@printercu)\n\n## 0.4.4 (2017-06-16)\n\n* Fix last changes being incompatible with older Ruby versions, again (@janko)\n\n## 0.4.3 (2017-06-16)\n\n* Fix last changes being incompatible with older Ruby versions (@janko)\n\n## 0.4.2 (2017-06-16)\n\n* Don't use path of input file as basename for output file (@janko)\n\n## 0.4.1 (2016-09-08)\n\n* Maintain transparent background of PNGs in `#resize_to_fill` (janko-m)\n\n## 0.4.0 (2016-11-07)\n\n* Add `#corrupted?` for checking whether an image is corrupted (janko-m)\n\n## 0.3.0 (2016-05-03)\n\n* Add cropping functionality to `ImageProcessing::MiniMagick` (paulgoetze)\n\n## 0.2.5 (2016-03-24)\n\n* Rewind the file after making a copy in non-destructive methods (janko-m)\n\n* Add ability to supply page number to `#convert` (janko-m)\n\n## 0.2.4 (2015-10-21)\n\n* Don't error when checking MiniMagick version for older versions of MiniMagick (janko-m)\n\n## 0.2.3 (2015-10-17)\n\n* Fix uploading tempfiles to S3 using aws-sdk (janko-m)\n\n* Make nondestructive methods available on class methods on `ImageProcessing::MiniMagick` (janko-m)\n\n## 0.2.2 (2015-10-04)\n\n* Make `ImageProcessing::MiniMagick#with_minimagick` public (janko-m)\n\n* Add `ImageProcessing::MiniMagick#auto_orient` (janko-m)\n\n## 0.2.1 (2015-10-03)\n\n* Include the actual code in the gem (janko-m)\n\n## 0.2.0 (2015-10-03)\n\n* Add `ImageProcessing::MiniMagick#resample` for changing resolution (janko-m)\n\n* Fix padding in `ImageProcessing::MiniMagick#resize_and_pad` (janko-m)\n", "module ImageProcessing\n  # Implements a chainable interface for building processing options.\n  module Chainable\n    # Specify the source image file.\n    def source(file)\n      branch source: file\n    end\n\n    # Specify the output format.\n    def convert(format)\n      branch format: format\n    end\n\n    # Specify processor options applied when loading the image.\n    def loader(**options)\n      branch loader: options\n    end\n\n    # Specify processor options applied when saving the image.\n    def saver(**options)\n      branch saver: options\n    end\n\n    # Register instrumentation block that will be called around the pipeline.\n    def instrumenter(&block)\n      branch instrumenter: block\n    end\n\n    # Add multiple operations as a hash or an array.\n    #\n    #   .apply(resize_to_limit: [400, 400], strip: true)\n    #   # or\n    #   .apply([[:resize_to_limit, [400, 400]], [:strip, true])\n    def apply(operations)\n      operations.inject(self) do |builder, (name, argument)|\n        if argument == true || argument == nil\n          builder.send(name)\n        elsif argument.is_a?(Array)\n          builder.send(name, *argument)\n        elsif argument.is_a?(Hash)\n          builder.send(name, **argument)\n        else\n          builder.send(name, argument)\n        end\n      end\n    end\n\n    # Add an operation defined by the processor.\n    def operation(name, *args, &block)\n      branch operations: [[name, args, *block]]\n    end\n\n    # Call the defined processing and get the result. Allows specifying\n    # the source file and destination.\n    def call(file = nil, destination: nil, **call_options)\n      options = {}\n      options[:source] = file if file\n      options[:destination] = destination if destination\n\n      branch(**options).call!(**call_options)\n    end\n\n    # Creates a new builder object, merging current options with new options.\n    def branch(**new_options)\n      if self.is_a?(Builder)\n        options = self.options\n      else\n        options = DEFAULT_OPTIONS.merge(processor: self::Processor)\n      end\n\n      options = options.merge(new_options) do |key, old_value, new_value|\n        case key\n        when :loader, :saver then old_value.merge(new_value)\n        when :operations     then old_value + new_value\n        else                      new_value\n        end\n      end\n\n      Builder.new(options.freeze)\n    end\n\n    private\n\n    # Assume that any unknown method names an operation supported by the\n    # processor. Add a bang (\"!\") if you want processing to be performed.\n    def method_missing(name, *args, &block)\n      return super if name.to_s.end_with?(\"?\")\n      return send(name.to_s.chomp(\"!\"), *args, &block).call if name.to_s.end_with?(\"!\")\n\n      operation(name, *args, &block)\n    end\n    ruby2_keywords(:method_missing) if respond_to?(:ruby2_keywords, true)\n\n    # Empty options which the builder starts with.\n    DEFAULT_OPTIONS = {\n      source:     nil,\n      loader:     {},\n      saver:      {},\n      format:     nil,\n      operations: [],\n      processor:  nil,\n    }.freeze\n  end\nend\n", "require \"test_helper\"\nrequire \"image_processing/vips\"\nrequire \"pathname\"\n\ndescribe \"ImageProcessing::Pipeline\" do\n  before do\n    @portrait = fixture_image(\"portrait.jpg\")\n  end\n\n  it \"accepts source\" do\n    pipeline = ImageProcessing::Vips.source(@portrait)\n    assert_equal @portrait, pipeline.options[:source]\n  end\n\n  it \"accepts File, Tempfile, String, and Pathname objects as source\" do\n    ImageProcessing::Vips.source(@portrait).call\n    ImageProcessing::Vips.source(copy_to_tempfile(@portrait, \"jpg\")).call\n    ImageProcessing::Vips.source(@portrait.path).call\n    ImageProcessing::Vips.source(Pathname(@portrait.path)).call\n  end\n\n  it \"accepts format\" do\n    pipeline = ImageProcessing::Vips.source(@portrait)\n\n    result = pipeline.convert!(\"png\")\n    assert_equal \".png\", File.extname(result.path)\n\n    result = pipeline.convert!(nil)\n    assert_equal \".jpg\", File.extname(result.path)\n    assert_similar @portrait, result\n  end\n\n  it \"retains original format if format was not specified\" do\n    jpg = ImageProcessing::Vips.convert(\"jpg\").call(@portrait)\n    png = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    result_jpg = ImageProcessing::Vips.invert.call(jpg)\n    result_png = ImageProcessing::Vips.invert.call(png)\n    assert_equal \".jpg\", File.extname(result_jpg.path)\n    assert_equal \".png\", File.extname(result_png.path)\n  end\n\n  it \"saves as JPEG when format is unknown\" do\n    png = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    result = ImageProcessing::Vips.invert.call(copy_to_tempfile(png))\n    assert_equal \".jpg\", File.extname(result.path)\n    assert_type \"JPEG\", result\n  end\n\n  it \"saves as JPEG when format is unknown and the path ends with a '.'\" do\n    png = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    result = ImageProcessing::Vips.invert.call(copy_to_tempfile(png, \".\"))\n    assert_equal \".jpg\", File.extname(result.path)\n    assert_type \"JPEG\", result\n  end\n\n  it \"accepts destination path\" do\n    destination = Tempfile.new([\"destination\", \".jpg\"])\n    ImageProcessing::Vips.source(@portrait).call(destination: destination.path)\n    refute_equal 0, destination.path\n  end\n\n  it \"makes sure the destination file is deleted on processing errors\" do\n    destination_path = Dir::Tmpname.create([\"destination\", \".jpg\"]) {}\n    pipeline = ImageProcessing::MiniMagick.source(fixture_image(\"invalid.jpg\"))\n    assert_raises(MiniMagick::Error) { pipeline.call(destination: destination_path) }\n    refute File.exist?(destination_path)\n  end\n\n  it \"doesn't delete the destination file if it has already existed\" do\n    destination = Tempfile.new([\"destination\", \".jpg\"])\n    pipeline = ImageProcessing::MiniMagick.source(fixture_image(\"invalid.jpg\"))\n    assert_raises(MiniMagick::Error) { pipeline.call(destination: destination.path) }\n    assert File.exist?(destination.path)\n  end\n\n  it \"doesn't fail when destination file hasn't been created\" do\n    destination_path = Dir::Tmpname.create(\"destination\") {}\n    pipeline = ImageProcessing::Vips.source(@portrait)\n    assert_raises(Vips::Error) { pipeline.call(destination: destination_path) }\n  end\n\n  it \"accepts loader options\" do\n    pipeline = ImageProcessing::Vips.loader(shrink: 2)\n    assert_equal Hash[shrink: 2], pipeline.options[:loader]\n\n    pipeline = pipeline.loader(autorotate: true)\n    assert_equal Hash[shrink: 2, autorotate: true], pipeline.options[:loader]\n  end\n\n  it \"accepts saver options\" do\n    pipeline = ImageProcessing::Vips.saver(strip: true)\n    assert_equal Hash[strip: true], pipeline.options[:saver]\n\n    pipeline = pipeline.saver(Q: 100)\n    assert_equal Hash[strip: true, Q: 100], pipeline.options[:saver]\n  end\n\n  it \"accepts operations\" do\n    pipeline = ImageProcessing::Vips.shrink(2, 2)\n    assert_equal [[:shrink, [2, 2]]], pipeline.options[:operations]\n\n    pipeline = pipeline.invert\n    assert_equal [[:shrink, [2, 2]], [:invert, []]], pipeline.options[:operations]\n  end\n\n  it \"saves blocks passed to operations\" do\n    pipeline = ImageProcessing::MiniMagick.stack { |stack| stack.foo(\"bar\") }\n    assert_equal :stack,     pipeline.options[:operations].first[0]\n    assert_equal [],         pipeline.options[:operations].first[1]\n    assert_instance_of Proc, pipeline.options[:operations].first[2]\n  end\n\n  it \"accepts a list of commands\" do\n    pipeline = ImageProcessing::Vips.source(fixture_image(\"rotated.jpg\"))\n\n    # hash\n    actual1 = pipeline\n      .apply(\n        loader:        { autorotate: true },\n        resize_to_fit: [400, 400, sharpen: false],\n        invert:        true,\n        rot90:         nil,\n        rot:           :d90,\n        convert:       \"png\",\n      )\n      .call\n\n    # array\n    actual2 = pipeline\n      .apply([\n        [:loader,        { autorotate: true }],\n        [:resize_to_fit, [400, 400, sharpen: false]],\n        [:invert,        true],\n        [:rot90,         nil],\n        [:rot,           :d90],\n        [:convert,       \"png\"],\n      ])\n      .call\n\n    expected = pipeline\n      .loader(autorotate: true)\n      .resize_to_fit(400, 400, sharpen: false)\n      .invert\n      .rot90\n      .rot(:d90)\n      .convert(\"png\")\n      .call\n\n    assert_similar expected, actual1\n    assert_similar expected, actual2\n  end\n\n  it \"applies a custom block\" do\n    actual   = ImageProcessing::Vips.custom(&:invert).call(@portrait)\n    expected = ImageProcessing::Vips.invert.call(@portrait)\n    assert_similar expected, actual\n\n    actual   = ImageProcessing::Vips.custom { nil }.call(@portrait)\n    expected = ImageProcessing::Vips.call(@portrait)\n    assert_similar expected, actual\n\n    identity = ImageProcessing::Vips.custom.call(@portrait)\n    assert_similar @portrait, identity\n  end\n\n  it \"merges different options\" do\n    pipeline = ImageProcessing::Vips\n      .resize_to_fill(400, 400)\n      .convert(\"png\")\n\n    assert_equal [[:resize_to_fill, [400, 400]]], pipeline.options[:operations]\n    assert_equal \"png\", pipeline.options[:format]\n  end\n\n  it \"doesn't mutate the receiver when branching\" do\n    pipeline_jpg = ImageProcessing::Vips.convert(\"jpg\")\n    pipeline_png = pipeline_jpg.convert(\"png\")\n\n    assert_equal \"jpg\", pipeline_jpg.options[:format]\n    assert_equal \"png\", pipeline_png.options[:format]\n  end\n\n  it \"executes processing on #call with source\" do\n    result = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    assert_instance_of Tempfile, result\n    assert_type \"PNG\", result\n  end\n\n  it \"executes processing on #call without source\" do\n    result = ImageProcessing::Vips.source(@portrait).convert(\"png\").call\n    assert_instance_of Tempfile, result\n    assert_type \"PNG\", result\n  end\n\n  it \"executes processing on bang operation method\" do\n    result = ImageProcessing::Vips.source(@portrait).convert!(\"png\")\n    assert_instance_of Tempfile, result\n    assert_type \"PNG\", result\n\n    result = ImageProcessing::Vips.source(@portrait).shrink!(2, 2)\n    assert_instance_of Tempfile, result\n    assert_dimensions [300, 400], result\n\n    result = ImageProcessing::Vips.source(@portrait).resize_to_fill!(400, 400)\n    assert_instance_of Tempfile, result\n    assert_dimensions [400, 400], result\n  end\n\n  it \"can be called directly\" do\n    result = ImageProcessing::Vips.call(@portrait)\n    assert_similar result, @portrait\n  end\n\n  it \"applies a sequence of operations\" do\n    actual = ImageProcessing::Vips\n      .invert\n      .shrink(2, 2)\n      .call(@portrait)\n\n    expected = ImageProcessing::Vips.invert.call(@portrait)\n    expected = ImageProcessing::Vips.shrink(2, 2).call(expected)\n\n    assert_similar expected, actual\n  end\n\n  it \"returns a rewinded and refreshed tempfile in binary mode\" do\n    tempfile = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    assert_instance_of Tempfile, tempfile\n    assert tempfile.binmode?\n    assert_equal 0, tempfile.pos\n    assert_equal File.binread(tempfile.path), tempfile.read\n  end\n\n  it \"returns an intermediary object on #call(save: false)\" do\n    vips_image = ImageProcessing::Vips.resize_to_limit(400, 400).call(@portrait, save: false)\n    assert_instance_of Vips::Image, vips_image\n    assert_equal [300, 400], vips_image.size\n\n    magick = ImageProcessing::MiniMagick.source(@portrait).resize_to_limit(400, 400).call(save: false)\n    assert_instance_of MiniMagick::Tool::Convert, magick\n    assert_includes magick.args, \"400x400>\"\n  end\n\n  it \"raises exception when source was not provided\" do\n    assert_raises(ImageProcessing::Error) do\n      ImageProcessing::Vips.call\n    end\n  end\n\n  it \"raises exception when invalid source was provided\" do\n    assert_raises(ImageProcessing::Error) do\n      ImageProcessing::Vips.source(:invalid).call\n    end\n  end\n\n  it \"raises a NoMethodError when predicate method is not defined\" do\n    assert_raises(NoMethodError) do\n      ImageProcessing::Vips.valid?(@portrait)\n    end\n  end\nend\n"], "fixing_code": ["## HEAD\n\n* Prevent remote shell execution when using `#apply` with operations coming from user input (@janko)\n\n## 1.12.1 (2020-11-06)\n\n* Fix format fallback for files ending with a dot on Ruby 2.7+ (@coding-chimp)\n\n## 1.12.0 (2020-09-20)\n\n* Add instrumentation support via `#instrumenter` (@janko)\n\n## 1.11.0 (2020-05-17)\n\n* [minimagick] Handle destination format having no file extension (@janko)\n\n* [minimagick] Disable sharpening on `#resize_*` operators by default (@flori)\n\n* [minimagick] Add `#crop` which accepts `left, top, width, height` arguments (@janko)\n\n## 1.10.3 (2020-01-12)\n\n* [vips] Fix auto-rotation not working in certain cases on libvips 8.9.0 (@janko)\n\n## 1.10.2 (2020-01-11)\n\n* Fix Ruby 2.7 warnings for separation of positional and keyword arguments (@kamipo, @janko)\n\n## 1.10.1 (2020-01-07)\n\n* [vips] Fix compatibility with ruby-vips 2.0.17+ (@janko)\n\n## 1.10.0 (2019-12-18)\n\n* [minimagick] Add `:loader` option for explicitly setting input file type (@janko)\n\n## 1.9.3 (2019-08-11)\n\n* [vips] Use integer precision when sharpening for better quality (@metaskills)\n\n## 1.9.2 (2019-07-22)\n\n* Bump `mini_magick` dependency to `>= 4.9.5` (@chioreandan)\n\n## 1.9.1 (2019-07-20)\n\n* Bring back support for MRI 2.3 (@janko)\n\n## 1.9.0 (2019-04-09)\n\n* Drop support for MRI 2.2 and 2.3 (@janko)\n\n* [vips] Allow forcing a specific loader or saver (@janko)\n\n## 1.8.0 (2019-02-25)\n\n* [vips] Perform resize-on-load when possible, significantly improving resizing speed (@janko)\n\n## 1.7.1 (2018-09-27)\n\n* [vips] Make `#remove` that's used for removing image metadata chainable (@janko)\n\n## 1.7.0 (2018-09-20)\n\n* [vips] `#rotate` now always calls `vips_similarity()` and forwards all options to it (@janko)\n\n## 1.6.0 (2018-07-13)\n\n* [vips] In `#composite` accept `:offset` option for the position of the overlay image (@janko)\n\n* [vips] In `#composite` accept `:gravity` option for the direction of the overlay image (@janko)\n\n* [vips] In `#composite` accept blend mode as an optional `:mode` parameter which defaults to `:over` (@janko)\n\n* [minimagick] In `#composite` rename `:compose` option to `:mode` (@janko)\n\n* [minimagick] In `#composite` replace `:geometry` option with `:offset` which accepts an array (@janko)\n\n## 1.5.0 (2018-07-10)\n\n* [minimagick, vips] Add `#composite` method (@janko)\n\n* [core] Allow operations to accept blocks (janko-m)\n\n## 1.4.0 (2018-06-14)\n\n* [minimagick] Accept RGB(A) arrays for color names for `:background` (@janko)\n\n* [minimagick] Don't add empty `-background` option in `#rotate` when `:background` is not given (@janko)\n\n* [vips] Modify `#rotate` to accept only `:background` and not other `vips_similarity()` options (@janko)\n\n## 1.3.0 (2018-06-13)\n\n* [minimagick, vips] Add `#rotate` method (@janko)\n\n* [vips] Use native `vips_image_hasalpha()` and `vips_addalpha()` functions in `#resize_and_pad` (@janko)\n\n## 1.2.0 (2018-04-18)\n\n* [minimagick] Allow appending \"+\" operators in `#loader` and `#saver` using the value `false` (@janko)\n\n* [core] Fix `#apply` not accepting a Hash as an argument (@janko)\n\n* [core] Allow sending any builder commands via `#apply`, not just operations (@janko)\n\n* [minimagick] Add `#define` as a wrapper around `-define` (@janko)\n\n## 1.1.0 (2018-04-05)\n\n* [minimagick] Disallow splitting multi-layer images into multiple single-layer\n  images by default to avoid unexpected behaviour, but can be re-enabled with\n  the `:allow_splitting` saver option (@janko)\n\n* [core] Add `#apply` for applying a list of operations (@janko)\n\n## 1.0.0 (2018-04-04)\n\n* Depend on `mini_magick` and `ruby-vips` gems (@janko, @mokolabs)\n\n* [minimagick] Remove deprecated API in favor of the chainable API (@janko)\n\n* [core] Rename `Builder#default_options` to `Builder#options` (@janko)\n\n* [minimagick] Remove `:fail` loader option in favor of the existing `:regard_warnings` (@janko)\n\n* [vips, minimagick] Don't fail on warnings when loading the image (@janko)\n\n* [vips] Don't apply `Vips::Image#autorot` if `:autorotate` loader option was passed in (@janko)\n\n* [minimagick] Allow using value `nil` to add ImageMagick options that don't have a value (@janko)\n\n* [vips] Accept `:quality` saver option as an alias to `:Q` (@janko)\n\n* [minimagick] Automatically sharpen thumbnails after resizing (@janko, @mokolabs)\n\n* [vips] Automatically sharpen thumbnails after resizing (@janko, @mokolabs)\n\n## 0.11.2 (2018-03-31)\n\n* [minimagick] Avoid `#resize_*` operations stripping data by switching back to `-resize` (@janko)\n\n* [core] Make sure an empty destination file doesn't remain on processing errors when `:destination` is used (@janko)\n\n* [vips] Fix `:alpha` not correctly adding alpha for certain types of images (@janko)\n\n## 0.11.1 (2018-03-27)\n\n* [minimagick] Rename `#limit` to `#limits` to still allow adding `-limit` arguments directly (@janko)\n\n## 0.11.0 (2018-03-27)\n\n* [minimagick] Fix broken deprecated `#convert` (@janko)\n\n* [minimagick] Add `#limit` for specifying resource limits using `-limit` (@janko)\n\n* [minimagick] Use `-thumbnail` instead of `-resize` in `#resize_*` methods (@janko)\n\n* [minimagick] Add loader and saver options (@janko)\n\n## 0.10.3 (2018-03-24)\n\n* [minimagick] Fix bang methods in deprecated API calling nondestructive versions (@janko)\n\n## 0.10.2 (2018-03-22)\n\n* [minimagick] Add back default offset arguments to deprecated `#crop` (@janko)\n\n## 0.10.1 (2018-03-22)\n\n* [minimagick] Don't print deprecation warning for old API twice when IO objects are used (@janko)\n\n## 0.10.0 (2018-03-21)\n\n* [minimagick] Rewrite MiniMagick module to use the chainable API (@janko)\n\n* [minimagick] Deprecate the old API (@janko)\n\n* [minimagick] Raise an exception on processing warnings (@janko)\n\n* [minimagick] Speed up `.valid_image?` by an order of magnitude (@janko)\n\n* [minimagick] Don't accept arbitrary IO object anymore (@janko)\n\n* [minimagick] Removed unnecessary `#crop` and `#resample` macros (@janko)\n\n* [vips] Ignore undefined loader/saver options (@janko)\n\n* [vips] Preserve transparent background in `#resize_to_pad` (@janko)\n\n* [vips] Remove the ability to specify colors using names (@janko)\n\n* [minimagick, vips] Autorotate images after loading them (@janko)\n\n* [core] Delete result `Tempfile` object in case of processing errors (@janko)\n\n* [core] Allow returning `nil` in the `#custom` block (@janko)\n\n* [core] Allow specifying a path string as source file (@janko)\n\n* [core] Allow saving to a specific location with the `:destination` call option (@janko)\n\n## 0.9.0 (2018-03-16)\n\n* Added libvips module (@GustavoCaso, @janko)\n\n* Drop official support for MRI 2.0 and 2.1\n\n## 0.4.5 (2017-09-08)\n\n* Add `lib/image_processing.rb` to allow loading via `Bundler.require` (@printercu)\n\n## 0.4.4 (2017-06-16)\n\n* Fix last changes being incompatible with older Ruby versions, again (@janko)\n\n## 0.4.3 (2017-06-16)\n\n* Fix last changes being incompatible with older Ruby versions (@janko)\n\n## 0.4.2 (2017-06-16)\n\n* Don't use path of input file as basename for output file (@janko)\n\n## 0.4.1 (2016-09-08)\n\n* Maintain transparent background of PNGs in `#resize_to_fill` (janko-m)\n\n## 0.4.0 (2016-11-07)\n\n* Add `#corrupted?` for checking whether an image is corrupted (janko-m)\n\n## 0.3.0 (2016-05-03)\n\n* Add cropping functionality to `ImageProcessing::MiniMagick` (paulgoetze)\n\n## 0.2.5 (2016-03-24)\n\n* Rewind the file after making a copy in non-destructive methods (janko-m)\n\n* Add ability to supply page number to `#convert` (janko-m)\n\n## 0.2.4 (2015-10-21)\n\n* Don't error when checking MiniMagick version for older versions of MiniMagick (janko-m)\n\n## 0.2.3 (2015-10-17)\n\n* Fix uploading tempfiles to S3 using aws-sdk (janko-m)\n\n* Make nondestructive methods available on class methods on `ImageProcessing::MiniMagick` (janko-m)\n\n## 0.2.2 (2015-10-04)\n\n* Make `ImageProcessing::MiniMagick#with_minimagick` public (janko-m)\n\n* Add `ImageProcessing::MiniMagick#auto_orient` (janko-m)\n\n## 0.2.1 (2015-10-03)\n\n* Include the actual code in the gem (janko-m)\n\n## 0.2.0 (2015-10-03)\n\n* Add `ImageProcessing::MiniMagick#resample` for changing resolution (janko-m)\n\n* Fix padding in `ImageProcessing::MiniMagick#resize_and_pad` (janko-m)\n", "module ImageProcessing\n  # Implements a chainable interface for building processing options.\n  module Chainable\n    # Specify the source image file.\n    def source(file)\n      branch source: file\n    end\n\n    # Specify the output format.\n    def convert(format)\n      branch format: format\n    end\n\n    # Specify processor options applied when loading the image.\n    def loader(**options)\n      branch loader: options\n    end\n\n    # Specify processor options applied when saving the image.\n    def saver(**options)\n      branch saver: options\n    end\n\n    # Register instrumentation block that will be called around the pipeline.\n    def instrumenter(&block)\n      branch instrumenter: block\n    end\n\n    # Add multiple operations as a hash or an array.\n    #\n    #   .apply(resize_to_limit: [400, 400], strip: true)\n    #   # or\n    #   .apply([[:resize_to_limit, [400, 400]], [:strip, true])\n    def apply(operations)\n      operations.inject(self) do |builder, (name, argument)|\n        if argument == true || argument == nil\n          builder.public_send(name)\n        elsif argument.is_a?(Array)\n          builder.public_send(name, *argument)\n        elsif argument.is_a?(Hash)\n          builder.public_send(name, **argument)\n        else\n          builder.public_send(name, argument)\n        end\n      end\n    end\n\n    # Add an operation defined by the processor.\n    def operation(name, *args, &block)\n      branch operations: [[name, args, *block]]\n    end\n\n    # Call the defined processing and get the result. Allows specifying\n    # the source file and destination.\n    def call(file = nil, destination: nil, **call_options)\n      options = {}\n      options[:source] = file if file\n      options[:destination] = destination if destination\n\n      branch(**options).call!(**call_options)\n    end\n\n    # Creates a new builder object, merging current options with new options.\n    def branch(**new_options)\n      if self.is_a?(Builder)\n        options = self.options\n      else\n        options = DEFAULT_OPTIONS.merge(processor: self::Processor)\n      end\n\n      options = options.merge(new_options) do |key, old_value, new_value|\n        case key\n        when :loader, :saver then old_value.merge(new_value)\n        when :operations     then old_value + new_value\n        else                      new_value\n        end\n      end\n\n      Builder.new(options.freeze)\n    end\n\n    private\n\n    # Assume that any unknown method names an operation supported by the\n    # processor. Add a bang (\"!\") if you want processing to be performed.\n    def method_missing(name, *args, &block)\n      return super if name.to_s.end_with?(\"?\")\n      return send(name.to_s.chomp(\"!\"), *args, &block).call if name.to_s.end_with?(\"!\")\n\n      operation(name, *args, &block)\n    end\n    ruby2_keywords(:method_missing) if respond_to?(:ruby2_keywords, true)\n\n    # Empty options which the builder starts with.\n    DEFAULT_OPTIONS = {\n      source:     nil,\n      loader:     {},\n      saver:      {},\n      format:     nil,\n      operations: [],\n      processor:  nil,\n    }.freeze\n  end\nend\n", "require \"test_helper\"\nrequire \"image_processing/vips\"\nrequire \"pathname\"\n\ndescribe \"ImageProcessing::Pipeline\" do\n  before do\n    @portrait = fixture_image(\"portrait.jpg\")\n  end\n\n  it \"accepts source\" do\n    pipeline = ImageProcessing::Vips.source(@portrait)\n    assert_equal @portrait, pipeline.options[:source]\n  end\n\n  it \"accepts File, Tempfile, String, and Pathname objects as source\" do\n    ImageProcessing::Vips.source(@portrait).call\n    ImageProcessing::Vips.source(copy_to_tempfile(@portrait, \"jpg\")).call\n    ImageProcessing::Vips.source(@portrait.path).call\n    ImageProcessing::Vips.source(Pathname(@portrait.path)).call\n  end\n\n  it \"accepts format\" do\n    pipeline = ImageProcessing::Vips.source(@portrait)\n\n    result = pipeline.convert!(\"png\")\n    assert_equal \".png\", File.extname(result.path)\n\n    result = pipeline.convert!(nil)\n    assert_equal \".jpg\", File.extname(result.path)\n    assert_similar @portrait, result\n  end\n\n  it \"retains original format if format was not specified\" do\n    jpg = ImageProcessing::Vips.convert(\"jpg\").call(@portrait)\n    png = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    result_jpg = ImageProcessing::Vips.invert.call(jpg)\n    result_png = ImageProcessing::Vips.invert.call(png)\n    assert_equal \".jpg\", File.extname(result_jpg.path)\n    assert_equal \".png\", File.extname(result_png.path)\n  end\n\n  it \"saves as JPEG when format is unknown\" do\n    png = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    result = ImageProcessing::Vips.invert.call(copy_to_tempfile(png))\n    assert_equal \".jpg\", File.extname(result.path)\n    assert_type \"JPEG\", result\n  end\n\n  it \"saves as JPEG when format is unknown and the path ends with a '.'\" do\n    png = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    result = ImageProcessing::Vips.invert.call(copy_to_tempfile(png, \".\"))\n    assert_equal \".jpg\", File.extname(result.path)\n    assert_type \"JPEG\", result\n  end\n\n  it \"accepts destination path\" do\n    destination = Tempfile.new([\"destination\", \".jpg\"])\n    ImageProcessing::Vips.source(@portrait).call(destination: destination.path)\n    refute_equal 0, destination.path\n  end\n\n  it \"makes sure the destination file is deleted on processing errors\" do\n    destination_path = Dir::Tmpname.create([\"destination\", \".jpg\"]) {}\n    pipeline = ImageProcessing::MiniMagick.source(fixture_image(\"invalid.jpg\"))\n    assert_raises(MiniMagick::Error) { pipeline.call(destination: destination_path) }\n    refute File.exist?(destination_path)\n  end\n\n  it \"doesn't delete the destination file if it has already existed\" do\n    destination = Tempfile.new([\"destination\", \".jpg\"])\n    pipeline = ImageProcessing::MiniMagick.source(fixture_image(\"invalid.jpg\"))\n    assert_raises(MiniMagick::Error) { pipeline.call(destination: destination.path) }\n    assert File.exist?(destination.path)\n  end\n\n  it \"doesn't fail when destination file hasn't been created\" do\n    destination_path = Dir::Tmpname.create(\"destination\") {}\n    pipeline = ImageProcessing::Vips.source(@portrait)\n    assert_raises(Vips::Error) { pipeline.call(destination: destination_path) }\n  end\n\n  it \"accepts loader options\" do\n    pipeline = ImageProcessing::Vips.loader(shrink: 2)\n    assert_equal Hash[shrink: 2], pipeline.options[:loader]\n\n    pipeline = pipeline.loader(autorotate: true)\n    assert_equal Hash[shrink: 2, autorotate: true], pipeline.options[:loader]\n  end\n\n  it \"accepts saver options\" do\n    pipeline = ImageProcessing::Vips.saver(strip: true)\n    assert_equal Hash[strip: true], pipeline.options[:saver]\n\n    pipeline = pipeline.saver(Q: 100)\n    assert_equal Hash[strip: true, Q: 100], pipeline.options[:saver]\n  end\n\n  it \"accepts operations\" do\n    pipeline = ImageProcessing::Vips.shrink(2, 2)\n    assert_equal [[:shrink, [2, 2]]], pipeline.options[:operations]\n\n    pipeline = pipeline.invert\n    assert_equal [[:shrink, [2, 2]], [:invert, []]], pipeline.options[:operations]\n  end\n\n  it \"saves blocks passed to operations\" do\n    pipeline = ImageProcessing::MiniMagick.stack { |stack| stack.foo(\"bar\") }\n    assert_equal :stack,     pipeline.options[:operations].first[0]\n    assert_equal [],         pipeline.options[:operations].first[1]\n    assert_instance_of Proc, pipeline.options[:operations].first[2]\n  end\n\n  it \"accepts a list of commands\" do\n    pipeline = ImageProcessing::Vips.source(fixture_image(\"rotated.jpg\"))\n\n    # hash\n    actual1 = pipeline\n      .apply(\n        loader:        { autorotate: true },\n        resize_to_fit: [400, 400, sharpen: false],\n        invert:        true,\n        rot90:         nil,\n        rot:           :d90,\n        convert:       \"png\",\n      )\n      .call\n\n    # array\n    actual2 = pipeline\n      .apply([\n        [:loader,        { autorotate: true }],\n        [:resize_to_fit, [400, 400, sharpen: false]],\n        [:invert,        true],\n        [:rot90,         nil],\n        [:rot,           :d90],\n        [:convert,       \"png\"],\n      ])\n      .call\n\n    expected = pipeline\n      .loader(autorotate: true)\n      .resize_to_fit(400, 400, sharpen: false)\n      .invert\n      .rot90\n      .rot(:d90)\n      .convert(\"png\")\n      .call\n\n    assert_similar expected, actual1\n    assert_similar expected, actual2\n  end\n\n  it \"applies a custom block\" do\n    actual   = ImageProcessing::Vips.custom(&:invert).call(@portrait)\n    expected = ImageProcessing::Vips.invert.call(@portrait)\n    assert_similar expected, actual\n\n    actual   = ImageProcessing::Vips.custom { nil }.call(@portrait)\n    expected = ImageProcessing::Vips.call(@portrait)\n    assert_similar expected, actual\n\n    identity = ImageProcessing::Vips.custom.call(@portrait)\n    assert_similar @portrait, identity\n  end\n\n  it \"merges different options\" do\n    pipeline = ImageProcessing::Vips\n      .resize_to_fill(400, 400)\n      .convert(\"png\")\n\n    assert_equal [[:resize_to_fill, [400, 400]]], pipeline.options[:operations]\n    assert_equal \"png\", pipeline.options[:format]\n  end\n\n  it \"doesn't mutate the receiver when branching\" do\n    pipeline_jpg = ImageProcessing::Vips.convert(\"jpg\")\n    pipeline_png = pipeline_jpg.convert(\"png\")\n\n    assert_equal \"jpg\", pipeline_jpg.options[:format]\n    assert_equal \"png\", pipeline_png.options[:format]\n  end\n\n  it \"executes processing on #call with source\" do\n    result = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    assert_instance_of Tempfile, result\n    assert_type \"PNG\", result\n  end\n\n  it \"executes processing on #call without source\" do\n    result = ImageProcessing::Vips.source(@portrait).convert(\"png\").call\n    assert_instance_of Tempfile, result\n    assert_type \"PNG\", result\n  end\n\n  it \"executes processing on bang operation method\" do\n    result = ImageProcessing::Vips.source(@portrait).convert!(\"png\")\n    assert_instance_of Tempfile, result\n    assert_type \"PNG\", result\n\n    result = ImageProcessing::Vips.source(@portrait).shrink!(2, 2)\n    assert_instance_of Tempfile, result\n    assert_dimensions [300, 400], result\n\n    result = ImageProcessing::Vips.source(@portrait).resize_to_fill!(400, 400)\n    assert_instance_of Tempfile, result\n    assert_dimensions [400, 400], result\n  end\n\n  it \"can be called directly\" do\n    result = ImageProcessing::Vips.call(@portrait)\n    assert_similar result, @portrait\n  end\n\n  it \"applies a sequence of operations\" do\n    actual = ImageProcessing::Vips\n      .invert\n      .shrink(2, 2)\n      .call(@portrait)\n\n    expected = ImageProcessing::Vips.invert.call(@portrait)\n    expected = ImageProcessing::Vips.shrink(2, 2).call(expected)\n\n    assert_similar expected, actual\n  end\n\n  it \"returns a rewinded and refreshed tempfile in binary mode\" do\n    tempfile = ImageProcessing::Vips.convert(\"png\").call(@portrait)\n    assert_instance_of Tempfile, tempfile\n    assert tempfile.binmode?\n    assert_equal 0, tempfile.pos\n    assert_equal File.binread(tempfile.path), tempfile.read\n  end\n\n  it \"returns an intermediary object on #call(save: false)\" do\n    vips_image = ImageProcessing::Vips.resize_to_limit(400, 400).call(@portrait, save: false)\n    assert_instance_of Vips::Image, vips_image\n    assert_equal [300, 400], vips_image.size\n\n    magick = ImageProcessing::MiniMagick.source(@portrait).resize_to_limit(400, 400).call(save: false)\n    assert_instance_of MiniMagick::Tool::Convert, magick\n    assert_includes magick.args, \"400x400>\"\n  end\n\n  it \"raises exception when source was not provided\" do\n    assert_raises(ImageProcessing::Error) do\n      ImageProcessing::Vips.call\n    end\n  end\n\n  it \"raises exception when invalid source was provided\" do\n    assert_raises(ImageProcessing::Error) do\n      ImageProcessing::Vips.source(:invalid).call\n    end\n  end\n\n  it \"raises a NoMethodError when predicate method is not defined\" do\n    assert_raises(NoMethodError) do\n      ImageProcessing::Vips.valid?(@portrait)\n    end\n  end\n\n  it \"doesn't allow making system calls\" do\n    ImageProcessing::Vips.source(@portrait).apply(system: \"touch foo.txt\")\n    refute File.exist?(\"foo.txt\")\n\n    assert_raises Vips::Error do\n      ImageProcessing::Vips.source(@portrait).spawn(\"touch foo.txt\").call\n    end\n    refute File.exist?(\"foo.txt\")\n\n    assert_raises MiniMagick::Error do\n      ImageProcessing::MiniMagick.source(@portrait).spawn(\"touch foo.txt\").call\n    end\n    refute File.exist?(\"foo.txt\")\n  end\nend\n"], "filenames": ["CHANGELOG.md", "lib/image_processing/chainable.rb", "test/pipeline_test.rb"], "buggy_code_start_loc": [0, 37, 260], "buggy_code_end_loc": [0, 44, 260], "fixing_code_start_loc": [1, 37, 261], "fixing_code_end_loc": [5, 44, 276], "type": "CWE-20", "message": "image_processing is an image processing wrapper for libvips and ImageMagick/GraphicsMagick. Prior to version 1.12.2, using the `#apply` method from image_processing to apply a series of operations that are coming from unsanitized user input allows the attacker to execute shell commands. This method is called internally by Active Storage variants, so Active Storage is vulnerable as well. The vulnerability has been fixed in version 1.12.2 of image_processing. As a workaround, users who process based on user input should always sanitize the user input by allowing only a constrained set of operations.", "other": {"cve": {"id": "CVE-2022-24720", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-01T23:15:08.993", "lastModified": "2023-02-22T17:49:00.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "image_processing is an image processing wrapper for libvips and ImageMagick/GraphicsMagick. Prior to version 1.12.2, using the `#apply` method from image_processing to apply a series of operations that are coming from unsanitized user input allows the attacker to execute shell commands. This method is called internally by Active Storage variants, so Active Storage is vulnerable as well. The vulnerability has been fixed in version 1.12.2 of image_processing. As a workaround, users who process based on user input should always sanitize the user input by allowing only a constrained set of operations."}, {"lang": "es", "value": "image_processing es una envoltura de procesamiento de im\u00e1genes para libvips e ImageMagick/GraphicsMagick. En versiones anteriores a 1.12.2, usar el m\u00e9todo \"#apply\" de image_processing para aplicar una serie de operaciones que provienen de una entrada de usuario no saneada permite al atacante ejecutar comandos del shell. Este m\u00e9todo es llamado internamente por las variantes de Active Storage, por lo que Active Storage tambi\u00e9n es vulnerable. La vulnerabilidad ha sido corregida en versi\u00f3n 1.12.2 de image_processing. Como medida de mitigaci\u00f3n, los usuarios que procesan en base a la entrada del usuario deben siempre sanear la entrada del usuario permitiendo s\u00f3lo un conjunto restringido de operaciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:image_processing_project:image_processing:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.12.2", "matchCriteriaId": "0D331DC9-BD55-4D95-83DE-3DF006DCBBA3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/janko/image_processing/commit/038e4574e8f4f4b636a62394e09983c71980dada", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/janko/image_processing/security/advisories/GHSA-cxf7-qrc5-9446", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5310", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/janko/image_processing/commit/038e4574e8f4f4b636a62394e09983c71980dada"}}