{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2018-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / RAW PCM reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\ntypedef struct\n{\n\t//opts\n\tu32 framelen, safmt, sr, ch;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tBool file_loaded, is_playing, initial_play_done;\n\tu64 cts;\n\tu32 frame_size, nb_bytes_in_frame, Bps;\n\tu64 filepos, total_frames;\n\tGF_FilterPacket *out_pck;\n\tu8 *out_data;\n\tBool reverse_play, done;\n\n\tu32 probe_wave, wav_hdr_size;\n\tu8 *probe_data;\n\tu32 probe_data_size;\n} GF_PCMReframeCtx;\n\n\n\n\nGF_Err pcmreframe_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_EXT);\n\tif (!ctx->safmt) {\n\t\tif (p && p->value.string) ctx->safmt = gf_audio_fmt_parse(p->value.string);\n\t}\n\tif (!ctx->safmt) {\n\t\tctx->probe_wave = 1;\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\tgf_filter_pid_send_event(pid, &evt);\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!ctx->sr) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio sample rate, cannot parse\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (!ctx->ch) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio ch, cannot parse\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tctx->Bps = gf_audio_fmt_bit_depth(ctx->safmt) / 8;\n\t}\n\tif (!ctx->framelen) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio framelen, using 1024\\n\"));\n\t\tctx->framelen = 1024;\n\t}\n\n\tctx->frame_size = ctx->framelen * ctx->Bps * ctx->ch;\n\n\tif (!ctx->opid)\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_framing_mode(ctx->ipid, GF_FALSE);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(ctx->sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(ctx->ch));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT(ctx->framelen));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(ctx->safmt));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_REWIND));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, &PROP_BOOL(GF_TRUE));\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\n\tif (!gf_sys_is_test_mode() ) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->sr * ctx->Bps * ctx->ch));\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\tif (p && p->value.longuint) {\n\t\tu64 nb_frames = p->value.longuint;\n\t\tif (ctx->probe_wave) nb_frames -= ctx->wav_hdr_size;\n\t\tnb_frames /= ctx->Bps * ctx->ch;\n\t\tctx->total_frames = p->value.longuint;\n\t\tctx->total_frames /= ctx->frame_size;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(nb_frames, ctx->sr));\n\t}\n\n\treturn GF_OK;\n}\n\nstatic Bool pcmreframe_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 nb_frames;\n\tGF_FilterEvent fevt;\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tctx->done = GF_FALSE;\n\n\t\tif (!ctx->total_frames)\n\t\t\treturn GF_TRUE;\n\n\t\tif (evt->play.start_range>=0) {\n\t\t\tctx->cts = (u64) (evt->play.start_range * ctx->sr);\n\t\t} else {\n\t\t\tctx->cts = (ctx->total_frames-1) * ctx->framelen;\n\t\t}\n\t\tnb_frames = (u32) (ctx->cts / ctx->framelen);\n\t\tif (nb_frames==ctx->total_frames) {\n\t\t\tif (evt->play.speed>=0) {\n\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tnb_frames--;\n\t\t\tctx->cts = nb_frames * ctx->framelen;\n\t\t}\n\n\t\tctx->filepos = nb_frames * ctx->frame_size;\n\t\tctx->reverse_play =  (evt->play.speed<0) ? GF_TRUE : GF_FALSE;\n\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->filepos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->out_pck) {\n\t\t\tgf_filter_pck_discard(ctx->out_pck);\n\t\t\tctx->out_pck = NULL;\n\t\t}\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nvoid pcmreframe_flush_packet(GF_PCMReframeCtx *ctx)\n{\n\tif (ctx->reverse_play) {\n\t\tu32 i, nb_bytes_in_sample, nb_samples = ctx->nb_bytes_in_frame / ctx->Bps / ctx->ch;\n\t\tnb_bytes_in_sample = ctx->Bps * ctx->ch;\n\t\tfor (i=0; i<nb_samples/2; i++) {\n\t\t\tchar store[100];\n\t\t\tmemcpy(store, ctx->out_data + i*nb_bytes_in_sample, nb_bytes_in_sample);\n\t\t\tmemcpy(ctx->out_data + i*nb_bytes_in_sample, ctx->out_data + (nb_samples - i - 1)*nb_bytes_in_sample, nb_bytes_in_sample);\n\t\t\tmemcpy(ctx->out_data + (nb_samples-i-1)*nb_bytes_in_sample, store, nb_bytes_in_sample);\n\t\t}\n\t}\n\tgf_filter_pck_send(ctx->out_pck);\n\tctx->out_pck = NULL;\n}\nGF_Err pcmreframe_process(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu64 byte_offset;\n\tu8 *data;\n\tu32 pck_size;\n\n\tif (ctx->done) return GF_EOS;\n\n\tif (!ctx->is_playing && ctx->opid) return GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid) && !ctx->reverse_play) {\n\t\t\tif (ctx->out_pck) {\n\t\t\t\tgf_filter_pck_truncate(ctx->out_pck, ctx->nb_bytes_in_frame);\n\t\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->nb_bytes_in_frame/ctx->Bps/ctx->ch);\n\t\t\t\tpcmreframe_flush_packet(ctx);\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tif (ctx->probe_wave==1) {\n\t\tBool wav_ok = GF_TRUE;\n\t\tGF_BitStream *bs;\n\t\tif (ctx->probe_data) {\n\t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n\t\t\tmemcpy(ctx->probe_data + ctx->probe_data_size, data, pck_size);\n\t\t\tctx->probe_data_size += pck_size;\n\t\t\tbs = gf_bs_new(ctx->probe_data, ctx->probe_data_size, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tbs = gf_bs_new(data, pck_size, GF_BITSTREAM_READ);\n\t\t}\n\t\tu32 type = gf_bs_read_u32(bs);\n\t\tif (type!=GF_4CC('R', 'I', 'F', 'F')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tgf_bs_read_u32(bs);\n\t\tu32 wtype = gf_bs_read_u32(bs);\n\t\tif (wtype!=GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\twhile (gf_bs_available(bs)) {\n\t\t\ttype = gf_bs_read_u32(bs);\n\t\t\tu32 csize = gf_bs_read_u32_le(bs); //subchunk size\n\t\t\tif (type==GF_4CC('d', 'a', 't', 'a')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type!=GF_4CC('f', 'm', 't', ' ')) {\n\t\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//parse fmt\n\t\t\tu16 atype = gf_bs_read_u16_le(bs);\n\t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\t\t\tctx->sr = gf_bs_read_u32_le(bs);\n\t\t\tgf_bs_read_u32_le(bs); //byte rate\n\t\t\tgf_bs_read_u16_le(bs); // block align\n\t\t\tu32 bps = gf_bs_read_u16_le(bs);\n\t\t\tif (atype==3) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_FLT;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else if (atype==1) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S32;\n\t\t\t\t} else if (bps==24) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S24;\n\t\t\t\t} else if (bps==16) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S16;\n\t\t\t\t} else if (bps==8) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_U8;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tif (!ctx->probe_data) {\n\t\t\t\tctx->probe_data = gf_malloc(pck_size);\n\t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n\t\t\t\tctx->probe_data_size = pck_size;\n\t\t\t}\n\t\t\tif (ctx->probe_data_size<=10000) {\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chink afetr %d bytes, aborting\\n\", ctx->probe_data_size));\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\n\t\tctx->wav_hdr_size = (u32) gf_bs_get_position(bs);\n\n\t\tgf_bs_del(bs);\n\t\tif (!wav_ok) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Invalid or unsupported WAVE header, aborting\\n\", ctx->probe_data_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tctx->probe_wave = 2;\n\t\tpcmreframe_configure_pid(filter, ctx->ipid, GF_FALSE);\n\t\tif (ctx->probe_data) {\n\t\t\tpck_size = ctx->probe_data_size;\n\t\t\tdata = ctx->probe_data;\n\t\t}\n\t\tpck_size -= ctx->wav_hdr_size;\n\t\tdata+=ctx->wav_hdr_size;\n\t\tbyte_offset = 0;\n\t}\n\tbyte_offset+= ctx->wav_hdr_size;\n\n\twhile (pck_size) {\n\t\tif (!ctx->out_pck) {\n\t\t\tctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);\n\t\t\tif (!ctx->out_pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_cts(ctx->out_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_sap(ctx->out_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->framelen);\n\t\t\tgf_filter_pck_set_byte_offset(ctx->out_pck, byte_offset);\n\t\t}\n\n\t\tif (pck_size + ctx->nb_bytes_in_frame < ctx->frame_size) {\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, pck_size);\n\t\t\tctx->nb_bytes_in_frame += pck_size;\n\t\t\tpck_size = 0;\n\t\t} else {\n\t\t\tu32 remain = ctx->frame_size - ctx->nb_bytes_in_frame;\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, remain);\n\t\t\tctx->nb_bytes_in_frame = ctx->frame_size;\n\t\t\tpcmreframe_flush_packet(ctx);\n\n\t\t\tpck_size -= remain;\n\t\t\tdata += remain;\n\t\t\tbyte_offset += remain;\n\t\t\tctx->out_pck = NULL;\n\t\t\tctx->nb_bytes_in_frame = 0;\n\n\t\t\t//reverse playback, the remaining data is for the next frame, we want the previous one.\n\t\t\t//Trash packet and seek to previous frame\n\t\t\tif (ctx->reverse_play) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\tif (!ctx->cts) {\n\t\t\t\t\tif (ctx->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_STOP, ctx->ipid);\n\t\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\t\treturn GF_EOS;\n\t\t\t\t}\n\t\t\t\tctx->cts -= ctx->framelen;\n\t\t\t\tctx->filepos -= ctx->frame_size;\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t//post a seek, this will trash remaining packets in buffers\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tctx->cts += ctx->framelen;\n\t\t}\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (ctx->probe_data) {\n\t\tgf_free(ctx->probe_data);\n\t\tctx->probe_data = NULL;\n\t\tctx->probe_data_size = 0;\n\t}\n\treturn GF_OK;\n}\n\nstatic const char *pcmreframe_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tif (size<20) return NULL;\n\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tu32 code = gf_bs_read_u32(bs);\n\tif (code == GF_4CC('R', 'I', 'F', 'F')) {\n\t\tgf_bs_read_u32(bs);\n\t\tcode = gf_bs_read_u32(bs);\n\t\tif (code == GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\t*score = GF_FPROBE_SUPPORTED;\n\t\t\tgf_bs_del(bs);\n\t\t\treturn \"audio/wav\";\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\t*score = GF_FPROBE_EXT_MATCH;\n\treturn gf_audio_fmt_all_shortnames();\n}\n\n\nstatic void pcmreframe_finalize(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->out_pck) gf_filter_pck_discard(ctx->out_pck);\n\tif (ctx->probe_data) gf_free(ctx->probe_data);\n}\n\nstatic GF_FilterCapability PCMReframeCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"pcm\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/x-pcm\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"wav\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/wav\"),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_PCMReframeCtx, _n)\nstatic GF_FilterArgs PCMReframeArgs[] =\n{\n\t{ OFFS(sr), \"sample rate\", GF_PROP_UINT, \"44100\", NULL, 0},\n\t{ OFFS(safmt), \"audio format\", GF_PROP_PCMFMT, \"none\", NULL, 0},\n\t{ OFFS(ch), \"number of channels\", GF_PROP_UINT, \"2\", NULL, 0},\n\t{ OFFS(framelen), \"number of samples to put in one audio frame. For planar formats, indicate plane size in samples\", GF_PROP_UINT, \"1024\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\n\nGF_FilterRegister PCMReframeRegister = {\n\t.name = \"rfpcm\",\n\tGF_FS_SET_DESCRIPTION(\"PCM reframer\")\n\tGF_FS_SET_HELP(\"This filter parses raw PCM file/data or WAVE files and outputs corresponding raw audio PID and frames.\")\n\t.private_size = sizeof(GF_PCMReframeCtx),\n\t.args = PCMReframeArgs,\n\tSETCAPS(PCMReframeCaps),\n\t.finalize = pcmreframe_finalize,\n\t.configure_pid = pcmreframe_configure_pid,\n\t.process = pcmreframe_process,\n\t.process_event = pcmreframe_process_event,\n\t.probe_data = pcmreframe_probe_data\n};\n\n\nconst GF_FilterRegister *pcmreframe_register(GF_FilterSession *session)\n{\n\tPCMReframeArgs[1].min_max_enum = gf_audio_fmt_all_names();\n\tPCMReframeCaps[1].val.value.string = (char *) gf_audio_fmt_all_shortnames();\n\treturn &PCMReframeRegister;\n}\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/bitstream.h>\n\n/*the default size for new streams allocation...*/\n#define BS_MEM_BLOCK_ALLOC_SIZE\t\t512\n\n/*private types*/\nenum\n{\n\tGF_BITSTREAM_FILE_READ = GF_BITSTREAM_WRITE_DYN + 1,\n\tGF_BITSTREAM_FILE_WRITE,\n};\n\nstruct __tag_bitstream\n{\n\t/*original stream data*/\n\tFILE *stream;\n\n\t/*or original data*/\n\tchar *original;\n\t/*the size of our buffer in bytes*/\n\tu64 size;\n\t/*current position in BYTES*/\n\tu64 position;\n\t/*the byte readen/written*/\n\tu32 current;\n\t/*the number of bits in the current byte*/\n\tu32 nbBits;\n\t/*the bitstream mode*/\n\tu32 bsmode;\n\n\tvoid (*EndOfStream)(void *par);\n\tvoid *par;\n\n\n\tchar *cache_write;\n\tu32 cache_write_size, buffer_written;\n\n\tBool remove_emul_prevention_byte;\n\tu32 nb_zeros, nb_removed;\n\n\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size);\n\tvoid *usr_data;\n\tu64 bytes_out;\n\tu32 prevent_dispatch;\n\n\tu64 cookie;\n\n\tu8 *cache_read;\n\tu32 cache_read_size, cache_read_pos, cache_read_alloc;\n\n\tvoid (*on_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3);\n\tvoid *log_udta;\n\n\tu32 total_bits_read;\n\tu32 overflow_state;\n};\n\nGF_Err gf_bs_reassign_buffer(GF_BitStream *bs, const u8 *buffer, u64 BufferSize)\n{\n\tif (!bs) return GF_BAD_PARAM;\n\tbs->total_bits_read = 0;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tbs->original = (char*)buffer;\n\t\tbs->size = BufferSize;\n\t\tbs->position = 0;\n\t\tbs->current = 0;\n\t\tbs->nbBits = 8;\n\t\tbs->current = 0;\n\t\tbs->nb_zeros = bs->nb_removed = 0;\n\t\treturn GF_OK;\n\t}\n\tif (bs->bsmode==GF_BITSTREAM_WRITE) {\n\t\tif (!buffer || !BufferSize) return GF_BAD_PARAM;\n\t\tbs->original = (char*)buffer;\n\t\tbs->size = BufferSize;\n\t\tbs->position = 0;\n\t\tbs->current = 0;\n\t\tbs->nbBits = 0;\n\t\tbs->current = 0;\n\t\treturn GF_OK;\n\t}\n\tif (bs->bsmode!=GF_BITSTREAM_WRITE_DYN) return GF_BAD_PARAM;\n\tif (bs->original) return GF_BAD_PARAM;\n\n\tbs->position = 0;\n\tbs->current = 0;\n\tbs->nbBits = 0;\n\tbs->current = 0;\n\tbs->size = BufferSize ? BufferSize : BS_MEM_BLOCK_ALLOC_SIZE;\n\tif (buffer) {\n\t\tbs->original = (char *) buffer;\n\t} else {\n\t\tbs->original = (char *) gf_malloc(sizeof(char) * ((u32) bs->size));\n\t\tif (! bs->original) {\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_BitStream *gf_bs_new(const u8 *buffer, u64 BufferSize, u32 mode)\n{\n\tGF_BitStream *tmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\n\ttmp->original = (char*)buffer;\n\ttmp->size = BufferSize;\n\n\ttmp->bsmode = mode;\n\n\tswitch (tmp->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\t\ttmp->nbBits = 8;\n\t\ttmp->current = 0;\n\t\tbreak;\n\tcase GF_BITSTREAM_WRITE:\n\tcase GF_BITSTREAM_WRITE_DYN:\n\t\ttmp->nbBits = 0;\n\t\tif (! buffer) {\n\t\t\t/*if BufferSize is specified, use it. This is typically used when AvgSize of\n\t\t\tsome buffers is known, but some exceed it.*/\n\t\t\tif (BufferSize) {\n\t\t\t\ttmp->size = BufferSize;\n\t\t\t} else {\n\t\t\t\ttmp->size = BS_MEM_BLOCK_ALLOC_SIZE;\n\t\t\t}\n\t\t\ttmp->original = (char *) gf_malloc(sizeof(char) * ((u32) tmp->size));\n\t\t\tif (! tmp->original) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp->bsmode = GF_BITSTREAM_WRITE_DYN;\n\t\t} else {\n\t\t\ttmp->original = (char*)buffer;\n\t\t\ttmp->size = BufferSize;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/*the stream constructor is not the same...*/\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_BitStream *gf_bs_from_file(FILE *f, u32 mode)\n{\n\tGF_BitStream *tmp;\n\tif (!f) return NULL;\n\n\ttmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\t/*switch to internal mode*/\n\tmode = (mode==GF_BITSTREAM_READ) ? GF_BITSTREAM_FILE_READ : GF_BITSTREAM_FILE_WRITE;\n\ttmp->bsmode = mode;\n\ttmp->current = 0;\n\ttmp->nbBits = (mode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\ttmp->original = NULL;\n\ttmp->position = 0;\n\ttmp->stream = f;\n\n\t/*get the size of this file (for read streams)*/\n\ttmp->position = gf_ftell(f);\n\ttmp->size = gf_fsize(f);\n\tgf_fseek(f, tmp->position, SEEK_SET);\n\n\n\tif (mode==GF_BITSTREAM_FILE_READ) {\n\t\ttmp->cache_read_alloc = gf_opts_get_int(\"core\", \"bs-cache-size\");\n\t\tif (tmp->cache_read_alloc) {\n\t\t\ttmp->cache_read_pos = tmp->cache_read_size = tmp->cache_read_alloc;\n\t\t\ttmp->cache_read = gf_malloc(tmp->cache_read_alloc);\n\t\t\tif (!tmp->cache_read) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (mode == GF_BITSTREAM_FILE_WRITE) {\n\t\ttmp->cache_write_size = gf_opts_get_int(\"core\", \"bs-cache-size\");\n\t\tif (tmp->cache_write_size) {\n\t\t\ttmp->cache_write = (char*)gf_malloc(tmp->cache_write_size);\n\t\t\tif (!tmp->cache_write) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp->buffer_written = 0;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\n\nGF_BitStream *gf_bs_new_cbk_buffer(GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size), void *usr_data, u8 *buffer, u32 buffer_size)\n{\n\tGF_BitStream *tmp;\n\n\tif (!on_block_out) return NULL;\n\n\ttmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\n\tif (buffer && buffer_size) {\n\t\ttmp->size = buffer_size;\n\t\ttmp->original = buffer;\n\t} else {\n\t\ttmp->size = buffer_size ? buffer_size : 10*BS_MEM_BLOCK_ALLOC_SIZE;\n\t\ttmp->original = (char *) gf_malloc(sizeof(char) * ((u32) tmp->size));\n\t\tif (! tmp->original) {\n\t\t\tgf_free(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bsmode = GF_BITSTREAM_WRITE_DYN;\n\ttmp->on_block_out = on_block_out;\n\ttmp->usr_data = usr_data;\n\n\treturn tmp;\n}\n\nGF_BitStream *gf_bs_new_cbk(GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size), void *usr_data, u32 block_size)\n{\n\treturn gf_bs_new_cbk_buffer(on_block_out, usr_data, NULL, block_size);\n\n}\nvoid gf_bs_prevent_dispatch(GF_BitStream *bs, Bool prevent_dispatch)\n{\n\tif (!bs) return;\n\tif (prevent_dispatch) {\n\t\tbs->prevent_dispatch ++;\n\t\treturn;\n\t}\n\tif (!bs->prevent_dispatch) return;\n\tbs->prevent_dispatch --;\n\n\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\tassert(bs->position >= bs->bytes_out);\n\t\tif (bs->position > bs->bytes_out) {\n\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out));\n\t\t\tbs->bytes_out = bs->position;\n\t\t}\n\t}\n}\n\nstatic Bool bs_flush_write_cache(GF_BitStream *bs)\n{\n\tBool res = GF_TRUE;\n\tif (bs->buffer_written) {\n\t\tu32 nb_write;\n\t\tnb_write = (u32) gf_fwrite(bs->cache_write, bs->buffer_written, bs->stream);\n\t\tif (nb_write != bs->buffer_written)\n\t\t\tres = GF_FALSE;\n\t\t//check we didn't rewind the bitstream\n\t\tif (bs->size == bs->position)\n\t\t\tbs->size += nb_write;\n\t\tbs->position += nb_write;\n\t\tbs->buffer_written = 0;\n\t}\n\treturn res;\n}\n\n\n\nGF_EXPORT\nvoid gf_bs_del(GF_BitStream *bs)\n{\n\tif (!bs) return;\n\tif (bs->on_block_out && bs->position>bs->bytes_out) {\n\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t}\n\t/*if we are in dynamic mode (alloc done by the bitstream), free the buffer if still present*/\n\tif ((bs->bsmode == GF_BITSTREAM_WRITE_DYN) && bs->original) gf_free(bs->original);\n\tif (bs->cache_write) {\n\t\tbs_flush_write_cache(bs);\n\t\tgf_free(bs->cache_write);\n\t}\n\tif (bs->cache_read)\n\t\tgf_free(bs->cache_read);\n\tgf_free(bs);\n}\n\nGF_EXPORT\nvoid gf_bs_enable_emulation_byte_removal(GF_BitStream *bs, Bool do_remove)\n{\n\tif (bs) {\n\t\tbs->remove_emul_prevention_byte = do_remove;\n\t\tbs->nb_zeros = bs->nb_removed = 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_bs_get_emulation_byte_removed(GF_BitStream *bs)\n{\n\tif (bs) return bs->nb_removed;\n\treturn 0;\n}\n\n\n/*returns 1 if aligned wrt current mode, 0 otherwise*/\nBool gf_bs_is_align(GF_BitStream *bs)\n{\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\tcase GF_BITSTREAM_FILE_READ:\n\t\treturn ( (8 == bs->nbBits) ? GF_TRUE : GF_FALSE);\n\tdefault:\n\t\treturn !bs->nbBits;\n\t}\n}\n\nstatic GFINLINE u8 gf_bs_load_byte(GF_BitStream *bs, Bool *is_eos)\n{\n\tu8 res;\n\tif (bs->cache_read) {\n\t\tif (bs->cache_read_pos == bs->cache_read_size) {\n\t\t\tbs->cache_read_size = (u32) gf_fread(bs->cache_read, bs->cache_read_alloc, bs->stream);\n\t\t\tbs->cache_read_pos = 0;\n\t\t\tif (!bs->cache_read_size) {\n\t\t\t\t*is_eos = GF_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tres = bs->cache_read[bs->cache_read_pos];\n\t\tbs->cache_read_pos++;\n\t} else {\n\t\tres = gf_fgetc(bs->stream);\n\t}\n\treturn res;\n}\n\n/*fetch a new byte in the bitstream switch between packets*/\nstatic u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tbs->nb_removed++;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tis_eos = bs->stream ? gf_feof(bs->stream) : GF_TRUE;\n\t//cache not fully read, reset EOS\n\tif (bs->cache_read && (bs->cache_read_pos<bs->cache_read_size))\n\t\tis_eos = GF_FALSE;\n\n\t/*we are in FILE mode, test for end of file*/\n\tif (!is_eos) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tbs->nb_removed++;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tif (!bs->overflow_state) {\n\t\t\tbs->overflow_state = 1;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t\t}\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}\n\n#define NO_OPTS\n\n#ifndef NO_OPTS\nstatic u32 bit_mask[] = {0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};\nstatic u32 bits_mask[] = {0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F};\n#endif\n\nGF_EXPORT\nu8 gf_bs_read_bit(GF_BitStream *bs)\n{\n\tif (bs->nbBits == 8) {\n\t\tbs->current = BS_ReadByte(bs);\n\t\tbs->nbBits = 0;\n\t}\n#ifdef NO_OPTS\n\t{\n\t\ts32 ret;\n\t\tbs->current <<= 1;\n\t\tbs->nbBits++;\n\t\tret = (bs->current & 0x100) >> 8;\n\t\treturn (u8) ret;\n\t}\n#else\n\treturn (u8) (bs->current & bit_mask[bs->nbBits++]) ? 1 : 0;\n#endif\n\n}\n\nGF_EXPORT\nu32 gf_bs_read_int(GF_BitStream *bs, u32 nBits)\n{\n\tu32 ret;\n\tbs->total_bits_read+= nBits;\n\n#ifndef NO_OPTS\n\tif (nBits + bs->nbBits <= 8) {\n\t\tbs->nbBits += nBits;\n\t\tret = (bs->current >> (8 - bs->nbBits) ) & bits_mask[nBits];\n\t\treturn ret;\n\t}\n#endif\n\tret = 0;\n\twhile (nBits-- > 0) {\n\t\tret <<= 1;\n\t\tret |= gf_bs_read_bit(bs);\n\t}\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u8(GF_BitStream *bs)\n{\n\tassert(bs->nbBits==8);\n\tif (bs->cache_read && (bs->cache_read_pos+1<bs->cache_read_size) ) {\n\t\tu32 ret = bs->cache_read[bs->cache_read_pos];\n\t\tbs->cache_read_pos+=1;\n\t\tbs->position+=1;\n\t\treturn ret;\n\t}\n\n\treturn (u32) BS_ReadByte(bs);\n}\n\n#if 0\nGF_EXPORT\nu32 gf_bs_read_u8_until_delimiter(GF_BitStream *bs, u8 delimiter, u8* out, u32 max_length) {\n\tu32 i = 0;\n\tchar token=0;\n\tu64 cur_pos = gf_bs_get_position(bs);\n\n\tif (!max_length) out = NULL;\n\n\twhile(gf_bs_available(bs) && (!max_length || i < max_length)) {\n\t\tgf_bs_read_data(bs, &token, 1);\n\t\tif (token == delimiter) goto found;\n\t\tif (out) out[i] = token;\n\t\ti++;\n\t}\n\n\t/* Delimiter not found */\n\tgf_bs_seek(bs, cur_pos);\n\treturn 0;\n\nfound:\n\treturn i;\n}\n#endif\n\nGF_EXPORT\nu32 gf_bs_read_u16(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\tif (bs->cache_read && (bs->cache_read_pos+2<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tbs->cache_read_pos+=2;\n\t\tbs->position+=2;\n\t\treturn ret;\n\t}\n\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\n\nGF_EXPORT\nu32 gf_bs_read_u24(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\n\tif (bs->cache_read && (bs->cache_read_pos+3<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tbs->cache_read_pos+=3;\n\t\tbs->position+=3;\n\t\treturn ret;\n\t}\n\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u32(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\n\tif (bs->cache_read && (bs->cache_read_pos+4<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+3];\n\t\tbs->cache_read_pos+=4;\n\t\tbs->position+=4;\n\t\treturn ret;\n\t}\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_read_u64(GF_BitStream *bs)\n{\n\tu64 ret;\n\n\tif (bs->cache_read && (bs->cache_read_pos+8<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+3];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+4];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+5];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+6];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+7];\n\t\tbs->cache_read_pos+=8;\n\t\tbs->position+=8;\n\t\treturn ret;\n\t}\n\tret = gf_bs_read_u32(bs);\n\tret<<=32;\n\tret |= gf_bs_read_u32(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_read_long_int(GF_BitStream *bs, u32 nBits)\n{\n\tu64 ret = 0;\n\tif (nBits>64) {\n\t\tu32 skip = nBits-64;\n\t\tif (gf_bs_available(bs) * 8 < nBits-8) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tbs->position = bs->size;\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Reading %d bits but max should be 64, skipping %d most significants bits\\n\", nBits, nBits-64));\n\t\t//avoid recursion\n\t\twhile (skip) {\n\t\t\tif (skip>32) {\n\t\t\t\tgf_bs_read_int(bs, 32);\n\t\t\t\tskip-=32;\n\t\t\t} else {\n\t\t\t\tgf_bs_read_int(bs, skip);\n\t\t\t\tskip=0;\n\t\t\t}\n\t\t}\n\t\tret = gf_bs_read_long_int(bs, 64);\n\t} else {\n\t\twhile (nBits-- > 0) {\n\t\t\tret <<= 1;\n\t\t\tret |= gf_bs_read_bit(bs);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nGF_EXPORT\nFloat gf_bs_read_float(GF_BitStream *bs)\n{\n\tchar buf [4] = \"\\0\\0\\0\";\n#ifdef NO_OPTS\n\ts32 i;\n\tfor (i = 0; i < 32; i++)\n\t\tbuf[3-i/8] |= gf_bs_read_bit(bs) << (7 - i%8);\n#else\n\tbuf[3] = gf_bs_read_int(bs, 8);\n\tbuf[2] = gf_bs_read_int(bs, 8);\n\tbuf[1] = gf_bs_read_int(bs, 8);\n\tbuf[0] = gf_bs_read_int(bs, 8);\n#endif\n\treturn (* (Float *) buf);\n}\n\nGF_EXPORT\nDouble gf_bs_read_double(GF_BitStream *bs)\n{\n\tchar buf [8] = \"\\0\\0\\0\\0\\0\\0\\0\";\n\ts32 i;\n\tfor (i = 0; i < 64; i++)\n\t\tbuf[7-i/8] |= gf_bs_read_bit(bs) << (7 - i%8);\n\treturn (* (Double *) buf);\n}\n\nGF_EXPORT\nu32 gf_bs_read_data(GF_BitStream *bs, u8 *data, u32 nbBytes)\n{\n\tu64 orig = bs->position;\n\n\tif (bs->position+nbBytes > bs->size) return 0;\n\n\tif (gf_bs_is_align(bs) ) {\n\t\ts32 bytes_read, bytes_read_cache;\n\t\tswitch (bs->bsmode) {\n\t\tcase GF_BITSTREAM_READ:\n\t\tcase GF_BITSTREAM_WRITE:\n\t\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t\tmemcpy(data, bs->original + bs->position, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_FILE_READ:\n\t\tcase GF_BITSTREAM_FILE_WRITE:\n\t\t\tif (bs->cache_write)\n\t\t\t\tbs_flush_write_cache(bs);\n\n\t\t\tbytes_read = bytes_read_cache = 0;\n\t\t\tif (bs->cache_read) {\n\t\t\t\tu32 csize = bs->cache_read_size-bs->cache_read_pos;\n\t\t\t\tif (csize>nbBytes) csize = nbBytes;\n\t\t\t\tmemcpy(data, bs->cache_read + bs->cache_read_pos, csize);\n\t\t\t\tbs->cache_read_pos += csize;\n\t\t\t\tnbBytes -= csize;\n\t\t\t\tbytes_read_cache = csize;\n\t\t\t}\n\t\t\tif (nbBytes) {\n\t\t\t\tbytes_read = (s32) gf_fread(data + bytes_read_cache, nbBytes, bs->stream);\n\t\t\t\tif (bytes_read<0) return bytes_read_cache;\n\t\t\t}\n\t\t\tbs->position += bytes_read + bytes_read_cache;\n\t\t\treturn bytes_read + bytes_read_cache;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (nbBytes-- > 0) {\n\t\t*data++ = gf_bs_read_int(bs, 8);\n\t}\n\treturn (u32) (bs->position - orig);\n\n}\n\n\n\nstatic void BS_WriteByte(GF_BitStream *bs, u8 val)\n{\n\t/*we don't allow write on READ buffers*/\n\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_FILE_READ) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write on read bitstream\\n\"));\n\t\treturn;\n\t}\n\tif (!bs->original && !bs->stream) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write on unassigned bitstream\\n\"));\n\t\treturn;\n\t}\n\t/*we are in MEM mode*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN) ) {\n\t\t//if callback mode and dispatch is not blocked, dispatch\n\t\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\tif (bs->position - bs->bytes_out == bs->size) {\n\t\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out));\n\t\t\t\tbs->bytes_out = bs->position;\n\t\t\t}\n\t\t\tif (bs->original)\n\t\t\t\tbs->original[bs->position - bs->bytes_out] = val;\n\t\t\tbs->position++;\n\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\treturn;\n\t\t}\n\t\t//otherwise store\n\t\tif (bs->position - bs->bytes_out == bs->size) {\n\t\t\t/*no more space...*/\n\t\t\tif (bs->bsmode != GF_BITSTREAM_WRITE_DYN) return;\n\t\t\t/*gf_realloc if enough space...*/\n\t\t\tif (bs->size > 0xFFFFFFFF) return;\n\t\t\tbs->size = bs->size ? (bs->size * 2) : BS_MEM_BLOCK_ALLOC_SIZE;\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32)bs->size);\n\t\t\tif (!bs->original) return;\n\t\t}\n\t\tif (bs->original)\n\t\t\tbs->original[bs->position - bs->bytes_out] = val;\n\t\tbs->position++;\n\t\treturn;\n\t}\n\tif (bs->cache_write) {\n\t\tif (bs->buffer_written == bs->cache_write_size) {\n\t\t\tbs_flush_write_cache(bs);\n\t\t}\n\t\tbs->cache_write[bs->buffer_written] = val;\n\t\tbs->buffer_written++;\n\t\tif (bs->buffer_written == bs->cache_write_size) {\n\t\t\tbs_flush_write_cache(bs);\n\t\t}\n\t\treturn;\n\t}\n\t/*we are in FILE mode, no pb for any gf_realloc...*/\n\tgf_fputc(val, bs->stream);\n\n\t/*check we didn't rewind the stream*/\n\tif (bs->size == bs->position) bs->size++;\n\tbs->position += 1;\n}\n\nstatic void BS_WriteBit(GF_BitStream *bs, u32 bit)\n{\n\tbs->current <<= 1;\n\tbs->current |= bit;\n\tif (++ bs->nbBits == 8) {\n\t\tbs->nbBits = 0;\n\t\tBS_WriteByte(bs, (u8) bs->current);\n\t\tbs->current = 0;\n\t}\n}\n\nstatic s32 bs_handle_nbits_overflow(GF_BitStream* bs, s32 nBits, s32 max_shift)\n{\n\tif (nBits > max_shift) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write %d bits, when max is %d\\n\", nBits, max_shift));\n\t}\n\twhile (nBits > max_shift) {\n\t\tgf_bs_write_long_int(bs, 0, max_shift);\n\t\tnBits -= max_shift;\n\t}\n\n\treturn nBits;\n}\n\nGF_EXPORT\nvoid gf_bs_write_int(GF_BitStream *bs, s32 _value, s32 nBits)\n{\n\tu32 value, nb_shift;\n\ts32 max_shift = sizeof(s32) * 8;\n\tif (!nBits) return;\n\tnBits = bs_handle_nbits_overflow(bs, nBits, max_shift);\n\t//move to unsigned to avoid sanitizer warnings when we pass a value not codable on the given number of bits\n\t//we do this when setting bit fields to all 1's\n\tvalue = (u32) _value;\n\tnb_shift = max_shift - nBits;\n\tif (nb_shift)\n\t\tvalue <<= nb_shift;\n\n\twhile (--nBits >= 0) {\n\t\t//but check value as signed\n\t\tBS_WriteBit (bs, ((s32)value) < 0);\n\t\tvalue <<= 1;\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_long_int(GF_BitStream *bs, s64 _value, s32 nBits)\n{\n\ts32 max_shift = sizeof(s64) * 8;\n\tif (!nBits) return;\n\tnBits = bs_handle_nbits_overflow(bs, nBits, max_shift);\n\n\t//cf note in gf_bs_write_int\n\tu64 value = (u64) _value;\n\tvalue <<= max_shift - nBits;\n\twhile (--nBits >= 0) {\n\t\tBS_WriteBit (bs, ((s64)value) < 0);\n\t\tvalue <<= 1;\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u8(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\n\tif (bs->cache_write && (bs->buffer_written+1 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) value;\n\t\tbs->buffer_written += 1;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) value);\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u16(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+2 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 2;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u24(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+3 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>16)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+2] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 3;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>16)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u32(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+4 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>24)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value>>16)&0xff);\n\t\tbs->cache_write[bs->buffer_written+2] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+3] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 4;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>24)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>16)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u64(GF_BitStream *bs, u64 value)\n{\n\tassert(!bs->nbBits);\n\tgf_bs_write_u32(bs, (u32) ((value>>32)&0xffffffff));\n\tgf_bs_write_u32(bs, (u32) (value&0xffffffff));\n}\n\nGF_EXPORT\nu32 gf_bs_write_byte(GF_BitStream *bs, u8 byte, u32 repeat_count)\n{\n\tif (!gf_bs_is_align(bs) || bs->cache_write) {\n\t\tu32 count = 0;\n\t\twhile (count<repeat_count) {\n\t\t\tgf_bs_write_int(bs, byte, 8);\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_WRITE:\n\t\tif (bs->position + repeat_count > bs->size)\n\t\t\treturn 0;\n\t\tmemset(bs->original + bs->position, byte, repeat_count);\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t/*need to gf_realloc ...*/\n\t\tif (bs->position+repeat_count> bs->size) {\n\t\t\tu32 new_size = (u32) (bs->size*2);\n\t\t\tif (!new_size) new_size = BS_MEM_BLOCK_ALLOC_SIZE;\n\n\t\t\tif (bs->size + repeat_count > 0xFFFFFFFF)\n\t\t\t\treturn 0;\n\t\t\twhile (new_size < (u32) ( bs->size + repeat_count))\n\t\t\t\tnew_size *= 2;\n\t\t\tbs->original = (char*)gf_realloc(bs->original, sizeof(u32)*new_size);\n\t\t\tif (!bs->original)\n\t\t\t\treturn 0;\n\t\t\tbs->size = new_size;\n\t\t}\n\t\tmemset(bs->original + bs->position, byte, repeat_count);\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tcase GF_BITSTREAM_FILE_READ:\n\tcase GF_BITSTREAM_FILE_WRITE:\n\t\tif (gf_fwrite(&byte, repeat_count, bs->stream) != repeat_count)\n\t\t\treturn 0;\n\t\tif (bs->size == bs->position) bs->size += repeat_count;\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n\nGF_EXPORT\nvoid gf_bs_write_float(GF_BitStream *bs, Float value)\n{\n\tu32 i;\n\tunion\n\t{\tfloat f;\n\t\tchar sz [4];\n\t} float_value;\n\tfloat_value.f = value;\n\n\tfor (i = 0; i < 32; i++)\n\t\tBS_WriteBit(bs, (float_value.sz [3 - i / 8] & 1 << (7 - i % 8)) != 0);\n\n}\n\nGF_EXPORT\nvoid gf_bs_write_double (GF_BitStream *bs, Double value)\n{\n\tu32 i;\n\tunion\n\t{\tDouble d;\n\t\tchar sz [8];\n\t} double_value;\n\tdouble_value.d = value;\n\tfor (i = 0; i < 64; i++) {\n\t\tBS_WriteBit(bs, (double_value.sz [7 - i / 8] & 1 << (7 - i % 8)) != 0);\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_bs_write_data(GF_BitStream *bs, const u8 *data, u32 nbBytes)\n{\n\t/*we need some feedback for this guy...*/\n\tu64 begin = bs->position;\n\tif (!nbBytes) return 0;\n\n\tif (gf_bs_is_align(bs)) {\n\t\tswitch (bs->bsmode) {\n\t\tcase GF_BITSTREAM_WRITE:\n\t\t\tif (bs->position+nbBytes > bs->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overwrite bitstream by %d bytes\\n\", bs->position + nbBytes - bs->size));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(bs->original + bs->position, data, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t\t//if callback mode and dispatch not disabled, dispatch bytes\n\t\t\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\t\t\tassert(bs->position >= bs->bytes_out);\n\n\t\t\t\tif (bs->position - bs->bytes_out + nbBytes <= bs->size) {\n\t\t\t\t\tmemcpy(bs->original + bs->position - bs->bytes_out, data, nbBytes);\n\t\t\t\t\tbs->position += nbBytes;\n\t\t\t\t} else {\n\t\t\t\t\tif (bs->position > bs->bytes_out)\n\t\t\t\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t\t\t\t\tif (nbBytes)\n\t\t\t\t\t\tbs->on_block_out(bs->usr_data, (char *) data, nbBytes);\n\n\t\t\t\t\tbs->position += nbBytes;\n\t\t\t\t\tbs->bytes_out = bs->position;\n\t\t\t\t}\n\t\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\t\treturn nbBytes;\n\t\t\t}\n\t\t\t//otherwise store\n\t\t\t/*need to gf_realloc ...*/\n\t\t\tif (bs->position + nbBytes - bs->bytes_out > bs->size) {\n\t\t\t\tu32 new_size = (u32) (bs->size*2);\n\t\t\t\tif (!new_size) new_size = BS_MEM_BLOCK_ALLOC_SIZE;\n\n\t\t\t\tif (bs->size + nbBytes > 0xFFFFFFFF)\n\t\t\t\t\treturn 0;\n\n\t\t\t\twhile (new_size < (u32) ( bs->size + nbBytes))\n\t\t\t\t\tnew_size *= 2;\n\t\t\t\tbs->original = (char*)gf_realloc(bs->original, sizeof(u32)*new_size);\n\t\t\t\tif (!bs->original)\n\t\t\t\t\treturn 0;\n\t\t\t\tbs->size = new_size;\n\t\t\t}\n\t\t\tmemcpy(bs->original + bs->position - bs->bytes_out, data, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_FILE_READ:\n\t\tcase GF_BITSTREAM_FILE_WRITE:\n\t\t\tif (bs->cache_write) {\n\t\t\t\t//if block fits in our write cache, write it\n\t\t\t\tif (bs->buffer_written + nbBytes < bs->cache_write_size) {\n\t\t\t\t\tmemcpy(bs->cache_write+bs->buffer_written, data, nbBytes);\n\t\t\t\t\tbs->buffer_written+=nbBytes;\n\t\t\t\t\treturn nbBytes;\n\t\t\t\t}\n\t\t\t\t//otherwise flush cache and use file write\n\t\t\t\tif (!bs_flush_write_cache(bs))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (gf_fwrite(data, nbBytes, bs->stream) != nbBytes) return 0;\n\n\t\t\tif (bs->size == bs->position) bs->size += nbBytes;\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, (s32) *data, 8);\n\t\tdata++;\n\t\tnbBytes--;\n\t}\n\treturn (u32) (bs->position - begin);\n}\n\n/*align return the num of bits read in READ mode, 0 in WRITE*/\nGF_EXPORT\nu8 gf_bs_align(GF_BitStream *bs)\n{\n\tu8 res = 8 - bs->nbBits;\n\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (res > 0) {\n\t\t\tgf_bs_read_int(bs, res);\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->nbBits > 0) {\n\t\tgf_bs_write_int (bs, 0, res);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\n\n/*size available in the bitstream*/\nGF_EXPORT\nu64 gf_bs_available(GF_BitStream *bs)\n{\n\ts64 cur, end;\n\n\t/*in WRITE mode only, this should not be called, but return something big in case ...*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE)\n\t        || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)\n\t   )\n\t\treturn (u64) -1;\n\n\t/*we are in MEM mode*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->size < bs->position)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn (bs->size - bs->position);\n\t}\n\t/*FILE READ: assume size hasn't changed, otherwise the user shall call gf_bs_get_refreshed_size*/\n\tif (bs->bsmode==GF_BITSTREAM_FILE_READ) {\n\t\tif (bs->position>bs->size) return 0;\n\t\treturn (bs->size - bs->position);\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tcur = gf_ftell(bs->stream);\n\tend = gf_fsize(bs->stream);\n\tgf_fseek(bs->stream, cur, SEEK_SET);\n\n\treturn (u64) (end - cur);\n}\n\n/*call this funct to set the buffer size to the nb of bytes written\nUsed only in WRITE mode, as we don't know the real size during allocation...\nreturn -1 for bad param or gf_malloc failed\nreturn nbBytes cut*/\nstatic s32 BS_CutBuffer(GF_BitStream *bs)\n{\n\ts32 nbBytes;\n\tif ( (bs->bsmode != GF_BITSTREAM_WRITE_DYN) && (bs->bsmode != GF_BITSTREAM_WRITE)) return (u32) -1;\n\t/*Align our buffer or we're dead!*/\n\tgf_bs_align(bs);\n\n\tnbBytes = (u32) (bs->size - bs->position);\n\tif (!nbBytes || (nbBytes == 0xFFFFFFFF) || (bs->position >= 0xFFFFFFFF)) return 0;\n\t/*\n\t\tbs->original = (char*)gf_realloc(bs->original, (u32) bs->position);\n\t\tif (! bs->original) return (u32) -1;\n\t*/\n\t/*just in case, re-adjust..*/\n\tbs->size = bs->position;\n\treturn nbBytes;\n}\n\n/*For DYN mode, this gets the content out without cutting the buffer to the number of written bytes*/\nGF_EXPORT\nvoid gf_bs_get_content_no_truncate(GF_BitStream *bs, u8 **output, u32 *outSize, u32 *alloc_size)\n{\n\t/*only in WRITE MEM mode*/\n\tif (!bs || bs->bsmode != GF_BITSTREAM_WRITE_DYN) return;\n\n\tif (bs->on_block_out && bs->position>bs->bytes_out) {\n\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t}\n\n\tif (!bs->position && !bs->nbBits) {\n\t\tif (!alloc_size) {\n\t\t\t*output = NULL;\n\t\t\tgf_free(bs->original);\n\t\t} else {\n\t\t\t*alloc_size = (u32) bs->size;\n\t\t\t*output = bs->original;\n\t\t}\n\t\t*outSize = 0;\n\t} else {\n\t\tif (alloc_size) {\n\t\t\t/*Align our buffer or we're dead!*/\n\t\t\tgf_bs_align(bs);\n\t\t\t*alloc_size = (u32) bs->size;\n\t\t\t*outSize = (u32) bs->position;\n\t\t\t*output = bs->original;\n\t\t} else {\n\t\t\ts32 copy = BS_CutBuffer(bs);\n\t\t\tif (copy < 0) {\n\t\t\t\t*output = NULL;\n\t\t\t} else\n\t\t\t\t*output = bs->original;\n\t\t\t*outSize = (u32) bs->size;\n\t\t}\n\t}\n\tbs->original = NULL;\n\tbs->size = 0;\n\tbs->position = 0;\n}\n\n/*For DYN mode, this gets the content out*/\nGF_EXPORT\nvoid gf_bs_get_content(GF_BitStream *bs, u8 **output, u32 *outSize)\n{\n\tgf_bs_get_content_no_truncate(bs, output, outSize, NULL);\n}\n\n/*\tSkip nbytes.\n\tAlign\n\tIf READ (MEM or FILE) mode, just read n times 8 bit\n\tIf WRITE (MEM or FILE) mode, write n times 0 on 8 bit\n*/\nGF_EXPORT\nvoid gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\n\tgf_bs_align(bs);\n\n\t/*special case for file skipping...*/\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\t//weird msys2 bug resulting in broken seek on some files ?!?  -the bug is not happening when doing absolute seek\n//\t\tgf_fseek(bs->stream, nbBytes, SEEK_CUR);\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\n\t/*special case for reading*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t}\n\t\treturn;\n\t}\n\t/*for writing we must do it this way, otherwise pb in dynamic buffers*/\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}\n\n#ifdef GPAC_ENABLE_BIFS_PMF\n\nvoid gf_bs_rewind_bits(GF_BitStream *bs, u64 nbBits)\n{\n\tu64 nbBytes;\n\tif (bs->bsmode != GF_BITSTREAM_READ) return;\n\n\tnbBits -= (bs->nbBits);\n\tnbBytes = (nbBits+8)>>3;\n\tnbBits = nbBytes*8 - nbBits;\n\tgf_bs_align(bs);\n\tassert(bs->position >= nbBytes);\n\tbs->position -= nbBytes + 1;\n\tgf_bs_read_int(bs, (u32)nbBits);\n\treturn;\n}\n\n#endif\n\n/*seek from beginning of stream: use internally even when non aligned!*/\nstatic GF_Err BS_SeekIntern(GF_BitStream *bs, u64 offset)\n{\n\tu32 i;\n\t/*if mem, do it */\n\tif ((bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)) {\n\t\tif (offset > 0xFFFFFFFF) return GF_IO_ERR;\n\t\tif (!bs->original) return GF_BAD_PARAM;\n\t\t/*0 for write, read will be done automatically*/\n\t\tif (offset >= bs->size) {\n\t\t\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) ) {\n\t\t\t\tif (offset > bs->size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[BS] Attempt to seek to %d after end of bitstream %d, assuming seek to end\\n\", offset, bs->size));\n\t\t\t\t}\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t/*in DYN, gf_realloc ...*/\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32) (offset + 1));\n\t\t\tif (!bs->original)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i = 0; i < (u32) (offset + 1 - bs->size); i++) {\n\t\t\t\tbs->original[bs->size + i] = 0;\n\t\t\t}\n\t\t\tbs->size = offset + 1;\n\t\t}\n\t\tbs->current = bs->original[offset];\n\t\tbs->position = offset;\n\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tif (bs->cache_read) {\n\t\tbs->cache_read_pos = bs->cache_read_size;\n\t}\n\n\tgf_fseek(bs->stream, offset, SEEK_SET);\n\n\tbs->position = offset;\n\tbs->current = 0;\n\t/*setup NbBits so that next acccess to the buffer will trigger read/write*/\n\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\treturn GF_OK;\n}\n\n/*seek from beginning of stream: align before anything else*/\nGF_EXPORT\nGF_Err gf_bs_seek(GF_BitStream *bs, u64 offset)\n{\n\tbs->overflow_state = 0;\n\tif (bs->on_block_out) {\n\t\tGF_Err e;\n\t\tif (offset < bs->bytes_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to seek on byte range already forwarded\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\t/*warning: we allow offset = bs->size for WRITE buffers*/\n\t\tif (offset - bs->bytes_out > bs->size)\n\t\t\treturn GF_BAD_PARAM;\n\t\tgf_bs_align(bs);\n\t\te = BS_SeekIntern(bs, offset - bs->bytes_out);\n\t\tbs->position += bs->bytes_out;\n\t\treturn e;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\t/*warning: we allow offset = bs->size for WRITE buffers*/\n\tif (offset > bs->size) return GF_BAD_PARAM;\n\n\tgf_bs_align(bs);\n\treturn BS_SeekIntern(bs, offset);\n}\n\n/*peek bits (as int!!) from orig position (ON BYTE BOUNDARIES, from 0) - only for read ...*/\nGF_EXPORT\nu32 gf_bs_peek_bits(GF_BitStream *bs, u32 numBits, u64 byte_offset)\n{\n\tu64 curPos;\n\tu32 curBits, ret, current, nb_zeros, nb_removed;\n\n\tif ( (bs->bsmode != GF_BITSTREAM_READ) && (bs->bsmode != GF_BITSTREAM_FILE_READ)) return 0;\n\tif (!numBits || (bs->size < bs->position + byte_offset)) return 0;\n\n\t/*store our state*/\n\tcurPos = bs->position;\n\tcurBits = bs->nbBits;\n\tcurrent = bs->current;\n\tnb_zeros = bs->nb_zeros;\n\tnb_removed = bs->nb_removed;\n\n\tif (byte_offset) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (byte_offset) {\n\t\t\t\tgf_bs_read_int(bs, 8);\n\t\t\t\tbyte_offset--;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_seek(bs, bs->position + byte_offset);\n\t\t}\n\t}\n\tret = gf_bs_read_int(bs, numBits);\n\n\t/*restore our cache - position*/\n\tgf_bs_seek(bs, curPos);\n\t/*to avoid re-reading our bits ...*/\n\tbs->nbBits = curBits;\n\tbs->current = current;\n\tbs->nb_zeros = nb_zeros;\n\tbs->nb_removed = nb_removed;\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_get_refreshed_size(GF_BitStream *bs)\n{\n\ts64 offset;\n\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\tcase GF_BITSTREAM_WRITE:\n\t\treturn bs->size;\n\n\tdefault:\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->stream) {\n\t\t\toffset = gf_ftell(bs->stream);\n\t\t\tbs->size = gf_fsize(bs->stream);\n\t\t\tgf_fseek(bs->stream, offset, SEEK_SET);\n\t\t}\n\t\treturn bs->size;\n\t}\n}\n\nGF_EXPORT\nu64 gf_bs_get_size(GF_BitStream *bs)\n{\n\tif (bs->cache_write) {\n\t\tif (bs->size == bs->position)\n\t\t\treturn bs->size + bs->buffer_written;\n\t\telse\n\t\t\treturn bs->size;\n\t}\n\tif (bs->on_block_out)\n\t\treturn bs->position;\n\treturn bs->size;\n}\n\nGF_EXPORT\nu64 gf_bs_get_position(GF_BitStream *bs)\n{\n\tif (bs->cache_write)\n\t\treturn bs->position + bs->buffer_written;\n\treturn bs->position;\n}\n\nGF_EXPORT\nu8 gf_bs_bits_available(GF_BitStream *bs)\n{\n\tif (bs->size > bs->position) return 8;\n\tif (bs->nbBits < 8) return (8-bs->nbBits);\n\treturn 0;\n}\n\nGF_EXPORT\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par)\n{\n\tbs->EndOfStream = EndOfStream;\n\tbs->par = par;\n}\n\n\nGF_EXPORT\nu64 gf_bs_read_u64_le(GF_BitStream *bs)\n{\n\tu64 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=16;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=24;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=32;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=40;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=48;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=56;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u32_le(GF_BitStream *bs)\n{\n\tu32 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=16;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=24;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nu16 gf_bs_read_u16_le(GF_BitStream *bs)\n{\n\tu32 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nvoid gf_bs_write_u64_le(GF_BitStream *bs, u64 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>8) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>16) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>24) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>32) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>40) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>48) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>56) & 0xFF, 8);\n}\n\nGF_EXPORT\nvoid gf_bs_write_u32_le(GF_BitStream *bs, u32 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, val>>8, 8);\n\tgf_bs_write_int(bs, val>>16, 8);\n\tgf_bs_write_int(bs, val>>24, 8);\n}\n\nGF_EXPORT\nvoid gf_bs_write_u16_le(GF_BitStream *bs, u32 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, val>>8, 8);\n}\n\nGF_EXPORT\nu32 gf_bs_get_bit_offset(GF_BitStream *bs)\n{\n\tif (bs->bsmode==GF_BITSTREAM_READ) return (u32) ( (bs->position - 1) * 8 + bs->nbBits);\n\treturn (u32) ( (bs->position ) * 8 + bs->nbBits);\n}\n\nGF_EXPORT\nu32 gf_bs_get_bit_position(GF_BitStream *bs)\n{\n\treturn bs->nbBits;\n}\n\nGF_EXPORT\nu32 gf_bs_read_vluimsbf5(GF_BitStream *bs)\n{\n\tu32 nb_words = 0;\n\twhile (gf_bs_read_int(bs, 1)) nb_words++;\n\tnb_words++;\n\treturn gf_bs_read_int(bs, 4*nb_words);\n}\n\nGF_EXPORT\nvoid gf_bs_truncate(GF_BitStream *bs)\n{\n\tbs->size = bs->position;\n}\n\n\nGF_EXPORT\nGF_Err gf_bs_transfer(GF_BitStream *dst, GF_BitStream *src, Bool keep_src)\n{\n\tu8 *data;\n\tu32 data_len, written;\n\n\tdata = NULL;\n\tdata_len = 0;\n\tgf_bs_get_content(src, &data, &data_len);\n\tif (!data || !data_len)\n\t{\n\t\tif (data) {\n\t\t\tif (keep_src) {\n\t\t\t\tsrc->original = data;\n\t\t\t\tsrc->size = data_len;\n\t\t\t} else {\n\t\t\t\tgf_free(data);\n\t\t\t}\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\twritten = gf_bs_write_data(dst, data, data_len);\n\tif (keep_src) {\n\t\tsrc->original = data;\n\t\tsrc->size = data_len;\n\t} else {\n\t\tgf_free(data);\n\t}\n\tif (written<data_len) return GF_IO_ERR;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_bs_flush(GF_BitStream *bs)\n{\n\tif (!bs->stream) return;\n\tif (bs->bsmode != GF_BITSTREAM_FILE_WRITE) return;\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tgf_fflush(bs->stream);\n}\n\n#if 0 //unused\n/*!\n\\brief Reassigns FILE object for stream-based bitstreams\n *\n *Reassigns FILE object for stream-based bitstreams. Automatically sets the stream position to the bitstream position\n\\param bs the target bitstream\n\\param stream the new stream to assign\n */\nvoid gf_bs_reassign(GF_BitStream *bs, FILE *stream)\n{\n\tif (!bs) return;\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_FILE_WRITE:\n\tcase GF_BITSTREAM_FILE_READ:\n\t\tbs->stream = stream;\n\t\tif (gf_ftell(stream) != bs->position)\n\t\t\tgf_bs_seek(bs, bs->position);\n\t\tbreak;\n\t}\n}\n#endif\n\nu64 gf_bs_set_cookie(GF_BitStream *bs, u64 cookie)\n{\n\tu64 res = 0;\n\tif (bs) {\n\t\tres = bs->cookie;\n\t\tbs->cookie = cookie;\n\t}\n\treturn res;\n}\n\nu64 gf_bs_get_cookie(GF_BitStream *bs)\n{\n\tif (!bs) return 0;\n\treturn bs->cookie;\n}\n\nGF_EXPORT\nGF_Err gf_bs_insert_data(GF_BitStream *bs, u8 *data, u32 size, u64 offset)\n{\n\tu64 cur_r, cur_w, pos;\n\tu32 nb_io;\n\n\tif (bs->on_block_out) return GF_BAD_PARAM;\n\n\tpos = bs->position;\n\tnb_io = gf_bs_write_data(bs, data, size);\n\tif (nb_io != size) goto exit;\n\n\tcur_w = bs->position;\n\tgf_bs_seek(bs, pos);\n\tcur_r = pos;\n\tpos = cur_w;\n\twhile (cur_r > offset) {\n\t\tu8 block[8196];\n\t\tu32 move_bytes = 8196;\n\t\tif (cur_r - offset < move_bytes)\n\t\t\tmove_bytes = (u32) (cur_r - offset);\n\n\t\tgf_bs_seek(bs, cur_r - move_bytes);\n\t\tnb_io = gf_bs_read_data(bs, block, move_bytes);\n\t\tif (nb_io != move_bytes) goto exit;\n\t\tgf_bs_seek(bs, cur_w - move_bytes);\n\t\tnb_io = gf_bs_write_data(bs, block, move_bytes);\n\t\tif (nb_io != move_bytes) goto exit;\n\t\tcur_r -= move_bytes;\n\t\tcur_w -= move_bytes;\n\t}\n\n\tgf_bs_seek(bs, offset);\n\tnb_io = gf_bs_write_data(bs, data, size);\n\tif (nb_io != size) goto exit;\n\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n\nexit:\n\tgf_bs_seek(bs, pos);\n\treturn GF_IO_ERR;\n}\n\n\nGF_Err gf_bs_set_logger(GF_BitStream *bs, void (*on_bs_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3), void *udta)\n{\n\tif (!bs) return GF_BAD_PARAM;\n\tbs->on_log = on_bs_log;\n\tbs->log_udta = udta;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_AVPARSE_LOGS\nvoid gf_bs_log_idx(GF_BitStream *bs, u32 nBits, const char *fname, s64 val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tassert(bs);\n\tif (bs->on_log) bs->on_log(bs->log_udta, fname, nBits, val, idx1, idx2, idx3);\n}\n#endif\n\n\nvoid gf_bs_mark_overflow(GF_BitStream *bs, Bool reset)\n{\n\tbs->overflow_state = reset ? 0 : 2;\n}\nu32 gf_bs_is_overflow(GF_BitStream *bs)\n{\n\treturn bs->overflow_state;\n}\n\n\nGF_EXPORT\nchar *gf_bs_read_utf8(GF_BitStream *bs)\n{\n\tchar szC[2];\n\tchar *res = NULL;\n\tif (!bs || !gf_bs_is_align(bs))\n\t\treturn NULL;\n\n\tszC[1] = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tu8 c = gf_bs_read_u8(bs);\n\t\tif (!c) break;\n\t\tszC[0] = c;\n\t\tgf_dynstrcat(&res, szC, NULL);\n\t}\n\treturn res;\n}\n\nGF_EXPORT\nGF_Err gf_bs_write_utf8(GF_BitStream *bs, const char *str)\n{\n\tif (!bs || !gf_bs_is_align(bs))\n\t\treturn GF_BAD_PARAM;\n\n\tu32 i, len = str ? (u32) strlen(str) : 0;\n\tfor (i=0; i<len; i++)\n\t\tgf_bs_write_u8(bs, str[i]);\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2018-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / RAW PCM reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\ntypedef struct\n{\n\t//opts\n\tu32 framelen, safmt, sr, ch;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tBool file_loaded, is_playing, initial_play_done;\n\tu64 cts;\n\tu32 frame_size, nb_bytes_in_frame, Bps;\n\tu64 filepos, total_frames;\n\tGF_FilterPacket *out_pck;\n\tu8 *out_data;\n\tBool reverse_play, done;\n\n\tu32 probe_wave, wav_hdr_size;\n\tu8 *probe_data;\n\tu32 probe_data_size;\n} GF_PCMReframeCtx;\n\n\n\n\nGF_Err pcmreframe_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_EXT);\n\tif (!ctx->safmt) {\n\t\tif (p && p->value.string) ctx->safmt = gf_audio_fmt_parse(p->value.string);\n\t}\n\tif (!ctx->safmt) {\n\t\tctx->probe_wave = 1;\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\tgf_filter_pid_send_event(pid, &evt);\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!ctx->sr) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio sample rate, cannot parse\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (!ctx->ch) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio ch, cannot parse\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tctx->Bps = gf_audio_fmt_bit_depth(ctx->safmt) / 8;\n\t}\n\tif (!ctx->framelen) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio framelen, using 1024\\n\"));\n\t\tctx->framelen = 1024;\n\t}\n\n\tctx->frame_size = ctx->framelen * ctx->Bps * ctx->ch;\n\n\tif (!ctx->opid)\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_framing_mode(ctx->ipid, GF_FALSE);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(ctx->sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(ctx->ch));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT(ctx->framelen));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(ctx->safmt));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_REWIND));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, &PROP_BOOL(GF_TRUE));\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\n\tif (!gf_sys_is_test_mode() ) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->sr * ctx->Bps * ctx->ch));\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\tif (p && p->value.longuint) {\n\t\tu64 nb_frames = p->value.longuint;\n\t\tif (ctx->probe_wave) nb_frames -= ctx->wav_hdr_size;\n\t\tnb_frames /= ctx->Bps * ctx->ch;\n\t\tctx->total_frames = p->value.longuint;\n\t\tctx->total_frames /= ctx->frame_size;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(nb_frames, ctx->sr));\n\t}\n\n\treturn GF_OK;\n}\n\nstatic Bool pcmreframe_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 nb_frames;\n\tGF_FilterEvent fevt;\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tctx->done = GF_FALSE;\n\n\t\tif (!ctx->total_frames)\n\t\t\treturn GF_TRUE;\n\n\t\tif (evt->play.start_range>=0) {\n\t\t\tctx->cts = (u64) (evt->play.start_range * ctx->sr);\n\t\t} else {\n\t\t\tctx->cts = (ctx->total_frames-1) * ctx->framelen;\n\t\t}\n\t\tnb_frames = (u32) (ctx->cts / ctx->framelen);\n\t\tif (nb_frames==ctx->total_frames) {\n\t\t\tif (evt->play.speed>=0) {\n\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tnb_frames--;\n\t\t\tctx->cts = nb_frames * ctx->framelen;\n\t\t}\n\n\t\tctx->filepos = nb_frames * ctx->frame_size;\n\t\tctx->reverse_play =  (evt->play.speed<0) ? GF_TRUE : GF_FALSE;\n\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->filepos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->out_pck) {\n\t\t\tgf_filter_pck_discard(ctx->out_pck);\n\t\t\tctx->out_pck = NULL;\n\t\t}\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nvoid pcmreframe_flush_packet(GF_PCMReframeCtx *ctx)\n{\n\tif (ctx->reverse_play) {\n\t\tu32 i, nb_bytes_in_sample, nb_samples = ctx->nb_bytes_in_frame / ctx->Bps / ctx->ch;\n\t\tnb_bytes_in_sample = ctx->Bps * ctx->ch;\n\t\tfor (i=0; i<nb_samples/2; i++) {\n\t\t\tchar store[100];\n\t\t\tmemcpy(store, ctx->out_data + i*nb_bytes_in_sample, nb_bytes_in_sample);\n\t\t\tmemcpy(ctx->out_data + i*nb_bytes_in_sample, ctx->out_data + (nb_samples - i - 1)*nb_bytes_in_sample, nb_bytes_in_sample);\n\t\t\tmemcpy(ctx->out_data + (nb_samples-i-1)*nb_bytes_in_sample, store, nb_bytes_in_sample);\n\t\t}\n\t}\n\tgf_filter_pck_send(ctx->out_pck);\n\tctx->out_pck = NULL;\n}\nGF_Err pcmreframe_process(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu64 byte_offset;\n\tu8 *data;\n\tu32 pck_size;\n\n\tif (ctx->done) return GF_EOS;\n\n\tif (!ctx->is_playing && ctx->opid) return GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid) && !ctx->reverse_play) {\n\t\t\tif (ctx->out_pck) {\n\t\t\t\tgf_filter_pck_truncate(ctx->out_pck, ctx->nb_bytes_in_frame);\n\t\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->nb_bytes_in_frame/ctx->Bps/ctx->ch);\n\t\t\t\tpcmreframe_flush_packet(ctx);\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tif (ctx->probe_wave==1) {\n\t\tBool wav_ok = GF_TRUE;\n\t\tBool hdr_found = GF_FALSE;\n\t\tGF_BitStream *bs;\n\t\tif (ctx->probe_data) {\n\t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n\t\t\tmemcpy(ctx->probe_data + ctx->probe_data_size, data, pck_size);\n\t\t\tctx->probe_data_size += pck_size;\n\t\t\tbs = gf_bs_new(ctx->probe_data, ctx->probe_data_size, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tbs = gf_bs_new(data, pck_size, GF_BITSTREAM_READ);\n\t\t}\n\t\tu32 type = gf_bs_read_u32(bs);\n\t\tif (type!=GF_4CC('R', 'I', 'F', 'F')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tgf_bs_read_u32(bs);\n\t\tu32 wtype = gf_bs_read_u32(bs);\n\t\tif (wtype!=GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\twhile (gf_bs_available(bs)) {\n\t\t\ttype = gf_bs_read_u32(bs);\n\t\t\tu32 csize = gf_bs_read_u32_le(bs); //subchunk size\n\t\t\tif (type==GF_4CC('d', 'a', 't', 'a')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type!=GF_4CC('f', 'm', 't', ' ')) {\n\t\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//parse fmt\n\t\t\thdr_found = GF_TRUE;\n\t\t\tu16 atype = gf_bs_read_u16_le(bs);\n\t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\t\t\tctx->sr = gf_bs_read_u32_le(bs);\n\t\t\tgf_bs_read_u32_le(bs); //byte rate\n\t\t\tgf_bs_read_u16_le(bs); // block align\n\t\t\tu32 bps = gf_bs_read_u16_le(bs);\n\t\t\tif (atype==3) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_FLT;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else if (atype==1) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S32;\n\t\t\t\t} else if (bps==24) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S24;\n\t\t\t\t} else if (bps==16) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S16;\n\t\t\t\t} else if (bps==8) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_U8;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tif (!ctx->probe_data) {\n\t\t\t\tctx->probe_data = gf_malloc(pck_size);\n\t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n\t\t\t\tctx->probe_data_size = pck_size;\n\t\t\t}\n\t\t\tif (!hdr_found) {\n\t\t\t\tif (ctx->probe_data_size<=10000) {\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));\n\t\t\t}\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\n\t\tctx->wav_hdr_size = (u32) gf_bs_get_position(bs);\n\n\t\tgf_bs_del(bs);\n\t\tif (!wav_ok) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Invalid or unsupported WAVE header, aborting\\n\", ctx->probe_data_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tctx->probe_wave = 2;\n\t\tpcmreframe_configure_pid(filter, ctx->ipid, GF_FALSE);\n\t\tif (ctx->probe_data) {\n\t\t\tpck_size = ctx->probe_data_size;\n\t\t\tdata = ctx->probe_data;\n\t\t}\n\t\tpck_size -= ctx->wav_hdr_size;\n\t\tdata+=ctx->wav_hdr_size;\n\t\tbyte_offset = 0;\n\t}\n\tbyte_offset+= ctx->wav_hdr_size;\n\n\twhile (pck_size) {\n\t\tif (!ctx->out_pck) {\n\t\t\tctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);\n\t\t\tif (!ctx->out_pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_cts(ctx->out_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_sap(ctx->out_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->framelen);\n\t\t\tgf_filter_pck_set_byte_offset(ctx->out_pck, byte_offset);\n\t\t}\n\n\t\tif (pck_size + ctx->nb_bytes_in_frame < ctx->frame_size) {\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, pck_size);\n\t\t\tctx->nb_bytes_in_frame += pck_size;\n\t\t\tpck_size = 0;\n\t\t} else {\n\t\t\tu32 remain = ctx->frame_size - ctx->nb_bytes_in_frame;\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, remain);\n\t\t\tctx->nb_bytes_in_frame = ctx->frame_size;\n\t\t\tpcmreframe_flush_packet(ctx);\n\n\t\t\tpck_size -= remain;\n\t\t\tdata += remain;\n\t\t\tbyte_offset += remain;\n\t\t\tctx->out_pck = NULL;\n\t\t\tctx->nb_bytes_in_frame = 0;\n\n\t\t\t//reverse playback, the remaining data is for the next frame, we want the previous one.\n\t\t\t//Trash packet and seek to previous frame\n\t\t\tif (ctx->reverse_play) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\tif (!ctx->cts) {\n\t\t\t\t\tif (ctx->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_STOP, ctx->ipid);\n\t\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\t\treturn GF_EOS;\n\t\t\t\t}\n\t\t\t\tctx->cts -= ctx->framelen;\n\t\t\t\tctx->filepos -= ctx->frame_size;\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t//post a seek, this will trash remaining packets in buffers\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tctx->cts += ctx->framelen;\n\t\t}\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (ctx->probe_data) {\n\t\tgf_free(ctx->probe_data);\n\t\tctx->probe_data = NULL;\n\t\tctx->probe_data_size = 0;\n\t}\n\treturn GF_OK;\n}\n\nstatic const char *pcmreframe_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tif (size<20) return NULL;\n\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tu32 code = gf_bs_read_u32(bs);\n\tif (code == GF_4CC('R', 'I', 'F', 'F')) {\n\t\tgf_bs_read_u32(bs);\n\t\tcode = gf_bs_read_u32(bs);\n\t\tif (code == GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\t*score = GF_FPROBE_SUPPORTED;\n\t\t\tgf_bs_del(bs);\n\t\t\treturn \"audio/wav\";\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\t*score = GF_FPROBE_EXT_MATCH;\n\treturn gf_audio_fmt_all_shortnames();\n}\n\n\nstatic void pcmreframe_finalize(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->out_pck) gf_filter_pck_discard(ctx->out_pck);\n\tif (ctx->probe_data) gf_free(ctx->probe_data);\n}\n\nstatic GF_FilterCapability PCMReframeCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"pcm\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/x-pcm\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"wav\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/wav\"),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_PCMReframeCtx, _n)\nstatic GF_FilterArgs PCMReframeArgs[] =\n{\n\t{ OFFS(sr), \"sample rate\", GF_PROP_UINT, \"44100\", NULL, 0},\n\t{ OFFS(safmt), \"audio format\", GF_PROP_PCMFMT, \"none\", NULL, 0},\n\t{ OFFS(ch), \"number of channels\", GF_PROP_UINT, \"2\", NULL, 0},\n\t{ OFFS(framelen), \"number of samples to put in one audio frame. For planar formats, indicate plane size in samples\", GF_PROP_UINT, \"1024\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\n\nGF_FilterRegister PCMReframeRegister = {\n\t.name = \"rfpcm\",\n\tGF_FS_SET_DESCRIPTION(\"PCM reframer\")\n\tGF_FS_SET_HELP(\"This filter parses raw PCM file/data or WAVE files and outputs corresponding raw audio PID and frames.\")\n\t.private_size = sizeof(GF_PCMReframeCtx),\n\t.args = PCMReframeArgs,\n\tSETCAPS(PCMReframeCaps),\n\t.finalize = pcmreframe_finalize,\n\t.configure_pid = pcmreframe_configure_pid,\n\t.process = pcmreframe_process,\n\t.process_event = pcmreframe_process_event,\n\t.probe_data = pcmreframe_probe_data\n};\n\n\nconst GF_FilterRegister *pcmreframe_register(GF_FilterSession *session)\n{\n\tPCMReframeArgs[1].min_max_enum = gf_audio_fmt_all_names();\n\tPCMReframeCaps[1].val.value.string = (char *) gf_audio_fmt_all_shortnames();\n\treturn &PCMReframeRegister;\n}\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / common tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/bitstream.h>\n\n/*the default size for new streams allocation...*/\n#define BS_MEM_BLOCK_ALLOC_SIZE\t\t512\n\n/*private types*/\nenum\n{\n\tGF_BITSTREAM_FILE_READ = GF_BITSTREAM_WRITE_DYN + 1,\n\tGF_BITSTREAM_FILE_WRITE,\n};\n\nstruct __tag_bitstream\n{\n\t/*original stream data*/\n\tFILE *stream;\n\n\t/*or original data*/\n\tchar *original;\n\t/*the size of our buffer in bytes*/\n\tu64 size;\n\t/*current position in BYTES*/\n\tu64 position;\n\t/*the byte readen/written*/\n\tu32 current;\n\t/*the number of bits in the current byte*/\n\tu32 nbBits;\n\t/*the bitstream mode*/\n\tu32 bsmode;\n\n\tvoid (*EndOfStream)(void *par);\n\tvoid *par;\n\n\n\tchar *cache_write;\n\tu32 cache_write_size, buffer_written;\n\n\tBool remove_emul_prevention_byte;\n\tu32 nb_zeros, nb_removed;\n\n\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size);\n\tvoid *usr_data;\n\tu64 bytes_out;\n\tu32 prevent_dispatch;\n\n\tu64 cookie;\n\n\tu8 *cache_read;\n\tu32 cache_read_size, cache_read_pos, cache_read_alloc;\n\n\tvoid (*on_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3);\n\tvoid *log_udta;\n\n\tu32 total_bits_read;\n\tu32 overflow_state;\n};\n\nGF_Err gf_bs_reassign_buffer(GF_BitStream *bs, const u8 *buffer, u64 BufferSize)\n{\n\tif (!bs) return GF_BAD_PARAM;\n\tbs->total_bits_read = 0;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tbs->original = (char*)buffer;\n\t\tbs->size = BufferSize;\n\t\tbs->position = 0;\n\t\tbs->current = 0;\n\t\tbs->nbBits = 8;\n\t\tbs->current = 0;\n\t\tbs->nb_zeros = bs->nb_removed = 0;\n\t\treturn GF_OK;\n\t}\n\tif (bs->bsmode==GF_BITSTREAM_WRITE) {\n\t\tif (!buffer || !BufferSize) return GF_BAD_PARAM;\n\t\tbs->original = (char*)buffer;\n\t\tbs->size = BufferSize;\n\t\tbs->position = 0;\n\t\tbs->current = 0;\n\t\tbs->nbBits = 0;\n\t\tbs->current = 0;\n\t\treturn GF_OK;\n\t}\n\tif (bs->bsmode!=GF_BITSTREAM_WRITE_DYN) return GF_BAD_PARAM;\n\tif (bs->original) return GF_BAD_PARAM;\n\n\tbs->position = 0;\n\tbs->current = 0;\n\tbs->nbBits = 0;\n\tbs->current = 0;\n\tbs->size = BufferSize ? BufferSize : BS_MEM_BLOCK_ALLOC_SIZE;\n\tif (buffer) {\n\t\tbs->original = (char *) buffer;\n\t} else {\n\t\tbs->original = (char *) gf_malloc(sizeof(char) * ((u32) bs->size));\n\t\tif (! bs->original) {\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_BitStream *gf_bs_new(const u8 *buffer, u64 BufferSize, u32 mode)\n{\n\tGF_BitStream *tmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\n\ttmp->original = (char*)buffer;\n\ttmp->size = BufferSize;\n\n\ttmp->bsmode = mode;\n\n\tswitch (tmp->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\t\ttmp->nbBits = 8;\n\t\ttmp->current = 0;\n\t\tbreak;\n\tcase GF_BITSTREAM_WRITE:\n\tcase GF_BITSTREAM_WRITE_DYN:\n\t\ttmp->nbBits = 0;\n\t\tif (! buffer) {\n\t\t\t/*if BufferSize is specified, use it. This is typically used when AvgSize of\n\t\t\tsome buffers is known, but some exceed it.*/\n\t\t\tif (BufferSize) {\n\t\t\t\ttmp->size = BufferSize;\n\t\t\t} else {\n\t\t\t\ttmp->size = BS_MEM_BLOCK_ALLOC_SIZE;\n\t\t\t}\n\t\t\ttmp->original = (char *) gf_malloc(sizeof(char) * ((u32) tmp->size));\n\t\t\tif (! tmp->original) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp->bsmode = GF_BITSTREAM_WRITE_DYN;\n\t\t} else {\n\t\t\ttmp->original = (char*)buffer;\n\t\t\ttmp->size = BufferSize;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/*the stream constructor is not the same...*/\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_BitStream *gf_bs_from_file(FILE *f, u32 mode)\n{\n\tGF_BitStream *tmp;\n\tif (!f) return NULL;\n\n\ttmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\t/*switch to internal mode*/\n\tmode = (mode==GF_BITSTREAM_READ) ? GF_BITSTREAM_FILE_READ : GF_BITSTREAM_FILE_WRITE;\n\ttmp->bsmode = mode;\n\ttmp->current = 0;\n\ttmp->nbBits = (mode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\ttmp->original = NULL;\n\ttmp->position = 0;\n\ttmp->stream = f;\n\n\t/*get the size of this file (for read streams)*/\n\ttmp->position = gf_ftell(f);\n\ttmp->size = gf_fsize(f);\n\tgf_fseek(f, tmp->position, SEEK_SET);\n\n\n\tif (mode==GF_BITSTREAM_FILE_READ) {\n\t\ttmp->cache_read_alloc = gf_opts_get_int(\"core\", \"bs-cache-size\");\n\t\tif (tmp->cache_read_alloc) {\n\t\t\ttmp->cache_read_pos = tmp->cache_read_size = tmp->cache_read_alloc;\n\t\t\ttmp->cache_read = gf_malloc(tmp->cache_read_alloc);\n\t\t\tif (!tmp->cache_read) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (mode == GF_BITSTREAM_FILE_WRITE) {\n\t\ttmp->cache_write_size = gf_opts_get_int(\"core\", \"bs-cache-size\");\n\t\tif (tmp->cache_write_size) {\n\t\t\ttmp->cache_write = (char*)gf_malloc(tmp->cache_write_size);\n\t\t\tif (!tmp->cache_write) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmp->buffer_written = 0;\n\t\t}\n\t}\n\n\treturn tmp;\n}\n\n\nGF_BitStream *gf_bs_new_cbk_buffer(GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size), void *usr_data, u8 *buffer, u32 buffer_size)\n{\n\tGF_BitStream *tmp;\n\n\tif (!on_block_out) return NULL;\n\n\ttmp = (GF_BitStream *)gf_malloc(sizeof(GF_BitStream));\n\tif (!tmp) return NULL;\n\tmemset(tmp, 0, sizeof(GF_BitStream));\n\n\tif (buffer && buffer_size) {\n\t\ttmp->size = buffer_size;\n\t\ttmp->original = buffer;\n\t} else {\n\t\ttmp->size = buffer_size ? buffer_size : 10*BS_MEM_BLOCK_ALLOC_SIZE;\n\t\ttmp->original = (char *) gf_malloc(sizeof(char) * ((u32) tmp->size));\n\t\tif (! tmp->original) {\n\t\t\tgf_free(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bsmode = GF_BITSTREAM_WRITE_DYN;\n\ttmp->on_block_out = on_block_out;\n\ttmp->usr_data = usr_data;\n\n\treturn tmp;\n}\n\nGF_BitStream *gf_bs_new_cbk(GF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size), void *usr_data, u32 block_size)\n{\n\treturn gf_bs_new_cbk_buffer(on_block_out, usr_data, NULL, block_size);\n\n}\nvoid gf_bs_prevent_dispatch(GF_BitStream *bs, Bool prevent_dispatch)\n{\n\tif (!bs) return;\n\tif (prevent_dispatch) {\n\t\tbs->prevent_dispatch ++;\n\t\treturn;\n\t}\n\tif (!bs->prevent_dispatch) return;\n\tbs->prevent_dispatch --;\n\n\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\tassert(bs->position >= bs->bytes_out);\n\t\tif (bs->position > bs->bytes_out) {\n\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out));\n\t\t\tbs->bytes_out = bs->position;\n\t\t}\n\t}\n}\n\nstatic Bool bs_flush_write_cache(GF_BitStream *bs)\n{\n\tBool res = GF_TRUE;\n\tif (bs->buffer_written) {\n\t\tu32 nb_write;\n\t\tnb_write = (u32) gf_fwrite(bs->cache_write, bs->buffer_written, bs->stream);\n\t\tif (nb_write != bs->buffer_written)\n\t\t\tres = GF_FALSE;\n\t\t//check we didn't rewind the bitstream\n\t\tif (bs->size == bs->position)\n\t\t\tbs->size += nb_write;\n\t\tbs->position += nb_write;\n\t\tbs->buffer_written = 0;\n\t}\n\treturn res;\n}\n\n\n\nGF_EXPORT\nvoid gf_bs_del(GF_BitStream *bs)\n{\n\tif (!bs) return;\n\tif (bs->on_block_out && bs->position>bs->bytes_out) {\n\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t}\n\t/*if we are in dynamic mode (alloc done by the bitstream), free the buffer if still present*/\n\tif ((bs->bsmode == GF_BITSTREAM_WRITE_DYN) && bs->original) gf_free(bs->original);\n\tif (bs->cache_write) {\n\t\tbs_flush_write_cache(bs);\n\t\tgf_free(bs->cache_write);\n\t}\n\tif (bs->cache_read)\n\t\tgf_free(bs->cache_read);\n\tgf_free(bs);\n}\n\nGF_EXPORT\nvoid gf_bs_enable_emulation_byte_removal(GF_BitStream *bs, Bool do_remove)\n{\n\tif (bs) {\n\t\tbs->remove_emul_prevention_byte = do_remove;\n\t\tbs->nb_zeros = bs->nb_removed = 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_bs_get_emulation_byte_removed(GF_BitStream *bs)\n{\n\tif (bs) return bs->nb_removed;\n\treturn 0;\n}\n\n\n/*returns 1 if aligned wrt current mode, 0 otherwise*/\nBool gf_bs_is_align(GF_BitStream *bs)\n{\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\tcase GF_BITSTREAM_FILE_READ:\n\t\treturn ( (8 == bs->nbBits) ? GF_TRUE : GF_FALSE);\n\tdefault:\n\t\treturn !bs->nbBits;\n\t}\n}\n\nstatic GFINLINE u8 gf_bs_load_byte(GF_BitStream *bs, Bool *is_eos)\n{\n\tu8 res;\n\tif (bs->cache_read) {\n\t\tif (bs->cache_read_pos == bs->cache_read_size) {\n\t\t\tbs->cache_read_size = (u32) gf_fread(bs->cache_read, bs->cache_read_alloc, bs->stream);\n\t\t\tbs->cache_read_pos = 0;\n\t\t\tif (!bs->cache_read_size) {\n\t\t\t\t*is_eos = GF_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tres = bs->cache_read[bs->cache_read_pos];\n\t\tbs->cache_read_pos++;\n\t} else {\n\t\tres = gf_fgetc(bs->stream);\n\t}\n\treturn res;\n}\n\n/*fetch a new byte in the bitstream switch between packets*/\nstatic u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tbs->nb_removed++;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tis_eos = bs->stream ? gf_feof(bs->stream) : GF_TRUE;\n\t//cache not fully read, reset EOS\n\tif (bs->cache_read && (bs->cache_read_pos<bs->cache_read_size))\n\t\tis_eos = GF_FALSE;\n\n\t/*we are in FILE mode, test for end of file*/\n\tif (!is_eos) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tbs->nb_removed++;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tif (!bs->overflow_state) {\n\t\t\tbs->overflow_state = 1;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t\t}\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}\n\n#define NO_OPTS\n\n#ifndef NO_OPTS\nstatic u32 bit_mask[] = {0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};\nstatic u32 bits_mask[] = {0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F};\n#endif\n\nGF_EXPORT\nu8 gf_bs_read_bit(GF_BitStream *bs)\n{\n\tif (bs->nbBits == 8) {\n\t\tbs->current = BS_ReadByte(bs);\n\t\tbs->nbBits = 0;\n\t}\n#ifdef NO_OPTS\n\t{\n\t\ts32 ret;\n\t\tbs->current <<= 1;\n\t\tbs->nbBits++;\n\t\tret = (bs->current & 0x100) >> 8;\n\t\treturn (u8) ret;\n\t}\n#else\n\treturn (u8) (bs->current & bit_mask[bs->nbBits++]) ? 1 : 0;\n#endif\n\n}\n\nGF_EXPORT\nu32 gf_bs_read_int(GF_BitStream *bs, u32 nBits)\n{\n\tu32 ret;\n\tbs->total_bits_read+= nBits;\n\n#ifndef NO_OPTS\n\tif (nBits + bs->nbBits <= 8) {\n\t\tbs->nbBits += nBits;\n\t\tret = (bs->current >> (8 - bs->nbBits) ) & bits_mask[nBits];\n\t\treturn ret;\n\t}\n#endif\n\tret = 0;\n\twhile (nBits-- > 0) {\n\t\tret <<= 1;\n\t\tret |= gf_bs_read_bit(bs);\n\t}\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u8(GF_BitStream *bs)\n{\n\tassert(bs->nbBits==8);\n\tif (bs->cache_read && (bs->cache_read_pos+1<bs->cache_read_size) ) {\n\t\tu32 ret = bs->cache_read[bs->cache_read_pos];\n\t\tbs->cache_read_pos+=1;\n\t\tbs->position+=1;\n\t\treturn ret;\n\t}\n\n\treturn (u32) BS_ReadByte(bs);\n}\n\n#if 0\nGF_EXPORT\nu32 gf_bs_read_u8_until_delimiter(GF_BitStream *bs, u8 delimiter, u8* out, u32 max_length) {\n\tu32 i = 0;\n\tchar token=0;\n\tu64 cur_pos = gf_bs_get_position(bs);\n\n\tif (!max_length) out = NULL;\n\n\twhile(gf_bs_available(bs) && (!max_length || i < max_length)) {\n\t\tgf_bs_read_data(bs, &token, 1);\n\t\tif (token == delimiter) goto found;\n\t\tif (out) out[i] = token;\n\t\ti++;\n\t}\n\n\t/* Delimiter not found */\n\tgf_bs_seek(bs, cur_pos);\n\treturn 0;\n\nfound:\n\treturn i;\n}\n#endif\n\nGF_EXPORT\nu32 gf_bs_read_u16(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\tif (bs->cache_read && (bs->cache_read_pos+2<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tbs->cache_read_pos+=2;\n\t\tbs->position+=2;\n\t\treturn ret;\n\t}\n\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\n\nGF_EXPORT\nu32 gf_bs_read_u24(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\n\tif (bs->cache_read && (bs->cache_read_pos+3<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tbs->cache_read_pos+=3;\n\t\tbs->position+=3;\n\t\treturn ret;\n\t}\n\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u32(GF_BitStream *bs)\n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\n\tif (bs->cache_read && (bs->cache_read_pos+4<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+3];\n\t\tbs->cache_read_pos+=4;\n\t\tbs->position+=4;\n\t\treturn ret;\n\t}\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_read_u64(GF_BitStream *bs)\n{\n\tu64 ret;\n\n\tif (bs->cache_read && (bs->cache_read_pos+8<bs->cache_read_size) ) {\n\t\tret = bs->cache_read[bs->cache_read_pos];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+1];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+2];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+3];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+4];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+5];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+6];\n\t\tret<<=8;\n\t\tret |= bs->cache_read[bs->cache_read_pos+7];\n\t\tbs->cache_read_pos+=8;\n\t\tbs->position+=8;\n\t\treturn ret;\n\t}\n\tret = gf_bs_read_u32(bs);\n\tret<<=32;\n\tret |= gf_bs_read_u32(bs);\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_read_long_int(GF_BitStream *bs, u32 nBits)\n{\n\tu64 ret = 0;\n\tif (nBits>64) {\n\t\tu32 skip = nBits-64;\n\t\tif (gf_bs_available(bs) * 8 < nBits-8) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tbs->position = bs->size;\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Reading %d bits but max should be 64, skipping %d most significants bits\\n\", nBits, nBits-64));\n\t\t//avoid recursion\n\t\twhile (skip) {\n\t\t\tif (skip>32) {\n\t\t\t\tgf_bs_read_int(bs, 32);\n\t\t\t\tskip-=32;\n\t\t\t} else {\n\t\t\t\tgf_bs_read_int(bs, skip);\n\t\t\t\tskip=0;\n\t\t\t}\n\t\t}\n\t\tret = gf_bs_read_long_int(bs, 64);\n\t} else {\n\t\twhile (nBits-- > 0) {\n\t\t\tret <<= 1;\n\t\t\tret |= gf_bs_read_bit(bs);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nGF_EXPORT\nFloat gf_bs_read_float(GF_BitStream *bs)\n{\n\tchar buf [4] = \"\\0\\0\\0\";\n#ifdef NO_OPTS\n\ts32 i;\n\tfor (i = 0; i < 32; i++)\n\t\tbuf[3-i/8] |= gf_bs_read_bit(bs) << (7 - i%8);\n#else\n\tbuf[3] = gf_bs_read_int(bs, 8);\n\tbuf[2] = gf_bs_read_int(bs, 8);\n\tbuf[1] = gf_bs_read_int(bs, 8);\n\tbuf[0] = gf_bs_read_int(bs, 8);\n#endif\n\treturn (* (Float *) buf);\n}\n\nGF_EXPORT\nDouble gf_bs_read_double(GF_BitStream *bs)\n{\n\tchar buf [8] = \"\\0\\0\\0\\0\\0\\0\\0\";\n\ts32 i;\n\tfor (i = 0; i < 64; i++)\n\t\tbuf[7-i/8] |= gf_bs_read_bit(bs) << (7 - i%8);\n\treturn (* (Double *) buf);\n}\n\nGF_EXPORT\nu32 gf_bs_read_data(GF_BitStream *bs, u8 *data, u32 nbBytes)\n{\n\tu64 orig = bs->position;\n\n\tif (bs->position+nbBytes > bs->size) return 0;\n\n\tif (gf_bs_is_align(bs) ) {\n\t\ts32 bytes_read, bytes_read_cache;\n\t\tswitch (bs->bsmode) {\n\t\tcase GF_BITSTREAM_READ:\n\t\tcase GF_BITSTREAM_WRITE:\n\t\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t\tmemcpy(data, bs->original + bs->position, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_FILE_READ:\n\t\tcase GF_BITSTREAM_FILE_WRITE:\n\t\t\tif (bs->cache_write)\n\t\t\t\tbs_flush_write_cache(bs);\n\n\t\t\tbytes_read = bytes_read_cache = 0;\n\t\t\tif (bs->cache_read) {\n\t\t\t\tu32 csize = bs->cache_read_size-bs->cache_read_pos;\n\t\t\t\tif (csize>nbBytes) csize = nbBytes;\n\t\t\t\tmemcpy(data, bs->cache_read + bs->cache_read_pos, csize);\n\t\t\t\tbs->cache_read_pos += csize;\n\t\t\t\tnbBytes -= csize;\n\t\t\t\tbytes_read_cache = csize;\n\t\t\t}\n\t\t\tif (nbBytes) {\n\t\t\t\tbytes_read = (s32) gf_fread(data + bytes_read_cache, nbBytes, bs->stream);\n\t\t\t\tif (bytes_read<0) return bytes_read_cache;\n\t\t\t}\n\t\t\tbs->position += bytes_read + bytes_read_cache;\n\t\t\treturn bytes_read + bytes_read_cache;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (nbBytes-- > 0) {\n\t\t*data++ = gf_bs_read_int(bs, 8);\n\t}\n\treturn (u32) (bs->position - orig);\n\n}\n\n\n\nstatic void BS_WriteByte(GF_BitStream *bs, u8 val)\n{\n\t/*we don't allow write on READ buffers*/\n\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_FILE_READ) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write on read bitstream\\n\"));\n\t\treturn;\n\t}\n\tif (!bs->original && !bs->stream) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write on unassigned bitstream\\n\"));\n\t\treturn;\n\t}\n\t/*we are in MEM mode*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN) ) {\n\t\t//if callback mode and dispatch is not blocked, dispatch\n\t\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\tif (bs->position - bs->bytes_out == bs->size) {\n\t\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out));\n\t\t\t\tbs->bytes_out = bs->position;\n\t\t\t}\n\t\t\tif (bs->original)\n\t\t\t\tbs->original[bs->position - bs->bytes_out] = val;\n\t\t\tbs->position++;\n\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\treturn;\n\t\t}\n\t\t//otherwise store\n\t\tif (bs->position - bs->bytes_out == bs->size) {\n\t\t\t/*no more space...*/\n\t\t\tif (bs->bsmode != GF_BITSTREAM_WRITE_DYN) return;\n\t\t\t/*gf_realloc if enough space...*/\n\t\t\tif (bs->size > 0xFFFFFFFF) return;\n\t\t\tbs->size = bs->size ? (bs->size * 2) : BS_MEM_BLOCK_ALLOC_SIZE;\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32)bs->size);\n\t\t\tif (!bs->original) return;\n\t\t}\n\t\tif (bs->original)\n\t\t\tbs->original[bs->position - bs->bytes_out] = val;\n\t\tbs->position++;\n\t\treturn;\n\t}\n\tif (bs->cache_write) {\n\t\tif (bs->buffer_written == bs->cache_write_size) {\n\t\t\tbs_flush_write_cache(bs);\n\t\t}\n\t\tbs->cache_write[bs->buffer_written] = val;\n\t\tbs->buffer_written++;\n\t\tif (bs->buffer_written == bs->cache_write_size) {\n\t\t\tbs_flush_write_cache(bs);\n\t\t}\n\t\treturn;\n\t}\n\t/*we are in FILE mode, no pb for any gf_realloc...*/\n\tgf_fputc(val, bs->stream);\n\n\t/*check we didn't rewind the stream*/\n\tif (bs->size == bs->position) bs->size++;\n\tbs->position += 1;\n}\n\nstatic void BS_WriteBit(GF_BitStream *bs, u32 bit)\n{\n\tbs->current <<= 1;\n\tbs->current |= bit;\n\tif (++ bs->nbBits == 8) {\n\t\tbs->nbBits = 0;\n\t\tBS_WriteByte(bs, (u8) bs->current);\n\t\tbs->current = 0;\n\t}\n}\n\nstatic s32 bs_handle_nbits_overflow(GF_BitStream* bs, s32 nBits, s32 max_shift)\n{\n\tif (nBits > max_shift) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write %d bits, when max is %d\\n\", nBits, max_shift));\n\t}\n\twhile (nBits > max_shift) {\n\t\tgf_bs_write_long_int(bs, 0, max_shift);\n\t\tnBits -= max_shift;\n\t}\n\n\treturn nBits;\n}\n\nGF_EXPORT\nvoid gf_bs_write_int(GF_BitStream *bs, s32 _value, s32 nBits)\n{\n\tu32 value, nb_shift;\n\ts32 max_shift = sizeof(s32) * 8;\n\tif (!nBits) return;\n\tnBits = bs_handle_nbits_overflow(bs, nBits, max_shift);\n\t//move to unsigned to avoid sanitizer warnings when we pass a value not codable on the given number of bits\n\t//we do this when setting bit fields to all 1's\n\tvalue = (u32) _value;\n\tnb_shift = max_shift - nBits;\n\tif (nb_shift)\n\t\tvalue <<= nb_shift;\n\n\twhile (--nBits >= 0) {\n\t\t//but check value as signed\n\t\tBS_WriteBit (bs, ((s32)value) < 0);\n\t\tvalue <<= 1;\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_long_int(GF_BitStream *bs, s64 _value, s32 nBits)\n{\n\ts32 max_shift = sizeof(s64) * 8;\n\tif (!nBits) return;\n\tnBits = bs_handle_nbits_overflow(bs, nBits, max_shift);\n\n\t//cf note in gf_bs_write_int\n\tu64 value = (u64) _value;\n\tvalue <<= max_shift - nBits;\n\twhile (--nBits >= 0) {\n\t\tBS_WriteBit (bs, ((s64)value) < 0);\n\t\tvalue <<= 1;\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u8(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\n\tif (bs->cache_write && (bs->buffer_written+1 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) value;\n\t\tbs->buffer_written += 1;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) value);\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u16(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+2 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 2;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u24(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+3 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>16)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+2] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 3;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>16)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u32(GF_BitStream *bs, u32 value)\n{\n\tassert(!bs->nbBits);\n\tif (bs->cache_write && (bs->buffer_written+4 < bs->cache_write_size) ) {\n\t\tbs->cache_write[bs->buffer_written] = (u8) ((value>>24)&0xff);\n\t\tbs->cache_write[bs->buffer_written+1] = (u8) ((value>>16)&0xff);\n\t\tbs->cache_write[bs->buffer_written+2] = (u8) ((value>>8)&0xff);\n\t\tbs->cache_write[bs->buffer_written+3] = (u8) ((value)&0xff);\n\t\tbs->buffer_written += 4;\n\t} else {\n\t\tBS_WriteByte(bs, (u8) ((value>>24)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>16)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value>>8)&0xff));\n\t\tBS_WriteByte(bs, (u8) ((value)&0xff));\n\t}\n}\n\nGF_EXPORT\nvoid gf_bs_write_u64(GF_BitStream *bs, u64 value)\n{\n\tassert(!bs->nbBits);\n\tgf_bs_write_u32(bs, (u32) ((value>>32)&0xffffffff));\n\tgf_bs_write_u32(bs, (u32) (value&0xffffffff));\n}\n\nGF_EXPORT\nu32 gf_bs_write_byte(GF_BitStream *bs, u8 byte, u32 repeat_count)\n{\n\tif (!gf_bs_is_align(bs) || bs->cache_write) {\n\t\tu32 count = 0;\n\t\twhile (count<repeat_count) {\n\t\t\tgf_bs_write_int(bs, byte, 8);\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_WRITE:\n\t\tif (bs->position + repeat_count > bs->size)\n\t\t\treturn 0;\n\t\tmemset(bs->original + bs->position, byte, repeat_count);\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t/*need to gf_realloc ...*/\n\t\tif (bs->position+repeat_count> bs->size) {\n\t\t\tu32 new_size = (u32) (bs->size*2);\n\t\t\tif (!new_size) new_size = BS_MEM_BLOCK_ALLOC_SIZE;\n\n\t\t\tif (bs->size + repeat_count > 0xFFFFFFFF)\n\t\t\t\treturn 0;\n\t\t\twhile (new_size < (u32) ( bs->size + repeat_count))\n\t\t\t\tnew_size *= 2;\n\t\t\tbs->original = (char*)gf_realloc(bs->original, sizeof(u32)*new_size);\n\t\t\tif (!bs->original)\n\t\t\t\treturn 0;\n\t\t\tbs->size = new_size;\n\t\t}\n\t\tmemset(bs->original + bs->position, byte, repeat_count);\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tcase GF_BITSTREAM_FILE_READ:\n\tcase GF_BITSTREAM_FILE_WRITE:\n\t\tif (gf_fwrite(&byte, repeat_count, bs->stream) != repeat_count)\n\t\t\treturn 0;\n\t\tif (bs->size == bs->position) bs->size += repeat_count;\n\t\tbs->position += repeat_count;\n\t\treturn repeat_count;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n\nGF_EXPORT\nvoid gf_bs_write_float(GF_BitStream *bs, Float value)\n{\n\tu32 i;\n\tunion\n\t{\tfloat f;\n\t\tchar sz [4];\n\t} float_value;\n\tfloat_value.f = value;\n\n\tfor (i = 0; i < 32; i++)\n\t\tBS_WriteBit(bs, (float_value.sz [3 - i / 8] & 1 << (7 - i % 8)) != 0);\n\n}\n\nGF_EXPORT\nvoid gf_bs_write_double (GF_BitStream *bs, Double value)\n{\n\tu32 i;\n\tunion\n\t{\tDouble d;\n\t\tchar sz [8];\n\t} double_value;\n\tdouble_value.d = value;\n\tfor (i = 0; i < 64; i++) {\n\t\tBS_WriteBit(bs, (double_value.sz [7 - i / 8] & 1 << (7 - i % 8)) != 0);\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_bs_write_data(GF_BitStream *bs, const u8 *data, u32 nbBytes)\n{\n\t/*we need some feedback for this guy...*/\n\tu64 begin = bs->position;\n\tif (!nbBytes) return 0;\n\n\tif (gf_bs_is_align(bs)) {\n\t\tswitch (bs->bsmode) {\n\t\tcase GF_BITSTREAM_WRITE:\n\t\t\tif (bs->position+nbBytes > bs->size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overwrite bitstream by %d bytes\\n\", bs->position + nbBytes - bs->size));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmemcpy(bs->original + bs->position, data, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_WRITE_DYN:\n\t\t\t//if callback mode and dispatch not disabled, dispatch bytes\n\t\t\tif (bs->on_block_out && !bs->prevent_dispatch) {\n\t\t\t\tassert(bs->position >= bs->bytes_out);\n\n\t\t\t\tif (bs->position - bs->bytes_out + nbBytes <= bs->size) {\n\t\t\t\t\tmemcpy(bs->original + bs->position - bs->bytes_out, data, nbBytes);\n\t\t\t\t\tbs->position += nbBytes;\n\t\t\t\t} else {\n\t\t\t\t\tif (bs->position > bs->bytes_out)\n\t\t\t\t\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t\t\t\t\tif (nbBytes)\n\t\t\t\t\t\tbs->on_block_out(bs->usr_data, (char *) data, nbBytes);\n\n\t\t\t\t\tbs->position += nbBytes;\n\t\t\t\t\tbs->bytes_out = bs->position;\n\t\t\t\t}\n\t\t\t\tassert(bs->position >= bs->bytes_out);\n\t\t\t\treturn nbBytes;\n\t\t\t}\n\t\t\t//otherwise store\n\t\t\t/*need to gf_realloc ...*/\n\t\t\tif (bs->position + nbBytes - bs->bytes_out > bs->size) {\n\t\t\t\tu32 new_size = (u32) (bs->size*2);\n\t\t\t\tif (!new_size) new_size = BS_MEM_BLOCK_ALLOC_SIZE;\n\n\t\t\t\tif (bs->size + nbBytes > 0xFFFFFFFF)\n\t\t\t\t\treturn 0;\n\n\t\t\t\twhile (new_size < (u32) ( bs->size + nbBytes))\n\t\t\t\t\tnew_size *= 2;\n\t\t\t\tbs->original = (char*)gf_realloc(bs->original, sizeof(u32)*new_size);\n\t\t\t\tif (!bs->original)\n\t\t\t\t\treturn 0;\n\t\t\t\tbs->size = new_size;\n\t\t\t}\n\t\t\tmemcpy(bs->original + bs->position - bs->bytes_out, data, nbBytes);\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tcase GF_BITSTREAM_FILE_READ:\n\t\tcase GF_BITSTREAM_FILE_WRITE:\n\t\t\tif (bs->cache_write) {\n\t\t\t\t//if block fits in our write cache, write it\n\t\t\t\tif (bs->buffer_written + nbBytes < bs->cache_write_size) {\n\t\t\t\t\tmemcpy(bs->cache_write+bs->buffer_written, data, nbBytes);\n\t\t\t\t\tbs->buffer_written+=nbBytes;\n\t\t\t\t\treturn nbBytes;\n\t\t\t\t}\n\t\t\t\t//otherwise flush cache and use file write\n\t\t\t\tif (!bs_flush_write_cache(bs))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (gf_fwrite(data, nbBytes, bs->stream) != nbBytes) return 0;\n\n\t\t\tif (bs->size == bs->position) bs->size += nbBytes;\n\t\t\tbs->position += nbBytes;\n\t\t\treturn nbBytes;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, (s32) *data, 8);\n\t\tdata++;\n\t\tnbBytes--;\n\t}\n\treturn (u32) (bs->position - begin);\n}\n\n/*align return the num of bits read in READ mode, 0 in WRITE*/\nGF_EXPORT\nu8 gf_bs_align(GF_BitStream *bs)\n{\n\tu8 res = 8 - bs->nbBits;\n\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (res > 0) {\n\t\t\tgf_bs_read_int(bs, res);\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->nbBits > 0) {\n\t\tgf_bs_write_int (bs, 0, res);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\n\n/*size available in the bitstream*/\nGF_EXPORT\nu64 gf_bs_available(GF_BitStream *bs)\n{\n\ts64 cur, end;\n\n\t/*in WRITE mode only, this should not be called, but return something big in case ...*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE)\n\t        || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)\n\t   )\n\t\treturn (u64) -1;\n\n\t/*we are in MEM mode*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->size < bs->position)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn (bs->size - bs->position);\n\t}\n\t/*FILE READ: assume size hasn't changed, otherwise the user shall call gf_bs_get_refreshed_size*/\n\tif (bs->bsmode==GF_BITSTREAM_FILE_READ) {\n\t\tif (bs->position>bs->size) return 0;\n\t\treturn (bs->size - bs->position);\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tcur = gf_ftell(bs->stream);\n\tend = gf_fsize(bs->stream);\n\tgf_fseek(bs->stream, cur, SEEK_SET);\n\n\treturn (u64) (end - cur);\n}\n\n/*call this funct to set the buffer size to the nb of bytes written\nUsed only in WRITE mode, as we don't know the real size during allocation...\nreturn -1 for bad param or gf_malloc failed\nreturn nbBytes cut*/\nstatic s32 BS_CutBuffer(GF_BitStream *bs)\n{\n\ts32 nbBytes;\n\tif ( (bs->bsmode != GF_BITSTREAM_WRITE_DYN) && (bs->bsmode != GF_BITSTREAM_WRITE)) return (u32) -1;\n\t/*Align our buffer or we're dead!*/\n\tgf_bs_align(bs);\n\n\tnbBytes = (u32) (bs->size - bs->position);\n\tif (!nbBytes || (nbBytes == 0xFFFFFFFF) || (bs->position >= 0xFFFFFFFF)) return 0;\n\t/*\n\t\tbs->original = (char*)gf_realloc(bs->original, (u32) bs->position);\n\t\tif (! bs->original) return (u32) -1;\n\t*/\n\t/*just in case, re-adjust..*/\n\tbs->size = bs->position;\n\treturn nbBytes;\n}\n\n/*For DYN mode, this gets the content out without cutting the buffer to the number of written bytes*/\nGF_EXPORT\nvoid gf_bs_get_content_no_truncate(GF_BitStream *bs, u8 **output, u32 *outSize, u32 *alloc_size)\n{\n\t/*only in WRITE MEM mode*/\n\tif (!bs || bs->bsmode != GF_BITSTREAM_WRITE_DYN) return;\n\n\tif (bs->on_block_out && bs->position>bs->bytes_out) {\n\t\tbs->on_block_out(bs->usr_data, bs->original, (u32) (bs->position - bs->bytes_out) );\n\t}\n\n\tif (!bs->position && !bs->nbBits) {\n\t\tif (!alloc_size) {\n\t\t\t*output = NULL;\n\t\t\tgf_free(bs->original);\n\t\t} else {\n\t\t\t*alloc_size = (u32) bs->size;\n\t\t\t*output = bs->original;\n\t\t}\n\t\t*outSize = 0;\n\t} else {\n\t\tif (alloc_size) {\n\t\t\t/*Align our buffer or we're dead!*/\n\t\t\tgf_bs_align(bs);\n\t\t\t*alloc_size = (u32) bs->size;\n\t\t\t*outSize = (u32) bs->position;\n\t\t\t*output = bs->original;\n\t\t} else {\n\t\t\ts32 copy = BS_CutBuffer(bs);\n\t\t\tif (copy < 0) {\n\t\t\t\t*output = NULL;\n\t\t\t} else\n\t\t\t\t*output = bs->original;\n\t\t\t*outSize = (u32) bs->size;\n\t\t}\n\t}\n\tbs->original = NULL;\n\tbs->size = 0;\n\tbs->position = 0;\n}\n\n/*For DYN mode, this gets the content out*/\nGF_EXPORT\nvoid gf_bs_get_content(GF_BitStream *bs, u8 **output, u32 *outSize)\n{\n\tgf_bs_get_content_no_truncate(bs, output, outSize, NULL);\n}\n\n/*\tSkip nbytes.\n\tAlign\n\tIf READ (MEM or FILE) mode, just read n times 8 bit\n\tIf WRITE (MEM or FILE) mode, write n times 0 on 8 bit\n*/\nGF_EXPORT\nvoid gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\n\tgf_bs_align(bs);\n\n\t/*special case for file skipping...*/\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\t//weird msys2 bug resulting in broken seek on some files ?!?  -the bug is not happening when doing absolute seek\n//\t\tgf_fseek(bs->stream, nbBytes, SEEK_CUR);\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\n\t/*special case for reading*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\t/*for writing we must do it this way, otherwise pb in dynamic buffers*/\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}\n\n#ifdef GPAC_ENABLE_BIFS_PMF\n\nvoid gf_bs_rewind_bits(GF_BitStream *bs, u64 nbBits)\n{\n\tu64 nbBytes;\n\tif (bs->bsmode != GF_BITSTREAM_READ) return;\n\n\tnbBits -= (bs->nbBits);\n\tnbBytes = (nbBits+8)>>3;\n\tnbBits = nbBytes*8 - nbBits;\n\tgf_bs_align(bs);\n\tassert(bs->position >= nbBytes);\n\tbs->position -= nbBytes + 1;\n\tgf_bs_read_int(bs, (u32)nbBits);\n\treturn;\n}\n\n#endif\n\n/*seek from beginning of stream: use internally even when non aligned!*/\nstatic GF_Err BS_SeekIntern(GF_BitStream *bs, u64 offset)\n{\n\tu32 i;\n\t/*if mem, do it */\n\tif ((bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)) {\n\t\tif (offset > 0xFFFFFFFF) return GF_IO_ERR;\n\t\tif (!bs->original) return GF_BAD_PARAM;\n\t\t/*0 for write, read will be done automatically*/\n\t\tif (offset >= bs->size) {\n\t\t\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) ) {\n\t\t\t\tif (offset > bs->size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[BS] Attempt to seek to %d after end of bitstream %d, assuming seek to end\\n\", offset, bs->size));\n\t\t\t\t}\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t/*in DYN, gf_realloc ...*/\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32) (offset + 1));\n\t\t\tif (!bs->original)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i = 0; i < (u32) (offset + 1 - bs->size); i++) {\n\t\t\t\tbs->original[bs->size + i] = 0;\n\t\t\t}\n\t\t\tbs->size = offset + 1;\n\t\t}\n\t\tbs->current = bs->original[offset];\n\t\tbs->position = offset;\n\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tif (bs->cache_read) {\n\t\tbs->cache_read_pos = bs->cache_read_size;\n\t}\n\n\tgf_fseek(bs->stream, offset, SEEK_SET);\n\n\tbs->position = offset;\n\tbs->current = 0;\n\t/*setup NbBits so that next acccess to the buffer will trigger read/write*/\n\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\treturn GF_OK;\n}\n\n/*seek from beginning of stream: align before anything else*/\nGF_EXPORT\nGF_Err gf_bs_seek(GF_BitStream *bs, u64 offset)\n{\n\tbs->overflow_state = 0;\n\tif (bs->on_block_out) {\n\t\tGF_Err e;\n\t\tif (offset < bs->bytes_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to seek on byte range already forwarded\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\t/*warning: we allow offset = bs->size for WRITE buffers*/\n\t\tif (offset - bs->bytes_out > bs->size)\n\t\t\treturn GF_BAD_PARAM;\n\t\tgf_bs_align(bs);\n\t\te = BS_SeekIntern(bs, offset - bs->bytes_out);\n\t\tbs->position += bs->bytes_out;\n\t\treturn e;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\t/*warning: we allow offset = bs->size for WRITE buffers*/\n\tif (offset > bs->size) return GF_BAD_PARAM;\n\n\tgf_bs_align(bs);\n\treturn BS_SeekIntern(bs, offset);\n}\n\n/*peek bits (as int!!) from orig position (ON BYTE BOUNDARIES, from 0) - only for read ...*/\nGF_EXPORT\nu32 gf_bs_peek_bits(GF_BitStream *bs, u32 numBits, u64 byte_offset)\n{\n\tu64 curPos;\n\tu32 curBits, ret, current, nb_zeros, nb_removed;\n\n\tif ( (bs->bsmode != GF_BITSTREAM_READ) && (bs->bsmode != GF_BITSTREAM_FILE_READ)) return 0;\n\tif (!numBits || (bs->size < bs->position + byte_offset)) return 0;\n\n\t/*store our state*/\n\tcurPos = bs->position;\n\tcurBits = bs->nbBits;\n\tcurrent = bs->current;\n\tnb_zeros = bs->nb_zeros;\n\tnb_removed = bs->nb_removed;\n\n\tif (byte_offset) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (byte_offset) {\n\t\t\t\tgf_bs_read_int(bs, 8);\n\t\t\t\tbyte_offset--;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_seek(bs, bs->position + byte_offset);\n\t\t}\n\t}\n\tret = gf_bs_read_int(bs, numBits);\n\n\t/*restore our cache - position*/\n\tgf_bs_seek(bs, curPos);\n\t/*to avoid re-reading our bits ...*/\n\tbs->nbBits = curBits;\n\tbs->current = current;\n\tbs->nb_zeros = nb_zeros;\n\tbs->nb_removed = nb_removed;\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_bs_get_refreshed_size(GF_BitStream *bs)\n{\n\ts64 offset;\n\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_READ:\n\tcase GF_BITSTREAM_WRITE:\n\t\treturn bs->size;\n\n\tdefault:\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\n\t\tif (bs->stream) {\n\t\t\toffset = gf_ftell(bs->stream);\n\t\t\tbs->size = gf_fsize(bs->stream);\n\t\t\tgf_fseek(bs->stream, offset, SEEK_SET);\n\t\t}\n\t\treturn bs->size;\n\t}\n}\n\nGF_EXPORT\nu64 gf_bs_get_size(GF_BitStream *bs)\n{\n\tif (bs->cache_write) {\n\t\tif (bs->size == bs->position)\n\t\t\treturn bs->size + bs->buffer_written;\n\t\telse\n\t\t\treturn bs->size;\n\t}\n\tif (bs->on_block_out)\n\t\treturn bs->position;\n\treturn bs->size;\n}\n\nGF_EXPORT\nu64 gf_bs_get_position(GF_BitStream *bs)\n{\n\tif (bs->cache_write)\n\t\treturn bs->position + bs->buffer_written;\n\treturn bs->position;\n}\n\nGF_EXPORT\nu8 gf_bs_bits_available(GF_BitStream *bs)\n{\n\tif (bs->size > bs->position) return 8;\n\tif (bs->nbBits < 8) return (8-bs->nbBits);\n\treturn 0;\n}\n\nGF_EXPORT\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par)\n{\n\tbs->EndOfStream = EndOfStream;\n\tbs->par = par;\n}\n\n\nGF_EXPORT\nu64 gf_bs_read_u64_le(GF_BitStream *bs)\n{\n\tu64 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=16;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=24;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=32;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=40;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=48;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=56;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nu32 gf_bs_read_u32_le(GF_BitStream *bs)\n{\n\tu32 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=16;\n\tret |= v;\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=24;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nu16 gf_bs_read_u16_le(GF_BitStream *bs)\n{\n\tu32 ret, v;\n\tret = gf_bs_read_int(bs, 8);\n\tv = gf_bs_read_int(bs, 8);\n\tv<<=8;\n\tret |= v;\n\treturn ret;\n}\n\nGF_EXPORT\nvoid gf_bs_write_u64_le(GF_BitStream *bs, u64 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>8) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>16) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>24) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>32) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>40) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>48) & 0xFF, 8);\n\tgf_bs_write_int(bs, (val>>56) & 0xFF, 8);\n}\n\nGF_EXPORT\nvoid gf_bs_write_u32_le(GF_BitStream *bs, u32 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, val>>8, 8);\n\tgf_bs_write_int(bs, val>>16, 8);\n\tgf_bs_write_int(bs, val>>24, 8);\n}\n\nGF_EXPORT\nvoid gf_bs_write_u16_le(GF_BitStream *bs, u32 val)\n{\n\tgf_bs_write_int(bs, val & 0xFF, 8);\n\tgf_bs_write_int(bs, val>>8, 8);\n}\n\nGF_EXPORT\nu32 gf_bs_get_bit_offset(GF_BitStream *bs)\n{\n\tif (bs->bsmode==GF_BITSTREAM_READ) return (u32) ( (bs->position - 1) * 8 + bs->nbBits);\n\treturn (u32) ( (bs->position ) * 8 + bs->nbBits);\n}\n\nGF_EXPORT\nu32 gf_bs_get_bit_position(GF_BitStream *bs)\n{\n\treturn bs->nbBits;\n}\n\nGF_EXPORT\nu32 gf_bs_read_vluimsbf5(GF_BitStream *bs)\n{\n\tu32 nb_words = 0;\n\twhile (gf_bs_read_int(bs, 1)) nb_words++;\n\tnb_words++;\n\treturn gf_bs_read_int(bs, 4*nb_words);\n}\n\nGF_EXPORT\nvoid gf_bs_truncate(GF_BitStream *bs)\n{\n\tbs->size = bs->position;\n}\n\n\nGF_EXPORT\nGF_Err gf_bs_transfer(GF_BitStream *dst, GF_BitStream *src, Bool keep_src)\n{\n\tu8 *data;\n\tu32 data_len, written;\n\n\tdata = NULL;\n\tdata_len = 0;\n\tgf_bs_get_content(src, &data, &data_len);\n\tif (!data || !data_len)\n\t{\n\t\tif (data) {\n\t\t\tif (keep_src) {\n\t\t\t\tsrc->original = data;\n\t\t\t\tsrc->size = data_len;\n\t\t\t} else {\n\t\t\t\tgf_free(data);\n\t\t\t}\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\twritten = gf_bs_write_data(dst, data, data_len);\n\tif (keep_src) {\n\t\tsrc->original = data;\n\t\tsrc->size = data_len;\n\t} else {\n\t\tgf_free(data);\n\t}\n\tif (written<data_len) return GF_IO_ERR;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_bs_flush(GF_BitStream *bs)\n{\n\tif (!bs->stream) return;\n\tif (bs->bsmode != GF_BITSTREAM_FILE_WRITE) return;\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tgf_fflush(bs->stream);\n}\n\n#if 0 //unused\n/*!\n\\brief Reassigns FILE object for stream-based bitstreams\n *\n *Reassigns FILE object for stream-based bitstreams. Automatically sets the stream position to the bitstream position\n\\param bs the target bitstream\n\\param stream the new stream to assign\n */\nvoid gf_bs_reassign(GF_BitStream *bs, FILE *stream)\n{\n\tif (!bs) return;\n\tswitch (bs->bsmode) {\n\tcase GF_BITSTREAM_FILE_WRITE:\n\tcase GF_BITSTREAM_FILE_READ:\n\t\tbs->stream = stream;\n\t\tif (gf_ftell(stream) != bs->position)\n\t\t\tgf_bs_seek(bs, bs->position);\n\t\tbreak;\n\t}\n}\n#endif\n\nu64 gf_bs_set_cookie(GF_BitStream *bs, u64 cookie)\n{\n\tu64 res = 0;\n\tif (bs) {\n\t\tres = bs->cookie;\n\t\tbs->cookie = cookie;\n\t}\n\treturn res;\n}\n\nu64 gf_bs_get_cookie(GF_BitStream *bs)\n{\n\tif (!bs) return 0;\n\treturn bs->cookie;\n}\n\nGF_EXPORT\nGF_Err gf_bs_insert_data(GF_BitStream *bs, u8 *data, u32 size, u64 offset)\n{\n\tu64 cur_r, cur_w, pos;\n\tu32 nb_io;\n\n\tif (bs->on_block_out) return GF_BAD_PARAM;\n\n\tpos = bs->position;\n\tnb_io = gf_bs_write_data(bs, data, size);\n\tif (nb_io != size) goto exit;\n\n\tcur_w = bs->position;\n\tgf_bs_seek(bs, pos);\n\tcur_r = pos;\n\tpos = cur_w;\n\twhile (cur_r > offset) {\n\t\tu8 block[8196];\n\t\tu32 move_bytes = 8196;\n\t\tif (cur_r - offset < move_bytes)\n\t\t\tmove_bytes = (u32) (cur_r - offset);\n\n\t\tgf_bs_seek(bs, cur_r - move_bytes);\n\t\tnb_io = gf_bs_read_data(bs, block, move_bytes);\n\t\tif (nb_io != move_bytes) goto exit;\n\t\tgf_bs_seek(bs, cur_w - move_bytes);\n\t\tnb_io = gf_bs_write_data(bs, block, move_bytes);\n\t\tif (nb_io != move_bytes) goto exit;\n\t\tcur_r -= move_bytes;\n\t\tcur_w -= move_bytes;\n\t}\n\n\tgf_bs_seek(bs, offset);\n\tnb_io = gf_bs_write_data(bs, data, size);\n\tif (nb_io != size) goto exit;\n\n\tgf_bs_seek(bs, pos);\n\treturn GF_OK;\n\nexit:\n\tgf_bs_seek(bs, pos);\n\treturn GF_IO_ERR;\n}\n\n\nGF_Err gf_bs_set_logger(GF_BitStream *bs, void (*on_bs_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3), void *udta)\n{\n\tif (!bs) return GF_BAD_PARAM;\n\tbs->on_log = on_bs_log;\n\tbs->log_udta = udta;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_AVPARSE_LOGS\nvoid gf_bs_log_idx(GF_BitStream *bs, u32 nBits, const char *fname, s64 val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tassert(bs);\n\tif (bs->on_log) bs->on_log(bs->log_udta, fname, nBits, val, idx1, idx2, idx3);\n}\n#endif\n\n\nvoid gf_bs_mark_overflow(GF_BitStream *bs, Bool reset)\n{\n\tbs->overflow_state = reset ? 0 : 2;\n}\nu32 gf_bs_is_overflow(GF_BitStream *bs)\n{\n\treturn bs->overflow_state;\n}\n\n\nGF_EXPORT\nchar *gf_bs_read_utf8(GF_BitStream *bs)\n{\n\tchar szC[2];\n\tchar *res = NULL;\n\tif (!bs || !gf_bs_is_align(bs))\n\t\treturn NULL;\n\n\tszC[1] = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tu8 c = gf_bs_read_u8(bs);\n\t\tif (!c) break;\n\t\tszC[0] = c;\n\t\tgf_dynstrcat(&res, szC, NULL);\n\t}\n\treturn res;\n}\n\nGF_EXPORT\nGF_Err gf_bs_write_utf8(GF_BitStream *bs, const char *str)\n{\n\tif (!bs || !gf_bs_is_align(bs))\n\t\treturn GF_BAD_PARAM;\n\n\tu32 i, len = str ? (u32) strlen(str) : 0;\n\tfor (i=0; i<len; i++)\n\t\tgf_bs_write_u8(bs, str[i]);\n\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n"], "filenames": ["src/filters/reframe_rawpcm.c", "src/utils/bitstream.c"], "buggy_code_start_loc": [252, 1268], "buggy_code_end_loc": [320, 1268], "fixing_code_start_loc": [253, 1269], "fixing_code_end_loc": [324, 1273], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.4.0.", "other": {"cve": {"id": "CVE-2023-1655", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-27T15:15:08.390", "lastModified": "2023-04-03T18:27:42.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.4.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.0", "matchCriteriaId": "8D40AF3F-484F-41A5-BBAD-15B2391EB83F"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/e7f96c2d3774e4ea25f952bcdf55af1dd6e919f4", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/05f1d1de-bbfd-43fe-bdf9-7f73419ce7c9", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/e7f96c2d3774e4ea25f952bcdf55af1dd6e919f4"}}