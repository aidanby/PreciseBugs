{"buggy_code": ["To build RPM you will need several other packages:\n--------------------------------------------------\n\nThe popt library for option parsing, must be version 1.13 or later.\nIt is available from\n    http://ftp.rpm.org/popt/\n\nThe debugedit >= 0.3 tools for producing debuginfo sub-packages.\nIt is available from\n   https://sourceware.org/debugedit/\n\nLua >= 5.2 library + development environment.\nNote that only the library is needed at runtime, RPM never calls external\nLua interpreter for anything. Lua is available from\n    http://www.lua.org\n\nThe zlib library for compression support. You might also need/want\nthe unzip executable for java jar dependency analysis. All available from\n    http://www.gzip.org/zlib/\n\nThe libmagic (aka file) library for file type detection (used by rpmbuild). \nThe source for the file utility + library is available from\n    ftp://ftp.astron.com/pub/file/\n\nYou will need a cryptographic library to support digests and signatures.\nThis library may be libgcrypt or OpenSSL, and can be specified with the\n--with-crypto=[libgcrypt|openssl] argument to configure.\nlibgcrypt is the default.\n\nlibgcrypt library is available from https://www.gnupg.org/software/libgcrypt/\n\nIf using the OpenSSL library for encryption, it must be version 1.0.2 or\nlater. Note: when compiling against OpenSSL, there is a possible license\nincompatibility. For more details on this, see\nhttps://people.gnome.org/~markmc/openssl-and-the-gpl.html\nSome Linux distributions have different legal interpretations of this\npossible incompatibility. It is recommended to consult with a lawyer before\nbuilding RPM against OpenSSL.\nFedora: https://fedoraproject.org/wiki/Licensing:FAQ#What.27s_the_deal_with_the_OpenSSL_license.3F\nDebian: https://lists.debian.org/debian-legal/2002/10/msg00113.html\n\nThe OpenSSL crypto library is available from https://www.openssl.org/\n\nRPM needs a database engine for normal operation. The main options are\n\"ndb\" (--enable-ndb) and \"sqlite\" (--enable-sqlite).\nAdditionally standalone support for read-only BDB databases is available as\n\"bdb_ro\" (--enable-bdb-ro) to aid with migration from BDB.\n\nThe ndb and bdb_ro backends have no external dependencies.\nSQLite >= 3.22.0 is required for the sqlite database backend.\nSQLite is available from https://www.sqlite.org/\n\nIf SELinux support is desired, it can be enabled with --with-selinux option\nto configure and libselinux development environment installed. SELinux\nis available from\n    http://www.nsa.gov/selinux/\n\nIt may be desired to install bzip2, gzip, and xz/lzma so that RPM can use these\nformats.  Gzip is necessary to build packages that contain compressed\ntar balls, these are quite common on the Internet.\nThese are available from\n    http://www.gzip.org\n    http://www.bzip.org\n    http://tukaani.org/xz/\n\nIf you want to build the Python bindings to RPM library, it can be enabled\nwith --enable-python option to configure. You'll need to have Python >= 3.1\nruntime and C API development environment installed.\nPython is available from:\n    http://www.python.org/\n\nTo enable POSIX.1e draft 15 file capabilities support, configure with\n--with-cap. You'll also need recent libcap, available from:\n    http://ftp.kernel.org/pub/linux/libs/security/linux-privs/libcap2/\n\nTo enable POSIX 1003.1e draft 17 ACL verification support, configure with\n--with-acl. You'll also need the ACL library, available from:\n    ftp://oss.sgi.com/projects/xfs/cmd_tars/\n\nFor best results you should compile with GCC and GNU Make.  Users have\nreported difficulty with other build tools (any patches to lift these\ndependencies are welcome). Both GCC and GNU Make available from \n    http://www.gnu.org/\n\nIf National Language Support (NLS) is desired you will need gnu\ngettext (currently this is required to build rpm but we hope to \nlift this requirement soon), available from \n    http://www.gnu.org/\n\nIf you are going to hack the sources (or compile from source repository)\nyou will need most of the GNU development tools including:\nautoconf, automake, gettext, libtool, makeinfo, perl, GNU m4, GNU tar\navailable from \n    http://www.gnu.org/\n\nIf you plan on using cryptographic signatures you will need a version\nof GPG, available from\n    http://www.gnupg.org/\n\nOpenMP multithreading support is automatically enabled if your C compiler has\nsupport for OpenMP version 4.5 or higher (to disable, pass the --disable-openmp\noption to configure).  For GCC, OpenMP 4.5 is fully supported since GCC 6.1,\nwhich is available from\n    http://www.gnu.org/\n\nTo compile RPM:\n--------------\n\nRPM uses a small shell script to run: libtool, autoconf,\nautomake. This step should not be necessary if you are running a\nreleased version of rpm, however if you have gotten the rpm sources\ndirectly from the source code repository, you need to generate\nintermediate files by running the autogen.sh script.\n\nThe autogen.sh script checks that the required tools are installed.\nThe autogen.sh script also runs configure for you and passes the command line\narguments to configure.  To run it without configure type:\n\n    ./autogen.sh --noconfigure\n\nIf your libraries are not in a standard place you will need to change\nconfigures environment.  These options can be passed directly to\nconfigure or to autogen.sh which will pass them through to configure.\n\nHere is an example:\n    LIBS='-L/opt/libz/ -L/opt/BerkeleyDB/lib/' \\\n    CPPFLAGS='-I/opt/libz/ -I/opt/BerkeleyDB/include' \\\n    ./configure\n\nIf you have build tools stored in non standard places you should check\nthe resulting Makefile to be sure that the tools you wish to use have\nbeen correctly identified.  The configure script will modify your path\nbefore looking for the build tools and it may find versions of these\ntools that you do not want.  It uses the following search path\n\n    MYPATH=\"/bin:/usr/bin:/usr/local/bin:$PATH:/opt/gnu/bin\"\n\nnow build the system with:\n\n    make\n\nand then install with:\n\n    make install\n\nRpm comes with an automated self-test suite. The test-suite relies heavily\non fakechroot (https://github.com/dex4er/fakechroot/) and cannot be executed\nwithout it. Provided that fakechroot was found during configure,\nit can be executed after a successful build with:\n\n    make check\n\nFinally, if you wish to prepare an rpm source tar ball, you should do\n\n    make dist\n\nTo package RPM:\n--------------\n\nAfter RPM has been installed you can run rpm to build an rpm package.\nEdit the rpm.spec file to mirror any special steps you needed to\nfollow to make rpm compile and change the specfile to match your\ntaste.  You will need to put the rpm source tar file into the\nSOURCES directory and we suggest putting the specfile in the\nSPECS directory, then run rpmbuild -ba rpm.spec.  You will end up\nwith two rpms which can be found in RPMS and SRPMS.\n\nIf you are going to install rpm on machines with OS package managers\nother then rpm, you may choose to install the base rpm package via a\ncpio instead of a tar file.  Instead of running \"make tar\" during the\nbuild process, as described above, use the base rpm packages to create\na cpio.  After the rpms have been created run rpm2cpio on the base rpm\npackage, this will give you a cpio package which can then use to\ninstall rpm on a new system.\n\n    rpm2cpio rpm-4.0-1.solaris2.6-sparc.rpm > rpm-4.0-1.solaris2.6-sparc.cpio\n\n\nNon Linux Configuration Issues:\n------------------------------\n\n\nOS dependencies:\n----------------\n\nUnder RPM based Linux distributions all libraries (in fact all files \ndistributed with the OS) are under RPM control and this section is not \nan issue.\n\nRPM will need to be informed of all the dependencies which were\nsatisfied before RPM was installed.  Typically this only refers to\nlibraries that are installed by the OS, but may include other\nlibraries and packages which are available at the time RPM is\ninstalled and will not under RPM control.  Another common example of\nlibraries which may need dependency provisions are precompiled\nlibraries which are installed by the OS package manager during system\nbuild time.  The list of dependencies you will wish to load into RPM\nwill depend on exactly how you bootstrap RPM onto your system and what\nparts of the system you put into packages as well as on the specific OS\nyou are using.\n\nThe script vpkg-provides.sh can be used to generate a package which\nwill satisfy the dependencies on your system.  To run it you will need\nto create a specfile header for this empty package and run the progam\nwith:\n\n    --spec_header '/path/to/os-base-header.spec\n\nand if you wish to ensure that some directories are not traversed you\ncan use the option: \n\n    --ignore_dirs 'grep-E|pattern|of|paths|to|ignore\n\nBy default the generated rpm will include a %verifyscript to verify\nchecksum of all files traversed has not changed.  This additional\ncheck can be suppressed with:\n\n    --no_verify\n\nThe result of running the script will be a specfile which will create\na package continging all the dependencies found on the system.  There\nwill be one provides line for each depednecy. The package will contain\nnone of the actual OS library files as it is assumed they are already\non your system and managed by other means.  Here is a example\n(truncated) of the provides lines used by one user of Digital Unix. (I\nhave put several provides on the same line for brevity)\n\nprovides: /bin/sh /usr/bin/ksh /usr/bin/csh \nprovides: libc.so.osf.1 libm.so.osf.1 libcurses.so.xpg4 libdb.so.osf.1\nprovides: libX11.so libXaw.so.6.0 libXext.so libXm.so.motif1.2 libXmu.so\nprovides: libdnet_stub.so.osf.1 libsecurity.so.osf.1 libpthread.so.osf.1\nprovides: libexc.so.osf.1 libmach.so.osf.1 libdps.so libdpstk.so \n\n\nThe script vpkg-provides2.sh is underdevelopment as a more advanced\nversion of vpkg-provides.sh which is aware of many different unix\nvendor packaging schemes.  It will create one \"dependency package\" for\neach unix package your OS vendor installed.\n\n\nrpmfilename:\n-----------\n\nIf you plan on packaging for more then one OS you may want to edit\n/etc/macros or /usr/lib/rpm/macros and change the line which has\nrpmfilename to something which include both the %{_target_os} and\n%{_target_cpu}.  This will cause the name of the generated rpm files\nto the operating system name as well as the architecture which the rpm\nruns under.  The line to change looks like:\n\n%_rpmfilename           %%{ARCH}/%%{NAME}-%%{VERSION}-%%{RELEASE}.%%{ARCH}.rpm\n\nyou may wish to include both the %{_target_os} and %{_target_cpu} in\nthe final base name, so that it's easier to distinguish between what\npackage is appropriate for a particular arch-os-version combo.  We\nsuggest:\n\n%_rpmfilename           %%{_target_platform/%%{NAME}-%%{VERSION}-%%{RELEASE}.%%{_target_platform}.rpm\n\nThere is no %{_target_os_version} tag, so if you need to also\ndistinguish between RPMs for certain versions of the OS, you can\nhard-code the version in the rpmrc on the build machine, so that .rpm\nfiles are generated with the version as part of the filename.\n\nFor example when one user builds RPMs for Digital Unix 4.0b and 4.0d,\noptimization is important and he will build one set of RPMs for the\nEV4 processor and another set for the EV56 processor.  He specifies\nboth the OS version (if it's important, as it is for a few packages)\nand the processor version by default by setting a special rpmfilename:\non the particular build machine.\n\nThe \"rpmfilename: \"tag on one machine (Digital Unix 4.0d, EV56 PWS 433)\nlooks like:\n\nrpmfilename: %{_target_os}/4.0d/%{_target_cpu}/%{name}-%{version}-%{release}.%{_target_os}-%{_target_cpu}ev56.rpm\n\nFor package `foo-1.1', at build time that would translate into:\n\n    osf1/4.0d/alpha/foo-1.1-1.osf1-alphaev56.rpm\n\nThe hyphen between the %{_target_cpu} and ev56 is left out for compatibility\nwith GNU Config.guess and because `alphaev56' looks more \"normal\" to\npeople with an alpha than alpha-ev56 for someone on an Intel Pentium\nPro would want `i586pro' over `i586-pro', but it does make parsing\nthis filename by other programs a bit more difficult.\n\n\nGPG\n---\n\nTo use the signing features of rpm, you will need to configure certain\nrpm macros in ~/.rpmmacros:\n\n\t%_gpg_name      <GPG UID>\n\t%_gpg_path      %(echo $HOME)/.gnupg\n\n", "AC_PREREQ(2.61)\nAC_INIT(rpm, 4.17.90, rpm-maint@lists.rpm.org)\n\nAC_CONFIG_SRCDIR([rpm.c])\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_AUX_DIR([build-aux])\n\nAM_INIT_AUTOMAKE([1.10 foreign tar-pax dist-bzip2 subdir-objects nostdinc])\ndnl Allow silent build on automake versions that support it\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES])\n\nAC_CONFIG_TESTDIR(tests)\n\nAC_USE_SYSTEM_EXTENSIONS\n\nAC_DISABLE_STATIC\n\nPKG_PROG_PKG_CONFIG\n\ndnl Checks for programs.\nAC_PROG_CXX\nAC_PROG_AWK\nAC_PROG_CC\nAC_PROG_CPP\nAC_PROG_INSTALL\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAC_PROG_LIBTOOL\n\nAC_SUBST(__CC, $CC)\nAC_PROG_CC_C99\nif test \"$ac_cv_prog_cc_c99\" = no; then\n    AC_MSG_ERROR([ISO C99 capable compiler required])\nfi\n\nAS=${AS-as}\nAC_SUBST(AS)\nif test \"$GCC\" = yes; then\n    cflags_to_try=\"-fno-strict-aliasing -fno-strict-overflow -fno-delete-null-pointer-checks -Wempty-body\"\n    AC_MSG_CHECKING([supported compiler flags])\n    old_cflags=$CFLAGS\n    echo\n    for flag in $cflags_to_try; do\n        CFLAGS=\"$CFLAGS $flag -Werror\"\n        AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[#include <alloca.h>\n\t\t\t\t\t\talloca(100);]])],[\n                echo \"   $flag\"\n                RPMCFLAGS=\"$RPMCFLAGS $flag\"\n        ],[])\n        CFLAGS=$old_cflags\n    done\n    RPMCFLAGS=\"-Wall -Wpointer-arith -Wmissing-prototypes -Wstrict-prototypes $RPMCFLAGS\"\nfi\nAC_ARG_ENABLE(werror, [AS_HELP_STRING([--enable-werror], [build with -Werror])],\n\t\t[RPMCFLAGS=\"$RPMCFLAGS -Werror\"], [])\nAC_SUBST(RPMCFLAGS)\n\nAC_SYS_LARGEFILE\n\ndnl AM_DISABLE_SHARED\nAM_PROG_LIBTOOL\n\nAC_CHECK_TOOL(AR, ar, :)\n\ndnl\ndnl use defaults if cross-compiling, otherwise use the default path.\ndnl\nif test \"$cross_compiling\" = \"yes\"; then\n    MYPATH=\":\"\nelse\n    MYPATH=$PATH\nfi\n\ndnl\ndnl Find some common programs\ndnl\nAC_PATH_PROGS(__7ZIP, [7zip 7za 7z], /usr/bin/7za, $MYPATH)\nAC_PATH_PROG(__BZIP2, bzip2, /usr/bin/bzip2, $MYPATH)\nAC_PATH_PROG(__CAT, cat, /bin/cat, $MYPATH)\nAC_PATH_PROG(__CHMOD, chmod, /bin/chmod, $MYPATH)\nAC_PATH_PROG(__CHOWN, chown, /bin/chown, $MYPATH)\nAC_PATH_PROG(__CP, cp, /bin/cp, $MYPATH)\nAC_PATH_PROG(__CURL, curl, /usr/bin/curl, $MYPATH)\nAC_PATH_PROG(__FILE, file, /usr/bin/file, $MYPATH)\nAC_PATH_PROGS(__GPG, gpg2 gpg, /usr/bin/gpg2, $MYPATH)\nAC_PATH_PROG(__GREP, grep, /bin/grep, $MYPATH)\nAC_PATH_PROG(__GZIP, gzip, /bin/gzip, $MYPATH)\nAC_PATH_PROG(__UNZIP, unzip, /usr/bin/unzip, $MYPATH)\nAC_PATH_PROG(__ID, id, /usr/bin/id, $MYPATH)\nAC_PATH_PROG(__INSTALL, install, /usr/bin/install, $MYPATH)\nAC_PATH_PROG(__LRZIP, lrzip, /usr/bin/lrzip, $MYPATH)\nAC_PATH_PROG(__LZIP, lzip, /usr/bin/lzip, $MYPATH)\nAC_PATH_PROG(__XZ, xz, /usr/bin/xz, $MYPATH)\nAC_PATH_PROG(__GEM, gem, /usr/bin/gem, $MYPATH)\nAC_PATH_PROG(__MAKE, make, /usr/bin/make, $MYPATH)\nAC_PATH_PROG(__MKDIR, mkdir, /bin/mkdir, $MYPATH)\nAC_PATH_PROG(__MV, mv, /bin/mv, $MYPATH)\nAC_PATH_PROG(__PATCH, patch, /usr/bin/patch, $MYPATH)\nAC_PATH_PROG(__RM, rm, /bin/rm, $MYPATH)\nAC_PATH_PROG(__SED, sed, /bin/sed, $MYPATH)\nAC_PATH_PROG(__TAR, tar, /bin/tar, $MYPATH)\nAC_PATH_PROG(__ZSTD, zstd, /usr/bin/zstd, $MYPATH)\n\nAC_PATH_PROG(__LD, ld, /usr/bin/ld, $MYPATH)\nAC_PATH_PROG(__OBJDUMP, objdump, /usr/bin/objdump, $MYPATH)\nAC_PATH_PROG(__STRIP, strip, /usr/bin/strip, $MYPATH)\nAC_PATH_PROG(__FIND_DEBUGINFO, find-debuginfo, /usr/bin/find-debuginfo, $MYPATH)\n\nAC_PATH_PROG(__GIT, git, /usr/bin/git, $MYPATH)\nAC_PATH_PROG(__HG, hg, /usr/bin/hg, $MYPATH)\nAC_PATH_PROG(__BZR, bzr, /usr/bin/bzr, $MYPATH)\nAC_PATH_PROG(__QUILT, quilt, /usr/bin/quilt, $MYPATH)\n\nAC_PATH_PROG(__FAKECHROOT, fakechroot, no, $MYPATH)\nAM_CONDITIONAL(HAVE_FAKECHROOT, [test \"$__FAKECHROOT\" != \"no\"])\n\ndnl see if we have a mkdir that supports `-p' for rpmbuild's purposes\nAC_PROG_MKDIR_P\nif ! echo $MKDIR_P | grep -q mkdir; then \n  __MKDIR_P=\"`echo ${prefix}/lib/rpm/mkinstalldirs`\"\nelse\n  __MKDIR_P=$MKDIR_P\nfi\nAC_DEFINE_UNQUOTED(__MKDIR_P, \"${__MKDIR_P}\",\n[A full path to a program, possibly with arguments, that will create a\n   directory and all necessary parent directories, ala 'mkdir -p'])\nAC_SUBST(__MKDIR_P)\n\n#=================\n# Check for zlib library. \n\nWITH_ZLIB_INCLUDE=\nWITH_ZLIB_LIB=\n\nAC_CHECK_HEADERS([zlib.h],[\n  AS_IF([test -z \"${WITH_ZLIB_LIB}\"],[\n    for zlib in z gz ; do\n      AC_CHECK_LIB(${zlib}, gzread, \n\t[WITH_ZLIB_LIB=\"-l${zlib}\"; break])\n    done\n\ndnl zlib-1.0.4 has not gzseek\n    AC_CHECK_LIB(${zlib}, gzseek, [AC_DEFINE(HAVE_GZSEEK, 1, [Define as 1 if your zlib has gzseek()])])\n  ])\n],[\n  AC_MSG_ERROR([missing required header zlib.h])\n])\n\nAC_SUBST(WITH_ZLIB_INCLUDE)\nAC_SUBST(WITH_ZLIB_LIB)\n\n#=================\n# Check for bzip2 library.\n\nAC_CHECK_HEADERS([bzlib.h],[\n  AC_CHECK_LIB(bz2, BZ2_bzread, [WITH_BZ2_LIB=-lbz2])\n])\nAC_SUBST(WITH_BZ2_LIB)\n\n#=================\n# Check for lzma library.\n\nAC_CHECK_HEADERS([lzma.h],[\n  AC_CHECK_LIB(lzma, lzma_easy_encoder, [WITH_LZMA_LIB=-llzma])\n])\nAC_SUBST(WITH_LZMA_LIB)\n\n# AC_OPENMP supports --enable/disable-openmp out of the box, but it doesn't\n# actually give us a way to conditionalize the build based on that. Argh.\n# Version 4.5 (201511) introduced \"priority\" clause for tasks.\nOPENMP_CFLAGS=\nAC_OPENMP\nAS_IF([test \"x$ac_cv_prog_c_openmp\" != x &&\n       test \"x$ac_cv_prog_c_openmp\" != xunsupported],[\n  old_CFLAGS=$CFLAGS\n  CFLAGS=\"$CFLAGS $OPENMP_CFLAGS\"\n  AC_MSG_CHECKING([OpenMP is at least version 4.5])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM(\n      [#include <omp.h>],\n      [#if _OPENMP < 201511\n       #error\n       #endif\n      ]\n    )],\n    [AC_MSG_RESULT([yes])\n     AC_DEFINE(ENABLE_OPENMP, 1, [Enable multithreading support?])\n    ],\n    [AC_MSG_RESULT([no])\n     OPENMP_CFLAGS=\n     if test \"$enable_openmp\" = \"yes\"; then\n       AC_MSG_ERROR([OpenMP too old])\n     fi\n    ]\n  )\n  CFLAGS=$old_CFLAGS\n])\nAC_SUBST(OPENMP_CFLAGS)\n\n#=================\n# Check for zstd.\n\nAC_ARG_ENABLE([zstd],\n              [AS_HELP_STRING([--enable-zstd=@<:@yes/no/auto@:>@],\n                              [build without zstd support (default=auto)])],\n              [enable_zstd=\"$enableval\"],\n              [enable_zstd=auto])\n\nAS_IF([test \"x$enable_zstd\" != \"xno\"], [\n  PKG_CHECK_MODULES([ZSTD], [libzstd >= 1.3.8], [have_zstd=yes], [have_zstd=no])\n  AS_IF([test \"$enable_zstd\" = \"yes\"], [\n    if test \"$have_zstd\" = \"no\"; then\n      AC_MSG_ERROR([--enable-zstd specified, but not available])\n    fi\n  ])\n])\n\nif test \"x$have_zstd\" = \"xyes\"; then\n  AC_DEFINE([HAVE_ZSTD], [1], [Define if libzstd is available])\n  ZSTD_REQUIRES=libzstd\n  AC_SUBST(ZSTD_REQUIRES)\nfi\nAM_CONDITIONAL([HAVE_ZSTD], [test \"x$have_zstd\" = \"xyes\"])\n\n#=================\n\ndnl\ndnl Check for features\ndnl\n\ndnl Checks for libraries.\n\nAC_CHECK_FUNC(gethostname, [], [\n    AC_CHECK_LIB(nsl, gethostname)\n])\n\nAC_CHECK_HEADERS(pthread.h)\n\nAC_CHECK_LIB(pthread, pthread_mutex_trylock, [], [\n  dnl OSF 5.0 has the the symbols prefixed with __ in libpthread.\n  AC_CHECK_LIB(pthread, __pthread_mutex_trylock, [], [\n    AC_CHECK_LIB(thread, mutex_lock)\n  ])\n])\n\nAC_SEARCH_LIBS(dlopen, [dl])\n\n#=================\n# Check for libelf library. Prefer external, otherwise none.\nAC_ARG_ENABLE([libelf],\n\t\t[AS_HELP_STRING([--enable-libelf=@<:@yes/no/auto@:>@],\n\t\t\t\t[build with libelf support (default=yes)])],\n\t\t[enable_libelf=\"$enableval\"],\n\t\t[enable_libelf=yes])\n\nAS_IF([test \"x$enable_libelf\" != \"xno\"], [\n  WITH_LIBELF_LIB=\n  AC_CHECK_HEADER([libelf.h])\n  AC_CHECK_HEADERS([gelf.h], [\n    AC_CHECK_LIB(elf, gelf_getvernaux, [\n    AC_DEFINE(HAVE_LIBELF, 1, [Define to 1 if you have the 'elf' library (-lelf).])\n    WITH_LIBELF_LIB=\"-lelf\"\n    WITH_LIBELF=yes\n    ])\n  ])\n])\nAC_SUBST(WITH_LIBELF_LIB)\nAM_CONDITIONAL(LIBELF,[test \"$WITH_LIBELF\" = yes])\n\n#=================\n# Select crypto library\nAC_ARG_WITH(crypto,\n            [AC_HELP_STRING([--with-crypto=CRYPTO_LIB],\n                            [The cryptographic library to use (openssl|libgcrypt). The default is libgcrypt.])\n                            ],[],\n                            [with_crypto=libgcrypt])\n\n#=================\n# Check for OpenSSL library.\n# We need evp.h from OpenSSL.\n\nWITH_OPENSSL_INCLUDE=\nWITH_OPENSSL_LIB=\nif test \"$with_crypto\" = openssl; then\n# If we have pkgconfig make sure CPPFLAGS are setup correctly for the OpenSSL\n# -I include path.\nAC_PATH_TOOL([PKGCONFIG], [pkg-config], [no], [$PATH:/usr/bin:/usr/local/bin])\nif test \"x$PKGCONFIG\" != \"xno\"; then\n  CPPFLAGS=\"$CPPFLAGS $($PKGCONFIG --cflags libcrypto)\"\n  WITH_OPENSSL_LIB=$($PKGCONFIG --libs libcrypto)\nelse\n  WITH_OPENSSL_LIB=-lcrypto\nfi\n\nAC_CHECK_HEADERS([openssl/evp.h], [], [\n  AC_MSG_ERROR([missing required OpenSSL header])\n])\nAC_CHECK_HEADERS([openssl/rsa.h], [], [\n  AC_MSG_ERROR([missing required OpenSSL header])\n])\nAC_CHECK_HEADERS([openssl/dsa.h], [], [\n  AC_MSG_ERROR([missing required OpenSSL header])\n])\n\nAC_CHECK_LIB(crypto, EVP_DigestInit_ex, [], [\n  AC_MSG_ERROR([required OpenSSL library 'libcrypto' missing or too old])\n])\n\nAC_CHECK_LIB(crypto, EVP_MD_CTX_new, [\n    AC_DEFINE(HAVE_EVP_MD_CTX_NEW, 1, [Define to 1 if OpenSSL has EVP_MD_CTX_new])\n    AC_SUBST(HAVE_EVP_MD_CTX_NEW, [1])\n  ], [\n  AC_CHECK_LIB(crypto, EVP_MD_CTX_create, [], [\n      AC_MSG_ERROR([required OpenSSL library 'libcrypto' missing or too old])\n  ])\n])\n\nAC_CHECK_LIB(crypto, EVP_PKEY_CTX_new, [], [\n  AC_MSG_ERROR([required OpenSSL library 'libcrypto' missing or too old])\n])\n\nAC_CHECK_LIB(crypto, DSA_set0_key, [\n    AC_DEFINE(HAVE_DSA_SET0_KEY, 1, [Define to 1 if OpenSSL has DSA_set0_key])\n    AC_SUBST(HAVE_DSA_SET0_KEY, [1])\n    ], []\n)\n\nAC_CHECK_LIB(crypto, DSA_set0_pqg, [\n    AC_DEFINE(HAVE_DSA_SET0_PQG, 1, [Define to 1 if OpenSSL has DSA_set0_pqg])\n    AC_SUBST(HAVE_DSA_SET0_PQG, [1])\n    ], []\n)\n\nAC_CHECK_LIB(crypto, DSA_SIG_set0, [\n    AC_DEFINE(HAVE_DSA_SIG_SET0, 1, [Define to 1 if OpenSSL has DSA_SIG_set0])\n    AC_SUBST(HAVE_DSA_SIG_SET0, [1])\n    ], []\n)\n\nAC_CHECK_LIB(crypto, RSA_set0_key, [\n    AC_DEFINE(HAVE_RSA_SET0_KEY, 1, [Define to 1 if OpenSSL has RSA_set0_key])\n    AC_SUBST(HAVE_RSA_SET0_KEY, [1])\n    ], []\n)\n\nAC_CHECK_LIB(crypto, BN_bn2binpad, [\n    AC_DEFINE(HAVE_BN2BINPAD, 1, [Define to 1 if OpenSSL has BN_bn2binpad])\n    AC_SUBST(HAVE_BN2BINPAD, [1])\n    ], []\n)\n\nfi\n\nAM_CONDITIONAL([WITH_OPENSSL],[test \"$with_crypto\" = openssl])\nAC_SUBST(WITH_OPENSSL_INCLUDE)\nAC_SUBST(WITH_OPENSSL_LIB)\n\n#=================\n# Check for libgcrypt library.\nWITH_LIBGCRYPT_INCLUDE=\nWITH_LIBGCRYPT_LIB=\nif test \"$with_crypto\" = libgcrypt ; then\n  # libgcrypt 1.8.5 onwards ships a pkg-config file so prefer that\n  PKG_CHECK_MODULES([LIBGCRYPT], [libgcrypt], [have_libgcrypt=yes], [have_libgcrypt=no])\n  if test \"$have_libgcrypt\" = \"yes\"; then\n    WITH_LIBGCRYPT_INCLUDE=\"$LIBGCRYPT_CFLAGS\"\n    WITH_LIBGCRYPT_LIB=\"$LIBGCRYPT_LIBS\"\n  else\n    AC_PATH_TOOL(LIBGCRYPT_CONFIG, libgcrypt-config, notfound)\n      if test notfound != \"$LIBGCRYPT_CONFIG\" ; then\n        WITH_LIBGCRYPT_INCLUDE=`$LIBGCRYPT_CONFIG --cflags`\n        WITH_LIBGCRYPT_LIB=`$LIBGCRYPT_CONFIG --libs`\n     fi\n     if test -z \"$WITH_LIBGCRYPT_LIB\" ; then\n       AC_MSG_ERROR([libgcrypt not found])\n    fi\n  fi\nfi\n\nAM_CONDITIONAL([WITH_LIBGCRYPT],[test \"$with_crypto\" = libgcrypt])\nAC_SUBST(WITH_LIBGCRYPT_INCLUDE)\nAC_SUBST(WITH_LIBGCRYPT_LIB)\n\n#=================\n# Check for magic library.\nWITH_MAGIC_INCLUDE=\nWITH_MAGIC_LIB=\n\nAC_CHECK_HEADER([magic.h], [\n    AC_CHECK_LIB(magic, magic_open, [\n      WITH_MAGIC_INCLUDE=\n      WITH_MAGIC_LIB=\"-lmagic\"\n    ],[\n      AC_MSG_ERROR([missing required library 'libmagic']) \n    ])\n],[\n      AC_MSG_ERROR([missing required header magic.h]) \n])\n\nAC_SUBST(WITH_MAGIC_INCLUDE)\nAC_SUBST(WITH_MAGIC_LIB)\n\n#=================\n# Check for popt library.\nWITH_POPT_INCLUDE=\nWITH_POPT_LIB=\n\nAC_CHECK_HEADER([popt.h], [\n  AC_CHECK_LIB(popt, poptGetContext, [\n      WITH_POPT_INCLUDE=\n      WITH_POPT_LIB=\"-lpopt\"\n  ],[\n    AC_MSG_ERROR([missing required library popt])\n  ])\n],[\n  AC_MSG_ERROR([missing required header popt.h])\n])\n\nAC_SUBST(WITH_POPT_INCLUDE)\nAC_SUBST(WITH_POPT_LIB)\n\n#=================\n# Check for libarchive library.\nAC_ARG_WITH([archive], [AS_HELP_STRING([--with-archive], [build rpm2archive - requires libarchive])],\n            [],\n            [with_archive=yes])\n\nWITH_ARCHIVE_INCLUDE=\nWITH_ARCHIVE_LIB=\nAS_IF([test \"$with_archive\" != no],[\n  AC_CHECK_HEADER([archive.h], [\n    AC_CHECK_LIB(archive, archive_write_open_filename, [\n      WITH_ARCHIVE_INCLUDE=\n      WITH_ARCHIVE_LIB=\"-larchive\"\n    ],[\n      AC_MSG_ERROR([missing required library 'libarchive'])\n    ])\n],[\n      AC_MSG_ERROR([missing required header archive.h])\n  ])\n])\n\nAC_SUBST(WITH_ARCHIVE_INCLUDE)\nAC_SUBST(WITH_ARCHIVE_LIB)\nAM_CONDITIONAL(WITH_ARCHIVE,[test \"$with_archive\" = yes])\n\n#=================\n# Check for elfutils libdw library with dwelf_elf_gnu_build_id.\nAS_IF([test \"x$enable_libelf\" != \"xno\"], [\n  WITH_LIBDW_LIB=\n  AS_IF([test \"$WITH_LIBELF\" = yes],[\n    AC_CHECK_HEADERS([elfutils/libdwelf.h],[\n      # dwelf_elf_gnu_build_id was introduced in elfutils 0.159\n      AC_CHECK_LIB(dw, dwelf_elf_gnu_build_id, [\n        AC_DEFINE(HAVE_LIBDW, 1,\n                  [Define to 1 if you have elfutils libdw library])\n        WITH_LIBDW_LIB=\"-ldw\"\n        WITH_LIBDW=yes\n        # whether libdw supports compressed ELF objects\n        AC_CHECK_LIB(dw, dwelf_elf_begin, [\n                     AC_DEFINE(HAVE_DWELF_ELF_BEGIN, 1, [Have dwelf_elf_begin?])\n        ])\n      ])\n    ])\n  ])\n])\nAC_SUBST(WITH_LIBDW_LIB)\nAM_CONDITIONAL(LIBDW,[test \"$WITH_LIBDW\" = yes])\n\n#=================\n# Process --enable-ndb\nAC_ARG_ENABLE([ndb], [AS_HELP_STRING([--enable-ndb],[enable the new rpm database format])],\n[case \"$enable_ndb\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --enable-ndb])\n  ;;\nesac],\n[enable_ndb=no])\nAS_IF([test \"$enable_ndb\" = yes],[\n  AC_DEFINE(ENABLE_NDB, 1, [Enable new rpm database format?])\n  AC_CHECK_FUNCS(mremap, [], [], [#include <sys/mman.h>])\n])\nAM_CONDITIONAL([NDB], [test \"$enable_ndb\" = yes])\n\n#=================\n# Process --enable-bdb-ro\nAC_ARG_ENABLE([bdb-ro], [AS_HELP_STRING([--enable-bdb-ro (EXPERIMENTAL)],[enable the read-only Berkeley DB code])],\n[case \"$enable_bdb_ro\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --enable-bdb-ro])\n  ;;\nesac],\n[enable_bdb_ro=no])\nAS_IF([test \"$enable_bdb_ro\" = yes],[\n  AC_DEFINE(WITH_BDB_RO, 1, [Build with read-only Berkeley DB])\n])\nAM_CONDITIONAL([BDB_RO], [test \"$enable_bdb_ro\" = yes])\n\n# Check for SQLITE support\nAC_ARG_ENABLE([sqlite],\n              [AS_HELP_STRING([--enable-sqlite=@<:@yes/no/auto@:>@)],\n                              [build with sqlite rpm database format support (default=yes)])],\n              [enable_sqlite=\"$enableval\"],\n              [enable_sqlite=yes])\n\nAS_IF([test \"x$enable_sqlite\" != \"xno\"], [\n  PKG_CHECK_MODULES([SQLITE], [sqlite3 >= 3.22.0], [have_sqlite=yes], [have_sqlite=no])\n  AS_IF([test \"$enable_sqlite\" = \"yes\"], [\n    if test \"$have_sqlite\" = \"no\"; then\n      AC_MSG_ERROR([--enable-sqlite specified, but not available])\n    fi\n  ])\n])\n\nif test \"x$have_sqlite\" = \"xyes\"; then\n  AC_DEFINE([WITH_SQLITE], [1], [Define if SQLITE is available])\n  SQLITE_REQUIRES=sqlite\n  AC_SUBST(SQLITE_REQUIRES)\nfi\nAM_CONDITIONAL([SQLITE], [test \"x$have_sqlite\" = \"xyes\"])\n\nAM_GNU_GETTEXT_VERSION([0.18.2])\nAM_GNU_GETTEXT([external])\nAM_ICONV\n\ndnl Checks for header files we can live without.\nAC_HEADER_STDC\ndnl glibc and autoconf don't really play well together.\ndnl glibc will produce a warning when including the wrong header.\ndnl but still define major and minor. Causing us to include the header\ndnl that produces a giant warning for each major/minor use.\ndnl Use -Werror to work around that.\nold_CFLAGS=$CFLAGS\nCFLAGS=\"$CFLAGS -Werror\"\nAC_HEADER_MAJOR\nCFLAGS=$old_CFLAGS\nAC_STRUCT_DIRENT_D_TYPE\n\nAC_CHECK_HEADERS(limits.h)\nAC_CHECK_HEADERS(getopt.h)\n\nAC_CHECK_HEADERS(sys/utsname.h)\n\nAC_CHECK_HEADERS(sys/systemcfg.h)\nAC_CHECK_HEADERS(sys/param.h)\nAC_CHECK_HEADERS(sys/auxv.h)\n\ndnl look for libc features\n\ndnl Check for missing typedefs\nAC_TYPE_MODE_T\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\n\ndnl Checks for library functions.\nAC_CHECK_FUNCS(putenv)\nAC_CHECK_FUNCS(mempcpy)\nAC_CHECK_FUNCS(fdatasync)\nAC_CHECK_DECLS(fdatasync, [], [], [#include <unistd.h>])\nAC_CHECK_FUNCS(lutimes)\nAC_CHECK_FUNCS(mergesort)\nAC_CHECK_FUNCS(getauxval)\nAC_CHECK_FUNCS(setprogname, [], [], [#include <stdlib.h>])\nAC_CHECK_FUNCS(syncfs)\nAC_CHECK_FUNCS(sched_getaffinity, [], [], [#include <sched.h>])\nAC_CHECK_FUNCS(unshare, [], [], [#include <sched.h>])\n\nAC_MSG_CHECKING([whether __progname is defined])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([extern const char *__progname;],\n\t   [if (*__progname == 0) return 0;])],\n\t   AC_DEFINE([HAVE___PROGNAME], [1], [Define if __progname is defined])\n\t   AC_MSG_RESULT([yes]),\n\t   AC_MSG_RESULT([no]))\n\nAC_REPLACE_FUNCS(stpcpy stpncpy)\n\nAC_CHECK_FUNCS([secure_getenv __secure_getenv])\n\nAC_CHECK_FUNCS(\n   [mkstemp getcwd basename dirname realpath setenv unsetenv regcomp lchown \\\n    utimes getline localtime_r statvfs getaddrinfo ],\n   [], [AC_MSG_ERROR([function required by rpm])])\n\nAC_LIBOBJ(fnmatch)\n\ndnl check if python is requested\nAC_ARG_ENABLE(python, [AS_HELP_STRING([--enable-python],[build rpm python bindings])],\n[case \"$enable_python\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --enable-python])\n  ;;\nesac],\n[enable_python=no])\n\nWITH_PYTHON_SUBPACKAGE=0\nAS_IF([test \"$enable_python\" = yes],[\n  PYTHON=\"${PYTHON:-python3}\"\n  AM_PATH_PYTHON([3.1],[\n    PKG_CHECK_MODULES([PYTHON], [python-${PYTHON_VERSION}], [WITH_PYTHON_SUBPACKAGE=1])\n    AC_SUBST(PYTHON_CFLAGS)\n    AC_SUBST(PYTHON_LIB)\n  ])\n])\n\nAM_CONDITIONAL(ENABLE_PYTHON,[test \"$WITH_PYTHON_SUBPACKAGE\" = 1])\n\nAC_PATH_PROG(DOXYGEN, doxygen, no)\nAC_CHECK_PROG(HAVE_DOT,[dot],[YES],[NO])\nAC_PATH_PROG(PANDOC, pandoc, no)\n\nWITH_SELINUX_LIB=\nAC_ARG_WITH(selinux, [AS_HELP_STRING([--with-selinux],[build with selinux support])],\n[case \"$with_selinux\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --with-selinux])\n  ;;\nesac],\n[with_selinux=no])\n\nAS_IF([test \"$with_selinux\" = yes],[\n  AC_CHECK_HEADER([selinux/selinux.h],[\n    save_LIBS=\"$LIBS\"\n    AC_CHECK_LIB([selinux],[is_selinux_enabled],[],[\n      AC_MSG_ERROR([--with-selinux given, but is_selinux_enabled not found in libselinux])])\n    AC_CHECK_LIB([selinux],[selinux_getpolicytype],[],[\n      AC_MSG_ERROR([--with-selinux given, but selinux_getpolicytype not found in libselinux])])\n    AC_CHECK_LIB([selinux],[selinux_reset_config],[],[\n      AC_MSG_ERROR([--with-selinux given, but selinux_reset_config not found in libselinux])])\n    AC_CHECK_LIB([selinux],[setexecfilecon],[\n      AC_DEFINE([HAVE_SETEXECFILECON],[1],[Define to 1 if SELinux setexecfilecon is present])])\n    LIBS=\"$save_LIBS\"\n  ],[\n    AC_MSG_ERROR([--with-selinux given, but selinux/selinux.h not found])\n  ])\n\n  AC_CHECK_HEADER([selinux/label.h],[\n    save_LIBS=\"$LIBS\"\n    AC_CHECK_LIB([selinux],[selabel_close],[],[\n      AC_MSG_ERROR([--with-selinux given, but selabel_close not found in libselinux])])\n    AC_CHECK_LIB([selinux],[selabel_lookup_raw],[],[\n      AC_MSG_ERROR([--with-selinux given, but selabel_lookup_raw not found in libselinux])])\n    AC_CHECK_LIB([selinux],[selabel_open],[],[\n      AC_MSG_ERROR([--with-selinux given, but selabel_open not found in libselinux])])\n    LIBS=\"$save_LIBS\"\n  ],[\n    AC_MSG_ERROR([--with-selinux given, but selinux/label.h not found])\n  ])\n])\n\nAS_IF([test \"$with_selinux\" = yes],[\n  AC_DEFINE(WITH_SELINUX, 1, [Build with selinux support?])\n  WITH_SELINUX_LIB=\"-lselinux\"\n])\nAC_SUBST(WITH_SELINUX_LIB)\nAC_SUBST(WITH_SEMANAGE_LIB)\nAM_CONDITIONAL(SELINUX,[test \"$with_selinux\" = yes])\n\n# libimaevm\nwith_iamevm=no\nAC_ARG_WITH(imaevm, [AS_HELP_STRING([--with-imaevm],[build with imaevm support])])\nif test \"$with_imaevm\" = yes ; then\n  AC_MSG_CHECKING([libimaevm >= 1.0])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM(\n      [[#include <imaevm.h>]],\n      [[return sign_hash(NULL, NULL, 0, NULL, NULL, NULL);]]\n    )],\n    [AC_MSG_RESULT(yes)\n     AC_DEFINE(WITH_IMAEVM, 1, [Build with imaevm support?])\n     WITH_IMAEVM_LIB=\"-limaevm\"\n    ],\n    [AC_MSG_ERROR([libimaevm not present or too old (< 1.0)])]\n  )\nfi\nAM_CONDITIONAL(WITH_IMAEVM,[test \"$with_imaevm\" = yes])\nAC_SUBST(WITH_IMAEVM_LIB)\n\n# fsverity\nAC_ARG_WITH([fsverity], [AS_HELP_STRING([--with-fsverity],[build with fsverity support])],[],[with_fsverity=no])\nif test \"$with_fsverity\" = yes ; then\n  AC_MSG_CHECKING([libfsverity])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM(\n      [[#include <libfsverity.h>]],\n      [[return libfsverity_sign_digest(NULL, NULL, NULL, NULL);]]\n    )],\n    [AC_MSG_RESULT(yes)\n      AC_DEFINE(WITH_FSVERITY, 1, [Build with fsverity support?])\n      WITH_FSVERITY_LIB=\"-lfsverity\"\n    ],\n    [AC_MSG_ERROR([--with-fsverity given, libfsverity or libfsverity.h missing])]\n  )\nfi\nAM_CONDITIONAL(WITH_FSVERITY,[test \"$with_fsverity\" = yes])\nAC_SUBST(WITH_FSVERITY_LIB)\n\n# libcap\nWITH_CAP_LIB=\nAC_ARG_WITH(cap, [AS_HELP_STRING([--with-cap],[build with capability support])],\n[case \"$with_cap\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --with-cap])\n  ;;\nesac],\n[with_cap=no])\n\nAS_IF([test \"$with_cap\" = yes],[\n  AC_CHECK_HEADER([sys/capability.h],[\n    AC_CHECK_LIB(cap,[cap_get_file], [\n      with_cap=yes\n      save_LIBS=\"$LIBS\"\n      AC_CHECK_LIB(cap,[cap_compare], [\n        AC_DEFINE(HAVE_CAP_COMPARE, 1, [Have cap_compare function?])\n      ])\n      LIBS=\"$save_LIBS\"\n    ],[\n      AC_MSG_ERROR([--with-cap given, but libcap not found])])\n  ],[\n    AC_MSG_ERROR([--with-cap given, but sys/capability.h not found])\n  ])\n])\n\nAS_IF([test \"$with_cap\" = yes],[\n  AC_DEFINE(WITH_CAP, 1, [Build with capability support?])\n  WITH_CAP_LIB=\"-lcap\"\n])\nAC_SUBST(WITH_CAP_LIB)\nAM_CONDITIONAL(CAP,[test \"$with_cap\" = yes])\n\nWITH_ACL_LIB=\nAC_ARG_WITH(acl, [AS_HELP_STRING([--with-acl],[build with acl support])],\n[case \"$with_acl\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --with-acl])\n  ;;\nesac],\n[with_acl=no])\n\nAS_IF([test \"$with_acl\" = yes],[\n  dnl verification uses non-portable acl_equiv_mode() \n  AC_CHECK_HEADER([acl/libacl.h],[\n    AC_CHECK_LIB(acl,[acl_equiv_mode],[with_acl=yes],[\n      AC_MSG_ERROR([--with-acl given, but libacl not found or not suitable])])\n  ],[\n    AC_MSG_ERROR([--with-acl given, but acl/libacl.h not found])\n  ])\n])\n\nAS_IF([test \"$with_acl\" = yes],[\n  AC_DEFINE(WITH_ACL, 1, [Build with acl support?])\n  WITH_ACL_LIB=\"-lacl\"\n])\nAC_SUBST(WITH_ACL_LIB)\nAM_CONDITIONAL(ACL,[test \"$with_acl\" = yes])\n\nPKG_CHECK_MODULES([LUA],\n    [lua >= 5.2],\n    [],\n    [AC_MSG_ERROR([lua not present or too old)])])\nAC_SUBST(LUA_CFLAGS)\nAC_SUBST(LUA_LIBS)\n\nAC_ARG_WITH([readline],[AS_HELP_STRING([--with-readline=@<:@yes/no/auto@:>@], [build with readline support])], [with_readline=\"$withval\"], [with_readline=\"auto\"])\nAS_IF([test \"$with_readline\" != \"no\"],[\n  PKG_CHECK_MODULES([READLINE], [readline], [have_readline=yes], [have_readline=no])\n  AS_IF([test \"$with_readline\" = \"yes\"],[\n    if test \"$have_readline\" = \"no\"; then\n      AC_MSG_ERROR([readline support requested but not present])\n    fi\n  ])\n])\nif test \"$have_readline\" = \"yes\"; then\n  AC_DEFINE([HAVE_READLINE], [1], [Define if readline is available])\n  AC_SUBST(READLINE_CFLAGS)\n  AC_SUBST(READLINE_LIBS)\nfi\nAM_CONDITIONAL(WITH_READLINE, [test \"$have_readline\" = yes])\n\n\nAC_ARG_ENABLE(plugins, [AS_HELP_STRING([--disable-plugins],[build without plugin support])],,[enable_plugins=yes])\nAS_IF([test \"$enable_plugins\" = yes],[\n  AC_DEFINE(ENABLE_PLUGINS, 1, [Build with plugin support?])\n])\nAM_CONDITIONAL(ENABLE_PLUGINS,[test \"$enable_plugins\" = yes])\n\nAC_ARG_ENABLE(inhibit_plugin, [AS_HELP_STRING([--disable-inhibit-plugin],[build without systemd inhibit plugin])],,[enable_inhibit_plugin=yes])\nAS_IF([test \"$enable_inhibit_plugin\" = yes],[\n  AC_DEFINE(ENABLE_INHIBIT_PLUGIN, 1, [Build with systemd inhibit plugin?])\n])\nAM_CONDITIONAL(ENABLE_INHIBIT_PLUGIN,[test \"$enable_inhibit_plugin\" = yes])\n\nwith_dbus=no\nAS_IF([test \"$enable_plugins\" != no],[\n AS_IF([test \"$enable_inhibit_plugin\" != no],[\n  PKG_CHECK_MODULES([DBUS],\n    [dbus-1 >= 1.3],\n    [AC_DEFINE(DBUS, 1, [Build with dbus support?]) with_dbus=yes],\n    [with_dbus=no])\n  AC_SUBST(DBUS_CFLAGS)\n  AC_SUBST(DBUS_LIBS)\n ])\n])\nAM_CONDITIONAL(DBUS, [test \"$with_dbus\" = yes])\n\nAS_IF([test \"$enable_plugins\" != no],[\n  AC_CHECK_FUNCS(lsetxattr, [], [], [#include <sys/xattr.h>])\n])\nAM_CONDITIONAL(IMA, [test \"x$ac_cv_func_lsetxattr\" = xyes])\n\nAS_IF([test \"$enable_plugins\" != no],[\nAC_CHECK_HEADERS([linux/fsverity.h],[FSVERITY_IOCTL=\"yes\"])\n])\nAM_CONDITIONAL(FSVERITY_IOCTL,[test \"x$FSVERITY_IOCTL\" = xyes])\n\n#=================\n# Check for fapolicyd support\nAC_ARG_WITH(fapolicyd,\nAS_HELP_STRING([--with-fapolicyd],[build with File Access Policy Daemon support]),\nwith_fapolicyd=$withval,\nwith_fapolicyd=auto)\nAM_CONDITIONAL(FAPOLICYD,[test \"$with_fapolicyd\" = yes])\n\n#=================\n# Check for audit library.\nAC_ARG_WITH(audit,\nAS_HELP_STRING([--with-audit],[Linux audit plugin]),\nwith_audit=$withval,\nwith_audit=auto)\n\nWITH_AUDIT_LIB=\nAS_IF([test \"$enable_plugins\" != no],[\n  AS_IF([test \"x$with_audit\" != xno],[\n    AC_SEARCH_LIBS([audit_open],[audit],[\n      WITH_AUDIT_LIB=\"$ac_res\"\n      AC_DEFINE(WITH_AUDIT, 1, [libaudit support])\n      with_audit=yes\n    ],[\n      if test \"x$with_audit\" != xauto; then\n        AC_MSG_ERROR([missing audit library])\n      fi\n    ])\n  ])\n])\nAC_SUBST(WITH_AUDIT_LIB)\nAM_CONDITIONAL(AUDIT,[test \"$with_audit\" = yes])\n\nuser_with_uid0=$(awk -F: '$3==0 {print $1;exit}' /etc/passwd)\ngroup_with_gid0=$(awk -F: '$3==0 {print $1;exit}' /etc/group)\nif test -z \"$user_with_uid0\" ; then user_with_uid0=root ; fi\nif test -z \"$group_with_gid0\" ; then group_with_gid0=root ; fi\nAC_DEFINE_UNQUOTED([UID_0_USER],[\"$user_with_uid0\"],[Get the user name having userid 0])\nAC_DEFINE_UNQUOTED([GID_0_GROUP],[\"$group_with_gid0\"],[Get the group name having groupid 0])\n\n#\n# get rid of the 4-th tuple, if config.guess returned \"linux-gnu\" for host_os\n#\nhost_os_gnu=-gnu\nif echo \"$host_os\" | grep '.*-gnulibc1$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnulibc1$//'`\nfi\nif echo \"$host_os\" | grep '.*-gnueabihf$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnueabihf$//'`\n\thost_os_gnu=-gnueabihf\nfi\nif echo \"$host_os\" | grep '.*-gnueabi$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnueabi$//'`\n\thost_os_gnu=-gnueabi\nfi\nif echo \"$host_os\" | grep '.*-gnuabi64$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnuabi64$//'`\n\thost_os_gnu=-gnuabi64\nfi\nif echo \"$host_os\" | grep '.*-gnu$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnu$//'`\nfi\nif echo \"$host_os\" | grep '.*-gnu[[^-]]*$' > /dev/null ; then\n\tAC_MSG_ERROR([unrecognized GNU build triplet $host_os])\nfi\n\nchangequote(<, >)\nhost_os_exact=\"${host_os}\"\nhost_os_major=`echo \"${host_os}\" | sed 's/\\..*$//'`\nhost_os_noversion=`echo \"${host_os}\" | sed 's/[0-9]*\\..*$//'`\nchangequote([, ])\n\ndnl permit overriding build_vendor for \"canonical rpm vendor\"\nRPMCANONVENDOR=\"$build_vendor\"\nAC_ARG_WITH([vendor], \n  AS_HELP_STRING([--with-vendor=VENDOR], [specify rpm vendor name]),\n  [RPMCANONVENDOR=$withval])\nAC_DEFINE_UNQUOTED([RPMCANONVENDOR],[\"${RPMCANONVENDOR}\"],[canonical vendor])\n\t   \nRPMCANONOS=\"$host_os_noversion\"\nRPMCANONGNU=\"$host_os_gnu\"\nAC_SUBST(RPMCANONVENDOR)\nAC_SUBST(RPMCANONOS)\nAC_SUBST(RPMCANONGNU)\n\nRUNDIR=\"/run\"\nAC_ARG_WITH([rundir], \n  AS_HELP_STRING([--with-rundir=RUNDIR], [specify run-time variable directory]),\n  [RUNDIR=$withval])\nAC_DEFINE_UNQUOTED([RUNDIR],[\"${RUNDIR}\"],[run-time variable directory])\nAC_SUBST(RUNDIR)\n\nif test X\"$prefix\" = XNONE ; then\n    usrprefix=\"$ac_default_prefix\"\nelse\n    usrprefix=$prefix\nfi\n\nRPMCONFIGDIR=\"`echo ${usrprefix}/lib/rpm`\"\nAC_SUBST(RPMCONFIGDIR)\n\nAC_SUBST(OBJDUMP)\n\nAM_CONDITIONAL([DOXYGEN],[test \"$DOXYGEN\" != no])\nAM_CONDITIONAL([PANDOC],[test \"$PANDOC\" != no])\n\nAC_PATH_PROG(AUTOM4TE,autom4te,:)\n\nAC_SUBST([dirstamp],[\\${am__leading_dot}dirstamp])\n\nAC_CONFIG_FILES([Makefile\n\trpmio/Makefile lib/Makefile build/Makefile sign/Makefile\n\tpo/Makefile.in scripts/Makefile fileattrs/Makefile\n\tmisc/Makefile \n\tdocs/Makefile\n\tdocs/man/Makefile\n\tpython/Makefile\n \tluaext/Makefile\n \ttests/Makefile\n \tplugins/Makefile\n\tpython/setup.py\n  ])\nAC_OUTPUT\n", "/** \\ingroup payload\n * \\file lib/fsm.c\n * File state machine to handle a payload from a package.\n */\n\n#include \"system.h\"\n\n#include <inttypes.h>\n#include <utime.h>\n#include <errno.h>\n#if WITH_CAP\n#include <sys/capability.h>\n#endif\n\n#include <rpm/rpmte.h>\n#include <rpm/rpmts.h>\n#include <rpm/rpmlog.h>\n#include <rpm/rpmmacro.h>\n\n#include \"rpmio/rpmio_internal.h\"\t/* fdInit/FiniDigest */\n#include \"lib/fsm.h\"\n#include \"lib/rpmte_internal.h\"\t/* XXX rpmfs */\n#include \"lib/rpmplugins.h\"\t/* rpm plugins hooks */\n#include \"lib/rpmug.h\"\n\n#include \"debug.h\"\n\n#define\t_FSM_DEBUG\t0\nint _fsm_debug = _FSM_DEBUG;\n\n/* XXX Failure to remove is not (yet) cause for failure. */\nstatic int strict_erasures = 0;\n\n#define\tSUFFIX_RPMORIG\t\".rpmorig\"\n#define\tSUFFIX_RPMSAVE\t\".rpmsave\"\n#define\tSUFFIX_RPMNEW\t\".rpmnew\"\n\n/* Default directory and file permissions if not mapped */\n#define _dirPerms 0755\n#define _filePerms 0644\n\nenum filestage_e {\n    FILE_COMMIT = -1,\n    FILE_NONE   = 0,\n    FILE_PRE    = 1,\n    FILE_UNPACK = 2,\n    FILE_PREP   = 3,\n    FILE_POST   = 4,\n};\n\nstruct filedata_s {\n    int stage;\n    int setmeta;\n    int skip;\n    rpmFileAction action;\n    const char *suffix;\n    char *fpath;\n    struct stat sb;\n};\n\n/* \n * XXX Forward declarations for previously exported functions to avoid moving \n * things around needlessly \n */ \nstatic const char * fileActionString(rpmFileAction a);\n\n/** \\ingroup payload\n * Build path to file from file info, optionally ornamented with suffix.\n * @param fi\t\tfile info iterator\n * @param suffix\tsuffix to use (NULL disables)\n * @param[out]\t\tpath to file (malloced)\n */\nstatic char * fsmFsPath(rpmfi fi, const char * suffix)\n{\n    return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : \"\", NULL);\n}\n\n/** \\ingroup payload\n * Directory name iterator.\n */\ntypedef struct dnli_s {\n    rpmfiles fi;\n    char * active;\n    int reverse;\n    int isave;\n    int i;\n} * DNLI_t;\n\n/** \\ingroup payload\n * Destroy directory name iterator.\n * @param dnli\t\tdirectory name iterator\n * @param[out]\t\tNULL always\n */\nstatic DNLI_t dnlFreeIterator(DNLI_t dnli)\n{\n    if (dnli) {\n\tif (dnli->active) free(dnli->active);\n\tfree(dnli);\n    }\n    return NULL;\n}\n\n/** \\ingroup payload\n * Create directory name iterator.\n * @param fi\t\tfile info set\n * @param fs\t\tfile state set\n * @param reverse\ttraverse directory names in reverse order?\n * @return\t\tdirectory name iterator\n */\nstatic DNLI_t dnlInitIterator(rpmfiles fi, rpmfs fs, int reverse)\n{\n    DNLI_t dnli;\n    int i, j;\n    int dc;\n\n    if (fi == NULL)\n\treturn NULL;\n    dc = rpmfilesDC(fi);\n    dnli = xcalloc(1, sizeof(*dnli));\n    dnli->fi = fi;\n    dnli->reverse = reverse;\n    dnli->i = (reverse ? dc : 0);\n\n    if (dc) {\n\tdnli->active = xcalloc(dc, sizeof(*dnli->active));\n\tint fc = rpmfilesFC(fi);\n\n\t/* Identify parent directories not skipped. */\n\tfor (i = 0; i < fc; i++)\n            if (!XFA_SKIPPING(rpmfsGetAction(fs, i)))\n\t\tdnli->active[rpmfilesDI(fi, i)] = 1;\n\n\t/* Exclude parent directories that are explicitly included. */\n\tfor (i = 0; i < fc; i++) {\n\t    int dil;\n\t    size_t dnlen, bnlen;\n\n\t    if (!S_ISDIR(rpmfilesFMode(fi, i)))\n\t\tcontinue;\n\n\t    dil = rpmfilesDI(fi, i);\n\t    dnlen = strlen(rpmfilesDN(fi, dil));\n\t    bnlen = strlen(rpmfilesBN(fi, i));\n\n\t    for (j = 0; j < dc; j++) {\n\t\tconst char * dnl;\n\t\tsize_t jlen;\n\n\t\tif (!dnli->active[j] || j == dil)\n\t\t    continue;\n\t\tdnl = rpmfilesDN(fi, j);\n\t\tjlen = strlen(dnl);\n\t\tif (jlen != (dnlen+bnlen+1))\n\t\t    continue;\n\t\tif (!rstreqn(dnl, rpmfilesDN(fi, dil), dnlen))\n\t\t    continue;\n\t\tif (!rstreqn(dnl+dnlen, rpmfilesBN(fi, i), bnlen))\n\t\t    continue;\n\t\tif (dnl[dnlen+bnlen] != '/' || dnl[dnlen+bnlen+1] != '\\0')\n\t\t    continue;\n\t\t/* This directory is included in the package. */\n\t\tdnli->active[j] = 0;\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Print only once per package. */\n\tif (!reverse) {\n\t    j = 0;\n\t    for (i = 0; i < dc; i++) {\n\t\tif (!dnli->active[i]) continue;\n\t\tif (j == 0) {\n\t\t    j = 1;\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\"========== Directories not explicitly included in package:\\n\");\n\t\t}\n\t\trpmlog(RPMLOG_DEBUG, \"%10d %s\\n\", i, rpmfilesDN(fi, i));\n\t    }\n\t    if (j)\n\t\trpmlog(RPMLOG_DEBUG, \"==========\\n\");\n\t}\n    }\n    return dnli;\n}\n\n/** \\ingroup payload\n * Return next directory name (from file info).\n * @param dnli\t\tdirectory name iterator\n * @return\t\tnext directory name\n */\nstatic\nconst char * dnlNextIterator(DNLI_t dnli)\n{\n    const char * dn = NULL;\n\n    if (dnli) {\n\trpmfiles fi = dnli->fi;\n\tint dc = rpmfilesDC(fi);\n\tint i = -1;\n\n\tif (dnli->active)\n\tdo {\n\t    i = (!dnli->reverse ? dnli->i++ : --dnli->i);\n\t} while (i >= 0 && i < dc && !dnli->active[i]);\n\n\tif (i >= 0 && i < dc)\n\t    dn = rpmfilesDN(fi, i);\n\telse\n\t    i = -1;\n\tdnli->isave = i;\n    }\n    return dn;\n}\n\nstatic int fsmLink(const char *opath, const char *path)\n{\n    int rc = link(opath, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_LINK_FAILED;\n    return rc;\n}\n\nstatic int fsmSetFCaps(const char *path, const char *captxt)\n{\n    int rc = 0;\n#if WITH_CAP\n    if (captxt && *captxt != '\\0') {\n\tcap_t fcaps = cap_from_text(captxt);\n\tif (fcaps == NULL || cap_set_file(path, fcaps) != 0) {\n\t    rc = RPMERR_SETCAP_FAILED;\n\t}\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t\t   path, captxt, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\tcap_free(fcaps);\n    } \n#endif\n    return rc;\n}\n\nstatic int fsmClose(FD_t *wfdp)\n{\n    int rc = 0;\n    if (wfdp && *wfdp) {\n\tint myerrno = errno;\n\tstatic int oneshot = 0;\n\tstatic int flush_io = 0;\n\tint fdno = Fileno(*wfdp);\n\n\tif (!oneshot) {\n\t    flush_io = (rpmExpandNumeric(\"%{?_flush_io}\") > 0);\n\t    oneshot = 1;\n\t}\n\tif (flush_io) {\n\t    fsync(fdno);\n\t}\n\tif (Fclose(*wfdp))\n\t    rc = RPMERR_CLOSE_FAILED;\n\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s ([%d]) %s\\n\", __func__,\n\t\t   fdno, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\t*wfdp = NULL;\n\terrno = myerrno;\n    }\n    return rc;\n}\n\nstatic int fsmOpen(FD_t *wfdp, const char *dest)\n{\n    int rc = 0;\n    /* Create the file with 0200 permissions (write by owner). */\n    {\n\tmode_t old_umask = umask(0577);\n\t*wfdp = Fopen(dest, \"wx.ufdio\");\n\tumask(old_umask);\n    }\n\n    if (Ferror(*wfdp))\n\trc = RPMERR_OPEN_FAILED;\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s [%d]) %s\\n\", __func__,\n\t       dest, Fileno(*wfdp), (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc)\n\tfsmClose(wfdp);\n\n    return rc;\n}\n\nstatic int fsmUnpack(rpmfi fi, FD_t fd, rpmpsm psm, int nodigest)\n{\n    int rc = rpmfiArchiveReadToFilePsm(fi, fd, nodigest, psm);\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s %\" PRIu64 \" bytes [%d]) %s\\n\", __func__,\n\t       rpmfiFN(fi), rpmfiFSize(fi), Fileno(fd),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    return rc;\n}\n\nstatic int fsmMkfile(rpmfi fi, struct filedata_s *fp, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest,\n\t\t     struct filedata_s ** firstlink, FD_t *firstlinkfile)\n{\n    int rc = 0;\n    FD_t fd = NULL;\n\n    if (*firstlink == NULL) {\n\t/* First encounter, open file for writing */\n\trc = fsmOpen(&fd, fp->fpath);\n\t/* If it's a part of a hardlinked set, the content may come later */\n\tif (fp->sb.st_nlink > 1) {\n\t    *firstlink = fp;\n\t    *firstlinkfile = fd;\n\t}\n    } else {\n\t/* Create hard links for others and avoid redundant metadata setting */\n\tif (*firstlink != fp) {\n\t    rc = fsmLink((*firstlink)->fpath, fp->fpath);\n\t    fp->setmeta = 0;\n\t}\n\tfd = *firstlinkfile;\n    }\n\n    /* If the file has content, unpack it */\n    if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = fsmUnpack(fi, fd, psm, nodigest);\n\t/* Last file of hardlink set, ensure metadata gets set */\n\tif (*firstlink) {\n\t    (*firstlink)->setmeta = 1;\n\t    *firstlink = NULL;\n\t    *firstlinkfile = NULL;\n\t}\n    }\n\n    if (fd != *firstlinkfile)\n\tfsmClose(&fd);\n\n    return rc;\n}\n\nstatic int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}\n\nstatic int fsmStat(const char *path, int dolstat, struct stat *sb)\n{\n    int rc;\n    if (dolstat){\n\trc = lstat(path, sb);\n    } else {\n        rc = stat(path, sb);\n    }\n    if (_fsm_debug && rc && errno != ENOENT)\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, ost) %s\\n\",\n               __func__,\n               path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0) {\n        rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_LSTAT_FAILED);\n\t/* Ensure consistent struct content on failure */\n        memset(sb, 0, sizeof(*sb));\n    }\n    return rc;\n}\n\nstatic int fsmRmdir(const char *path)\n{\n    int rc = rmdir(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}\n\nstatic int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}\n\nstatic int fsmMkfifo(const char *path, mode_t mode)\n{\n    int rc = mkfifo(path, (mode & 07777));\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\",\n\t       __func__, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKFIFO_FAILED;\n\n    return rc;\n}\n\nstatic int fsmMknod(const char *path, mode_t mode, dev_t dev)\n{\n    /* FIX: check S_IFIFO or dev != 0 */\n    int rc = mknod(path, (mode & ~07777), dev);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%o, 0x%x) %s\\n\",\n\t       __func__, path, (unsigned)(mode & ~07777),\n\t       (unsigned)dev, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKNOD_FAILED;\n\n    return rc;\n}\n\n/**\n * Create (if necessary) directories not explicitly included in package.\n * @param files\t\tfile data\n * @param fs\t\tfile states\n * @param plugins\trpm plugins handle\n * @return\t\t0 on success\n */\nstatic int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tif (dnlen <= 1)\n\t    continue;\n\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume '/' directory exists, \"mkdir -p\" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\n\t    /* Already validated? */\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\n\t    /* Validate next component of path. */\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); /* lstat */\n\t    *te = '/';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n\n    return rc;\n}\n\nstatic void removeSBITS(const char *path)\n{\n    struct stat stb;\n    if (lstat(path, &stb) == 0 && S_ISREG(stb.st_mode)) {\n\tif ((stb.st_mode & 06000) != 0) {\n\t    (void) chmod(path, stb.st_mode & 0777);\n\t}\n#if WITH_CAP\n\tif (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\t    (void) cap_set_file(path, NULL);\n\t}\n#endif\n    }\n}\n\nstatic void fsmDebug(const char *fpath, rpmFileAction action,\n\t\t     const struct stat *st)\n{\n    rpmlog(RPMLOG_DEBUG, \"%-10s %06o%3d (%4d,%4d)%6d %s\\n\",\n\t   fileActionString(action), (int)st->st_mode,\n\t   (int)st->st_nlink, (int)st->st_uid,\n\t   (int)st->st_gid, (int)st->st_size,\n\t    (fpath ? fpath : \"\"));\n}\n\nstatic int fsmSymlink(const char *opath, const char *path)\n{\n    int rc = symlink(opath, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_SYMLINK_FAILED;\n    return rc;\n}\n\nstatic int fsmUnlink(const char *path)\n{\n    int rc = 0;\n    removeSBITS(path);\n    rc = unlink(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_UNLINK_FAILED);\n    return rc;\n}\n\nstatic int fsmRename(const char *opath, const char *path)\n{\n    removeSBITS(path);\n    int rc = rename(opath, path);\n#if defined(ETXTBSY) && defined(__HPUX__)\n    /* XXX HP-UX (and other os'es) don't permit rename to busy files. */\n    if (rc && errno == ETXTBSY) {\n\tchar *rmpath = NULL;\n\trstrscat(&rmpath, path, \"-RPMDELETE\", NULL);\n\trc = rename(path, rmpath);\n\tif (!rc) rc = rename(opath, path);\n\tfree(rmpath);\n    }\n#endif\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == EISDIR ? RPMERR_EXIST_AS_DIR : RPMERR_RENAME_FAILED);\n    return rc;\n}\n\nstatic int fsmRemove(const char *path, mode_t mode)\n{\n    return S_ISDIR(mode) ? fsmRmdir(path) : fsmUnlink(path);\n}\n\nstatic int fsmChown(const char *path, mode_t mode, uid_t uid, gid_t gid)\n{\n    int rc = S_ISLNK(mode) ? lchown(path, uid, gid) : chown(path, uid, gid);\n    if (rc < 0) {\n\tstruct stat st;\n\tif (lstat(path, &st) == 0 && st.st_uid == uid && st.st_gid == gid)\n\t    rc = 0;\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %d, %d) %s\\n\", __func__,\n\t       path, (int)uid, (int)gid,\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHOWN_FAILED;\n    return rc;\n}\n\nstatic int fsmChmod(const char *path, mode_t mode)\n{\n    int rc = chmod(path, (mode & 07777));\n    if (rc < 0) {\n\tstruct stat st;\n\tif (lstat(path, &st) == 0 && (st.st_mode & 07777) == (mode & 07777))\n\t    rc = 0;\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHMOD_FAILED;\n    return rc;\n}\n\nstatic int fsmUtime(const char *path, mode_t mode, time_t mtime)\n{\n    int rc = 0;\n    struct timeval stamps[2] = {\n\t{ .tv_sec = mtime, .tv_usec = 0 },\n\t{ .tv_sec = mtime, .tv_usec = 0 },\n    };\n\n#if HAVE_LUTIMES\n    rc = lutimes(path, stamps);\n#else\n    if (!S_ISLNK(mode))\n\trc = utimes(path, stamps);\n#endif\n    \n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0x%x) %s\\n\", __func__,\n\t       path, (unsigned)mtime, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_UTIME_FAILED;\n    /* ...but utime error is not critical for directories */\n    if (rc && S_ISDIR(mode))\n\trc = 0;\n    return rc;\n}\n\nstatic int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == dsb.st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}\n\n#define\tIS_DEV_LOG(_x)\t\\\n\t((_x) != NULL && strlen(_x) >= (sizeof(\"/dev/log\")-1) && \\\n\trstreqn((_x), \"/dev/log\", sizeof(\"/dev/log\")-1) && \\\n\t((_x)[sizeof(\"/dev/log\")-1] == '\\0' || \\\n\t (_x)[sizeof(\"/dev/log\")-1] == ';'))\n\n\n\n/* Rename pre-existing modified or unmanaged file. */\nstatic int fsmBackup(rpmfi fi, rpmFileAction action)\n{\n    int rc = 0;\n    const char *suffix = NULL;\n\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(opath, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}\n\nstatic int fsmSetmeta(const char *path, rpmfi fi, rpmPlugins plugins,\n\t\t      rpmFileAction action, const struct stat * st,\n\t\t      int nofcaps)\n{\n    int rc = 0;\n    const char *dest = rpmfiFN(fi);\n\n    if (!rc && !getuid()) {\n\trc = fsmChown(path, st->st_mode, st->st_uid, st->st_gid);\n    }\n    if (!rc && !S_ISLNK(st->st_mode)) {\n\trc = fsmChmod(path, st->st_mode);\n    }\n    /* Set file capabilities (if enabled) */\n    if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {\n\trc = fsmSetFCaps(path, rpmfiFCaps(fi));\n    }\n    if (!rc) {\n\trc = fsmUtime(path, st->st_mode, rpmfiFMtime(fi));\n    }\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, fi,\n\t\t\t\t\t  path, dest, st->st_mode, action);\n    }\n\n    return rc;\n}\n\nstatic int fsmCommit(char **path, rpmfi fi, rpmFileAction action, const char *suffix)\n{\n    int rc = 0;\n\n    /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\t/* Construct final destination path (nsuffix is usually NULL) */\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\n\t/* Rename temporary to final file name if needed. */\n\tif (dest != *path) {\n\t    rc = fsmRename(*path, dest);\n\t    if (!rc) {\n\t\tif (nsuffix) {\n\t\t    char * opath = fsmFsPath(fi, NULL);\n\t\t    rpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t\t   opath, dest);\n\t\t    free(opath);\n\t\t}\n\t\tfree(*path);\n\t\t*path = dest;\n\t    }\n\t}\n    }\n\n    return rc;\n}\n\n/**\n * Return formatted string representation of file disposition.\n * @param a\t\tfile disposition\n * @return\t\tformatted string\n */\nstatic const char * fileActionString(rpmFileAction a)\n{\n    switch (a) {\n    case FA_UNKNOWN:\treturn \"unknown\";\n    case FA_CREATE:\treturn \"create\";\n    case FA_BACKUP:\treturn \"backup\";\n    case FA_SAVE:\treturn \"save\";\n    case FA_SKIP:\treturn \"skip\";\n    case FA_ALTNAME:\treturn \"altname\";\n    case FA_ERASE:\treturn \"erase\";\n    case FA_SKIPNSTATE: return \"skipnstate\";\n    case FA_SKIPNETSHARED: return \"skipnetshared\";\n    case FA_SKIPCOLOR:\treturn \"skipcolor\";\n    case FA_TOUCH:     return \"touch\";\n    default:\t\treturn \"???\";\n    }\n}\n\n/* Remember any non-regular file state for recording in the rpmdb */\nstatic void setFileState(rpmfs fs, int i)\n{\n    switch (rpmfsGetAction(fs, i)) {\n    case FA_SKIPNSTATE:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NOTINSTALLED);\n\tbreak;\n    case FA_SKIPNETSHARED:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NETSHARED);\n\tbreak;\n    case FA_SKIPCOLOR:\n\trpmfsSetState(fs, i, RPMFILE_STATE_WRONGCOLOR);\n\tbreak;\n    case FA_TOUCH:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NORMAL);\n\tbreak;\n    default:\n\tbreak;\n    }\n}\n\nint rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    FD_t firstlinkfile = NULL;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tfp->setmeta = 1;\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    if (rpmteType(te) == TR_ADDED)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Detect and create directories not explicitly in package. */\n    if (!rc)\n\trc = fsmMkdirs(files, fs, plugins);\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n        if (!fp->skip) {\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix) {\n\t\trc = fsmBackup(fi, fp->action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tcontinue;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t} else if (firstlink && rpmfiArchiveHasContent(fi)) {\n\t    /*\n\t     * Tricksy case: this file is a being skipped, but it's part of\n\t     * a hardlinked set and has the actual content linked with it.\n\t     * Write the content to the first non-skipped file of the set\n\t     * instead.\n\t     */\n\t    rc = fsmMkfile(fi, firstlink, files, psm, nodigest,\n\t\t\t   &firstlink, &firstlinkfile);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = rpmfiFree(fi);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* Set permissions, timestamps etc for non-hardlink entries */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (!fp->skip && fp->setmeta) {\n\t    rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,\n\t\t\t    &fp->sb, nofcaps);\n\t}\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\tfp->stage = FILE_PREP;\n    }\n    fi = rpmfiFree(fi);\n\n    /* If all went well, commit files to final destination */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(&fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\t}\n    }\n    fi = rpmfiFree(fi);\n\n    /* Walk backwards in case we need to erase */\n    fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    while ((fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\t/* Run fsm file post hook for all plugins for all processed files */\n\tif (fp->stage) {\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n\n\t/* On failure, erase non-committed files */\n\tif (rc && fp->stage > FILE_NONE && !fp->skip) {\n\t    (void) fsmRemove(fp->fpath, fp->sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}\n\n\nint rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    rpmfi fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int fc = rpmfilesFC(files);\n    int fx = -1;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    int rc = 0;\n\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tfp->action = rpmfsGetAction(fs, rpmfiFX(fi));\n\tfp->fpath = fsmFsPath(fi, NULL);\n\trc = fsmStat(fp->fpath, 1, &fp->sb);\n\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\n\tif (!XFA_SKIPPING(fp->action))\n\t    rc = fsmBackup(fi, fp->action);\n\n        /* Remove erased files. */\n        if (fp->action == FA_ERASE) {\n\t    int missingok = (rpmfiFFlags(fi) & (RPMFILE_MISSINGOK | RPMFILE_GHOST));\n\n\t    rc = fsmRemove(fp->fpath, fp->sb.st_mode);\n\n\t    /*\n\t     * Missing %ghost or %missingok entries are not errors.\n\t     * XXX: Are non-existent files ever an actual error here? Afterall\n\t     * that's exactly what we're trying to accomplish here,\n\t     * and complaining about job already done seems like kinderkarten\n\t     * level \"But it was MY turn!\" whining...\n\t     */\n\t    if (rc == RPMERR_ENOENT && missingok) {\n\t\trc = 0;\n\t    }\n\n\t    /*\n\t     * Dont whine on non-empty directories for now. We might be able\n\t     * to track at least some of the expected failures though,\n\t     * such as when we knowingly left config file backups etc behind.\n\t     */\n\t    if (rc == RPMERR_ENOTEMPTY) {\n\t\trc = 0;\n\t    }\n\n\t    if (rc) {\n\t\tint lvl = strict_erasures ? RPMLOG_ERR : RPMLOG_WARNING;\n\t\trpmlog(lvl, _(\"%s %s: remove failed: %s\\n\"),\n\t\t\tS_ISDIR(fp->sb.st_mode) ? _(\"directory\") : _(\"file\"),\n\t\t\tfp->fpath, strerror(errno));\n            }\n        }\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t  fp->sb.st_mode, fp->action, rc);\n\n        /* XXX Failure to remove is not (yet) cause for failure. */\n        if (!strict_erasures) rc = 0;\n\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\n\tif (rc == 0) {\n\t    /* Notify on success. */\n\t    /* On erase we're iterating backwards, fixup for progress */\n\t    rpm_loff_t amount = rpmfiFC(fi) - rpmfiFX(fi);\n\t    rpmpsmNotify(psm, RPMCALLBACK_UNINST_PROGRESS, amount);\n\t}\n    }\n\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n    rpmfiFree(fi);\n\n    return rc;\n}\n\n\n"], "fixing_code": ["To build RPM you will need several other packages:\n--------------------------------------------------\n\nThe popt library for option parsing, must be version 1.13 or later.\nIt is available from\n    http://ftp.rpm.org/popt/\n\nThe debugedit >= 0.3 tools for producing debuginfo sub-packages.\nIt is available from\n   https://sourceware.org/debugedit/\n\nLua >= 5.2 library + development environment.\nNote that only the library is needed at runtime, RPM never calls external\nLua interpreter for anything. Lua is available from\n    http://www.lua.org\n\nThe zlib library for compression support. You might also need/want\nthe unzip executable for java jar dependency analysis. All available from\n    http://www.gzip.org/zlib/\n\nThe libmagic (aka file) library for file type detection (used by rpmbuild). \nThe source for the file utility + library is available from\n    ftp://ftp.astron.com/pub/file/\n\nYou will need a cryptographic library to support digests and signatures.\nThis library may be libgcrypt or OpenSSL, and can be specified with the\n--with-crypto=[libgcrypt|openssl] argument to configure.\nlibgcrypt is the default.\n\nlibgcrypt library is available from https://www.gnupg.org/software/libgcrypt/\n\nIf using the OpenSSL library for encryption, it must be version 1.0.2 or\nlater. Note: when compiling against OpenSSL, there is a possible license\nincompatibility. For more details on this, see\nhttps://people.gnome.org/~markmc/openssl-and-the-gpl.html\nSome Linux distributions have different legal interpretations of this\npossible incompatibility. It is recommended to consult with a lawyer before\nbuilding RPM against OpenSSL.\nFedora: https://fedoraproject.org/wiki/Licensing:FAQ#What.27s_the_deal_with_the_OpenSSL_license.3F\nDebian: https://lists.debian.org/debian-legal/2002/10/msg00113.html\n\nThe OpenSSL crypto library is available from https://www.openssl.org/\n\nRPM needs a database engine for normal operation. The main options are\n\"ndb\" (--enable-ndb) and \"sqlite\" (--enable-sqlite).\nAdditionally standalone support for read-only BDB databases is available as\n\"bdb_ro\" (--enable-bdb-ro) to aid with migration from BDB.\n\nThe ndb and bdb_ro backends have no external dependencies.\nSQLite >= 3.22.0 is required for the sqlite database backend.\nSQLite is available from https://www.sqlite.org/\n\nIf SELinux support is desired, it can be enabled with --with-selinux option\nto configure and libselinux development environment installed. SELinux\nis available from\n    http://www.nsa.gov/selinux/\n\nIt may be desired to install bzip2, gzip, and xz/lzma so that RPM can use these\nformats.  Gzip is necessary to build packages that contain compressed\ntar balls, these are quite common on the Internet.\nThese are available from\n    http://www.gzip.org\n    http://www.bzip.org\n    http://tukaani.org/xz/\n\nIf you want to build the Python bindings to RPM library, it can be enabled\nwith --enable-python option to configure. You'll need to have Python >= 3.1\nruntime and C API development environment installed.\nPython is available from:\n    http://www.python.org/\n\nTo enable POSIX.1e draft 15 file capabilities support, configure with\n--with-cap. You'll also need recent libcap, available from:\n    http://ftp.kernel.org/pub/linux/libs/security/linux-privs/libcap2/\n\nTo enable POSIX 1003.1e draft 17 ACL verification support, configure with\n--with-acl. You'll also need the ACL library, available from:\n    ftp://oss.sgi.com/projects/xfs/cmd_tars/\n\nFor best results you should compile with GCC and GNU Make.  Users have\nreported difficulty with other build tools (any patches to lift these\ndependencies are welcome). Both GCC and GNU Make available from \n    http://www.gnu.org/\n\nIf National Language Support (NLS) is desired you will need gnu\ngettext (currently this is required to build rpm but we hope to \nlift this requirement soon), available from \n    http://www.gnu.org/\n\nIf you are going to hack the sources (or compile from source repository)\nyou will need most of the GNU development tools including:\nautoconf, automake, gettext, libtool, makeinfo, perl, GNU m4, GNU tar\navailable from \n    http://www.gnu.org/\n\nIf you plan on using cryptographic signatures you will need a version\nof GPG, available from\n    http://www.gnupg.org/\n\nOpenMP multithreading support is automatically enabled if your C compiler has\nsupport for OpenMP version 4.5 or higher (to disable, pass the --disable-openmp\noption to configure).  For GCC, OpenMP 4.5 is fully supported since GCC 6.1,\nwhich is available from\n    http://www.gnu.org/\n\nRpm requires a POSIX.1-2008 level operating system.\n\nTo compile RPM:\n--------------\n\nRPM uses a small shell script to run: libtool, autoconf,\nautomake. This step should not be necessary if you are running a\nreleased version of rpm, however if you have gotten the rpm sources\ndirectly from the source code repository, you need to generate\nintermediate files by running the autogen.sh script.\n\nThe autogen.sh script checks that the required tools are installed.\nThe autogen.sh script also runs configure for you and passes the command line\narguments to configure.  To run it without configure type:\n\n    ./autogen.sh --noconfigure\n\nIf your libraries are not in a standard place you will need to change\nconfigures environment.  These options can be passed directly to\nconfigure or to autogen.sh which will pass them through to configure.\n\nHere is an example:\n    LIBS='-L/opt/libz/ -L/opt/BerkeleyDB/lib/' \\\n    CPPFLAGS='-I/opt/libz/ -I/opt/BerkeleyDB/include' \\\n    ./configure\n\nIf you have build tools stored in non standard places you should check\nthe resulting Makefile to be sure that the tools you wish to use have\nbeen correctly identified.  The configure script will modify your path\nbefore looking for the build tools and it may find versions of these\ntools that you do not want.  It uses the following search path\n\n    MYPATH=\"/bin:/usr/bin:/usr/local/bin:$PATH:/opt/gnu/bin\"\n\nnow build the system with:\n\n    make\n\nand then install with:\n\n    make install\n\nRpm comes with an automated self-test suite. The test-suite relies heavily\non fakechroot (https://github.com/dex4er/fakechroot/) and cannot be executed\nwithout it. Provided that fakechroot was found during configure,\nit can be executed after a successful build with:\n\n    make check\n\nFinally, if you wish to prepare an rpm source tar ball, you should do\n\n    make dist\n\nTo package RPM:\n--------------\n\nAfter RPM has been installed you can run rpm to build an rpm package.\nEdit the rpm.spec file to mirror any special steps you needed to\nfollow to make rpm compile and change the specfile to match your\ntaste.  You will need to put the rpm source tar file into the\nSOURCES directory and we suggest putting the specfile in the\nSPECS directory, then run rpmbuild -ba rpm.spec.  You will end up\nwith two rpms which can be found in RPMS and SRPMS.\n\nIf you are going to install rpm on machines with OS package managers\nother then rpm, you may choose to install the base rpm package via a\ncpio instead of a tar file.  Instead of running \"make tar\" during the\nbuild process, as described above, use the base rpm packages to create\na cpio.  After the rpms have been created run rpm2cpio on the base rpm\npackage, this will give you a cpio package which can then use to\ninstall rpm on a new system.\n\n    rpm2cpio rpm-4.0-1.solaris2.6-sparc.rpm > rpm-4.0-1.solaris2.6-sparc.cpio\n\n\nNon Linux Configuration Issues:\n------------------------------\n\n\nOS dependencies:\n----------------\n\nUnder RPM based Linux distributions all libraries (in fact all files \ndistributed with the OS) are under RPM control and this section is not \nan issue.\n\nRPM will need to be informed of all the dependencies which were\nsatisfied before RPM was installed.  Typically this only refers to\nlibraries that are installed by the OS, but may include other\nlibraries and packages which are available at the time RPM is\ninstalled and will not under RPM control.  Another common example of\nlibraries which may need dependency provisions are precompiled\nlibraries which are installed by the OS package manager during system\nbuild time.  The list of dependencies you will wish to load into RPM\nwill depend on exactly how you bootstrap RPM onto your system and what\nparts of the system you put into packages as well as on the specific OS\nyou are using.\n\nThe script vpkg-provides.sh can be used to generate a package which\nwill satisfy the dependencies on your system.  To run it you will need\nto create a specfile header for this empty package and run the progam\nwith:\n\n    --spec_header '/path/to/os-base-header.spec\n\nand if you wish to ensure that some directories are not traversed you\ncan use the option: \n\n    --ignore_dirs 'grep-E|pattern|of|paths|to|ignore\n\nBy default the generated rpm will include a %verifyscript to verify\nchecksum of all files traversed has not changed.  This additional\ncheck can be suppressed with:\n\n    --no_verify\n\nThe result of running the script will be a specfile which will create\na package continging all the dependencies found on the system.  There\nwill be one provides line for each depednecy. The package will contain\nnone of the actual OS library files as it is assumed they are already\non your system and managed by other means.  Here is a example\n(truncated) of the provides lines used by one user of Digital Unix. (I\nhave put several provides on the same line for brevity)\n\nprovides: /bin/sh /usr/bin/ksh /usr/bin/csh \nprovides: libc.so.osf.1 libm.so.osf.1 libcurses.so.xpg4 libdb.so.osf.1\nprovides: libX11.so libXaw.so.6.0 libXext.so libXm.so.motif1.2 libXmu.so\nprovides: libdnet_stub.so.osf.1 libsecurity.so.osf.1 libpthread.so.osf.1\nprovides: libexc.so.osf.1 libmach.so.osf.1 libdps.so libdpstk.so \n\n\nThe script vpkg-provides2.sh is underdevelopment as a more advanced\nversion of vpkg-provides.sh which is aware of many different unix\nvendor packaging schemes.  It will create one \"dependency package\" for\neach unix package your OS vendor installed.\n\n\nrpmfilename:\n-----------\n\nIf you plan on packaging for more then one OS you may want to edit\n/etc/macros or /usr/lib/rpm/macros and change the line which has\nrpmfilename to something which include both the %{_target_os} and\n%{_target_cpu}.  This will cause the name of the generated rpm files\nto the operating system name as well as the architecture which the rpm\nruns under.  The line to change looks like:\n\n%_rpmfilename           %%{ARCH}/%%{NAME}-%%{VERSION}-%%{RELEASE}.%%{ARCH}.rpm\n\nyou may wish to include both the %{_target_os} and %{_target_cpu} in\nthe final base name, so that it's easier to distinguish between what\npackage is appropriate for a particular arch-os-version combo.  We\nsuggest:\n\n%_rpmfilename           %%{_target_platform/%%{NAME}-%%{VERSION}-%%{RELEASE}.%%{_target_platform}.rpm\n\nThere is no %{_target_os_version} tag, so if you need to also\ndistinguish between RPMs for certain versions of the OS, you can\nhard-code the version in the rpmrc on the build machine, so that .rpm\nfiles are generated with the version as part of the filename.\n\nFor example when one user builds RPMs for Digital Unix 4.0b and 4.0d,\noptimization is important and he will build one set of RPMs for the\nEV4 processor and another set for the EV56 processor.  He specifies\nboth the OS version (if it's important, as it is for a few packages)\nand the processor version by default by setting a special rpmfilename:\non the particular build machine.\n\nThe \"rpmfilename: \"tag on one machine (Digital Unix 4.0d, EV56 PWS 433)\nlooks like:\n\nrpmfilename: %{_target_os}/4.0d/%{_target_cpu}/%{name}-%{version}-%{release}.%{_target_os}-%{_target_cpu}ev56.rpm\n\nFor package `foo-1.1', at build time that would translate into:\n\n    osf1/4.0d/alpha/foo-1.1-1.osf1-alphaev56.rpm\n\nThe hyphen between the %{_target_cpu} and ev56 is left out for compatibility\nwith GNU Config.guess and because `alphaev56' looks more \"normal\" to\npeople with an alpha than alpha-ev56 for someone on an Intel Pentium\nPro would want `i586pro' over `i586-pro', but it does make parsing\nthis filename by other programs a bit more difficult.\n\n\nGPG\n---\n\nTo use the signing features of rpm, you will need to configure certain\nrpm macros in ~/.rpmmacros:\n\n\t%_gpg_name      <GPG UID>\n\t%_gpg_path      %(echo $HOME)/.gnupg\n\n", "AC_PREREQ(2.61)\nAC_INIT(rpm, 4.17.90, rpm-maint@lists.rpm.org)\n\nAC_CONFIG_SRCDIR([rpm.c])\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([m4])\nAC_CONFIG_AUX_DIR([build-aux])\n\nAM_INIT_AUTOMAKE([1.10 foreign tar-pax dist-bzip2 subdir-objects nostdinc])\ndnl Allow silent build on automake versions that support it\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES])\n\nAC_CONFIG_TESTDIR(tests)\n\nAC_USE_SYSTEM_EXTENSIONS\n\nAC_DISABLE_STATIC\n\nPKG_PROG_PKG_CONFIG\n\ndnl Checks for programs.\nAC_PROG_CXX\nAC_PROG_AWK\nAC_PROG_CC\nAC_PROG_CPP\nAC_PROG_INSTALL\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\nAC_PROG_LIBTOOL\n\nAC_SUBST(__CC, $CC)\nAC_PROG_CC_C99\nif test \"$ac_cv_prog_cc_c99\" = no; then\n    AC_MSG_ERROR([ISO C99 capable compiler required])\nfi\n\nAS=${AS-as}\nAC_SUBST(AS)\nif test \"$GCC\" = yes; then\n    cflags_to_try=\"-fno-strict-aliasing -fno-strict-overflow -fno-delete-null-pointer-checks -Wempty-body\"\n    AC_MSG_CHECKING([supported compiler flags])\n    old_cflags=$CFLAGS\n    echo\n    for flag in $cflags_to_try; do\n        CFLAGS=\"$CFLAGS $flag -Werror\"\n        AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[#include <alloca.h>\n\t\t\t\t\t\talloca(100);]])],[\n                echo \"   $flag\"\n                RPMCFLAGS=\"$RPMCFLAGS $flag\"\n        ],[])\n        CFLAGS=$old_cflags\n    done\n    RPMCFLAGS=\"-Wall -Wpointer-arith -Wmissing-prototypes -Wstrict-prototypes $RPMCFLAGS\"\nfi\nAC_ARG_ENABLE(werror, [AS_HELP_STRING([--enable-werror], [build with -Werror])],\n\t\t[RPMCFLAGS=\"$RPMCFLAGS -Werror\"], [])\nAC_SUBST(RPMCFLAGS)\n\nAC_SYS_LARGEFILE\n\ndnl AM_DISABLE_SHARED\nAM_PROG_LIBTOOL\n\nAC_CHECK_TOOL(AR, ar, :)\n\ndnl\ndnl use defaults if cross-compiling, otherwise use the default path.\ndnl\nif test \"$cross_compiling\" = \"yes\"; then\n    MYPATH=\":\"\nelse\n    MYPATH=$PATH\nfi\n\ndnl\ndnl Find some common programs\ndnl\nAC_PATH_PROGS(__7ZIP, [7zip 7za 7z], /usr/bin/7za, $MYPATH)\nAC_PATH_PROG(__BZIP2, bzip2, /usr/bin/bzip2, $MYPATH)\nAC_PATH_PROG(__CAT, cat, /bin/cat, $MYPATH)\nAC_PATH_PROG(__CHMOD, chmod, /bin/chmod, $MYPATH)\nAC_PATH_PROG(__CHOWN, chown, /bin/chown, $MYPATH)\nAC_PATH_PROG(__CP, cp, /bin/cp, $MYPATH)\nAC_PATH_PROG(__CURL, curl, /usr/bin/curl, $MYPATH)\nAC_PATH_PROG(__FILE, file, /usr/bin/file, $MYPATH)\nAC_PATH_PROGS(__GPG, gpg2 gpg, /usr/bin/gpg2, $MYPATH)\nAC_PATH_PROG(__GREP, grep, /bin/grep, $MYPATH)\nAC_PATH_PROG(__GZIP, gzip, /bin/gzip, $MYPATH)\nAC_PATH_PROG(__UNZIP, unzip, /usr/bin/unzip, $MYPATH)\nAC_PATH_PROG(__ID, id, /usr/bin/id, $MYPATH)\nAC_PATH_PROG(__INSTALL, install, /usr/bin/install, $MYPATH)\nAC_PATH_PROG(__LRZIP, lrzip, /usr/bin/lrzip, $MYPATH)\nAC_PATH_PROG(__LZIP, lzip, /usr/bin/lzip, $MYPATH)\nAC_PATH_PROG(__XZ, xz, /usr/bin/xz, $MYPATH)\nAC_PATH_PROG(__GEM, gem, /usr/bin/gem, $MYPATH)\nAC_PATH_PROG(__MAKE, make, /usr/bin/make, $MYPATH)\nAC_PATH_PROG(__MKDIR, mkdir, /bin/mkdir, $MYPATH)\nAC_PATH_PROG(__MV, mv, /bin/mv, $MYPATH)\nAC_PATH_PROG(__PATCH, patch, /usr/bin/patch, $MYPATH)\nAC_PATH_PROG(__RM, rm, /bin/rm, $MYPATH)\nAC_PATH_PROG(__SED, sed, /bin/sed, $MYPATH)\nAC_PATH_PROG(__TAR, tar, /bin/tar, $MYPATH)\nAC_PATH_PROG(__ZSTD, zstd, /usr/bin/zstd, $MYPATH)\n\nAC_PATH_PROG(__LD, ld, /usr/bin/ld, $MYPATH)\nAC_PATH_PROG(__OBJDUMP, objdump, /usr/bin/objdump, $MYPATH)\nAC_PATH_PROG(__STRIP, strip, /usr/bin/strip, $MYPATH)\nAC_PATH_PROG(__FIND_DEBUGINFO, find-debuginfo, /usr/bin/find-debuginfo, $MYPATH)\n\nAC_PATH_PROG(__GIT, git, /usr/bin/git, $MYPATH)\nAC_PATH_PROG(__HG, hg, /usr/bin/hg, $MYPATH)\nAC_PATH_PROG(__BZR, bzr, /usr/bin/bzr, $MYPATH)\nAC_PATH_PROG(__QUILT, quilt, /usr/bin/quilt, $MYPATH)\n\nAC_PATH_PROG(__FAKECHROOT, fakechroot, no, $MYPATH)\nAM_CONDITIONAL(HAVE_FAKECHROOT, [test \"$__FAKECHROOT\" != \"no\"])\n\ndnl see if we have a mkdir that supports `-p' for rpmbuild's purposes\nAC_PROG_MKDIR_P\nif ! echo $MKDIR_P | grep -q mkdir; then \n  __MKDIR_P=\"`echo ${prefix}/lib/rpm/mkinstalldirs`\"\nelse\n  __MKDIR_P=$MKDIR_P\nfi\nAC_DEFINE_UNQUOTED(__MKDIR_P, \"${__MKDIR_P}\",\n[A full path to a program, possibly with arguments, that will create a\n   directory and all necessary parent directories, ala 'mkdir -p'])\nAC_SUBST(__MKDIR_P)\n\n#=================\n# Check for zlib library. \n\nWITH_ZLIB_INCLUDE=\nWITH_ZLIB_LIB=\n\nAC_CHECK_HEADERS([zlib.h],[\n  AS_IF([test -z \"${WITH_ZLIB_LIB}\"],[\n    for zlib in z gz ; do\n      AC_CHECK_LIB(${zlib}, gzread, \n\t[WITH_ZLIB_LIB=\"-l${zlib}\"; break])\n    done\n\ndnl zlib-1.0.4 has not gzseek\n    AC_CHECK_LIB(${zlib}, gzseek, [AC_DEFINE(HAVE_GZSEEK, 1, [Define as 1 if your zlib has gzseek()])])\n  ])\n],[\n  AC_MSG_ERROR([missing required header zlib.h])\n])\n\nAC_SUBST(WITH_ZLIB_INCLUDE)\nAC_SUBST(WITH_ZLIB_LIB)\n\n#=================\n# Check for bzip2 library.\n\nAC_CHECK_HEADERS([bzlib.h],[\n  AC_CHECK_LIB(bz2, BZ2_bzread, [WITH_BZ2_LIB=-lbz2])\n])\nAC_SUBST(WITH_BZ2_LIB)\n\n#=================\n# Check for lzma library.\n\nAC_CHECK_HEADERS([lzma.h],[\n  AC_CHECK_LIB(lzma, lzma_easy_encoder, [WITH_LZMA_LIB=-llzma])\n])\nAC_SUBST(WITH_LZMA_LIB)\n\n# AC_OPENMP supports --enable/disable-openmp out of the box, but it doesn't\n# actually give us a way to conditionalize the build based on that. Argh.\n# Version 4.5 (201511) introduced \"priority\" clause for tasks.\nOPENMP_CFLAGS=\nAC_OPENMP\nAS_IF([test \"x$ac_cv_prog_c_openmp\" != x &&\n       test \"x$ac_cv_prog_c_openmp\" != xunsupported],[\n  old_CFLAGS=$CFLAGS\n  CFLAGS=\"$CFLAGS $OPENMP_CFLAGS\"\n  AC_MSG_CHECKING([OpenMP is at least version 4.5])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM(\n      [#include <omp.h>],\n      [#if _OPENMP < 201511\n       #error\n       #endif\n      ]\n    )],\n    [AC_MSG_RESULT([yes])\n     AC_DEFINE(ENABLE_OPENMP, 1, [Enable multithreading support?])\n    ],\n    [AC_MSG_RESULT([no])\n     OPENMP_CFLAGS=\n     if test \"$enable_openmp\" = \"yes\"; then\n       AC_MSG_ERROR([OpenMP too old])\n     fi\n    ]\n  )\n  CFLAGS=$old_CFLAGS\n])\nAC_SUBST(OPENMP_CFLAGS)\n\n#=================\n# Check for zstd.\n\nAC_ARG_ENABLE([zstd],\n              [AS_HELP_STRING([--enable-zstd=@<:@yes/no/auto@:>@],\n                              [build without zstd support (default=auto)])],\n              [enable_zstd=\"$enableval\"],\n              [enable_zstd=auto])\n\nAS_IF([test \"x$enable_zstd\" != \"xno\"], [\n  PKG_CHECK_MODULES([ZSTD], [libzstd >= 1.3.8], [have_zstd=yes], [have_zstd=no])\n  AS_IF([test \"$enable_zstd\" = \"yes\"], [\n    if test \"$have_zstd\" = \"no\"; then\n      AC_MSG_ERROR([--enable-zstd specified, but not available])\n    fi\n  ])\n])\n\nif test \"x$have_zstd\" = \"xyes\"; then\n  AC_DEFINE([HAVE_ZSTD], [1], [Define if libzstd is available])\n  ZSTD_REQUIRES=libzstd\n  AC_SUBST(ZSTD_REQUIRES)\nfi\nAM_CONDITIONAL([HAVE_ZSTD], [test \"x$have_zstd\" = \"xyes\"])\n\n#=================\n\ndnl\ndnl Check for features\ndnl\n\ndnl Checks for libraries.\n\nAC_CHECK_FUNC(gethostname, [], [\n    AC_CHECK_LIB(nsl, gethostname)\n])\n\nAC_CHECK_HEADERS(pthread.h)\n\nAC_CHECK_LIB(pthread, pthread_mutex_trylock, [], [\n  dnl OSF 5.0 has the the symbols prefixed with __ in libpthread.\n  AC_CHECK_LIB(pthread, __pthread_mutex_trylock, [], [\n    AC_CHECK_LIB(thread, mutex_lock)\n  ])\n])\n\nAC_SEARCH_LIBS(dlopen, [dl])\n\n#=================\n# Check for libelf library. Prefer external, otherwise none.\nAC_ARG_ENABLE([libelf],\n\t\t[AS_HELP_STRING([--enable-libelf=@<:@yes/no/auto@:>@],\n\t\t\t\t[build with libelf support (default=yes)])],\n\t\t[enable_libelf=\"$enableval\"],\n\t\t[enable_libelf=yes])\n\nAS_IF([test \"x$enable_libelf\" != \"xno\"], [\n  WITH_LIBELF_LIB=\n  AC_CHECK_HEADER([libelf.h])\n  AC_CHECK_HEADERS([gelf.h], [\n    AC_CHECK_LIB(elf, gelf_getvernaux, [\n    AC_DEFINE(HAVE_LIBELF, 1, [Define to 1 if you have the 'elf' library (-lelf).])\n    WITH_LIBELF_LIB=\"-lelf\"\n    WITH_LIBELF=yes\n    ])\n  ])\n])\nAC_SUBST(WITH_LIBELF_LIB)\nAM_CONDITIONAL(LIBELF,[test \"$WITH_LIBELF\" = yes])\n\n#=================\n# Select crypto library\nAC_ARG_WITH(crypto,\n            [AC_HELP_STRING([--with-crypto=CRYPTO_LIB],\n                            [The cryptographic library to use (openssl|libgcrypt). The default is libgcrypt.])\n                            ],[],\n                            [with_crypto=libgcrypt])\n\n#=================\n# Check for OpenSSL library.\n# We need evp.h from OpenSSL.\n\nWITH_OPENSSL_INCLUDE=\nWITH_OPENSSL_LIB=\nif test \"$with_crypto\" = openssl; then\n# If we have pkgconfig make sure CPPFLAGS are setup correctly for the OpenSSL\n# -I include path.\nAC_PATH_TOOL([PKGCONFIG], [pkg-config], [no], [$PATH:/usr/bin:/usr/local/bin])\nif test \"x$PKGCONFIG\" != \"xno\"; then\n  CPPFLAGS=\"$CPPFLAGS $($PKGCONFIG --cflags libcrypto)\"\n  WITH_OPENSSL_LIB=$($PKGCONFIG --libs libcrypto)\nelse\n  WITH_OPENSSL_LIB=-lcrypto\nfi\n\nAC_CHECK_HEADERS([openssl/evp.h], [], [\n  AC_MSG_ERROR([missing required OpenSSL header])\n])\nAC_CHECK_HEADERS([openssl/rsa.h], [], [\n  AC_MSG_ERROR([missing required OpenSSL header])\n])\nAC_CHECK_HEADERS([openssl/dsa.h], [], [\n  AC_MSG_ERROR([missing required OpenSSL header])\n])\n\nAC_CHECK_LIB(crypto, EVP_DigestInit_ex, [], [\n  AC_MSG_ERROR([required OpenSSL library 'libcrypto' missing or too old])\n])\n\nAC_CHECK_LIB(crypto, EVP_MD_CTX_new, [\n    AC_DEFINE(HAVE_EVP_MD_CTX_NEW, 1, [Define to 1 if OpenSSL has EVP_MD_CTX_new])\n    AC_SUBST(HAVE_EVP_MD_CTX_NEW, [1])\n  ], [\n  AC_CHECK_LIB(crypto, EVP_MD_CTX_create, [], [\n      AC_MSG_ERROR([required OpenSSL library 'libcrypto' missing or too old])\n  ])\n])\n\nAC_CHECK_LIB(crypto, EVP_PKEY_CTX_new, [], [\n  AC_MSG_ERROR([required OpenSSL library 'libcrypto' missing or too old])\n])\n\nAC_CHECK_LIB(crypto, DSA_set0_key, [\n    AC_DEFINE(HAVE_DSA_SET0_KEY, 1, [Define to 1 if OpenSSL has DSA_set0_key])\n    AC_SUBST(HAVE_DSA_SET0_KEY, [1])\n    ], []\n)\n\nAC_CHECK_LIB(crypto, DSA_set0_pqg, [\n    AC_DEFINE(HAVE_DSA_SET0_PQG, 1, [Define to 1 if OpenSSL has DSA_set0_pqg])\n    AC_SUBST(HAVE_DSA_SET0_PQG, [1])\n    ], []\n)\n\nAC_CHECK_LIB(crypto, DSA_SIG_set0, [\n    AC_DEFINE(HAVE_DSA_SIG_SET0, 1, [Define to 1 if OpenSSL has DSA_SIG_set0])\n    AC_SUBST(HAVE_DSA_SIG_SET0, [1])\n    ], []\n)\n\nAC_CHECK_LIB(crypto, RSA_set0_key, [\n    AC_DEFINE(HAVE_RSA_SET0_KEY, 1, [Define to 1 if OpenSSL has RSA_set0_key])\n    AC_SUBST(HAVE_RSA_SET0_KEY, [1])\n    ], []\n)\n\nAC_CHECK_LIB(crypto, BN_bn2binpad, [\n    AC_DEFINE(HAVE_BN2BINPAD, 1, [Define to 1 if OpenSSL has BN_bn2binpad])\n    AC_SUBST(HAVE_BN2BINPAD, [1])\n    ], []\n)\n\nfi\n\nAM_CONDITIONAL([WITH_OPENSSL],[test \"$with_crypto\" = openssl])\nAC_SUBST(WITH_OPENSSL_INCLUDE)\nAC_SUBST(WITH_OPENSSL_LIB)\n\n#=================\n# Check for libgcrypt library.\nWITH_LIBGCRYPT_INCLUDE=\nWITH_LIBGCRYPT_LIB=\nif test \"$with_crypto\" = libgcrypt ; then\n  # libgcrypt 1.8.5 onwards ships a pkg-config file so prefer that\n  PKG_CHECK_MODULES([LIBGCRYPT], [libgcrypt], [have_libgcrypt=yes], [have_libgcrypt=no])\n  if test \"$have_libgcrypt\" = \"yes\"; then\n    WITH_LIBGCRYPT_INCLUDE=\"$LIBGCRYPT_CFLAGS\"\n    WITH_LIBGCRYPT_LIB=\"$LIBGCRYPT_LIBS\"\n  else\n    AC_PATH_TOOL(LIBGCRYPT_CONFIG, libgcrypt-config, notfound)\n      if test notfound != \"$LIBGCRYPT_CONFIG\" ; then\n        WITH_LIBGCRYPT_INCLUDE=`$LIBGCRYPT_CONFIG --cflags`\n        WITH_LIBGCRYPT_LIB=`$LIBGCRYPT_CONFIG --libs`\n     fi\n     if test -z \"$WITH_LIBGCRYPT_LIB\" ; then\n       AC_MSG_ERROR([libgcrypt not found])\n    fi\n  fi\nfi\n\nAM_CONDITIONAL([WITH_LIBGCRYPT],[test \"$with_crypto\" = libgcrypt])\nAC_SUBST(WITH_LIBGCRYPT_INCLUDE)\nAC_SUBST(WITH_LIBGCRYPT_LIB)\n\n#=================\n# Check for magic library.\nWITH_MAGIC_INCLUDE=\nWITH_MAGIC_LIB=\n\nAC_CHECK_HEADER([magic.h], [\n    AC_CHECK_LIB(magic, magic_open, [\n      WITH_MAGIC_INCLUDE=\n      WITH_MAGIC_LIB=\"-lmagic\"\n    ],[\n      AC_MSG_ERROR([missing required library 'libmagic']) \n    ])\n],[\n      AC_MSG_ERROR([missing required header magic.h]) \n])\n\nAC_SUBST(WITH_MAGIC_INCLUDE)\nAC_SUBST(WITH_MAGIC_LIB)\n\n#=================\n# Check for popt library.\nWITH_POPT_INCLUDE=\nWITH_POPT_LIB=\n\nAC_CHECK_HEADER([popt.h], [\n  AC_CHECK_LIB(popt, poptGetContext, [\n      WITH_POPT_INCLUDE=\n      WITH_POPT_LIB=\"-lpopt\"\n  ],[\n    AC_MSG_ERROR([missing required library popt])\n  ])\n],[\n  AC_MSG_ERROR([missing required header popt.h])\n])\n\nAC_SUBST(WITH_POPT_INCLUDE)\nAC_SUBST(WITH_POPT_LIB)\n\n#=================\n# Check for libarchive library.\nAC_ARG_WITH([archive], [AS_HELP_STRING([--with-archive], [build rpm2archive - requires libarchive])],\n            [],\n            [with_archive=yes])\n\nWITH_ARCHIVE_INCLUDE=\nWITH_ARCHIVE_LIB=\nAS_IF([test \"$with_archive\" != no],[\n  AC_CHECK_HEADER([archive.h], [\n    AC_CHECK_LIB(archive, archive_write_open_filename, [\n      WITH_ARCHIVE_INCLUDE=\n      WITH_ARCHIVE_LIB=\"-larchive\"\n    ],[\n      AC_MSG_ERROR([missing required library 'libarchive'])\n    ])\n],[\n      AC_MSG_ERROR([missing required header archive.h])\n  ])\n])\n\nAC_SUBST(WITH_ARCHIVE_INCLUDE)\nAC_SUBST(WITH_ARCHIVE_LIB)\nAM_CONDITIONAL(WITH_ARCHIVE,[test \"$with_archive\" = yes])\n\n#=================\n# Check for elfutils libdw library with dwelf_elf_gnu_build_id.\nAS_IF([test \"x$enable_libelf\" != \"xno\"], [\n  WITH_LIBDW_LIB=\n  AS_IF([test \"$WITH_LIBELF\" = yes],[\n    AC_CHECK_HEADERS([elfutils/libdwelf.h],[\n      # dwelf_elf_gnu_build_id was introduced in elfutils 0.159\n      AC_CHECK_LIB(dw, dwelf_elf_gnu_build_id, [\n        AC_DEFINE(HAVE_LIBDW, 1,\n                  [Define to 1 if you have elfutils libdw library])\n        WITH_LIBDW_LIB=\"-ldw\"\n        WITH_LIBDW=yes\n        # whether libdw supports compressed ELF objects\n        AC_CHECK_LIB(dw, dwelf_elf_begin, [\n                     AC_DEFINE(HAVE_DWELF_ELF_BEGIN, 1, [Have dwelf_elf_begin?])\n        ])\n      ])\n    ])\n  ])\n])\nAC_SUBST(WITH_LIBDW_LIB)\nAM_CONDITIONAL(LIBDW,[test \"$WITH_LIBDW\" = yes])\n\n#=================\n# Process --enable-ndb\nAC_ARG_ENABLE([ndb], [AS_HELP_STRING([--enable-ndb],[enable the new rpm database format])],\n[case \"$enable_ndb\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --enable-ndb])\n  ;;\nesac],\n[enable_ndb=no])\nAS_IF([test \"$enable_ndb\" = yes],[\n  AC_DEFINE(ENABLE_NDB, 1, [Enable new rpm database format?])\n  AC_CHECK_FUNCS(mremap, [], [], [#include <sys/mman.h>])\n])\nAM_CONDITIONAL([NDB], [test \"$enable_ndb\" = yes])\n\n#=================\n# Process --enable-bdb-ro\nAC_ARG_ENABLE([bdb-ro], [AS_HELP_STRING([--enable-bdb-ro (EXPERIMENTAL)],[enable the read-only Berkeley DB code])],\n[case \"$enable_bdb_ro\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --enable-bdb-ro])\n  ;;\nesac],\n[enable_bdb_ro=no])\nAS_IF([test \"$enable_bdb_ro\" = yes],[\n  AC_DEFINE(WITH_BDB_RO, 1, [Build with read-only Berkeley DB])\n])\nAM_CONDITIONAL([BDB_RO], [test \"$enable_bdb_ro\" = yes])\n\n# Check for SQLITE support\nAC_ARG_ENABLE([sqlite],\n              [AS_HELP_STRING([--enable-sqlite=@<:@yes/no/auto@:>@)],\n                              [build with sqlite rpm database format support (default=yes)])],\n              [enable_sqlite=\"$enableval\"],\n              [enable_sqlite=yes])\n\nAS_IF([test \"x$enable_sqlite\" != \"xno\"], [\n  PKG_CHECK_MODULES([SQLITE], [sqlite3 >= 3.22.0], [have_sqlite=yes], [have_sqlite=no])\n  AS_IF([test \"$enable_sqlite\" = \"yes\"], [\n    if test \"$have_sqlite\" = \"no\"; then\n      AC_MSG_ERROR([--enable-sqlite specified, but not available])\n    fi\n  ])\n])\n\nif test \"x$have_sqlite\" = \"xyes\"; then\n  AC_DEFINE([WITH_SQLITE], [1], [Define if SQLITE is available])\n  SQLITE_REQUIRES=sqlite\n  AC_SUBST(SQLITE_REQUIRES)\nfi\nAM_CONDITIONAL([SQLITE], [test \"x$have_sqlite\" = \"xyes\"])\n\nAM_GNU_GETTEXT_VERSION([0.18.2])\nAM_GNU_GETTEXT([external])\nAM_ICONV\n\ndnl Checks for header files we can live without.\nAC_HEADER_STDC\ndnl glibc and autoconf don't really play well together.\ndnl glibc will produce a warning when including the wrong header.\ndnl but still define major and minor. Causing us to include the header\ndnl that produces a giant warning for each major/minor use.\ndnl Use -Werror to work around that.\nold_CFLAGS=$CFLAGS\nCFLAGS=\"$CFLAGS -Werror\"\nAC_HEADER_MAJOR\nCFLAGS=$old_CFLAGS\nAC_STRUCT_DIRENT_D_TYPE\n\nAC_CHECK_HEADERS(limits.h)\nAC_CHECK_HEADERS(getopt.h)\n\nAC_CHECK_HEADERS(sys/utsname.h)\n\nAC_CHECK_HEADERS(sys/systemcfg.h)\nAC_CHECK_HEADERS(sys/param.h)\nAC_CHECK_HEADERS(sys/auxv.h)\n\ndnl look for libc features\n\ndnl Check for missing typedefs\nAC_TYPE_MODE_T\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\n\ndnl Checks for library functions.\nAC_CHECK_FUNCS(putenv)\nAC_CHECK_FUNCS(mempcpy)\nAC_CHECK_FUNCS(fdatasync)\nAC_CHECK_DECLS(fdatasync, [], [], [#include <unistd.h>])\nAC_CHECK_FUNCS(lutimes)\nAC_CHECK_FUNCS(mergesort)\nAC_CHECK_FUNCS(getauxval)\nAC_CHECK_FUNCS(setprogname, [], [], [#include <stdlib.h>])\nAC_CHECK_FUNCS(syncfs)\nAC_CHECK_FUNCS(sched_getaffinity, [], [], [#include <sched.h>])\nAC_CHECK_FUNCS(unshare, [], [], [#include <sched.h>])\n\nAC_MSG_CHECKING([whether __progname is defined])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([extern const char *__progname;],\n\t   [if (*__progname == 0) return 0;])],\n\t   AC_DEFINE([HAVE___PROGNAME], [1], [Define if __progname is defined])\n\t   AC_MSG_RESULT([yes]),\n\t   AC_MSG_RESULT([no]))\n\nAC_REPLACE_FUNCS(stpcpy stpncpy)\n\nAC_CHECK_FUNCS([secure_getenv __secure_getenv])\n\nAC_CHECK_FUNCS(\n   [mkstemp getcwd basename dirname realpath setenv unsetenv regcomp lchown \\\n    utimes getline localtime_r statvfs getaddrinfo \\\n    openat mkdirat fstatat ],\n   [], [AC_MSG_ERROR([function required by rpm])])\n\nAC_LIBOBJ(fnmatch)\n\ndnl check if python is requested\nAC_ARG_ENABLE(python, [AS_HELP_STRING([--enable-python],[build rpm python bindings])],\n[case \"$enable_python\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --enable-python])\n  ;;\nesac],\n[enable_python=no])\n\nWITH_PYTHON_SUBPACKAGE=0\nAS_IF([test \"$enable_python\" = yes],[\n  PYTHON=\"${PYTHON:-python3}\"\n  AM_PATH_PYTHON([3.1],[\n    PKG_CHECK_MODULES([PYTHON], [python-${PYTHON_VERSION}], [WITH_PYTHON_SUBPACKAGE=1])\n    AC_SUBST(PYTHON_CFLAGS)\n    AC_SUBST(PYTHON_LIB)\n  ])\n])\n\nAM_CONDITIONAL(ENABLE_PYTHON,[test \"$WITH_PYTHON_SUBPACKAGE\" = 1])\n\nAC_PATH_PROG(DOXYGEN, doxygen, no)\nAC_CHECK_PROG(HAVE_DOT,[dot],[YES],[NO])\nAC_PATH_PROG(PANDOC, pandoc, no)\n\nWITH_SELINUX_LIB=\nAC_ARG_WITH(selinux, [AS_HELP_STRING([--with-selinux],[build with selinux support])],\n[case \"$with_selinux\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --with-selinux])\n  ;;\nesac],\n[with_selinux=no])\n\nAS_IF([test \"$with_selinux\" = yes],[\n  AC_CHECK_HEADER([selinux/selinux.h],[\n    save_LIBS=\"$LIBS\"\n    AC_CHECK_LIB([selinux],[is_selinux_enabled],[],[\n      AC_MSG_ERROR([--with-selinux given, but is_selinux_enabled not found in libselinux])])\n    AC_CHECK_LIB([selinux],[selinux_getpolicytype],[],[\n      AC_MSG_ERROR([--with-selinux given, but selinux_getpolicytype not found in libselinux])])\n    AC_CHECK_LIB([selinux],[selinux_reset_config],[],[\n      AC_MSG_ERROR([--with-selinux given, but selinux_reset_config not found in libselinux])])\n    AC_CHECK_LIB([selinux],[setexecfilecon],[\n      AC_DEFINE([HAVE_SETEXECFILECON],[1],[Define to 1 if SELinux setexecfilecon is present])])\n    LIBS=\"$save_LIBS\"\n  ],[\n    AC_MSG_ERROR([--with-selinux given, but selinux/selinux.h not found])\n  ])\n\n  AC_CHECK_HEADER([selinux/label.h],[\n    save_LIBS=\"$LIBS\"\n    AC_CHECK_LIB([selinux],[selabel_close],[],[\n      AC_MSG_ERROR([--with-selinux given, but selabel_close not found in libselinux])])\n    AC_CHECK_LIB([selinux],[selabel_lookup_raw],[],[\n      AC_MSG_ERROR([--with-selinux given, but selabel_lookup_raw not found in libselinux])])\n    AC_CHECK_LIB([selinux],[selabel_open],[],[\n      AC_MSG_ERROR([--with-selinux given, but selabel_open not found in libselinux])])\n    LIBS=\"$save_LIBS\"\n  ],[\n    AC_MSG_ERROR([--with-selinux given, but selinux/label.h not found])\n  ])\n])\n\nAS_IF([test \"$with_selinux\" = yes],[\n  AC_DEFINE(WITH_SELINUX, 1, [Build with selinux support?])\n  WITH_SELINUX_LIB=\"-lselinux\"\n])\nAC_SUBST(WITH_SELINUX_LIB)\nAC_SUBST(WITH_SEMANAGE_LIB)\nAM_CONDITIONAL(SELINUX,[test \"$with_selinux\" = yes])\n\n# libimaevm\nwith_iamevm=no\nAC_ARG_WITH(imaevm, [AS_HELP_STRING([--with-imaevm],[build with imaevm support])])\nif test \"$with_imaevm\" = yes ; then\n  AC_MSG_CHECKING([libimaevm >= 1.0])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM(\n      [[#include <imaevm.h>]],\n      [[return sign_hash(NULL, NULL, 0, NULL, NULL, NULL);]]\n    )],\n    [AC_MSG_RESULT(yes)\n     AC_DEFINE(WITH_IMAEVM, 1, [Build with imaevm support?])\n     WITH_IMAEVM_LIB=\"-limaevm\"\n    ],\n    [AC_MSG_ERROR([libimaevm not present or too old (< 1.0)])]\n  )\nfi\nAM_CONDITIONAL(WITH_IMAEVM,[test \"$with_imaevm\" = yes])\nAC_SUBST(WITH_IMAEVM_LIB)\n\n# fsverity\nAC_ARG_WITH([fsverity], [AS_HELP_STRING([--with-fsverity],[build with fsverity support])],[],[with_fsverity=no])\nif test \"$with_fsverity\" = yes ; then\n  AC_MSG_CHECKING([libfsverity])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM(\n      [[#include <libfsverity.h>]],\n      [[return libfsverity_sign_digest(NULL, NULL, NULL, NULL);]]\n    )],\n    [AC_MSG_RESULT(yes)\n      AC_DEFINE(WITH_FSVERITY, 1, [Build with fsverity support?])\n      WITH_FSVERITY_LIB=\"-lfsverity\"\n    ],\n    [AC_MSG_ERROR([--with-fsverity given, libfsverity or libfsverity.h missing])]\n  )\nfi\nAM_CONDITIONAL(WITH_FSVERITY,[test \"$with_fsverity\" = yes])\nAC_SUBST(WITH_FSVERITY_LIB)\n\n# libcap\nWITH_CAP_LIB=\nAC_ARG_WITH(cap, [AS_HELP_STRING([--with-cap],[build with capability support])],\n[case \"$with_cap\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --with-cap])\n  ;;\nesac],\n[with_cap=no])\n\nAS_IF([test \"$with_cap\" = yes],[\n  AC_CHECK_HEADER([sys/capability.h],[\n    AC_CHECK_LIB(cap,[cap_get_file], [\n      with_cap=yes\n      save_LIBS=\"$LIBS\"\n      AC_CHECK_LIB(cap,[cap_compare], [\n        AC_DEFINE(HAVE_CAP_COMPARE, 1, [Have cap_compare function?])\n      ])\n      LIBS=\"$save_LIBS\"\n    ],[\n      AC_MSG_ERROR([--with-cap given, but libcap not found])])\n  ],[\n    AC_MSG_ERROR([--with-cap given, but sys/capability.h not found])\n  ])\n])\n\nAS_IF([test \"$with_cap\" = yes],[\n  AC_DEFINE(WITH_CAP, 1, [Build with capability support?])\n  WITH_CAP_LIB=\"-lcap\"\n])\nAC_SUBST(WITH_CAP_LIB)\nAM_CONDITIONAL(CAP,[test \"$with_cap\" = yes])\n\nWITH_ACL_LIB=\nAC_ARG_WITH(acl, [AS_HELP_STRING([--with-acl],[build with acl support])],\n[case \"$with_acl\" in\nyes|no) ;;\n*) AC_MSG_ERROR([invalid argument to --with-acl])\n  ;;\nesac],\n[with_acl=no])\n\nAS_IF([test \"$with_acl\" = yes],[\n  dnl verification uses non-portable acl_equiv_mode() \n  AC_CHECK_HEADER([acl/libacl.h],[\n    AC_CHECK_LIB(acl,[acl_equiv_mode],[with_acl=yes],[\n      AC_MSG_ERROR([--with-acl given, but libacl not found or not suitable])])\n  ],[\n    AC_MSG_ERROR([--with-acl given, but acl/libacl.h not found])\n  ])\n])\n\nAS_IF([test \"$with_acl\" = yes],[\n  AC_DEFINE(WITH_ACL, 1, [Build with acl support?])\n  WITH_ACL_LIB=\"-lacl\"\n])\nAC_SUBST(WITH_ACL_LIB)\nAM_CONDITIONAL(ACL,[test \"$with_acl\" = yes])\n\nPKG_CHECK_MODULES([LUA],\n    [lua >= 5.2],\n    [],\n    [AC_MSG_ERROR([lua not present or too old)])])\nAC_SUBST(LUA_CFLAGS)\nAC_SUBST(LUA_LIBS)\n\nAC_ARG_WITH([readline],[AS_HELP_STRING([--with-readline=@<:@yes/no/auto@:>@], [build with readline support])], [with_readline=\"$withval\"], [with_readline=\"auto\"])\nAS_IF([test \"$with_readline\" != \"no\"],[\n  PKG_CHECK_MODULES([READLINE], [readline], [have_readline=yes], [have_readline=no])\n  AS_IF([test \"$with_readline\" = \"yes\"],[\n    if test \"$have_readline\" = \"no\"; then\n      AC_MSG_ERROR([readline support requested but not present])\n    fi\n  ])\n])\nif test \"$have_readline\" = \"yes\"; then\n  AC_DEFINE([HAVE_READLINE], [1], [Define if readline is available])\n  AC_SUBST(READLINE_CFLAGS)\n  AC_SUBST(READLINE_LIBS)\nfi\nAM_CONDITIONAL(WITH_READLINE, [test \"$have_readline\" = yes])\n\n\nAC_ARG_ENABLE(plugins, [AS_HELP_STRING([--disable-plugins],[build without plugin support])],,[enable_plugins=yes])\nAS_IF([test \"$enable_plugins\" = yes],[\n  AC_DEFINE(ENABLE_PLUGINS, 1, [Build with plugin support?])\n])\nAM_CONDITIONAL(ENABLE_PLUGINS,[test \"$enable_plugins\" = yes])\n\nAC_ARG_ENABLE(inhibit_plugin, [AS_HELP_STRING([--disable-inhibit-plugin],[build without systemd inhibit plugin])],,[enable_inhibit_plugin=yes])\nAS_IF([test \"$enable_inhibit_plugin\" = yes],[\n  AC_DEFINE(ENABLE_INHIBIT_PLUGIN, 1, [Build with systemd inhibit plugin?])\n])\nAM_CONDITIONAL(ENABLE_INHIBIT_PLUGIN,[test \"$enable_inhibit_plugin\" = yes])\n\nwith_dbus=no\nAS_IF([test \"$enable_plugins\" != no],[\n AS_IF([test \"$enable_inhibit_plugin\" != no],[\n  PKG_CHECK_MODULES([DBUS],\n    [dbus-1 >= 1.3],\n    [AC_DEFINE(DBUS, 1, [Build with dbus support?]) with_dbus=yes],\n    [with_dbus=no])\n  AC_SUBST(DBUS_CFLAGS)\n  AC_SUBST(DBUS_LIBS)\n ])\n])\nAM_CONDITIONAL(DBUS, [test \"$with_dbus\" = yes])\n\nAS_IF([test \"$enable_plugins\" != no],[\n  AC_CHECK_FUNCS(lsetxattr, [], [], [#include <sys/xattr.h>])\n])\nAM_CONDITIONAL(IMA, [test \"x$ac_cv_func_lsetxattr\" = xyes])\n\nAS_IF([test \"$enable_plugins\" != no],[\nAC_CHECK_HEADERS([linux/fsverity.h],[FSVERITY_IOCTL=\"yes\"])\n])\nAM_CONDITIONAL(FSVERITY_IOCTL,[test \"x$FSVERITY_IOCTL\" = xyes])\n\n#=================\n# Check for fapolicyd support\nAC_ARG_WITH(fapolicyd,\nAS_HELP_STRING([--with-fapolicyd],[build with File Access Policy Daemon support]),\nwith_fapolicyd=$withval,\nwith_fapolicyd=auto)\nAM_CONDITIONAL(FAPOLICYD,[test \"$with_fapolicyd\" = yes])\n\n#=================\n# Check for audit library.\nAC_ARG_WITH(audit,\nAS_HELP_STRING([--with-audit],[Linux audit plugin]),\nwith_audit=$withval,\nwith_audit=auto)\n\nWITH_AUDIT_LIB=\nAS_IF([test \"$enable_plugins\" != no],[\n  AS_IF([test \"x$with_audit\" != xno],[\n    AC_SEARCH_LIBS([audit_open],[audit],[\n      WITH_AUDIT_LIB=\"$ac_res\"\n      AC_DEFINE(WITH_AUDIT, 1, [libaudit support])\n      with_audit=yes\n    ],[\n      if test \"x$with_audit\" != xauto; then\n        AC_MSG_ERROR([missing audit library])\n      fi\n    ])\n  ])\n])\nAC_SUBST(WITH_AUDIT_LIB)\nAM_CONDITIONAL(AUDIT,[test \"$with_audit\" = yes])\n\nuser_with_uid0=$(awk -F: '$3==0 {print $1;exit}' /etc/passwd)\ngroup_with_gid0=$(awk -F: '$3==0 {print $1;exit}' /etc/group)\nif test -z \"$user_with_uid0\" ; then user_with_uid0=root ; fi\nif test -z \"$group_with_gid0\" ; then group_with_gid0=root ; fi\nAC_DEFINE_UNQUOTED([UID_0_USER],[\"$user_with_uid0\"],[Get the user name having userid 0])\nAC_DEFINE_UNQUOTED([GID_0_GROUP],[\"$group_with_gid0\"],[Get the group name having groupid 0])\n\n#\n# get rid of the 4-th tuple, if config.guess returned \"linux-gnu\" for host_os\n#\nhost_os_gnu=-gnu\nif echo \"$host_os\" | grep '.*-gnulibc1$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnulibc1$//'`\nfi\nif echo \"$host_os\" | grep '.*-gnueabihf$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnueabihf$//'`\n\thost_os_gnu=-gnueabihf\nfi\nif echo \"$host_os\" | grep '.*-gnueabi$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnueabi$//'`\n\thost_os_gnu=-gnueabi\nfi\nif echo \"$host_os\" | grep '.*-gnuabi64$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnuabi64$//'`\n\thost_os_gnu=-gnuabi64\nfi\nif echo \"$host_os\" | grep '.*-gnu$' > /dev/null ; then\n\thost_os=`echo \"${host_os}\" | sed 's/-gnu$//'`\nfi\nif echo \"$host_os\" | grep '.*-gnu[[^-]]*$' > /dev/null ; then\n\tAC_MSG_ERROR([unrecognized GNU build triplet $host_os])\nfi\n\nchangequote(<, >)\nhost_os_exact=\"${host_os}\"\nhost_os_major=`echo \"${host_os}\" | sed 's/\\..*$//'`\nhost_os_noversion=`echo \"${host_os}\" | sed 's/[0-9]*\\..*$//'`\nchangequote([, ])\n\ndnl permit overriding build_vendor for \"canonical rpm vendor\"\nRPMCANONVENDOR=\"$build_vendor\"\nAC_ARG_WITH([vendor], \n  AS_HELP_STRING([--with-vendor=VENDOR], [specify rpm vendor name]),\n  [RPMCANONVENDOR=$withval])\nAC_DEFINE_UNQUOTED([RPMCANONVENDOR],[\"${RPMCANONVENDOR}\"],[canonical vendor])\n\t   \nRPMCANONOS=\"$host_os_noversion\"\nRPMCANONGNU=\"$host_os_gnu\"\nAC_SUBST(RPMCANONVENDOR)\nAC_SUBST(RPMCANONOS)\nAC_SUBST(RPMCANONGNU)\n\nRUNDIR=\"/run\"\nAC_ARG_WITH([rundir], \n  AS_HELP_STRING([--with-rundir=RUNDIR], [specify run-time variable directory]),\n  [RUNDIR=$withval])\nAC_DEFINE_UNQUOTED([RUNDIR],[\"${RUNDIR}\"],[run-time variable directory])\nAC_SUBST(RUNDIR)\n\nif test X\"$prefix\" = XNONE ; then\n    usrprefix=\"$ac_default_prefix\"\nelse\n    usrprefix=$prefix\nfi\n\nRPMCONFIGDIR=\"`echo ${usrprefix}/lib/rpm`\"\nAC_SUBST(RPMCONFIGDIR)\n\nAC_SUBST(OBJDUMP)\n\nAM_CONDITIONAL([DOXYGEN],[test \"$DOXYGEN\" != no])\nAM_CONDITIONAL([PANDOC],[test \"$PANDOC\" != no])\n\nAC_PATH_PROG(AUTOM4TE,autom4te,:)\n\nAC_SUBST([dirstamp],[\\${am__leading_dot}dirstamp])\n\nAC_CONFIG_FILES([Makefile\n\trpmio/Makefile lib/Makefile build/Makefile sign/Makefile\n\tpo/Makefile.in scripts/Makefile fileattrs/Makefile\n\tmisc/Makefile \n\tdocs/Makefile\n\tdocs/man/Makefile\n\tpython/Makefile\n \tluaext/Makefile\n \ttests/Makefile\n \tplugins/Makefile\n\tpython/setup.py\n  ])\nAC_OUTPUT\n", "/** \\ingroup payload\n * \\file lib/fsm.c\n * File state machine to handle a payload from a package.\n */\n\n#include \"system.h\"\n\n#include <inttypes.h>\n#include <utime.h>\n#include <errno.h>\n#include <fcntl.h>\n#if WITH_CAP\n#include <sys/capability.h>\n#endif\n\n#include <rpm/rpmte.h>\n#include <rpm/rpmts.h>\n#include <rpm/rpmlog.h>\n#include <rpm/rpmmacro.h>\n\n#include \"rpmio/rpmio_internal.h\"\t/* fdInit/FiniDigest */\n#include \"lib/fsm.h\"\n#include \"lib/rpmte_internal.h\"\t/* XXX rpmfs */\n#include \"lib/rpmfi_internal.h\" /* rpmfiSetOnChdir */\n#include \"lib/rpmplugins.h\"\t/* rpm plugins hooks */\n#include \"lib/rpmug.h\"\n\n#include \"debug.h\"\n\n#define\t_FSM_DEBUG\t0\nint _fsm_debug = _FSM_DEBUG;\n\n/* XXX Failure to remove is not (yet) cause for failure. */\nstatic int strict_erasures = 0;\n\n#define\tSUFFIX_RPMORIG\t\".rpmorig\"\n#define\tSUFFIX_RPMSAVE\t\".rpmsave\"\n#define\tSUFFIX_RPMNEW\t\".rpmnew\"\n\n/* Default directory and file permissions if not mapped */\n#define _dirPerms 0755\n#define _filePerms 0644\n\nenum filestage_e {\n    FILE_COMMIT = -1,\n    FILE_NONE   = 0,\n    FILE_PRE    = 1,\n    FILE_UNPACK = 2,\n    FILE_PREP   = 3,\n    FILE_POST   = 4,\n};\n\nstruct filedata_s {\n    int stage;\n    int setmeta;\n    int skip;\n    rpmFileAction action;\n    const char *suffix;\n    char *fpath;\n    struct stat sb;\n};\n\n/* \n * XXX Forward declarations for previously exported functions to avoid moving \n * things around needlessly \n */ \nstatic const char * fileActionString(rpmFileAction a);\n\n/** \\ingroup payload\n * Build path to file from file info, optionally ornamented with suffix.\n * @param fi\t\tfile info iterator\n * @param suffix\tsuffix to use (NULL disables)\n * @param[out]\t\tpath to file (malloced)\n */\nstatic char * fsmFsPath(rpmfi fi, const char * suffix)\n{\n    return rstrscat(NULL, rpmfiDN(fi), rpmfiBN(fi), suffix ? suffix : \"\", NULL);\n}\n\n/** \\ingroup payload\n * Directory name iterator.\n */\ntypedef struct dnli_s {\n    rpmfiles fi;\n    char * active;\n    int reverse;\n    int isave;\n    int i;\n} * DNLI_t;\n\n/** \\ingroup payload\n * Destroy directory name iterator.\n * @param dnli\t\tdirectory name iterator\n * @param[out]\t\tNULL always\n */\nstatic DNLI_t dnlFreeIterator(DNLI_t dnli)\n{\n    if (dnli) {\n\tif (dnli->active) free(dnli->active);\n\tfree(dnli);\n    }\n    return NULL;\n}\n\n/** \\ingroup payload\n * Create directory name iterator.\n * @param fi\t\tfile info set\n * @param fs\t\tfile state set\n * @param reverse\ttraverse directory names in reverse order?\n * @return\t\tdirectory name iterator\n */\nstatic DNLI_t dnlInitIterator(rpmfiles fi, rpmfs fs, int reverse)\n{\n    DNLI_t dnli;\n    int i, j;\n    int dc;\n\n    if (fi == NULL)\n\treturn NULL;\n    dc = rpmfilesDC(fi);\n    dnli = xcalloc(1, sizeof(*dnli));\n    dnli->fi = fi;\n    dnli->reverse = reverse;\n    dnli->i = (reverse ? dc : 0);\n\n    if (dc) {\n\tdnli->active = xcalloc(dc, sizeof(*dnli->active));\n\tint fc = rpmfilesFC(fi);\n\n\t/* Identify parent directories not skipped. */\n\tfor (i = 0; i < fc; i++)\n            if (!XFA_SKIPPING(rpmfsGetAction(fs, i)))\n\t\tdnli->active[rpmfilesDI(fi, i)] = 1;\n\n\t/* Exclude parent directories that are explicitly included. */\n\tfor (i = 0; i < fc; i++) {\n\t    int dil;\n\t    size_t dnlen, bnlen;\n\n\t    if (!S_ISDIR(rpmfilesFMode(fi, i)))\n\t\tcontinue;\n\n\t    dil = rpmfilesDI(fi, i);\n\t    dnlen = strlen(rpmfilesDN(fi, dil));\n\t    bnlen = strlen(rpmfilesBN(fi, i));\n\n\t    for (j = 0; j < dc; j++) {\n\t\tconst char * dnl;\n\t\tsize_t jlen;\n\n\t\tif (!dnli->active[j] || j == dil)\n\t\t    continue;\n\t\tdnl = rpmfilesDN(fi, j);\n\t\tjlen = strlen(dnl);\n\t\tif (jlen != (dnlen+bnlen+1))\n\t\t    continue;\n\t\tif (!rstreqn(dnl, rpmfilesDN(fi, dil), dnlen))\n\t\t    continue;\n\t\tif (!rstreqn(dnl+dnlen, rpmfilesBN(fi, i), bnlen))\n\t\t    continue;\n\t\tif (dnl[dnlen+bnlen] != '/' || dnl[dnlen+bnlen+1] != '\\0')\n\t\t    continue;\n\t\t/* This directory is included in the package. */\n\t\tdnli->active[j] = 0;\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Print only once per package. */\n\tif (!reverse) {\n\t    j = 0;\n\t    for (i = 0; i < dc; i++) {\n\t\tif (!dnli->active[i]) continue;\n\t\tif (j == 0) {\n\t\t    j = 1;\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\"========== Directories not explicitly included in package:\\n\");\n\t\t}\n\t\trpmlog(RPMLOG_DEBUG, \"%10d %s\\n\", i, rpmfilesDN(fi, i));\n\t    }\n\t    if (j)\n\t\trpmlog(RPMLOG_DEBUG, \"==========\\n\");\n\t}\n    }\n    return dnli;\n}\n\n/** \\ingroup payload\n * Return next directory name (from file info).\n * @param dnli\t\tdirectory name iterator\n * @return\t\tnext directory name\n */\nstatic\nconst char * dnlNextIterator(DNLI_t dnli)\n{\n    const char * dn = NULL;\n\n    if (dnli) {\n\trpmfiles fi = dnli->fi;\n\tint dc = rpmfilesDC(fi);\n\tint i = -1;\n\n\tif (dnli->active)\n\tdo {\n\t    i = (!dnli->reverse ? dnli->i++ : --dnli->i);\n\t} while (i >= 0 && i < dc && !dnli->active[i]);\n\n\tif (i >= 0 && i < dc)\n\t    dn = rpmfilesDN(fi, i);\n\telse\n\t    i = -1;\n\tdnli->isave = i;\n    }\n    return dn;\n}\n\nstatic int fsmLink(const char *opath, const char *path)\n{\n    int rc = link(opath, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_LINK_FAILED;\n    return rc;\n}\n\nstatic int fsmSetFCaps(const char *path, const char *captxt)\n{\n    int rc = 0;\n#if WITH_CAP\n    if (captxt && *captxt != '\\0') {\n\tcap_t fcaps = cap_from_text(captxt);\n\tif (fcaps == NULL || cap_set_file(path, fcaps) != 0) {\n\t    rc = RPMERR_SETCAP_FAILED;\n\t}\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t\t   path, captxt, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\tcap_free(fcaps);\n    } \n#endif\n    return rc;\n}\n\nstatic int fsmClose(FD_t *wfdp)\n{\n    int rc = 0;\n    if (wfdp && *wfdp) {\n\tint myerrno = errno;\n\tstatic int oneshot = 0;\n\tstatic int flush_io = 0;\n\tint fdno = Fileno(*wfdp);\n\n\tif (!oneshot) {\n\t    flush_io = (rpmExpandNumeric(\"%{?_flush_io}\") > 0);\n\t    oneshot = 1;\n\t}\n\tif (flush_io) {\n\t    fsync(fdno);\n\t}\n\tif (Fclose(*wfdp))\n\t    rc = RPMERR_CLOSE_FAILED;\n\n\tif (_fsm_debug) {\n\t    rpmlog(RPMLOG_DEBUG, \" %8s ([%d]) %s\\n\", __func__,\n\t\t   fdno, (rc < 0 ? strerror(errno) : \"\"));\n\t}\n\t*wfdp = NULL;\n\terrno = myerrno;\n    }\n    return rc;\n}\n\nstatic int fsmOpen(FD_t *wfdp, const char *dest)\n{\n    int rc = 0;\n    /* Create the file with 0200 permissions (write by owner). */\n    {\n\tmode_t old_umask = umask(0577);\n\t*wfdp = Fopen(dest, \"wx.ufdio\");\n\tumask(old_umask);\n    }\n\n    if (Ferror(*wfdp))\n\trc = RPMERR_OPEN_FAILED;\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s [%d]) %s\\n\", __func__,\n\t       dest, Fileno(*wfdp), (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc)\n\tfsmClose(wfdp);\n\n    return rc;\n}\n\nstatic int fsmUnpack(rpmfi fi, FD_t fd, rpmpsm psm, int nodigest)\n{\n    int rc = rpmfiArchiveReadToFilePsm(fi, fd, nodigest, psm);\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s %\" PRIu64 \" bytes [%d]) %s\\n\", __func__,\n\t       rpmfiFN(fi), rpmfiFSize(fi), Fileno(fd),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n    return rc;\n}\n\nstatic int fsmMkfile(rpmfi fi, struct filedata_s *fp, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest,\n\t\t     struct filedata_s ** firstlink, FD_t *firstlinkfile)\n{\n    int rc = 0;\n    FD_t fd = NULL;\n\n    if (*firstlink == NULL) {\n\t/* First encounter, open file for writing */\n\trc = fsmOpen(&fd, fp->fpath);\n\t/* If it's a part of a hardlinked set, the content may come later */\n\tif (fp->sb.st_nlink > 1) {\n\t    *firstlink = fp;\n\t    *firstlinkfile = fd;\n\t}\n    } else {\n\t/* Create hard links for others and avoid redundant metadata setting */\n\tif (*firstlink != fp) {\n\t    rc = fsmLink((*firstlink)->fpath, fp->fpath);\n\t    fp->setmeta = 0;\n\t}\n\tfd = *firstlinkfile;\n    }\n\n    /* If the file has content, unpack it */\n    if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = fsmUnpack(fi, fd, psm, nodigest);\n\t/* Last file of hardlink set, ensure metadata gets set */\n\tif (*firstlink) {\n\t    (*firstlink)->setmeta = 1;\n\t    *firstlink = NULL;\n\t    *firstlinkfile = NULL;\n\t}\n    }\n\n    if (fd != *firstlinkfile)\n\tfsmClose(&fd);\n\n    return rc;\n}\n\nstatic int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}\n\nstatic int fsmStat(const char *path, int dolstat, struct stat *sb)\n{\n    int rc;\n    if (dolstat){\n\trc = lstat(path, sb);\n    } else {\n        rc = stat(path, sb);\n    }\n    if (_fsm_debug && rc && errno != ENOENT)\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, ost) %s\\n\",\n               __func__,\n               path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0) {\n        rc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_LSTAT_FAILED);\n\t/* Ensure consistent struct content on failure */\n        memset(sb, 0, sizeof(*sb));\n    }\n    return rc;\n}\n\nstatic int fsmRmdir(const char *path)\n{\n    int rc = rmdir(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\tswitch (errno) {\n\tcase ENOENT:        rc = RPMERR_ENOENT;    break;\n\tcase ENOTEMPTY:     rc = RPMERR_ENOTEMPTY; break;\n\tdefault:            rc = RPMERR_RMDIR_FAILED; break;\n\t}\n    return rc;\n}\n\nstatic int fsmMkdir(int dirfd, const char *path, mode_t mode)\n{\n    int rc = mkdirat(dirfd, path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n\t       dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}\n\nstatic int fsmOpenat(int dirfd, const char *path, int flags)\n{\n    struct stat lsb, sb;\n    int sflags = flags | O_NOFOLLOW;\n    int fd = openat(dirfd, path, sflags);\n\n    /*\n     * Only ever follow symlinks by root or target owner. Since we can't\n     * open the symlink itself, the order matters: we stat the link *after*\n     * opening the target, and if the link ownership changed between the calls\n     * it could've only been the link owner or root.\n     */\n    if (fd < 0 && errno == ELOOP && flags != sflags) {\n\tint ffd = openat(dirfd, path, flags);\n\tif (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n\t    if (fstat(ffd, &sb) == 0) {\n\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n\t\t    fd = ffd;\n\t\t} else {\n\t\t    close(ffd);\n\t\t}\n\t    }\n\t}\n    }\n    return fd;\n}\n\nstatic int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,\n\t\t\tint owned, mode_t mode)\n{\n    int rc;\n    rpmFsmOp op = (FA_CREATE);\n    if (!owned)\n\top |= FAF_UNOWNED;\n\n    /* Run fsm file pre hook for all plugins */\n    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n    if (!rc)\n\trc = fsmMkdir(dirfd, dn, mode);\n\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);\n    }\n\n    /* Run fsm file post hook for all plugins */\n    rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n    if (!rc) {\n\trpmlog(RPMLOG_DEBUG,\n\t\t\"%s directory created with perms %04o\\n\",\n\t\tdn, (unsigned)(mode & 07777));\n    }\n\n    return rc;\n}\n\nstatic int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)\n{\n    char *path = xstrdup(p);\n    char *dp = path;\n    char *sp = NULL, *bn;\n    int oflags = O_RDONLY;\n\n    int dirfd = fsmOpenat(-1, \"/\", oflags);\n    int fd = dirfd; /* special case of \"/\" */\n\n    while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {\n\tstruct stat sb;\n\tfd = fsmOpenat(dirfd, bn, oflags);\n\n\tif (fd < 0 && errno == ENOENT && create) {\n\t    mode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t    if (fsmDoMkDir(plugins, dirfd, bn, owned, mode) == 0) {\n\t\tfd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);\n\t    }\n\t}\n\n\tif (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {\n\t    close(fd);\n\t    errno = ENOTDIR;\n\t    fd = -1;\n\t}\n\n\tclose(dirfd);\n\tif (fd >= 0) {\n\t    dirfd = fd;\n\t} else {\n\t    dirfd = -1;\n\t    rpmlog(RPMLOG_ERR, _(\"failed to open dir %s of %s: %s\\n\"),\n\t\t\t\tbn, p, strerror(errno));\n\t    break;\n\t}\n\n\tdp = NULL;\n    }\n\n    free(path);\n    return dirfd;\n}\n\nstatic int fsmMkfifo(const char *path, mode_t mode)\n{\n    int rc = mkfifo(path, (mode & 07777));\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\",\n\t       __func__, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKFIFO_FAILED;\n\n    return rc;\n}\n\nstatic int fsmMknod(const char *path, mode_t mode, dev_t dev)\n{\n    /* FIX: check S_IFIFO or dev != 0 */\n    int rc = mknod(path, (mode & ~07777), dev);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%o, 0x%x) %s\\n\",\n\t       __func__, path, (unsigned)(mode & ~07777),\n\t       (unsigned)dev, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_MKNOD_FAILED;\n\n    return rc;\n}\n\n/**\n * Create (if necessary) directories not explicitly included in package.\n * @param files\t\tfile data\n * @param fs\t\tfile states\n * @param plugins\trpm plugins handle\n * @return\t\t0 on success\n */\nstatic int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tif (dnlen <= 1)\n\t    continue;\n\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume '/' directory exists, \"mkdir -p\" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\n\t    /* Already validated? */\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\n\t    /* Validate next component of path. */\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); /* lstat */\n\t    *te = '/';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(-1, dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n\n    return rc;\n}\n\nstatic void removeSBITS(const char *path)\n{\n    struct stat stb;\n    if (lstat(path, &stb) == 0 && S_ISREG(stb.st_mode)) {\n\tif ((stb.st_mode & 06000) != 0) {\n\t    (void) chmod(path, stb.st_mode & 0777);\n\t}\n#if WITH_CAP\n\tif (stb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH)) {\n\t    (void) cap_set_file(path, NULL);\n\t}\n#endif\n    }\n}\n\nstatic void fsmDebug(const char *fpath, rpmFileAction action,\n\t\t     const struct stat *st)\n{\n    rpmlog(RPMLOG_DEBUG, \"%-10s %06o%3d (%4d,%4d)%6d %s\\n\",\n\t   fileActionString(action), (int)st->st_mode,\n\t   (int)st->st_nlink, (int)st->st_uid,\n\t   (int)st->st_gid, (int)st->st_size,\n\t    (fpath ? fpath : \"\"));\n}\n\nstatic int fsmSymlink(const char *opath, const char *path)\n{\n    int rc = symlink(opath, path);\n\n    if (_fsm_debug) {\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    }\n\n    if (rc < 0)\n\trc = RPMERR_SYMLINK_FAILED;\n    return rc;\n}\n\nstatic int fsmUnlink(const char *path)\n{\n    int rc = 0;\n    removeSBITS(path);\n    rc = unlink(path);\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s) %s\\n\", __func__,\n\t       path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == ENOENT ? RPMERR_ENOENT : RPMERR_UNLINK_FAILED);\n    return rc;\n}\n\nstatic int fsmRename(const char *opath, const char *path)\n{\n    removeSBITS(path);\n    int rc = rename(opath, path);\n#if defined(ETXTBSY) && defined(__HPUX__)\n    /* XXX HP-UX (and other os'es) don't permit rename to busy files. */\n    if (rc && errno == ETXTBSY) {\n\tchar *rmpath = NULL;\n\trstrscat(&rmpath, path, \"-RPMDELETE\", NULL);\n\trc = rename(path, rmpath);\n\tif (!rc) rc = rename(opath, path);\n\tfree(rmpath);\n    }\n#endif\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %s) %s\\n\", __func__,\n\t       opath, path, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\n\trc = (errno == EISDIR ? RPMERR_EXIST_AS_DIR : RPMERR_RENAME_FAILED);\n    return rc;\n}\n\nstatic int fsmRemove(const char *path, mode_t mode)\n{\n    return S_ISDIR(mode) ? fsmRmdir(path) : fsmUnlink(path);\n}\n\nstatic int fsmChown(const char *path, mode_t mode, uid_t uid, gid_t gid)\n{\n    int rc = S_ISLNK(mode) ? lchown(path, uid, gid) : chown(path, uid, gid);\n    if (rc < 0) {\n\tstruct stat st;\n\tif (lstat(path, &st) == 0 && st.st_uid == uid && st.st_gid == gid)\n\t    rc = 0;\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, %d, %d) %s\\n\", __func__,\n\t       path, (int)uid, (int)gid,\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHOWN_FAILED;\n    return rc;\n}\n\nstatic int fsmChmod(const char *path, mode_t mode)\n{\n    int rc = chmod(path, (mode & 07777));\n    if (rc < 0) {\n\tstruct stat st;\n\tif (lstat(path, &st) == 0 && (st.st_mode & 07777) == (mode & 07777))\n\t    rc = 0;\n    }\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_CHMOD_FAILED;\n    return rc;\n}\n\nstatic int fsmUtime(const char *path, mode_t mode, time_t mtime)\n{\n    int rc = 0;\n    struct timeval stamps[2] = {\n\t{ .tv_sec = mtime, .tv_usec = 0 },\n\t{ .tv_sec = mtime, .tv_usec = 0 },\n    };\n\n#if HAVE_LUTIMES\n    rc = lutimes(path, stamps);\n#else\n    if (!S_ISLNK(mode))\n\trc = utimes(path, stamps);\n#endif\n    \n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0x%x) %s\\n\", __func__,\n\t       path, (unsigned)mtime, (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_UTIME_FAILED;\n    /* ...but utime error is not critical for directories */\n    if (rc && S_ISDIR(mode))\n\trc = 0;\n    return rc;\n}\n\nstatic int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == dsb.st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}\n\n#define\tIS_DEV_LOG(_x)\t\\\n\t((_x) != NULL && strlen(_x) >= (sizeof(\"/dev/log\")-1) && \\\n\trstreqn((_x), \"/dev/log\", sizeof(\"/dev/log\")-1) && \\\n\t((_x)[sizeof(\"/dev/log\")-1] == '\\0' || \\\n\t (_x)[sizeof(\"/dev/log\")-1] == ';'))\n\n\n\n/* Rename pre-existing modified or unmanaged file. */\nstatic int fsmBackup(rpmfi fi, rpmFileAction action)\n{\n    int rc = 0;\n    const char *suffix = NULL;\n\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(opath, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}\n\nstatic int fsmSetmeta(const char *path, rpmfi fi, rpmPlugins plugins,\n\t\t      rpmFileAction action, const struct stat * st,\n\t\t      int nofcaps)\n{\n    int rc = 0;\n    const char *dest = rpmfiFN(fi);\n\n    if (!rc && !getuid()) {\n\trc = fsmChown(path, st->st_mode, st->st_uid, st->st_gid);\n    }\n    if (!rc && !S_ISLNK(st->st_mode)) {\n\trc = fsmChmod(path, st->st_mode);\n    }\n    /* Set file capabilities (if enabled) */\n    if (!rc && !nofcaps && S_ISREG(st->st_mode) && !getuid()) {\n\trc = fsmSetFCaps(path, rpmfiFCaps(fi));\n    }\n    if (!rc) {\n\trc = fsmUtime(path, st->st_mode, rpmfiFMtime(fi));\n    }\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, fi,\n\t\t\t\t\t  path, dest, st->st_mode, action);\n    }\n\n    return rc;\n}\n\nstatic int fsmCommit(char **path, rpmfi fi, rpmFileAction action, const char *suffix)\n{\n    int rc = 0;\n\n    /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\t/* Construct final destination path (nsuffix is usually NULL) */\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\n\t/* Rename temporary to final file name if needed. */\n\tif (dest != *path) {\n\t    rc = fsmRename(*path, dest);\n\t    if (!rc) {\n\t\tif (nsuffix) {\n\t\t    char * opath = fsmFsPath(fi, NULL);\n\t\t    rpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t\t   opath, dest);\n\t\t    free(opath);\n\t\t}\n\t\tfree(*path);\n\t\t*path = dest;\n\t    }\n\t}\n    }\n\n    return rc;\n}\n\n/**\n * Return formatted string representation of file disposition.\n * @param a\t\tfile disposition\n * @return\t\tformatted string\n */\nstatic const char * fileActionString(rpmFileAction a)\n{\n    switch (a) {\n    case FA_UNKNOWN:\treturn \"unknown\";\n    case FA_CREATE:\treturn \"create\";\n    case FA_BACKUP:\treturn \"backup\";\n    case FA_SAVE:\treturn \"save\";\n    case FA_SKIP:\treturn \"skip\";\n    case FA_ALTNAME:\treturn \"altname\";\n    case FA_ERASE:\treturn \"erase\";\n    case FA_SKIPNSTATE: return \"skipnstate\";\n    case FA_SKIPNETSHARED: return \"skipnetshared\";\n    case FA_SKIPCOLOR:\treturn \"skipcolor\";\n    case FA_TOUCH:     return \"touch\";\n    default:\t\treturn \"???\";\n    }\n}\n\n/* Remember any non-regular file state for recording in the rpmdb */\nstatic void setFileState(rpmfs fs, int i)\n{\n    switch (rpmfsGetAction(fs, i)) {\n    case FA_SKIPNSTATE:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NOTINSTALLED);\n\tbreak;\n    case FA_SKIPNETSHARED:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NETSHARED);\n\tbreak;\n    case FA_SKIPCOLOR:\n\trpmfsSetState(fs, i, RPMFILE_STATE_WRONGCOLOR);\n\tbreak;\n    case FA_TOUCH:\n\trpmfsSetState(fs, i, RPMFILE_STATE_NORMAL);\n\tbreak;\n    default:\n\tbreak;\n    }\n}\n\nstruct diriter_s {\n    int dirfd;\n};\n\nstatic int onChdir(rpmfi fi, void *data)\n{\n    struct diriter_s *di = data;\n\n    if (di->dirfd >= 0) {\n\tclose(di->dirfd);\n\tdi->dirfd = -1;\n    }\n    return 0;\n}\n\nint rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    FD_t firstlinkfile = NULL;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tfp->setmeta = 1;\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    if (rpmteType(te) == TR_ADDED)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n    rpmfiSetOnChdir(fi, onChdir, &di);\n\n    /* Detect and create directories not explicitly in package. */\n    if (!rc)\n\trc = fsmMkdirs(files, fs, plugins);\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n        if (!fp->skip) {\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix) {\n\t\trc = fsmBackup(fi, fp->action);\n\t    }\n\n\t    if (di.dirfd == -1) {\n\t\tdi.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t    (fp->action == FA_CREATE));\n\t\tif (di.dirfd == -1) {\n\t\t    rc = RPMERR_OPEN_FAILED;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tcontinue;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t} else if (firstlink && rpmfiArchiveHasContent(fi)) {\n\t    /*\n\t     * Tricksy case: this file is a being skipped, but it's part of\n\t     * a hardlinked set and has the actual content linked with it.\n\t     * Write the content to the first non-skipped file of the set\n\t     * instead.\n\t     */\n\t    rc = fsmMkfile(fi, firstlink, files, psm, nodigest,\n\t\t\t   &firstlink, &firstlinkfile);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = rpmfiFree(fi);\n    close(di.dirfd);\n    di.dirfd = -1;\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* Set permissions, timestamps etc for non-hardlink entries */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (!fp->skip && fp->setmeta) {\n\t    rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,\n\t\t\t    &fp->sb, nofcaps);\n\t}\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\tfp->stage = FILE_PREP;\n    }\n    fi = rpmfiFree(fi);\n\n    /* If all went well, commit files to final destination */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(&fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\t}\n    }\n    fi = rpmfiFree(fi);\n\n    /* Walk backwards in case we need to erase */\n    fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    while ((fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\t/* Run fsm file post hook for all plugins for all processed files */\n\tif (fp->stage) {\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n\n\t/* On failure, erase non-committed files */\n\tif (rc && fp->stage > FILE_NONE && !fp->skip) {\n\t    (void) fsmRemove(fp->fpath, fp->sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}\n\n\nint rpmPackageFilesRemove(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    rpmfi fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int fc = rpmfilesFC(files);\n    int fx = -1;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    int rc = 0;\n\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tfp->action = rpmfsGetAction(fs, rpmfiFX(fi));\n\tfp->fpath = fsmFsPath(fi, NULL);\n\trc = fsmStat(fp->fpath, 1, &fp->sb);\n\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\n\tif (!XFA_SKIPPING(fp->action))\n\t    rc = fsmBackup(fi, fp->action);\n\n        /* Remove erased files. */\n        if (fp->action == FA_ERASE) {\n\t    int missingok = (rpmfiFFlags(fi) & (RPMFILE_MISSINGOK | RPMFILE_GHOST));\n\n\t    rc = fsmRemove(fp->fpath, fp->sb.st_mode);\n\n\t    /*\n\t     * Missing %ghost or %missingok entries are not errors.\n\t     * XXX: Are non-existent files ever an actual error here? Afterall\n\t     * that's exactly what we're trying to accomplish here,\n\t     * and complaining about job already done seems like kinderkarten\n\t     * level \"But it was MY turn!\" whining...\n\t     */\n\t    if (rc == RPMERR_ENOENT && missingok) {\n\t\trc = 0;\n\t    }\n\n\t    /*\n\t     * Dont whine on non-empty directories for now. We might be able\n\t     * to track at least some of the expected failures though,\n\t     * such as when we knowingly left config file backups etc behind.\n\t     */\n\t    if (rc == RPMERR_ENOTEMPTY) {\n\t\trc = 0;\n\t    }\n\n\t    if (rc) {\n\t\tint lvl = strict_erasures ? RPMLOG_ERR : RPMLOG_WARNING;\n\t\trpmlog(lvl, _(\"%s %s: remove failed: %s\\n\"),\n\t\t\tS_ISDIR(fp->sb.st_mode) ? _(\"directory\") : _(\"file\"),\n\t\t\tfp->fpath, strerror(errno));\n            }\n        }\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t  fp->sb.st_mode, fp->action, rc);\n\n        /* XXX Failure to remove is not (yet) cause for failure. */\n        if (!strict_erasures) rc = 0;\n\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\n\tif (rc == 0) {\n\t    /* Notify on success. */\n\t    /* On erase we're iterating backwards, fixup for progress */\n\t    rpm_loff_t amount = rpmfiFC(fi) - rpmfiFX(fi);\n\t    rpmpsmNotify(psm, RPMCALLBACK_UNINST_PROGRESS, amount);\n\t}\n    }\n\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n    rpmfiFree(fi);\n\n    return rc;\n}\n\n\n"], "filenames": ["INSTALL", "configure.ac", "lib/fsm.c"], "buggy_code_start_loc": [104, 583, 10], "buggy_code_end_loc": [104, 584, 1024], "fixing_code_start_loc": [105, 583, 11], "fixing_code_end_loc": [107, 585, 1157], "type": "CWE-59", "message": "It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete: the check was only implemented for the parent directory of the file to be created. A local unprivileged user who owns another ancestor directory could potentially use this flaw to gain root privileges. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.", "other": {"cve": {"id": "CVE-2021-35939", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-26T16:15:08.683", "lastModified": "2023-02-04T01:16:51.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete: the check was only implemented for the parent directory of the file to be created. A local unprivileged user who owns another ancestor directory could potentially use this flaw to gain root privileges. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability."}, {"lang": "es", "value": "Se ha detectado que la correcci\u00f3n de CVE-2017-7500 y CVE-2017-7501 era incompleta: la comprobaci\u00f3n s\u00f3lo es implementada para el directorio padre del archivo que iba a crearse. Un usuario local no privilegiado que posea otro directorio antecesor podr\u00eda usar este fallo para conseguir privilegios de root. La mayor amenaza de esta vulnerabilidad es para la confidencialidad e integridad de los datos, as\u00ed como para la disponibilidad del sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rpm:rpm:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.18", "matchCriteriaId": "582D14B9-3812-42FD-9FA3-2BDEAA02DD6C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-35939", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1964129", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/rpm/pull/1919", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://rpm.org/wiki/Releases/4.18.0", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-22", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556"}}