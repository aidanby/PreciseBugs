{"buggy_code": ["\n/* Core extension modules are built-in on some platforms (e.g. Windows). */\n#ifdef Py_BUILD_CORE\n#define Py_BUILD_CORE_BUILTIN\n#undef Py_BUILD_CORE\n#endif\n\n#include \"Python.h\"\n#include \"structmember.h\"\n\nPyDoc_STRVAR(pickle_module_doc,\n\"Optimized C implementation for the Python pickle module.\");\n\n/*[clinic input]\nmodule _pickle\nclass _pickle.Pickler \"PicklerObject *\" \"&Pickler_Type\"\nclass _pickle.PicklerMemoProxy \"PicklerMemoProxyObject *\" \"&PicklerMemoProxyType\"\nclass _pickle.Unpickler \"UnpicklerObject *\" \"&Unpickler_Type\"\nclass _pickle.UnpicklerMemoProxy \"UnpicklerMemoProxyObject *\" \"&UnpicklerMemoProxyType\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=4b3e113468a58e6c]*/\n\n/* Bump HIGHEST_PROTOCOL when new opcodes are added to the pickle protocol.\n   Bump DEFAULT_PROTOCOL only when the oldest still supported version of Python\n   already includes it. */\nenum {\n    HIGHEST_PROTOCOL = 4,\n    DEFAULT_PROTOCOL = 4\n};\n\n/* Pickle opcodes. These must be kept updated with pickle.py.\n   Extensive docs are in pickletools.py. */\nenum opcode {\n    MARK            = '(',\n    STOP            = '.',\n    POP             = '0',\n    POP_MARK        = '1',\n    DUP             = '2',\n    FLOAT           = 'F',\n    INT             = 'I',\n    BININT          = 'J',\n    BININT1         = 'K',\n    LONG            = 'L',\n    BININT2         = 'M',\n    NONE            = 'N',\n    PERSID          = 'P',\n    BINPERSID       = 'Q',\n    REDUCE          = 'R',\n    STRING          = 'S',\n    BINSTRING       = 'T',\n    SHORT_BINSTRING = 'U',\n    UNICODE         = 'V',\n    BINUNICODE      = 'X',\n    APPEND          = 'a',\n    BUILD           = 'b',\n    GLOBAL          = 'c',\n    DICT            = 'd',\n    EMPTY_DICT      = '}',\n    APPENDS         = 'e',\n    GET             = 'g',\n    BINGET          = 'h',\n    INST            = 'i',\n    LONG_BINGET     = 'j',\n    LIST            = 'l',\n    EMPTY_LIST      = ']',\n    OBJ             = 'o',\n    PUT             = 'p',\n    BINPUT          = 'q',\n    LONG_BINPUT     = 'r',\n    SETITEM         = 's',\n    TUPLE           = 't',\n    EMPTY_TUPLE     = ')',\n    SETITEMS        = 'u',\n    BINFLOAT        = 'G',\n\n    /* Protocol 2. */\n    PROTO       = '\\x80',\n    NEWOBJ      = '\\x81',\n    EXT1        = '\\x82',\n    EXT2        = '\\x83',\n    EXT4        = '\\x84',\n    TUPLE1      = '\\x85',\n    TUPLE2      = '\\x86',\n    TUPLE3      = '\\x87',\n    NEWTRUE     = '\\x88',\n    NEWFALSE    = '\\x89',\n    LONG1       = '\\x8a',\n    LONG4       = '\\x8b',\n\n    /* Protocol 3 (Python 3.x) */\n    BINBYTES       = 'B',\n    SHORT_BINBYTES = 'C',\n\n    /* Protocol 4 */\n    SHORT_BINUNICODE = '\\x8c',\n    BINUNICODE8      = '\\x8d',\n    BINBYTES8        = '\\x8e',\n    EMPTY_SET        = '\\x8f',\n    ADDITEMS         = '\\x90',\n    FROZENSET        = '\\x91',\n    NEWOBJ_EX        = '\\x92',\n    STACK_GLOBAL     = '\\x93',\n    MEMOIZE          = '\\x94',\n    FRAME            = '\\x95'\n};\n\nenum {\n   /* Keep in synch with pickle.Pickler._BATCHSIZE.  This is how many elements\n      batch_list/dict() pumps out before doing APPENDS/SETITEMS.  Nothing will\n      break if this gets out of synch with pickle.py, but it's unclear that would\n      help anything either. */\n    BATCHSIZE = 1000,\n\n    /* Nesting limit until Pickler, when running in \"fast mode\", starts\n       checking for self-referential data-structures. */\n    FAST_NESTING_LIMIT = 50,\n\n    /* Initial size of the write buffer of Pickler. */\n    WRITE_BUF_SIZE = 4096,\n\n    /* Prefetch size when unpickling (disabled on unpeekable streams) */\n    PREFETCH = 8192 * 16,\n\n    FRAME_SIZE_MIN = 4,\n    FRAME_SIZE_TARGET = 64 * 1024,\n    FRAME_HEADER_SIZE = 9\n};\n\n/*************************************************************************/\n\n/* State of the pickle module, per PEP 3121. */\ntypedef struct {\n    /* Exception classes for pickle. */\n    PyObject *PickleError;\n    PyObject *PicklingError;\n    PyObject *UnpicklingError;\n\n    /* copyreg.dispatch_table, {type_object: pickling_function} */\n    PyObject *dispatch_table;\n\n    /* For the extension opcodes EXT1, EXT2 and EXT4. */\n\n    /* copyreg._extension_registry, {(module_name, function_name): code} */\n    PyObject *extension_registry;\n    /* copyreg._extension_cache, {code: object} */\n    PyObject *extension_cache;\n    /* copyreg._inverted_registry, {code: (module_name, function_name)} */\n    PyObject *inverted_registry;\n\n    /* Import mappings for compatibility with Python 2.x */\n\n    /* _compat_pickle.NAME_MAPPING,\n       {(oldmodule, oldname): (newmodule, newname)} */\n    PyObject *name_mapping_2to3;\n    /* _compat_pickle.IMPORT_MAPPING, {oldmodule: newmodule} */\n    PyObject *import_mapping_2to3;\n    /* Same, but with REVERSE_NAME_MAPPING / REVERSE_IMPORT_MAPPING */\n    PyObject *name_mapping_3to2;\n    PyObject *import_mapping_3to2;\n\n    /* codecs.encode, used for saving bytes in older protocols */\n    PyObject *codecs_encode;\n    /* builtins.getattr, used for saving nested names with protocol < 4 */\n    PyObject *getattr;\n    /* functools.partial, used for implementing __newobj_ex__ with protocols\n       2 and 3 */\n    PyObject *partial;\n} PickleState;\n\n/* Forward declaration of the _pickle module definition. */\nstatic struct PyModuleDef _picklemodule;\n\n/* Given a module object, get its per-module state. */\nstatic PickleState *\n_Pickle_GetState(PyObject *module)\n{\n    return (PickleState *)PyModule_GetState(module);\n}\n\n/* Find the module instance imported in the currently running sub-interpreter\n   and get its state. */\nstatic PickleState *\n_Pickle_GetGlobalState(void)\n{\n    return _Pickle_GetState(PyState_FindModule(&_picklemodule));\n}\n\n/* Clear the given pickle module state. */\nstatic void\n_Pickle_ClearState(PickleState *st)\n{\n    Py_CLEAR(st->PickleError);\n    Py_CLEAR(st->PicklingError);\n    Py_CLEAR(st->UnpicklingError);\n    Py_CLEAR(st->dispatch_table);\n    Py_CLEAR(st->extension_registry);\n    Py_CLEAR(st->extension_cache);\n    Py_CLEAR(st->inverted_registry);\n    Py_CLEAR(st->name_mapping_2to3);\n    Py_CLEAR(st->import_mapping_2to3);\n    Py_CLEAR(st->name_mapping_3to2);\n    Py_CLEAR(st->import_mapping_3to2);\n    Py_CLEAR(st->codecs_encode);\n    Py_CLEAR(st->getattr);\n    Py_CLEAR(st->partial);\n}\n\n/* Initialize the given pickle module state. */\nstatic int\n_Pickle_InitState(PickleState *st)\n{\n    PyObject *builtins;\n    PyObject *copyreg = NULL;\n    PyObject *compat_pickle = NULL;\n    PyObject *codecs = NULL;\n    PyObject *functools = NULL;\n\n    builtins = PyEval_GetBuiltins();\n    if (builtins == NULL)\n        goto error;\n    st->getattr = PyDict_GetItemString(builtins, \"getattr\");\n    if (st->getattr == NULL)\n        goto error;\n    Py_INCREF(st->getattr);\n\n    copyreg = PyImport_ImportModule(\"copyreg\");\n    if (!copyreg)\n        goto error;\n    st->dispatch_table = PyObject_GetAttrString(copyreg, \"dispatch_table\");\n    if (!st->dispatch_table)\n        goto error;\n    if (!PyDict_CheckExact(st->dispatch_table)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"copyreg.dispatch_table should be a dict, not %.200s\",\n                     Py_TYPE(st->dispatch_table)->tp_name);\n        goto error;\n    }\n    st->extension_registry = \\\n        PyObject_GetAttrString(copyreg, \"_extension_registry\");\n    if (!st->extension_registry)\n        goto error;\n    if (!PyDict_CheckExact(st->extension_registry)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"copyreg._extension_registry should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->extension_registry)->tp_name);\n        goto error;\n    }\n    st->inverted_registry = \\\n        PyObject_GetAttrString(copyreg, \"_inverted_registry\");\n    if (!st->inverted_registry)\n        goto error;\n    if (!PyDict_CheckExact(st->inverted_registry)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"copyreg._inverted_registry should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->inverted_registry)->tp_name);\n        goto error;\n    }\n    st->extension_cache = PyObject_GetAttrString(copyreg, \"_extension_cache\");\n    if (!st->extension_cache)\n        goto error;\n    if (!PyDict_CheckExact(st->extension_cache)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"copyreg._extension_cache should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->extension_cache)->tp_name);\n        goto error;\n    }\n    Py_CLEAR(copyreg);\n\n    /* Load the 2.x -> 3.x stdlib module mapping tables */\n    compat_pickle = PyImport_ImportModule(\"_compat_pickle\");\n    if (!compat_pickle)\n        goto error;\n    st->name_mapping_2to3 = \\\n        PyObject_GetAttrString(compat_pickle, \"NAME_MAPPING\");\n    if (!st->name_mapping_2to3)\n        goto error;\n    if (!PyDict_CheckExact(st->name_mapping_2to3)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"_compat_pickle.NAME_MAPPING should be a dict, not %.200s\",\n                     Py_TYPE(st->name_mapping_2to3)->tp_name);\n        goto error;\n    }\n    st->import_mapping_2to3 = \\\n        PyObject_GetAttrString(compat_pickle, \"IMPORT_MAPPING\");\n    if (!st->import_mapping_2to3)\n        goto error;\n    if (!PyDict_CheckExact(st->import_mapping_2to3)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"_compat_pickle.IMPORT_MAPPING should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->import_mapping_2to3)->tp_name);\n        goto error;\n    }\n    /* ... and the 3.x -> 2.x mapping tables */\n    st->name_mapping_3to2 = \\\n        PyObject_GetAttrString(compat_pickle, \"REVERSE_NAME_MAPPING\");\n    if (!st->name_mapping_3to2)\n        goto error;\n    if (!PyDict_CheckExact(st->name_mapping_3to2)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"_compat_pickle.REVERSE_NAME_MAPPING should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->name_mapping_3to2)->tp_name);\n        goto error;\n    }\n    st->import_mapping_3to2 = \\\n        PyObject_GetAttrString(compat_pickle, \"REVERSE_IMPORT_MAPPING\");\n    if (!st->import_mapping_3to2)\n        goto error;\n    if (!PyDict_CheckExact(st->import_mapping_3to2)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"_compat_pickle.REVERSE_IMPORT_MAPPING should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->import_mapping_3to2)->tp_name);\n        goto error;\n    }\n    Py_CLEAR(compat_pickle);\n\n    codecs = PyImport_ImportModule(\"codecs\");\n    if (codecs == NULL)\n        goto error;\n    st->codecs_encode = PyObject_GetAttrString(codecs, \"encode\");\n    if (st->codecs_encode == NULL) {\n        goto error;\n    }\n    if (!PyCallable_Check(st->codecs_encode)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"codecs.encode should be a callable, not %.200s\",\n                     Py_TYPE(st->codecs_encode)->tp_name);\n        goto error;\n    }\n    Py_CLEAR(codecs);\n\n    functools = PyImport_ImportModule(\"functools\");\n    if (!functools)\n        goto error;\n    st->partial = PyObject_GetAttrString(functools, \"partial\");\n    if (!st->partial)\n        goto error;\n    Py_CLEAR(functools);\n\n    return 0;\n\n  error:\n    Py_CLEAR(copyreg);\n    Py_CLEAR(compat_pickle);\n    Py_CLEAR(codecs);\n    Py_CLEAR(functools);\n    _Pickle_ClearState(st);\n    return -1;\n}\n\n/* Helper for calling a function with a single argument quickly.\n\n   This function steals the reference of the given argument. */\nstatic PyObject *\n_Pickle_FastCall(PyObject *func, PyObject *obj)\n{\n    PyObject *result;\n\n    result = PyObject_CallFunctionObjArgs(func, obj, NULL);\n    Py_DECREF(obj);\n    return result;\n}\n\n/*************************************************************************/\n\n/* Retrieve and deconstruct a method for avoiding a reference cycle\n   (pickler -> bound method of pickler -> pickler) */\nstatic int\ninit_method_ref(PyObject *self, _Py_Identifier *name,\n                PyObject **method_func, PyObject **method_self)\n{\n    PyObject *func, *func2;\n    int ret;\n\n    /* *method_func and *method_self should be consistent.  All refcount decrements\n       should be occurred after setting *method_self and *method_func. */\n    ret = _PyObject_LookupAttrId(self, name, &func);\n    if (func == NULL) {\n        *method_self = NULL;\n        Py_CLEAR(*method_func);\n        return ret;\n    }\n\n    if (PyMethod_Check(func) && PyMethod_GET_SELF(func) == self) {\n        /* Deconstruct a bound Python method */\n        func2 = PyMethod_GET_FUNCTION(func);\n        Py_INCREF(func2);\n        *method_self = self; /* borrowed */\n        Py_XSETREF(*method_func, func2);\n        Py_DECREF(func);\n        return 0;\n    }\n    else {\n        *method_self = NULL;\n        Py_XSETREF(*method_func, func);\n        return 0;\n    }\n}\n\n/* Bind a method if it was deconstructed */\nstatic PyObject *\nreconstruct_method(PyObject *func, PyObject *self)\n{\n    if (self) {\n        return PyMethod_New(func, self);\n    }\n    else {\n        Py_INCREF(func);\n        return func;\n    }\n}\n\nstatic PyObject *\ncall_method(PyObject *func, PyObject *self, PyObject *obj)\n{\n    if (self) {\n        return PyObject_CallFunctionObjArgs(func, self, obj, NULL);\n    }\n    else {\n        return PyObject_CallFunctionObjArgs(func, obj, NULL);\n    }\n}\n\n/*************************************************************************/\n\n/* Internal data type used as the unpickling stack. */\ntypedef struct {\n    PyObject_VAR_HEAD\n    PyObject **data;\n    int mark_set;          /* is MARK set? */\n    Py_ssize_t fence;      /* position of top MARK or 0 */\n    Py_ssize_t allocated;  /* number of slots in data allocated */\n} Pdata;\n\nstatic void\nPdata_dealloc(Pdata *self)\n{\n    Py_ssize_t i = Py_SIZE(self);\n    while (--i >= 0) {\n        Py_DECREF(self->data[i]);\n    }\n    PyMem_FREE(self->data);\n    PyObject_Del(self);\n}\n\nstatic PyTypeObject Pdata_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.Pdata\",              /*tp_name*/\n    sizeof(Pdata),                /*tp_basicsize*/\n    sizeof(PyObject *),           /*tp_itemsize*/\n    (destructor)Pdata_dealloc,    /*tp_dealloc*/\n};\n\nstatic PyObject *\nPdata_New(void)\n{\n    Pdata *self;\n\n    if (!(self = PyObject_New(Pdata, &Pdata_Type)))\n        return NULL;\n    Py_SIZE(self) = 0;\n    self->mark_set = 0;\n    self->fence = 0;\n    self->allocated = 8;\n    self->data = PyMem_MALLOC(self->allocated * sizeof(PyObject *));\n    if (self->data)\n        return (PyObject *)self;\n    Py_DECREF(self);\n    return PyErr_NoMemory();\n}\n\n\n/* Retain only the initial clearto items.  If clearto >= the current\n * number of items, this is a (non-erroneous) NOP.\n */\nstatic int\nPdata_clear(Pdata *self, Py_ssize_t clearto)\n{\n    Py_ssize_t i = Py_SIZE(self);\n\n    assert(clearto >= self->fence);\n    if (clearto >= i)\n        return 0;\n\n    while (--i >= clearto) {\n        Py_CLEAR(self->data[i]);\n    }\n    Py_SIZE(self) = clearto;\n    return 0;\n}\n\nstatic int\nPdata_grow(Pdata *self)\n{\n    PyObject **data = self->data;\n    size_t allocated = (size_t)self->allocated;\n    size_t new_allocated;\n\n    new_allocated = (allocated >> 3) + 6;\n    /* check for integer overflow */\n    if (new_allocated > (size_t)PY_SSIZE_T_MAX - allocated)\n        goto nomemory;\n    new_allocated += allocated;\n    PyMem_RESIZE(data, PyObject *, new_allocated);\n    if (data == NULL)\n        goto nomemory;\n\n    self->data = data;\n    self->allocated = (Py_ssize_t)new_allocated;\n    return 0;\n\n  nomemory:\n    PyErr_NoMemory();\n    return -1;\n}\n\nstatic int\nPdata_stack_underflow(Pdata *self)\n{\n    PickleState *st = _Pickle_GetGlobalState();\n    PyErr_SetString(st->UnpicklingError,\n                    self->mark_set ?\n                    \"unexpected MARK found\" :\n                    \"unpickling stack underflow\");\n    return -1;\n}\n\n/* D is a Pdata*.  Pop the topmost element and store it into V, which\n * must be an lvalue holding PyObject*.  On stack underflow, UnpicklingError\n * is raised and V is set to NULL.\n */\nstatic PyObject *\nPdata_pop(Pdata *self)\n{\n    if (Py_SIZE(self) <= self->fence) {\n        Pdata_stack_underflow(self);\n        return NULL;\n    }\n    return self->data[--Py_SIZE(self)];\n}\n#define PDATA_POP(D, V) do { (V) = Pdata_pop((D)); } while (0)\n\nstatic int\nPdata_push(Pdata *self, PyObject *obj)\n{\n    if (Py_SIZE(self) == self->allocated && Pdata_grow(self) < 0) {\n        return -1;\n    }\n    self->data[Py_SIZE(self)++] = obj;\n    return 0;\n}\n\n/* Push an object on stack, transferring its ownership to the stack. */\n#define PDATA_PUSH(D, O, ER) do {                               \\\n        if (Pdata_push((D), (O)) < 0) return (ER); } while(0)\n\n/* Push an object on stack, adding a new reference to the object. */\n#define PDATA_APPEND(D, O, ER) do {                             \\\n        Py_INCREF((O));                                         \\\n        if (Pdata_push((D), (O)) < 0) return (ER); } while(0)\n\nstatic PyObject *\nPdata_poptuple(Pdata *self, Py_ssize_t start)\n{\n    PyObject *tuple;\n    Py_ssize_t len, i, j;\n\n    if (start < self->fence) {\n        Pdata_stack_underflow(self);\n        return NULL;\n    }\n    len = Py_SIZE(self) - start;\n    tuple = PyTuple_New(len);\n    if (tuple == NULL)\n        return NULL;\n    for (i = start, j = 0; j < len; i++, j++)\n        PyTuple_SET_ITEM(tuple, j, self->data[i]);\n\n    Py_SIZE(self) = start;\n    return tuple;\n}\n\nstatic PyObject *\nPdata_poplist(Pdata *self, Py_ssize_t start)\n{\n    PyObject *list;\n    Py_ssize_t len, i, j;\n\n    len = Py_SIZE(self) - start;\n    list = PyList_New(len);\n    if (list == NULL)\n        return NULL;\n    for (i = start, j = 0; j < len; i++, j++)\n        PyList_SET_ITEM(list, j, self->data[i]);\n\n    Py_SIZE(self) = start;\n    return list;\n}\n\ntypedef struct {\n    PyObject *me_key;\n    Py_ssize_t me_value;\n} PyMemoEntry;\n\ntypedef struct {\n    Py_ssize_t mt_mask;\n    Py_ssize_t mt_used;\n    Py_ssize_t mt_allocated;\n    PyMemoEntry *mt_table;\n} PyMemoTable;\n\ntypedef struct PicklerObject {\n    PyObject_HEAD\n    PyMemoTable *memo;          /* Memo table, keep track of the seen\n                                   objects to support self-referential objects\n                                   pickling. */\n    PyObject *pers_func;        /* persistent_id() method, can be NULL */\n    PyObject *pers_func_self;   /* borrowed reference to self if pers_func\n                                   is an unbound method, NULL otherwise */\n    PyObject *dispatch_table;   /* private dispatch_table, can be NULL */\n\n    PyObject *write;            /* write() method of the output stream. */\n    PyObject *output_buffer;    /* Write into a local bytearray buffer before\n                                   flushing to the stream. */\n    Py_ssize_t output_len;      /* Length of output_buffer. */\n    Py_ssize_t max_output_len;  /* Allocation size of output_buffer. */\n    int proto;                  /* Pickle protocol number, >= 0 */\n    int bin;                    /* Boolean, true if proto > 0 */\n    int framing;                /* True when framing is enabled, proto >= 4 */\n    Py_ssize_t frame_start;     /* Position in output_buffer where the\n                                   current frame begins. -1 if there\n                                   is no frame currently open. */\n\n    Py_ssize_t buf_size;        /* Size of the current buffered pickle data */\n    int fast;                   /* Enable fast mode if set to a true value.\n                                   The fast mode disable the usage of memo,\n                                   therefore speeding the pickling process by\n                                   not generating superfluous PUT opcodes. It\n                                   should not be used if with self-referential\n                                   objects. */\n    int fast_nesting;\n    int fix_imports;            /* Indicate whether Pickler should fix\n                                   the name of globals for Python 2.x. */\n    PyObject *fast_memo;\n} PicklerObject;\n\ntypedef struct UnpicklerObject {\n    PyObject_HEAD\n    Pdata *stack;               /* Pickle data stack, store unpickled objects. */\n\n    /* The unpickler memo is just an array of PyObject *s. Using a dict\n       is unnecessary, since the keys are contiguous ints. */\n    PyObject **memo;\n    Py_ssize_t memo_size;       /* Capacity of the memo array */\n    Py_ssize_t memo_len;        /* Number of objects in the memo */\n\n    PyObject *pers_func;        /* persistent_load() method, can be NULL. */\n    PyObject *pers_func_self;   /* borrowed reference to self if pers_func\n                                   is an unbound method, NULL otherwise */\n\n    Py_buffer buffer;\n    char *input_buffer;\n    char *input_line;\n    Py_ssize_t input_len;\n    Py_ssize_t next_read_idx;\n    Py_ssize_t prefetched_idx;  /* index of first prefetched byte */\n\n    PyObject *read;             /* read() method of the input stream. */\n    PyObject *readline;         /* readline() method of the input stream. */\n    PyObject *peek;             /* peek() method of the input stream, or NULL */\n\n    char *encoding;             /* Name of the encoding to be used for\n                                   decoding strings pickled using Python\n                                   2.x. The default value is \"ASCII\" */\n    char *errors;               /* Name of errors handling scheme to used when\n                                   decoding strings. The default value is\n                                   \"strict\". */\n    Py_ssize_t *marks;          /* Mark stack, used for unpickling container\n                                   objects. */\n    Py_ssize_t num_marks;       /* Number of marks in the mark stack. */\n    Py_ssize_t marks_size;      /* Current allocated size of the mark stack. */\n    int proto;                  /* Protocol of the pickle loaded. */\n    int fix_imports;            /* Indicate whether Unpickler should fix\n                                   the name of globals pickled by Python 2.x. */\n} UnpicklerObject;\n\ntypedef struct {\n    PyObject_HEAD\n    PicklerObject *pickler; /* Pickler whose memo table we're proxying. */\n}  PicklerMemoProxyObject;\n\ntypedef struct {\n    PyObject_HEAD\n    UnpicklerObject *unpickler;\n} UnpicklerMemoProxyObject;\n\n/* Forward declarations */\nstatic int save(PicklerObject *, PyObject *, int);\nstatic int save_reduce(PicklerObject *, PyObject *, PyObject *);\nstatic PyTypeObject Pickler_Type;\nstatic PyTypeObject Unpickler_Type;\n\n#include \"clinic/_pickle.c.h\"\n\n/*************************************************************************\n A custom hashtable mapping void* to Python ints. This is used by the pickler\n for memoization. Using a custom hashtable rather than PyDict allows us to skip\n a bunch of unnecessary object creation. This makes a huge performance\n difference. */\n\n#define MT_MINSIZE 8\n#define PERTURB_SHIFT 5\n\n\nstatic PyMemoTable *\nPyMemoTable_New(void)\n{\n    PyMemoTable *memo = PyMem_MALLOC(sizeof(PyMemoTable));\n    if (memo == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    memo->mt_used = 0;\n    memo->mt_allocated = MT_MINSIZE;\n    memo->mt_mask = MT_MINSIZE - 1;\n    memo->mt_table = PyMem_MALLOC(MT_MINSIZE * sizeof(PyMemoEntry));\n    if (memo->mt_table == NULL) {\n        PyMem_FREE(memo);\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset(memo->mt_table, 0, MT_MINSIZE * sizeof(PyMemoEntry));\n\n    return memo;\n}\n\nstatic PyMemoTable *\nPyMemoTable_Copy(PyMemoTable *self)\n{\n    Py_ssize_t i;\n    PyMemoTable *new = PyMemoTable_New();\n    if (new == NULL)\n        return NULL;\n\n    new->mt_used = self->mt_used;\n    new->mt_allocated = self->mt_allocated;\n    new->mt_mask = self->mt_mask;\n    /* The table we get from _New() is probably smaller than we wanted.\n       Free it and allocate one that's the right size. */\n    PyMem_FREE(new->mt_table);\n    new->mt_table = PyMem_NEW(PyMemoEntry, self->mt_allocated);\n    if (new->mt_table == NULL) {\n        PyMem_FREE(new);\n        PyErr_NoMemory();\n        return NULL;\n    }\n    for (i = 0; i < self->mt_allocated; i++) {\n        Py_XINCREF(self->mt_table[i].me_key);\n    }\n    memcpy(new->mt_table, self->mt_table,\n           sizeof(PyMemoEntry) * self->mt_allocated);\n\n    return new;\n}\n\nstatic Py_ssize_t\nPyMemoTable_Size(PyMemoTable *self)\n{\n    return self->mt_used;\n}\n\nstatic int\nPyMemoTable_Clear(PyMemoTable *self)\n{\n    Py_ssize_t i = self->mt_allocated;\n\n    while (--i >= 0) {\n        Py_XDECREF(self->mt_table[i].me_key);\n    }\n    self->mt_used = 0;\n    memset(self->mt_table, 0, self->mt_allocated * sizeof(PyMemoEntry));\n    return 0;\n}\n\nstatic void\nPyMemoTable_Del(PyMemoTable *self)\n{\n    if (self == NULL)\n        return;\n    PyMemoTable_Clear(self);\n\n    PyMem_FREE(self->mt_table);\n    PyMem_FREE(self);\n}\n\n/* Since entries cannot be deleted from this hashtable, _PyMemoTable_Lookup()\n   can be considerably simpler than dictobject.c's lookdict(). */\nstatic PyMemoEntry *\n_PyMemoTable_Lookup(PyMemoTable *self, PyObject *key)\n{\n    size_t i;\n    size_t perturb;\n    size_t mask = (size_t)self->mt_mask;\n    PyMemoEntry *table = self->mt_table;\n    PyMemoEntry *entry;\n    Py_hash_t hash = (Py_hash_t)key >> 3;\n\n    i = hash & mask;\n    entry = &table[i];\n    if (entry->me_key == NULL || entry->me_key == key)\n        return entry;\n\n    for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {\n        i = (i << 2) + i + perturb + 1;\n        entry = &table[i & mask];\n        if (entry->me_key == NULL || entry->me_key == key)\n            return entry;\n    }\n    Py_UNREACHABLE();\n}\n\n/* Returns -1 on failure, 0 on success. */\nstatic int\n_PyMemoTable_ResizeTable(PyMemoTable *self, Py_ssize_t min_size)\n{\n    PyMemoEntry *oldtable = NULL;\n    PyMemoEntry *oldentry, *newentry;\n    Py_ssize_t new_size = MT_MINSIZE;\n    Py_ssize_t to_process;\n\n    assert(min_size > 0);\n\n    /* Find the smallest valid table size >= min_size. */\n    while (new_size < min_size && new_size > 0)\n        new_size <<= 1;\n    if (new_size <= 0) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    /* new_size needs to be a power of two. */\n    assert((new_size & (new_size - 1)) == 0);\n\n    /* Allocate new table. */\n    oldtable = self->mt_table;\n    self->mt_table = PyMem_NEW(PyMemoEntry, new_size);\n    if (self->mt_table == NULL) {\n        self->mt_table = oldtable;\n        PyErr_NoMemory();\n        return -1;\n    }\n    self->mt_allocated = new_size;\n    self->mt_mask = new_size - 1;\n    memset(self->mt_table, 0, sizeof(PyMemoEntry) * new_size);\n\n    /* Copy entries from the old table. */\n    to_process = self->mt_used;\n    for (oldentry = oldtable; to_process > 0; oldentry++) {\n        if (oldentry->me_key != NULL) {\n            to_process--;\n            /* newentry is a pointer to a chunk of the new\n               mt_table, so we're setting the key:value pair\n               in-place. */\n            newentry = _PyMemoTable_Lookup(self, oldentry->me_key);\n            newentry->me_key = oldentry->me_key;\n            newentry->me_value = oldentry->me_value;\n        }\n    }\n\n    /* Deallocate the old table. */\n    PyMem_FREE(oldtable);\n    return 0;\n}\n\n/* Returns NULL on failure, a pointer to the value otherwise. */\nstatic Py_ssize_t *\nPyMemoTable_Get(PyMemoTable *self, PyObject *key)\n{\n    PyMemoEntry *entry = _PyMemoTable_Lookup(self, key);\n    if (entry->me_key == NULL)\n        return NULL;\n    return &entry->me_value;\n}\n\n/* Returns -1 on failure, 0 on success. */\nstatic int\nPyMemoTable_Set(PyMemoTable *self, PyObject *key, Py_ssize_t value)\n{\n    PyMemoEntry *entry;\n\n    assert(key != NULL);\n\n    entry = _PyMemoTable_Lookup(self, key);\n    if (entry->me_key != NULL) {\n        entry->me_value = value;\n        return 0;\n    }\n    Py_INCREF(key);\n    entry->me_key = key;\n    entry->me_value = value;\n    self->mt_used++;\n\n    /* If we added a key, we can safely resize. Otherwise just return!\n     * If used >= 2/3 size, adjust size. Normally, this quaduples the size.\n     *\n     * Quadrupling the size improves average table sparseness\n     * (reducing collisions) at the cost of some memory. It also halves\n     * the number of expensive resize operations in a growing memo table.\n     *\n     * Very large memo tables (over 50K items) use doubling instead.\n     * This may help applications with severe memory constraints.\n     */\n    if (!(self->mt_used * 3 >= (self->mt_mask + 1) * 2))\n        return 0;\n    return _PyMemoTable_ResizeTable(self,\n        (self->mt_used > 50000 ? 2 : 4) * self->mt_used);\n}\n\n#undef MT_MINSIZE\n#undef PERTURB_SHIFT\n\n/*************************************************************************/\n\n\nstatic int\n_Pickler_ClearBuffer(PicklerObject *self)\n{\n    Py_XSETREF(self->output_buffer,\n              PyBytes_FromStringAndSize(NULL, self->max_output_len));\n    if (self->output_buffer == NULL)\n        return -1;\n    self->output_len = 0;\n    self->frame_start = -1;\n    return 0;\n}\n\nstatic void\n_write_size64(char *out, size_t value)\n{\n    size_t i;\n\n    Py_BUILD_ASSERT(sizeof(size_t) <= 8);\n\n    for (i = 0; i < sizeof(size_t); i++) {\n        out[i] = (unsigned char)((value >> (8 * i)) & 0xff);\n    }\n    for (i = sizeof(size_t); i < 8; i++) {\n        out[i] = 0;\n    }\n}\n\nstatic int\n_Pickler_CommitFrame(PicklerObject *self)\n{\n    size_t frame_len;\n    char *qdata;\n\n    if (!self->framing || self->frame_start == -1)\n        return 0;\n    frame_len = self->output_len - self->frame_start - FRAME_HEADER_SIZE;\n    qdata = PyBytes_AS_STRING(self->output_buffer) + self->frame_start;\n    if (frame_len >= FRAME_SIZE_MIN) {\n        qdata[0] = FRAME;\n        _write_size64(qdata + 1, frame_len);\n    }\n    else {\n        memmove(qdata, qdata + FRAME_HEADER_SIZE, frame_len);\n        self->output_len -= FRAME_HEADER_SIZE;\n    }\n    self->frame_start = -1;\n    return 0;\n}\n\nstatic PyObject *\n_Pickler_GetString(PicklerObject *self)\n{\n    PyObject *output_buffer = self->output_buffer;\n\n    assert(self->output_buffer != NULL);\n\n    if (_Pickler_CommitFrame(self))\n        return NULL;\n\n    self->output_buffer = NULL;\n    /* Resize down to exact size */\n    if (_PyBytes_Resize(&output_buffer, self->output_len) < 0)\n        return NULL;\n    return output_buffer;\n}\n\nstatic int\n_Pickler_FlushToFile(PicklerObject *self)\n{\n    PyObject *output, *result;\n\n    assert(self->write != NULL);\n\n    /* This will commit the frame first */\n    output = _Pickler_GetString(self);\n    if (output == NULL)\n        return -1;\n\n    result = _Pickle_FastCall(self->write, output);\n    Py_XDECREF(result);\n    return (result == NULL) ? -1 : 0;\n}\n\nstatic int\n_Pickler_OpcodeBoundary(PicklerObject *self)\n{\n    Py_ssize_t frame_len;\n\n    if (!self->framing || self->frame_start == -1) {\n        return 0;\n    }\n    frame_len = self->output_len - self->frame_start - FRAME_HEADER_SIZE;\n    if (frame_len >= FRAME_SIZE_TARGET) {\n        if(_Pickler_CommitFrame(self)) {\n            return -1;\n        }\n        /* Flush the content of the committed frame to the underlying\n         * file and reuse the pickler buffer for the next frame so as\n         * to limit memory usage when dumping large complex objects to\n         * a file.\n         *\n         * self->write is NULL when called via dumps.\n         */\n        if (self->write != NULL) {\n            if (_Pickler_FlushToFile(self) < 0) {\n                return -1;\n            }\n            if (_Pickler_ClearBuffer(self) < 0) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic Py_ssize_t\n_Pickler_Write(PicklerObject *self, const char *s, Py_ssize_t data_len)\n{\n    Py_ssize_t i, n, required;\n    char *buffer;\n    int need_new_frame;\n\n    assert(s != NULL);\n    need_new_frame = (self->framing && self->frame_start == -1);\n\n    if (need_new_frame)\n        n = data_len + FRAME_HEADER_SIZE;\n    else\n        n = data_len;\n\n    required = self->output_len + n;\n    if (required > self->max_output_len) {\n        /* Make place in buffer for the pickle chunk */\n        if (self->output_len >= PY_SSIZE_T_MAX / 2 - n) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        self->max_output_len = (self->output_len + n) / 2 * 3;\n        if (_PyBytes_Resize(&self->output_buffer, self->max_output_len) < 0)\n            return -1;\n    }\n    buffer = PyBytes_AS_STRING(self->output_buffer);\n    if (need_new_frame) {\n        /* Setup new frame */\n        Py_ssize_t frame_start = self->output_len;\n        self->frame_start = frame_start;\n        for (i = 0; i < FRAME_HEADER_SIZE; i++) {\n            /* Write an invalid value, for debugging */\n            buffer[frame_start + i] = 0xFE;\n        }\n        self->output_len += FRAME_HEADER_SIZE;\n    }\n    if (data_len < 8) {\n        /* This is faster than memcpy when the string is short. */\n        for (i = 0; i < data_len; i++) {\n            buffer[self->output_len + i] = s[i];\n        }\n    }\n    else {\n        memcpy(buffer + self->output_len, s, data_len);\n    }\n    self->output_len += data_len;\n    return data_len;\n}\n\nstatic PicklerObject *\n_Pickler_New(void)\n{\n    PicklerObject *self;\n\n    self = PyObject_GC_New(PicklerObject, &Pickler_Type);\n    if (self == NULL)\n        return NULL;\n\n    self->pers_func = NULL;\n    self->dispatch_table = NULL;\n    self->write = NULL;\n    self->proto = 0;\n    self->bin = 0;\n    self->framing = 0;\n    self->frame_start = -1;\n    self->fast = 0;\n    self->fast_nesting = 0;\n    self->fix_imports = 0;\n    self->fast_memo = NULL;\n    self->max_output_len = WRITE_BUF_SIZE;\n    self->output_len = 0;\n\n    self->memo = PyMemoTable_New();\n    self->output_buffer = PyBytes_FromStringAndSize(NULL,\n                                                    self->max_output_len);\n\n    if (self->memo == NULL || self->output_buffer == NULL) {\n        Py_DECREF(self);\n        return NULL;\n    }\n    return self;\n}\n\nstatic int\n_Pickler_SetProtocol(PicklerObject *self, PyObject *protocol, int fix_imports)\n{\n    long proto;\n\n    if (protocol == NULL || protocol == Py_None) {\n        proto = DEFAULT_PROTOCOL;\n    }\n    else {\n        proto = PyLong_AsLong(protocol);\n        if (proto < 0) {\n            if (proto == -1 && PyErr_Occurred())\n                return -1;\n            proto = HIGHEST_PROTOCOL;\n        }\n        else if (proto > HIGHEST_PROTOCOL) {\n            PyErr_Format(PyExc_ValueError, \"pickle protocol must be <= %d\",\n                         HIGHEST_PROTOCOL);\n            return -1;\n        }\n    }\n    self->proto = (int)proto;\n    self->bin = proto > 0;\n    self->fix_imports = fix_imports && proto < 3;\n    return 0;\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success. This may\n   be called once on a freshly created Pickler. */\nstatic int\n_Pickler_SetOutputStream(PicklerObject *self, PyObject *file)\n{\n    _Py_IDENTIFIER(write);\n    assert(file != NULL);\n    if (_PyObject_LookupAttrId(file, &PyId_write, &self->write) < 0) {\n        return -1;\n    }\n    if (self->write == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"file must have a 'write' attribute\");\n        return -1;\n    }\n\n    return 0;\n}\n\n/* Returns the size of the input on success, -1 on failure. This takes its\n   own reference to `input`. */\nstatic Py_ssize_t\n_Unpickler_SetStringInput(UnpicklerObject *self, PyObject *input)\n{\n    if (self->buffer.buf != NULL)\n        PyBuffer_Release(&self->buffer);\n    if (PyObject_GetBuffer(input, &self->buffer, PyBUF_CONTIG_RO) < 0)\n        return -1;\n    self->input_buffer = self->buffer.buf;\n    self->input_len = self->buffer.len;\n    self->next_read_idx = 0;\n    self->prefetched_idx = self->input_len;\n    return self->input_len;\n}\n\nstatic int\nbad_readline(void)\n{\n    PickleState *st = _Pickle_GetGlobalState();\n    PyErr_SetString(st->UnpicklingError, \"pickle data was truncated\");\n    return -1;\n}\n\nstatic int\n_Unpickler_SkipConsumed(UnpicklerObject *self)\n{\n    Py_ssize_t consumed;\n    PyObject *r;\n\n    consumed = self->next_read_idx - self->prefetched_idx;\n    if (consumed <= 0)\n        return 0;\n\n    assert(self->peek);  /* otherwise we did something wrong */\n    /* This makes a useless copy... */\n    r = PyObject_CallFunction(self->read, \"n\", consumed);\n    if (r == NULL)\n        return -1;\n    Py_DECREF(r);\n\n    self->prefetched_idx = self->next_read_idx;\n    return 0;\n}\n\nstatic const Py_ssize_t READ_WHOLE_LINE = -1;\n\n/* If reading from a file, we need to only pull the bytes we need, since there\n   may be multiple pickle objects arranged contiguously in the same input\n   buffer.\n\n   If `n` is READ_WHOLE_LINE, read a whole line. Otherwise, read up to `n`\n   bytes from the input stream/buffer.\n\n   Update the unpickler's input buffer with the newly-read data. Returns -1 on\n   failure; on success, returns the number of bytes read from the file.\n\n   On success, self->input_len will be 0; this is intentional so that when\n   unpickling from a file, the \"we've run out of data\" code paths will trigger,\n   causing the Unpickler to go back to the file for more data. Use the returned\n   size to tell you how much data you can process. */\nstatic Py_ssize_t\n_Unpickler_ReadFromFile(UnpicklerObject *self, Py_ssize_t n)\n{\n    PyObject *data;\n    Py_ssize_t read_size;\n\n    assert(self->read != NULL);\n\n    if (_Unpickler_SkipConsumed(self) < 0)\n        return -1;\n\n    if (n == READ_WHOLE_LINE) {\n        data = _PyObject_CallNoArg(self->readline);\n    }\n    else {\n        PyObject *len;\n        /* Prefetch some data without advancing the file pointer, if possible */\n        if (self->peek && n < PREFETCH) {\n            len = PyLong_FromSsize_t(PREFETCH);\n            if (len == NULL)\n                return -1;\n            data = _Pickle_FastCall(self->peek, len);\n            if (data == NULL) {\n                if (!PyErr_ExceptionMatches(PyExc_NotImplementedError))\n                    return -1;\n                /* peek() is probably not supported by the given file object */\n                PyErr_Clear();\n                Py_CLEAR(self->peek);\n            }\n            else {\n                read_size = _Unpickler_SetStringInput(self, data);\n                Py_DECREF(data);\n                self->prefetched_idx = 0;\n                if (n <= read_size)\n                    return n;\n            }\n        }\n        len = PyLong_FromSsize_t(n);\n        if (len == NULL)\n            return -1;\n        data = _Pickle_FastCall(self->read, len);\n    }\n    if (data == NULL)\n        return -1;\n\n    read_size = _Unpickler_SetStringInput(self, data);\n    Py_DECREF(data);\n    return read_size;\n}\n\n/* Don't call it directly: use _Unpickler_Read() */\nstatic Py_ssize_t\n_Unpickler_ReadImpl(UnpicklerObject *self, char **s, Py_ssize_t n)\n{\n    Py_ssize_t num_read;\n\n    *s = NULL;\n    if (self->next_read_idx > PY_SSIZE_T_MAX - n) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError,\n                        \"read would overflow (invalid bytecode)\");\n        return -1;\n    }\n\n    /* This case is handled by the _Unpickler_Read() macro for efficiency */\n    assert(self->next_read_idx + n > self->input_len);\n\n    if (!self->read)\n        return bad_readline();\n\n    num_read = _Unpickler_ReadFromFile(self, n);\n    if (num_read < 0)\n        return -1;\n    if (num_read < n)\n        return bad_readline();\n    *s = self->input_buffer;\n    self->next_read_idx = n;\n    return n;\n}\n\n/* Read `n` bytes from the unpickler's data source, storing the result in `*s`.\n\n   This should be used for all data reads, rather than accessing the unpickler's\n   input buffer directly. This method deals correctly with reading from input\n   streams, which the input buffer doesn't deal with.\n\n   Note that when reading from a file-like object, self->next_read_idx won't\n   be updated (it should remain at 0 for the entire unpickling process). You\n   should use this function's return value to know how many bytes you can\n   consume.\n\n   Returns -1 (with an exception set) on failure. On success, return the\n   number of chars read. */\n#define _Unpickler_Read(self, s, n) \\\n    (((n) <= (self)->input_len - (self)->next_read_idx)      \\\n     ? (*(s) = (self)->input_buffer + (self)->next_read_idx, \\\n        (self)->next_read_idx += (n),                        \\\n        (n))                                                 \\\n     : _Unpickler_ReadImpl(self, (s), (n)))\n\nstatic Py_ssize_t\n_Unpickler_CopyLine(UnpicklerObject *self, char *line, Py_ssize_t len,\n                    char **result)\n{\n    char *input_line = PyMem_Realloc(self->input_line, len + 1);\n    if (input_line == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    memcpy(input_line, line, len);\n    input_line[len] = '\\0';\n    self->input_line = input_line;\n    *result = self->input_line;\n    return len;\n}\n\n/* Read a line from the input stream/buffer. If we run off the end of the input\n   before hitting \\n, raise an error.\n\n   Returns the number of chars read, or -1 on failure. */\nstatic Py_ssize_t\n_Unpickler_Readline(UnpicklerObject *self, char **result)\n{\n    Py_ssize_t i, num_read;\n\n    for (i = self->next_read_idx; i < self->input_len; i++) {\n        if (self->input_buffer[i] == '\\n') {\n            char *line_start = self->input_buffer + self->next_read_idx;\n            num_read = i - self->next_read_idx + 1;\n            self->next_read_idx = i + 1;\n            return _Unpickler_CopyLine(self, line_start, num_read, result);\n        }\n    }\n    if (!self->read)\n        return bad_readline();\n\n    num_read = _Unpickler_ReadFromFile(self, READ_WHOLE_LINE);\n    if (num_read < 0)\n        return -1;\n    if (num_read == 0 || self->input_buffer[num_read - 1] != '\\n')\n        return bad_readline();\n    self->next_read_idx = num_read;\n    return _Unpickler_CopyLine(self, self->input_buffer, num_read, result);\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success. The memo array\n   will be modified in place. */\nstatic int\n_Unpickler_ResizeMemoList(UnpicklerObject *self, Py_ssize_t new_size)\n{\n    Py_ssize_t i;\n\n    assert(new_size > self->memo_size);\n\n    PyObject **memo_new = self->memo;\n    PyMem_RESIZE(memo_new, PyObject *, new_size);\n    if (memo_new == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    self->memo = memo_new;\n    for (i = self->memo_size; i < new_size; i++)\n        self->memo[i] = NULL;\n    self->memo_size = new_size;\n    return 0;\n}\n\n/* Returns NULL if idx is out of bounds. */\nstatic PyObject *\n_Unpickler_MemoGet(UnpicklerObject *self, Py_ssize_t idx)\n{\n    if (idx < 0 || idx >= self->memo_size)\n        return NULL;\n\n    return self->memo[idx];\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success.\n   This takes its own reference to `value`. */\nstatic int\n_Unpickler_MemoPut(UnpicklerObject *self, Py_ssize_t idx, PyObject *value)\n{\n    PyObject *old_item;\n\n    if (idx >= self->memo_size) {\n        if (_Unpickler_ResizeMemoList(self, idx * 2) < 0)\n            return -1;\n        assert(idx < self->memo_size);\n    }\n    Py_INCREF(value);\n    old_item = self->memo[idx];\n    self->memo[idx] = value;\n    if (old_item != NULL) {\n        Py_DECREF(old_item);\n    }\n    else {\n        self->memo_len++;\n    }\n    return 0;\n}\n\nstatic PyObject **\n_Unpickler_NewMemo(Py_ssize_t new_size)\n{\n    PyObject **memo = PyMem_NEW(PyObject *, new_size);\n    if (memo == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset(memo, 0, new_size * sizeof(PyObject *));\n    return memo;\n}\n\n/* Free the unpickler's memo, taking care to decref any items left in it. */\nstatic void\n_Unpickler_MemoCleanup(UnpicklerObject *self)\n{\n    Py_ssize_t i;\n    PyObject **memo = self->memo;\n\n    if (self->memo == NULL)\n        return;\n    self->memo = NULL;\n    i = self->memo_size;\n    while (--i >= 0) {\n        Py_XDECREF(memo[i]);\n    }\n    PyMem_FREE(memo);\n}\n\nstatic UnpicklerObject *\n_Unpickler_New(void)\n{\n    UnpicklerObject *self;\n\n    self = PyObject_GC_New(UnpicklerObject, &Unpickler_Type);\n    if (self == NULL)\n        return NULL;\n\n    self->pers_func = NULL;\n    self->input_buffer = NULL;\n    self->input_line = NULL;\n    self->input_len = 0;\n    self->next_read_idx = 0;\n    self->prefetched_idx = 0;\n    self->read = NULL;\n    self->readline = NULL;\n    self->peek = NULL;\n    self->encoding = NULL;\n    self->errors = NULL;\n    self->marks = NULL;\n    self->num_marks = 0;\n    self->marks_size = 0;\n    self->proto = 0;\n    self->fix_imports = 0;\n    memset(&self->buffer, 0, sizeof(Py_buffer));\n    self->memo_size = 32;\n    self->memo_len = 0;\n    self->memo = _Unpickler_NewMemo(self->memo_size);\n    self->stack = (Pdata *)Pdata_New();\n\n    if (self->memo == NULL || self->stack == NULL) {\n        Py_DECREF(self);\n        return NULL;\n    }\n\n    return self;\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success. This may\n   be called once on a freshly created Pickler. */\nstatic int\n_Unpickler_SetInputStream(UnpicklerObject *self, PyObject *file)\n{\n    _Py_IDENTIFIER(peek);\n    _Py_IDENTIFIER(read);\n    _Py_IDENTIFIER(readline);\n\n    if (_PyObject_LookupAttrId(file, &PyId_peek, &self->peek) < 0) {\n        return -1;\n    }\n    (void)_PyObject_LookupAttrId(file, &PyId_read, &self->read);\n    (void)_PyObject_LookupAttrId(file, &PyId_readline, &self->readline);\n    if (self->readline == NULL || self->read == NULL) {\n        if (!PyErr_Occurred()) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"file must have 'read' and 'readline' attributes\");\n        }\n        Py_CLEAR(self->read);\n        Py_CLEAR(self->readline);\n        Py_CLEAR(self->peek);\n        return -1;\n    }\n    return 0;\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success. This may\n   be called once on a freshly created Pickler. */\nstatic int\n_Unpickler_SetInputEncoding(UnpicklerObject *self,\n                            const char *encoding,\n                            const char *errors)\n{\n    if (encoding == NULL)\n        encoding = \"ASCII\";\n    if (errors == NULL)\n        errors = \"strict\";\n\n    self->encoding = _PyMem_Strdup(encoding);\n    self->errors = _PyMem_Strdup(errors);\n    if (self->encoding == NULL || self->errors == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    return 0;\n}\n\n/* Generate a GET opcode for an object stored in the memo. */\nstatic int\nmemo_get(PicklerObject *self, PyObject *key)\n{\n    Py_ssize_t *value;\n    char pdata[30];\n    Py_ssize_t len;\n\n    value = PyMemoTable_Get(self->memo, key);\n    if (value == NULL)  {\n        PyErr_SetObject(PyExc_KeyError, key);\n        return -1;\n    }\n\n    if (!self->bin) {\n        pdata[0] = GET;\n        PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,\n                      \"%\" PY_FORMAT_SIZE_T \"d\\n\", *value);\n        len = strlen(pdata);\n    }\n    else {\n        if (*value < 256) {\n            pdata[0] = BINGET;\n            pdata[1] = (unsigned char)(*value & 0xff);\n            len = 2;\n        }\n        else if ((size_t)*value <= 0xffffffffUL) {\n            pdata[0] = LONG_BINGET;\n            pdata[1] = (unsigned char)(*value & 0xff);\n            pdata[2] = (unsigned char)((*value >> 8) & 0xff);\n            pdata[3] = (unsigned char)((*value >> 16) & 0xff);\n            pdata[4] = (unsigned char)((*value >> 24) & 0xff);\n            len = 5;\n        }\n        else { /* unlikely */\n            PickleState *st = _Pickle_GetGlobalState();\n            PyErr_SetString(st->PicklingError,\n                            \"memo id too large for LONG_BINGET\");\n            return -1;\n        }\n    }\n\n    if (_Pickler_Write(self, pdata, len) < 0)\n        return -1;\n\n    return 0;\n}\n\n/* Store an object in the memo, assign it a new unique ID based on the number\n   of objects currently stored in the memo and generate a PUT opcode. */\nstatic int\nmemo_put(PicklerObject *self, PyObject *obj)\n{\n    char pdata[30];\n    Py_ssize_t len;\n    Py_ssize_t idx;\n\n    const char memoize_op = MEMOIZE;\n\n    if (self->fast)\n        return 0;\n\n    idx = PyMemoTable_Size(self->memo);\n    if (PyMemoTable_Set(self->memo, obj, idx) < 0)\n        return -1;\n\n    if (self->proto >= 4) {\n        if (_Pickler_Write(self, &memoize_op, 1) < 0)\n            return -1;\n        return 0;\n    }\n    else if (!self->bin) {\n        pdata[0] = PUT;\n        PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,\n                      \"%\" PY_FORMAT_SIZE_T \"d\\n\", idx);\n        len = strlen(pdata);\n    }\n    else {\n        if (idx < 256) {\n            pdata[0] = BINPUT;\n            pdata[1] = (unsigned char)idx;\n            len = 2;\n        }\n        else if ((size_t)idx <= 0xffffffffUL) {\n            pdata[0] = LONG_BINPUT;\n            pdata[1] = (unsigned char)(idx & 0xff);\n            pdata[2] = (unsigned char)((idx >> 8) & 0xff);\n            pdata[3] = (unsigned char)((idx >> 16) & 0xff);\n            pdata[4] = (unsigned char)((idx >> 24) & 0xff);\n            len = 5;\n        }\n        else { /* unlikely */\n            PickleState *st = _Pickle_GetGlobalState();\n            PyErr_SetString(st->PicklingError,\n                            \"memo id too large for LONG_BINPUT\");\n            return -1;\n        }\n    }\n    if (_Pickler_Write(self, pdata, len) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic PyObject *\nget_dotted_path(PyObject *obj, PyObject *name)\n{\n    _Py_static_string(PyId_dot, \".\");\n    PyObject *dotted_path;\n    Py_ssize_t i, n;\n\n    dotted_path = PyUnicode_Split(name, _PyUnicode_FromId(&PyId_dot), -1);\n    if (dotted_path == NULL)\n        return NULL;\n    n = PyList_GET_SIZE(dotted_path);\n    assert(n >= 1);\n    for (i = 0; i < n; i++) {\n        PyObject *subpath = PyList_GET_ITEM(dotted_path, i);\n        if (_PyUnicode_EqualToASCIIString(subpath, \"<locals>\")) {\n            if (obj == NULL)\n                PyErr_Format(PyExc_AttributeError,\n                             \"Can't pickle local object %R\", name);\n            else\n                PyErr_Format(PyExc_AttributeError,\n                             \"Can't pickle local attribute %R on %R\", name, obj);\n            Py_DECREF(dotted_path);\n            return NULL;\n        }\n    }\n    return dotted_path;\n}\n\nstatic PyObject *\nget_deep_attribute(PyObject *obj, PyObject *names, PyObject **pparent)\n{\n    Py_ssize_t i, n;\n    PyObject *parent = NULL;\n\n    assert(PyList_CheckExact(names));\n    Py_INCREF(obj);\n    n = PyList_GET_SIZE(names);\n    for (i = 0; i < n; i++) {\n        PyObject *name = PyList_GET_ITEM(names, i);\n        Py_XDECREF(parent);\n        parent = obj;\n        (void)_PyObject_LookupAttr(parent, name, &obj);\n        if (obj == NULL) {\n            Py_DECREF(parent);\n            return NULL;\n        }\n    }\n    if (pparent != NULL)\n        *pparent = parent;\n    else\n        Py_XDECREF(parent);\n    return obj;\n}\n\n\nstatic PyObject *\ngetattribute(PyObject *obj, PyObject *name, int allow_qualname)\n{\n    PyObject *dotted_path, *attr;\n\n    if (allow_qualname) {\n        dotted_path = get_dotted_path(obj, name);\n        if (dotted_path == NULL)\n            return NULL;\n        attr = get_deep_attribute(obj, dotted_path, NULL);\n        Py_DECREF(dotted_path);\n    }\n    else {\n        (void)_PyObject_LookupAttr(obj, name, &attr);\n    }\n    if (attr == NULL && !PyErr_Occurred()) {\n        PyErr_Format(PyExc_AttributeError,\n                     \"Can't get attribute %R on %R\", name, obj);\n    }\n    return attr;\n}\n\nstatic int\n_checkmodule(PyObject *module_name, PyObject *module,\n             PyObject *global, PyObject *dotted_path)\n{\n    if (module == Py_None) {\n        return -1;\n    }\n    if (PyUnicode_Check(module_name) &&\n            _PyUnicode_EqualToASCIIString(module_name, \"__main__\")) {\n        return -1;\n    }\n\n    PyObject *candidate = get_deep_attribute(module, dotted_path, NULL);\n    if (candidate == NULL) {\n        return -1;\n    }\n    if (candidate != global) {\n        Py_DECREF(candidate);\n        return -1;\n    }\n    Py_DECREF(candidate);\n    return 0;\n}\n\nstatic PyObject *\nwhichmodule(PyObject *global, PyObject *dotted_path)\n{\n    PyObject *module_name;\n    PyObject *module = NULL;\n    Py_ssize_t i;\n    PyObject *modules;\n    _Py_IDENTIFIER(__module__);\n    _Py_IDENTIFIER(modules);\n    _Py_IDENTIFIER(__main__);\n\n    if (_PyObject_LookupAttrId(global, &PyId___module__, &module_name) < 0) {\n        return NULL;\n    }\n    if (module_name) {\n        /* In some rare cases (e.g., bound methods of extension types),\n           __module__ can be None. If it is so, then search sys.modules for\n           the module of global. */\n        if (module_name != Py_None)\n            return module_name;\n        Py_CLEAR(module_name);\n    }\n    assert(module_name == NULL);\n\n    /* Fallback on walking sys.modules */\n    modules = _PySys_GetObjectId(&PyId_modules);\n    if (modules == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"unable to get sys.modules\");\n        return NULL;\n    }\n    if (PyDict_CheckExact(modules)) {\n        i = 0;\n        while (PyDict_Next(modules, &i, &module_name, &module)) {\n            if (_checkmodule(module_name, module, global, dotted_path) == 0) {\n                Py_INCREF(module_name);\n                return module_name;\n            }\n            if (PyErr_Occurred()) {\n                return NULL;\n            }\n        }\n    }\n    else {\n        PyObject *iterator = PyObject_GetIter(modules);\n        if (iterator == NULL) {\n            return NULL;\n        }\n        while ((module_name = PyIter_Next(iterator))) {\n            module = PyObject_GetItem(modules, module_name);\n            if (module == NULL) {\n                Py_DECREF(module_name);\n                Py_DECREF(iterator);\n                return NULL;\n            }\n            if (_checkmodule(module_name, module, global, dotted_path) == 0) {\n                Py_DECREF(module);\n                Py_DECREF(iterator);\n                return module_name;\n            }\n            Py_DECREF(module);\n            Py_DECREF(module_name);\n            if (PyErr_Occurred()) {\n                Py_DECREF(iterator);\n                return NULL;\n            }\n        }\n        Py_DECREF(iterator);\n    }\n\n    /* If no module is found, use __main__. */\n    module_name = _PyUnicode_FromId(&PyId___main__);\n    Py_XINCREF(module_name);\n    return module_name;\n}\n\n/* fast_save_enter() and fast_save_leave() are guards against recursive\n   objects when Pickler is used with the \"fast mode\" (i.e., with object\n   memoization disabled). If the nesting of a list or dict object exceed\n   FAST_NESTING_LIMIT, these guards will start keeping an internal\n   reference to the seen list or dict objects and check whether these objects\n   are recursive. These are not strictly necessary, since save() has a\n   hard-coded recursion limit, but they give a nicer error message than the\n   typical RuntimeError. */\nstatic int\nfast_save_enter(PicklerObject *self, PyObject *obj)\n{\n    /* if fast_nesting < 0, we're doing an error exit. */\n    if (++self->fast_nesting >= FAST_NESTING_LIMIT) {\n        PyObject *key = NULL;\n        if (self->fast_memo == NULL) {\n            self->fast_memo = PyDict_New();\n            if (self->fast_memo == NULL) {\n                self->fast_nesting = -1;\n                return 0;\n            }\n        }\n        key = PyLong_FromVoidPtr(obj);\n        if (key == NULL) {\n            self->fast_nesting = -1;\n            return 0;\n        }\n        if (PyDict_GetItemWithError(self->fast_memo, key)) {\n            Py_DECREF(key);\n            PyErr_Format(PyExc_ValueError,\n                         \"fast mode: can't pickle cyclic objects \"\n                         \"including object type %.200s at %p\",\n                         obj->ob_type->tp_name, obj);\n            self->fast_nesting = -1;\n            return 0;\n        }\n        if (PyErr_Occurred()) {\n            Py_DECREF(key);\n            self->fast_nesting = -1;\n            return 0;\n        }\n        if (PyDict_SetItem(self->fast_memo, key, Py_None) < 0) {\n            Py_DECREF(key);\n            self->fast_nesting = -1;\n            return 0;\n        }\n        Py_DECREF(key);\n    }\n    return 1;\n}\n\nstatic int\nfast_save_leave(PicklerObject *self, PyObject *obj)\n{\n    if (self->fast_nesting-- >= FAST_NESTING_LIMIT) {\n        PyObject *key = PyLong_FromVoidPtr(obj);\n        if (key == NULL)\n            return 0;\n        if (PyDict_DelItem(self->fast_memo, key) < 0) {\n            Py_DECREF(key);\n            return 0;\n        }\n        Py_DECREF(key);\n    }\n    return 1;\n}\n\nstatic int\nsave_none(PicklerObject *self, PyObject *obj)\n{\n    const char none_op = NONE;\n    if (_Pickler_Write(self, &none_op, 1) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic int\nsave_bool(PicklerObject *self, PyObject *obj)\n{\n    if (self->proto >= 2) {\n        const char bool_op = (obj == Py_True) ? NEWTRUE : NEWFALSE;\n        if (_Pickler_Write(self, &bool_op, 1) < 0)\n            return -1;\n    }\n    else {\n        /* These aren't opcodes -- they're ways to pickle bools before protocol 2\n         * so that unpicklers written before bools were introduced unpickle them\n         * as ints, but unpicklers after can recognize that bools were intended.\n         * Note that protocol 2 added direct ways to pickle bools.\n         */\n        const char *bool_str = (obj == Py_True) ? \"I01\\n\" : \"I00\\n\";\n        if (_Pickler_Write(self, bool_str, strlen(bool_str)) < 0)\n            return -1;\n    }\n    return 0;\n}\n\nstatic int\nsave_long(PicklerObject *self, PyObject *obj)\n{\n    PyObject *repr = NULL;\n    Py_ssize_t size;\n    long val;\n    int overflow;\n    int status = 0;\n\n    val= PyLong_AsLongAndOverflow(obj, &overflow);\n    if (!overflow && (sizeof(long) <= 4 ||\n            (val <= 0x7fffffffL && val >= (-0x7fffffffL - 1))))\n    {\n        /* result fits in a signed 4-byte integer.\n\n           Note: we can't use -0x80000000L in the above condition because some\n           compilers (e.g., MSVC) will promote 0x80000000L to an unsigned type\n           before applying the unary minus when sizeof(long) <= 4. The\n           resulting value stays unsigned which is commonly not what we want,\n           so MSVC happily warns us about it.  However, that result would have\n           been fine because we guard for sizeof(long) <= 4 which turns the\n           condition true in that particular case. */\n        char pdata[32];\n        Py_ssize_t len = 0;\n\n        if (self->bin) {\n            pdata[1] = (unsigned char)(val & 0xff);\n            pdata[2] = (unsigned char)((val >> 8) & 0xff);\n            pdata[3] = (unsigned char)((val >> 16) & 0xff);\n            pdata[4] = (unsigned char)((val >> 24) & 0xff);\n\n            if ((pdata[4] != 0) || (pdata[3] != 0)) {\n                pdata[0] = BININT;\n                len = 5;\n            }\n            else if (pdata[2] != 0) {\n                pdata[0] = BININT2;\n                len = 3;\n            }\n            else {\n                pdata[0] = BININT1;\n                len = 2;\n            }\n        }\n        else {\n            sprintf(pdata, \"%c%ld\\n\", INT,  val);\n            len = strlen(pdata);\n        }\n        if (_Pickler_Write(self, pdata, len) < 0)\n            return -1;\n\n        return 0;\n    }\n    assert(!PyErr_Occurred());\n\n    if (self->proto >= 2) {\n        /* Linear-time pickling. */\n        size_t nbits;\n        size_t nbytes;\n        unsigned char *pdata;\n        char header[5];\n        int i;\n        int sign = _PyLong_Sign(obj);\n\n        if (sign == 0) {\n            header[0] = LONG1;\n            header[1] = 0;      /* It's 0 -- an empty bytestring. */\n            if (_Pickler_Write(self, header, 2) < 0)\n                goto error;\n            return 0;\n        }\n        nbits = _PyLong_NumBits(obj);\n        if (nbits == (size_t)-1 && PyErr_Occurred())\n            goto error;\n        /* How many bytes do we need?  There are nbits >> 3 full\n         * bytes of data, and nbits & 7 leftover bits.  If there\n         * are any leftover bits, then we clearly need another\n         * byte.  Wnat's not so obvious is that we *probably*\n         * need another byte even if there aren't any leftovers:\n         * the most-significant bit of the most-significant byte\n         * acts like a sign bit, and it's usually got a sense\n         * opposite of the one we need.  The exception is ints\n         * of the form -(2**(8*j-1)) for j > 0.  Such an int is\n         * its own 256's-complement, so has the right sign bit\n         * even without the extra byte.  That's a pain to check\n         * for in advance, though, so we always grab an extra\n         * byte at the start, and cut it back later if possible.\n         */\n        nbytes = (nbits >> 3) + 1;\n        if (nbytes > 0x7fffffffL) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"int too large to pickle\");\n            goto error;\n        }\n        repr = PyBytes_FromStringAndSize(NULL, (Py_ssize_t)nbytes);\n        if (repr == NULL)\n            goto error;\n        pdata = (unsigned char *)PyBytes_AS_STRING(repr);\n        i = _PyLong_AsByteArray((PyLongObject *)obj,\n                                pdata, nbytes,\n                                1 /* little endian */ , 1 /* signed */ );\n        if (i < 0)\n            goto error;\n        /* If the int is negative, this may be a byte more than\n         * needed.  This is so iff the MSB is all redundant sign\n         * bits.\n         */\n        if (sign < 0 &&\n            nbytes > 1 &&\n            pdata[nbytes - 1] == 0xff &&\n            (pdata[nbytes - 2] & 0x80) != 0) {\n            nbytes--;\n        }\n\n        if (nbytes < 256) {\n            header[0] = LONG1;\n            header[1] = (unsigned char)nbytes;\n            size = 2;\n        }\n        else {\n            header[0] = LONG4;\n            size = (Py_ssize_t) nbytes;\n            for (i = 1; i < 5; i++) {\n                header[i] = (unsigned char)(size & 0xff);\n                size >>= 8;\n            }\n            size = 5;\n        }\n        if (_Pickler_Write(self, header, size) < 0 ||\n            _Pickler_Write(self, (char *)pdata, (int)nbytes) < 0)\n            goto error;\n    }\n    else {\n        const char long_op = LONG;\n        const char *string;\n\n        /* proto < 2: write the repr and newline.  This is quadratic-time (in\n           the number of digits), in both directions.  We add a trailing 'L'\n           to the repr, for compatibility with Python 2.x. */\n\n        repr = PyObject_Repr(obj);\n        if (repr == NULL)\n            goto error;\n\n        string = PyUnicode_AsUTF8AndSize(repr, &size);\n        if (string == NULL)\n            goto error;\n\n        if (_Pickler_Write(self, &long_op, 1) < 0 ||\n            _Pickler_Write(self, string, size) < 0 ||\n            _Pickler_Write(self, \"L\\n\", 2) < 0)\n            goto error;\n    }\n\n    if (0) {\n  error:\n      status = -1;\n    }\n    Py_XDECREF(repr);\n\n    return status;\n}\n\nstatic int\nsave_float(PicklerObject *self, PyObject *obj)\n{\n    double x = PyFloat_AS_DOUBLE((PyFloatObject *)obj);\n\n    if (self->bin) {\n        char pdata[9];\n        pdata[0] = BINFLOAT;\n        if (_PyFloat_Pack8(x, (unsigned char *)&pdata[1], 0) < 0)\n            return -1;\n        if (_Pickler_Write(self, pdata, 9) < 0)\n            return -1;\n   }\n    else {\n        int result = -1;\n        char *buf = NULL;\n        char op = FLOAT;\n\n        if (_Pickler_Write(self, &op, 1) < 0)\n            goto done;\n\n        buf = PyOS_double_to_string(x, 'r', 0, Py_DTSF_ADD_DOT_0, NULL);\n        if (!buf) {\n            PyErr_NoMemory();\n            goto done;\n        }\n\n        if (_Pickler_Write(self, buf, strlen(buf)) < 0)\n            goto done;\n\n        if (_Pickler_Write(self, \"\\n\", 1) < 0)\n            goto done;\n\n        result = 0;\ndone:\n        PyMem_Free(buf);\n        return result;\n    }\n\n    return 0;\n}\n\n/* Perform direct write of the header and payload of the binary object.\n\n   The large contiguous data is written directly into the underlying file\n   object, bypassing the output_buffer of the Pickler.  We intentionally\n   do not insert a protocol 4 frame opcode to make it possible to optimize\n   file.read calls in the loader.\n */\nstatic int\n_Pickler_write_bytes(PicklerObject *self,\n                     const char *header, Py_ssize_t header_size,\n                     const char *data, Py_ssize_t data_size,\n                     PyObject *payload)\n{\n    int bypass_buffer = (data_size >= FRAME_SIZE_TARGET);\n    int framing = self->framing;\n\n    if (bypass_buffer) {\n        assert(self->output_buffer != NULL);\n        /* Commit the previous frame. */\n        if (_Pickler_CommitFrame(self)) {\n            return -1;\n        }\n        /* Disable framing temporarily */\n        self->framing = 0;\n    }\n\n    if (_Pickler_Write(self, header, header_size) < 0) {\n        return -1;\n    }\n\n    if (bypass_buffer && self->write != NULL) {\n        /* Bypass the in-memory buffer to directly stream large data\n           into the underlying file object. */\n        PyObject *result, *mem = NULL;\n        /* Dump the output buffer to the file. */\n        if (_Pickler_FlushToFile(self) < 0) {\n            return -1;\n        }\n\n        /* Stream write the payload into the file without going through the\n           output buffer. */\n        if (payload == NULL) {\n            /* TODO: It would be better to use a memoryview with a linked\n               original string if this is possible. */\n            payload = mem = PyBytes_FromStringAndSize(data, data_size);\n            if (payload == NULL) {\n                return -1;\n            }\n        }\n        result = PyObject_CallFunctionObjArgs(self->write, payload, NULL);\n        Py_XDECREF(mem);\n        if (result == NULL) {\n            return -1;\n        }\n        Py_DECREF(result);\n\n        /* Reinitialize the buffer for subsequent calls to _Pickler_Write. */\n        if (_Pickler_ClearBuffer(self) < 0) {\n            return -1;\n        }\n    }\n    else {\n        if (_Pickler_Write(self, data, data_size) < 0) {\n            return -1;\n        }\n    }\n\n    /* Re-enable framing for subsequent calls to _Pickler_Write. */\n    self->framing = framing;\n\n    return 0;\n}\n\nstatic int\nsave_bytes(PicklerObject *self, PyObject *obj)\n{\n    if (self->proto < 3) {\n        /* Older pickle protocols do not have an opcode for pickling bytes\n           objects. Therefore, we need to fake the copy protocol (i.e.,\n           the __reduce__ method) to permit bytes object unpickling.\n\n           Here we use a hack to be compatible with Python 2. Since in Python\n           2 'bytes' is just an alias for 'str' (which has different\n           parameters than the actual bytes object), we use codecs.encode\n           to create the appropriate 'str' object when unpickled using\n           Python 2 *and* the appropriate 'bytes' object when unpickled\n           using Python 3. Again this is a hack and we don't need to do this\n           with newer protocols. */\n        PyObject *reduce_value = NULL;\n        int status;\n\n        if (PyBytes_GET_SIZE(obj) == 0) {\n            reduce_value = Py_BuildValue(\"(O())\", (PyObject*)&PyBytes_Type);\n        }\n        else {\n            PickleState *st = _Pickle_GetGlobalState();\n            PyObject *unicode_str =\n                PyUnicode_DecodeLatin1(PyBytes_AS_STRING(obj),\n                                       PyBytes_GET_SIZE(obj),\n                                       \"strict\");\n            _Py_IDENTIFIER(latin1);\n\n            if (unicode_str == NULL)\n                return -1;\n            reduce_value = Py_BuildValue(\"(O(OO))\",\n                                         st->codecs_encode, unicode_str,\n                                         _PyUnicode_FromId(&PyId_latin1));\n            Py_DECREF(unicode_str);\n        }\n\n        if (reduce_value == NULL)\n            return -1;\n\n        /* save_reduce() will memoize the object automatically. */\n        status = save_reduce(self, reduce_value, obj);\n        Py_DECREF(reduce_value);\n        return status;\n    }\n    else {\n        Py_ssize_t size;\n        char header[9];\n        Py_ssize_t len;\n\n        size = PyBytes_GET_SIZE(obj);\n        if (size < 0)\n            return -1;\n\n        if (size <= 0xff) {\n            header[0] = SHORT_BINBYTES;\n            header[1] = (unsigned char)size;\n            len = 2;\n        }\n        else if ((size_t)size <= 0xffffffffUL) {\n            header[0] = BINBYTES;\n            header[1] = (unsigned char)(size & 0xff);\n            header[2] = (unsigned char)((size >> 8) & 0xff);\n            header[3] = (unsigned char)((size >> 16) & 0xff);\n            header[4] = (unsigned char)((size >> 24) & 0xff);\n            len = 5;\n        }\n        else if (self->proto >= 4) {\n            header[0] = BINBYTES8;\n            _write_size64(header + 1, size);\n            len = 9;\n        }\n        else {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"cannot serialize a bytes object larger than 4 GiB\");\n            return -1;          /* string too large */\n        }\n\n        if (_Pickler_write_bytes(self, header, len,\n                                 PyBytes_AS_STRING(obj), size, obj) < 0)\n        {\n            return -1;\n        }\n\n        if (memo_put(self, obj) < 0)\n            return -1;\n\n        return 0;\n    }\n}\n\n/* A copy of PyUnicode_EncodeRawUnicodeEscape() that also translates\n   backslash and newline characters to \\uXXXX escapes. */\nstatic PyObject *\nraw_unicode_escape(PyObject *obj)\n{\n    char *p;\n    Py_ssize_t i, size;\n    void *data;\n    unsigned int kind;\n    _PyBytesWriter writer;\n\n    if (PyUnicode_READY(obj))\n        return NULL;\n\n    _PyBytesWriter_Init(&writer);\n\n    size = PyUnicode_GET_LENGTH(obj);\n    data = PyUnicode_DATA(obj);\n    kind = PyUnicode_KIND(obj);\n\n    p = _PyBytesWriter_Alloc(&writer, size);\n    if (p == NULL)\n        goto error;\n    writer.overallocate = 1;\n\n    for (i=0; i < size; i++) {\n        Py_UCS4 ch = PyUnicode_READ(kind, data, i);\n        /* Map 32-bit characters to '\\Uxxxxxxxx' */\n        if (ch >= 0x10000) {\n            /* -1: subtract 1 preallocated byte */\n            p = _PyBytesWriter_Prepare(&writer, p, 10-1);\n            if (p == NULL)\n                goto error;\n\n            *p++ = '\\\\';\n            *p++ = 'U';\n            *p++ = Py_hexdigits[(ch >> 28) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 24) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 20) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 16) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 12) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 8) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 4) & 0xf];\n            *p++ = Py_hexdigits[ch & 15];\n        }\n        /* Map 16-bit characters, '\\\\' and '\\n' to '\\uxxxx' */\n        else if (ch >= 256 || ch == '\\\\' || ch == '\\n') {\n            /* -1: subtract 1 preallocated byte */\n            p = _PyBytesWriter_Prepare(&writer, p, 6-1);\n            if (p == NULL)\n                goto error;\n\n            *p++ = '\\\\';\n            *p++ = 'u';\n            *p++ = Py_hexdigits[(ch >> 12) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 8) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 4) & 0xf];\n            *p++ = Py_hexdigits[ch & 15];\n        }\n        /* Copy everything else as-is */\n        else\n            *p++ = (char) ch;\n    }\n\n    return _PyBytesWriter_Finish(&writer, p);\n\nerror:\n    _PyBytesWriter_Dealloc(&writer);\n    return NULL;\n}\n\nstatic int\nwrite_unicode_binary(PicklerObject *self, PyObject *obj)\n{\n    char header[9];\n    Py_ssize_t len;\n    PyObject *encoded = NULL;\n    Py_ssize_t size;\n    const char *data;\n\n    if (PyUnicode_READY(obj))\n        return -1;\n\n    data = PyUnicode_AsUTF8AndSize(obj, &size);\n    if (data == NULL) {\n        /* Issue #8383: for strings with lone surrogates, fallback on the\n           \"surrogatepass\" error handler. */\n        PyErr_Clear();\n        encoded = PyUnicode_AsEncodedString(obj, \"utf-8\", \"surrogatepass\");\n        if (encoded == NULL)\n            return -1;\n\n        data = PyBytes_AS_STRING(encoded);\n        size = PyBytes_GET_SIZE(encoded);\n    }\n\n    assert(size >= 0);\n    if (size <= 0xff && self->proto >= 4) {\n        header[0] = SHORT_BINUNICODE;\n        header[1] = (unsigned char)(size & 0xff);\n        len = 2;\n    }\n    else if ((size_t)size <= 0xffffffffUL) {\n        header[0] = BINUNICODE;\n        header[1] = (unsigned char)(size & 0xff);\n        header[2] = (unsigned char)((size >> 8) & 0xff);\n        header[3] = (unsigned char)((size >> 16) & 0xff);\n        header[4] = (unsigned char)((size >> 24) & 0xff);\n        len = 5;\n    }\n    else if (self->proto >= 4) {\n        header[0] = BINUNICODE8;\n        _write_size64(header + 1, size);\n        len = 9;\n    }\n    else {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"cannot serialize a string larger than 4GiB\");\n        Py_XDECREF(encoded);\n        return -1;\n    }\n\n    if (_Pickler_write_bytes(self, header, len, data, size, encoded) < 0) {\n        Py_XDECREF(encoded);\n        return -1;\n    }\n    Py_XDECREF(encoded);\n    return 0;\n}\n\nstatic int\nsave_unicode(PicklerObject *self, PyObject *obj)\n{\n    if (self->bin) {\n        if (write_unicode_binary(self, obj) < 0)\n            return -1;\n    }\n    else {\n        PyObject *encoded;\n        Py_ssize_t size;\n        const char unicode_op = UNICODE;\n\n        encoded = raw_unicode_escape(obj);\n        if (encoded == NULL)\n            return -1;\n\n        if (_Pickler_Write(self, &unicode_op, 1) < 0) {\n            Py_DECREF(encoded);\n            return -1;\n        }\n\n        size = PyBytes_GET_SIZE(encoded);\n        if (_Pickler_Write(self, PyBytes_AS_STRING(encoded), size) < 0) {\n            Py_DECREF(encoded);\n            return -1;\n        }\n        Py_DECREF(encoded);\n\n        if (_Pickler_Write(self, \"\\n\", 1) < 0)\n            return -1;\n    }\n    if (memo_put(self, obj) < 0)\n        return -1;\n\n    return 0;\n}\n\n/* A helper for save_tuple.  Push the len elements in tuple t on the stack. */\nstatic int\nstore_tuple_elements(PicklerObject *self, PyObject *t, Py_ssize_t len)\n{\n    Py_ssize_t i;\n\n    assert(PyTuple_Size(t) == len);\n\n    for (i = 0; i < len; i++) {\n        PyObject *element = PyTuple_GET_ITEM(t, i);\n\n        if (element == NULL)\n            return -1;\n        if (save(self, element, 0) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n/* Tuples are ubiquitous in the pickle protocols, so many techniques are\n * used across protocols to minimize the space needed to pickle them.\n * Tuples are also the only builtin immutable type that can be recursive\n * (a tuple can be reached from itself), and that requires some subtle\n * magic so that it works in all cases.  IOW, this is a long routine.\n */\nstatic int\nsave_tuple(PicklerObject *self, PyObject *obj)\n{\n    Py_ssize_t len, i;\n\n    const char mark_op = MARK;\n    const char tuple_op = TUPLE;\n    const char pop_op = POP;\n    const char pop_mark_op = POP_MARK;\n    const char len2opcode[] = {EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3};\n\n    if ((len = PyTuple_Size(obj)) < 0)\n        return -1;\n\n    if (len == 0) {\n        char pdata[2];\n\n        if (self->proto) {\n            pdata[0] = EMPTY_TUPLE;\n            len = 1;\n        }\n        else {\n            pdata[0] = MARK;\n            pdata[1] = TUPLE;\n            len = 2;\n        }\n        if (_Pickler_Write(self, pdata, len) < 0)\n            return -1;\n        return 0;\n    }\n\n    /* The tuple isn't in the memo now.  If it shows up there after\n     * saving the tuple elements, the tuple must be recursive, in\n     * which case we'll pop everything we put on the stack, and fetch\n     * its value from the memo.\n     */\n    if (len <= 3 && self->proto >= 2) {\n        /* Use TUPLE{1,2,3} opcodes. */\n        if (store_tuple_elements(self, obj, len) < 0)\n            return -1;\n\n        if (PyMemoTable_Get(self->memo, obj)) {\n            /* pop the len elements */\n            for (i = 0; i < len; i++)\n                if (_Pickler_Write(self, &pop_op, 1) < 0)\n                    return -1;\n            /* fetch from memo */\n            if (memo_get(self, obj) < 0)\n                return -1;\n\n            return 0;\n        }\n        else { /* Not recursive. */\n            if (_Pickler_Write(self, len2opcode + len, 1) < 0)\n                return -1;\n        }\n        goto memoize;\n    }\n\n    /* proto < 2 and len > 0, or proto >= 2 and len > 3.\n     * Generate MARK e1 e2 ... TUPLE\n     */\n    if (_Pickler_Write(self, &mark_op, 1) < 0)\n        return -1;\n\n    if (store_tuple_elements(self, obj, len) < 0)\n        return -1;\n\n    if (PyMemoTable_Get(self->memo, obj)) {\n        /* pop the stack stuff we pushed */\n        if (self->bin) {\n            if (_Pickler_Write(self, &pop_mark_op, 1) < 0)\n                return -1;\n        }\n        else {\n            /* Note that we pop one more than len, to remove\n             * the MARK too.\n             */\n            for (i = 0; i <= len; i++)\n                if (_Pickler_Write(self, &pop_op, 1) < 0)\n                    return -1;\n        }\n        /* fetch from memo */\n        if (memo_get(self, obj) < 0)\n            return -1;\n\n        return 0;\n    }\n    else { /* Not recursive. */\n        if (_Pickler_Write(self, &tuple_op, 1) < 0)\n            return -1;\n    }\n\n  memoize:\n    if (memo_put(self, obj) < 0)\n        return -1;\n\n    return 0;\n}\n\n/* iter is an iterator giving items, and we batch up chunks of\n *     MARK item item ... item APPENDS\n * opcode sequences.  Calling code should have arranged to first create an\n * empty list, or list-like object, for the APPENDS to operate on.\n * Returns 0 on success, <0 on error.\n */\nstatic int\nbatch_list(PicklerObject *self, PyObject *iter)\n{\n    PyObject *obj = NULL;\n    PyObject *firstitem = NULL;\n    int i, n;\n\n    const char mark_op = MARK;\n    const char append_op = APPEND;\n    const char appends_op = APPENDS;\n\n    assert(iter != NULL);\n\n    /* XXX: I think this function could be made faster by avoiding the\n       iterator interface and fetching objects directly from list using\n       PyList_GET_ITEM.\n    */\n\n    if (self->proto == 0) {\n        /* APPENDS isn't available; do one at a time. */\n        for (;;) {\n            obj = PyIter_Next(iter);\n            if (obj == NULL) {\n                if (PyErr_Occurred())\n                    return -1;\n                break;\n            }\n            i = save(self, obj, 0);\n            Py_DECREF(obj);\n            if (i < 0)\n                return -1;\n            if (_Pickler_Write(self, &append_op, 1) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    /* proto > 0:  write in batches of BATCHSIZE. */\n    do {\n        /* Get first item */\n        firstitem = PyIter_Next(iter);\n        if (firstitem == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n\n            /* nothing more to add */\n            break;\n        }\n\n        /* Try to get a second item */\n        obj = PyIter_Next(iter);\n        if (obj == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n\n            /* Only one item to write */\n            if (save(self, firstitem, 0) < 0)\n                goto error;\n            if (_Pickler_Write(self, &append_op, 1) < 0)\n                goto error;\n            Py_CLEAR(firstitem);\n            break;\n        }\n\n        /* More than one item to write */\n\n        /* Pump out MARK, items, APPENDS. */\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            goto error;\n\n        if (save(self, firstitem, 0) < 0)\n            goto error;\n        Py_CLEAR(firstitem);\n        n = 1;\n\n        /* Fetch and save up to BATCHSIZE items */\n        while (obj) {\n            if (save(self, obj, 0) < 0)\n                goto error;\n            Py_CLEAR(obj);\n            n += 1;\n\n            if (n == BATCHSIZE)\n                break;\n\n            obj = PyIter_Next(iter);\n            if (obj == NULL) {\n                if (PyErr_Occurred())\n                    goto error;\n                break;\n            }\n        }\n\n        if (_Pickler_Write(self, &appends_op, 1) < 0)\n            goto error;\n\n    } while (n == BATCHSIZE);\n    return 0;\n\n  error:\n    Py_XDECREF(firstitem);\n    Py_XDECREF(obj);\n    return -1;\n}\n\n/* This is a variant of batch_list() above, specialized for lists (with no\n * support for list subclasses). Like batch_list(), we batch up chunks of\n *     MARK item item ... item APPENDS\n * opcode sequences.  Calling code should have arranged to first create an\n * empty list, or list-like object, for the APPENDS to operate on.\n * Returns 0 on success, -1 on error.\n *\n * This version is considerably faster than batch_list(), if less general.\n *\n * Note that this only works for protocols > 0.\n */\nstatic int\nbatch_list_exact(PicklerObject *self, PyObject *obj)\n{\n    PyObject *item = NULL;\n    Py_ssize_t this_batch, total;\n\n    const char append_op = APPEND;\n    const char appends_op = APPENDS;\n    const char mark_op = MARK;\n\n    assert(obj != NULL);\n    assert(self->proto > 0);\n    assert(PyList_CheckExact(obj));\n\n    if (PyList_GET_SIZE(obj) == 1) {\n        item = PyList_GET_ITEM(obj, 0);\n        if (save(self, item, 0) < 0)\n            return -1;\n        if (_Pickler_Write(self, &append_op, 1) < 0)\n            return -1;\n        return 0;\n    }\n\n    /* Write in batches of BATCHSIZE. */\n    total = 0;\n    do {\n        this_batch = 0;\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            return -1;\n        while (total < PyList_GET_SIZE(obj)) {\n            item = PyList_GET_ITEM(obj, total);\n            if (save(self, item, 0) < 0)\n                return -1;\n            total++;\n            if (++this_batch == BATCHSIZE)\n                break;\n        }\n        if (_Pickler_Write(self, &appends_op, 1) < 0)\n            return -1;\n\n    } while (total < PyList_GET_SIZE(obj));\n\n    return 0;\n}\n\nstatic int\nsave_list(PicklerObject *self, PyObject *obj)\n{\n    char header[3];\n    Py_ssize_t len;\n    int status = 0;\n\n    if (self->fast && !fast_save_enter(self, obj))\n        goto error;\n\n    /* Create an empty list. */\n    if (self->bin) {\n        header[0] = EMPTY_LIST;\n        len = 1;\n    }\n    else {\n        header[0] = MARK;\n        header[1] = LIST;\n        len = 2;\n    }\n\n    if (_Pickler_Write(self, header, len) < 0)\n        goto error;\n\n    /* Get list length, and bow out early if empty. */\n    if ((len = PyList_Size(obj)) < 0)\n        goto error;\n\n    if (memo_put(self, obj) < 0)\n        goto error;\n\n    if (len != 0) {\n        /* Materialize the list elements. */\n        if (PyList_CheckExact(obj) && self->proto > 0) {\n            if (Py_EnterRecursiveCall(\" while pickling an object\"))\n                goto error;\n            status = batch_list_exact(self, obj);\n            Py_LeaveRecursiveCall();\n        } else {\n            PyObject *iter = PyObject_GetIter(obj);\n            if (iter == NULL)\n                goto error;\n\n            if (Py_EnterRecursiveCall(\" while pickling an object\")) {\n                Py_DECREF(iter);\n                goto error;\n            }\n            status = batch_list(self, iter);\n            Py_LeaveRecursiveCall();\n            Py_DECREF(iter);\n        }\n    }\n    if (0) {\n  error:\n        status = -1;\n    }\n\n    if (self->fast && !fast_save_leave(self, obj))\n        status = -1;\n\n    return status;\n}\n\n/* iter is an iterator giving (key, value) pairs, and we batch up chunks of\n *     MARK key value ... key value SETITEMS\n * opcode sequences.  Calling code should have arranged to first create an\n * empty dict, or dict-like object, for the SETITEMS to operate on.\n * Returns 0 on success, <0 on error.\n *\n * This is very much like batch_list().  The difference between saving\n * elements directly, and picking apart two-tuples, is so long-winded at\n * the C level, though, that attempts to combine these routines were too\n * ugly to bear.\n */\nstatic int\nbatch_dict(PicklerObject *self, PyObject *iter)\n{\n    PyObject *obj = NULL;\n    PyObject *firstitem = NULL;\n    int i, n;\n\n    const char mark_op = MARK;\n    const char setitem_op = SETITEM;\n    const char setitems_op = SETITEMS;\n\n    assert(iter != NULL);\n\n    if (self->proto == 0) {\n        /* SETITEMS isn't available; do one at a time. */\n        for (;;) {\n            obj = PyIter_Next(iter);\n            if (obj == NULL) {\n                if (PyErr_Occurred())\n                    return -1;\n                break;\n            }\n            if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 2) {\n                PyErr_SetString(PyExc_TypeError, \"dict items \"\n                                \"iterator must return 2-tuples\");\n                return -1;\n            }\n            i = save(self, PyTuple_GET_ITEM(obj, 0), 0);\n            if (i >= 0)\n                i = save(self, PyTuple_GET_ITEM(obj, 1), 0);\n            Py_DECREF(obj);\n            if (i < 0)\n                return -1;\n            if (_Pickler_Write(self, &setitem_op, 1) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    /* proto > 0:  write in batches of BATCHSIZE. */\n    do {\n        /* Get first item */\n        firstitem = PyIter_Next(iter);\n        if (firstitem == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n\n            /* nothing more to add */\n            break;\n        }\n        if (!PyTuple_Check(firstitem) || PyTuple_Size(firstitem) != 2) {\n            PyErr_SetString(PyExc_TypeError, \"dict items \"\n                                \"iterator must return 2-tuples\");\n            goto error;\n        }\n\n        /* Try to get a second item */\n        obj = PyIter_Next(iter);\n        if (obj == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n\n            /* Only one item to write */\n            if (save(self, PyTuple_GET_ITEM(firstitem, 0), 0) < 0)\n                goto error;\n            if (save(self, PyTuple_GET_ITEM(firstitem, 1), 0) < 0)\n                goto error;\n            if (_Pickler_Write(self, &setitem_op, 1) < 0)\n                goto error;\n            Py_CLEAR(firstitem);\n            break;\n        }\n\n        /* More than one item to write */\n\n        /* Pump out MARK, items, SETITEMS. */\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            goto error;\n\n        if (save(self, PyTuple_GET_ITEM(firstitem, 0), 0) < 0)\n            goto error;\n        if (save(self, PyTuple_GET_ITEM(firstitem, 1), 0) < 0)\n            goto error;\n        Py_CLEAR(firstitem);\n        n = 1;\n\n        /* Fetch and save up to BATCHSIZE items */\n        while (obj) {\n            if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 2) {\n                PyErr_SetString(PyExc_TypeError, \"dict items \"\n                    \"iterator must return 2-tuples\");\n                goto error;\n            }\n            if (save(self, PyTuple_GET_ITEM(obj, 0), 0) < 0 ||\n                save(self, PyTuple_GET_ITEM(obj, 1), 0) < 0)\n                goto error;\n            Py_CLEAR(obj);\n            n += 1;\n\n            if (n == BATCHSIZE)\n                break;\n\n            obj = PyIter_Next(iter);\n            if (obj == NULL) {\n                if (PyErr_Occurred())\n                    goto error;\n                break;\n            }\n        }\n\n        if (_Pickler_Write(self, &setitems_op, 1) < 0)\n            goto error;\n\n    } while (n == BATCHSIZE);\n    return 0;\n\n  error:\n    Py_XDECREF(firstitem);\n    Py_XDECREF(obj);\n    return -1;\n}\n\n/* This is a variant of batch_dict() above that specializes for dicts, with no\n * support for dict subclasses. Like batch_dict(), we batch up chunks of\n *     MARK key value ... key value SETITEMS\n * opcode sequences.  Calling code should have arranged to first create an\n * empty dict, or dict-like object, for the SETITEMS to operate on.\n * Returns 0 on success, -1 on error.\n *\n * Note that this currently doesn't work for protocol 0.\n */\nstatic int\nbatch_dict_exact(PicklerObject *self, PyObject *obj)\n{\n    PyObject *key = NULL, *value = NULL;\n    int i;\n    Py_ssize_t dict_size, ppos = 0;\n\n    const char mark_op = MARK;\n    const char setitem_op = SETITEM;\n    const char setitems_op = SETITEMS;\n\n    assert(obj != NULL && PyDict_CheckExact(obj));\n    assert(self->proto > 0);\n\n    dict_size = PyDict_GET_SIZE(obj);\n\n    /* Special-case len(d) == 1 to save space. */\n    if (dict_size == 1) {\n        PyDict_Next(obj, &ppos, &key, &value);\n        if (save(self, key, 0) < 0)\n            return -1;\n        if (save(self, value, 0) < 0)\n            return -1;\n        if (_Pickler_Write(self, &setitem_op, 1) < 0)\n            return -1;\n        return 0;\n    }\n\n    /* Write in batches of BATCHSIZE. */\n    do {\n        i = 0;\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            return -1;\n        while (PyDict_Next(obj, &ppos, &key, &value)) {\n            if (save(self, key, 0) < 0)\n                return -1;\n            if (save(self, value, 0) < 0)\n                return -1;\n            if (++i == BATCHSIZE)\n                break;\n        }\n        if (_Pickler_Write(self, &setitems_op, 1) < 0)\n            return -1;\n        if (PyDict_GET_SIZE(obj) != dict_size) {\n            PyErr_Format(\n                PyExc_RuntimeError,\n                \"dictionary changed size during iteration\");\n            return -1;\n        }\n\n    } while (i == BATCHSIZE);\n    return 0;\n}\n\nstatic int\nsave_dict(PicklerObject *self, PyObject *obj)\n{\n    PyObject *items, *iter;\n    char header[3];\n    Py_ssize_t len;\n    int status = 0;\n    assert(PyDict_Check(obj));\n\n    if (self->fast && !fast_save_enter(self, obj))\n        goto error;\n\n    /* Create an empty dict. */\n    if (self->bin) {\n        header[0] = EMPTY_DICT;\n        len = 1;\n    }\n    else {\n        header[0] = MARK;\n        header[1] = DICT;\n        len = 2;\n    }\n\n    if (_Pickler_Write(self, header, len) < 0)\n        goto error;\n\n    if (memo_put(self, obj) < 0)\n        goto error;\n\n    if (PyDict_GET_SIZE(obj)) {\n        /* Save the dict items. */\n        if (PyDict_CheckExact(obj) && self->proto > 0) {\n            /* We can take certain shortcuts if we know this is a dict and\n               not a dict subclass. */\n            if (Py_EnterRecursiveCall(\" while pickling an object\"))\n                goto error;\n            status = batch_dict_exact(self, obj);\n            Py_LeaveRecursiveCall();\n        } else {\n            _Py_IDENTIFIER(items);\n\n            items = _PyObject_CallMethodId(obj, &PyId_items, NULL);\n            if (items == NULL)\n                goto error;\n            iter = PyObject_GetIter(items);\n            Py_DECREF(items);\n            if (iter == NULL)\n                goto error;\n            if (Py_EnterRecursiveCall(\" while pickling an object\")) {\n                Py_DECREF(iter);\n                goto error;\n            }\n            status = batch_dict(self, iter);\n            Py_LeaveRecursiveCall();\n            Py_DECREF(iter);\n        }\n    }\n\n    if (0) {\n  error:\n        status = -1;\n    }\n\n    if (self->fast && !fast_save_leave(self, obj))\n        status = -1;\n\n    return status;\n}\n\nstatic int\nsave_set(PicklerObject *self, PyObject *obj)\n{\n    PyObject *item;\n    int i;\n    Py_ssize_t set_size, ppos = 0;\n    Py_hash_t hash;\n\n    const char empty_set_op = EMPTY_SET;\n    const char mark_op = MARK;\n    const char additems_op = ADDITEMS;\n\n    if (self->proto < 4) {\n        PyObject *items;\n        PyObject *reduce_value;\n        int status;\n\n        items = PySequence_List(obj);\n        if (items == NULL) {\n            return -1;\n        }\n        reduce_value = Py_BuildValue(\"(O(O))\", (PyObject*)&PySet_Type, items);\n        Py_DECREF(items);\n        if (reduce_value == NULL) {\n            return -1;\n        }\n        /* save_reduce() will memoize the object automatically. */\n        status = save_reduce(self, reduce_value, obj);\n        Py_DECREF(reduce_value);\n        return status;\n    }\n\n    if (_Pickler_Write(self, &empty_set_op, 1) < 0)\n        return -1;\n\n    if (memo_put(self, obj) < 0)\n        return -1;\n\n    set_size = PySet_GET_SIZE(obj);\n    if (set_size == 0)\n        return 0;  /* nothing to do */\n\n    /* Write in batches of BATCHSIZE. */\n    do {\n        i = 0;\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            return -1;\n        while (_PySet_NextEntry(obj, &ppos, &item, &hash)) {\n            if (save(self, item, 0) < 0)\n                return -1;\n            if (++i == BATCHSIZE)\n                break;\n        }\n        if (_Pickler_Write(self, &additems_op, 1) < 0)\n            return -1;\n        if (PySet_GET_SIZE(obj) != set_size) {\n            PyErr_Format(\n                PyExc_RuntimeError,\n                \"set changed size during iteration\");\n            return -1;\n        }\n    } while (i == BATCHSIZE);\n\n    return 0;\n}\n\nstatic int\nsave_frozenset(PicklerObject *self, PyObject *obj)\n{\n    PyObject *iter;\n\n    const char mark_op = MARK;\n    const char frozenset_op = FROZENSET;\n\n    if (self->fast && !fast_save_enter(self, obj))\n        return -1;\n\n    if (self->proto < 4) {\n        PyObject *items;\n        PyObject *reduce_value;\n        int status;\n\n        items = PySequence_List(obj);\n        if (items == NULL) {\n            return -1;\n        }\n        reduce_value = Py_BuildValue(\"(O(O))\", (PyObject*)&PyFrozenSet_Type,\n                                     items);\n        Py_DECREF(items);\n        if (reduce_value == NULL) {\n            return -1;\n        }\n        /* save_reduce() will memoize the object automatically. */\n        status = save_reduce(self, reduce_value, obj);\n        Py_DECREF(reduce_value);\n        return status;\n    }\n\n    if (_Pickler_Write(self, &mark_op, 1) < 0)\n        return -1;\n\n    iter = PyObject_GetIter(obj);\n    if (iter == NULL) {\n        return -1;\n    }\n    for (;;) {\n        PyObject *item;\n\n        item = PyIter_Next(iter);\n        if (item == NULL) {\n            if (PyErr_Occurred()) {\n                Py_DECREF(iter);\n                return -1;\n            }\n            break;\n        }\n        if (save(self, item, 0) < 0) {\n            Py_DECREF(item);\n            Py_DECREF(iter);\n            return -1;\n        }\n        Py_DECREF(item);\n    }\n    Py_DECREF(iter);\n\n    /* If the object is already in the memo, this means it is\n       recursive. In this case, throw away everything we put on the\n       stack, and fetch the object back from the memo. */\n    if (PyMemoTable_Get(self->memo, obj)) {\n        const char pop_mark_op = POP_MARK;\n\n        if (_Pickler_Write(self, &pop_mark_op, 1) < 0)\n            return -1;\n        if (memo_get(self, obj) < 0)\n            return -1;\n        return 0;\n    }\n\n    if (_Pickler_Write(self, &frozenset_op, 1) < 0)\n        return -1;\n    if (memo_put(self, obj) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic int\nfix_imports(PyObject **module_name, PyObject **global_name)\n{\n    PyObject *key;\n    PyObject *item;\n    PickleState *st = _Pickle_GetGlobalState();\n\n    key = PyTuple_Pack(2, *module_name, *global_name);\n    if (key == NULL)\n        return -1;\n    item = PyDict_GetItemWithError(st->name_mapping_3to2, key);\n    Py_DECREF(key);\n    if (item) {\n        PyObject *fixed_module_name;\n        PyObject *fixed_global_name;\n\n        if (!PyTuple_Check(item) || PyTuple_GET_SIZE(item) != 2) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"_compat_pickle.REVERSE_NAME_MAPPING values \"\n                         \"should be 2-tuples, not %.200s\",\n                         Py_TYPE(item)->tp_name);\n            return -1;\n        }\n        fixed_module_name = PyTuple_GET_ITEM(item, 0);\n        fixed_global_name = PyTuple_GET_ITEM(item, 1);\n        if (!PyUnicode_Check(fixed_module_name) ||\n            !PyUnicode_Check(fixed_global_name)) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"_compat_pickle.REVERSE_NAME_MAPPING values \"\n                         \"should be pairs of str, not (%.200s, %.200s)\",\n                         Py_TYPE(fixed_module_name)->tp_name,\n                         Py_TYPE(fixed_global_name)->tp_name);\n            return -1;\n        }\n\n        Py_CLEAR(*module_name);\n        Py_CLEAR(*global_name);\n        Py_INCREF(fixed_module_name);\n        Py_INCREF(fixed_global_name);\n        *module_name = fixed_module_name;\n        *global_name = fixed_global_name;\n        return 0;\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n\n    item = PyDict_GetItemWithError(st->import_mapping_3to2, *module_name);\n    if (item) {\n        if (!PyUnicode_Check(item)) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"_compat_pickle.REVERSE_IMPORT_MAPPING values \"\n                         \"should be strings, not %.200s\",\n                         Py_TYPE(item)->tp_name);\n            return -1;\n        }\n        Py_INCREF(item);\n        Py_XSETREF(*module_name, item);\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int\nsave_global(PicklerObject *self, PyObject *obj, PyObject *name)\n{\n    PyObject *global_name = NULL;\n    PyObject *module_name = NULL;\n    PyObject *module = NULL;\n    PyObject *parent = NULL;\n    PyObject *dotted_path = NULL;\n    PyObject *lastname = NULL;\n    PyObject *cls;\n    PickleState *st = _Pickle_GetGlobalState();\n    int status = 0;\n    _Py_IDENTIFIER(__name__);\n    _Py_IDENTIFIER(__qualname__);\n\n    const char global_op = GLOBAL;\n\n    if (name) {\n        Py_INCREF(name);\n        global_name = name;\n    }\n    else {\n        if (_PyObject_LookupAttrId(obj, &PyId___qualname__, &global_name) < 0)\n            goto error;\n        if (global_name == NULL) {\n            global_name = _PyObject_GetAttrId(obj, &PyId___name__);\n            if (global_name == NULL)\n                goto error;\n        }\n    }\n\n    dotted_path = get_dotted_path(module, global_name);\n    if (dotted_path == NULL)\n        goto error;\n    module_name = whichmodule(obj, dotted_path);\n    if (module_name == NULL)\n        goto error;\n\n    /* XXX: Change to use the import C API directly with level=0 to disallow\n       relative imports.\n\n       XXX: PyImport_ImportModuleLevel could be used. However, this bypasses\n       builtins.__import__. Therefore, _pickle, unlike pickle.py, will ignore\n       custom import functions (IMHO, this would be a nice security\n       feature). The import C API would need to be extended to support the\n       extra parameters of __import__ to fix that. */\n    module = PyImport_Import(module_name);\n    if (module == NULL) {\n        PyErr_Format(st->PicklingError,\n                     \"Can't pickle %R: import of module %R failed\",\n                     obj, module_name);\n        goto error;\n    }\n    lastname = PyList_GET_ITEM(dotted_path, PyList_GET_SIZE(dotted_path)-1);\n    Py_INCREF(lastname);\n    cls = get_deep_attribute(module, dotted_path, &parent);\n    Py_CLEAR(dotted_path);\n    if (cls == NULL) {\n        PyErr_Format(st->PicklingError,\n                     \"Can't pickle %R: attribute lookup %S on %S failed\",\n                     obj, global_name, module_name);\n        goto error;\n    }\n    if (cls != obj) {\n        Py_DECREF(cls);\n        PyErr_Format(st->PicklingError,\n                     \"Can't pickle %R: it's not the same object as %S.%S\",\n                     obj, module_name, global_name);\n        goto error;\n    }\n    Py_DECREF(cls);\n\n    if (self->proto >= 2) {\n        /* See whether this is in the extension registry, and if\n         * so generate an EXT opcode.\n         */\n        PyObject *extension_key;\n        PyObject *code_obj;      /* extension code as Python object */\n        long code;               /* extension code as C value */\n        char pdata[5];\n        Py_ssize_t n;\n\n        extension_key = PyTuple_Pack(2, module_name, global_name);\n        if (extension_key == NULL) {\n            goto error;\n        }\n        code_obj = PyDict_GetItemWithError(st->extension_registry,\n                                           extension_key);\n        Py_DECREF(extension_key);\n        /* The object is not registered in the extension registry.\n           This is the most likely code path. */\n        if (code_obj == NULL) {\n            if (PyErr_Occurred()) {\n                goto error;\n            }\n            goto gen_global;\n        }\n\n        /* XXX: pickle.py doesn't check neither the type, nor the range\n           of the value returned by the extension_registry. It should for\n           consistency. */\n\n        /* Verify code_obj has the right type and value. */\n        if (!PyLong_Check(code_obj)) {\n            PyErr_Format(st->PicklingError,\n                         \"Can't pickle %R: extension code %R isn't an integer\",\n                         obj, code_obj);\n            goto error;\n        }\n        code = PyLong_AS_LONG(code_obj);\n        if (code <= 0 || code > 0x7fffffffL) {\n            if (!PyErr_Occurred())\n                PyErr_Format(st->PicklingError, \"Can't pickle %R: extension \"\n                             \"code %ld is out of range\", obj, code);\n            goto error;\n        }\n\n        /* Generate an EXT opcode. */\n        if (code <= 0xff) {\n            pdata[0] = EXT1;\n            pdata[1] = (unsigned char)code;\n            n = 2;\n        }\n        else if (code <= 0xffff) {\n            pdata[0] = EXT2;\n            pdata[1] = (unsigned char)(code & 0xff);\n            pdata[2] = (unsigned char)((code >> 8) & 0xff);\n            n = 3;\n        }\n        else {\n            pdata[0] = EXT4;\n            pdata[1] = (unsigned char)(code & 0xff);\n            pdata[2] = (unsigned char)((code >> 8) & 0xff);\n            pdata[3] = (unsigned char)((code >> 16) & 0xff);\n            pdata[4] = (unsigned char)((code >> 24) & 0xff);\n            n = 5;\n        }\n\n        if (_Pickler_Write(self, pdata, n) < 0)\n            goto error;\n    }\n    else {\n  gen_global:\n        if (parent == module) {\n            Py_INCREF(lastname);\n            Py_DECREF(global_name);\n            global_name = lastname;\n        }\n        if (self->proto >= 4) {\n            const char stack_global_op = STACK_GLOBAL;\n\n            if (save(self, module_name, 0) < 0)\n                goto error;\n            if (save(self, global_name, 0) < 0)\n                goto error;\n\n            if (_Pickler_Write(self, &stack_global_op, 1) < 0)\n                goto error;\n        }\n        else if (parent != module) {\n            PickleState *st = _Pickle_GetGlobalState();\n            PyObject *reduce_value = Py_BuildValue(\"(O(OO))\",\n                                        st->getattr, parent, lastname);\n            if (reduce_value == NULL)\n                goto error;\n            status = save_reduce(self, reduce_value, NULL);\n            Py_DECREF(reduce_value);\n            if (status < 0)\n                goto error;\n        }\n        else {\n            /* Generate a normal global opcode if we are using a pickle\n               protocol < 4, or if the object is not registered in the\n               extension registry. */\n            PyObject *encoded;\n            PyObject *(*unicode_encoder)(PyObject *);\n\n            if (_Pickler_Write(self, &global_op, 1) < 0)\n                goto error;\n\n            /* For protocol < 3 and if the user didn't request against doing\n               so, we convert module names to the old 2.x module names. */\n            if (self->proto < 3 && self->fix_imports) {\n                if (fix_imports(&module_name, &global_name) < 0) {\n                    goto error;\n                }\n            }\n\n            /* Since Python 3.0 now supports non-ASCII identifiers, we encode\n               both the module name and the global name using UTF-8. We do so\n               only when we are using the pickle protocol newer than version\n               3. This is to ensure compatibility with older Unpickler running\n               on Python 2.x. */\n            if (self->proto == 3) {\n                unicode_encoder = PyUnicode_AsUTF8String;\n            }\n            else {\n                unicode_encoder = PyUnicode_AsASCIIString;\n            }\n            encoded = unicode_encoder(module_name);\n            if (encoded == NULL) {\n                if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))\n                    PyErr_Format(st->PicklingError,\n                                 \"can't pickle module identifier '%S' using \"\n                                 \"pickle protocol %i\",\n                                 module_name, self->proto);\n                goto error;\n            }\n            if (_Pickler_Write(self, PyBytes_AS_STRING(encoded),\n                               PyBytes_GET_SIZE(encoded)) < 0) {\n                Py_DECREF(encoded);\n                goto error;\n            }\n            Py_DECREF(encoded);\n            if(_Pickler_Write(self, \"\\n\", 1) < 0)\n                goto error;\n\n            /* Save the name of the module. */\n            encoded = unicode_encoder(global_name);\n            if (encoded == NULL) {\n                if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))\n                    PyErr_Format(st->PicklingError,\n                                 \"can't pickle global identifier '%S' using \"\n                                 \"pickle protocol %i\",\n                                 global_name, self->proto);\n                goto error;\n            }\n            if (_Pickler_Write(self, PyBytes_AS_STRING(encoded),\n                               PyBytes_GET_SIZE(encoded)) < 0) {\n                Py_DECREF(encoded);\n                goto error;\n            }\n            Py_DECREF(encoded);\n            if (_Pickler_Write(self, \"\\n\", 1) < 0)\n                goto error;\n        }\n        /* Memoize the object. */\n        if (memo_put(self, obj) < 0)\n            goto error;\n    }\n\n    if (0) {\n  error:\n        status = -1;\n    }\n    Py_XDECREF(module_name);\n    Py_XDECREF(global_name);\n    Py_XDECREF(module);\n    Py_XDECREF(parent);\n    Py_XDECREF(dotted_path);\n    Py_XDECREF(lastname);\n\n    return status;\n}\n\nstatic int\nsave_singleton_type(PicklerObject *self, PyObject *obj, PyObject *singleton)\n{\n    PyObject *reduce_value;\n    int status;\n\n    reduce_value = Py_BuildValue(\"O(O)\", &PyType_Type, singleton);\n    if (reduce_value == NULL) {\n        return -1;\n    }\n    status = save_reduce(self, reduce_value, obj);\n    Py_DECREF(reduce_value);\n    return status;\n}\n\nstatic int\nsave_type(PicklerObject *self, PyObject *obj)\n{\n    if (obj == (PyObject *)&_PyNone_Type) {\n        return save_singleton_type(self, obj, Py_None);\n    }\n    else if (obj == (PyObject *)&PyEllipsis_Type) {\n        return save_singleton_type(self, obj, Py_Ellipsis);\n    }\n    else if (obj == (PyObject *)&_PyNotImplemented_Type) {\n        return save_singleton_type(self, obj, Py_NotImplemented);\n    }\n    return save_global(self, obj, NULL);\n}\n\nstatic int\nsave_pers(PicklerObject *self, PyObject *obj)\n{\n    PyObject *pid = NULL;\n    int status = 0;\n\n    const char persid_op = PERSID;\n    const char binpersid_op = BINPERSID;\n\n    pid = call_method(self->pers_func, self->pers_func_self, obj);\n    if (pid == NULL)\n        return -1;\n\n    if (pid != Py_None) {\n        if (self->bin) {\n            if (save(self, pid, 1) < 0 ||\n                _Pickler_Write(self, &binpersid_op, 1) < 0)\n                goto error;\n        }\n        else {\n            PyObject *pid_str;\n\n            pid_str = PyObject_Str(pid);\n            if (pid_str == NULL)\n                goto error;\n\n            /* XXX: Should it check whether the pid contains embedded\n               newlines? */\n            if (!PyUnicode_IS_ASCII(pid_str)) {\n                PyErr_SetString(_Pickle_GetGlobalState()->PicklingError,\n                                \"persistent IDs in protocol 0 must be \"\n                                \"ASCII strings\");\n                Py_DECREF(pid_str);\n                goto error;\n            }\n\n            if (_Pickler_Write(self, &persid_op, 1) < 0 ||\n                _Pickler_Write(self, PyUnicode_DATA(pid_str),\n                               PyUnicode_GET_LENGTH(pid_str)) < 0 ||\n                _Pickler_Write(self, \"\\n\", 1) < 0) {\n                Py_DECREF(pid_str);\n                goto error;\n            }\n            Py_DECREF(pid_str);\n        }\n        status = 1;\n    }\n\n    if (0) {\n  error:\n        status = -1;\n    }\n    Py_XDECREF(pid);\n\n    return status;\n}\n\nstatic PyObject *\nget_class(PyObject *obj)\n{\n    PyObject *cls;\n    _Py_IDENTIFIER(__class__);\n\n    if (_PyObject_LookupAttrId(obj, &PyId___class__, &cls) == 0) {\n        cls = (PyObject *) Py_TYPE(obj);\n        Py_INCREF(cls);\n    }\n    return cls;\n}\n\n/* We're saving obj, and args is the 2-thru-5 tuple returned by the\n * appropriate __reduce__ method for obj.\n */\nstatic int\nsave_reduce(PicklerObject *self, PyObject *args, PyObject *obj)\n{\n    PyObject *callable;\n    PyObject *argtup;\n    PyObject *state = NULL;\n    PyObject *listitems = Py_None;\n    PyObject *dictitems = Py_None;\n    PickleState *st = _Pickle_GetGlobalState();\n    Py_ssize_t size;\n    int use_newobj = 0, use_newobj_ex = 0;\n\n    const char reduce_op = REDUCE;\n    const char build_op = BUILD;\n    const char newobj_op = NEWOBJ;\n    const char newobj_ex_op = NEWOBJ_EX;\n\n    size = PyTuple_Size(args);\n    if (size < 2 || size > 5) {\n        PyErr_SetString(st->PicklingError, \"tuple returned by \"\n                        \"__reduce__ must contain 2 through 5 elements\");\n        return -1;\n    }\n\n    if (!PyArg_UnpackTuple(args, \"save_reduce\", 2, 5,\n                           &callable, &argtup, &state, &listitems, &dictitems))\n        return -1;\n\n    if (!PyCallable_Check(callable)) {\n        PyErr_SetString(st->PicklingError, \"first item of the tuple \"\n                        \"returned by __reduce__ must be callable\");\n        return -1;\n    }\n    if (!PyTuple_Check(argtup)) {\n        PyErr_SetString(st->PicklingError, \"second item of the tuple \"\n                        \"returned by __reduce__ must be a tuple\");\n        return -1;\n    }\n\n    if (state == Py_None)\n        state = NULL;\n\n    if (listitems == Py_None)\n        listitems = NULL;\n    else if (!PyIter_Check(listitems)) {\n        PyErr_Format(st->PicklingError, \"fourth element of the tuple \"\n                     \"returned by __reduce__ must be an iterator, not %s\",\n                     Py_TYPE(listitems)->tp_name);\n        return -1;\n    }\n\n    if (dictitems == Py_None)\n        dictitems = NULL;\n    else if (!PyIter_Check(dictitems)) {\n        PyErr_Format(st->PicklingError, \"fifth element of the tuple \"\n                     \"returned by __reduce__ must be an iterator, not %s\",\n                     Py_TYPE(dictitems)->tp_name);\n        return -1;\n    }\n\n    if (self->proto >= 2) {\n        PyObject *name;\n        _Py_IDENTIFIER(__name__);\n\n        if (_PyObject_LookupAttrId(callable, &PyId___name__, &name) < 0) {\n            return -1;\n        }\n        if (name != NULL && PyUnicode_Check(name)) {\n            _Py_IDENTIFIER(__newobj_ex__);\n            use_newobj_ex = _PyUnicode_EqualToASCIIId(\n                    name, &PyId___newobj_ex__);\n            if (!use_newobj_ex) {\n                _Py_IDENTIFIER(__newobj__);\n                use_newobj = _PyUnicode_EqualToASCIIId(name, &PyId___newobj__);\n            }\n        }\n        Py_XDECREF(name);\n    }\n\n    if (use_newobj_ex) {\n        PyObject *cls;\n        PyObject *args;\n        PyObject *kwargs;\n\n        if (PyTuple_GET_SIZE(argtup) != 3) {\n            PyErr_Format(st->PicklingError,\n                         \"length of the NEWOBJ_EX argument tuple must be \"\n                         \"exactly 3, not %zd\", PyTuple_GET_SIZE(argtup));\n            return -1;\n        }\n\n        cls = PyTuple_GET_ITEM(argtup, 0);\n        if (!PyType_Check(cls)) {\n            PyErr_Format(st->PicklingError,\n                         \"first item from NEWOBJ_EX argument tuple must \"\n                         \"be a class, not %.200s\", Py_TYPE(cls)->tp_name);\n            return -1;\n        }\n        args = PyTuple_GET_ITEM(argtup, 1);\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(st->PicklingError,\n                         \"second item from NEWOBJ_EX argument tuple must \"\n                         \"be a tuple, not %.200s\", Py_TYPE(args)->tp_name);\n            return -1;\n        }\n        kwargs = PyTuple_GET_ITEM(argtup, 2);\n        if (!PyDict_Check(kwargs)) {\n            PyErr_Format(st->PicklingError,\n                         \"third item from NEWOBJ_EX argument tuple must \"\n                         \"be a dict, not %.200s\", Py_TYPE(kwargs)->tp_name);\n            return -1;\n        }\n\n        if (self->proto >= 4) {\n            if (save(self, cls, 0) < 0 ||\n                save(self, args, 0) < 0 ||\n                save(self, kwargs, 0) < 0 ||\n                _Pickler_Write(self, &newobj_ex_op, 1) < 0) {\n                return -1;\n            }\n        }\n        else {\n            PyObject *newargs;\n            PyObject *cls_new;\n            Py_ssize_t i;\n            _Py_IDENTIFIER(__new__);\n\n            newargs = PyTuple_New(PyTuple_GET_SIZE(args) + 2);\n            if (newargs == NULL)\n                return -1;\n\n            cls_new = _PyObject_GetAttrId(cls, &PyId___new__);\n            if (cls_new == NULL) {\n                Py_DECREF(newargs);\n                return -1;\n            }\n            PyTuple_SET_ITEM(newargs, 0, cls_new);\n            Py_INCREF(cls);\n            PyTuple_SET_ITEM(newargs, 1, cls);\n            for (i = 0; i < PyTuple_GET_SIZE(args); i++) {\n                PyObject *item = PyTuple_GET_ITEM(args, i);\n                Py_INCREF(item);\n                PyTuple_SET_ITEM(newargs, i + 2, item);\n            }\n\n            callable = PyObject_Call(st->partial, newargs, kwargs);\n            Py_DECREF(newargs);\n            if (callable == NULL)\n                return -1;\n\n            newargs = PyTuple_New(0);\n            if (newargs == NULL) {\n                Py_DECREF(callable);\n                return -1;\n            }\n\n            if (save(self, callable, 0) < 0 ||\n                save(self, newargs, 0) < 0 ||\n                _Pickler_Write(self, &reduce_op, 1) < 0) {\n                Py_DECREF(newargs);\n                Py_DECREF(callable);\n                return -1;\n            }\n            Py_DECREF(newargs);\n            Py_DECREF(callable);\n        }\n    }\n    else if (use_newobj) {\n        PyObject *cls;\n        PyObject *newargtup;\n        PyObject *obj_class;\n        int p;\n\n        /* Sanity checks. */\n        if (PyTuple_GET_SIZE(argtup) < 1) {\n            PyErr_SetString(st->PicklingError, \"__newobj__ arglist is empty\");\n            return -1;\n        }\n\n        cls = PyTuple_GET_ITEM(argtup, 0);\n        if (!PyType_Check(cls)) {\n            PyErr_SetString(st->PicklingError, \"args[0] from \"\n                            \"__newobj__ args is not a type\");\n            return -1;\n        }\n\n        if (obj != NULL) {\n            obj_class = get_class(obj);\n            p = obj_class != cls;    /* true iff a problem */\n            Py_DECREF(obj_class);\n            if (p) {\n                PyErr_SetString(st->PicklingError, \"args[0] from \"\n                                \"__newobj__ args has the wrong class\");\n                return -1;\n            }\n        }\n        /* XXX: These calls save() are prone to infinite recursion. Imagine\n           what happen if the value returned by the __reduce__() method of\n           some extension type contains another object of the same type. Ouch!\n\n           Here is a quick example, that I ran into, to illustrate what I\n           mean:\n\n             >>> import pickle, copyreg\n             >>> copyreg.dispatch_table.pop(complex)\n             >>> pickle.dumps(1+2j)\n             Traceback (most recent call last):\n               ...\n             RecursionError: maximum recursion depth exceeded\n\n           Removing the complex class from copyreg.dispatch_table made the\n           __reduce_ex__() method emit another complex object:\n\n             >>> (1+1j).__reduce_ex__(2)\n             (<function __newobj__ at 0xb7b71c3c>,\n               (<class 'complex'>, (1+1j)), None, None, None)\n\n           Thus when save() was called on newargstup (the 2nd item) recursion\n           ensued. Of course, the bug was in the complex class which had a\n           broken __getnewargs__() that emitted another complex object. But,\n           the point, here, is it is quite easy to end up with a broken reduce\n           function. */\n\n        /* Save the class and its __new__ arguments. */\n        if (save(self, cls, 0) < 0)\n            return -1;\n\n        newargtup = PyTuple_GetSlice(argtup, 1, PyTuple_GET_SIZE(argtup));\n        if (newargtup == NULL)\n            return -1;\n\n        p = save(self, newargtup, 0);\n        Py_DECREF(newargtup);\n        if (p < 0)\n            return -1;\n\n        /* Add NEWOBJ opcode. */\n        if (_Pickler_Write(self, &newobj_op, 1) < 0)\n            return -1;\n    }\n    else { /* Not using NEWOBJ. */\n        if (save(self, callable, 0) < 0 ||\n            save(self, argtup, 0) < 0 ||\n            _Pickler_Write(self, &reduce_op, 1) < 0)\n            return -1;\n    }\n\n    /* obj can be NULL when save_reduce() is used directly. A NULL obj means\n       the caller do not want to memoize the object. Not particularly useful,\n       but that is to mimic the behavior save_reduce() in pickle.py when\n       obj is None. */\n    if (obj != NULL) {\n        /* If the object is already in the memo, this means it is\n           recursive. In this case, throw away everything we put on the\n           stack, and fetch the object back from the memo. */\n        if (PyMemoTable_Get(self->memo, obj)) {\n            const char pop_op = POP;\n\n            if (_Pickler_Write(self, &pop_op, 1) < 0)\n                return -1;\n            if (memo_get(self, obj) < 0)\n                return -1;\n\n            return 0;\n        }\n        else if (memo_put(self, obj) < 0)\n            return -1;\n    }\n\n    if (listitems && batch_list(self, listitems) < 0)\n        return -1;\n\n    if (dictitems && batch_dict(self, dictitems) < 0)\n        return -1;\n\n    if (state) {\n        if (save(self, state, 0) < 0 ||\n            _Pickler_Write(self, &build_op, 1) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\nstatic int\nsave(PicklerObject *self, PyObject *obj, int pers_save)\n{\n    PyTypeObject *type;\n    PyObject *reduce_func = NULL;\n    PyObject *reduce_value = NULL;\n    int status = 0;\n\n    if (_Pickler_OpcodeBoundary(self) < 0)\n        return -1;\n\n    /* The extra pers_save argument is necessary to avoid calling save_pers()\n       on its returned object. */\n    if (!pers_save && self->pers_func) {\n        /* save_pers() returns:\n            -1   to signal an error;\n             0   if it did nothing successfully;\n             1   if a persistent id was saved.\n         */\n        if ((status = save_pers(self, obj)) != 0)\n            return status;\n    }\n\n    type = Py_TYPE(obj);\n\n    /* The old cPickle had an optimization that used switch-case statement\n       dispatching on the first letter of the type name.  This has was removed\n       since benchmarks shown that this optimization was actually slowing\n       things down. */\n\n    /* Atom types; these aren't memoized, so don't check the memo. */\n\n    if (obj == Py_None) {\n        return save_none(self, obj);\n    }\n    else if (obj == Py_False || obj == Py_True) {\n        return save_bool(self, obj);\n    }\n    else if (type == &PyLong_Type) {\n        return save_long(self, obj);\n    }\n    else if (type == &PyFloat_Type) {\n        return save_float(self, obj);\n    }\n\n    /* Check the memo to see if it has the object. If so, generate\n       a GET (or BINGET) opcode, instead of pickling the object\n       once again. */\n    if (PyMemoTable_Get(self->memo, obj)) {\n        return memo_get(self, obj);\n    }\n\n    if (type == &PyBytes_Type) {\n        return save_bytes(self, obj);\n    }\n    else if (type == &PyUnicode_Type) {\n        return save_unicode(self, obj);\n    }\n\n    /* We're only calling Py_EnterRecursiveCall here so that atomic\n       types above are pickled faster. */\n    if (Py_EnterRecursiveCall(\" while pickling an object\")) {\n        return -1;\n    }\n\n    if (type == &PyDict_Type) {\n        status = save_dict(self, obj);\n        goto done;\n    }\n    else if (type == &PySet_Type) {\n        status = save_set(self, obj);\n        goto done;\n    }\n    else if (type == &PyFrozenSet_Type) {\n        status = save_frozenset(self, obj);\n        goto done;\n    }\n    else if (type == &PyList_Type) {\n        status = save_list(self, obj);\n        goto done;\n    }\n    else if (type == &PyTuple_Type) {\n        status = save_tuple(self, obj);\n        goto done;\n    }\n    else if (type == &PyType_Type) {\n        status = save_type(self, obj);\n        goto done;\n    }\n    else if (type == &PyFunction_Type) {\n        status = save_global(self, obj, NULL);\n        goto done;\n    }\n\n    /* XXX: This part needs some unit tests. */\n\n    /* Get a reduction callable, and call it.  This may come from\n     * self.dispatch_table, copyreg.dispatch_table, the object's\n     * __reduce_ex__ method, or the object's __reduce__ method.\n     */\n    if (self->dispatch_table == NULL) {\n        PickleState *st = _Pickle_GetGlobalState();\n        reduce_func = PyDict_GetItemWithError(st->dispatch_table,\n                                              (PyObject *)type);\n        if (reduce_func == NULL) {\n            if (PyErr_Occurred()) {\n                goto error;\n            }\n        } else {\n            /* PyDict_GetItemWithError() returns a borrowed reference.\n               Increase the reference count to be consistent with\n               PyObject_GetItem and _PyObject_GetAttrId used below. */\n            Py_INCREF(reduce_func);\n        }\n    } else {\n        reduce_func = PyObject_GetItem(self->dispatch_table,\n                                       (PyObject *)type);\n        if (reduce_func == NULL) {\n            if (PyErr_ExceptionMatches(PyExc_KeyError))\n                PyErr_Clear();\n            else\n                goto error;\n        }\n    }\n    if (reduce_func != NULL) {\n        Py_INCREF(obj);\n        reduce_value = _Pickle_FastCall(reduce_func, obj);\n    }\n    else if (PyType_IsSubtype(type, &PyType_Type)) {\n        status = save_global(self, obj, NULL);\n        goto done;\n    }\n    else {\n        _Py_IDENTIFIER(__reduce__);\n        _Py_IDENTIFIER(__reduce_ex__);\n\n\n        /* XXX: If the __reduce__ method is defined, __reduce_ex__ is\n           automatically defined as __reduce__. While this is convenient, this\n           make it impossible to know which method was actually called. Of\n           course, this is not a big deal. But still, it would be nice to let\n           the user know which method was called when something go\n           wrong. Incidentally, this means if __reduce_ex__ is not defined, we\n           don't actually have to check for a __reduce__ method. */\n\n        /* Check for a __reduce_ex__ method. */\n        if (_PyObject_LookupAttrId(obj, &PyId___reduce_ex__, &reduce_func) < 0) {\n            goto error;\n        }\n        if (reduce_func != NULL) {\n            PyObject *proto;\n            proto = PyLong_FromLong(self->proto);\n            if (proto != NULL) {\n                reduce_value = _Pickle_FastCall(reduce_func, proto);\n            }\n        }\n        else {\n            PickleState *st = _Pickle_GetGlobalState();\n\n            /* Check for a __reduce__ method. */\n            reduce_func = _PyObject_GetAttrId(obj, &PyId___reduce__);\n            if (reduce_func != NULL) {\n                reduce_value = _PyObject_CallNoArg(reduce_func);\n            }\n            else {\n                PyErr_Format(st->PicklingError,\n                             \"can't pickle '%.200s' object: %R\",\n                             type->tp_name, obj);\n                goto error;\n            }\n        }\n    }\n\n    if (reduce_value == NULL)\n        goto error;\n\n    if (PyUnicode_Check(reduce_value)) {\n        status = save_global(self, obj, reduce_value);\n        goto done;\n    }\n\n    if (!PyTuple_Check(reduce_value)) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->PicklingError,\n                        \"__reduce__ must return a string or tuple\");\n        goto error;\n    }\n\n    status = save_reduce(self, reduce_value, obj);\n\n    if (0) {\n  error:\n        status = -1;\n    }\n  done:\n\n    Py_LeaveRecursiveCall();\n    Py_XDECREF(reduce_func);\n    Py_XDECREF(reduce_value);\n\n    return status;\n}\n\nstatic int\ndump(PicklerObject *self, PyObject *obj)\n{\n    const char stop_op = STOP;\n\n    if (self->proto >= 2) {\n        char header[2];\n\n        header[0] = PROTO;\n        assert(self->proto >= 0 && self->proto < 256);\n        header[1] = (unsigned char)self->proto;\n        if (_Pickler_Write(self, header, 2) < 0)\n            return -1;\n        if (self->proto >= 4)\n            self->framing = 1;\n    }\n\n    if (save(self, obj, 0) < 0 ||\n        _Pickler_Write(self, &stop_op, 1) < 0 ||\n        _Pickler_CommitFrame(self) < 0)\n        return -1;\n    self->framing = 0;\n    return 0;\n}\n\n/*[clinic input]\n\n_pickle.Pickler.clear_memo\n\nClears the pickler's \"memo\".\n\nThe memo is the data structure that remembers which objects the\npickler has already seen, so that shared or recursive objects are\npickled by reference and not by value.  This method is useful when\nre-using picklers.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_Pickler_clear_memo_impl(PicklerObject *self)\n/*[clinic end generated code: output=8665c8658aaa094b input=01bdad52f3d93e56]*/\n{\n    if (self->memo)\n        PyMemoTable_Clear(self->memo);\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n\n_pickle.Pickler.dump\n\n  obj: object\n  /\n\nWrite a pickled representation of the given object to the open file.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_Pickler_dump(PicklerObject *self, PyObject *obj)\n/*[clinic end generated code: output=87ecad1261e02ac7 input=552eb1c0f52260d9]*/\n{\n    /* Check whether the Pickler was initialized correctly (issue3664).\n       Developers often forget to call __init__() in their subclasses, which\n       would trigger a segfault without this check. */\n    if (self->write == NULL) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_Format(st->PicklingError,\n                     \"Pickler.__init__() was not called by %s.__init__()\",\n                     Py_TYPE(self)->tp_name);\n        return NULL;\n    }\n\n    if (_Pickler_ClearBuffer(self) < 0)\n        return NULL;\n\n    if (dump(self, obj) < 0)\n        return NULL;\n\n    if (_Pickler_FlushToFile(self) < 0)\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n\n_pickle.Pickler.__sizeof__ -> Py_ssize_t\n\nReturns size in memory, in bytes.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_pickle_Pickler___sizeof___impl(PicklerObject *self)\n/*[clinic end generated code: output=106edb3123f332e1 input=8cbbec9bd5540d42]*/\n{\n    Py_ssize_t res, s;\n\n    res = _PyObject_SIZE(Py_TYPE(self));\n    if (self->memo != NULL) {\n        res += sizeof(PyMemoTable);\n        res += self->memo->mt_allocated * sizeof(PyMemoEntry);\n    }\n    if (self->output_buffer != NULL) {\n        s = _PySys_GetSizeOf(self->output_buffer);\n        if (s == -1)\n            return -1;\n        res += s;\n    }\n    return res;\n}\n\nstatic struct PyMethodDef Pickler_methods[] = {\n    _PICKLE_PICKLER_DUMP_METHODDEF\n    _PICKLE_PICKLER_CLEAR_MEMO_METHODDEF\n    _PICKLE_PICKLER___SIZEOF___METHODDEF\n    {NULL, NULL}                /* sentinel */\n};\n\nstatic void\nPickler_dealloc(PicklerObject *self)\n{\n    PyObject_GC_UnTrack(self);\n\n    Py_XDECREF(self->output_buffer);\n    Py_XDECREF(self->write);\n    Py_XDECREF(self->pers_func);\n    Py_XDECREF(self->dispatch_table);\n    Py_XDECREF(self->fast_memo);\n\n    PyMemoTable_Del(self->memo);\n\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic int\nPickler_traverse(PicklerObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->write);\n    Py_VISIT(self->pers_func);\n    Py_VISIT(self->dispatch_table);\n    Py_VISIT(self->fast_memo);\n    return 0;\n}\n\nstatic int\nPickler_clear(PicklerObject *self)\n{\n    Py_CLEAR(self->output_buffer);\n    Py_CLEAR(self->write);\n    Py_CLEAR(self->pers_func);\n    Py_CLEAR(self->dispatch_table);\n    Py_CLEAR(self->fast_memo);\n\n    if (self->memo != NULL) {\n        PyMemoTable *memo = self->memo;\n        self->memo = NULL;\n        PyMemoTable_Del(memo);\n    }\n    return 0;\n}\n\n\n/*[clinic input]\n\n_pickle.Pickler.__init__\n\n  file: object\n  protocol: object = NULL\n  fix_imports: bool = True\n\nThis takes a binary file for writing a pickle data stream.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3 and 4.  The default\nprotocol is 3; a backward-incompatible protocol designed for Python 3.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument. It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n[clinic start generated code]*/\n\nstatic int\n_pickle_Pickler___init___impl(PicklerObject *self, PyObject *file,\n                              PyObject *protocol, int fix_imports)\n/*[clinic end generated code: output=b5f31078dab17fb0 input=4faabdbc763c2389]*/\n{\n    _Py_IDENTIFIER(persistent_id);\n    _Py_IDENTIFIER(dispatch_table);\n\n    /* In case of multiple __init__() calls, clear previous content. */\n    if (self->write != NULL)\n        (void)Pickler_clear(self);\n\n    if (_Pickler_SetProtocol(self, protocol, fix_imports) < 0)\n        return -1;\n\n    if (_Pickler_SetOutputStream(self, file) < 0)\n        return -1;\n\n    /* memo and output_buffer may have already been created in _Pickler_New */\n    if (self->memo == NULL) {\n        self->memo = PyMemoTable_New();\n        if (self->memo == NULL)\n            return -1;\n    }\n    self->output_len = 0;\n    if (self->output_buffer == NULL) {\n        self->max_output_len = WRITE_BUF_SIZE;\n        self->output_buffer = PyBytes_FromStringAndSize(NULL,\n                                                        self->max_output_len);\n        if (self->output_buffer == NULL)\n            return -1;\n    }\n\n    self->fast = 0;\n    self->fast_nesting = 0;\n    self->fast_memo = NULL;\n\n    if (init_method_ref((PyObject *)self, &PyId_persistent_id,\n                        &self->pers_func, &self->pers_func_self) < 0)\n    {\n        return -1;\n    }\n\n    if (_PyObject_LookupAttrId((PyObject *)self,\n                                    &PyId_dispatch_table, &self->dispatch_table) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n\n\n/* Define a proxy object for the Pickler's internal memo object. This is to\n * avoid breaking code like:\n *  pickler.memo.clear()\n * and\n *  pickler.memo = saved_memo\n * Is this a good idea? Not really, but we don't want to break code that uses\n * it. Note that we don't implement the entire mapping API here. This is\n * intentional, as these should be treated as black-box implementation details.\n */\n\n/*[clinic input]\n_pickle.PicklerMemoProxy.clear\n\nRemove all items from memo.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_PicklerMemoProxy_clear_impl(PicklerMemoProxyObject *self)\n/*[clinic end generated code: output=5fb9370d48ae8b05 input=ccc186dacd0f1405]*/\n{\n    if (self->pickler->memo)\n        PyMemoTable_Clear(self->pickler->memo);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_pickle.PicklerMemoProxy.copy\n\nCopy the memo to a new object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *self)\n/*[clinic end generated code: output=bb83a919d29225ef input=b73043485ac30b36]*/\n{\n    Py_ssize_t i;\n    PyMemoTable *memo;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    memo = self->pickler->memo;\n    for (i = 0; i < memo->mt_allocated; ++i) {\n        PyMemoEntry entry = memo->mt_table[i];\n        if (entry.me_key != NULL) {\n            int status;\n            PyObject *key, *value;\n\n            key = PyLong_FromVoidPtr(entry.me_key);\n            value = Py_BuildValue(\"nO\", entry.me_value, entry.me_key);\n\n            if (key == NULL || value == NULL) {\n                Py_XDECREF(key);\n                Py_XDECREF(value);\n                goto error;\n            }\n            status = PyDict_SetItem(new_memo, key, value);\n            Py_DECREF(key);\n            Py_DECREF(value);\n            if (status < 0)\n                goto error;\n        }\n    }\n    return new_memo;\n\n  error:\n    Py_XDECREF(new_memo);\n    return NULL;\n}\n\n/*[clinic input]\n_pickle.PicklerMemoProxy.__reduce__\n\nImplement pickle support.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_PicklerMemoProxy___reduce___impl(PicklerMemoProxyObject *self)\n/*[clinic end generated code: output=bebba1168863ab1d input=2f7c540e24b7aae4]*/\n{\n    PyObject *reduce_value, *dict_args;\n    PyObject *contents = _pickle_PicklerMemoProxy_copy_impl(self);\n    if (contents == NULL)\n        return NULL;\n\n    reduce_value = PyTuple_New(2);\n    if (reduce_value == NULL) {\n        Py_DECREF(contents);\n        return NULL;\n    }\n    dict_args = PyTuple_New(1);\n    if (dict_args == NULL) {\n        Py_DECREF(contents);\n        Py_DECREF(reduce_value);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(dict_args, 0, contents);\n    Py_INCREF((PyObject *)&PyDict_Type);\n    PyTuple_SET_ITEM(reduce_value, 0, (PyObject *)&PyDict_Type);\n    PyTuple_SET_ITEM(reduce_value, 1, dict_args);\n    return reduce_value;\n}\n\nstatic PyMethodDef picklerproxy_methods[] = {\n    _PICKLE_PICKLERMEMOPROXY_CLEAR_METHODDEF\n    _PICKLE_PICKLERMEMOPROXY_COPY_METHODDEF\n    _PICKLE_PICKLERMEMOPROXY___REDUCE___METHODDEF\n    {NULL, NULL} /* sentinel */\n};\n\nstatic void\nPicklerMemoProxy_dealloc(PicklerMemoProxyObject *self)\n{\n    PyObject_GC_UnTrack(self);\n    Py_XDECREF(self->pickler);\n    PyObject_GC_Del((PyObject *)self);\n}\n\nstatic int\nPicklerMemoProxy_traverse(PicklerMemoProxyObject *self,\n                          visitproc visit, void *arg)\n{\n    Py_VISIT(self->pickler);\n    return 0;\n}\n\nstatic int\nPicklerMemoProxy_clear(PicklerMemoProxyObject *self)\n{\n    Py_CLEAR(self->pickler);\n    return 0;\n}\n\nstatic PyTypeObject PicklerMemoProxyType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.PicklerMemoProxy\",                 /*tp_name*/\n    sizeof(PicklerMemoProxyObject),             /*tp_basicsize*/\n    0,\n    (destructor)PicklerMemoProxy_dealloc,       /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    PyObject_HashNotImplemented,                /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    PyObject_GenericSetAttr,                    /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)PicklerMemoProxy_traverse,    /* tp_traverse */\n    (inquiry)PicklerMemoProxy_clear,            /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    picklerproxy_methods,                       /* tp_methods */\n};\n\nstatic PyObject *\nPicklerMemoProxy_New(PicklerObject *pickler)\n{\n    PicklerMemoProxyObject *self;\n\n    self = PyObject_GC_New(PicklerMemoProxyObject, &PicklerMemoProxyType);\n    if (self == NULL)\n        return NULL;\n    Py_INCREF(pickler);\n    self->pickler = pickler;\n    PyObject_GC_Track(self);\n    return (PyObject *)self;\n}\n\n/*****************************************************************************/\n\nstatic PyObject *\nPickler_get_memo(PicklerObject *self)\n{\n    return PicklerMemoProxy_New(self);\n}\n\nstatic int\nPickler_set_memo(PicklerObject *self, PyObject *obj)\n{\n    PyMemoTable *new_memo = NULL;\n\n    if (obj == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(obj) == &PicklerMemoProxyType) {\n        PicklerObject *pickler =\n            ((PicklerMemoProxyObject *)obj)->pickler;\n\n        new_memo = PyMemoTable_Copy(pickler->memo);\n        if (new_memo == NULL)\n            return -1;\n    }\n    else if (PyDict_Check(obj)) {\n        Py_ssize_t i = 0;\n        PyObject *key, *value;\n\n        new_memo = PyMemoTable_New();\n        if (new_memo == NULL)\n            return -1;\n\n        while (PyDict_Next(obj, &i, &key, &value)) {\n            Py_ssize_t memo_id;\n            PyObject *memo_obj;\n\n            if (!PyTuple_Check(value) || PyTuple_GET_SIZE(value) != 2) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"'memo' values must be 2-item tuples\");\n                goto error;\n            }\n            memo_id = PyLong_AsSsize_t(PyTuple_GET_ITEM(value, 0));\n            if (memo_id == -1 && PyErr_Occurred())\n                goto error;\n            memo_obj = PyTuple_GET_ITEM(value, 1);\n            if (PyMemoTable_Set(new_memo, memo_obj, memo_id) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"'memo' attribute must be a PicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(obj)->tp_name);\n        return -1;\n    }\n\n    PyMemoTable_Del(self->memo);\n    self->memo = new_memo;\n\n    return 0;\n\n  error:\n    if (new_memo)\n        PyMemoTable_Del(new_memo);\n    return -1;\n}\n\nstatic PyObject *\nPickler_get_persid(PicklerObject *self)\n{\n    if (self->pers_func == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"persistent_id\");\n        return NULL;\n    }\n    return reconstruct_method(self->pers_func, self->pers_func_self);\n}\n\nstatic int\nPickler_set_persid(PicklerObject *self, PyObject *value)\n{\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n    if (!PyCallable_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"persistent_id must be a callable taking one argument\");\n        return -1;\n    }\n\n    self->pers_func_self = NULL;\n    Py_INCREF(value);\n    Py_XSETREF(self->pers_func, value);\n\n    return 0;\n}\n\nstatic PyMemberDef Pickler_members[] = {\n    {\"bin\", T_INT, offsetof(PicklerObject, bin)},\n    {\"fast\", T_INT, offsetof(PicklerObject, fast)},\n    {\"dispatch_table\", T_OBJECT_EX, offsetof(PicklerObject, dispatch_table)},\n    {NULL}\n};\n\nstatic PyGetSetDef Pickler_getsets[] = {\n    {\"memo\",          (getter)Pickler_get_memo,\n                      (setter)Pickler_set_memo},\n    {\"persistent_id\", (getter)Pickler_get_persid,\n                      (setter)Pickler_set_persid},\n    {NULL}\n};\n\nstatic PyTypeObject Pickler_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.Pickler\"  ,                /*tp_name*/\n    sizeof(PicklerObject),              /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    (destructor)Pickler_dealloc,        /*tp_dealloc*/\n    0,                                  /*tp_print*/\n    0,                                  /*tp_getattr*/\n    0,                                  /*tp_setattr*/\n    0,                                  /*tp_reserved*/\n    0,                                  /*tp_repr*/\n    0,                                  /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    0,                                  /*tp_hash*/\n    0,                                  /*tp_call*/\n    0,                                  /*tp_str*/\n    0,                                  /*tp_getattro*/\n    0,                                  /*tp_setattro*/\n    0,                                  /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n    _pickle_Pickler___init____doc__,    /*tp_doc*/\n    (traverseproc)Pickler_traverse,     /*tp_traverse*/\n    (inquiry)Pickler_clear,             /*tp_clear*/\n    0,                                  /*tp_richcompare*/\n    0,                                  /*tp_weaklistoffset*/\n    0,                                  /*tp_iter*/\n    0,                                  /*tp_iternext*/\n    Pickler_methods,                    /*tp_methods*/\n    Pickler_members,                    /*tp_members*/\n    Pickler_getsets,                    /*tp_getset*/\n    0,                                  /*tp_base*/\n    0,                                  /*tp_dict*/\n    0,                                  /*tp_descr_get*/\n    0,                                  /*tp_descr_set*/\n    0,                                  /*tp_dictoffset*/\n    _pickle_Pickler___init__,           /*tp_init*/\n    PyType_GenericAlloc,                /*tp_alloc*/\n    PyType_GenericNew,                  /*tp_new*/\n    PyObject_GC_Del,                    /*tp_free*/\n    0,                                  /*tp_is_gc*/\n};\n\n/* Temporary helper for calling self.find_class().\n\n   XXX: It would be nice to able to avoid Python function call overhead, by\n   using directly the C version of find_class(), when find_class() is not\n   overridden by a subclass. Although, this could become rather hackish. A\n   simpler optimization would be to call the C function when self is not a\n   subclass instance. */\nstatic PyObject *\nfind_class(UnpicklerObject *self, PyObject *module_name, PyObject *global_name)\n{\n    _Py_IDENTIFIER(find_class);\n\n    return _PyObject_CallMethodIdObjArgs((PyObject *)self, &PyId_find_class,\n                                         module_name, global_name, NULL);\n}\n\nstatic Py_ssize_t\nmarker(UnpicklerObject *self)\n{\n    Py_ssize_t mark;\n\n    if (self->num_marks < 1) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError, \"could not find MARK\");\n        return -1;\n    }\n\n    mark = self->marks[--self->num_marks];\n    self->stack->mark_set = self->num_marks != 0;\n    self->stack->fence = self->num_marks ?\n            self->marks[self->num_marks - 1] : 0;\n    return mark;\n}\n\nstatic int\nload_none(UnpicklerObject *self)\n{\n    PDATA_APPEND(self->stack, Py_None, -1);\n    return 0;\n}\n\nstatic int\nload_int(UnpicklerObject *self)\n{\n    PyObject *value;\n    char *endptr, *s;\n    Py_ssize_t len;\n    long x;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    errno = 0;\n    /* XXX: Should the base argument of strtol() be explicitly set to 10?\n       XXX(avassalotti): Should this uses PyOS_strtol()? */\n    x = strtol(s, &endptr, 0);\n\n    if (errno || (*endptr != '\\n' && *endptr != '\\0')) {\n        /* Hm, maybe we've got something long.  Let's try reading\n         * it as a Python int object. */\n        errno = 0;\n        /* XXX: Same thing about the base here. */\n        value = PyLong_FromString(s, NULL, 0);\n        if (value == NULL) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"could not convert string to int\");\n            return -1;\n        }\n    }\n    else {\n        if (len == 3 && (x == 0 || x == 1)) {\n            if ((value = PyBool_FromLong(x)) == NULL)\n                return -1;\n        }\n        else {\n            if ((value = PyLong_FromLong(x)) == NULL)\n                return -1;\n        }\n    }\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_bool(UnpicklerObject *self, PyObject *boolean)\n{\n    assert(boolean == Py_True || boolean == Py_False);\n    PDATA_APPEND(self->stack, boolean, -1);\n    return 0;\n}\n\n/* s contains x bytes of an unsigned little-endian integer.  Return its value\n * as a C Py_ssize_t, or -1 if it's higher than PY_SSIZE_T_MAX.\n */\nstatic Py_ssize_t\ncalc_binsize(char *bytes, int nbytes)\n{\n    unsigned char *s = (unsigned char *)bytes;\n    int i;\n    size_t x = 0;\n\n    if (nbytes > (int)sizeof(size_t)) {\n        /* Check for integer overflow.  BINBYTES8 and BINUNICODE8 opcodes\n         * have 64-bit size that can't be represented on 32-bit platform.\n         */\n        for (i = (int)sizeof(size_t); i < nbytes; i++) {\n            if (s[i])\n                return -1;\n        }\n        nbytes = (int)sizeof(size_t);\n    }\n    for (i = 0; i < nbytes; i++) {\n        x |= (size_t) s[i] << (8 * i);\n    }\n\n    if (x > PY_SSIZE_T_MAX)\n        return -1;\n    else\n        return (Py_ssize_t) x;\n}\n\n/* s contains x bytes of a little-endian integer.  Return its value as a\n * C int.  Obscure:  when x is 1 or 2, this is an unsigned little-endian\n * int, but when x is 4 it's a signed one.  This is a historical source\n * of x-platform bugs.\n */\nstatic long\ncalc_binint(char *bytes, int nbytes)\n{\n    unsigned char *s = (unsigned char *)bytes;\n    Py_ssize_t i;\n    long x = 0;\n\n    for (i = 0; i < nbytes; i++) {\n        x |= (long)s[i] << (8 * i);\n    }\n\n    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)\n     * is signed, so on a box with longs bigger than 4 bytes we need\n     * to extend a BININT's sign bit to the full width.\n     */\n    if (SIZEOF_LONG > 4 && nbytes == 4) {\n        x |= -(x & (1L << 31));\n    }\n\n    return x;\n}\n\nstatic int\nload_binintx(UnpicklerObject *self, char *s, int size)\n{\n    PyObject *value;\n    long x;\n\n    x = calc_binint(s, size);\n\n    if ((value = PyLong_FromLong(x)) == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_binint(UnpicklerObject *self)\n{\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 4) < 0)\n        return -1;\n\n    return load_binintx(self, s, 4);\n}\n\nstatic int\nload_binint1(UnpicklerObject *self)\n{\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 1) < 0)\n        return -1;\n\n    return load_binintx(self, s, 1);\n}\n\nstatic int\nload_binint2(UnpicklerObject *self)\n{\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 2) < 0)\n        return -1;\n\n    return load_binintx(self, s, 2);\n}\n\nstatic int\nload_long(UnpicklerObject *self)\n{\n    PyObject *value;\n    char *s = NULL;\n    Py_ssize_t len;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    /* s[len-2] will usually be 'L' (and s[len-1] is '\\n'); we need to remove\n       the 'L' before calling PyLong_FromString.  In order to maintain\n       compatibility with Python 3.0.0, we don't actually *require*\n       the 'L' to be present. */\n    if (s[len-2] == 'L')\n        s[len-2] = '\\0';\n    /* XXX: Should the base argument explicitly set to 10? */\n    value = PyLong_FromString(s, NULL, 0);\n    if (value == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\n/* 'size' bytes contain the # of bytes of little-endian 256's-complement\n * data following.\n */\nstatic int\nload_counted_long(UnpicklerObject *self, int size)\n{\n    PyObject *value;\n    char *nbytes;\n    char *pdata;\n\n    assert(size == 1 || size == 4);\n    if (_Unpickler_Read(self, &nbytes, size) < 0)\n        return -1;\n\n    size = calc_binint(nbytes, size);\n    if (size < 0) {\n        PickleState *st = _Pickle_GetGlobalState();\n        /* Corrupt or hostile pickle -- we never write one like this */\n        PyErr_SetString(st->UnpicklingError,\n                        \"LONG pickle has negative byte count\");\n        return -1;\n    }\n\n    if (size == 0)\n        value = PyLong_FromLong(0L);\n    else {\n        /* Read the raw little-endian bytes and convert. */\n        if (_Unpickler_Read(self, &pdata, size) < 0)\n            return -1;\n        value = _PyLong_FromByteArray((unsigned char *)pdata, (size_t)size,\n                                      1 /* little endian */ , 1 /* signed */ );\n    }\n    if (value == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_float(UnpicklerObject *self)\n{\n    PyObject *value;\n    char *endptr, *s;\n    Py_ssize_t len;\n    double d;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    errno = 0;\n    d = PyOS_string_to_double(s, &endptr, PyExc_OverflowError);\n    if (d == -1.0 && PyErr_Occurred())\n        return -1;\n    if ((endptr[0] != '\\n') && (endptr[0] != '\\0')) {\n        PyErr_SetString(PyExc_ValueError, \"could not convert string to float\");\n        return -1;\n    }\n    value = PyFloat_FromDouble(d);\n    if (value == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_binfloat(UnpicklerObject *self)\n{\n    PyObject *value;\n    double x;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 8) < 0)\n        return -1;\n\n    x = _PyFloat_Unpack8((unsigned char *)s, 0);\n    if (x == -1.0 && PyErr_Occurred())\n        return -1;\n\n    if ((value = PyFloat_FromDouble(x)) == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_string(UnpicklerObject *self)\n{\n    PyObject *bytes;\n    PyObject *obj;\n    Py_ssize_t len;\n    char *s, *p;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    /* Strip the newline */\n    len--;\n    /* Strip outermost quotes */\n    if (len >= 2 && s[0] == s[len - 1] && (s[0] == '\\'' || s[0] == '\"')) {\n        p = s + 1;\n        len -= 2;\n    }\n    else {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError,\n                        \"the STRING opcode argument must be quoted\");\n        return -1;\n    }\n    assert(len >= 0);\n\n    /* Use the PyBytes API to decode the string, since that is what is used\n       to encode, and then coerce the result to Unicode. */\n    bytes = PyBytes_DecodeEscape(p, len, NULL, 0, NULL);\n    if (bytes == NULL)\n        return -1;\n\n    /* Leave the Python 2.x strings as bytes if the *encoding* given to the\n       Unpickler was 'bytes'. Otherwise, convert them to unicode. */\n    if (strcmp(self->encoding, \"bytes\") == 0) {\n        obj = bytes;\n    }\n    else {\n        obj = PyUnicode_FromEncodedObject(bytes, self->encoding, self->errors);\n        Py_DECREF(bytes);\n        if (obj == NULL) {\n            return -1;\n        }\n    }\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_counted_binstring(UnpicklerObject *self, int nbytes)\n{\n    PyObject *obj;\n    Py_ssize_t size;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, nbytes) < 0)\n        return -1;\n\n    size = calc_binsize(s, nbytes);\n    if (size < 0) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_Format(st->UnpicklingError,\n                     \"BINSTRING exceeds system's maximum size of %zd bytes\",\n                     PY_SSIZE_T_MAX);\n        return -1;\n    }\n\n    if (_Unpickler_Read(self, &s, size) < 0)\n        return -1;\n\n    /* Convert Python 2.x strings to bytes if the *encoding* given to the\n       Unpickler was 'bytes'. Otherwise, convert them to unicode. */\n    if (strcmp(self->encoding, \"bytes\") == 0) {\n        obj = PyBytes_FromStringAndSize(s, size);\n    }\n    else {\n        obj = PyUnicode_Decode(s, size, self->encoding, self->errors);\n    }\n    if (obj == NULL) {\n        return -1;\n    }\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_counted_binbytes(UnpicklerObject *self, int nbytes)\n{\n    PyObject *bytes;\n    Py_ssize_t size;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, nbytes) < 0)\n        return -1;\n\n    size = calc_binsize(s, nbytes);\n    if (size < 0) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"BINBYTES exceeds system's maximum size of %zd bytes\",\n                     PY_SSIZE_T_MAX);\n        return -1;\n    }\n\n    if (_Unpickler_Read(self, &s, size) < 0)\n        return -1;\n\n    bytes = PyBytes_FromStringAndSize(s, size);\n    if (bytes == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, bytes, -1);\n    return 0;\n}\n\nstatic int\nload_unicode(UnpicklerObject *self)\n{\n    PyObject *str;\n    Py_ssize_t len;\n    char *s = NULL;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 1)\n        return bad_readline();\n\n    str = PyUnicode_DecodeRawUnicodeEscape(s, len - 1, NULL);\n    if (str == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, str, -1);\n    return 0;\n}\n\nstatic int\nload_counted_binunicode(UnpicklerObject *self, int nbytes)\n{\n    PyObject *str;\n    Py_ssize_t size;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, nbytes) < 0)\n        return -1;\n\n    size = calc_binsize(s, nbytes);\n    if (size < 0) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"BINUNICODE exceeds system's maximum size of %zd bytes\",\n                     PY_SSIZE_T_MAX);\n        return -1;\n    }\n\n    if (_Unpickler_Read(self, &s, size) < 0)\n        return -1;\n\n    str = PyUnicode_DecodeUTF8(s, size, \"surrogatepass\");\n    if (str == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, str, -1);\n    return 0;\n}\n\nstatic int\nload_counted_tuple(UnpicklerObject *self, Py_ssize_t len)\n{\n    PyObject *tuple;\n\n    if (Py_SIZE(self->stack) < len)\n        return Pdata_stack_underflow(self->stack);\n\n    tuple = Pdata_poptuple(self->stack, Py_SIZE(self->stack) - len);\n    if (tuple == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, tuple, -1);\n    return 0;\n}\n\nstatic int\nload_tuple(UnpicklerObject *self)\n{\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    return load_counted_tuple(self, Py_SIZE(self->stack) - i);\n}\n\nstatic int\nload_empty_list(UnpicklerObject *self)\n{\n    PyObject *list;\n\n    if ((list = PyList_New(0)) == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, list, -1);\n    return 0;\n}\n\nstatic int\nload_empty_dict(UnpicklerObject *self)\n{\n    PyObject *dict;\n\n    if ((dict = PyDict_New()) == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, dict, -1);\n    return 0;\n}\n\nstatic int\nload_empty_set(UnpicklerObject *self)\n{\n    PyObject *set;\n\n    if ((set = PySet_New(NULL)) == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, set, -1);\n    return 0;\n}\n\nstatic int\nload_list(UnpicklerObject *self)\n{\n    PyObject *list;\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    list = Pdata_poplist(self->stack, i);\n    if (list == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, list, -1);\n    return 0;\n}\n\nstatic int\nload_dict(UnpicklerObject *self)\n{\n    PyObject *dict, *key, *value;\n    Py_ssize_t i, j, k;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n    j = Py_SIZE(self->stack);\n\n    if ((dict = PyDict_New()) == NULL)\n        return -1;\n\n    if ((j - i) % 2 != 0) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError, \"odd number of items for DICT\");\n        Py_DECREF(dict);\n        return -1;\n    }\n\n    for (k = i + 1; k < j; k += 2) {\n        key = self->stack->data[k - 1];\n        value = self->stack->data[k];\n        if (PyDict_SetItem(dict, key, value) < 0) {\n            Py_DECREF(dict);\n            return -1;\n        }\n    }\n    Pdata_clear(self->stack, i);\n    PDATA_PUSH(self->stack, dict, -1);\n    return 0;\n}\n\nstatic int\nload_frozenset(UnpicklerObject *self)\n{\n    PyObject *items;\n    PyObject *frozenset;\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    items = Pdata_poptuple(self->stack, i);\n    if (items == NULL)\n        return -1;\n\n    frozenset = PyFrozenSet_New(items);\n    Py_DECREF(items);\n    if (frozenset == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, frozenset, -1);\n    return 0;\n}\n\nstatic PyObject *\ninstantiate(PyObject *cls, PyObject *args)\n{\n    /* Caller must assure args are a tuple.  Normally, args come from\n       Pdata_poptuple which packs objects from the top of the stack\n       into a newly created tuple. */\n    assert(PyTuple_Check(args));\n    if (!PyTuple_GET_SIZE(args) && PyType_Check(cls)) {\n        _Py_IDENTIFIER(__getinitargs__);\n        _Py_IDENTIFIER(__new__);\n        PyObject *func;\n        if (_PyObject_LookupAttrId(cls, &PyId___getinitargs__, &func) < 0) {\n            return NULL;\n        }\n        if (func == NULL) {\n            return _PyObject_CallMethodIdObjArgs(cls, &PyId___new__, cls, NULL);\n        }\n        Py_DECREF(func);\n    }\n    return PyObject_CallObject(cls, args);\n}\n\nstatic int\nload_obj(UnpicklerObject *self)\n{\n    PyObject *cls, *args, *obj = NULL;\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    if (Py_SIZE(self->stack) - i < 1)\n        return Pdata_stack_underflow(self->stack);\n\n    args = Pdata_poptuple(self->stack, i + 1);\n    if (args == NULL)\n        return -1;\n\n    PDATA_POP(self->stack, cls);\n    if (cls) {\n        obj = instantiate(cls, args);\n        Py_DECREF(cls);\n    }\n    Py_DECREF(args);\n    if (obj == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_inst(UnpicklerObject *self)\n{\n    PyObject *cls = NULL;\n    PyObject *args = NULL;\n    PyObject *obj = NULL;\n    PyObject *module_name;\n    PyObject *class_name;\n    Py_ssize_t len;\n    Py_ssize_t i;\n    char *s;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    /* Here it is safe to use PyUnicode_DecodeASCII(), even though non-ASCII\n       identifiers are permitted in Python 3.0, since the INST opcode is only\n       supported by older protocols on Python 2.x. */\n    module_name = PyUnicode_DecodeASCII(s, len - 1, \"strict\");\n    if (module_name == NULL)\n        return -1;\n\n    if ((len = _Unpickler_Readline(self, &s)) >= 0) {\n        if (len < 2) {\n            Py_DECREF(module_name);\n            return bad_readline();\n        }\n        class_name = PyUnicode_DecodeASCII(s, len - 1, \"strict\");\n        if (class_name != NULL) {\n            cls = find_class(self, module_name, class_name);\n            Py_DECREF(class_name);\n        }\n    }\n    Py_DECREF(module_name);\n\n    if (cls == NULL)\n        return -1;\n\n    if ((args = Pdata_poptuple(self->stack, i)) != NULL) {\n        obj = instantiate(cls, args);\n        Py_DECREF(args);\n    }\n    Py_DECREF(cls);\n\n    if (obj == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_newobj(UnpicklerObject *self)\n{\n    PyObject *args = NULL;\n    PyObject *clsraw = NULL;\n    PyTypeObject *cls;          /* clsraw cast to its true type */\n    PyObject *obj;\n    PickleState *st = _Pickle_GetGlobalState();\n\n    /* Stack is ... cls argtuple, and we want to call\n     * cls.__new__(cls, *argtuple).\n     */\n    PDATA_POP(self->stack, args);\n    if (args == NULL)\n        goto error;\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(st->UnpicklingError,\n                        \"NEWOBJ expected an arg \" \"tuple.\");\n        goto error;\n    }\n\n    PDATA_POP(self->stack, clsraw);\n    cls = (PyTypeObject *)clsraw;\n    if (cls == NULL)\n        goto error;\n    if (!PyType_Check(cls)) {\n        PyErr_SetString(st->UnpicklingError, \"NEWOBJ class argument \"\n                        \"isn't a type object\");\n        goto error;\n    }\n    if (cls->tp_new == NULL) {\n        PyErr_SetString(st->UnpicklingError, \"NEWOBJ class argument \"\n                        \"has NULL tp_new\");\n        goto error;\n    }\n\n    /* Call __new__. */\n    obj = cls->tp_new(cls, args, NULL);\n    if (obj == NULL)\n        goto error;\n\n    Py_DECREF(args);\n    Py_DECREF(clsraw);\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n\n  error:\n    Py_XDECREF(args);\n    Py_XDECREF(clsraw);\n    return -1;\n}\n\nstatic int\nload_newobj_ex(UnpicklerObject *self)\n{\n    PyObject *cls, *args, *kwargs;\n    PyObject *obj;\n    PickleState *st = _Pickle_GetGlobalState();\n\n    PDATA_POP(self->stack, kwargs);\n    if (kwargs == NULL) {\n        return -1;\n    }\n    PDATA_POP(self->stack, args);\n    if (args == NULL) {\n        Py_DECREF(kwargs);\n        return -1;\n    }\n    PDATA_POP(self->stack, cls);\n    if (cls == NULL) {\n        Py_DECREF(kwargs);\n        Py_DECREF(args);\n        return -1;\n    }\n\n    if (!PyType_Check(cls)) {\n        Py_DECREF(kwargs);\n        Py_DECREF(args);\n        PyErr_Format(st->UnpicklingError,\n                     \"NEWOBJ_EX class argument must be a type, not %.200s\",\n                     Py_TYPE(cls)->tp_name);\n        Py_DECREF(cls);\n        return -1;\n    }\n\n    if (((PyTypeObject *)cls)->tp_new == NULL) {\n        Py_DECREF(kwargs);\n        Py_DECREF(args);\n        Py_DECREF(cls);\n        PyErr_SetString(st->UnpicklingError,\n                        \"NEWOBJ_EX class argument doesn't have __new__\");\n        return -1;\n    }\n    obj = ((PyTypeObject *)cls)->tp_new((PyTypeObject *)cls, args, kwargs);\n    Py_DECREF(kwargs);\n    Py_DECREF(args);\n    Py_DECREF(cls);\n    if (obj == NULL) {\n        return -1;\n    }\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_global(UnpicklerObject *self)\n{\n    PyObject *global = NULL;\n    PyObject *module_name;\n    PyObject *global_name;\n    Py_ssize_t len;\n    char *s;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n    module_name = PyUnicode_DecodeUTF8(s, len - 1, \"strict\");\n    if (!module_name)\n        return -1;\n\n    if ((len = _Unpickler_Readline(self, &s)) >= 0) {\n        if (len < 2) {\n            Py_DECREF(module_name);\n            return bad_readline();\n        }\n        global_name = PyUnicode_DecodeUTF8(s, len - 1, \"strict\");\n        if (global_name) {\n            global = find_class(self, module_name, global_name);\n            Py_DECREF(global_name);\n        }\n    }\n    Py_DECREF(module_name);\n\n    if (global == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, global, -1);\n    return 0;\n}\n\nstatic int\nload_stack_global(UnpicklerObject *self)\n{\n    PyObject *global;\n    PyObject *module_name;\n    PyObject *global_name;\n\n    PDATA_POP(self->stack, global_name);\n    PDATA_POP(self->stack, module_name);\n    if (module_name == NULL || !PyUnicode_CheckExact(module_name) ||\n        global_name == NULL || !PyUnicode_CheckExact(global_name)) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError, \"STACK_GLOBAL requires str\");\n        Py_XDECREF(global_name);\n        Py_XDECREF(module_name);\n        return -1;\n    }\n    global = find_class(self, module_name, global_name);\n    Py_DECREF(global_name);\n    Py_DECREF(module_name);\n    if (global == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, global, -1);\n    return 0;\n}\n\nstatic int\nload_persid(UnpicklerObject *self)\n{\n    PyObject *pid, *obj;\n    Py_ssize_t len;\n    char *s;\n\n    if (self->pers_func) {\n        if ((len = _Unpickler_Readline(self, &s)) < 0)\n            return -1;\n        if (len < 1)\n            return bad_readline();\n\n        pid = PyUnicode_DecodeASCII(s, len - 1, \"strict\");\n        if (pid == NULL) {\n            if (PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {\n                PyErr_SetString(_Pickle_GetGlobalState()->UnpicklingError,\n                                \"persistent IDs in protocol 0 must be \"\n                                \"ASCII strings\");\n            }\n            return -1;\n        }\n\n        obj = call_method(self->pers_func, self->pers_func_self, pid);\n        Py_DECREF(pid);\n        if (obj == NULL)\n            return -1;\n\n        PDATA_PUSH(self->stack, obj, -1);\n        return 0;\n    }\n    else {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError,\n                        \"A load persistent id instruction was encountered,\\n\"\n                        \"but no persistent_load function was specified.\");\n        return -1;\n    }\n}\n\nstatic int\nload_binpersid(UnpicklerObject *self)\n{\n    PyObject *pid, *obj;\n\n    if (self->pers_func) {\n        PDATA_POP(self->stack, pid);\n        if (pid == NULL)\n            return -1;\n\n        obj = call_method(self->pers_func, self->pers_func_self, pid);\n        Py_DECREF(pid);\n        if (obj == NULL)\n            return -1;\n\n        PDATA_PUSH(self->stack, obj, -1);\n        return 0;\n    }\n    else {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError,\n                        \"A load persistent id instruction was encountered,\\n\"\n                        \"but no persistent_load function was specified.\");\n        return -1;\n    }\n}\n\nstatic int\nload_pop(UnpicklerObject *self)\n{\n    Py_ssize_t len = Py_SIZE(self->stack);\n\n    /* Note that we split the (pickle.py) stack into two stacks,\n     * an object stack and a mark stack. We have to be clever and\n     * pop the right one. We do this by looking at the top of the\n     * mark stack first, and only signalling a stack underflow if\n     * the object stack is empty and the mark stack doesn't match\n     * our expectations.\n     */\n    if (self->num_marks > 0 && self->marks[self->num_marks - 1] == len) {\n        self->num_marks--;\n        self->stack->mark_set = self->num_marks != 0;\n        self->stack->fence = self->num_marks ?\n                self->marks[self->num_marks - 1] : 0;\n    } else if (len <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    else {\n        len--;\n        Py_DECREF(self->stack->data[len]);\n        Py_SIZE(self->stack) = len;\n    }\n    return 0;\n}\n\nstatic int\nload_pop_mark(UnpicklerObject *self)\n{\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    Pdata_clear(self->stack, i);\n\n    return 0;\n}\n\nstatic int\nload_dup(UnpicklerObject *self)\n{\n    PyObject *last;\n    Py_ssize_t len = Py_SIZE(self->stack);\n\n    if (len <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    last = self->stack->data[len - 1];\n    PDATA_APPEND(self->stack, last, -1);\n    return 0;\n}\n\nstatic int\nload_get(UnpicklerObject *self)\n{\n    PyObject *key, *value;\n    Py_ssize_t idx;\n    Py_ssize_t len;\n    char *s;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    key = PyLong_FromString(s, NULL, 10);\n    if (key == NULL)\n        return -1;\n    idx = PyLong_AsSsize_t(key);\n    if (idx == -1 && PyErr_Occurred()) {\n        Py_DECREF(key);\n        return -1;\n    }\n\n    value = _Unpickler_MemoGet(self, idx);\n    if (value == NULL) {\n        if (!PyErr_Occurred())\n            PyErr_SetObject(PyExc_KeyError, key);\n        Py_DECREF(key);\n        return -1;\n    }\n    Py_DECREF(key);\n\n    PDATA_APPEND(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_binget(UnpicklerObject *self)\n{\n    PyObject *value;\n    Py_ssize_t idx;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 1) < 0)\n        return -1;\n\n    idx = Py_CHARMASK(s[0]);\n\n    value = _Unpickler_MemoGet(self, idx);\n    if (value == NULL) {\n        PyObject *key = PyLong_FromSsize_t(idx);\n        if (key != NULL) {\n            PyErr_SetObject(PyExc_KeyError, key);\n            Py_DECREF(key);\n        }\n        return -1;\n    }\n\n    PDATA_APPEND(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_long_binget(UnpicklerObject *self)\n{\n    PyObject *value;\n    Py_ssize_t idx;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 4) < 0)\n        return -1;\n\n    idx = calc_binsize(s, 4);\n\n    value = _Unpickler_MemoGet(self, idx);\n    if (value == NULL) {\n        PyObject *key = PyLong_FromSsize_t(idx);\n        if (key != NULL) {\n            PyErr_SetObject(PyExc_KeyError, key);\n            Py_DECREF(key);\n        }\n        return -1;\n    }\n\n    PDATA_APPEND(self->stack, value, -1);\n    return 0;\n}\n\n/* Push an object from the extension registry (EXT[124]).  nbytes is\n * the number of bytes following the opcode, holding the index (code) value.\n */\nstatic int\nload_extension(UnpicklerObject *self, int nbytes)\n{\n    char *codebytes;            /* the nbytes bytes after the opcode */\n    long code;                  /* calc_binint returns long */\n    PyObject *py_code;          /* code as a Python int */\n    PyObject *obj;              /* the object to push */\n    PyObject *pair;             /* (module_name, class_name) */\n    PyObject *module_name, *class_name;\n    PickleState *st = _Pickle_GetGlobalState();\n\n    assert(nbytes == 1 || nbytes == 2 || nbytes == 4);\n    if (_Unpickler_Read(self, &codebytes, nbytes) < 0)\n        return -1;\n    code = calc_binint(codebytes, nbytes);\n    if (code <= 0) {            /* note that 0 is forbidden */\n        /* Corrupt or hostile pickle. */\n        PyErr_SetString(st->UnpicklingError, \"EXT specifies code <= 0\");\n        return -1;\n    }\n\n    /* Look for the code in the cache. */\n    py_code = PyLong_FromLong(code);\n    if (py_code == NULL)\n        return -1;\n    obj = PyDict_GetItemWithError(st->extension_cache, py_code);\n    if (obj != NULL) {\n        /* Bingo. */\n        Py_DECREF(py_code);\n        PDATA_APPEND(self->stack, obj, -1);\n        return 0;\n    }\n    if (PyErr_Occurred()) {\n        Py_DECREF(py_code);\n        return -1;\n    }\n\n    /* Look up the (module_name, class_name) pair. */\n    pair = PyDict_GetItemWithError(st->inverted_registry, py_code);\n    if (pair == NULL) {\n        Py_DECREF(py_code);\n        if (!PyErr_Occurred()) {\n            PyErr_Format(PyExc_ValueError, \"unregistered extension \"\n                         \"code %ld\", code);\n        }\n        return -1;\n    }\n    /* Since the extension registry is manipulable via Python code,\n     * confirm that pair is really a 2-tuple of strings.\n     */\n    if (!PyTuple_Check(pair) || PyTuple_Size(pair) != 2 ||\n        !PyUnicode_Check(module_name = PyTuple_GET_ITEM(pair, 0)) ||\n        !PyUnicode_Check(class_name = PyTuple_GET_ITEM(pair, 1))) {\n        Py_DECREF(py_code);\n        PyErr_Format(PyExc_ValueError, \"_inverted_registry[%ld] \"\n                     \"isn't a 2-tuple of strings\", code);\n        return -1;\n    }\n    /* Load the object. */\n    obj = find_class(self, module_name, class_name);\n    if (obj == NULL) {\n        Py_DECREF(py_code);\n        return -1;\n    }\n    /* Cache code -> obj. */\n    code = PyDict_SetItem(st->extension_cache, py_code, obj);\n    Py_DECREF(py_code);\n    if (code < 0) {\n        Py_DECREF(obj);\n        return -1;\n    }\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_put(UnpicklerObject *self)\n{\n    PyObject *key, *value;\n    Py_ssize_t idx;\n    Py_ssize_t len;\n    char *s = NULL;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n    if (Py_SIZE(self->stack) <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    value = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    key = PyLong_FromString(s, NULL, 10);\n    if (key == NULL)\n        return -1;\n    idx = PyLong_AsSsize_t(key);\n    Py_DECREF(key);\n    if (idx < 0) {\n        if (!PyErr_Occurred())\n            PyErr_SetString(PyExc_ValueError,\n                            \"negative PUT argument\");\n        return -1;\n    }\n\n    return _Unpickler_MemoPut(self, idx, value);\n}\n\nstatic int\nload_binput(UnpicklerObject *self)\n{\n    PyObject *value;\n    Py_ssize_t idx;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 1) < 0)\n        return -1;\n\n    if (Py_SIZE(self->stack) <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    value = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    idx = Py_CHARMASK(s[0]);\n\n    return _Unpickler_MemoPut(self, idx, value);\n}\n\nstatic int\nload_long_binput(UnpicklerObject *self)\n{\n    PyObject *value;\n    Py_ssize_t idx;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 4) < 0)\n        return -1;\n\n    if (Py_SIZE(self->stack) <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    value = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    idx = calc_binsize(s, 4);\n    if (idx < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"negative LONG_BINPUT argument\");\n        return -1;\n    }\n\n    return _Unpickler_MemoPut(self, idx, value);\n}\n\nstatic int\nload_memoize(UnpicklerObject *self)\n{\n    PyObject *value;\n\n    if (Py_SIZE(self->stack) <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    value = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    return _Unpickler_MemoPut(self, self->memo_len, value);\n}\n\nstatic int\ndo_append(UnpicklerObject *self, Py_ssize_t x)\n{\n    PyObject *value;\n    PyObject *slice;\n    PyObject *list;\n    PyObject *result;\n    Py_ssize_t len, i;\n\n    len = Py_SIZE(self->stack);\n    if (x > len || x <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    if (len == x)  /* nothing to do */\n        return 0;\n\n    list = self->stack->data[x - 1];\n\n    if (PyList_CheckExact(list)) {\n        Py_ssize_t list_len;\n        int ret;\n\n        slice = Pdata_poplist(self->stack, x);\n        if (!slice)\n            return -1;\n        list_len = PyList_GET_SIZE(list);\n        ret = PyList_SetSlice(list, list_len, list_len, slice);\n        Py_DECREF(slice);\n        return ret;\n    }\n    else {\n        PyObject *extend_func;\n        _Py_IDENTIFIER(extend);\n\n        extend_func = _PyObject_GetAttrId(list, &PyId_extend);\n        if (extend_func != NULL) {\n            slice = Pdata_poplist(self->stack, x);\n            if (!slice) {\n                Py_DECREF(extend_func);\n                return -1;\n            }\n            result = _Pickle_FastCall(extend_func, slice);\n            Py_DECREF(extend_func);\n            if (result == NULL)\n                return -1;\n            Py_DECREF(result);\n        }\n        else {\n            PyObject *append_func;\n            _Py_IDENTIFIER(append);\n\n            /* Even if the PEP 307 requires extend() and append() methods,\n               fall back on append() if the object has no extend() method\n               for backward compatibility. */\n            PyErr_Clear();\n            append_func = _PyObject_GetAttrId(list, &PyId_append);\n            if (append_func == NULL)\n                return -1;\n            for (i = x; i < len; i++) {\n                value = self->stack->data[i];\n                result = _Pickle_FastCall(append_func, value);\n                if (result == NULL) {\n                    Pdata_clear(self->stack, i + 1);\n                    Py_SIZE(self->stack) = x;\n                    Py_DECREF(append_func);\n                    return -1;\n                }\n                Py_DECREF(result);\n            }\n            Py_SIZE(self->stack) = x;\n            Py_DECREF(append_func);\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nload_append(UnpicklerObject *self)\n{\n    if (Py_SIZE(self->stack) - 1 <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    return do_append(self, Py_SIZE(self->stack) - 1);\n}\n\nstatic int\nload_appends(UnpicklerObject *self)\n{\n    Py_ssize_t i = marker(self);\n    if (i < 0)\n        return -1;\n    return do_append(self, i);\n}\n\nstatic int\ndo_setitems(UnpicklerObject *self, Py_ssize_t x)\n{\n    PyObject *value, *key;\n    PyObject *dict;\n    Py_ssize_t len, i;\n    int status = 0;\n\n    len = Py_SIZE(self->stack);\n    if (x > len || x <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    if (len == x)  /* nothing to do */\n        return 0;\n    if ((len - x) % 2 != 0) {\n        PickleState *st = _Pickle_GetGlobalState();\n        /* Currupt or hostile pickle -- we never write one like this. */\n        PyErr_SetString(st->UnpicklingError,\n                        \"odd number of items for SETITEMS\");\n        return -1;\n    }\n\n    /* Here, dict does not actually need to be a PyDict; it could be anything\n       that supports the __setitem__ attribute. */\n    dict = self->stack->data[x - 1];\n\n    for (i = x + 1; i < len; i += 2) {\n        key = self->stack->data[i - 1];\n        value = self->stack->data[i];\n        if (PyObject_SetItem(dict, key, value) < 0) {\n            status = -1;\n            break;\n        }\n    }\n\n    Pdata_clear(self->stack, x);\n    return status;\n}\n\nstatic int\nload_setitem(UnpicklerObject *self)\n{\n    return do_setitems(self, Py_SIZE(self->stack) - 2);\n}\n\nstatic int\nload_setitems(UnpicklerObject *self)\n{\n    Py_ssize_t i = marker(self);\n    if (i < 0)\n        return -1;\n    return do_setitems(self, i);\n}\n\nstatic int\nload_additems(UnpicklerObject *self)\n{\n    PyObject *set;\n    Py_ssize_t mark, len, i;\n\n    mark =  marker(self);\n    if (mark < 0)\n        return -1;\n    len = Py_SIZE(self->stack);\n    if (mark > len || mark <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    if (len == mark)  /* nothing to do */\n        return 0;\n\n    set = self->stack->data[mark - 1];\n\n    if (PySet_Check(set)) {\n        PyObject *items;\n        int status;\n\n        items = Pdata_poptuple(self->stack, mark);\n        if (items == NULL)\n            return -1;\n\n        status = _PySet_Update(set, items);\n        Py_DECREF(items);\n        return status;\n    }\n    else {\n        PyObject *add_func;\n        _Py_IDENTIFIER(add);\n\n        add_func = _PyObject_GetAttrId(set, &PyId_add);\n        if (add_func == NULL)\n            return -1;\n        for (i = mark; i < len; i++) {\n            PyObject *result;\n            PyObject *item;\n\n            item = self->stack->data[i];\n            result = _Pickle_FastCall(add_func, item);\n            if (result == NULL) {\n                Pdata_clear(self->stack, i + 1);\n                Py_SIZE(self->stack) = mark;\n                return -1;\n            }\n            Py_DECREF(result);\n        }\n        Py_SIZE(self->stack) = mark;\n    }\n\n    return 0;\n}\n\nstatic int\nload_build(UnpicklerObject *self)\n{\n    PyObject *state, *inst, *slotstate;\n    PyObject *setstate;\n    int status = 0;\n    _Py_IDENTIFIER(__setstate__);\n\n    /* Stack is ... instance, state.  We want to leave instance at\n     * the stack top, possibly mutated via instance.__setstate__(state).\n     */\n    if (Py_SIZE(self->stack) - 2 < self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n\n    PDATA_POP(self->stack, state);\n    if (state == NULL)\n        return -1;\n\n    inst = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    if (_PyObject_LookupAttrId(inst, &PyId___setstate__, &setstate) < 0) {\n        Py_DECREF(state);\n        return -1;\n    }\n    if (setstate != NULL) {\n        PyObject *result;\n\n        /* The explicit __setstate__ is responsible for everything. */\n        result = _Pickle_FastCall(setstate, state);\n        Py_DECREF(setstate);\n        if (result == NULL)\n            return -1;\n        Py_DECREF(result);\n        return 0;\n    }\n\n    /* A default __setstate__.  First see whether state embeds a\n     * slot state dict too (a proto 2 addition).\n     */\n    if (PyTuple_Check(state) && PyTuple_GET_SIZE(state) == 2) {\n        PyObject *tmp = state;\n\n        state = PyTuple_GET_ITEM(tmp, 0);\n        slotstate = PyTuple_GET_ITEM(tmp, 1);\n        Py_INCREF(state);\n        Py_INCREF(slotstate);\n        Py_DECREF(tmp);\n    }\n    else\n        slotstate = NULL;\n\n    /* Set inst.__dict__ from the state dict (if any). */\n    if (state != Py_None) {\n        PyObject *dict;\n        PyObject *d_key, *d_value;\n        Py_ssize_t i;\n        _Py_IDENTIFIER(__dict__);\n\n        if (!PyDict_Check(state)) {\n            PickleState *st = _Pickle_GetGlobalState();\n            PyErr_SetString(st->UnpicklingError, \"state is not a dictionary\");\n            goto error;\n        }\n        dict = _PyObject_GetAttrId(inst, &PyId___dict__);\n        if (dict == NULL)\n            goto error;\n\n        i = 0;\n        while (PyDict_Next(state, &i, &d_key, &d_value)) {\n            /* normally the keys for instance attributes are\n               interned.  we should try to do that here. */\n            Py_INCREF(d_key);\n            if (PyUnicode_CheckExact(d_key))\n                PyUnicode_InternInPlace(&d_key);\n            if (PyObject_SetItem(dict, d_key, d_value) < 0) {\n                Py_DECREF(d_key);\n                goto error;\n            }\n            Py_DECREF(d_key);\n        }\n        Py_DECREF(dict);\n    }\n\n    /* Also set instance attributes from the slotstate dict (if any). */\n    if (slotstate != NULL) {\n        PyObject *d_key, *d_value;\n        Py_ssize_t i;\n\n        if (!PyDict_Check(slotstate)) {\n            PickleState *st = _Pickle_GetGlobalState();\n            PyErr_SetString(st->UnpicklingError,\n                            \"slot state is not a dictionary\");\n            goto error;\n        }\n        i = 0;\n        while (PyDict_Next(slotstate, &i, &d_key, &d_value)) {\n            if (PyObject_SetAttr(inst, d_key, d_value) < 0)\n                goto error;\n        }\n    }\n\n    if (0) {\n  error:\n        status = -1;\n    }\n\n    Py_DECREF(state);\n    Py_XDECREF(slotstate);\n    return status;\n}\n\nstatic int\nload_mark(UnpicklerObject *self)\n{\n\n    /* Note that we split the (pickle.py) stack into two stacks, an\n     * object stack and a mark stack. Here we push a mark onto the\n     * mark stack.\n     */\n\n    if (self->num_marks >= self->marks_size) {\n        size_t alloc = ((size_t)self->num_marks << 1) + 20;\n        Py_ssize_t *marks_new = self->marks;\n        PyMem_RESIZE(marks_new, Py_ssize_t, alloc);\n        if (marks_new == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        self->marks = marks_new;\n        self->marks_size = (Py_ssize_t)alloc;\n    }\n\n    self->stack->mark_set = 1;\n    self->marks[self->num_marks++] = self->stack->fence = Py_SIZE(self->stack);\n\n    return 0;\n}\n\nstatic int\nload_reduce(UnpicklerObject *self)\n{\n    PyObject *callable = NULL;\n    PyObject *argtup = NULL;\n    PyObject *obj = NULL;\n\n    PDATA_POP(self->stack, argtup);\n    if (argtup == NULL)\n        return -1;\n    PDATA_POP(self->stack, callable);\n    if (callable) {\n        obj = PyObject_CallObject(callable, argtup);\n        Py_DECREF(callable);\n    }\n    Py_DECREF(argtup);\n\n    if (obj == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\n/* Just raises an error if we don't know the protocol specified.  PROTO\n * is the first opcode for protocols >= 2.\n */\nstatic int\nload_proto(UnpicklerObject *self)\n{\n    char *s;\n    int i;\n\n    if (_Unpickler_Read(self, &s, 1) < 0)\n        return -1;\n\n    i = (unsigned char)s[0];\n    if (i <= HIGHEST_PROTOCOL) {\n        self->proto = i;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_ValueError, \"unsupported pickle protocol: %d\", i);\n    return -1;\n}\n\nstatic int\nload_frame(UnpicklerObject *self)\n{\n    char *s;\n    Py_ssize_t frame_len;\n\n    if (_Unpickler_Read(self, &s, 8) < 0)\n        return -1;\n\n    frame_len = calc_binsize(s, 8);\n    if (frame_len < 0) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"FRAME length exceeds system's maximum of %zd bytes\",\n                     PY_SSIZE_T_MAX);\n        return -1;\n    }\n\n    if (_Unpickler_Read(self, &s, frame_len) < 0)\n        return -1;\n\n    /* Rewind to start of frame */\n    self->next_read_idx -= frame_len;\n    return 0;\n}\n\nstatic PyObject *\nload(UnpicklerObject *self)\n{\n    PyObject *value = NULL;\n    char *s = NULL;\n\n    self->num_marks = 0;\n    self->stack->mark_set = 0;\n    self->stack->fence = 0;\n    self->proto = 0;\n    if (Py_SIZE(self->stack))\n        Pdata_clear(self->stack, 0);\n\n    /* Convenient macros for the dispatch while-switch loop just below. */\n#define OP(opcode, load_func) \\\n    case opcode: if (load_func(self) < 0) break; continue;\n\n#define OP_ARG(opcode, load_func, arg) \\\n    case opcode: if (load_func(self, (arg)) < 0) break; continue;\n\n    while (1) {\n        if (_Unpickler_Read(self, &s, 1) < 0) {\n            PickleState *st = _Pickle_GetGlobalState();\n            if (PyErr_ExceptionMatches(st->UnpicklingError)) {\n                PyErr_Format(PyExc_EOFError, \"Ran out of input\");\n            }\n            return NULL;\n        }\n\n        switch ((enum opcode)s[0]) {\n        OP(NONE, load_none)\n        OP(BININT, load_binint)\n        OP(BININT1, load_binint1)\n        OP(BININT2, load_binint2)\n        OP(INT, load_int)\n        OP(LONG, load_long)\n        OP_ARG(LONG1, load_counted_long, 1)\n        OP_ARG(LONG4, load_counted_long, 4)\n        OP(FLOAT, load_float)\n        OP(BINFLOAT, load_binfloat)\n        OP_ARG(SHORT_BINBYTES, load_counted_binbytes, 1)\n        OP_ARG(BINBYTES, load_counted_binbytes, 4)\n        OP_ARG(BINBYTES8, load_counted_binbytes, 8)\n        OP_ARG(SHORT_BINSTRING, load_counted_binstring, 1)\n        OP_ARG(BINSTRING, load_counted_binstring, 4)\n        OP(STRING, load_string)\n        OP(UNICODE, load_unicode)\n        OP_ARG(SHORT_BINUNICODE, load_counted_binunicode, 1)\n        OP_ARG(BINUNICODE, load_counted_binunicode, 4)\n        OP_ARG(BINUNICODE8, load_counted_binunicode, 8)\n        OP_ARG(EMPTY_TUPLE, load_counted_tuple, 0)\n        OP_ARG(TUPLE1, load_counted_tuple, 1)\n        OP_ARG(TUPLE2, load_counted_tuple, 2)\n        OP_ARG(TUPLE3, load_counted_tuple, 3)\n        OP(TUPLE, load_tuple)\n        OP(EMPTY_LIST, load_empty_list)\n        OP(LIST, load_list)\n        OP(EMPTY_DICT, load_empty_dict)\n        OP(DICT, load_dict)\n        OP(EMPTY_SET, load_empty_set)\n        OP(ADDITEMS, load_additems)\n        OP(FROZENSET, load_frozenset)\n        OP(OBJ, load_obj)\n        OP(INST, load_inst)\n        OP(NEWOBJ, load_newobj)\n        OP(NEWOBJ_EX, load_newobj_ex)\n        OP(GLOBAL, load_global)\n        OP(STACK_GLOBAL, load_stack_global)\n        OP(APPEND, load_append)\n        OP(APPENDS, load_appends)\n        OP(BUILD, load_build)\n        OP(DUP, load_dup)\n        OP(BINGET, load_binget)\n        OP(LONG_BINGET, load_long_binget)\n        OP(GET, load_get)\n        OP(MARK, load_mark)\n        OP(BINPUT, load_binput)\n        OP(LONG_BINPUT, load_long_binput)\n        OP(PUT, load_put)\n        OP(MEMOIZE, load_memoize)\n        OP(POP, load_pop)\n        OP(POP_MARK, load_pop_mark)\n        OP(SETITEM, load_setitem)\n        OP(SETITEMS, load_setitems)\n        OP(PERSID, load_persid)\n        OP(BINPERSID, load_binpersid)\n        OP(REDUCE, load_reduce)\n        OP(PROTO, load_proto)\n        OP(FRAME, load_frame)\n        OP_ARG(EXT1, load_extension, 1)\n        OP_ARG(EXT2, load_extension, 2)\n        OP_ARG(EXT4, load_extension, 4)\n        OP_ARG(NEWTRUE, load_bool, Py_True)\n        OP_ARG(NEWFALSE, load_bool, Py_False)\n\n        case STOP:\n            break;\n\n        default:\n            {\n                PickleState *st = _Pickle_GetGlobalState();\n                unsigned char c = (unsigned char) *s;\n                if (0x20 <= c && c <= 0x7e && c != '\\'' && c != '\\\\') {\n                    PyErr_Format(st->UnpicklingError,\n                                 \"invalid load key, '%c'.\", c);\n                }\n                else {\n                    PyErr_Format(st->UnpicklingError,\n                                 \"invalid load key, '\\\\x%02x'.\", c);\n                }\n                return NULL;\n            }\n        }\n\n        break;                  /* and we are done! */\n    }\n\n    if (PyErr_Occurred()) {\n        return NULL;\n    }\n\n    if (_Unpickler_SkipConsumed(self) < 0)\n        return NULL;\n\n    PDATA_POP(self->stack, value);\n    return value;\n}\n\n/*[clinic input]\n\n_pickle.Unpickler.load\n\nLoad a pickle.\n\nRead a pickled object representation from the open file object given\nin the constructor, and return the reconstituted object hierarchy\nspecified therein.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_Unpickler_load_impl(UnpicklerObject *self)\n/*[clinic end generated code: output=fdcc488aad675b14 input=acbb91a42fa9b7b9]*/\n{\n    UnpicklerObject *unpickler = (UnpicklerObject*)self;\n\n    /* Check whether the Unpickler was initialized correctly. This prevents\n       segfaulting if a subclass overridden __init__ with a function that does\n       not call Unpickler.__init__(). Here, we simply ensure that self->read\n       is not NULL. */\n    if (unpickler->read == NULL) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_Format(st->UnpicklingError,\n                     \"Unpickler.__init__() was not called by %s.__init__()\",\n                     Py_TYPE(unpickler)->tp_name);\n        return NULL;\n    }\n\n    return load(unpickler);\n}\n\n/* The name of find_class() is misleading. In newer pickle protocols, this\n   function is used for loading any global (i.e., functions), not just\n   classes. The name is kept only for backward compatibility. */\n\n/*[clinic input]\n\n_pickle.Unpickler.find_class\n\n  module_name: object\n  global_name: object\n  /\n\nReturn an object from a specified module.\n\nIf necessary, the module will be imported. Subclasses may override\nthis method (e.g. to restrict unpickling of arbitrary classes and\nfunctions).\n\nThis method is called whenever a class or a function object is\nneeded.  Both arguments passed are str objects.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_Unpickler_find_class_impl(UnpicklerObject *self,\n                                  PyObject *module_name,\n                                  PyObject *global_name)\n/*[clinic end generated code: output=becc08d7f9ed41e3 input=e2e6a865de093ef4]*/\n{\n    PyObject *global;\n    PyObject *module;\n\n    /* Try to map the old names used in Python 2.x to the new ones used in\n       Python 3.x.  We do this only with old pickle protocols and when the\n       user has not disabled the feature. */\n    if (self->proto < 3 && self->fix_imports) {\n        PyObject *key;\n        PyObject *item;\n        PickleState *st = _Pickle_GetGlobalState();\n\n        /* Check if the global (i.e., a function or a class) was renamed\n           or moved to another module. */\n        key = PyTuple_Pack(2, module_name, global_name);\n        if (key == NULL)\n            return NULL;\n        item = PyDict_GetItemWithError(st->name_mapping_2to3, key);\n        Py_DECREF(key);\n        if (item) {\n            if (!PyTuple_Check(item) || PyTuple_GET_SIZE(item) != 2) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"_compat_pickle.NAME_MAPPING values should be \"\n                             \"2-tuples, not %.200s\", Py_TYPE(item)->tp_name);\n                return NULL;\n            }\n            module_name = PyTuple_GET_ITEM(item, 0);\n            global_name = PyTuple_GET_ITEM(item, 1);\n            if (!PyUnicode_Check(module_name) ||\n                !PyUnicode_Check(global_name)) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"_compat_pickle.NAME_MAPPING values should be \"\n                             \"pairs of str, not (%.200s, %.200s)\",\n                             Py_TYPE(module_name)->tp_name,\n                             Py_TYPE(global_name)->tp_name);\n                return NULL;\n            }\n        }\n        else if (PyErr_Occurred()) {\n            return NULL;\n        }\n        else {\n            /* Check if the module was renamed. */\n            item = PyDict_GetItemWithError(st->import_mapping_2to3, module_name);\n            if (item) {\n                if (!PyUnicode_Check(item)) {\n                    PyErr_Format(PyExc_RuntimeError,\n                                \"_compat_pickle.IMPORT_MAPPING values should be \"\n                                \"strings, not %.200s\", Py_TYPE(item)->tp_name);\n                    return NULL;\n                }\n                module_name = item;\n            }\n            else if (PyErr_Occurred()) {\n                return NULL;\n            }\n        }\n    }\n\n    module = PyImport_GetModule(module_name);\n    if (module == NULL) {\n        if (PyErr_Occurred())\n            return NULL;\n        module = PyImport_Import(module_name);\n        if (module == NULL)\n            return NULL;\n    }\n    global = getattribute(module, global_name, self->proto >= 4);\n    Py_DECREF(module);\n    return global;\n}\n\n/*[clinic input]\n\n_pickle.Unpickler.__sizeof__ -> Py_ssize_t\n\nReturns size in memory, in bytes.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_pickle_Unpickler___sizeof___impl(UnpicklerObject *self)\n/*[clinic end generated code: output=119d9d03ad4c7651 input=13333471fdeedf5e]*/\n{\n    Py_ssize_t res;\n\n    res = _PyObject_SIZE(Py_TYPE(self));\n    if (self->memo != NULL)\n        res += self->memo_size * sizeof(PyObject *);\n    if (self->marks != NULL)\n        res += self->marks_size * sizeof(Py_ssize_t);\n    if (self->input_line != NULL)\n        res += strlen(self->input_line) + 1;\n    if (self->encoding != NULL)\n        res += strlen(self->encoding) + 1;\n    if (self->errors != NULL)\n        res += strlen(self->errors) + 1;\n    return res;\n}\n\nstatic struct PyMethodDef Unpickler_methods[] = {\n    _PICKLE_UNPICKLER_LOAD_METHODDEF\n    _PICKLE_UNPICKLER_FIND_CLASS_METHODDEF\n    _PICKLE_UNPICKLER___SIZEOF___METHODDEF\n    {NULL, NULL}                /* sentinel */\n};\n\nstatic void\nUnpickler_dealloc(UnpicklerObject *self)\n{\n    PyObject_GC_UnTrack((PyObject *)self);\n    Py_XDECREF(self->readline);\n    Py_XDECREF(self->read);\n    Py_XDECREF(self->peek);\n    Py_XDECREF(self->stack);\n    Py_XDECREF(self->pers_func);\n    if (self->buffer.buf != NULL) {\n        PyBuffer_Release(&self->buffer);\n        self->buffer.buf = NULL;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    PyMem_Free(self->marks);\n    PyMem_Free(self->input_line);\n    PyMem_Free(self->encoding);\n    PyMem_Free(self->errors);\n\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic int\nUnpickler_traverse(UnpicklerObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->readline);\n    Py_VISIT(self->read);\n    Py_VISIT(self->peek);\n    Py_VISIT(self->stack);\n    Py_VISIT(self->pers_func);\n    return 0;\n}\n\nstatic int\nUnpickler_clear(UnpicklerObject *self)\n{\n    Py_CLEAR(self->readline);\n    Py_CLEAR(self->read);\n    Py_CLEAR(self->peek);\n    Py_CLEAR(self->stack);\n    Py_CLEAR(self->pers_func);\n    if (self->buffer.buf != NULL) {\n        PyBuffer_Release(&self->buffer);\n        self->buffer.buf = NULL;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    PyMem_Free(self->marks);\n    self->marks = NULL;\n    PyMem_Free(self->input_line);\n    self->input_line = NULL;\n    PyMem_Free(self->encoding);\n    self->encoding = NULL;\n    PyMem_Free(self->errors);\n    self->errors = NULL;\n\n    return 0;\n}\n\n/*[clinic input]\n\n_pickle.Unpickler.__init__\n\n  file: object\n  *\n  fix_imports: bool = True\n  encoding: str = 'ASCII'\n  errors: str = 'strict'\n\nThis takes a binary file for reading a pickle data stream.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.\n[clinic start generated code]*/\n\nstatic int\n_pickle_Unpickler___init___impl(UnpicklerObject *self, PyObject *file,\n                                int fix_imports, const char *encoding,\n                                const char *errors)\n/*[clinic end generated code: output=e2c8ce748edc57b0 input=f9b7da04f5f4f335]*/\n{\n    _Py_IDENTIFIER(persistent_load);\n\n    /* In case of multiple __init__() calls, clear previous content. */\n    if (self->read != NULL)\n        (void)Unpickler_clear(self);\n\n    if (_Unpickler_SetInputStream(self, file) < 0)\n        return -1;\n\n    if (_Unpickler_SetInputEncoding(self, encoding, errors) < 0)\n        return -1;\n\n    self->fix_imports = fix_imports;\n\n    if (init_method_ref((PyObject *)self, &PyId_persistent_load,\n                        &self->pers_func, &self->pers_func_self) < 0)\n    {\n        return -1;\n    }\n\n    self->stack = (Pdata *)Pdata_New();\n    if (self->stack == NULL)\n        return 1;\n\n    self->memo_size = 32;\n    self->memo = _Unpickler_NewMemo(self->memo_size);\n    if (self->memo == NULL)\n        return -1;\n\n    self->proto = 0;\n\n    return 0;\n}\n\n\n/* Define a proxy object for the Unpickler's internal memo object. This is to\n * avoid breaking code like:\n *  unpickler.memo.clear()\n * and\n *  unpickler.memo = saved_memo\n * Is this a good idea? Not really, but we don't want to break code that uses\n * it. Note that we don't implement the entire mapping API here. This is\n * intentional, as these should be treated as black-box implementation details.\n *\n * We do, however, have to implement pickling/unpickling support because of\n * real-world code like cvs2svn.\n */\n\n/*[clinic input]\n_pickle.UnpicklerMemoProxy.clear\n\nRemove all items from memo.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_UnpicklerMemoProxy_clear_impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=d20cd43f4ba1fb1f input=b1df7c52e7afd9bd]*/\n{\n    _Unpickler_MemoCleanup(self->unpickler);\n    self->unpickler->memo = _Unpickler_NewMemo(self->unpickler->memo_size);\n    if (self->unpickler->memo == NULL)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_pickle.UnpicklerMemoProxy.copy\n\nCopy the memo to a new object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/\n{\n    Py_ssize_t i;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    for (i = 0; i < self->unpickler->memo_size; i++) {\n        int status;\n        PyObject *key, *value;\n\n        value = self->unpickler->memo[i];\n        if (value == NULL)\n            continue;\n\n        key = PyLong_FromSsize_t(i);\n        if (key == NULL)\n            goto error;\n        status = PyDict_SetItem(new_memo, key, value);\n        Py_DECREF(key);\n        if (status < 0)\n            goto error;\n    }\n    return new_memo;\n\nerror:\n    Py_DECREF(new_memo);\n    return NULL;\n}\n\n/*[clinic input]\n_pickle.UnpicklerMemoProxy.__reduce__\n\nImplement pickling support.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_UnpicklerMemoProxy___reduce___impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=6da34ac048d94cca input=6920862413407199]*/\n{\n    PyObject *reduce_value;\n    PyObject *constructor_args;\n    PyObject *contents = _pickle_UnpicklerMemoProxy_copy_impl(self);\n    if (contents == NULL)\n        return NULL;\n\n    reduce_value = PyTuple_New(2);\n    if (reduce_value == NULL) {\n        Py_DECREF(contents);\n        return NULL;\n    }\n    constructor_args = PyTuple_New(1);\n    if (constructor_args == NULL) {\n        Py_DECREF(contents);\n        Py_DECREF(reduce_value);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(constructor_args, 0, contents);\n    Py_INCREF((PyObject *)&PyDict_Type);\n    PyTuple_SET_ITEM(reduce_value, 0, (PyObject *)&PyDict_Type);\n    PyTuple_SET_ITEM(reduce_value, 1, constructor_args);\n    return reduce_value;\n}\n\nstatic PyMethodDef unpicklerproxy_methods[] = {\n    _PICKLE_UNPICKLERMEMOPROXY_CLEAR_METHODDEF\n    _PICKLE_UNPICKLERMEMOPROXY_COPY_METHODDEF\n    _PICKLE_UNPICKLERMEMOPROXY___REDUCE___METHODDEF\n    {NULL, NULL}    /* sentinel */\n};\n\nstatic void\nUnpicklerMemoProxy_dealloc(UnpicklerMemoProxyObject *self)\n{\n    PyObject_GC_UnTrack(self);\n    Py_XDECREF(self->unpickler);\n    PyObject_GC_Del((PyObject *)self);\n}\n\nstatic int\nUnpicklerMemoProxy_traverse(UnpicklerMemoProxyObject *self,\n                            visitproc visit, void *arg)\n{\n    Py_VISIT(self->unpickler);\n    return 0;\n}\n\nstatic int\nUnpicklerMemoProxy_clear(UnpicklerMemoProxyObject *self)\n{\n    Py_CLEAR(self->unpickler);\n    return 0;\n}\n\nstatic PyTypeObject UnpicklerMemoProxyType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.UnpicklerMemoProxy\",               /*tp_name*/\n    sizeof(UnpicklerMemoProxyObject),           /*tp_basicsize*/\n    0,\n    (destructor)UnpicklerMemoProxy_dealloc,     /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    PyObject_HashNotImplemented,                /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    PyObject_GenericSetAttr,                    /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)UnpicklerMemoProxy_traverse,  /* tp_traverse */\n    (inquiry)UnpicklerMemoProxy_clear,          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    unpicklerproxy_methods,                     /* tp_methods */\n};\n\nstatic PyObject *\nUnpicklerMemoProxy_New(UnpicklerObject *unpickler)\n{\n    UnpicklerMemoProxyObject *self;\n\n    self = PyObject_GC_New(UnpicklerMemoProxyObject,\n                           &UnpicklerMemoProxyType);\n    if (self == NULL)\n        return NULL;\n    Py_INCREF(unpickler);\n    self->unpickler = unpickler;\n    PyObject_GC_Track(self);\n    return (PyObject *)self;\n}\n\n/*****************************************************************************/\n\n\nstatic PyObject *\nUnpickler_get_memo(UnpicklerObject *self)\n{\n    return UnpicklerMemoProxy_New(self);\n}\n\nstatic int\nUnpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n{\n    PyObject **new_memo;\n    Py_ssize_t new_memo_size = 0;\n    Py_ssize_t i;\n\n    if (obj == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(obj) == &UnpicklerMemoProxyType) {\n        UnpicklerObject *unpickler =\n            ((UnpicklerMemoProxyObject *)obj)->unpickler;\n\n        new_memo_size = unpickler->memo_size;\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        for (i = 0; i < new_memo_size; i++) {\n            Py_XINCREF(unpickler->memo[i]);\n            new_memo[i] = unpickler->memo[i];\n        }\n    }\n    else if (PyDict_Check(obj)) {\n        Py_ssize_t i = 0;\n        PyObject *key, *value;\n\n        new_memo_size = PyDict_GET_SIZE(obj);\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        while (PyDict_Next(obj, &i, &key, &value)) {\n            Py_ssize_t idx;\n            if (!PyLong_Check(key)) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"memo key must be integers\");\n                goto error;\n            }\n            idx = PyLong_AsSsize_t(key);\n            if (idx == -1 && PyErr_Occurred())\n                goto error;\n            if (idx < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"memo key must be positive integers.\");\n                goto error;\n            }\n            if (_Unpickler_MemoPut(self, idx, value) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"'memo' attribute must be an UnpicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(obj)->tp_name);\n        return -1;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    self->memo_size = new_memo_size;\n    self->memo = new_memo;\n\n    return 0;\n\n  error:\n    if (new_memo_size) {\n        i = new_memo_size;\n        while (--i >= 0) {\n            Py_XDECREF(new_memo[i]);\n        }\n        PyMem_FREE(new_memo);\n    }\n    return -1;\n}\n\nstatic PyObject *\nUnpickler_get_persload(UnpicklerObject *self)\n{\n    if (self->pers_func == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"persistent_load\");\n        return NULL;\n    }\n    return reconstruct_method(self->pers_func, self->pers_func_self);\n}\n\nstatic int\nUnpickler_set_persload(UnpicklerObject *self, PyObject *value)\n{\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n    if (!PyCallable_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"persistent_load must be a callable taking \"\n                        \"one argument\");\n        return -1;\n    }\n\n    self->pers_func_self = NULL;\n    Py_INCREF(value);\n    Py_XSETREF(self->pers_func, value);\n\n    return 0;\n}\n\nstatic PyGetSetDef Unpickler_getsets[] = {\n    {\"memo\", (getter)Unpickler_get_memo, (setter)Unpickler_set_memo},\n    {\"persistent_load\", (getter)Unpickler_get_persload,\n                        (setter)Unpickler_set_persload},\n    {NULL}\n};\n\nstatic PyTypeObject Unpickler_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.Unpickler\",                /*tp_name*/\n    sizeof(UnpicklerObject),            /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    (destructor)Unpickler_dealloc,      /*tp_dealloc*/\n    0,                                  /*tp_print*/\n    0,                                  /*tp_getattr*/\n    0,                                  /*tp_setattr*/\n    0,                                  /*tp_reserved*/\n    0,                                  /*tp_repr*/\n    0,                                  /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    0,                                  /*tp_hash*/\n    0,                                  /*tp_call*/\n    0,                                  /*tp_str*/\n    0,                                  /*tp_getattro*/\n    0,                                  /*tp_setattro*/\n    0,                                  /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n    _pickle_Unpickler___init____doc__,  /*tp_doc*/\n    (traverseproc)Unpickler_traverse,   /*tp_traverse*/\n    (inquiry)Unpickler_clear,           /*tp_clear*/\n    0,                                  /*tp_richcompare*/\n    0,                                  /*tp_weaklistoffset*/\n    0,                                  /*tp_iter*/\n    0,                                  /*tp_iternext*/\n    Unpickler_methods,                  /*tp_methods*/\n    0,                                  /*tp_members*/\n    Unpickler_getsets,                  /*tp_getset*/\n    0,                                  /*tp_base*/\n    0,                                  /*tp_dict*/\n    0,                                  /*tp_descr_get*/\n    0,                                  /*tp_descr_set*/\n    0,                                  /*tp_dictoffset*/\n    _pickle_Unpickler___init__,         /*tp_init*/\n    PyType_GenericAlloc,                /*tp_alloc*/\n    PyType_GenericNew,                  /*tp_new*/\n    PyObject_GC_Del,                    /*tp_free*/\n    0,                                  /*tp_is_gc*/\n};\n\n/*[clinic input]\n\n_pickle.dump\n\n  obj: object\n  file: object\n  protocol: object = NULL\n  *\n  fix_imports: bool = True\n\nWrite a pickled representation of obj to the open file object file.\n\nThis is equivalent to ``Pickler(file, protocol).dump(obj)``, but may\nbe more efficient.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3 and 4.  The default\nprotocol is 4. It was introduced in Python 3.4, it is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument.  It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_dump_impl(PyObject *module, PyObject *obj, PyObject *file,\n                  PyObject *protocol, int fix_imports)\n/*[clinic end generated code: output=a4774d5fde7d34de input=93f1408489a87472]*/\n{\n    PicklerObject *pickler = _Pickler_New();\n\n    if (pickler == NULL)\n        return NULL;\n\n    if (_Pickler_SetProtocol(pickler, protocol, fix_imports) < 0)\n        goto error;\n\n    if (_Pickler_SetOutputStream(pickler, file) < 0)\n        goto error;\n\n    if (dump(pickler, obj) < 0)\n        goto error;\n\n    if (_Pickler_FlushToFile(pickler) < 0)\n        goto error;\n\n    Py_DECREF(pickler);\n    Py_RETURN_NONE;\n\n  error:\n    Py_XDECREF(pickler);\n    return NULL;\n}\n\n/*[clinic input]\n\n_pickle.dumps\n\n  obj: object\n  protocol: object = NULL\n  *\n  fix_imports: bool = True\n\nReturn the pickled representation of the object as a bytes object.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3 and 4.  The default\nprotocol is 4. It was introduced in Python 3.4, it is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nIf *fix_imports* is True and *protocol* is less than 3, pickle will\ntry to map the new Python 3 names to the old module names used in\nPython 2, so that the pickle data stream is readable with Python 2.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_dumps_impl(PyObject *module, PyObject *obj, PyObject *protocol,\n                   int fix_imports)\n/*[clinic end generated code: output=d75d5cda456fd261 input=b6efb45a7d19b5ab]*/\n{\n    PyObject *result;\n    PicklerObject *pickler = _Pickler_New();\n\n    if (pickler == NULL)\n        return NULL;\n\n    if (_Pickler_SetProtocol(pickler, protocol, fix_imports) < 0)\n        goto error;\n\n    if (dump(pickler, obj) < 0)\n        goto error;\n\n    result = _Pickler_GetString(pickler);\n    Py_DECREF(pickler);\n    return result;\n\n  error:\n    Py_XDECREF(pickler);\n    return NULL;\n}\n\n/*[clinic input]\n\n_pickle.load\n\n  file: object\n  *\n  fix_imports: bool = True\n  encoding: str = 'ASCII'\n  errors: str = 'strict'\n\nRead and return an object from the pickle data stored in a file.\n\nThis is equivalent to ``Unpickler(file).load()``, but may be more\nefficient.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_load_impl(PyObject *module, PyObject *file, int fix_imports,\n                  const char *encoding, const char *errors)\n/*[clinic end generated code: output=69e298160285199e input=01b44dd3fc07afa7]*/\n{\n    PyObject *result;\n    UnpicklerObject *unpickler = _Unpickler_New();\n\n    if (unpickler == NULL)\n        return NULL;\n\n    if (_Unpickler_SetInputStream(unpickler, file) < 0)\n        goto error;\n\n    if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)\n        goto error;\n\n    unpickler->fix_imports = fix_imports;\n\n    result = load(unpickler);\n    Py_DECREF(unpickler);\n    return result;\n\n  error:\n    Py_XDECREF(unpickler);\n    return NULL;\n}\n\n/*[clinic input]\n\n_pickle.loads\n\n  data: object\n  *\n  fix_imports: bool = True\n  encoding: str = 'ASCII'\n  errors: str = 'strict'\n\nRead and return an object from the given pickle data.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_loads_impl(PyObject *module, PyObject *data, int fix_imports,\n                   const char *encoding, const char *errors)\n/*[clinic end generated code: output=1e7cb2343f2c440f input=70605948a719feb9]*/\n{\n    PyObject *result;\n    UnpicklerObject *unpickler = _Unpickler_New();\n\n    if (unpickler == NULL)\n        return NULL;\n\n    if (_Unpickler_SetStringInput(unpickler, data) < 0)\n        goto error;\n\n    if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)\n        goto error;\n\n    unpickler->fix_imports = fix_imports;\n\n    result = load(unpickler);\n    Py_DECREF(unpickler);\n    return result;\n\n  error:\n    Py_XDECREF(unpickler);\n    return NULL;\n}\n\nstatic struct PyMethodDef pickle_methods[] = {\n    _PICKLE_DUMP_METHODDEF\n    _PICKLE_DUMPS_METHODDEF\n    _PICKLE_LOAD_METHODDEF\n    _PICKLE_LOADS_METHODDEF\n    {NULL, NULL} /* sentinel */\n};\n\nstatic int\npickle_clear(PyObject *m)\n{\n    _Pickle_ClearState(_Pickle_GetState(m));\n    return 0;\n}\n\nstatic void\npickle_free(PyObject *m)\n{\n    _Pickle_ClearState(_Pickle_GetState(m));\n}\n\nstatic int\npickle_traverse(PyObject *m, visitproc visit, void *arg)\n{\n    PickleState *st = _Pickle_GetState(m);\n    Py_VISIT(st->PickleError);\n    Py_VISIT(st->PicklingError);\n    Py_VISIT(st->UnpicklingError);\n    Py_VISIT(st->dispatch_table);\n    Py_VISIT(st->extension_registry);\n    Py_VISIT(st->extension_cache);\n    Py_VISIT(st->inverted_registry);\n    Py_VISIT(st->name_mapping_2to3);\n    Py_VISIT(st->import_mapping_2to3);\n    Py_VISIT(st->name_mapping_3to2);\n    Py_VISIT(st->import_mapping_3to2);\n    Py_VISIT(st->codecs_encode);\n    Py_VISIT(st->getattr);\n    return 0;\n}\n\nstatic struct PyModuleDef _picklemodule = {\n    PyModuleDef_HEAD_INIT,\n    \"_pickle\",            /* m_name */\n    pickle_module_doc,    /* m_doc */\n    sizeof(PickleState),  /* m_size */\n    pickle_methods,       /* m_methods */\n    NULL,                 /* m_reload */\n    pickle_traverse,      /* m_traverse */\n    pickle_clear,         /* m_clear */\n    (freefunc)pickle_free /* m_free */\n};\n\nPyMODINIT_FUNC\nPyInit__pickle(void)\n{\n    PyObject *m;\n    PickleState *st;\n\n    m = PyState_FindModule(&_picklemodule);\n    if (m) {\n        Py_INCREF(m);\n        return m;\n    }\n\n    if (PyType_Ready(&Unpickler_Type) < 0)\n        return NULL;\n    if (PyType_Ready(&Pickler_Type) < 0)\n        return NULL;\n    if (PyType_Ready(&Pdata_Type) < 0)\n        return NULL;\n    if (PyType_Ready(&PicklerMemoProxyType) < 0)\n        return NULL;\n    if (PyType_Ready(&UnpicklerMemoProxyType) < 0)\n        return NULL;\n\n    /* Create the module and add the functions. */\n    m = PyModule_Create(&_picklemodule);\n    if (m == NULL)\n        return NULL;\n\n    Py_INCREF(&Pickler_Type);\n    if (PyModule_AddObject(m, \"Pickler\", (PyObject *)&Pickler_Type) < 0)\n        return NULL;\n    Py_INCREF(&Unpickler_Type);\n    if (PyModule_AddObject(m, \"Unpickler\", (PyObject *)&Unpickler_Type) < 0)\n        return NULL;\n\n    st = _Pickle_GetState(m);\n\n    /* Initialize the exceptions. */\n    st->PickleError = PyErr_NewException(\"_pickle.PickleError\", NULL, NULL);\n    if (st->PickleError == NULL)\n        return NULL;\n    st->PicklingError = \\\n        PyErr_NewException(\"_pickle.PicklingError\", st->PickleError, NULL);\n    if (st->PicklingError == NULL)\n        return NULL;\n    st->UnpicklingError = \\\n        PyErr_NewException(\"_pickle.UnpicklingError\", st->PickleError, NULL);\n    if (st->UnpicklingError == NULL)\n        return NULL;\n\n    Py_INCREF(st->PickleError);\n    if (PyModule_AddObject(m, \"PickleError\", st->PickleError) < 0)\n        return NULL;\n    Py_INCREF(st->PicklingError);\n    if (PyModule_AddObject(m, \"PicklingError\", st->PicklingError) < 0)\n        return NULL;\n    Py_INCREF(st->UnpicklingError);\n    if (PyModule_AddObject(m, \"UnpicklingError\", st->UnpicklingError) < 0)\n        return NULL;\n\n    if (_Pickle_InitState(st) < 0)\n        return NULL;\n\n    return m;\n}\n"], "fixing_code": ["\n/* Core extension modules are built-in on some platforms (e.g. Windows). */\n#ifdef Py_BUILD_CORE\n#define Py_BUILD_CORE_BUILTIN\n#undef Py_BUILD_CORE\n#endif\n\n#include \"Python.h\"\n#include \"structmember.h\"\n\nPyDoc_STRVAR(pickle_module_doc,\n\"Optimized C implementation for the Python pickle module.\");\n\n/*[clinic input]\nmodule _pickle\nclass _pickle.Pickler \"PicklerObject *\" \"&Pickler_Type\"\nclass _pickle.PicklerMemoProxy \"PicklerMemoProxyObject *\" \"&PicklerMemoProxyType\"\nclass _pickle.Unpickler \"UnpicklerObject *\" \"&Unpickler_Type\"\nclass _pickle.UnpicklerMemoProxy \"UnpicklerMemoProxyObject *\" \"&UnpicklerMemoProxyType\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=4b3e113468a58e6c]*/\n\n/* Bump HIGHEST_PROTOCOL when new opcodes are added to the pickle protocol.\n   Bump DEFAULT_PROTOCOL only when the oldest still supported version of Python\n   already includes it. */\nenum {\n    HIGHEST_PROTOCOL = 4,\n    DEFAULT_PROTOCOL = 4\n};\n\n/* Pickle opcodes. These must be kept updated with pickle.py.\n   Extensive docs are in pickletools.py. */\nenum opcode {\n    MARK            = '(',\n    STOP            = '.',\n    POP             = '0',\n    POP_MARK        = '1',\n    DUP             = '2',\n    FLOAT           = 'F',\n    INT             = 'I',\n    BININT          = 'J',\n    BININT1         = 'K',\n    LONG            = 'L',\n    BININT2         = 'M',\n    NONE            = 'N',\n    PERSID          = 'P',\n    BINPERSID       = 'Q',\n    REDUCE          = 'R',\n    STRING          = 'S',\n    BINSTRING       = 'T',\n    SHORT_BINSTRING = 'U',\n    UNICODE         = 'V',\n    BINUNICODE      = 'X',\n    APPEND          = 'a',\n    BUILD           = 'b',\n    GLOBAL          = 'c',\n    DICT            = 'd',\n    EMPTY_DICT      = '}',\n    APPENDS         = 'e',\n    GET             = 'g',\n    BINGET          = 'h',\n    INST            = 'i',\n    LONG_BINGET     = 'j',\n    LIST            = 'l',\n    EMPTY_LIST      = ']',\n    OBJ             = 'o',\n    PUT             = 'p',\n    BINPUT          = 'q',\n    LONG_BINPUT     = 'r',\n    SETITEM         = 's',\n    TUPLE           = 't',\n    EMPTY_TUPLE     = ')',\n    SETITEMS        = 'u',\n    BINFLOAT        = 'G',\n\n    /* Protocol 2. */\n    PROTO       = '\\x80',\n    NEWOBJ      = '\\x81',\n    EXT1        = '\\x82',\n    EXT2        = '\\x83',\n    EXT4        = '\\x84',\n    TUPLE1      = '\\x85',\n    TUPLE2      = '\\x86',\n    TUPLE3      = '\\x87',\n    NEWTRUE     = '\\x88',\n    NEWFALSE    = '\\x89',\n    LONG1       = '\\x8a',\n    LONG4       = '\\x8b',\n\n    /* Protocol 3 (Python 3.x) */\n    BINBYTES       = 'B',\n    SHORT_BINBYTES = 'C',\n\n    /* Protocol 4 */\n    SHORT_BINUNICODE = '\\x8c',\n    BINUNICODE8      = '\\x8d',\n    BINBYTES8        = '\\x8e',\n    EMPTY_SET        = '\\x8f',\n    ADDITEMS         = '\\x90',\n    FROZENSET        = '\\x91',\n    NEWOBJ_EX        = '\\x92',\n    STACK_GLOBAL     = '\\x93',\n    MEMOIZE          = '\\x94',\n    FRAME            = '\\x95'\n};\n\nenum {\n   /* Keep in synch with pickle.Pickler._BATCHSIZE.  This is how many elements\n      batch_list/dict() pumps out before doing APPENDS/SETITEMS.  Nothing will\n      break if this gets out of synch with pickle.py, but it's unclear that would\n      help anything either. */\n    BATCHSIZE = 1000,\n\n    /* Nesting limit until Pickler, when running in \"fast mode\", starts\n       checking for self-referential data-structures. */\n    FAST_NESTING_LIMIT = 50,\n\n    /* Initial size of the write buffer of Pickler. */\n    WRITE_BUF_SIZE = 4096,\n\n    /* Prefetch size when unpickling (disabled on unpeekable streams) */\n    PREFETCH = 8192 * 16,\n\n    FRAME_SIZE_MIN = 4,\n    FRAME_SIZE_TARGET = 64 * 1024,\n    FRAME_HEADER_SIZE = 9\n};\n\n/*************************************************************************/\n\n/* State of the pickle module, per PEP 3121. */\ntypedef struct {\n    /* Exception classes for pickle. */\n    PyObject *PickleError;\n    PyObject *PicklingError;\n    PyObject *UnpicklingError;\n\n    /* copyreg.dispatch_table, {type_object: pickling_function} */\n    PyObject *dispatch_table;\n\n    /* For the extension opcodes EXT1, EXT2 and EXT4. */\n\n    /* copyreg._extension_registry, {(module_name, function_name): code} */\n    PyObject *extension_registry;\n    /* copyreg._extension_cache, {code: object} */\n    PyObject *extension_cache;\n    /* copyreg._inverted_registry, {code: (module_name, function_name)} */\n    PyObject *inverted_registry;\n\n    /* Import mappings for compatibility with Python 2.x */\n\n    /* _compat_pickle.NAME_MAPPING,\n       {(oldmodule, oldname): (newmodule, newname)} */\n    PyObject *name_mapping_2to3;\n    /* _compat_pickle.IMPORT_MAPPING, {oldmodule: newmodule} */\n    PyObject *import_mapping_2to3;\n    /* Same, but with REVERSE_NAME_MAPPING / REVERSE_IMPORT_MAPPING */\n    PyObject *name_mapping_3to2;\n    PyObject *import_mapping_3to2;\n\n    /* codecs.encode, used for saving bytes in older protocols */\n    PyObject *codecs_encode;\n    /* builtins.getattr, used for saving nested names with protocol < 4 */\n    PyObject *getattr;\n    /* functools.partial, used for implementing __newobj_ex__ with protocols\n       2 and 3 */\n    PyObject *partial;\n} PickleState;\n\n/* Forward declaration of the _pickle module definition. */\nstatic struct PyModuleDef _picklemodule;\n\n/* Given a module object, get its per-module state. */\nstatic PickleState *\n_Pickle_GetState(PyObject *module)\n{\n    return (PickleState *)PyModule_GetState(module);\n}\n\n/* Find the module instance imported in the currently running sub-interpreter\n   and get its state. */\nstatic PickleState *\n_Pickle_GetGlobalState(void)\n{\n    return _Pickle_GetState(PyState_FindModule(&_picklemodule));\n}\n\n/* Clear the given pickle module state. */\nstatic void\n_Pickle_ClearState(PickleState *st)\n{\n    Py_CLEAR(st->PickleError);\n    Py_CLEAR(st->PicklingError);\n    Py_CLEAR(st->UnpicklingError);\n    Py_CLEAR(st->dispatch_table);\n    Py_CLEAR(st->extension_registry);\n    Py_CLEAR(st->extension_cache);\n    Py_CLEAR(st->inverted_registry);\n    Py_CLEAR(st->name_mapping_2to3);\n    Py_CLEAR(st->import_mapping_2to3);\n    Py_CLEAR(st->name_mapping_3to2);\n    Py_CLEAR(st->import_mapping_3to2);\n    Py_CLEAR(st->codecs_encode);\n    Py_CLEAR(st->getattr);\n    Py_CLEAR(st->partial);\n}\n\n/* Initialize the given pickle module state. */\nstatic int\n_Pickle_InitState(PickleState *st)\n{\n    PyObject *builtins;\n    PyObject *copyreg = NULL;\n    PyObject *compat_pickle = NULL;\n    PyObject *codecs = NULL;\n    PyObject *functools = NULL;\n\n    builtins = PyEval_GetBuiltins();\n    if (builtins == NULL)\n        goto error;\n    st->getattr = PyDict_GetItemString(builtins, \"getattr\");\n    if (st->getattr == NULL)\n        goto error;\n    Py_INCREF(st->getattr);\n\n    copyreg = PyImport_ImportModule(\"copyreg\");\n    if (!copyreg)\n        goto error;\n    st->dispatch_table = PyObject_GetAttrString(copyreg, \"dispatch_table\");\n    if (!st->dispatch_table)\n        goto error;\n    if (!PyDict_CheckExact(st->dispatch_table)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"copyreg.dispatch_table should be a dict, not %.200s\",\n                     Py_TYPE(st->dispatch_table)->tp_name);\n        goto error;\n    }\n    st->extension_registry = \\\n        PyObject_GetAttrString(copyreg, \"_extension_registry\");\n    if (!st->extension_registry)\n        goto error;\n    if (!PyDict_CheckExact(st->extension_registry)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"copyreg._extension_registry should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->extension_registry)->tp_name);\n        goto error;\n    }\n    st->inverted_registry = \\\n        PyObject_GetAttrString(copyreg, \"_inverted_registry\");\n    if (!st->inverted_registry)\n        goto error;\n    if (!PyDict_CheckExact(st->inverted_registry)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"copyreg._inverted_registry should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->inverted_registry)->tp_name);\n        goto error;\n    }\n    st->extension_cache = PyObject_GetAttrString(copyreg, \"_extension_cache\");\n    if (!st->extension_cache)\n        goto error;\n    if (!PyDict_CheckExact(st->extension_cache)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"copyreg._extension_cache should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->extension_cache)->tp_name);\n        goto error;\n    }\n    Py_CLEAR(copyreg);\n\n    /* Load the 2.x -> 3.x stdlib module mapping tables */\n    compat_pickle = PyImport_ImportModule(\"_compat_pickle\");\n    if (!compat_pickle)\n        goto error;\n    st->name_mapping_2to3 = \\\n        PyObject_GetAttrString(compat_pickle, \"NAME_MAPPING\");\n    if (!st->name_mapping_2to3)\n        goto error;\n    if (!PyDict_CheckExact(st->name_mapping_2to3)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"_compat_pickle.NAME_MAPPING should be a dict, not %.200s\",\n                     Py_TYPE(st->name_mapping_2to3)->tp_name);\n        goto error;\n    }\n    st->import_mapping_2to3 = \\\n        PyObject_GetAttrString(compat_pickle, \"IMPORT_MAPPING\");\n    if (!st->import_mapping_2to3)\n        goto error;\n    if (!PyDict_CheckExact(st->import_mapping_2to3)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"_compat_pickle.IMPORT_MAPPING should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->import_mapping_2to3)->tp_name);\n        goto error;\n    }\n    /* ... and the 3.x -> 2.x mapping tables */\n    st->name_mapping_3to2 = \\\n        PyObject_GetAttrString(compat_pickle, \"REVERSE_NAME_MAPPING\");\n    if (!st->name_mapping_3to2)\n        goto error;\n    if (!PyDict_CheckExact(st->name_mapping_3to2)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"_compat_pickle.REVERSE_NAME_MAPPING should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->name_mapping_3to2)->tp_name);\n        goto error;\n    }\n    st->import_mapping_3to2 = \\\n        PyObject_GetAttrString(compat_pickle, \"REVERSE_IMPORT_MAPPING\");\n    if (!st->import_mapping_3to2)\n        goto error;\n    if (!PyDict_CheckExact(st->import_mapping_3to2)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"_compat_pickle.REVERSE_IMPORT_MAPPING should be a dict, \"\n                     \"not %.200s\", Py_TYPE(st->import_mapping_3to2)->tp_name);\n        goto error;\n    }\n    Py_CLEAR(compat_pickle);\n\n    codecs = PyImport_ImportModule(\"codecs\");\n    if (codecs == NULL)\n        goto error;\n    st->codecs_encode = PyObject_GetAttrString(codecs, \"encode\");\n    if (st->codecs_encode == NULL) {\n        goto error;\n    }\n    if (!PyCallable_Check(st->codecs_encode)) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"codecs.encode should be a callable, not %.200s\",\n                     Py_TYPE(st->codecs_encode)->tp_name);\n        goto error;\n    }\n    Py_CLEAR(codecs);\n\n    functools = PyImport_ImportModule(\"functools\");\n    if (!functools)\n        goto error;\n    st->partial = PyObject_GetAttrString(functools, \"partial\");\n    if (!st->partial)\n        goto error;\n    Py_CLEAR(functools);\n\n    return 0;\n\n  error:\n    Py_CLEAR(copyreg);\n    Py_CLEAR(compat_pickle);\n    Py_CLEAR(codecs);\n    Py_CLEAR(functools);\n    _Pickle_ClearState(st);\n    return -1;\n}\n\n/* Helper for calling a function with a single argument quickly.\n\n   This function steals the reference of the given argument. */\nstatic PyObject *\n_Pickle_FastCall(PyObject *func, PyObject *obj)\n{\n    PyObject *result;\n\n    result = PyObject_CallFunctionObjArgs(func, obj, NULL);\n    Py_DECREF(obj);\n    return result;\n}\n\n/*************************************************************************/\n\n/* Retrieve and deconstruct a method for avoiding a reference cycle\n   (pickler -> bound method of pickler -> pickler) */\nstatic int\ninit_method_ref(PyObject *self, _Py_Identifier *name,\n                PyObject **method_func, PyObject **method_self)\n{\n    PyObject *func, *func2;\n    int ret;\n\n    /* *method_func and *method_self should be consistent.  All refcount decrements\n       should be occurred after setting *method_self and *method_func. */\n    ret = _PyObject_LookupAttrId(self, name, &func);\n    if (func == NULL) {\n        *method_self = NULL;\n        Py_CLEAR(*method_func);\n        return ret;\n    }\n\n    if (PyMethod_Check(func) && PyMethod_GET_SELF(func) == self) {\n        /* Deconstruct a bound Python method */\n        func2 = PyMethod_GET_FUNCTION(func);\n        Py_INCREF(func2);\n        *method_self = self; /* borrowed */\n        Py_XSETREF(*method_func, func2);\n        Py_DECREF(func);\n        return 0;\n    }\n    else {\n        *method_self = NULL;\n        Py_XSETREF(*method_func, func);\n        return 0;\n    }\n}\n\n/* Bind a method if it was deconstructed */\nstatic PyObject *\nreconstruct_method(PyObject *func, PyObject *self)\n{\n    if (self) {\n        return PyMethod_New(func, self);\n    }\n    else {\n        Py_INCREF(func);\n        return func;\n    }\n}\n\nstatic PyObject *\ncall_method(PyObject *func, PyObject *self, PyObject *obj)\n{\n    if (self) {\n        return PyObject_CallFunctionObjArgs(func, self, obj, NULL);\n    }\n    else {\n        return PyObject_CallFunctionObjArgs(func, obj, NULL);\n    }\n}\n\n/*************************************************************************/\n\n/* Internal data type used as the unpickling stack. */\ntypedef struct {\n    PyObject_VAR_HEAD\n    PyObject **data;\n    int mark_set;          /* is MARK set? */\n    Py_ssize_t fence;      /* position of top MARK or 0 */\n    Py_ssize_t allocated;  /* number of slots in data allocated */\n} Pdata;\n\nstatic void\nPdata_dealloc(Pdata *self)\n{\n    Py_ssize_t i = Py_SIZE(self);\n    while (--i >= 0) {\n        Py_DECREF(self->data[i]);\n    }\n    PyMem_FREE(self->data);\n    PyObject_Del(self);\n}\n\nstatic PyTypeObject Pdata_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.Pdata\",              /*tp_name*/\n    sizeof(Pdata),                /*tp_basicsize*/\n    sizeof(PyObject *),           /*tp_itemsize*/\n    (destructor)Pdata_dealloc,    /*tp_dealloc*/\n};\n\nstatic PyObject *\nPdata_New(void)\n{\n    Pdata *self;\n\n    if (!(self = PyObject_New(Pdata, &Pdata_Type)))\n        return NULL;\n    Py_SIZE(self) = 0;\n    self->mark_set = 0;\n    self->fence = 0;\n    self->allocated = 8;\n    self->data = PyMem_MALLOC(self->allocated * sizeof(PyObject *));\n    if (self->data)\n        return (PyObject *)self;\n    Py_DECREF(self);\n    return PyErr_NoMemory();\n}\n\n\n/* Retain only the initial clearto items.  If clearto >= the current\n * number of items, this is a (non-erroneous) NOP.\n */\nstatic int\nPdata_clear(Pdata *self, Py_ssize_t clearto)\n{\n    Py_ssize_t i = Py_SIZE(self);\n\n    assert(clearto >= self->fence);\n    if (clearto >= i)\n        return 0;\n\n    while (--i >= clearto) {\n        Py_CLEAR(self->data[i]);\n    }\n    Py_SIZE(self) = clearto;\n    return 0;\n}\n\nstatic int\nPdata_grow(Pdata *self)\n{\n    PyObject **data = self->data;\n    size_t allocated = (size_t)self->allocated;\n    size_t new_allocated;\n\n    new_allocated = (allocated >> 3) + 6;\n    /* check for integer overflow */\n    if (new_allocated > (size_t)PY_SSIZE_T_MAX - allocated)\n        goto nomemory;\n    new_allocated += allocated;\n    PyMem_RESIZE(data, PyObject *, new_allocated);\n    if (data == NULL)\n        goto nomemory;\n\n    self->data = data;\n    self->allocated = (Py_ssize_t)new_allocated;\n    return 0;\n\n  nomemory:\n    PyErr_NoMemory();\n    return -1;\n}\n\nstatic int\nPdata_stack_underflow(Pdata *self)\n{\n    PickleState *st = _Pickle_GetGlobalState();\n    PyErr_SetString(st->UnpicklingError,\n                    self->mark_set ?\n                    \"unexpected MARK found\" :\n                    \"unpickling stack underflow\");\n    return -1;\n}\n\n/* D is a Pdata*.  Pop the topmost element and store it into V, which\n * must be an lvalue holding PyObject*.  On stack underflow, UnpicklingError\n * is raised and V is set to NULL.\n */\nstatic PyObject *\nPdata_pop(Pdata *self)\n{\n    if (Py_SIZE(self) <= self->fence) {\n        Pdata_stack_underflow(self);\n        return NULL;\n    }\n    return self->data[--Py_SIZE(self)];\n}\n#define PDATA_POP(D, V) do { (V) = Pdata_pop((D)); } while (0)\n\nstatic int\nPdata_push(Pdata *self, PyObject *obj)\n{\n    if (Py_SIZE(self) == self->allocated && Pdata_grow(self) < 0) {\n        return -1;\n    }\n    self->data[Py_SIZE(self)++] = obj;\n    return 0;\n}\n\n/* Push an object on stack, transferring its ownership to the stack. */\n#define PDATA_PUSH(D, O, ER) do {                               \\\n        if (Pdata_push((D), (O)) < 0) return (ER); } while(0)\n\n/* Push an object on stack, adding a new reference to the object. */\n#define PDATA_APPEND(D, O, ER) do {                             \\\n        Py_INCREF((O));                                         \\\n        if (Pdata_push((D), (O)) < 0) return (ER); } while(0)\n\nstatic PyObject *\nPdata_poptuple(Pdata *self, Py_ssize_t start)\n{\n    PyObject *tuple;\n    Py_ssize_t len, i, j;\n\n    if (start < self->fence) {\n        Pdata_stack_underflow(self);\n        return NULL;\n    }\n    len = Py_SIZE(self) - start;\n    tuple = PyTuple_New(len);\n    if (tuple == NULL)\n        return NULL;\n    for (i = start, j = 0; j < len; i++, j++)\n        PyTuple_SET_ITEM(tuple, j, self->data[i]);\n\n    Py_SIZE(self) = start;\n    return tuple;\n}\n\nstatic PyObject *\nPdata_poplist(Pdata *self, Py_ssize_t start)\n{\n    PyObject *list;\n    Py_ssize_t len, i, j;\n\n    len = Py_SIZE(self) - start;\n    list = PyList_New(len);\n    if (list == NULL)\n        return NULL;\n    for (i = start, j = 0; j < len; i++, j++)\n        PyList_SET_ITEM(list, j, self->data[i]);\n\n    Py_SIZE(self) = start;\n    return list;\n}\n\ntypedef struct {\n    PyObject *me_key;\n    Py_ssize_t me_value;\n} PyMemoEntry;\n\ntypedef struct {\n    size_t mt_mask;\n    size_t mt_used;\n    size_t mt_allocated;\n    PyMemoEntry *mt_table;\n} PyMemoTable;\n\ntypedef struct PicklerObject {\n    PyObject_HEAD\n    PyMemoTable *memo;          /* Memo table, keep track of the seen\n                                   objects to support self-referential objects\n                                   pickling. */\n    PyObject *pers_func;        /* persistent_id() method, can be NULL */\n    PyObject *pers_func_self;   /* borrowed reference to self if pers_func\n                                   is an unbound method, NULL otherwise */\n    PyObject *dispatch_table;   /* private dispatch_table, can be NULL */\n\n    PyObject *write;            /* write() method of the output stream. */\n    PyObject *output_buffer;    /* Write into a local bytearray buffer before\n                                   flushing to the stream. */\n    Py_ssize_t output_len;      /* Length of output_buffer. */\n    Py_ssize_t max_output_len;  /* Allocation size of output_buffer. */\n    int proto;                  /* Pickle protocol number, >= 0 */\n    int bin;                    /* Boolean, true if proto > 0 */\n    int framing;                /* True when framing is enabled, proto >= 4 */\n    Py_ssize_t frame_start;     /* Position in output_buffer where the\n                                   current frame begins. -1 if there\n                                   is no frame currently open. */\n\n    Py_ssize_t buf_size;        /* Size of the current buffered pickle data */\n    int fast;                   /* Enable fast mode if set to a true value.\n                                   The fast mode disable the usage of memo,\n                                   therefore speeding the pickling process by\n                                   not generating superfluous PUT opcodes. It\n                                   should not be used if with self-referential\n                                   objects. */\n    int fast_nesting;\n    int fix_imports;            /* Indicate whether Pickler should fix\n                                   the name of globals for Python 2.x. */\n    PyObject *fast_memo;\n} PicklerObject;\n\ntypedef struct UnpicklerObject {\n    PyObject_HEAD\n    Pdata *stack;               /* Pickle data stack, store unpickled objects. */\n\n    /* The unpickler memo is just an array of PyObject *s. Using a dict\n       is unnecessary, since the keys are contiguous ints. */\n    PyObject **memo;\n    size_t memo_size;       /* Capacity of the memo array */\n    size_t memo_len;        /* Number of objects in the memo */\n\n    PyObject *pers_func;        /* persistent_load() method, can be NULL. */\n    PyObject *pers_func_self;   /* borrowed reference to self if pers_func\n                                   is an unbound method, NULL otherwise */\n\n    Py_buffer buffer;\n    char *input_buffer;\n    char *input_line;\n    Py_ssize_t input_len;\n    Py_ssize_t next_read_idx;\n    Py_ssize_t prefetched_idx;  /* index of first prefetched byte */\n\n    PyObject *read;             /* read() method of the input stream. */\n    PyObject *readline;         /* readline() method of the input stream. */\n    PyObject *peek;             /* peek() method of the input stream, or NULL */\n\n    char *encoding;             /* Name of the encoding to be used for\n                                   decoding strings pickled using Python\n                                   2.x. The default value is \"ASCII\" */\n    char *errors;               /* Name of errors handling scheme to used when\n                                   decoding strings. The default value is\n                                   \"strict\". */\n    Py_ssize_t *marks;          /* Mark stack, used for unpickling container\n                                   objects. */\n    Py_ssize_t num_marks;       /* Number of marks in the mark stack. */\n    Py_ssize_t marks_size;      /* Current allocated size of the mark stack. */\n    int proto;                  /* Protocol of the pickle loaded. */\n    int fix_imports;            /* Indicate whether Unpickler should fix\n                                   the name of globals pickled by Python 2.x. */\n} UnpicklerObject;\n\ntypedef struct {\n    PyObject_HEAD\n    PicklerObject *pickler; /* Pickler whose memo table we're proxying. */\n}  PicklerMemoProxyObject;\n\ntypedef struct {\n    PyObject_HEAD\n    UnpicklerObject *unpickler;\n} UnpicklerMemoProxyObject;\n\n/* Forward declarations */\nstatic int save(PicklerObject *, PyObject *, int);\nstatic int save_reduce(PicklerObject *, PyObject *, PyObject *);\nstatic PyTypeObject Pickler_Type;\nstatic PyTypeObject Unpickler_Type;\n\n#include \"clinic/_pickle.c.h\"\n\n/*************************************************************************\n A custom hashtable mapping void* to Python ints. This is used by the pickler\n for memoization. Using a custom hashtable rather than PyDict allows us to skip\n a bunch of unnecessary object creation. This makes a huge performance\n difference. */\n\n#define MT_MINSIZE 8\n#define PERTURB_SHIFT 5\n\n\nstatic PyMemoTable *\nPyMemoTable_New(void)\n{\n    PyMemoTable *memo = PyMem_MALLOC(sizeof(PyMemoTable));\n    if (memo == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    memo->mt_used = 0;\n    memo->mt_allocated = MT_MINSIZE;\n    memo->mt_mask = MT_MINSIZE - 1;\n    memo->mt_table = PyMem_MALLOC(MT_MINSIZE * sizeof(PyMemoEntry));\n    if (memo->mt_table == NULL) {\n        PyMem_FREE(memo);\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset(memo->mt_table, 0, MT_MINSIZE * sizeof(PyMemoEntry));\n\n    return memo;\n}\n\nstatic PyMemoTable *\nPyMemoTable_Copy(PyMemoTable *self)\n{\n    PyMemoTable *new = PyMemoTable_New();\n    if (new == NULL)\n        return NULL;\n\n    new->mt_used = self->mt_used;\n    new->mt_allocated = self->mt_allocated;\n    new->mt_mask = self->mt_mask;\n    /* The table we get from _New() is probably smaller than we wanted.\n       Free it and allocate one that's the right size. */\n    PyMem_FREE(new->mt_table);\n    new->mt_table = PyMem_NEW(PyMemoEntry, self->mt_allocated);\n    if (new->mt_table == NULL) {\n        PyMem_FREE(new);\n        PyErr_NoMemory();\n        return NULL;\n    }\n    for (size_t i = 0; i < self->mt_allocated; i++) {\n        Py_XINCREF(self->mt_table[i].me_key);\n    }\n    memcpy(new->mt_table, self->mt_table,\n           sizeof(PyMemoEntry) * self->mt_allocated);\n\n    return new;\n}\n\nstatic Py_ssize_t\nPyMemoTable_Size(PyMemoTable *self)\n{\n    return self->mt_used;\n}\n\nstatic int\nPyMemoTable_Clear(PyMemoTable *self)\n{\n    Py_ssize_t i = self->mt_allocated;\n\n    while (--i >= 0) {\n        Py_XDECREF(self->mt_table[i].me_key);\n    }\n    self->mt_used = 0;\n    memset(self->mt_table, 0, self->mt_allocated * sizeof(PyMemoEntry));\n    return 0;\n}\n\nstatic void\nPyMemoTable_Del(PyMemoTable *self)\n{\n    if (self == NULL)\n        return;\n    PyMemoTable_Clear(self);\n\n    PyMem_FREE(self->mt_table);\n    PyMem_FREE(self);\n}\n\n/* Since entries cannot be deleted from this hashtable, _PyMemoTable_Lookup()\n   can be considerably simpler than dictobject.c's lookdict(). */\nstatic PyMemoEntry *\n_PyMemoTable_Lookup(PyMemoTable *self, PyObject *key)\n{\n    size_t i;\n    size_t perturb;\n    size_t mask = self->mt_mask;\n    PyMemoEntry *table = self->mt_table;\n    PyMemoEntry *entry;\n    Py_hash_t hash = (Py_hash_t)key >> 3;\n\n    i = hash & mask;\n    entry = &table[i];\n    if (entry->me_key == NULL || entry->me_key == key)\n        return entry;\n\n    for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {\n        i = (i << 2) + i + perturb + 1;\n        entry = &table[i & mask];\n        if (entry->me_key == NULL || entry->me_key == key)\n            return entry;\n    }\n    Py_UNREACHABLE();\n}\n\n/* Returns -1 on failure, 0 on success. */\nstatic int\n_PyMemoTable_ResizeTable(PyMemoTable *self, size_t min_size)\n{\n    PyMemoEntry *oldtable = NULL;\n    PyMemoEntry *oldentry, *newentry;\n    size_t new_size = MT_MINSIZE;\n    size_t to_process;\n\n    assert(min_size > 0);\n\n    if (min_size > PY_SSIZE_T_MAX) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    /* Find the smallest valid table size >= min_size. */\n    while (new_size < min_size) {\n        new_size <<= 1;\n    }\n    /* new_size needs to be a power of two. */\n    assert((new_size & (new_size - 1)) == 0);\n\n    /* Allocate new table. */\n    oldtable = self->mt_table;\n    self->mt_table = PyMem_NEW(PyMemoEntry, new_size);\n    if (self->mt_table == NULL) {\n        self->mt_table = oldtable;\n        PyErr_NoMemory();\n        return -1;\n    }\n    self->mt_allocated = new_size;\n    self->mt_mask = new_size - 1;\n    memset(self->mt_table, 0, sizeof(PyMemoEntry) * new_size);\n\n    /* Copy entries from the old table. */\n    to_process = self->mt_used;\n    for (oldentry = oldtable; to_process > 0; oldentry++) {\n        if (oldentry->me_key != NULL) {\n            to_process--;\n            /* newentry is a pointer to a chunk of the new\n               mt_table, so we're setting the key:value pair\n               in-place. */\n            newentry = _PyMemoTable_Lookup(self, oldentry->me_key);\n            newentry->me_key = oldentry->me_key;\n            newentry->me_value = oldentry->me_value;\n        }\n    }\n\n    /* Deallocate the old table. */\n    PyMem_FREE(oldtable);\n    return 0;\n}\n\n/* Returns NULL on failure, a pointer to the value otherwise. */\nstatic Py_ssize_t *\nPyMemoTable_Get(PyMemoTable *self, PyObject *key)\n{\n    PyMemoEntry *entry = _PyMemoTable_Lookup(self, key);\n    if (entry->me_key == NULL)\n        return NULL;\n    return &entry->me_value;\n}\n\n/* Returns -1 on failure, 0 on success. */\nstatic int\nPyMemoTable_Set(PyMemoTable *self, PyObject *key, Py_ssize_t value)\n{\n    PyMemoEntry *entry;\n\n    assert(key != NULL);\n\n    entry = _PyMemoTable_Lookup(self, key);\n    if (entry->me_key != NULL) {\n        entry->me_value = value;\n        return 0;\n    }\n    Py_INCREF(key);\n    entry->me_key = key;\n    entry->me_value = value;\n    self->mt_used++;\n\n    /* If we added a key, we can safely resize. Otherwise just return!\n     * If used >= 2/3 size, adjust size. Normally, this quaduples the size.\n     *\n     * Quadrupling the size improves average table sparseness\n     * (reducing collisions) at the cost of some memory. It also halves\n     * the number of expensive resize operations in a growing memo table.\n     *\n     * Very large memo tables (over 50K items) use doubling instead.\n     * This may help applications with severe memory constraints.\n     */\n    if (SIZE_MAX / 3 >= self->mt_used && self->mt_used * 3 < self->mt_allocated * 2) {\n        return 0;\n    }\n    // self->mt_used is always < PY_SSIZE_T_MAX, so this can't overflow.\n    size_t desired_size = (self->mt_used > 50000 ? 2 : 4) * self->mt_used;\n    return _PyMemoTable_ResizeTable(self, desired_size);\n}\n\n#undef MT_MINSIZE\n#undef PERTURB_SHIFT\n\n/*************************************************************************/\n\n\nstatic int\n_Pickler_ClearBuffer(PicklerObject *self)\n{\n    Py_XSETREF(self->output_buffer,\n              PyBytes_FromStringAndSize(NULL, self->max_output_len));\n    if (self->output_buffer == NULL)\n        return -1;\n    self->output_len = 0;\n    self->frame_start = -1;\n    return 0;\n}\n\nstatic void\n_write_size64(char *out, size_t value)\n{\n    size_t i;\n\n    Py_BUILD_ASSERT(sizeof(size_t) <= 8);\n\n    for (i = 0; i < sizeof(size_t); i++) {\n        out[i] = (unsigned char)((value >> (8 * i)) & 0xff);\n    }\n    for (i = sizeof(size_t); i < 8; i++) {\n        out[i] = 0;\n    }\n}\n\nstatic int\n_Pickler_CommitFrame(PicklerObject *self)\n{\n    size_t frame_len;\n    char *qdata;\n\n    if (!self->framing || self->frame_start == -1)\n        return 0;\n    frame_len = self->output_len - self->frame_start - FRAME_HEADER_SIZE;\n    qdata = PyBytes_AS_STRING(self->output_buffer) + self->frame_start;\n    if (frame_len >= FRAME_SIZE_MIN) {\n        qdata[0] = FRAME;\n        _write_size64(qdata + 1, frame_len);\n    }\n    else {\n        memmove(qdata, qdata + FRAME_HEADER_SIZE, frame_len);\n        self->output_len -= FRAME_HEADER_SIZE;\n    }\n    self->frame_start = -1;\n    return 0;\n}\n\nstatic PyObject *\n_Pickler_GetString(PicklerObject *self)\n{\n    PyObject *output_buffer = self->output_buffer;\n\n    assert(self->output_buffer != NULL);\n\n    if (_Pickler_CommitFrame(self))\n        return NULL;\n\n    self->output_buffer = NULL;\n    /* Resize down to exact size */\n    if (_PyBytes_Resize(&output_buffer, self->output_len) < 0)\n        return NULL;\n    return output_buffer;\n}\n\nstatic int\n_Pickler_FlushToFile(PicklerObject *self)\n{\n    PyObject *output, *result;\n\n    assert(self->write != NULL);\n\n    /* This will commit the frame first */\n    output = _Pickler_GetString(self);\n    if (output == NULL)\n        return -1;\n\n    result = _Pickle_FastCall(self->write, output);\n    Py_XDECREF(result);\n    return (result == NULL) ? -1 : 0;\n}\n\nstatic int\n_Pickler_OpcodeBoundary(PicklerObject *self)\n{\n    Py_ssize_t frame_len;\n\n    if (!self->framing || self->frame_start == -1) {\n        return 0;\n    }\n    frame_len = self->output_len - self->frame_start - FRAME_HEADER_SIZE;\n    if (frame_len >= FRAME_SIZE_TARGET) {\n        if(_Pickler_CommitFrame(self)) {\n            return -1;\n        }\n        /* Flush the content of the committed frame to the underlying\n         * file and reuse the pickler buffer for the next frame so as\n         * to limit memory usage when dumping large complex objects to\n         * a file.\n         *\n         * self->write is NULL when called via dumps.\n         */\n        if (self->write != NULL) {\n            if (_Pickler_FlushToFile(self) < 0) {\n                return -1;\n            }\n            if (_Pickler_ClearBuffer(self) < 0) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\nstatic Py_ssize_t\n_Pickler_Write(PicklerObject *self, const char *s, Py_ssize_t data_len)\n{\n    Py_ssize_t i, n, required;\n    char *buffer;\n    int need_new_frame;\n\n    assert(s != NULL);\n    need_new_frame = (self->framing && self->frame_start == -1);\n\n    if (need_new_frame)\n        n = data_len + FRAME_HEADER_SIZE;\n    else\n        n = data_len;\n\n    required = self->output_len + n;\n    if (required > self->max_output_len) {\n        /* Make place in buffer for the pickle chunk */\n        if (self->output_len >= PY_SSIZE_T_MAX / 2 - n) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        self->max_output_len = (self->output_len + n) / 2 * 3;\n        if (_PyBytes_Resize(&self->output_buffer, self->max_output_len) < 0)\n            return -1;\n    }\n    buffer = PyBytes_AS_STRING(self->output_buffer);\n    if (need_new_frame) {\n        /* Setup new frame */\n        Py_ssize_t frame_start = self->output_len;\n        self->frame_start = frame_start;\n        for (i = 0; i < FRAME_HEADER_SIZE; i++) {\n            /* Write an invalid value, for debugging */\n            buffer[frame_start + i] = 0xFE;\n        }\n        self->output_len += FRAME_HEADER_SIZE;\n    }\n    if (data_len < 8) {\n        /* This is faster than memcpy when the string is short. */\n        for (i = 0; i < data_len; i++) {\n            buffer[self->output_len + i] = s[i];\n        }\n    }\n    else {\n        memcpy(buffer + self->output_len, s, data_len);\n    }\n    self->output_len += data_len;\n    return data_len;\n}\n\nstatic PicklerObject *\n_Pickler_New(void)\n{\n    PicklerObject *self;\n\n    self = PyObject_GC_New(PicklerObject, &Pickler_Type);\n    if (self == NULL)\n        return NULL;\n\n    self->pers_func = NULL;\n    self->dispatch_table = NULL;\n    self->write = NULL;\n    self->proto = 0;\n    self->bin = 0;\n    self->framing = 0;\n    self->frame_start = -1;\n    self->fast = 0;\n    self->fast_nesting = 0;\n    self->fix_imports = 0;\n    self->fast_memo = NULL;\n    self->max_output_len = WRITE_BUF_SIZE;\n    self->output_len = 0;\n\n    self->memo = PyMemoTable_New();\n    self->output_buffer = PyBytes_FromStringAndSize(NULL,\n                                                    self->max_output_len);\n\n    if (self->memo == NULL || self->output_buffer == NULL) {\n        Py_DECREF(self);\n        return NULL;\n    }\n    return self;\n}\n\nstatic int\n_Pickler_SetProtocol(PicklerObject *self, PyObject *protocol, int fix_imports)\n{\n    long proto;\n\n    if (protocol == NULL || protocol == Py_None) {\n        proto = DEFAULT_PROTOCOL;\n    }\n    else {\n        proto = PyLong_AsLong(protocol);\n        if (proto < 0) {\n            if (proto == -1 && PyErr_Occurred())\n                return -1;\n            proto = HIGHEST_PROTOCOL;\n        }\n        else if (proto > HIGHEST_PROTOCOL) {\n            PyErr_Format(PyExc_ValueError, \"pickle protocol must be <= %d\",\n                         HIGHEST_PROTOCOL);\n            return -1;\n        }\n    }\n    self->proto = (int)proto;\n    self->bin = proto > 0;\n    self->fix_imports = fix_imports && proto < 3;\n    return 0;\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success. This may\n   be called once on a freshly created Pickler. */\nstatic int\n_Pickler_SetOutputStream(PicklerObject *self, PyObject *file)\n{\n    _Py_IDENTIFIER(write);\n    assert(file != NULL);\n    if (_PyObject_LookupAttrId(file, &PyId_write, &self->write) < 0) {\n        return -1;\n    }\n    if (self->write == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"file must have a 'write' attribute\");\n        return -1;\n    }\n\n    return 0;\n}\n\n/* Returns the size of the input on success, -1 on failure. This takes its\n   own reference to `input`. */\nstatic Py_ssize_t\n_Unpickler_SetStringInput(UnpicklerObject *self, PyObject *input)\n{\n    if (self->buffer.buf != NULL)\n        PyBuffer_Release(&self->buffer);\n    if (PyObject_GetBuffer(input, &self->buffer, PyBUF_CONTIG_RO) < 0)\n        return -1;\n    self->input_buffer = self->buffer.buf;\n    self->input_len = self->buffer.len;\n    self->next_read_idx = 0;\n    self->prefetched_idx = self->input_len;\n    return self->input_len;\n}\n\nstatic int\nbad_readline(void)\n{\n    PickleState *st = _Pickle_GetGlobalState();\n    PyErr_SetString(st->UnpicklingError, \"pickle data was truncated\");\n    return -1;\n}\n\nstatic int\n_Unpickler_SkipConsumed(UnpicklerObject *self)\n{\n    Py_ssize_t consumed;\n    PyObject *r;\n\n    consumed = self->next_read_idx - self->prefetched_idx;\n    if (consumed <= 0)\n        return 0;\n\n    assert(self->peek);  /* otherwise we did something wrong */\n    /* This makes a useless copy... */\n    r = PyObject_CallFunction(self->read, \"n\", consumed);\n    if (r == NULL)\n        return -1;\n    Py_DECREF(r);\n\n    self->prefetched_idx = self->next_read_idx;\n    return 0;\n}\n\nstatic const Py_ssize_t READ_WHOLE_LINE = -1;\n\n/* If reading from a file, we need to only pull the bytes we need, since there\n   may be multiple pickle objects arranged contiguously in the same input\n   buffer.\n\n   If `n` is READ_WHOLE_LINE, read a whole line. Otherwise, read up to `n`\n   bytes from the input stream/buffer.\n\n   Update the unpickler's input buffer with the newly-read data. Returns -1 on\n   failure; on success, returns the number of bytes read from the file.\n\n   On success, self->input_len will be 0; this is intentional so that when\n   unpickling from a file, the \"we've run out of data\" code paths will trigger,\n   causing the Unpickler to go back to the file for more data. Use the returned\n   size to tell you how much data you can process. */\nstatic Py_ssize_t\n_Unpickler_ReadFromFile(UnpicklerObject *self, Py_ssize_t n)\n{\n    PyObject *data;\n    Py_ssize_t read_size;\n\n    assert(self->read != NULL);\n\n    if (_Unpickler_SkipConsumed(self) < 0)\n        return -1;\n\n    if (n == READ_WHOLE_LINE) {\n        data = _PyObject_CallNoArg(self->readline);\n    }\n    else {\n        PyObject *len;\n        /* Prefetch some data without advancing the file pointer, if possible */\n        if (self->peek && n < PREFETCH) {\n            len = PyLong_FromSsize_t(PREFETCH);\n            if (len == NULL)\n                return -1;\n            data = _Pickle_FastCall(self->peek, len);\n            if (data == NULL) {\n                if (!PyErr_ExceptionMatches(PyExc_NotImplementedError))\n                    return -1;\n                /* peek() is probably not supported by the given file object */\n                PyErr_Clear();\n                Py_CLEAR(self->peek);\n            }\n            else {\n                read_size = _Unpickler_SetStringInput(self, data);\n                Py_DECREF(data);\n                self->prefetched_idx = 0;\n                if (n <= read_size)\n                    return n;\n            }\n        }\n        len = PyLong_FromSsize_t(n);\n        if (len == NULL)\n            return -1;\n        data = _Pickle_FastCall(self->read, len);\n    }\n    if (data == NULL)\n        return -1;\n\n    read_size = _Unpickler_SetStringInput(self, data);\n    Py_DECREF(data);\n    return read_size;\n}\n\n/* Don't call it directly: use _Unpickler_Read() */\nstatic Py_ssize_t\n_Unpickler_ReadImpl(UnpicklerObject *self, char **s, Py_ssize_t n)\n{\n    Py_ssize_t num_read;\n\n    *s = NULL;\n    if (self->next_read_idx > PY_SSIZE_T_MAX - n) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError,\n                        \"read would overflow (invalid bytecode)\");\n        return -1;\n    }\n\n    /* This case is handled by the _Unpickler_Read() macro for efficiency */\n    assert(self->next_read_idx + n > self->input_len);\n\n    if (!self->read)\n        return bad_readline();\n\n    num_read = _Unpickler_ReadFromFile(self, n);\n    if (num_read < 0)\n        return -1;\n    if (num_read < n)\n        return bad_readline();\n    *s = self->input_buffer;\n    self->next_read_idx = n;\n    return n;\n}\n\n/* Read `n` bytes from the unpickler's data source, storing the result in `*s`.\n\n   This should be used for all data reads, rather than accessing the unpickler's\n   input buffer directly. This method deals correctly with reading from input\n   streams, which the input buffer doesn't deal with.\n\n   Note that when reading from a file-like object, self->next_read_idx won't\n   be updated (it should remain at 0 for the entire unpickling process). You\n   should use this function's return value to know how many bytes you can\n   consume.\n\n   Returns -1 (with an exception set) on failure. On success, return the\n   number of chars read. */\n#define _Unpickler_Read(self, s, n) \\\n    (((n) <= (self)->input_len - (self)->next_read_idx)      \\\n     ? (*(s) = (self)->input_buffer + (self)->next_read_idx, \\\n        (self)->next_read_idx += (n),                        \\\n        (n))                                                 \\\n     : _Unpickler_ReadImpl(self, (s), (n)))\n\nstatic Py_ssize_t\n_Unpickler_CopyLine(UnpicklerObject *self, char *line, Py_ssize_t len,\n                    char **result)\n{\n    char *input_line = PyMem_Realloc(self->input_line, len + 1);\n    if (input_line == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n\n    memcpy(input_line, line, len);\n    input_line[len] = '\\0';\n    self->input_line = input_line;\n    *result = self->input_line;\n    return len;\n}\n\n/* Read a line from the input stream/buffer. If we run off the end of the input\n   before hitting \\n, raise an error.\n\n   Returns the number of chars read, or -1 on failure. */\nstatic Py_ssize_t\n_Unpickler_Readline(UnpicklerObject *self, char **result)\n{\n    Py_ssize_t i, num_read;\n\n    for (i = self->next_read_idx; i < self->input_len; i++) {\n        if (self->input_buffer[i] == '\\n') {\n            char *line_start = self->input_buffer + self->next_read_idx;\n            num_read = i - self->next_read_idx + 1;\n            self->next_read_idx = i + 1;\n            return _Unpickler_CopyLine(self, line_start, num_read, result);\n        }\n    }\n    if (!self->read)\n        return bad_readline();\n\n    num_read = _Unpickler_ReadFromFile(self, READ_WHOLE_LINE);\n    if (num_read < 0)\n        return -1;\n    if (num_read == 0 || self->input_buffer[num_read - 1] != '\\n')\n        return bad_readline();\n    self->next_read_idx = num_read;\n    return _Unpickler_CopyLine(self, self->input_buffer, num_read, result);\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success. The memo array\n   will be modified in place. */\nstatic int\n_Unpickler_ResizeMemoList(UnpicklerObject *self, size_t new_size)\n{\n    size_t i;\n\n    assert(new_size > self->memo_size);\n\n    PyObject **memo_new = self->memo;\n    PyMem_RESIZE(memo_new, PyObject *, new_size);\n    if (memo_new == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    self->memo = memo_new;\n    for (i = self->memo_size; i < new_size; i++)\n        self->memo[i] = NULL;\n    self->memo_size = new_size;\n    return 0;\n}\n\n/* Returns NULL if idx is out of bounds. */\nstatic PyObject *\n_Unpickler_MemoGet(UnpicklerObject *self, size_t idx)\n{\n    if (idx >= self->memo_size)\n        return NULL;\n\n    return self->memo[idx];\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success.\n   This takes its own reference to `value`. */\nstatic int\n_Unpickler_MemoPut(UnpicklerObject *self, size_t idx, PyObject *value)\n{\n    PyObject *old_item;\n\n    if (idx >= self->memo_size) {\n        if (_Unpickler_ResizeMemoList(self, idx * 2) < 0)\n            return -1;\n        assert(idx < self->memo_size);\n    }\n    Py_INCREF(value);\n    old_item = self->memo[idx];\n    self->memo[idx] = value;\n    if (old_item != NULL) {\n        Py_DECREF(old_item);\n    }\n    else {\n        self->memo_len++;\n    }\n    return 0;\n}\n\nstatic PyObject **\n_Unpickler_NewMemo(Py_ssize_t new_size)\n{\n    PyObject **memo = PyMem_NEW(PyObject *, new_size);\n    if (memo == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset(memo, 0, new_size * sizeof(PyObject *));\n    return memo;\n}\n\n/* Free the unpickler's memo, taking care to decref any items left in it. */\nstatic void\n_Unpickler_MemoCleanup(UnpicklerObject *self)\n{\n    Py_ssize_t i;\n    PyObject **memo = self->memo;\n\n    if (self->memo == NULL)\n        return;\n    self->memo = NULL;\n    i = self->memo_size;\n    while (--i >= 0) {\n        Py_XDECREF(memo[i]);\n    }\n    PyMem_FREE(memo);\n}\n\nstatic UnpicklerObject *\n_Unpickler_New(void)\n{\n    UnpicklerObject *self;\n\n    self = PyObject_GC_New(UnpicklerObject, &Unpickler_Type);\n    if (self == NULL)\n        return NULL;\n\n    self->pers_func = NULL;\n    self->input_buffer = NULL;\n    self->input_line = NULL;\n    self->input_len = 0;\n    self->next_read_idx = 0;\n    self->prefetched_idx = 0;\n    self->read = NULL;\n    self->readline = NULL;\n    self->peek = NULL;\n    self->encoding = NULL;\n    self->errors = NULL;\n    self->marks = NULL;\n    self->num_marks = 0;\n    self->marks_size = 0;\n    self->proto = 0;\n    self->fix_imports = 0;\n    memset(&self->buffer, 0, sizeof(Py_buffer));\n    self->memo_size = 32;\n    self->memo_len = 0;\n    self->memo = _Unpickler_NewMemo(self->memo_size);\n    self->stack = (Pdata *)Pdata_New();\n\n    if (self->memo == NULL || self->stack == NULL) {\n        Py_DECREF(self);\n        return NULL;\n    }\n\n    return self;\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success. This may\n   be called once on a freshly created Pickler. */\nstatic int\n_Unpickler_SetInputStream(UnpicklerObject *self, PyObject *file)\n{\n    _Py_IDENTIFIER(peek);\n    _Py_IDENTIFIER(read);\n    _Py_IDENTIFIER(readline);\n\n    if (_PyObject_LookupAttrId(file, &PyId_peek, &self->peek) < 0) {\n        return -1;\n    }\n    (void)_PyObject_LookupAttrId(file, &PyId_read, &self->read);\n    (void)_PyObject_LookupAttrId(file, &PyId_readline, &self->readline);\n    if (self->readline == NULL || self->read == NULL) {\n        if (!PyErr_Occurred()) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"file must have 'read' and 'readline' attributes\");\n        }\n        Py_CLEAR(self->read);\n        Py_CLEAR(self->readline);\n        Py_CLEAR(self->peek);\n        return -1;\n    }\n    return 0;\n}\n\n/* Returns -1 (with an exception set) on failure, 0 on success. This may\n   be called once on a freshly created Pickler. */\nstatic int\n_Unpickler_SetInputEncoding(UnpicklerObject *self,\n                            const char *encoding,\n                            const char *errors)\n{\n    if (encoding == NULL)\n        encoding = \"ASCII\";\n    if (errors == NULL)\n        errors = \"strict\";\n\n    self->encoding = _PyMem_Strdup(encoding);\n    self->errors = _PyMem_Strdup(errors);\n    if (self->encoding == NULL || self->errors == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    return 0;\n}\n\n/* Generate a GET opcode for an object stored in the memo. */\nstatic int\nmemo_get(PicklerObject *self, PyObject *key)\n{\n    Py_ssize_t *value;\n    char pdata[30];\n    Py_ssize_t len;\n\n    value = PyMemoTable_Get(self->memo, key);\n    if (value == NULL)  {\n        PyErr_SetObject(PyExc_KeyError, key);\n        return -1;\n    }\n\n    if (!self->bin) {\n        pdata[0] = GET;\n        PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,\n                      \"%\" PY_FORMAT_SIZE_T \"d\\n\", *value);\n        len = strlen(pdata);\n    }\n    else {\n        if (*value < 256) {\n            pdata[0] = BINGET;\n            pdata[1] = (unsigned char)(*value & 0xff);\n            len = 2;\n        }\n        else if ((size_t)*value <= 0xffffffffUL) {\n            pdata[0] = LONG_BINGET;\n            pdata[1] = (unsigned char)(*value & 0xff);\n            pdata[2] = (unsigned char)((*value >> 8) & 0xff);\n            pdata[3] = (unsigned char)((*value >> 16) & 0xff);\n            pdata[4] = (unsigned char)((*value >> 24) & 0xff);\n            len = 5;\n        }\n        else { /* unlikely */\n            PickleState *st = _Pickle_GetGlobalState();\n            PyErr_SetString(st->PicklingError,\n                            \"memo id too large for LONG_BINGET\");\n            return -1;\n        }\n    }\n\n    if (_Pickler_Write(self, pdata, len) < 0)\n        return -1;\n\n    return 0;\n}\n\n/* Store an object in the memo, assign it a new unique ID based on the number\n   of objects currently stored in the memo and generate a PUT opcode. */\nstatic int\nmemo_put(PicklerObject *self, PyObject *obj)\n{\n    char pdata[30];\n    Py_ssize_t len;\n    Py_ssize_t idx;\n\n    const char memoize_op = MEMOIZE;\n\n    if (self->fast)\n        return 0;\n\n    idx = PyMemoTable_Size(self->memo);\n    if (PyMemoTable_Set(self->memo, obj, idx) < 0)\n        return -1;\n\n    if (self->proto >= 4) {\n        if (_Pickler_Write(self, &memoize_op, 1) < 0)\n            return -1;\n        return 0;\n    }\n    else if (!self->bin) {\n        pdata[0] = PUT;\n        PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,\n                      \"%\" PY_FORMAT_SIZE_T \"d\\n\", idx);\n        len = strlen(pdata);\n    }\n    else {\n        if (idx < 256) {\n            pdata[0] = BINPUT;\n            pdata[1] = (unsigned char)idx;\n            len = 2;\n        }\n        else if ((size_t)idx <= 0xffffffffUL) {\n            pdata[0] = LONG_BINPUT;\n            pdata[1] = (unsigned char)(idx & 0xff);\n            pdata[2] = (unsigned char)((idx >> 8) & 0xff);\n            pdata[3] = (unsigned char)((idx >> 16) & 0xff);\n            pdata[4] = (unsigned char)((idx >> 24) & 0xff);\n            len = 5;\n        }\n        else { /* unlikely */\n            PickleState *st = _Pickle_GetGlobalState();\n            PyErr_SetString(st->PicklingError,\n                            \"memo id too large for LONG_BINPUT\");\n            return -1;\n        }\n    }\n    if (_Pickler_Write(self, pdata, len) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic PyObject *\nget_dotted_path(PyObject *obj, PyObject *name)\n{\n    _Py_static_string(PyId_dot, \".\");\n    PyObject *dotted_path;\n    Py_ssize_t i, n;\n\n    dotted_path = PyUnicode_Split(name, _PyUnicode_FromId(&PyId_dot), -1);\n    if (dotted_path == NULL)\n        return NULL;\n    n = PyList_GET_SIZE(dotted_path);\n    assert(n >= 1);\n    for (i = 0; i < n; i++) {\n        PyObject *subpath = PyList_GET_ITEM(dotted_path, i);\n        if (_PyUnicode_EqualToASCIIString(subpath, \"<locals>\")) {\n            if (obj == NULL)\n                PyErr_Format(PyExc_AttributeError,\n                             \"Can't pickle local object %R\", name);\n            else\n                PyErr_Format(PyExc_AttributeError,\n                             \"Can't pickle local attribute %R on %R\", name, obj);\n            Py_DECREF(dotted_path);\n            return NULL;\n        }\n    }\n    return dotted_path;\n}\n\nstatic PyObject *\nget_deep_attribute(PyObject *obj, PyObject *names, PyObject **pparent)\n{\n    Py_ssize_t i, n;\n    PyObject *parent = NULL;\n\n    assert(PyList_CheckExact(names));\n    Py_INCREF(obj);\n    n = PyList_GET_SIZE(names);\n    for (i = 0; i < n; i++) {\n        PyObject *name = PyList_GET_ITEM(names, i);\n        Py_XDECREF(parent);\n        parent = obj;\n        (void)_PyObject_LookupAttr(parent, name, &obj);\n        if (obj == NULL) {\n            Py_DECREF(parent);\n            return NULL;\n        }\n    }\n    if (pparent != NULL)\n        *pparent = parent;\n    else\n        Py_XDECREF(parent);\n    return obj;\n}\n\n\nstatic PyObject *\ngetattribute(PyObject *obj, PyObject *name, int allow_qualname)\n{\n    PyObject *dotted_path, *attr;\n\n    if (allow_qualname) {\n        dotted_path = get_dotted_path(obj, name);\n        if (dotted_path == NULL)\n            return NULL;\n        attr = get_deep_attribute(obj, dotted_path, NULL);\n        Py_DECREF(dotted_path);\n    }\n    else {\n        (void)_PyObject_LookupAttr(obj, name, &attr);\n    }\n    if (attr == NULL && !PyErr_Occurred()) {\n        PyErr_Format(PyExc_AttributeError,\n                     \"Can't get attribute %R on %R\", name, obj);\n    }\n    return attr;\n}\n\nstatic int\n_checkmodule(PyObject *module_name, PyObject *module,\n             PyObject *global, PyObject *dotted_path)\n{\n    if (module == Py_None) {\n        return -1;\n    }\n    if (PyUnicode_Check(module_name) &&\n            _PyUnicode_EqualToASCIIString(module_name, \"__main__\")) {\n        return -1;\n    }\n\n    PyObject *candidate = get_deep_attribute(module, dotted_path, NULL);\n    if (candidate == NULL) {\n        return -1;\n    }\n    if (candidate != global) {\n        Py_DECREF(candidate);\n        return -1;\n    }\n    Py_DECREF(candidate);\n    return 0;\n}\n\nstatic PyObject *\nwhichmodule(PyObject *global, PyObject *dotted_path)\n{\n    PyObject *module_name;\n    PyObject *module = NULL;\n    Py_ssize_t i;\n    PyObject *modules;\n    _Py_IDENTIFIER(__module__);\n    _Py_IDENTIFIER(modules);\n    _Py_IDENTIFIER(__main__);\n\n    if (_PyObject_LookupAttrId(global, &PyId___module__, &module_name) < 0) {\n        return NULL;\n    }\n    if (module_name) {\n        /* In some rare cases (e.g., bound methods of extension types),\n           __module__ can be None. If it is so, then search sys.modules for\n           the module of global. */\n        if (module_name != Py_None)\n            return module_name;\n        Py_CLEAR(module_name);\n    }\n    assert(module_name == NULL);\n\n    /* Fallback on walking sys.modules */\n    modules = _PySys_GetObjectId(&PyId_modules);\n    if (modules == NULL) {\n        PyErr_SetString(PyExc_RuntimeError, \"unable to get sys.modules\");\n        return NULL;\n    }\n    if (PyDict_CheckExact(modules)) {\n        i = 0;\n        while (PyDict_Next(modules, &i, &module_name, &module)) {\n            if (_checkmodule(module_name, module, global, dotted_path) == 0) {\n                Py_INCREF(module_name);\n                return module_name;\n            }\n            if (PyErr_Occurred()) {\n                return NULL;\n            }\n        }\n    }\n    else {\n        PyObject *iterator = PyObject_GetIter(modules);\n        if (iterator == NULL) {\n            return NULL;\n        }\n        while ((module_name = PyIter_Next(iterator))) {\n            module = PyObject_GetItem(modules, module_name);\n            if (module == NULL) {\n                Py_DECREF(module_name);\n                Py_DECREF(iterator);\n                return NULL;\n            }\n            if (_checkmodule(module_name, module, global, dotted_path) == 0) {\n                Py_DECREF(module);\n                Py_DECREF(iterator);\n                return module_name;\n            }\n            Py_DECREF(module);\n            Py_DECREF(module_name);\n            if (PyErr_Occurred()) {\n                Py_DECREF(iterator);\n                return NULL;\n            }\n        }\n        Py_DECREF(iterator);\n    }\n\n    /* If no module is found, use __main__. */\n    module_name = _PyUnicode_FromId(&PyId___main__);\n    Py_XINCREF(module_name);\n    return module_name;\n}\n\n/* fast_save_enter() and fast_save_leave() are guards against recursive\n   objects when Pickler is used with the \"fast mode\" (i.e., with object\n   memoization disabled). If the nesting of a list or dict object exceed\n   FAST_NESTING_LIMIT, these guards will start keeping an internal\n   reference to the seen list or dict objects and check whether these objects\n   are recursive. These are not strictly necessary, since save() has a\n   hard-coded recursion limit, but they give a nicer error message than the\n   typical RuntimeError. */\nstatic int\nfast_save_enter(PicklerObject *self, PyObject *obj)\n{\n    /* if fast_nesting < 0, we're doing an error exit. */\n    if (++self->fast_nesting >= FAST_NESTING_LIMIT) {\n        PyObject *key = NULL;\n        if (self->fast_memo == NULL) {\n            self->fast_memo = PyDict_New();\n            if (self->fast_memo == NULL) {\n                self->fast_nesting = -1;\n                return 0;\n            }\n        }\n        key = PyLong_FromVoidPtr(obj);\n        if (key == NULL) {\n            self->fast_nesting = -1;\n            return 0;\n        }\n        if (PyDict_GetItemWithError(self->fast_memo, key)) {\n            Py_DECREF(key);\n            PyErr_Format(PyExc_ValueError,\n                         \"fast mode: can't pickle cyclic objects \"\n                         \"including object type %.200s at %p\",\n                         obj->ob_type->tp_name, obj);\n            self->fast_nesting = -1;\n            return 0;\n        }\n        if (PyErr_Occurred()) {\n            Py_DECREF(key);\n            self->fast_nesting = -1;\n            return 0;\n        }\n        if (PyDict_SetItem(self->fast_memo, key, Py_None) < 0) {\n            Py_DECREF(key);\n            self->fast_nesting = -1;\n            return 0;\n        }\n        Py_DECREF(key);\n    }\n    return 1;\n}\n\nstatic int\nfast_save_leave(PicklerObject *self, PyObject *obj)\n{\n    if (self->fast_nesting-- >= FAST_NESTING_LIMIT) {\n        PyObject *key = PyLong_FromVoidPtr(obj);\n        if (key == NULL)\n            return 0;\n        if (PyDict_DelItem(self->fast_memo, key) < 0) {\n            Py_DECREF(key);\n            return 0;\n        }\n        Py_DECREF(key);\n    }\n    return 1;\n}\n\nstatic int\nsave_none(PicklerObject *self, PyObject *obj)\n{\n    const char none_op = NONE;\n    if (_Pickler_Write(self, &none_op, 1) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic int\nsave_bool(PicklerObject *self, PyObject *obj)\n{\n    if (self->proto >= 2) {\n        const char bool_op = (obj == Py_True) ? NEWTRUE : NEWFALSE;\n        if (_Pickler_Write(self, &bool_op, 1) < 0)\n            return -1;\n    }\n    else {\n        /* These aren't opcodes -- they're ways to pickle bools before protocol 2\n         * so that unpicklers written before bools were introduced unpickle them\n         * as ints, but unpicklers after can recognize that bools were intended.\n         * Note that protocol 2 added direct ways to pickle bools.\n         */\n        const char *bool_str = (obj == Py_True) ? \"I01\\n\" : \"I00\\n\";\n        if (_Pickler_Write(self, bool_str, strlen(bool_str)) < 0)\n            return -1;\n    }\n    return 0;\n}\n\nstatic int\nsave_long(PicklerObject *self, PyObject *obj)\n{\n    PyObject *repr = NULL;\n    Py_ssize_t size;\n    long val;\n    int overflow;\n    int status = 0;\n\n    val= PyLong_AsLongAndOverflow(obj, &overflow);\n    if (!overflow && (sizeof(long) <= 4 ||\n            (val <= 0x7fffffffL && val >= (-0x7fffffffL - 1))))\n    {\n        /* result fits in a signed 4-byte integer.\n\n           Note: we can't use -0x80000000L in the above condition because some\n           compilers (e.g., MSVC) will promote 0x80000000L to an unsigned type\n           before applying the unary minus when sizeof(long) <= 4. The\n           resulting value stays unsigned which is commonly not what we want,\n           so MSVC happily warns us about it.  However, that result would have\n           been fine because we guard for sizeof(long) <= 4 which turns the\n           condition true in that particular case. */\n        char pdata[32];\n        Py_ssize_t len = 0;\n\n        if (self->bin) {\n            pdata[1] = (unsigned char)(val & 0xff);\n            pdata[2] = (unsigned char)((val >> 8) & 0xff);\n            pdata[3] = (unsigned char)((val >> 16) & 0xff);\n            pdata[4] = (unsigned char)((val >> 24) & 0xff);\n\n            if ((pdata[4] != 0) || (pdata[3] != 0)) {\n                pdata[0] = BININT;\n                len = 5;\n            }\n            else if (pdata[2] != 0) {\n                pdata[0] = BININT2;\n                len = 3;\n            }\n            else {\n                pdata[0] = BININT1;\n                len = 2;\n            }\n        }\n        else {\n            sprintf(pdata, \"%c%ld\\n\", INT,  val);\n            len = strlen(pdata);\n        }\n        if (_Pickler_Write(self, pdata, len) < 0)\n            return -1;\n\n        return 0;\n    }\n    assert(!PyErr_Occurred());\n\n    if (self->proto >= 2) {\n        /* Linear-time pickling. */\n        size_t nbits;\n        size_t nbytes;\n        unsigned char *pdata;\n        char header[5];\n        int i;\n        int sign = _PyLong_Sign(obj);\n\n        if (sign == 0) {\n            header[0] = LONG1;\n            header[1] = 0;      /* It's 0 -- an empty bytestring. */\n            if (_Pickler_Write(self, header, 2) < 0)\n                goto error;\n            return 0;\n        }\n        nbits = _PyLong_NumBits(obj);\n        if (nbits == (size_t)-1 && PyErr_Occurred())\n            goto error;\n        /* How many bytes do we need?  There are nbits >> 3 full\n         * bytes of data, and nbits & 7 leftover bits.  If there\n         * are any leftover bits, then we clearly need another\n         * byte.  Wnat's not so obvious is that we *probably*\n         * need another byte even if there aren't any leftovers:\n         * the most-significant bit of the most-significant byte\n         * acts like a sign bit, and it's usually got a sense\n         * opposite of the one we need.  The exception is ints\n         * of the form -(2**(8*j-1)) for j > 0.  Such an int is\n         * its own 256's-complement, so has the right sign bit\n         * even without the extra byte.  That's a pain to check\n         * for in advance, though, so we always grab an extra\n         * byte at the start, and cut it back later if possible.\n         */\n        nbytes = (nbits >> 3) + 1;\n        if (nbytes > 0x7fffffffL) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"int too large to pickle\");\n            goto error;\n        }\n        repr = PyBytes_FromStringAndSize(NULL, (Py_ssize_t)nbytes);\n        if (repr == NULL)\n            goto error;\n        pdata = (unsigned char *)PyBytes_AS_STRING(repr);\n        i = _PyLong_AsByteArray((PyLongObject *)obj,\n                                pdata, nbytes,\n                                1 /* little endian */ , 1 /* signed */ );\n        if (i < 0)\n            goto error;\n        /* If the int is negative, this may be a byte more than\n         * needed.  This is so iff the MSB is all redundant sign\n         * bits.\n         */\n        if (sign < 0 &&\n            nbytes > 1 &&\n            pdata[nbytes - 1] == 0xff &&\n            (pdata[nbytes - 2] & 0x80) != 0) {\n            nbytes--;\n        }\n\n        if (nbytes < 256) {\n            header[0] = LONG1;\n            header[1] = (unsigned char)nbytes;\n            size = 2;\n        }\n        else {\n            header[0] = LONG4;\n            size = (Py_ssize_t) nbytes;\n            for (i = 1; i < 5; i++) {\n                header[i] = (unsigned char)(size & 0xff);\n                size >>= 8;\n            }\n            size = 5;\n        }\n        if (_Pickler_Write(self, header, size) < 0 ||\n            _Pickler_Write(self, (char *)pdata, (int)nbytes) < 0)\n            goto error;\n    }\n    else {\n        const char long_op = LONG;\n        const char *string;\n\n        /* proto < 2: write the repr and newline.  This is quadratic-time (in\n           the number of digits), in both directions.  We add a trailing 'L'\n           to the repr, for compatibility with Python 2.x. */\n\n        repr = PyObject_Repr(obj);\n        if (repr == NULL)\n            goto error;\n\n        string = PyUnicode_AsUTF8AndSize(repr, &size);\n        if (string == NULL)\n            goto error;\n\n        if (_Pickler_Write(self, &long_op, 1) < 0 ||\n            _Pickler_Write(self, string, size) < 0 ||\n            _Pickler_Write(self, \"L\\n\", 2) < 0)\n            goto error;\n    }\n\n    if (0) {\n  error:\n      status = -1;\n    }\n    Py_XDECREF(repr);\n\n    return status;\n}\n\nstatic int\nsave_float(PicklerObject *self, PyObject *obj)\n{\n    double x = PyFloat_AS_DOUBLE((PyFloatObject *)obj);\n\n    if (self->bin) {\n        char pdata[9];\n        pdata[0] = BINFLOAT;\n        if (_PyFloat_Pack8(x, (unsigned char *)&pdata[1], 0) < 0)\n            return -1;\n        if (_Pickler_Write(self, pdata, 9) < 0)\n            return -1;\n   }\n    else {\n        int result = -1;\n        char *buf = NULL;\n        char op = FLOAT;\n\n        if (_Pickler_Write(self, &op, 1) < 0)\n            goto done;\n\n        buf = PyOS_double_to_string(x, 'r', 0, Py_DTSF_ADD_DOT_0, NULL);\n        if (!buf) {\n            PyErr_NoMemory();\n            goto done;\n        }\n\n        if (_Pickler_Write(self, buf, strlen(buf)) < 0)\n            goto done;\n\n        if (_Pickler_Write(self, \"\\n\", 1) < 0)\n            goto done;\n\n        result = 0;\ndone:\n        PyMem_Free(buf);\n        return result;\n    }\n\n    return 0;\n}\n\n/* Perform direct write of the header and payload of the binary object.\n\n   The large contiguous data is written directly into the underlying file\n   object, bypassing the output_buffer of the Pickler.  We intentionally\n   do not insert a protocol 4 frame opcode to make it possible to optimize\n   file.read calls in the loader.\n */\nstatic int\n_Pickler_write_bytes(PicklerObject *self,\n                     const char *header, Py_ssize_t header_size,\n                     const char *data, Py_ssize_t data_size,\n                     PyObject *payload)\n{\n    int bypass_buffer = (data_size >= FRAME_SIZE_TARGET);\n    int framing = self->framing;\n\n    if (bypass_buffer) {\n        assert(self->output_buffer != NULL);\n        /* Commit the previous frame. */\n        if (_Pickler_CommitFrame(self)) {\n            return -1;\n        }\n        /* Disable framing temporarily */\n        self->framing = 0;\n    }\n\n    if (_Pickler_Write(self, header, header_size) < 0) {\n        return -1;\n    }\n\n    if (bypass_buffer && self->write != NULL) {\n        /* Bypass the in-memory buffer to directly stream large data\n           into the underlying file object. */\n        PyObject *result, *mem = NULL;\n        /* Dump the output buffer to the file. */\n        if (_Pickler_FlushToFile(self) < 0) {\n            return -1;\n        }\n\n        /* Stream write the payload into the file without going through the\n           output buffer. */\n        if (payload == NULL) {\n            /* TODO: It would be better to use a memoryview with a linked\n               original string if this is possible. */\n            payload = mem = PyBytes_FromStringAndSize(data, data_size);\n            if (payload == NULL) {\n                return -1;\n            }\n        }\n        result = PyObject_CallFunctionObjArgs(self->write, payload, NULL);\n        Py_XDECREF(mem);\n        if (result == NULL) {\n            return -1;\n        }\n        Py_DECREF(result);\n\n        /* Reinitialize the buffer for subsequent calls to _Pickler_Write. */\n        if (_Pickler_ClearBuffer(self) < 0) {\n            return -1;\n        }\n    }\n    else {\n        if (_Pickler_Write(self, data, data_size) < 0) {\n            return -1;\n        }\n    }\n\n    /* Re-enable framing for subsequent calls to _Pickler_Write. */\n    self->framing = framing;\n\n    return 0;\n}\n\nstatic int\nsave_bytes(PicklerObject *self, PyObject *obj)\n{\n    if (self->proto < 3) {\n        /* Older pickle protocols do not have an opcode for pickling bytes\n           objects. Therefore, we need to fake the copy protocol (i.e.,\n           the __reduce__ method) to permit bytes object unpickling.\n\n           Here we use a hack to be compatible with Python 2. Since in Python\n           2 'bytes' is just an alias for 'str' (which has different\n           parameters than the actual bytes object), we use codecs.encode\n           to create the appropriate 'str' object when unpickled using\n           Python 2 *and* the appropriate 'bytes' object when unpickled\n           using Python 3. Again this is a hack and we don't need to do this\n           with newer protocols. */\n        PyObject *reduce_value = NULL;\n        int status;\n\n        if (PyBytes_GET_SIZE(obj) == 0) {\n            reduce_value = Py_BuildValue(\"(O())\", (PyObject*)&PyBytes_Type);\n        }\n        else {\n            PickleState *st = _Pickle_GetGlobalState();\n            PyObject *unicode_str =\n                PyUnicode_DecodeLatin1(PyBytes_AS_STRING(obj),\n                                       PyBytes_GET_SIZE(obj),\n                                       \"strict\");\n            _Py_IDENTIFIER(latin1);\n\n            if (unicode_str == NULL)\n                return -1;\n            reduce_value = Py_BuildValue(\"(O(OO))\",\n                                         st->codecs_encode, unicode_str,\n                                         _PyUnicode_FromId(&PyId_latin1));\n            Py_DECREF(unicode_str);\n        }\n\n        if (reduce_value == NULL)\n            return -1;\n\n        /* save_reduce() will memoize the object automatically. */\n        status = save_reduce(self, reduce_value, obj);\n        Py_DECREF(reduce_value);\n        return status;\n    }\n    else {\n        Py_ssize_t size;\n        char header[9];\n        Py_ssize_t len;\n\n        size = PyBytes_GET_SIZE(obj);\n        if (size < 0)\n            return -1;\n\n        if (size <= 0xff) {\n            header[0] = SHORT_BINBYTES;\n            header[1] = (unsigned char)size;\n            len = 2;\n        }\n        else if ((size_t)size <= 0xffffffffUL) {\n            header[0] = BINBYTES;\n            header[1] = (unsigned char)(size & 0xff);\n            header[2] = (unsigned char)((size >> 8) & 0xff);\n            header[3] = (unsigned char)((size >> 16) & 0xff);\n            header[4] = (unsigned char)((size >> 24) & 0xff);\n            len = 5;\n        }\n        else if (self->proto >= 4) {\n            header[0] = BINBYTES8;\n            _write_size64(header + 1, size);\n            len = 9;\n        }\n        else {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"cannot serialize a bytes object larger than 4 GiB\");\n            return -1;          /* string too large */\n        }\n\n        if (_Pickler_write_bytes(self, header, len,\n                                 PyBytes_AS_STRING(obj), size, obj) < 0)\n        {\n            return -1;\n        }\n\n        if (memo_put(self, obj) < 0)\n            return -1;\n\n        return 0;\n    }\n}\n\n/* A copy of PyUnicode_EncodeRawUnicodeEscape() that also translates\n   backslash and newline characters to \\uXXXX escapes. */\nstatic PyObject *\nraw_unicode_escape(PyObject *obj)\n{\n    char *p;\n    Py_ssize_t i, size;\n    void *data;\n    unsigned int kind;\n    _PyBytesWriter writer;\n\n    if (PyUnicode_READY(obj))\n        return NULL;\n\n    _PyBytesWriter_Init(&writer);\n\n    size = PyUnicode_GET_LENGTH(obj);\n    data = PyUnicode_DATA(obj);\n    kind = PyUnicode_KIND(obj);\n\n    p = _PyBytesWriter_Alloc(&writer, size);\n    if (p == NULL)\n        goto error;\n    writer.overallocate = 1;\n\n    for (i=0; i < size; i++) {\n        Py_UCS4 ch = PyUnicode_READ(kind, data, i);\n        /* Map 32-bit characters to '\\Uxxxxxxxx' */\n        if (ch >= 0x10000) {\n            /* -1: subtract 1 preallocated byte */\n            p = _PyBytesWriter_Prepare(&writer, p, 10-1);\n            if (p == NULL)\n                goto error;\n\n            *p++ = '\\\\';\n            *p++ = 'U';\n            *p++ = Py_hexdigits[(ch >> 28) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 24) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 20) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 16) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 12) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 8) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 4) & 0xf];\n            *p++ = Py_hexdigits[ch & 15];\n        }\n        /* Map 16-bit characters, '\\\\' and '\\n' to '\\uxxxx' */\n        else if (ch >= 256 || ch == '\\\\' || ch == '\\n') {\n            /* -1: subtract 1 preallocated byte */\n            p = _PyBytesWriter_Prepare(&writer, p, 6-1);\n            if (p == NULL)\n                goto error;\n\n            *p++ = '\\\\';\n            *p++ = 'u';\n            *p++ = Py_hexdigits[(ch >> 12) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 8) & 0xf];\n            *p++ = Py_hexdigits[(ch >> 4) & 0xf];\n            *p++ = Py_hexdigits[ch & 15];\n        }\n        /* Copy everything else as-is */\n        else\n            *p++ = (char) ch;\n    }\n\n    return _PyBytesWriter_Finish(&writer, p);\n\nerror:\n    _PyBytesWriter_Dealloc(&writer);\n    return NULL;\n}\n\nstatic int\nwrite_unicode_binary(PicklerObject *self, PyObject *obj)\n{\n    char header[9];\n    Py_ssize_t len;\n    PyObject *encoded = NULL;\n    Py_ssize_t size;\n    const char *data;\n\n    if (PyUnicode_READY(obj))\n        return -1;\n\n    data = PyUnicode_AsUTF8AndSize(obj, &size);\n    if (data == NULL) {\n        /* Issue #8383: for strings with lone surrogates, fallback on the\n           \"surrogatepass\" error handler. */\n        PyErr_Clear();\n        encoded = PyUnicode_AsEncodedString(obj, \"utf-8\", \"surrogatepass\");\n        if (encoded == NULL)\n            return -1;\n\n        data = PyBytes_AS_STRING(encoded);\n        size = PyBytes_GET_SIZE(encoded);\n    }\n\n    assert(size >= 0);\n    if (size <= 0xff && self->proto >= 4) {\n        header[0] = SHORT_BINUNICODE;\n        header[1] = (unsigned char)(size & 0xff);\n        len = 2;\n    }\n    else if ((size_t)size <= 0xffffffffUL) {\n        header[0] = BINUNICODE;\n        header[1] = (unsigned char)(size & 0xff);\n        header[2] = (unsigned char)((size >> 8) & 0xff);\n        header[3] = (unsigned char)((size >> 16) & 0xff);\n        header[4] = (unsigned char)((size >> 24) & 0xff);\n        len = 5;\n    }\n    else if (self->proto >= 4) {\n        header[0] = BINUNICODE8;\n        _write_size64(header + 1, size);\n        len = 9;\n    }\n    else {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"cannot serialize a string larger than 4GiB\");\n        Py_XDECREF(encoded);\n        return -1;\n    }\n\n    if (_Pickler_write_bytes(self, header, len, data, size, encoded) < 0) {\n        Py_XDECREF(encoded);\n        return -1;\n    }\n    Py_XDECREF(encoded);\n    return 0;\n}\n\nstatic int\nsave_unicode(PicklerObject *self, PyObject *obj)\n{\n    if (self->bin) {\n        if (write_unicode_binary(self, obj) < 0)\n            return -1;\n    }\n    else {\n        PyObject *encoded;\n        Py_ssize_t size;\n        const char unicode_op = UNICODE;\n\n        encoded = raw_unicode_escape(obj);\n        if (encoded == NULL)\n            return -1;\n\n        if (_Pickler_Write(self, &unicode_op, 1) < 0) {\n            Py_DECREF(encoded);\n            return -1;\n        }\n\n        size = PyBytes_GET_SIZE(encoded);\n        if (_Pickler_Write(self, PyBytes_AS_STRING(encoded), size) < 0) {\n            Py_DECREF(encoded);\n            return -1;\n        }\n        Py_DECREF(encoded);\n\n        if (_Pickler_Write(self, \"\\n\", 1) < 0)\n            return -1;\n    }\n    if (memo_put(self, obj) < 0)\n        return -1;\n\n    return 0;\n}\n\n/* A helper for save_tuple.  Push the len elements in tuple t on the stack. */\nstatic int\nstore_tuple_elements(PicklerObject *self, PyObject *t, Py_ssize_t len)\n{\n    Py_ssize_t i;\n\n    assert(PyTuple_Size(t) == len);\n\n    for (i = 0; i < len; i++) {\n        PyObject *element = PyTuple_GET_ITEM(t, i);\n\n        if (element == NULL)\n            return -1;\n        if (save(self, element, 0) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n/* Tuples are ubiquitous in the pickle protocols, so many techniques are\n * used across protocols to minimize the space needed to pickle them.\n * Tuples are also the only builtin immutable type that can be recursive\n * (a tuple can be reached from itself), and that requires some subtle\n * magic so that it works in all cases.  IOW, this is a long routine.\n */\nstatic int\nsave_tuple(PicklerObject *self, PyObject *obj)\n{\n    Py_ssize_t len, i;\n\n    const char mark_op = MARK;\n    const char tuple_op = TUPLE;\n    const char pop_op = POP;\n    const char pop_mark_op = POP_MARK;\n    const char len2opcode[] = {EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3};\n\n    if ((len = PyTuple_Size(obj)) < 0)\n        return -1;\n\n    if (len == 0) {\n        char pdata[2];\n\n        if (self->proto) {\n            pdata[0] = EMPTY_TUPLE;\n            len = 1;\n        }\n        else {\n            pdata[0] = MARK;\n            pdata[1] = TUPLE;\n            len = 2;\n        }\n        if (_Pickler_Write(self, pdata, len) < 0)\n            return -1;\n        return 0;\n    }\n\n    /* The tuple isn't in the memo now.  If it shows up there after\n     * saving the tuple elements, the tuple must be recursive, in\n     * which case we'll pop everything we put on the stack, and fetch\n     * its value from the memo.\n     */\n    if (len <= 3 && self->proto >= 2) {\n        /* Use TUPLE{1,2,3} opcodes. */\n        if (store_tuple_elements(self, obj, len) < 0)\n            return -1;\n\n        if (PyMemoTable_Get(self->memo, obj)) {\n            /* pop the len elements */\n            for (i = 0; i < len; i++)\n                if (_Pickler_Write(self, &pop_op, 1) < 0)\n                    return -1;\n            /* fetch from memo */\n            if (memo_get(self, obj) < 0)\n                return -1;\n\n            return 0;\n        }\n        else { /* Not recursive. */\n            if (_Pickler_Write(self, len2opcode + len, 1) < 0)\n                return -1;\n        }\n        goto memoize;\n    }\n\n    /* proto < 2 and len > 0, or proto >= 2 and len > 3.\n     * Generate MARK e1 e2 ... TUPLE\n     */\n    if (_Pickler_Write(self, &mark_op, 1) < 0)\n        return -1;\n\n    if (store_tuple_elements(self, obj, len) < 0)\n        return -1;\n\n    if (PyMemoTable_Get(self->memo, obj)) {\n        /* pop the stack stuff we pushed */\n        if (self->bin) {\n            if (_Pickler_Write(self, &pop_mark_op, 1) < 0)\n                return -1;\n        }\n        else {\n            /* Note that we pop one more than len, to remove\n             * the MARK too.\n             */\n            for (i = 0; i <= len; i++)\n                if (_Pickler_Write(self, &pop_op, 1) < 0)\n                    return -1;\n        }\n        /* fetch from memo */\n        if (memo_get(self, obj) < 0)\n            return -1;\n\n        return 0;\n    }\n    else { /* Not recursive. */\n        if (_Pickler_Write(self, &tuple_op, 1) < 0)\n            return -1;\n    }\n\n  memoize:\n    if (memo_put(self, obj) < 0)\n        return -1;\n\n    return 0;\n}\n\n/* iter is an iterator giving items, and we batch up chunks of\n *     MARK item item ... item APPENDS\n * opcode sequences.  Calling code should have arranged to first create an\n * empty list, or list-like object, for the APPENDS to operate on.\n * Returns 0 on success, <0 on error.\n */\nstatic int\nbatch_list(PicklerObject *self, PyObject *iter)\n{\n    PyObject *obj = NULL;\n    PyObject *firstitem = NULL;\n    int i, n;\n\n    const char mark_op = MARK;\n    const char append_op = APPEND;\n    const char appends_op = APPENDS;\n\n    assert(iter != NULL);\n\n    /* XXX: I think this function could be made faster by avoiding the\n       iterator interface and fetching objects directly from list using\n       PyList_GET_ITEM.\n    */\n\n    if (self->proto == 0) {\n        /* APPENDS isn't available; do one at a time. */\n        for (;;) {\n            obj = PyIter_Next(iter);\n            if (obj == NULL) {\n                if (PyErr_Occurred())\n                    return -1;\n                break;\n            }\n            i = save(self, obj, 0);\n            Py_DECREF(obj);\n            if (i < 0)\n                return -1;\n            if (_Pickler_Write(self, &append_op, 1) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    /* proto > 0:  write in batches of BATCHSIZE. */\n    do {\n        /* Get first item */\n        firstitem = PyIter_Next(iter);\n        if (firstitem == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n\n            /* nothing more to add */\n            break;\n        }\n\n        /* Try to get a second item */\n        obj = PyIter_Next(iter);\n        if (obj == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n\n            /* Only one item to write */\n            if (save(self, firstitem, 0) < 0)\n                goto error;\n            if (_Pickler_Write(self, &append_op, 1) < 0)\n                goto error;\n            Py_CLEAR(firstitem);\n            break;\n        }\n\n        /* More than one item to write */\n\n        /* Pump out MARK, items, APPENDS. */\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            goto error;\n\n        if (save(self, firstitem, 0) < 0)\n            goto error;\n        Py_CLEAR(firstitem);\n        n = 1;\n\n        /* Fetch and save up to BATCHSIZE items */\n        while (obj) {\n            if (save(self, obj, 0) < 0)\n                goto error;\n            Py_CLEAR(obj);\n            n += 1;\n\n            if (n == BATCHSIZE)\n                break;\n\n            obj = PyIter_Next(iter);\n            if (obj == NULL) {\n                if (PyErr_Occurred())\n                    goto error;\n                break;\n            }\n        }\n\n        if (_Pickler_Write(self, &appends_op, 1) < 0)\n            goto error;\n\n    } while (n == BATCHSIZE);\n    return 0;\n\n  error:\n    Py_XDECREF(firstitem);\n    Py_XDECREF(obj);\n    return -1;\n}\n\n/* This is a variant of batch_list() above, specialized for lists (with no\n * support for list subclasses). Like batch_list(), we batch up chunks of\n *     MARK item item ... item APPENDS\n * opcode sequences.  Calling code should have arranged to first create an\n * empty list, or list-like object, for the APPENDS to operate on.\n * Returns 0 on success, -1 on error.\n *\n * This version is considerably faster than batch_list(), if less general.\n *\n * Note that this only works for protocols > 0.\n */\nstatic int\nbatch_list_exact(PicklerObject *self, PyObject *obj)\n{\n    PyObject *item = NULL;\n    Py_ssize_t this_batch, total;\n\n    const char append_op = APPEND;\n    const char appends_op = APPENDS;\n    const char mark_op = MARK;\n\n    assert(obj != NULL);\n    assert(self->proto > 0);\n    assert(PyList_CheckExact(obj));\n\n    if (PyList_GET_SIZE(obj) == 1) {\n        item = PyList_GET_ITEM(obj, 0);\n        if (save(self, item, 0) < 0)\n            return -1;\n        if (_Pickler_Write(self, &append_op, 1) < 0)\n            return -1;\n        return 0;\n    }\n\n    /* Write in batches of BATCHSIZE. */\n    total = 0;\n    do {\n        this_batch = 0;\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            return -1;\n        while (total < PyList_GET_SIZE(obj)) {\n            item = PyList_GET_ITEM(obj, total);\n            if (save(self, item, 0) < 0)\n                return -1;\n            total++;\n            if (++this_batch == BATCHSIZE)\n                break;\n        }\n        if (_Pickler_Write(self, &appends_op, 1) < 0)\n            return -1;\n\n    } while (total < PyList_GET_SIZE(obj));\n\n    return 0;\n}\n\nstatic int\nsave_list(PicklerObject *self, PyObject *obj)\n{\n    char header[3];\n    Py_ssize_t len;\n    int status = 0;\n\n    if (self->fast && !fast_save_enter(self, obj))\n        goto error;\n\n    /* Create an empty list. */\n    if (self->bin) {\n        header[0] = EMPTY_LIST;\n        len = 1;\n    }\n    else {\n        header[0] = MARK;\n        header[1] = LIST;\n        len = 2;\n    }\n\n    if (_Pickler_Write(self, header, len) < 0)\n        goto error;\n\n    /* Get list length, and bow out early if empty. */\n    if ((len = PyList_Size(obj)) < 0)\n        goto error;\n\n    if (memo_put(self, obj) < 0)\n        goto error;\n\n    if (len != 0) {\n        /* Materialize the list elements. */\n        if (PyList_CheckExact(obj) && self->proto > 0) {\n            if (Py_EnterRecursiveCall(\" while pickling an object\"))\n                goto error;\n            status = batch_list_exact(self, obj);\n            Py_LeaveRecursiveCall();\n        } else {\n            PyObject *iter = PyObject_GetIter(obj);\n            if (iter == NULL)\n                goto error;\n\n            if (Py_EnterRecursiveCall(\" while pickling an object\")) {\n                Py_DECREF(iter);\n                goto error;\n            }\n            status = batch_list(self, iter);\n            Py_LeaveRecursiveCall();\n            Py_DECREF(iter);\n        }\n    }\n    if (0) {\n  error:\n        status = -1;\n    }\n\n    if (self->fast && !fast_save_leave(self, obj))\n        status = -1;\n\n    return status;\n}\n\n/* iter is an iterator giving (key, value) pairs, and we batch up chunks of\n *     MARK key value ... key value SETITEMS\n * opcode sequences.  Calling code should have arranged to first create an\n * empty dict, or dict-like object, for the SETITEMS to operate on.\n * Returns 0 on success, <0 on error.\n *\n * This is very much like batch_list().  The difference between saving\n * elements directly, and picking apart two-tuples, is so long-winded at\n * the C level, though, that attempts to combine these routines were too\n * ugly to bear.\n */\nstatic int\nbatch_dict(PicklerObject *self, PyObject *iter)\n{\n    PyObject *obj = NULL;\n    PyObject *firstitem = NULL;\n    int i, n;\n\n    const char mark_op = MARK;\n    const char setitem_op = SETITEM;\n    const char setitems_op = SETITEMS;\n\n    assert(iter != NULL);\n\n    if (self->proto == 0) {\n        /* SETITEMS isn't available; do one at a time. */\n        for (;;) {\n            obj = PyIter_Next(iter);\n            if (obj == NULL) {\n                if (PyErr_Occurred())\n                    return -1;\n                break;\n            }\n            if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 2) {\n                PyErr_SetString(PyExc_TypeError, \"dict items \"\n                                \"iterator must return 2-tuples\");\n                return -1;\n            }\n            i = save(self, PyTuple_GET_ITEM(obj, 0), 0);\n            if (i >= 0)\n                i = save(self, PyTuple_GET_ITEM(obj, 1), 0);\n            Py_DECREF(obj);\n            if (i < 0)\n                return -1;\n            if (_Pickler_Write(self, &setitem_op, 1) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    /* proto > 0:  write in batches of BATCHSIZE. */\n    do {\n        /* Get first item */\n        firstitem = PyIter_Next(iter);\n        if (firstitem == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n\n            /* nothing more to add */\n            break;\n        }\n        if (!PyTuple_Check(firstitem) || PyTuple_Size(firstitem) != 2) {\n            PyErr_SetString(PyExc_TypeError, \"dict items \"\n                                \"iterator must return 2-tuples\");\n            goto error;\n        }\n\n        /* Try to get a second item */\n        obj = PyIter_Next(iter);\n        if (obj == NULL) {\n            if (PyErr_Occurred())\n                goto error;\n\n            /* Only one item to write */\n            if (save(self, PyTuple_GET_ITEM(firstitem, 0), 0) < 0)\n                goto error;\n            if (save(self, PyTuple_GET_ITEM(firstitem, 1), 0) < 0)\n                goto error;\n            if (_Pickler_Write(self, &setitem_op, 1) < 0)\n                goto error;\n            Py_CLEAR(firstitem);\n            break;\n        }\n\n        /* More than one item to write */\n\n        /* Pump out MARK, items, SETITEMS. */\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            goto error;\n\n        if (save(self, PyTuple_GET_ITEM(firstitem, 0), 0) < 0)\n            goto error;\n        if (save(self, PyTuple_GET_ITEM(firstitem, 1), 0) < 0)\n            goto error;\n        Py_CLEAR(firstitem);\n        n = 1;\n\n        /* Fetch and save up to BATCHSIZE items */\n        while (obj) {\n            if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 2) {\n                PyErr_SetString(PyExc_TypeError, \"dict items \"\n                    \"iterator must return 2-tuples\");\n                goto error;\n            }\n            if (save(self, PyTuple_GET_ITEM(obj, 0), 0) < 0 ||\n                save(self, PyTuple_GET_ITEM(obj, 1), 0) < 0)\n                goto error;\n            Py_CLEAR(obj);\n            n += 1;\n\n            if (n == BATCHSIZE)\n                break;\n\n            obj = PyIter_Next(iter);\n            if (obj == NULL) {\n                if (PyErr_Occurred())\n                    goto error;\n                break;\n            }\n        }\n\n        if (_Pickler_Write(self, &setitems_op, 1) < 0)\n            goto error;\n\n    } while (n == BATCHSIZE);\n    return 0;\n\n  error:\n    Py_XDECREF(firstitem);\n    Py_XDECREF(obj);\n    return -1;\n}\n\n/* This is a variant of batch_dict() above that specializes for dicts, with no\n * support for dict subclasses. Like batch_dict(), we batch up chunks of\n *     MARK key value ... key value SETITEMS\n * opcode sequences.  Calling code should have arranged to first create an\n * empty dict, or dict-like object, for the SETITEMS to operate on.\n * Returns 0 on success, -1 on error.\n *\n * Note that this currently doesn't work for protocol 0.\n */\nstatic int\nbatch_dict_exact(PicklerObject *self, PyObject *obj)\n{\n    PyObject *key = NULL, *value = NULL;\n    int i;\n    Py_ssize_t dict_size, ppos = 0;\n\n    const char mark_op = MARK;\n    const char setitem_op = SETITEM;\n    const char setitems_op = SETITEMS;\n\n    assert(obj != NULL && PyDict_CheckExact(obj));\n    assert(self->proto > 0);\n\n    dict_size = PyDict_GET_SIZE(obj);\n\n    /* Special-case len(d) == 1 to save space. */\n    if (dict_size == 1) {\n        PyDict_Next(obj, &ppos, &key, &value);\n        if (save(self, key, 0) < 0)\n            return -1;\n        if (save(self, value, 0) < 0)\n            return -1;\n        if (_Pickler_Write(self, &setitem_op, 1) < 0)\n            return -1;\n        return 0;\n    }\n\n    /* Write in batches of BATCHSIZE. */\n    do {\n        i = 0;\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            return -1;\n        while (PyDict_Next(obj, &ppos, &key, &value)) {\n            if (save(self, key, 0) < 0)\n                return -1;\n            if (save(self, value, 0) < 0)\n                return -1;\n            if (++i == BATCHSIZE)\n                break;\n        }\n        if (_Pickler_Write(self, &setitems_op, 1) < 0)\n            return -1;\n        if (PyDict_GET_SIZE(obj) != dict_size) {\n            PyErr_Format(\n                PyExc_RuntimeError,\n                \"dictionary changed size during iteration\");\n            return -1;\n        }\n\n    } while (i == BATCHSIZE);\n    return 0;\n}\n\nstatic int\nsave_dict(PicklerObject *self, PyObject *obj)\n{\n    PyObject *items, *iter;\n    char header[3];\n    Py_ssize_t len;\n    int status = 0;\n    assert(PyDict_Check(obj));\n\n    if (self->fast && !fast_save_enter(self, obj))\n        goto error;\n\n    /* Create an empty dict. */\n    if (self->bin) {\n        header[0] = EMPTY_DICT;\n        len = 1;\n    }\n    else {\n        header[0] = MARK;\n        header[1] = DICT;\n        len = 2;\n    }\n\n    if (_Pickler_Write(self, header, len) < 0)\n        goto error;\n\n    if (memo_put(self, obj) < 0)\n        goto error;\n\n    if (PyDict_GET_SIZE(obj)) {\n        /* Save the dict items. */\n        if (PyDict_CheckExact(obj) && self->proto > 0) {\n            /* We can take certain shortcuts if we know this is a dict and\n               not a dict subclass. */\n            if (Py_EnterRecursiveCall(\" while pickling an object\"))\n                goto error;\n            status = batch_dict_exact(self, obj);\n            Py_LeaveRecursiveCall();\n        } else {\n            _Py_IDENTIFIER(items);\n\n            items = _PyObject_CallMethodId(obj, &PyId_items, NULL);\n            if (items == NULL)\n                goto error;\n            iter = PyObject_GetIter(items);\n            Py_DECREF(items);\n            if (iter == NULL)\n                goto error;\n            if (Py_EnterRecursiveCall(\" while pickling an object\")) {\n                Py_DECREF(iter);\n                goto error;\n            }\n            status = batch_dict(self, iter);\n            Py_LeaveRecursiveCall();\n            Py_DECREF(iter);\n        }\n    }\n\n    if (0) {\n  error:\n        status = -1;\n    }\n\n    if (self->fast && !fast_save_leave(self, obj))\n        status = -1;\n\n    return status;\n}\n\nstatic int\nsave_set(PicklerObject *self, PyObject *obj)\n{\n    PyObject *item;\n    int i;\n    Py_ssize_t set_size, ppos = 0;\n    Py_hash_t hash;\n\n    const char empty_set_op = EMPTY_SET;\n    const char mark_op = MARK;\n    const char additems_op = ADDITEMS;\n\n    if (self->proto < 4) {\n        PyObject *items;\n        PyObject *reduce_value;\n        int status;\n\n        items = PySequence_List(obj);\n        if (items == NULL) {\n            return -1;\n        }\n        reduce_value = Py_BuildValue(\"(O(O))\", (PyObject*)&PySet_Type, items);\n        Py_DECREF(items);\n        if (reduce_value == NULL) {\n            return -1;\n        }\n        /* save_reduce() will memoize the object automatically. */\n        status = save_reduce(self, reduce_value, obj);\n        Py_DECREF(reduce_value);\n        return status;\n    }\n\n    if (_Pickler_Write(self, &empty_set_op, 1) < 0)\n        return -1;\n\n    if (memo_put(self, obj) < 0)\n        return -1;\n\n    set_size = PySet_GET_SIZE(obj);\n    if (set_size == 0)\n        return 0;  /* nothing to do */\n\n    /* Write in batches of BATCHSIZE. */\n    do {\n        i = 0;\n        if (_Pickler_Write(self, &mark_op, 1) < 0)\n            return -1;\n        while (_PySet_NextEntry(obj, &ppos, &item, &hash)) {\n            if (save(self, item, 0) < 0)\n                return -1;\n            if (++i == BATCHSIZE)\n                break;\n        }\n        if (_Pickler_Write(self, &additems_op, 1) < 0)\n            return -1;\n        if (PySet_GET_SIZE(obj) != set_size) {\n            PyErr_Format(\n                PyExc_RuntimeError,\n                \"set changed size during iteration\");\n            return -1;\n        }\n    } while (i == BATCHSIZE);\n\n    return 0;\n}\n\nstatic int\nsave_frozenset(PicklerObject *self, PyObject *obj)\n{\n    PyObject *iter;\n\n    const char mark_op = MARK;\n    const char frozenset_op = FROZENSET;\n\n    if (self->fast && !fast_save_enter(self, obj))\n        return -1;\n\n    if (self->proto < 4) {\n        PyObject *items;\n        PyObject *reduce_value;\n        int status;\n\n        items = PySequence_List(obj);\n        if (items == NULL) {\n            return -1;\n        }\n        reduce_value = Py_BuildValue(\"(O(O))\", (PyObject*)&PyFrozenSet_Type,\n                                     items);\n        Py_DECREF(items);\n        if (reduce_value == NULL) {\n            return -1;\n        }\n        /* save_reduce() will memoize the object automatically. */\n        status = save_reduce(self, reduce_value, obj);\n        Py_DECREF(reduce_value);\n        return status;\n    }\n\n    if (_Pickler_Write(self, &mark_op, 1) < 0)\n        return -1;\n\n    iter = PyObject_GetIter(obj);\n    if (iter == NULL) {\n        return -1;\n    }\n    for (;;) {\n        PyObject *item;\n\n        item = PyIter_Next(iter);\n        if (item == NULL) {\n            if (PyErr_Occurred()) {\n                Py_DECREF(iter);\n                return -1;\n            }\n            break;\n        }\n        if (save(self, item, 0) < 0) {\n            Py_DECREF(item);\n            Py_DECREF(iter);\n            return -1;\n        }\n        Py_DECREF(item);\n    }\n    Py_DECREF(iter);\n\n    /* If the object is already in the memo, this means it is\n       recursive. In this case, throw away everything we put on the\n       stack, and fetch the object back from the memo. */\n    if (PyMemoTable_Get(self->memo, obj)) {\n        const char pop_mark_op = POP_MARK;\n\n        if (_Pickler_Write(self, &pop_mark_op, 1) < 0)\n            return -1;\n        if (memo_get(self, obj) < 0)\n            return -1;\n        return 0;\n    }\n\n    if (_Pickler_Write(self, &frozenset_op, 1) < 0)\n        return -1;\n    if (memo_put(self, obj) < 0)\n        return -1;\n\n    return 0;\n}\n\nstatic int\nfix_imports(PyObject **module_name, PyObject **global_name)\n{\n    PyObject *key;\n    PyObject *item;\n    PickleState *st = _Pickle_GetGlobalState();\n\n    key = PyTuple_Pack(2, *module_name, *global_name);\n    if (key == NULL)\n        return -1;\n    item = PyDict_GetItemWithError(st->name_mapping_3to2, key);\n    Py_DECREF(key);\n    if (item) {\n        PyObject *fixed_module_name;\n        PyObject *fixed_global_name;\n\n        if (!PyTuple_Check(item) || PyTuple_GET_SIZE(item) != 2) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"_compat_pickle.REVERSE_NAME_MAPPING values \"\n                         \"should be 2-tuples, not %.200s\",\n                         Py_TYPE(item)->tp_name);\n            return -1;\n        }\n        fixed_module_name = PyTuple_GET_ITEM(item, 0);\n        fixed_global_name = PyTuple_GET_ITEM(item, 1);\n        if (!PyUnicode_Check(fixed_module_name) ||\n            !PyUnicode_Check(fixed_global_name)) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"_compat_pickle.REVERSE_NAME_MAPPING values \"\n                         \"should be pairs of str, not (%.200s, %.200s)\",\n                         Py_TYPE(fixed_module_name)->tp_name,\n                         Py_TYPE(fixed_global_name)->tp_name);\n            return -1;\n        }\n\n        Py_CLEAR(*module_name);\n        Py_CLEAR(*global_name);\n        Py_INCREF(fixed_module_name);\n        Py_INCREF(fixed_global_name);\n        *module_name = fixed_module_name;\n        *global_name = fixed_global_name;\n        return 0;\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n\n    item = PyDict_GetItemWithError(st->import_mapping_3to2, *module_name);\n    if (item) {\n        if (!PyUnicode_Check(item)) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"_compat_pickle.REVERSE_IMPORT_MAPPING values \"\n                         \"should be strings, not %.200s\",\n                         Py_TYPE(item)->tp_name);\n            return -1;\n        }\n        Py_INCREF(item);\n        Py_XSETREF(*module_name, item);\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic int\nsave_global(PicklerObject *self, PyObject *obj, PyObject *name)\n{\n    PyObject *global_name = NULL;\n    PyObject *module_name = NULL;\n    PyObject *module = NULL;\n    PyObject *parent = NULL;\n    PyObject *dotted_path = NULL;\n    PyObject *lastname = NULL;\n    PyObject *cls;\n    PickleState *st = _Pickle_GetGlobalState();\n    int status = 0;\n    _Py_IDENTIFIER(__name__);\n    _Py_IDENTIFIER(__qualname__);\n\n    const char global_op = GLOBAL;\n\n    if (name) {\n        Py_INCREF(name);\n        global_name = name;\n    }\n    else {\n        if (_PyObject_LookupAttrId(obj, &PyId___qualname__, &global_name) < 0)\n            goto error;\n        if (global_name == NULL) {\n            global_name = _PyObject_GetAttrId(obj, &PyId___name__);\n            if (global_name == NULL)\n                goto error;\n        }\n    }\n\n    dotted_path = get_dotted_path(module, global_name);\n    if (dotted_path == NULL)\n        goto error;\n    module_name = whichmodule(obj, dotted_path);\n    if (module_name == NULL)\n        goto error;\n\n    /* XXX: Change to use the import C API directly with level=0 to disallow\n       relative imports.\n\n       XXX: PyImport_ImportModuleLevel could be used. However, this bypasses\n       builtins.__import__. Therefore, _pickle, unlike pickle.py, will ignore\n       custom import functions (IMHO, this would be a nice security\n       feature). The import C API would need to be extended to support the\n       extra parameters of __import__ to fix that. */\n    module = PyImport_Import(module_name);\n    if (module == NULL) {\n        PyErr_Format(st->PicklingError,\n                     \"Can't pickle %R: import of module %R failed\",\n                     obj, module_name);\n        goto error;\n    }\n    lastname = PyList_GET_ITEM(dotted_path, PyList_GET_SIZE(dotted_path)-1);\n    Py_INCREF(lastname);\n    cls = get_deep_attribute(module, dotted_path, &parent);\n    Py_CLEAR(dotted_path);\n    if (cls == NULL) {\n        PyErr_Format(st->PicklingError,\n                     \"Can't pickle %R: attribute lookup %S on %S failed\",\n                     obj, global_name, module_name);\n        goto error;\n    }\n    if (cls != obj) {\n        Py_DECREF(cls);\n        PyErr_Format(st->PicklingError,\n                     \"Can't pickle %R: it's not the same object as %S.%S\",\n                     obj, module_name, global_name);\n        goto error;\n    }\n    Py_DECREF(cls);\n\n    if (self->proto >= 2) {\n        /* See whether this is in the extension registry, and if\n         * so generate an EXT opcode.\n         */\n        PyObject *extension_key;\n        PyObject *code_obj;      /* extension code as Python object */\n        long code;               /* extension code as C value */\n        char pdata[5];\n        Py_ssize_t n;\n\n        extension_key = PyTuple_Pack(2, module_name, global_name);\n        if (extension_key == NULL) {\n            goto error;\n        }\n        code_obj = PyDict_GetItemWithError(st->extension_registry,\n                                           extension_key);\n        Py_DECREF(extension_key);\n        /* The object is not registered in the extension registry.\n           This is the most likely code path. */\n        if (code_obj == NULL) {\n            if (PyErr_Occurred()) {\n                goto error;\n            }\n            goto gen_global;\n        }\n\n        /* XXX: pickle.py doesn't check neither the type, nor the range\n           of the value returned by the extension_registry. It should for\n           consistency. */\n\n        /* Verify code_obj has the right type and value. */\n        if (!PyLong_Check(code_obj)) {\n            PyErr_Format(st->PicklingError,\n                         \"Can't pickle %R: extension code %R isn't an integer\",\n                         obj, code_obj);\n            goto error;\n        }\n        code = PyLong_AS_LONG(code_obj);\n        if (code <= 0 || code > 0x7fffffffL) {\n            if (!PyErr_Occurred())\n                PyErr_Format(st->PicklingError, \"Can't pickle %R: extension \"\n                             \"code %ld is out of range\", obj, code);\n            goto error;\n        }\n\n        /* Generate an EXT opcode. */\n        if (code <= 0xff) {\n            pdata[0] = EXT1;\n            pdata[1] = (unsigned char)code;\n            n = 2;\n        }\n        else if (code <= 0xffff) {\n            pdata[0] = EXT2;\n            pdata[1] = (unsigned char)(code & 0xff);\n            pdata[2] = (unsigned char)((code >> 8) & 0xff);\n            n = 3;\n        }\n        else {\n            pdata[0] = EXT4;\n            pdata[1] = (unsigned char)(code & 0xff);\n            pdata[2] = (unsigned char)((code >> 8) & 0xff);\n            pdata[3] = (unsigned char)((code >> 16) & 0xff);\n            pdata[4] = (unsigned char)((code >> 24) & 0xff);\n            n = 5;\n        }\n\n        if (_Pickler_Write(self, pdata, n) < 0)\n            goto error;\n    }\n    else {\n  gen_global:\n        if (parent == module) {\n            Py_INCREF(lastname);\n            Py_DECREF(global_name);\n            global_name = lastname;\n        }\n        if (self->proto >= 4) {\n            const char stack_global_op = STACK_GLOBAL;\n\n            if (save(self, module_name, 0) < 0)\n                goto error;\n            if (save(self, global_name, 0) < 0)\n                goto error;\n\n            if (_Pickler_Write(self, &stack_global_op, 1) < 0)\n                goto error;\n        }\n        else if (parent != module) {\n            PickleState *st = _Pickle_GetGlobalState();\n            PyObject *reduce_value = Py_BuildValue(\"(O(OO))\",\n                                        st->getattr, parent, lastname);\n            if (reduce_value == NULL)\n                goto error;\n            status = save_reduce(self, reduce_value, NULL);\n            Py_DECREF(reduce_value);\n            if (status < 0)\n                goto error;\n        }\n        else {\n            /* Generate a normal global opcode if we are using a pickle\n               protocol < 4, or if the object is not registered in the\n               extension registry. */\n            PyObject *encoded;\n            PyObject *(*unicode_encoder)(PyObject *);\n\n            if (_Pickler_Write(self, &global_op, 1) < 0)\n                goto error;\n\n            /* For protocol < 3 and if the user didn't request against doing\n               so, we convert module names to the old 2.x module names. */\n            if (self->proto < 3 && self->fix_imports) {\n                if (fix_imports(&module_name, &global_name) < 0) {\n                    goto error;\n                }\n            }\n\n            /* Since Python 3.0 now supports non-ASCII identifiers, we encode\n               both the module name and the global name using UTF-8. We do so\n               only when we are using the pickle protocol newer than version\n               3. This is to ensure compatibility with older Unpickler running\n               on Python 2.x. */\n            if (self->proto == 3) {\n                unicode_encoder = PyUnicode_AsUTF8String;\n            }\n            else {\n                unicode_encoder = PyUnicode_AsASCIIString;\n            }\n            encoded = unicode_encoder(module_name);\n            if (encoded == NULL) {\n                if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))\n                    PyErr_Format(st->PicklingError,\n                                 \"can't pickle module identifier '%S' using \"\n                                 \"pickle protocol %i\",\n                                 module_name, self->proto);\n                goto error;\n            }\n            if (_Pickler_Write(self, PyBytes_AS_STRING(encoded),\n                               PyBytes_GET_SIZE(encoded)) < 0) {\n                Py_DECREF(encoded);\n                goto error;\n            }\n            Py_DECREF(encoded);\n            if(_Pickler_Write(self, \"\\n\", 1) < 0)\n                goto error;\n\n            /* Save the name of the module. */\n            encoded = unicode_encoder(global_name);\n            if (encoded == NULL) {\n                if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))\n                    PyErr_Format(st->PicklingError,\n                                 \"can't pickle global identifier '%S' using \"\n                                 \"pickle protocol %i\",\n                                 global_name, self->proto);\n                goto error;\n            }\n            if (_Pickler_Write(self, PyBytes_AS_STRING(encoded),\n                               PyBytes_GET_SIZE(encoded)) < 0) {\n                Py_DECREF(encoded);\n                goto error;\n            }\n            Py_DECREF(encoded);\n            if (_Pickler_Write(self, \"\\n\", 1) < 0)\n                goto error;\n        }\n        /* Memoize the object. */\n        if (memo_put(self, obj) < 0)\n            goto error;\n    }\n\n    if (0) {\n  error:\n        status = -1;\n    }\n    Py_XDECREF(module_name);\n    Py_XDECREF(global_name);\n    Py_XDECREF(module);\n    Py_XDECREF(parent);\n    Py_XDECREF(dotted_path);\n    Py_XDECREF(lastname);\n\n    return status;\n}\n\nstatic int\nsave_singleton_type(PicklerObject *self, PyObject *obj, PyObject *singleton)\n{\n    PyObject *reduce_value;\n    int status;\n\n    reduce_value = Py_BuildValue(\"O(O)\", &PyType_Type, singleton);\n    if (reduce_value == NULL) {\n        return -1;\n    }\n    status = save_reduce(self, reduce_value, obj);\n    Py_DECREF(reduce_value);\n    return status;\n}\n\nstatic int\nsave_type(PicklerObject *self, PyObject *obj)\n{\n    if (obj == (PyObject *)&_PyNone_Type) {\n        return save_singleton_type(self, obj, Py_None);\n    }\n    else if (obj == (PyObject *)&PyEllipsis_Type) {\n        return save_singleton_type(self, obj, Py_Ellipsis);\n    }\n    else if (obj == (PyObject *)&_PyNotImplemented_Type) {\n        return save_singleton_type(self, obj, Py_NotImplemented);\n    }\n    return save_global(self, obj, NULL);\n}\n\nstatic int\nsave_pers(PicklerObject *self, PyObject *obj)\n{\n    PyObject *pid = NULL;\n    int status = 0;\n\n    const char persid_op = PERSID;\n    const char binpersid_op = BINPERSID;\n\n    pid = call_method(self->pers_func, self->pers_func_self, obj);\n    if (pid == NULL)\n        return -1;\n\n    if (pid != Py_None) {\n        if (self->bin) {\n            if (save(self, pid, 1) < 0 ||\n                _Pickler_Write(self, &binpersid_op, 1) < 0)\n                goto error;\n        }\n        else {\n            PyObject *pid_str;\n\n            pid_str = PyObject_Str(pid);\n            if (pid_str == NULL)\n                goto error;\n\n            /* XXX: Should it check whether the pid contains embedded\n               newlines? */\n            if (!PyUnicode_IS_ASCII(pid_str)) {\n                PyErr_SetString(_Pickle_GetGlobalState()->PicklingError,\n                                \"persistent IDs in protocol 0 must be \"\n                                \"ASCII strings\");\n                Py_DECREF(pid_str);\n                goto error;\n            }\n\n            if (_Pickler_Write(self, &persid_op, 1) < 0 ||\n                _Pickler_Write(self, PyUnicode_DATA(pid_str),\n                               PyUnicode_GET_LENGTH(pid_str)) < 0 ||\n                _Pickler_Write(self, \"\\n\", 1) < 0) {\n                Py_DECREF(pid_str);\n                goto error;\n            }\n            Py_DECREF(pid_str);\n        }\n        status = 1;\n    }\n\n    if (0) {\n  error:\n        status = -1;\n    }\n    Py_XDECREF(pid);\n\n    return status;\n}\n\nstatic PyObject *\nget_class(PyObject *obj)\n{\n    PyObject *cls;\n    _Py_IDENTIFIER(__class__);\n\n    if (_PyObject_LookupAttrId(obj, &PyId___class__, &cls) == 0) {\n        cls = (PyObject *) Py_TYPE(obj);\n        Py_INCREF(cls);\n    }\n    return cls;\n}\n\n/* We're saving obj, and args is the 2-thru-5 tuple returned by the\n * appropriate __reduce__ method for obj.\n */\nstatic int\nsave_reduce(PicklerObject *self, PyObject *args, PyObject *obj)\n{\n    PyObject *callable;\n    PyObject *argtup;\n    PyObject *state = NULL;\n    PyObject *listitems = Py_None;\n    PyObject *dictitems = Py_None;\n    PickleState *st = _Pickle_GetGlobalState();\n    Py_ssize_t size;\n    int use_newobj = 0, use_newobj_ex = 0;\n\n    const char reduce_op = REDUCE;\n    const char build_op = BUILD;\n    const char newobj_op = NEWOBJ;\n    const char newobj_ex_op = NEWOBJ_EX;\n\n    size = PyTuple_Size(args);\n    if (size < 2 || size > 5) {\n        PyErr_SetString(st->PicklingError, \"tuple returned by \"\n                        \"__reduce__ must contain 2 through 5 elements\");\n        return -1;\n    }\n\n    if (!PyArg_UnpackTuple(args, \"save_reduce\", 2, 5,\n                           &callable, &argtup, &state, &listitems, &dictitems))\n        return -1;\n\n    if (!PyCallable_Check(callable)) {\n        PyErr_SetString(st->PicklingError, \"first item of the tuple \"\n                        \"returned by __reduce__ must be callable\");\n        return -1;\n    }\n    if (!PyTuple_Check(argtup)) {\n        PyErr_SetString(st->PicklingError, \"second item of the tuple \"\n                        \"returned by __reduce__ must be a tuple\");\n        return -1;\n    }\n\n    if (state == Py_None)\n        state = NULL;\n\n    if (listitems == Py_None)\n        listitems = NULL;\n    else if (!PyIter_Check(listitems)) {\n        PyErr_Format(st->PicklingError, \"fourth element of the tuple \"\n                     \"returned by __reduce__ must be an iterator, not %s\",\n                     Py_TYPE(listitems)->tp_name);\n        return -1;\n    }\n\n    if (dictitems == Py_None)\n        dictitems = NULL;\n    else if (!PyIter_Check(dictitems)) {\n        PyErr_Format(st->PicklingError, \"fifth element of the tuple \"\n                     \"returned by __reduce__ must be an iterator, not %s\",\n                     Py_TYPE(dictitems)->tp_name);\n        return -1;\n    }\n\n    if (self->proto >= 2) {\n        PyObject *name;\n        _Py_IDENTIFIER(__name__);\n\n        if (_PyObject_LookupAttrId(callable, &PyId___name__, &name) < 0) {\n            return -1;\n        }\n        if (name != NULL && PyUnicode_Check(name)) {\n            _Py_IDENTIFIER(__newobj_ex__);\n            use_newobj_ex = _PyUnicode_EqualToASCIIId(\n                    name, &PyId___newobj_ex__);\n            if (!use_newobj_ex) {\n                _Py_IDENTIFIER(__newobj__);\n                use_newobj = _PyUnicode_EqualToASCIIId(name, &PyId___newobj__);\n            }\n        }\n        Py_XDECREF(name);\n    }\n\n    if (use_newobj_ex) {\n        PyObject *cls;\n        PyObject *args;\n        PyObject *kwargs;\n\n        if (PyTuple_GET_SIZE(argtup) != 3) {\n            PyErr_Format(st->PicklingError,\n                         \"length of the NEWOBJ_EX argument tuple must be \"\n                         \"exactly 3, not %zd\", PyTuple_GET_SIZE(argtup));\n            return -1;\n        }\n\n        cls = PyTuple_GET_ITEM(argtup, 0);\n        if (!PyType_Check(cls)) {\n            PyErr_Format(st->PicklingError,\n                         \"first item from NEWOBJ_EX argument tuple must \"\n                         \"be a class, not %.200s\", Py_TYPE(cls)->tp_name);\n            return -1;\n        }\n        args = PyTuple_GET_ITEM(argtup, 1);\n        if (!PyTuple_Check(args)) {\n            PyErr_Format(st->PicklingError,\n                         \"second item from NEWOBJ_EX argument tuple must \"\n                         \"be a tuple, not %.200s\", Py_TYPE(args)->tp_name);\n            return -1;\n        }\n        kwargs = PyTuple_GET_ITEM(argtup, 2);\n        if (!PyDict_Check(kwargs)) {\n            PyErr_Format(st->PicklingError,\n                         \"third item from NEWOBJ_EX argument tuple must \"\n                         \"be a dict, not %.200s\", Py_TYPE(kwargs)->tp_name);\n            return -1;\n        }\n\n        if (self->proto >= 4) {\n            if (save(self, cls, 0) < 0 ||\n                save(self, args, 0) < 0 ||\n                save(self, kwargs, 0) < 0 ||\n                _Pickler_Write(self, &newobj_ex_op, 1) < 0) {\n                return -1;\n            }\n        }\n        else {\n            PyObject *newargs;\n            PyObject *cls_new;\n            Py_ssize_t i;\n            _Py_IDENTIFIER(__new__);\n\n            newargs = PyTuple_New(PyTuple_GET_SIZE(args) + 2);\n            if (newargs == NULL)\n                return -1;\n\n            cls_new = _PyObject_GetAttrId(cls, &PyId___new__);\n            if (cls_new == NULL) {\n                Py_DECREF(newargs);\n                return -1;\n            }\n            PyTuple_SET_ITEM(newargs, 0, cls_new);\n            Py_INCREF(cls);\n            PyTuple_SET_ITEM(newargs, 1, cls);\n            for (i = 0; i < PyTuple_GET_SIZE(args); i++) {\n                PyObject *item = PyTuple_GET_ITEM(args, i);\n                Py_INCREF(item);\n                PyTuple_SET_ITEM(newargs, i + 2, item);\n            }\n\n            callable = PyObject_Call(st->partial, newargs, kwargs);\n            Py_DECREF(newargs);\n            if (callable == NULL)\n                return -1;\n\n            newargs = PyTuple_New(0);\n            if (newargs == NULL) {\n                Py_DECREF(callable);\n                return -1;\n            }\n\n            if (save(self, callable, 0) < 0 ||\n                save(self, newargs, 0) < 0 ||\n                _Pickler_Write(self, &reduce_op, 1) < 0) {\n                Py_DECREF(newargs);\n                Py_DECREF(callable);\n                return -1;\n            }\n            Py_DECREF(newargs);\n            Py_DECREF(callable);\n        }\n    }\n    else if (use_newobj) {\n        PyObject *cls;\n        PyObject *newargtup;\n        PyObject *obj_class;\n        int p;\n\n        /* Sanity checks. */\n        if (PyTuple_GET_SIZE(argtup) < 1) {\n            PyErr_SetString(st->PicklingError, \"__newobj__ arglist is empty\");\n            return -1;\n        }\n\n        cls = PyTuple_GET_ITEM(argtup, 0);\n        if (!PyType_Check(cls)) {\n            PyErr_SetString(st->PicklingError, \"args[0] from \"\n                            \"__newobj__ args is not a type\");\n            return -1;\n        }\n\n        if (obj != NULL) {\n            obj_class = get_class(obj);\n            p = obj_class != cls;    /* true iff a problem */\n            Py_DECREF(obj_class);\n            if (p) {\n                PyErr_SetString(st->PicklingError, \"args[0] from \"\n                                \"__newobj__ args has the wrong class\");\n                return -1;\n            }\n        }\n        /* XXX: These calls save() are prone to infinite recursion. Imagine\n           what happen if the value returned by the __reduce__() method of\n           some extension type contains another object of the same type. Ouch!\n\n           Here is a quick example, that I ran into, to illustrate what I\n           mean:\n\n             >>> import pickle, copyreg\n             >>> copyreg.dispatch_table.pop(complex)\n             >>> pickle.dumps(1+2j)\n             Traceback (most recent call last):\n               ...\n             RecursionError: maximum recursion depth exceeded\n\n           Removing the complex class from copyreg.dispatch_table made the\n           __reduce_ex__() method emit another complex object:\n\n             >>> (1+1j).__reduce_ex__(2)\n             (<function __newobj__ at 0xb7b71c3c>,\n               (<class 'complex'>, (1+1j)), None, None, None)\n\n           Thus when save() was called on newargstup (the 2nd item) recursion\n           ensued. Of course, the bug was in the complex class which had a\n           broken __getnewargs__() that emitted another complex object. But,\n           the point, here, is it is quite easy to end up with a broken reduce\n           function. */\n\n        /* Save the class and its __new__ arguments. */\n        if (save(self, cls, 0) < 0)\n            return -1;\n\n        newargtup = PyTuple_GetSlice(argtup, 1, PyTuple_GET_SIZE(argtup));\n        if (newargtup == NULL)\n            return -1;\n\n        p = save(self, newargtup, 0);\n        Py_DECREF(newargtup);\n        if (p < 0)\n            return -1;\n\n        /* Add NEWOBJ opcode. */\n        if (_Pickler_Write(self, &newobj_op, 1) < 0)\n            return -1;\n    }\n    else { /* Not using NEWOBJ. */\n        if (save(self, callable, 0) < 0 ||\n            save(self, argtup, 0) < 0 ||\n            _Pickler_Write(self, &reduce_op, 1) < 0)\n            return -1;\n    }\n\n    /* obj can be NULL when save_reduce() is used directly. A NULL obj means\n       the caller do not want to memoize the object. Not particularly useful,\n       but that is to mimic the behavior save_reduce() in pickle.py when\n       obj is None. */\n    if (obj != NULL) {\n        /* If the object is already in the memo, this means it is\n           recursive. In this case, throw away everything we put on the\n           stack, and fetch the object back from the memo. */\n        if (PyMemoTable_Get(self->memo, obj)) {\n            const char pop_op = POP;\n\n            if (_Pickler_Write(self, &pop_op, 1) < 0)\n                return -1;\n            if (memo_get(self, obj) < 0)\n                return -1;\n\n            return 0;\n        }\n        else if (memo_put(self, obj) < 0)\n            return -1;\n    }\n\n    if (listitems && batch_list(self, listitems) < 0)\n        return -1;\n\n    if (dictitems && batch_dict(self, dictitems) < 0)\n        return -1;\n\n    if (state) {\n        if (save(self, state, 0) < 0 ||\n            _Pickler_Write(self, &build_op, 1) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\nstatic int\nsave(PicklerObject *self, PyObject *obj, int pers_save)\n{\n    PyTypeObject *type;\n    PyObject *reduce_func = NULL;\n    PyObject *reduce_value = NULL;\n    int status = 0;\n\n    if (_Pickler_OpcodeBoundary(self) < 0)\n        return -1;\n\n    /* The extra pers_save argument is necessary to avoid calling save_pers()\n       on its returned object. */\n    if (!pers_save && self->pers_func) {\n        /* save_pers() returns:\n            -1   to signal an error;\n             0   if it did nothing successfully;\n             1   if a persistent id was saved.\n         */\n        if ((status = save_pers(self, obj)) != 0)\n            return status;\n    }\n\n    type = Py_TYPE(obj);\n\n    /* The old cPickle had an optimization that used switch-case statement\n       dispatching on the first letter of the type name.  This has was removed\n       since benchmarks shown that this optimization was actually slowing\n       things down. */\n\n    /* Atom types; these aren't memoized, so don't check the memo. */\n\n    if (obj == Py_None) {\n        return save_none(self, obj);\n    }\n    else if (obj == Py_False || obj == Py_True) {\n        return save_bool(self, obj);\n    }\n    else if (type == &PyLong_Type) {\n        return save_long(self, obj);\n    }\n    else if (type == &PyFloat_Type) {\n        return save_float(self, obj);\n    }\n\n    /* Check the memo to see if it has the object. If so, generate\n       a GET (or BINGET) opcode, instead of pickling the object\n       once again. */\n    if (PyMemoTable_Get(self->memo, obj)) {\n        return memo_get(self, obj);\n    }\n\n    if (type == &PyBytes_Type) {\n        return save_bytes(self, obj);\n    }\n    else if (type == &PyUnicode_Type) {\n        return save_unicode(self, obj);\n    }\n\n    /* We're only calling Py_EnterRecursiveCall here so that atomic\n       types above are pickled faster. */\n    if (Py_EnterRecursiveCall(\" while pickling an object\")) {\n        return -1;\n    }\n\n    if (type == &PyDict_Type) {\n        status = save_dict(self, obj);\n        goto done;\n    }\n    else if (type == &PySet_Type) {\n        status = save_set(self, obj);\n        goto done;\n    }\n    else if (type == &PyFrozenSet_Type) {\n        status = save_frozenset(self, obj);\n        goto done;\n    }\n    else if (type == &PyList_Type) {\n        status = save_list(self, obj);\n        goto done;\n    }\n    else if (type == &PyTuple_Type) {\n        status = save_tuple(self, obj);\n        goto done;\n    }\n    else if (type == &PyType_Type) {\n        status = save_type(self, obj);\n        goto done;\n    }\n    else if (type == &PyFunction_Type) {\n        status = save_global(self, obj, NULL);\n        goto done;\n    }\n\n    /* XXX: This part needs some unit tests. */\n\n    /* Get a reduction callable, and call it.  This may come from\n     * self.dispatch_table, copyreg.dispatch_table, the object's\n     * __reduce_ex__ method, or the object's __reduce__ method.\n     */\n    if (self->dispatch_table == NULL) {\n        PickleState *st = _Pickle_GetGlobalState();\n        reduce_func = PyDict_GetItemWithError(st->dispatch_table,\n                                              (PyObject *)type);\n        if (reduce_func == NULL) {\n            if (PyErr_Occurred()) {\n                goto error;\n            }\n        } else {\n            /* PyDict_GetItemWithError() returns a borrowed reference.\n               Increase the reference count to be consistent with\n               PyObject_GetItem and _PyObject_GetAttrId used below. */\n            Py_INCREF(reduce_func);\n        }\n    } else {\n        reduce_func = PyObject_GetItem(self->dispatch_table,\n                                       (PyObject *)type);\n        if (reduce_func == NULL) {\n            if (PyErr_ExceptionMatches(PyExc_KeyError))\n                PyErr_Clear();\n            else\n                goto error;\n        }\n    }\n    if (reduce_func != NULL) {\n        Py_INCREF(obj);\n        reduce_value = _Pickle_FastCall(reduce_func, obj);\n    }\n    else if (PyType_IsSubtype(type, &PyType_Type)) {\n        status = save_global(self, obj, NULL);\n        goto done;\n    }\n    else {\n        _Py_IDENTIFIER(__reduce__);\n        _Py_IDENTIFIER(__reduce_ex__);\n\n\n        /* XXX: If the __reduce__ method is defined, __reduce_ex__ is\n           automatically defined as __reduce__. While this is convenient, this\n           make it impossible to know which method was actually called. Of\n           course, this is not a big deal. But still, it would be nice to let\n           the user know which method was called when something go\n           wrong. Incidentally, this means if __reduce_ex__ is not defined, we\n           don't actually have to check for a __reduce__ method. */\n\n        /* Check for a __reduce_ex__ method. */\n        if (_PyObject_LookupAttrId(obj, &PyId___reduce_ex__, &reduce_func) < 0) {\n            goto error;\n        }\n        if (reduce_func != NULL) {\n            PyObject *proto;\n            proto = PyLong_FromLong(self->proto);\n            if (proto != NULL) {\n                reduce_value = _Pickle_FastCall(reduce_func, proto);\n            }\n        }\n        else {\n            PickleState *st = _Pickle_GetGlobalState();\n\n            /* Check for a __reduce__ method. */\n            reduce_func = _PyObject_GetAttrId(obj, &PyId___reduce__);\n            if (reduce_func != NULL) {\n                reduce_value = _PyObject_CallNoArg(reduce_func);\n            }\n            else {\n                PyErr_Format(st->PicklingError,\n                             \"can't pickle '%.200s' object: %R\",\n                             type->tp_name, obj);\n                goto error;\n            }\n        }\n    }\n\n    if (reduce_value == NULL)\n        goto error;\n\n    if (PyUnicode_Check(reduce_value)) {\n        status = save_global(self, obj, reduce_value);\n        goto done;\n    }\n\n    if (!PyTuple_Check(reduce_value)) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->PicklingError,\n                        \"__reduce__ must return a string or tuple\");\n        goto error;\n    }\n\n    status = save_reduce(self, reduce_value, obj);\n\n    if (0) {\n  error:\n        status = -1;\n    }\n  done:\n\n    Py_LeaveRecursiveCall();\n    Py_XDECREF(reduce_func);\n    Py_XDECREF(reduce_value);\n\n    return status;\n}\n\nstatic int\ndump(PicklerObject *self, PyObject *obj)\n{\n    const char stop_op = STOP;\n\n    if (self->proto >= 2) {\n        char header[2];\n\n        header[0] = PROTO;\n        assert(self->proto >= 0 && self->proto < 256);\n        header[1] = (unsigned char)self->proto;\n        if (_Pickler_Write(self, header, 2) < 0)\n            return -1;\n        if (self->proto >= 4)\n            self->framing = 1;\n    }\n\n    if (save(self, obj, 0) < 0 ||\n        _Pickler_Write(self, &stop_op, 1) < 0 ||\n        _Pickler_CommitFrame(self) < 0)\n        return -1;\n    self->framing = 0;\n    return 0;\n}\n\n/*[clinic input]\n\n_pickle.Pickler.clear_memo\n\nClears the pickler's \"memo\".\n\nThe memo is the data structure that remembers which objects the\npickler has already seen, so that shared or recursive objects are\npickled by reference and not by value.  This method is useful when\nre-using picklers.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_Pickler_clear_memo_impl(PicklerObject *self)\n/*[clinic end generated code: output=8665c8658aaa094b input=01bdad52f3d93e56]*/\n{\n    if (self->memo)\n        PyMemoTable_Clear(self->memo);\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n\n_pickle.Pickler.dump\n\n  obj: object\n  /\n\nWrite a pickled representation of the given object to the open file.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_Pickler_dump(PicklerObject *self, PyObject *obj)\n/*[clinic end generated code: output=87ecad1261e02ac7 input=552eb1c0f52260d9]*/\n{\n    /* Check whether the Pickler was initialized correctly (issue3664).\n       Developers often forget to call __init__() in their subclasses, which\n       would trigger a segfault without this check. */\n    if (self->write == NULL) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_Format(st->PicklingError,\n                     \"Pickler.__init__() was not called by %s.__init__()\",\n                     Py_TYPE(self)->tp_name);\n        return NULL;\n    }\n\n    if (_Pickler_ClearBuffer(self) < 0)\n        return NULL;\n\n    if (dump(self, obj) < 0)\n        return NULL;\n\n    if (_Pickler_FlushToFile(self) < 0)\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n\n_pickle.Pickler.__sizeof__ -> Py_ssize_t\n\nReturns size in memory, in bytes.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_pickle_Pickler___sizeof___impl(PicklerObject *self)\n/*[clinic end generated code: output=106edb3123f332e1 input=8cbbec9bd5540d42]*/\n{\n    Py_ssize_t res, s;\n\n    res = _PyObject_SIZE(Py_TYPE(self));\n    if (self->memo != NULL) {\n        res += sizeof(PyMemoTable);\n        res += self->memo->mt_allocated * sizeof(PyMemoEntry);\n    }\n    if (self->output_buffer != NULL) {\n        s = _PySys_GetSizeOf(self->output_buffer);\n        if (s == -1)\n            return -1;\n        res += s;\n    }\n    return res;\n}\n\nstatic struct PyMethodDef Pickler_methods[] = {\n    _PICKLE_PICKLER_DUMP_METHODDEF\n    _PICKLE_PICKLER_CLEAR_MEMO_METHODDEF\n    _PICKLE_PICKLER___SIZEOF___METHODDEF\n    {NULL, NULL}                /* sentinel */\n};\n\nstatic void\nPickler_dealloc(PicklerObject *self)\n{\n    PyObject_GC_UnTrack(self);\n\n    Py_XDECREF(self->output_buffer);\n    Py_XDECREF(self->write);\n    Py_XDECREF(self->pers_func);\n    Py_XDECREF(self->dispatch_table);\n    Py_XDECREF(self->fast_memo);\n\n    PyMemoTable_Del(self->memo);\n\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic int\nPickler_traverse(PicklerObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->write);\n    Py_VISIT(self->pers_func);\n    Py_VISIT(self->dispatch_table);\n    Py_VISIT(self->fast_memo);\n    return 0;\n}\n\nstatic int\nPickler_clear(PicklerObject *self)\n{\n    Py_CLEAR(self->output_buffer);\n    Py_CLEAR(self->write);\n    Py_CLEAR(self->pers_func);\n    Py_CLEAR(self->dispatch_table);\n    Py_CLEAR(self->fast_memo);\n\n    if (self->memo != NULL) {\n        PyMemoTable *memo = self->memo;\n        self->memo = NULL;\n        PyMemoTable_Del(memo);\n    }\n    return 0;\n}\n\n\n/*[clinic input]\n\n_pickle.Pickler.__init__\n\n  file: object\n  protocol: object = NULL\n  fix_imports: bool = True\n\nThis takes a binary file for writing a pickle data stream.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3 and 4.  The default\nprotocol is 3; a backward-incompatible protocol designed for Python 3.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument. It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n[clinic start generated code]*/\n\nstatic int\n_pickle_Pickler___init___impl(PicklerObject *self, PyObject *file,\n                              PyObject *protocol, int fix_imports)\n/*[clinic end generated code: output=b5f31078dab17fb0 input=4faabdbc763c2389]*/\n{\n    _Py_IDENTIFIER(persistent_id);\n    _Py_IDENTIFIER(dispatch_table);\n\n    /* In case of multiple __init__() calls, clear previous content. */\n    if (self->write != NULL)\n        (void)Pickler_clear(self);\n\n    if (_Pickler_SetProtocol(self, protocol, fix_imports) < 0)\n        return -1;\n\n    if (_Pickler_SetOutputStream(self, file) < 0)\n        return -1;\n\n    /* memo and output_buffer may have already been created in _Pickler_New */\n    if (self->memo == NULL) {\n        self->memo = PyMemoTable_New();\n        if (self->memo == NULL)\n            return -1;\n    }\n    self->output_len = 0;\n    if (self->output_buffer == NULL) {\n        self->max_output_len = WRITE_BUF_SIZE;\n        self->output_buffer = PyBytes_FromStringAndSize(NULL,\n                                                        self->max_output_len);\n        if (self->output_buffer == NULL)\n            return -1;\n    }\n\n    self->fast = 0;\n    self->fast_nesting = 0;\n    self->fast_memo = NULL;\n\n    if (init_method_ref((PyObject *)self, &PyId_persistent_id,\n                        &self->pers_func, &self->pers_func_self) < 0)\n    {\n        return -1;\n    }\n\n    if (_PyObject_LookupAttrId((PyObject *)self,\n                                    &PyId_dispatch_table, &self->dispatch_table) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n\n\n/* Define a proxy object for the Pickler's internal memo object. This is to\n * avoid breaking code like:\n *  pickler.memo.clear()\n * and\n *  pickler.memo = saved_memo\n * Is this a good idea? Not really, but we don't want to break code that uses\n * it. Note that we don't implement the entire mapping API here. This is\n * intentional, as these should be treated as black-box implementation details.\n */\n\n/*[clinic input]\n_pickle.PicklerMemoProxy.clear\n\nRemove all items from memo.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_PicklerMemoProxy_clear_impl(PicklerMemoProxyObject *self)\n/*[clinic end generated code: output=5fb9370d48ae8b05 input=ccc186dacd0f1405]*/\n{\n    if (self->pickler->memo)\n        PyMemoTable_Clear(self->pickler->memo);\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_pickle.PicklerMemoProxy.copy\n\nCopy the memo to a new object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *self)\n/*[clinic end generated code: output=bb83a919d29225ef input=b73043485ac30b36]*/\n{\n    PyMemoTable *memo;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    memo = self->pickler->memo;\n    for (size_t i = 0; i < memo->mt_allocated; ++i) {\n        PyMemoEntry entry = memo->mt_table[i];\n        if (entry.me_key != NULL) {\n            int status;\n            PyObject *key, *value;\n\n            key = PyLong_FromVoidPtr(entry.me_key);\n            value = Py_BuildValue(\"nO\", entry.me_value, entry.me_key);\n\n            if (key == NULL || value == NULL) {\n                Py_XDECREF(key);\n                Py_XDECREF(value);\n                goto error;\n            }\n            status = PyDict_SetItem(new_memo, key, value);\n            Py_DECREF(key);\n            Py_DECREF(value);\n            if (status < 0)\n                goto error;\n        }\n    }\n    return new_memo;\n\n  error:\n    Py_XDECREF(new_memo);\n    return NULL;\n}\n\n/*[clinic input]\n_pickle.PicklerMemoProxy.__reduce__\n\nImplement pickle support.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_PicklerMemoProxy___reduce___impl(PicklerMemoProxyObject *self)\n/*[clinic end generated code: output=bebba1168863ab1d input=2f7c540e24b7aae4]*/\n{\n    PyObject *reduce_value, *dict_args;\n    PyObject *contents = _pickle_PicklerMemoProxy_copy_impl(self);\n    if (contents == NULL)\n        return NULL;\n\n    reduce_value = PyTuple_New(2);\n    if (reduce_value == NULL) {\n        Py_DECREF(contents);\n        return NULL;\n    }\n    dict_args = PyTuple_New(1);\n    if (dict_args == NULL) {\n        Py_DECREF(contents);\n        Py_DECREF(reduce_value);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(dict_args, 0, contents);\n    Py_INCREF((PyObject *)&PyDict_Type);\n    PyTuple_SET_ITEM(reduce_value, 0, (PyObject *)&PyDict_Type);\n    PyTuple_SET_ITEM(reduce_value, 1, dict_args);\n    return reduce_value;\n}\n\nstatic PyMethodDef picklerproxy_methods[] = {\n    _PICKLE_PICKLERMEMOPROXY_CLEAR_METHODDEF\n    _PICKLE_PICKLERMEMOPROXY_COPY_METHODDEF\n    _PICKLE_PICKLERMEMOPROXY___REDUCE___METHODDEF\n    {NULL, NULL} /* sentinel */\n};\n\nstatic void\nPicklerMemoProxy_dealloc(PicklerMemoProxyObject *self)\n{\n    PyObject_GC_UnTrack(self);\n    Py_XDECREF(self->pickler);\n    PyObject_GC_Del((PyObject *)self);\n}\n\nstatic int\nPicklerMemoProxy_traverse(PicklerMemoProxyObject *self,\n                          visitproc visit, void *arg)\n{\n    Py_VISIT(self->pickler);\n    return 0;\n}\n\nstatic int\nPicklerMemoProxy_clear(PicklerMemoProxyObject *self)\n{\n    Py_CLEAR(self->pickler);\n    return 0;\n}\n\nstatic PyTypeObject PicklerMemoProxyType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.PicklerMemoProxy\",                 /*tp_name*/\n    sizeof(PicklerMemoProxyObject),             /*tp_basicsize*/\n    0,\n    (destructor)PicklerMemoProxy_dealloc,       /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    PyObject_HashNotImplemented,                /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    PyObject_GenericSetAttr,                    /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)PicklerMemoProxy_traverse,    /* tp_traverse */\n    (inquiry)PicklerMemoProxy_clear,            /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    picklerproxy_methods,                       /* tp_methods */\n};\n\nstatic PyObject *\nPicklerMemoProxy_New(PicklerObject *pickler)\n{\n    PicklerMemoProxyObject *self;\n\n    self = PyObject_GC_New(PicklerMemoProxyObject, &PicklerMemoProxyType);\n    if (self == NULL)\n        return NULL;\n    Py_INCREF(pickler);\n    self->pickler = pickler;\n    PyObject_GC_Track(self);\n    return (PyObject *)self;\n}\n\n/*****************************************************************************/\n\nstatic PyObject *\nPickler_get_memo(PicklerObject *self)\n{\n    return PicklerMemoProxy_New(self);\n}\n\nstatic int\nPickler_set_memo(PicklerObject *self, PyObject *obj)\n{\n    PyMemoTable *new_memo = NULL;\n\n    if (obj == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(obj) == &PicklerMemoProxyType) {\n        PicklerObject *pickler =\n            ((PicklerMemoProxyObject *)obj)->pickler;\n\n        new_memo = PyMemoTable_Copy(pickler->memo);\n        if (new_memo == NULL)\n            return -1;\n    }\n    else if (PyDict_Check(obj)) {\n        Py_ssize_t i = 0;\n        PyObject *key, *value;\n\n        new_memo = PyMemoTable_New();\n        if (new_memo == NULL)\n            return -1;\n\n        while (PyDict_Next(obj, &i, &key, &value)) {\n            Py_ssize_t memo_id;\n            PyObject *memo_obj;\n\n            if (!PyTuple_Check(value) || PyTuple_GET_SIZE(value) != 2) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"'memo' values must be 2-item tuples\");\n                goto error;\n            }\n            memo_id = PyLong_AsSsize_t(PyTuple_GET_ITEM(value, 0));\n            if (memo_id == -1 && PyErr_Occurred())\n                goto error;\n            memo_obj = PyTuple_GET_ITEM(value, 1);\n            if (PyMemoTable_Set(new_memo, memo_obj, memo_id) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"'memo' attribute must be a PicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(obj)->tp_name);\n        return -1;\n    }\n\n    PyMemoTable_Del(self->memo);\n    self->memo = new_memo;\n\n    return 0;\n\n  error:\n    if (new_memo)\n        PyMemoTable_Del(new_memo);\n    return -1;\n}\n\nstatic PyObject *\nPickler_get_persid(PicklerObject *self)\n{\n    if (self->pers_func == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"persistent_id\");\n        return NULL;\n    }\n    return reconstruct_method(self->pers_func, self->pers_func_self);\n}\n\nstatic int\nPickler_set_persid(PicklerObject *self, PyObject *value)\n{\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n    if (!PyCallable_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"persistent_id must be a callable taking one argument\");\n        return -1;\n    }\n\n    self->pers_func_self = NULL;\n    Py_INCREF(value);\n    Py_XSETREF(self->pers_func, value);\n\n    return 0;\n}\n\nstatic PyMemberDef Pickler_members[] = {\n    {\"bin\", T_INT, offsetof(PicklerObject, bin)},\n    {\"fast\", T_INT, offsetof(PicklerObject, fast)},\n    {\"dispatch_table\", T_OBJECT_EX, offsetof(PicklerObject, dispatch_table)},\n    {NULL}\n};\n\nstatic PyGetSetDef Pickler_getsets[] = {\n    {\"memo\",          (getter)Pickler_get_memo,\n                      (setter)Pickler_set_memo},\n    {\"persistent_id\", (getter)Pickler_get_persid,\n                      (setter)Pickler_set_persid},\n    {NULL}\n};\n\nstatic PyTypeObject Pickler_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.Pickler\"  ,                /*tp_name*/\n    sizeof(PicklerObject),              /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    (destructor)Pickler_dealloc,        /*tp_dealloc*/\n    0,                                  /*tp_print*/\n    0,                                  /*tp_getattr*/\n    0,                                  /*tp_setattr*/\n    0,                                  /*tp_reserved*/\n    0,                                  /*tp_repr*/\n    0,                                  /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    0,                                  /*tp_hash*/\n    0,                                  /*tp_call*/\n    0,                                  /*tp_str*/\n    0,                                  /*tp_getattro*/\n    0,                                  /*tp_setattro*/\n    0,                                  /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n    _pickle_Pickler___init____doc__,    /*tp_doc*/\n    (traverseproc)Pickler_traverse,     /*tp_traverse*/\n    (inquiry)Pickler_clear,             /*tp_clear*/\n    0,                                  /*tp_richcompare*/\n    0,                                  /*tp_weaklistoffset*/\n    0,                                  /*tp_iter*/\n    0,                                  /*tp_iternext*/\n    Pickler_methods,                    /*tp_methods*/\n    Pickler_members,                    /*tp_members*/\n    Pickler_getsets,                    /*tp_getset*/\n    0,                                  /*tp_base*/\n    0,                                  /*tp_dict*/\n    0,                                  /*tp_descr_get*/\n    0,                                  /*tp_descr_set*/\n    0,                                  /*tp_dictoffset*/\n    _pickle_Pickler___init__,           /*tp_init*/\n    PyType_GenericAlloc,                /*tp_alloc*/\n    PyType_GenericNew,                  /*tp_new*/\n    PyObject_GC_Del,                    /*tp_free*/\n    0,                                  /*tp_is_gc*/\n};\n\n/* Temporary helper for calling self.find_class().\n\n   XXX: It would be nice to able to avoid Python function call overhead, by\n   using directly the C version of find_class(), when find_class() is not\n   overridden by a subclass. Although, this could become rather hackish. A\n   simpler optimization would be to call the C function when self is not a\n   subclass instance. */\nstatic PyObject *\nfind_class(UnpicklerObject *self, PyObject *module_name, PyObject *global_name)\n{\n    _Py_IDENTIFIER(find_class);\n\n    return _PyObject_CallMethodIdObjArgs((PyObject *)self, &PyId_find_class,\n                                         module_name, global_name, NULL);\n}\n\nstatic Py_ssize_t\nmarker(UnpicklerObject *self)\n{\n    Py_ssize_t mark;\n\n    if (self->num_marks < 1) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError, \"could not find MARK\");\n        return -1;\n    }\n\n    mark = self->marks[--self->num_marks];\n    self->stack->mark_set = self->num_marks != 0;\n    self->stack->fence = self->num_marks ?\n            self->marks[self->num_marks - 1] : 0;\n    return mark;\n}\n\nstatic int\nload_none(UnpicklerObject *self)\n{\n    PDATA_APPEND(self->stack, Py_None, -1);\n    return 0;\n}\n\nstatic int\nload_int(UnpicklerObject *self)\n{\n    PyObject *value;\n    char *endptr, *s;\n    Py_ssize_t len;\n    long x;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    errno = 0;\n    /* XXX: Should the base argument of strtol() be explicitly set to 10?\n       XXX(avassalotti): Should this uses PyOS_strtol()? */\n    x = strtol(s, &endptr, 0);\n\n    if (errno || (*endptr != '\\n' && *endptr != '\\0')) {\n        /* Hm, maybe we've got something long.  Let's try reading\n         * it as a Python int object. */\n        errno = 0;\n        /* XXX: Same thing about the base here. */\n        value = PyLong_FromString(s, NULL, 0);\n        if (value == NULL) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"could not convert string to int\");\n            return -1;\n        }\n    }\n    else {\n        if (len == 3 && (x == 0 || x == 1)) {\n            if ((value = PyBool_FromLong(x)) == NULL)\n                return -1;\n        }\n        else {\n            if ((value = PyLong_FromLong(x)) == NULL)\n                return -1;\n        }\n    }\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_bool(UnpicklerObject *self, PyObject *boolean)\n{\n    assert(boolean == Py_True || boolean == Py_False);\n    PDATA_APPEND(self->stack, boolean, -1);\n    return 0;\n}\n\n/* s contains x bytes of an unsigned little-endian integer.  Return its value\n * as a C Py_ssize_t, or -1 if it's higher than PY_SSIZE_T_MAX.\n */\nstatic Py_ssize_t\ncalc_binsize(char *bytes, int nbytes)\n{\n    unsigned char *s = (unsigned char *)bytes;\n    int i;\n    size_t x = 0;\n\n    if (nbytes > (int)sizeof(size_t)) {\n        /* Check for integer overflow.  BINBYTES8 and BINUNICODE8 opcodes\n         * have 64-bit size that can't be represented on 32-bit platform.\n         */\n        for (i = (int)sizeof(size_t); i < nbytes; i++) {\n            if (s[i])\n                return -1;\n        }\n        nbytes = (int)sizeof(size_t);\n    }\n    for (i = 0; i < nbytes; i++) {\n        x |= (size_t) s[i] << (8 * i);\n    }\n\n    if (x > PY_SSIZE_T_MAX)\n        return -1;\n    else\n        return (Py_ssize_t) x;\n}\n\n/* s contains x bytes of a little-endian integer.  Return its value as a\n * C int.  Obscure:  when x is 1 or 2, this is an unsigned little-endian\n * int, but when x is 4 it's a signed one.  This is a historical source\n * of x-platform bugs.\n */\nstatic long\ncalc_binint(char *bytes, int nbytes)\n{\n    unsigned char *s = (unsigned char *)bytes;\n    Py_ssize_t i;\n    long x = 0;\n\n    for (i = 0; i < nbytes; i++) {\n        x |= (long)s[i] << (8 * i);\n    }\n\n    /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)\n     * is signed, so on a box with longs bigger than 4 bytes we need\n     * to extend a BININT's sign bit to the full width.\n     */\n    if (SIZEOF_LONG > 4 && nbytes == 4) {\n        x |= -(x & (1L << 31));\n    }\n\n    return x;\n}\n\nstatic int\nload_binintx(UnpicklerObject *self, char *s, int size)\n{\n    PyObject *value;\n    long x;\n\n    x = calc_binint(s, size);\n\n    if ((value = PyLong_FromLong(x)) == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_binint(UnpicklerObject *self)\n{\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 4) < 0)\n        return -1;\n\n    return load_binintx(self, s, 4);\n}\n\nstatic int\nload_binint1(UnpicklerObject *self)\n{\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 1) < 0)\n        return -1;\n\n    return load_binintx(self, s, 1);\n}\n\nstatic int\nload_binint2(UnpicklerObject *self)\n{\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 2) < 0)\n        return -1;\n\n    return load_binintx(self, s, 2);\n}\n\nstatic int\nload_long(UnpicklerObject *self)\n{\n    PyObject *value;\n    char *s = NULL;\n    Py_ssize_t len;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    /* s[len-2] will usually be 'L' (and s[len-1] is '\\n'); we need to remove\n       the 'L' before calling PyLong_FromString.  In order to maintain\n       compatibility with Python 3.0.0, we don't actually *require*\n       the 'L' to be present. */\n    if (s[len-2] == 'L')\n        s[len-2] = '\\0';\n    /* XXX: Should the base argument explicitly set to 10? */\n    value = PyLong_FromString(s, NULL, 0);\n    if (value == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\n/* 'size' bytes contain the # of bytes of little-endian 256's-complement\n * data following.\n */\nstatic int\nload_counted_long(UnpicklerObject *self, int size)\n{\n    PyObject *value;\n    char *nbytes;\n    char *pdata;\n\n    assert(size == 1 || size == 4);\n    if (_Unpickler_Read(self, &nbytes, size) < 0)\n        return -1;\n\n    size = calc_binint(nbytes, size);\n    if (size < 0) {\n        PickleState *st = _Pickle_GetGlobalState();\n        /* Corrupt or hostile pickle -- we never write one like this */\n        PyErr_SetString(st->UnpicklingError,\n                        \"LONG pickle has negative byte count\");\n        return -1;\n    }\n\n    if (size == 0)\n        value = PyLong_FromLong(0L);\n    else {\n        /* Read the raw little-endian bytes and convert. */\n        if (_Unpickler_Read(self, &pdata, size) < 0)\n            return -1;\n        value = _PyLong_FromByteArray((unsigned char *)pdata, (size_t)size,\n                                      1 /* little endian */ , 1 /* signed */ );\n    }\n    if (value == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_float(UnpicklerObject *self)\n{\n    PyObject *value;\n    char *endptr, *s;\n    Py_ssize_t len;\n    double d;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    errno = 0;\n    d = PyOS_string_to_double(s, &endptr, PyExc_OverflowError);\n    if (d == -1.0 && PyErr_Occurred())\n        return -1;\n    if ((endptr[0] != '\\n') && (endptr[0] != '\\0')) {\n        PyErr_SetString(PyExc_ValueError, \"could not convert string to float\");\n        return -1;\n    }\n    value = PyFloat_FromDouble(d);\n    if (value == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_binfloat(UnpicklerObject *self)\n{\n    PyObject *value;\n    double x;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 8) < 0)\n        return -1;\n\n    x = _PyFloat_Unpack8((unsigned char *)s, 0);\n    if (x == -1.0 && PyErr_Occurred())\n        return -1;\n\n    if ((value = PyFloat_FromDouble(x)) == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_string(UnpicklerObject *self)\n{\n    PyObject *bytes;\n    PyObject *obj;\n    Py_ssize_t len;\n    char *s, *p;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    /* Strip the newline */\n    len--;\n    /* Strip outermost quotes */\n    if (len >= 2 && s[0] == s[len - 1] && (s[0] == '\\'' || s[0] == '\"')) {\n        p = s + 1;\n        len -= 2;\n    }\n    else {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError,\n                        \"the STRING opcode argument must be quoted\");\n        return -1;\n    }\n    assert(len >= 0);\n\n    /* Use the PyBytes API to decode the string, since that is what is used\n       to encode, and then coerce the result to Unicode. */\n    bytes = PyBytes_DecodeEscape(p, len, NULL, 0, NULL);\n    if (bytes == NULL)\n        return -1;\n\n    /* Leave the Python 2.x strings as bytes if the *encoding* given to the\n       Unpickler was 'bytes'. Otherwise, convert them to unicode. */\n    if (strcmp(self->encoding, \"bytes\") == 0) {\n        obj = bytes;\n    }\n    else {\n        obj = PyUnicode_FromEncodedObject(bytes, self->encoding, self->errors);\n        Py_DECREF(bytes);\n        if (obj == NULL) {\n            return -1;\n        }\n    }\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_counted_binstring(UnpicklerObject *self, int nbytes)\n{\n    PyObject *obj;\n    Py_ssize_t size;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, nbytes) < 0)\n        return -1;\n\n    size = calc_binsize(s, nbytes);\n    if (size < 0) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_Format(st->UnpicklingError,\n                     \"BINSTRING exceeds system's maximum size of %zd bytes\",\n                     PY_SSIZE_T_MAX);\n        return -1;\n    }\n\n    if (_Unpickler_Read(self, &s, size) < 0)\n        return -1;\n\n    /* Convert Python 2.x strings to bytes if the *encoding* given to the\n       Unpickler was 'bytes'. Otherwise, convert them to unicode. */\n    if (strcmp(self->encoding, \"bytes\") == 0) {\n        obj = PyBytes_FromStringAndSize(s, size);\n    }\n    else {\n        obj = PyUnicode_Decode(s, size, self->encoding, self->errors);\n    }\n    if (obj == NULL) {\n        return -1;\n    }\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_counted_binbytes(UnpicklerObject *self, int nbytes)\n{\n    PyObject *bytes;\n    Py_ssize_t size;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, nbytes) < 0)\n        return -1;\n\n    size = calc_binsize(s, nbytes);\n    if (size < 0) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"BINBYTES exceeds system's maximum size of %zd bytes\",\n                     PY_SSIZE_T_MAX);\n        return -1;\n    }\n\n    if (_Unpickler_Read(self, &s, size) < 0)\n        return -1;\n\n    bytes = PyBytes_FromStringAndSize(s, size);\n    if (bytes == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, bytes, -1);\n    return 0;\n}\n\nstatic int\nload_unicode(UnpicklerObject *self)\n{\n    PyObject *str;\n    Py_ssize_t len;\n    char *s = NULL;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 1)\n        return bad_readline();\n\n    str = PyUnicode_DecodeRawUnicodeEscape(s, len - 1, NULL);\n    if (str == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, str, -1);\n    return 0;\n}\n\nstatic int\nload_counted_binunicode(UnpicklerObject *self, int nbytes)\n{\n    PyObject *str;\n    Py_ssize_t size;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, nbytes) < 0)\n        return -1;\n\n    size = calc_binsize(s, nbytes);\n    if (size < 0) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"BINUNICODE exceeds system's maximum size of %zd bytes\",\n                     PY_SSIZE_T_MAX);\n        return -1;\n    }\n\n    if (_Unpickler_Read(self, &s, size) < 0)\n        return -1;\n\n    str = PyUnicode_DecodeUTF8(s, size, \"surrogatepass\");\n    if (str == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, str, -1);\n    return 0;\n}\n\nstatic int\nload_counted_tuple(UnpicklerObject *self, Py_ssize_t len)\n{\n    PyObject *tuple;\n\n    if (Py_SIZE(self->stack) < len)\n        return Pdata_stack_underflow(self->stack);\n\n    tuple = Pdata_poptuple(self->stack, Py_SIZE(self->stack) - len);\n    if (tuple == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, tuple, -1);\n    return 0;\n}\n\nstatic int\nload_tuple(UnpicklerObject *self)\n{\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    return load_counted_tuple(self, Py_SIZE(self->stack) - i);\n}\n\nstatic int\nload_empty_list(UnpicklerObject *self)\n{\n    PyObject *list;\n\n    if ((list = PyList_New(0)) == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, list, -1);\n    return 0;\n}\n\nstatic int\nload_empty_dict(UnpicklerObject *self)\n{\n    PyObject *dict;\n\n    if ((dict = PyDict_New()) == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, dict, -1);\n    return 0;\n}\n\nstatic int\nload_empty_set(UnpicklerObject *self)\n{\n    PyObject *set;\n\n    if ((set = PySet_New(NULL)) == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, set, -1);\n    return 0;\n}\n\nstatic int\nload_list(UnpicklerObject *self)\n{\n    PyObject *list;\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    list = Pdata_poplist(self->stack, i);\n    if (list == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, list, -1);\n    return 0;\n}\n\nstatic int\nload_dict(UnpicklerObject *self)\n{\n    PyObject *dict, *key, *value;\n    Py_ssize_t i, j, k;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n    j = Py_SIZE(self->stack);\n\n    if ((dict = PyDict_New()) == NULL)\n        return -1;\n\n    if ((j - i) % 2 != 0) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError, \"odd number of items for DICT\");\n        Py_DECREF(dict);\n        return -1;\n    }\n\n    for (k = i + 1; k < j; k += 2) {\n        key = self->stack->data[k - 1];\n        value = self->stack->data[k];\n        if (PyDict_SetItem(dict, key, value) < 0) {\n            Py_DECREF(dict);\n            return -1;\n        }\n    }\n    Pdata_clear(self->stack, i);\n    PDATA_PUSH(self->stack, dict, -1);\n    return 0;\n}\n\nstatic int\nload_frozenset(UnpicklerObject *self)\n{\n    PyObject *items;\n    PyObject *frozenset;\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    items = Pdata_poptuple(self->stack, i);\n    if (items == NULL)\n        return -1;\n\n    frozenset = PyFrozenSet_New(items);\n    Py_DECREF(items);\n    if (frozenset == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, frozenset, -1);\n    return 0;\n}\n\nstatic PyObject *\ninstantiate(PyObject *cls, PyObject *args)\n{\n    /* Caller must assure args are a tuple.  Normally, args come from\n       Pdata_poptuple which packs objects from the top of the stack\n       into a newly created tuple. */\n    assert(PyTuple_Check(args));\n    if (!PyTuple_GET_SIZE(args) && PyType_Check(cls)) {\n        _Py_IDENTIFIER(__getinitargs__);\n        _Py_IDENTIFIER(__new__);\n        PyObject *func;\n        if (_PyObject_LookupAttrId(cls, &PyId___getinitargs__, &func) < 0) {\n            return NULL;\n        }\n        if (func == NULL) {\n            return _PyObject_CallMethodIdObjArgs(cls, &PyId___new__, cls, NULL);\n        }\n        Py_DECREF(func);\n    }\n    return PyObject_CallObject(cls, args);\n}\n\nstatic int\nload_obj(UnpicklerObject *self)\n{\n    PyObject *cls, *args, *obj = NULL;\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    if (Py_SIZE(self->stack) - i < 1)\n        return Pdata_stack_underflow(self->stack);\n\n    args = Pdata_poptuple(self->stack, i + 1);\n    if (args == NULL)\n        return -1;\n\n    PDATA_POP(self->stack, cls);\n    if (cls) {\n        obj = instantiate(cls, args);\n        Py_DECREF(cls);\n    }\n    Py_DECREF(args);\n    if (obj == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_inst(UnpicklerObject *self)\n{\n    PyObject *cls = NULL;\n    PyObject *args = NULL;\n    PyObject *obj = NULL;\n    PyObject *module_name;\n    PyObject *class_name;\n    Py_ssize_t len;\n    Py_ssize_t i;\n    char *s;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    /* Here it is safe to use PyUnicode_DecodeASCII(), even though non-ASCII\n       identifiers are permitted in Python 3.0, since the INST opcode is only\n       supported by older protocols on Python 2.x. */\n    module_name = PyUnicode_DecodeASCII(s, len - 1, \"strict\");\n    if (module_name == NULL)\n        return -1;\n\n    if ((len = _Unpickler_Readline(self, &s)) >= 0) {\n        if (len < 2) {\n            Py_DECREF(module_name);\n            return bad_readline();\n        }\n        class_name = PyUnicode_DecodeASCII(s, len - 1, \"strict\");\n        if (class_name != NULL) {\n            cls = find_class(self, module_name, class_name);\n            Py_DECREF(class_name);\n        }\n    }\n    Py_DECREF(module_name);\n\n    if (cls == NULL)\n        return -1;\n\n    if ((args = Pdata_poptuple(self->stack, i)) != NULL) {\n        obj = instantiate(cls, args);\n        Py_DECREF(args);\n    }\n    Py_DECREF(cls);\n\n    if (obj == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_newobj(UnpicklerObject *self)\n{\n    PyObject *args = NULL;\n    PyObject *clsraw = NULL;\n    PyTypeObject *cls;          /* clsraw cast to its true type */\n    PyObject *obj;\n    PickleState *st = _Pickle_GetGlobalState();\n\n    /* Stack is ... cls argtuple, and we want to call\n     * cls.__new__(cls, *argtuple).\n     */\n    PDATA_POP(self->stack, args);\n    if (args == NULL)\n        goto error;\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(st->UnpicklingError,\n                        \"NEWOBJ expected an arg \" \"tuple.\");\n        goto error;\n    }\n\n    PDATA_POP(self->stack, clsraw);\n    cls = (PyTypeObject *)clsraw;\n    if (cls == NULL)\n        goto error;\n    if (!PyType_Check(cls)) {\n        PyErr_SetString(st->UnpicklingError, \"NEWOBJ class argument \"\n                        \"isn't a type object\");\n        goto error;\n    }\n    if (cls->tp_new == NULL) {\n        PyErr_SetString(st->UnpicklingError, \"NEWOBJ class argument \"\n                        \"has NULL tp_new\");\n        goto error;\n    }\n\n    /* Call __new__. */\n    obj = cls->tp_new(cls, args, NULL);\n    if (obj == NULL)\n        goto error;\n\n    Py_DECREF(args);\n    Py_DECREF(clsraw);\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n\n  error:\n    Py_XDECREF(args);\n    Py_XDECREF(clsraw);\n    return -1;\n}\n\nstatic int\nload_newobj_ex(UnpicklerObject *self)\n{\n    PyObject *cls, *args, *kwargs;\n    PyObject *obj;\n    PickleState *st = _Pickle_GetGlobalState();\n\n    PDATA_POP(self->stack, kwargs);\n    if (kwargs == NULL) {\n        return -1;\n    }\n    PDATA_POP(self->stack, args);\n    if (args == NULL) {\n        Py_DECREF(kwargs);\n        return -1;\n    }\n    PDATA_POP(self->stack, cls);\n    if (cls == NULL) {\n        Py_DECREF(kwargs);\n        Py_DECREF(args);\n        return -1;\n    }\n\n    if (!PyType_Check(cls)) {\n        Py_DECREF(kwargs);\n        Py_DECREF(args);\n        PyErr_Format(st->UnpicklingError,\n                     \"NEWOBJ_EX class argument must be a type, not %.200s\",\n                     Py_TYPE(cls)->tp_name);\n        Py_DECREF(cls);\n        return -1;\n    }\n\n    if (((PyTypeObject *)cls)->tp_new == NULL) {\n        Py_DECREF(kwargs);\n        Py_DECREF(args);\n        Py_DECREF(cls);\n        PyErr_SetString(st->UnpicklingError,\n                        \"NEWOBJ_EX class argument doesn't have __new__\");\n        return -1;\n    }\n    obj = ((PyTypeObject *)cls)->tp_new((PyTypeObject *)cls, args, kwargs);\n    Py_DECREF(kwargs);\n    Py_DECREF(args);\n    Py_DECREF(cls);\n    if (obj == NULL) {\n        return -1;\n    }\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_global(UnpicklerObject *self)\n{\n    PyObject *global = NULL;\n    PyObject *module_name;\n    PyObject *global_name;\n    Py_ssize_t len;\n    char *s;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n    module_name = PyUnicode_DecodeUTF8(s, len - 1, \"strict\");\n    if (!module_name)\n        return -1;\n\n    if ((len = _Unpickler_Readline(self, &s)) >= 0) {\n        if (len < 2) {\n            Py_DECREF(module_name);\n            return bad_readline();\n        }\n        global_name = PyUnicode_DecodeUTF8(s, len - 1, \"strict\");\n        if (global_name) {\n            global = find_class(self, module_name, global_name);\n            Py_DECREF(global_name);\n        }\n    }\n    Py_DECREF(module_name);\n\n    if (global == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, global, -1);\n    return 0;\n}\n\nstatic int\nload_stack_global(UnpicklerObject *self)\n{\n    PyObject *global;\n    PyObject *module_name;\n    PyObject *global_name;\n\n    PDATA_POP(self->stack, global_name);\n    PDATA_POP(self->stack, module_name);\n    if (module_name == NULL || !PyUnicode_CheckExact(module_name) ||\n        global_name == NULL || !PyUnicode_CheckExact(global_name)) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError, \"STACK_GLOBAL requires str\");\n        Py_XDECREF(global_name);\n        Py_XDECREF(module_name);\n        return -1;\n    }\n    global = find_class(self, module_name, global_name);\n    Py_DECREF(global_name);\n    Py_DECREF(module_name);\n    if (global == NULL)\n        return -1;\n    PDATA_PUSH(self->stack, global, -1);\n    return 0;\n}\n\nstatic int\nload_persid(UnpicklerObject *self)\n{\n    PyObject *pid, *obj;\n    Py_ssize_t len;\n    char *s;\n\n    if (self->pers_func) {\n        if ((len = _Unpickler_Readline(self, &s)) < 0)\n            return -1;\n        if (len < 1)\n            return bad_readline();\n\n        pid = PyUnicode_DecodeASCII(s, len - 1, \"strict\");\n        if (pid == NULL) {\n            if (PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {\n                PyErr_SetString(_Pickle_GetGlobalState()->UnpicklingError,\n                                \"persistent IDs in protocol 0 must be \"\n                                \"ASCII strings\");\n            }\n            return -1;\n        }\n\n        obj = call_method(self->pers_func, self->pers_func_self, pid);\n        Py_DECREF(pid);\n        if (obj == NULL)\n            return -1;\n\n        PDATA_PUSH(self->stack, obj, -1);\n        return 0;\n    }\n    else {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError,\n                        \"A load persistent id instruction was encountered,\\n\"\n                        \"but no persistent_load function was specified.\");\n        return -1;\n    }\n}\n\nstatic int\nload_binpersid(UnpicklerObject *self)\n{\n    PyObject *pid, *obj;\n\n    if (self->pers_func) {\n        PDATA_POP(self->stack, pid);\n        if (pid == NULL)\n            return -1;\n\n        obj = call_method(self->pers_func, self->pers_func_self, pid);\n        Py_DECREF(pid);\n        if (obj == NULL)\n            return -1;\n\n        PDATA_PUSH(self->stack, obj, -1);\n        return 0;\n    }\n    else {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_SetString(st->UnpicklingError,\n                        \"A load persistent id instruction was encountered,\\n\"\n                        \"but no persistent_load function was specified.\");\n        return -1;\n    }\n}\n\nstatic int\nload_pop(UnpicklerObject *self)\n{\n    Py_ssize_t len = Py_SIZE(self->stack);\n\n    /* Note that we split the (pickle.py) stack into two stacks,\n     * an object stack and a mark stack. We have to be clever and\n     * pop the right one. We do this by looking at the top of the\n     * mark stack first, and only signalling a stack underflow if\n     * the object stack is empty and the mark stack doesn't match\n     * our expectations.\n     */\n    if (self->num_marks > 0 && self->marks[self->num_marks - 1] == len) {\n        self->num_marks--;\n        self->stack->mark_set = self->num_marks != 0;\n        self->stack->fence = self->num_marks ?\n                self->marks[self->num_marks - 1] : 0;\n    } else if (len <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    else {\n        len--;\n        Py_DECREF(self->stack->data[len]);\n        Py_SIZE(self->stack) = len;\n    }\n    return 0;\n}\n\nstatic int\nload_pop_mark(UnpicklerObject *self)\n{\n    Py_ssize_t i;\n\n    if ((i = marker(self)) < 0)\n        return -1;\n\n    Pdata_clear(self->stack, i);\n\n    return 0;\n}\n\nstatic int\nload_dup(UnpicklerObject *self)\n{\n    PyObject *last;\n    Py_ssize_t len = Py_SIZE(self->stack);\n\n    if (len <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    last = self->stack->data[len - 1];\n    PDATA_APPEND(self->stack, last, -1);\n    return 0;\n}\n\nstatic int\nload_get(UnpicklerObject *self)\n{\n    PyObject *key, *value;\n    Py_ssize_t idx;\n    Py_ssize_t len;\n    char *s;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n\n    key = PyLong_FromString(s, NULL, 10);\n    if (key == NULL)\n        return -1;\n    idx = PyLong_AsSsize_t(key);\n    if (idx == -1 && PyErr_Occurred()) {\n        Py_DECREF(key);\n        return -1;\n    }\n\n    value = _Unpickler_MemoGet(self, idx);\n    if (value == NULL) {\n        if (!PyErr_Occurred())\n            PyErr_SetObject(PyExc_KeyError, key);\n        Py_DECREF(key);\n        return -1;\n    }\n    Py_DECREF(key);\n\n    PDATA_APPEND(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_binget(UnpicklerObject *self)\n{\n    PyObject *value;\n    Py_ssize_t idx;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 1) < 0)\n        return -1;\n\n    idx = Py_CHARMASK(s[0]);\n\n    value = _Unpickler_MemoGet(self, idx);\n    if (value == NULL) {\n        PyObject *key = PyLong_FromSsize_t(idx);\n        if (key != NULL) {\n            PyErr_SetObject(PyExc_KeyError, key);\n            Py_DECREF(key);\n        }\n        return -1;\n    }\n\n    PDATA_APPEND(self->stack, value, -1);\n    return 0;\n}\n\nstatic int\nload_long_binget(UnpicklerObject *self)\n{\n    PyObject *value;\n    Py_ssize_t idx;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 4) < 0)\n        return -1;\n\n    idx = calc_binsize(s, 4);\n\n    value = _Unpickler_MemoGet(self, idx);\n    if (value == NULL) {\n        PyObject *key = PyLong_FromSsize_t(idx);\n        if (key != NULL) {\n            PyErr_SetObject(PyExc_KeyError, key);\n            Py_DECREF(key);\n        }\n        return -1;\n    }\n\n    PDATA_APPEND(self->stack, value, -1);\n    return 0;\n}\n\n/* Push an object from the extension registry (EXT[124]).  nbytes is\n * the number of bytes following the opcode, holding the index (code) value.\n */\nstatic int\nload_extension(UnpicklerObject *self, int nbytes)\n{\n    char *codebytes;            /* the nbytes bytes after the opcode */\n    long code;                  /* calc_binint returns long */\n    PyObject *py_code;          /* code as a Python int */\n    PyObject *obj;              /* the object to push */\n    PyObject *pair;             /* (module_name, class_name) */\n    PyObject *module_name, *class_name;\n    PickleState *st = _Pickle_GetGlobalState();\n\n    assert(nbytes == 1 || nbytes == 2 || nbytes == 4);\n    if (_Unpickler_Read(self, &codebytes, nbytes) < 0)\n        return -1;\n    code = calc_binint(codebytes, nbytes);\n    if (code <= 0) {            /* note that 0 is forbidden */\n        /* Corrupt or hostile pickle. */\n        PyErr_SetString(st->UnpicklingError, \"EXT specifies code <= 0\");\n        return -1;\n    }\n\n    /* Look for the code in the cache. */\n    py_code = PyLong_FromLong(code);\n    if (py_code == NULL)\n        return -1;\n    obj = PyDict_GetItemWithError(st->extension_cache, py_code);\n    if (obj != NULL) {\n        /* Bingo. */\n        Py_DECREF(py_code);\n        PDATA_APPEND(self->stack, obj, -1);\n        return 0;\n    }\n    if (PyErr_Occurred()) {\n        Py_DECREF(py_code);\n        return -1;\n    }\n\n    /* Look up the (module_name, class_name) pair. */\n    pair = PyDict_GetItemWithError(st->inverted_registry, py_code);\n    if (pair == NULL) {\n        Py_DECREF(py_code);\n        if (!PyErr_Occurred()) {\n            PyErr_Format(PyExc_ValueError, \"unregistered extension \"\n                         \"code %ld\", code);\n        }\n        return -1;\n    }\n    /* Since the extension registry is manipulable via Python code,\n     * confirm that pair is really a 2-tuple of strings.\n     */\n    if (!PyTuple_Check(pair) || PyTuple_Size(pair) != 2 ||\n        !PyUnicode_Check(module_name = PyTuple_GET_ITEM(pair, 0)) ||\n        !PyUnicode_Check(class_name = PyTuple_GET_ITEM(pair, 1))) {\n        Py_DECREF(py_code);\n        PyErr_Format(PyExc_ValueError, \"_inverted_registry[%ld] \"\n                     \"isn't a 2-tuple of strings\", code);\n        return -1;\n    }\n    /* Load the object. */\n    obj = find_class(self, module_name, class_name);\n    if (obj == NULL) {\n        Py_DECREF(py_code);\n        return -1;\n    }\n    /* Cache code -> obj. */\n    code = PyDict_SetItem(st->extension_cache, py_code, obj);\n    Py_DECREF(py_code);\n    if (code < 0) {\n        Py_DECREF(obj);\n        return -1;\n    }\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\nstatic int\nload_put(UnpicklerObject *self)\n{\n    PyObject *key, *value;\n    Py_ssize_t idx;\n    Py_ssize_t len;\n    char *s = NULL;\n\n    if ((len = _Unpickler_Readline(self, &s)) < 0)\n        return -1;\n    if (len < 2)\n        return bad_readline();\n    if (Py_SIZE(self->stack) <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    value = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    key = PyLong_FromString(s, NULL, 10);\n    if (key == NULL)\n        return -1;\n    idx = PyLong_AsSsize_t(key);\n    Py_DECREF(key);\n    if (idx < 0) {\n        if (!PyErr_Occurred())\n            PyErr_SetString(PyExc_ValueError,\n                            \"negative PUT argument\");\n        return -1;\n    }\n\n    return _Unpickler_MemoPut(self, idx, value);\n}\n\nstatic int\nload_binput(UnpicklerObject *self)\n{\n    PyObject *value;\n    Py_ssize_t idx;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 1) < 0)\n        return -1;\n\n    if (Py_SIZE(self->stack) <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    value = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    idx = Py_CHARMASK(s[0]);\n\n    return _Unpickler_MemoPut(self, idx, value);\n}\n\nstatic int\nload_long_binput(UnpicklerObject *self)\n{\n    PyObject *value;\n    Py_ssize_t idx;\n    char *s;\n\n    if (_Unpickler_Read(self, &s, 4) < 0)\n        return -1;\n\n    if (Py_SIZE(self->stack) <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    value = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    idx = calc_binsize(s, 4);\n    if (idx < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"negative LONG_BINPUT argument\");\n        return -1;\n    }\n\n    return _Unpickler_MemoPut(self, idx, value);\n}\n\nstatic int\nload_memoize(UnpicklerObject *self)\n{\n    PyObject *value;\n\n    if (Py_SIZE(self->stack) <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    value = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    return _Unpickler_MemoPut(self, self->memo_len, value);\n}\n\nstatic int\ndo_append(UnpicklerObject *self, Py_ssize_t x)\n{\n    PyObject *value;\n    PyObject *slice;\n    PyObject *list;\n    PyObject *result;\n    Py_ssize_t len, i;\n\n    len = Py_SIZE(self->stack);\n    if (x > len || x <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    if (len == x)  /* nothing to do */\n        return 0;\n\n    list = self->stack->data[x - 1];\n\n    if (PyList_CheckExact(list)) {\n        Py_ssize_t list_len;\n        int ret;\n\n        slice = Pdata_poplist(self->stack, x);\n        if (!slice)\n            return -1;\n        list_len = PyList_GET_SIZE(list);\n        ret = PyList_SetSlice(list, list_len, list_len, slice);\n        Py_DECREF(slice);\n        return ret;\n    }\n    else {\n        PyObject *extend_func;\n        _Py_IDENTIFIER(extend);\n\n        extend_func = _PyObject_GetAttrId(list, &PyId_extend);\n        if (extend_func != NULL) {\n            slice = Pdata_poplist(self->stack, x);\n            if (!slice) {\n                Py_DECREF(extend_func);\n                return -1;\n            }\n            result = _Pickle_FastCall(extend_func, slice);\n            Py_DECREF(extend_func);\n            if (result == NULL)\n                return -1;\n            Py_DECREF(result);\n        }\n        else {\n            PyObject *append_func;\n            _Py_IDENTIFIER(append);\n\n            /* Even if the PEP 307 requires extend() and append() methods,\n               fall back on append() if the object has no extend() method\n               for backward compatibility. */\n            PyErr_Clear();\n            append_func = _PyObject_GetAttrId(list, &PyId_append);\n            if (append_func == NULL)\n                return -1;\n            for (i = x; i < len; i++) {\n                value = self->stack->data[i];\n                result = _Pickle_FastCall(append_func, value);\n                if (result == NULL) {\n                    Pdata_clear(self->stack, i + 1);\n                    Py_SIZE(self->stack) = x;\n                    Py_DECREF(append_func);\n                    return -1;\n                }\n                Py_DECREF(result);\n            }\n            Py_SIZE(self->stack) = x;\n            Py_DECREF(append_func);\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nload_append(UnpicklerObject *self)\n{\n    if (Py_SIZE(self->stack) - 1 <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    return do_append(self, Py_SIZE(self->stack) - 1);\n}\n\nstatic int\nload_appends(UnpicklerObject *self)\n{\n    Py_ssize_t i = marker(self);\n    if (i < 0)\n        return -1;\n    return do_append(self, i);\n}\n\nstatic int\ndo_setitems(UnpicklerObject *self, Py_ssize_t x)\n{\n    PyObject *value, *key;\n    PyObject *dict;\n    Py_ssize_t len, i;\n    int status = 0;\n\n    len = Py_SIZE(self->stack);\n    if (x > len || x <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    if (len == x)  /* nothing to do */\n        return 0;\n    if ((len - x) % 2 != 0) {\n        PickleState *st = _Pickle_GetGlobalState();\n        /* Currupt or hostile pickle -- we never write one like this. */\n        PyErr_SetString(st->UnpicklingError,\n                        \"odd number of items for SETITEMS\");\n        return -1;\n    }\n\n    /* Here, dict does not actually need to be a PyDict; it could be anything\n       that supports the __setitem__ attribute. */\n    dict = self->stack->data[x - 1];\n\n    for (i = x + 1; i < len; i += 2) {\n        key = self->stack->data[i - 1];\n        value = self->stack->data[i];\n        if (PyObject_SetItem(dict, key, value) < 0) {\n            status = -1;\n            break;\n        }\n    }\n\n    Pdata_clear(self->stack, x);\n    return status;\n}\n\nstatic int\nload_setitem(UnpicklerObject *self)\n{\n    return do_setitems(self, Py_SIZE(self->stack) - 2);\n}\n\nstatic int\nload_setitems(UnpicklerObject *self)\n{\n    Py_ssize_t i = marker(self);\n    if (i < 0)\n        return -1;\n    return do_setitems(self, i);\n}\n\nstatic int\nload_additems(UnpicklerObject *self)\n{\n    PyObject *set;\n    Py_ssize_t mark, len, i;\n\n    mark =  marker(self);\n    if (mark < 0)\n        return -1;\n    len = Py_SIZE(self->stack);\n    if (mark > len || mark <= self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n    if (len == mark)  /* nothing to do */\n        return 0;\n\n    set = self->stack->data[mark - 1];\n\n    if (PySet_Check(set)) {\n        PyObject *items;\n        int status;\n\n        items = Pdata_poptuple(self->stack, mark);\n        if (items == NULL)\n            return -1;\n\n        status = _PySet_Update(set, items);\n        Py_DECREF(items);\n        return status;\n    }\n    else {\n        PyObject *add_func;\n        _Py_IDENTIFIER(add);\n\n        add_func = _PyObject_GetAttrId(set, &PyId_add);\n        if (add_func == NULL)\n            return -1;\n        for (i = mark; i < len; i++) {\n            PyObject *result;\n            PyObject *item;\n\n            item = self->stack->data[i];\n            result = _Pickle_FastCall(add_func, item);\n            if (result == NULL) {\n                Pdata_clear(self->stack, i + 1);\n                Py_SIZE(self->stack) = mark;\n                return -1;\n            }\n            Py_DECREF(result);\n        }\n        Py_SIZE(self->stack) = mark;\n    }\n\n    return 0;\n}\n\nstatic int\nload_build(UnpicklerObject *self)\n{\n    PyObject *state, *inst, *slotstate;\n    PyObject *setstate;\n    int status = 0;\n    _Py_IDENTIFIER(__setstate__);\n\n    /* Stack is ... instance, state.  We want to leave instance at\n     * the stack top, possibly mutated via instance.__setstate__(state).\n     */\n    if (Py_SIZE(self->stack) - 2 < self->stack->fence)\n        return Pdata_stack_underflow(self->stack);\n\n    PDATA_POP(self->stack, state);\n    if (state == NULL)\n        return -1;\n\n    inst = self->stack->data[Py_SIZE(self->stack) - 1];\n\n    if (_PyObject_LookupAttrId(inst, &PyId___setstate__, &setstate) < 0) {\n        Py_DECREF(state);\n        return -1;\n    }\n    if (setstate != NULL) {\n        PyObject *result;\n\n        /* The explicit __setstate__ is responsible for everything. */\n        result = _Pickle_FastCall(setstate, state);\n        Py_DECREF(setstate);\n        if (result == NULL)\n            return -1;\n        Py_DECREF(result);\n        return 0;\n    }\n\n    /* A default __setstate__.  First see whether state embeds a\n     * slot state dict too (a proto 2 addition).\n     */\n    if (PyTuple_Check(state) && PyTuple_GET_SIZE(state) == 2) {\n        PyObject *tmp = state;\n\n        state = PyTuple_GET_ITEM(tmp, 0);\n        slotstate = PyTuple_GET_ITEM(tmp, 1);\n        Py_INCREF(state);\n        Py_INCREF(slotstate);\n        Py_DECREF(tmp);\n    }\n    else\n        slotstate = NULL;\n\n    /* Set inst.__dict__ from the state dict (if any). */\n    if (state != Py_None) {\n        PyObject *dict;\n        PyObject *d_key, *d_value;\n        Py_ssize_t i;\n        _Py_IDENTIFIER(__dict__);\n\n        if (!PyDict_Check(state)) {\n            PickleState *st = _Pickle_GetGlobalState();\n            PyErr_SetString(st->UnpicklingError, \"state is not a dictionary\");\n            goto error;\n        }\n        dict = _PyObject_GetAttrId(inst, &PyId___dict__);\n        if (dict == NULL)\n            goto error;\n\n        i = 0;\n        while (PyDict_Next(state, &i, &d_key, &d_value)) {\n            /* normally the keys for instance attributes are\n               interned.  we should try to do that here. */\n            Py_INCREF(d_key);\n            if (PyUnicode_CheckExact(d_key))\n                PyUnicode_InternInPlace(&d_key);\n            if (PyObject_SetItem(dict, d_key, d_value) < 0) {\n                Py_DECREF(d_key);\n                goto error;\n            }\n            Py_DECREF(d_key);\n        }\n        Py_DECREF(dict);\n    }\n\n    /* Also set instance attributes from the slotstate dict (if any). */\n    if (slotstate != NULL) {\n        PyObject *d_key, *d_value;\n        Py_ssize_t i;\n\n        if (!PyDict_Check(slotstate)) {\n            PickleState *st = _Pickle_GetGlobalState();\n            PyErr_SetString(st->UnpicklingError,\n                            \"slot state is not a dictionary\");\n            goto error;\n        }\n        i = 0;\n        while (PyDict_Next(slotstate, &i, &d_key, &d_value)) {\n            if (PyObject_SetAttr(inst, d_key, d_value) < 0)\n                goto error;\n        }\n    }\n\n    if (0) {\n  error:\n        status = -1;\n    }\n\n    Py_DECREF(state);\n    Py_XDECREF(slotstate);\n    return status;\n}\n\nstatic int\nload_mark(UnpicklerObject *self)\n{\n\n    /* Note that we split the (pickle.py) stack into two stacks, an\n     * object stack and a mark stack. Here we push a mark onto the\n     * mark stack.\n     */\n\n    if (self->num_marks >= self->marks_size) {\n        size_t alloc = ((size_t)self->num_marks << 1) + 20;\n        Py_ssize_t *marks_new = self->marks;\n        PyMem_RESIZE(marks_new, Py_ssize_t, alloc);\n        if (marks_new == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        self->marks = marks_new;\n        self->marks_size = (Py_ssize_t)alloc;\n    }\n\n    self->stack->mark_set = 1;\n    self->marks[self->num_marks++] = self->stack->fence = Py_SIZE(self->stack);\n\n    return 0;\n}\n\nstatic int\nload_reduce(UnpicklerObject *self)\n{\n    PyObject *callable = NULL;\n    PyObject *argtup = NULL;\n    PyObject *obj = NULL;\n\n    PDATA_POP(self->stack, argtup);\n    if (argtup == NULL)\n        return -1;\n    PDATA_POP(self->stack, callable);\n    if (callable) {\n        obj = PyObject_CallObject(callable, argtup);\n        Py_DECREF(callable);\n    }\n    Py_DECREF(argtup);\n\n    if (obj == NULL)\n        return -1;\n\n    PDATA_PUSH(self->stack, obj, -1);\n    return 0;\n}\n\n/* Just raises an error if we don't know the protocol specified.  PROTO\n * is the first opcode for protocols >= 2.\n */\nstatic int\nload_proto(UnpicklerObject *self)\n{\n    char *s;\n    int i;\n\n    if (_Unpickler_Read(self, &s, 1) < 0)\n        return -1;\n\n    i = (unsigned char)s[0];\n    if (i <= HIGHEST_PROTOCOL) {\n        self->proto = i;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_ValueError, \"unsupported pickle protocol: %d\", i);\n    return -1;\n}\n\nstatic int\nload_frame(UnpicklerObject *self)\n{\n    char *s;\n    Py_ssize_t frame_len;\n\n    if (_Unpickler_Read(self, &s, 8) < 0)\n        return -1;\n\n    frame_len = calc_binsize(s, 8);\n    if (frame_len < 0) {\n        PyErr_Format(PyExc_OverflowError,\n                     \"FRAME length exceeds system's maximum of %zd bytes\",\n                     PY_SSIZE_T_MAX);\n        return -1;\n    }\n\n    if (_Unpickler_Read(self, &s, frame_len) < 0)\n        return -1;\n\n    /* Rewind to start of frame */\n    self->next_read_idx -= frame_len;\n    return 0;\n}\n\nstatic PyObject *\nload(UnpicklerObject *self)\n{\n    PyObject *value = NULL;\n    char *s = NULL;\n\n    self->num_marks = 0;\n    self->stack->mark_set = 0;\n    self->stack->fence = 0;\n    self->proto = 0;\n    if (Py_SIZE(self->stack))\n        Pdata_clear(self->stack, 0);\n\n    /* Convenient macros for the dispatch while-switch loop just below. */\n#define OP(opcode, load_func) \\\n    case opcode: if (load_func(self) < 0) break; continue;\n\n#define OP_ARG(opcode, load_func, arg) \\\n    case opcode: if (load_func(self, (arg)) < 0) break; continue;\n\n    while (1) {\n        if (_Unpickler_Read(self, &s, 1) < 0) {\n            PickleState *st = _Pickle_GetGlobalState();\n            if (PyErr_ExceptionMatches(st->UnpicklingError)) {\n                PyErr_Format(PyExc_EOFError, \"Ran out of input\");\n            }\n            return NULL;\n        }\n\n        switch ((enum opcode)s[0]) {\n        OP(NONE, load_none)\n        OP(BININT, load_binint)\n        OP(BININT1, load_binint1)\n        OP(BININT2, load_binint2)\n        OP(INT, load_int)\n        OP(LONG, load_long)\n        OP_ARG(LONG1, load_counted_long, 1)\n        OP_ARG(LONG4, load_counted_long, 4)\n        OP(FLOAT, load_float)\n        OP(BINFLOAT, load_binfloat)\n        OP_ARG(SHORT_BINBYTES, load_counted_binbytes, 1)\n        OP_ARG(BINBYTES, load_counted_binbytes, 4)\n        OP_ARG(BINBYTES8, load_counted_binbytes, 8)\n        OP_ARG(SHORT_BINSTRING, load_counted_binstring, 1)\n        OP_ARG(BINSTRING, load_counted_binstring, 4)\n        OP(STRING, load_string)\n        OP(UNICODE, load_unicode)\n        OP_ARG(SHORT_BINUNICODE, load_counted_binunicode, 1)\n        OP_ARG(BINUNICODE, load_counted_binunicode, 4)\n        OP_ARG(BINUNICODE8, load_counted_binunicode, 8)\n        OP_ARG(EMPTY_TUPLE, load_counted_tuple, 0)\n        OP_ARG(TUPLE1, load_counted_tuple, 1)\n        OP_ARG(TUPLE2, load_counted_tuple, 2)\n        OP_ARG(TUPLE3, load_counted_tuple, 3)\n        OP(TUPLE, load_tuple)\n        OP(EMPTY_LIST, load_empty_list)\n        OP(LIST, load_list)\n        OP(EMPTY_DICT, load_empty_dict)\n        OP(DICT, load_dict)\n        OP(EMPTY_SET, load_empty_set)\n        OP(ADDITEMS, load_additems)\n        OP(FROZENSET, load_frozenset)\n        OP(OBJ, load_obj)\n        OP(INST, load_inst)\n        OP(NEWOBJ, load_newobj)\n        OP(NEWOBJ_EX, load_newobj_ex)\n        OP(GLOBAL, load_global)\n        OP(STACK_GLOBAL, load_stack_global)\n        OP(APPEND, load_append)\n        OP(APPENDS, load_appends)\n        OP(BUILD, load_build)\n        OP(DUP, load_dup)\n        OP(BINGET, load_binget)\n        OP(LONG_BINGET, load_long_binget)\n        OP(GET, load_get)\n        OP(MARK, load_mark)\n        OP(BINPUT, load_binput)\n        OP(LONG_BINPUT, load_long_binput)\n        OP(PUT, load_put)\n        OP(MEMOIZE, load_memoize)\n        OP(POP, load_pop)\n        OP(POP_MARK, load_pop_mark)\n        OP(SETITEM, load_setitem)\n        OP(SETITEMS, load_setitems)\n        OP(PERSID, load_persid)\n        OP(BINPERSID, load_binpersid)\n        OP(REDUCE, load_reduce)\n        OP(PROTO, load_proto)\n        OP(FRAME, load_frame)\n        OP_ARG(EXT1, load_extension, 1)\n        OP_ARG(EXT2, load_extension, 2)\n        OP_ARG(EXT4, load_extension, 4)\n        OP_ARG(NEWTRUE, load_bool, Py_True)\n        OP_ARG(NEWFALSE, load_bool, Py_False)\n\n        case STOP:\n            break;\n\n        default:\n            {\n                PickleState *st = _Pickle_GetGlobalState();\n                unsigned char c = (unsigned char) *s;\n                if (0x20 <= c && c <= 0x7e && c != '\\'' && c != '\\\\') {\n                    PyErr_Format(st->UnpicklingError,\n                                 \"invalid load key, '%c'.\", c);\n                }\n                else {\n                    PyErr_Format(st->UnpicklingError,\n                                 \"invalid load key, '\\\\x%02x'.\", c);\n                }\n                return NULL;\n            }\n        }\n\n        break;                  /* and we are done! */\n    }\n\n    if (PyErr_Occurred()) {\n        return NULL;\n    }\n\n    if (_Unpickler_SkipConsumed(self) < 0)\n        return NULL;\n\n    PDATA_POP(self->stack, value);\n    return value;\n}\n\n/*[clinic input]\n\n_pickle.Unpickler.load\n\nLoad a pickle.\n\nRead a pickled object representation from the open file object given\nin the constructor, and return the reconstituted object hierarchy\nspecified therein.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_Unpickler_load_impl(UnpicklerObject *self)\n/*[clinic end generated code: output=fdcc488aad675b14 input=acbb91a42fa9b7b9]*/\n{\n    UnpicklerObject *unpickler = (UnpicklerObject*)self;\n\n    /* Check whether the Unpickler was initialized correctly. This prevents\n       segfaulting if a subclass overridden __init__ with a function that does\n       not call Unpickler.__init__(). Here, we simply ensure that self->read\n       is not NULL. */\n    if (unpickler->read == NULL) {\n        PickleState *st = _Pickle_GetGlobalState();\n        PyErr_Format(st->UnpicklingError,\n                     \"Unpickler.__init__() was not called by %s.__init__()\",\n                     Py_TYPE(unpickler)->tp_name);\n        return NULL;\n    }\n\n    return load(unpickler);\n}\n\n/* The name of find_class() is misleading. In newer pickle protocols, this\n   function is used for loading any global (i.e., functions), not just\n   classes. The name is kept only for backward compatibility. */\n\n/*[clinic input]\n\n_pickle.Unpickler.find_class\n\n  module_name: object\n  global_name: object\n  /\n\nReturn an object from a specified module.\n\nIf necessary, the module will be imported. Subclasses may override\nthis method (e.g. to restrict unpickling of arbitrary classes and\nfunctions).\n\nThis method is called whenever a class or a function object is\nneeded.  Both arguments passed are str objects.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_Unpickler_find_class_impl(UnpicklerObject *self,\n                                  PyObject *module_name,\n                                  PyObject *global_name)\n/*[clinic end generated code: output=becc08d7f9ed41e3 input=e2e6a865de093ef4]*/\n{\n    PyObject *global;\n    PyObject *module;\n\n    /* Try to map the old names used in Python 2.x to the new ones used in\n       Python 3.x.  We do this only with old pickle protocols and when the\n       user has not disabled the feature. */\n    if (self->proto < 3 && self->fix_imports) {\n        PyObject *key;\n        PyObject *item;\n        PickleState *st = _Pickle_GetGlobalState();\n\n        /* Check if the global (i.e., a function or a class) was renamed\n           or moved to another module. */\n        key = PyTuple_Pack(2, module_name, global_name);\n        if (key == NULL)\n            return NULL;\n        item = PyDict_GetItemWithError(st->name_mapping_2to3, key);\n        Py_DECREF(key);\n        if (item) {\n            if (!PyTuple_Check(item) || PyTuple_GET_SIZE(item) != 2) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"_compat_pickle.NAME_MAPPING values should be \"\n                             \"2-tuples, not %.200s\", Py_TYPE(item)->tp_name);\n                return NULL;\n            }\n            module_name = PyTuple_GET_ITEM(item, 0);\n            global_name = PyTuple_GET_ITEM(item, 1);\n            if (!PyUnicode_Check(module_name) ||\n                !PyUnicode_Check(global_name)) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"_compat_pickle.NAME_MAPPING values should be \"\n                             \"pairs of str, not (%.200s, %.200s)\",\n                             Py_TYPE(module_name)->tp_name,\n                             Py_TYPE(global_name)->tp_name);\n                return NULL;\n            }\n        }\n        else if (PyErr_Occurred()) {\n            return NULL;\n        }\n        else {\n            /* Check if the module was renamed. */\n            item = PyDict_GetItemWithError(st->import_mapping_2to3, module_name);\n            if (item) {\n                if (!PyUnicode_Check(item)) {\n                    PyErr_Format(PyExc_RuntimeError,\n                                \"_compat_pickle.IMPORT_MAPPING values should be \"\n                                \"strings, not %.200s\", Py_TYPE(item)->tp_name);\n                    return NULL;\n                }\n                module_name = item;\n            }\n            else if (PyErr_Occurred()) {\n                return NULL;\n            }\n        }\n    }\n\n    module = PyImport_GetModule(module_name);\n    if (module == NULL) {\n        if (PyErr_Occurred())\n            return NULL;\n        module = PyImport_Import(module_name);\n        if (module == NULL)\n            return NULL;\n    }\n    global = getattribute(module, global_name, self->proto >= 4);\n    Py_DECREF(module);\n    return global;\n}\n\n/*[clinic input]\n\n_pickle.Unpickler.__sizeof__ -> Py_ssize_t\n\nReturns size in memory, in bytes.\n[clinic start generated code]*/\n\nstatic Py_ssize_t\n_pickle_Unpickler___sizeof___impl(UnpicklerObject *self)\n/*[clinic end generated code: output=119d9d03ad4c7651 input=13333471fdeedf5e]*/\n{\n    Py_ssize_t res;\n\n    res = _PyObject_SIZE(Py_TYPE(self));\n    if (self->memo != NULL)\n        res += self->memo_size * sizeof(PyObject *);\n    if (self->marks != NULL)\n        res += self->marks_size * sizeof(Py_ssize_t);\n    if (self->input_line != NULL)\n        res += strlen(self->input_line) + 1;\n    if (self->encoding != NULL)\n        res += strlen(self->encoding) + 1;\n    if (self->errors != NULL)\n        res += strlen(self->errors) + 1;\n    return res;\n}\n\nstatic struct PyMethodDef Unpickler_methods[] = {\n    _PICKLE_UNPICKLER_LOAD_METHODDEF\n    _PICKLE_UNPICKLER_FIND_CLASS_METHODDEF\n    _PICKLE_UNPICKLER___SIZEOF___METHODDEF\n    {NULL, NULL}                /* sentinel */\n};\n\nstatic void\nUnpickler_dealloc(UnpicklerObject *self)\n{\n    PyObject_GC_UnTrack((PyObject *)self);\n    Py_XDECREF(self->readline);\n    Py_XDECREF(self->read);\n    Py_XDECREF(self->peek);\n    Py_XDECREF(self->stack);\n    Py_XDECREF(self->pers_func);\n    if (self->buffer.buf != NULL) {\n        PyBuffer_Release(&self->buffer);\n        self->buffer.buf = NULL;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    PyMem_Free(self->marks);\n    PyMem_Free(self->input_line);\n    PyMem_Free(self->encoding);\n    PyMem_Free(self->errors);\n\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic int\nUnpickler_traverse(UnpicklerObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->readline);\n    Py_VISIT(self->read);\n    Py_VISIT(self->peek);\n    Py_VISIT(self->stack);\n    Py_VISIT(self->pers_func);\n    return 0;\n}\n\nstatic int\nUnpickler_clear(UnpicklerObject *self)\n{\n    Py_CLEAR(self->readline);\n    Py_CLEAR(self->read);\n    Py_CLEAR(self->peek);\n    Py_CLEAR(self->stack);\n    Py_CLEAR(self->pers_func);\n    if (self->buffer.buf != NULL) {\n        PyBuffer_Release(&self->buffer);\n        self->buffer.buf = NULL;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    PyMem_Free(self->marks);\n    self->marks = NULL;\n    PyMem_Free(self->input_line);\n    self->input_line = NULL;\n    PyMem_Free(self->encoding);\n    self->encoding = NULL;\n    PyMem_Free(self->errors);\n    self->errors = NULL;\n\n    return 0;\n}\n\n/*[clinic input]\n\n_pickle.Unpickler.__init__\n\n  file: object\n  *\n  fix_imports: bool = True\n  encoding: str = 'ASCII'\n  errors: str = 'strict'\n\nThis takes a binary file for reading a pickle data stream.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.\n[clinic start generated code]*/\n\nstatic int\n_pickle_Unpickler___init___impl(UnpicklerObject *self, PyObject *file,\n                                int fix_imports, const char *encoding,\n                                const char *errors)\n/*[clinic end generated code: output=e2c8ce748edc57b0 input=f9b7da04f5f4f335]*/\n{\n    _Py_IDENTIFIER(persistent_load);\n\n    /* In case of multiple __init__() calls, clear previous content. */\n    if (self->read != NULL)\n        (void)Unpickler_clear(self);\n\n    if (_Unpickler_SetInputStream(self, file) < 0)\n        return -1;\n\n    if (_Unpickler_SetInputEncoding(self, encoding, errors) < 0)\n        return -1;\n\n    self->fix_imports = fix_imports;\n\n    if (init_method_ref((PyObject *)self, &PyId_persistent_load,\n                        &self->pers_func, &self->pers_func_self) < 0)\n    {\n        return -1;\n    }\n\n    self->stack = (Pdata *)Pdata_New();\n    if (self->stack == NULL)\n        return 1;\n\n    self->memo_size = 32;\n    self->memo = _Unpickler_NewMemo(self->memo_size);\n    if (self->memo == NULL)\n        return -1;\n\n    self->proto = 0;\n\n    return 0;\n}\n\n\n/* Define a proxy object for the Unpickler's internal memo object. This is to\n * avoid breaking code like:\n *  unpickler.memo.clear()\n * and\n *  unpickler.memo = saved_memo\n * Is this a good idea? Not really, but we don't want to break code that uses\n * it. Note that we don't implement the entire mapping API here. This is\n * intentional, as these should be treated as black-box implementation details.\n *\n * We do, however, have to implement pickling/unpickling support because of\n * real-world code like cvs2svn.\n */\n\n/*[clinic input]\n_pickle.UnpicklerMemoProxy.clear\n\nRemove all items from memo.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_UnpicklerMemoProxy_clear_impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=d20cd43f4ba1fb1f input=b1df7c52e7afd9bd]*/\n{\n    _Unpickler_MemoCleanup(self->unpickler);\n    self->unpickler->memo = _Unpickler_NewMemo(self->unpickler->memo_size);\n    if (self->unpickler->memo == NULL)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*[clinic input]\n_pickle.UnpicklerMemoProxy.copy\n\nCopy the memo to a new object.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/\n{\n    size_t i;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    for (i = 0; i < self->unpickler->memo_size; i++) {\n        int status;\n        PyObject *key, *value;\n\n        value = self->unpickler->memo[i];\n        if (value == NULL)\n            continue;\n\n        key = PyLong_FromSsize_t(i);\n        if (key == NULL)\n            goto error;\n        status = PyDict_SetItem(new_memo, key, value);\n        Py_DECREF(key);\n        if (status < 0)\n            goto error;\n    }\n    return new_memo;\n\nerror:\n    Py_DECREF(new_memo);\n    return NULL;\n}\n\n/*[clinic input]\n_pickle.UnpicklerMemoProxy.__reduce__\n\nImplement pickling support.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_UnpicklerMemoProxy___reduce___impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=6da34ac048d94cca input=6920862413407199]*/\n{\n    PyObject *reduce_value;\n    PyObject *constructor_args;\n    PyObject *contents = _pickle_UnpicklerMemoProxy_copy_impl(self);\n    if (contents == NULL)\n        return NULL;\n\n    reduce_value = PyTuple_New(2);\n    if (reduce_value == NULL) {\n        Py_DECREF(contents);\n        return NULL;\n    }\n    constructor_args = PyTuple_New(1);\n    if (constructor_args == NULL) {\n        Py_DECREF(contents);\n        Py_DECREF(reduce_value);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(constructor_args, 0, contents);\n    Py_INCREF((PyObject *)&PyDict_Type);\n    PyTuple_SET_ITEM(reduce_value, 0, (PyObject *)&PyDict_Type);\n    PyTuple_SET_ITEM(reduce_value, 1, constructor_args);\n    return reduce_value;\n}\n\nstatic PyMethodDef unpicklerproxy_methods[] = {\n    _PICKLE_UNPICKLERMEMOPROXY_CLEAR_METHODDEF\n    _PICKLE_UNPICKLERMEMOPROXY_COPY_METHODDEF\n    _PICKLE_UNPICKLERMEMOPROXY___REDUCE___METHODDEF\n    {NULL, NULL}    /* sentinel */\n};\n\nstatic void\nUnpicklerMemoProxy_dealloc(UnpicklerMemoProxyObject *self)\n{\n    PyObject_GC_UnTrack(self);\n    Py_XDECREF(self->unpickler);\n    PyObject_GC_Del((PyObject *)self);\n}\n\nstatic int\nUnpicklerMemoProxy_traverse(UnpicklerMemoProxyObject *self,\n                            visitproc visit, void *arg)\n{\n    Py_VISIT(self->unpickler);\n    return 0;\n}\n\nstatic int\nUnpicklerMemoProxy_clear(UnpicklerMemoProxyObject *self)\n{\n    Py_CLEAR(self->unpickler);\n    return 0;\n}\n\nstatic PyTypeObject UnpicklerMemoProxyType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.UnpicklerMemoProxy\",               /*tp_name*/\n    sizeof(UnpicklerMemoProxyObject),           /*tp_basicsize*/\n    0,\n    (destructor)UnpicklerMemoProxy_dealloc,     /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    PyObject_HashNotImplemented,                /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    PyObject_GenericSetAttr,                    /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)UnpicklerMemoProxy_traverse,  /* tp_traverse */\n    (inquiry)UnpicklerMemoProxy_clear,          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    unpicklerproxy_methods,                     /* tp_methods */\n};\n\nstatic PyObject *\nUnpicklerMemoProxy_New(UnpicklerObject *unpickler)\n{\n    UnpicklerMemoProxyObject *self;\n\n    self = PyObject_GC_New(UnpicklerMemoProxyObject,\n                           &UnpicklerMemoProxyType);\n    if (self == NULL)\n        return NULL;\n    Py_INCREF(unpickler);\n    self->unpickler = unpickler;\n    PyObject_GC_Track(self);\n    return (PyObject *)self;\n}\n\n/*****************************************************************************/\n\n\nstatic PyObject *\nUnpickler_get_memo(UnpicklerObject *self)\n{\n    return UnpicklerMemoProxy_New(self);\n}\n\nstatic int\nUnpickler_set_memo(UnpicklerObject *self, PyObject *obj)\n{\n    PyObject **new_memo;\n    size_t new_memo_size = 0;\n\n    if (obj == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n\n    if (Py_TYPE(obj) == &UnpicklerMemoProxyType) {\n        UnpicklerObject *unpickler =\n            ((UnpicklerMemoProxyObject *)obj)->unpickler;\n\n        new_memo_size = unpickler->memo_size;\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        for (size_t i = 0; i < new_memo_size; i++) {\n            Py_XINCREF(unpickler->memo[i]);\n            new_memo[i] = unpickler->memo[i];\n        }\n    }\n    else if (PyDict_Check(obj)) {\n        Py_ssize_t i = 0;\n        PyObject *key, *value;\n\n        new_memo_size = PyDict_GET_SIZE(obj);\n        new_memo = _Unpickler_NewMemo(new_memo_size);\n        if (new_memo == NULL)\n            return -1;\n\n        while (PyDict_Next(obj, &i, &key, &value)) {\n            Py_ssize_t idx;\n            if (!PyLong_Check(key)) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"memo key must be integers\");\n                goto error;\n            }\n            idx = PyLong_AsSsize_t(key);\n            if (idx == -1 && PyErr_Occurred())\n                goto error;\n            if (idx < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"memo key must be positive integers.\");\n                goto error;\n            }\n            if (_Unpickler_MemoPut(self, idx, value) < 0)\n                goto error;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"'memo' attribute must be an UnpicklerMemoProxy object\"\n                     \"or dict, not %.200s\", Py_TYPE(obj)->tp_name);\n        return -1;\n    }\n\n    _Unpickler_MemoCleanup(self);\n    self->memo_size = new_memo_size;\n    self->memo = new_memo;\n\n    return 0;\n\n  error:\n    if (new_memo_size) {\n        for (size_t i = new_memo_size - 1; i != SIZE_MAX; i--) {\n            Py_XDECREF(new_memo[i]);\n        }\n        PyMem_FREE(new_memo);\n    }\n    return -1;\n}\n\nstatic PyObject *\nUnpickler_get_persload(UnpicklerObject *self)\n{\n    if (self->pers_func == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"persistent_load\");\n        return NULL;\n    }\n    return reconstruct_method(self->pers_func, self->pers_func_self);\n}\n\nstatic int\nUnpickler_set_persload(UnpicklerObject *self, PyObject *value)\n{\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"attribute deletion is not supported\");\n        return -1;\n    }\n    if (!PyCallable_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"persistent_load must be a callable taking \"\n                        \"one argument\");\n        return -1;\n    }\n\n    self->pers_func_self = NULL;\n    Py_INCREF(value);\n    Py_XSETREF(self->pers_func, value);\n\n    return 0;\n}\n\nstatic PyGetSetDef Unpickler_getsets[] = {\n    {\"memo\", (getter)Unpickler_get_memo, (setter)Unpickler_set_memo},\n    {\"persistent_load\", (getter)Unpickler_get_persload,\n                        (setter)Unpickler_set_persload},\n    {NULL}\n};\n\nstatic PyTypeObject Unpickler_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_pickle.Unpickler\",                /*tp_name*/\n    sizeof(UnpicklerObject),            /*tp_basicsize*/\n    0,                                  /*tp_itemsize*/\n    (destructor)Unpickler_dealloc,      /*tp_dealloc*/\n    0,                                  /*tp_print*/\n    0,                                  /*tp_getattr*/\n    0,                                  /*tp_setattr*/\n    0,                                  /*tp_reserved*/\n    0,                                  /*tp_repr*/\n    0,                                  /*tp_as_number*/\n    0,                                  /*tp_as_sequence*/\n    0,                                  /*tp_as_mapping*/\n    0,                                  /*tp_hash*/\n    0,                                  /*tp_call*/\n    0,                                  /*tp_str*/\n    0,                                  /*tp_getattro*/\n    0,                                  /*tp_setattro*/\n    0,                                  /*tp_as_buffer*/\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,\n    _pickle_Unpickler___init____doc__,  /*tp_doc*/\n    (traverseproc)Unpickler_traverse,   /*tp_traverse*/\n    (inquiry)Unpickler_clear,           /*tp_clear*/\n    0,                                  /*tp_richcompare*/\n    0,                                  /*tp_weaklistoffset*/\n    0,                                  /*tp_iter*/\n    0,                                  /*tp_iternext*/\n    Unpickler_methods,                  /*tp_methods*/\n    0,                                  /*tp_members*/\n    Unpickler_getsets,                  /*tp_getset*/\n    0,                                  /*tp_base*/\n    0,                                  /*tp_dict*/\n    0,                                  /*tp_descr_get*/\n    0,                                  /*tp_descr_set*/\n    0,                                  /*tp_dictoffset*/\n    _pickle_Unpickler___init__,         /*tp_init*/\n    PyType_GenericAlloc,                /*tp_alloc*/\n    PyType_GenericNew,                  /*tp_new*/\n    PyObject_GC_Del,                    /*tp_free*/\n    0,                                  /*tp_is_gc*/\n};\n\n/*[clinic input]\n\n_pickle.dump\n\n  obj: object\n  file: object\n  protocol: object = NULL\n  *\n  fix_imports: bool = True\n\nWrite a pickled representation of obj to the open file object file.\n\nThis is equivalent to ``Pickler(file, protocol).dump(obj)``, but may\nbe more efficient.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3 and 4.  The default\nprotocol is 4. It was introduced in Python 3.4, it is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument.  It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_dump_impl(PyObject *module, PyObject *obj, PyObject *file,\n                  PyObject *protocol, int fix_imports)\n/*[clinic end generated code: output=a4774d5fde7d34de input=93f1408489a87472]*/\n{\n    PicklerObject *pickler = _Pickler_New();\n\n    if (pickler == NULL)\n        return NULL;\n\n    if (_Pickler_SetProtocol(pickler, protocol, fix_imports) < 0)\n        goto error;\n\n    if (_Pickler_SetOutputStream(pickler, file) < 0)\n        goto error;\n\n    if (dump(pickler, obj) < 0)\n        goto error;\n\n    if (_Pickler_FlushToFile(pickler) < 0)\n        goto error;\n\n    Py_DECREF(pickler);\n    Py_RETURN_NONE;\n\n  error:\n    Py_XDECREF(pickler);\n    return NULL;\n}\n\n/*[clinic input]\n\n_pickle.dumps\n\n  obj: object\n  protocol: object = NULL\n  *\n  fix_imports: bool = True\n\nReturn the pickled representation of the object as a bytes object.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3 and 4.  The default\nprotocol is 4. It was introduced in Python 3.4, it is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nIf *fix_imports* is True and *protocol* is less than 3, pickle will\ntry to map the new Python 3 names to the old module names used in\nPython 2, so that the pickle data stream is readable with Python 2.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_dumps_impl(PyObject *module, PyObject *obj, PyObject *protocol,\n                   int fix_imports)\n/*[clinic end generated code: output=d75d5cda456fd261 input=b6efb45a7d19b5ab]*/\n{\n    PyObject *result;\n    PicklerObject *pickler = _Pickler_New();\n\n    if (pickler == NULL)\n        return NULL;\n\n    if (_Pickler_SetProtocol(pickler, protocol, fix_imports) < 0)\n        goto error;\n\n    if (dump(pickler, obj) < 0)\n        goto error;\n\n    result = _Pickler_GetString(pickler);\n    Py_DECREF(pickler);\n    return result;\n\n  error:\n    Py_XDECREF(pickler);\n    return NULL;\n}\n\n/*[clinic input]\n\n_pickle.load\n\n  file: object\n  *\n  fix_imports: bool = True\n  encoding: str = 'ASCII'\n  errors: str = 'strict'\n\nRead and return an object from the pickle data stored in a file.\n\nThis is equivalent to ``Unpickler(file).load()``, but may be more\nefficient.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_load_impl(PyObject *module, PyObject *file, int fix_imports,\n                  const char *encoding, const char *errors)\n/*[clinic end generated code: output=69e298160285199e input=01b44dd3fc07afa7]*/\n{\n    PyObject *result;\n    UnpicklerObject *unpickler = _Unpickler_New();\n\n    if (unpickler == NULL)\n        return NULL;\n\n    if (_Unpickler_SetInputStream(unpickler, file) < 0)\n        goto error;\n\n    if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)\n        goto error;\n\n    unpickler->fix_imports = fix_imports;\n\n    result = load(unpickler);\n    Py_DECREF(unpickler);\n    return result;\n\n  error:\n    Py_XDECREF(unpickler);\n    return NULL;\n}\n\n/*[clinic input]\n\n_pickle.loads\n\n  data: object\n  *\n  fix_imports: bool = True\n  encoding: str = 'ASCII'\n  errors: str = 'strict'\n\nRead and return an object from the given pickle data.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.\n[clinic start generated code]*/\n\nstatic PyObject *\n_pickle_loads_impl(PyObject *module, PyObject *data, int fix_imports,\n                   const char *encoding, const char *errors)\n/*[clinic end generated code: output=1e7cb2343f2c440f input=70605948a719feb9]*/\n{\n    PyObject *result;\n    UnpicklerObject *unpickler = _Unpickler_New();\n\n    if (unpickler == NULL)\n        return NULL;\n\n    if (_Unpickler_SetStringInput(unpickler, data) < 0)\n        goto error;\n\n    if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)\n        goto error;\n\n    unpickler->fix_imports = fix_imports;\n\n    result = load(unpickler);\n    Py_DECREF(unpickler);\n    return result;\n\n  error:\n    Py_XDECREF(unpickler);\n    return NULL;\n}\n\nstatic struct PyMethodDef pickle_methods[] = {\n    _PICKLE_DUMP_METHODDEF\n    _PICKLE_DUMPS_METHODDEF\n    _PICKLE_LOAD_METHODDEF\n    _PICKLE_LOADS_METHODDEF\n    {NULL, NULL} /* sentinel */\n};\n\nstatic int\npickle_clear(PyObject *m)\n{\n    _Pickle_ClearState(_Pickle_GetState(m));\n    return 0;\n}\n\nstatic void\npickle_free(PyObject *m)\n{\n    _Pickle_ClearState(_Pickle_GetState(m));\n}\n\nstatic int\npickle_traverse(PyObject *m, visitproc visit, void *arg)\n{\n    PickleState *st = _Pickle_GetState(m);\n    Py_VISIT(st->PickleError);\n    Py_VISIT(st->PicklingError);\n    Py_VISIT(st->UnpicklingError);\n    Py_VISIT(st->dispatch_table);\n    Py_VISIT(st->extension_registry);\n    Py_VISIT(st->extension_cache);\n    Py_VISIT(st->inverted_registry);\n    Py_VISIT(st->name_mapping_2to3);\n    Py_VISIT(st->import_mapping_2to3);\n    Py_VISIT(st->name_mapping_3to2);\n    Py_VISIT(st->import_mapping_3to2);\n    Py_VISIT(st->codecs_encode);\n    Py_VISIT(st->getattr);\n    return 0;\n}\n\nstatic struct PyModuleDef _picklemodule = {\n    PyModuleDef_HEAD_INIT,\n    \"_pickle\",            /* m_name */\n    pickle_module_doc,    /* m_doc */\n    sizeof(PickleState),  /* m_size */\n    pickle_methods,       /* m_methods */\n    NULL,                 /* m_reload */\n    pickle_traverse,      /* m_traverse */\n    pickle_clear,         /* m_clear */\n    (freefunc)pickle_free /* m_free */\n};\n\nPyMODINIT_FUNC\nPyInit__pickle(void)\n{\n    PyObject *m;\n    PickleState *st;\n\n    m = PyState_FindModule(&_picklemodule);\n    if (m) {\n        Py_INCREF(m);\n        return m;\n    }\n\n    if (PyType_Ready(&Unpickler_Type) < 0)\n        return NULL;\n    if (PyType_Ready(&Pickler_Type) < 0)\n        return NULL;\n    if (PyType_Ready(&Pdata_Type) < 0)\n        return NULL;\n    if (PyType_Ready(&PicklerMemoProxyType) < 0)\n        return NULL;\n    if (PyType_Ready(&UnpicklerMemoProxyType) < 0)\n        return NULL;\n\n    /* Create the module and add the functions. */\n    m = PyModule_Create(&_picklemodule);\n    if (m == NULL)\n        return NULL;\n\n    Py_INCREF(&Pickler_Type);\n    if (PyModule_AddObject(m, \"Pickler\", (PyObject *)&Pickler_Type) < 0)\n        return NULL;\n    Py_INCREF(&Unpickler_Type);\n    if (PyModule_AddObject(m, \"Unpickler\", (PyObject *)&Unpickler_Type) < 0)\n        return NULL;\n\n    st = _Pickle_GetState(m);\n\n    /* Initialize the exceptions. */\n    st->PickleError = PyErr_NewException(\"_pickle.PickleError\", NULL, NULL);\n    if (st->PickleError == NULL)\n        return NULL;\n    st->PicklingError = \\\n        PyErr_NewException(\"_pickle.PicklingError\", st->PickleError, NULL);\n    if (st->PicklingError == NULL)\n        return NULL;\n    st->UnpicklingError = \\\n        PyErr_NewException(\"_pickle.UnpicklingError\", st->PickleError, NULL);\n    if (st->UnpicklingError == NULL)\n        return NULL;\n\n    Py_INCREF(st->PickleError);\n    if (PyModule_AddObject(m, \"PickleError\", st->PickleError) < 0)\n        return NULL;\n    Py_INCREF(st->PicklingError);\n    if (PyModule_AddObject(m, \"PicklingError\", st->PicklingError) < 0)\n        return NULL;\n    Py_INCREF(st->UnpicklingError);\n    if (PyModule_AddObject(m, \"UnpicklingError\", st->UnpicklingError) < 0)\n        return NULL;\n\n    if (_Pickle_InitState(st) < 0)\n        return NULL;\n\n    return m;\n}\n"], "filenames": ["Modules/_pickle.c"], "buggy_code_start_loc": [605], "buggy_code_end_loc": [7065], "fixing_code_start_loc": [605], "fixing_code_end_loc": [7065], "type": "CWE-190", "message": "Modules/_pickle.c in Python before 3.7.1 has an integer overflow via a large LONG_BINPUT value that is mishandled during a \"resize to twice the size\" attempt. This issue might cause memory exhaustion, but is only relevant if the pickle format is used for serializing tens or hundreds of gigabytes of data. This issue is fixed in: v3.4.10, v3.4.10rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.7rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.7, v3.6.7rc1, v3.6.7rc2, v3.6.8, v3.6.8rc1, v3.6.9, v3.6.9rc1; v3.7.1, v3.7.1rc1, v3.7.1rc2, v3.7.2, v3.7.2rc1, v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.", "other": {"cve": {"id": "CVE-2018-20406", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-23T23:29:00.307", "lastModified": "2020-10-29T15:15:12.110", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Modules/_pickle.c in Python before 3.7.1 has an integer overflow via a large LONG_BINPUT value that is mishandled during a \"resize to twice the size\" attempt. This issue might cause memory exhaustion, but is only relevant if the pickle format is used for serializing tens or hundreds of gigabytes of data. This issue is fixed in: v3.4.10, v3.4.10rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.7rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.7, v3.6.7rc1, v3.6.7rc2, v3.6.8, v3.6.8rc1, v3.6.9, v3.6.9rc1; v3.7.1, v3.7.1rc1, v3.7.1rc2, v3.7.2, v3.7.2rc1, v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9."}, {"lang": "es", "value": "Modules/_pickle.c en Python, en versiones anteriores a la 3.7.1, tiene un desbordamiento de enteros mediante un valor LONG_BINPUT largo que se gestiona de manera incorrecta durante un intento de \"redimensionar al tama\u00f1o doble\". Este problema podr\u00eda provocar el agotamiento de memoria, pero solo es relevante si el formato picke se emplea para serializar decenas o cientos de gigabytes de datos.Este problema est\u00e1 resuelto en las versiones: v3.4.10, v3.4.10rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.7rc1, v3.5.8, v3.5.8rc1, v3. 5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.7, v3.6.7rc1, v3.6.7rc2, v3.6.6. 8, v3.6.8rc1, v3.6.9, v3.6.9rc1; v3.7.1, v3.7.1rc1, v3.7.1rc2, v3.7.2, v3.7.2rc1, v3.7.3, v3.7.3rc1, v3.7. 4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:python:python:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.7.1", "matchCriteriaId": "FECA0AB3-E761-454E-A689-5A7BE1C44384"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:28:*:*:*:*:*:*:*", "matchCriteriaId": "DC1BD7B7-6D88-42B8-878E-F1318CA5FCAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00040.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3725", "source": "cve@mitre.org"}, {"url": "https://bugs.python.org/issue34656", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00011.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/46PVWY5LFP4BRPG3BVQ5QEEFYBVEXHCK/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AEZ5IQT7OF7Q2NCGIVABOWYGKO7YU3NJ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/D3LXPABKVLFYUHRYJPM3CSS5MS6FXKS7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ICBEGRHIPHWPG2VGYS6R4EVKVUUF4AQW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JSKPGPZQNTAULHW4UH63KGOOUIDE4RRB/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TR6GCO3WTV4D5L23WTCBF275VE6BVNI3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190416-0010/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4127-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4127-2/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/python/cpython/commit/a4ae828ee416a66d8c7bf5ee71d653c2cc6a26dd"}}