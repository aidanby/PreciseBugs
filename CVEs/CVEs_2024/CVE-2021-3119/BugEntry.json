{"buggy_code": ["/*\n** SQLCipher\n** http://sqlcipher.net\n** \n** Copyright (c) 2008 - 2013, ZETETIC LLC\n** All rights reserved.\n** \n** Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are met:\n**     * Redistributions of source code must retain the above copyright\n**       notice, this list of conditions and the following disclaimer.\n**     * Redistributions in binary form must reproduce the above copyright\n**       notice, this list of conditions and the following disclaimer in the\n**       documentation and/or other materials provided with the distribution.\n**     * Neither the name of the ZETETIC LLC nor the\n**       names of its contributors may be used to endorse or promote products\n**       derived from this software without specific prior written permission.\n** \n** THIS SOFTWARE IS PROVIDED BY ZETETIC LLC ''AS IS'' AND ANY\n** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n** DISCLAIMED. IN NO EVENT SHALL ZETETIC LLC BE LIABLE FOR ANY\n** DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n** ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**  \n*/\n/* BEGIN SQLCIPHER */\n#ifdef SQLITE_HAS_CODEC\n\n#include <assert.h>\n#include \"sqlcipher.h\"\n#include \"crypto.h\"\n\n#ifdef SQLCIPHER_EXT\n#include \"sqlcipher_ext.h\"\n#endif\n\n#ifdef SQLCIPHER_TEST\nstatic int cipher_fail_next_encrypt = 0;\nstatic int cipher_fail_next_decrypt = 0;\n#endif\n\n/* Generate code to return a string value */\nstatic void codec_vdbe_return_string(Parse *pParse, const char *zLabel, const char *value, int value_type){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  sqlite3VdbeSetNumCols(v, 1);\n  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC);\n  sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, value, value_type);\n  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n}\n\nstatic int codec_set_btree_to_codec_pagesize(sqlite3 *db, Db *pDb, codec_ctx *ctx) {\n  int rc, page_sz, reserve_sz; \n\n  page_sz = sqlcipher_codec_ctx_get_pagesize(ctx);\n  reserve_sz = sqlcipher_codec_ctx_get_reservesize(ctx);\n\n  CODEC_TRACE(\"codec_set_btree_to_codec_pagesize: sqlite3BtreeSetPageSize() size=%d reserve=%d\\n\", page_sz, reserve_sz);\n\n  CODEC_TRACE_MUTEX(\"codec_set_btree_to_codec_pagesize: entering database mutex %p\\n\", db->mutex);\n  sqlite3_mutex_enter(db->mutex);\n  CODEC_TRACE_MUTEX(\"codec_set_btree_to_codec_pagesize: entered database mutex %p\\n\", db->mutex);\n  db->nextPagesize = page_sz; \n\n  /* before forcing the page size we need to unset the BTS_PAGESIZE_FIXED flag, else  \n     sqliteBtreeSetPageSize will block the change  */\n  pDb->pBt->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;\n  rc = sqlite3BtreeSetPageSize(pDb->pBt, page_sz, reserve_sz, 0);\n\n  CODEC_TRACE(\"codec_set_btree_to_codec_pagesize: sqlite3BtreeSetPageSize returned %d\\n\", rc);\n\n  CODEC_TRACE_MUTEX(\"codec_set_btree_to_codec_pagesize: leaving database mutex %p\\n\", db->mutex);\n  sqlite3_mutex_leave(db->mutex);\n  CODEC_TRACE_MUTEX(\"codec_set_btree_to_codec_pagesize: left database mutex %p\\n\", db->mutex);\n\n  return rc;\n}\n\nstatic int codec_set_pass_key(sqlite3* db, int nDb, const void *zKey, int nKey, int for_ctx) {\n  struct Db *pDb = &db->aDb[nDb];\n  CODEC_TRACE(\"codec_set_pass_key: entered db=%p nDb=%d zKey=%s nKey=%d for_ctx=%d\\n\", db, nDb, (char *)zKey, nKey, for_ctx);\n  if(pDb->pBt) {\n    codec_ctx *ctx = (codec_ctx*) sqlite3PagerGetCodec(pDb->pBt->pBt->pPager);\n\n    if(ctx) return sqlcipher_codec_ctx_set_pass(ctx, zKey, nKey, for_ctx);\n  }\n  return SQLITE_ERROR;\n} \n\nint sqlcipher_codec_pragma(sqlite3* db, int iDb, Parse *pParse, const char *zLeft, const char *zRight) {\n  struct Db *pDb = &db->aDb[iDb];\n  codec_ctx *ctx = NULL;\n  int rc;\n\n  if(pDb->pBt) {\n    ctx = (codec_ctx*) sqlite3PagerGetCodec(pDb->pBt->pBt->pPager);\n  }\n\n  CODEC_TRACE(\"sqlcipher_codec_pragma: entered db=%p iDb=%d pParse=%p zLeft=%s zRight=%s ctx=%p\\n\", db, iDb, pParse, zLeft, zRight, ctx);\n  \n#ifdef SQLCIPHER_EXT\n  if( sqlite3StrICmp(zLeft, \"cipher_license\")==0 && zRight ){\n    char *license_result = sqlite3_mprintf(\"%d\", sqlcipher_license_key(zRight));\n    codec_vdbe_return_string(pParse, \"cipher_license\", license_result, P4_DYNAMIC);\n  } else\n    if( sqlite3StrICmp(zLeft, \"cipher_license\")==0 && !zRight ){\n      if(ctx) {\n        char *license_result = sqlite3_mprintf(\"%d\", ctx\n                                               ? sqlcipher_license_key_status(ctx->provider)\n                                               : SQLITE_ERROR);\n        codec_vdbe_return_string(pParse, \"cipher_license\", license_result, P4_DYNAMIC);\n      }\n  } else\n#endif\n#ifdef SQLCIPHER_TEST\n  if( sqlite3StrICmp(zLeft,\"cipher_fail_next_encrypt\")==0 ){\n    if( zRight ) {\n      cipher_fail_next_encrypt = sqlite3GetBoolean(zRight,1);\n    } else {\n      char *fail = sqlite3_mprintf(\"%d\", cipher_fail_next_encrypt);\n      codec_vdbe_return_string(pParse, \"cipher_fail_next_encrypt\", fail, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_fail_next_decrypt\")==0 ){\n    if( zRight ) {\n      cipher_fail_next_decrypt = sqlite3GetBoolean(zRight,1);\n    } else {\n      char *fail = sqlite3_mprintf(\"%d\", cipher_fail_next_decrypt);\n      codec_vdbe_return_string(pParse, \"cipher_fail_next_decrypt\", fail, P4_DYNAMIC);\n    }\n  }else\n#endif\n  if( sqlite3StrICmp(zLeft, \"cipher_fips_status\")== 0 && !zRight ){\n    if(ctx) {\n      char *fips_mode_status = sqlite3_mprintf(\"%d\", sqlcipher_codec_fips_status(ctx));\n      codec_vdbe_return_string(pParse, \"cipher_fips_status\", fips_mode_status, P4_DYNAMIC);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_store_pass\")==0 && zRight ) {\n    if(ctx) {\n      char *deprecation = \"PRAGMA cipher_store_pass is deprecated, please remove from use\";\n      sqlcipher_codec_set_store_pass(ctx, sqlite3GetBoolean(zRight, 1));\n      codec_vdbe_return_string(pParse, \"cipher_store_pass\", deprecation, P4_TRANSIENT);\n      sqlite3_log(SQLITE_WARNING, deprecation);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_store_pass\")==0 && !zRight ) {\n    if(ctx){\n      char *store_pass_value = sqlite3_mprintf(\"%d\", sqlcipher_codec_get_store_pass(ctx));\n      codec_vdbe_return_string(pParse, \"cipher_store_pass\", store_pass_value, P4_DYNAMIC);\n    }\n  }\n  if( sqlite3StrICmp(zLeft, \"cipher_profile\")== 0 && zRight ){\n      char *profile_status = sqlite3_mprintf(\"%d\", sqlcipher_cipher_profile(db, zRight));\n      codec_vdbe_return_string(pParse, \"cipher_profile\", profile_status, P4_DYNAMIC);\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_add_random\")==0 && zRight ){\n    if(ctx) {\n      char *add_random_status = sqlite3_mprintf(\"%d\", sqlcipher_codec_add_random(ctx, zRight, sqlite3Strlen30(zRight)));\n      codec_vdbe_return_string(pParse, \"cipher_add_random\", add_random_status, P4_DYNAMIC);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_migrate\")==0 && !zRight ){\n    if(ctx){\n      char *migrate_status = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_migrate(ctx));\n      codec_vdbe_return_string(pParse, \"cipher_migrate\", migrate_status, P4_DYNAMIC);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_provider\")==0 && !zRight ){\n    if(ctx) { codec_vdbe_return_string(pParse, \"cipher_provider\",\n                                              sqlcipher_codec_get_cipher_provider(ctx), P4_TRANSIENT);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_provider_version\")==0 && !zRight){\n    if(ctx) { codec_vdbe_return_string(pParse, \"cipher_provider_version\",\n                                              sqlcipher_codec_get_provider_version(ctx), P4_TRANSIENT);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_version\")==0 && !zRight ){\n    codec_vdbe_return_string(pParse, \"cipher_version\", sqlcipher_version(), P4_DYNAMIC);\n  }else\n  if( sqlite3StrICmp(zLeft, \"cipher\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        const char* message = \"PRAGMA cipher is no longer supported.\";\n        codec_vdbe_return_string(pParse, \"cipher\", message, P4_TRANSIENT);\n        sqlite3_log(SQLITE_WARNING, message);\n      }else {\n        codec_vdbe_return_string(pParse, \"cipher\", sqlcipher_codec_ctx_get_cipher(ctx), P4_TRANSIENT); \n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft, \"rekey_cipher\")==0 && zRight ){\n    const char* message = \"PRAGMA rekey_cipher is no longer supported.\";\n    codec_vdbe_return_string(pParse, \"rekey_cipher\", message, P4_TRANSIENT);\n    sqlite3_log(SQLITE_WARNING, message);\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_default_kdf_iter\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_default_kdf_iter(atoi(zRight)); /* change default KDF iterations */\n    } else {\n      char *kdf_iter = sqlite3_mprintf(\"%d\", sqlcipher_get_default_kdf_iter());\n      codec_vdbe_return_string(pParse, \"cipher_default_kdf_iter\", kdf_iter, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft, \"kdf_iter\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        sqlcipher_codec_ctx_set_kdf_iter(ctx, atoi(zRight)); /* change of RW PBKDF2 iteration */\n      } else {\n        char *kdf_iter = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_kdf_iter(ctx));\n        codec_vdbe_return_string(pParse, \"kdf_iter\", kdf_iter, P4_DYNAMIC);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft, \"fast_kdf_iter\")==0){\n    if(ctx) {\n      if( zRight ) {\n        char *deprecation = \"PRAGMA fast_kdf_iter is deprecated, please remove from use\";\n        sqlcipher_codec_ctx_set_fast_kdf_iter(ctx, atoi(zRight)); /* change of RW PBKDF2 iteration */\n        codec_vdbe_return_string(pParse, \"fast_kdf_iter\", deprecation, P4_TRANSIENT);\n        sqlite3_log(SQLITE_WARNING, deprecation);\n      } else {\n        char *fast_kdf_iter = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_fast_kdf_iter(ctx));\n        codec_vdbe_return_string(pParse, \"fast_kdf_iter\", fast_kdf_iter, P4_DYNAMIC);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft, \"rekey_kdf_iter\")==0 && zRight ){\n    const char* message = \"PRAGMA rekey_kdf_iter is no longer supported.\";\n    codec_vdbe_return_string(pParse, \"rekey_kdf_iter\", message, P4_TRANSIENT);\n    sqlite3_log(SQLITE_WARNING, message);\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_page_size\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        int size = atoi(zRight);\n        rc = sqlcipher_codec_ctx_set_pagesize(ctx, size);\n        if(rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, rc);\n        rc = codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n        if(rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, rc);\n      } else {\n        char * page_size = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_pagesize(ctx));\n        codec_vdbe_return_string(pParse, \"cipher_page_size\", page_size, P4_DYNAMIC);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_default_page_size\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_default_pagesize(atoi(zRight));\n    } else {\n      char *default_page_size = sqlite3_mprintf(\"%d\", sqlcipher_get_default_pagesize());\n      codec_vdbe_return_string(pParse, \"cipher_default_page_size\", default_page_size, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_default_use_hmac\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_default_use_hmac(sqlite3GetBoolean(zRight,1));\n    } else {\n      char *default_use_hmac = sqlite3_mprintf(\"%d\", sqlcipher_get_default_use_hmac());\n      codec_vdbe_return_string(pParse, \"cipher_default_use_hmac\", default_use_hmac, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_use_hmac\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        rc = sqlcipher_codec_ctx_set_use_hmac(ctx, sqlite3GetBoolean(zRight,1));\n        if(rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, rc);\n        /* since the use of hmac has changed, the page size may also change */\n        rc = codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n        if(rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, rc);\n      } else {\n        char *hmac_flag = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_use_hmac(ctx));\n        codec_vdbe_return_string(pParse, \"cipher_use_hmac\", hmac_flag, P4_DYNAMIC);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_hmac_pgno\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        char *deprecation = \"PRAGMA cipher_hmac_pgno is deprecated, please remove from use\";\n        /* clear both pgno endian flags */\n        if(sqlite3StrICmp(zRight, \"le\") == 0) {\n          sqlcipher_codec_ctx_unset_flag(ctx, CIPHER_FLAG_BE_PGNO);\n          sqlcipher_codec_ctx_set_flag(ctx, CIPHER_FLAG_LE_PGNO);\n        } else if(sqlite3StrICmp(zRight, \"be\") == 0) {\n          sqlcipher_codec_ctx_unset_flag(ctx, CIPHER_FLAG_LE_PGNO);\n          sqlcipher_codec_ctx_set_flag(ctx, CIPHER_FLAG_BE_PGNO);\n        } else if(sqlite3StrICmp(zRight, \"native\") == 0) {\n          sqlcipher_codec_ctx_unset_flag(ctx, CIPHER_FLAG_LE_PGNO);\n          sqlcipher_codec_ctx_unset_flag(ctx, CIPHER_FLAG_BE_PGNO);\n        }\n        codec_vdbe_return_string(pParse, \"cipher_hmac_pgno\", deprecation, P4_TRANSIENT);\n        sqlite3_log(SQLITE_WARNING, deprecation);\n \n      } else {\n        if(sqlcipher_codec_ctx_get_flag(ctx, CIPHER_FLAG_LE_PGNO)) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_pgno\", \"le\", P4_TRANSIENT);\n        } else if(sqlcipher_codec_ctx_get_flag(ctx, CIPHER_FLAG_BE_PGNO)) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_pgno\", \"be\", P4_TRANSIENT);\n        } else {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_pgno\", \"native\", P4_TRANSIENT);\n        }\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_hmac_salt_mask\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        char *deprecation = \"PRAGMA cipher_hmac_salt_mask is deprecated, please remove from use\";\n        if (sqlite3StrNICmp(zRight ,\"x'\", 2) == 0 && sqlite3Strlen30(zRight) == 5) {\n          unsigned char mask = 0;\n          const unsigned char *hex = (const unsigned char *)zRight+2;\n          cipher_hex2bin(hex,2,&mask);\n          sqlcipher_set_hmac_salt_mask(mask);\n        }\n        codec_vdbe_return_string(pParse, \"cipher_hmac_salt_mask\", deprecation, P4_TRANSIENT);\n        sqlite3_log(SQLITE_WARNING, deprecation);\n      } else {\n        char *hmac_salt_mask = sqlite3_mprintf(\"%02x\", sqlcipher_get_hmac_salt_mask());\n        codec_vdbe_return_string(pParse, \"cipher_hmac_salt_mask\", hmac_salt_mask, P4_DYNAMIC);\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_plaintext_header_size\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        int size = atoi(zRight);\n        /* deliberately ignore result code, if size is invalid it will be set to -1\n           and trip the error later in the codec */\n        sqlcipher_codec_ctx_set_plaintext_header_size(ctx, size);\n      } else {\n        char *size = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_plaintext_header_size(ctx));\n        codec_vdbe_return_string(pParse, \"cipher_plaintext_header_size\", size, P4_DYNAMIC);\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_default_plaintext_header_size\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_default_plaintext_header_size(atoi(zRight));\n    } else {\n      char *size = sqlite3_mprintf(\"%d\", sqlcipher_get_default_plaintext_header_size());\n      codec_vdbe_return_string(pParse, \"cipher_default_plaintext_header_size\", size, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_salt\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        if (sqlite3StrNICmp(zRight ,\"x'\", 2) == 0 && sqlite3Strlen30(zRight) == (FILE_HEADER_SZ*2)+3) {\n          unsigned char *salt = (unsigned char*) sqlite3_malloc(FILE_HEADER_SZ);\n          const unsigned char *hex = (const unsigned char *)zRight+2;\n          cipher_hex2bin(hex,FILE_HEADER_SZ*2,salt);\n          sqlcipher_codec_ctx_set_kdf_salt(ctx, salt, FILE_HEADER_SZ);\n          sqlite3_free(salt);\n        }\n      } else {\n        void *salt;\n        char *hexsalt = (char*) sqlite3_malloc((FILE_HEADER_SZ*2)+1);\n        if((rc = sqlcipher_codec_ctx_get_kdf_salt(ctx, &salt)) == SQLITE_OK) {\n          cipher_bin2hex(salt, FILE_HEADER_SZ, hexsalt);\n          codec_vdbe_return_string(pParse, \"cipher_salt\", hexsalt, P4_DYNAMIC);\n        } else {\n          sqlite3_free(hexsalt);\n          sqlcipher_codec_ctx_set_error(ctx, rc);\n        }\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_hmac_algorithm\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        rc = SQLITE_ERROR;\n        if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA1_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA1);\n        } else if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA256_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA256);\n        } else if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA512_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA512);\n        }\n        if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n        rc = codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n        if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n      } else {\n        int algorithm = sqlcipher_codec_ctx_get_hmac_algorithm(ctx);\n        if(algorithm == SQLCIPHER_HMAC_SHA1) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_algorithm\", SQLCIPHER_HMAC_SHA1_LABEL, P4_TRANSIENT);\n        } else if(algorithm == SQLCIPHER_HMAC_SHA256) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_algorithm\", SQLCIPHER_HMAC_SHA256_LABEL, P4_TRANSIENT);\n        } else if(algorithm == SQLCIPHER_HMAC_SHA512) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_algorithm\", SQLCIPHER_HMAC_SHA512_LABEL, P4_TRANSIENT);\n        }\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_default_hmac_algorithm\")==0 ){\n    if(zRight) {\n      rc = SQLITE_ERROR;\n      if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA1_LABEL) == 0) {\n        rc = sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA1);\n      } else if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA256_LABEL) == 0) {\n        rc = sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA256);\n      } else if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA512_LABEL) == 0) {\n        rc = sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA512);\n      }\n    } else {\n      int algorithm = sqlcipher_get_default_hmac_algorithm();\n      if(algorithm == SQLCIPHER_HMAC_SHA1) {\n        codec_vdbe_return_string(pParse, \"cipher_default_hmac_algorithm\", SQLCIPHER_HMAC_SHA1_LABEL, P4_TRANSIENT);\n      } else if(algorithm == SQLCIPHER_HMAC_SHA256) {\n        codec_vdbe_return_string(pParse, \"cipher_default_hmac_algorithm\", SQLCIPHER_HMAC_SHA256_LABEL, P4_TRANSIENT);\n      } else if(algorithm == SQLCIPHER_HMAC_SHA512) {\n        codec_vdbe_return_string(pParse, \"cipher_default_hmac_algorithm\", SQLCIPHER_HMAC_SHA512_LABEL, P4_TRANSIENT);\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_kdf_algorithm\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        rc = SQLITE_ERROR;\n        if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA1);\n        } else if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA256);\n        } else if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA512);\n        }\n        if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n      } else {\n        int algorithm = sqlcipher_codec_ctx_get_kdf_algorithm(ctx);\n        if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA1) {\n          codec_vdbe_return_string(pParse, \"cipher_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL, P4_TRANSIENT);\n        } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA256) {\n          codec_vdbe_return_string(pParse, \"cipher_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL, P4_TRANSIENT);\n        } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA512) {\n          codec_vdbe_return_string(pParse, \"cipher_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL, P4_TRANSIENT);\n        }\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_default_kdf_algorithm\")==0 ){\n    if(zRight) {\n      rc = SQLITE_ERROR;\n      if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL) == 0) {\n        rc = sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA1);\n      } else if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL) == 0) {\n        rc = sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA256);\n      } else if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL) == 0) {\n        rc = sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA512);\n      }\n    } else {\n      int algorithm = sqlcipher_get_default_kdf_algorithm();\n      if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA1) {\n        codec_vdbe_return_string(pParse, \"cipher_default_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL, P4_TRANSIENT);\n      } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA256) {\n        codec_vdbe_return_string(pParse, \"cipher_default_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL, P4_TRANSIENT);\n      } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA512) {\n        codec_vdbe_return_string(pParse, \"cipher_default_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL, P4_TRANSIENT);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_compatibility\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        int version = atoi(zRight); \n\n        switch(version) {\n          case 1: \n            rc = sqlcipher_codec_ctx_set_pagesize(ctx, 1024);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_iter(ctx, 4000); \n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_use_hmac(ctx, 0);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            break;\n\n          case 2: \n            rc = sqlcipher_codec_ctx_set_pagesize(ctx, 1024);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_iter(ctx, 4000); \n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_use_hmac(ctx, 1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            break;\n\n          case 3:\n            rc = sqlcipher_codec_ctx_set_pagesize(ctx, 1024);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_iter(ctx, 64000); \n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_use_hmac(ctx, 1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            break;\n\n          default:\n            rc = sqlcipher_codec_ctx_set_pagesize(ctx, 4096);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA512);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA512);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_iter(ctx, 256000); \n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_use_hmac(ctx, 1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            break;\n        }  \n\n        rc = codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n        if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n      } \n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_default_compatibility\")==0 ){\n    if(zRight) {\n      int version = atoi(zRight); \n      switch(version) {\n        case 1: \n          sqlcipher_set_default_pagesize(1024);\n          sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA1);\n          sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA1);\n          sqlcipher_set_default_kdf_iter(4000);\n          sqlcipher_set_default_use_hmac(0);\n          break;\n\n        case 2: \n          sqlcipher_set_default_pagesize(1024);\n          sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA1);\n          sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA1);\n          sqlcipher_set_default_kdf_iter(4000);\n          sqlcipher_set_default_use_hmac(1);\n          break;\n\n        case 3:\n          sqlcipher_set_default_pagesize(1024);\n          sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA1);\n          sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA1);\n          sqlcipher_set_default_kdf_iter(64000);\n          sqlcipher_set_default_use_hmac(1);\n          break;\n\n        default:\n          sqlcipher_set_default_pagesize(4096);\n          sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA512);\n          sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA512);\n          sqlcipher_set_default_kdf_iter(256000);\n          sqlcipher_set_default_use_hmac(1);\n          break;\n      }  \n    } \n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_memory_security\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_mem_security(sqlite3GetBoolean(zRight,1));\n    } else {\n      char *on = sqlite3_mprintf(\"%d\", sqlcipher_get_mem_security());\n      codec_vdbe_return_string(pParse, \"cipher_memory_security\", on, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_settings\")==0 ){\n    if(ctx) {\n      int algorithm;\n      char *pragma;\n\n      pragma = sqlite3_mprintf(\"PRAGMA kdf_iter = %d;\", sqlcipher_codec_ctx_get_kdf_iter(ctx));\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_page_size = %d;\", sqlcipher_codec_ctx_get_pagesize(ctx));\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_use_hmac = %d;\", sqlcipher_codec_ctx_get_use_hmac(ctx));\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_plaintext_header_size = %d;\", sqlcipher_codec_ctx_get_plaintext_header_size(ctx));\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      algorithm = sqlcipher_codec_ctx_get_hmac_algorithm(ctx);\n      pragma = NULL;\n      if(algorithm == SQLCIPHER_HMAC_SHA1) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA1_LABEL);\n      } else if(algorithm == SQLCIPHER_HMAC_SHA256) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA256_LABEL);\n      } else if(algorithm == SQLCIPHER_HMAC_SHA512) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA512_LABEL);\n      }\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      algorithm = sqlcipher_codec_ctx_get_kdf_algorithm(ctx);\n      pragma = NULL;\n      if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA1) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL);\n      } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA256) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL);\n      } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA512) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL);\n      }\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_default_settings\")==0 ){\n    int algorithm;\n    char *pragma;\n\n    pragma = sqlite3_mprintf(\"PRAGMA cipher_default_kdf_iter = %d;\", sqlcipher_get_default_kdf_iter());\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    pragma = sqlite3_mprintf(\"PRAGMA cipher_default_page_size = %d;\", sqlcipher_get_default_pagesize());\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    pragma = sqlite3_mprintf(\"PRAGMA cipher_default_use_hmac = %d;\", sqlcipher_get_default_use_hmac());\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    pragma = sqlite3_mprintf(\"PRAGMA cipher_default_plaintext_header_size = %d;\", sqlcipher_get_default_plaintext_header_size());\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    algorithm = sqlcipher_get_default_hmac_algorithm();\n    pragma = NULL;\n    if(algorithm == SQLCIPHER_HMAC_SHA1) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA1_LABEL);\n    } else if(algorithm == SQLCIPHER_HMAC_SHA256) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA256_LABEL);\n    } else if(algorithm == SQLCIPHER_HMAC_SHA512) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA512_LABEL);\n    }\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    algorithm = sqlcipher_get_default_kdf_algorithm();\n    pragma = NULL;\n    if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA1) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL);\n    } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA256) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL);\n    } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA512) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL);\n    }\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_integrity_check\")==0 ){\n    if(ctx) {\n      sqlcipher_codec_ctx_integrity_check(ctx, pParse, \"cipher_integrity_check\");\n    }\n  }else {\n    return 0;\n  }\n  return 1;\n}\n\n/* these constants are used internally within SQLite's pager.c to differentiate between\n   operations on the main database or journal pages. This is important in the context\n   of a rekey operations, where the journal must be written using the original key \n   material (to allow a transactional rollback), while the new database pages are being\n   written with the new key material*/\n#define CODEC_READ_OP 3\n#define CODEC_WRITE_OP 6\n#define CODEC_JOURNAL_OP 7\n\n/*\n * sqlite3Codec can be called in multiple modes.\n * encrypt mode - expected to return a pointer to the \n *   encrypted data without altering pData.\n * decrypt mode - expected to return a pointer to pData, with\n *   the data decrypted in the input buffer\n */\nstatic void* sqlite3Codec(void *iCtx, void *data, Pgno pgno, int mode) {\n  codec_ctx *ctx = (codec_ctx *) iCtx;\n  int offset = 0, rc = 0;\n  int page_sz = sqlcipher_codec_ctx_get_pagesize(ctx); \n  unsigned char *pData = (unsigned char *) data;\n  void *buffer = sqlcipher_codec_ctx_get_data(ctx);\n  int plaintext_header_sz = sqlcipher_codec_ctx_get_plaintext_header_size(ctx);\n  int cctx = CIPHER_READ_CTX;\n\n  CODEC_TRACE(\"sqlite3Codec: entered pgno=%d, mode=%d, page_sz=%d\\n\", pgno, mode, page_sz);\n\n#ifdef SQLCIPHER_EXT\n  if(sqlcipher_license_check(ctx) != SQLITE_OK) return NULL;\n#endif\n\n  /* call to derive keys if not present yet */\n  if((rc = sqlcipher_codec_key_derive(ctx)) != SQLITE_OK) {\n   sqlcipher_codec_ctx_set_error(ctx, rc); \n   return NULL;\n  }\n\n  /* if the plaintext_header_size is negative that means an invalid size was set via \n     PRAGMA. We can't set the error state on the pager at that point because the pager\n     may not be open yet. However, this is a fatal error state, so abort the codec */\n  if(plaintext_header_sz < 0) {\n    sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n    return NULL;\n  }\n\n  if(pgno == 1) /* adjust starting pointers in data page for header offset on first page*/   \n    offset = plaintext_header_sz ? plaintext_header_sz : FILE_HEADER_SZ; \n  \n\n  CODEC_TRACE(\"sqlite3Codec: switch mode=%d offset=%d\\n\",  mode, offset);\n  switch(mode) {\n    case CODEC_READ_OP: /* decrypt */\n      if(pgno == 1) /* copy initial part of file header or SQLite magic to buffer */ \n        memcpy(buffer, plaintext_header_sz ? pData : (void *) SQLITE_FILE_HEADER, offset); \n\n      rc = sqlcipher_page_cipher(ctx, cctx, pgno, CIPHER_DECRYPT, page_sz - offset, pData + offset, (unsigned char*)buffer + offset);\n#ifdef SQLCIPHER_TEST\n      if(cipher_fail_next_decrypt) rc = SQLITE_ERROR;\n#endif\n      if(rc != SQLITE_OK) { /* clear results of failed cipher operation and set error */\n        sqlcipher_memset((unsigned char*) buffer+offset, 0, page_sz-offset);\n        sqlcipher_codec_ctx_set_error(ctx, rc);\n      }\n      memcpy(pData, buffer, page_sz); /* copy buffer data back to pData and return */\n      return pData;\n      break;\n\n    case CODEC_WRITE_OP: /* encrypt database page, operate on write context and fall through to case 7, so the write context is used*/\n      cctx = CIPHER_WRITE_CTX; \n\n    case CODEC_JOURNAL_OP: /* encrypt journal page, operate on read context use to get the original page data from the database */ \n      if(pgno == 1) { /* copy initial part of file header or salt to buffer */ \n        void *kdf_salt = NULL; \n        /* retrieve the kdf salt */\n        if((rc = sqlcipher_codec_ctx_get_kdf_salt(ctx, &kdf_salt)) != SQLITE_OK) {\n          sqlcipher_codec_ctx_set_error(ctx, rc); \n          return NULL;\n        }\n        memcpy(buffer, plaintext_header_sz ? pData : kdf_salt, offset); \n      }\n      rc = sqlcipher_page_cipher(ctx, cctx, pgno, CIPHER_ENCRYPT, page_sz - offset, pData + offset, (unsigned char*)buffer + offset);\n#ifdef SQLCIPHER_TEST\n      if(cipher_fail_next_encrypt) rc = SQLITE_ERROR;\n#endif\n      if(rc != SQLITE_OK) { /* clear results of failed cipher operation and set error */\n        sqlcipher_memset((unsigned char*)buffer+offset, 0, page_sz-offset);\n        sqlcipher_codec_ctx_set_error(ctx, rc);\n        return NULL;\n      }\n      return buffer; /* return persistent buffer data, pData remains intact */\n      break;\n\n    default:\n      sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR); /* unsupported mode, set error */\n      return pData;\n      break;\n  }\n}\n\nstatic void sqlite3FreeCodecArg(void *pCodecArg) {\n  codec_ctx *ctx = (codec_ctx *) pCodecArg;\n  if(pCodecArg == NULL) return;\n  sqlcipher_codec_ctx_free(&ctx); /* wipe and free allocated memory for the context */\n  sqlcipher_deactivate(); /* cleanup related structures, OpenSSL etc, when codec is detatched */\n}\n\nint sqlite3CodecAttach(sqlite3* db, int nDb, const void *zKey, int nKey) {\n  struct Db *pDb = &db->aDb[nDb];\n\n  CODEC_TRACE(\"sqlite3CodecAttach: entered db=%p, nDb=%d zKey=%s, nKey=%d\\n\", db, nDb, (char *)zKey, nKey);\n\n\n  if(nKey && zKey && pDb->pBt) {\n    int rc;\n    Pager *pPager = pDb->pBt->pBt->pPager;\n    sqlite3_file *fd;\n    codec_ctx *ctx;\n\n    /* check if the sqlite3_file is open, and if not force handle to NULL */ \n    if((fd = sqlite3PagerFile(pPager))->pMethods == 0) fd = NULL; \n\n    CODEC_TRACE(\"sqlite3CodecAttach: calling sqlcipher_activate()\\n\");\n    sqlcipher_activate(); /* perform internal initialization for sqlcipher */\n\n    CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: entering database mutex %p\\n\", db->mutex);\n    sqlite3_mutex_enter(db->mutex);\n    CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: entered database mutex %p\\n\", db->mutex);\n\n#ifdef SQLCIPHER_EXT\n    if((rc = sqlite3_set_authorizer(db, sqlcipher_license_authorizer, db)) != SQLITE_OK) {\n      sqlite3_mutex_leave(db->mutex);\n      return rc;\n    }\n#endif\n\n    /* point the internal codec argument against the contet to be prepared */\n    CODEC_TRACE(\"sqlite3CodecAttach: calling sqlcipher_codec_ctx_init()\\n\");\n    rc = sqlcipher_codec_ctx_init(&ctx, pDb, pDb->pBt->pBt->pPager, zKey, nKey);\n\n    if(rc != SQLITE_OK) {\n      /* initialization failed, do not attach potentially corrupted context */\n      CODEC_TRACE(\"sqlite3CodecAttach: context initialization failed with rc=%d\\n\", rc);\n      /* force an error at the pager level, such that even the upstream caller ignores the return code\n         the pager will be in an error state and will process no further operations */\n      sqlite3pager_error(pPager, rc);\n      pDb->pBt->pBt->db->errCode = rc;\n      CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: leaving database mutex %p (early return on rc=%d)\\n\", db->mutex, rc);\n      sqlite3_mutex_leave(db->mutex);\n      CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: left database mutex %p (early return on rc=%d)\\n\", db->mutex, rc);\n      return rc;\n    }\n\n    CODEC_TRACE(\"sqlite3CodecAttach: calling sqlite3PagerSetCodec()\\n\");\n    sqlite3PagerSetCodec(sqlite3BtreePager(pDb->pBt), sqlite3Codec, NULL, sqlite3FreeCodecArg, (void *) ctx);\n\n    CODEC_TRACE(\"sqlite3CodecAttach: calling codec_set_btree_to_codec_pagesize()\\n\");\n    codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n\n    /* force secure delete. This has the benefit of wiping internal data when deleted\n       and also ensures that all pages are written to disk (i.e. not skipped by\n       sqlite3PagerDontWrite optimizations) */ \n    CODEC_TRACE(\"sqlite3CodecAttach: calling sqlite3BtreeSecureDelete()\\n\");\n    sqlite3BtreeSecureDelete(pDb->pBt, 1); \n\n    /* if fd is null, then this is an in-memory database and\n       we dont' want to overwrite the AutoVacuum settings\n       if not null, then set to the default */\n    if(fd != NULL) { \n      CODEC_TRACE(\"sqlite3CodecAttach: calling sqlite3BtreeSetAutoVacuum()\\n\");\n      sqlite3BtreeSetAutoVacuum(pDb->pBt, SQLITE_DEFAULT_AUTOVACUUM);\n    }\n    CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: leaving database mutex %p\\n\", db->mutex);\n    sqlite3_mutex_leave(db->mutex);\n    CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: left database mutex %p\\n\", db->mutex);\n  }\n  return SQLITE_OK;\n}\n\nint sqlcipher_find_db_index(sqlite3 *db, const char *zDb) {\n  int db_index;\n  if(zDb == NULL){\n    return 0;\n  }\n  for(db_index = 0; db_index < db->nDb; db_index++) {\n    struct Db *pDb = &db->aDb[db_index];\n    if(strcmp(pDb->zDbSName, zDb) == 0) {\n      return db_index;\n    }\n  }\n  return 0;\n}\n\nvoid sqlite3_activate_see(const char* in) {\n  /* do nothing, security enhancements are always active */\n}\n\nint sqlite3_key(sqlite3 *db, const void *pKey, int nKey) {\n  CODEC_TRACE(\"sqlite3_key entered: db=%p pKey=%s nKey=%d\\n\", db, (char *)pKey, nKey);\n  return sqlite3_key_v2(db, \"main\", pKey, nKey);\n}\n\nint sqlite3_key_v2(sqlite3 *db, const char *zDb, const void *pKey, int nKey) {\n  CODEC_TRACE(\"sqlite3_key_v2: entered db=%p zDb=%s pKey=%s nKey=%d\\n\", db, zDb, (char *)pKey, nKey);\n  /* attach key if db and pKey are not null and nKey is > 0 */\n  if(db && pKey && nKey) {\n    int db_index = sqlcipher_find_db_index(db, zDb);\n    return sqlite3CodecAttach(db, db_index, pKey, nKey); \n  }\n  return SQLITE_ERROR;\n}\n\nint sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey) {\n  CODEC_TRACE(\"sqlite3_rekey entered: db=%p pKey=%s nKey=%d\\n\", db, (char *)pKey, nKey);\n  return sqlite3_rekey_v2(db, \"main\", pKey, nKey);\n}\n\n/* sqlite3_rekey_v2\n** Given a database, this will reencrypt the database using a new key.\n** There is only one possible modes of operation - to encrypt a database\n** that is already encrpyted. If the database is not already encrypted\n** this should do nothing\n** The proposed logic for this function follows:\n** 1. Determine if the database is already encryptped\n** 2. If there is NOT already a key present do nothing\n** 3. If there is a key present, re-encrypt the database with the new key\n*/\nint sqlite3_rekey_v2(sqlite3 *db, const char *zDb, const void *pKey, int nKey) {\n  CODEC_TRACE(\"sqlite3_rekey_v2: entered db=%p zDb=%s pKey=%s, nKey=%d\\n\", db, zDb, (char *)pKey, nKey);\n  if(db && pKey && nKey) {\n    int db_index = sqlcipher_find_db_index(db, zDb);\n    struct Db *pDb = &db->aDb[db_index];\n    CODEC_TRACE(\"sqlite3_rekey_v2: database pDb=%p db_index:%d\\n\", pDb, db_index);\n    if(pDb->pBt) {\n      codec_ctx *ctx;\n      int rc, page_count;\n      Pgno pgno;\n      PgHdr *page;\n      Pager *pPager = pDb->pBt->pBt->pPager;\n\n      ctx = (codec_ctx*) sqlite3PagerGetCodec(pDb->pBt->pBt->pPager);\n     \n      if(ctx == NULL) { \n        /* there was no codec attached to this database, so this should do nothing! */ \n        CODEC_TRACE(\"sqlite3_rekey_v2: no codec attached to db, exiting\\n\");\n        return SQLITE_OK;\n      }\n\n      CODEC_TRACE_MUTEX(\"sqlite3_rekey_v2: entering database mutex %p\\n\", db->mutex);\n      sqlite3_mutex_enter(db->mutex);\n      CODEC_TRACE_MUTEX(\"sqlite3_rekey_v2: entered database mutex %p\\n\", db->mutex);\n\n      codec_set_pass_key(db, db_index, pKey, nKey, CIPHER_WRITE_CTX);\n    \n      /* do stuff here to rewrite the database \n      ** 1. Create a transaction on the database\n      ** 2. Iterate through each page, reading it and then writing it.\n      ** 3. If that goes ok then commit and put ctx->rekey into ctx->key\n      **    note: don't deallocate rekey since it may be used in a subsequent iteration \n      */\n      rc = sqlite3BtreeBeginTrans(pDb->pBt, 1, 0); /* begin write transaction */\n      sqlite3PagerPagecount(pPager, &page_count);\n      for(pgno = 1; rc == SQLITE_OK && pgno <= (unsigned int)page_count; pgno++) { /* pgno's start at 1 see pager.c:pagerAcquire */\n        if(!sqlite3pager_is_mj_pgno(pPager, pgno)) { /* skip this page (see pager.c:pagerAcquire for reasoning) */\n          rc = sqlite3PagerGet(pPager, pgno, &page, 0);\n          if(rc == SQLITE_OK) { /* write page see pager_incr_changecounter for example */\n            rc = sqlite3PagerWrite(page);\n            if(rc == SQLITE_OK) {\n              sqlite3PagerUnref(page);\n            } else {\n             CODEC_TRACE(\"sqlite3_rekey_v2: error %d occurred writing page %d\\n\", rc, pgno);  \n            }\n          } else {\n             CODEC_TRACE(\"sqlite3_rekey_v2: error %d occurred getting page %d\\n\", rc, pgno);  \n          }\n        } \n      }\n\n      /* if commit was successful commit and copy the rekey data to current key, else rollback to release locks */\n      if(rc == SQLITE_OK) { \n        CODEC_TRACE(\"sqlite3_rekey_v2: committing\\n\");\n        rc = sqlite3BtreeCommit(pDb->pBt); \n        sqlcipher_codec_key_copy(ctx, CIPHER_WRITE_CTX);\n      } else {\n        CODEC_TRACE(\"sqlite3_rekey_v2: rollback\\n\");\n        sqlite3BtreeRollback(pDb->pBt, SQLITE_ABORT_ROLLBACK, 0);\n      }\n\n      CODEC_TRACE_MUTEX(\"sqlite3_rekey_v2: leaving database mutex %p\\n\", db->mutex);\n      sqlite3_mutex_leave(db->mutex);\n      CODEC_TRACE_MUTEX(\"sqlite3_rekey_v2: left database mutex %p\\n\", db->mutex);\n    }\n    return SQLITE_OK;\n  }\n  return SQLITE_ERROR;\n}\n\nvoid sqlite3CodecGetKey(sqlite3* db, int nDb, void **zKey, int *nKey) {\n  struct Db *pDb = &db->aDb[nDb];\n  CODEC_TRACE(\"sqlite3CodecGetKey: entered db=%p, nDb=%d\\n\", db, nDb);\n  if( pDb->pBt ) {\n    codec_ctx *ctx = (codec_ctx*) sqlite3PagerGetCodec(pDb->pBt->pBt->pPager);\n    \n    if(ctx) {\n      /* pass back the keyspec from the codec, unless PRAGMA cipher_store_pass\n         is set or keyspec has not yet been derived, in which case pass\n         back the password key material */\n      sqlcipher_codec_get_keyspec(ctx, zKey, nKey);\n      if(sqlcipher_codec_get_store_pass(ctx) == 1 || *zKey == NULL) {\n        sqlcipher_codec_get_pass(ctx, zKey, nKey);\n      }\n    } else {\n      *zKey = NULL;\n      *nKey = 0;\n    }\n  }\n}\n\n/*\n * Implementation of an \"export\" function that allows a caller\n * to duplicate the main database to an attached database. This is intended\n * as a conveneince for users who need to:\n * \n *   1. migrate from an non-encrypted database to an encrypted database\n *   2. move from an encrypted database to a non-encrypted database\n *   3. convert beween the various flavors of encrypted databases.  \n *\n * This implementation is based heavily on the procedure and code used\n * in vacuum.c, but is exposed as a function that allows export to any\n * named attached database.\n */\n\n/*\n** Finalize a prepared statement.  If there was an error, store the\n** text of the error message in *pzErrMsg.  Return the result code.\n** \n** Based on vacuumFinalize from vacuum.c\n*/\nstatic int sqlcipher_finalize(sqlite3 *db, sqlite3_stmt *pStmt, char **pzErrMsg){\n  int rc;\n  rc = sqlite3VdbeFinalize((Vdbe*)pStmt);\n  if( rc ){\n    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));\n  }\n  return rc;\n}\n\n/*\n** Execute zSql on database db. Return an error code.\n** \n** Based on execSql from vacuum.c\n*/\nstatic int sqlcipher_execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){\n  sqlite3_stmt *pStmt;\n  VVA_ONLY( int rc; )\n  if( !zSql ){\n    return SQLITE_NOMEM;\n  }\n  if( SQLITE_OK!=sqlite3_prepare(db, zSql, -1, &pStmt, 0) ){\n    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));\n    return sqlite3_errcode(db);\n  }\n  VVA_ONLY( rc = ) sqlite3_step(pStmt);\n  assert( rc!=SQLITE_ROW );\n  return sqlcipher_finalize(db, pStmt, pzErrMsg);\n}\n\n/*\n** Execute zSql on database db. The statement returns exactly\n** one column. Execute this as SQL on the same database.\n** \n** Based on execExecSql from vacuum.c\n*/\nstatic int sqlcipher_execExecSql(sqlite3 *db, char **pzErrMsg, const char *zSql){\n  sqlite3_stmt *pStmt;\n  int rc;\n\n  rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ) return rc;\n\n  while( SQLITE_ROW==sqlite3_step(pStmt) ){\n    rc = sqlcipher_execSql(db, pzErrMsg, (char*)sqlite3_column_text(pStmt, 0));\n    if( rc!=SQLITE_OK ){\n      sqlcipher_finalize(db, pStmt, pzErrMsg);\n      return rc;\n    }\n  }\n\n  return sqlcipher_finalize(db, pStmt, pzErrMsg);\n}\n\n/*\n * copy database and schema from the main database to an attached database\n * \n * Based on sqlite3RunVacuum from vacuum.c\n*/\nvoid sqlcipher_exportFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char* targetDb, *sourceDb; \n  int targetDb_idx = 0;\n  u64 saved_flags = db->flags;        /* Saved value of the db->flags */\n  u32 saved_mDbFlags = db->mDbFlags;        /* Saved value of the db->mDbFlags */\n  int saved_nChange = db->nChange;      /* Saved value of db->nChange */\n  int saved_nTotalChange = db->nTotalChange; /* Saved value of db->nTotalChange */\n  u8 saved_mTrace = db->mTrace;        /* Saved value of db->mTrace */\n  int rc = SQLITE_OK;     /* Return code from service routines */\n  char *zSql = NULL;         /* SQL statements */\n  char *pzErrMsg = NULL;\n\n  if(argc != 1 && argc != 2) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"invalid number of arguments (%d) passed to sqlcipher_export\", argc);\n    goto end_of_export;\n  }\n\n  targetDb = (const char*) sqlite3_value_text(argv[0]);\n  sourceDb = (argc == 2) ? (char *) sqlite3_value_text(argv[1]) : \"main\";\n\n  /* if the name of the target is not main, but the index returned is zero \n     there is a mismatch and we should not proceed */\n  targetDb_idx =  sqlcipher_find_db_index(db, targetDb);\n  if(targetDb_idx == 0 && sqlite3StrICmp(\"main\", targetDb) != 0) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"unknown database %s\", targetDb);\n    goto end_of_export;\n  }\n  db->init.iDb = targetDb_idx;\n\n  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks; \n  db->mDbFlags |= DBFLAG_PreferBuiltin | DBFLAG_Vacuum;\n  db->flags &= ~(u64)(SQLITE_ForeignKeys | SQLITE_ReverseOrder | SQLITE_Defensive | SQLITE_CountRows); \n  db->mTrace = 0;\n\n  /* Query the schema of the main database. Create a mirror schema\n  ** in the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE type='table' AND name!='sqlite_sequence'\"\n    \"   AND rootpage>0\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE INDEX %%' \"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %%'\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Loop through the tables in the main database. For each, do\n  ** an \"INSERT INTO rekey_db.xxx SELECT * FROM main.xxx;\" to copy\n  ** the contents to the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';'\"\n    \"FROM %s.sqlite_master \"\n    \"WHERE type = 'table' AND name!='sqlite_sequence' \"\n    \"  AND rootpage>0\"\n  , targetDb, sourceDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy over the contents of the sequence table\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';' \"\n    \"FROM %s.sqlite_master WHERE name=='sqlite_sequence';\"\n  , targetDb, sourceDb, targetDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy the triggers, views, and virtual tables from the main database\n  ** over to the temporary database.  None of these objects has any\n  ** associated storage, so all we have to do is copy their entries\n  ** from the SQLITE_MASTER table.\n  */\n  zSql = sqlite3_mprintf(\n    \"INSERT INTO %s.sqlite_master \"\n    \"  SELECT type, name, tbl_name, rootpage, sql\"\n    \"    FROM %s.sqlite_master\"\n    \"   WHERE type='view' OR type='trigger'\"\n    \"      OR (type='table' AND rootpage=0)\"\n  , targetDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = NULL;\nend_of_export:\n  db->init.iDb = 0;\n  db->flags = saved_flags;\n  db->mDbFlags = saved_mDbFlags;\n  db->nChange = saved_nChange;\n  db->nTotalChange = saved_nTotalChange;\n  db->mTrace = saved_mTrace;\n\n  if(zSql) sqlite3_free(zSql);\n\n  if(rc) {\n    if(pzErrMsg != NULL) {\n      sqlite3_result_error(context, pzErrMsg, -1);\n      sqlite3DbFree(db, pzErrMsg);\n    } else {\n      sqlite3_result_error(context, sqlite3ErrStr(rc), -1);\n    }\n  }\n}\n#endif\n/* END SQLCIPHER */\n", "# SQLCipher\n# codec.test developed by Stephen Lombardo (Zetetic LLC)\n# sjlombardo at zetetic dot net\n# http://zetetic.net\n#\n# Copyright (c) 2018, ZETETIC LLC\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#     * Redistributions of source code must retain the above copyright\n#       notice, this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of the ZETETIC LLC nor the\n#       names of its contributors may be used to endorse or promote products\n#       derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY ZETETIC LLC ''AS IS'' AND ANY\n# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL ZETETIC LLC BE LIABLE FOR ANY\n# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# This file implements regression tests for SQLite library.  The\n# focus of this script is testing code cipher features.\n#\n# NOTE: tester.tcl has overridden the definition of sqlite3 to\n# automatically pass in a key value. Thus tests in this file\n# should explicitly close and open db with sqlite_orig in order\n# to bypass default key assignment.\n\nset testdir [file dirname $argv0]\nsource $testdir/tester.tcl\nsource $testdir/sqlcipher.tcl\n\nset old_pending_byte [sqlite3_test_control_pending_byte 0x40000000]\n\n# create an unencrypted database, attach a new encrypted volume\n# copy data between, verify the encypted database is good afterwards\ndo_test unencrypted-attach {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  } \n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS db2 KEY 'testkey';\n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM t1;\n    DETACH DATABASE db2;\n  }\n  \n  sqlite_orig db2 test2.db\n  execsql {\n    PRAGMA  key='testkey';\n    SELECT count(*) FROM t1;\n  } db2 \n} {ok 1000}\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n# create an unencrypted database, attach a new encrypted volume\n# using a raw key copy data between, verify the encypted \n# database is good afterwards \ndo_test unencrypted-attach-raw-key {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  } \n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS db2 KEY \"x'10483C6EB40B6C31A448C22A66DED3B5E5E8D5119CAC8327B655C8B5C4836481'\";\n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM t1;\n    DETACH DATABASE db2;\n  }\n  \n  sqlite_orig db2 test2.db\n  execsql {\n    PRAGMA key=\"x'10483C6EB40B6C31A448C22A66DED3B5E5E8D5119CAC8327B655C8B5C4836481'\";\n    SELECT count(*) FROM t1;\n  } db2 \n} {ok 1000}\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n# open a 4.0 database \ndo_test compat-open-4.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-4.0-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\ndb close\n\n# create an encrypted database, attach an default-key encrypted volume\n# copy data between, verify the second database\ndo_test encrypted-attach-default-key {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA  key='testkey';\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS test;\n    CREATE TABLE test.t1(a,b);\n    INSERT INTO test.t1 SELECT * FROM t1;\n    DETACH DATABASE test;\n  } \n\n  sqlite_orig db2 test2.db\n\n  execsql {\n    PRAGMA  key='testkey';\n    SELECT count(*) FROM t1;\n  } db2\n} {ok 1000}\ndb close\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n# create an encrypted database, attach an unencrypted volume\n# copy data between, verify the unencypted database is good afterwards\ndo_test encrypted-attach-unencrypted {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n  } \n\n  sqlite_orig db2 test2.db\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }  db2\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" db2 \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test.db' AS test KEY '';\n    INSERT INTO test.t1 SELECT * FROM t1;\n    DETACH DATABASE test;\n  } db2\n\n  execsql {\n    SELECT count(*) FROM t1;\n  } \n} {1000}\ndb close\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n# create an unencrypted database, attach an encrypted database\n# then copy the data to it via sqlcipher_export and verify results\ndo_test unencrypted-to-encrypted-export {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" \n  }\n\n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS test2 KEY 'testkey2';\n    SELECT sqlcipher_export('test2');\n    DETACH DATABASE test2;\n  } \n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    SELECT count(*) FROM t1;\n  } \n\n  execsql {\n    SELECT count(*) FROM t1;\n  }\n} {1000}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\ndo_test unencrypted-corrupt-to-encrypted-export {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    INSERT INTO t1 VALUES (1,2);\n\n    PRAGMA writable_schema = ON;\n\n    UPDATE sqlite_master SET sql = 'CREATE TABLE IF NOT EXISTS t1(a,b)' \n    WHERE tbl_name = 't1';\n\n    PRAGMA writable_schema = OFF;\n    INSERT INTO t1 VALUES (3,4);\n\n    SELECT * FROM t1;\n\n    ATTACH DATABASE 'test2.db' AS test2 KEY 'testkey2';\n\n    SELECT sqlcipher_export('test2');\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    SELECT count(*) FROM sqlite_master;\n    SELECT count(*) FROM t1;\n  }\n} {ok 1 2}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n\n# create an encrypted database, attach an unencrypted database\n# with data in it, then import the data back into the encrypted DB\n# and verify\ndo_test unencrypted-to-encrypted-import {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\"\n  }\n\n  execsql {\n    COMMIT;\n  }\n  db close\n\n  sqlite_orig db test2.db\n\n  execsql {\n    PRAGMA key = 'testkey2';\n    ATTACH DATABASE 'test.db' AS test KEY '';\n    SELECT sqlcipher_export('main', 'test');\n    DETACH DATABASE test;\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    SELECT count(*) FROM t1;\n  }\n} {ok 1000}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n# create an unencrypted database, attach an unencrypted volume\n# copy data between, verify the unencypted database is good afterwards\ndo_test unencrypted-attach-unencrypted {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n  } \n\n  sqlite_orig db2 test2.db\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }  db2\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" db2 \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test.db' AS test;\n    INSERT INTO test.t1 SELECT * FROM t1;\n    DETACH DATABASE test;\n  } db2\n\n  execsql {\n    SELECT count(*) FROM t1;\n  } \n} {1000}\ndb close\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n\n# open a 1.1.8 database using the new code, HMAC disabled\ndo_test open-1.1.8-database {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db test.db\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_use_hmac = off;\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok 75709 1 1 one one 1 2 one two 1 2}\ndb close\nfile delete -force test.db\n\n# open a 1.1.8 database without hmac, then copy the data\ndo_test attach-and-copy-1.1.8 {\n  sqlite_orig db $sampleDir/sqlcipher-1.1.8-testkey.db\n  \n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_use_hmac = OFF;\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    ATTACH DATABASE 'test.db' AS db2 KEY 'testkey-hmac'; \n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM main.t1;\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey-hmac';\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  }\n} {ok 75709 1 1 one one 1 2 one two 1 2}\ndb close\nfile delete -force test.db\n\n\n# open a standard database, then attach a new \n# database with completely different options. \n# copy data between them, and verify that the\n# new database can be opened with the proper data\ndo_test attached-database-pragmas {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,'value $r');\" \n  } \n\n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS db2 KEY 'testkey2'; \n    PRAGMA db2.cipher_page_size = 8192;\n    PRAGMA db2.kdf_iter = 1000;\n    PRAGMA db2.cipher_use_hmac = OFF;\n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM main.t1;\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    PRAGMA cipher_page_size = 8192;\n    PRAGMA kdf_iter = 1000;\n    PRAGMA cipher_use_hmac = OFF;\n    SELECT count(*) FROM t1;\n  }\n} {ok 1000}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n# use the sqlcipher_export function\n# on a non-existent database. Verify \n# the error gets through.\ndo_test export-error {\n  sqlite_orig db test.db\n\n  catchsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a,b);\n    SELECT sqlcipher_export('nodb');\n  } \n} {1 {unknown database nodb}}\ndb close\nfile delete -force test.db\n\n# use the sqlcipher_export function\n# to copy a complicated database. \n# tests autoincrement fields,\n# indexes, views, and triggers,\n# tables and virtual tables\ndo_test export-database {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a INTEGER PRIMARY KEY AUTOINCREMENT, b, c);\n    CREATE UNIQUE INDEX b_idx ON t1(b);\n    CREATE INDEX c_idx ON t1(c);\n\n    CREATE TABLE t2(b,c);\n    CREATE TRIGGER t2_after_insert AFTER INSERT ON t2\n    BEGIN \n      INSERT INTO t1(b,c) VALUES (new.b, new.c);\n    END;\n\n    CREATE VIEW v1 AS\n      SELECT c FROM t1;\n\n    CREATE VIRTUAL TABLE fts USING fts5(a,b); \n\n    BEGIN;\n    -- start with one known value\n    INSERT INTO t2 VALUES(1000000,'value 1000000');\n  }\n\n  for {set i 1} {$i<=999} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t2 VALUES($i,'value $r');\" \n  } \n\n  execsql {\n    INSERT INTO fts SELECT b,c FROM t1;\n    COMMIT;\n\n    ATTACH DATABASE 'test2.db' AS db2 KEY 'testkey2'; \n    PRAGMA db2.cipher_page_size = 8192;\n\n    SELECT sqlcipher_export('db2');\n\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    PRAGMA cipher_page_size = 8192;\n    SELECT count(*) FROM t1;\n    SELECT count(*) FROM v1;\n    SELECT count(*) FROM sqlite_sequence;\n    SELECT seq FROM sqlite_sequence WHERE name = 't1';\n    INSERT INTO t2 VALUES(10001, 'value 938383');\n    SELECT count(*) FROM t1; -- verify the trigger worked\n    SELECT seq FROM sqlite_sequence WHERE name = 't1'; -- verify that autoincrement worked\n    SELECT a FROM fts WHERE b MATCH '1000000';  \n  }\n} {ok 1000 1000 1 1000 1001 1001 1000000}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n# use the sqlcipher_export function\n# to copy a complicated attached database to the main database\ndo_test export-attached-database {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a INTEGER PRIMARY KEY AUTOINCREMENT, b, c);\n    CREATE UNIQUE INDEX b_idx ON t1(b);\n    CREATE INDEX c_idx ON t1(c);\n\n    CREATE TABLE t2(b,c);\n    CREATE TRIGGER t2_after_insert AFTER INSERT ON t2\n    BEGIN\n      INSERT INTO t1(b,c) VALUES (new.b, new.c);\n    END;\n\n    CREATE VIEW v1 AS\n      SELECT c FROM t1;\n\n    CREATE VIRTUAL TABLE fts USING fts5(a,b);\n\n    BEGIN;\n    -- start with one known value\n    INSERT INTO t2 VALUES(1000000,'value 1000000');\n  }\n\n  for {set i 1} {$i<=999} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t2 VALUES($i,'value $r');\"\n  }\n\n  execsql {\n    INSERT INTO fts SELECT b,c FROM t1;\n    COMMIT;\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n\n    CREATE TABLE t3(a INTEGER PRIMARY KEY AUTOINCREMENT, b, c);\n    CREATE UNIQUE INDEX d_idx ON t3(b);\n    INSERT INTO t3(b,c) VALUES ('one', 'two');\n\n    ATTACH DATABASE 'test.db' AS db KEY 'testkey';\n\n    SELECT sqlcipher_export('main', 'db');\n\n    DETACH DATABASE db;\n    INSERT INTO t3(b,c) VALUES ('three', 'four');\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    SELECT count(*) FROM t1;\n    SELECT count(*) FROM v1;\n    SELECT count(*) FROM sqlite_sequence;\n    SELECT seq FROM sqlite_sequence WHERE name = 't1';\n    INSERT INTO t2 VALUES(10001, 'value 938383');\n    SELECT count(*) FROM t1; -- verify the trigger worked\n    SELECT seq FROM sqlite_sequence WHERE name = 't1'; -- verify that autoincrement worked\n    SELECT a FROM fts WHERE b MATCH '1000000';\n    SELECT count(*) FROM t3;\n  }\n} {ok 1000 1000 2 1000 1001 1001 1000000 2}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n\n# open the database then insert a bunch of data.\n# then delete it and run a manual vacuum\n# verify that the file has become smaller\n# but can still be opened with the proper\n# key. also test vacuum into functionality introduced\n# in sqlite 3.27.1\ndo_test vacuum {\n  sqlite_orig db test.db\n  set rc {}\n\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE table t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=10000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,'value $r');\" \n  }\n\n  lappend rc [execsql {\n    COMMIT;\n    SELECT count(*) FROM t1;\n  }]\n\n  # grab current size of file\n  set sz [file size test.db]\n\n  execsql {\n    DELETE FROM t1 WHERE rowid > 5000;\n    VACUUM into 'test-vacuum.db';\n    VACUUM;\n  } \n  db close\n\n  # grab separate vacuum file size\n  set sz2 [file size test-vacuum.db]\n\n  # grab test.db file size, post vacuum\n  set sz3 [file size test.db]\n\n  # verify that the new size is \n  # smaller than the old size\n  if {$sz > $sz2} { lappend rc true }\n  if {$sz > $sz3} { lappend rc true }\n\n  sqlite_orig db test-vacuum.db\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n  }]\n  db close\n\n  sqlite_orig db test.db\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n  }]\n\n} {10000 true true {ok 5000} {ok 5000}}\ndb close\nfile delete -force test.db\nfile delete -force test-vacuum.db\n\n# open a 1.1.8 database (no HMAC, 4K iter), then \n# try to open another 1.1.8 database. The\n# attached database should have the same hmac\n# setting as the original \ndo_test default-hmac-kdf-attach {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db test.db\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db sqlcipher-1.1.8-testkey.db;\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA cipher_default_use_hmac = OFF;\n    PRAGMA cipher_default_kdf_iter = 4000;\n    PRAGMA cipher_default_page_size = 1024;\n    PRAGMA cipher_default_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n    ATTACH 'sqlcipher-1.1.8-testkey.db' AS db2 KEY 'testkey';\n    SELECT count(*) from db2.t1;\n    PRAGMA cipher_default_use_hmac = ON;\n    PRAGMA cipher_default_kdf_iter = 256000;\n    PRAGMA cipher_default_page_size = 4096;\n    PRAGMA cipher_default_kdf_algorithm = PBKDF2_HMAC_SHA512;\n  } \n} {ok 75709 75709}\ndb close\nfile delete -force test.db\nfile delete -force sqlcipher-1.1.8-testkey.db\n\n# open a 2.0 database (with HMAC), then \n# try to a 1.1.8 database. this should \n# fail because the hmac setting for the \n# attached database is not compatible\ndo_test attach-1.1.8-database-from-2.0-fails {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db sqlcipher-1.1.8-testkey.db;\n  sqlite_orig db test.db\n  catchsql {\n    PRAGMA key = 'testkey';\n    CREATE table t1(a,b);\n    ATTACH 'sqlcipher-1.1.8-testkey.db' AS db2 KEY 'testkey';\n  } \n} {1 {file is not a database}}\ndb close\nfile delete -force test.db\nfile delete -force sqlcipher-1.1.8-testkey.db\n\n# open a 2.0 database (with HMAC, 4k iter), then \n# set the default hmac setting to OFF.\n# try to a 1.1.8 database. this should \n# succeed now that hmac is off by default\n# before the attach\ndo_test change-default-hmac-kdf-attach {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db sqlcipher-1.1.8-testkey.db;\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE table t1(a,b);\n    INSERT INTO t1(a,b) VALUES (1,2);\n  }\n  db close\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n    PRAGMA cipher_default_use_hmac = OFF;\n    PRAGMA cipher_default_kdf_iter = 4000;\n    PRAGMA cipher_default_page_size = 1024;\n    PRAGMA cipher_default_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    ATTACH 'sqlcipher-1.1.8-testkey.db' AS db2 KEY 'testkey';\n    SELECT count(*) from db2.t1;\n    PRAGMA cipher_default_use_hmac = ON;\n    PRAGMA cipher_default_kdf_iter = 256000;\n    PRAGMA cipher_default_page_size = 4096;\n    PRAGMA cipher_default_kdf_algorithm = PBKDF2_HMAC_SHA512;\n  } \n} {ok 1 75709}\ndb close\nfile delete -force test.db\nfile delete -force sqlcipher-1.1.8-testkey.db\n\n\n# create a new database, insert some data\n# and delete some data with \n# auto_vacuum on\ndo_test auto-vacuum-full {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'test123';\n    PRAGMA auto_vacuum = FULL;\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<10000} {incr i} {\n    set r [expr {int(rand()*32767)}]\n    set r1 [expr {int(rand()*32767)}]\n    execsql \"INSERT INTO t1 VALUES($r,$r1);\"\n  }\n  set r [expr {int(rand()*32767)}]\n  execsql \"DELETE FROM t1 WHERE a < $r;\"\n\n  execsql {\n    COMMIT;\n    PRAGMA integrity_check;\n    PRAGMA freelist_count;\n    SELECT (count(*) > 0) FROM t1;\n  }\n} {ok 0 1}\ndb close\nfile delete -force test.db\n\n# create a new database, insert some data\n# and delete some data with \n# auto_vacuum incremental \ndo_test auto-vacuum-incremental {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'test123';\n    PRAGMA auto_vacuum = INCREMENTAL;\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<10000} {incr i} {\n    set r [expr {int(rand()*32767)}]\n    set r1 [expr {int(rand()*32767)}]\n    execsql \"INSERT INTO t1 VALUES($r,$r1);\"\n  }\n  set r [expr {int(rand()*32767)}]\n  execsql \"DELETE FROM t1 WHERE a < $r;\"\n\n  execsql {\n    COMMIT;\n    PRAGMA incremental_vacuum;\n    PRAGMA freelist_count; \n    PRAGMA integrity_check;\n    SELECT (count(*) > 0) FROM t1;\n  }\n} {0 ok 1}\ndb close\nfile delete -force test.db\n\n\n# create a database with many hundred tables such that the schema\n# will overflow the first several pages of the database. verify the schema\n# is intact on open.\ndo_test multipage-schema {\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    BEGIN EXCLUSIVE;\n  } db\n  \n  for {set i 1} {$i<=300} {incr i} {\n    execsql \"CREATE TABLE tab$i (a TEXT, b TEXT, c TEXT, d TEXT, e TEXT, f TEXT, g TEXT, h TEXT, i TEXT, j TEXT, k, TEXT, l, m TEXT, n TEXT, o TEXT, p TEXT);\" db\n  }\n\n  execsql {\n    COMMIT;\n  } db\n\n  db close\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master where type = 'table';\n  } db\n\n} {ok 300}\ndb close\nfile delete -force test.db\n\n# create a database with many hundred tables such that the schema\n# will overflow the first several pages of the database. this time, enable\n# autovacuum on the database, which will cause sqlite to do some \"short reads\"\n# after the end of the main database file. verify that there are no HMAC errors\n# resulting from the short reads, and that the schema is intact when \n# the database is reopened\ndo_test multipage-schema-autovacuum-shortread {\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA auto_vacuum = FULL;\n    BEGIN EXCLUSIVE;\n  } db\n  \n  for {set i 1} {$i<=300} {incr i} {\n    execsql \"CREATE TABLE tab$i (a TEXT, b TEXT, c TEXT, d TEXT, e TEXT, f TEXT, g TEXT, h TEXT, i TEXT, j TEXT, k, TEXT, l, m TEXT, n TEXT, o TEXT, p TEXT);\" db\n  }\n\n  execsql {\n    COMMIT;\n  } db\n\n  db close\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master where type = 'table';\n  } db\n\n} {ok 300}\ndb close\nfile delete -force test.db\n\n# same as multi-page-schema-autovacuum-shortread, except\n# using write ahead log mode\ndo_test multipage-schema-autovacuum-shortread-wal {\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA auto_vacuum = FULL;\n    PRAGMA journal_mode = WAL;\n    BEGIN EXCLUSIVE;\n  } db\n  \n  for {set i 1} {$i<=300} {incr i} {\n    execsql \"CREATE TABLE tab$i (a TEXT, b TEXT, c TEXT, d TEXT, e TEXT, f TEXT, g TEXT, h TEXT, i TEXT, j TEXT, k, TEXT, l, m TEXT, n TEXT, o TEXT, p TEXT);\" db\n  }\n\n  execsql {\n    COMMIT;\n  } db\n\n  db close\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master where type = 'table';\n  } db\n} {ok 300}\ndb close\nfile delete -force test.db\n\n# open a 3.0 database with little endian hmac page numbers (default)\n# verify it can be opened\ndo_test open-3.0-le-database {\n  sqlite_orig db $sampleDir/sqlcipher-3.0-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA kdf_iter = 64000;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok 78536 1 1 one one 1 2 one two}\ndb close\n\n# open a 2.0 database with little endian hmac page numbers (default)\n# verify it can be opened\ndo_test open-2.0-le-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-le-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok 78536 1 1 one one 1 2 one two}\ndb close\n\n# open a 2.0 database with big-endian hmac page numbers\n# verify it can be opened\ndo_test open-2.0-be-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-be-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_hmac_pgno = be;\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok {PRAGMA cipher_hmac_pgno is deprecated, please remove from use} 78536 1 1 one one 1 2 one two}\ndb close\n\n# open a 2.0 database with big-endian hmac page numbers\n# attach a new database with little endian page numbers (default)\n# copy schema between the two, and verify the latter \n# can be opened\ndo_test be-to-le-migration {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-be-testkey.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_hmac_pgno = be;\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    ATTACH DATABASE 'test.db' AS db2 KEY 'testkey'; \n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM main.t1;\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  }\n} {ok 78536 1 1 one one 1 2 one two}\ndb close\nfile delete -force test.db\n\n\n\n# open a 2.0 beta database with 4000 round hmac kdf and 0x00 \n# hmac salt mask \n# verify it can be opened\ndo_test open-2.0-beta-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-beta-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA kdf_iter = 4000;\n    PRAGMA fast_kdf_iter = 4000;\n    PRAGMA cipher_hmac_salt_mask = \"x'00'\";\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok {PRAGMA fast_kdf_iter is deprecated, please remove from use} {PRAGMA cipher_hmac_salt_mask is deprecated, please remove from use} 38768 test-0-0 test-0-1 test-1-0 test-1-1}\ndb close\n\n# open a 2.0 beta database \n# attach a new standard database\n# copy schema between the two, and verify the latter \n# can be opened\ndo_test 2.0-beta-to-2.0-migration {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-beta-testkey.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_hmac_salt_mask = \"x'00'\";\n    PRAGMA kdf_iter = 4000;\n    PRAGMA fast_kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM sqlite_master;\n\n    PRAGMA cipher_hmac_salt_mask = \"x'3a'\";\n    ATTACH DATABASE 'test.db' AS db2 KEY 'testkey'; \n    \n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM main.t1;\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT distinct * FROM t1;\n  }\n} {ok test-0-0 test-0-1 test-1-0 test-1-1}\ndb close\nfile delete -force test.db\n\ndo_test migrate-1.1.8-database-to-current-format {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db test.db\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_migrate;\n  }\n  db close\n    \n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master;\n  }\n} {ok 1}\ndb close\nfile delete -force test.db test.db-migrated test.db-journal\n\ndo_test migrate-2-0-le-database-to-current-format {\n  file copy -force $sampleDir/sqlcipher-2.0-le-testkey.db test.db\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_migrate;\n  }\n  db close\n    \n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master;\n  }\n} {ok 1}\ndb close\nfile delete -force test.db test.db-migrated test.db-journal\n\ndo_test migrate-3-0-database-to-current-format {\n  file copy -force $sampleDir/sqlcipher-3.0-testkey.db test.db\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_migrate;\n  }\n  db close\n    \n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master;\n    PRAGMA journal_mode;\n  }\n} {ok 1 delete}\ndb close\nfile delete -force test.db\n\ndo_test migrate-wal-database-to-current {\n  file copy -force $sampleDir/sqlcipher-3.0-testkey.db test.db\n  sqlite_orig db test.db\n  set rc {}\n\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_page_size = 1024; PRAGMA kdf_iter = 64000; PRAGMA cipher_hmac_algorithm = HMAC_SHA1; PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    PRAGMA journal_mode = wal;\n  }]\n  db close\n    \n  sqlite_orig db test.db\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_migrate;\n    PRAGMA journal_mode;\n  }]\n  db close\n\n  sqlite_orig db test.db\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master;\n    PRAGMA journal_mode;\n  }]\n} {{ok wal} {ok 0 wal} {ok 1 wal}}\ndb close\nfile delete -force test.db\n\n\ndo_test key-database-by-name {\n    sqlite_orig db test.db\n    execsql {\n        attach database 'new.db' as new;\n        pragma new.key = 'foo';\n        create table new.t1(a,b);\n        insert into new.t1(a,b) values('foo', 'bar');\n        detach database new;\n    }\n    db close\n\n    sqlite_orig db new.db\n    execsql {\n        pragma key = 'foo';\n        select * from t1;\n    }\n} {ok foo bar}\ndb close\nfile delete -force test.db\nfile delete -force new.db\n\ndo_test key-multiple-databases-with-different-keys-using-pragma {\n    sqlite_orig db test.db\n    execsql {\n        pragma key = 'foobar';\n        create table t1(a,b);\n        insert into t1(a,b) values('baz','qux');\n        attach database 'new.db' as new;\n        pragma new.key = 'foo';\n        create table new.t1(a,b);\n        insert into new.t1(a,b) values('foo', 'bar');\n        detach database new;\n    }\n    db close\n\n    sqlite_orig db new.db\n    execsql {\n        pragma key = 'foo';\n        attach database 'test.db' as test key 'foobar';\n        select * from t1;\n        select * from test.t1;\n    }\n} {ok foo bar baz qux}\ndb close\nfile delete -force test.db\nfile delete -force new.db\n\n\n# Requires SQLCipher to be built with -DSQLCIPHER_TEST\nif_built_with_libtomcrypt verify-random-data-alters-file-content {\n    file delete -force test.db\n    file delete -force test2.db\n    file delete -force test3.db\n    set rc {}\n    \n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key=\"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        create table t1(a,b);\n    }\n    db close\n    sqlite_orig db test2.db\n    execsql {\n        PRAGMA key=\"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        create table t1(a,b);\n    }\n    db close\n    sqlite_orig db test3.db\n    execsql {\n        PRAGMA key=\"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        PRAGMA cipher_add_random = \"x'deadbaad'\";\n        create table t1(a,b);\n    }\n    db close\n    lappend rc [cmpFilesChunked test.db test2.db]\n    lappend rc [cmpFilesChunked test2.db test3.db]\n} {0 1}\nfile delete -force test.db\nfile delete -force test2.db\nfile delete -force test3.db\n\ndo_test can-migrate-with-keys-longer-than-64-characters {\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"012345678901234567890123456789012345678901234567890123456789012345\";\n        PRAGMA cipher_page_size = 1024;\n        PRAGMA kdf_iter = 4000;\n        PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n        PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n        PRAGMA user_version = 5;\n    }\n    db close\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"012345678901234567890123456789012345678901234567890123456789012345\";\n        PRAGMA cipher_migrate;\n    }\n    db close\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"012345678901234567890123456789012345678901234567890123456789012345\";\n        PRAGMA user_version;\n    }\n} {ok 5}\ndb close\nfile delete -force test.db\n\ndo_test can-migrate-with-raw-hex-key {\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        PRAGMA cipher_page_size = 1024;\n        PRAGMA kdf_iter = 4000;\n        PRAGMA cipher_use_hmac = off;\n        PRAGMA user_version = 5;\n    }\n    db close\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        PRAGMA cipher_migrate;\n    }\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        PRAGMA user_version;\n    }\n    \n} {ok 5}\ndb close\nfile delete -force test.db\n\ndo_test attach_database_with_non_default_page_size {\n    sqlite_orig db test2.db\n    execsql {\n        PRAGMA key = 'test';\n        PRAGMA cipher_page_size = 8192;\n        CREATE TABLE t1(a,b);\n        INSERT INTO t1(a,b) values('one for the money', 'two for the show');\n        INSERT INTO t1(a,b) values('three to get ready', 'now, go cat, go');\n    }\n    db close\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA cipher_default_page_size = 8192;\n        PRAGMA key = 'test';\n        ATTACH DATABASE 'test2.db' as test2 KEY 'test';\n        SELECT count(*) FROM test2.t1;\n        PRAGMA cipher_default_page_size = 4096;\n    }\n} {ok 2}\ndb close\nfile delete -force test.db test2.db\n\ndo_test verify-cipher-export-with-trace-configured {\n  sqlite_orig db plain.db\n  execsql {\n    CREATE TABLE t1(a,b);\n    INSERT INTO t1(a,b) VALUES(1,2);\n  }\n  set TRACE_OUT {}\n  db trace trace_proc\n  execsql {\n    ATTACH DATABASE 'encrypted.db' AS encrypted KEY 'encrypted';\n    SELECT sqlcipher_export('encrypted');\n    DETACH DATABASE encrypted;\n  }\n  set TRACE_OUT\n} {{ATTACH DATABASE 'encrypted.db' AS encrypted KEY 'encrypted';} {SELECT sqlcipher_export('encrypted');} {DETACH DATABASE encrypted;}}\nset TRACE_OUT {}\ndb close\nfile delete -force plain.db\nfile delete -force encrypted.db\n\n# open a 1.1.8 database using cipher_compatibility\ndo_test compat-open-1.1.8-database {\n  sqlite_orig db $sampleDir/sqlcipher-1.1.8-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_compatibility = 1;\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 75709}\ndb close\n\n# open a 2.0 database using cipher_compatibility\ndo_test compat-open-2.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-le-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_compatibility = 2;\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\ndb close\n\n# open a 3.0 database using cipher_compatibility\ndo_test compat-open-3.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-3.0-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_compatibility = 3;\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\ndb close\n\n# open a 4.0 database using cipher_compatibility\ndo_test compat-open-4.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-4.0-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_compatibility = 4;\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\ndb close\n\n# open a 1.1.8 database using cipher_default_compatibility\ndo_test default-compat-open-1.1.8-database {\n  sqlite_orig db $sampleDir/sqlcipher-1.1.8-testkey.db\n  execsql {\n    PRAGMA cipher_default_compatibility = 1;\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 75709}\ndb close\n\n# open a 2.0 database using cipher_default_compatibility\ndo_test default-compat-open-2.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-le-testkey.db\n  execsql {\n    PRAGMA cipher_default_compatibility = 2;\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\n\n# open a 3.0 database using cipher_default_compatibility\ndo_test default-compat-open-3.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-3.0-testkey.db\n  execsql {\n    PRAGMA cipher_default_compatibility = 3;\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\n\n# re-open a 4.0 database using cipher_default_compatibility\ndo_test default-compat-open-4.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-4.0-testkey.db\n  execsql {\n    PRAGMA cipher_default_compatibility = 4;\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\n\nsqlite3_test_control_pending_byte $old_pending_byte\n\nfinish_test\n"], "fixing_code": ["/*\n** SQLCipher\n** http://sqlcipher.net\n** \n** Copyright (c) 2008 - 2013, ZETETIC LLC\n** All rights reserved.\n** \n** Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are met:\n**     * Redistributions of source code must retain the above copyright\n**       notice, this list of conditions and the following disclaimer.\n**     * Redistributions in binary form must reproduce the above copyright\n**       notice, this list of conditions and the following disclaimer in the\n**       documentation and/or other materials provided with the distribution.\n**     * Neither the name of the ZETETIC LLC nor the\n**       names of its contributors may be used to endorse or promote products\n**       derived from this software without specific prior written permission.\n** \n** THIS SOFTWARE IS PROVIDED BY ZETETIC LLC ''AS IS'' AND ANY\n** EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n** DISCLAIMED. IN NO EVENT SHALL ZETETIC LLC BE LIABLE FOR ANY\n** DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n** LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n** ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**  \n*/\n/* BEGIN SQLCIPHER */\n#ifdef SQLITE_HAS_CODEC\n\n#include <assert.h>\n#include \"sqlcipher.h\"\n#include \"crypto.h\"\n\n#ifdef SQLCIPHER_EXT\n#include \"sqlcipher_ext.h\"\n#endif\n\n#ifdef SQLCIPHER_TEST\nstatic int cipher_fail_next_encrypt = 0;\nstatic int cipher_fail_next_decrypt = 0;\n#endif\n\n/* Generate code to return a string value */\nstatic void codec_vdbe_return_string(Parse *pParse, const char *zLabel, const char *value, int value_type){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  sqlite3VdbeSetNumCols(v, 1);\n  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC);\n  sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, value, value_type);\n  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n}\n\nstatic int codec_set_btree_to_codec_pagesize(sqlite3 *db, Db *pDb, codec_ctx *ctx) {\n  int rc, page_sz, reserve_sz; \n\n  page_sz = sqlcipher_codec_ctx_get_pagesize(ctx);\n  reserve_sz = sqlcipher_codec_ctx_get_reservesize(ctx);\n\n  CODEC_TRACE(\"codec_set_btree_to_codec_pagesize: sqlite3BtreeSetPageSize() size=%d reserve=%d\\n\", page_sz, reserve_sz);\n\n  CODEC_TRACE_MUTEX(\"codec_set_btree_to_codec_pagesize: entering database mutex %p\\n\", db->mutex);\n  sqlite3_mutex_enter(db->mutex);\n  CODEC_TRACE_MUTEX(\"codec_set_btree_to_codec_pagesize: entered database mutex %p\\n\", db->mutex);\n  db->nextPagesize = page_sz; \n\n  /* before forcing the page size we need to unset the BTS_PAGESIZE_FIXED flag, else  \n     sqliteBtreeSetPageSize will block the change  */\n  pDb->pBt->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;\n  rc = sqlite3BtreeSetPageSize(pDb->pBt, page_sz, reserve_sz, 0);\n\n  CODEC_TRACE(\"codec_set_btree_to_codec_pagesize: sqlite3BtreeSetPageSize returned %d\\n\", rc);\n\n  CODEC_TRACE_MUTEX(\"codec_set_btree_to_codec_pagesize: leaving database mutex %p\\n\", db->mutex);\n  sqlite3_mutex_leave(db->mutex);\n  CODEC_TRACE_MUTEX(\"codec_set_btree_to_codec_pagesize: left database mutex %p\\n\", db->mutex);\n\n  return rc;\n}\n\nstatic int codec_set_pass_key(sqlite3* db, int nDb, const void *zKey, int nKey, int for_ctx) {\n  struct Db *pDb = &db->aDb[nDb];\n  CODEC_TRACE(\"codec_set_pass_key: entered db=%p nDb=%d zKey=%s nKey=%d for_ctx=%d\\n\", db, nDb, (char *)zKey, nKey, for_ctx);\n  if(pDb->pBt) {\n    codec_ctx *ctx = (codec_ctx*) sqlite3PagerGetCodec(pDb->pBt->pBt->pPager);\n\n    if(ctx) return sqlcipher_codec_ctx_set_pass(ctx, zKey, nKey, for_ctx);\n  }\n  return SQLITE_ERROR;\n} \n\nint sqlcipher_codec_pragma(sqlite3* db, int iDb, Parse *pParse, const char *zLeft, const char *zRight) {\n  struct Db *pDb = &db->aDb[iDb];\n  codec_ctx *ctx = NULL;\n  int rc;\n\n  if(pDb->pBt) {\n    ctx = (codec_ctx*) sqlite3PagerGetCodec(pDb->pBt->pBt->pPager);\n  }\n\n  CODEC_TRACE(\"sqlcipher_codec_pragma: entered db=%p iDb=%d pParse=%p zLeft=%s zRight=%s ctx=%p\\n\", db, iDb, pParse, zLeft, zRight, ctx);\n  \n#ifdef SQLCIPHER_EXT\n  if( sqlite3StrICmp(zLeft, \"cipher_license\")==0 && zRight ){\n    char *license_result = sqlite3_mprintf(\"%d\", sqlcipher_license_key(zRight));\n    codec_vdbe_return_string(pParse, \"cipher_license\", license_result, P4_DYNAMIC);\n  } else\n    if( sqlite3StrICmp(zLeft, \"cipher_license\")==0 && !zRight ){\n      if(ctx) {\n        char *license_result = sqlite3_mprintf(\"%d\", ctx\n                                               ? sqlcipher_license_key_status(ctx->provider)\n                                               : SQLITE_ERROR);\n        codec_vdbe_return_string(pParse, \"cipher_license\", license_result, P4_DYNAMIC);\n      }\n  } else\n#endif\n#ifdef SQLCIPHER_TEST\n  if( sqlite3StrICmp(zLeft,\"cipher_fail_next_encrypt\")==0 ){\n    if( zRight ) {\n      cipher_fail_next_encrypt = sqlite3GetBoolean(zRight,1);\n    } else {\n      char *fail = sqlite3_mprintf(\"%d\", cipher_fail_next_encrypt);\n      codec_vdbe_return_string(pParse, \"cipher_fail_next_encrypt\", fail, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_fail_next_decrypt\")==0 ){\n    if( zRight ) {\n      cipher_fail_next_decrypt = sqlite3GetBoolean(zRight,1);\n    } else {\n      char *fail = sqlite3_mprintf(\"%d\", cipher_fail_next_decrypt);\n      codec_vdbe_return_string(pParse, \"cipher_fail_next_decrypt\", fail, P4_DYNAMIC);\n    }\n  }else\n#endif\n  if( sqlite3StrICmp(zLeft, \"cipher_fips_status\")== 0 && !zRight ){\n    if(ctx) {\n      char *fips_mode_status = sqlite3_mprintf(\"%d\", sqlcipher_codec_fips_status(ctx));\n      codec_vdbe_return_string(pParse, \"cipher_fips_status\", fips_mode_status, P4_DYNAMIC);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_store_pass\")==0 && zRight ) {\n    if(ctx) {\n      char *deprecation = \"PRAGMA cipher_store_pass is deprecated, please remove from use\";\n      sqlcipher_codec_set_store_pass(ctx, sqlite3GetBoolean(zRight, 1));\n      codec_vdbe_return_string(pParse, \"cipher_store_pass\", deprecation, P4_TRANSIENT);\n      sqlite3_log(SQLITE_WARNING, deprecation);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_store_pass\")==0 && !zRight ) {\n    if(ctx){\n      char *store_pass_value = sqlite3_mprintf(\"%d\", sqlcipher_codec_get_store_pass(ctx));\n      codec_vdbe_return_string(pParse, \"cipher_store_pass\", store_pass_value, P4_DYNAMIC);\n    }\n  }\n  if( sqlite3StrICmp(zLeft, \"cipher_profile\")== 0 && zRight ){\n      char *profile_status = sqlite3_mprintf(\"%d\", sqlcipher_cipher_profile(db, zRight));\n      codec_vdbe_return_string(pParse, \"cipher_profile\", profile_status, P4_DYNAMIC);\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_add_random\")==0 && zRight ){\n    if(ctx) {\n      char *add_random_status = sqlite3_mprintf(\"%d\", sqlcipher_codec_add_random(ctx, zRight, sqlite3Strlen30(zRight)));\n      codec_vdbe_return_string(pParse, \"cipher_add_random\", add_random_status, P4_DYNAMIC);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_migrate\")==0 && !zRight ){\n    if(ctx){\n      char *migrate_status = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_migrate(ctx));\n      codec_vdbe_return_string(pParse, \"cipher_migrate\", migrate_status, P4_DYNAMIC);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_provider\")==0 && !zRight ){\n    if(ctx) { codec_vdbe_return_string(pParse, \"cipher_provider\",\n                                              sqlcipher_codec_get_cipher_provider(ctx), P4_TRANSIENT);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_provider_version\")==0 && !zRight){\n    if(ctx) { codec_vdbe_return_string(pParse, \"cipher_provider_version\",\n                                              sqlcipher_codec_get_provider_version(ctx), P4_TRANSIENT);\n    }\n  } else\n  if( sqlite3StrICmp(zLeft, \"cipher_version\")==0 && !zRight ){\n    codec_vdbe_return_string(pParse, \"cipher_version\", sqlcipher_version(), P4_DYNAMIC);\n  }else\n  if( sqlite3StrICmp(zLeft, \"cipher\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        const char* message = \"PRAGMA cipher is no longer supported.\";\n        codec_vdbe_return_string(pParse, \"cipher\", message, P4_TRANSIENT);\n        sqlite3_log(SQLITE_WARNING, message);\n      }else {\n        codec_vdbe_return_string(pParse, \"cipher\", sqlcipher_codec_ctx_get_cipher(ctx), P4_TRANSIENT); \n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft, \"rekey_cipher\")==0 && zRight ){\n    const char* message = \"PRAGMA rekey_cipher is no longer supported.\";\n    codec_vdbe_return_string(pParse, \"rekey_cipher\", message, P4_TRANSIENT);\n    sqlite3_log(SQLITE_WARNING, message);\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_default_kdf_iter\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_default_kdf_iter(atoi(zRight)); /* change default KDF iterations */\n    } else {\n      char *kdf_iter = sqlite3_mprintf(\"%d\", sqlcipher_get_default_kdf_iter());\n      codec_vdbe_return_string(pParse, \"cipher_default_kdf_iter\", kdf_iter, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft, \"kdf_iter\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        sqlcipher_codec_ctx_set_kdf_iter(ctx, atoi(zRight)); /* change of RW PBKDF2 iteration */\n      } else {\n        char *kdf_iter = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_kdf_iter(ctx));\n        codec_vdbe_return_string(pParse, \"kdf_iter\", kdf_iter, P4_DYNAMIC);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft, \"fast_kdf_iter\")==0){\n    if(ctx) {\n      if( zRight ) {\n        char *deprecation = \"PRAGMA fast_kdf_iter is deprecated, please remove from use\";\n        sqlcipher_codec_ctx_set_fast_kdf_iter(ctx, atoi(zRight)); /* change of RW PBKDF2 iteration */\n        codec_vdbe_return_string(pParse, \"fast_kdf_iter\", deprecation, P4_TRANSIENT);\n        sqlite3_log(SQLITE_WARNING, deprecation);\n      } else {\n        char *fast_kdf_iter = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_fast_kdf_iter(ctx));\n        codec_vdbe_return_string(pParse, \"fast_kdf_iter\", fast_kdf_iter, P4_DYNAMIC);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft, \"rekey_kdf_iter\")==0 && zRight ){\n    const char* message = \"PRAGMA rekey_kdf_iter is no longer supported.\";\n    codec_vdbe_return_string(pParse, \"rekey_kdf_iter\", message, P4_TRANSIENT);\n    sqlite3_log(SQLITE_WARNING, message);\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_page_size\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        int size = atoi(zRight);\n        rc = sqlcipher_codec_ctx_set_pagesize(ctx, size);\n        if(rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, rc);\n        rc = codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n        if(rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, rc);\n      } else {\n        char * page_size = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_pagesize(ctx));\n        codec_vdbe_return_string(pParse, \"cipher_page_size\", page_size, P4_DYNAMIC);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_default_page_size\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_default_pagesize(atoi(zRight));\n    } else {\n      char *default_page_size = sqlite3_mprintf(\"%d\", sqlcipher_get_default_pagesize());\n      codec_vdbe_return_string(pParse, \"cipher_default_page_size\", default_page_size, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_default_use_hmac\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_default_use_hmac(sqlite3GetBoolean(zRight,1));\n    } else {\n      char *default_use_hmac = sqlite3_mprintf(\"%d\", sqlcipher_get_default_use_hmac());\n      codec_vdbe_return_string(pParse, \"cipher_default_use_hmac\", default_use_hmac, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_use_hmac\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        rc = sqlcipher_codec_ctx_set_use_hmac(ctx, sqlite3GetBoolean(zRight,1));\n        if(rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, rc);\n        /* since the use of hmac has changed, the page size may also change */\n        rc = codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n        if(rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, rc);\n      } else {\n        char *hmac_flag = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_use_hmac(ctx));\n        codec_vdbe_return_string(pParse, \"cipher_use_hmac\", hmac_flag, P4_DYNAMIC);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_hmac_pgno\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        char *deprecation = \"PRAGMA cipher_hmac_pgno is deprecated, please remove from use\";\n        /* clear both pgno endian flags */\n        if(sqlite3StrICmp(zRight, \"le\") == 0) {\n          sqlcipher_codec_ctx_unset_flag(ctx, CIPHER_FLAG_BE_PGNO);\n          sqlcipher_codec_ctx_set_flag(ctx, CIPHER_FLAG_LE_PGNO);\n        } else if(sqlite3StrICmp(zRight, \"be\") == 0) {\n          sqlcipher_codec_ctx_unset_flag(ctx, CIPHER_FLAG_LE_PGNO);\n          sqlcipher_codec_ctx_set_flag(ctx, CIPHER_FLAG_BE_PGNO);\n        } else if(sqlite3StrICmp(zRight, \"native\") == 0) {\n          sqlcipher_codec_ctx_unset_flag(ctx, CIPHER_FLAG_LE_PGNO);\n          sqlcipher_codec_ctx_unset_flag(ctx, CIPHER_FLAG_BE_PGNO);\n        }\n        codec_vdbe_return_string(pParse, \"cipher_hmac_pgno\", deprecation, P4_TRANSIENT);\n        sqlite3_log(SQLITE_WARNING, deprecation);\n \n      } else {\n        if(sqlcipher_codec_ctx_get_flag(ctx, CIPHER_FLAG_LE_PGNO)) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_pgno\", \"le\", P4_TRANSIENT);\n        } else if(sqlcipher_codec_ctx_get_flag(ctx, CIPHER_FLAG_BE_PGNO)) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_pgno\", \"be\", P4_TRANSIENT);\n        } else {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_pgno\", \"native\", P4_TRANSIENT);\n        }\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_hmac_salt_mask\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        char *deprecation = \"PRAGMA cipher_hmac_salt_mask is deprecated, please remove from use\";\n        if (sqlite3StrNICmp(zRight ,\"x'\", 2) == 0 && sqlite3Strlen30(zRight) == 5) {\n          unsigned char mask = 0;\n          const unsigned char *hex = (const unsigned char *)zRight+2;\n          cipher_hex2bin(hex,2,&mask);\n          sqlcipher_set_hmac_salt_mask(mask);\n        }\n        codec_vdbe_return_string(pParse, \"cipher_hmac_salt_mask\", deprecation, P4_TRANSIENT);\n        sqlite3_log(SQLITE_WARNING, deprecation);\n      } else {\n        char *hmac_salt_mask = sqlite3_mprintf(\"%02x\", sqlcipher_get_hmac_salt_mask());\n        codec_vdbe_return_string(pParse, \"cipher_hmac_salt_mask\", hmac_salt_mask, P4_DYNAMIC);\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_plaintext_header_size\")==0 ){\n    if(ctx) {\n      if( zRight ) {\n        int size = atoi(zRight);\n        /* deliberately ignore result code, if size is invalid it will be set to -1\n           and trip the error later in the codec */\n        sqlcipher_codec_ctx_set_plaintext_header_size(ctx, size);\n      } else {\n        char *size = sqlite3_mprintf(\"%d\", sqlcipher_codec_ctx_get_plaintext_header_size(ctx));\n        codec_vdbe_return_string(pParse, \"cipher_plaintext_header_size\", size, P4_DYNAMIC);\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_default_plaintext_header_size\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_default_plaintext_header_size(atoi(zRight));\n    } else {\n      char *size = sqlite3_mprintf(\"%d\", sqlcipher_get_default_plaintext_header_size());\n      codec_vdbe_return_string(pParse, \"cipher_default_plaintext_header_size\", size, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_salt\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        if (sqlite3StrNICmp(zRight ,\"x'\", 2) == 0 && sqlite3Strlen30(zRight) == (FILE_HEADER_SZ*2)+3) {\n          unsigned char *salt = (unsigned char*) sqlite3_malloc(FILE_HEADER_SZ);\n          const unsigned char *hex = (const unsigned char *)zRight+2;\n          cipher_hex2bin(hex,FILE_HEADER_SZ*2,salt);\n          sqlcipher_codec_ctx_set_kdf_salt(ctx, salt, FILE_HEADER_SZ);\n          sqlite3_free(salt);\n        }\n      } else {\n        void *salt;\n        char *hexsalt = (char*) sqlite3_malloc((FILE_HEADER_SZ*2)+1);\n        if((rc = sqlcipher_codec_ctx_get_kdf_salt(ctx, &salt)) == SQLITE_OK) {\n          cipher_bin2hex(salt, FILE_HEADER_SZ, hexsalt);\n          codec_vdbe_return_string(pParse, \"cipher_salt\", hexsalt, P4_DYNAMIC);\n        } else {\n          sqlite3_free(hexsalt);\n          sqlcipher_codec_ctx_set_error(ctx, rc);\n        }\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_hmac_algorithm\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        rc = SQLITE_ERROR;\n        if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA1_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA1);\n        } else if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA256_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA256);\n        } else if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA512_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA512);\n        }\n        if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n        rc = codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n        if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n      } else {\n        int algorithm = sqlcipher_codec_ctx_get_hmac_algorithm(ctx);\n        if(algorithm == SQLCIPHER_HMAC_SHA1) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_algorithm\", SQLCIPHER_HMAC_SHA1_LABEL, P4_TRANSIENT);\n        } else if(algorithm == SQLCIPHER_HMAC_SHA256) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_algorithm\", SQLCIPHER_HMAC_SHA256_LABEL, P4_TRANSIENT);\n        } else if(algorithm == SQLCIPHER_HMAC_SHA512) {\n          codec_vdbe_return_string(pParse, \"cipher_hmac_algorithm\", SQLCIPHER_HMAC_SHA512_LABEL, P4_TRANSIENT);\n        }\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_default_hmac_algorithm\")==0 ){\n    if(zRight) {\n      rc = SQLITE_ERROR;\n      if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA1_LABEL) == 0) {\n        rc = sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA1);\n      } else if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA256_LABEL) == 0) {\n        rc = sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA256);\n      } else if(sqlite3StrICmp(zRight, SQLCIPHER_HMAC_SHA512_LABEL) == 0) {\n        rc = sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA512);\n      }\n    } else {\n      int algorithm = sqlcipher_get_default_hmac_algorithm();\n      if(algorithm == SQLCIPHER_HMAC_SHA1) {\n        codec_vdbe_return_string(pParse, \"cipher_default_hmac_algorithm\", SQLCIPHER_HMAC_SHA1_LABEL, P4_TRANSIENT);\n      } else if(algorithm == SQLCIPHER_HMAC_SHA256) {\n        codec_vdbe_return_string(pParse, \"cipher_default_hmac_algorithm\", SQLCIPHER_HMAC_SHA256_LABEL, P4_TRANSIENT);\n      } else if(algorithm == SQLCIPHER_HMAC_SHA512) {\n        codec_vdbe_return_string(pParse, \"cipher_default_hmac_algorithm\", SQLCIPHER_HMAC_SHA512_LABEL, P4_TRANSIENT);\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_kdf_algorithm\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        rc = SQLITE_ERROR;\n        if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA1);\n        } else if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA256);\n        } else if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL) == 0) {\n          rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA512);\n        }\n        if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n      } else {\n        int algorithm = sqlcipher_codec_ctx_get_kdf_algorithm(ctx);\n        if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA1) {\n          codec_vdbe_return_string(pParse, \"cipher_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL, P4_TRANSIENT);\n        } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA256) {\n          codec_vdbe_return_string(pParse, \"cipher_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL, P4_TRANSIENT);\n        } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA512) {\n          codec_vdbe_return_string(pParse, \"cipher_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL, P4_TRANSIENT);\n        }\n      }\n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_default_kdf_algorithm\")==0 ){\n    if(zRight) {\n      rc = SQLITE_ERROR;\n      if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL) == 0) {\n        rc = sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA1);\n      } else if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL) == 0) {\n        rc = sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA256);\n      } else if(sqlite3StrICmp(zRight, SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL) == 0) {\n        rc = sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA512);\n      }\n    } else {\n      int algorithm = sqlcipher_get_default_kdf_algorithm();\n      if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA1) {\n        codec_vdbe_return_string(pParse, \"cipher_default_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL, P4_TRANSIENT);\n      } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA256) {\n        codec_vdbe_return_string(pParse, \"cipher_default_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL, P4_TRANSIENT);\n      } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA512) {\n        codec_vdbe_return_string(pParse, \"cipher_default_kdf_algorithm\", SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL, P4_TRANSIENT);\n      }\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_compatibility\")==0 ){\n    if(ctx) {\n      if(zRight) {\n        int version = atoi(zRight); \n\n        switch(version) {\n          case 1: \n            rc = sqlcipher_codec_ctx_set_pagesize(ctx, 1024);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_iter(ctx, 4000); \n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_use_hmac(ctx, 0);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            break;\n\n          case 2: \n            rc = sqlcipher_codec_ctx_set_pagesize(ctx, 1024);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_iter(ctx, 4000); \n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_use_hmac(ctx, 1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            break;\n\n          case 3:\n            rc = sqlcipher_codec_ctx_set_pagesize(ctx, 1024);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_iter(ctx, 64000); \n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_use_hmac(ctx, 1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            break;\n\n          default:\n            rc = sqlcipher_codec_ctx_set_pagesize(ctx, 4096);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_hmac_algorithm(ctx, SQLCIPHER_HMAC_SHA512);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_algorithm(ctx, SQLCIPHER_PBKDF2_HMAC_SHA512);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_kdf_iter(ctx, 256000); \n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            rc = sqlcipher_codec_ctx_set_use_hmac(ctx, 1);\n            if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n            break;\n        }  \n\n        rc = codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n        if (rc != SQLITE_OK) sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n      } \n    }\n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_default_compatibility\")==0 ){\n    if(zRight) {\n      int version = atoi(zRight); \n      switch(version) {\n        case 1: \n          sqlcipher_set_default_pagesize(1024);\n          sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA1);\n          sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA1);\n          sqlcipher_set_default_kdf_iter(4000);\n          sqlcipher_set_default_use_hmac(0);\n          break;\n\n        case 2: \n          sqlcipher_set_default_pagesize(1024);\n          sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA1);\n          sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA1);\n          sqlcipher_set_default_kdf_iter(4000);\n          sqlcipher_set_default_use_hmac(1);\n          break;\n\n        case 3:\n          sqlcipher_set_default_pagesize(1024);\n          sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA1);\n          sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA1);\n          sqlcipher_set_default_kdf_iter(64000);\n          sqlcipher_set_default_use_hmac(1);\n          break;\n\n        default:\n          sqlcipher_set_default_pagesize(4096);\n          sqlcipher_set_default_hmac_algorithm(SQLCIPHER_HMAC_SHA512);\n          sqlcipher_set_default_kdf_algorithm(SQLCIPHER_PBKDF2_HMAC_SHA512);\n          sqlcipher_set_default_kdf_iter(256000);\n          sqlcipher_set_default_use_hmac(1);\n          break;\n      }  \n    } \n  }else \n  if( sqlite3StrICmp(zLeft,\"cipher_memory_security\")==0 ){\n    if( zRight ) {\n      sqlcipher_set_mem_security(sqlite3GetBoolean(zRight,1));\n    } else {\n      char *on = sqlite3_mprintf(\"%d\", sqlcipher_get_mem_security());\n      codec_vdbe_return_string(pParse, \"cipher_memory_security\", on, P4_DYNAMIC);\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_settings\")==0 ){\n    if(ctx) {\n      int algorithm;\n      char *pragma;\n\n      pragma = sqlite3_mprintf(\"PRAGMA kdf_iter = %d;\", sqlcipher_codec_ctx_get_kdf_iter(ctx));\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_page_size = %d;\", sqlcipher_codec_ctx_get_pagesize(ctx));\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_use_hmac = %d;\", sqlcipher_codec_ctx_get_use_hmac(ctx));\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_plaintext_header_size = %d;\", sqlcipher_codec_ctx_get_plaintext_header_size(ctx));\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      algorithm = sqlcipher_codec_ctx_get_hmac_algorithm(ctx);\n      pragma = NULL;\n      if(algorithm == SQLCIPHER_HMAC_SHA1) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA1_LABEL);\n      } else if(algorithm == SQLCIPHER_HMAC_SHA256) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA256_LABEL);\n      } else if(algorithm == SQLCIPHER_HMAC_SHA512) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA512_LABEL);\n      }\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n      algorithm = sqlcipher_codec_ctx_get_kdf_algorithm(ctx);\n      pragma = NULL;\n      if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA1) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL);\n      } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA256) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL);\n      } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA512) {\n        pragma = sqlite3_mprintf(\"PRAGMA cipher_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL);\n      }\n      codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    }\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_default_settings\")==0 ){\n    int algorithm;\n    char *pragma;\n\n    pragma = sqlite3_mprintf(\"PRAGMA cipher_default_kdf_iter = %d;\", sqlcipher_get_default_kdf_iter());\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    pragma = sqlite3_mprintf(\"PRAGMA cipher_default_page_size = %d;\", sqlcipher_get_default_pagesize());\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    pragma = sqlite3_mprintf(\"PRAGMA cipher_default_use_hmac = %d;\", sqlcipher_get_default_use_hmac());\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    pragma = sqlite3_mprintf(\"PRAGMA cipher_default_plaintext_header_size = %d;\", sqlcipher_get_default_plaintext_header_size());\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    algorithm = sqlcipher_get_default_hmac_algorithm();\n    pragma = NULL;\n    if(algorithm == SQLCIPHER_HMAC_SHA1) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA1_LABEL);\n    } else if(algorithm == SQLCIPHER_HMAC_SHA256) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA256_LABEL);\n    } else if(algorithm == SQLCIPHER_HMAC_SHA512) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_hmac_algorithm = %s;\", SQLCIPHER_HMAC_SHA512_LABEL);\n    }\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n\n    algorithm = sqlcipher_get_default_kdf_algorithm();\n    pragma = NULL;\n    if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA1) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA1_LABEL);\n    } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA256) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA256_LABEL);\n    } else if(algorithm == SQLCIPHER_PBKDF2_HMAC_SHA512) {\n      pragma = sqlite3_mprintf(\"PRAGMA cipher_default_kdf_algorithm = %s;\", SQLCIPHER_PBKDF2_HMAC_SHA512_LABEL);\n    }\n    codec_vdbe_return_string(pParse, \"pragma\", pragma, P4_DYNAMIC);\n  }else\n  if( sqlite3StrICmp(zLeft,\"cipher_integrity_check\")==0 ){\n    if(ctx) {\n      sqlcipher_codec_ctx_integrity_check(ctx, pParse, \"cipher_integrity_check\");\n    }\n  }else {\n    return 0;\n  }\n  return 1;\n}\n\n/* these constants are used internally within SQLite's pager.c to differentiate between\n   operations on the main database or journal pages. This is important in the context\n   of a rekey operations, where the journal must be written using the original key \n   material (to allow a transactional rollback), while the new database pages are being\n   written with the new key material*/\n#define CODEC_READ_OP 3\n#define CODEC_WRITE_OP 6\n#define CODEC_JOURNAL_OP 7\n\n/*\n * sqlite3Codec can be called in multiple modes.\n * encrypt mode - expected to return a pointer to the \n *   encrypted data without altering pData.\n * decrypt mode - expected to return a pointer to pData, with\n *   the data decrypted in the input buffer\n */\nstatic void* sqlite3Codec(void *iCtx, void *data, Pgno pgno, int mode) {\n  codec_ctx *ctx = (codec_ctx *) iCtx;\n  int offset = 0, rc = 0;\n  int page_sz = sqlcipher_codec_ctx_get_pagesize(ctx); \n  unsigned char *pData = (unsigned char *) data;\n  void *buffer = sqlcipher_codec_ctx_get_data(ctx);\n  int plaintext_header_sz = sqlcipher_codec_ctx_get_plaintext_header_size(ctx);\n  int cctx = CIPHER_READ_CTX;\n\n  CODEC_TRACE(\"sqlite3Codec: entered pgno=%d, mode=%d, page_sz=%d\\n\", pgno, mode, page_sz);\n\n#ifdef SQLCIPHER_EXT\n  if(sqlcipher_license_check(ctx) != SQLITE_OK) return NULL;\n#endif\n\n  /* call to derive keys if not present yet */\n  if((rc = sqlcipher_codec_key_derive(ctx)) != SQLITE_OK) {\n   sqlcipher_codec_ctx_set_error(ctx, rc); \n   return NULL;\n  }\n\n  /* if the plaintext_header_size is negative that means an invalid size was set via \n     PRAGMA. We can't set the error state on the pager at that point because the pager\n     may not be open yet. However, this is a fatal error state, so abort the codec */\n  if(plaintext_header_sz < 0) {\n    sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR);\n    return NULL;\n  }\n\n  if(pgno == 1) /* adjust starting pointers in data page for header offset on first page*/   \n    offset = plaintext_header_sz ? plaintext_header_sz : FILE_HEADER_SZ; \n  \n\n  CODEC_TRACE(\"sqlite3Codec: switch mode=%d offset=%d\\n\",  mode, offset);\n  switch(mode) {\n    case CODEC_READ_OP: /* decrypt */\n      if(pgno == 1) /* copy initial part of file header or SQLite magic to buffer */ \n        memcpy(buffer, plaintext_header_sz ? pData : (void *) SQLITE_FILE_HEADER, offset); \n\n      rc = sqlcipher_page_cipher(ctx, cctx, pgno, CIPHER_DECRYPT, page_sz - offset, pData + offset, (unsigned char*)buffer + offset);\n#ifdef SQLCIPHER_TEST\n      if(cipher_fail_next_decrypt) rc = SQLITE_ERROR;\n#endif\n      if(rc != SQLITE_OK) { /* clear results of failed cipher operation and set error */\n        sqlcipher_memset((unsigned char*) buffer+offset, 0, page_sz-offset);\n        sqlcipher_codec_ctx_set_error(ctx, rc);\n      }\n      memcpy(pData, buffer, page_sz); /* copy buffer data back to pData and return */\n      return pData;\n      break;\n\n    case CODEC_WRITE_OP: /* encrypt database page, operate on write context and fall through to case 7, so the write context is used*/\n      cctx = CIPHER_WRITE_CTX; \n\n    case CODEC_JOURNAL_OP: /* encrypt journal page, operate on read context use to get the original page data from the database */ \n      if(pgno == 1) { /* copy initial part of file header or salt to buffer */ \n        void *kdf_salt = NULL; \n        /* retrieve the kdf salt */\n        if((rc = sqlcipher_codec_ctx_get_kdf_salt(ctx, &kdf_salt)) != SQLITE_OK) {\n          sqlcipher_codec_ctx_set_error(ctx, rc); \n          return NULL;\n        }\n        memcpy(buffer, plaintext_header_sz ? pData : kdf_salt, offset); \n      }\n      rc = sqlcipher_page_cipher(ctx, cctx, pgno, CIPHER_ENCRYPT, page_sz - offset, pData + offset, (unsigned char*)buffer + offset);\n#ifdef SQLCIPHER_TEST\n      if(cipher_fail_next_encrypt) rc = SQLITE_ERROR;\n#endif\n      if(rc != SQLITE_OK) { /* clear results of failed cipher operation and set error */\n        sqlcipher_memset((unsigned char*)buffer+offset, 0, page_sz-offset);\n        sqlcipher_codec_ctx_set_error(ctx, rc);\n        return NULL;\n      }\n      return buffer; /* return persistent buffer data, pData remains intact */\n      break;\n\n    default:\n      sqlcipher_codec_ctx_set_error(ctx, SQLITE_ERROR); /* unsupported mode, set error */\n      return pData;\n      break;\n  }\n}\n\nstatic void sqlite3FreeCodecArg(void *pCodecArg) {\n  codec_ctx *ctx = (codec_ctx *) pCodecArg;\n  if(pCodecArg == NULL) return;\n  sqlcipher_codec_ctx_free(&ctx); /* wipe and free allocated memory for the context */\n  sqlcipher_deactivate(); /* cleanup related structures, OpenSSL etc, when codec is detatched */\n}\n\nint sqlite3CodecAttach(sqlite3* db, int nDb, const void *zKey, int nKey) {\n  struct Db *pDb = &db->aDb[nDb];\n\n  CODEC_TRACE(\"sqlite3CodecAttach: entered db=%p, nDb=%d zKey=%s, nKey=%d\\n\", db, nDb, (char *)zKey, nKey);\n\n\n  if(nKey && zKey && pDb->pBt) {\n    int rc;\n    Pager *pPager = pDb->pBt->pBt->pPager;\n    sqlite3_file *fd;\n    codec_ctx *ctx;\n\n    /* check if the sqlite3_file is open, and if not force handle to NULL */ \n    if((fd = sqlite3PagerFile(pPager))->pMethods == 0) fd = NULL; \n\n    CODEC_TRACE(\"sqlite3CodecAttach: calling sqlcipher_activate()\\n\");\n    sqlcipher_activate(); /* perform internal initialization for sqlcipher */\n\n    CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: entering database mutex %p\\n\", db->mutex);\n    sqlite3_mutex_enter(db->mutex);\n    CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: entered database mutex %p\\n\", db->mutex);\n\n#ifdef SQLCIPHER_EXT\n    if((rc = sqlite3_set_authorizer(db, sqlcipher_license_authorizer, db)) != SQLITE_OK) {\n      sqlite3_mutex_leave(db->mutex);\n      return rc;\n    }\n#endif\n\n    /* point the internal codec argument against the contet to be prepared */\n    CODEC_TRACE(\"sqlite3CodecAttach: calling sqlcipher_codec_ctx_init()\\n\");\n    rc = sqlcipher_codec_ctx_init(&ctx, pDb, pDb->pBt->pBt->pPager, zKey, nKey);\n\n    if(rc != SQLITE_OK) {\n      /* initialization failed, do not attach potentially corrupted context */\n      CODEC_TRACE(\"sqlite3CodecAttach: context initialization failed with rc=%d\\n\", rc);\n      /* force an error at the pager level, such that even the upstream caller ignores the return code\n         the pager will be in an error state and will process no further operations */\n      sqlite3pager_error(pPager, rc);\n      pDb->pBt->pBt->db->errCode = rc;\n      CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: leaving database mutex %p (early return on rc=%d)\\n\", db->mutex, rc);\n      sqlite3_mutex_leave(db->mutex);\n      CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: left database mutex %p (early return on rc=%d)\\n\", db->mutex, rc);\n      return rc;\n    }\n\n    CODEC_TRACE(\"sqlite3CodecAttach: calling sqlite3PagerSetCodec()\\n\");\n    sqlite3PagerSetCodec(sqlite3BtreePager(pDb->pBt), sqlite3Codec, NULL, sqlite3FreeCodecArg, (void *) ctx);\n\n    CODEC_TRACE(\"sqlite3CodecAttach: calling codec_set_btree_to_codec_pagesize()\\n\");\n    codec_set_btree_to_codec_pagesize(db, pDb, ctx);\n\n    /* force secure delete. This has the benefit of wiping internal data when deleted\n       and also ensures that all pages are written to disk (i.e. not skipped by\n       sqlite3PagerDontWrite optimizations) */ \n    CODEC_TRACE(\"sqlite3CodecAttach: calling sqlite3BtreeSecureDelete()\\n\");\n    sqlite3BtreeSecureDelete(pDb->pBt, 1); \n\n    /* if fd is null, then this is an in-memory database and\n       we dont' want to overwrite the AutoVacuum settings\n       if not null, then set to the default */\n    if(fd != NULL) { \n      CODEC_TRACE(\"sqlite3CodecAttach: calling sqlite3BtreeSetAutoVacuum()\\n\");\n      sqlite3BtreeSetAutoVacuum(pDb->pBt, SQLITE_DEFAULT_AUTOVACUUM);\n    }\n    CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: leaving database mutex %p\\n\", db->mutex);\n    sqlite3_mutex_leave(db->mutex);\n    CODEC_TRACE_MUTEX(\"sqlite3CodecAttach: left database mutex %p\\n\", db->mutex);\n  }\n  return SQLITE_OK;\n}\n\nint sqlcipher_find_db_index(sqlite3 *db, const char *zDb) {\n  int db_index;\n  if(zDb == NULL){\n    return 0;\n  }\n  for(db_index = 0; db_index < db->nDb; db_index++) {\n    struct Db *pDb = &db->aDb[db_index];\n    if(strcmp(pDb->zDbSName, zDb) == 0) {\n      return db_index;\n    }\n  }\n  return 0;\n}\n\nvoid sqlite3_activate_see(const char* in) {\n  /* do nothing, security enhancements are always active */\n}\n\nint sqlite3_key(sqlite3 *db, const void *pKey, int nKey) {\n  CODEC_TRACE(\"sqlite3_key entered: db=%p pKey=%s nKey=%d\\n\", db, (char *)pKey, nKey);\n  return sqlite3_key_v2(db, \"main\", pKey, nKey);\n}\n\nint sqlite3_key_v2(sqlite3 *db, const char *zDb, const void *pKey, int nKey) {\n  CODEC_TRACE(\"sqlite3_key_v2: entered db=%p zDb=%s pKey=%s nKey=%d\\n\", db, zDb, (char *)pKey, nKey);\n  /* attach key if db and pKey are not null and nKey is > 0 */\n  if(db && pKey && nKey) {\n    int db_index = sqlcipher_find_db_index(db, zDb);\n    return sqlite3CodecAttach(db, db_index, pKey, nKey); \n  }\n  return SQLITE_ERROR;\n}\n\nint sqlite3_rekey(sqlite3 *db, const void *pKey, int nKey) {\n  CODEC_TRACE(\"sqlite3_rekey entered: db=%p pKey=%s nKey=%d\\n\", db, (char *)pKey, nKey);\n  return sqlite3_rekey_v2(db, \"main\", pKey, nKey);\n}\n\n/* sqlite3_rekey_v2\n** Given a database, this will reencrypt the database using a new key.\n** There is only one possible modes of operation - to encrypt a database\n** that is already encrpyted. If the database is not already encrypted\n** this should do nothing\n** The proposed logic for this function follows:\n** 1. Determine if the database is already encryptped\n** 2. If there is NOT already a key present do nothing\n** 3. If there is a key present, re-encrypt the database with the new key\n*/\nint sqlite3_rekey_v2(sqlite3 *db, const char *zDb, const void *pKey, int nKey) {\n  CODEC_TRACE(\"sqlite3_rekey_v2: entered db=%p zDb=%s pKey=%s, nKey=%d\\n\", db, zDb, (char *)pKey, nKey);\n  if(db && pKey && nKey) {\n    int db_index = sqlcipher_find_db_index(db, zDb);\n    struct Db *pDb = &db->aDb[db_index];\n    CODEC_TRACE(\"sqlite3_rekey_v2: database pDb=%p db_index:%d\\n\", pDb, db_index);\n    if(pDb->pBt) {\n      codec_ctx *ctx;\n      int rc, page_count;\n      Pgno pgno;\n      PgHdr *page;\n      Pager *pPager = pDb->pBt->pBt->pPager;\n\n      ctx = (codec_ctx*) sqlite3PagerGetCodec(pDb->pBt->pBt->pPager);\n     \n      if(ctx == NULL) { \n        /* there was no codec attached to this database, so this should do nothing! */ \n        CODEC_TRACE(\"sqlite3_rekey_v2: no codec attached to db, exiting\\n\");\n        return SQLITE_OK;\n      }\n\n      CODEC_TRACE_MUTEX(\"sqlite3_rekey_v2: entering database mutex %p\\n\", db->mutex);\n      sqlite3_mutex_enter(db->mutex);\n      CODEC_TRACE_MUTEX(\"sqlite3_rekey_v2: entered database mutex %p\\n\", db->mutex);\n\n      codec_set_pass_key(db, db_index, pKey, nKey, CIPHER_WRITE_CTX);\n    \n      /* do stuff here to rewrite the database \n      ** 1. Create a transaction on the database\n      ** 2. Iterate through each page, reading it and then writing it.\n      ** 3. If that goes ok then commit and put ctx->rekey into ctx->key\n      **    note: don't deallocate rekey since it may be used in a subsequent iteration \n      */\n      rc = sqlite3BtreeBeginTrans(pDb->pBt, 1, 0); /* begin write transaction */\n      sqlite3PagerPagecount(pPager, &page_count);\n      for(pgno = 1; rc == SQLITE_OK && pgno <= (unsigned int)page_count; pgno++) { /* pgno's start at 1 see pager.c:pagerAcquire */\n        if(!sqlite3pager_is_mj_pgno(pPager, pgno)) { /* skip this page (see pager.c:pagerAcquire for reasoning) */\n          rc = sqlite3PagerGet(pPager, pgno, &page, 0);\n          if(rc == SQLITE_OK) { /* write page see pager_incr_changecounter for example */\n            rc = sqlite3PagerWrite(page);\n            if(rc == SQLITE_OK) {\n              sqlite3PagerUnref(page);\n            } else {\n             CODEC_TRACE(\"sqlite3_rekey_v2: error %d occurred writing page %d\\n\", rc, pgno);  \n            }\n          } else {\n             CODEC_TRACE(\"sqlite3_rekey_v2: error %d occurred getting page %d\\n\", rc, pgno);  \n          }\n        } \n      }\n\n      /* if commit was successful commit and copy the rekey data to current key, else rollback to release locks */\n      if(rc == SQLITE_OK) { \n        CODEC_TRACE(\"sqlite3_rekey_v2: committing\\n\");\n        rc = sqlite3BtreeCommit(pDb->pBt); \n        sqlcipher_codec_key_copy(ctx, CIPHER_WRITE_CTX);\n      } else {\n        CODEC_TRACE(\"sqlite3_rekey_v2: rollback\\n\");\n        sqlite3BtreeRollback(pDb->pBt, SQLITE_ABORT_ROLLBACK, 0);\n      }\n\n      CODEC_TRACE_MUTEX(\"sqlite3_rekey_v2: leaving database mutex %p\\n\", db->mutex);\n      sqlite3_mutex_leave(db->mutex);\n      CODEC_TRACE_MUTEX(\"sqlite3_rekey_v2: left database mutex %p\\n\", db->mutex);\n    }\n    return SQLITE_OK;\n  }\n  return SQLITE_ERROR;\n}\n\nvoid sqlite3CodecGetKey(sqlite3* db, int nDb, void **zKey, int *nKey) {\n  struct Db *pDb = &db->aDb[nDb];\n  CODEC_TRACE(\"sqlite3CodecGetKey: entered db=%p, nDb=%d\\n\", db, nDb);\n  if( pDb->pBt ) {\n    codec_ctx *ctx = (codec_ctx*) sqlite3PagerGetCodec(pDb->pBt->pBt->pPager);\n    \n    if(ctx) {\n      /* pass back the keyspec from the codec, unless PRAGMA cipher_store_pass\n         is set or keyspec has not yet been derived, in which case pass\n         back the password key material */\n      sqlcipher_codec_get_keyspec(ctx, zKey, nKey);\n      if(sqlcipher_codec_get_store_pass(ctx) == 1 || *zKey == NULL) {\n        sqlcipher_codec_get_pass(ctx, zKey, nKey);\n      }\n    } else {\n      *zKey = NULL;\n      *nKey = 0;\n    }\n  }\n}\n\n/*\n * Implementation of an \"export\" function that allows a caller\n * to duplicate the main database to an attached database. This is intended\n * as a conveneince for users who need to:\n * \n *   1. migrate from an non-encrypted database to an encrypted database\n *   2. move from an encrypted database to a non-encrypted database\n *   3. convert beween the various flavors of encrypted databases.  \n *\n * This implementation is based heavily on the procedure and code used\n * in vacuum.c, but is exposed as a function that allows export to any\n * named attached database.\n */\n\n/*\n** Finalize a prepared statement.  If there was an error, store the\n** text of the error message in *pzErrMsg.  Return the result code.\n** \n** Based on vacuumFinalize from vacuum.c\n*/\nstatic int sqlcipher_finalize(sqlite3 *db, sqlite3_stmt *pStmt, char **pzErrMsg){\n  int rc;\n  rc = sqlite3VdbeFinalize((Vdbe*)pStmt);\n  if( rc ){\n    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));\n  }\n  return rc;\n}\n\n/*\n** Execute zSql on database db. Return an error code.\n** \n** Based on execSql from vacuum.c\n*/\nstatic int sqlcipher_execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){\n  sqlite3_stmt *pStmt;\n  VVA_ONLY( int rc; )\n  if( !zSql ){\n    return SQLITE_NOMEM;\n  }\n  if( SQLITE_OK!=sqlite3_prepare(db, zSql, -1, &pStmt, 0) ){\n    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));\n    return sqlite3_errcode(db);\n  }\n  VVA_ONLY( rc = ) sqlite3_step(pStmt);\n  assert( rc!=SQLITE_ROW );\n  return sqlcipher_finalize(db, pStmt, pzErrMsg);\n}\n\n/*\n** Execute zSql on database db. The statement returns exactly\n** one column. Execute this as SQL on the same database.\n** \n** Based on execExecSql from vacuum.c\n*/\nstatic int sqlcipher_execExecSql(sqlite3 *db, char **pzErrMsg, const char *zSql){\n  sqlite3_stmt *pStmt;\n  int rc;\n\n  rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ) return rc;\n\n  while( SQLITE_ROW==sqlite3_step(pStmt) ){\n    rc = sqlcipher_execSql(db, pzErrMsg, (char*)sqlite3_column_text(pStmt, 0));\n    if( rc!=SQLITE_OK ){\n      sqlcipher_finalize(db, pStmt, pzErrMsg);\n      return rc;\n    }\n  }\n\n  return sqlcipher_finalize(db, pStmt, pzErrMsg);\n}\n\n/*\n * copy database and schema from the main database to an attached database\n * \n * Based on sqlite3RunVacuum from vacuum.c\n*/\nvoid sqlcipher_exportFunc(sqlite3_context *context, int argc, sqlite3_value **argv) {\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char* targetDb, *sourceDb; \n  int targetDb_idx = 0;\n  u64 saved_flags = db->flags;        /* Saved value of the db->flags */\n  u32 saved_mDbFlags = db->mDbFlags;        /* Saved value of the db->mDbFlags */\n  int saved_nChange = db->nChange;      /* Saved value of db->nChange */\n  int saved_nTotalChange = db->nTotalChange; /* Saved value of db->nTotalChange */\n  u8 saved_mTrace = db->mTrace;        /* Saved value of db->mTrace */\n  int rc = SQLITE_OK;     /* Return code from service routines */\n  char *zSql = NULL;         /* SQL statements */\n  char *pzErrMsg = NULL;\n\n  if(argc != 1 && argc != 2) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"invalid number of arguments (%d) passed to sqlcipher_export\", argc);\n    goto end_of_export;\n  }\n\n  if(sqlite3_value_type(argv[0]) == SQLITE_NULL) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"target database can't be NULL\");\n    goto end_of_export;\n  }\n\n  targetDb = (const char*) sqlite3_value_text(argv[0]); \n  sourceDb = \"main\";\n\n  if(argc == 2) {\n    if(sqlite3_value_type(argv[1]) == SQLITE_NULL) {\n      rc = SQLITE_ERROR;\n      pzErrMsg = sqlite3_mprintf(\"target database can't be NULL\");\n      goto end_of_export;\n    }\n    sourceDb = (char *) sqlite3_value_text(argv[1]);\n  }\n\n\n  /* if the name of the target is not main, but the index returned is zero \n     there is a mismatch and we should not proceed */\n  targetDb_idx =  sqlcipher_find_db_index(db, targetDb);\n  if(targetDb_idx == 0 && targetDb != NULL && sqlite3StrICmp(\"main\", targetDb) != 0) {\n    rc = SQLITE_ERROR;\n    pzErrMsg = sqlite3_mprintf(\"unknown database %s\", targetDb);\n    goto end_of_export;\n  }\n  db->init.iDb = targetDb_idx;\n\n  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks; \n  db->mDbFlags |= DBFLAG_PreferBuiltin | DBFLAG_Vacuum;\n  db->flags &= ~(u64)(SQLITE_ForeignKeys | SQLITE_ReverseOrder | SQLITE_Defensive | SQLITE_CountRows); \n  db->mTrace = 0;\n\n  /* Query the schema of the main database. Create a mirror schema\n  ** in the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE type='table' AND name!='sqlite_sequence'\"\n    \"   AND rootpage>0\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE INDEX %%' \"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = sqlite3_mprintf(\n    \"SELECT sql \"\n    \"  FROM %s.sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %%'\"\n  , sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Loop through the tables in the main database. For each, do\n  ** an \"INSERT INTO rekey_db.xxx SELECT * FROM main.xxx;\" to copy\n  ** the contents to the temporary database.\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';'\"\n    \"FROM %s.sqlite_master \"\n    \"WHERE type = 'table' AND name!='sqlite_sequence' \"\n    \"  AND rootpage>0\"\n  , targetDb, sourceDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy over the contents of the sequence table\n  */\n  zSql = sqlite3_mprintf(\n    \"SELECT 'INSERT INTO %s.' || quote(name) \"\n    \"|| ' SELECT * FROM %s.' || quote(name) || ';' \"\n    \"FROM %s.sqlite_master WHERE name=='sqlite_sequence';\"\n  , targetDb, sourceDb, targetDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execExecSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  /* Copy the triggers, views, and virtual tables from the main database\n  ** over to the temporary database.  None of these objects has any\n  ** associated storage, so all we have to do is copy their entries\n  ** from the SQLITE_MASTER table.\n  */\n  zSql = sqlite3_mprintf(\n    \"INSERT INTO %s.sqlite_master \"\n    \"  SELECT type, name, tbl_name, rootpage, sql\"\n    \"    FROM %s.sqlite_master\"\n    \"   WHERE type='view' OR type='trigger'\"\n    \"      OR (type='table' AND rootpage=0)\"\n  , targetDb, sourceDb);\n  rc = (zSql == NULL) ? SQLITE_NOMEM : sqlcipher_execSql(db, &pzErrMsg, zSql); \n  if( rc!=SQLITE_OK ) goto end_of_export;\n  sqlite3_free(zSql);\n\n  zSql = NULL;\nend_of_export:\n  db->init.iDb = 0;\n  db->flags = saved_flags;\n  db->mDbFlags = saved_mDbFlags;\n  db->nChange = saved_nChange;\n  db->nTotalChange = saved_nTotalChange;\n  db->mTrace = saved_mTrace;\n\n  if(zSql) sqlite3_free(zSql);\n\n  if(rc) {\n    if(pzErrMsg != NULL) {\n      sqlite3_result_error(context, pzErrMsg, -1);\n      sqlite3DbFree(db, pzErrMsg);\n    } else {\n      sqlite3_result_error(context, sqlite3ErrStr(rc), -1);\n    }\n  }\n}\n#endif\n/* END SQLCIPHER */\n", "# SQLCipher\n# codec.test developed by Stephen Lombardo (Zetetic LLC)\n# sjlombardo at zetetic dot net\n# http://zetetic.net\n#\n# Copyright (c) 2018, ZETETIC LLC\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#     * Redistributions of source code must retain the above copyright\n#       notice, this list of conditions and the following disclaimer.\n#     * Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in the\n#       documentation and/or other materials provided with the distribution.\n#     * Neither the name of the ZETETIC LLC nor the\n#       names of its contributors may be used to endorse or promote products\n#       derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY ZETETIC LLC ''AS IS'' AND ANY\n# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL ZETETIC LLC BE LIABLE FOR ANY\n# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# This file implements regression tests for SQLite library.  The\n# focus of this script is testing code cipher features.\n#\n# NOTE: tester.tcl has overridden the definition of sqlite3 to\n# automatically pass in a key value. Thus tests in this file\n# should explicitly close and open db with sqlite_orig in order\n# to bypass default key assignment.\n\nset testdir [file dirname $argv0]\nsource $testdir/tester.tcl\nsource $testdir/sqlcipher.tcl\n\nset old_pending_byte [sqlite3_test_control_pending_byte 0x40000000]\n\n# create an unencrypted database, attach a new encrypted volume\n# copy data between, verify the encypted database is good afterwards\ndo_test unencrypted-attach {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  } \n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS db2 KEY 'testkey';\n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM t1;\n    DETACH DATABASE db2;\n  }\n  \n  sqlite_orig db2 test2.db\n  execsql {\n    PRAGMA  key='testkey';\n    SELECT count(*) FROM t1;\n  } db2 \n} {ok 1000}\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n# create an unencrypted database, attach a new encrypted volume\n# using a raw key copy data between, verify the encypted \n# database is good afterwards \ndo_test unencrypted-attach-raw-key {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  } \n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS db2 KEY \"x'10483C6EB40B6C31A448C22A66DED3B5E5E8D5119CAC8327B655C8B5C4836481'\";\n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM t1;\n    DETACH DATABASE db2;\n  }\n  \n  sqlite_orig db2 test2.db\n  execsql {\n    PRAGMA key=\"x'10483C6EB40B6C31A448C22A66DED3B5E5E8D5119CAC8327B655C8B5C4836481'\";\n    SELECT count(*) FROM t1;\n  } db2 \n} {ok 1000}\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n# open a 4.0 database \ndo_test compat-open-4.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-4.0-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\ndb close\n\n# create an encrypted database, attach an default-key encrypted volume\n# copy data between, verify the second database\ndo_test encrypted-attach-default-key {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA  key='testkey';\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS test;\n    CREATE TABLE test.t1(a,b);\n    INSERT INTO test.t1 SELECT * FROM t1;\n    DETACH DATABASE test;\n  } \n\n  sqlite_orig db2 test2.db\n\n  execsql {\n    PRAGMA  key='testkey';\n    SELECT count(*) FROM t1;\n  } db2\n} {ok 1000}\ndb close\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n# create an encrypted database, attach an unencrypted volume\n# copy data between, verify the unencypted database is good afterwards\ndo_test encrypted-attach-unencrypted {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n  } \n\n  sqlite_orig db2 test2.db\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }  db2\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" db2 \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test.db' AS test KEY '';\n    INSERT INTO test.t1 SELECT * FROM t1;\n    DETACH DATABASE test;\n  } db2\n\n  execsql {\n    SELECT count(*) FROM t1;\n  } \n} {1000}\ndb close\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n# create an unencrypted database, attach an encrypted database\n# then copy the data to it via sqlcipher_export and verify results\ndo_test unencrypted-to-encrypted-export {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" \n  }\n\n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS test2 KEY 'testkey2';\n    SELECT sqlcipher_export('test2');\n    DETACH DATABASE test2;\n  } \n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    SELECT count(*) FROM t1;\n  } \n\n  execsql {\n    SELECT count(*) FROM t1;\n  }\n} {1000}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\ndo_test unencrypted-corrupt-to-encrypted-export {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    INSERT INTO t1 VALUES (1,2);\n\n    PRAGMA writable_schema = ON;\n\n    UPDATE sqlite_master SET sql = 'CREATE TABLE IF NOT EXISTS t1(a,b)' \n    WHERE tbl_name = 't1';\n\n    PRAGMA writable_schema = OFF;\n    INSERT INTO t1 VALUES (3,4);\n\n    SELECT * FROM t1;\n\n    ATTACH DATABASE 'test2.db' AS test2 KEY 'testkey2';\n\n    SELECT sqlcipher_export('test2');\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    SELECT count(*) FROM sqlite_master;\n    SELECT count(*) FROM t1;\n  }\n} {ok 1 2}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n\n# create an encrypted database, attach an unencrypted database\n# with data in it, then import the data back into the encrypted DB\n# and verify\ndo_test unencrypted-to-encrypted-import {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\"\n  }\n\n  execsql {\n    COMMIT;\n  }\n  db close\n\n  sqlite_orig db test2.db\n\n  execsql {\n    PRAGMA key = 'testkey2';\n    ATTACH DATABASE 'test.db' AS test KEY '';\n    SELECT sqlcipher_export('main', 'test');\n    DETACH DATABASE test;\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    SELECT count(*) FROM t1;\n  }\n} {ok 1000}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n# create an unencrypted database, attach an unencrypted volume\n# copy data between, verify the unencypted database is good afterwards\ndo_test unencrypted-attach-unencrypted {\n  sqlite_orig db test.db\n\n  execsql {\n    CREATE TABLE t1(a,b);\n  } \n\n  sqlite_orig db2 test2.db\n  execsql {\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }  db2\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,$r);\" db2 \n  }\n  \n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test.db' AS test;\n    INSERT INTO test.t1 SELECT * FROM t1;\n    DETACH DATABASE test;\n  } db2\n\n  execsql {\n    SELECT count(*) FROM t1;\n  } \n} {1000}\ndb close\ndb2 close\nfile delete -force test.db\nfile delete -force test2.db\n\n\n# open a 1.1.8 database using the new code, HMAC disabled\ndo_test open-1.1.8-database {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db test.db\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_use_hmac = off;\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok 75709 1 1 one one 1 2 one two 1 2}\ndb close\nfile delete -force test.db\n\n# open a 1.1.8 database without hmac, then copy the data\ndo_test attach-and-copy-1.1.8 {\n  sqlite_orig db $sampleDir/sqlcipher-1.1.8-testkey.db\n  \n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_use_hmac = OFF;\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    ATTACH DATABASE 'test.db' AS db2 KEY 'testkey-hmac'; \n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM main.t1;\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey-hmac';\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  }\n} {ok 75709 1 1 one one 1 2 one two 1 2}\ndb close\nfile delete -force test.db\n\n\n# open a standard database, then attach a new \n# database with completely different options. \n# copy data between them, and verify that the\n# new database can be opened with the proper data\ndo_test attached-database-pragmas {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=1000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,'value $r');\" \n  } \n\n  execsql {\n    COMMIT;\n    ATTACH DATABASE 'test2.db' AS db2 KEY 'testkey2'; \n    PRAGMA db2.cipher_page_size = 8192;\n    PRAGMA db2.kdf_iter = 1000;\n    PRAGMA db2.cipher_use_hmac = OFF;\n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM main.t1;\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    PRAGMA cipher_page_size = 8192;\n    PRAGMA kdf_iter = 1000;\n    PRAGMA cipher_use_hmac = OFF;\n    SELECT count(*) FROM t1;\n  }\n} {ok 1000}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n# use the sqlcipher_export function\n# on a non-existent database. Verify \n# the error gets through.\ndo_test export-error {\n  sqlite_orig db test.db\n\n  catchsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a,b);\n    SELECT sqlcipher_export('nodb');\n  } \n} {1 {unknown database nodb}}\ndb close\nfile delete -force test.db\n\n# verify sqlcipher_export with NULL parameters\ndo_test export-nulls {\n  sqlite_orig db test.db\n\n  catchsql {\n    SELECT sqlcipher_export(NULL);\n  }\n\n} {1 {target database can't be NULL}}\ndb close\nfile delete -force test.db\n\ndo_test export-nulls {\n  sqlite_orig db test.db\n\n  catchsql {\n    SELECT sqlcipher_export('main', NULL);\n  }\n\n} {1 {target database can't be NULL}}\ndb close\nfile delete -force test.db\n\n\n# use the sqlcipher_export function\n\n# use the sqlcipher_export function\n# to copy a complicated database. \n# tests autoincrement fields,\n# indexes, views, and triggers,\n# tables and virtual tables\ndo_test export-database {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a INTEGER PRIMARY KEY AUTOINCREMENT, b, c);\n    CREATE UNIQUE INDEX b_idx ON t1(b);\n    CREATE INDEX c_idx ON t1(c);\n\n    CREATE TABLE t2(b,c);\n    CREATE TRIGGER t2_after_insert AFTER INSERT ON t2\n    BEGIN \n      INSERT INTO t1(b,c) VALUES (new.b, new.c);\n    END;\n\n    CREATE VIEW v1 AS\n      SELECT c FROM t1;\n\n    CREATE VIRTUAL TABLE fts USING fts5(a,b); \n\n    BEGIN;\n    -- start with one known value\n    INSERT INTO t2 VALUES(1000000,'value 1000000');\n  }\n\n  for {set i 1} {$i<=999} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t2 VALUES($i,'value $r');\" \n  } \n\n  execsql {\n    INSERT INTO fts SELECT b,c FROM t1;\n    COMMIT;\n\n    ATTACH DATABASE 'test2.db' AS db2 KEY 'testkey2'; \n    PRAGMA db2.cipher_page_size = 8192;\n\n    SELECT sqlcipher_export('db2');\n\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    PRAGMA cipher_page_size = 8192;\n    SELECT count(*) FROM t1;\n    SELECT count(*) FROM v1;\n    SELECT count(*) FROM sqlite_sequence;\n    SELECT seq FROM sqlite_sequence WHERE name = 't1';\n    INSERT INTO t2 VALUES(10001, 'value 938383');\n    SELECT count(*) FROM t1; -- verify the trigger worked\n    SELECT seq FROM sqlite_sequence WHERE name = 't1'; -- verify that autoincrement worked\n    SELECT a FROM fts WHERE b MATCH '1000000';  \n  }\n} {ok 1000 1000 1 1000 1001 1001 1000000}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n# use the sqlcipher_export function\n# to copy a complicated attached database to the main database\ndo_test export-attached-database {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE TABLE t1(a INTEGER PRIMARY KEY AUTOINCREMENT, b, c);\n    CREATE UNIQUE INDEX b_idx ON t1(b);\n    CREATE INDEX c_idx ON t1(c);\n\n    CREATE TABLE t2(b,c);\n    CREATE TRIGGER t2_after_insert AFTER INSERT ON t2\n    BEGIN\n      INSERT INTO t1(b,c) VALUES (new.b, new.c);\n    END;\n\n    CREATE VIEW v1 AS\n      SELECT c FROM t1;\n\n    CREATE VIRTUAL TABLE fts USING fts5(a,b);\n\n    BEGIN;\n    -- start with one known value\n    INSERT INTO t2 VALUES(1000000,'value 1000000');\n  }\n\n  for {set i 1} {$i<=999} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t2 VALUES($i,'value $r');\"\n  }\n\n  execsql {\n    INSERT INTO fts SELECT b,c FROM t1;\n    COMMIT;\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n\n    CREATE TABLE t3(a INTEGER PRIMARY KEY AUTOINCREMENT, b, c);\n    CREATE UNIQUE INDEX d_idx ON t3(b);\n    INSERT INTO t3(b,c) VALUES ('one', 'two');\n\n    ATTACH DATABASE 'test.db' AS db KEY 'testkey';\n\n    SELECT sqlcipher_export('main', 'db');\n\n    DETACH DATABASE db;\n    INSERT INTO t3(b,c) VALUES ('three', 'four');\n  }\n  db close\n\n  sqlite_orig db test2.db\n  execsql {\n    PRAGMA key = 'testkey2';\n    SELECT count(*) FROM t1;\n    SELECT count(*) FROM v1;\n    SELECT count(*) FROM sqlite_sequence;\n    SELECT seq FROM sqlite_sequence WHERE name = 't1';\n    INSERT INTO t2 VALUES(10001, 'value 938383');\n    SELECT count(*) FROM t1; -- verify the trigger worked\n    SELECT seq FROM sqlite_sequence WHERE name = 't1'; -- verify that autoincrement worked\n    SELECT a FROM fts WHERE b MATCH '1000000';\n    SELECT count(*) FROM t3;\n  }\n} {ok 1000 1000 2 1000 1001 1001 1000000 2}\ndb close\nfile delete -force test.db\nfile delete -force test2.db\n\n\n# open the database then insert a bunch of data.\n# then delete it and run a manual vacuum\n# verify that the file has become smaller\n# but can still be opened with the proper\n# key. also test vacuum into functionality introduced\n# in sqlite 3.27.1\ndo_test vacuum {\n  sqlite_orig db test.db\n  set rc {}\n\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE table t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<=10000} {incr i} {\n    set r [expr {int(rand()*500000)}]\n    execsql \"INSERT INTO t1 VALUES($i,'value $r');\" \n  }\n\n  lappend rc [execsql {\n    COMMIT;\n    SELECT count(*) FROM t1;\n  }]\n\n  # grab current size of file\n  set sz [file size test.db]\n\n  execsql {\n    DELETE FROM t1 WHERE rowid > 5000;\n    VACUUM into 'test-vacuum.db';\n    VACUUM;\n  } \n  db close\n\n  # grab separate vacuum file size\n  set sz2 [file size test-vacuum.db]\n\n  # grab test.db file size, post vacuum\n  set sz3 [file size test.db]\n\n  # verify that the new size is \n  # smaller than the old size\n  if {$sz > $sz2} { lappend rc true }\n  if {$sz > $sz3} { lappend rc true }\n\n  sqlite_orig db test-vacuum.db\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n  }]\n  db close\n\n  sqlite_orig db test.db\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n  }]\n\n} {10000 true true {ok 5000} {ok 5000}}\ndb close\nfile delete -force test.db\nfile delete -force test-vacuum.db\n\n# open a 1.1.8 database (no HMAC, 4K iter), then \n# try to open another 1.1.8 database. The\n# attached database should have the same hmac\n# setting as the original \ndo_test default-hmac-kdf-attach {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db test.db\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db sqlcipher-1.1.8-testkey.db;\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA cipher_default_use_hmac = OFF;\n    PRAGMA cipher_default_kdf_iter = 4000;\n    PRAGMA cipher_default_page_size = 1024;\n    PRAGMA cipher_default_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n    ATTACH 'sqlcipher-1.1.8-testkey.db' AS db2 KEY 'testkey';\n    SELECT count(*) from db2.t1;\n    PRAGMA cipher_default_use_hmac = ON;\n    PRAGMA cipher_default_kdf_iter = 256000;\n    PRAGMA cipher_default_page_size = 4096;\n    PRAGMA cipher_default_kdf_algorithm = PBKDF2_HMAC_SHA512;\n  } \n} {ok 75709 75709}\ndb close\nfile delete -force test.db\nfile delete -force sqlcipher-1.1.8-testkey.db\n\n# open a 2.0 database (with HMAC), then \n# try to a 1.1.8 database. this should \n# fail because the hmac setting for the \n# attached database is not compatible\ndo_test attach-1.1.8-database-from-2.0-fails {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db sqlcipher-1.1.8-testkey.db;\n  sqlite_orig db test.db\n  catchsql {\n    PRAGMA key = 'testkey';\n    CREATE table t1(a,b);\n    ATTACH 'sqlcipher-1.1.8-testkey.db' AS db2 KEY 'testkey';\n  } \n} {1 {file is not a database}}\ndb close\nfile delete -force test.db\nfile delete -force sqlcipher-1.1.8-testkey.db\n\n# open a 2.0 database (with HMAC, 4k iter), then \n# set the default hmac setting to OFF.\n# try to a 1.1.8 database. this should \n# succeed now that hmac is off by default\n# before the attach\ndo_test change-default-hmac-kdf-attach {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db sqlcipher-1.1.8-testkey.db;\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    CREATE table t1(a,b);\n    INSERT INTO t1(a,b) VALUES (1,2);\n  }\n  db close\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n    PRAGMA cipher_default_use_hmac = OFF;\n    PRAGMA cipher_default_kdf_iter = 4000;\n    PRAGMA cipher_default_page_size = 1024;\n    PRAGMA cipher_default_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    ATTACH 'sqlcipher-1.1.8-testkey.db' AS db2 KEY 'testkey';\n    SELECT count(*) from db2.t1;\n    PRAGMA cipher_default_use_hmac = ON;\n    PRAGMA cipher_default_kdf_iter = 256000;\n    PRAGMA cipher_default_page_size = 4096;\n    PRAGMA cipher_default_kdf_algorithm = PBKDF2_HMAC_SHA512;\n  } \n} {ok 1 75709}\ndb close\nfile delete -force test.db\nfile delete -force sqlcipher-1.1.8-testkey.db\n\n\n# create a new database, insert some data\n# and delete some data with \n# auto_vacuum on\ndo_test auto-vacuum-full {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'test123';\n    PRAGMA auto_vacuum = FULL;\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<10000} {incr i} {\n    set r [expr {int(rand()*32767)}]\n    set r1 [expr {int(rand()*32767)}]\n    execsql \"INSERT INTO t1 VALUES($r,$r1);\"\n  }\n  set r [expr {int(rand()*32767)}]\n  execsql \"DELETE FROM t1 WHERE a < $r;\"\n\n  execsql {\n    COMMIT;\n    PRAGMA integrity_check;\n    PRAGMA freelist_count;\n    SELECT (count(*) > 0) FROM t1;\n  }\n} {ok 0 1}\ndb close\nfile delete -force test.db\n\n# create a new database, insert some data\n# and delete some data with \n# auto_vacuum incremental \ndo_test auto-vacuum-incremental {\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'test123';\n    PRAGMA auto_vacuum = INCREMENTAL;\n    CREATE TABLE t1(a,b);\n    BEGIN;\n  }\n\n  for {set i 1} {$i<10000} {incr i} {\n    set r [expr {int(rand()*32767)}]\n    set r1 [expr {int(rand()*32767)}]\n    execsql \"INSERT INTO t1 VALUES($r,$r1);\"\n  }\n  set r [expr {int(rand()*32767)}]\n  execsql \"DELETE FROM t1 WHERE a < $r;\"\n\n  execsql {\n    COMMIT;\n    PRAGMA incremental_vacuum;\n    PRAGMA freelist_count; \n    PRAGMA integrity_check;\n    SELECT (count(*) > 0) FROM t1;\n  }\n} {0 ok 1}\ndb close\nfile delete -force test.db\n\n\n# create a database with many hundred tables such that the schema\n# will overflow the first several pages of the database. verify the schema\n# is intact on open.\ndo_test multipage-schema {\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    BEGIN EXCLUSIVE;\n  } db\n  \n  for {set i 1} {$i<=300} {incr i} {\n    execsql \"CREATE TABLE tab$i (a TEXT, b TEXT, c TEXT, d TEXT, e TEXT, f TEXT, g TEXT, h TEXT, i TEXT, j TEXT, k, TEXT, l, m TEXT, n TEXT, o TEXT, p TEXT);\" db\n  }\n\n  execsql {\n    COMMIT;\n  } db\n\n  db close\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master where type = 'table';\n  } db\n\n} {ok 300}\ndb close\nfile delete -force test.db\n\n# create a database with many hundred tables such that the schema\n# will overflow the first several pages of the database. this time, enable\n# autovacuum on the database, which will cause sqlite to do some \"short reads\"\n# after the end of the main database file. verify that there are no HMAC errors\n# resulting from the short reads, and that the schema is intact when \n# the database is reopened\ndo_test multipage-schema-autovacuum-shortread {\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA auto_vacuum = FULL;\n    BEGIN EXCLUSIVE;\n  } db\n  \n  for {set i 1} {$i<=300} {incr i} {\n    execsql \"CREATE TABLE tab$i (a TEXT, b TEXT, c TEXT, d TEXT, e TEXT, f TEXT, g TEXT, h TEXT, i TEXT, j TEXT, k, TEXT, l, m TEXT, n TEXT, o TEXT, p TEXT);\" db\n  }\n\n  execsql {\n    COMMIT;\n  } db\n\n  db close\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master where type = 'table';\n  } db\n\n} {ok 300}\ndb close\nfile delete -force test.db\n\n# same as multi-page-schema-autovacuum-shortread, except\n# using write ahead log mode\ndo_test multipage-schema-autovacuum-shortread-wal {\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA auto_vacuum = FULL;\n    PRAGMA journal_mode = WAL;\n    BEGIN EXCLUSIVE;\n  } db\n  \n  for {set i 1} {$i<=300} {incr i} {\n    execsql \"CREATE TABLE tab$i (a TEXT, b TEXT, c TEXT, d TEXT, e TEXT, f TEXT, g TEXT, h TEXT, i TEXT, j TEXT, k, TEXT, l, m TEXT, n TEXT, o TEXT, p TEXT);\" db\n  }\n\n  execsql {\n    COMMIT;\n  } db\n\n  db close\n  sqlite_orig db test.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master where type = 'table';\n  } db\n} {ok 300}\ndb close\nfile delete -force test.db\n\n# open a 3.0 database with little endian hmac page numbers (default)\n# verify it can be opened\ndo_test open-3.0-le-database {\n  sqlite_orig db $sampleDir/sqlcipher-3.0-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA kdf_iter = 64000;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok 78536 1 1 one one 1 2 one two}\ndb close\n\n# open a 2.0 database with little endian hmac page numbers (default)\n# verify it can be opened\ndo_test open-2.0-le-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-le-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok 78536 1 1 one one 1 2 one two}\ndb close\n\n# open a 2.0 database with big-endian hmac page numbers\n# verify it can be opened\ndo_test open-2.0-be-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-be-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_hmac_pgno = be;\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok {PRAGMA cipher_hmac_pgno is deprecated, please remove from use} 78536 1 1 one one 1 2 one two}\ndb close\n\n# open a 2.0 database with big-endian hmac page numbers\n# attach a new database with little endian page numbers (default)\n# copy schema between the two, and verify the latter \n# can be opened\ndo_test be-to-le-migration {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-be-testkey.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_hmac_pgno = be;\n    PRAGMA kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    ATTACH DATABASE 'test.db' AS db2 KEY 'testkey'; \n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM main.t1;\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  }\n} {ok 78536 1 1 one one 1 2 one two}\ndb close\nfile delete -force test.db\n\n\n\n# open a 2.0 beta database with 4000 round hmac kdf and 0x00 \n# hmac salt mask \n# verify it can be opened\ndo_test open-2.0-beta-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-beta-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA kdf_iter = 4000;\n    PRAGMA fast_kdf_iter = 4000;\n    PRAGMA cipher_hmac_salt_mask = \"x'00'\";\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM t1;\n    SELECT distinct * FROM t1;\n  } \n} {ok {PRAGMA fast_kdf_iter is deprecated, please remove from use} {PRAGMA cipher_hmac_salt_mask is deprecated, please remove from use} 38768 test-0-0 test-0-1 test-1-0 test-1-1}\ndb close\n\n# open a 2.0 beta database \n# attach a new standard database\n# copy schema between the two, and verify the latter \n# can be opened\ndo_test 2.0-beta-to-2.0-migration {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-beta-testkey.db\n\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_hmac_salt_mask = \"x'00'\";\n    PRAGMA kdf_iter = 4000;\n    PRAGMA fast_kdf_iter = 4000;\n    PRAGMA cipher_page_size = 1024;\n    PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n    PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    SELECT count(*) FROM sqlite_master;\n\n    PRAGMA cipher_hmac_salt_mask = \"x'3a'\";\n    ATTACH DATABASE 'test.db' AS db2 KEY 'testkey'; \n    \n    CREATE TABLE db2.t1(a,b);\n    INSERT INTO db2.t1 SELECT * FROM main.t1;\n    DETACH DATABASE db2;\n  }\n  db close\n\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT distinct * FROM t1;\n  }\n} {ok test-0-0 test-0-1 test-1-0 test-1-1}\ndb close\nfile delete -force test.db\n\ndo_test migrate-1.1.8-database-to-current-format {\n  file copy -force $sampleDir/sqlcipher-1.1.8-testkey.db test.db\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_migrate;\n  }\n  db close\n    \n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master;\n  }\n} {ok 1}\ndb close\nfile delete -force test.db test.db-migrated test.db-journal\n\ndo_test migrate-2-0-le-database-to-current-format {\n  file copy -force $sampleDir/sqlcipher-2.0-le-testkey.db test.db\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_migrate;\n  }\n  db close\n    \n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master;\n  }\n} {ok 1}\ndb close\nfile delete -force test.db test.db-migrated test.db-journal\n\ndo_test migrate-3-0-database-to-current-format {\n  file copy -force $sampleDir/sqlcipher-3.0-testkey.db test.db\n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_migrate;\n  }\n  db close\n    \n  sqlite_orig db test.db\n  execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master;\n    PRAGMA journal_mode;\n  }\n} {ok 1 delete}\ndb close\nfile delete -force test.db\n\ndo_test migrate-wal-database-to-current {\n  file copy -force $sampleDir/sqlcipher-3.0-testkey.db test.db\n  sqlite_orig db test.db\n  set rc {}\n\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_page_size = 1024; PRAGMA kdf_iter = 64000; PRAGMA cipher_hmac_algorithm = HMAC_SHA1; PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n    PRAGMA journal_mode = wal;\n  }]\n  db close\n    \n  sqlite_orig db test.db\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_migrate;\n    PRAGMA journal_mode;\n  }]\n  db close\n\n  sqlite_orig db test.db\n  lappend rc [execsql {\n    PRAGMA key = 'testkey';\n    SELECT count(*) FROM sqlite_master;\n    PRAGMA journal_mode;\n  }]\n} {{ok wal} {ok 0 wal} {ok 1 wal}}\ndb close\nfile delete -force test.db\n\n\ndo_test key-database-by-name {\n    sqlite_orig db test.db\n    execsql {\n        attach database 'new.db' as new;\n        pragma new.key = 'foo';\n        create table new.t1(a,b);\n        insert into new.t1(a,b) values('foo', 'bar');\n        detach database new;\n    }\n    db close\n\n    sqlite_orig db new.db\n    execsql {\n        pragma key = 'foo';\n        select * from t1;\n    }\n} {ok foo bar}\ndb close\nfile delete -force test.db\nfile delete -force new.db\n\ndo_test key-multiple-databases-with-different-keys-using-pragma {\n    sqlite_orig db test.db\n    execsql {\n        pragma key = 'foobar';\n        create table t1(a,b);\n        insert into t1(a,b) values('baz','qux');\n        attach database 'new.db' as new;\n        pragma new.key = 'foo';\n        create table new.t1(a,b);\n        insert into new.t1(a,b) values('foo', 'bar');\n        detach database new;\n    }\n    db close\n\n    sqlite_orig db new.db\n    execsql {\n        pragma key = 'foo';\n        attach database 'test.db' as test key 'foobar';\n        select * from t1;\n        select * from test.t1;\n    }\n} {ok foo bar baz qux}\ndb close\nfile delete -force test.db\nfile delete -force new.db\n\n\n# Requires SQLCipher to be built with -DSQLCIPHER_TEST\nif_built_with_libtomcrypt verify-random-data-alters-file-content {\n    file delete -force test.db\n    file delete -force test2.db\n    file delete -force test3.db\n    set rc {}\n    \n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key=\"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        create table t1(a,b);\n    }\n    db close\n    sqlite_orig db test2.db\n    execsql {\n        PRAGMA key=\"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        create table t1(a,b);\n    }\n    db close\n    sqlite_orig db test3.db\n    execsql {\n        PRAGMA key=\"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        PRAGMA cipher_add_random = \"x'deadbaad'\";\n        create table t1(a,b);\n    }\n    db close\n    lappend rc [cmpFilesChunked test.db test2.db]\n    lappend rc [cmpFilesChunked test2.db test3.db]\n} {0 1}\nfile delete -force test.db\nfile delete -force test2.db\nfile delete -force test3.db\n\ndo_test can-migrate-with-keys-longer-than-64-characters {\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"012345678901234567890123456789012345678901234567890123456789012345\";\n        PRAGMA cipher_page_size = 1024;\n        PRAGMA kdf_iter = 4000;\n        PRAGMA cipher_hmac_algorithm = HMAC_SHA1;\n        PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA1;\n        PRAGMA user_version = 5;\n    }\n    db close\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"012345678901234567890123456789012345678901234567890123456789012345\";\n        PRAGMA cipher_migrate;\n    }\n    db close\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"012345678901234567890123456789012345678901234567890123456789012345\";\n        PRAGMA user_version;\n    }\n} {ok 5}\ndb close\nfile delete -force test.db\n\ndo_test can-migrate-with-raw-hex-key {\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        PRAGMA cipher_page_size = 1024;\n        PRAGMA kdf_iter = 4000;\n        PRAGMA cipher_use_hmac = off;\n        PRAGMA user_version = 5;\n    }\n    db close\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        PRAGMA cipher_migrate;\n    }\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA key = \"x'2DD29CA851E7B56E4697B0E1F08507293D761A05CE4D1B628663F411A8086D99'\";\n        PRAGMA user_version;\n    }\n    \n} {ok 5}\ndb close\nfile delete -force test.db\n\ndo_test attach_database_with_non_default_page_size {\n    sqlite_orig db test2.db\n    execsql {\n        PRAGMA key = 'test';\n        PRAGMA cipher_page_size = 8192;\n        CREATE TABLE t1(a,b);\n        INSERT INTO t1(a,b) values('one for the money', 'two for the show');\n        INSERT INTO t1(a,b) values('three to get ready', 'now, go cat, go');\n    }\n    db close\n\n    sqlite_orig db test.db\n    execsql {\n        PRAGMA cipher_default_page_size = 8192;\n        PRAGMA key = 'test';\n        ATTACH DATABASE 'test2.db' as test2 KEY 'test';\n        SELECT count(*) FROM test2.t1;\n        PRAGMA cipher_default_page_size = 4096;\n    }\n} {ok 2}\ndb close\nfile delete -force test.db test2.db\n\ndo_test verify-cipher-export-with-trace-configured {\n  sqlite_orig db plain.db\n  execsql {\n    CREATE TABLE t1(a,b);\n    INSERT INTO t1(a,b) VALUES(1,2);\n  }\n  set TRACE_OUT {}\n  db trace trace_proc\n  execsql {\n    ATTACH DATABASE 'encrypted.db' AS encrypted KEY 'encrypted';\n    SELECT sqlcipher_export('encrypted');\n    DETACH DATABASE encrypted;\n  }\n  set TRACE_OUT\n} {{ATTACH DATABASE 'encrypted.db' AS encrypted KEY 'encrypted';} {SELECT sqlcipher_export('encrypted');} {DETACH DATABASE encrypted;}}\nset TRACE_OUT {}\ndb close\nfile delete -force plain.db\nfile delete -force encrypted.db\n\n# open a 1.1.8 database using cipher_compatibility\ndo_test compat-open-1.1.8-database {\n  sqlite_orig db $sampleDir/sqlcipher-1.1.8-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_compatibility = 1;\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 75709}\ndb close\n\n# open a 2.0 database using cipher_compatibility\ndo_test compat-open-2.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-le-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_compatibility = 2;\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\ndb close\n\n# open a 3.0 database using cipher_compatibility\ndo_test compat-open-3.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-3.0-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_compatibility = 3;\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\ndb close\n\n# open a 4.0 database using cipher_compatibility\ndo_test compat-open-4.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-4.0-testkey.db\n  execsql {\n    PRAGMA key = 'testkey';\n    PRAGMA cipher_compatibility = 4;\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\ndb close\n\n# open a 1.1.8 database using cipher_default_compatibility\ndo_test default-compat-open-1.1.8-database {\n  sqlite_orig db $sampleDir/sqlcipher-1.1.8-testkey.db\n  execsql {\n    PRAGMA cipher_default_compatibility = 1;\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 75709}\ndb close\n\n# open a 2.0 database using cipher_default_compatibility\ndo_test default-compat-open-2.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-2.0-le-testkey.db\n  execsql {\n    PRAGMA cipher_default_compatibility = 2;\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\n\n# open a 3.0 database using cipher_default_compatibility\ndo_test default-compat-open-3.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-3.0-testkey.db\n  execsql {\n    PRAGMA cipher_default_compatibility = 3;\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\n\n# re-open a 4.0 database using cipher_default_compatibility\ndo_test default-compat-open-4.0-database {\n  sqlite_orig db $sampleDir/sqlcipher-4.0-testkey.db\n  execsql {\n    PRAGMA cipher_default_compatibility = 4;\n    PRAGMA key = 'testkey';\n    PRAGMA integrity_check;\n    SELECT count(*) FROM t1;\n  } \n} {ok ok 78536}\n\nsqlite3_test_control_pending_byte $old_pending_byte\n\nfinish_test\n"], "filenames": ["src/crypto.c", "test/sqlcipher-compatibility.test"], "buggy_code_start_loc": [1078, 446], "buggy_code_end_loc": [1085, 446], "fixing_code_start_loc": [1078, 447], "fixing_code_end_loc": [1101, 473], "type": "CWE-476", "message": "Zetetic SQLCipher 4.x before 4.4.3 has a NULL pointer dereferencing issue related to sqlcipher_export in crypto.c and sqlite3StrICmp in sqlite3.c. This may allow an attacker to perform a remote denial of service attack. For example, an SQL injection can be used to execute the crafted SQL command sequence, which causes a segmentation fault.", "other": {"cve": {"id": "CVE-2021-3119", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-25T23:15:13.257", "lastModified": "2022-05-03T16:04:40.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zetetic SQLCipher 4.x before 4.4.3 has a NULL pointer dereferencing issue related to sqlcipher_export in crypto.c and sqlite3StrICmp in sqlite3.c. This may allow an attacker to perform a remote denial of service attack. For example, an SQL injection can be used to execute the crafted SQL command sequence, which causes a segmentation fault."}, {"lang": "es", "value": "Zetetic SQLCipher versiones 4.x anteriores a 4.4.3, presenta un problema de desreferencia del puntero NULL relacionado con la funci\u00f3n sqlcipher_export en el archivo crypto.cy y sqlite3StrICmp en el archivo sqlite3.c.&#xa0;Esto puede permitir a un atacante llevar a cabo un ataque de denegaci\u00f3n de servicio remota.&#xa0;Por ejemplo, puede ser usada una inyecci\u00f3n SQL para ejecutar el script SQL dise\u00f1ado, causando un fallo de segmentaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zetetic:sqlcipher:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.4.3", "matchCriteriaId": "8ED7FB70-ED8A-4FF4-B73A-58F495E1D82D"}]}]}], "references": [{"url": "https://github.com/sqlcipher/sqlcipher/commit/cb71f53e8cea4802509f182fa5bead0ac6ab0e7f#diff-9305215a9a0ea69300281fc4af90bc7f3437e34a0e1745d030213152993ddae4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.telekom.com/resource/blob/621186/3fb50ca7a4a97728be18717ed7b0062c/dl-210308-critical-dos-vulnerability-in-sqlcipher-sql-command-processing-data.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/sqlcipher/sqlcipher/commit/cb71f53e8cea4802509f182fa5bead0ac6ab0e7f#diff-9305215a9a0ea69300281fc4af90bc7f3437e34a0e1745d030213152993ddae4"}}