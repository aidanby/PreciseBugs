{"buggy_code": ["/*\t$OpenBSD: smtpd.h,v 1.670 2021/07/28 19:39:51 benno Exp $\t*/\n\n/*\n * Copyright (c) 2008 Gilles Chehade <gilles@poolp.org>\n * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@openbsd.org>\n * Copyright (c) 2012 Eric Faurot <eric@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <event.h>\n\n#include\t\t\t <imsg.h>\n\n#include\t\t\t \"openbsd-compat.h\"\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/socket.h>\n\n#include <event.h>\n#include <imsg.h>\n#include <limits.h>\n#include <netdb.h>\n#include <stdio.h>\n\n#include \"smtpd-defines.h\"\n#include \"smtpd-api.h\"\n#include \"ioev.h\"\n\n#define CHECK_IMSG_DATA_SIZE(imsg, expected_sz) do {\t\t\t\\\n\tif ((imsg)->hdr.len - IMSG_HEADER_SIZE != (expected_sz))\t\\\n\t\tfatalx(\"smtpd: imsg %d: data size expected %zd got %zd\",\\\n\t   \t    (imsg)->hdr.type,\t\t\t\t\t\\\n\t   \t    (expected_sz), (imsg)->hdr.len - IMSG_HEADER_SIZE);\t\\\n} while (0)\n\n#ifndef SMTPD_CONFDIR\n#define SMTPD_CONFDIR\t\t \"/etc\"\n#endif\n#define CONF_FILE\t\t SMTPD_CONFDIR \"/smtpd.conf\"\n#define MAILNAME_FILE\t\t SMTPD_CONFDIR \"/mailname\"\n#ifndef CA_FILE\n#define CA_FILE                  \"/etc/ssl/cert.pem\"\n#endif\n\n#define PROC_COUNT\t\t 7\n\n#define MAX_HOPS_COUNT\t\t 100\n#define\tDEFAULT_MAX_BODY_SIZE\t(35*1024*1024)\n\n#define\tEXPAND_BUFFER\t\t 1024\n\n#define SMTPD_QUEUE_EXPIRY\t (4 * 24 * 60 * 60)\n#ifndef SMTPD_USER\n#define SMTPD_USER\t\t \"_smtpd\"\n#endif\n#ifndef SMTPD_QUEUE_USER\n#define SMTPD_QUEUE_USER\t \"_smtpq\"\n#endif\n#ifndef SMTPD_SOCKDIR\n#define SMTPD_SOCKDIR\t\t \"/var/run\"\n#endif\n#define SMTPD_SOCKET\t\t SMTPD_SOCKDIR \"/smtpd.sock\"\n#ifndef SMTPD_NAME\n#define\tSMTPD_NAME\t\t \"OpenSMTPD\"\n#endif\n#define\tSMTPD_VERSION\t\t \"6.9.0-portable\"\n#define SMTPD_SESSION_TIMEOUT\t 300\n#define SMTPD_BACKLOG\t\t 5\n\n#ifndef PATH_SMTPCTL\n#define\tPATH_SMTPCTL\t\t\"/usr/sbin/smtpctl\"\n#endif\n\n#define PATH_OFFLINE\t\t\"/offline\"\n#define PATH_PURGE\t\t\"/purge\"\n#define PATH_TEMPORARY\t\t\"/temporary\"\n\n#ifndef\tPATH_LIBEXEC\n#define\tPATH_LIBEXEC\t\t\"/usr/local/libexec/smtpd\"\n#endif\n\n\n/*\n * RFC 5322 defines these characters as valid, some of them are\n * potentially dangerous and need to be escaped.\n */\n#define\tMAILADDR_ALLOWED       \t\"!#$%&'*/?^`{|}~+-=_\"\n#define\tMAILADDR_ESCAPE\t\t\"!#$%&'*?`{|}~\"\n\n\n#define F_STARTTLS\t\t0x01\n#define F_SMTPS\t\t\t0x02\n#define F_SSL\t\t       (F_STARTTLS | F_SMTPS)\n#define F_AUTH\t\t\t0x08\n#define\tF_STARTTLS_REQUIRE\t0x20\n#define\tF_AUTH_REQUIRE\t\t0x40\n#define\tF_MASK_SOURCE\t\t0x100\n#define\tF_TLS_VERIFY\t\t0x200\n#define\tF_EXT_DSN\t\t0x400\n#define\tF_RECEIVEDAUTH\t\t0x800\n#define\tF_MASQUERADE\t\t0x1000\n#define\tF_FILTERED\t\t0x2000\n#define\tF_PROXY\t\t\t0x4000\n\n#define RELAY_TLS_OPPORTUNISTIC\t0\n#define RELAY_TLS_STARTTLS\t1\n#define RELAY_TLS_SMTPS\t\t2\n#define RELAY_TLS_NO\t\t3\n\n#define RELAY_AUTH\t\t0x08\n#define RELAY_LMTP\t\t0x80\n#define\tRELAY_TLS_VERIFY\t0x200\n\n#define MTA_EXT_DSN\t\t0x400\n\n\n#define P_SENDMAIL\t0\n#define P_NEWALIASES\t1\n#define P_MAKEMAP\t2\n\nstruct userinfo {\n\tchar username[SMTPD_VUSERNAME_SIZE];\n\tchar directory[PATH_MAX];\n\tuid_t uid;\n\tgid_t gid;\n};\n\nstruct netaddr {\n\tstruct sockaddr_storage ss;\n\tint bits;\n};\n\nstruct relayhost {\n\tuint16_t flags;\n\tint tls;\n\tchar hostname[HOST_NAME_MAX+1];\n\tuint16_t port;\n\tchar authlabel[PATH_MAX];\n};\n\nstruct credentials {\n\tchar username[LINE_MAX];\n\tchar password[LINE_MAX];\n};\n\nstruct destination {\n\tchar\tname[HOST_NAME_MAX+1];\n};\n\nstruct source {\n\tstruct sockaddr_storage\taddr;\n};\n\nstruct addrname {\n\tstruct sockaddr_storage\taddr;\n\tchar\t\t\tname[HOST_NAME_MAX+1];\n};\n\nunion lookup {\n\tstruct expand\t\t*expand;\n\tstruct credentials\t creds;\n\tstruct netaddr\t\t netaddr;\n\tstruct source\t\t source;\n\tstruct destination\t domain;\n\tstruct userinfo\t\t userinfo;\n\tstruct mailaddr\t\t mailaddr;\n\tstruct addrname\t\t addrname;\n\tstruct maddrmap\t\t*maddrmap;\n\tchar\t\t\t relayhost[LINE_MAX];\n};\n\n/*\n * Bump IMSG_VERSION whenever a change is made to enum imsg_type.\n * This will ensure that we can never use a wrong version of smtpctl with smtpd.\n */\n#define\tIMSG_VERSION\t\t16\n\nenum imsg_type {\n\tIMSG_NONE,\n\n\tIMSG_CTL_OK,\n\tIMSG_CTL_FAIL,\n\n\tIMSG_CTL_GET_DIGEST,\n\tIMSG_CTL_GET_STATS,\n\tIMSG_CTL_LIST_MESSAGES,\n\tIMSG_CTL_LIST_ENVELOPES,\n\tIMSG_CTL_MTA_SHOW_HOSTS,\n\tIMSG_CTL_MTA_SHOW_RELAYS,\n\tIMSG_CTL_MTA_SHOW_ROUTES,\n\tIMSG_CTL_MTA_SHOW_HOSTSTATS,\n\tIMSG_CTL_MTA_BLOCK,\n\tIMSG_CTL_MTA_UNBLOCK,\n\tIMSG_CTL_MTA_SHOW_BLOCK,\n\tIMSG_CTL_PAUSE_EVP,\n\tIMSG_CTL_PAUSE_MDA,\n\tIMSG_CTL_PAUSE_MTA,\n\tIMSG_CTL_PAUSE_SMTP,\n\tIMSG_CTL_PROFILE,\n\tIMSG_CTL_PROFILE_DISABLE,\n\tIMSG_CTL_PROFILE_ENABLE,\n\tIMSG_CTL_RESUME_EVP,\n\tIMSG_CTL_RESUME_MDA,\n\tIMSG_CTL_RESUME_MTA,\n\tIMSG_CTL_RESUME_SMTP,\n\tIMSG_CTL_RESUME_ROUTE,\n\tIMSG_CTL_REMOVE,\n\tIMSG_CTL_SCHEDULE,\n\tIMSG_CTL_SHOW_STATUS,\n\tIMSG_CTL_TRACE_DISABLE,\n\tIMSG_CTL_TRACE_ENABLE,\n\tIMSG_CTL_UPDATE_TABLE,\n\tIMSG_CTL_VERBOSE,\n\tIMSG_CTL_DISCOVER_EVPID,\n\tIMSG_CTL_DISCOVER_MSGID,\n\n\tIMSG_CTL_SMTP_SESSION,\n\n\tIMSG_GETADDRINFO,\n\tIMSG_GETADDRINFO_END,\n\tIMSG_GETNAMEINFO,\n\tIMSG_RES_QUERY,\n\n\tIMSG_SETUP_KEY,\n\tIMSG_SETUP_PEER,\n\tIMSG_SETUP_DONE,\n\n\tIMSG_CONF_START,\n\tIMSG_CONF_END,\n\n\tIMSG_STAT_INCREMENT,\n\tIMSG_STAT_DECREMENT,\n\tIMSG_STAT_SET,\n\n\tIMSG_LKA_AUTHENTICATE,\n\tIMSG_LKA_OPEN_FORWARD,\n\tIMSG_LKA_ENVELOPE_SUBMIT,\n\tIMSG_LKA_ENVELOPE_COMMIT,\n\n\tIMSG_QUEUE_DELIVER,\n\tIMSG_QUEUE_DELIVERY_OK,\n\tIMSG_QUEUE_DELIVERY_TEMPFAIL,\n\tIMSG_QUEUE_DELIVERY_PERMFAIL,\n\tIMSG_QUEUE_DELIVERY_LOOP,\n\tIMSG_QUEUE_DISCOVER_EVPID,\n\tIMSG_QUEUE_DISCOVER_MSGID,\n\tIMSG_QUEUE_ENVELOPE_ACK,\n\tIMSG_QUEUE_ENVELOPE_COMMIT,\n\tIMSG_QUEUE_ENVELOPE_REMOVE,\n\tIMSG_QUEUE_ENVELOPE_SCHEDULE,\n\tIMSG_QUEUE_ENVELOPE_SUBMIT,\n\tIMSG_QUEUE_HOLDQ_HOLD,\n\tIMSG_QUEUE_HOLDQ_RELEASE,\n\tIMSG_QUEUE_MESSAGE_COMMIT,\n\tIMSG_QUEUE_MESSAGE_ROLLBACK,\n\tIMSG_QUEUE_SMTP_SESSION,\n\tIMSG_QUEUE_TRANSFER,\n\n\tIMSG_MDA_DELIVERY_OK,\n\tIMSG_MDA_DELIVERY_TEMPFAIL,\n\tIMSG_MDA_DELIVERY_PERMFAIL,\n\tIMSG_MDA_DELIVERY_LOOP,\n\tIMSG_MDA_DELIVERY_HOLD,\n\tIMSG_MDA_DONE,\n\tIMSG_MDA_FORK,\n\tIMSG_MDA_HOLDQ_RELEASE,\n\tIMSG_MDA_LOOKUP_USERINFO,\n\tIMSG_MDA_KILL,\n\tIMSG_MDA_OPEN_MESSAGE,\n\n\tIMSG_MTA_DELIVERY_OK,\n\tIMSG_MTA_DELIVERY_TEMPFAIL,\n\tIMSG_MTA_DELIVERY_PERMFAIL,\n\tIMSG_MTA_DELIVERY_LOOP,\n\tIMSG_MTA_DELIVERY_HOLD,\n\tIMSG_MTA_DNS_HOST,\n\tIMSG_MTA_DNS_HOST_END,\n\tIMSG_MTA_DNS_MX,\n\tIMSG_MTA_DNS_MX_PREFERENCE,\n\tIMSG_MTA_HOLDQ_RELEASE,\n\tIMSG_MTA_LOOKUP_CREDENTIALS,\n\tIMSG_MTA_LOOKUP_SOURCE,\n\tIMSG_MTA_LOOKUP_HELO,\n\tIMSG_MTA_LOOKUP_SMARTHOST,\n\tIMSG_MTA_OPEN_MESSAGE,\n\tIMSG_MTA_SCHEDULE,\n\n\tIMSG_SCHED_ENVELOPE_BOUNCE,\n\tIMSG_SCHED_ENVELOPE_DELIVER,\n\tIMSG_SCHED_ENVELOPE_EXPIRE,\n\tIMSG_SCHED_ENVELOPE_INJECT,\n\tIMSG_SCHED_ENVELOPE_REMOVE,\n\tIMSG_SCHED_ENVELOPE_TRANSFER,\n\n\tIMSG_SMTP_AUTHENTICATE,\n\tIMSG_SMTP_MESSAGE_COMMIT,\n\tIMSG_SMTP_MESSAGE_CREATE,\n\tIMSG_SMTP_MESSAGE_ROLLBACK,\n\tIMSG_SMTP_MESSAGE_OPEN,\n\tIMSG_SMTP_CHECK_SENDER,\n\tIMSG_SMTP_EXPAND_RCPT,\n\tIMSG_SMTP_LOOKUP_HELO,\n\n\tIMSG_SMTP_REQ_CONNECT,\n\tIMSG_SMTP_REQ_HELO,\n\tIMSG_SMTP_REQ_MAIL,\n\tIMSG_SMTP_REQ_RCPT,\n\tIMSG_SMTP_REQ_DATA,\n\tIMSG_SMTP_REQ_EOM,\n\tIMSG_SMTP_EVENT_RSET,\n\tIMSG_SMTP_EVENT_COMMIT,\n\tIMSG_SMTP_EVENT_ROLLBACK,\n\tIMSG_SMTP_EVENT_DISCONNECT,\n\n\tIMSG_LKA_PROCESSOR_FORK,\n\tIMSG_LKA_PROCESSOR_ERRFD,\n\n\tIMSG_REPORT_SMTP_LINK_CONNECT,\n\tIMSG_REPORT_SMTP_LINK_DISCONNECT,\n\tIMSG_REPORT_SMTP_LINK_GREETING,\n\tIMSG_REPORT_SMTP_LINK_IDENTIFY,\n\tIMSG_REPORT_SMTP_LINK_TLS,\n\tIMSG_REPORT_SMTP_LINK_AUTH,\n\tIMSG_REPORT_SMTP_TX_RESET,\n\tIMSG_REPORT_SMTP_TX_BEGIN,\n\tIMSG_REPORT_SMTP_TX_MAIL,\n\tIMSG_REPORT_SMTP_TX_RCPT,\n\tIMSG_REPORT_SMTP_TX_ENVELOPE,\n\tIMSG_REPORT_SMTP_TX_DATA,\n\tIMSG_REPORT_SMTP_TX_COMMIT,\n\tIMSG_REPORT_SMTP_TX_ROLLBACK,\n\tIMSG_REPORT_SMTP_PROTOCOL_CLIENT,\n\tIMSG_REPORT_SMTP_PROTOCOL_SERVER,\n\tIMSG_REPORT_SMTP_FILTER_RESPONSE,\n\tIMSG_REPORT_SMTP_TIMEOUT,\n\n\tIMSG_FILTER_SMTP_BEGIN,\n\tIMSG_FILTER_SMTP_END,\n\tIMSG_FILTER_SMTP_PROTOCOL,\n\tIMSG_FILTER_SMTP_DATA_BEGIN,\n\tIMSG_FILTER_SMTP_DATA_END,\n\n\tIMSG_CA_RSA_PRIVENC,\n\tIMSG_CA_RSA_PRIVDEC,\n\tIMSG_CA_ECDSA_SIGN,\n};\n\nenum smtp_proc_type {\n\tPROC_PARENT = 0,\n\tPROC_LKA,\n\tPROC_QUEUE,\n\tPROC_CONTROL,\n\tPROC_SCHEDULER,\n\tPROC_DISPATCHER,\n\tPROC_CA,\n\tPROC_PROCESSOR,\n\tPROC_CLIENT,\n};\n\nenum table_type {\n\tT_NONE\t\t= 0,\n\tT_DYNAMIC\t= 0x01,\t/* table with external source\t*/\n\tT_LIST\t\t= 0x02,\t/* table holding a list\t\t*/\n\tT_HASH\t\t= 0x04,\t/* table holding a hash table\t*/\n};\n\nstruct table {\n\tchar\t\t\t\t t_name[LINE_MAX];\n\tenum table_type\t\t\t t_type;\n\tchar\t\t\t\t t_config[PATH_MAX];\n\n\tvoid\t\t\t\t*t_handle;\n\tstruct table_backend\t\t*t_backend;\n};\n\nstruct table_backend {\n\tconst char *name;\n\tconst unsigned int\tservices;\n\tint\t(*config)(struct table *);\n\tint\t(*add)(struct table *, const char *, const char *);\n\tvoid\t(*dump)(struct table *);\n\tint\t(*open)(struct table *);\n\tint\t(*update)(struct table *);\n\tvoid\t(*close)(struct table *);\n\tint\t(*lookup)(struct table *, enum table_service, const char *, char **);\n\tint\t(*fetch)(struct table *, enum table_service, char **);\n};\n\n\nenum bounce_type {\n\tB_FAILED,\n\tB_DELAYED,\n\tB_DELIVERED\n};\n\nenum dsn_ret {\n\tDSN_RETFULL = 1,\n\tDSN_RETHDRS\n};\n\nstruct delivery_bounce {\n\tenum bounce_type\ttype;\n\ttime_t\t\t\tdelay;\n\ttime_t\t\t\tttl;\n\tenum dsn_ret\t\tdsn_ret;\n        int\t\t\tmta_without_dsn;\n};\n\nenum expand_type {\n\tEXPAND_INVALID,\n\tEXPAND_USERNAME,\n\tEXPAND_FILENAME,\n\tEXPAND_FILTER,\n\tEXPAND_INCLUDE,\n\tEXPAND_ADDRESS,\n\tEXPAND_ERROR,\n};\n\nenum filter_phase {\n\tFILTER_CONNECT,\n\tFILTER_HELO,\n\tFILTER_EHLO,\n\tFILTER_STARTTLS,\n\tFILTER_AUTH,\n\tFILTER_MAIL_FROM,\n\tFILTER_RCPT_TO,\n\tFILTER_DATA,\n\tFILTER_DATA_LINE,\n\tFILTER_RSET,\n\tFILTER_QUIT,\n\tFILTER_NOOP,\n\tFILTER_HELP,\n\tFILTER_WIZ,\n\tFILTER_COMMIT,\n\tFILTER_PHASES_COUNT     /* must be last */\n};\n\nstruct expandnode {\n\tRB_ENTRY(expandnode)\tentry;\n\tTAILQ_ENTRY(expandnode)\ttq_entry;\n\tenum expand_type\ttype;\n\tint\t\t\tsameuser;\n\tint\t\t\trealuser;\n\tint\t\t\tforwarded;\n\tstruct rule\t       *rule;\n\tstruct expandnode      *parent;\n\tunsigned int\t\tdepth;\n\tunion {\n\t\t/*\n\t\t * user field handles both expansion user and system user\n\t\t * so we MUST make it large enough to fit a mailaddr user\n\t\t */\n\t\tchar\t\tuser[SMTPD_MAXLOCALPARTSIZE];\n\t\tchar\t\tbuffer[EXPAND_BUFFER];\n\t\tstruct mailaddr\tmailaddr;\n\t}\t\t\tu;\n\tchar\t\tsubaddress[SMTPD_SUBADDRESS_SIZE];\n};\n\nstruct expand {\n\tRB_HEAD(expandtree, expandnode)\t tree;\n\tTAILQ_HEAD(xnodes, expandnode)\t*queue;\n\tsize_t\t\t\t\t nb_nodes;\n\tstruct rule\t\t\t*rule;\n\tstruct expandnode\t\t*parent;\n};\n\nstruct maddrnode {\n\tTAILQ_ENTRY(maddrnode)\t\tentries;\n\tstruct mailaddr\t\t\tmailaddr;\n};\n\nstruct maddrmap {\n\tTAILQ_HEAD(xmaddr, maddrnode)\tqueue;\n};\n\n#define DSN_SUCCESS 0x01\n#define DSN_FAILURE 0x02\n#define DSN_DELAY   0x04\n#define DSN_NEVER   0x08\n\n#define\tDSN_ENVID_LEN\t100\n\n#define\tSMTPD_ENVELOPE_VERSION\t\t3\nstruct envelope {\n\tTAILQ_ENTRY(envelope)\t\tentry;\n\n\tchar\t\t\t\tdispatcher[HOST_NAME_MAX+1];\n\n\tchar\t\t\t\ttag[SMTPD_TAG_SIZE];\n\n\tuint32_t\t\t\tversion;\n\tuint64_t\t\t\tid;\n\tenum envelope_flags\t\tflags;\n\n\tchar\t\t\t\tsmtpname[HOST_NAME_MAX+1];\n\tchar\t\t\t\thelo[HOST_NAME_MAX+1];\n\tchar\t\t\t\thostname[HOST_NAME_MAX+1];\n\tchar\t\t\t\tusername[SMTPD_MAXMAILADDRSIZE];\n\tchar\t\t\t\terrorline[LINE_MAX];\n\tstruct sockaddr_storage\t\tss;\n\n\tstruct mailaddr\t\t\tsender;\n\tstruct mailaddr\t\t\trcpt;\n\tstruct mailaddr\t\t\tdest;\n\n\tchar\t\t\t\tmda_user[SMTPD_VUSERNAME_SIZE];\n\tchar\t\t\t\tmda_subaddress[SMTPD_SUBADDRESS_SIZE];\n\tchar\t\t\t\tmda_exec[LINE_MAX];\n\n\tenum delivery_type\t\ttype;\n\tunion {\n\t\tstruct delivery_bounce\tbounce;\n\t}\t\t\t\tagent;\n\n\tuint16_t\t\t\tretry;\n\ttime_t\t\t\t\tcreation;\n\ttime_t\t\t\t\tttl;\n\ttime_t\t\t\t\tlasttry;\n\ttime_t\t\t\t\tnexttry;\n\ttime_t\t\t\t\tlastbounce;\n\n\tstruct mailaddr\t\t\tdsn_orcpt;\n\tchar\t\t\t\tdsn_envid[DSN_ENVID_LEN+1];\n\tuint8_t\t\t\t\tdsn_notify;\n\tenum dsn_ret\t\t\tdsn_ret;\n\n\tuint8_t\t\t\t\tesc_class;\n\tuint8_t\t\t\t\tesc_code;\n};\n\nstruct listener {\n\tuint16_t       \t\t flags;\n\tint\t\t\t fd;\n\tstruct sockaddr_storage\t ss;\n\tin_port_t\t\t port;\n\tstruct timeval\t\t timeout;\n\tstruct event\t\t ev;\n\tchar\t\t\t filter_name[PATH_MAX];\n\tchar\t\t\t pki_name[PATH_MAX];\n\tchar\t\t\t ca_name[PATH_MAX];\n\tchar\t\t\t tag[SMTPD_TAG_SIZE];\n\tchar\t\t\t authtable[LINE_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tchar\t\t\t hostnametable[PATH_MAX];\n\tchar\t\t\t sendertable[PATH_MAX];\n\n\tTAILQ_ENTRY(listener)\t entry;\n\n\tint\t\t\t local;\t\t/* there must be a better way */\n\n\tchar\t\t\t*tls_protocols;\n\tchar\t\t\t*tls_ciphers;\n\tstruct tls\t\t*tls;\n\tstruct pki\t\t**pki;\n\tint\t\t\t pkicount;\n};\n\nstruct smtpd {\n\tchar\t\t\t\tsc_conffile[PATH_MAX];\n\tsize_t\t\t\t\tsc_maxsize;\n\n#define SMTPD_OPT_VERBOSE\t\t0x00000001\n#define SMTPD_OPT_NOACTION\t\t0x00000002\n\tuint32_t\t\t\tsc_opts;\n\n#define SMTPD_EXITING\t\t\t0x00000001 /* unused */\n#define SMTPD_MDA_PAUSED\t\t0x00000002\n#define SMTPD_MTA_PAUSED\t\t0x00000004\n#define SMTPD_SMTP_PAUSED\t\t0x00000008\n#define SMTPD_MDA_BUSY\t\t\t0x00000010\n#define SMTPD_MTA_BUSY\t\t\t0x00000020\n#define SMTPD_BOUNCE_BUSY\t\t0x00000040\n#define SMTPD_SMTP_DISABLED\t\t0x00000080\n\tuint32_t\t\t\tsc_flags;\n\n#define QUEUE_COMPRESSION      \t\t0x00000001\n#define QUEUE_ENCRYPTION      \t\t0x00000002\n#define QUEUE_EVPCACHE\t\t\t0x00000004\n\tuint32_t\t\t\tsc_queue_flags;\n\tchar\t\t\t       *sc_queue_key;\n\tsize_t\t\t\t\tsc_queue_evpcache_size;\n\n\tsize_t\t\t\t\tsc_session_max_rcpt;\n\tsize_t\t\t\t\tsc_session_max_mails;\n\n\tstruct dict\t\t       *sc_mda_wrappers;\n\tsize_t\t\t\t\tsc_mda_max_session;\n\tsize_t\t\t\t\tsc_mda_max_user_session;\n\tsize_t\t\t\t\tsc_mda_task_hiwat;\n\tsize_t\t\t\t\tsc_mda_task_lowat;\n\tsize_t\t\t\t\tsc_mda_task_release;\n\n\tsize_t\t\t\t\tsc_mta_max_deferred;\n\n\tsize_t\t\t\t\tsc_scheduler_max_inflight;\n\tsize_t\t\t\t\tsc_scheduler_max_evp_batch_size;\n\tsize_t\t\t\t\tsc_scheduler_max_msg_batch_size;\n\tsize_t\t\t\t\tsc_scheduler_max_schedule;\n\n\tstruct dict\t\t       *sc_filter_processes_dict;\n\n\tint\t\t\t\tsc_ttl;\n#define MAX_BOUNCE_WARN\t\t\t4\n\ttime_t\t\t\t\tsc_bounce_warn[MAX_BOUNCE_WARN];\n\tchar\t\t\t\tsc_hostname[HOST_NAME_MAX+1];\n\tstruct stat_backend\t       *sc_stat;\n\tstruct compress_backend\t       *sc_comp;\n\n\ttime_t\t\t\t\t\t sc_uptime;\n\n\t/* This is a listener for a local socket used by smtp_enqueue(). */\n\tstruct listener                         *sc_sock_listener;\n\n\tTAILQ_HEAD(listenerlist, listener)\t*sc_listeners;\n\n\tTAILQ_HEAD(rulelist, rule)\t\t*sc_rules;\n\n\n\tstruct dict\t\t\t\t*sc_filters_dict;\n\tstruct dict\t\t\t\t*sc_dispatchers;\n\tstruct dispatcher\t\t\t*sc_dispatcher_bounce;\n\n\tstruct dict\t\t\t       *sc_ca_dict;\n\tstruct dict\t\t\t       *sc_pki_dict;\n\tstruct dict\t\t\t       *sc_ssl_dict;\n\n\tstruct dict\t\t\t       *sc_tables_dict;\t\t/* keyed lookup\t*/\n\n\tstruct dict\t\t\t       *sc_limits_dict;\n\n\tchar\t\t\t\t       *sc_tls_ciphers;\n\n\tchar\t\t\t\t       *sc_subaddressing_delim;\n\n\tchar\t\t\t\t       *sc_srs_key;\n\tchar\t\t\t\t       *sc_srs_key_backup;\n\tint\t\t\t\t        sc_srs_ttl;\n\n\tchar\t\t\t\t       *sc_admd;\n};\n\n#define\tTRACE_DEBUG\t0x0001\n#define\tTRACE_IMSG\t0x0002\n#define\tTRACE_IO\t0x0004\n#define\tTRACE_SMTP\t0x0008\n#define\tTRACE_FILTERS\t0x0010\n#define\tTRACE_MTA\t0x0020\n#define\tTRACE_BOUNCE\t0x0040\n#define\tTRACE_SCHEDULER\t0x0080\n#define\tTRACE_LOOKUP\t0x0100\n#define\tTRACE_STAT\t0x0200\n#define\tTRACE_RULES\t0x0400\n#define\tTRACE_MPROC\t0x0800\n#define\tTRACE_EXPAND\t0x1000\n#define\tTRACE_TABLES\t0x2000\n#define\tTRACE_QUEUE\t0x4000\n\n#define PROFILE_TOSTAT\t0x0001\n#define PROFILE_IMSG\t0x0002\n#define PROFILE_QUEUE\t0x0004\n\nstruct forward_req {\n\tuint64_t\t\t\tid;\n\tuint8_t\t\t\t\tstatus;\n\n\tchar\t\t\t\tuser[SMTPD_VUSERNAME_SIZE];\n\tuid_t\t\t\t\tuid;\n\tgid_t\t\t\t\tgid;\n\tchar\t\t\t\tdirectory[PATH_MAX];\n};\n\nstruct deliver {\n\tchar\t\t\tdispatcher[EXPAND_BUFFER];\n\n\tstruct mailaddr\t\tsender;\n\tstruct mailaddr\t\trcpt;\n\tstruct mailaddr\t\tdest;\n\n\tchar\t\t\tmda_subaddress[SMTPD_SUBADDRESS_SIZE];\n\tchar\t\t\tmda_exec[LINE_MAX];\n\n\tstruct userinfo\t\tuserinfo;\n};\n\nstruct mta_host {\n\tSPLAY_ENTRY(mta_host)\t entry;\n\tstruct sockaddr\t\t*sa;\n\tchar\t\t\t*ptrname;\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\ttime_t\t\t\t lastconn;\n\ttime_t\t\t\t lastptrquery;\n\n#define HOST_IGNORE\t0x01\n\tint\t\t\t flags;\n};\n\nstruct mta_mx {\n\tTAILQ_ENTRY(mta_mx)\t entry;\n\tstruct mta_host\t\t*host;\n\tchar\t\t\t*mxname;\n\tint\t\t\t preference;\n};\n\nstruct mta_domain {\n\tSPLAY_ENTRY(mta_domain)\t entry;\n\tchar\t\t\t*name;\n\tint\t\t\t as_host;\n\tTAILQ_HEAD(, mta_mx)\t mxs;\n\tint\t\t\t mxstatus;\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\ttime_t\t\t\t lastconn;\n\ttime_t\t\t\t lastmxquery;\n};\n\nstruct mta_source {\n\tSPLAY_ENTRY(mta_source)\t entry;\n\tstruct sockaddr\t\t*sa;\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\ttime_t\t\t\t lastconn;\n};\n\nstruct mta_connector {\n\tstruct mta_source\t\t*source;\n\tstruct mta_relay\t\t*relay;\n\n#define CONNECTOR_ERROR_FAMILY\t\t0x0001\n#define CONNECTOR_ERROR_SOURCE\t\t0x0002\n#define CONNECTOR_ERROR_MX\t\t0x0004\n#define CONNECTOR_ERROR_ROUTE_NET\t0x0008\n#define CONNECTOR_ERROR_ROUTE_SMTP\t0x0010\n#define CONNECTOR_ERROR_ROUTE\t\t0x0018\n#define CONNECTOR_ERROR_BLOCKED\t\t0x0020\n#define CONNECTOR_ERROR\t\t\t0x00ff\n\n#define CONNECTOR_LIMIT_HOST\t\t0x0100\n#define CONNECTOR_LIMIT_ROUTE\t\t0x0200\n#define CONNECTOR_LIMIT_SOURCE\t\t0x0400\n#define CONNECTOR_LIMIT_RELAY\t\t0x0800\n#define CONNECTOR_LIMIT_CONN\t\t0x1000\n#define CONNECTOR_LIMIT_DOMAIN\t\t0x2000\n#define CONNECTOR_LIMIT\t\t\t0xff00\n\n#define CONNECTOR_NEW\t\t\t0x10000\n#define CONNECTOR_WAIT\t\t\t0x20000\n\tint\t\t\t\t flags;\n\n\tint\t\t\t\t refcount;\n\tsize_t\t\t\t\t nconn;\n\ttime_t\t\t\t\t lastconn;\n};\n\nstruct mta_route {\n\tSPLAY_ENTRY(mta_route)\t entry;\n\tuint64_t\t\t id;\n\tstruct mta_source\t*src;\n\tstruct mta_host\t\t*dst;\n#define ROUTE_NEW\t\t0x01\n#define ROUTE_RUNQ\t\t0x02\n#define ROUTE_KEEPALIVE\t\t0x04\n#define ROUTE_DISABLED\t\t0xf0\n#define ROUTE_DISABLED_NET\t0x10\n#define ROUTE_DISABLED_SMTP\t0x20\n\tint\t\t\t flags;\n\tint\t\t\t nerror;\n\tint\t\t\t penalty;\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\ttime_t\t\t\t lastconn;\n\ttime_t\t\t\t lastdisc;\n\ttime_t\t\t\t lastpenalty;\n};\n\nstruct mta_limits {\n\tsize_t\tmaxconn_per_host;\n\tsize_t\tmaxconn_per_route;\n\tsize_t\tmaxconn_per_source;\n\tsize_t\tmaxconn_per_connector;\n\tsize_t\tmaxconn_per_relay;\n\tsize_t\tmaxconn_per_domain;\n\n\ttime_t\tconndelay_host;\n\ttime_t\tconndelay_route;\n\ttime_t\tconndelay_source;\n\ttime_t\tconndelay_connector;\n\ttime_t\tconndelay_relay;\n\ttime_t\tconndelay_domain;\n\n\ttime_t\tdiscdelay_route;\n\n\tsize_t\tmax_mail_per_session;\n\ttime_t\tsessdelay_transaction;\n\ttime_t\tsessdelay_keepalive;\n\n\tsize_t\tmax_failures_per_session;\n\n\tint\tfamily;\n\n\tint\ttask_hiwat;\n\tint\ttask_lowat;\n\tint\ttask_release;\n};\n\nstruct mta_relay {\n\tSPLAY_ENTRY(mta_relay)\t entry;\n\tuint64_t\t\t id;\n\n\tstruct dispatcher\t*dispatcher;\n\tstruct mta_domain\t*domain;\n\tstruct mta_limits\t*limits;\n\tint\t\t\t tls;\n\tint\t\t\t flags;\n\tchar\t\t\t*backupname;\n\tint\t\t\t backuppref;\n\tchar\t\t\t*sourcetable;\n\tuint16_t\t\t port;\n\tchar\t\t\t*pki_name;\n\tchar\t\t\t*ca_name;\n\tchar\t\t\t*authtable;\n\tchar\t\t\t*authlabel;\n\tchar\t\t\t*helotable;\n\tchar\t\t\t*heloname;\n\tchar\t\t\t*secret;\n\tint\t\t\t srs;\n\n\tint\t\t\t state;\n\tsize_t\t\t\t ntask;\n\tTAILQ_HEAD(, mta_task)\t tasks;\n\n\tstruct tree\t\t connectors;\n\tsize_t\t\t\t sourceloop;\n\ttime_t\t\t\t lastsource;\n\ttime_t\t\t\t nextsource;\n\n\tint\t\t\t fail;\n\tchar\t\t\t*failstr;\n\n#define RELAY_WAIT_MX\t\t0x01\n#define RELAY_WAIT_PREFERENCE\t0x02\n#define RELAY_WAIT_SECRET\t0x04\n#define RELAY_WAIT_LIMITS\t0x08\n#define RELAY_WAIT_SOURCE\t0x10\n#define RELAY_WAIT_CONNECTOR\t0x20\n#define RELAY_WAIT_SMARTHOST\t0x40\n#define RELAY_WAITMASK\t\t0x7f\n\tint\t\t\t status;\n\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\tsize_t\t\t\t nconn_ready;\n\ttime_t\t\t\t lastconn;\n};\n\nstruct mta_envelope {\n\tTAILQ_ENTRY(mta_envelope)\t entry;\n\tuint64_t\t\t\t id;\n\tuint64_t\t\t\t session;\n\ttime_t\t\t\t\t creation;\n\tchar\t\t\t\t*smtpname;\n\tchar\t\t\t\t*dest;\n\tchar\t\t\t\t*rcpt;\n\tstruct mta_task\t\t\t*task;\n\tint\t\t\t\t delivery;\n\n\tint\t\t\t\t ext;\n\tchar\t\t\t\t*dsn_orcpt;\n\tchar\t\t\t\tdsn_envid[DSN_ENVID_LEN+1];\n\tuint8_t\t\t\t\tdsn_notify;\n\tenum dsn_ret\t\t\tdsn_ret;\n\n\tchar\t\t\t\t status[LINE_MAX];\n};\n\nstruct mta_task {\n\tTAILQ_ENTRY(mta_task)\t\t entry;\n\tstruct mta_relay\t\t*relay;\n\tuint32_t\t\t\t msgid;\n\tTAILQ_HEAD(, mta_envelope)\t envelopes;\n\tchar\t\t\t\t*sender;\n};\n\nstruct passwd;\n\nstruct queue_backend {\n\tint\t(*init)(struct passwd *, int, const char *);\n};\n\nstruct compress_backend {\n\tsize_t\t(*compress_chunk)(void *, size_t, void *, size_t);\n\tsize_t\t(*uncompress_chunk)(void *, size_t, void *, size_t);\n\tint\t(*compress_file)(FILE *, FILE *);\n\tint\t(*uncompress_file)(FILE *, FILE *);\n};\n\n/* auth structures */\nenum auth_type {\n\tAUTH_BSD,\n\tAUTH_PWD,\n};\n\nstruct auth_backend {\n\tint\t(*authenticate)(char *, char *);\n};\n\nstruct scheduler_backend {\n\tint\t(*init)(const char *);\n\n\tint\t(*insert)(struct scheduler_info *);\n\tsize_t\t(*commit)(uint32_t);\n\tsize_t\t(*rollback)(uint32_t);\n\n\tint\t(*update)(struct scheduler_info *);\n\tint\t(*delete)(uint64_t);\n\tint\t(*hold)(uint64_t, uint64_t);\n\tint\t(*release)(int, uint64_t, int);\n\n\tint\t(*batch)(int, int*, size_t*, uint64_t*, int*);\n\n\tsize_t\t(*messages)(uint32_t, uint32_t *, size_t);\n\tsize_t\t(*envelopes)(uint64_t, struct evpstate *, size_t);\n\tint\t(*schedule)(uint64_t);\n\tint\t(*remove)(uint64_t);\n\tint\t(*suspend)(uint64_t);\n\tint\t(*resume)(uint64_t);\n\tint\t(*query)(uint64_t);\n};\n\nenum stat_type {\n\tSTAT_COUNTER,\n\tSTAT_TIMESTAMP,\n\tSTAT_TIMEVAL,\n\tSTAT_TIMESPEC,\n};\n\nstruct stat_value {\n\tenum stat_type\ttype;\n\tunion stat_v {\n\t\tsize_t\t\tcounter;\n\t\ttime_t\t\ttimestamp;\n\t\tstruct timeval\ttv;\n\t\tstruct timespec\tts;\n\t} u;\n};\n\n#define\tSTAT_KEY_SIZE\t1024\nstruct stat_kv {\n\tvoid\t*iter;\n\tchar\tkey[STAT_KEY_SIZE];\n\tstruct stat_value\tval;\n};\n\nstruct stat_backend {\n\tvoid\t(*init)(void);\n\tvoid\t(*close)(void);\n\tvoid\t(*increment)(const char *, size_t);\n\tvoid\t(*decrement)(const char *, size_t);\n\tvoid\t(*set)(const char *, const struct stat_value *);\n\tint\t(*iter)(void **, char **, struct stat_value *);\n};\n\nstruct stat_digest {\n\ttime_t\t\t\t startup;\n\ttime_t\t\t\t timestamp;\n\n\tsize_t\t\t\t clt_connect;\n\tsize_t\t\t\t clt_disconnect;\n\n\tsize_t\t\t\t evp_enqueued;\n\tsize_t\t\t\t evp_dequeued;\n\n\tsize_t\t\t\t evp_expired;\n\tsize_t\t\t\t evp_removed;\n\tsize_t\t\t\t evp_bounce;\n\n\tsize_t\t\t\t dlv_ok;\n\tsize_t\t\t\t dlv_permfail;\n\tsize_t\t\t\t dlv_tempfail;\n\tsize_t\t\t\t dlv_loop;\n};\n\n\nstruct mproc {\n\tpid_t\t\t pid;\n\tchar\t\t*name;\n\tint\t\t proc;\n\tvoid\t\t(*handler)(struct mproc *, struct imsg *);\n\tstruct imsgbuf\t imsgbuf;\n\n\tchar\t\t*m_buf;\n\tsize_t\t\t m_alloc;\n\tsize_t\t\t m_pos;\n\tuint32_t\t m_type;\n\tuint32_t\t m_peerid;\n\tpid_t\t\t m_pid;\n\tint\t\t m_fd;\n\n\tint\t\t enable;\n\tshort\t\t events;\n\tstruct event\t ev;\n\tvoid\t\t*data;\n};\n\nstruct msg {\n\tconst uint8_t\t*pos;\n\tconst uint8_t\t*end;\n};\n\nextern enum smtp_proc_type\tsmtpd_process;\n\nextern int tracing;\nextern int foreground_log;\nextern int profiling;\n\nextern struct mproc *p_control;\nextern struct mproc *p_parent;\nextern struct mproc *p_lka;\nextern struct mproc *p_queue;\nextern struct mproc *p_scheduler;\nextern struct mproc *p_dispatcher;\nextern struct mproc *p_ca;\n\nextern struct smtpd\t*env;\nextern void (*imsg_callback)(struct mproc *, struct imsg *);\n\n/* inter-process structures */\n\nstruct bounce_req_msg {\n\tuint64_t\t\tevpid;\n\ttime_t\t\t\ttimestamp;\n\tstruct delivery_bounce\tbounce;\n};\n\nenum dns_error {\n\tDNS_OK = 0,\n\tDNS_RETRY,\n\tDNS_EINVAL,\n\tDNS_ENONAME,\n\tDNS_ENOTFOUND,\n};\n\nenum lka_resp_status {\n\tLKA_OK,\n\tLKA_TEMPFAIL,\n\tLKA_PERMFAIL\n};\n\nenum filter_type {\n\tFILTER_TYPE_BUILTIN,\n\tFILTER_TYPE_PROC,\n\tFILTER_TYPE_CHAIN,\n};\n\nenum filter_subsystem {\n\tFILTER_SUBSYSTEM_SMTP_IN\t= 1<<0,\n\tFILTER_SUBSYSTEM_SMTP_OUT\t= 1<<1,\n};\n\nstruct filter_proc {\n\tconst char\t\t       *command;\n\tconst char\t\t       *user;\n\tconst char\t\t       *group;\n\tconst char\t\t       *chroot;\n\tint\t\t\t\terrfd;\n\tenum filter_subsystem\t\tfilter_subsystem;\n};\n\nstruct filter_config {\n\tchar\t\t\t       *name;\n\tenum filter_subsystem\t\tfilter_subsystem;\n\tenum filter_type\t\tfilter_type;\n\tenum filter_phase               phase;\n\tchar                           *reject;\n\tchar                           *disconnect;\n\tchar                           *rewrite;\n\tchar                           *report;\n\tuint8_t\t\t\t\tjunk;\n  \tuint8_t\t\t\t\tbypass;\n\tchar                           *proc;\n\n\tconst char\t\t      **chain;\n\tsize_t\t\t\t\tchain_size;\n\tstruct dict\t\t\tchain_procs;\n\n\tint8_t\t\t\t\tnot_fcrdns;\n\tint8_t\t\t\t\tfcrdns;\n\n\tint8_t\t\t\t\tnot_rdns;\n\tint8_t\t\t\t\trdns;\n\n\tint8_t                          not_rdns_table;\n\tstruct table                   *rdns_table;\n\n\tint8_t                          not_rdns_regex;\n\tstruct table                   *rdns_regex;\n\n\tint8_t                          not_src_table;\n\tstruct table                   *src_table;\n\n\tint8_t                          not_src_regex;\n\tstruct table                   *src_regex;\n\n\tint8_t                          not_helo_table;\n\tstruct table                   *helo_table;\n\n\tint8_t                          not_helo_regex;\n\tstruct table                   *helo_regex;\n\n  \tint8_t                          not_auth;\n\tint8_t\t\t\t\tauth;\n\n  \tint8_t                          not_auth_table;\n\tstruct table                   *auth_table;\n\n\tint8_t                          not_auth_regex;\n\tstruct table                   *auth_regex;\n\n\tint8_t                          not_mail_from_table;\n\tstruct table                   *mail_from_table;\n\n\tint8_t                          not_mail_from_regex;\n\tstruct table                   *mail_from_regex;\n\n\tint8_t                          not_rcpt_to_table;\n\tstruct table                   *rcpt_to_table;\n\n\tint8_t                          not_rcpt_to_regex;\n\tstruct table                   *rcpt_to_regex;\n\n};\n\nenum filter_status {\n\tFILTER_PROCEED,\n\tFILTER_REWRITE,\n\tFILTER_REJECT,\n\tFILTER_DISCONNECT,\n\tFILTER_JUNK,\n};\n\nenum ca_resp_status {\n\tCA_OK,\n\tCA_FAIL\n};\n\nenum mda_resp_status {\n\tMDA_OK,\n\tMDA_TEMPFAIL,\n\tMDA_PERMFAIL\n};\n\nstruct msg_walkinfo {\n\tstruct event\t ev;\n\tuint32_t\t msgid;\n\tuint32_t\t peerid;\n\tsize_t\t\t n_evp;\n\tvoid\t\t*data;\n\tint\t\t done;\n};\n\n\nenum dispatcher_type {\n\tDISPATCHER_LOCAL,\n\tDISPATCHER_REMOTE,\n\tDISPATCHER_BOUNCE,\n};\n\nstruct dispatcher_local {\n\tuint8_t is_mbox;\t/* only for MBOX */\n\n\tuint8_t\texpand_only;\n\tuint8_t\tforward_only;\n\n\tchar\t*mda_wrapper;\n\tchar\t*command;\n\n\tchar\t*table_alias;\n\tchar\t*table_virtual;\n\tchar\t*table_userbase;\n\n\tchar\t*user;\n};\n\nstruct dispatcher_remote {\n\tchar\t*helo;\n\tchar\t*helo_source;\n\n\tchar\t*source;\n\n\tstruct tls_config *tls_config;\n\tchar\t*ca;\n\tchar\t*pki;\n\n\tchar\t*mail_from;\n\n\tchar\t*smarthost;\n\tint\t smarthost_domain;\n\n\tchar\t*auth;\n\tint\t tls_required;\n\tint\t tls_noverify;\n\tchar\t*tls_protocols;\n\tchar\t*tls_ciphers;\n\n\tint\t backup;\n\tchar\t*backupmx;\n\n\tchar\t*filtername;\n\n\tint\t srs;\n};\n\nstruct dispatcher_bounce {\n};\n\nstruct dispatcher {\n\tenum dispatcher_type\t\t\ttype;\n\tunion dispatcher_agent {\n\t\tstruct dispatcher_local\t\tlocal;\n\t\tstruct dispatcher_remote  \tremote;\n\t\tstruct dispatcher_bounce  \tbounce;\n\t} u;\n\n\ttime_t\tttl;\n};\n\nstruct rule {\n\tTAILQ_ENTRY(rule)\tr_entry;\n\n\tuint8_t\treject;\n\n\tint8_t\tflag_tag;\n\tint8_t\tflag_from;\n\tint8_t\tflag_for;\n\tint8_t\tflag_from_rdns;\n\tint8_t\tflag_from_socket;\n\n\tint8_t\tflag_tag_regex;\n\tint8_t\tflag_from_regex;\n\tint8_t\tflag_for_regex;\n\n\tint8_t\tflag_smtp_helo;\n\tint8_t\tflag_smtp_starttls;\n\tint8_t\tflag_smtp_auth;\n\tint8_t\tflag_smtp_mail_from;\n\tint8_t\tflag_smtp_rcpt_to;\n\n\tint8_t\tflag_smtp_helo_regex;\n\tint8_t\tflag_smtp_starttls_regex;\n\tint8_t\tflag_smtp_auth_regex;\n\tint8_t\tflag_smtp_mail_from_regex;\n\tint8_t\tflag_smtp_rcpt_to_regex;\n\n\n\tchar\t*table_tag;\n\tchar\t*table_from;\n\tchar\t*table_for;\n\n\tchar\t*table_smtp_helo;\n\tchar\t*table_smtp_auth;\n\tchar\t*table_smtp_mail_from;\n\tchar\t*table_smtp_rcpt_to;\n\n\tchar\t*dispatcher;\n};\n\n\n/* aliases.c */\nint aliases_get(struct expand *, const char *);\nint aliases_virtual_get(struct expand *, const struct mailaddr *);\nint alias_parse(struct expandnode *, const char *);\n\n\n/* auth.c */\nstruct auth_backend *auth_backend_lookup(enum auth_type);\n\n\n/* bounce.c */\nvoid bounce_add(uint64_t);\nvoid bounce_fd(int);\n\n\n/* ca.c */\nint\t ca(void);\nint\t ca_X509_verify(void *, void *, const char *, const char *, const char **);\nvoid\t ca_imsg(struct mproc *, struct imsg *);\nvoid\t ca_init(void);\nvoid\t ca_engine_init(void);\n\n\n/* compress_backend.c */\nstruct compress_backend *compress_backend_lookup(const char *);\nsize_t\tcompress_chunk(void *, size_t, void *, size_t);\nsize_t\tuncompress_chunk(void *, size_t, void *, size_t);\nint\tcompress_file(FILE *, FILE *);\nint\tuncompress_file(FILE *, FILE *);\n\n/* config.c */\n#define PURGE_LISTENERS\t\t0x01\n#define PURGE_TABLES\t\t0x02\n#define PURGE_RULES\t\t0x04\n#define PURGE_PKI\t\t0x08\n#define PURGE_PKI_KEYS\t\t0x10\n#define PURGE_DISPATCHERS\t0x20\n#define PURGE_EVERYTHING\t0xff\nstruct smtpd *config_default(void);\nvoid purge_config(uint8_t);\nvoid config_process(enum smtp_proc_type);\nvoid config_peer(enum smtp_proc_type);\n\n\n/* control.c */\nint control(void);\nint control_create_socket(void);\n\n\n/* crypto.c */\nint\tcrypto_setup(const char *, size_t);\nint\tcrypto_encrypt_file(FILE *, FILE *);\nint\tcrypto_decrypt_file(FILE *, FILE *);\nsize_t\tcrypto_encrypt_buffer(const char *, size_t, char *, size_t);\nsize_t\tcrypto_decrypt_buffer(const char *, size_t, char *, size_t);\n\n\n/* dns.c */\nvoid dns_imsg(struct mproc *, struct imsg *);\n\n\n/* enqueue.c */\nint\t\t enqueue(int, char **, FILE *);\n\n\n/* envelope.c */\nvoid envelope_set_errormsg(struct envelope *, char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\nvoid envelope_set_esc_class(struct envelope *, enum enhanced_status_class);\nvoid envelope_set_esc_code(struct envelope *, enum enhanced_status_code);\nint envelope_load_buffer(struct envelope *, const char *, size_t);\nint envelope_dump_buffer(const struct envelope *, char *, size_t);\n\n\n/* expand.c */\nint expand_cmp(struct expandnode *, struct expandnode *);\nvoid expand_insert(struct expand *, struct expandnode *);\nstruct expandnode *expand_lookup(struct expand *, struct expandnode *);\nvoid expand_clear(struct expand *);\nvoid expand_free(struct expand *);\nint expand_line(struct expand *, const char *, int);\nint expand_to_text(struct expand *, char *, size_t);\nRB_PROTOTYPE(expandtree, expandnode, nodes, expand_cmp);\n\n\n/* forward.c */\nint forwards_get(int, struct expand *);\n\n\n/* limit.c */\nvoid limit_mta_set_defaults(struct mta_limits *);\nint limit_mta_set(struct mta_limits *, const char*, int64_t);\n\n\n/* lka.c */\nint lka(void);\n\n\n/* lka_proc.c */\nint lka_proc_ready(void);\nvoid lka_proc_forked(const char *, uint32_t, int);\nvoid lka_proc_errfd(const char *, int);\nstruct io *lka_proc_get_io(const char *);\n\n\n/* lka_report.c */\nvoid lka_report_init(void);\nvoid lka_report_register_hook(const char *, const char *);\nvoid lka_report_smtp_link_connect(const char *, struct timeval *, uint64_t, const char *, int,\n    const struct sockaddr_storage *, const struct sockaddr_storage *);\nvoid lka_report_smtp_link_disconnect(const char *, struct timeval *, uint64_t);\nvoid lka_report_smtp_link_greeting(const char *, uint64_t, struct timeval *,\n    const char *);\nvoid lka_report_smtp_link_identify(const char *, struct timeval *, uint64_t, const char *, const char *);\nvoid lka_report_smtp_link_tls(const char *, struct timeval *, uint64_t, const char *);\nvoid lka_report_smtp_link_auth(const char *, struct timeval *, uint64_t, const char *, const char *);\nvoid lka_report_smtp_tx_reset(const char *, struct timeval *, uint64_t, uint32_t);\nvoid lka_report_smtp_tx_begin(const char *, struct timeval *, uint64_t, uint32_t);\nvoid lka_report_smtp_tx_mail(const char *, struct timeval *, uint64_t, uint32_t, const char *, int);\nvoid lka_report_smtp_tx_rcpt(const char *, struct timeval *, uint64_t, uint32_t, const char *, int);\nvoid lka_report_smtp_tx_envelope(const char *, struct timeval *, uint64_t, uint32_t, uint64_t);\nvoid lka_report_smtp_tx_commit(const char *, struct timeval *, uint64_t, uint32_t, size_t);\nvoid lka_report_smtp_tx_data(const char *, struct timeval *, uint64_t, uint32_t, int);\nvoid lka_report_smtp_tx_rollback(const char *, struct timeval *, uint64_t, uint32_t);\nvoid lka_report_smtp_protocol_client(const char *, struct timeval *, uint64_t, const char *);\nvoid lka_report_smtp_protocol_server(const char *, struct timeval *, uint64_t, const char *);\nvoid lka_report_smtp_filter_response(const char *, struct timeval *, uint64_t,\n    int, int, const char *);\nvoid lka_report_smtp_timeout(const char *, struct timeval *, uint64_t);\nvoid lka_report_filter_report(uint64_t, const char *, int, const char *,\n    struct timeval *, const char *);\nvoid lka_report_proc(const char *, const char *);\n\n\n/* lka_filter.c */\nvoid lka_filter_init(void);\nvoid lka_filter_register_hook(const char *, const char *);\nvoid lka_filter_ready(void);\nint lka_filter_proc_in_session(uint64_t, const char *);\nvoid lka_filter_begin(uint64_t, const char *);\nvoid lka_filter_end(uint64_t);\nvoid lka_filter_protocol(uint64_t, enum filter_phase, const char *);\nvoid lka_filter_data_begin(uint64_t);\nvoid lka_filter_data_end(uint64_t);\nint lka_filter_response(uint64_t, const char *, const char *);\n\n\n/* lka_session.c */\nvoid lka_session(uint64_t, struct envelope *);\nvoid lka_session_forward_reply(struct forward_req *, int);\n\n\n/* log.c */\nvoid vlog(int, const char *, va_list);\nvoid logit(int, const char *, ...) __attribute__((format (printf, 2, 3)));\n\n\n/* mda.c */\nvoid mda_postfork(void);\nvoid mda_postprivdrop(void);\nvoid mda_imsg(struct mproc *, struct imsg *);\n\n\n/* mda_mbox.c */\nvoid mda_mbox_init(struct deliver *);\nvoid mda_mbox(struct deliver *);\n\n\n/* mda_unpriv.c */\nvoid mda_unpriv(struct dispatcher *, struct deliver *, const char *, const char *);\n\n\n/* mda_variables.c */\nssize_t mda_expand_format(char *, size_t, const struct deliver *,\n    const struct userinfo *, const char *);\n\n\n/* makemap.c */\nint makemap(int, int, char **);\n\n\n/* mailaddr.c */\nint mailaddr_line(struct maddrmap *, const char *);\nvoid maddrmap_init(struct maddrmap *);\nvoid maddrmap_insert(struct maddrmap *, struct maddrnode *);\nvoid maddrmap_free(struct maddrmap *);\n\n\n/* mproc.c */\nint mproc_fork(struct mproc *, const char*, char **);\nvoid mproc_init(struct mproc *, int);\nvoid mproc_clear(struct mproc *);\nvoid mproc_enable(struct mproc *);\nvoid mproc_disable(struct mproc *);\nvoid mproc_event_add(struct mproc *);\nvoid m_compose(struct mproc *, uint32_t, uint32_t, pid_t, int, void *, size_t);\nvoid m_composev(struct mproc *, uint32_t, uint32_t, pid_t, int,\n    const struct iovec *, int);\nvoid m_forward(struct mproc *, struct imsg *);\nvoid m_create(struct mproc *, uint32_t, uint32_t, pid_t, int);\nvoid m_add(struct mproc *, const void *, size_t);\nvoid m_add_int(struct mproc *, int);\nvoid m_add_u32(struct mproc *, uint32_t);\nvoid m_add_size(struct mproc *, size_t);\nvoid m_add_time(struct mproc *, time_t);\nvoid m_add_timeval(struct mproc *, struct timeval *tv);\nvoid m_add_string(struct mproc *, const char *);\nvoid m_add_data(struct mproc *, const void *, size_t);\nvoid m_add_evpid(struct mproc *, uint64_t);\nvoid m_add_msgid(struct mproc *, uint32_t);\nvoid m_add_id(struct mproc *, uint64_t);\nvoid m_add_sockaddr(struct mproc *, const struct sockaddr *);\nvoid m_add_mailaddr(struct mproc *, const struct mailaddr *);\nvoid m_add_envelope(struct mproc *, const struct envelope *);\nvoid m_add_params(struct mproc *, struct dict *);\nvoid m_close(struct mproc *);\nvoid m_flush(struct mproc *);\n\nvoid m_msg(struct msg *, struct imsg *);\nint  m_is_eom(struct msg *);\nvoid m_end(struct msg *);\nvoid m_get_int(struct msg *, int *);\nvoid m_get_size(struct msg *, size_t *);\nvoid m_get_u32(struct msg *, uint32_t *);\nvoid m_get_time(struct msg *, time_t *);\nvoid m_get_timeval(struct msg *, struct timeval *);\nvoid m_get_string(struct msg *, const char **);\nvoid m_get_data(struct msg *, const void **, size_t *);\nvoid m_get_evpid(struct msg *, uint64_t *);\nvoid m_get_msgid(struct msg *, uint32_t *);\nvoid m_get_id(struct msg *, uint64_t *);\nvoid m_get_sockaddr(struct msg *, struct sockaddr *);\nvoid m_get_mailaddr(struct msg *, struct mailaddr *);\nvoid m_get_envelope(struct msg *, struct envelope *);\nvoid m_get_params(struct msg *, struct dict *);\nvoid m_clear_params(struct dict *);\n\n\n/* mta.c */\nvoid mta_postfork(void);\nvoid mta_postprivdrop(void);\nvoid mta_imsg(struct mproc *, struct imsg *);\nvoid mta_route_ok(struct mta_relay *, struct mta_route *);\nvoid mta_route_error(struct mta_relay *, struct mta_route *);\nvoid mta_route_down(struct mta_relay *, struct mta_route *);\nvoid mta_route_collect(struct mta_relay *, struct mta_route *);\nvoid mta_source_error(struct mta_relay *, struct mta_route *, const char *);\nvoid mta_delivery_log(struct mta_envelope *, const char *, const char *, int, const char *);\nvoid mta_delivery_notify(struct mta_envelope *);\nstruct mta_task *mta_route_next_task(struct mta_relay *, struct mta_route *);\nconst char *mta_host_to_text(struct mta_host *);\nconst char *mta_relay_to_text(struct mta_relay *);\n\n\n/* mta_session.c */\nvoid mta_session(struct mta_relay *, struct mta_route *, const char *);\nvoid mta_session_imsg(struct mproc *, struct imsg *);\n\n\n/* parse.y */\nint parse_config(struct smtpd *, const char *, int);\nint cmdline_symset(char *);\n\n\n/* queue.c */\nint queue(void);\n\n\n/* queue_backend.c */\nuint32_t queue_generate_msgid(void);\nuint64_t queue_generate_evpid(uint32_t);\nint queue_init(const char *, int);\nint queue_close(void);\nint queue_message_create(uint32_t *);\nint queue_message_delete(uint32_t);\nint queue_message_commit(uint32_t);\nint queue_message_fd_r(uint32_t);\nint queue_message_fd_rw(uint32_t);\nint queue_envelope_create(struct envelope *);\nint queue_envelope_delete(uint64_t);\nint queue_envelope_load(uint64_t, struct envelope *);\nint queue_envelope_update(struct envelope *);\nint queue_envelope_walk(struct envelope *);\nint queue_message_walk(struct envelope *, uint32_t, int *, void **);\n\n\n/* report_smtp.c */\nvoid report_smtp_link_connect(const char *, uint64_t, const char *, int,\n    const struct sockaddr_storage *, const struct sockaddr_storage *);\nvoid report_smtp_link_disconnect(const char *, uint64_t);\nvoid report_smtp_link_greeting(const char *, uint64_t, const char *);\nvoid report_smtp_link_identify(const char *, uint64_t, const char *, const char *);\nvoid report_smtp_link_tls(const char *, uint64_t, const char *);\nvoid report_smtp_link_auth(const char *, uint64_t, const char *, const char *);\nvoid report_smtp_tx_reset(const char *, uint64_t, uint32_t);\nvoid report_smtp_tx_begin(const char *, uint64_t, uint32_t);\nvoid report_smtp_tx_mail(const char *, uint64_t, uint32_t, const char *, int);\nvoid report_smtp_tx_rcpt(const char *, uint64_t, uint32_t, const char *, int);\nvoid report_smtp_tx_envelope(const char *, uint64_t, uint32_t, uint64_t);\nvoid report_smtp_tx_data(const char *, uint64_t, uint32_t, int);\nvoid report_smtp_tx_commit(const char *, uint64_t, uint32_t, size_t);\nvoid report_smtp_tx_rollback(const char *, uint64_t, uint32_t);\nvoid report_smtp_protocol_client(const char *, uint64_t, const char *);\nvoid report_smtp_protocol_server(const char *, uint64_t, const char *);\nvoid report_smtp_filter_response(const char *, uint64_t, int, int, const char *);\nvoid report_smtp_timeout(const char *, uint64_t);\n\n\n/* ruleset.c */\nstruct rule *ruleset_match(const struct envelope *);\n\n\n/* scheduler.c */\nint scheduler(void);\n\n\n/* scheduler_bakend.c */\nstruct scheduler_backend *scheduler_backend_lookup(const char *);\nvoid scheduler_info(struct scheduler_info *, struct envelope *);\n\n\n/* dispatcher.c */\nint dispatcher(void);\nvoid dispatcher_imsg(struct mproc *, struct imsg *);\n\n\n/* resolver.c */\nvoid resolver_getaddrinfo(const char *, const char *, const struct addrinfo *,\n    void(*)(void *, int, struct addrinfo*), void *);\nvoid resolver_getnameinfo(const struct sockaddr *, int,\n    void(*)(void *, int, const char *, const char *), void *);\nvoid resolver_res_query(const char *, int, int,\n    void (*cb)(void *, int, int, int, const void *, int), void *);\nvoid resolver_dispatch_request(struct mproc *, struct imsg *);\nvoid resolver_dispatch_result(struct mproc *, struct imsg *);\n\n\n/* smtp.c */\nvoid smtp_postfork(void);\nvoid smtp_postprivdrop(void);\nvoid smtp_imsg(struct mproc *, struct imsg *);\nvoid smtp_configure(void);\nvoid smtp_collect(void);\n\n\n/* smtp_session.c */\nint smtp_session(struct listener *, int, const struct sockaddr_storage *,\n    const char *, struct io *);\nvoid smtp_session_imsg(struct mproc *, struct imsg *);\n\n\n/* smtpf_session.c */\nint smtpf_session(struct listener *, int, const struct sockaddr_storage *,\n    const char *);\nvoid smtpf_session_imsg(struct mproc *, struct imsg *);\n\n\n/* smtpd.c */\nvoid imsg_dispatch(struct mproc *, struct imsg *);\nconst char *proc_name(enum smtp_proc_type);\nconst char *proc_title(enum smtp_proc_type);\nconst char *imsg_to_str(int);\nvoid log_imsg(int, int, struct imsg *);\nint fork_proc_backend(const char *, const char *, const char *);\n\n\n/* srs.c */\nconst char *srs_encode(const char *, const char *);\nconst char *srs_decode(const char *);\n\n\n/* stat_backend.c */\nstruct stat_backend\t*stat_backend_lookup(const char *);\nvoid\tstat_increment(const char *, size_t);\nvoid\tstat_decrement(const char *, size_t);\nvoid\tstat_set(const char *, const struct stat_value *);\nstruct stat_value *stat_counter(size_t);\nstruct stat_value *stat_timestamp(time_t);\nstruct stat_value *stat_timeval(struct timeval *);\nstruct stat_value *stat_timespec(struct timespec *);\n\n\n/* table.c */\nstruct table *table_find(struct smtpd *, const char *);\nstruct table *table_create(struct smtpd *, const char *, const char *,\n    const char *);\nint\ttable_config(struct table *);\nint\ttable_open(struct table *);\nint\ttable_update(struct table *);\nvoid\ttable_close(struct table *);\nvoid\ttable_dump(struct table *);\nint\ttable_check_use(struct table *, uint32_t, uint32_t);\nint\ttable_check_type(struct table *, uint32_t);\nint\ttable_check_service(struct table *, uint32_t);\nint\ttable_match(struct table *, enum table_service, const char *);\nint\ttable_lookup(struct table *, enum table_service, const char *,\n    union lookup *);\nint\ttable_fetch(struct table *, enum table_service, union lookup *);\nvoid table_destroy(struct smtpd *, struct table *);\nvoid table_add(struct table *, const char *, const char *);\nint table_domain_match(const char *, const char *);\nint table_netaddr_match(const char *, const char *);\nint table_mailaddr_match(const char *, const char *);\nint table_regex_match(const char *, const char *);\nvoid\ttable_open_all(struct smtpd *);\nvoid\ttable_dump_all(struct smtpd *);\nvoid\ttable_close_all(struct smtpd *);\n\n\n/* to.c */\nint email_to_mailaddr(struct mailaddr *, char *);\nint text_to_netaddr(struct netaddr *, const char *);\nint text_to_mailaddr(struct mailaddr *, const char *);\nint text_to_relayhost(struct relayhost *, const char *);\nint text_to_userinfo(struct userinfo *, const char *);\nint text_to_credentials(struct credentials *, const char *);\nint text_to_expandnode(struct expandnode *, const char *);\nuint64_t text_to_evpid(const char *);\nuint32_t text_to_msgid(const char *);\nconst char *sa_to_text(const struct sockaddr *);\nconst char *ss_to_text(const struct sockaddr_storage *);\nconst char *time_to_text(time_t);\nconst char *duration_to_text(time_t);\nconst char *rule_to_text(struct rule *);\nconst char *sockaddr_to_text(const struct sockaddr *);\nconst char *mailaddr_to_text(const struct mailaddr *);\nconst char *expandnode_to_text(struct expandnode *);\nconst char *tls_to_text(struct tls *);\n\n\n/* util.c */\ntypedef struct arglist arglist;\nstruct arglist {\n\tchar\t**list;\n\tuint\t  num;\n\tuint\t  nalloc;\n};\nvoid addargs(arglist *, char *, ...)\n\t__attribute__((format(printf, 2, 3)));\nint bsnprintf(char *, size_t, const char *, ...)\n\t__attribute__((format (printf, 3, 4)));\nint safe_fclose(FILE *);\nint hostname_match(const char *, const char *);\nint mailaddr_match(const struct mailaddr *, const struct mailaddr *);\nint valid_localpart(const char *);\nint valid_domainpart(const char *);\nint valid_domainname(const char *);\nint valid_smtp_response(const char *);\nint secure_file(int, char *, char *, uid_t, int);\nint  lowercase(char *, const char *, size_t);\nvoid xlowercase(char *, const char *, size_t);\nint  uppercase(char *, const char *, size_t);\nuint64_t generate_uid(void);\nint availdesc(void);\nint ckdir(const char *, mode_t, uid_t, gid_t, int);\nint rmtree(char *, int);\nint mvpurge(char *, char *);\nint mktmpfile(void);\nconst char *parse_smtp_response(char *, size_t, char **, int *);\nint xasprintf(char **, const char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\nvoid *xmalloc(size_t);\nvoid *xcalloc(size_t, size_t);\nchar *xstrdup(const char *);\nvoid *xmemdup(const void *, size_t);\nchar *strip(char *);\nint io_xprint(struct io *, const char *);\nint io_xprintf(struct io *, const char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\nvoid log_envelope(const struct envelope *, const char *, const char *,\n    const char *);\nint session_socket_error(int);\nint getmailname(char *, size_t);\nint base64_encode(unsigned char const *, size_t, char *, size_t);\nint base64_decode(char const *, unsigned char *, size_t);\nint base64_encode_rfc3548(unsigned char const *, size_t,\n\t\t      char *, size_t);\nvoid xclosefrom(int);\n\nvoid log_trace_verbose(int);\nvoid log_trace0(const char *, ...)\n    __attribute__((format (printf, 1, 2)));\n#define log_trace(m, ...)  do { if (tracing & (m)) log_trace0(__VA_ARGS__); } while (0)\n\n/* waitq.c */\nint  waitq_wait(void *, void (*)(void *, void *, void *), void *);\nvoid waitq_run(void *, void *);\n\n\n/* runq.c */\nstruct runq;\n\nint runq_init(struct runq **, void (*)(struct runq *, void *));\nint runq_schedule(struct runq *, time_t, void *);\nint runq_schedule_at(struct runq *, time_t, void *);\nint runq_cancel(struct runq *, void *);\nint runq_pending(struct runq *, void *, time_t *);\n"], "fixing_code": ["/*\t$OpenBSD: smtpd.h,v 1.671 2021/09/22 17:12:34 eric Exp $\t*/\n\n/*\n * Copyright (c) 2008 Gilles Chehade <gilles@poolp.org>\n * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@openbsd.org>\n * Copyright (c) 2012 Eric Faurot <eric@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <event.h>\n\n#include\t\t\t <imsg.h>\n\n#include\t\t\t \"openbsd-compat.h\"\n\n#ifndef nitems\n#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))\n#endif\n\n#include <sys/queue.h>\n#include <sys/tree.h>\n#include <sys/socket.h>\n\n#include <event.h>\n#include <imsg.h>\n#include <limits.h>\n#include <netdb.h>\n#include <stdio.h>\n\n#include \"smtpd-defines.h\"\n#include \"smtpd-api.h\"\n#include \"ioev.h\"\n\n#define CHECK_IMSG_DATA_SIZE(imsg, expected_sz) do {\t\t\t\\\n\tif ((imsg)->hdr.len - IMSG_HEADER_SIZE != (expected_sz))\t\\\n\t\tfatalx(\"smtpd: imsg %d: data size expected %zd got %zd\",\\\n\t   \t    (imsg)->hdr.type,\t\t\t\t\t\\\n\t   \t    (expected_sz), (imsg)->hdr.len - IMSG_HEADER_SIZE);\t\\\n} while (0)\n\n#ifndef SMTPD_CONFDIR\n#define SMTPD_CONFDIR\t\t \"/etc\"\n#endif\n#define CONF_FILE\t\t SMTPD_CONFDIR \"/smtpd.conf\"\n#define MAILNAME_FILE\t\t SMTPD_CONFDIR \"/mailname\"\n#ifndef CA_FILE\n#define CA_FILE                  \"/etc/ssl/cert.pem\"\n#endif\n\n#define PROC_COUNT\t\t 7\n\n#define MAX_HOPS_COUNT\t\t 100\n#define\tDEFAULT_MAX_BODY_SIZE\t(35*1024*1024)\n\n#define\tEXPAND_BUFFER\t\t 1024\n\n#define SMTPD_QUEUE_EXPIRY\t (4 * 24 * 60 * 60)\n#ifndef SMTPD_USER\n#define SMTPD_USER\t\t \"_smtpd\"\n#endif\n#ifndef SMTPD_QUEUE_USER\n#define SMTPD_QUEUE_USER\t \"_smtpq\"\n#endif\n#ifndef SMTPD_SOCKDIR\n#define SMTPD_SOCKDIR\t\t \"/var/run\"\n#endif\n#define SMTPD_SOCKET\t\t SMTPD_SOCKDIR \"/smtpd.sock\"\n#ifndef SMTPD_NAME\n#define\tSMTPD_NAME\t\t \"OpenSMTPD\"\n#endif\n#define\tSMTPD_VERSION\t\t \"7.0.0-portable\"\n#define SMTPD_SESSION_TIMEOUT\t 300\n#define SMTPD_BACKLOG\t\t 5\n\n#ifndef PATH_SMTPCTL\n#define\tPATH_SMTPCTL\t\t\"/usr/sbin/smtpctl\"\n#endif\n\n#define PATH_OFFLINE\t\t\"/offline\"\n#define PATH_PURGE\t\t\"/purge\"\n#define PATH_TEMPORARY\t\t\"/temporary\"\n\n#ifndef\tPATH_LIBEXEC\n#define\tPATH_LIBEXEC\t\t\"/usr/local/libexec/smtpd\"\n#endif\n\n\n/*\n * RFC 5322 defines these characters as valid, some of them are\n * potentially dangerous and need to be escaped.\n */\n#define\tMAILADDR_ALLOWED       \t\"!#$%&'*/?^`{|}~+-=_\"\n#define\tMAILADDR_ESCAPE\t\t\"!#$%&'*?`{|}~\"\n\n\n#define F_STARTTLS\t\t0x01\n#define F_SMTPS\t\t\t0x02\n#define F_SSL\t\t       (F_STARTTLS | F_SMTPS)\n#define F_AUTH\t\t\t0x08\n#define\tF_STARTTLS_REQUIRE\t0x20\n#define\tF_AUTH_REQUIRE\t\t0x40\n#define\tF_MASK_SOURCE\t\t0x100\n#define\tF_TLS_VERIFY\t\t0x200\n#define\tF_EXT_DSN\t\t0x400\n#define\tF_RECEIVEDAUTH\t\t0x800\n#define\tF_MASQUERADE\t\t0x1000\n#define\tF_FILTERED\t\t0x2000\n#define\tF_PROXY\t\t\t0x4000\n\n#define RELAY_TLS_OPPORTUNISTIC\t0\n#define RELAY_TLS_STARTTLS\t1\n#define RELAY_TLS_SMTPS\t\t2\n#define RELAY_TLS_NO\t\t3\n\n#define RELAY_AUTH\t\t0x08\n#define RELAY_LMTP\t\t0x80\n#define\tRELAY_TLS_VERIFY\t0x200\n\n#define MTA_EXT_DSN\t\t0x400\n\n\n#define P_SENDMAIL\t0\n#define P_NEWALIASES\t1\n#define P_MAKEMAP\t2\n\nstruct userinfo {\n\tchar username[SMTPD_VUSERNAME_SIZE];\n\tchar directory[PATH_MAX];\n\tuid_t uid;\n\tgid_t gid;\n};\n\nstruct netaddr {\n\tstruct sockaddr_storage ss;\n\tint bits;\n};\n\nstruct relayhost {\n\tuint16_t flags;\n\tint tls;\n\tchar hostname[HOST_NAME_MAX+1];\n\tuint16_t port;\n\tchar authlabel[PATH_MAX];\n};\n\nstruct credentials {\n\tchar username[LINE_MAX];\n\tchar password[LINE_MAX];\n};\n\nstruct destination {\n\tchar\tname[HOST_NAME_MAX+1];\n};\n\nstruct source {\n\tstruct sockaddr_storage\taddr;\n};\n\nstruct addrname {\n\tstruct sockaddr_storage\taddr;\n\tchar\t\t\tname[HOST_NAME_MAX+1];\n};\n\nunion lookup {\n\tstruct expand\t\t*expand;\n\tstruct credentials\t creds;\n\tstruct netaddr\t\t netaddr;\n\tstruct source\t\t source;\n\tstruct destination\t domain;\n\tstruct userinfo\t\t userinfo;\n\tstruct mailaddr\t\t mailaddr;\n\tstruct addrname\t\t addrname;\n\tstruct maddrmap\t\t*maddrmap;\n\tchar\t\t\t relayhost[LINE_MAX];\n};\n\n/*\n * Bump IMSG_VERSION whenever a change is made to enum imsg_type.\n * This will ensure that we can never use a wrong version of smtpctl with smtpd.\n */\n#define\tIMSG_VERSION\t\t16\n\nenum imsg_type {\n\tIMSG_NONE,\n\n\tIMSG_CTL_OK,\n\tIMSG_CTL_FAIL,\n\n\tIMSG_CTL_GET_DIGEST,\n\tIMSG_CTL_GET_STATS,\n\tIMSG_CTL_LIST_MESSAGES,\n\tIMSG_CTL_LIST_ENVELOPES,\n\tIMSG_CTL_MTA_SHOW_HOSTS,\n\tIMSG_CTL_MTA_SHOW_RELAYS,\n\tIMSG_CTL_MTA_SHOW_ROUTES,\n\tIMSG_CTL_MTA_SHOW_HOSTSTATS,\n\tIMSG_CTL_MTA_BLOCK,\n\tIMSG_CTL_MTA_UNBLOCK,\n\tIMSG_CTL_MTA_SHOW_BLOCK,\n\tIMSG_CTL_PAUSE_EVP,\n\tIMSG_CTL_PAUSE_MDA,\n\tIMSG_CTL_PAUSE_MTA,\n\tIMSG_CTL_PAUSE_SMTP,\n\tIMSG_CTL_PROFILE,\n\tIMSG_CTL_PROFILE_DISABLE,\n\tIMSG_CTL_PROFILE_ENABLE,\n\tIMSG_CTL_RESUME_EVP,\n\tIMSG_CTL_RESUME_MDA,\n\tIMSG_CTL_RESUME_MTA,\n\tIMSG_CTL_RESUME_SMTP,\n\tIMSG_CTL_RESUME_ROUTE,\n\tIMSG_CTL_REMOVE,\n\tIMSG_CTL_SCHEDULE,\n\tIMSG_CTL_SHOW_STATUS,\n\tIMSG_CTL_TRACE_DISABLE,\n\tIMSG_CTL_TRACE_ENABLE,\n\tIMSG_CTL_UPDATE_TABLE,\n\tIMSG_CTL_VERBOSE,\n\tIMSG_CTL_DISCOVER_EVPID,\n\tIMSG_CTL_DISCOVER_MSGID,\n\n\tIMSG_CTL_SMTP_SESSION,\n\n\tIMSG_GETADDRINFO,\n\tIMSG_GETADDRINFO_END,\n\tIMSG_GETNAMEINFO,\n\tIMSG_RES_QUERY,\n\n\tIMSG_SETUP_KEY,\n\tIMSG_SETUP_PEER,\n\tIMSG_SETUP_DONE,\n\n\tIMSG_CONF_START,\n\tIMSG_CONF_END,\n\n\tIMSG_STAT_INCREMENT,\n\tIMSG_STAT_DECREMENT,\n\tIMSG_STAT_SET,\n\n\tIMSG_LKA_AUTHENTICATE,\n\tIMSG_LKA_OPEN_FORWARD,\n\tIMSG_LKA_ENVELOPE_SUBMIT,\n\tIMSG_LKA_ENVELOPE_COMMIT,\n\n\tIMSG_QUEUE_DELIVER,\n\tIMSG_QUEUE_DELIVERY_OK,\n\tIMSG_QUEUE_DELIVERY_TEMPFAIL,\n\tIMSG_QUEUE_DELIVERY_PERMFAIL,\n\tIMSG_QUEUE_DELIVERY_LOOP,\n\tIMSG_QUEUE_DISCOVER_EVPID,\n\tIMSG_QUEUE_DISCOVER_MSGID,\n\tIMSG_QUEUE_ENVELOPE_ACK,\n\tIMSG_QUEUE_ENVELOPE_COMMIT,\n\tIMSG_QUEUE_ENVELOPE_REMOVE,\n\tIMSG_QUEUE_ENVELOPE_SCHEDULE,\n\tIMSG_QUEUE_ENVELOPE_SUBMIT,\n\tIMSG_QUEUE_HOLDQ_HOLD,\n\tIMSG_QUEUE_HOLDQ_RELEASE,\n\tIMSG_QUEUE_MESSAGE_COMMIT,\n\tIMSG_QUEUE_MESSAGE_ROLLBACK,\n\tIMSG_QUEUE_SMTP_SESSION,\n\tIMSG_QUEUE_TRANSFER,\n\n\tIMSG_MDA_DELIVERY_OK,\n\tIMSG_MDA_DELIVERY_TEMPFAIL,\n\tIMSG_MDA_DELIVERY_PERMFAIL,\n\tIMSG_MDA_DELIVERY_LOOP,\n\tIMSG_MDA_DELIVERY_HOLD,\n\tIMSG_MDA_DONE,\n\tIMSG_MDA_FORK,\n\tIMSG_MDA_HOLDQ_RELEASE,\n\tIMSG_MDA_LOOKUP_USERINFO,\n\tIMSG_MDA_KILL,\n\tIMSG_MDA_OPEN_MESSAGE,\n\n\tIMSG_MTA_DELIVERY_OK,\n\tIMSG_MTA_DELIVERY_TEMPFAIL,\n\tIMSG_MTA_DELIVERY_PERMFAIL,\n\tIMSG_MTA_DELIVERY_LOOP,\n\tIMSG_MTA_DELIVERY_HOLD,\n\tIMSG_MTA_DNS_HOST,\n\tIMSG_MTA_DNS_HOST_END,\n\tIMSG_MTA_DNS_MX,\n\tIMSG_MTA_DNS_MX_PREFERENCE,\n\tIMSG_MTA_HOLDQ_RELEASE,\n\tIMSG_MTA_LOOKUP_CREDENTIALS,\n\tIMSG_MTA_LOOKUP_SOURCE,\n\tIMSG_MTA_LOOKUP_HELO,\n\tIMSG_MTA_LOOKUP_SMARTHOST,\n\tIMSG_MTA_OPEN_MESSAGE,\n\tIMSG_MTA_SCHEDULE,\n\n\tIMSG_SCHED_ENVELOPE_BOUNCE,\n\tIMSG_SCHED_ENVELOPE_DELIVER,\n\tIMSG_SCHED_ENVELOPE_EXPIRE,\n\tIMSG_SCHED_ENVELOPE_INJECT,\n\tIMSG_SCHED_ENVELOPE_REMOVE,\n\tIMSG_SCHED_ENVELOPE_TRANSFER,\n\n\tIMSG_SMTP_AUTHENTICATE,\n\tIMSG_SMTP_MESSAGE_COMMIT,\n\tIMSG_SMTP_MESSAGE_CREATE,\n\tIMSG_SMTP_MESSAGE_ROLLBACK,\n\tIMSG_SMTP_MESSAGE_OPEN,\n\tIMSG_SMTP_CHECK_SENDER,\n\tIMSG_SMTP_EXPAND_RCPT,\n\tIMSG_SMTP_LOOKUP_HELO,\n\n\tIMSG_SMTP_REQ_CONNECT,\n\tIMSG_SMTP_REQ_HELO,\n\tIMSG_SMTP_REQ_MAIL,\n\tIMSG_SMTP_REQ_RCPT,\n\tIMSG_SMTP_REQ_DATA,\n\tIMSG_SMTP_REQ_EOM,\n\tIMSG_SMTP_EVENT_RSET,\n\tIMSG_SMTP_EVENT_COMMIT,\n\tIMSG_SMTP_EVENT_ROLLBACK,\n\tIMSG_SMTP_EVENT_DISCONNECT,\n\n\tIMSG_LKA_PROCESSOR_FORK,\n\tIMSG_LKA_PROCESSOR_ERRFD,\n\n\tIMSG_REPORT_SMTP_LINK_CONNECT,\n\tIMSG_REPORT_SMTP_LINK_DISCONNECT,\n\tIMSG_REPORT_SMTP_LINK_GREETING,\n\tIMSG_REPORT_SMTP_LINK_IDENTIFY,\n\tIMSG_REPORT_SMTP_LINK_TLS,\n\tIMSG_REPORT_SMTP_LINK_AUTH,\n\tIMSG_REPORT_SMTP_TX_RESET,\n\tIMSG_REPORT_SMTP_TX_BEGIN,\n\tIMSG_REPORT_SMTP_TX_MAIL,\n\tIMSG_REPORT_SMTP_TX_RCPT,\n\tIMSG_REPORT_SMTP_TX_ENVELOPE,\n\tIMSG_REPORT_SMTP_TX_DATA,\n\tIMSG_REPORT_SMTP_TX_COMMIT,\n\tIMSG_REPORT_SMTP_TX_ROLLBACK,\n\tIMSG_REPORT_SMTP_PROTOCOL_CLIENT,\n\tIMSG_REPORT_SMTP_PROTOCOL_SERVER,\n\tIMSG_REPORT_SMTP_FILTER_RESPONSE,\n\tIMSG_REPORT_SMTP_TIMEOUT,\n\n\tIMSG_FILTER_SMTP_BEGIN,\n\tIMSG_FILTER_SMTP_END,\n\tIMSG_FILTER_SMTP_PROTOCOL,\n\tIMSG_FILTER_SMTP_DATA_BEGIN,\n\tIMSG_FILTER_SMTP_DATA_END,\n\n\tIMSG_CA_RSA_PRIVENC,\n\tIMSG_CA_RSA_PRIVDEC,\n\tIMSG_CA_ECDSA_SIGN,\n};\n\nenum smtp_proc_type {\n\tPROC_PARENT = 0,\n\tPROC_LKA,\n\tPROC_QUEUE,\n\tPROC_CONTROL,\n\tPROC_SCHEDULER,\n\tPROC_DISPATCHER,\n\tPROC_CA,\n\tPROC_PROCESSOR,\n\tPROC_CLIENT,\n};\n\nenum table_type {\n\tT_NONE\t\t= 0,\n\tT_DYNAMIC\t= 0x01,\t/* table with external source\t*/\n\tT_LIST\t\t= 0x02,\t/* table holding a list\t\t*/\n\tT_HASH\t\t= 0x04,\t/* table holding a hash table\t*/\n};\n\nstruct table {\n\tchar\t\t\t\t t_name[LINE_MAX];\n\tenum table_type\t\t\t t_type;\n\tchar\t\t\t\t t_config[PATH_MAX];\n\n\tvoid\t\t\t\t*t_handle;\n\tstruct table_backend\t\t*t_backend;\n};\n\nstruct table_backend {\n\tconst char *name;\n\tconst unsigned int\tservices;\n\tint\t(*config)(struct table *);\n\tint\t(*add)(struct table *, const char *, const char *);\n\tvoid\t(*dump)(struct table *);\n\tint\t(*open)(struct table *);\n\tint\t(*update)(struct table *);\n\tvoid\t(*close)(struct table *);\n\tint\t(*lookup)(struct table *, enum table_service, const char *, char **);\n\tint\t(*fetch)(struct table *, enum table_service, char **);\n};\n\n\nenum bounce_type {\n\tB_FAILED,\n\tB_DELAYED,\n\tB_DELIVERED\n};\n\nenum dsn_ret {\n\tDSN_RETFULL = 1,\n\tDSN_RETHDRS\n};\n\nstruct delivery_bounce {\n\tenum bounce_type\ttype;\n\ttime_t\t\t\tdelay;\n\ttime_t\t\t\tttl;\n\tenum dsn_ret\t\tdsn_ret;\n        int\t\t\tmta_without_dsn;\n};\n\nenum expand_type {\n\tEXPAND_INVALID,\n\tEXPAND_USERNAME,\n\tEXPAND_FILENAME,\n\tEXPAND_FILTER,\n\tEXPAND_INCLUDE,\n\tEXPAND_ADDRESS,\n\tEXPAND_ERROR,\n};\n\nenum filter_phase {\n\tFILTER_CONNECT,\n\tFILTER_HELO,\n\tFILTER_EHLO,\n\tFILTER_STARTTLS,\n\tFILTER_AUTH,\n\tFILTER_MAIL_FROM,\n\tFILTER_RCPT_TO,\n\tFILTER_DATA,\n\tFILTER_DATA_LINE,\n\tFILTER_RSET,\n\tFILTER_QUIT,\n\tFILTER_NOOP,\n\tFILTER_HELP,\n\tFILTER_WIZ,\n\tFILTER_COMMIT,\n\tFILTER_PHASES_COUNT     /* must be last */\n};\n\nstruct expandnode {\n\tRB_ENTRY(expandnode)\tentry;\n\tTAILQ_ENTRY(expandnode)\ttq_entry;\n\tenum expand_type\ttype;\n\tint\t\t\tsameuser;\n\tint\t\t\trealuser;\n\tint\t\t\tforwarded;\n\tstruct rule\t       *rule;\n\tstruct expandnode      *parent;\n\tunsigned int\t\tdepth;\n\tunion {\n\t\t/*\n\t\t * user field handles both expansion user and system user\n\t\t * so we MUST make it large enough to fit a mailaddr user\n\t\t */\n\t\tchar\t\tuser[SMTPD_MAXLOCALPARTSIZE];\n\t\tchar\t\tbuffer[EXPAND_BUFFER];\n\t\tstruct mailaddr\tmailaddr;\n\t}\t\t\tu;\n\tchar\t\tsubaddress[SMTPD_SUBADDRESS_SIZE];\n};\n\nstruct expand {\n\tRB_HEAD(expandtree, expandnode)\t tree;\n\tTAILQ_HEAD(xnodes, expandnode)\t*queue;\n\tsize_t\t\t\t\t nb_nodes;\n\tstruct rule\t\t\t*rule;\n\tstruct expandnode\t\t*parent;\n};\n\nstruct maddrnode {\n\tTAILQ_ENTRY(maddrnode)\t\tentries;\n\tstruct mailaddr\t\t\tmailaddr;\n};\n\nstruct maddrmap {\n\tTAILQ_HEAD(xmaddr, maddrnode)\tqueue;\n};\n\n#define DSN_SUCCESS 0x01\n#define DSN_FAILURE 0x02\n#define DSN_DELAY   0x04\n#define DSN_NEVER   0x08\n\n#define\tDSN_ENVID_LEN\t100\n\n#define\tSMTPD_ENVELOPE_VERSION\t\t3\nstruct envelope {\n\tTAILQ_ENTRY(envelope)\t\tentry;\n\n\tchar\t\t\t\tdispatcher[HOST_NAME_MAX+1];\n\n\tchar\t\t\t\ttag[SMTPD_TAG_SIZE];\n\n\tuint32_t\t\t\tversion;\n\tuint64_t\t\t\tid;\n\tenum envelope_flags\t\tflags;\n\n\tchar\t\t\t\tsmtpname[HOST_NAME_MAX+1];\n\tchar\t\t\t\thelo[HOST_NAME_MAX+1];\n\tchar\t\t\t\thostname[HOST_NAME_MAX+1];\n\tchar\t\t\t\tusername[SMTPD_MAXMAILADDRSIZE];\n\tchar\t\t\t\terrorline[LINE_MAX];\n\tstruct sockaddr_storage\t\tss;\n\n\tstruct mailaddr\t\t\tsender;\n\tstruct mailaddr\t\t\trcpt;\n\tstruct mailaddr\t\t\tdest;\n\n\tchar\t\t\t\tmda_user[SMTPD_VUSERNAME_SIZE];\n\tchar\t\t\t\tmda_subaddress[SMTPD_SUBADDRESS_SIZE];\n\tchar\t\t\t\tmda_exec[LINE_MAX];\n\n\tenum delivery_type\t\ttype;\n\tunion {\n\t\tstruct delivery_bounce\tbounce;\n\t}\t\t\t\tagent;\n\n\tuint16_t\t\t\tretry;\n\ttime_t\t\t\t\tcreation;\n\ttime_t\t\t\t\tttl;\n\ttime_t\t\t\t\tlasttry;\n\ttime_t\t\t\t\tnexttry;\n\ttime_t\t\t\t\tlastbounce;\n\n\tstruct mailaddr\t\t\tdsn_orcpt;\n\tchar\t\t\t\tdsn_envid[DSN_ENVID_LEN+1];\n\tuint8_t\t\t\t\tdsn_notify;\n\tenum dsn_ret\t\t\tdsn_ret;\n\n\tuint8_t\t\t\t\tesc_class;\n\tuint8_t\t\t\t\tesc_code;\n};\n\nstruct listener {\n\tuint16_t       \t\t flags;\n\tint\t\t\t fd;\n\tstruct sockaddr_storage\t ss;\n\tin_port_t\t\t port;\n\tstruct timeval\t\t timeout;\n\tstruct event\t\t ev;\n\tchar\t\t\t filter_name[PATH_MAX];\n\tchar\t\t\t pki_name[PATH_MAX];\n\tchar\t\t\t ca_name[PATH_MAX];\n\tchar\t\t\t tag[SMTPD_TAG_SIZE];\n\tchar\t\t\t authtable[LINE_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tchar\t\t\t hostnametable[PATH_MAX];\n\tchar\t\t\t sendertable[PATH_MAX];\n\n\tTAILQ_ENTRY(listener)\t entry;\n\n\tint\t\t\t local;\t\t/* there must be a better way */\n\n\tchar\t\t\t*tls_protocols;\n\tchar\t\t\t*tls_ciphers;\n\tstruct tls\t\t*tls;\n\tstruct pki\t\t**pki;\n\tint\t\t\t pkicount;\n};\n\nstruct smtpd {\n\tchar\t\t\t\tsc_conffile[PATH_MAX];\n\tsize_t\t\t\t\tsc_maxsize;\n\n#define SMTPD_OPT_VERBOSE\t\t0x00000001\n#define SMTPD_OPT_NOACTION\t\t0x00000002\n\tuint32_t\t\t\tsc_opts;\n\n#define SMTPD_EXITING\t\t\t0x00000001 /* unused */\n#define SMTPD_MDA_PAUSED\t\t0x00000002\n#define SMTPD_MTA_PAUSED\t\t0x00000004\n#define SMTPD_SMTP_PAUSED\t\t0x00000008\n#define SMTPD_MDA_BUSY\t\t\t0x00000010\n#define SMTPD_MTA_BUSY\t\t\t0x00000020\n#define SMTPD_BOUNCE_BUSY\t\t0x00000040\n#define SMTPD_SMTP_DISABLED\t\t0x00000080\n\tuint32_t\t\t\tsc_flags;\n\n#define QUEUE_COMPRESSION      \t\t0x00000001\n#define QUEUE_ENCRYPTION      \t\t0x00000002\n#define QUEUE_EVPCACHE\t\t\t0x00000004\n\tuint32_t\t\t\tsc_queue_flags;\n\tchar\t\t\t       *sc_queue_key;\n\tsize_t\t\t\t\tsc_queue_evpcache_size;\n\n\tsize_t\t\t\t\tsc_session_max_rcpt;\n\tsize_t\t\t\t\tsc_session_max_mails;\n\n\tstruct dict\t\t       *sc_mda_wrappers;\n\tsize_t\t\t\t\tsc_mda_max_session;\n\tsize_t\t\t\t\tsc_mda_max_user_session;\n\tsize_t\t\t\t\tsc_mda_task_hiwat;\n\tsize_t\t\t\t\tsc_mda_task_lowat;\n\tsize_t\t\t\t\tsc_mda_task_release;\n\n\tsize_t\t\t\t\tsc_mta_max_deferred;\n\n\tsize_t\t\t\t\tsc_scheduler_max_inflight;\n\tsize_t\t\t\t\tsc_scheduler_max_evp_batch_size;\n\tsize_t\t\t\t\tsc_scheduler_max_msg_batch_size;\n\tsize_t\t\t\t\tsc_scheduler_max_schedule;\n\n\tstruct dict\t\t       *sc_filter_processes_dict;\n\n\tint\t\t\t\tsc_ttl;\n#define MAX_BOUNCE_WARN\t\t\t4\n\ttime_t\t\t\t\tsc_bounce_warn[MAX_BOUNCE_WARN];\n\tchar\t\t\t\tsc_hostname[HOST_NAME_MAX+1];\n\tstruct stat_backend\t       *sc_stat;\n\tstruct compress_backend\t       *sc_comp;\n\n\ttime_t\t\t\t\t\t sc_uptime;\n\n\t/* This is a listener for a local socket used by smtp_enqueue(). */\n\tstruct listener                         *sc_sock_listener;\n\n\tTAILQ_HEAD(listenerlist, listener)\t*sc_listeners;\n\n\tTAILQ_HEAD(rulelist, rule)\t\t*sc_rules;\n\n\n\tstruct dict\t\t\t\t*sc_filters_dict;\n\tstruct dict\t\t\t\t*sc_dispatchers;\n\tstruct dispatcher\t\t\t*sc_dispatcher_bounce;\n\n\tstruct dict\t\t\t       *sc_ca_dict;\n\tstruct dict\t\t\t       *sc_pki_dict;\n\tstruct dict\t\t\t       *sc_ssl_dict;\n\n\tstruct dict\t\t\t       *sc_tables_dict;\t\t/* keyed lookup\t*/\n\n\tstruct dict\t\t\t       *sc_limits_dict;\n\n\tchar\t\t\t\t       *sc_tls_ciphers;\n\n\tchar\t\t\t\t       *sc_subaddressing_delim;\n\n\tchar\t\t\t\t       *sc_srs_key;\n\tchar\t\t\t\t       *sc_srs_key_backup;\n\tint\t\t\t\t        sc_srs_ttl;\n\n\tchar\t\t\t\t       *sc_admd;\n};\n\n#define\tTRACE_DEBUG\t0x0001\n#define\tTRACE_IMSG\t0x0002\n#define\tTRACE_IO\t0x0004\n#define\tTRACE_SMTP\t0x0008\n#define\tTRACE_FILTERS\t0x0010\n#define\tTRACE_MTA\t0x0020\n#define\tTRACE_BOUNCE\t0x0040\n#define\tTRACE_SCHEDULER\t0x0080\n#define\tTRACE_LOOKUP\t0x0100\n#define\tTRACE_STAT\t0x0200\n#define\tTRACE_RULES\t0x0400\n#define\tTRACE_MPROC\t0x0800\n#define\tTRACE_EXPAND\t0x1000\n#define\tTRACE_TABLES\t0x2000\n#define\tTRACE_QUEUE\t0x4000\n\n#define PROFILE_TOSTAT\t0x0001\n#define PROFILE_IMSG\t0x0002\n#define PROFILE_QUEUE\t0x0004\n\nstruct forward_req {\n\tuint64_t\t\t\tid;\n\tuint8_t\t\t\t\tstatus;\n\n\tchar\t\t\t\tuser[SMTPD_VUSERNAME_SIZE];\n\tuid_t\t\t\t\tuid;\n\tgid_t\t\t\t\tgid;\n\tchar\t\t\t\tdirectory[PATH_MAX];\n};\n\nstruct deliver {\n\tchar\t\t\tdispatcher[EXPAND_BUFFER];\n\n\tstruct mailaddr\t\tsender;\n\tstruct mailaddr\t\trcpt;\n\tstruct mailaddr\t\tdest;\n\n\tchar\t\t\tmda_subaddress[SMTPD_SUBADDRESS_SIZE];\n\tchar\t\t\tmda_exec[LINE_MAX];\n\n\tstruct userinfo\t\tuserinfo;\n};\n\nstruct mta_host {\n\tSPLAY_ENTRY(mta_host)\t entry;\n\tstruct sockaddr\t\t*sa;\n\tchar\t\t\t*ptrname;\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\ttime_t\t\t\t lastconn;\n\ttime_t\t\t\t lastptrquery;\n\n#define HOST_IGNORE\t0x01\n\tint\t\t\t flags;\n};\n\nstruct mta_mx {\n\tTAILQ_ENTRY(mta_mx)\t entry;\n\tstruct mta_host\t\t*host;\n\tchar\t\t\t*mxname;\n\tint\t\t\t preference;\n};\n\nstruct mta_domain {\n\tSPLAY_ENTRY(mta_domain)\t entry;\n\tchar\t\t\t*name;\n\tint\t\t\t as_host;\n\tTAILQ_HEAD(, mta_mx)\t mxs;\n\tint\t\t\t mxstatus;\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\ttime_t\t\t\t lastconn;\n\ttime_t\t\t\t lastmxquery;\n};\n\nstruct mta_source {\n\tSPLAY_ENTRY(mta_source)\t entry;\n\tstruct sockaddr\t\t*sa;\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\ttime_t\t\t\t lastconn;\n};\n\nstruct mta_connector {\n\tstruct mta_source\t\t*source;\n\tstruct mta_relay\t\t*relay;\n\n#define CONNECTOR_ERROR_FAMILY\t\t0x0001\n#define CONNECTOR_ERROR_SOURCE\t\t0x0002\n#define CONNECTOR_ERROR_MX\t\t0x0004\n#define CONNECTOR_ERROR_ROUTE_NET\t0x0008\n#define CONNECTOR_ERROR_ROUTE_SMTP\t0x0010\n#define CONNECTOR_ERROR_ROUTE\t\t0x0018\n#define CONNECTOR_ERROR_BLOCKED\t\t0x0020\n#define CONNECTOR_ERROR\t\t\t0x00ff\n\n#define CONNECTOR_LIMIT_HOST\t\t0x0100\n#define CONNECTOR_LIMIT_ROUTE\t\t0x0200\n#define CONNECTOR_LIMIT_SOURCE\t\t0x0400\n#define CONNECTOR_LIMIT_RELAY\t\t0x0800\n#define CONNECTOR_LIMIT_CONN\t\t0x1000\n#define CONNECTOR_LIMIT_DOMAIN\t\t0x2000\n#define CONNECTOR_LIMIT\t\t\t0xff00\n\n#define CONNECTOR_NEW\t\t\t0x10000\n#define CONNECTOR_WAIT\t\t\t0x20000\n\tint\t\t\t\t flags;\n\n\tint\t\t\t\t refcount;\n\tsize_t\t\t\t\t nconn;\n\ttime_t\t\t\t\t lastconn;\n};\n\nstruct mta_route {\n\tSPLAY_ENTRY(mta_route)\t entry;\n\tuint64_t\t\t id;\n\tstruct mta_source\t*src;\n\tstruct mta_host\t\t*dst;\n#define ROUTE_NEW\t\t0x01\n#define ROUTE_RUNQ\t\t0x02\n#define ROUTE_KEEPALIVE\t\t0x04\n#define ROUTE_DISABLED\t\t0xf0\n#define ROUTE_DISABLED_NET\t0x10\n#define ROUTE_DISABLED_SMTP\t0x20\n\tint\t\t\t flags;\n\tint\t\t\t nerror;\n\tint\t\t\t penalty;\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\ttime_t\t\t\t lastconn;\n\ttime_t\t\t\t lastdisc;\n\ttime_t\t\t\t lastpenalty;\n};\n\nstruct mta_limits {\n\tsize_t\tmaxconn_per_host;\n\tsize_t\tmaxconn_per_route;\n\tsize_t\tmaxconn_per_source;\n\tsize_t\tmaxconn_per_connector;\n\tsize_t\tmaxconn_per_relay;\n\tsize_t\tmaxconn_per_domain;\n\n\ttime_t\tconndelay_host;\n\ttime_t\tconndelay_route;\n\ttime_t\tconndelay_source;\n\ttime_t\tconndelay_connector;\n\ttime_t\tconndelay_relay;\n\ttime_t\tconndelay_domain;\n\n\ttime_t\tdiscdelay_route;\n\n\tsize_t\tmax_mail_per_session;\n\ttime_t\tsessdelay_transaction;\n\ttime_t\tsessdelay_keepalive;\n\n\tsize_t\tmax_failures_per_session;\n\n\tint\tfamily;\n\n\tint\ttask_hiwat;\n\tint\ttask_lowat;\n\tint\ttask_release;\n};\n\nstruct mta_relay {\n\tSPLAY_ENTRY(mta_relay)\t entry;\n\tuint64_t\t\t id;\n\n\tstruct dispatcher\t*dispatcher;\n\tstruct mta_domain\t*domain;\n\tstruct mta_limits\t*limits;\n\tint\t\t\t tls;\n\tint\t\t\t flags;\n\tchar\t\t\t*backupname;\n\tint\t\t\t backuppref;\n\tchar\t\t\t*sourcetable;\n\tuint16_t\t\t port;\n\tchar\t\t\t*pki_name;\n\tchar\t\t\t*ca_name;\n\tchar\t\t\t*authtable;\n\tchar\t\t\t*authlabel;\n\tchar\t\t\t*helotable;\n\tchar\t\t\t*heloname;\n\tchar\t\t\t*secret;\n\tint\t\t\t srs;\n\n\tint\t\t\t state;\n\tsize_t\t\t\t ntask;\n\tTAILQ_HEAD(, mta_task)\t tasks;\n\n\tstruct tree\t\t connectors;\n\tsize_t\t\t\t sourceloop;\n\ttime_t\t\t\t lastsource;\n\ttime_t\t\t\t nextsource;\n\n\tint\t\t\t fail;\n\tchar\t\t\t*failstr;\n\n#define RELAY_WAIT_MX\t\t0x01\n#define RELAY_WAIT_PREFERENCE\t0x02\n#define RELAY_WAIT_SECRET\t0x04\n#define RELAY_WAIT_LIMITS\t0x08\n#define RELAY_WAIT_SOURCE\t0x10\n#define RELAY_WAIT_CONNECTOR\t0x20\n#define RELAY_WAIT_SMARTHOST\t0x40\n#define RELAY_WAITMASK\t\t0x7f\n\tint\t\t\t status;\n\n\tint\t\t\t refcount;\n\tsize_t\t\t\t nconn;\n\tsize_t\t\t\t nconn_ready;\n\ttime_t\t\t\t lastconn;\n};\n\nstruct mta_envelope {\n\tTAILQ_ENTRY(mta_envelope)\t entry;\n\tuint64_t\t\t\t id;\n\tuint64_t\t\t\t session;\n\ttime_t\t\t\t\t creation;\n\tchar\t\t\t\t*smtpname;\n\tchar\t\t\t\t*dest;\n\tchar\t\t\t\t*rcpt;\n\tstruct mta_task\t\t\t*task;\n\tint\t\t\t\t delivery;\n\n\tint\t\t\t\t ext;\n\tchar\t\t\t\t*dsn_orcpt;\n\tchar\t\t\t\tdsn_envid[DSN_ENVID_LEN+1];\n\tuint8_t\t\t\t\tdsn_notify;\n\tenum dsn_ret\t\t\tdsn_ret;\n\n\tchar\t\t\t\t status[LINE_MAX];\n};\n\nstruct mta_task {\n\tTAILQ_ENTRY(mta_task)\t\t entry;\n\tstruct mta_relay\t\t*relay;\n\tuint32_t\t\t\t msgid;\n\tTAILQ_HEAD(, mta_envelope)\t envelopes;\n\tchar\t\t\t\t*sender;\n};\n\nstruct passwd;\n\nstruct queue_backend {\n\tint\t(*init)(struct passwd *, int, const char *);\n};\n\nstruct compress_backend {\n\tsize_t\t(*compress_chunk)(void *, size_t, void *, size_t);\n\tsize_t\t(*uncompress_chunk)(void *, size_t, void *, size_t);\n\tint\t(*compress_file)(FILE *, FILE *);\n\tint\t(*uncompress_file)(FILE *, FILE *);\n};\n\n/* auth structures */\nenum auth_type {\n\tAUTH_BSD,\n\tAUTH_PWD,\n};\n\nstruct auth_backend {\n\tint\t(*authenticate)(char *, char *);\n};\n\nstruct scheduler_backend {\n\tint\t(*init)(const char *);\n\n\tint\t(*insert)(struct scheduler_info *);\n\tsize_t\t(*commit)(uint32_t);\n\tsize_t\t(*rollback)(uint32_t);\n\n\tint\t(*update)(struct scheduler_info *);\n\tint\t(*delete)(uint64_t);\n\tint\t(*hold)(uint64_t, uint64_t);\n\tint\t(*release)(int, uint64_t, int);\n\n\tint\t(*batch)(int, int*, size_t*, uint64_t*, int*);\n\n\tsize_t\t(*messages)(uint32_t, uint32_t *, size_t);\n\tsize_t\t(*envelopes)(uint64_t, struct evpstate *, size_t);\n\tint\t(*schedule)(uint64_t);\n\tint\t(*remove)(uint64_t);\n\tint\t(*suspend)(uint64_t);\n\tint\t(*resume)(uint64_t);\n\tint\t(*query)(uint64_t);\n};\n\nenum stat_type {\n\tSTAT_COUNTER,\n\tSTAT_TIMESTAMP,\n\tSTAT_TIMEVAL,\n\tSTAT_TIMESPEC,\n};\n\nstruct stat_value {\n\tenum stat_type\ttype;\n\tunion stat_v {\n\t\tsize_t\t\tcounter;\n\t\ttime_t\t\ttimestamp;\n\t\tstruct timeval\ttv;\n\t\tstruct timespec\tts;\n\t} u;\n};\n\n#define\tSTAT_KEY_SIZE\t1024\nstruct stat_kv {\n\tvoid\t*iter;\n\tchar\tkey[STAT_KEY_SIZE];\n\tstruct stat_value\tval;\n};\n\nstruct stat_backend {\n\tvoid\t(*init)(void);\n\tvoid\t(*close)(void);\n\tvoid\t(*increment)(const char *, size_t);\n\tvoid\t(*decrement)(const char *, size_t);\n\tvoid\t(*set)(const char *, const struct stat_value *);\n\tint\t(*iter)(void **, char **, struct stat_value *);\n};\n\nstruct stat_digest {\n\ttime_t\t\t\t startup;\n\ttime_t\t\t\t timestamp;\n\n\tsize_t\t\t\t clt_connect;\n\tsize_t\t\t\t clt_disconnect;\n\n\tsize_t\t\t\t evp_enqueued;\n\tsize_t\t\t\t evp_dequeued;\n\n\tsize_t\t\t\t evp_expired;\n\tsize_t\t\t\t evp_removed;\n\tsize_t\t\t\t evp_bounce;\n\n\tsize_t\t\t\t dlv_ok;\n\tsize_t\t\t\t dlv_permfail;\n\tsize_t\t\t\t dlv_tempfail;\n\tsize_t\t\t\t dlv_loop;\n};\n\n\nstruct mproc {\n\tpid_t\t\t pid;\n\tchar\t\t*name;\n\tint\t\t proc;\n\tvoid\t\t(*handler)(struct mproc *, struct imsg *);\n\tstruct imsgbuf\t imsgbuf;\n\n\tchar\t\t*m_buf;\n\tsize_t\t\t m_alloc;\n\tsize_t\t\t m_pos;\n\tuint32_t\t m_type;\n\tuint32_t\t m_peerid;\n\tpid_t\t\t m_pid;\n\tint\t\t m_fd;\n\n\tint\t\t enable;\n\tshort\t\t events;\n\tstruct event\t ev;\n\tvoid\t\t*data;\n};\n\nstruct msg {\n\tconst uint8_t\t*pos;\n\tconst uint8_t\t*end;\n};\n\nextern enum smtp_proc_type\tsmtpd_process;\n\nextern int tracing;\nextern int foreground_log;\nextern int profiling;\n\nextern struct mproc *p_control;\nextern struct mproc *p_parent;\nextern struct mproc *p_lka;\nextern struct mproc *p_queue;\nextern struct mproc *p_scheduler;\nextern struct mproc *p_dispatcher;\nextern struct mproc *p_ca;\n\nextern struct smtpd\t*env;\nextern void (*imsg_callback)(struct mproc *, struct imsg *);\n\n/* inter-process structures */\n\nstruct bounce_req_msg {\n\tuint64_t\t\tevpid;\n\ttime_t\t\t\ttimestamp;\n\tstruct delivery_bounce\tbounce;\n};\n\nenum dns_error {\n\tDNS_OK = 0,\n\tDNS_RETRY,\n\tDNS_EINVAL,\n\tDNS_ENONAME,\n\tDNS_ENOTFOUND,\n};\n\nenum lka_resp_status {\n\tLKA_OK,\n\tLKA_TEMPFAIL,\n\tLKA_PERMFAIL\n};\n\nenum filter_type {\n\tFILTER_TYPE_BUILTIN,\n\tFILTER_TYPE_PROC,\n\tFILTER_TYPE_CHAIN,\n};\n\nenum filter_subsystem {\n\tFILTER_SUBSYSTEM_SMTP_IN\t= 1<<0,\n\tFILTER_SUBSYSTEM_SMTP_OUT\t= 1<<1,\n};\n\nstruct filter_proc {\n\tconst char\t\t       *command;\n\tconst char\t\t       *user;\n\tconst char\t\t       *group;\n\tconst char\t\t       *chroot;\n\tint\t\t\t\terrfd;\n\tenum filter_subsystem\t\tfilter_subsystem;\n};\n\nstruct filter_config {\n\tchar\t\t\t       *name;\n\tenum filter_subsystem\t\tfilter_subsystem;\n\tenum filter_type\t\tfilter_type;\n\tenum filter_phase               phase;\n\tchar                           *reject;\n\tchar                           *disconnect;\n\tchar                           *rewrite;\n\tchar                           *report;\n\tuint8_t\t\t\t\tjunk;\n  \tuint8_t\t\t\t\tbypass;\n\tchar                           *proc;\n\n\tconst char\t\t      **chain;\n\tsize_t\t\t\t\tchain_size;\n\tstruct dict\t\t\tchain_procs;\n\n\tint8_t\t\t\t\tnot_fcrdns;\n\tint8_t\t\t\t\tfcrdns;\n\n\tint8_t\t\t\t\tnot_rdns;\n\tint8_t\t\t\t\trdns;\n\n\tint8_t                          not_rdns_table;\n\tstruct table                   *rdns_table;\n\n\tint8_t                          not_rdns_regex;\n\tstruct table                   *rdns_regex;\n\n\tint8_t                          not_src_table;\n\tstruct table                   *src_table;\n\n\tint8_t                          not_src_regex;\n\tstruct table                   *src_regex;\n\n\tint8_t                          not_helo_table;\n\tstruct table                   *helo_table;\n\n\tint8_t                          not_helo_regex;\n\tstruct table                   *helo_regex;\n\n  \tint8_t                          not_auth;\n\tint8_t\t\t\t\tauth;\n\n  \tint8_t                          not_auth_table;\n\tstruct table                   *auth_table;\n\n\tint8_t                          not_auth_regex;\n\tstruct table                   *auth_regex;\n\n\tint8_t                          not_mail_from_table;\n\tstruct table                   *mail_from_table;\n\n\tint8_t                          not_mail_from_regex;\n\tstruct table                   *mail_from_regex;\n\n\tint8_t                          not_rcpt_to_table;\n\tstruct table                   *rcpt_to_table;\n\n\tint8_t                          not_rcpt_to_regex;\n\tstruct table                   *rcpt_to_regex;\n\n};\n\nenum filter_status {\n\tFILTER_PROCEED,\n\tFILTER_REWRITE,\n\tFILTER_REJECT,\n\tFILTER_DISCONNECT,\n\tFILTER_JUNK,\n};\n\nenum ca_resp_status {\n\tCA_OK,\n\tCA_FAIL\n};\n\nenum mda_resp_status {\n\tMDA_OK,\n\tMDA_TEMPFAIL,\n\tMDA_PERMFAIL\n};\n\nstruct msg_walkinfo {\n\tstruct event\t ev;\n\tuint32_t\t msgid;\n\tuint32_t\t peerid;\n\tsize_t\t\t n_evp;\n\tvoid\t\t*data;\n\tint\t\t done;\n};\n\n\nenum dispatcher_type {\n\tDISPATCHER_LOCAL,\n\tDISPATCHER_REMOTE,\n\tDISPATCHER_BOUNCE,\n};\n\nstruct dispatcher_local {\n\tuint8_t is_mbox;\t/* only for MBOX */\n\n\tuint8_t\texpand_only;\n\tuint8_t\tforward_only;\n\n\tchar\t*mda_wrapper;\n\tchar\t*command;\n\n\tchar\t*table_alias;\n\tchar\t*table_virtual;\n\tchar\t*table_userbase;\n\n\tchar\t*user;\n};\n\nstruct dispatcher_remote {\n\tchar\t*helo;\n\tchar\t*helo_source;\n\n\tchar\t*source;\n\n\tstruct tls_config *tls_config;\n\tchar\t*ca;\n\tchar\t*pki;\n\n\tchar\t*mail_from;\n\n\tchar\t*smarthost;\n\tint\t smarthost_domain;\n\n\tchar\t*auth;\n\tint\t tls_required;\n\tint\t tls_noverify;\n\tchar\t*tls_protocols;\n\tchar\t*tls_ciphers;\n\n\tint\t backup;\n\tchar\t*backupmx;\n\n\tchar\t*filtername;\n\n\tint\t srs;\n};\n\nstruct dispatcher_bounce {\n};\n\nstruct dispatcher {\n\tenum dispatcher_type\t\t\ttype;\n\tunion dispatcher_agent {\n\t\tstruct dispatcher_local\t\tlocal;\n\t\tstruct dispatcher_remote  \tremote;\n\t\tstruct dispatcher_bounce  \tbounce;\n\t} u;\n\n\ttime_t\tttl;\n};\n\nstruct rule {\n\tTAILQ_ENTRY(rule)\tr_entry;\n\n\tuint8_t\treject;\n\n\tint8_t\tflag_tag;\n\tint8_t\tflag_from;\n\tint8_t\tflag_for;\n\tint8_t\tflag_from_rdns;\n\tint8_t\tflag_from_socket;\n\n\tint8_t\tflag_tag_regex;\n\tint8_t\tflag_from_regex;\n\tint8_t\tflag_for_regex;\n\n\tint8_t\tflag_smtp_helo;\n\tint8_t\tflag_smtp_starttls;\n\tint8_t\tflag_smtp_auth;\n\tint8_t\tflag_smtp_mail_from;\n\tint8_t\tflag_smtp_rcpt_to;\n\n\tint8_t\tflag_smtp_helo_regex;\n\tint8_t\tflag_smtp_starttls_regex;\n\tint8_t\tflag_smtp_auth_regex;\n\tint8_t\tflag_smtp_mail_from_regex;\n\tint8_t\tflag_smtp_rcpt_to_regex;\n\n\n\tchar\t*table_tag;\n\tchar\t*table_from;\n\tchar\t*table_for;\n\n\tchar\t*table_smtp_helo;\n\tchar\t*table_smtp_auth;\n\tchar\t*table_smtp_mail_from;\n\tchar\t*table_smtp_rcpt_to;\n\n\tchar\t*dispatcher;\n};\n\n\n/* aliases.c */\nint aliases_get(struct expand *, const char *);\nint aliases_virtual_get(struct expand *, const struct mailaddr *);\nint alias_parse(struct expandnode *, const char *);\n\n\n/* auth.c */\nstruct auth_backend *auth_backend_lookup(enum auth_type);\n\n\n/* bounce.c */\nvoid bounce_add(uint64_t);\nvoid bounce_fd(int);\n\n\n/* ca.c */\nint\t ca(void);\nint\t ca_X509_verify(void *, void *, const char *, const char *, const char **);\nvoid\t ca_imsg(struct mproc *, struct imsg *);\nvoid\t ca_init(void);\nvoid\t ca_engine_init(void);\n\n\n/* compress_backend.c */\nstruct compress_backend *compress_backend_lookup(const char *);\nsize_t\tcompress_chunk(void *, size_t, void *, size_t);\nsize_t\tuncompress_chunk(void *, size_t, void *, size_t);\nint\tcompress_file(FILE *, FILE *);\nint\tuncompress_file(FILE *, FILE *);\n\n/* config.c */\n#define PURGE_LISTENERS\t\t0x01\n#define PURGE_TABLES\t\t0x02\n#define PURGE_RULES\t\t0x04\n#define PURGE_PKI\t\t0x08\n#define PURGE_PKI_KEYS\t\t0x10\n#define PURGE_DISPATCHERS\t0x20\n#define PURGE_EVERYTHING\t0xff\nstruct smtpd *config_default(void);\nvoid purge_config(uint8_t);\nvoid config_process(enum smtp_proc_type);\nvoid config_peer(enum smtp_proc_type);\n\n\n/* control.c */\nint control(void);\nint control_create_socket(void);\n\n\n/* crypto.c */\nint\tcrypto_setup(const char *, size_t);\nint\tcrypto_encrypt_file(FILE *, FILE *);\nint\tcrypto_decrypt_file(FILE *, FILE *);\nsize_t\tcrypto_encrypt_buffer(const char *, size_t, char *, size_t);\nsize_t\tcrypto_decrypt_buffer(const char *, size_t, char *, size_t);\n\n\n/* dns.c */\nvoid dns_imsg(struct mproc *, struct imsg *);\n\n\n/* enqueue.c */\nint\t\t enqueue(int, char **, FILE *);\n\n\n/* envelope.c */\nvoid envelope_set_errormsg(struct envelope *, char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\nvoid envelope_set_esc_class(struct envelope *, enum enhanced_status_class);\nvoid envelope_set_esc_code(struct envelope *, enum enhanced_status_code);\nint envelope_load_buffer(struct envelope *, const char *, size_t);\nint envelope_dump_buffer(const struct envelope *, char *, size_t);\n\n\n/* expand.c */\nint expand_cmp(struct expandnode *, struct expandnode *);\nvoid expand_insert(struct expand *, struct expandnode *);\nstruct expandnode *expand_lookup(struct expand *, struct expandnode *);\nvoid expand_clear(struct expand *);\nvoid expand_free(struct expand *);\nint expand_line(struct expand *, const char *, int);\nint expand_to_text(struct expand *, char *, size_t);\nRB_PROTOTYPE(expandtree, expandnode, nodes, expand_cmp);\n\n\n/* forward.c */\nint forwards_get(int, struct expand *);\n\n\n/* limit.c */\nvoid limit_mta_set_defaults(struct mta_limits *);\nint limit_mta_set(struct mta_limits *, const char*, int64_t);\n\n\n/* lka.c */\nint lka(void);\n\n\n/* lka_proc.c */\nint lka_proc_ready(void);\nvoid lka_proc_forked(const char *, uint32_t, int);\nvoid lka_proc_errfd(const char *, int);\nstruct io *lka_proc_get_io(const char *);\n\n\n/* lka_report.c */\nvoid lka_report_init(void);\nvoid lka_report_register_hook(const char *, const char *);\nvoid lka_report_smtp_link_connect(const char *, struct timeval *, uint64_t, const char *, int,\n    const struct sockaddr_storage *, const struct sockaddr_storage *);\nvoid lka_report_smtp_link_disconnect(const char *, struct timeval *, uint64_t);\nvoid lka_report_smtp_link_greeting(const char *, uint64_t, struct timeval *,\n    const char *);\nvoid lka_report_smtp_link_identify(const char *, struct timeval *, uint64_t, const char *, const char *);\nvoid lka_report_smtp_link_tls(const char *, struct timeval *, uint64_t, const char *);\nvoid lka_report_smtp_link_auth(const char *, struct timeval *, uint64_t, const char *, const char *);\nvoid lka_report_smtp_tx_reset(const char *, struct timeval *, uint64_t, uint32_t);\nvoid lka_report_smtp_tx_begin(const char *, struct timeval *, uint64_t, uint32_t);\nvoid lka_report_smtp_tx_mail(const char *, struct timeval *, uint64_t, uint32_t, const char *, int);\nvoid lka_report_smtp_tx_rcpt(const char *, struct timeval *, uint64_t, uint32_t, const char *, int);\nvoid lka_report_smtp_tx_envelope(const char *, struct timeval *, uint64_t, uint32_t, uint64_t);\nvoid lka_report_smtp_tx_commit(const char *, struct timeval *, uint64_t, uint32_t, size_t);\nvoid lka_report_smtp_tx_data(const char *, struct timeval *, uint64_t, uint32_t, int);\nvoid lka_report_smtp_tx_rollback(const char *, struct timeval *, uint64_t, uint32_t);\nvoid lka_report_smtp_protocol_client(const char *, struct timeval *, uint64_t, const char *);\nvoid lka_report_smtp_protocol_server(const char *, struct timeval *, uint64_t, const char *);\nvoid lka_report_smtp_filter_response(const char *, struct timeval *, uint64_t,\n    int, int, const char *);\nvoid lka_report_smtp_timeout(const char *, struct timeval *, uint64_t);\nvoid lka_report_filter_report(uint64_t, const char *, int, const char *,\n    struct timeval *, const char *);\nvoid lka_report_proc(const char *, const char *);\n\n\n/* lka_filter.c */\nvoid lka_filter_init(void);\nvoid lka_filter_register_hook(const char *, const char *);\nvoid lka_filter_ready(void);\nint lka_filter_proc_in_session(uint64_t, const char *);\nvoid lka_filter_begin(uint64_t, const char *);\nvoid lka_filter_end(uint64_t);\nvoid lka_filter_protocol(uint64_t, enum filter_phase, const char *);\nvoid lka_filter_data_begin(uint64_t);\nvoid lka_filter_data_end(uint64_t);\nint lka_filter_response(uint64_t, const char *, const char *);\n\n\n/* lka_session.c */\nvoid lka_session(uint64_t, struct envelope *);\nvoid lka_session_forward_reply(struct forward_req *, int);\n\n\n/* log.c */\nvoid vlog(int, const char *, va_list);\nvoid logit(int, const char *, ...) __attribute__((format (printf, 2, 3)));\n\n\n/* mda.c */\nvoid mda_postfork(void);\nvoid mda_postprivdrop(void);\nvoid mda_imsg(struct mproc *, struct imsg *);\n\n\n/* mda_mbox.c */\nvoid mda_mbox_init(struct deliver *);\nvoid mda_mbox(struct deliver *);\n\n\n/* mda_unpriv.c */\nvoid mda_unpriv(struct dispatcher *, struct deliver *, const char *, const char *);\n\n\n/* mda_variables.c */\nssize_t mda_expand_format(char *, size_t, const struct deliver *,\n    const struct userinfo *, const char *);\n\n\n/* makemap.c */\nint makemap(int, int, char **);\n\n\n/* mailaddr.c */\nint mailaddr_line(struct maddrmap *, const char *);\nvoid maddrmap_init(struct maddrmap *);\nvoid maddrmap_insert(struct maddrmap *, struct maddrnode *);\nvoid maddrmap_free(struct maddrmap *);\n\n\n/* mproc.c */\nint mproc_fork(struct mproc *, const char*, char **);\nvoid mproc_init(struct mproc *, int);\nvoid mproc_clear(struct mproc *);\nvoid mproc_enable(struct mproc *);\nvoid mproc_disable(struct mproc *);\nvoid mproc_event_add(struct mproc *);\nvoid m_compose(struct mproc *, uint32_t, uint32_t, pid_t, int, void *, size_t);\nvoid m_composev(struct mproc *, uint32_t, uint32_t, pid_t, int,\n    const struct iovec *, int);\nvoid m_forward(struct mproc *, struct imsg *);\nvoid m_create(struct mproc *, uint32_t, uint32_t, pid_t, int);\nvoid m_add(struct mproc *, const void *, size_t);\nvoid m_add_int(struct mproc *, int);\nvoid m_add_u32(struct mproc *, uint32_t);\nvoid m_add_size(struct mproc *, size_t);\nvoid m_add_time(struct mproc *, time_t);\nvoid m_add_timeval(struct mproc *, struct timeval *tv);\nvoid m_add_string(struct mproc *, const char *);\nvoid m_add_data(struct mproc *, const void *, size_t);\nvoid m_add_evpid(struct mproc *, uint64_t);\nvoid m_add_msgid(struct mproc *, uint32_t);\nvoid m_add_id(struct mproc *, uint64_t);\nvoid m_add_sockaddr(struct mproc *, const struct sockaddr *);\nvoid m_add_mailaddr(struct mproc *, const struct mailaddr *);\nvoid m_add_envelope(struct mproc *, const struct envelope *);\nvoid m_add_params(struct mproc *, struct dict *);\nvoid m_close(struct mproc *);\nvoid m_flush(struct mproc *);\n\nvoid m_msg(struct msg *, struct imsg *);\nint  m_is_eom(struct msg *);\nvoid m_end(struct msg *);\nvoid m_get_int(struct msg *, int *);\nvoid m_get_size(struct msg *, size_t *);\nvoid m_get_u32(struct msg *, uint32_t *);\nvoid m_get_time(struct msg *, time_t *);\nvoid m_get_timeval(struct msg *, struct timeval *);\nvoid m_get_string(struct msg *, const char **);\nvoid m_get_data(struct msg *, const void **, size_t *);\nvoid m_get_evpid(struct msg *, uint64_t *);\nvoid m_get_msgid(struct msg *, uint32_t *);\nvoid m_get_id(struct msg *, uint64_t *);\nvoid m_get_sockaddr(struct msg *, struct sockaddr *);\nvoid m_get_mailaddr(struct msg *, struct mailaddr *);\nvoid m_get_envelope(struct msg *, struct envelope *);\nvoid m_get_params(struct msg *, struct dict *);\nvoid m_clear_params(struct dict *);\n\n\n/* mta.c */\nvoid mta_postfork(void);\nvoid mta_postprivdrop(void);\nvoid mta_imsg(struct mproc *, struct imsg *);\nvoid mta_route_ok(struct mta_relay *, struct mta_route *);\nvoid mta_route_error(struct mta_relay *, struct mta_route *);\nvoid mta_route_down(struct mta_relay *, struct mta_route *);\nvoid mta_route_collect(struct mta_relay *, struct mta_route *);\nvoid mta_source_error(struct mta_relay *, struct mta_route *, const char *);\nvoid mta_delivery_log(struct mta_envelope *, const char *, const char *, int, const char *);\nvoid mta_delivery_notify(struct mta_envelope *);\nstruct mta_task *mta_route_next_task(struct mta_relay *, struct mta_route *);\nconst char *mta_host_to_text(struct mta_host *);\nconst char *mta_relay_to_text(struct mta_relay *);\n\n\n/* mta_session.c */\nvoid mta_session(struct mta_relay *, struct mta_route *, const char *);\nvoid mta_session_imsg(struct mproc *, struct imsg *);\n\n\n/* parse.y */\nint parse_config(struct smtpd *, const char *, int);\nint cmdline_symset(char *);\n\n\n/* queue.c */\nint queue(void);\n\n\n/* queue_backend.c */\nuint32_t queue_generate_msgid(void);\nuint64_t queue_generate_evpid(uint32_t);\nint queue_init(const char *, int);\nint queue_close(void);\nint queue_message_create(uint32_t *);\nint queue_message_delete(uint32_t);\nint queue_message_commit(uint32_t);\nint queue_message_fd_r(uint32_t);\nint queue_message_fd_rw(uint32_t);\nint queue_envelope_create(struct envelope *);\nint queue_envelope_delete(uint64_t);\nint queue_envelope_load(uint64_t, struct envelope *);\nint queue_envelope_update(struct envelope *);\nint queue_envelope_walk(struct envelope *);\nint queue_message_walk(struct envelope *, uint32_t, int *, void **);\n\n\n/* report_smtp.c */\nvoid report_smtp_link_connect(const char *, uint64_t, const char *, int,\n    const struct sockaddr_storage *, const struct sockaddr_storage *);\nvoid report_smtp_link_disconnect(const char *, uint64_t);\nvoid report_smtp_link_greeting(const char *, uint64_t, const char *);\nvoid report_smtp_link_identify(const char *, uint64_t, const char *, const char *);\nvoid report_smtp_link_tls(const char *, uint64_t, const char *);\nvoid report_smtp_link_auth(const char *, uint64_t, const char *, const char *);\nvoid report_smtp_tx_reset(const char *, uint64_t, uint32_t);\nvoid report_smtp_tx_begin(const char *, uint64_t, uint32_t);\nvoid report_smtp_tx_mail(const char *, uint64_t, uint32_t, const char *, int);\nvoid report_smtp_tx_rcpt(const char *, uint64_t, uint32_t, const char *, int);\nvoid report_smtp_tx_envelope(const char *, uint64_t, uint32_t, uint64_t);\nvoid report_smtp_tx_data(const char *, uint64_t, uint32_t, int);\nvoid report_smtp_tx_commit(const char *, uint64_t, uint32_t, size_t);\nvoid report_smtp_tx_rollback(const char *, uint64_t, uint32_t);\nvoid report_smtp_protocol_client(const char *, uint64_t, const char *);\nvoid report_smtp_protocol_server(const char *, uint64_t, const char *);\nvoid report_smtp_filter_response(const char *, uint64_t, int, int, const char *);\nvoid report_smtp_timeout(const char *, uint64_t);\n\n\n/* ruleset.c */\nstruct rule *ruleset_match(const struct envelope *);\n\n\n/* scheduler.c */\nint scheduler(void);\n\n\n/* scheduler_bakend.c */\nstruct scheduler_backend *scheduler_backend_lookup(const char *);\nvoid scheduler_info(struct scheduler_info *, struct envelope *);\n\n\n/* dispatcher.c */\nint dispatcher(void);\nvoid dispatcher_imsg(struct mproc *, struct imsg *);\n\n\n/* resolver.c */\nvoid resolver_getaddrinfo(const char *, const char *, const struct addrinfo *,\n    void(*)(void *, int, struct addrinfo*), void *);\nvoid resolver_getnameinfo(const struct sockaddr *, int,\n    void(*)(void *, int, const char *, const char *), void *);\nvoid resolver_res_query(const char *, int, int,\n    void (*cb)(void *, int, int, int, const void *, int), void *);\nvoid resolver_dispatch_request(struct mproc *, struct imsg *);\nvoid resolver_dispatch_result(struct mproc *, struct imsg *);\n\n\n/* smtp.c */\nvoid smtp_postfork(void);\nvoid smtp_postprivdrop(void);\nvoid smtp_imsg(struct mproc *, struct imsg *);\nvoid smtp_configure(void);\nvoid smtp_collect(void);\n\n\n/* smtp_session.c */\nint smtp_session(struct listener *, int, const struct sockaddr_storage *,\n    const char *, struct io *);\nvoid smtp_session_imsg(struct mproc *, struct imsg *);\n\n\n/* smtpf_session.c */\nint smtpf_session(struct listener *, int, const struct sockaddr_storage *,\n    const char *);\nvoid smtpf_session_imsg(struct mproc *, struct imsg *);\n\n\n/* smtpd.c */\nvoid imsg_dispatch(struct mproc *, struct imsg *);\nconst char *proc_name(enum smtp_proc_type);\nconst char *proc_title(enum smtp_proc_type);\nconst char *imsg_to_str(int);\nvoid log_imsg(int, int, struct imsg *);\nint fork_proc_backend(const char *, const char *, const char *);\n\n\n/* srs.c */\nconst char *srs_encode(const char *, const char *);\nconst char *srs_decode(const char *);\n\n\n/* stat_backend.c */\nstruct stat_backend\t*stat_backend_lookup(const char *);\nvoid\tstat_increment(const char *, size_t);\nvoid\tstat_decrement(const char *, size_t);\nvoid\tstat_set(const char *, const struct stat_value *);\nstruct stat_value *stat_counter(size_t);\nstruct stat_value *stat_timestamp(time_t);\nstruct stat_value *stat_timeval(struct timeval *);\nstruct stat_value *stat_timespec(struct timespec *);\n\n\n/* table.c */\nstruct table *table_find(struct smtpd *, const char *);\nstruct table *table_create(struct smtpd *, const char *, const char *,\n    const char *);\nint\ttable_config(struct table *);\nint\ttable_open(struct table *);\nint\ttable_update(struct table *);\nvoid\ttable_close(struct table *);\nvoid\ttable_dump(struct table *);\nint\ttable_check_use(struct table *, uint32_t, uint32_t);\nint\ttable_check_type(struct table *, uint32_t);\nint\ttable_check_service(struct table *, uint32_t);\nint\ttable_match(struct table *, enum table_service, const char *);\nint\ttable_lookup(struct table *, enum table_service, const char *,\n    union lookup *);\nint\ttable_fetch(struct table *, enum table_service, union lookup *);\nvoid table_destroy(struct smtpd *, struct table *);\nvoid table_add(struct table *, const char *, const char *);\nint table_domain_match(const char *, const char *);\nint table_netaddr_match(const char *, const char *);\nint table_mailaddr_match(const char *, const char *);\nint table_regex_match(const char *, const char *);\nvoid\ttable_open_all(struct smtpd *);\nvoid\ttable_dump_all(struct smtpd *);\nvoid\ttable_close_all(struct smtpd *);\n\n\n/* to.c */\nint email_to_mailaddr(struct mailaddr *, char *);\nint text_to_netaddr(struct netaddr *, const char *);\nint text_to_mailaddr(struct mailaddr *, const char *);\nint text_to_relayhost(struct relayhost *, const char *);\nint text_to_userinfo(struct userinfo *, const char *);\nint text_to_credentials(struct credentials *, const char *);\nint text_to_expandnode(struct expandnode *, const char *);\nuint64_t text_to_evpid(const char *);\nuint32_t text_to_msgid(const char *);\nconst char *sa_to_text(const struct sockaddr *);\nconst char *ss_to_text(const struct sockaddr_storage *);\nconst char *time_to_text(time_t);\nconst char *duration_to_text(time_t);\nconst char *rule_to_text(struct rule *);\nconst char *sockaddr_to_text(const struct sockaddr *);\nconst char *mailaddr_to_text(const struct mailaddr *);\nconst char *expandnode_to_text(struct expandnode *);\nconst char *tls_to_text(struct tls *);\n\n\n/* util.c */\ntypedef struct arglist arglist;\nstruct arglist {\n\tchar\t**list;\n\tuint\t  num;\n\tuint\t  nalloc;\n};\nvoid addargs(arglist *, char *, ...)\n\t__attribute__((format(printf, 2, 3)));\nint bsnprintf(char *, size_t, const char *, ...)\n\t__attribute__((format (printf, 3, 4)));\nint safe_fclose(FILE *);\nint hostname_match(const char *, const char *);\nint mailaddr_match(const struct mailaddr *, const struct mailaddr *);\nint valid_localpart(const char *);\nint valid_domainpart(const char *);\nint valid_domainname(const char *);\nint valid_smtp_response(const char *);\nint secure_file(int, char *, char *, uid_t, int);\nint  lowercase(char *, const char *, size_t);\nvoid xlowercase(char *, const char *, size_t);\nint  uppercase(char *, const char *, size_t);\nuint64_t generate_uid(void);\nint availdesc(void);\nint ckdir(const char *, mode_t, uid_t, gid_t, int);\nint rmtree(char *, int);\nint mvpurge(char *, char *);\nint mktmpfile(void);\nconst char *parse_smtp_response(char *, size_t, char **, int *);\nint xasprintf(char **, const char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\nvoid *xmalloc(size_t);\nvoid *xcalloc(size_t, size_t);\nchar *xstrdup(const char *);\nvoid *xmemdup(const void *, size_t);\nchar *strip(char *);\nint io_xprint(struct io *, const char *);\nint io_xprintf(struct io *, const char *, ...)\n    __attribute__((__format__ (printf, 2, 3)));\nvoid log_envelope(const struct envelope *, const char *, const char *,\n    const char *);\nint session_socket_error(int);\nint getmailname(char *, size_t);\nint base64_encode(unsigned char const *, size_t, char *, size_t);\nint base64_decode(char const *, unsigned char *, size_t);\nint base64_encode_rfc3548(unsigned char const *, size_t,\n\t\t      char *, size_t);\nvoid xclosefrom(int);\n\nvoid log_trace_verbose(int);\nvoid log_trace0(const char *, ...)\n    __attribute__((format (printf, 1, 2)));\n#define log_trace(m, ...)  do { if (tracing & (m)) log_trace0(__VA_ARGS__); } while (0)\n\n/* waitq.c */\nint  waitq_wait(void *, void (*)(void *, void *, void *), void *);\nvoid waitq_run(void *, void *);\n\n\n/* runq.c */\nstruct runq;\n\nint runq_init(struct runq **, void (*)(struct runq *, void *));\nint runq_schedule(struct runq *, time_t, void *);\nint runq_schedule_at(struct runq *, time_t, void *);\nint runq_cancel(struct runq *, void *);\nint runq_pending(struct runq *, void *, time_t *);\n"], "filenames": ["usr.sbin/smtpd/smtpd.h"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [83], "fixing_code_start_loc": [1], "fixing_code_end_loc": [83], "type": "NVD-CWE-noinfo", "message": "ascii_load_sockaddr in smtpd in OpenBSD before 7.1 errata 024 and 7.2 before errata 020, and OpenSMTPD Portable before 7.0.0-portable commit f748277, can abort upon a connection from a local, scoped IPv6 address.", "other": {"cve": {"id": "CVE-2023-29323", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-04T23:15:07.347", "lastModified": "2023-05-26T20:15:41.603", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ascii_load_sockaddr in smtpd in OpenBSD before 7.1 errata 024 and 7.2 before errata 020, and OpenSMTPD Portable before 7.0.0-portable commit f748277, can abort upon a connection from a local, scoped IPv6 address."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensmtpd:opensmtpd:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.0", "matchCriteriaId": "35EC43DF-70E4-4B31-8881-E79D09432151"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "4EDBEB9A-DA9B-4384-8C56-599ED2B8D7DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "6E6EC6AC-E2DE-4166-A762-AB6A88DF1C1E"}]}]}], "references": [{"url": "https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/smtpd/envelope.c.diff?r1=1.49&r2=1.49.4.1&f=h", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/smtpd/envelope.c.diff?r1=1.50&r2=1.50.4.1&f=h", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.sbin/smtpd/envelope.c.diff?r1=1.50&r2=1.51&f=h", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/7.1/common/024_smtpd.patch.sig", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/020_smtpd.patch.sig", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/OpenSMTPD/OpenSMTPD/commit/41d0eae481f538956b1f1fbadfb535043454061f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/openbsd/src/commit/f748277ed1fc7065ae8998d61ed78b9ab1e55fae", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.netapp.com/advisory/ntap-20230526-0006/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/OpenSMTPD/OpenSMTPD/commit/41d0eae481f538956b1f1fbadfb535043454061f"}}