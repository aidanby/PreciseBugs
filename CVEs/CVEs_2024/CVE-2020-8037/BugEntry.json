{"buggy_code": ["/*\n * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Extensively modified by Motonori Shindo (mshindo@mshindo.net) for more\n * complete PPP support.\n */\n\n/* \\summary: Point to Point Protocol (PPP) printer */\n\n/*\n * TODO:\n * o resolve XXX as much as possible\n * o MP support\n * o BAP support\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#ifdef __bsdi__\n#include <net/slcompress.h>\n#include <net/if_ppp.h>\n#endif\n\n#include <stdlib.h>\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"addrtoname.h\"\n#include \"ppp.h\"\n#include \"chdlc.h\"\n#include \"ethertype.h\"\n#include \"oui.h\"\n\n/*\n * The following constatns are defined by IANA. Please refer to\n *    http://www.isi.edu/in-notes/iana/assignments/ppp-numbers\n * for the up-to-date information.\n */\n\n/* Protocol Codes defined in ppp.h */\n\nstatic const struct tok ppptype2str[] = {\n        { PPP_IP,\t  \"IP\" },\n        { PPP_OSI,\t  \"OSI\" },\n        { PPP_NS,\t  \"NS\" },\n        { PPP_DECNET,\t  \"DECNET\" },\n        { PPP_APPLE,\t  \"APPLE\" },\n\t{ PPP_IPX,\t  \"IPX\" },\n\t{ PPP_VJC,\t  \"VJC IP\" },\n\t{ PPP_VJNC,\t  \"VJNC IP\" },\n\t{ PPP_BRPDU,\t  \"BRPDU\" },\n\t{ PPP_STII,\t  \"STII\" },\n\t{ PPP_VINES,\t  \"VINES\" },\n\t{ PPP_MPLS_UCAST, \"MPLS\" },\n\t{ PPP_MPLS_MCAST, \"MPLS\" },\n        { PPP_COMP,       \"Compressed\"},\n        { PPP_ML,         \"MLPPP\"},\n        { PPP_IPV6,       \"IP6\"},\n\n\t{ PPP_HELLO,\t  \"HELLO\" },\n\t{ PPP_LUXCOM,\t  \"LUXCOM\" },\n\t{ PPP_SNS,\t  \"SNS\" },\n\t{ PPP_IPCP,\t  \"IPCP\" },\n\t{ PPP_OSICP,\t  \"OSICP\" },\n\t{ PPP_NSCP,\t  \"NSCP\" },\n\t{ PPP_DECNETCP,   \"DECNETCP\" },\n\t{ PPP_APPLECP,\t  \"APPLECP\" },\n\t{ PPP_IPXCP,\t  \"IPXCP\" },\n\t{ PPP_STIICP,\t  \"STIICP\" },\n\t{ PPP_VINESCP,\t  \"VINESCP\" },\n        { PPP_IPV6CP,     \"IP6CP\" },\n\t{ PPP_MPLSCP,\t  \"MPLSCP\" },\n\n\t{ PPP_LCP,\t  \"LCP\" },\n\t{ PPP_PAP,\t  \"PAP\" },\n\t{ PPP_LQM,\t  \"LQM\" },\n\t{ PPP_CHAP,\t  \"CHAP\" },\n\t{ PPP_EAP,\t  \"EAP\" },\n\t{ PPP_SPAP,\t  \"SPAP\" },\n\t{ PPP_SPAP_OLD,\t  \"Old-SPAP\" },\n\t{ PPP_BACP,\t  \"BACP\" },\n\t{ PPP_BAP,\t  \"BAP\" },\n\t{ PPP_MPCP,\t  \"MLPPP-CP\" },\n\t{ PPP_CCP,\t  \"CCP\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* Control Protocols (LCP/IPCP/CCP etc.) Codes defined in RFC 1661 */\n\n#define CPCODES_VEXT\t\t0\t/* Vendor-Specific (RFC2153) */\n#define CPCODES_CONF_REQ\t1\t/* Configure-Request */\n#define CPCODES_CONF_ACK\t2\t/* Configure-Ack */\n#define CPCODES_CONF_NAK\t3\t/* Configure-Nak */\n#define CPCODES_CONF_REJ\t4\t/* Configure-Reject */\n#define CPCODES_TERM_REQ\t5\t/* Terminate-Request */\n#define CPCODES_TERM_ACK\t6\t/* Terminate-Ack */\n#define CPCODES_CODE_REJ\t7\t/* Code-Reject */\n#define CPCODES_PROT_REJ\t8\t/* Protocol-Reject (LCP only) */\n#define CPCODES_ECHO_REQ\t9\t/* Echo-Request (LCP only) */\n#define CPCODES_ECHO_RPL\t10\t/* Echo-Reply (LCP only) */\n#define CPCODES_DISC_REQ\t11\t/* Discard-Request (LCP only) */\n#define CPCODES_ID\t\t12\t/* Identification (LCP only) RFC1570 */\n#define CPCODES_TIME_REM\t13\t/* Time-Remaining (LCP only) RFC1570 */\n#define CPCODES_RESET_REQ\t14\t/* Reset-Request (CCP only) RFC1962 */\n#define CPCODES_RESET_REP\t15\t/* Reset-Reply (CCP only) */\n\nstatic const struct tok cpcodes[] = {\n\t{CPCODES_VEXT,      \"Vendor-Extension\"}, /* RFC2153 */\n\t{CPCODES_CONF_REQ,  \"Conf-Request\"},\n        {CPCODES_CONF_ACK,  \"Conf-Ack\"},\n\t{CPCODES_CONF_NAK,  \"Conf-Nack\"},\n\t{CPCODES_CONF_REJ,  \"Conf-Reject\"},\n\t{CPCODES_TERM_REQ,  \"Term-Request\"},\n\t{CPCODES_TERM_ACK,  \"Term-Ack\"},\n\t{CPCODES_CODE_REJ,  \"Code-Reject\"},\n\t{CPCODES_PROT_REJ,  \"Prot-Reject\"},\n\t{CPCODES_ECHO_REQ,  \"Echo-Request\"},\n\t{CPCODES_ECHO_RPL,  \"Echo-Reply\"},\n\t{CPCODES_DISC_REQ,  \"Disc-Req\"},\n\t{CPCODES_ID,        \"Ident\"},            /* RFC1570 */\n\t{CPCODES_TIME_REM,  \"Time-Rem\"},         /* RFC1570 */\n\t{CPCODES_RESET_REQ, \"Reset-Req\"},        /* RFC1962 */\n\t{CPCODES_RESET_REP, \"Reset-Ack\"},        /* RFC1962 */\n        {0,                 NULL}\n};\n\n/* LCP Config Options */\n\n#define LCPOPT_VEXT\t0\n#define LCPOPT_MRU\t1\n#define LCPOPT_ACCM\t2\n#define LCPOPT_AP\t3\n#define LCPOPT_QP\t4\n#define LCPOPT_MN\t5\n#define LCPOPT_DEP6\t6\n#define LCPOPT_PFC\t7\n#define LCPOPT_ACFC\t8\n#define LCPOPT_FCSALT\t9\n#define LCPOPT_SDP\t10\n#define LCPOPT_NUMMODE\t11\n#define LCPOPT_DEP12\t12\n#define LCPOPT_CBACK\t13\n#define LCPOPT_DEP14\t14\n#define LCPOPT_DEP15\t15\n#define LCPOPT_DEP16\t16\n#define LCPOPT_MLMRRU\t17\n#define LCPOPT_MLSSNHF\t18\n#define LCPOPT_MLED\t19\n#define LCPOPT_PROP\t20\n#define LCPOPT_DCEID\t21\n#define LCPOPT_MPP\t22\n#define LCPOPT_LD\t23\n#define LCPOPT_LCPAOPT\t24\n#define LCPOPT_COBS\t25\n#define LCPOPT_PE\t26\n#define LCPOPT_MLHF\t27\n#define LCPOPT_I18N\t28\n#define LCPOPT_SDLOS\t29\n#define LCPOPT_PPPMUX\t30\n\n#define LCPOPT_MIN LCPOPT_VEXT\n#define LCPOPT_MAX LCPOPT_PPPMUX\n\nstatic const char *lcpconfopts[] = {\n\t\"Vend-Ext\",\t\t/* (0) */\n\t\"MRU\",\t\t\t/* (1) */\n\t\"ACCM\",\t\t\t/* (2) */\n\t\"Auth-Prot\",\t\t/* (3) */\n\t\"Qual-Prot\",\t\t/* (4) */\n\t\"Magic-Num\",\t\t/* (5) */\n\t\"deprecated(6)\",\t/* used to be a Quality Protocol */\n\t\"PFC\",\t\t\t/* (7) */\n\t\"ACFC\",\t\t\t/* (8) */\n\t\"FCS-Alt\",\t\t/* (9) */\n\t\"SDP\",\t\t\t/* (10) */\n\t\"Num-Mode\",\t\t/* (11) */\n\t\"deprecated(12)\",\t/* used to be a Multi-Link-Procedure*/\n\t\"Call-Back\",\t\t/* (13) */\n\t\"deprecated(14)\",\t/* used to be a Connect-Time */\n\t\"deprecated(15)\",\t/* used to be a Compund-Frames */\n\t\"deprecated(16)\",\t/* used to be a Nominal-Data-Encap */\n\t\"MRRU\",\t\t\t/* (17) */\n\t\"12-Bit seq #\",\t\t/* (18) */\n\t\"End-Disc\",\t\t/* (19) */\n\t\"Proprietary\",\t\t/* (20) */\n\t\"DCE-Id\",\t\t/* (21) */\n\t\"MP+\",\t\t\t/* (22) */\n\t\"Link-Disc\",\t\t/* (23) */\n\t\"LCP-Auth-Opt\",\t\t/* (24) */\n\t\"COBS\",\t\t\t/* (25) */\n\t\"Prefix-elision\",\t/* (26) */\n\t\"Multilink-header-Form\",/* (27) */\n\t\"I18N\",\t\t\t/* (28) */\n\t\"SDL-over-SONET/SDH\",\t/* (29) */\n\t\"PPP-Muxing\",\t\t/* (30) */\n};\n\n/* ECP - to be supported */\n\n/* CCP Config Options */\n\n#define CCPOPT_OUI\t0\t/* RFC1962 */\n#define CCPOPT_PRED1\t1\t/* RFC1962 */\n#define CCPOPT_PRED2\t2\t/* RFC1962 */\n#define CCPOPT_PJUMP\t3\t/* RFC1962 */\n/* 4-15 unassigned */\n#define CCPOPT_HPPPC\t16\t/* RFC1962 */\n#define CCPOPT_STACLZS\t17\t/* RFC1974 */\n#define CCPOPT_MPPC\t18\t/* RFC2118 */\n#define CCPOPT_GFZA\t19\t/* RFC1962 */\n#define CCPOPT_V42BIS\t20\t/* RFC1962 */\n#define CCPOPT_BSDCOMP\t21\t/* RFC1977 */\n/* 22 unassigned */\n#define CCPOPT_LZSDCP\t23\t/* RFC1967 */\n#define CCPOPT_MVRCA\t24\t/* RFC1975 */\n#define CCPOPT_DEC\t25\t/* RFC1976 */\n#define CCPOPT_DEFLATE\t26\t/* RFC1979 */\n/* 27-254 unassigned */\n#define CCPOPT_RESV\t255\t/* RFC1962 */\n\nstatic const struct tok ccpconfopts_values[] = {\n        { CCPOPT_OUI, \"OUI\" },\n        { CCPOPT_PRED1, \"Pred-1\" },\n        { CCPOPT_PRED2, \"Pred-2\" },\n        { CCPOPT_PJUMP, \"Puddle\" },\n        { CCPOPT_HPPPC, \"HP-PPC\" },\n        { CCPOPT_STACLZS, \"Stac-LZS\" },\n        { CCPOPT_MPPC, \"MPPC\" },\n        { CCPOPT_GFZA, \"Gand-FZA\" },\n        { CCPOPT_V42BIS, \"V.42bis\" },\n        { CCPOPT_BSDCOMP, \"BSD-Comp\" },\n        { CCPOPT_LZSDCP, \"LZS-DCP\" },\n        { CCPOPT_MVRCA, \"MVRCA\" },\n        { CCPOPT_DEC, \"DEC\" },\n        { CCPOPT_DEFLATE, \"Deflate\" },\n        { CCPOPT_RESV, \"Reserved\"},\n        {0,                 NULL}\n};\n\n/* BACP Config Options */\n\n#define BACPOPT_FPEER\t1\t/* RFC2125 */\n\nstatic const struct tok bacconfopts_values[] = {\n        { BACPOPT_FPEER, \"Favored-Peer\" },\n        {0,                 NULL}\n};\n\n\n/* SDCP - to be supported */\n\n/* IPCP Config Options */\n#define IPCPOPT_2ADDR\t1\t/* RFC1172, RFC1332 (deprecated) */\n#define IPCPOPT_IPCOMP\t2\t/* RFC1332 */\n#define IPCPOPT_ADDR\t3\t/* RFC1332 */\n#define IPCPOPT_MOBILE4\t4\t/* RFC2290 */\n#define IPCPOPT_PRIDNS\t129\t/* RFC1877 */\n#define IPCPOPT_PRINBNS\t130\t/* RFC1877 */\n#define IPCPOPT_SECDNS\t131\t/* RFC1877 */\n#define IPCPOPT_SECNBNS\t132\t/* RFC1877 */\n\nstatic const struct tok ipcpopt_values[] = {\n        { IPCPOPT_2ADDR, \"IP-Addrs\" },\n        { IPCPOPT_IPCOMP, \"IP-Comp\" },\n        { IPCPOPT_ADDR, \"IP-Addr\" },\n        { IPCPOPT_MOBILE4, \"Home-Addr\" },\n        { IPCPOPT_PRIDNS, \"Pri-DNS\" },\n        { IPCPOPT_PRINBNS, \"Pri-NBNS\" },\n        { IPCPOPT_SECDNS, \"Sec-DNS\" },\n        { IPCPOPT_SECNBNS, \"Sec-NBNS\" },\n\t{ 0,\t\t  NULL }\n};\n\n#define IPCPOPT_IPCOMP_HDRCOMP 0x61  /* rfc3544 */\n#define IPCPOPT_IPCOMP_MINLEN    14\n\nstatic const struct tok ipcpopt_compproto_values[] = {\n        { PPP_VJC, \"VJ-Comp\" },\n        { IPCPOPT_IPCOMP_HDRCOMP, \"IP Header Compression\" },\n\t{ 0,\t\t  NULL }\n};\n\nstatic const struct tok ipcpopt_compproto_subopt_values[] = {\n        { 1, \"RTP-Compression\" },\n        { 2, \"Enhanced RTP-Compression\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* IP6CP Config Options */\n#define IP6CP_IFID      1\n\nstatic const struct tok ip6cpopt_values[] = {\n        { IP6CP_IFID, \"Interface-ID\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* ATCP - to be supported */\n/* OSINLCP - to be supported */\n/* BVCP - to be supported */\n/* BCP - to be supported */\n/* IPXCP - to be supported */\n/* MPLSCP - to be supported */\n\n/* Auth Algorithms */\n\n/* 0-4 Reserved (RFC1994) */\n#define AUTHALG_CHAPMD5\t5\t/* RFC1994 */\n#define AUTHALG_MSCHAP1\t128\t/* RFC2433 */\n#define AUTHALG_MSCHAP2\t129\t/* RFC2795 */\n\nstatic const struct tok authalg_values[] = {\n        { AUTHALG_CHAPMD5, \"MD5\" },\n        { AUTHALG_MSCHAP1, \"MS-CHAPv1\" },\n        { AUTHALG_MSCHAP2, \"MS-CHAPv2\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* FCS Alternatives - to be supported */\n\n/* Multilink Endpoint Discriminator (RFC1717) */\n#define MEDCLASS_NULL\t0\t/* Null Class */\n#define MEDCLASS_LOCAL\t1\t/* Locally Assigned */\n#define MEDCLASS_IPV4\t2\t/* Internet Protocol (IPv4) */\n#define MEDCLASS_MAC\t3\t/* IEEE 802.1 global MAC address */\n#define MEDCLASS_MNB\t4\t/* PPP Magic Number Block */\n#define MEDCLASS_PSNDN\t5\t/* Public Switched Network Director Number */\n\n/* PPP LCP Callback */\n#define CALLBACK_AUTH\t0\t/* Location determined by user auth */\n#define CALLBACK_DSTR\t1\t/* Dialing string */\n#define CALLBACK_LID\t2\t/* Location identifier */\n#define CALLBACK_E164\t3\t/* E.164 number */\n#define CALLBACK_X500\t4\t/* X.500 distinguished name */\n#define CALLBACK_CBCP\t6\t/* Location is determined during CBCP nego */\n\nstatic const struct tok ppp_callback_values[] = {\n        { CALLBACK_AUTH, \"UserAuth\" },\n        { CALLBACK_DSTR, \"DialString\" },\n        { CALLBACK_LID, \"LocalID\" },\n        { CALLBACK_E164, \"E.164\" },\n        { CALLBACK_X500, \"X.500\" },\n        { CALLBACK_CBCP, \"CBCP\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* CHAP */\n\n#define CHAP_CHAL\t1\n#define CHAP_RESP\t2\n#define CHAP_SUCC\t3\n#define CHAP_FAIL\t4\n\nstatic const struct tok chapcode_values[] = {\n\t{ CHAP_CHAL, \"Challenge\" },\n\t{ CHAP_RESP, \"Response\" },\n\t{ CHAP_SUCC, \"Success\" },\n\t{ CHAP_FAIL, \"Fail\" },\n        { 0, NULL}\n};\n\n/* PAP */\n\n#define PAP_AREQ\t1\n#define PAP_AACK\t2\n#define PAP_ANAK\t3\n\nstatic const struct tok papcode_values[] = {\n        { PAP_AREQ, \"Auth-Req\" },\n        { PAP_AACK, \"Auth-ACK\" },\n        { PAP_ANAK, \"Auth-NACK\" },\n        { 0, NULL }\n};\n\n/* BAP */\n#define BAP_CALLREQ\t1\n#define BAP_CALLRES\t2\n#define BAP_CBREQ\t3\n#define BAP_CBRES\t4\n#define BAP_LDQREQ\t5\n#define BAP_LDQRES\t6\n#define BAP_CSIND\t7\n#define BAP_CSRES\t8\n\nstatic int print_lcp_config_options(netdissect_options *, const u_char *p, int);\nstatic int print_ipcp_config_options(netdissect_options *, const u_char *p, int);\nstatic int print_ip6cp_config_options(netdissect_options *, const u_char *p, int);\nstatic int print_ccp_config_options(netdissect_options *, const u_char *p, int);\nstatic int print_bacp_config_options(netdissect_options *, const u_char *p, int);\nstatic void handle_ppp(netdissect_options *, u_int proto, const u_char *p, int length);\n\n/* generic Control Protocol (e.g. LCP, IPCP, CCP, etc.) handler */\nstatic void\nhandle_ctrl_proto(netdissect_options *ndo,\n                  u_int proto, const u_char *pptr, int length)\n{\n\tconst char *typestr;\n\tu_int code, len;\n\tint (*pfunc)(netdissect_options *, const u_char *, int);\n\tint x, j;\n        const u_char *tptr;\n\n        tptr=pptr;\n\n        typestr = tok2str(ppptype2str, \"unknown ctrl-proto (0x%04x)\", proto);\n\tND_PRINT((ndo, \"%s, \", typestr));\n\n\tif (length < 4) /* FIXME weak boundary checking */\n\t\tgoto trunc;\n\tND_TCHECK2(*tptr, 2);\n\n\tcode = *tptr++;\n\n\tND_PRINT((ndo, \"%s (0x%02x), id %u, length %u\",\n\t          tok2str(cpcodes, \"Unknown Opcode\",code),\n\t          code,\n\t          *tptr++, /* ID */\n\t          length + 2));\n\n\tif (!ndo->ndo_vflag)\n\t\treturn;\n\n\tif (length <= 4)\n\t\treturn;    /* there may be a NULL confreq etc. */\n\n\tND_TCHECK2(*tptr, 2);\n\tlen = EXTRACT_16BITS(tptr);\n\ttptr += 2;\n\n\tND_PRINT((ndo, \"\\n\\tencoded length %u (=Option(s) length %u)\", len, len - 4));\n\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, pptr - 2, \"\\n\\t\", 6);\n\n\n\tswitch (code) {\n\tcase CPCODES_VEXT:\n\t\tif (length < 11)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 4);\n\t\tND_PRINT((ndo, \"\\n\\t  Magic-Num 0x%08x\", EXTRACT_32BITS(tptr)));\n\t\ttptr += 4;\n\t\tND_TCHECK2(*tptr, 3);\n\t\tND_PRINT((ndo, \" Vendor: %s (%u)\",\n                       tok2str(oui_values,\"Unknown\",EXTRACT_24BITS(tptr)),\n                       EXTRACT_24BITS(tptr)));\n\t\t/* XXX: need to decode Kind and Value(s)? */\n\t\tbreak;\n\tcase CPCODES_CONF_REQ:\n\tcase CPCODES_CONF_ACK:\n\tcase CPCODES_CONF_NAK:\n\tcase CPCODES_CONF_REJ:\n\t\tx = len - 4;\t/* Code(1), Identifier(1) and Length(2) */\n\t\tdo {\n\t\t\tswitch (proto) {\n\t\t\tcase PPP_LCP:\n\t\t\t\tpfunc = print_lcp_config_options;\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPCP:\n\t\t\t\tpfunc = print_ipcp_config_options;\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPV6CP:\n\t\t\t\tpfunc = print_ip6cp_config_options;\n\t\t\t\tbreak;\n\t\t\tcase PPP_CCP:\n\t\t\t\tpfunc = print_ccp_config_options;\n\t\t\t\tbreak;\n\t\t\tcase PPP_BACP:\n\t\t\t\tpfunc = print_bacp_config_options;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * No print routine for the options for\n\t\t\t\t * this protocol.\n\t\t\t\t */\n\t\t\t\tpfunc = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pfunc == NULL) /* catch the above null pointer if unknown CP */\n\t\t\t\tbreak;\n\n\t\t\tif ((j = (*pfunc)(ndo, tptr, len)) == 0)\n\t\t\t\tbreak;\n\t\t\tx -= j;\n\t\t\ttptr += j;\n\t\t} while (x > 0);\n\t\tbreak;\n\n\tcase CPCODES_TERM_REQ:\n\tcase CPCODES_TERM_ACK:\n\t\t/* XXX: need to decode Data? */\n\t\tbreak;\n\tcase CPCODES_CODE_REJ:\n\t\t/* XXX: need to decode Rejected-Packet? */\n\t\tbreak;\n\tcase CPCODES_PROT_REJ:\n\t\tif (length < 6)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 2);\n\t\tND_PRINT((ndo, \"\\n\\t  Rejected %s Protocol (0x%04x)\",\n\t\t       tok2str(ppptype2str,\"unknown\", EXTRACT_16BITS(tptr)),\n\t\t       EXTRACT_16BITS(tptr)));\n\t\t/* XXX: need to decode Rejected-Information? - hexdump for now */\n\t\tif (len > 6) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Rejected Packet\"));\n\t\t\tprint_unknown_data(ndo, tptr + 2, \"\\n\\t    \", len - 2);\n\t\t}\n\t\tbreak;\n\tcase CPCODES_ECHO_REQ:\n\tcase CPCODES_ECHO_RPL:\n\tcase CPCODES_DISC_REQ:\n\t\tif (length < 8)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 4);\n\t\tND_PRINT((ndo, \"\\n\\t  Magic-Num 0x%08x\", EXTRACT_32BITS(tptr)));\n\t\t/* XXX: need to decode Data? - hexdump for now */\n\t\tif (len > 8) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  -----trailing data-----\"));\n\t\t\tND_TCHECK2(tptr[4], len - 8);\n\t\t\tprint_unknown_data(ndo, tptr + 4, \"\\n\\t  \", len - 8);\n\t\t}\n\t\tbreak;\n\tcase CPCODES_ID:\n\t\tif (length < 8)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 4);\n\t\tND_PRINT((ndo, \"\\n\\t  Magic-Num 0x%08x\", EXTRACT_32BITS(tptr)));\n\t\t/* RFC 1661 says this is intended to be human readable */\n\t\tif (len > 8) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Message\\n\\t    \"));\n\t\t\tif (fn_printn(ndo, tptr + 4, len - 4, ndo->ndo_snapend))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tbreak;\n\tcase CPCODES_TIME_REM:\n\t\tif (length < 12)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 4);\n\t\tND_PRINT((ndo, \"\\n\\t  Magic-Num 0x%08x\", EXTRACT_32BITS(tptr)));\n\t\tND_TCHECK2(*(tptr + 4), 4);\n\t\tND_PRINT((ndo, \", Seconds-Remaining %us\", EXTRACT_32BITS(tptr + 4)));\n\t\t/* XXX: need to decode Message? */\n\t\tbreak;\n\tdefault:\n\t\t/* XXX this is dirty but we do not get the\n\t\t * original pointer passed to the begin\n\t\t * the PPP packet */\n\t\tif (ndo->ndo_vflag <= 1)\n\t\t\tprint_unknown_data(ndo, pptr - 2, \"\\n\\t  \", length + 2);\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|%s]\", typestr));\n}\n\n/* LCP config options */\nstatic int\nprint_lcp_config_options(netdissect_options *ndo,\n                         const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tif ((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))\n\t\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t\t          lcpconfopts[opt], opt, len));\n\t\telse\n\t\t\tND_PRINT((ndo, \"\\n\\tunknown LCP option 0x%02x\", opt));\n\t\treturn 0;\n\t}\n\tif ((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\", lcpconfopts[opt], opt, len));\n\telse {\n\t\tND_PRINT((ndo, \"\\n\\tunknown LCP option 0x%02x\", opt));\n\t\treturn len;\n\t}\n\n\tswitch (opt) {\n\tcase LCPOPT_VEXT:\n\t\tif (len < 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_24BITS(p + 2);\n\t\tND_PRINT((ndo, \": Vendor: %s (%u)\",\n\t\t\ttok2str(oui_values,\"Unknown\",EXTRACT_24BITS(p+2)),\n\t\t\tEXTRACT_24BITS(p + 2)));\n#if 0\n\t\tND_TCHECK(p[5]);\n\t\tND_PRINT((ndo, \", kind: 0x%02x\", p[5]));\n\t\tND_PRINT((ndo, \", Value: 0x\"));\n\t\tfor (i = 0; i < len - 6; i++) {\n\t\t\tND_TCHECK(p[6 + i]);\n\t\t\tND_PRINT((ndo, \"%02x\", p[6 + i]));\n\t\t}\n#endif\n\t\tbreak;\n\tcase LCPOPT_MRU:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_16BITS(p + 2);\n\t\tND_PRINT((ndo, \": %u\", EXTRACT_16BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_ACCM:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_32BITS(p + 2);\n\t\tND_PRINT((ndo, \": 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_AP:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_16BITS(p + 2);\n\t\tND_PRINT((ndo, \": %s\", tok2str(ppptype2str, \"Unknown Auth Proto (0x04x)\", EXTRACT_16BITS(p + 2))));\n\n\t\tswitch (EXTRACT_16BITS(p+2)) {\n\t\tcase PPP_CHAP:\n\t\t\tND_TCHECK(p[4]);\n\t\t\tND_PRINT((ndo, \", %s\", tok2str(authalg_values, \"Unknown Auth Alg %u\", p[4])));\n\t\t\tbreak;\n\t\tcase PPP_PAP: /* fall through */\n\t\tcase PPP_EAP:\n\t\tcase PPP_SPAP:\n\t\tcase PPP_SPAP_OLD:\n                        break;\n\t\tdefault:\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", len);\n\t\t}\n\t\tbreak;\n\tcase LCPOPT_QP:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_16BITS(p+2);\n\t\tif (EXTRACT_16BITS(p+2) == PPP_LQM)\n\t\t\tND_PRINT((ndo, \": LQR\"));\n\t\telse\n\t\t\tND_PRINT((ndo, \": unknown\"));\n\t\tbreak;\n\tcase LCPOPT_MN:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_32BITS(p + 2);\n\t\tND_PRINT((ndo, \": 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_PFC:\n\t\tbreak;\n\tcase LCPOPT_ACFC:\n\t\tbreak;\n\tcase LCPOPT_LD:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_16BITS(p + 2);\n\t\tND_PRINT((ndo, \": 0x%04x\", EXTRACT_16BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_CBACK:\n\t\tif (len < 3) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 3)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_PRINT((ndo, \": \"));\n\t\tND_TCHECK(p[2]);\n\t\tND_PRINT((ndo, \": Callback Operation %s (%u)\",\n                       tok2str(ppp_callback_values, \"Unknown\", p[2]),\n                       p[2]));\n\t\tbreak;\n\tcase LCPOPT_MLMRRU:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_16BITS(p + 2);\n\t\tND_PRINT((ndo, \": %u\", EXTRACT_16BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_MLED:\n\t\tif (len < 3) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 3)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK(p[2]);\n\t\tswitch (p[2]) {\t\t/* class */\n\t\tcase MEDCLASS_NULL:\n\t\t\tND_PRINT((ndo, \": Null\"));\n\t\t\tbreak;\n\t\tcase MEDCLASS_LOCAL:\n\t\t\tND_PRINT((ndo, \": Local\")); /* XXX */\n\t\t\tbreak;\n\t\tcase MEDCLASS_IPV4:\n\t\t\tif (len != 7) {\n\t\t\t\tND_PRINT((ndo, \" (length bogus, should be = 7)\"));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tND_TCHECK2(*(p + 3), 4);\n\t\t\tND_PRINT((ndo, \": IPv4 %s\", ipaddr_string(ndo, p + 3)));\n\t\t\tbreak;\n\t\tcase MEDCLASS_MAC:\n\t\t\tif (len != 9) {\n\t\t\t\tND_PRINT((ndo, \" (length bogus, should be = 9)\"));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tND_TCHECK2(*(p + 3), 6);\n\t\t\tND_PRINT((ndo, \": MAC %s\", etheraddr_string(ndo, p + 3)));\n\t\t\tbreak;\n\t\tcase MEDCLASS_MNB:\n\t\t\tND_PRINT((ndo, \": Magic-Num-Block\")); /* XXX */\n\t\t\tbreak;\n\t\tcase MEDCLASS_PSNDN:\n\t\t\tND_PRINT((ndo, \": PSNDN\")); /* XXX */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \": Unknown class %u\", p[2]));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n/* XXX: to be supported */\n#if 0\n\tcase LCPOPT_DEP6:\n\tcase LCPOPT_FCSALT:\n\tcase LCPOPT_SDP:\n\tcase LCPOPT_NUMMODE:\n\tcase LCPOPT_DEP12:\n\tcase LCPOPT_DEP14:\n\tcase LCPOPT_DEP15:\n\tcase LCPOPT_DEP16:\n        case LCPOPT_MLSSNHF:\n\tcase LCPOPT_PROP:\n\tcase LCPOPT_DCEID:\n\tcase LCPOPT_MPP:\n\tcase LCPOPT_LCPAOPT:\n\tcase LCPOPT_COBS:\n\tcase LCPOPT_PE:\n\tcase LCPOPT_MLHF:\n\tcase LCPOPT_I18N:\n\tcase LCPOPT_SDLOS:\n\tcase LCPOPT_PPPMUX:\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|lcp]\"));\n\treturn 0;\n}\n\n/* ML-PPP*/\nstatic const struct tok ppp_ml_flag_values[] = {\n    { 0x80, \"begin\" },\n    { 0x40, \"end\" },\n    { 0, NULL }\n};\n\nstatic void\nhandle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n\n    if (length < 2) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    if (!ND_TTEST_16BITS(p)) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}\n\n/* CHAP */\nstatic void\nhandle_chap(netdissect_options *ndo,\n            const u_char *p, int length)\n{\n\tu_int code, len;\n\tint val_size, name_size, msg_size;\n\tconst u_char *p0;\n\tint i;\n\n\tp0 = p;\n\tif (length < 1) {\n\t\tND_PRINT((ndo, \"[|chap]\"));\n\t\treturn;\n\t} else if (length < 4) {\n\t\tND_TCHECK(*p);\n\t\tND_PRINT((ndo, \"[|chap 0x%02x]\", *p));\n\t\treturn;\n\t}\n\n\tND_TCHECK(*p);\n\tcode = *p;\n\tND_PRINT((ndo, \"CHAP, %s (0x%02x)\",\n               tok2str(chapcode_values,\"unknown\",code),\n               code));\n\tp++;\n\n\tND_TCHECK(*p);\n\tND_PRINT((ndo, \", id %u\", *p));\t\t/* ID */\n\tp++;\n\n\tND_TCHECK2(*p, 2);\n\tlen = EXTRACT_16BITS(p);\n\tp += 2;\n\n\t/*\n\t * Note that this is a generic CHAP decoding routine. Since we\n\t * don't know which flavor of CHAP (i.e. CHAP-MD5, MS-CHAPv1,\n\t * MS-CHAPv2) is used at this point, we can't decode packet\n\t * specifically to each algorithms. Instead, we simply decode\n\t * the GCD (Gratest Common Denominator) for all algorithms.\n\t */\n\tswitch (code) {\n\tcase CHAP_CHAL:\n\tcase CHAP_RESP:\n\t\tif (length - (p - p0) < 1)\n\t\t\treturn;\n\t\tND_TCHECK(*p);\n\t\tval_size = *p;\t\t/* value size */\n\t\tp++;\n\t\tif (length - (p - p0) < val_size)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \", Value \"));\n\t\tfor (i = 0; i < val_size; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tND_PRINT((ndo, \"%02x\", *p++));\n\t\t}\n\t\tname_size = len - (p - p0);\n\t\tND_PRINT((ndo, \", Name \"));\n\t\tfor (i = 0; i < name_size; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\t\tbreak;\n\tcase CHAP_SUCC:\n\tcase CHAP_FAIL:\n\t\tmsg_size = len - (p - p0);\n\t\tND_PRINT((ndo, \", Msg \"));\n\t\tfor (i = 0; i< msg_size; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|chap]\"));\n}\n\n/* PAP (see RFC 1334) */\nstatic void\nhandle_pap(netdissect_options *ndo,\n           const u_char *p, int length)\n{\n\tu_int code, len;\n\tint peerid_len, passwd_len, msg_len;\n\tconst u_char *p0;\n\tint i;\n\n\tp0 = p;\n\tif (length < 1) {\n\t\tND_PRINT((ndo, \"[|pap]\"));\n\t\treturn;\n\t} else if (length < 4) {\n\t\tND_TCHECK(*p);\n\t\tND_PRINT((ndo, \"[|pap 0x%02x]\", *p));\n\t\treturn;\n\t}\n\n\tND_TCHECK(*p);\n\tcode = *p;\n\tND_PRINT((ndo, \"PAP, %s (0x%02x)\",\n\t          tok2str(papcode_values, \"unknown\", code),\n\t          code));\n\tp++;\n\n\tND_TCHECK(*p);\n\tND_PRINT((ndo, \", id %u\", *p));\t\t/* ID */\n\tp++;\n\n\tND_TCHECK2(*p, 2);\n\tlen = EXTRACT_16BITS(p);\n\tp += 2;\n\n\tif ((int)len > length) {\n\t\tND_PRINT((ndo, \", length %u > packet size\", len));\n\t\treturn;\n\t}\n\tlength = len;\n\tif (length < (p - p0)) {\n\t\tND_PRINT((ndo, \", length %u < PAP header length\", length));\n\t\treturn;\n\t}\n\n\tswitch (code) {\n\tcase PAP_AREQ:\n\t\t/* A valid Authenticate-Request is 6 or more octets long. */\n\t\tif (len < 6)\n\t\t\tgoto trunc;\n\t\tif (length - (p - p0) < 1)\n\t\t\treturn;\n\t\tND_TCHECK(*p);\n\t\tpeerid_len = *p;\t/* Peer-ID Length */\n\t\tp++;\n\t\tif (length - (p - p0) < peerid_len)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \", Peer \"));\n\t\tfor (i = 0; i < peerid_len; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\n\t\tif (length - (p - p0) < 1)\n\t\t\treturn;\n\t\tND_TCHECK(*p);\n\t\tpasswd_len = *p;\t/* Password Length */\n\t\tp++;\n\t\tif (length - (p - p0) < passwd_len)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \", Name \"));\n\t\tfor (i = 0; i < passwd_len; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\t\tbreak;\n\tcase PAP_AACK:\n\tcase PAP_ANAK:\n\t\t/* Although some implementations ignore truncation at\n\t\t * this point and at least one generates a truncated\n\t\t * packet, RFC 1334 section 2.2.2 clearly states that\n\t\t * both AACK and ANAK are at least 5 bytes long.\n\t\t */\n\t\tif (len < 5)\n\t\t\tgoto trunc;\n\t\tif (length - (p - p0) < 1)\n\t\t\treturn;\n\t\tND_TCHECK(*p);\n\t\tmsg_len = *p;\t\t/* Msg-Length */\n\t\tp++;\n\t\tif (length - (p - p0) < msg_len)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \", Msg \"));\n\t\tfor (i = 0; i< msg_len; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pap]\"));\n}\n\n/* BAP */\nstatic void\nhandle_bap(netdissect_options *ndo _U_,\n           const u_char *p _U_, int length _U_)\n{\n\t/* XXX: to be supported!! */\n}\n\n\n/* IPCP config options */\nstatic int\nprint_ipcp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n        u_int compproto, ipcomp_subopttotallen, ipcomp_subopt, ipcomp_suboptlen;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t       tok2str(ipcpopt_values,\"unknown\",opt),\n\t\t       opt,\n\t\t       len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t       tok2str(ipcpopt_values,\"unknown\",opt),\n\t       opt,\n\t       len));\n\n\tswitch (opt) {\n\tcase IPCPOPT_2ADDR:\t\t/* deprecated */\n\t\tif (len != 10) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 10)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 6), 4);\n\t\tND_PRINT((ndo, \": src %s, dst %s\",\n\t\t       ipaddr_string(ndo, p + 2),\n\t\t       ipaddr_string(ndo, p + 6)));\n\t\tbreak;\n\tcase IPCPOPT_IPCOMP:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_16BITS(p+2);\n\t\tcompproto = EXTRACT_16BITS(p+2);\n\n\t\tND_PRINT((ndo, \": %s (0x%02x):\",\n\t\t          tok2str(ipcpopt_compproto_values, \"Unknown\", compproto),\n\t\t          compproto));\n\n\t\tswitch (compproto) {\n                case PPP_VJC:\n\t\t\t/* XXX: VJ-Comp parameters should be decoded */\n                        break;\n                case IPCPOPT_IPCOMP_HDRCOMP:\n                        if (len < IPCPOPT_IPCOMP_MINLEN) {\n                        \tND_PRINT((ndo, \" (length bogus, should be >= %u)\",\n                        \t\tIPCPOPT_IPCOMP_MINLEN));\n                        \treturn 0;\n                        }\n\n                        ND_TCHECK2(*(p + 2), IPCPOPT_IPCOMP_MINLEN);\n                        ND_PRINT((ndo, \"\\n\\t    TCP Space %u, non-TCP Space %u\" \\\n                               \", maxPeriod %u, maxTime %u, maxHdr %u\",\n                               EXTRACT_16BITS(p+4),\n                               EXTRACT_16BITS(p+6),\n                               EXTRACT_16BITS(p+8),\n                               EXTRACT_16BITS(p+10),\n                               EXTRACT_16BITS(p+12)));\n\n                        /* suboptions present ? */\n                        if (len > IPCPOPT_IPCOMP_MINLEN) {\n                                ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN;\n                                p += IPCPOPT_IPCOMP_MINLEN;\n\n                                ND_PRINT((ndo, \"\\n\\t      Suboptions, length %u\", ipcomp_subopttotallen));\n\n                                while (ipcomp_subopttotallen >= 2) {\n                                        ND_TCHECK2(*p, 2);\n                                        ipcomp_subopt = *p;\n                                        ipcomp_suboptlen = *(p+1);\n\n                                        /* sanity check */\n                                        if (ipcomp_subopt == 0 ||\n                                            ipcomp_suboptlen == 0 )\n                                                break;\n\n                                        /* XXX: just display the suboptions for now */\n                                        ND_PRINT((ndo, \"\\n\\t\\t%s Suboption #%u, length %u\",\n                                               tok2str(ipcpopt_compproto_subopt_values,\n                                                       \"Unknown\",\n                                                       ipcomp_subopt),\n                                               ipcomp_subopt,\n                                               ipcomp_suboptlen));\n\n                                        ipcomp_subopttotallen -= ipcomp_suboptlen;\n                                        p += ipcomp_suboptlen;\n                                }\n                        }\n                        break;\n                default:\n                        break;\n\t\t}\n\t\tbreak;\n\n\tcase IPCPOPT_ADDR:     /* those options share the same format - fall through */\n\tcase IPCPOPT_MOBILE4:\n\tcase IPCPOPT_PRIDNS:\n\tcase IPCPOPT_PRINBNS:\n\tcase IPCPOPT_SECDNS:\n\tcase IPCPOPT_SECNBNS:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 4);\n\t\tND_PRINT((ndo, \": %s\", ipaddr_string(ndo, p + 2)));\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ipcp]\"));\n\treturn 0;\n}\n\n/* IP6CP config options */\nstatic int\nprint_ip6cp_config_options(netdissect_options *ndo,\n                           const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t       tok2str(ip6cpopt_values,\"unknown\",opt),\n\t\t       opt,\n\t\t       len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t       tok2str(ip6cpopt_values,\"unknown\",opt),\n\t       opt,\n\t       len));\n\n\tswitch (opt) {\n\tcase IP6CP_IFID:\n\t\tif (len != 10) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 10)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 8);\n\t\tND_PRINT((ndo, \": %04x:%04x:%04x:%04x\",\n\t\t       EXTRACT_16BITS(p + 2),\n\t\t       EXTRACT_16BITS(p + 4),\n\t\t       EXTRACT_16BITS(p + 6),\n\t\t       EXTRACT_16BITS(p + 8)));\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ip6cp]\"));\n\treturn 0;\n}\n\n\n/* CCP config options */\nstatic int\nprint_ccp_config_options(netdissect_options *ndo,\n                         const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(ccpconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(ccpconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\n\tswitch (opt) {\n\tcase CCPOPT_BSDCOMP:\n\t\tif (len < 3) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 3)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK(p[2]);\n\t\tND_PRINT((ndo, \": Version: %u, Dictionary Bits: %u\",\n\t\t\tp[2] >> 5, p[2] & 0x1f));\n\t\tbreak;\n\tcase CCPOPT_MVRCA:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK(p[3]);\n\t\tND_PRINT((ndo, \": Features: %u, PxP: %s, History: %u, #CTX-ID: %u\",\n\t\t\t\t(p[2] & 0xc0) >> 6,\n\t\t\t\t(p[2] & 0x20) ? \"Enabled\" : \"Disabled\",\n\t\t\t\tp[2] & 0x1f, p[3]));\n\t\tbreak;\n\tcase CCPOPT_DEFLATE:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK(p[3]);\n\t\tND_PRINT((ndo, \": Window: %uK, Method: %s (0x%x), MBZ: %u, CHK: %u\",\n\t\t\t(p[2] & 0xf0) >> 4,\n\t\t\t((p[2] & 0x0f) == 8) ? \"zlib\" : \"unknown\",\n\t\t\tp[2] & 0x0f, (p[3] & 0xfc) >> 2, p[3] & 0x03));\n\t\tbreak;\n\n/* XXX: to be supported */\n#if 0\n\tcase CCPOPT_OUI:\n\tcase CCPOPT_PRED1:\n\tcase CCPOPT_PRED2:\n\tcase CCPOPT_PJUMP:\n\tcase CCPOPT_HPPPC:\n\tcase CCPOPT_STACLZS:\n\tcase CCPOPT_MPPC:\n\tcase CCPOPT_GFZA:\n\tcase CCPOPT_V42BIS:\n\tcase CCPOPT_LZSDCP:\n\tcase CCPOPT_DEC:\n\tcase CCPOPT_RESV:\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ccp]\"));\n\treturn 0;\n}\n\n/* BACP config options */\nstatic int\nprint_bacp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\n\tswitch (opt) {\n\tcase BACPOPT_FPEER:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_32BITS(p + 2);\n\t\tND_PRINT((ndo, \": Magic-Num 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|bacp]\"));\n\treturn 0;\n}\n\nstatic void\nppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tint i, proto;\n\tconst void *se;\n\n        if (length <= 0)\n                return;\n\n\tb = (u_char *)malloc(length);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1 || !ND_TTEST(*s))\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}\n\n\n/* PPP */\nstatic void\nhandle_ppp(netdissect_options *ndo,\n           u_int proto, const u_char *p, int length)\n{\n\tif ((proto & 0xff00) == 0x7e00) { /* is this an escape code ? */\n\t\tppp_hdlc(ndo, p - 1, length);\n\t\treturn;\n\t}\n\n\tswitch (proto) {\n\tcase PPP_LCP: /* fall through */\n\tcase PPP_IPCP:\n\tcase PPP_OSICP:\n\tcase PPP_MPLSCP:\n\tcase PPP_IPV6CP:\n\tcase PPP_CCP:\n\tcase PPP_BACP:\n\t\thandle_ctrl_proto(ndo, proto, p, length);\n\t\tbreak;\n\tcase PPP_ML:\n\t\thandle_mlppp(ndo, p, length);\n\t\tbreak;\n\tcase PPP_CHAP:\n\t\thandle_chap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_PAP:\n\t\thandle_pap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_BAP:\t\t/* XXX: not yet completed */\n\t\thandle_bap(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IP:\t/*XXX*/\n        case PPP_VJNC:\n\tcase PPP_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\t/*XXX*/\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPX:\t/*XXX*/\n\tcase PPP_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_OSI:\n\t\tisoclns_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_COMP:\n\t\tND_PRINT((ndo, \"compressed PPP data\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto)));\n\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n\t\tbreak;\n\t}\n}\n\n/* Standard PPP printer */\nu_int\nppp_print(netdissect_options *ndo,\n          register const u_char *p, u_int length)\n{\n\tu_int proto,ppp_header;\n        u_int olen = length; /* _o_riginal length */\n\tu_int hdr_len = 0;\n\n\t/*\n\t * Here, we assume that p points to the Address and Control\n\t * field (if they present).\n\t */\n\tif (length < 2)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, 2);\n        ppp_header = EXTRACT_16BITS(p);\n\n        switch(ppp_header) {\n        case (PPP_WITHDIRECTION_IN  << 8 | PPP_CONTROL):\n            if (ndo->ndo_eflag) ND_PRINT((ndo, \"In  \"));\n            p += 2;\n            length -= 2;\n            hdr_len += 2;\n            break;\n        case (PPP_WITHDIRECTION_OUT << 8 | PPP_CONTROL):\n            if (ndo->ndo_eflag) ND_PRINT((ndo, \"Out \"));\n            p += 2;\n            length -= 2;\n            hdr_len += 2;\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL):\n            p += 2;\t\t\t/* ACFC not used */\n            length -= 2;\n            hdr_len += 2;\n            break;\n\n        default:\n            break;\n        }\n\n\tif (length < 2)\n\t\tgoto trunc;\n\tND_TCHECK(*p);\n\tif (*p % 2) {\n\t\tproto = *p;\t\t/* PFC is used */\n\t\tp++;\n\t\tlength--;\n\t\thdr_len++;\n\t} else {\n\t\tND_TCHECK2(*p, 2);\n\t\tproto = EXTRACT_16BITS(p);\n\t\tp += 2;\n\t\tlength -= 2;\n\t\thdr_len += 2;\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%s (0x%04x), length %u: \",\n\t\t          tok2str(ppptype2str, \"unknown\", proto),\n\t\t          proto,\n\t\t          olen));\n\n\thandle_ppp(ndo, proto, p, length);\n\treturn (hdr_len);\ntrunc:\n\tND_PRINT((ndo, \"[|ppp]\"));\n\treturn (0);\n}\n\n\n/* PPP I/F printer */\nu_int\nppp_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\n\tif (caplen < PPP_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\treturn (caplen);\n\t}\n\n#if 0\n\t/*\n\t * XXX: seems to assume that there are 2 octets prepended to an\n\t * actual PPP frame. The 1st octet looks like Input/Output flag\n\t * while 2nd octet is unknown, at least to me\n\t * (mshindo@mshindo.net).\n\t *\n\t * That was what the original tcpdump code did.\n\t *\n\t * FreeBSD's \"if_ppp.c\" *does* set the first octet to 1 for outbound\n\t * packets and 0 for inbound packets - but only if the\n\t * protocol field has the 0x8000 bit set (i.e., it's a network\n\t * control protocol); it does so before running the packet through\n\t * \"bpf_filter\" to see if it should be discarded, and to see\n\t * if we should update the time we sent the most recent packet...\n\t *\n\t * ...but it puts the original address field back after doing\n\t * so.\n\t *\n\t * NetBSD's \"if_ppp.c\" doesn't set the first octet in that fashion.\n\t *\n\t * I don't know if any PPP implementation handed up to a BPF\n\t * device packets with the first octet being 1 for outbound and\n\t * 0 for inbound packets, so I (guy@alum.mit.edu) don't know\n\t * whether that ever needs to be checked or not.\n\t *\n\t * Note that NetBSD has a DLT_PPP_SERIAL, which it uses for PPP,\n\t * and its tcpdump appears to assume that the frame always\n\t * begins with an address field and a control field, and that\n\t * the address field might be 0x0f or 0x8f, for Cisco\n\t * point-to-point with HDLC framing as per section 4.3.1 of RFC\n\t * 1547, as well as 0xff, for PPP in HDLC-like framing as per\n\t * RFC 1662.\n\t *\n\t * (Is the Cisco framing in question what DLT_C_HDLC, in\n\t * BSD/OS, is?)\n\t */\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%c %4d %02x \", p[0] ? 'O' : 'I', length, p[1]));\n#endif\n\n\tppp_print(ndo, p, length);\n\n\treturn (0);\n}\n\n/*\n * PPP I/F printer to use if we know that RFC 1662-style PPP in HDLC-like\n * framing, or Cisco PPP with HDLC framing as per section 4.3.1 of RFC 1547,\n * is being used (i.e., we don't check for PPP_ADDRESS and PPP_CONTROL,\n * discard them *if* those are the first two octets, and parse the remaining\n * packet as a PPP packet, as \"ppp_print()\" does).\n *\n * This handles, for example, DLT_PPP_SERIAL in NetBSD.\n */\nu_int\nppp_hdlc_if_print(netdissect_options *ndo,\n                  const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tu_int proto;\n\tu_int hdrlen = 0;\n\n\tif (caplen < 2) {\n\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\treturn (caplen);\n\t}\n\n\tswitch (p[0]) {\n\n\tcase PPP_ADDRESS:\n\t\tif (caplen < 4) {\n\t\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\t\treturn (caplen);\n\t\t}\n\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x %02x %d \", p[0], p[1], length));\n\t\tp += 2;\n\t\tlength -= 2;\n\t\thdrlen += 2;\n\n\t\tproto = EXTRACT_16BITS(p);\n\t\tp += 2;\n\t\tlength -= 2;\n\t\thdrlen += 2;\n\t\tND_PRINT((ndo, \"%s: \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto)));\n\n\t\thandle_ppp(ndo, proto, p, length);\n\t\tbreak;\n\n\tcase CHDLC_UNICAST:\n\tcase CHDLC_BCAST:\n\t\treturn (chdlc_if_print(ndo, h, p));\n\n\tdefault:\n\t\tif (caplen < 4) {\n\t\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\t\treturn (caplen);\n\t\t}\n\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x %02x %d \", p[0], p[1], length));\n\t\tp += 2;\n\t\thdrlen += 2;\n\n\t\t/*\n\t\t * XXX - NetBSD's \"ppp_netbsd_serial_if_print()\" treats\n\t\t * the next two octets as an Ethernet type; does that\n\t\t * ever happen?\n\t\t */\n\t\tND_PRINT((ndo, \"unknown addr %02x; ctrl %02x\", p[0], p[1]));\n\t\tbreak;\n\t}\n\n\treturn (hdrlen);\n}\n\n#define PPP_BSDI_HDRLEN 24\n\n/* BSD/OS specific PPP printer */\nu_int\nppp_bsdos_if_print(netdissect_options *ndo _U_,\n                   const struct pcap_pkthdr *h _U_, register const u_char *p _U_)\n{\n\tregister int hdrlength;\n#ifdef __bsdi__\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tuint16_t ptype;\n\tconst u_char *q;\n\tint i;\n\n\tif (caplen < PPP_BSDI_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\treturn (caplen)\n\t}\n\n\thdrlength = 0;\n\n#if 0\n\tif (p[0] == PPP_ADDRESS && p[1] == PPP_CONTROL) {\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x %02x \", p[0], p[1]));\n\t\tp += 2;\n\t\thdrlength = 2;\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%d \", length));\n\t/* Retrieve the protocol type */\n\tif (*p & 01) {\n\t\t/* Compressed protocol field */\n\t\tptype = *p;\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x \", ptype));\n\t\tp++;\n\t\thdrlength += 1;\n\t} else {\n\t\t/* Un-compressed protocol field */\n\t\tptype = EXTRACT_16BITS(p);\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%04x \", ptype));\n\t\tp += 2;\n\t\thdrlength += 2;\n\t}\n#else\n\tptype = 0;\t/*XXX*/\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%c \", p[SLC_DIR] ? 'O' : 'I'));\n\tif (p[SLC_LLHL]) {\n\t\t/* link level header */\n\t\tstruct ppp_header *ph;\n\n\t\tq = p + SLC_BPFHDRLEN;\n\t\tph = (struct ppp_header *)q;\n\t\tif (ph->phdr_addr == PPP_ADDRESS\n\t\t && ph->phdr_ctl == PPP_CONTROL) {\n\t\t\tif (ndo->ndo_eflag)\n\t\t\t\tND_PRINT((ndo, \"%02x %02x \", q[0], q[1]));\n\t\t\tptype = EXTRACT_16BITS(&ph->phdr_type);\n\t\t\tif (ndo->ndo_eflag && (ptype == PPP_VJC || ptype == PPP_VJNC)) {\n\t\t\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str,\n\t\t\t\t\t\t\"proto-#%d\", ptype)));\n\t\t\t}\n\t\t} else {\n\t\t\tif (ndo->ndo_eflag) {\n\t\t\t\tND_PRINT((ndo, \"LLH=[\"));\n\t\t\t\tfor (i = 0; i < p[SLC_LLHL]; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", q[i]));\n\t\t\t\tND_PRINT((ndo, \"] \"));\n\t\t\t}\n\t\t}\n\t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%d \", length));\n\tif (p[SLC_CHL]) {\n\t\tq = p + SLC_BPFHDRLEN + p[SLC_LLHL];\n\n\t\tswitch (ptype) {\n\t\tcase PPP_VJC:\n\t\t\tptype = vjc_print(ndo, q, ptype);\n\t\t\thdrlength = PPP_BSDI_HDRLEN;\n\t\t\tp += hdrlength;\n\t\t\tswitch (ptype) {\n\t\t\tcase PPP_IP:\n\t\t\t\tip_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPV6:\n\t\t\t\tip6_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_MPLS_UCAST:\n\t\t\tcase PPP_MPLS_MCAST:\n\t\t\t\tmpls_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto printx;\n\t\tcase PPP_VJNC:\n\t\t\tptype = vjc_print(ndo, q, ptype);\n\t\t\thdrlength = PPP_BSDI_HDRLEN;\n\t\t\tp += hdrlength;\n\t\t\tswitch (ptype) {\n\t\t\tcase PPP_IP:\n\t\t\t\tip_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPV6:\n\t\t\t\tip6_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_MPLS_UCAST:\n\t\t\tcase PPP_MPLS_MCAST:\n\t\t\t\tmpls_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto printx;\n\t\tdefault:\n\t\t\tif (ndo->ndo_eflag) {\n\t\t\t\tND_PRINT((ndo, \"CH=[\"));\n\t\t\t\tfor (i = 0; i < p[SLC_LLHL]; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", q[i]));\n\t\t\t\tND_PRINT((ndo, \"] \"));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thdrlength = PPP_BSDI_HDRLEN;\n#endif\n\n\tlength -= hdrlength;\n\tp += hdrlength;\n\n\tswitch (ptype) {\n\tcase PPP_IP:\n\t\tip_print(p, length);\n\t\tbreak;\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", ptype)));\n\t}\n\nprintx:\n#else /* __bsdi */\n\thdrlength = 0;\n#endif /* __bsdi__ */\n\treturn (hdrlength);\n}\n\n\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 8\n * End:\n */\n"], "fixing_code": ["/*\n * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * Extensively modified by Motonori Shindo (mshindo@mshindo.net) for more\n * complete PPP support.\n */\n\n/* \\summary: Point to Point Protocol (PPP) printer */\n\n/*\n * TODO:\n * o resolve XXX as much as possible\n * o MP support\n * o BAP support\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#ifdef __bsdi__\n#include <net/slcompress.h>\n#include <net/if_ppp.h>\n#endif\n\n#include <stdlib.h>\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"addrtoname.h\"\n#include \"ppp.h\"\n#include \"chdlc.h\"\n#include \"ethertype.h\"\n#include \"oui.h\"\n\n/*\n * The following constatns are defined by IANA. Please refer to\n *    http://www.isi.edu/in-notes/iana/assignments/ppp-numbers\n * for the up-to-date information.\n */\n\n/* Protocol Codes defined in ppp.h */\n\nstatic const struct tok ppptype2str[] = {\n        { PPP_IP,\t  \"IP\" },\n        { PPP_OSI,\t  \"OSI\" },\n        { PPP_NS,\t  \"NS\" },\n        { PPP_DECNET,\t  \"DECNET\" },\n        { PPP_APPLE,\t  \"APPLE\" },\n\t{ PPP_IPX,\t  \"IPX\" },\n\t{ PPP_VJC,\t  \"VJC IP\" },\n\t{ PPP_VJNC,\t  \"VJNC IP\" },\n\t{ PPP_BRPDU,\t  \"BRPDU\" },\n\t{ PPP_STII,\t  \"STII\" },\n\t{ PPP_VINES,\t  \"VINES\" },\n\t{ PPP_MPLS_UCAST, \"MPLS\" },\n\t{ PPP_MPLS_MCAST, \"MPLS\" },\n        { PPP_COMP,       \"Compressed\"},\n        { PPP_ML,         \"MLPPP\"},\n        { PPP_IPV6,       \"IP6\"},\n\n\t{ PPP_HELLO,\t  \"HELLO\" },\n\t{ PPP_LUXCOM,\t  \"LUXCOM\" },\n\t{ PPP_SNS,\t  \"SNS\" },\n\t{ PPP_IPCP,\t  \"IPCP\" },\n\t{ PPP_OSICP,\t  \"OSICP\" },\n\t{ PPP_NSCP,\t  \"NSCP\" },\n\t{ PPP_DECNETCP,   \"DECNETCP\" },\n\t{ PPP_APPLECP,\t  \"APPLECP\" },\n\t{ PPP_IPXCP,\t  \"IPXCP\" },\n\t{ PPP_STIICP,\t  \"STIICP\" },\n\t{ PPP_VINESCP,\t  \"VINESCP\" },\n        { PPP_IPV6CP,     \"IP6CP\" },\n\t{ PPP_MPLSCP,\t  \"MPLSCP\" },\n\n\t{ PPP_LCP,\t  \"LCP\" },\n\t{ PPP_PAP,\t  \"PAP\" },\n\t{ PPP_LQM,\t  \"LQM\" },\n\t{ PPP_CHAP,\t  \"CHAP\" },\n\t{ PPP_EAP,\t  \"EAP\" },\n\t{ PPP_SPAP,\t  \"SPAP\" },\n\t{ PPP_SPAP_OLD,\t  \"Old-SPAP\" },\n\t{ PPP_BACP,\t  \"BACP\" },\n\t{ PPP_BAP,\t  \"BAP\" },\n\t{ PPP_MPCP,\t  \"MLPPP-CP\" },\n\t{ PPP_CCP,\t  \"CCP\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* Control Protocols (LCP/IPCP/CCP etc.) Codes defined in RFC 1661 */\n\n#define CPCODES_VEXT\t\t0\t/* Vendor-Specific (RFC2153) */\n#define CPCODES_CONF_REQ\t1\t/* Configure-Request */\n#define CPCODES_CONF_ACK\t2\t/* Configure-Ack */\n#define CPCODES_CONF_NAK\t3\t/* Configure-Nak */\n#define CPCODES_CONF_REJ\t4\t/* Configure-Reject */\n#define CPCODES_TERM_REQ\t5\t/* Terminate-Request */\n#define CPCODES_TERM_ACK\t6\t/* Terminate-Ack */\n#define CPCODES_CODE_REJ\t7\t/* Code-Reject */\n#define CPCODES_PROT_REJ\t8\t/* Protocol-Reject (LCP only) */\n#define CPCODES_ECHO_REQ\t9\t/* Echo-Request (LCP only) */\n#define CPCODES_ECHO_RPL\t10\t/* Echo-Reply (LCP only) */\n#define CPCODES_DISC_REQ\t11\t/* Discard-Request (LCP only) */\n#define CPCODES_ID\t\t12\t/* Identification (LCP only) RFC1570 */\n#define CPCODES_TIME_REM\t13\t/* Time-Remaining (LCP only) RFC1570 */\n#define CPCODES_RESET_REQ\t14\t/* Reset-Request (CCP only) RFC1962 */\n#define CPCODES_RESET_REP\t15\t/* Reset-Reply (CCP only) */\n\nstatic const struct tok cpcodes[] = {\n\t{CPCODES_VEXT,      \"Vendor-Extension\"}, /* RFC2153 */\n\t{CPCODES_CONF_REQ,  \"Conf-Request\"},\n        {CPCODES_CONF_ACK,  \"Conf-Ack\"},\n\t{CPCODES_CONF_NAK,  \"Conf-Nack\"},\n\t{CPCODES_CONF_REJ,  \"Conf-Reject\"},\n\t{CPCODES_TERM_REQ,  \"Term-Request\"},\n\t{CPCODES_TERM_ACK,  \"Term-Ack\"},\n\t{CPCODES_CODE_REJ,  \"Code-Reject\"},\n\t{CPCODES_PROT_REJ,  \"Prot-Reject\"},\n\t{CPCODES_ECHO_REQ,  \"Echo-Request\"},\n\t{CPCODES_ECHO_RPL,  \"Echo-Reply\"},\n\t{CPCODES_DISC_REQ,  \"Disc-Req\"},\n\t{CPCODES_ID,        \"Ident\"},            /* RFC1570 */\n\t{CPCODES_TIME_REM,  \"Time-Rem\"},         /* RFC1570 */\n\t{CPCODES_RESET_REQ, \"Reset-Req\"},        /* RFC1962 */\n\t{CPCODES_RESET_REP, \"Reset-Ack\"},        /* RFC1962 */\n        {0,                 NULL}\n};\n\n/* LCP Config Options */\n\n#define LCPOPT_VEXT\t0\n#define LCPOPT_MRU\t1\n#define LCPOPT_ACCM\t2\n#define LCPOPT_AP\t3\n#define LCPOPT_QP\t4\n#define LCPOPT_MN\t5\n#define LCPOPT_DEP6\t6\n#define LCPOPT_PFC\t7\n#define LCPOPT_ACFC\t8\n#define LCPOPT_FCSALT\t9\n#define LCPOPT_SDP\t10\n#define LCPOPT_NUMMODE\t11\n#define LCPOPT_DEP12\t12\n#define LCPOPT_CBACK\t13\n#define LCPOPT_DEP14\t14\n#define LCPOPT_DEP15\t15\n#define LCPOPT_DEP16\t16\n#define LCPOPT_MLMRRU\t17\n#define LCPOPT_MLSSNHF\t18\n#define LCPOPT_MLED\t19\n#define LCPOPT_PROP\t20\n#define LCPOPT_DCEID\t21\n#define LCPOPT_MPP\t22\n#define LCPOPT_LD\t23\n#define LCPOPT_LCPAOPT\t24\n#define LCPOPT_COBS\t25\n#define LCPOPT_PE\t26\n#define LCPOPT_MLHF\t27\n#define LCPOPT_I18N\t28\n#define LCPOPT_SDLOS\t29\n#define LCPOPT_PPPMUX\t30\n\n#define LCPOPT_MIN LCPOPT_VEXT\n#define LCPOPT_MAX LCPOPT_PPPMUX\n\nstatic const char *lcpconfopts[] = {\n\t\"Vend-Ext\",\t\t/* (0) */\n\t\"MRU\",\t\t\t/* (1) */\n\t\"ACCM\",\t\t\t/* (2) */\n\t\"Auth-Prot\",\t\t/* (3) */\n\t\"Qual-Prot\",\t\t/* (4) */\n\t\"Magic-Num\",\t\t/* (5) */\n\t\"deprecated(6)\",\t/* used to be a Quality Protocol */\n\t\"PFC\",\t\t\t/* (7) */\n\t\"ACFC\",\t\t\t/* (8) */\n\t\"FCS-Alt\",\t\t/* (9) */\n\t\"SDP\",\t\t\t/* (10) */\n\t\"Num-Mode\",\t\t/* (11) */\n\t\"deprecated(12)\",\t/* used to be a Multi-Link-Procedure*/\n\t\"Call-Back\",\t\t/* (13) */\n\t\"deprecated(14)\",\t/* used to be a Connect-Time */\n\t\"deprecated(15)\",\t/* used to be a Compund-Frames */\n\t\"deprecated(16)\",\t/* used to be a Nominal-Data-Encap */\n\t\"MRRU\",\t\t\t/* (17) */\n\t\"12-Bit seq #\",\t\t/* (18) */\n\t\"End-Disc\",\t\t/* (19) */\n\t\"Proprietary\",\t\t/* (20) */\n\t\"DCE-Id\",\t\t/* (21) */\n\t\"MP+\",\t\t\t/* (22) */\n\t\"Link-Disc\",\t\t/* (23) */\n\t\"LCP-Auth-Opt\",\t\t/* (24) */\n\t\"COBS\",\t\t\t/* (25) */\n\t\"Prefix-elision\",\t/* (26) */\n\t\"Multilink-header-Form\",/* (27) */\n\t\"I18N\",\t\t\t/* (28) */\n\t\"SDL-over-SONET/SDH\",\t/* (29) */\n\t\"PPP-Muxing\",\t\t/* (30) */\n};\n\n/* ECP - to be supported */\n\n/* CCP Config Options */\n\n#define CCPOPT_OUI\t0\t/* RFC1962 */\n#define CCPOPT_PRED1\t1\t/* RFC1962 */\n#define CCPOPT_PRED2\t2\t/* RFC1962 */\n#define CCPOPT_PJUMP\t3\t/* RFC1962 */\n/* 4-15 unassigned */\n#define CCPOPT_HPPPC\t16\t/* RFC1962 */\n#define CCPOPT_STACLZS\t17\t/* RFC1974 */\n#define CCPOPT_MPPC\t18\t/* RFC2118 */\n#define CCPOPT_GFZA\t19\t/* RFC1962 */\n#define CCPOPT_V42BIS\t20\t/* RFC1962 */\n#define CCPOPT_BSDCOMP\t21\t/* RFC1977 */\n/* 22 unassigned */\n#define CCPOPT_LZSDCP\t23\t/* RFC1967 */\n#define CCPOPT_MVRCA\t24\t/* RFC1975 */\n#define CCPOPT_DEC\t25\t/* RFC1976 */\n#define CCPOPT_DEFLATE\t26\t/* RFC1979 */\n/* 27-254 unassigned */\n#define CCPOPT_RESV\t255\t/* RFC1962 */\n\nstatic const struct tok ccpconfopts_values[] = {\n        { CCPOPT_OUI, \"OUI\" },\n        { CCPOPT_PRED1, \"Pred-1\" },\n        { CCPOPT_PRED2, \"Pred-2\" },\n        { CCPOPT_PJUMP, \"Puddle\" },\n        { CCPOPT_HPPPC, \"HP-PPC\" },\n        { CCPOPT_STACLZS, \"Stac-LZS\" },\n        { CCPOPT_MPPC, \"MPPC\" },\n        { CCPOPT_GFZA, \"Gand-FZA\" },\n        { CCPOPT_V42BIS, \"V.42bis\" },\n        { CCPOPT_BSDCOMP, \"BSD-Comp\" },\n        { CCPOPT_LZSDCP, \"LZS-DCP\" },\n        { CCPOPT_MVRCA, \"MVRCA\" },\n        { CCPOPT_DEC, \"DEC\" },\n        { CCPOPT_DEFLATE, \"Deflate\" },\n        { CCPOPT_RESV, \"Reserved\"},\n        {0,                 NULL}\n};\n\n/* BACP Config Options */\n\n#define BACPOPT_FPEER\t1\t/* RFC2125 */\n\nstatic const struct tok bacconfopts_values[] = {\n        { BACPOPT_FPEER, \"Favored-Peer\" },\n        {0,                 NULL}\n};\n\n\n/* SDCP - to be supported */\n\n/* IPCP Config Options */\n#define IPCPOPT_2ADDR\t1\t/* RFC1172, RFC1332 (deprecated) */\n#define IPCPOPT_IPCOMP\t2\t/* RFC1332 */\n#define IPCPOPT_ADDR\t3\t/* RFC1332 */\n#define IPCPOPT_MOBILE4\t4\t/* RFC2290 */\n#define IPCPOPT_PRIDNS\t129\t/* RFC1877 */\n#define IPCPOPT_PRINBNS\t130\t/* RFC1877 */\n#define IPCPOPT_SECDNS\t131\t/* RFC1877 */\n#define IPCPOPT_SECNBNS\t132\t/* RFC1877 */\n\nstatic const struct tok ipcpopt_values[] = {\n        { IPCPOPT_2ADDR, \"IP-Addrs\" },\n        { IPCPOPT_IPCOMP, \"IP-Comp\" },\n        { IPCPOPT_ADDR, \"IP-Addr\" },\n        { IPCPOPT_MOBILE4, \"Home-Addr\" },\n        { IPCPOPT_PRIDNS, \"Pri-DNS\" },\n        { IPCPOPT_PRINBNS, \"Pri-NBNS\" },\n        { IPCPOPT_SECDNS, \"Sec-DNS\" },\n        { IPCPOPT_SECNBNS, \"Sec-NBNS\" },\n\t{ 0,\t\t  NULL }\n};\n\n#define IPCPOPT_IPCOMP_HDRCOMP 0x61  /* rfc3544 */\n#define IPCPOPT_IPCOMP_MINLEN    14\n\nstatic const struct tok ipcpopt_compproto_values[] = {\n        { PPP_VJC, \"VJ-Comp\" },\n        { IPCPOPT_IPCOMP_HDRCOMP, \"IP Header Compression\" },\n\t{ 0,\t\t  NULL }\n};\n\nstatic const struct tok ipcpopt_compproto_subopt_values[] = {\n        { 1, \"RTP-Compression\" },\n        { 2, \"Enhanced RTP-Compression\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* IP6CP Config Options */\n#define IP6CP_IFID      1\n\nstatic const struct tok ip6cpopt_values[] = {\n        { IP6CP_IFID, \"Interface-ID\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* ATCP - to be supported */\n/* OSINLCP - to be supported */\n/* BVCP - to be supported */\n/* BCP - to be supported */\n/* IPXCP - to be supported */\n/* MPLSCP - to be supported */\n\n/* Auth Algorithms */\n\n/* 0-4 Reserved (RFC1994) */\n#define AUTHALG_CHAPMD5\t5\t/* RFC1994 */\n#define AUTHALG_MSCHAP1\t128\t/* RFC2433 */\n#define AUTHALG_MSCHAP2\t129\t/* RFC2795 */\n\nstatic const struct tok authalg_values[] = {\n        { AUTHALG_CHAPMD5, \"MD5\" },\n        { AUTHALG_MSCHAP1, \"MS-CHAPv1\" },\n        { AUTHALG_MSCHAP2, \"MS-CHAPv2\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* FCS Alternatives - to be supported */\n\n/* Multilink Endpoint Discriminator (RFC1717) */\n#define MEDCLASS_NULL\t0\t/* Null Class */\n#define MEDCLASS_LOCAL\t1\t/* Locally Assigned */\n#define MEDCLASS_IPV4\t2\t/* Internet Protocol (IPv4) */\n#define MEDCLASS_MAC\t3\t/* IEEE 802.1 global MAC address */\n#define MEDCLASS_MNB\t4\t/* PPP Magic Number Block */\n#define MEDCLASS_PSNDN\t5\t/* Public Switched Network Director Number */\n\n/* PPP LCP Callback */\n#define CALLBACK_AUTH\t0\t/* Location determined by user auth */\n#define CALLBACK_DSTR\t1\t/* Dialing string */\n#define CALLBACK_LID\t2\t/* Location identifier */\n#define CALLBACK_E164\t3\t/* E.164 number */\n#define CALLBACK_X500\t4\t/* X.500 distinguished name */\n#define CALLBACK_CBCP\t6\t/* Location is determined during CBCP nego */\n\nstatic const struct tok ppp_callback_values[] = {\n        { CALLBACK_AUTH, \"UserAuth\" },\n        { CALLBACK_DSTR, \"DialString\" },\n        { CALLBACK_LID, \"LocalID\" },\n        { CALLBACK_E164, \"E.164\" },\n        { CALLBACK_X500, \"X.500\" },\n        { CALLBACK_CBCP, \"CBCP\" },\n\t{ 0,\t\t  NULL }\n};\n\n/* CHAP */\n\n#define CHAP_CHAL\t1\n#define CHAP_RESP\t2\n#define CHAP_SUCC\t3\n#define CHAP_FAIL\t4\n\nstatic const struct tok chapcode_values[] = {\n\t{ CHAP_CHAL, \"Challenge\" },\n\t{ CHAP_RESP, \"Response\" },\n\t{ CHAP_SUCC, \"Success\" },\n\t{ CHAP_FAIL, \"Fail\" },\n        { 0, NULL}\n};\n\n/* PAP */\n\n#define PAP_AREQ\t1\n#define PAP_AACK\t2\n#define PAP_ANAK\t3\n\nstatic const struct tok papcode_values[] = {\n        { PAP_AREQ, \"Auth-Req\" },\n        { PAP_AACK, \"Auth-ACK\" },\n        { PAP_ANAK, \"Auth-NACK\" },\n        { 0, NULL }\n};\n\n/* BAP */\n#define BAP_CALLREQ\t1\n#define BAP_CALLRES\t2\n#define BAP_CBREQ\t3\n#define BAP_CBRES\t4\n#define BAP_LDQREQ\t5\n#define BAP_LDQRES\t6\n#define BAP_CSIND\t7\n#define BAP_CSRES\t8\n\nstatic int print_lcp_config_options(netdissect_options *, const u_char *p, int);\nstatic int print_ipcp_config_options(netdissect_options *, const u_char *p, int);\nstatic int print_ip6cp_config_options(netdissect_options *, const u_char *p, int);\nstatic int print_ccp_config_options(netdissect_options *, const u_char *p, int);\nstatic int print_bacp_config_options(netdissect_options *, const u_char *p, int);\nstatic void handle_ppp(netdissect_options *, u_int proto, const u_char *p, int length);\n\n/* generic Control Protocol (e.g. LCP, IPCP, CCP, etc.) handler */\nstatic void\nhandle_ctrl_proto(netdissect_options *ndo,\n                  u_int proto, const u_char *pptr, int length)\n{\n\tconst char *typestr;\n\tu_int code, len;\n\tint (*pfunc)(netdissect_options *, const u_char *, int);\n\tint x, j;\n        const u_char *tptr;\n\n        tptr=pptr;\n\n        typestr = tok2str(ppptype2str, \"unknown ctrl-proto (0x%04x)\", proto);\n\tND_PRINT((ndo, \"%s, \", typestr));\n\n\tif (length < 4) /* FIXME weak boundary checking */\n\t\tgoto trunc;\n\tND_TCHECK2(*tptr, 2);\n\n\tcode = *tptr++;\n\n\tND_PRINT((ndo, \"%s (0x%02x), id %u, length %u\",\n\t          tok2str(cpcodes, \"Unknown Opcode\",code),\n\t          code,\n\t          *tptr++, /* ID */\n\t          length + 2));\n\n\tif (!ndo->ndo_vflag)\n\t\treturn;\n\n\tif (length <= 4)\n\t\treturn;    /* there may be a NULL confreq etc. */\n\n\tND_TCHECK2(*tptr, 2);\n\tlen = EXTRACT_16BITS(tptr);\n\ttptr += 2;\n\n\tND_PRINT((ndo, \"\\n\\tencoded length %u (=Option(s) length %u)\", len, len - 4));\n\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, pptr - 2, \"\\n\\t\", 6);\n\n\n\tswitch (code) {\n\tcase CPCODES_VEXT:\n\t\tif (length < 11)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 4);\n\t\tND_PRINT((ndo, \"\\n\\t  Magic-Num 0x%08x\", EXTRACT_32BITS(tptr)));\n\t\ttptr += 4;\n\t\tND_TCHECK2(*tptr, 3);\n\t\tND_PRINT((ndo, \" Vendor: %s (%u)\",\n                       tok2str(oui_values,\"Unknown\",EXTRACT_24BITS(tptr)),\n                       EXTRACT_24BITS(tptr)));\n\t\t/* XXX: need to decode Kind and Value(s)? */\n\t\tbreak;\n\tcase CPCODES_CONF_REQ:\n\tcase CPCODES_CONF_ACK:\n\tcase CPCODES_CONF_NAK:\n\tcase CPCODES_CONF_REJ:\n\t\tx = len - 4;\t/* Code(1), Identifier(1) and Length(2) */\n\t\tdo {\n\t\t\tswitch (proto) {\n\t\t\tcase PPP_LCP:\n\t\t\t\tpfunc = print_lcp_config_options;\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPCP:\n\t\t\t\tpfunc = print_ipcp_config_options;\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPV6CP:\n\t\t\t\tpfunc = print_ip6cp_config_options;\n\t\t\t\tbreak;\n\t\t\tcase PPP_CCP:\n\t\t\t\tpfunc = print_ccp_config_options;\n\t\t\t\tbreak;\n\t\t\tcase PPP_BACP:\n\t\t\t\tpfunc = print_bacp_config_options;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * No print routine for the options for\n\t\t\t\t * this protocol.\n\t\t\t\t */\n\t\t\t\tpfunc = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pfunc == NULL) /* catch the above null pointer if unknown CP */\n\t\t\t\tbreak;\n\n\t\t\tif ((j = (*pfunc)(ndo, tptr, len)) == 0)\n\t\t\t\tbreak;\n\t\t\tx -= j;\n\t\t\ttptr += j;\n\t\t} while (x > 0);\n\t\tbreak;\n\n\tcase CPCODES_TERM_REQ:\n\tcase CPCODES_TERM_ACK:\n\t\t/* XXX: need to decode Data? */\n\t\tbreak;\n\tcase CPCODES_CODE_REJ:\n\t\t/* XXX: need to decode Rejected-Packet? */\n\t\tbreak;\n\tcase CPCODES_PROT_REJ:\n\t\tif (length < 6)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 2);\n\t\tND_PRINT((ndo, \"\\n\\t  Rejected %s Protocol (0x%04x)\",\n\t\t       tok2str(ppptype2str,\"unknown\", EXTRACT_16BITS(tptr)),\n\t\t       EXTRACT_16BITS(tptr)));\n\t\t/* XXX: need to decode Rejected-Information? - hexdump for now */\n\t\tif (len > 6) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Rejected Packet\"));\n\t\t\tprint_unknown_data(ndo, tptr + 2, \"\\n\\t    \", len - 2);\n\t\t}\n\t\tbreak;\n\tcase CPCODES_ECHO_REQ:\n\tcase CPCODES_ECHO_RPL:\n\tcase CPCODES_DISC_REQ:\n\t\tif (length < 8)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 4);\n\t\tND_PRINT((ndo, \"\\n\\t  Magic-Num 0x%08x\", EXTRACT_32BITS(tptr)));\n\t\t/* XXX: need to decode Data? - hexdump for now */\n\t\tif (len > 8) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  -----trailing data-----\"));\n\t\t\tND_TCHECK2(tptr[4], len - 8);\n\t\t\tprint_unknown_data(ndo, tptr + 4, \"\\n\\t  \", len - 8);\n\t\t}\n\t\tbreak;\n\tcase CPCODES_ID:\n\t\tif (length < 8)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 4);\n\t\tND_PRINT((ndo, \"\\n\\t  Magic-Num 0x%08x\", EXTRACT_32BITS(tptr)));\n\t\t/* RFC 1661 says this is intended to be human readable */\n\t\tif (len > 8) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Message\\n\\t    \"));\n\t\t\tif (fn_printn(ndo, tptr + 4, len - 4, ndo->ndo_snapend))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tbreak;\n\tcase CPCODES_TIME_REM:\n\t\tif (length < 12)\n\t\t\tbreak;\n\t\tND_TCHECK2(*tptr, 4);\n\t\tND_PRINT((ndo, \"\\n\\t  Magic-Num 0x%08x\", EXTRACT_32BITS(tptr)));\n\t\tND_TCHECK2(*(tptr + 4), 4);\n\t\tND_PRINT((ndo, \", Seconds-Remaining %us\", EXTRACT_32BITS(tptr + 4)));\n\t\t/* XXX: need to decode Message? */\n\t\tbreak;\n\tdefault:\n\t\t/* XXX this is dirty but we do not get the\n\t\t * original pointer passed to the begin\n\t\t * the PPP packet */\n\t\tif (ndo->ndo_vflag <= 1)\n\t\t\tprint_unknown_data(ndo, pptr - 2, \"\\n\\t  \", length + 2);\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|%s]\", typestr));\n}\n\n/* LCP config options */\nstatic int\nprint_lcp_config_options(netdissect_options *ndo,\n                         const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tif ((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))\n\t\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t\t          lcpconfopts[opt], opt, len));\n\t\telse\n\t\t\tND_PRINT((ndo, \"\\n\\tunknown LCP option 0x%02x\", opt));\n\t\treturn 0;\n\t}\n\tif ((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\", lcpconfopts[opt], opt, len));\n\telse {\n\t\tND_PRINT((ndo, \"\\n\\tunknown LCP option 0x%02x\", opt));\n\t\treturn len;\n\t}\n\n\tswitch (opt) {\n\tcase LCPOPT_VEXT:\n\t\tif (len < 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_24BITS(p + 2);\n\t\tND_PRINT((ndo, \": Vendor: %s (%u)\",\n\t\t\ttok2str(oui_values,\"Unknown\",EXTRACT_24BITS(p+2)),\n\t\t\tEXTRACT_24BITS(p + 2)));\n#if 0\n\t\tND_TCHECK(p[5]);\n\t\tND_PRINT((ndo, \", kind: 0x%02x\", p[5]));\n\t\tND_PRINT((ndo, \", Value: 0x\"));\n\t\tfor (i = 0; i < len - 6; i++) {\n\t\t\tND_TCHECK(p[6 + i]);\n\t\t\tND_PRINT((ndo, \"%02x\", p[6 + i]));\n\t\t}\n#endif\n\t\tbreak;\n\tcase LCPOPT_MRU:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_16BITS(p + 2);\n\t\tND_PRINT((ndo, \": %u\", EXTRACT_16BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_ACCM:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_32BITS(p + 2);\n\t\tND_PRINT((ndo, \": 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_AP:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_16BITS(p + 2);\n\t\tND_PRINT((ndo, \": %s\", tok2str(ppptype2str, \"Unknown Auth Proto (0x04x)\", EXTRACT_16BITS(p + 2))));\n\n\t\tswitch (EXTRACT_16BITS(p+2)) {\n\t\tcase PPP_CHAP:\n\t\t\tND_TCHECK(p[4]);\n\t\t\tND_PRINT((ndo, \", %s\", tok2str(authalg_values, \"Unknown Auth Alg %u\", p[4])));\n\t\t\tbreak;\n\t\tcase PPP_PAP: /* fall through */\n\t\tcase PPP_EAP:\n\t\tcase PPP_SPAP:\n\t\tcase PPP_SPAP_OLD:\n                        break;\n\t\tdefault:\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", len);\n\t\t}\n\t\tbreak;\n\tcase LCPOPT_QP:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_16BITS(p+2);\n\t\tif (EXTRACT_16BITS(p+2) == PPP_LQM)\n\t\t\tND_PRINT((ndo, \": LQR\"));\n\t\telse\n\t\t\tND_PRINT((ndo, \": unknown\"));\n\t\tbreak;\n\tcase LCPOPT_MN:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_32BITS(p + 2);\n\t\tND_PRINT((ndo, \": 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_PFC:\n\t\tbreak;\n\tcase LCPOPT_ACFC:\n\t\tbreak;\n\tcase LCPOPT_LD:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_16BITS(p + 2);\n\t\tND_PRINT((ndo, \": 0x%04x\", EXTRACT_16BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_CBACK:\n\t\tif (len < 3) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 3)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_PRINT((ndo, \": \"));\n\t\tND_TCHECK(p[2]);\n\t\tND_PRINT((ndo, \": Callback Operation %s (%u)\",\n                       tok2str(ppp_callback_values, \"Unknown\", p[2]),\n                       p[2]));\n\t\tbreak;\n\tcase LCPOPT_MLMRRU:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_16BITS(p + 2);\n\t\tND_PRINT((ndo, \": %u\", EXTRACT_16BITS(p + 2)));\n\t\tbreak;\n\tcase LCPOPT_MLED:\n\t\tif (len < 3) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 3)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK(p[2]);\n\t\tswitch (p[2]) {\t\t/* class */\n\t\tcase MEDCLASS_NULL:\n\t\t\tND_PRINT((ndo, \": Null\"));\n\t\t\tbreak;\n\t\tcase MEDCLASS_LOCAL:\n\t\t\tND_PRINT((ndo, \": Local\")); /* XXX */\n\t\t\tbreak;\n\t\tcase MEDCLASS_IPV4:\n\t\t\tif (len != 7) {\n\t\t\t\tND_PRINT((ndo, \" (length bogus, should be = 7)\"));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tND_TCHECK2(*(p + 3), 4);\n\t\t\tND_PRINT((ndo, \": IPv4 %s\", ipaddr_string(ndo, p + 3)));\n\t\t\tbreak;\n\t\tcase MEDCLASS_MAC:\n\t\t\tif (len != 9) {\n\t\t\t\tND_PRINT((ndo, \" (length bogus, should be = 9)\"));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tND_TCHECK2(*(p + 3), 6);\n\t\t\tND_PRINT((ndo, \": MAC %s\", etheraddr_string(ndo, p + 3)));\n\t\t\tbreak;\n\t\tcase MEDCLASS_MNB:\n\t\t\tND_PRINT((ndo, \": Magic-Num-Block\")); /* XXX */\n\t\t\tbreak;\n\t\tcase MEDCLASS_PSNDN:\n\t\t\tND_PRINT((ndo, \": PSNDN\")); /* XXX */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \": Unknown class %u\", p[2]));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n/* XXX: to be supported */\n#if 0\n\tcase LCPOPT_DEP6:\n\tcase LCPOPT_FCSALT:\n\tcase LCPOPT_SDP:\n\tcase LCPOPT_NUMMODE:\n\tcase LCPOPT_DEP12:\n\tcase LCPOPT_DEP14:\n\tcase LCPOPT_DEP15:\n\tcase LCPOPT_DEP16:\n        case LCPOPT_MLSSNHF:\n\tcase LCPOPT_PROP:\n\tcase LCPOPT_DCEID:\n\tcase LCPOPT_MPP:\n\tcase LCPOPT_LCPAOPT:\n\tcase LCPOPT_COBS:\n\tcase LCPOPT_PE:\n\tcase LCPOPT_MLHF:\n\tcase LCPOPT_I18N:\n\tcase LCPOPT_SDLOS:\n\tcase LCPOPT_PPPMUX:\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|lcp]\"));\n\treturn 0;\n}\n\n/* ML-PPP*/\nstatic const struct tok ppp_ml_flag_values[] = {\n    { 0x80, \"begin\" },\n    { 0x40, \"end\" },\n    { 0, NULL }\n};\n\nstatic void\nhandle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n\n    if (length < 2) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    if (!ND_TTEST_16BITS(p)) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}\n\n/* CHAP */\nstatic void\nhandle_chap(netdissect_options *ndo,\n            const u_char *p, int length)\n{\n\tu_int code, len;\n\tint val_size, name_size, msg_size;\n\tconst u_char *p0;\n\tint i;\n\n\tp0 = p;\n\tif (length < 1) {\n\t\tND_PRINT((ndo, \"[|chap]\"));\n\t\treturn;\n\t} else if (length < 4) {\n\t\tND_TCHECK(*p);\n\t\tND_PRINT((ndo, \"[|chap 0x%02x]\", *p));\n\t\treturn;\n\t}\n\n\tND_TCHECK(*p);\n\tcode = *p;\n\tND_PRINT((ndo, \"CHAP, %s (0x%02x)\",\n               tok2str(chapcode_values,\"unknown\",code),\n               code));\n\tp++;\n\n\tND_TCHECK(*p);\n\tND_PRINT((ndo, \", id %u\", *p));\t\t/* ID */\n\tp++;\n\n\tND_TCHECK2(*p, 2);\n\tlen = EXTRACT_16BITS(p);\n\tp += 2;\n\n\t/*\n\t * Note that this is a generic CHAP decoding routine. Since we\n\t * don't know which flavor of CHAP (i.e. CHAP-MD5, MS-CHAPv1,\n\t * MS-CHAPv2) is used at this point, we can't decode packet\n\t * specifically to each algorithms. Instead, we simply decode\n\t * the GCD (Gratest Common Denominator) for all algorithms.\n\t */\n\tswitch (code) {\n\tcase CHAP_CHAL:\n\tcase CHAP_RESP:\n\t\tif (length - (p - p0) < 1)\n\t\t\treturn;\n\t\tND_TCHECK(*p);\n\t\tval_size = *p;\t\t/* value size */\n\t\tp++;\n\t\tif (length - (p - p0) < val_size)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \", Value \"));\n\t\tfor (i = 0; i < val_size; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tND_PRINT((ndo, \"%02x\", *p++));\n\t\t}\n\t\tname_size = len - (p - p0);\n\t\tND_PRINT((ndo, \", Name \"));\n\t\tfor (i = 0; i < name_size; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\t\tbreak;\n\tcase CHAP_SUCC:\n\tcase CHAP_FAIL:\n\t\tmsg_size = len - (p - p0);\n\t\tND_PRINT((ndo, \", Msg \"));\n\t\tfor (i = 0; i< msg_size; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|chap]\"));\n}\n\n/* PAP (see RFC 1334) */\nstatic void\nhandle_pap(netdissect_options *ndo,\n           const u_char *p, int length)\n{\n\tu_int code, len;\n\tint peerid_len, passwd_len, msg_len;\n\tconst u_char *p0;\n\tint i;\n\n\tp0 = p;\n\tif (length < 1) {\n\t\tND_PRINT((ndo, \"[|pap]\"));\n\t\treturn;\n\t} else if (length < 4) {\n\t\tND_TCHECK(*p);\n\t\tND_PRINT((ndo, \"[|pap 0x%02x]\", *p));\n\t\treturn;\n\t}\n\n\tND_TCHECK(*p);\n\tcode = *p;\n\tND_PRINT((ndo, \"PAP, %s (0x%02x)\",\n\t          tok2str(papcode_values, \"unknown\", code),\n\t          code));\n\tp++;\n\n\tND_TCHECK(*p);\n\tND_PRINT((ndo, \", id %u\", *p));\t\t/* ID */\n\tp++;\n\n\tND_TCHECK2(*p, 2);\n\tlen = EXTRACT_16BITS(p);\n\tp += 2;\n\n\tif ((int)len > length) {\n\t\tND_PRINT((ndo, \", length %u > packet size\", len));\n\t\treturn;\n\t}\n\tlength = len;\n\tif (length < (p - p0)) {\n\t\tND_PRINT((ndo, \", length %u < PAP header length\", length));\n\t\treturn;\n\t}\n\n\tswitch (code) {\n\tcase PAP_AREQ:\n\t\t/* A valid Authenticate-Request is 6 or more octets long. */\n\t\tif (len < 6)\n\t\t\tgoto trunc;\n\t\tif (length - (p - p0) < 1)\n\t\t\treturn;\n\t\tND_TCHECK(*p);\n\t\tpeerid_len = *p;\t/* Peer-ID Length */\n\t\tp++;\n\t\tif (length - (p - p0) < peerid_len)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \", Peer \"));\n\t\tfor (i = 0; i < peerid_len; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\n\t\tif (length - (p - p0) < 1)\n\t\t\treturn;\n\t\tND_TCHECK(*p);\n\t\tpasswd_len = *p;\t/* Password Length */\n\t\tp++;\n\t\tif (length - (p - p0) < passwd_len)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \", Name \"));\n\t\tfor (i = 0; i < passwd_len; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\t\tbreak;\n\tcase PAP_AACK:\n\tcase PAP_ANAK:\n\t\t/* Although some implementations ignore truncation at\n\t\t * this point and at least one generates a truncated\n\t\t * packet, RFC 1334 section 2.2.2 clearly states that\n\t\t * both AACK and ANAK are at least 5 bytes long.\n\t\t */\n\t\tif (len < 5)\n\t\t\tgoto trunc;\n\t\tif (length - (p - p0) < 1)\n\t\t\treturn;\n\t\tND_TCHECK(*p);\n\t\tmsg_len = *p;\t\t/* Msg-Length */\n\t\tp++;\n\t\tif (length - (p - p0) < msg_len)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \", Msg \"));\n\t\tfor (i = 0; i< msg_len; i++) {\n\t\t\tND_TCHECK(*p);\n\t\t\tsafeputchar(ndo, *p++);\n\t\t}\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pap]\"));\n}\n\n/* BAP */\nstatic void\nhandle_bap(netdissect_options *ndo _U_,\n           const u_char *p _U_, int length _U_)\n{\n\t/* XXX: to be supported!! */\n}\n\n\n/* IPCP config options */\nstatic int\nprint_ipcp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n        u_int compproto, ipcomp_subopttotallen, ipcomp_subopt, ipcomp_suboptlen;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t       tok2str(ipcpopt_values,\"unknown\",opt),\n\t\t       opt,\n\t\t       len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t       tok2str(ipcpopt_values,\"unknown\",opt),\n\t       opt,\n\t       len));\n\n\tswitch (opt) {\n\tcase IPCPOPT_2ADDR:\t\t/* deprecated */\n\t\tif (len != 10) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 10)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 6), 4);\n\t\tND_PRINT((ndo, \": src %s, dst %s\",\n\t\t       ipaddr_string(ndo, p + 2),\n\t\t       ipaddr_string(ndo, p + 6)));\n\t\tbreak;\n\tcase IPCPOPT_IPCOMP:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK_16BITS(p+2);\n\t\tcompproto = EXTRACT_16BITS(p+2);\n\n\t\tND_PRINT((ndo, \": %s (0x%02x):\",\n\t\t          tok2str(ipcpopt_compproto_values, \"Unknown\", compproto),\n\t\t          compproto));\n\n\t\tswitch (compproto) {\n                case PPP_VJC:\n\t\t\t/* XXX: VJ-Comp parameters should be decoded */\n                        break;\n                case IPCPOPT_IPCOMP_HDRCOMP:\n                        if (len < IPCPOPT_IPCOMP_MINLEN) {\n                        \tND_PRINT((ndo, \" (length bogus, should be >= %u)\",\n                        \t\tIPCPOPT_IPCOMP_MINLEN));\n                        \treturn 0;\n                        }\n\n                        ND_TCHECK2(*(p + 2), IPCPOPT_IPCOMP_MINLEN);\n                        ND_PRINT((ndo, \"\\n\\t    TCP Space %u, non-TCP Space %u\" \\\n                               \", maxPeriod %u, maxTime %u, maxHdr %u\",\n                               EXTRACT_16BITS(p+4),\n                               EXTRACT_16BITS(p+6),\n                               EXTRACT_16BITS(p+8),\n                               EXTRACT_16BITS(p+10),\n                               EXTRACT_16BITS(p+12)));\n\n                        /* suboptions present ? */\n                        if (len > IPCPOPT_IPCOMP_MINLEN) {\n                                ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN;\n                                p += IPCPOPT_IPCOMP_MINLEN;\n\n                                ND_PRINT((ndo, \"\\n\\t      Suboptions, length %u\", ipcomp_subopttotallen));\n\n                                while (ipcomp_subopttotallen >= 2) {\n                                        ND_TCHECK2(*p, 2);\n                                        ipcomp_subopt = *p;\n                                        ipcomp_suboptlen = *(p+1);\n\n                                        /* sanity check */\n                                        if (ipcomp_subopt == 0 ||\n                                            ipcomp_suboptlen == 0 )\n                                                break;\n\n                                        /* XXX: just display the suboptions for now */\n                                        ND_PRINT((ndo, \"\\n\\t\\t%s Suboption #%u, length %u\",\n                                               tok2str(ipcpopt_compproto_subopt_values,\n                                                       \"Unknown\",\n                                                       ipcomp_subopt),\n                                               ipcomp_subopt,\n                                               ipcomp_suboptlen));\n\n                                        ipcomp_subopttotallen -= ipcomp_suboptlen;\n                                        p += ipcomp_suboptlen;\n                                }\n                        }\n                        break;\n                default:\n                        break;\n\t\t}\n\t\tbreak;\n\n\tcase IPCPOPT_ADDR:     /* those options share the same format - fall through */\n\tcase IPCPOPT_MOBILE4:\n\tcase IPCPOPT_PRIDNS:\n\tcase IPCPOPT_PRINBNS:\n\tcase IPCPOPT_SECDNS:\n\tcase IPCPOPT_SECNBNS:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn 0;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 4);\n\t\tND_PRINT((ndo, \": %s\", ipaddr_string(ndo, p + 2)));\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ipcp]\"));\n\treturn 0;\n}\n\n/* IP6CP config options */\nstatic int\nprint_ip6cp_config_options(netdissect_options *ndo,\n                           const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t       tok2str(ip6cpopt_values,\"unknown\",opt),\n\t\t       opt,\n\t\t       len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t       tok2str(ip6cpopt_values,\"unknown\",opt),\n\t       opt,\n\t       len));\n\n\tswitch (opt) {\n\tcase IP6CP_IFID:\n\t\tif (len != 10) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 10)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 8);\n\t\tND_PRINT((ndo, \": %04x:%04x:%04x:%04x\",\n\t\t       EXTRACT_16BITS(p + 2),\n\t\t       EXTRACT_16BITS(p + 4),\n\t\t       EXTRACT_16BITS(p + 6),\n\t\t       EXTRACT_16BITS(p + 8)));\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ip6cp]\"));\n\treturn 0;\n}\n\n\n/* CCP config options */\nstatic int\nprint_ccp_config_options(netdissect_options *ndo,\n                         const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(ccpconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(ccpconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\n\tswitch (opt) {\n\tcase CCPOPT_BSDCOMP:\n\t\tif (len < 3) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 3)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK(p[2]);\n\t\tND_PRINT((ndo, \": Version: %u, Dictionary Bits: %u\",\n\t\t\tp[2] >> 5, p[2] & 0x1f));\n\t\tbreak;\n\tcase CCPOPT_MVRCA:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK(p[3]);\n\t\tND_PRINT((ndo, \": Features: %u, PxP: %s, History: %u, #CTX-ID: %u\",\n\t\t\t\t(p[2] & 0xc0) >> 6,\n\t\t\t\t(p[2] & 0x20) ? \"Enabled\" : \"Disabled\",\n\t\t\t\tp[2] & 0x1f, p[3]));\n\t\tbreak;\n\tcase CCPOPT_DEFLATE:\n\t\tif (len < 4) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK(p[3]);\n\t\tND_PRINT((ndo, \": Window: %uK, Method: %s (0x%x), MBZ: %u, CHK: %u\",\n\t\t\t(p[2] & 0xf0) >> 4,\n\t\t\t((p[2] & 0x0f) == 8) ? \"zlib\" : \"unknown\",\n\t\t\tp[2] & 0x0f, (p[3] & 0xfc) >> 2, p[3] & 0x03));\n\t\tbreak;\n\n/* XXX: to be supported */\n#if 0\n\tcase CCPOPT_OUI:\n\tcase CCPOPT_PRED1:\n\tcase CCPOPT_PRED2:\n\tcase CCPOPT_PJUMP:\n\tcase CCPOPT_HPPPC:\n\tcase CCPOPT_STACLZS:\n\tcase CCPOPT_MPPC:\n\tcase CCPOPT_GFZA:\n\tcase CCPOPT_V42BIS:\n\tcase CCPOPT_LZSDCP:\n\tcase CCPOPT_DEC:\n\tcase CCPOPT_RESV:\n\t\tbreak;\n#endif\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ccp]\"));\n\treturn 0;\n}\n\n/* BACP config options */\nstatic int\nprint_bacp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\n\tswitch (opt) {\n\tcase BACPOPT_FPEER:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK_32BITS(p + 2);\n\t\tND_PRINT((ndo, \": Magic-Num 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|bacp]\"));\n\treturn 0;\n}\n\n/*\n * Un-escape RFC 1662 PPP in HDLC-like framing, with octet escapes.\n * The length argument is the on-the-wire length, not the captured\n * length; we can only un-escape the captured part.\n */\nstatic void\nppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_int caplen = ndo->ndo_snapend - p;\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i;\n\tint proto;\n\tconst void *se;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length <= 0)\n                return;\n\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we dont overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = *b; /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); /* load the PPP proto-id */\n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\n\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}\n\n\n/* PPP */\nstatic void\nhandle_ppp(netdissect_options *ndo,\n           u_int proto, const u_char *p, int length)\n{\n\tif ((proto & 0xff00) == 0x7e00) { /* is this an escape code ? */\n\t\tppp_hdlc(ndo, p - 1, length);\n\t\treturn;\n\t}\n\n\tswitch (proto) {\n\tcase PPP_LCP: /* fall through */\n\tcase PPP_IPCP:\n\tcase PPP_OSICP:\n\tcase PPP_MPLSCP:\n\tcase PPP_IPV6CP:\n\tcase PPP_CCP:\n\tcase PPP_BACP:\n\t\thandle_ctrl_proto(ndo, proto, p, length);\n\t\tbreak;\n\tcase PPP_ML:\n\t\thandle_mlppp(ndo, p, length);\n\t\tbreak;\n\tcase PPP_CHAP:\n\t\thandle_chap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_PAP:\n\t\thandle_pap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_BAP:\t\t/* XXX: not yet completed */\n\t\thandle_bap(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IP:\t/*XXX*/\n        case PPP_VJNC:\n\tcase PPP_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\t/*XXX*/\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPX:\t/*XXX*/\n\tcase PPP_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_OSI:\n\t\tisoclns_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_COMP:\n\t\tND_PRINT((ndo, \"compressed PPP data\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto)));\n\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n\t\tbreak;\n\t}\n}\n\n/* Standard PPP printer */\nu_int\nppp_print(netdissect_options *ndo,\n          register const u_char *p, u_int length)\n{\n\tu_int proto,ppp_header;\n        u_int olen = length; /* _o_riginal length */\n\tu_int hdr_len = 0;\n\n\t/*\n\t * Here, we assume that p points to the Address and Control\n\t * field (if they present).\n\t */\n\tif (length < 2)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, 2);\n        ppp_header = EXTRACT_16BITS(p);\n\n        switch(ppp_header) {\n        case (PPP_WITHDIRECTION_IN  << 8 | PPP_CONTROL):\n            if (ndo->ndo_eflag) ND_PRINT((ndo, \"In  \"));\n            p += 2;\n            length -= 2;\n            hdr_len += 2;\n            break;\n        case (PPP_WITHDIRECTION_OUT << 8 | PPP_CONTROL):\n            if (ndo->ndo_eflag) ND_PRINT((ndo, \"Out \"));\n            p += 2;\n            length -= 2;\n            hdr_len += 2;\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL):\n            p += 2;\t\t\t/* ACFC not used */\n            length -= 2;\n            hdr_len += 2;\n            break;\n\n        default:\n            break;\n        }\n\n\tif (length < 2)\n\t\tgoto trunc;\n\tND_TCHECK(*p);\n\tif (*p % 2) {\n\t\tproto = *p;\t\t/* PFC is used */\n\t\tp++;\n\t\tlength--;\n\t\thdr_len++;\n\t} else {\n\t\tND_TCHECK2(*p, 2);\n\t\tproto = EXTRACT_16BITS(p);\n\t\tp += 2;\n\t\tlength -= 2;\n\t\thdr_len += 2;\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%s (0x%04x), length %u: \",\n\t\t          tok2str(ppptype2str, \"unknown\", proto),\n\t\t          proto,\n\t\t          olen));\n\n\thandle_ppp(ndo, proto, p, length);\n\treturn (hdr_len);\ntrunc:\n\tND_PRINT((ndo, \"[|ppp]\"));\n\treturn (0);\n}\n\n\n/* PPP I/F printer */\nu_int\nppp_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\n\tif (caplen < PPP_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\treturn (caplen);\n\t}\n\n#if 0\n\t/*\n\t * XXX: seems to assume that there are 2 octets prepended to an\n\t * actual PPP frame. The 1st octet looks like Input/Output flag\n\t * while 2nd octet is unknown, at least to me\n\t * (mshindo@mshindo.net).\n\t *\n\t * That was what the original tcpdump code did.\n\t *\n\t * FreeBSD's \"if_ppp.c\" *does* set the first octet to 1 for outbound\n\t * packets and 0 for inbound packets - but only if the\n\t * protocol field has the 0x8000 bit set (i.e., it's a network\n\t * control protocol); it does so before running the packet through\n\t * \"bpf_filter\" to see if it should be discarded, and to see\n\t * if we should update the time we sent the most recent packet...\n\t *\n\t * ...but it puts the original address field back after doing\n\t * so.\n\t *\n\t * NetBSD's \"if_ppp.c\" doesn't set the first octet in that fashion.\n\t *\n\t * I don't know if any PPP implementation handed up to a BPF\n\t * device packets with the first octet being 1 for outbound and\n\t * 0 for inbound packets, so I (guy@alum.mit.edu) don't know\n\t * whether that ever needs to be checked or not.\n\t *\n\t * Note that NetBSD has a DLT_PPP_SERIAL, which it uses for PPP,\n\t * and its tcpdump appears to assume that the frame always\n\t * begins with an address field and a control field, and that\n\t * the address field might be 0x0f or 0x8f, for Cisco\n\t * point-to-point with HDLC framing as per section 4.3.1 of RFC\n\t * 1547, as well as 0xff, for PPP in HDLC-like framing as per\n\t * RFC 1662.\n\t *\n\t * (Is the Cisco framing in question what DLT_C_HDLC, in\n\t * BSD/OS, is?)\n\t */\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%c %4d %02x \", p[0] ? 'O' : 'I', length, p[1]));\n#endif\n\n\tppp_print(ndo, p, length);\n\n\treturn (0);\n}\n\n/*\n * PPP I/F printer to use if we know that RFC 1662-style PPP in HDLC-like\n * framing, or Cisco PPP with HDLC framing as per section 4.3.1 of RFC 1547,\n * is being used (i.e., we don't check for PPP_ADDRESS and PPP_CONTROL,\n * discard them *if* those are the first two octets, and parse the remaining\n * packet as a PPP packet, as \"ppp_print()\" does).\n *\n * This handles, for example, DLT_PPP_SERIAL in NetBSD.\n */\nu_int\nppp_hdlc_if_print(netdissect_options *ndo,\n                  const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tu_int proto;\n\tu_int hdrlen = 0;\n\n\tif (caplen < 2) {\n\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\treturn (caplen);\n\t}\n\n\tswitch (p[0]) {\n\n\tcase PPP_ADDRESS:\n\t\tif (caplen < 4) {\n\t\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\t\treturn (caplen);\n\t\t}\n\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x %02x %d \", p[0], p[1], length));\n\t\tp += 2;\n\t\tlength -= 2;\n\t\thdrlen += 2;\n\n\t\tproto = EXTRACT_16BITS(p);\n\t\tp += 2;\n\t\tlength -= 2;\n\t\thdrlen += 2;\n\t\tND_PRINT((ndo, \"%s: \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto)));\n\n\t\thandle_ppp(ndo, proto, p, length);\n\t\tbreak;\n\n\tcase CHDLC_UNICAST:\n\tcase CHDLC_BCAST:\n\t\treturn (chdlc_if_print(ndo, h, p));\n\n\tdefault:\n\t\tif (caplen < 4) {\n\t\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\t\treturn (caplen);\n\t\t}\n\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x %02x %d \", p[0], p[1], length));\n\t\tp += 2;\n\t\thdrlen += 2;\n\n\t\t/*\n\t\t * XXX - NetBSD's \"ppp_netbsd_serial_if_print()\" treats\n\t\t * the next two octets as an Ethernet type; does that\n\t\t * ever happen?\n\t\t */\n\t\tND_PRINT((ndo, \"unknown addr %02x; ctrl %02x\", p[0], p[1]));\n\t\tbreak;\n\t}\n\n\treturn (hdrlen);\n}\n\n#define PPP_BSDI_HDRLEN 24\n\n/* BSD/OS specific PPP printer */\nu_int\nppp_bsdos_if_print(netdissect_options *ndo _U_,\n                   const struct pcap_pkthdr *h _U_, register const u_char *p _U_)\n{\n\tregister int hdrlength;\n#ifdef __bsdi__\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tuint16_t ptype;\n\tconst u_char *q;\n\tint i;\n\n\tif (caplen < PPP_BSDI_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\treturn (caplen)\n\t}\n\n\thdrlength = 0;\n\n#if 0\n\tif (p[0] == PPP_ADDRESS && p[1] == PPP_CONTROL) {\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x %02x \", p[0], p[1]));\n\t\tp += 2;\n\t\thdrlength = 2;\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%d \", length));\n\t/* Retrieve the protocol type */\n\tif (*p & 01) {\n\t\t/* Compressed protocol field */\n\t\tptype = *p;\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x \", ptype));\n\t\tp++;\n\t\thdrlength += 1;\n\t} else {\n\t\t/* Un-compressed protocol field */\n\t\tptype = EXTRACT_16BITS(p);\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%04x \", ptype));\n\t\tp += 2;\n\t\thdrlength += 2;\n\t}\n#else\n\tptype = 0;\t/*XXX*/\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%c \", p[SLC_DIR] ? 'O' : 'I'));\n\tif (p[SLC_LLHL]) {\n\t\t/* link level header */\n\t\tstruct ppp_header *ph;\n\n\t\tq = p + SLC_BPFHDRLEN;\n\t\tph = (struct ppp_header *)q;\n\t\tif (ph->phdr_addr == PPP_ADDRESS\n\t\t && ph->phdr_ctl == PPP_CONTROL) {\n\t\t\tif (ndo->ndo_eflag)\n\t\t\t\tND_PRINT((ndo, \"%02x %02x \", q[0], q[1]));\n\t\t\tptype = EXTRACT_16BITS(&ph->phdr_type);\n\t\t\tif (ndo->ndo_eflag && (ptype == PPP_VJC || ptype == PPP_VJNC)) {\n\t\t\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str,\n\t\t\t\t\t\t\"proto-#%d\", ptype)));\n\t\t\t}\n\t\t} else {\n\t\t\tif (ndo->ndo_eflag) {\n\t\t\t\tND_PRINT((ndo, \"LLH=[\"));\n\t\t\t\tfor (i = 0; i < p[SLC_LLHL]; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", q[i]));\n\t\t\t\tND_PRINT((ndo, \"] \"));\n\t\t\t}\n\t\t}\n\t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%d \", length));\n\tif (p[SLC_CHL]) {\n\t\tq = p + SLC_BPFHDRLEN + p[SLC_LLHL];\n\n\t\tswitch (ptype) {\n\t\tcase PPP_VJC:\n\t\t\tptype = vjc_print(ndo, q, ptype);\n\t\t\thdrlength = PPP_BSDI_HDRLEN;\n\t\t\tp += hdrlength;\n\t\t\tswitch (ptype) {\n\t\t\tcase PPP_IP:\n\t\t\t\tip_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPV6:\n\t\t\t\tip6_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_MPLS_UCAST:\n\t\t\tcase PPP_MPLS_MCAST:\n\t\t\t\tmpls_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto printx;\n\t\tcase PPP_VJNC:\n\t\t\tptype = vjc_print(ndo, q, ptype);\n\t\t\thdrlength = PPP_BSDI_HDRLEN;\n\t\t\tp += hdrlength;\n\t\t\tswitch (ptype) {\n\t\t\tcase PPP_IP:\n\t\t\t\tip_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPV6:\n\t\t\t\tip6_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_MPLS_UCAST:\n\t\t\tcase PPP_MPLS_MCAST:\n\t\t\t\tmpls_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto printx;\n\t\tdefault:\n\t\t\tif (ndo->ndo_eflag) {\n\t\t\t\tND_PRINT((ndo, \"CH=[\"));\n\t\t\t\tfor (i = 0; i < p[SLC_LLHL]; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", q[i]));\n\t\t\t\tND_PRINT((ndo, \"] \"));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thdrlength = PPP_BSDI_HDRLEN;\n#endif\n\n\tlength -= hdrlength;\n\tp += hdrlength;\n\n\tswitch (ptype) {\n\tcase PPP_IP:\n\t\tip_print(p, length);\n\t\tbreak;\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", ptype)));\n\t}\n\nprintx:\n#else /* __bsdi */\n\thdrlength = 0;\n#endif /* __bsdi__ */\n\treturn (hdrlength);\n}\n\n\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 8\n * End:\n */\n"], "filenames": ["print-ppp.c"], "buggy_code_start_loc": [1369], "buggy_code_end_loc": [1395], "fixing_code_start_loc": [1370], "fixing_code_end_loc": [1405], "type": "CWE-770", "message": "The ppp decapsulator in tcpdump 4.9.3 can be convinced to allocate a large amount of memory.", "other": {"cve": {"id": "CVE-2020-8037", "sourceIdentifier": "security@tcpdump.org", "published": "2020-11-04T18:15:20.843", "lastModified": "2021-05-05T13:12:33.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ppp decapsulator in tcpdump 4.9.3 can be convinced to allocate a large amount of memory."}, {"lang": "es", "value": "El ppp decapsulator en tcpdump versi\u00f3n 4.9.3 puede ser convencido para que asigne una gran cantidad de memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:tcpdump:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "50B2D924-9D76-425D-828F-222F74F9F7AF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.14.6", "matchCriteriaId": "B0E97851-4DFF-4852-A339-183331F4ACBC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.15", "versionEndExcluding": "10.15.7", "matchCriteriaId": "DB8A73F8-3074-4B32-B9F6-343B6B1988C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:-:*:*:*:*:*:*", "matchCriteriaId": "693E7DAE-BBF0-4D48-9F8A-20DDBD4AAC0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2019-001:*:*:*:*:*:*", "matchCriteriaId": "CFE26ECC-A2C2-4501-9950-510DE0E1BD86"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2019-002:*:*:*:*:*:*", "matchCriteriaId": "26108BEF-0847-4AB0-BD98-35344DFA7835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2020-001:*:*:*:*:*:*", "matchCriteriaId": "0FD3467D-7679-479F-9C0B-A93F7CD0929D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2020-002:*:*:*:*:*:*", "matchCriteriaId": "D4C6098E-EDBD-4A85-8282-B2E9D9333872"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2020-003:*:*:*:*:*:*", "matchCriteriaId": "518BB47B-DD76-4E8C-9F10-7EBC1E146191"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2020-004:*:*:*:*:*:*", "matchCriteriaId": "63940A55-D851-46EB-9668-D82BEFC1FE95"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2020-005:*:*:*:*:*:*", "matchCriteriaId": "68C7A97A-3801-44FA-96CA-10298FA39883"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2020-006:*:*:*:*:*:*", "matchCriteriaId": "6D69914D-46C7-4A0E-A075-C863C1692D33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2020-007:*:*:*:*:*:*", "matchCriteriaId": "9CDB4476-B521-43E4-A129-8718A8E0A8CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2021-001:*:*:*:*:*:*", "matchCriteriaId": "9D072B77-BE3F-4A2E-B66A-E2C8DC3781E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:-:*:*:*:*:*:*", "matchCriteriaId": "A654B8A2-FC30-4171-B0BB-366CD7ED4B6A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2020-001:*:*:*:*:*:*", "matchCriteriaId": "F1F4BF7F-90D4-4668-B4E6-B06F4070F448"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-001:*:*:*:*:*:*", "matchCriteriaId": "0F441A43-1669-478D-9EC8-E96882DE4F9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:supplemental_update:*:*:*:*:*:*", "matchCriteriaId": "C1C795B9-E58D-467C-83A8-2D45C792292F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.3", "matchCriteriaId": "4E699CCC-31F5-458E-A59C-79B3AF143747"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2021/Apr/51", "source": "security@tcpdump.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/32027e199368dad9508965aae8cd8de5b6ab5231", "source": "security@tcpdump.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/11/msg00018.html", "source": "security@tcpdump.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/F2MX34MJIUJQGL6CMEPLTKFOOOC3CJ4Z/", "source": "security@tcpdump.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LWDBONZVLC6BAOR2KM376DJCM4H3FERV/", "source": "security@tcpdump.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT212325", "source": "security@tcpdump.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT212326", "source": "security@tcpdump.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT212327", "source": "security@tcpdump.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/32027e199368dad9508965aae8cd8de5b6ab5231"}}