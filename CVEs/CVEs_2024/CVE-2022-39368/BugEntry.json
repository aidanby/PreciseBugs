{"buggy_code": ["/*******************************************************************************\n * Copyright (c) 2015, 2018 Institute for Pervasive Computing, ETH Zurich and others.\n * \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n * \n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v20.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n * \n * Contributors:\n *    Matthias Kovatsch - creator and main architect\n *    Stefan Jucker - DTLS implementation\n *    Julien Vermillard - Sierra Wireless\n *    Kai Hudalla (Bosch Software Innovations GmbH) - add duplicate record detection\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 462463\n *    Kai Hudalla (Bosch Software Innovations GmbH) - re-factor configuration\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 464383\n *    Kai Hudalla (Bosch Software Innovations GmbH) - add support for stale\n *                                                    session expiration (466554)\n *    Kai Hudalla (Bosch Software Innovations GmbH) - replace SessionStore with ConnectionStore\n *                                                    keeping all information about the connection\n *                                                    to a peer in a single place\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 472196\n *    Achim Kraus, Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 478538\n *    Kai Hudalla (Bosch Software Innovations GmbH) - derive max datagram size for outbound messages\n *                                                    from network MTU\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 483371\n *    Benjamin Cabe - fix typos in logger\n *    Kai Hudalla (Bosch Software Innovations GmbH) - use SessionListener to trigger sending of pending\n *                                                    APPLICATION messages\n *    Bosch Software Innovations GmbH - set correlation context on sent/received messages\n *                                      (fix GitHub issue #1)\n *    Achim Kraus (Bosch Software Innovations GmbH) - use CorrelationContextMatcher\n *                                                    for outgoing messages\n *                                                    (fix GitHub issue #104)\n *    Achim Kraus (Bosch Software Innovations GmbH) - introduce synchronized getSocket()\n *                                                    as pair to synchronized releaseSocket().\n *    Achim Kraus (Bosch Software Innovations GmbH) - restart internal executor\n *    Achim Kraus (Bosch Software Innovations GmbH) - processing retransmission of flight\n *                                                    after last flight was sent.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add onSent() and onError(). \n *                                                    issue #305\n *    Achim Kraus (Bosch Software Innovations GmbH) - Change RetransmitTask to\n *                                                    schedule a \"stripped job\"\n *                                                    instead of executing \n *                                                    handleTimeout directly.\n *                                                    cancel flight only, if they\n *                                                    should not be retransmitted\n *                                                    anymore.\n *    Achim Kraus (Bosch Software Innovations GmbH) - call handshakeFailed on \n *                                                    terminateOngoingHandshake,\n *                                                    processAlertRecord, \n *                                                    handleTimeout,\n *                                                    and add error callback in\n *                                                    newDeferredMessageSender.\n *    Achim Kraus (Bosch Software Innovations GmbH) - reuse receive buffer and packet. \n *    Achim Kraus (Bosch Software Innovations GmbH) - use socket's reuseAddress only\n *                                                    if bindAddress determines a port\n *    Achim Kraus (Bosch Software Innovations GmbH) - introduce protocol,\n *                                                    remove scheme\n *    Achim Kraus (Bosch Software Innovations GmbH) - check for cancelled retransmission\n *                                                    before sending.\n *    Achim Kraus (Bosch Software Innovations GmbH) - move application handler call\n *                                                    out of synchronized block\n *    Achim Kraus (Bosch Software Innovations GmbH) - move creation of endpoint context\n *                                                    to DTLSSession\n *    Bosch Software Innovations GmbH - migrate to SLF4J\n *    Achim Kraus (Bosch Software Innovations GmbH) - add automatic resumption\n *    Achim Kraus (Bosch Software Innovations GmbH) - change receiver thread to\n *                                                    daemon\n *    Achim Kraus (Bosch Software Innovations GmbH) - response with alert, if \n *                                                    connection store is exhausted.\n *    Achim Kraus (Bosch Software Innovations GmbH) - fix double incrementing\n *                                                    pending outgoing message downcounter.\n *    Achim Kraus (Bosch Software Innovations GmbH) - update dtls session timestamp only,\n *                                                    if access is validated with the MAC \n *    Achim Kraus (Bosch Software Innovations GmbH) - fix session resumption with session cache\n *                                                    issue #712\n *                                                    execute jobs after shutdown to ensure, \n *                                                    onError is called for all pending messages. \n *    Achim Kraus (Bosch Software Innovations GmbH) - fix issues #716 and #717\n *                                                    change scopes to protected to support\n *                                                    subclass specific implementations.\n *    Achim Kraus (Bosch Software Innovations GmbH) - use session ticket when sending messages\n *                                                    over a connection marked for resumption.\n *    Achim Kraus (Bosch Software Innovations GmbH) - issue 744: use handshaker as \n *                                                    parameter for session listener.\n *                                                    Move session listener callback out of sync\n *                                                    block of processApplicationDataRecord.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add handshakeFlightRetransmitted\n *    Achim Kraus (Bosch Software Innovations GmbH) - add onConnecting and onDtlsRetransmission\n *    Achim Kraus (Bosch Software Innovations GmbH) - redesign connection session listener to\n *                                                    ensure, that the session listener methods\n *                                                    are called via the handshaker.\n *                                                    Move handshakeCompleted out on synchronized block.\n *                                                    When handshaker replaced, called handshakeFailed\n *                                                    on old to trigger sent error for pending messages.\n *                                                    Reuse ongoing handshaker instead of creating a new\n *                                                    one.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add multiple receiver threads.\n *                                                    move default thread numbers to configuration.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add cause to handshake failure.\n *    Achim Kraus (Bosch Software Innovations GmbH) - remove HELLO_VERIFY_REQUEST\n *                                                    from resumption handshakes\n *    Achim Kraus (Bosch Software Innovations GmbH) - extend deferred processed messages to\n *                                                    limited number of incoming and outgoing messages\n *                                                    extend executor names with specific prefix.\n *    Achim Kraus (Bosch Software Innovations GmbH) - fix reuse of already stopped serial\n *                                                    executors.\n *    Achim Kraus (Bosch Software Innovations GmbH) - remove unused RecordLayer.sendRecord\n *    Achim Kraus (Bosch Software Innovations GmbH) - redesign DTLSFlight and RecordLayer\n *                                                    add timeout for handshakes\n *    Achim Kraus (Bosch Software Innovations GmbH) - move serial executor into connection\n *                                                    process new CLIENT_HELLOs without\n *                                                    serial executor.\n ******************************************************************************/\npackage org.eclipse.californium.scandium;\n\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.NetworkInterface;\nimport java.net.PortUnreachableException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.Principal;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.MDC;\nimport org.eclipse.californium.elements.Connector;\nimport org.eclipse.californium.elements.DtlsEndpointContext;\nimport org.eclipse.californium.elements.EndpointContext;\nimport org.eclipse.californium.elements.EndpointContextMatcher;\nimport org.eclipse.californium.elements.exception.EndpointMismatchException;\nimport org.eclipse.californium.elements.exception.EndpointUnconnectedException;\nimport org.eclipse.californium.elements.exception.MulticastNotSupportedException;\nimport org.eclipse.californium.elements.RawData;\nimport org.eclipse.californium.elements.RawDataChannel;\nimport org.eclipse.californium.elements.util.ClockUtil;\nimport org.eclipse.californium.elements.util.DaemonThreadFactory;\nimport org.eclipse.californium.elements.util.DatagramReader;\nimport org.eclipse.californium.elements.util.ExecutorsUtil;\nimport org.eclipse.californium.elements.util.LeastRecentlyUsedCache;\nimport org.eclipse.californium.elements.util.NamedThreadFactory;\nimport org.eclipse.californium.elements.util.NetworkInterfacesUtil;\nimport org.eclipse.californium.elements.util.NoPublicAPI;\nimport org.eclipse.californium.elements.util.SerialExecutor;\nimport org.eclipse.californium.elements.util.StringUtil;\nimport org.eclipse.californium.scandium.config.DtlsConnectorConfig;\nimport org.eclipse.californium.scandium.dtls.AlertMessage;\nimport org.eclipse.californium.scandium.dtls.AlertMessage.AlertDescription;\nimport org.eclipse.californium.scandium.dtls.AlertMessage.AlertLevel;\nimport org.eclipse.californium.scandium.dtls.ApplicationMessage;\nimport org.eclipse.californium.scandium.dtls.AvailableConnections;\nimport org.eclipse.californium.scandium.dtls.ClientHandshaker;\nimport org.eclipse.californium.scandium.dtls.ClientHello;\nimport org.eclipse.californium.scandium.dtls.Connection;\nimport org.eclipse.californium.scandium.dtls.ConnectionEvictedException;\nimport org.eclipse.californium.scandium.dtls.ConnectionId;\nimport org.eclipse.californium.scandium.dtls.ConnectionIdGenerator;\nimport org.eclipse.californium.scandium.dtls.HandshakeResult;\nimport org.eclipse.californium.scandium.dtls.HandshakeResultHandler;\nimport org.eclipse.californium.scandium.dtls.ContentType;\nimport org.eclipse.californium.scandium.dtls.DTLSMessage;\nimport org.eclipse.californium.scandium.dtls.DTLSSession;\nimport org.eclipse.californium.scandium.dtls.DtlsException;\nimport org.eclipse.californium.scandium.dtls.DtlsHandshakeException;\nimport org.eclipse.californium.scandium.dtls.FragmentedHandshakeMessage;\nimport org.eclipse.californium.scandium.dtls.HandshakeException;\nimport org.eclipse.californium.scandium.dtls.HandshakeMessage;\nimport org.eclipse.californium.scandium.dtls.Handshaker;\nimport org.eclipse.californium.scandium.dtls.HelloVerifyRequest;\nimport org.eclipse.californium.scandium.dtls.InMemoryConnectionStore;\nimport org.eclipse.californium.scandium.dtls.PskSecretResult;\nimport org.eclipse.californium.scandium.dtls.MaxFragmentLengthExtension;\nimport org.eclipse.californium.scandium.dtls.ProtocolVersion;\nimport org.eclipse.californium.scandium.dtls.Record;\nimport org.eclipse.californium.scandium.dtls.RecordLayer;\nimport org.eclipse.californium.scandium.dtls.ResumingClientHandshaker;\nimport org.eclipse.californium.scandium.dtls.ResumingServerHandshaker;\nimport org.eclipse.californium.scandium.dtls.ResumptionSupportingConnectionStore;\nimport org.eclipse.californium.scandium.dtls.ServerHandshaker;\nimport org.eclipse.californium.scandium.dtls.ServerNameExtension;\nimport org.eclipse.californium.scandium.dtls.SessionAdapter;\nimport org.eclipse.californium.scandium.dtls.SessionCache;\nimport org.eclipse.californium.scandium.dtls.SessionId;\nimport org.eclipse.californium.scandium.dtls.SessionListener;\nimport org.eclipse.californium.scandium.dtls.SessionTicket;\nimport org.eclipse.californium.scandium.dtls.cipher.CipherSuite;\nimport org.eclipse.californium.scandium.dtls.pskstore.AdvancedPskStore;\nimport org.eclipse.californium.scandium.dtls.x509.NewAdvancedCertificateVerifier;\nimport org.eclipse.californium.scandium.util.SecretUtil;\nimport org.eclipse.californium.scandium.util.ServerNames;\n\n/**\n * A {@link Connector} using <em>Datagram TLS</em> (DTLS) as specified in\n * <a href=\"http://tools.ietf.org/html/rfc6347\">RFC 6347</a> for securing data\n * exchanged between networked clients and a server application.\n * \n * Note: using IPv6 interfaces with multiple addresses including permanent and\n * temporary (with potentially several different prefixes) currently causes\n * issues on the server side. The outgoing traffic in response to incoming may\n * select a different source address than the incoming destination address. To\n * overcome this, please ensure that the 'any address' is not used on the server\n * side and a separate Connector is created for each address to receive incoming\n * traffic.\n */\npublic class DTLSConnector implements Connector, RecordLayer {\n\n\t/**\n\t * The {@code EndpointContext} key used to store the host name indicated by a\n\t * client in an SNI hello extension.\n\t */\n\tpublic static final String KEY_TLS_SERVER_HOST_NAME = \"TLS_SERVER_HOST_NAME\";\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(DTLSConnector.class);\n\tprivate static final Logger DROP_LOGGER = LoggerFactory.getLogger(LOGGER.getName() + \".drops\");\n\tprivate static final int MAX_PLAINTEXT_FRAGMENT_LENGTH = 16384; // max. DTLSPlaintext.length (2^14 bytes)\n\tprivate static final int MAX_CIPHERTEXT_EXPANSION = CipherSuite.getOverallMaxCiphertextExpansion();\n\tprivate static final int MAX_DATAGRAM_BUFFER_SIZE = MAX_PLAINTEXT_FRAGMENT_LENGTH\n\t\t\t+ DTLSSession.DTLS_HEADER_LENGTH\n\t\t\t+ MAX_CIPHERTEXT_EXPANSION;\n\n\t/**\n\t * Additional padding used by the new record type introduced with the\n\t * connection id. May be randomized to obfuscate the payload length. Due to\n\t * the ongoing discussion in draft-ietf-tls-dtls-connection-id, currently\n\t * only a fixed value.\n\t */\n\tprivate static final int TLS12_CID_PADDING = 0;\n\n\tprivate static final long CLIENT_HELLO_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60);\n\n\t/**\n\t * Indicates, that MDC support is available.\n\t * \n\t * @see MDC\n\t */\n\tprivate static final boolean MDC_SUPPORT;\n\n\tstatic {\n\t\tboolean mdc = false;\n\t\ttry {\n\t\t\tMDC.clear();\n\t\t\tmdc = true;\n\t\t} catch (Throwable ex) {\n\t\t}\n\t\tMDC_SUPPORT = mdc;\n\t}\n\n\t/** all the configuration options for the DTLS connector */ \n\tprotected final DtlsConnectorConfig config;\n\n\tprivate final ResumptionSupportingConnectionStore connectionStore;\n\n\t/**\n\t * General auto resumption timeout in milliseconds. {@code null}, if auto\n\t * resumption is not used.\n\t */\n\tprivate final Long autoResumptionTimeoutMillis;\n\n\tprivate final int thresholdHandshakesWithoutVerifiedPeer;\n\tprivate final AtomicInteger pendingHandshakesWithoutVerifiedPeer = new AtomicInteger();\n\tprotected final DtlsHealth health;\n\n\tprivate final boolean serverOnly;\n\tprivate final String defaultHandshakeMode;\n\t/**\n\t * Apply record filter only for records within the receive window.\n\t */\n\tprivate final int useExtendedWindowFilter;\n\t/**\n\t * Apply record filter.\n\t */\n\tprivate final boolean useFilter;\n\t/**\n\t * Apply address update only for newer records based on epoch/sequence_number.\n\t */\n\tprivate final boolean useCidUpdateAddressOnNewerRecordFilter;\n\n\t/**\n\t * (Down-)counter for pending outbound messages. Initialized with\n\t * {@link DtlsConnectorConfig#getOutboundMessageBufferSize()}.\n\t */\n\tprivate final AtomicInteger pendingOutboundMessagesCountdown = new AtomicInteger();\n\n\tprivate final List<Thread> receiverThreads = new LinkedList<Thread>();\n\n\t/**\n\t * Configure connection id generator. May be {@code null}, if connection id\n\t * should not be supported.\n\t */\n\tprotected final ConnectionIdGenerator connectionIdGenerator;\n\t/**\n\t * Protocol version to use for sending a hello verify request. Default\n\t * {@code null} to reply the client's version.\n\t * \n\t * @since 2.5\n\t */\n\tprivate final ProtocolVersion protocolVersionForHelloVerifyRequests;\n\n\tprivate ScheduledFuture<?> statusLogger;\n\n\tprivate InetSocketAddress lastBindAddress;\n\t/**\n\t * Provided or configured maximum transmission unit.\n\t */\n\tprivate Integer maximumTransmissionUnit;\n\t/**\n\t * IPv4 maximum transmission unit.\n\t * @since 2.4\n\t */\n\tprivate int ipv4Mtu = DEFAULT_IPV4_MTU;\n\t/**\n\t * IPv6 maximum transmission unit.\n\t * @since 2.4\n\t */\n\tprivate int ipv6Mtu = DEFAULT_IPV6_MTU;\n\tprotected int inboundDatagramBufferSize = MAX_DATAGRAM_BUFFER_SIZE;\n\n\tprivate CookieGenerator cookieGenerator = new CookieGenerator();\n\tprivate Object alertHandlerLock= new Object();\n\n\tprivate volatile DatagramSocket socket;\n\n\t/** The timer daemon to schedule retransmissions. */\n\tprotected ScheduledExecutorService timer;\n\n\t/** Indicates whether the connector has started and not stopped yet */\n\tprivate AtomicBoolean running = new AtomicBoolean(false);\n\n\t/**\n\t * Endpoint context matcher for outgoing messages.\n\t * \n\t * @see #setEndpointContextMatcher(EndpointContextMatcher)\n\t * @see #getEndpointContextMatcher()\n\t * @see #sendMessage(RawData, Connection)\n\t * @see #sendMessage(RawData, Connection, DTLSSession)\n\t */\n\tprivate volatile EndpointContextMatcher endpointContextMatcher;\n\n\tprivate volatile RawDataChannel messageHandler;\n\tprivate AlertHandler alertHandler;\n\tprivate SessionListener sessionListener;\n\tprivate ConnectionExecutionListener connectionExecutionListener;\n\tprivate ExecutorService executorService;\n\tprivate boolean hasInternalExecutor;\n\n\t/**\n\t * Creates a DTLS connector from a given configuration object using the\n\t * standard in-memory {@code ConnectionStore}.\n\t * \n\t * @param configuration the configuration options\n\t * @throws NullPointerException if the configuration is {@code null}\n\t */\n\tpublic DTLSConnector(DtlsConnectorConfig configuration) {\n\t\tthis(configuration, (SessionCache) null);\n\t}\n\n\t/**\n\t * Creates a DTLS connector for a given set of configuration options.\n\t * \n\t * @param configuration The configuration options.\n\t * @param sessionCache An (optional) cache for {@code DTLSSession} objects\n\t *            that can be used for persisting and/or sharing of session\n\t *            state among multiple instances of {@code DTLSConnector}.\n\t *            Whenever a handshake with a client is finished the negotiated\n\t *            session is put to this cache. Similarly, whenever a client\n\t *            wants to perform an abbreviated handshake based on an existing\n\t *            session the connection store will try to retrieve the session\n\t *            from this cache if it is not available from the connection\n\t *            store's in-memory (first-level) cache.\n\t * @throws NullPointerException if the configuration is {@code null}.\n\t */\n\tpublic DTLSConnector(final DtlsConnectorConfig configuration, final SessionCache sessionCache) {\n\t\tthis(configuration, createConnectionStore(configuration, sessionCache));\n\t}\n\n\t/**\n\t * Create and initialize default connection store.\n\t * \n\t * @param configuration configuration for initialization\n\t * @param sessionCache An (optional) cache for {@code DTLSSession} objects\n\t *            that can be used for persisting and/or sharing of session\n\t *            state among multiple instances of {@code DTLSConnector}.\n\t *            Whenever a handshake with a client is finished the negotiated\n\t *            session is put to this cache. Similarly, whenever a client\n\t *            wants to perform an abbreviated handshake based on an existing\n\t *            session the connection store will try to retrieve the session\n\t *            from this cache if it is not available from the connection\n\t *            store's in-memory (first-level) cache.\n\t * @return connection store\n\t * @since 2.5\n\t */\n\tprotected static ResumptionSupportingConnectionStore createConnectionStore(DtlsConnectorConfig configuration,\n\t\t\tSessionCache sessionCache) {\n\t\treturn new InMemoryConnectionStore(configuration.getMaxConnections(),\n\t\t\t\tconfiguration.getStaleConnectionThreshold(), sessionCache).setTag(configuration.getLoggingTag());\n\n\t}\n\n\t/**\n\t * Creates a DTLS connector for a given set of configuration options.\n\t * <p>\n\t * The connection store must use the same connection id generator as\n\t * configured in the provided configuration. The current implementation synchronize on the connection store,\n\t * therefore it is important not to use the connection store within a\n\t * different synchronization scope.\n\t * </p>\n\t * \n\t * @param configuration The configuration options.\n\t * @param connectionStore The registry to use for managing connections to\n\t *            peers.\n\t * @throws NullPointerException if any of the parameters is {@code null}.\n\t * @throws IllegalArgumentException if the connection store uses a different\n\t *             cid generator than the configuration.\n\t */\n\tprotected DTLSConnector(final DtlsConnectorConfig configuration, final ResumptionSupportingConnectionStore connectionStore) {\n\t\tif (configuration == null) {\n\t\t\tthrow new NullPointerException(\"Configuration must not be null\");\n\t\t} else if (connectionStore == null) {\n\t\t\tthrow new NullPointerException(\"Connection store must not be null\");\n\t\t} else {\n\t\t\tthis.config = configuration;\n\t\t\tthis.connectionIdGenerator = config.getConnectionIdGenerator();\n\t\t\tthis.protocolVersionForHelloVerifyRequests = config.getProtocolVersionForHelloVerifyRequests();\n\t\t\tthis.pendingOutboundMessagesCountdown.set(config.getOutboundMessageBufferSize());\n\t\t\tthis.autoResumptionTimeoutMillis = config.getAutoResumptionTimeoutMillis();\n\t\t\tthis.serverOnly = config.isServerOnly();\n\t\t\tthis.defaultHandshakeMode = config.getDefaultHandshakeMode();\n\t\t\tthis.useExtendedWindowFilter = config.useExtendedWindowFilter();\n\t\t\tthis.useFilter = config.useAntiReplayFilter() || useExtendedWindowFilter != 0;\n\t\t\tthis.useCidUpdateAddressOnNewerRecordFilter = config.useCidUpdateAddressOnNewerRecordFilter();\n\t\t\tthis.connectionStore = connectionStore;\n\t\t\tthis.connectionStore.attach(connectionIdGenerator);\n\t\t\tthis.connectionStore.setConnectionListener(config.getConnectionListener());\n\t\t\tConnectionListener listener = config.getConnectionListener();\n\t\t\tif (listener instanceof ConnectionExecutionListener) {\n\t\t\t\tthis.connectionExecutionListener = (ConnectionExecutionListener) listener;\n\t\t\t}\n\t\t\tHandshakeResultHandler handler = new HandshakeResultHandler() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void apply(PskSecretResult secretResult) {\n\t\t\t\t\tprocessAsynchronousHandshakeResult(secretResult);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void apply(HandshakeResult connectionResult) {\n\t\t\t\t\tprocessAsynchronousHandshakeResult(connectionResult);\n\t\t\t\t}\n\t\t\t};\n\t\t\tAdvancedPskStore advancedPskStore = config.getAdvancedPskStore();\n\t\t\tif (advancedPskStore != null) {\n\t\t\t\tadvancedPskStore.setResultHandler(handler);\n\t\t\t}\n\t\t\tNewAdvancedCertificateVerifier certificateVerifier = config.getAdvancedCertificateVerifier();\n\t\t\tif (certificateVerifier != null) {\n\t\t\t\tcertificateVerifier.setResultHandler(handler);\n\t\t\t}\n\t\t\tDtlsHealth healthHandler = config.getHealthHandler();\n\t\t\tInteger healthStatusInterval = config.getHealthStatusInterval();\n\t\t\t// this is a useful health metric\n\t\t\t// that could later be exported to some kind of monitoring interface\n\t\t\tif (healthHandler == null && healthStatusInterval != null && healthStatusInterval > 0) {\n\t\t\t\thealthHandler = createDefaultHealthHandler(config);\n\t\t\t\tif (!healthHandler.isEnabled()) {\n\t\t\t\t\thealthHandler = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.health = healthHandler;\n\t\t\tthis.sessionListener = new SessionAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sessionEstablished(Handshaker handshaker, DTLSSession establishedSession)\n\t\t\t\t\t\tthrows HandshakeException {\n\t\t\t\t\tDTLSConnector.this.sessionEstablished(handshaker, establishedSession);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void handshakeCompleted(final Handshaker handshaker) {\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.endHandshake(true);\n\t\t\t\t\t}\n\t\t\t\t\tfinal Connection connection = handshaker.getConnection();\n\t\t\t\t\tScheduledExecutorService timer = DTLSConnector.this.timer;\n\t\t\t\t\tif (timer != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimer.schedule(new Runnable() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\tconnection.startByClientHello(null);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, CLIENT_HELLO_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} catch (RejectedExecutionException ex) {\n\t\t\t\t\t\t\tLOGGER.debug(\"stopping.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// fallback, if execution is rejected\n\t\t\t\t\tconnection.startByClientHello(null);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void handshakeFailed(Handshaker handshaker, Throwable error) {\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.endHandshake(false);\n\t\t\t\t\t}\n\t\t\t\t\tList<RawData> listOut = handshaker.takeDeferredApplicationData();\n\t\t\t\t\tif (!listOut.isEmpty()) {\n\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] failed, report error to deferred {} messages\",\n\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), listOut.size());\n\t\t\t\t\t\tfor (RawData message : listOut) {\n\t\t\t\t\t\t\tmessage.onError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tConnection connection = handshaker.getConnection();\n\t\t\t\t\tif (handshaker.isRemovingConnection()) {\n\t\t\t\t\t\tconnectionStore.remove(connection, false);\n\t\t\t\t\t} else if (handshaker.isProbing()) {\n\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] failed within probe!\", handshaker.getPeerAddress());\n\t\t\t\t\t} else if (connection.getEstablishedSession() == handshaker.getSession()) {\n\t\t\t\t\t\tif (error instanceof HandshakeException) {\n\t\t\t\t\t\t\tAlertMessage alert = ((HandshakeException)error).getAlert();\n\t\t\t\t\t\t\tif (alert != null && alert.getDescription() == AlertDescription.CLOSE_NOTIFY) {\n\t\t\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] closed after session was established!\",\n\t\t\t\t\t\t\t\t\t\thandshaker.getPeerAddress());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed after session was established! {}\",\n\t\t\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), alert);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// failure after established (last FINISH),\n\t\t\t\t\t\t\t// but before completed (first data)\n\t\t\t\t\t\t\tif (error instanceof ConnectionEvictedException) {\n\t\t\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] never get APPLICATION_DATA\",\n\t\t\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed after session was established!\",\n\t\t\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (connection.hasEstablishedSession()) {\n\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed, but has an established session!\",\n\t\t\t\t\t\t\t\thandshaker.getPeerAddress());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed, connection preserved!\", handshaker.getPeerAddress());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tint maxConnections = config.getMaxConnections();\n\t\t\t// calculate absolute threshold from relative.\n\t\t\tlong thresholdInPercent = config.getVerifyPeersOnResumptionThreshold();\n\t\t\tlong threshold = (((long) maxConnections * thresholdInPercent) + 50L) / 100L;\n\t\t\tif (threshold == 0 && thresholdInPercent > 0) {\n\t\t\t\tthreshold = 1;\n\t\t\t}\n\t\t\tthis.thresholdHandshakesWithoutVerifiedPeer = (int) threshold;\n\t\t}\n\t}\n\n\t/**\n\t * Create default health handler.\n\t * \n\t * @param configuration configuration\n\t * @return default health handler.\n\t * @since 2.5\n\t */\n\tprotected DtlsHealth createDefaultHealthHandler(DtlsConnectorConfig configuration) {\n\t\treturn new DtlsHealthLogger(configuration.getLoggingTag());\n\t}\n\n\tprivate final void sessionEstablished(Handshaker handshaker, final DTLSSession establishedSession)\n\t\t\tthrows HandshakeException {\n\t\ttry {\n\t\t\tfinal Connection connection = handshaker.getConnection();\n\t\t\tconnectionStore.putEstablishedSession(establishedSession, connection);\n\t\t\tfinal SerialExecutor serialExecutor = connection.getExecutor();\n\t\t\tList<RawData> listOut = handshaker.takeDeferredApplicationData();\n\t\t\tif (!listOut.isEmpty()) {\n\t\t\t\tLOGGER.trace(\"Session with [{}] established, now process deferred {} messages\",\n\t\t\t\t\t\testablishedSession.getPeer(), listOut.size());\n\t\t\t\tfor (RawData message : listOut) {\n\t\t\t\t\tfinal RawData rawData = message;\n\t\t\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tsendMessage(rawData, connection, establishedSession);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tList<Record> listIn = handshaker.takeDeferredRecords();\n\t\t\tif (!listIn.isEmpty()) {\n\t\t\t\tLOGGER.trace(\"Session with [{}] established, now process deferred {} messages\",\n\t\t\t\t\t\testablishedSession.getPeer(), listIn.size());\n\t\t\t\tfor (Record message : listIn) {\n\t\t\t\t\tfinal Record record = message;\n\t\t\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tprocessRecord(record, connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (RejectedExecutionException ex) {\n\t\t\tLOGGER.debug(\"stopping.\");\n\t\t}\n\t}\n\n\t/**\n\t * Called after initialization of new create handshaker.\n\t * \n\t * Intended to be used for subclass specific handshaker initialization.\n\t * \n\t * @param handshaker new create handshaker\n\t */\n\tprotected void onInitializeHandshaker(final Handshaker handshaker) {\n\t}\n\n\t/**\n\t * Initialize new create handshaker.\n\t * \n\t * Add {@link #sessionListener}.\n\t * \n\t * @param handshaker new create handshaker\n\t */\n\tprivate final void initializeHandshaker(final Handshaker handshaker) {\n\t\tif (sessionListener != null) {\n\t\t\thandshaker.addSessionListener(sessionListener);\n\t\t\tif (health != null) {\n\t\t\t\thealth.startHandshake();\n\t\t\t}\n\t\t}\n\t\tonInitializeHandshaker(handshaker);\n\t}\n\n\t/**\n\t * Sets the executor to be used for processing records.\n\t * <p>\n\t * If this property is not set before invoking the {@linkplain #start()\n\t * start method}, a new {@link ExecutorService} is created with a thread\n\t * pool of {@linkplain DtlsConnectorConfig#getConnectionThreadCount() size}.\n\t * \n\t * This helps with performing multiple handshakes in parallel, in particular if the key exchange\n\t * requires a look up of identities, e.g. in a database or using a web service.\n\t * <p>\n\t * If this method is used to set an executor, the executor will <em>not</em> be shut down\n\t * by the {@linkplain #stop() stop method}.\n\t * \n\t * @param executor The executor.\n\t * @throws IllegalStateException if a new executor is set and this connector is already running.\n\t */\n\tpublic final synchronized void setExecutor(ExecutorService executor) {\n\t\tif (this.executorService != executor) {\n\t\t\tif (running.get()) {\n\t\t\t\tthrow new IllegalStateException(\"cannot set new executor while connector is running\");\n\t\t\t} else {\n\t\t\t\tthis.executorService = executor;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a connection with a given peer.\n\t * \n\t * The connection is gracefully shut down, i.e. a final\n\t * <em>CLOSE_NOTIFY</em> alert message is sent to the peer\n\t * prior to removing all session state.\n\t * \n\t * @param peerAddress the address of the peer to close the connection to\n\t * @throws IllegalStateException if executor cache is exceeded.\n\t */\n\tpublic final void close(InetSocketAddress peerAddress) {\n\t\tfinal Connection connection = getConnection(peerAddress, null, false);\n\t\tif (connection != null && connection.hasEstablishedSession()) {\n\t\t\tSerialExecutor serialExecutor = connection.getExecutor();\n\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tDTLSSession session = connection.getEstablishedSession();\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tterminateConnection(connection, new AlertMessage(AlertLevel.WARNING,\n\t\t\t\t\t\t\t\tAlertDescription.CLOSE_NOTIFY, connection.getPeerAddress()), session);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic final synchronized void start() throws IOException {\n\t\tstart(config.getAddress());\n\t}\n\n\t/**\n\t * Re-starts the connector binding to the same IP address and port as\n\t * on the previous start.\n\t * \n\t * Note: intended for unit tests only!\n\t * \n\t * @throws IOException if the connector cannot be bound to the previous\n\t *            IP address and port\n\t */\n\tfinal synchronized void restart() throws IOException {\n\t\tif (lastBindAddress != null) {\n\t\t\tstart(lastBindAddress);\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Connector has never been started before\");\n\t\t}\n\t}\n\n\tprivate synchronized ExecutorService getExecutorService() {\n\t\treturn executorService;\n\t}\n\n\t/**\n\t * Start connector.\n\t * \n\t * @param bindAddress address to bind socket.\n\t * @throws IOException I/O error\n\t */\n\tprotected void start(InetSocketAddress bindAddress) throws IOException {\n\t\tif (running.get()) {\n\t\t\treturn;\n\t\t}\n\t\tinit(bindAddress, new DatagramSocket(null), config.getMaxTransmissionUnit());\n\t}\n\n\t/**\n\t * Initialize socket ad start connector.\n\t * \n\t * @param bindAddress address to bind socket\n\t * @param socket socket\n\t * @param mtu mtu of socket, or {@code null}, if socket implementation\n\t *            doesn't use a special mtu.\n\t * @throws IOException I/O error\n\t * @since 2.1\n\t */\n\tprotected void init(InetSocketAddress bindAddress, DatagramSocket socket, Integer mtu) throws IOException {\n\t\tthis.socket = socket;\n\t\tpendingOutboundMessagesCountdown.set(config.getOutboundMessageBufferSize());\n\n\t\tif (bindAddress.getPort() != 0 && config.isAddressReuseEnabled()) {\n\t\t\t// make it easier to stop/start a server consecutively without delays\n\t\t\tLOGGER.info(\"Enable address reuse for socket!\");\n\t\t\tsocket.setReuseAddress(true);\n\t\t\tif (!socket.getReuseAddress()) {\n\t\t\t\tLOGGER.warn(\"Enable address reuse for socket failed!\");\n\t\t\t}\n\t\t}\n\n\t\tInteger size = config.getSocketReceiveBufferSize();\n\t\ttry {\n\t\t\tif (size != null && size != 0) {\n\t\t\t\tsocket.setReceiveBufferSize(size);\n\t\t\t}\n\t\t\tsize = config.getSocketSendBufferSize();\n\t\t\tif (size != null && size != 0) {\n\t\t\t\tsocket.setSendBufferSize(size);\n\t\t\t}\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\tLOGGER.error(\"failed to apply {}\", size, ex);\n\t\t}\n\t\t// don't try to access the buffer sizes,\n\t\t// when receive may already lock the socket!\n\t\tint recvBuffer = socket.getReceiveBufferSize();\n\t\tint sendBuffer = socket.getSendBufferSize();\n\n\t\tif (!socket.isBound()) {\n\t\t\tsocket.bind(bindAddress);\n\t\t}\n\t\tif (lastBindAddress != null && (!socket.getLocalAddress().equals(lastBindAddress.getAddress()) || socket.getLocalPort() != lastBindAddress.getPort())){\n\t\t\tif (connectionStore instanceof ResumptionSupportingConnectionStore) {\n\t\t\t\t((ResumptionSupportingConnectionStore) connectionStore).markAllAsResumptionRequired();\n\t\t\t} else {\n\t\t\t\tconnectionStore.clear();\n\t\t\t}\n\t\t}\n\n\t\tif (config.getMaxFragmentLengthCode() != null) {\n\t\t\tMaxFragmentLengthExtension.Length lengthCode = MaxFragmentLengthExtension.Length.fromCode(\n\t\t\t\t\tconfig.getMaxFragmentLengthCode());\n\t\t\t// reduce inbound buffer size accordingly\n\t\t\tinboundDatagramBufferSize = lengthCode.length()\n\t\t\t\t\t+ MAX_CIPHERTEXT_EXPANSION\n\t\t\t\t\t+ DTLSSession.DTLS_HEADER_LENGTH; // 12 bytes DTLS message headers, 13 bytes DTLS record headers\n\t\t}\n\n\t\tif (config.getMaxTransmissionUnit() != null) {\n\t\t\tthis.maximumTransmissionUnit = config.getMaxTransmissionUnit();\n\t\t\tLOGGER.info(\"Configured MTU [{}]\", this.maximumTransmissionUnit);\n\t\t} else if (mtu != null) {\n\t\t\tthis.maximumTransmissionUnit = mtu;\n\t\t\tLOGGER.info(\"Forced MTU [{}]\", this.maximumTransmissionUnit);\n\t\t} else {\n\t\t\tInetAddress localInterfaceAddress = bindAddress.getAddress();\n\t\t\tif (localInterfaceAddress.isAnyLocalAddress()) {\n\t\t\t\tipv4Mtu = NetworkInterfacesUtil.getIPv4Mtu();\n\t\t\t\tipv6Mtu = NetworkInterfacesUtil.getIPv6Mtu();\n\t\t\t\tLOGGER.info(\"multiple network interfaces, using smallest MTU [IPv4 {}, IPv6 {}]\", ipv4Mtu, ipv6Mtu);\n\t\t\t} else {\n\t\t\t\tNetworkInterface ni = NetworkInterface.getByInetAddress(localInterfaceAddress);\n\t\t\t\tboolean ipv6 = localInterfaceAddress instanceof Inet6Address;\n\t\t\t\tif (ni != null && ni.getMTU() > 0) {\n\t\t\t\t\tif (ipv6) {\n\t\t\t\t\t\tipv6Mtu = ni.getMTU();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tipv4Mtu = ni.getMTU();\n\t\t\t\t\t}\n\t\t\t\t} else if (ipv6) {\n\t\t\t\t\tipv6Mtu = NetworkInterfacesUtil.getIPv6Mtu();\n\t\t\t\t\tLOGGER.info(\"Cannot determine MTU of network interface, using minimum MTU [{}] of IPv6 instead\", ipv6Mtu);\n\t\t\t\t} else {\n\t\t\t\t\tipv4Mtu = NetworkInterfacesUtil.getIPv4Mtu();\n\t\t\t\t\tLOGGER.info(\"Cannot determine MTU of network interface, using minimum MTU [{}] of IPv4 instead\", ipv4Mtu);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (inboundDatagramBufferSize > config.getMaxTransmissionUnitLimit()) {\n\t\t\t\tif (ipv4Mtu > config.getMaxTransmissionUnitLimit()) {\n\t\t\t\t\tipv4Mtu = config.getMaxTransmissionUnitLimit();\n\t\t\t\t\tLOGGER.info(\"Limit MTU IPv4[{}]\", ipv4Mtu);\n\t\t\t\t}\n\t\t\t\tif (ipv6Mtu > config.getMaxTransmissionUnitLimit()) {\n\t\t\t\t\tipv6Mtu = config.getMaxTransmissionUnitLimit();\n\t\t\t\t\tLOGGER.info(\"Limit MTU IPv6[{}]\", ipv6Mtu);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ipv4Mtu > inboundDatagramBufferSize) {\n\t\t\t\t\tipv4Mtu = inboundDatagramBufferSize;\n\t\t\t\t\tLOGGER.info(\"Buffersize MTU IPv4[{}]\", ipv4Mtu);\n\t\t\t\t}\n\t\t\t\tif (ipv6Mtu > inboundDatagramBufferSize) {\n\t\t\t\t\tipv6Mtu = inboundDatagramBufferSize;\n\t\t\t\t\tLOGGER.info(\"Buffersize MTU IPv6[{}]\", ipv6Mtu);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlastBindAddress = new InetSocketAddress(socket.getLocalAddress(), socket.getLocalPort());\n\n\t\tif (executorService instanceof ScheduledExecutorService) {\n\t\t\ttimer = (ScheduledExecutorService) executorService;\n\t\t} else {\n\t\t\ttimer = ExecutorsUtil.newSingleThreadScheduledExecutor(new DaemonThreadFactory(\n\t\t\t\t\t\"DTLS-Timer-\" + lastBindAddress + \"#\", NamedThreadFactory.SCANDIUM_THREAD_GROUP)); //$NON-NLS-1$\n\t\t}\n\n\t\tif (executorService == null) {\n\t\t\tint threadCount = config.getConnectionThreadCount();\n\t\t\tif (threadCount > 1) {\n\t\t\t\texecutorService = ExecutorsUtil.newFixedThreadPool(threadCount - 1, new DaemonThreadFactory(\n\t\t\t\t\t\t\"DTLS-Worker-\" + lastBindAddress + \"#\", NamedThreadFactory.SCANDIUM_THREAD_GROUP)); //$NON-NLS-1$\n\t\t\t} else {\n\t\t\t\texecutorService = timer;\n\t\t\t}\n\t\t\tthis.hasInternalExecutor = true;\n\t\t}\n\n\t\trunning.set(true);\n\n\t\tint receiverThreadCount = config.getReceiverThreadCount();\n\t\tfor (int i = 0; i < receiverThreadCount; i++) {\n\t\t\tWorker receiver = new Worker(\"DTLS-Receiver-\" + i + \"-\" + lastBindAddress) {\n\n\t\t\t\tprivate final byte[] receiverBuffer = new byte[inboundDatagramBufferSize];\n\t\t\t\tprivate final DatagramPacket packet = new DatagramPacket(receiverBuffer, inboundDatagramBufferSize);\n\n\t\t\t\t@Override\n\t\t\t\tpublic void doWork() throws Exception {\n\t\t\t\t\tif (MDC_SUPPORT) {\n\t\t\t\t\t\tMDC.clear();\n\t\t\t\t\t}\n\t\t\t\t\tpacket.setData(receiverBuffer);\n\t\t\t\t\treceiveNextDatagramFromNetwork(packet);\n\t\t\t\t}\n\t\t\t};\n\t\t\treceiver.setDaemon(true);\n\t\t\treceiver.start();\n\t\t\treceiverThreads.add(receiver);\n\t\t}\n\n\t\tString mtuDescription = maximumTransmissionUnit != null ? maximumTransmissionUnit.toString() : \"IPv4 \" + ipv4Mtu + \" / IPv6 \" + ipv6Mtu;\n\t\tLOGGER.info(\"DTLSConnector listening on {}, recv buf = {}, send buf = {}, recv packet size = {}, MTU = {}\",\n\t\t\t\tlastBindAddress, recvBuffer, sendBuffer, inboundDatagramBufferSize, mtuDescription);\n\n\t\t// this is a useful health metric\n\t\t// that could later be exported to some kind of monitoring interface\n\t\tif (health != null && health.isEnabled()) {\n\t\t\tfinal Integer healthStatusInterval = config.getHealthStatusInterval();\n\t\t\tif (healthStatusInterval != null) {\n\t\t\t\tstatusLogger = timer.scheduleAtFixedRate(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\thealth.dump(config.getLoggingTag(), config.getMaxConnections(), connectionStore.remainingCapacity(), pendingHandshakesWithoutVerifiedPeer.get());\n\t\t\t\t\t}\n\n\t\t\t\t}, healthStatusInterval, healthStatusInterval, TimeUnit.SECONDS);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Force connector to an abbreviated handshake. See <a href=\"https://tools.ietf.org/html/rfc5246#section-7.3\">RFC 5246</a>.\n\t * \n\t * The abbreviated handshake will be done next time data will be sent with {@link #send(RawData)}.\n\t * @param peer the peer for which we will force to do an abbreviated handshake\n\t */\n\tpublic final synchronized void forceResumeSessionFor(InetSocketAddress peer) {\n\t\tConnection peerConnection = connectionStore.get(peer);\n\t\tif (peerConnection != null && peerConnection.hasEstablishedSession()) {\n\t\t\tpeerConnection.setResumptionRequired(true);\n\t\t}\n\t}\n\n\t/**\n\t * Marks all established sessions currently maintained by this connector to be resumed by means\n\t * of an <a href=\"https://tools.ietf.org/html/rfc5246#section-7.3\">abbreviated handshake</a> the\n\t * next time a message is being sent to the corresponding peer using {@link #send(RawData)}.\n\t * <p>\n\t * This method's execution time is proportional to the number of connections this connector maintains.\n\t */\n\tpublic final synchronized void forceResumeAllSessions() {\n\t\tconnectionStore.markAllAsResumptionRequired();\n\t}\n\n\t/**\n\t * Clears all connection state this connector maintains for peers.\n\t * <p>\n\t * After invoking this method a new connection needs to be established with a peer using a \n\t * full handshake in order to exchange messages with it again.\n\t */\n\tpublic final synchronized void clearConnectionState() {\n\t\tconnectionStore.clear();\n\t}\n\n\tprivate final DatagramSocket getSocket() {\n\t\treturn socket;\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tExecutorService shutdownTimer = null;\n\t\tExecutorService shutdown = null;\n\t\tList<Runnable> pending = new ArrayList<>();\n\t\tsynchronized (this) {\n\t\t\tif (running.compareAndSet(true, false)) {\n\t\t\t\tif (statusLogger != null) {\n\t\t\t\t\tstatusLogger.cancel(false);\n\t\t\t\t\tstatusLogger = null;\n\t\t\t\t}\n\t\t\t\tLOGGER.info(\"Stopping DTLS connector on [{}]\", lastBindAddress);\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t}\n\t\t\t\tif (socket != null) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t\tsocket = null;\n\t\t\t\t}\n\t\t\t\tmaximumTransmissionUnit = null;\n\t\t\t\tipv4Mtu = DEFAULT_IPV4_MTU;\n\t\t\t\tipv6Mtu = DEFAULT_IPV6_MTU;\n\t\t\t\tconnectionStore.stop(pending);\n\t\t\t\tif (executorService != timer) {\n\t\t\t\t\tpending.addAll(timer.shutdownNow());\n\t\t\t\t\tshutdownTimer = timer;\n\t\t\t\t\ttimer = null;\n\t\t\t\t}\n\t\t\t\tif (hasInternalExecutor) {\n\t\t\t\t\tpending.addAll(executorService.shutdownNow());\n\t\t\t\t\tshutdown = executorService;\n\t\t\t\t\texecutorService = null;\n\t\t\t\t\thasInternalExecutor = false;\n\t\t\t\t}\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.join(500);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treceiverThreads.clear();\n\t\t\t}\n\t\t}\n\t\tif (shutdownTimer != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdownTimer.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] timer not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tif (shutdown != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdown.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] executor not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tfor (Runnable job : pending) {\n\t\t\ttry {\n\t\t\t\tjob.run();\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector:\", e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys the connector.\n\t * <p>\n\t * This method invokes {@link #stop()} and clears the <code>ConnectionStore</code>\n\t * used to manage connections to peers. Thus, contrary to the behavior specified\n\t * for {@link Connector#destroy()}, this connector can be re-started using the\n\t * {@link #start()} method but subsequent invocations of the {@link #send(RawData)}\n\t * method will trigger the establishment of a new connection to the corresponding peer.\n\t * </p>\n\t */\n\t@Override\n\tpublic synchronized void destroy() {\n\t\tstop();\n\t\tconnectionStore.clear();\n\t\tmessageHandler = null;\n\t}\n\n\t/**\n\t * Start to terminate connections related to the provided principals.\n\t * \n\t * Note: if {@link SessionCache} is used, it's not possible to remove a\n\t * cache entry, if no related connection is in the connection store.\n\t * \n\t * @param principal principal, which connections are to terminate\n\t * @return future to cancel or wait for completion\n\t */\n\tpublic Future<Void> startDropConnectionsForPrincipal(final Principal principal) {\n\t\tif (principal == null) {\n\t\t\tthrow new NullPointerException(\"principal must not be null!\");\n\t\t}\n\t\tLeastRecentlyUsedCache.Predicate<Principal> handler = new LeastRecentlyUsedCache.Predicate<Principal>() {\n\n\t\t\t@Override\n\t\t\tpublic boolean accept(Principal connectionPrincipal) {\n\t\t\t\treturn principal.equals(connectionPrincipal);\n\t\t\t}\n\t\t};\n\t\treturn startTerminateConnectionsForPrincipal(handler);\n\t}\n\n\t/**\n\t * Start to terminate connections applying the provided handler to the\n\t * principals of all connections.\n\t * \n\t * Note: if {@link SessionCache} is used, it's not possible to remove a\n\t * cache entry, if no related connection is in the connection store. All\n\t * available connections will be removed from that session cache as well.\n\t * \n\t * @param principalHandler handler to be called within the serial execution\n\t *            of the related connection. If {@code true} is returned, the\n\t *            related connection is terminated and the session is removed\n\t *            from the session cache.\n\t * @return future to cancel or wait for completion\n\t * @see #startTerminateConnectionsForPrincipal(org.eclipse.californium.elements.util.LeastRecentlyUsedCache.Predicate,\n\t *      boolean)\n\t */\n\tpublic Future<Void> startTerminateConnectionsForPrincipal(\n\t\t\tLeastRecentlyUsedCache.Predicate<Principal> principalHandler) {\n\t\treturn startTerminateConnectionsForPrincipal(principalHandler, true);\n\t}\n\n\t/**\n\t * Start to terminate connections applying the provided handler to the\n\t * principals of all connections.\n\t * \n\t * Note: if {@link SessionCache} is used, it's not possible to remove a\n\t * cache entry, if no related connection is in the connection store.\n\t * \n\t * @param principalHandler handler to be called within the serial execution\n\t *            of the related connection. If {@code true} is returned, the\n\t *            related connection is terminated\n\t * @param removeFromSessionCache {@code true} if the session of the\n\t *            connection should be removed from the session cache,\n\t *            {@code false}, otherwise\n\t * @return future to cancel or wait for completion\n\t * @see #startTerminateConnectionsForPrincipal(org.eclipse.californium.elements.util.LeastRecentlyUsedCache.Predicate)\n\t * @since 2.6\n\t */\n\tpublic Future<Void> startTerminateConnectionsForPrincipal(\n\t\t\tfinal LeastRecentlyUsedCache.Predicate<Principal> principalHandler, final boolean removeFromSessionCache) {\n\t\tif (principalHandler == null) {\n\t\t\tthrow new NullPointerException(\"principal handler must not be null!\");\n\t\t}\n\t\tLeastRecentlyUsedCache.Predicate<Connection> connectionHandler = new LeastRecentlyUsedCache.Predicate<Connection>() {\n\n\t\t\t@Override\n\t\t\tpublic boolean accept(Connection connection) {\n\t\t\t\tPrincipal peer = null;\n\t\t\t\tSessionTicket ticket = connection.getSessionTicket();\n\t\t\t\tif (ticket != null) {\n\t\t\t\t\tpeer = ticket.getClientIdentity();\n\t\t\t\t} else {\n\t\t\t\t\tDTLSSession session = connection.getSession();\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tpeer = session.getPeerIdentity();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (peer != null && principalHandler.accept(peer)) {\n\t\t\t\t\tconnectionStore.remove(connection, removeFromSessionCache);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\treturn startForEach(connectionHandler);\n\t}\n\n\t/**\n\t * Start applying provided handler to all connections.\n\t * \n\t * @param handler handler to be called within the serial execution of the\n\t *            passed in connection. If {@code true} is returned, iterating\n\t *            is stopped.\n\t * @return future to cancel or wait for completion\n\t */\n\tpublic Future<Void> startForEach(LeastRecentlyUsedCache.Predicate<Connection> handler) {\n\t\tif (handler == null) {\n\t\t\tthrow new NullPointerException(\"handler must not be null!\");\n\t\t}\n\t\tForEachFuture result = new ForEachFuture();\n\t\tnextForEach(connectionStore.iterator(), handler, result);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Calls provided handler for each connection returned be the provided\n\t * iterator.\n\t * \n\t * @param iterator iterator over connections\n\t * @param handler handler to be called for all connections returned by the\n\t *            iterator. Iteration is stopped, when handler returns\n\t *            {@code true}\n\t * @param result future to get cancelled or signal completion\n\t */\n\tprivate void nextForEach(final Iterator<Connection> iterator,\n\t\t\tfinal LeastRecentlyUsedCache.Predicate<Connection> handler, final ForEachFuture result) {\n\n\t\tif (!result.isStopped() && iterator.hasNext()) {\n\t\t\tfinal Connection next = iterator.next();\n\t\t\ttry {\n\t\t\t\tnext.getExecutor().execute(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tboolean done = true;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!result.isStopped() && !handler.accept(next)) {\n\t\t\t\t\t\t\t\tdone = false;\n\t\t\t\t\t\t\t\tnextForEach(iterator, handler, result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception exception) {\n\t\t\t\t\t\t\tresult.failed(exception);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\t\tresult.done();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} catch (RejectedExecutionException ex) {\n\t\t\t\tif (!handler.accept(next)) {\n\t\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\t\tif (handler.accept(iterator.next())) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (result.isStopped()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult.done();\n\t}\n\n\t/**\n\t * Get connection to communication with peer.\n\t * \n\t * @param peerAddress socket address of peer\n\t * @param cid connection id. {@code null}, if cid extension is not used\n\t * @param create {@code true}, create new connection, if connection is not\n\t *            available.\n\t * @return connection to communication with peer. {@code null}, if store is\n\t *         exhausted or if the connection is not available and the provided\n\t *         parameter create is {@code false}.\n\t */\n\tprivate final Connection getConnection(InetSocketAddress peerAddress, ConnectionId cid, boolean create) {\n\t\tExecutorService executor = getExecutorService();\n\t\tsynchronized (connectionStore) {\n\t\t\tConnection connection;\n\t\t\tif (cid != null) {\n\t\t\t\tconnection = connectionStore.get(cid);\n\t\t\t} else {\n\t\t\t\tconnection = connectionStore.get(peerAddress);\n\t\t\t\tif (connection == null && create) {\n\t\t\t\t\tLOGGER.trace(\"create new connection for {}\", peerAddress);\n\t\t\t\t\tConnection newConnection = new Connection(peerAddress, new SerialExecutor(executor));\n\t\t\t\t\tnewConnection.setExecutionListener(connectionExecutionListener);\n\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t// only add, if connector is running!\n\t\t\t\t\t\tif (!connectionStore.put(newConnection)) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn newConnection;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (connection == null) {\n\t\t\t\tLOGGER.trace(\"no connection available for {},{}\", peerAddress, cid);\n\t\t\t} else if (!connection.isExecuting() && running.get()) {\n\t\t\t\tLOGGER.trace(\"revive connection for {},{}\", peerAddress, cid);\n\t\t\t\tconnection.setExecutor(new SerialExecutor(executor));\n\t\t\t} else {\n\t\t\t\tLOGGER.trace(\"connection available for {},{}\", peerAddress, cid);\n\t\t\t}\n\t\t\treturn connection;\n\t\t}\n\t}\n\n\t/**\n\t * Receive the next datagram from network.\n\t * \n\t * Potentially called by multiple threads.\n\t * \n\t * @param packet datagram the be read from network\n\t * @throws IOException if anio- error occurred\n\t * @see #processDatagram(DatagramPacket)\n\t */\n\tprotected void receiveNextDatagramFromNetwork(DatagramPacket packet) throws IOException {\n\n\t\tDatagramSocket currentSocket = getSocket();\n\t\tif (currentSocket == null) {\n\t\t\t// very unlikely race condition.\n\t\t\treturn;\n\t\t}\n\n\t\tcurrentSocket.receive(packet);\n\n\t\tif (packet.getLength() == 0) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO: when deprecated function is removed, call the new one.\n\t\tprocessDatagram(packet);\n\t}\n\n\t/**\n\t * Process received datagram.\n\t * \n\t * Potentially called by multiple threads.\n\t * \n\t * @param packet datagram filled with the received data and source address.\n\t * @deprecated use {@link #processDatagram(DatagramPacket, InetSocketAddress)}\n\t */\n\t@Deprecated\n\tprotected void processDatagram(DatagramPacket packet) {\n\t\tprocessDatagram(packet, null);\n\t}\n\n\t/**\n\t * Process received datagram.\n\t * \n\t * Potentially called by multiple threads.\n\t * \n\t * @param packet received message\n\t * @param router router address, {@code null}, if no router is used.\n\t * @since 2.5\n\t */\n\tprotected void processDatagram(DatagramPacket packet, InetSocketAddress router) {\n\t\tInetSocketAddress peerAddress = (InetSocketAddress) packet.getSocketAddress();\n\t\tif (MDC_SUPPORT) {\n\t\t\tMDC.put(\"PEER\", StringUtil.toString(peerAddress));\n\t\t}\n\t\tif (health != null) {\n\t\t\thealth.receivingRecord(false);\n\t\t}\n\t\tlong timestamp = ClockUtil.nanoRealtime();\n\n\t\tif (peerAddress.getPort() == 0) {\n\t\t\t// RFC 768\n\t\t\t// Source Port is an optional field, when meaningful, it indicates\n\t\t\t// the port of the sending process, and may be assumed to be the\n\t\t\t// port to which a reply should be addressed in the absence of any\n\t\t\t// other information. If not used, a value of zero is inserted.\n\t\t\tDROP_LOGGER.trace(\"Discarding record with {} bytes from [{}] without source-port\", packet.getLength(),\n\t\t\t\t\tpeerAddress);\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tDatagramReader reader = new DatagramReader(packet.getData(), packet.getOffset(), packet.getLength());\n\t\tList<Record> records = Record.fromReader(reader, peerAddress, router, connectionIdGenerator, timestamp);\n\t\tLOGGER.trace(\"Received {} DTLS records from {} using a {} byte datagram buffer\",\n\t\t\t\trecords.size(), peerAddress, inboundDatagramBufferSize);\n\n\t\tif (records.isEmpty()) {\n\t\t\tDROP_LOGGER.trace(\"Discarding {} malicious record with {} bytes from [{}]\", packet.getLength(), peerAddress);\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!running.get()) {\n\t\t\tDROP_LOGGER.trace(\"Discarding {} records, startting with {} from [{}] on shutdown\", records.size(),\n\t\t\t\t\trecords.get(0).getType(), peerAddress);\n\t\t\tLOGGER.debug(\"Execution shutdown while processing incoming records from peer: {}\", peerAddress);\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Record firstRecord = records.get(0);\n\n\t\tif (records.size() == 1 && firstRecord.isNewClientHello()) {\n\t\t\tgetExecutorService().execute(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (MDC_SUPPORT) {\n\t\t\t\t\t\tMDC.put(\"PEER\", StringUtil.toString(firstRecord.getPeerAddress()));\n\t\t\t\t\t}\n\t\t\t\t\tprocessNewClientHello(firstRecord);\n\t\t\t\t\tif (MDC_SUPPORT) {\n\t\t\t\t\t\tMDC.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tfinal ConnectionId connectionId = firstRecord.getConnectionId();\n\t\tfinal Connection connection = getConnection(peerAddress, connectionId, false);\n\n\t\tif (connection == null) {\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\tif (connectionId == null) {\n\t\t\t\tDROP_LOGGER.trace(\"Discarding {} records from [{}] received without existing connection\",\n\t\t\t\t\t\trecords.size(), peerAddress);\n\t\t\t} else {\n\t\t\t\tDROP_LOGGER.trace(\"Discarding {} records from [{},{}] received without existing connection\",\n\t\t\t\t\t\trecords.size(), peerAddress, connectionId);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tSerialExecutor serialExecutor = connection.getExecutor();\n\n\t\tfor (final Record record : records) {\n\t\t\ttry {\n\n\t\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\tprocessRecord(record, connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\tLOGGER.debug(\"Execution rejected while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\tbreak;\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\tterminateConnection(connection, e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Process received record.\n\t * \n\t * @param record received record.\n\t * @param connection connection to process record.\n\t */\n\t@Override\n\tpublic void processRecord(Record record, Connection connection) {\n\n\t\ttry {\n\t\t\t// ensure, that connection is still related to record \n\t\t\t// and not changed by processing an other record before \n\t\t\tif (record.getConnectionId() == null && !connection.equalsPeerAddress(record.getPeerAddress())) {\n\t\t\t\tlong delay = TimeUnit.NANOSECONDS.toMillis(ClockUtil.nanoRealtime() - record.getReceiveNanos());\n\t\t\t\tDROP_LOGGER.debug(\"Drop received record {}, connection changed address {} => {}! (shift {}ms)\", record.getType(),\n\t\t\t\t\t\trecord.getPeerAddress(), connection.getPeerAddress(), delay);\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint epoch = record.getEpoch();\n\t\t\tLOGGER.trace(\"Received DTLS record of type [{}], length: {}, [epoche:{},rseqn:{}]\", \n\t\t\t\t\trecord.getType(), record.getFragmentLength(), epoch, record.getSequenceNumber());\n\n\t\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\t\tif (handshaker != null && handshaker.isExpired()) {\n\t\t\t\t// handshake expired during Android / OS \"deep sleep\"\n\t\t\t\t// on receiving, fail to remove connection, if session is not established \n\t\t\t\thandshaker.handshakeFailed(new Exception(\"handshake already expired!\"));\n\t\t\t\tif (connectionStore.get(connection.getConnectionId()) != connection) {\n\t\t\t\t\t// connection removed, then drop record\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding {} record [epoch {}, rseqn {}] received from peer [{}], handshake expired!\",\n\t\t\t\t\t\t\trecord.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thandshaker = null;\n\t\t\t}\n\n\t\t\tDTLSSession session = connection.getSession(epoch);\n\n\t\t\tif (session == null) {\n\t\t\t\tif (handshaker != null && handshaker.getSession().getReadEpoch() == 0 && epoch == 1) {\n\t\t\t\t\t// future records, apply session after handshake finished.\n\t\t\t\t\thandshaker.addRecordsForDeferredProcessing(record);\n\t\t\t\t} else {\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding {} record [epoch {}, rseqn {}] received from peer [{}] without an active session\",\n\t\t\t\t\t\t\trecord.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The DTLS 1.2 spec (section 4.1.2.6) advises to do replay detection\n\t\t\t// before MAC validation based on the record's sequence numbers\n\t\t\t// see http://tools.ietf.org/html/rfc6347#section-4.1.2.6\n\t\t\tboolean closed = connection.isClosed();\n\t\t\tboolean discard = (useFilter || closed) && (session != null)\n\t\t\t\t\t&& !session.isRecordProcessable(epoch, record.getSequenceNumber(), useExtendedWindowFilter);\n\t\t\t// closed and no session => discard it\n\t\t\tdiscard |= (closed && session == null);\n\t\t\tif (discard) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding {} record [epoch {}, rseqn {}] received from closed peer [{}]\", record.getType(),\n\t\t\t\t\t\t\tepoch, record.getSequenceNumber(), record.getPeerAddress());\n\t\t\t\t} else {\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding duplicate {} record [epoch {}, rseqn {}] received from peer [{}]\",\n\t\t\t\t\t\t\trecord.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());\n\t\t\t\t}\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (record.getType() == ContentType.TLS12_CID) {\n\t\t\t\t// !useCid already dropped in Record.fromByteArray\n\t\t\t\tif (epoch == 0) {\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding TLS_CID record received from peer [{}] during handshake\",\n\t\t\t\t\t\t\trecord.getPeerAddress());\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (epoch > 0 && connection.expectCid()) {\n\t\t\t\tDROP_LOGGER.debug(\"Discarding record received from peer [{}], CID required!\", record.getPeerAddress());\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!record.isDecoded() || record.getType() != ContentType.APPLICATION_DATA) {\n\t\t\t\t// application data may be deferred again until the session is really established\n\t\t\t\trecord.applySession(session);\n\t\t\t}\n\n\t\t\tif (handshaker != null && handshaker.isProbing()) {\n\t\t\t\t// received record, probe successful\n\t\t\t\tif (connection.hasEstablishedSession()) {\n\t\t\t\t\tconnectionStore.removeFromEstablishedSessions(connection.getEstablishedSession(), connection);\n\t\t\t\t}\n\t\t\t\tconnection.resetSession();\n\t\t\t\thandshaker.resetProbing();\n\t\t\t\tLOGGER.trace(\"handshake probe successful {}\", connection.getPeerAddress());\n\t\t\t}\n\n\t\t\tswitch (record.getType()) {\n\t\t\tcase APPLICATION_DATA:\n\t\t\t\tprocessApplicationDataRecord(record, connection);\n\t\t\t\tbreak;\n\t\t\tcase ALERT:\n\t\t\t\tprocessAlertRecord(record, connection, session);\n\t\t\t\tbreak;\n\t\t\tcase CHANGE_CIPHER_SPEC:\n\t\t\t\tprocessChangeCipherSpecRecord(record, connection);\n\t\t\t\tbreak;\n\t\t\tcase HANDSHAKE:\n\t\t\t\tprocessHandshakeRecord(record, connection);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDROP_LOGGER.debug(\"Discarding record of unsupported type [{}] from peer [{}]\",\n\t\t\t\t\trecord.getType(), record.getPeerAddress());\n\t\t\t}\n\t\t} catch (RuntimeException e) {\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record from peer [{}]\",\n\t\t\t\t\trecord.getPeerAddress(), e);\n\t\t\tterminateConnection(connection, e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.debug(\"Discarding {} received from peer [{}] caused by {}\",\n\t\t\t\t\trecord.getType(), record.getPeerAddress(), e.getMessage());\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\tLOGGER.debug(\"error occurred while processing record from peer [{}]\",\n\t\t\t\t\trecord.getPeerAddress(), e);\n\t\t} catch (HandshakeException e) {\n\t\t\tLOGGER.debug(\"error occurred while processing record from peer [{}]\",\n\t\t\t\t\trecord.getPeerAddress(), e);\n\t\t}\n\t}\n\n\t/**\n\t * Immediately terminates an ongoing handshake with a peer.\n\t * \n\t * Terminating the handshake includes\n\t * <ul>\n\t * <li>canceling any pending retransmissions to the peer</li>\n\t * <li>destroying any state for an ongoing handshake with the peer</li>\n\t * </ul>\n\t * \n\t * @param connection the peer to terminate the handshake with\n\t * @param cause the exception that is the cause for terminating the handshake\n\t */\n\tprivate void terminateOngoingHandshake(final Connection connection, final HandshakeException cause) {\n\n\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\tif (handshaker != null) {\n\t\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\t\tLOGGER.trace(\"Aborting handshake with peer [{}]:\", connection.getPeerAddress(), cause);\n\t\t\t} else if (LOGGER.isDebugEnabled()) {\n\t\t\t\tLOGGER.debug(\"Aborting handshake with peer [{}]: {}\", connection.getPeerAddress(), cause.getMessage());\n\t\t\t}\n\t\t\thandshaker.setFailureCause(cause);\n\t\t\tAlertMessage causingAlert = cause.getAlert();\n\t\t\tDTLSSession session = handshaker.getSession();\n\t\t\tif (!connection.hasEstablishedSession()) {\n\t\t\t\tterminateConnection(connection, causingAlert, session);\n\t\t\t} else {\n\t\t\t\t// keep established session intact and only terminate ongoing handshake\n\t\t\t\t// failure after established (last FINISH), but before completed (first data)\n\t\t\t\tif (connection.getEstablishedSession() == handshaker.getSession()) {\n\t\t\t\t\tif (causingAlert.getDescription() == AlertDescription.CLOSE_NOTIFY) {\n\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] closed after session was established!\",\n\t\t\t\t\t\t\t\thandshaker.getPeerAddress());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed after session was established! {}\",\n\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), causingAlert);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed, but has an established session!\", handshaker.getPeerAddress());\n\t\t\t\t}\n\t\t\t\tsend(causingAlert, session);\n\t\t\t}\n\t\t\thandshaker.handshakeFailed(cause);\n\t\t}\n\t}\n\n\tprivate void terminateConnection(Connection connection, Throwable cause, AlertLevel level, AlertDescription description) {\n\t\tif (connection.hasEstablishedSession()) {\n\t\t\tterminateConnection(\n\t\t\t\t\tconnection,\n\t\t\t\t\tnew AlertMessage(level, description, connection.getPeerAddress()),\n\t\t\t\t\tconnection.getEstablishedSession());\n\t\t} else if (connection.hasOngoingHandshake()) {\n\t\t\tterminateConnection(\n\t\t\t\t\tconnection,\n\t\t\t\t\tnew AlertMessage(level, description, connection.getPeerAddress()),\n\t\t\t\t\tconnection.getOngoingHandshake().getSession());\n\t\t}\n\t}\n\n\t/**\n\t * Immediately terminates a connection with a peer.\n\t * \n\t * Terminating the connection includes\n\t * <ul>\n\t * <li>canceling any pending retransmissions to the peer</li>\n\t * <li>destroying any established session with the peer</li>\n\t * <li>destroying any handshakers for the peer</li>\n\t * <li>optionally sending a final ALERT to the peer (if a session exists with the peer)</li>\n\t * </ul>\n\t * \n\t * @param connection the connection to terminate\n\t * @param alert the message to send to the peer before terminating the connection (may be <code>null</code>)\n\t * @param session the parameters to encrypt the alert message with (may be <code>null</code> if alert is\n\t *           <code>null</code>)\n\t * @throws IllegalArgumentException if alert is provided, but session not.\n\t */\n\tprivate void terminateConnection(Connection connection, AlertMessage alert, DTLSSession session) {\n\t\tif (alert == null) {\n\t\t\tLOGGER.trace(\"Terminating connection with peer [{}]\", connection.getPeerAddress());\n\t\t} else {\n\t\t\tif (session == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Session must not be null, if alert message is to be sent\");\n\t\t\t}\n\t\t\tLOGGER.trace(\"Terminating connection with peer [{}], reason [{}]\", connection.getPeerAddress(),\n\t\t\t\t\talert.getDescription());\n\t\t\tsend(alert, session);\n\t\t}\n\t\tif (alert != null && alert.getLevel() == AlertLevel.WARNING && alert.getDescription() == AlertDescription.CLOSE_NOTIFY) {\n\t\t\t// request resumption, keep connection and session\n\t\t\tconnection.setResumptionRequired(true);\n\t\t} else {\n\t\t\t// clear session & (pending) handshaker\n\t\t\tconnectionStore.remove(connection);\n\t\t}\n\t}\n\n\t/**\n\t * Process application data record.\n\t * \n\t * @param record application data record\n\t * @param connection connection to process the received record\n\t */\n\tprivate void processApplicationDataRecord(final Record record, final Connection connection) {\n\t\tfinal Handshaker ongoingHandshake = connection.getOngoingHandshake();\n\t\tfinal DTLSSession session = connection.getEstablishedSession();\n\t\tif (session != null && !connection.isResumptionRequired()) {\n\t\t\t// APPLICATION_DATA can only be processed within the context of\n\t\t\t// an established, i.e. fully negotiated, session\n\t\t\tApplicationMessage message = (ApplicationMessage) record.getFragment();\n\n\t\t\tupdateConnectionAddress(record, connection, session);\n\n\t\t\tfinal RawDataChannel channel = messageHandler;\n\t\t\t// finally, forward de-crypted message to application layer\n\t\t\tif (channel != null) {\n\t\t\t\t// context\n\t\t\t\tInetSocketAddress peer = session.getPeer();\n\t\t\t\tif (peer == null) {\n\t\t\t\t\t// set peer\n\t\t\t\t\t// endpoint context would fail ...\n\t\t\t\t\tsession.setPeer(record.getPeerAddress());\n\t\t\t\t}\n\t\t\t\t// create application message.\n\t\t\t\tDtlsEndpointContext context = session.getConnectionReadContext();\n\t\t\t\tif (peer == null) {\n\t\t\t\t\t// reset peer\n\t\t\t\t\tsession.setPeer(null);\n\t\t\t\t\tLOGGER.debug(\"Received APPLICATION_DATA from deprecated {}\", record.getPeerAddress());\n\t\t\t\t}\n\t\t\t\tLOGGER.trace(\"Received APPLICATION_DATA for {}\", context);\n\t\t\t\tRawData receivedApplicationMessage = RawData.inbound(message.getData(), context, false,\n\t\t\t\t\t\trecord.getReceiveNanos());\n\t\t\t\tchannel.receiveData(receivedApplicationMessage);\n\t\t\t}\n\t\t} else if (ongoingHandshake != null) {\n\t\t\t// wait for FINISH\n\t\t\t// the record is already decoded, so adding it for deferred processing\n\t\t\t// requires to protect it from applying the session again in processRecord!\n\t\t\tongoingHandshake.addRecordsForDeferredProcessing(record);\n\t\t} else {\n\t\t\tDROP_LOGGER.debug(\"Discarding APPLICATION_DATA record received from peer [{}]\",\n\t\t\t\t\trecord.getPeerAddress());\n\t\t}\n\t}\n\n\t/**\n\t * Process alert record.\n\t * \n\t * @param record alert record\n\t * @param connection connection to process the received record\n\t * @param session session applied to decode record\n\t */\n\tprivate void processAlertRecord(Record record, Connection connection, DTLSSession session) {\n\t\tAlertMessage alert = (AlertMessage) record.getFragment();\n\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\tHandshakeException error = null;\n\t\tLOGGER.trace(\"Processing {} ALERT from [{}]: {}\",\n\t\t\t\talert.getLevel(), alert.getPeer(), alert.getDescription());\n\t\tif (AlertDescription.CLOSE_NOTIFY.equals(alert.getDescription())) {\n\t\t\t// according to section 7.2.1 of the TLS 1.2 spec\n\t\t\t// (http://tools.ietf.org/html/rfc5246#section-7.2.1)\n\t\t\t// we need to respond with a CLOSE_NOTIFY alert and\n\t\t\t// then close and remove the connection immediately\n\t\t\tif (connection.hasEstablishedSession()) {\n\t\t\t\tupdateConnectionAddress(record, connection, session);\n\t\t\t} else {\n\t\t\t\terror = new HandshakeException(\"Received 'close notify'\", alert);\n\t\t\t\tif (handshaker != null) {\n\t\t\t\t\thandshaker.setFailureCause(error);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!connection.isResumptionRequired()) {\n\t\t\t\tif (session.getPeer() != null) {\n\t\t\t\t\tsend(new AlertMessage(AlertLevel.WARNING, AlertDescription.CLOSE_NOTIFY, alert.getPeer()), session);\n\t\t\t\t}\n\t\t\t\tif (connection.hasEstablishedSession()) {\n\t\t\t\t\tconnection.close(record);\n\t\t\t\t} else {\n\t\t\t\t\tconnectionStore.remove(connection);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (AlertLevel.FATAL.equals(alert.getLevel())) {\n\t\t\t// according to section 7.2 of the TLS 1.2 spec\n\t\t\t// (http://tools.ietf.org/html/rfc5246#section-7.2)\n\t\t\t// the connection needs to be terminated immediately\n\t\t\terror = new HandshakeException(\"Received 'fatal alert/\" + alert.getDescription() + \"'\", alert);\n\t\t\tif (handshaker != null) {\n\t\t\t\thandshaker.setFailureCause(error);\n\t\t\t}\n\t\t\tconnectionStore.remove(connection);\n\t\t} else {\n\t\t\t// non-fatal alerts do not require any special handling\n\t\t}\n\t\thandleAlertInternal(alert.getPeer(), alert, connection);\n\t\tif (null != error && null != handshaker) {\n\t\t\thandshaker.handshakeFailed(error);\n\t\t}\n\t}\n\n\t/**\n\t * Update connection address.\n\t * \n\t * @param record received record.\n\t * @param connection connection of received record\n\t * @param session session of received record\n\t * @since 2.5\n\t */\n\tprivate void updateConnectionAddress(Record record, Connection connection, DTLSSession session) {\n\t\tInetSocketAddress newAddress = null;\n\t\tif (session.markRecordAsRead(record.getEpoch(), record.getSequenceNumber())\n\t\t\t\t|| !useCidUpdateAddressOnNewerRecordFilter) {\n\t\t\t// address update, it's a newer record!\n\t\t\tconnection.setRouter(record.getRouter());\n\t\t\tnewAddress = record.getPeerAddress();\n\t\t}\n\t\tconnection.refreshAutoResumptionTime();\n\t\tconnectionStore.update(connection, newAddress);\n\t\tfinal Handshaker ongoingHandshake = connection.getOngoingHandshake();\n\t\tif (ongoingHandshake != null) {\n\t\t\t// the handshake has been completed successfully\n\t\t\tongoingHandshake.handshakeCompleted();\n\t\t}\n\t}\n\n\t/**\n\t * Process change cipher spec record.\n\t * \n\t * @param record change cipher spec record\n\t * @param connection connection to process the received record\n\t */\n\tprivate void processChangeCipherSpecRecord(Record record, Connection connection) {\n\t\tHandshaker ongoingHandshaker = connection.getOngoingHandshake();\n\t\tif (ongoingHandshaker != null) {\n\t\t\t// processing a CCS message does not result in any additional flight to be sent\n\t\t\ttry {\n\t\t\t\tongoingHandshaker.processMessage(record);\n\t\t\t} catch (HandshakeException e) {\n\t\t\t\thandleExceptionDuringHandshake(e, connection, record);\n\t\t\t}\n\t\t} else {\n\t\t\t// change cipher spec can only be processed within the\n\t\t\t// context of an existing handshake -> ignore record\n\t\t\tDROP_LOGGER.debug(\"Received CHANGE_CIPHER_SPEC record from peer [{}] with no handshake going on\", record.getPeerAddress());\n\t\t}\n\t}\n\n\t/**\n\t * Process handshake record.\n\t * \n\t * @param record handshake record\n\t * @param connection connection to process the record.\n\t */\n\tprivate void processHandshakeRecord(final Record record, final Connection connection) {\n\t\tLOGGER.trace(\"Received {} record from peer [{}]\", record.getType(), record.getPeerAddress());\n\t\ttry {\n\t\t\tif (record.isNewClientHello()) {\n\t\t\t\tthrow new IllegalArgumentException(\"new CLIENT_HELLO must be processed by processClientHello!\");\n\t\t\t}\n\t\t\tHandshakeMessage handshakeMessage = (HandshakeMessage) record.getFragment();\n\t\t\tswitch (handshakeMessage.getMessageType()) {\n\t\t\tcase CLIENT_HELLO:\n\t\t\t\t// We do not support re-negotiation as recommended in :\n\t\t\t\t// https://tools.ietf.org/html/rfc7925#section-17\n\t\t\t\tDROP_LOGGER.debug(\"Reject re-negotiation from peer {}\", record.getPeerAddress());\n\t\t\t\tDTLSSession session = connection.getEstablishedSession();\n\t\t\t\tsend(new AlertMessage(AlertLevel.WARNING, AlertDescription.NO_RENEGOTIATION, record.getPeerAddress()),\n\t\t\t\t\t\tsession);\n\t\t\t\tbreak;\n\t\t\tcase HELLO_REQUEST:\n\t\t\t\tprocessHelloRequest(connection);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\tif (handshaker != null) {\n\t\t\t\t\thandshaker.processMessage(record);\n\t\t\t\t} else {\n\t\t\t\t\tDROP_LOGGER.debug(\n\t\t\t\t\t\t\t\"Discarding HANDSHAKE message [epoch={}] from peer [{}], no ongoing handshake!\",\n\t\t\t\t\t\t\trecord.getEpoch(), record.getPeerAddress());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\thandleExceptionDuringHandshake(e, connection, record);\n\t\t}\n\t}\n\n\t/**\n\t * Process HELLO_REQUEST.\n\t * \n\t * @param connection connection to process HELLO_REQUEST message.\n\t * @throws HandshakeException if the message to initiate the handshake with\n\t *             the peer cannot be created\n\t */\n\tprivate void processHelloRequest(final Connection connection) throws HandshakeException {\n\t\tif (connection.hasOngoingHandshake()) {\n\t\t\t// TLS 1.2, Section 7.4 advises to ignore HELLO_REQUEST messages\n\t\t\t// arriving while in an ongoing handshake\n\t\t\t// (http://tools.ietf.org/html/rfc5246#section-7.4)\n\t\t\tDROP_LOGGER.debug(\"Ignoring HELLO_REQUEST received from [{}] while already in an ongoing handshake with peer\",\n\t\t\t\t\tconnection.getPeerAddress());\n\t\t} else {\n\t\t\t// We do not support re-negotiation as recommended in :\n\t\t\t// https://tools.ietf.org/html/rfc7925#section-17\n\t\t\tDTLSSession session = connection.getEstablishedSession();\n\t\t\tsend(new AlertMessage(AlertLevel.WARNING, AlertDescription.NO_RENEGOTIATION, connection.getPeerAddress()),\n\t\t\t\t\tsession);\n\t\t}\n\t}\n\n\t/**\n\t * Process new CLIENT_HELLO message.\n\t * \n\t * Executed outside the serial execution. Checks for either a valid session\n\t * id or a valid cookie. If the check is passed successfully, check next, if\n\t * a connection for that CLIENT_HELLO already exists using the client random\n\t * contained in the CLIENT_HELLO message. If the connection already exists,\n\t * take that, otherwise create a new one and pass the execution to the\n\t * serial execution of that connection.\n\t * \n\t * @param record record of CLIENT_HELLO message\n\t */\n\tprivate void processNewClientHello(final Record record) {\n\t\tInetSocketAddress peerAddress = record.getPeerAddress();\n\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\tStringBuilder msg = new StringBuilder(\"Processing new CLIENT_HELLO from peer [\")\n\t\t\t\t\t.append(peerAddress).append(\"]\").append(\":\").append(StringUtil.lineSeparator()).append(record);\n\t\t\tLOGGER.trace(msg.toString());\n\t\t}\n\t\ttry {\n\t\t\t// CLIENT_HELLO with epoch 0 is not encrypted, so use DTLSConnectionState.NULL \n\t\t\trecord.applySession(null);\n\t\t\tDTLSMessage message = record.getFragment();\n\t\t\tif (message instanceof FragmentedHandshakeMessage) {\n\t\t\t\tLOGGER.debug(\"Received unsupported fragmented CLIENT_HELLO from peer [{}].\", peerAddress);\n\t\t\t\tdiscardRecord(record, new DtlsException(\"Fragmented CLIENT_HELLO is not supported!\", peerAddress));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal ClientHello clientHello = (ClientHello) message;\n\n\t\t\t// before starting a new handshake or resuming an established\n\t\t\t// session we need to make sure that the peer is in possession of\n\t\t\t// the IP address indicated in the client hello message\n\t\t\tfinal AvailableConnections connections = new AvailableConnections();\n\t\t\tif (isClientInControlOfSourceIpAddress(clientHello, record, connections)) {\n\t\t\t\tboolean verify = false;\n\t\t\t\tExecutorService executorService = getExecutorService();\n\t\t\t\tConnection connection;\n\t\t\t\tsynchronized (connectionStore) {\n\t\t\t\t\tconnection = connectionStore.get(peerAddress);\n\t\t\t\t\tif (connection != null && !connection.isStartedByClientHello(clientHello)) {\n\t\t\t\t\t\tConnection sessionConnection = connections.getConnectionBySessionId();\n\t\t\t\t\t\tif (sessionConnection != null && sessionConnection != connection) {\n\t\t\t\t\t\t\t// don't overwrite\n\t\t\t\t\t\t\tverify = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sessionConnection != null && sessionConnection == connection) {\n\t\t\t\t\t\t\t\tconnections.setRemoveConnectionBySessionId(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal Handshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\t\t\t\t\t\tif (establishedSession == null || handshaker.getSession() != establishedSession) {\n\t\t\t\t\t\t\t\t\tfinal DtlsException cause = new DtlsException(\n\t\t\t\t\t\t\t\t\t\t\t\"Received new CLIENT_HELLO from \" + StringUtil.toDisplayString(peerAddress),\n\t\t\t\t\t\t\t\t\t\t\tpeerAddress);\n\t\t\t\t\t\t\t\t\thandshaker.setFailureCause(cause);\n\t\t\t\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\t\t\t\thandshaker.handshakeFailed(cause);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (connection == null) {\n\t\t\t\t\t\tconnection = new Connection(peerAddress, new SerialExecutor(executorService));\n\t\t\t\t\t\tconnection.setExecutionListener(connectionExecutionListener);\n\t\t\t\t\t\tconnection.startByClientHello(clientHello);\n\t\t\t\t\t\tif (!connectionStore.put(connection)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (verify) {\n\t\t\t\t\tsendHelloVerify(clientHello, record, null);\n\t\t\t\t} else {\n\t\t\t\t\tconnections.setConnectionByAddress(connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\tprocessClientHello(clientHello, record, connections);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\t\t\tLOGGER.debug(\"Execution rejected while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t\tterminateConnection(connections.getConnectionByAddress(), e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\tLOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (RuntimeException e) {\n\t\t\tLOGGER.warn(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t}\n\t}\n\n\t/**\n\t * Process CLIENT_HELLO message.\n\t * \n\t * @param clientHello CLIENT_HELLO message\n\t * @param record record of CLIENT_HELLO message\n\t * @param connections available connections to process handshake message\n\t */\n\tprivate void processClientHello(ClientHello clientHello, Record record, AvailableConnections connections) {\n\t\tif (connections == null) {\n\t\t\tthrow new NullPointerException(\"available connections must not be null!\");\n\t\t}\n\t\tConnection connection = connections.getConnectionByAddress();\n\t\tif (connection == null) {\n\t\t\tthrow new NullPointerException(\"connection by address must not be null!\");\n\t\t} else if (!connection.equalsPeerAddress(record.getPeerAddress())) {\n\t\t\tDROP_LOGGER.info(\"Drop received CLIENT_HELLO, changed address {} => {}!\", record.getPeerAddress(),\n\t\t\t\t\tconnection.getPeerAddress());\n\t\t\treturn;\n\t\t}\n\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\tStringBuilder msg = new StringBuilder(\"Processing CLIENT_HELLO from peer [\").append(record.getPeerAddress())\n\t\t\t\t\t.append(\"]\").append(\":\").append(StringUtil.lineSeparator()).append(record);\n\t\t\tLOGGER.trace(msg.toString());\n\t\t}\n\n\t\ttry {\n\t\t\tif (connection.hasEstablishedSession() || connection.getOngoingHandshake() != null) {\n\t\t\t\tDROP_LOGGER.debug(\"Discarding received duplicate CLIENT_HELLO message [epoch={}] from peer [{}]!\", record.getEpoch(),\n\t\t\t\t\t\trecord.getPeerAddress());\n\t\t\t} else if (clientHello.hasSessionId()) {\n\t\t\t\t// client wants to resume a cached session\n\t\t\t\tresumeExistingSession(clientHello, record, connections);\n\t\t\t} else {\n\t\t\t\t// At this point the client has demonstrated reachability by completing a cookie exchange\n\t\t\t\t// so we terminate the previous connection and start a new handshake\n\t\t\t\t// (see section 4.2.8 of RFC 6347 (DTLS 1.2))\n\t\t\t\tstartNewHandshake(clientHello, record, connection);\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\thandleExceptionDuringHandshake(e, connection, record);\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether the peer is able to receive data on the IP address indicated\n\t * in its client hello message.\n\t * <p>\n\t * The check is done by means of comparing the cookie contained in the client hello\n\t * message with the cookie computed for the request using the <code>generateCookie</code>\n\t * method.\n\t * </p>\n\t * <p>This method sends a <em>HELLO_VERIFY_REQUEST</em> to the peer if the cookie contained\n\t * in <code>clientHello</code> does not match the expected cookie.\n\t * </p>\n\t * <p>If a matching session id is contained, but no cookie, it depends on the\n\t * number of pending resumption handshakes, if a\n\t * <em>HELLO_VERIFY_REQUEST</em> is send to the peer, of a resumption\n\t * handshake is started without.\n\t * </p>\n\t * May be Executed outside the serial execution, if the connection is\n\t * {@code null}.\n\t * \n\t * @param clientHello the peer's client hello method including the cookie to\n\t *            verify\n\t * @param record the received record\n\t * @param connections used to set the\n\t *            {@link AvailableConnections#bySessionId} with the result of\n\t *            {@link ResumptionSupportingConnectionStore#find(SessionId)}.\n\t * @return <code>true</code> if the client hello message contains a cookie\n\t *         and the cookie is identical to the cookie expected from the peer\n\t *         address, or it contains a matching session id.\n\t */\n\tprivate boolean isClientInControlOfSourceIpAddress(ClientHello clientHello, Record record, AvailableConnections connections) {\n\t\tif (connections == null) {\n\t\t\tthrow new NullPointerException(\"available connections must not be null!\");\n\t\t}\n\t\t// verify client's ability to respond on given IP address\n\t\t// by exchanging a cookie as described in section 4.2.1 of the DTLS 1.2 spec\n\t\t// see http://tools.ietf.org/html/rfc6347#section-4.2.1\n\t\ttry {\n\t\t\tbyte[] expectedCookie = null;\n\t\t\tbyte[] providedCookie = clientHello.getCookie();\n\t\t\tif (providedCookie.length > 0) {\n\t\t\t\texpectedCookie = cookieGenerator.generateCookie(clientHello);\n\t\t\t\t// if cookie is present, it must match\n\t\t\t\tif (MessageDigest.isEqual(expectedCookie, providedCookie)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// check, if cookie of the past period matches\n\t\t\t\tbyte[] pastCookie = cookieGenerator.generatePastCookie(clientHello);\n\t\t\t\tif (pastCookie != null && MessageDigest.isEqual(pastCookie, providedCookie)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (LOGGER.isDebugEnabled()) {\n\t\t\t\t\tLOGGER.debug(\"provided cookie must {} match {}. Send verify request to {}\",\n\t\t\t\t\t\t\tStringUtil.byteArray2HexString(providedCookie, StringUtil.NO_SEPARATOR, 6),\n\t\t\t\t\t\t\tStringUtil.byteArray2HexString(expectedCookie, StringUtil.NO_SEPARATOR, 6),\n\t\t\t\t\t\t\trecord.getPeerAddress());\n\t\t\t\t}\n\t\t\t\t// otherwise send verify request\n\t\t\t} else {\n\t\t\t\t// threshold 0 always use a verify request\n\t\t\t\tif (0 < thresholdHandshakesWithoutVerifiedPeer) {\n\t\t\t\t\tint pending = pendingHandshakesWithoutVerifiedPeer.get();\n\t\t\t\t\tLOGGER.trace(\"pending fast resumptions [{}], threshold [{}]\", pending,\n\t\t\t\t\t\t\tthresholdHandshakesWithoutVerifiedPeer);\n\t\t\t\t\tif (pending < thresholdHandshakesWithoutVerifiedPeer) {\n\t\t\t\t\t\t// use short resumption (without verify request)\n\t\t\t\t\t\t// only, if the number of the pending short\n\t\t\t\t\t\t// resumption handshakes is below the threshold\n\t\t\t\t\t\tConnection sessionConnection = connectionStore.find(clientHello.getSessionId());\n\t\t\t\t\t\tconnections.setConnectionBySessionId(sessionConnection);\n\t\t\t\t\t\tif (sessionConnection != null) {\n\t\t\t\t\t\t\t// found provided session.\n\t\t\t\t\t\t\tSessionTicket ticket;\n\t\t\t\t\t\t\tif (sessionConnection.hasEstablishedSession()) {\n\t\t\t\t\t\t\t\tticket = sessionConnection.getEstablishedSession().getSessionTicket();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tticket = sessionConnection.getSessionTicket();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (verifySessionForResumption(clientHello, ticket)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// for all cases not detected above, use a verify request.\n\t\t\tsendHelloVerify(clientHello, record, expectedCookie);\n\t\t\treturn false;\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tthrow new DtlsHandshakeException(\"Cannot compute cookie for peer\", AlertDescription.INTERNAL_ERROR,\n\t\t\t\t\tAlertLevel.FATAL, clientHello.getPeer(), e);\n\t\t}\n\t}\n\n\t/**\n\t * Start a new handshake.\n\t * \n\t * @param clientHello CLIENT_HELLO message.\n\t * @param record record containing the CLIENT_HELLO message.\n\t * @param connection connection to start handshake.\n\t * @throws HandshakeException if the parameters provided in the client hello message\n\t *           cannot be used to start a handshake with the peer\n\t */\n\tprivate void startNewHandshake(final ClientHello clientHello, final Record record, final Connection connection) throws HandshakeException {\n\t\t// use the record sequence number from CLIENT_HELLO as initial sequence number\n\t\t// for records sent to the client (see section 4.2.1 of RFC 6347 (DTLS 1.2))\n\t\tDTLSSession newSession = new DTLSSession(record.getPeerAddress(), record.getSequenceNumber());\n\t\t// initialize handshaker based on CLIENT_HELLO (this accounts\n\t\t// for the case that multiple cookie exchanges have taken place)\n\t\tHandshaker handshaker = new ServerHandshaker(clientHello.getMessageSeq(), newSession, this, timer, connection, config);\n\t\tinitializeHandshaker(handshaker);\n\t\thandshaker.processMessage(record);\n\t}\n\n\t/**\n\t * Resume existing session.\n\t * \n\t * @param clientHello CLIENT_HELLO message.\n\t * @param record record containing the CLIENT_HELLO message.\n\t * @param connections available connections to resume\n\t * @throws HandshakeException if the session cannot be resumed based on the parameters\n\t *             provided in the client hello message\n\t */\n\tprivate void resumeExistingSession(ClientHello clientHello, Record record, final AvailableConnections connections)\n\t\t\tthrows HandshakeException {\n\t\tInetSocketAddress peerAddress = record.getPeerAddress();\n\t\tLOGGER.trace(\"Client [{}] wants to resume session with ID [{}]\", peerAddress, clientHello.getSessionId());\n\n\t\tif (connections == null) {\n\t\t\tthrow new NullPointerException(\"available connections must not be null!\");\n\t\t}\n\t\tConnection connection = connections.getConnectionByAddress();\n\t\tif (connection == null) {\n\t\t\tthrow new NullPointerException(\"connection by address must not be null!\");\n\t\t} else if (!connection.equalsPeerAddress(peerAddress)) {\n\t\t\tthrow new IllegalArgumentException(\"connection must have records address!\");\n\t\t}\n\n\t\tSessionTicket ticket = null;\n\t\tif (!connections.isConnectionBySessionIdKnown()) {\n\t\t\tconnections.setConnectionBySessionId(connectionStore.find(clientHello.getSessionId()));\n\t\t}\n\t\tConnection previousConnection = connections.getConnectionBySessionId();\n\t\tif (previousConnection != null && previousConnection.isActive()) {\n\t\t\tif (previousConnection.hasEstablishedSession()) {\n\t\t\t\tticket = previousConnection.getEstablishedSession().getSessionTicket();\n\t\t\t} else {\n\t\t\t\tticket = previousConnection.getSessionTicket();\n\t\t\t}\n\t\t\tboolean ok = verifySessionForResumption(clientHello, ticket);\n\t\t\tif (!ok && ticket != null) {\n\t\t\t\tSecretUtil.destroy(ticket);\n\t\t\t\tticket = null;\n\t\t\t}\n\t\t}\n\t\tif (ticket != null) {\n\t\t\t// session has been found in cache, resume it\n\t\t\tfinal DTLSSession sessionToResume = new DTLSSession(clientHello.getSessionId(), peerAddress, ticket,\n\t\t\t\t\trecord.getSequenceNumber());\n\t\t\tfinal Handshaker handshaker = new ResumingServerHandshaker(clientHello.getMessageSeq(), sessionToResume,\n\t\t\t\t\tthis, timer, connection, config);\n\t\t\tinitializeHandshaker(handshaker);\n\t\t\tSecretUtil.destroy(ticket);\n\n\t\t\tif (previousConnection.hasEstablishedSession()) {\n\t\t\t\t// client wants to resume a session that has been negotiated by this node\n\t\t\t\t// make sure that the same client only has a single active connection to this server\n\t\t\t\tif (connections.isRemoveConnectionBySessionId()) {\n\t\t\t\t\t// immediately remove previous connection\n\t\t\t\t\tconnectionStore.remove(previousConnection, false);\n\t\t\t\t} else if (clientHello.getCookie().length == 0) {\n\t\t\t\t\t// short resumption without verify request\n\t\t\t\t\tpendingHandshakesWithoutVerifiedPeer.incrementAndGet();\n\t\t\t\t\thandshaker.addSessionListener(new SessionAdapter() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void sessionEstablished(final Handshaker currentHandshaker,\n\t\t\t\t\t\t\t\tfinal DTLSSession establishedSession) throws HandshakeException {\n\t\t\t\t\t\t\tpendingHandshakesWithoutVerifiedPeer.decrementAndGet();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void handshakeFailed(Handshaker handshaker, Throwable error) {\n\t\t\t\t\t\t\tpendingHandshakesWithoutVerifiedPeer.decrementAndGet();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// process message\n\t\t\thandshaker.processMessage(record);\n\t\t} else {\n\t\t\tLOGGER.trace(\n\t\t\t\t\t\"Client [{}] tries to resume non-existing session [ID={}], performing full handshake instead ...\",\n\t\t\t\t\tpeerAddress, clientHello.getSessionId());\n\t\t\tstartNewHandshake(clientHello, record, connection);\n\t\t}\n\t}\n\t\n\tprivate boolean verifySessionForResumption(ClientHello clientHello, SessionTicket ticket) {\n\t\tboolean ok = true;\n\t\tif (ticket != null && config.isSniEnabled()) {\n\t\t\tServerNames serverNames1 = ticket.getServerNames();\n\t\t\tServerNames serverNames2 = null;\n\t\t\tServerNameExtension extension = clientHello.getServerNameExtension();\n\t\t\tif (extension != null) {\n\t\t\t\tserverNames2 = extension.getServerNames();\n\t\t\t}\n\t\t\tif (serverNames1 != null) {\n\t\t\t\tok = serverNames1.equals(serverNames2);\n\t\t\t} else if (serverNames2 != null) {\n\t\t\t\t// invalidate ticket, server names mismatch\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\tprivate void sendHelloVerify(ClientHello clientHello, Record record, byte[] expectedCookie) throws GeneralSecurityException {\n\t\t// send CLIENT_HELLO_VERIFY with cookie in order to prevent\n\t\t// DOS attack as described in DTLS 1.2 spec\n\t\tLOGGER.trace(\"Verifying client IP address [{}] using HELLO_VERIFY_REQUEST\", record.getPeerAddress());\n\t\tif (expectedCookie == null) {\n\t\t\texpectedCookie = cookieGenerator.generateCookie(clientHello);\n\t\t}\n\t\tProtocolVersion version = protocolVersionForHelloVerifyRequests;\n\t\tif (version == null) {\n\t\t\t// no fixed version configured, reply the client's version.\n\t\t\tversion = clientHello.getClientVersion();\n\t\t\tif (version.compareTo(ProtocolVersion.VERSION_DTLS_1_0) < 0) {\n\t\t\t\tversion = ProtocolVersion.VERSION_DTLS_1_0;\n\t\t\t} else if (version.compareTo(ProtocolVersion.VERSION_DTLS_1_2) > 0) {\n\t\t\t\tversion = ProtocolVersion.VERSION_DTLS_1_2;\n\t\t\t}\n\t\t}\n\t\t// according RFC 6347, 4.2.1. Denial-of-Service Countermeasures, the HelloVerifyRequest should use version 1.0\n\t\tHelloVerifyRequest msg = new HelloVerifyRequest(version, expectedCookie, record.getPeerAddress());\n\t\t// because we do not have a handshaker in place yet that\n\t\t// manages message_seq numbers, we need to set it explicitly\n\t\t// use message_seq from CLIENT_HELLO in order to allow for\n\t\t// multiple consecutive cookie exchanges with a client\n\t\tmsg.setMessageSeq(clientHello.getMessageSeq());\n\t\t// use epoch 0 and sequence no from CLIENT_HELLO record as\n\t\t// mandated by section 4.2.1 of the DTLS 1.2 spec\n\t\t// see http://tools.ietf.org/html/rfc6347#section-4.2.1\n\t\tRecord helloVerify = new Record(ContentType.HANDSHAKE, version, record.getSequenceNumber(), msg, record.getPeerAddress());\n\t\ttry {\n\t\t\tsendRecord(helloVerify);\n\t\t} catch (IOException e) {\n\t\t\t// already logged ...\n\t\t}\n\t}\n\n\tvoid send(AlertMessage alert, DTLSSession session) {\n\t\tif (alert == null) {\n\t\t\tthrow new IllegalArgumentException(\"Alert must not be NULL\");\n\t\t} else if (session == null) {\n\t\t\tthrow new IllegalArgumentException(\"Session must not be NULL\");\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tLOGGER.trace(\"send ALERT {} for peer {}.\", alert, session.getPeer());\n\t\t\t\tRecord record;\n\t\t\t\tboolean useCid = session.getWriteEpoch() > 0;\n\t\t\t\tif (useCid || alert.getProtocolVersion() == null) {\n\t\t\t\t\trecord = new Record(ContentType.ALERT, session.getWriteEpoch(), session.getSequenceNumber(), alert,\n\t\t\t\t\t\tsession, useCid, TLS12_CID_PADDING);\n\t\t\t\t} else {\n\t\t\t\t\trecord = new Record(ContentType.ALERT, alert.getProtocolVersion(), session.getSequenceNumber(), alert,\n\t\t\t\t\t\t\tsession.getPeer());\n\t\t\t\t}\n\t\t\t\tsendRecord(record);\n\t\t\t} catch (IOException e) {\n\t\t\t\t// already logged ...\n\t\t\t} catch (GeneralSecurityException e) {\n\t\t\t\tDROP_LOGGER.warn(\"Cannot create ALERT message for peer [{}]\", session.getPeer(), e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void send(final RawData message) {\n\t\tif (message == null) {\n\t\t\tthrow new NullPointerException(\"Message must not be null\");\n\t\t}\n\t\tif (health != null) {\n\t\t\thealth.sendingRecord(false);\n\t\t}\n\t\tif (message.isMulticast()) {\n\t\t\tDROP_LOGGER.warn(\"DTLSConnector drops {} outgoing bytes to multicast {}:{}\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\tmessage.onError(new MulticastNotSupportedException(\"DTLS doesn't support multicast!\"));\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (message.getInetSocketAddress().getPort() == 0) {\n\t\t\tString destination = StringUtil.toString(message.getInetSocketAddress());\n\t\t\tDROP_LOGGER.warn(\"DTLSConnector drops {} outgoing bytes to [{}] without destination-port\",\n\t\t\t\t\tmessage.getSize(), destination);\n\t\t\tmessage.onError(new IOException(\"CoAPs message to \" + destination + \" dropped, destination port 0!\"));\n\t\t\treturn;\n\t\t}\n\t\tfinal Connection connection;\n\t\tRuntimeException error = null;\n\n\t\tif (!running.get()) {\n\t\t\tconnection = null;\n\t\t\terror = new IllegalStateException(\"connector must be started before sending messages is possible\");\n\t\t} else if (message.getSize() > MAX_PLAINTEXT_FRAGMENT_LENGTH) {\n\t\t\tconnection = null;\n\t\t\terror = new IllegalArgumentException(\n\t\t\t\t\t\"Message data must not exceed \" + MAX_PLAINTEXT_FRAGMENT_LENGTH + \" bytes\");\n\t\t} else {\n\t\t\tboolean create = !serverOnly;\n\t\t\tif (create) {\n\t\t\t\tcreate = !getEffectiveHandshakeMode(message).equals(DtlsEndpointContext.HANDSHAKE_MODE_NONE);\n\t\t\t}\n\t\t\tconnection = getConnection(message.getInetSocketAddress(), null, create);\n\t\t\tif (connection == null) {\n\t\t\t\tif (create) {\n\t\t\t\t\terror = new IllegalStateException(\"connection store is exhausted!\");\n\t\t\t\t} else {\n\t\t\t\t\tif (serverOnly) {\n\t\t\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"server only, connection missing!\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"connection missing!\"));\n\t\t\t\t\t}\n\t\t\t\t\tDROP_LOGGER.debug(\"DTLSConnector drops {} outgoing bytes to {}:{}, connection missing!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (error != null) {\n\t\t\tDROP_LOGGER.debug(\"DTLSConnector drops {} outgoing bytes to {}:{}, {}!\", message.getSize(),\n\t\t\t\t\tmessage.getAddress(), message.getPort(), error.getMessage());\n\t\t\tmessage.onError(error);\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\n\t\tfinal long now =ClockUtil.nanoRealtime();\n\t\tif (pendingOutboundMessagesCountdown.decrementAndGet() >= 0) {\n\t\t\ttry {\n\t\t\t\tSerialExecutor executor = connection.getExecutor();\n\t\t\t\tif (executor == null) {\n\t\t\t\t\tthrow new NullPointerException(\"missing executor for connection! \" + connection.getPeerAddress());\n\t\t\t\t}\n\t\t\t\texecutor.execute(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\tsendMessage(now, message, connection);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, connector not running!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\t\t\t\t\tmessage.onError(new InterruptedIOException(\"Connector is not running.\"));\n\t\t\t\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\tLOGGER.warn(\"Exception thrown by executor thread [{}]\",\n\t\t\t\t\t\t\t\t\t\tThread.currentThread().getName(), e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, {}\", message.getSize(), message.getAddress(), message.getPort(), e.getMessage());\n\t\t\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmessage.onError(e);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tpendingOutboundMessagesCountdown.incrementAndGet();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\tLOGGER.debug(\"Execution rejected while sending application record [peer: {}]\",\n\t\t\t\t\t\tmessage.getInetSocketAddress(), e);\n\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, {}\", message.getSize(), message.getAddress(), message.getPort(), e.getMessage());\n\t\t\t\tmessage.onError(new InterruptedIOException(\"Connector is not running.\"));\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpendingOutboundMessagesCountdown.incrementAndGet();\n\t\t\tDROP_LOGGER.warn(\"Outbound message overflow! Dropping outbound message to peer [{}]\",\n\t\t\t\t\tmessage.getInetSocketAddress());\n\t\t\tmessage.onError(new IllegalStateException(\"Outbound message overflow!\"));\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Sends a raw message to a peer.\n\t * <p>\n\t * This method encrypts and sends the bytes contained in the message using an\n\t * already established session with the peer. If no session exists yet, a\n\t * new handshake with the peer is initiated and the sending of the message is\n\t * deferred to after the handshake has been completed and a session is established.\n\t * </p>\n\t * \n\t * @param nanos system nanoseconds of receiving the data\n\t * @param message the data to send to the peer\n\t * @param connection connection of the peer\n\t * @throws HandshakeException if starting the handshake fails\n\t */\n\tprivate void sendMessage(final long nanos, final RawData message, final Connection connection) throws HandshakeException {\n\n\t\tif (connection.getPeerAddress() == null) {\n\t\t\tlong delay = TimeUnit.NANOSECONDS.toMillis(ClockUtil.nanoRealtime() - nanos);\n\t\t\tDROP_LOGGER.info(\"Drop outgoing record with {} bytes, connection lost address {}! (shift {}ms)\", message.getSize(),\n\t\t\t\t\tmessage.getInetSocketAddress(), delay);\n\t\t\tmessage.onError(new EndpointUnconnectedException(\"connection not longer assigned to address!\"));\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tLOGGER.trace(\"Sending application layer message to [{}]\", message.getEndpointContext());\n\n\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\tif (handshaker != null && !handshaker.hasSessionEstablished()) {\n\t\t\tif (handshaker.isExpired()) {\n\t\t\t\t// handshake expired during Android / OS \"deep sleep\"\n\t\t\t\t// on sending, abort, keep connection for new handshake\n\t\t\t\thandshaker.handshakeAborted(new Exception(\"handshake already expired!\"));\n\t\t\t} else if (handshaker.isProbing()) {\n\t\t\t\tif (checkOutboundEndpointContext(message, null)) {\n\t\t\t\t\tmessage.onConnecting();\n\t\t\t\t\thandshaker.addApplicationDataForDeferredProcessing(message);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (connection.isActive() && !connection.isClosed()) {\n\t\t\tsendMessageWithSession(message, connection);\n\t\t} else {\n\t\t\tsendMessageWithoutSession(message, connection);\n\t\t}\n\t}\n\n\t/**\n\t * Send message without session.\n\t * \n\t * Starts handshake, if not already pending, and queue message.\n\t * \n\t * @param message message to send after handshake completes\n\t * @param connection connection to send message\n\t * @throws HandshakeException If exception occurred starting the handshake\n\t * @since 2.1\n\t */\n\tprivate void sendMessageWithoutSession(final RawData message, final Connection connection)\n\t\t\tthrows HandshakeException {\n\n\t\tif (!checkOutboundEndpointContext(message, null)) {\n\t\t\treturn;\n\t\t}\n\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\tif (handshaker == null) {\n\t\t\tif (serverOnly) {\n\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, server only, connection missing!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"server only, connection missing!\"));\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean none = getEffectiveHandshakeMode(message).contentEquals(DtlsEndpointContext.HANDSHAKE_MODE_NONE);\n\t\t\tif (none) {\n\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, connection missing!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"connection missing!\"));\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDTLSSession session = new DTLSSession(message.getInetSocketAddress());\n\t\t\tsession.setHostName(message.getEndpointContext().getVirtualHost());\n\t\t\t// no session with peer established nor handshaker started yet,\n\t\t\t// create new empty session & start handshake\n\t\t\thandshaker = new ClientHandshaker(session, this, timer, connection, config, false);\n\t\t\tinitializeHandshaker(handshaker);\n\t\t\tmessage.onConnecting();\n\t\t\thandshaker.addApplicationDataForDeferredProcessing(message);\n\t\t\thandshaker.startHandshake(); // may fail with IOException!\n\t\t} else {\n\t\t\tmessage.onConnecting();\n\t\t\thandshaker.addApplicationDataForDeferredProcessing(message);\n\t\t}\n\t}\n\n\t/**\n\t * Send message with session.\n\t * \n\t * Starts handshake, if requested by resumption or {@link DtlsEndpointContext#KEY_HANDSHAKE_MODE}.\n\t * \n\t * @param message message to send\n\t * @param connection connection to send message\n\t * @throws HandshakeException If exception occurred starting the handshake\n\t * @since 2.1\n\t */\n\tprivate void sendMessageWithSession(final RawData message, final Connection connection) throws HandshakeException {\n\n\t\tDTLSSession session = connection.getEstablishedSession();\n\t\tboolean markedAsClosed = session != null && session.isMarkedAsClosed();\n\t\tString handshakeMode = getEffectiveHandshakeMode(message);\n\t\tboolean none = DtlsEndpointContext.HANDSHAKE_MODE_NONE.equals(handshakeMode);\n\t\tif (none) {\n\t\t\tif (markedAsClosed || connection.isResumptionRequired()) {\n\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, resumption required!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"resumption required!\"));\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tboolean probing = DtlsEndpointContext.HANDSHAKE_MODE_PROBE.equals(handshakeMode);\n\t\t\tboolean full = DtlsEndpointContext.HANDSHAKE_MODE_FORCE_FULL.equals(handshakeMode);\n\t\t\tboolean force = probing || full || DtlsEndpointContext.HANDSHAKE_MODE_FORCE.equals(handshakeMode);\n\t\t\tif (force || markedAsClosed || connection.isAutoResumptionRequired(getAutResumptionTimeout(message))) {\n\t\t\t\t// create the session to resume from the previous one.\n\t\t\t\tif (serverOnly) {\n\t\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, server only, resumption requested failed!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"server only, resumption requested failed!\"));\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmessage.onConnecting();\n\t\t\t\tHandshaker previousHandshaker = connection.getOngoingHandshake();\n\t\t\t\tSessionTicket ticket = null;\n\t\t\t\tSessionId sessionId = null;\n\t\t\t\tif (!full) {\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tsessionId = session.getSessionIdentifier();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsessionId = connection.getSessionIdentity();\n\t\t\t\t\t}\n\t\t\t\t\tfull = sessionId.isEmpty();\n\t\t\t\t\tif (!full) {\n\t\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tticket = session.getSessionTicket();\n\t\t\t\t\t\t\t} catch (IllegalStateException ex) {\n\t\t\t\t\t\t\t\tLOGGER.debug(\"Not possible to resume incomplete session!\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tticket = connection.getSessionTicket();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (session != null) {\n\t\t\t\t\tif (!probing) {\n\t\t\t\t\t\tconnectionStore.removeFromEstablishedSessions(session, connection);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprobing = false;\n\t\t\t\t}\n\t\t\t\tif (probing) {\n\t\t\t\t\t// Only reset the resumption trigger, but keep the session for now\n\t\t\t\t\t// the session will be reseted with the first received data\n\t\t\t\t\tconnection.setResumptionRequired(false);\n\t\t\t\t} else {\n\t\t\t\t\tconnection.resetSession();\n\t\t\t\t}\n\t\t\t\tHandshaker newHandshaker;\n\t\t\t\tif (ticket == null) {\n\t\t\t\t\t// server may use a empty session id to indicate,\n\t\t\t\t\t// that resumption is not supported\n\t\t\t\t\t// https://tools.ietf.org/html/rfc5246#section-7.4.1.3\n\t\t\t\t\tDTLSSession newSession = new DTLSSession(message.getInetSocketAddress());\n\t\t\t\t\tnewSession.setHostName(message.getEndpointContext().getVirtualHost());\n\t\t\t\t\tnewHandshaker = new ClientHandshaker(newSession, this, timer, connection, config, probing);\n\t\t\t\t} else {\n\t\t\t\t\tDTLSSession resumableSession = new DTLSSession(sessionId, message.getInetSocketAddress(), ticket, 0);\n\t\t\t\t\tSecretUtil.destroy(ticket);\n\t\t\t\t\tresumableSession.setHostName(message.getEndpointContext().getVirtualHost());\n\t\t\t\t\tnewHandshaker = new ResumingClientHandshaker(resumableSession, this, timer, connection, config, probing);\n\t\t\t\t}\n\t\t\t\tinitializeHandshaker(newHandshaker);\n\t\t\t\tif (previousHandshaker != null) {\n\t\t\t\t\tnewHandshaker.takeDeferredApplicationData(previousHandshaker);\n\t\t\t\t\t// abort, keep connection\n\t\t\t\t\tpreviousHandshaker.handshakeAborted(new Exception(\"handshake replaced!\"));\n\t\t\t\t}\n\t\t\t\tnewHandshaker.addApplicationDataForDeferredProcessing(message);\n\t\t\t\tnewHandshaker.startHandshake();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// session with peer has already been established,\n\t\t// use it to send encrypted message\n\t\tsendMessage(message, connection, session);\n\t}\n\n\tprivate void sendMessage(final RawData message, final Connection connection, final DTLSSession session) {\n\t\ttry {\n\t\t\tLOGGER.trace(\"send {}-{} using {}-{}\", connection.getConnectionId(), connection.getPeerAddress(),\n\t\t\t\t\tsession.getSessionIdentifier(), session.getPeer());\n\t\t\tfinal EndpointContext ctx = session.getConnectionWriteContext();\n\t\t\tif (!checkOutboundEndpointContext(message, ctx)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.onContextEstablished(ctx);\n\t\t\tRecord record = new Record(\n\t\t\t\t\tContentType.APPLICATION_DATA,\n\t\t\t\t\tsession.getWriteEpoch(),\n\t\t\t\t\tsession.getSequenceNumber(),\n\t\t\t\t\tnew ApplicationMessage(message.getBytes(), message.getInetSocketAddress()),\n\t\t\t\t\tsession, true, TLS12_CID_PADDING);\n\t\t\tsendRecord(record);\n\t\t\tmessage.onSent();\n\t\t\tconnection.refreshAutoResumptionTime();\n\t\t} catch (IOException e) {\n\t\t\tmessage.onError(e);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.warn(\"Cannot send APPLICATION record to peer [{}]\", message.getInetSocketAddress(), e);\n\t\t\tmessage.onError(e);\n\t\t}\n\t}\n\n\t/**\n\t * Check, if the endpoint context match for outgoing messages using\n\t * {@link #endpointContextMatcher}.\n\t * \n\t * @param message message to be checked\n\t * @param connectionContext endpoint context of the connection. May be\n\t *            {@code null}, if not established.\n\t * @return {@code true}, if outgoing message matches, {@code false}, if not\n\t *         and should NOT be send.\n\t * @see EndpointContextMatcher#isToBeSent(EndpointContext, EndpointContext)\n\t */\n\tprivate boolean checkOutboundEndpointContext(final RawData message, final EndpointContext connectionContext) {\n\t\tfinal EndpointContextMatcher endpointMatcher = getEndpointContextMatcher();\n\t\tif (null != endpointMatcher && !endpointMatcher.isToBeSent(message.getEndpointContext(), connectionContext)) {\n\t\t\tif (DROP_LOGGER.isInfoEnabled()) {\n\t\t\t\tDROP_LOGGER.info(\"DTLSConnector ({}) drops {} bytes outgoing, {} != {}\", this, message.getSize(),\n\t\t\t\t\t\tendpointMatcher.toRelevantState(message.getEndpointContext()),\n\t\t\t\t\t\tendpointMatcher.toRelevantState(connectionContext));\n\t\t\t}\n\t\t\tmessage.onError(new EndpointMismatchException());\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the {@link DTLSSession} related to the given peer address.\n\t * \n\t * @param address the peer address\n\t * @return the {@link DTLSSession} or <code>null</code> if no session found.\n\t */\n\tpublic final DTLSSession getSessionByAddress(InetSocketAddress address) {\n\t\tif (address == null) {\n\t\t\treturn null;\n\t\t}\n\t\tConnection connection = connectionStore.get(address);\n\t\tif (connection != null) {\n\t\t\treturn connection.getEstablishedSession();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void dropReceivedRecord(Record record) {\n\t\tDROP_LOGGER.debug(\"Discarding {} record [epoch {}, rseqn {}] dropped by handshaker for peer [{}]\", record.getType(),\n\t\t\t\trecord.getEpoch(), record.getSequenceNumber(), record.getPeerAddress());\n\t\tif (health != null) {\n\t\t\thealth.receivingRecord(true);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getMaxDatagramSize(boolean ipv6) {\n\t\tint headerSize = ipv6 ? IPV6_HEADER_LENGTH : IPV4_HEADER_LENGTH;\n\t\tint mtu = maximumTransmissionUnit != null ? maximumTransmissionUnit : (ipv6 ? ipv6Mtu : ipv4Mtu);\n\t\tint size = mtu - headerSize;\n\t\tif (size < 64) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\tString.format(\"%s, datagram size %d, mtu %d\", ipv6 ? \"IPV6\" : \"IPv4\", size, mtu));\n\t\t}\n\t\treturn mtu - headerSize;\n\t}\n\n\t@NoPublicAPI\n\t@Override\n\tpublic void sendFlight(List<DatagramPacket> datagrams) throws IOException {\n\t\t// send it over the UDP socket\n\t\tfor (DatagramPacket datagramPacket : datagrams) {\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(false);\n\t\t\t}\n\t\t\tsendNextDatagramOverNetwork(datagramPacket);\n\t\t}\n\t}\n\n\tprotected void sendRecord(Record record) throws IOException {\n\t\tif (health != null && record.getType() != ContentType.APPLICATION_DATA) {\n\t\t\thealth.sendingRecord(false);\n\t\t}\n\t\tbyte[] recordBytes = record.toByteArray();\n\t\tDatagramPacket datagram = new DatagramPacket(recordBytes, recordBytes.length, record.getPeerAddress());\n\t\tsendNextDatagramOverNetwork(datagram);\n\t}\n\n\tprotected void sendNextDatagramOverNetwork(final DatagramPacket datagramPacket) throws IOException {\n\t\tDatagramSocket socket = getSocket();\n\t\tif (socket != null && !socket.isClosed()) {\n\t\t\tif (datagramPacket.getPort() == 0) {\n\t\t\t\tString destination = StringUtil.toString((InetSocketAddress) datagramPacket.getSocketAddress());\n\t\t\t\tDROP_LOGGER.trace(\"Discarding record with {} bytes to [{}] without destination-port\",\n\t\t\t\t\t\tdatagramPacket.getLength(), destination);\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t\tthrow new IOException(\"DTLS Record to \" + destination + \" dropped, destination port 0!\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsocket.send(datagramPacket);\n\t\t\t\treturn;\n\t\t\t} catch (PortUnreachableException e) {\n\t\t\t\tif (!socket.isClosed()) {\n\t\t\t\t\tLOGGER.warn(\"Could not send record, destination {} unreachable!\",\n\t\t\t\t\t\t\tStringUtil.toString((InetSocketAddress) datagramPacket.getSocketAddress()));\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tif (!socket.isClosed()) {\n\t\t\t\t\tLOGGER.warn(\"Could not send record\", e);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInetSocketAddress address = lastBindAddress;\n\t\tif (address == null) {\n\t\t\taddress = config.getAddress();\n\t\t}\n\t\tDROP_LOGGER.debug(\"Socket [{}] is closed, discarding packet ...\", address);\n\t\tthrow new IOException(\"Socket closed.\");\n\t}\n\n\t/**\n\t * Process handshake result.\n\t * \n\t * @param handshakeResult asynchronous handshake result\n\t * @since 2.5\n\t */\n\tprivate void processAsynchronousHandshakeResult(final HandshakeResult handshakeResult) {\n\t\tfinal Connection connection = connectionStore.get(handshakeResult.getConnectionId());\n\t\tif (connection != null && connection.hasOngoingHandshake()) {\n\t\t\tSerialExecutor serialExecutor = connection.getExecutor();\n\n\t\t\ttry {\n\n\t\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\thandshaker.processAsyncHandshakeResult(handshakeResult);\n\t\t\t\t\t\t\t\t} catch (HandshakeException e) {\n\t\t\t\t\t\t\t\t\thandleExceptionDuringHandshake(e, connection, null);\n\t\t\t\t\t\t\t\t} catch (IllegalStateException e) {\n\t\t\t\t\t\t\t\t\tLOGGER.warn(\"Exception while processing handshake result [{}]\", connection, e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOGGER.debug(\"No ongoing handshake for result [{}]\", connection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGGER.debug(\"Execution stopped while processing handshake result [{}]\", connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\tLOGGER.debug(\"Execution rejected while processing handshake result [{}]\", connection, e);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing handshake result [{}]\", connection, e);\n\t\t\t}\n\t\t} else {\n\t\t\tLOGGER.debug(\"No connection or ongoing handshake for handshake result [{}]\", connection);\n\t\t}\n\t}\n\n\t/**\n\t * Get auto resumption timeout.\n\t * \n\t * Check, if {@link DtlsEndpointContext#KEY_RESUMPTION_TIMEOUT} is provided,\n\t * or use {@link #autoResumptionTimeoutMillis} as default.\n\t * \n\t * @param message message to check for auto resumption timeout.\n\t * @return resulting timeout in milliseconds. {@code null} for no auto\n\t *         resumption.\n\t * @since 2.1\n\t */\n\tprivate Long getAutResumptionTimeout(RawData message) {\n\t\tLong timeout = autoResumptionTimeoutMillis;\n\t\tString contextTimeout = message.getEndpointContext().get(DtlsEndpointContext.KEY_RESUMPTION_TIMEOUT);\n\t\tif (contextTimeout != null) {\n\t\t\tif (contextTimeout.isEmpty()) {\n\t\t\t\ttimeout = null;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\ttimeout = Long.valueOf(contextTimeout);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn timeout;\n\t}\n\n\t/**\n\t * Gets the MTU value of the network interface this connector is bound to.\n\t * <p>\n\t * Applications may use this property to determine the maximum length of application\n\t * layer data that can be sent using this connector without requiring IP fragmentation.\n\t * <p> \n\t * The value returned will be 0 if this connector is not running or the network interface\n\t * this connector is bound to does not provide an MTU value.\n\t * \n\t * @return the MTU provided by the network interface\n\t * @deprecated use {@link #getMaxDatagramSize(boolean)} instead\n\t */\n\t@Deprecated\n\tpublic final int getMaximumTransmissionUnit() {\n\t\treturn maximumTransmissionUnit;\n\t}\n\n\t/**\n\t * Gets the maximum amount of unencrypted payload data that can be sent to a given\n\t * peer in a single DTLS record.\n\t * <p>\n\t * The value of this property serves as an upper boundary for the <em>DTLSPlaintext.length</em>\n\t * field defined in <a href=\"http://tools.ietf.org/html/rfc6347#section-4.3.1\">DTLS 1.2 spec,\n\t * Section 4.3.1</a>. This means that an application can assume that any message containing at\n\t * most as many bytes as indicated by this method, will be delivered to the peer in a single\n\t * unfragmented datagram.\n\t * </p>\n\t * <p>\n\t * The value returned by this method considers the <em>current write state</em> of the connection\n\t * to the peer and any potential ciphertext expansion introduced by this cipher suite used to\n\t * secure the connection. However, if no connection exists to the peer, the value returned is\n\t * determined as follows:\n\t * </p>\n\t * <pre>\n\t *   maxFragmentLength = network interface's <em>Maximum Transmission Unit</em>\n\t *                     - IP header length (20 bytes IPv4, 120 IPv6)\n\t *                     - UDP header length (8 bytes)\n\t *                     - DTLS record header length (13 bytes)\n\t *                     - DTLS message header length (12 bytes)\n\t * </pre>\n\t * \n\t * @param peer the address of the remote endpoint\n\t * \n\t * @return the maximum length in bytes\n\t */\n\tpublic final int getMaximumFragmentLength(InetSocketAddress peer) {\n\t\tConnection con = connectionStore.get(peer);\n\t\tif (con != null && con.hasEstablishedSession()) {\n\t\t\treturn con.getEstablishedSession().getMaxFragmentLength();\n\t\t} else {\n\t\t\treturn getMaxDatagramSize(peer.getAddress() instanceof Inet6Address) - DTLSSession.DTLS_HEADER_LENGTH;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the address this connector is bound to.\n\t * \n\t * @return the IP address and port this connector is bound to or configured to\n\t *            bind to\n\t */\n\t@Override\n\tpublic final InetSocketAddress getAddress() {\n\t\tDatagramSocket socket = getSocket();\n\t\tint localPort = socket == null ? -1 : socket.getLocalPort();\n\t\tif (localPort < 0) {\n\t\t\treturn config.getAddress();\n\t\t} else {\n\t\t\treturn new InetSocketAddress(socket.getLocalAddress(), localPort);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if this connector is running.\n\t * \n\t * @return {@code true} if running.\n\t */\n\t@Override\n\tpublic final boolean isRunning() {\n\t\treturn running.get();\n\t}\n\n\t/**\n\t * A worker thread for continuously doing repetitive tasks.\n\t */\n\tprotected abstract class Worker extends Thread {\n\t\t/**\n\t\t * Instantiates a new worker.\n\t\t *\n\t\t * @param name the name, e.g., of the transport protocol\n\t\t */\n\t\tprotected Worker(String name) {\n\t\t\tsuper(NamedThreadFactory.SCANDIUM_THREAD_GROUP, name);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tLOGGER.info(\"Starting worker thread [{}]\", getName());\n\t\t\t\twhile (running.get()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdoWork();\n\t\t\t\t\t} catch (InterruptedIOException e) {\n\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\tLOGGER.info(\"Worker thread [{}] IO has been interrupted\", getName());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGGER.debug(\"Worker thread [{}] IO has been interrupted\", getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\tLOGGER.info(\"Worker thread [{}] has been interrupted\", getName());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGGER.debug(\"Worker thread [{}] has been interrupted\", getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\tLOGGER.debug(\"Exception thrown by worker thread [{}]\", getName(), e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGGER.trace(\"Exception thrown by worker thread [{}]\", getName(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tLOGGER.info(\"Worker thread [{}] has terminated\", getName());\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Does the actual work.\n\t\t * \n\t\t * Subclasses should do the repetitive work here.\n\t\t * \n\t\t * @throws Exception if something goes wrong\n\t\t */\n\t\tprotected abstract void doWork() throws Exception;\n\t}\n\n\t/**\n\t * Future implementation for tasks passed in to the serial executors for each\n\t * connection.\n\t */\n\tprivate static class ForEachFuture implements Future<Void> {\n\n\t\tprivate final Lock lock = new ReentrantLock();\n\t\tprivate final Condition waitDone = lock.newCondition();\n\t\tprivate volatile boolean cancel;\n\t\tprivate volatile boolean done;\n\t\tprivate volatile Exception exception;\n\n\t\t/**\n\t\t * {@inheritDoc}\n\t\t * \n\t\t * Cancel iteration for each connection.\n\t\t * \n\t\t * Note: if a connection serial execution busy executing a different\n\t\t * blocking task, cancel will not interrupt that task!\n\t\t */\n\t\t@Override\n\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\tboolean cancelled = false;\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tif (!done && !cancel) {\n\t\t\t\t\tcancelled = true;\n\t\t\t\t\tcancel = true;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t\treturn cancelled;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCancelled() {\n\t\t\treturn cancel;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDone() {\n\t\t\treturn done;\n\t\t}\n\n\t\t@Override\n\t\tpublic Void get() throws InterruptedException, ExecutionException {\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tif (!done) {\n\t\t\t\t\twaitDone.await();\n\t\t\t\t}\n\t\t\t\tif (exception != null) {\n\t\t\t\t\tthrow new ExecutionException(exception);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tif (!done) {\n\t\t\t\t\twaitDone.await(timeout, unit);\n\t\t\t\t}\n\t\t\t\tif (exception != null) {\n\t\t\t\t\tthrow new ExecutionException(exception);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Signals, that the task has completed.\n\t\t */\n\t\tpublic void done() {\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tdone = true;\n\t\t\t\twaitDone.signalAll();\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\n\t\tpublic void failed(Exception exception) {\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tthis.exception = exception;\n\t\t\t\tdone = true;\n\t\t\t\twaitDone.signalAll();\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isStopped() {\n\t\t\treturn done || cancel;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setRawDataReceiver(final RawDataChannel messageHandler) {\n\t\tif (isRunning()) {\n\t\t\tthrow new IllegalStateException(\"message handler cannot be set on running connector\");\n\t\t}\n\t\tthis.messageHandler = messageHandler;\n\t}\n\n\t@Override\n\tpublic void setEndpointContextMatcher(EndpointContextMatcher endpointContextMatcher) {\n\t\tthis.endpointContextMatcher = endpointContextMatcher;\n\t}\n\n\tprivate EndpointContextMatcher getEndpointContextMatcher() {\n\t\treturn endpointContextMatcher;\n\t}\n\n\t/**\n\t * Get effective handshake mode.\n\t * \n\t * Either the handshake mode provided in the message's endpoint-context, see\n\t * {@link DtlsEndpointContext#KEY_HANDSHAKE_MODE}, or, if that is not\n\t * available, the default from the configuration\n\t * {@link DtlsConnectorConfig#getDefaultHandshakeMode()}.\n\t * \n\t * @param message message to be sent\n\t * @return effective handshake mode.\n\t * @since 2.1\n\t */\n\tprivate String getEffectiveHandshakeMode(RawData message) {\n\t\tString mode = message.getEndpointContext().get(DtlsEndpointContext.KEY_HANDSHAKE_MODE);\n\t\tif (mode == null) {\n\t\t\tmode = defaultHandshakeMode;\n\t\t}\n\t\treturn mode;\n\t}\n\t\n\t/**\n\t * Sets a handler to call back if an alert message is received from a peer.\n\t * <p>\n\t * Setting a handler using this method is useful to be notified when a peer closes\n\t * an existing connection, i.e. when the alert message has not been received during\n\t * a handshake but after the connection has been established.\n\t * <p>\n\t * The handler can be set (and changed) at any time, either before the connector has\n\t * been started or when the connector is already running.\n\t * <p>\n\t * Application code interested in being notified when a particular message cannot be sent,\n\t * e.g. due to a failing DTLS handshake that has been triggered as part of sending\n\t * the message, should instead register a\n\t * {@code org.eclipse.californium.core.coap.MessageObserver} on the message and\n\t * implement its <em>onSendError</em> method accordingly.\n\t * \n\t * @param handler The handler to notify.\n\t */\n\tpublic final void setAlertHandler(AlertHandler handler) {\n\t\tsynchronized (alertHandlerLock) {\n\t\t\tthis.alertHandler = handler;\n\t\t}\n\t}\n\n\t/**\n\t * Handle a exception occurring during the handshake.\n\t * \n\t * @param cause exception\n\t * @param level alert level\n\t * @param description alert description\n\t * @param connection connection\n\t * @param record related received record. Since 2.3, this may be\n\t *            {@code null} in order to support exception during processing\n\t *            of a asynchronous master secret result.\n\t */\n\tprivate void handleExceptionDuringHandshake(HandshakeException cause, Connection connection, Record record) {\n\t\tAlertMessage alert = cause.getAlert();\n\t\t// discard none fatal alert exception\n\t\tif (!AlertLevel.FATAL.equals(alert.getLevel())) {\n\t\t\tif (record != null) {\n\t\t\t\tdiscardRecord(record, cause);\n\t\t\t}\n\t\t\thandleAlertInternal(alert.getPeer(), alert, connection);\n\t\t\treturn;\n\t\t}\n\n\t\t// \"Unknown identity\" and \"bad PSK\" should be both handled in a same way.\n\t\t// Generally \"bad PSK\" means invalid MAC on FINISHED message.\n\t\t// In production both should be silently ignored : https://bugs.eclipse.org/bugs/show_bug.cgi?id=533258\n\t\tif (AlertDescription.UNKNOWN_PSK_IDENTITY.equals(alert.getDescription())) {\n\t\t\tif (record != null) {\n\t\t\t\tdiscardRecord(record, cause);\n\t\t\t}\n\t\t\thandleAlertInternal(alert.getPeer(), alert, connection);\n\t\t\treturn;\n\t\t}\n\n\t\t// in other cases terminate handshake\n\t\tterminateOngoingHandshake(connection, cause);\n\t}\n\n\t/**\n\t * Handle alert internally.\n\t * \n\t * Keeps first reported alert as root cause and reports that to the\n\t * {@link AlertHandler}, if available.\n\t * \n\t * @param peer pper's address\n\t * @param alert received alert or detected alert\n\t * @param connection connection affected by that alert\n\t * @since 2.5\n\t */\n\tprivate void handleAlertInternal(InetSocketAddress peer, AlertMessage alert, Connection connection) {\n\t\tif (connection.getRootCauseAlert() == null) {\n\t\t\tconnection.setRootCause(alert);\n\t\t\tAlertHandler handler;\n\t\t\tsynchronized (alertHandlerLock) {\n\t\t\t\thandler = alertHandler;\n\t\t\t}\n\t\t\tif (handler != null) {\n\t\t\t\thandler.onAlert(peer, alert);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void discardRecord(final Record record, final Throwable cause) {\n\t\tif (health != null) {\n\t\t\thealth.receivingRecord(true);\n\t\t}\n\t\tbyte[] bytes = record.getFragmentBytes();\n\t\tif (DROP_LOGGER.isTraceEnabled()) {\n\t\t\tString hexString = StringUtil.byteArray2HexString(bytes, StringUtil.NO_SEPARATOR, 64);\n\t\t\tDROP_LOGGER.trace(\"Discarding received {} record (epoch {}, payload: {}) from peer [{}]: \", record.getType(),\n\t\t\t\t\trecord.getEpoch(), hexString, record.getPeerAddress(), cause);\n\t\t} else if (DROP_LOGGER.isDebugEnabled()) {\n\t\t\tString hexString = StringUtil.byteArray2HexString(bytes, StringUtil.NO_SEPARATOR, 16);\n\t\t\tDROP_LOGGER.debug(\"Discarding received {} record (epoch {}, payload: {}) from peer [{}]: {}\", record.getType(),\n\t\t\t\t\trecord.getEpoch(), hexString, record.getPeerAddress(), cause.getMessage());\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getProtocol() {\n\t\treturn \"DTLS\";\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtocol() + \"-\" + StringUtil.toString(getAddress());\n\t}\n\t\n}\n", "/*******************************************************************************\n * Copyright (c) 2015, 2017 Bosch Software Innovations GmbH and others.\n * \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n * \n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v20.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n * \n * Contributors:\n *    Kai Hudalla (Bosch Software Innovations GmbH) - Initial creation\n *    Achim Kraus (Bosch Software Innovations GmbH) - add empty implementation\n *                                                    for handshakeFailed.\n *    Achim Kraus (Bosch Software Innovations GmbH) - use final for collections\n *    Bosch Software Innovations GmbH - migrate to SLF4J\n *    Achim Kraus (Bosch Software Innovations GmbH) - configure LRU to return\n *                                                    expired entries on read access.\n *                                                    See issue #707\n *    Achim Kraus (Bosch Software Innovations GmbH) - configure LRU to update\n *                                                    connection only, if access\n *                                                    is validated with the MAC\n *    Achim Kraus (Bosch Software Innovations GmbH) - fix session resumption with\n *                                                    session cache. issue #712\n *    Achim Kraus (Bosch Software Innovations GmbH) - add more logging\n *    Achim Kraus (Bosch Software Innovations GmbH) - restore connection from\n *                                                    client session cache,\n *                                                    when provided.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add putEstablishedSession\n *                                                    and removeFromEstablishedSessions\n *                                                    for faster find\n ******************************************************************************/\npackage org.eclipse.californium.scandium.dtls;\n\nimport java.net.InetSocketAddress;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.eclipse.californium.elements.util.LeastRecentlyUsedCache;\nimport org.eclipse.californium.elements.util.SerialExecutor;\nimport org.eclipse.californium.elements.util.StringUtil;\nimport org.eclipse.californium.scandium.ConnectionListener;\nimport org.eclipse.californium.scandium.util.SecretUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An in-memory <code>ResumptionSupportingConnectionStore</code> with a\n * configurable maximum capacity and support for evicting stale connections\n * based on a <em>least recently used</em> policy.\n * <p>\n * The store keeps track of the connections' last-access time automatically.\n * Every time a connection is read from or put to the store the access-time is\n * updated.\n * </p>\n * <p>\n * A connection can be successfully added to the store if any of the following\n * conditions is met:\n * </p>\n * <ul>\n * <li>The store's remaining capacity is greater than zero.</li>\n * <li>The store contains at least one <em>stale</em> connection, i.e. a\n * connection that has not been accessed for at least the store's <em>\n * connection expiration threshold</em> period. In such a case the least\n * recently accessed stale connection gets evicted from the store to make place\n * for the new connection to be added.</li>\n * </ul>\n * <p>\n * This implementation uses three <code>java.util.HashMap</code>. One with a\n * connection's id as key as its backing store, one with the peer address as\n * key, and one with the session id as key. In addition to that the store keeps\n * a doubly-linked list of the connections in access-time order.\n * </p>\n * <p>\n * Insertion, lookup and removal of connections is done in <em>O(log n)</em>.\n * </p>\n * <p>\n * Storing and reading to/from the store is thread safe.\n * </p>\n * <p>\n * Supports also a {@link SessionCache} implementation to keep sessions for\n * longer or in a distribute system. If this store evicts a connection in order\n * to gain storage for new connections, the associated session remains in the\n * cache. Therefore the cache requires a own, independent cleanup for stale\n * sessions. If a connection is removed by a critical ALERT, the session get's\n * removed also from the cache.\n * </p>\n */\n@SuppressWarnings(\"deprecation\")\npublic class InMemoryConnectionStore implements ResumptionSupportingConnectionStore, CloseSupportingConnectionStore {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(InMemoryConnectionStore.class);\n\tprivate static final int DEFAULT_SMALL_EXTRA_CID_LENGTH = 2; // extra cid bytes additionally to required bytes for small capacity.\n\tprivate static final int DEFAULT_LARGE_EXTRA_CID_LENGTH = 3; // extra cid bytes additionally to required bytes for large capacity.\n\tprivate static final int DEFAULT_CACHE_SIZE = 150000;\n\tprivate static final long DEFAULT_EXPIRATION_THRESHOLD = 36 * 60 * 60; // 36h\n\tprivate final SessionCache sessionCache;\n\tprotected final LeastRecentlyUsedCache<ConnectionId, Connection> connections;\n\tprotected final ConcurrentMap<InetSocketAddress, Connection> connectionsByAddress;\n\tprotected final ConcurrentMap<SessionId, Connection> connectionsByEstablishedSession;\n\n\tprivate ConnectionListener connectionListener;\n\t/**\n\t * Connection id generator.\n\t * \n\t * @see #attach(ConnectionIdGenerator)\n\t */\n\tprivate ConnectionIdGenerator connectionIdGenerator;\n\n\tprotected String tag = \"\";\n\n\t/**\n\t * Creates a store with a capacity of 500000 connections and\n\t * a connection expiration threshold of 36 hours.\n\t */\n\tpublic InMemoryConnectionStore() {\n\t\tthis(DEFAULT_CACHE_SIZE, DEFAULT_EXPIRATION_THRESHOLD, null);\n\t}\n\n\t/**\n\t * Creates a store with a capacity of 500000 connections and a connection\n\t * expiration threshold of 36 hours.\n\t * \n\t * @param sessionCache a second level cache to use for <em>current</em>\n\t *            connection state of established DTLS sessions.\n\t */\n\tpublic InMemoryConnectionStore(final SessionCache sessionCache) {\n\t\tthis(DEFAULT_CACHE_SIZE, DEFAULT_EXPIRATION_THRESHOLD, sessionCache);\n\t}\n\n\t/**\n\t * Creates a store based on given configuration parameters.\n\t * \n\t * @param capacity the maximum number of connections the store can manage\n\t * @param threshold the period of time of inactivity (in seconds) after which a\n\t *            connection is considered stale and can be evicted from the store if\n\t *            a new connection is to be added to the store\n\t */\n\tpublic InMemoryConnectionStore(final int capacity, final long threshold) {\n\t\tthis(capacity, threshold, null);\n\t}\n\n\t/**\n\t * Creates a store based on given configuration parameters.\n\t * \n\t * @param capacity the maximum number of connections the store can manage\n\t * @param threshold the period of time of inactivity (in seconds) after\n\t *            which a connection is considered stale and can be evicted from\n\t *            the store if a new connection is to be added to the store\n\t * @param sessionCache a second level cache to use for <em>current</em>\n\t *            connection state of established DTLS sessions. If implements\n\t *            {@link ClientSessionCache}, restore connection from the cache\n\t *            and mark them to resume.\n\t */\n\tpublic InMemoryConnectionStore(int capacity, long threshold, SessionCache sessionCache) {\n\t\tthis.connections = new LeastRecentlyUsedCache<>(capacity, threshold);\n\t\tthis.connections.setEvictingOnReadAccess(false);\n\t\tthis.connections.setUpdatingOnReadAccess(false);\n\t\tthis.connectionsByEstablishedSession = new ConcurrentHashMap<>();\n\t\tthis.connectionsByAddress = new ConcurrentHashMap<>();\n\t\tthis.sessionCache = sessionCache;\n\n\t\t// make sure that session state for stale (evicted) connections is removed from second level cache\n\t\tconnections.addEvictionListener(new LeastRecentlyUsedCache.EvictionListener<Connection>() {\n\n\t\t\t@Override\n\t\t\tpublic void onEviction(final Connection staleConnection) {\n\t\t\t\tRunnable remove = new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tHandshaker handshaker = staleConnection.getOngoingHandshake();\n\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\thandshaker.handshakeFailed(new ConnectionEvictedException(\"Evicted!\", staleConnection.getPeerAddress()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsynchronized (InMemoryConnectionStore.this) {\n\t\t\t\t\t\t\tremoveFromAddressConnections(staleConnection);\n\t\t\t\t\t\t\tremoveFromEstablishedSessions(staleConnection);\n\t\t\t\t\t\t\tConnectionListener listener = connectionListener;\n\t\t\t\t\t\t\tif (listener != null) {\n\t\t\t\t\t\t\t\tlistener.onConnectionRemoved(staleConnection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (staleConnection.isExecuting()) {\n\t\t\t\t\tstaleConnection.getExecutor().execute(remove);\n\t\t\t\t} else {\n\t\t\t\t\tremove.run();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tLOG.info(\"Created new InMemoryConnectionStore [capacity: {}, connection expiration threshold: {}s]\",\n\t\t\t\tcapacity, threshold);\n\t}\n\n\t/**\n\t * Set tag for logging outputs.\n\t * \n\t * @param tag tag for logging\n\t * @return this connection store for calls chaining\n\t */\n\tpublic synchronized InMemoryConnectionStore setTag(final String tag) {\n\t\tthis.tag = StringUtil.normalizeLoggingTag(tag);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a new unused connection id.\n\t * \n\t * @return connection id, or {@code null}, if no free connection id could\n\t *         created\n\t * @see #connectionIdGenerator\n\t * @see ConnectionIdGenerator\n\t */\n\tprivate ConnectionId newConnectionId() {\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\tConnectionId cid = connectionIdGenerator.createConnectionId();\n\t\t\tif (connections.get(cid) == null) {\n\t\t\t\treturn cid;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setConnectionListener(ConnectionListener listener) {\n\t\tthis.connectionListener = listener;\n\t}\n\n\t@Override\n\tpublic void attach(ConnectionIdGenerator connectionIdGenerator) {\n\t\tif (this.connectionIdGenerator != null) {\n\t\t\tthrow new IllegalStateException(\"Connection id generator already attached!\");\n\t\t}\n\t\tif (connectionIdGenerator == null || !connectionIdGenerator.useConnectionId()) {\n\t\t\tint bits = Integer.SIZE - Integer.numberOfLeadingZeros(connections.getCapacity());\n\t\t\tint cidLength = ((bits + 7) / 8); // required bytes for capacity\n\t\t\tcidLength += (cidLength < 3) ? DEFAULT_SMALL_EXTRA_CID_LENGTH : DEFAULT_LARGE_EXTRA_CID_LENGTH;\n\t\t\tthis.connectionIdGenerator = new SingleNodeConnectionIdGenerator(cidLength);\n\t\t} else {\n\t\t\tthis.connectionIdGenerator = connectionIdGenerator;\n\t\t}\n\t\tif (sessionCache instanceof ClientSessionCache) {\n\t\t\tClientSessionCache clientCache = (ClientSessionCache) sessionCache;\n\t\t\tLOG.debug(\"resume client sessions {}\", clientCache);\n\t\t\tfor (InetSocketAddress peer : clientCache) {\n\t\t\t\tSessionTicket ticket = clientCache.getSessionTicket(peer);\n\t\t\t\tSessionId id = clientCache.getSessionIdentity(peer);\n\t\t\t\tif (ticket != null && id != null) {\n\t\t\t\t\t// restore connection from session ticket\n\t\t\t\t\tConnection connection = new Connection(ticket, id, peer);\n\t\t\t\t\tConnectionId connectionId = newConnectionId();\n\t\t\t\t\tif (connectionId != null) {\n\t\t\t\t\t\tconnection.setConnectionId(connectionId);\n\t\t\t\t\t\tconnections.put(connectionId, connection);\n\t\t\t\t\t\tconnectionsByAddress.put(peer, connection);\n\t\t\t\t\t\tLOG.debug(\"{}resume {} {}\", tag, peer, id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.info(\"{}drop session {} {}, could not allocated cid!\", tag, peer, id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\t/**\n\t * {@inheritDoc}\n\t * <p>\n\t * A connection can be successfully added to the store if any of the\n\t * following conditions is met:\n\t * <ul>\n\t * <li>The store's remaining capacity is greater than zero.</li>\n\t * <li>The store contains at least one <em>stale</em> connection, i.e. a\n\t * connection that has not been accessed for at least the store's <em>\n\t * connection expiration threshold</em> period. In such a case the least-\n\t * recently accessed stale connection gets evicted from the store to make\n\t * place for the new connection to be added.</li>\n\t * </ul>\n\t */\n\t@Override\n\tpublic synchronized boolean put(final Connection connection) {\n\n\t\tif (connection != null) {\n\t\t\tif (!connection.isExecuting()) {\n\t\t\t\tthrow new IllegalStateException(\"Connection is not executing!\");\n\t\t\t}\n\t\t\tConnectionId connectionId = connection.getConnectionId();\n\t\t\tif (connectionId == null) {\n\t\t\t\tif (connectionIdGenerator == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Connection id generator must be attached before!\");\n\t\t\t\t}\n\t\t\t\tconnectionId = newConnectionId();\n\t\t\t\tif (connectionId == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Connection ids exhausted!\");\n\t\t\t\t}\n\t\t\t\tconnection.setConnectionId(connectionId);\n\t\t\t} else if (connectionId.isEmpty()) {\n\t\t\t\tthrow new IllegalStateException(\"Connection must have a none empty connection id!\");\n\t\t\t} else if (connections.get(connectionId) != null) {\n\t\t\t\tthrow new IllegalStateException(\"Connection id already used! \" + connectionId);\n\t\t\t}\n\t\t\tif (connections.put(connectionId, connection)) {\n\t\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\t\tLOG.trace(\"{}connection: add {} (size {})\", tag, connection, connections.size(), new Throwable(\"connection added!\"));\n\t\t\t\t} else {\n\t\t\t\t\tLOG.debug(\"{}connection: add {} (size {})\", tag, connectionId, connections.size());\n\t\t\t\t}\n\t\t\t\taddToAddressConnections(connection);\n\t\t\t\tDTLSSession session = connection.getEstablishedSession();\n\t\t\t\tif (session != null) {\n\t\t\t\t\tputEstablishedSession(session, connection);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tLOG.warn(\"{}connection store is full! {} max. entries.\", tag, connections.getCapacity());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic synchronized boolean update(final Connection connection, InetSocketAddress newPeerAddress) {\n\t\tif (connection == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (connections.update(connection.getConnectionId())) {\n\t\t\tif (newPeerAddress == null) {\n\t\t\t\tLOG.debug(\"{}connection: {} updated usage!\", tag, connection.getConnectionId());\n\t\t\t} else if (!connection.equalsPeerAddress(newPeerAddress)) {\n\t\t\t\tInetSocketAddress oldPeerAddress = connection.getPeerAddress();\n\t\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\t\tLOG.trace(\"{}connection: {} updated, address changed from {} to {}!\", tag,\n\t\t\t\t\t\t\tconnection.getConnectionId(), oldPeerAddress, newPeerAddress,\n\t\t\t\t\t\t\tnew Throwable(\"connection updated!\"));\n\t\t\t\t} else {\n\t\t\t\t\tLOG.debug(\"{}connection: {} updated, address changed from {} to {}!\", tag,\n\t\t\t\t\t\t\tconnection.getConnectionId(), oldPeerAddress, newPeerAddress);\n\t\t\t\t}\n\t\t\t\tif (oldPeerAddress != null) {\n\t\t\t\t\tconnectionsByAddress.remove(oldPeerAddress, connection);\n\t\t\t\t\tconnection.updatePeerAddress(null);\n\t\t\t\t}\n\t\t\t\tconnection.updatePeerAddress(newPeerAddress);\n\t\t\t\taddToAddressConnections(connection);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tLOG.debug(\"{}connection: {} - {} update failed!\", tag, connection.getConnectionId(), newPeerAddress);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * \n\t * @deprecated since 2.3 obsolete, see {@link Connection#close(Record)}.\n\t */\n\t@Deprecated\n\t@Override\n\tpublic synchronized boolean removeFromAddress(final Connection connection) {\n\t\tif (connection != null) {\n\t\t\tInetSocketAddress peerAddress = connection.getPeerAddress();\n\t\t\tif (peerAddress != null) {\n\t\t\t\tLOG.debug(\"{}connection: {} removed from address {}!\", tag, connection.getConnectionId(), peerAddress);\n\t\t\t\tconnectionsByAddress.remove(peerAddress, connection);\n\t\t\t\tconnection.updatePeerAddress(null);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic synchronized void putEstablishedSession(final DTLSSession session, final Connection connection) {\n\t\tConnectionListener listener = connectionListener;\n\t\tif (listener != null) {\n\t\t\tlistener.onConnectionEstablished(connection);\n\t\t}\n\t\tSessionId sessionId = session.getSessionIdentifier();\n\t\tif (!sessionId.isEmpty()) {\n\t\t\tif (sessionCache != null) {\n\t\t\t\tsessionCache.put(session);\n\t\t\t}\n\t\t\tfinal Connection previous = connectionsByEstablishedSession.put(sessionId, connection);\n\t\t\tif (previous != null && previous != connection) {\n\t\t\t\tRunnable removePreviousConnection = new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tremove(previous, false);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (previous.isExecuting()) {\n\t\t\t\t\tprevious.getExecutor().execute(removePreviousConnection);\n\t\t\t\t} else {\n\t\t\t\t\tremovePreviousConnection.run();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic synchronized void removeFromEstablishedSessions(final DTLSSession session, final Connection connection) {\n\t\tSessionId sessionId = session.getSessionIdentifier();\n\t\tif (!sessionId.isEmpty()) {\n\t\t\tconnectionsByEstablishedSession.remove(sessionId, connection);\n\t\t}\n\t}\n\n\t@Override\n\tpublic synchronized Connection find(final SessionId id) {\n\n\t\tif (id == null || id.isEmpty()) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tConnection conFromLocalCache = findLocally(id);\n\n\t\t\tif (sessionCache == null) {\n\n\t\t\t\treturn conFromLocalCache;\n\n\t\t\t} else {\n\n\t\t\t\t// make sure a stale session cannot be resumed\n\t\t\t\tSessionTicket ticket = sessionCache.get(id);\n\t\t\t\tif (ticket == null) {\n\t\t\t\t\t// either a session with the given ID has never been established (on other nodes)\n\t\t\t\t\t// or another node has removed the session from the cache, e.g. because it became\n\t\t\t\t\t// stale\n\n\t\t\t\t\tif (conFromLocalCache != null) {\n\t\t\t\t\t\t// remove corresponding connection from this store\n\t\t\t\t\t\tremove(conFromLocalCache, false);\n\t\t\t\t\t\t// TODO: should we send a fatal alert to peer in this case?\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t} else if (conFromLocalCache == null) {\n\t\t\t\t\t// this probably means that we are taking over the session from a failed node\n\t\t\t\t\treturn new Connection(ticket, id, null);\n\t\t\t\t\t// connection will be put to first level cache as part of\n\t\t\t\t\t// the abbreviated handshake\n\t\t\t\t} else {\n\t\t\t\t\t// resume connection found in local cache (i.e. this store)\n\t\t\t\t\treturn conFromLocalCache;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate synchronized Connection findLocally(final SessionId id) {\n\t\tConnection connection = connectionsByEstablishedSession.get(id);\n\t\tif (connection != null) {\n\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\tif (establishedSession != null) {\n\t\t\t\tif (!establishedSession.getSessionIdentifier().equals(id)) {\n\t\t\t\t\tLOG.warn(\"{}connection {} changed session {}!={}!\", tag, connection.getConnectionId(), id,\n\t\t\t\t\t\t\testablishedSession.getSessionIdentifier());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG.warn(\"{}connection {} lost session {}!\", tag, connection.getConnectionId(), id);\n\t\t\t}\n\t\t\tconnections.update(connection.getConnectionId());\n\t\t}\n\t\treturn connection;\n\t}\n\n\t@Override\n\tpublic synchronized void markAllAsResumptionRequired() {\n\t\tfor (Connection connection : connections.values()) {\n\t\t\tif (connection.getPeerAddress() != null && !connection.isResumptionRequired()) {\n\t\t\t\tconnection.setResumptionRequired(true);\n\t\t\t\tLOG.debug(\"{}connection: mark for resumption {}!\", tag, connection);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic synchronized int remainingCapacity() {\n\t\tint remaining = connections.remainingCapacity();\n\t\tLOG.debug(\"{}connection: size {}, remaining {}!\", tag, connections.size(), remaining);\n\t\treturn remaining;\n\t}\n\n\t@Override\n\tpublic synchronized Connection get(final InetSocketAddress peerAddress) {\n\t\tConnection connection = connectionsByAddress.get(peerAddress);\n\t\tif (connection == null) {\n\t\t\tLOG.debug(\"{}connection: missing connection for {}!\", tag, peerAddress);\n\t\t} else {\n\t\t\tInetSocketAddress address = connection.getPeerAddress();\n\t\t\tif (address == null) {\n\t\t\t\tLOG.warn(\"{}connection {} lost ip-address {}!\", tag, connection.getConnectionId(), peerAddress);\n\t\t\t} else if (!address.equals(peerAddress)) {\n\t\t\t\tLOG.warn(\"{}connection {} changed ip-address {}!={}!\", tag, connection.getConnectionId(), peerAddress, address);\n\t\t\t}\n\t\t}\n\t\treturn connection;\n\t}\n\n\t@Override\n\tpublic synchronized Connection get(final ConnectionId cid) {\n\t\tConnection connection = connections.get(cid);\n\t\tif (connection == null) {\n\t\t\tLOG.debug(\"{}connection: missing connection for {}!\", tag, cid);\n\t\t} else {\n\t\t\tConnectionId connectionId = connection.getConnectionId();\n\t\t\tif (connectionId == null) {\n\t\t\t\tLOG.warn(\"{}connection lost cid {}!\", tag,  cid);\n\t\t\t} else if (!connectionId.equals(cid)) {\n\t\t\t\tLOG.warn(\"{}connection changed cid {}!={}!\", tag, connectionId, cid);\n\t\t\t}\n\t\t}\n\t\treturn connection;\n\t}\n\n\t@Override\n\tpublic boolean remove(final Connection connection) {\n\t\treturn remove(connection, true);\n\t}\n\n\t@Override\n\tpublic synchronized boolean remove(final Connection connection, final boolean removeFromSessionCache) {\n\t\tboolean removed = connections.remove(connection.getConnectionId(), connection) == connection;\n\t\tif (removed) {\n\t\t\tList<Runnable> pendings = connection.getExecutor().shutdownNow();\n\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\tLOG.trace(\"{}connection: remove {} (size {}, left jobs: {})\", tag, connection, connections.size(),\n\t\t\t\t\t\tpendings.size(), new Throwable(\"connection removed!\"));\n\t\t\t} else if (pendings.isEmpty()) {\n\t\t\t\tLOG.debug(\"{}connection: remove {} (size {})\", tag, connection, connections.size());\n\t\t\t} else {\n\t\t\t\tLOG.debug(\"{}connection: remove {} (size {}, left jobs: {})\", tag, connection, connections.size(),\n\t\t\t\t\t\tpendings.size());\n\t\t\t}\n\t\t\tremoveFromEstablishedSessions(connection);\n\t\t\tremoveFromAddressConnections(connection);\n\t\t\tif (removeFromSessionCache) {\n\t\t\t\tremoveSessionFromCache(connection);\n\t\t\t}\n\t\t\tConnectionListener listener = connectionListener;\n\t\t\tif (listener != null) {\n\t\t\t\tlistener.onConnectionRemoved(connection);\n\t\t\t}\n\t\t}\n\t\treturn removed;\n\t}\n\n\tprivate void removeFromEstablishedSessions(Connection connection) {\n\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\tif (establishedSession != null) {\n\t\t\tSessionId sessionId = establishedSession.getSessionIdentifier();\n\t\t\tconnectionsByEstablishedSession.remove(sessionId, connection);\n\t\t\tSecretUtil.destroy(establishedSession);\n\t\t}\n\t}\n\n\tprivate void removeFromAddressConnections(Connection connection) {\n\t\tInetSocketAddress peerAddress = connection.getPeerAddress();\n\t\tif (peerAddress != null) {\n\t\t\tconnectionsByAddress.remove(peerAddress, connection);\n\t\t\tconnection.updatePeerAddress(null);\n\t\t}\n\t}\n\n\tprivate synchronized void removeSessionFromCache(final Connection connection) {\n\t\tif (sessionCache != null) {\n\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\tif (establishedSession != null) {\n\t\t\t\tSessionId sessionId = establishedSession.getSessionIdentifier();\n\t\t\t\tsessionCache.remove(sessionId);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void addToAddressConnections(Connection connection) {\n\t\tfinal InetSocketAddress peerAddress = connection.getPeerAddress();\n\t\tif (peerAddress != null) {\n\t\t\tfinal Connection previous = connectionsByAddress.put(peerAddress, connection);\n\t\t\tif (previous != null && previous != connection) {\n\t\t\t\tRunnable removeAddress = new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tif (previous.equalsPeerAddress(peerAddress)) {\n\t\t\t\t\t\t\tprevious.updatePeerAddress(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tLOG.debug(\"{}connection: {} - {} added! {} removed from address.\", tag, connection.getConnectionId(),\n\t\t\t\t\t\tpeerAddress, previous.getConnectionId());\n\t\t\t\tif (previous.isExecuting()) {\n\t\t\t\t\tprevious.getExecutor().execute(removeAddress);\n\t\t\t\t} else {\n\t\t\t\t\tremoveAddress.run();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG.debug(\"{}connection: {} - {} added!\", tag, connection.getConnectionId(), peerAddress);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG.debug(\"{}connection: {} - missing address!\", tag, connection.getConnectionId());\n\t\t}\n\t}\n\n\t@Override\n\tpublic final synchronized void clear() {\n\t\tfor (Connection connection : connections.values()) {\n\t\t\tSerialExecutor executor = connection.getExecutor();\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.shutdownNow();\n\t\t\t}\n\t\t}\n\t\tconnections.clear();\n\t\tconnectionsByEstablishedSession.clear();\n\t\tconnectionsByAddress.clear();\n\t\t// TODO: does it make sense to clear the SessionCache as well?\n\t}\n\n\t@Override\n\tpublic final synchronized void stop(List<Runnable> pending) {\n\t\tfor (Connection connection : connections.values()) {\n\t\t\tSerialExecutor executor = connection.getExecutor();\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.shutdownNow(pending);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * \n\t * @see LeastRecentlyUsedCache#valuesIterator()\n\t */\n\t@Override\n\tpublic Iterator<Connection> iterator() {\n\t\treturn connections.valuesIterator();\n\t}\n\n}\n"], "fixing_code": ["/*******************************************************************************\n * Copyright (c) 2015, 2018 Institute for Pervasive Computing, ETH Zurich and others.\n * \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n * \n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v20.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n * \n * Contributors:\n *    Matthias Kovatsch - creator and main architect\n *    Stefan Jucker - DTLS implementation\n *    Julien Vermillard - Sierra Wireless\n *    Kai Hudalla (Bosch Software Innovations GmbH) - add duplicate record detection\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 462463\n *    Kai Hudalla (Bosch Software Innovations GmbH) - re-factor configuration\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 464383\n *    Kai Hudalla (Bosch Software Innovations GmbH) - add support for stale\n *                                                    session expiration (466554)\n *    Kai Hudalla (Bosch Software Innovations GmbH) - replace SessionStore with ConnectionStore\n *                                                    keeping all information about the connection\n *                                                    to a peer in a single place\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 472196\n *    Achim Kraus, Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 478538\n *    Kai Hudalla (Bosch Software Innovations GmbH) - derive max datagram size for outbound messages\n *                                                    from network MTU\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 483371\n *    Benjamin Cabe - fix typos in logger\n *    Kai Hudalla (Bosch Software Innovations GmbH) - use SessionListener to trigger sending of pending\n *                                                    APPLICATION messages\n *    Bosch Software Innovations GmbH - set correlation context on sent/received messages\n *                                      (fix GitHub issue #1)\n *    Achim Kraus (Bosch Software Innovations GmbH) - use CorrelationContextMatcher\n *                                                    for outgoing messages\n *                                                    (fix GitHub issue #104)\n *    Achim Kraus (Bosch Software Innovations GmbH) - introduce synchronized getSocket()\n *                                                    as pair to synchronized releaseSocket().\n *    Achim Kraus (Bosch Software Innovations GmbH) - restart internal executor\n *    Achim Kraus (Bosch Software Innovations GmbH) - processing retransmission of flight\n *                                                    after last flight was sent.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add onSent() and onError(). \n *                                                    issue #305\n *    Achim Kraus (Bosch Software Innovations GmbH) - Change RetransmitTask to\n *                                                    schedule a \"stripped job\"\n *                                                    instead of executing \n *                                                    handleTimeout directly.\n *                                                    cancel flight only, if they\n *                                                    should not be retransmitted\n *                                                    anymore.\n *    Achim Kraus (Bosch Software Innovations GmbH) - call handshakeFailed on \n *                                                    terminateOngoingHandshake,\n *                                                    processAlertRecord, \n *                                                    handleTimeout,\n *                                                    and add error callback in\n *                                                    newDeferredMessageSender.\n *    Achim Kraus (Bosch Software Innovations GmbH) - reuse receive buffer and packet. \n *    Achim Kraus (Bosch Software Innovations GmbH) - use socket's reuseAddress only\n *                                                    if bindAddress determines a port\n *    Achim Kraus (Bosch Software Innovations GmbH) - introduce protocol,\n *                                                    remove scheme\n *    Achim Kraus (Bosch Software Innovations GmbH) - check for cancelled retransmission\n *                                                    before sending.\n *    Achim Kraus (Bosch Software Innovations GmbH) - move application handler call\n *                                                    out of synchronized block\n *    Achim Kraus (Bosch Software Innovations GmbH) - move creation of endpoint context\n *                                                    to DTLSSession\n *    Bosch Software Innovations GmbH - migrate to SLF4J\n *    Achim Kraus (Bosch Software Innovations GmbH) - add automatic resumption\n *    Achim Kraus (Bosch Software Innovations GmbH) - change receiver thread to\n *                                                    daemon\n *    Achim Kraus (Bosch Software Innovations GmbH) - response with alert, if \n *                                                    connection store is exhausted.\n *    Achim Kraus (Bosch Software Innovations GmbH) - fix double incrementing\n *                                                    pending outgoing message downcounter.\n *    Achim Kraus (Bosch Software Innovations GmbH) - update dtls session timestamp only,\n *                                                    if access is validated with the MAC \n *    Achim Kraus (Bosch Software Innovations GmbH) - fix session resumption with session cache\n *                                                    issue #712\n *                                                    execute jobs after shutdown to ensure, \n *                                                    onError is called for all pending messages. \n *    Achim Kraus (Bosch Software Innovations GmbH) - fix issues #716 and #717\n *                                                    change scopes to protected to support\n *                                                    subclass specific implementations.\n *    Achim Kraus (Bosch Software Innovations GmbH) - use session ticket when sending messages\n *                                                    over a connection marked for resumption.\n *    Achim Kraus (Bosch Software Innovations GmbH) - issue 744: use handshaker as \n *                                                    parameter for session listener.\n *                                                    Move session listener callback out of sync\n *                                                    block of processApplicationDataRecord.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add handshakeFlightRetransmitted\n *    Achim Kraus (Bosch Software Innovations GmbH) - add onConnecting and onDtlsRetransmission\n *    Achim Kraus (Bosch Software Innovations GmbH) - redesign connection session listener to\n *                                                    ensure, that the session listener methods\n *                                                    are called via the handshaker.\n *                                                    Move handshakeCompleted out on synchronized block.\n *                                                    When handshaker replaced, called handshakeFailed\n *                                                    on old to trigger sent error for pending messages.\n *                                                    Reuse ongoing handshaker instead of creating a new\n *                                                    one.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add multiple receiver threads.\n *                                                    move default thread numbers to configuration.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add cause to handshake failure.\n *    Achim Kraus (Bosch Software Innovations GmbH) - remove HELLO_VERIFY_REQUEST\n *                                                    from resumption handshakes\n *    Achim Kraus (Bosch Software Innovations GmbH) - extend deferred processed messages to\n *                                                    limited number of incoming and outgoing messages\n *                                                    extend executor names with specific prefix.\n *    Achim Kraus (Bosch Software Innovations GmbH) - fix reuse of already stopped serial\n *                                                    executors.\n *    Achim Kraus (Bosch Software Innovations GmbH) - remove unused RecordLayer.sendRecord\n *    Achim Kraus (Bosch Software Innovations GmbH) - redesign DTLSFlight and RecordLayer\n *                                                    add timeout for handshakes\n *    Achim Kraus (Bosch Software Innovations GmbH) - move serial executor into connection\n *                                                    process new CLIENT_HELLOs without\n *                                                    serial executor.\n ******************************************************************************/\npackage org.eclipse.californium.scandium;\n\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.NetworkInterface;\nimport java.net.PortUnreachableException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.Principal;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.MDC;\nimport org.eclipse.californium.elements.Connector;\nimport org.eclipse.californium.elements.DtlsEndpointContext;\nimport org.eclipse.californium.elements.EndpointContext;\nimport org.eclipse.californium.elements.EndpointContextMatcher;\nimport org.eclipse.californium.elements.exception.EndpointMismatchException;\nimport org.eclipse.californium.elements.exception.EndpointUnconnectedException;\nimport org.eclipse.californium.elements.exception.MulticastNotSupportedException;\nimport org.eclipse.californium.elements.RawData;\nimport org.eclipse.californium.elements.RawDataChannel;\nimport org.eclipse.californium.elements.util.ClockUtil;\nimport org.eclipse.californium.elements.util.DaemonThreadFactory;\nimport org.eclipse.californium.elements.util.DatagramReader;\nimport org.eclipse.californium.elements.util.ExecutorsUtil;\nimport org.eclipse.californium.elements.util.LeastRecentlyUsedCache;\nimport org.eclipse.californium.elements.util.NamedThreadFactory;\nimport org.eclipse.californium.elements.util.NetworkInterfacesUtil;\nimport org.eclipse.californium.elements.util.NoPublicAPI;\nimport org.eclipse.californium.elements.util.SerialExecutor;\nimport org.eclipse.californium.elements.util.StringUtil;\nimport org.eclipse.californium.scandium.config.DtlsConnectorConfig;\nimport org.eclipse.californium.scandium.dtls.AlertMessage;\nimport org.eclipse.californium.scandium.dtls.AlertMessage.AlertDescription;\nimport org.eclipse.californium.scandium.dtls.AlertMessage.AlertLevel;\nimport org.eclipse.californium.scandium.dtls.ApplicationMessage;\nimport org.eclipse.californium.scandium.dtls.AvailableConnections;\nimport org.eclipse.californium.scandium.dtls.ClientHandshaker;\nimport org.eclipse.californium.scandium.dtls.ClientHello;\nimport org.eclipse.californium.scandium.dtls.Connection;\nimport org.eclipse.californium.scandium.dtls.ConnectionEvictedException;\nimport org.eclipse.californium.scandium.dtls.ConnectionId;\nimport org.eclipse.californium.scandium.dtls.ConnectionIdGenerator;\nimport org.eclipse.californium.scandium.dtls.HandshakeResult;\nimport org.eclipse.californium.scandium.dtls.HandshakeResultHandler;\nimport org.eclipse.californium.scandium.dtls.ContentType;\nimport org.eclipse.californium.scandium.dtls.DTLSMessage;\nimport org.eclipse.californium.scandium.dtls.DTLSSession;\nimport org.eclipse.californium.scandium.dtls.DtlsException;\nimport org.eclipse.californium.scandium.dtls.DtlsHandshakeException;\nimport org.eclipse.californium.scandium.dtls.FragmentedHandshakeMessage;\nimport org.eclipse.californium.scandium.dtls.HandshakeException;\nimport org.eclipse.californium.scandium.dtls.HandshakeMessage;\nimport org.eclipse.californium.scandium.dtls.Handshaker;\nimport org.eclipse.californium.scandium.dtls.HelloVerifyRequest;\nimport org.eclipse.californium.scandium.dtls.InMemoryConnectionStore;\nimport org.eclipse.californium.scandium.dtls.PskSecretResult;\nimport org.eclipse.californium.scandium.dtls.MaxFragmentLengthExtension;\nimport org.eclipse.californium.scandium.dtls.ProtocolVersion;\nimport org.eclipse.californium.scandium.dtls.Record;\nimport org.eclipse.californium.scandium.dtls.RecordLayer;\nimport org.eclipse.californium.scandium.dtls.ResumingClientHandshaker;\nimport org.eclipse.californium.scandium.dtls.ResumingServerHandshaker;\nimport org.eclipse.californium.scandium.dtls.ResumptionSupportingConnectionStore;\nimport org.eclipse.californium.scandium.dtls.ServerHandshaker;\nimport org.eclipse.californium.scandium.dtls.ServerNameExtension;\nimport org.eclipse.californium.scandium.dtls.SessionAdapter;\nimport org.eclipse.californium.scandium.dtls.SessionCache;\nimport org.eclipse.californium.scandium.dtls.SessionId;\nimport org.eclipse.californium.scandium.dtls.SessionListener;\nimport org.eclipse.californium.scandium.dtls.SessionTicket;\nimport org.eclipse.californium.scandium.dtls.cipher.CipherSuite;\nimport org.eclipse.californium.scandium.dtls.pskstore.AdvancedPskStore;\nimport org.eclipse.californium.scandium.dtls.x509.NewAdvancedCertificateVerifier;\nimport org.eclipse.californium.scandium.util.SecretUtil;\nimport org.eclipse.californium.scandium.util.ServerNames;\n\n/**\n * A {@link Connector} using <em>Datagram TLS</em> (DTLS) as specified in\n * <a href=\"http://tools.ietf.org/html/rfc6347\">RFC 6347</a> for securing data\n * exchanged between networked clients and a server application.\n * \n * Note: using IPv6 interfaces with multiple addresses including permanent and\n * temporary (with potentially several different prefixes) currently causes\n * issues on the server side. The outgoing traffic in response to incoming may\n * select a different source address than the incoming destination address. To\n * overcome this, please ensure that the 'any address' is not used on the server\n * side and a separate Connector is created for each address to receive incoming\n * traffic.\n */\npublic class DTLSConnector implements Connector, RecordLayer {\n\n\t/**\n\t * The {@code EndpointContext} key used to store the host name indicated by a\n\t * client in an SNI hello extension.\n\t */\n\tpublic static final String KEY_TLS_SERVER_HOST_NAME = \"TLS_SERVER_HOST_NAME\";\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(DTLSConnector.class);\n\tprivate static final Logger DROP_LOGGER = LoggerFactory.getLogger(LOGGER.getName() + \".drops\");\n\tprivate static final int MAX_PLAINTEXT_FRAGMENT_LENGTH = 16384; // max. DTLSPlaintext.length (2^14 bytes)\n\tprivate static final int MAX_CIPHERTEXT_EXPANSION = CipherSuite.getOverallMaxCiphertextExpansion();\n\tprivate static final int MAX_DATAGRAM_BUFFER_SIZE = MAX_PLAINTEXT_FRAGMENT_LENGTH\n\t\t\t+ DTLSSession.DTLS_HEADER_LENGTH\n\t\t\t+ MAX_CIPHERTEXT_EXPANSION;\n\n\t/**\n\t * Additional padding used by the new record type introduced with the\n\t * connection id. May be randomized to obfuscate the payload length. Due to\n\t * the ongoing discussion in draft-ietf-tls-dtls-connection-id, currently\n\t * only a fixed value.\n\t */\n\tprivate static final int TLS12_CID_PADDING = 0;\n\n\tprivate static final long CLIENT_HELLO_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60);\n\n\t/**\n\t * Indicates, that MDC support is available.\n\t * \n\t * @see MDC\n\t */\n\tprivate static final boolean MDC_SUPPORT;\n\n\tstatic {\n\t\tboolean mdc = false;\n\t\ttry {\n\t\t\tMDC.clear();\n\t\t\tmdc = true;\n\t\t} catch (Throwable ex) {\n\t\t}\n\t\tMDC_SUPPORT = mdc;\n\t}\n\n\t/** all the configuration options for the DTLS connector */ \n\tprotected final DtlsConnectorConfig config;\n\n\tprivate final ResumptionSupportingConnectionStore connectionStore;\n\n\t/**\n\t * General auto resumption timeout in milliseconds. {@code null}, if auto\n\t * resumption is not used.\n\t */\n\tprivate final Long autoResumptionTimeoutMillis;\n\n\tprivate final int thresholdHandshakesWithoutVerifiedPeer;\n\tprivate final AtomicInteger pendingHandshakesWithoutVerifiedPeer = new AtomicInteger();\n\tprotected final DtlsHealth health;\n\n\tprivate final boolean serverOnly;\n\tprivate final String defaultHandshakeMode;\n\t/**\n\t * Apply record filter only for records within the receive window.\n\t */\n\tprivate final int useExtendedWindowFilter;\n\t/**\n\t * Apply record filter.\n\t */\n\tprivate final boolean useFilter;\n\t/**\n\t * Apply address update only for newer records based on epoch/sequence_number.\n\t */\n\tprivate final boolean useCidUpdateAddressOnNewerRecordFilter;\n\n\t/**\n\t * (Down-)counter for pending outbound messages. Initialized with\n\t * {@link DtlsConnectorConfig#getOutboundMessageBufferSize()}.\n\t */\n\tprivate final AtomicInteger pendingOutboundMessagesCountdown = new AtomicInteger();\n\n\tprivate final List<Thread> receiverThreads = new LinkedList<Thread>();\n\n\t/**\n\t * Configure connection id generator. May be {@code null}, if connection id\n\t * should not be supported.\n\t */\n\tprotected final ConnectionIdGenerator connectionIdGenerator;\n\t/**\n\t * Protocol version to use for sending a hello verify request. Default\n\t * {@code null} to reply the client's version.\n\t * \n\t * @since 2.5\n\t */\n\tprivate final ProtocolVersion protocolVersionForHelloVerifyRequests;\n\n\tprivate ScheduledFuture<?> statusLogger;\n\n\tprivate InetSocketAddress lastBindAddress;\n\t/**\n\t * Provided or configured maximum transmission unit.\n\t */\n\tprivate Integer maximumTransmissionUnit;\n\t/**\n\t * IPv4 maximum transmission unit.\n\t * @since 2.4\n\t */\n\tprivate int ipv4Mtu = DEFAULT_IPV4_MTU;\n\t/**\n\t * IPv6 maximum transmission unit.\n\t * @since 2.4\n\t */\n\tprivate int ipv6Mtu = DEFAULT_IPV6_MTU;\n\tprotected int inboundDatagramBufferSize = MAX_DATAGRAM_BUFFER_SIZE;\n\n\tprivate CookieGenerator cookieGenerator = new CookieGenerator();\n\tprivate Object alertHandlerLock= new Object();\n\n\tprivate volatile DatagramSocket socket;\n\n\t/** The timer daemon to schedule retransmissions. */\n\tprotected ScheduledExecutorService timer;\n\n\t/** Indicates whether the connector has started and not stopped yet */\n\tprivate AtomicBoolean running = new AtomicBoolean(false);\n\n\t/**\n\t * Endpoint context matcher for outgoing messages.\n\t * \n\t * @see #setEndpointContextMatcher(EndpointContextMatcher)\n\t * @see #getEndpointContextMatcher()\n\t * @see #sendMessage(RawData, Connection)\n\t * @see #sendMessage(RawData, Connection, DTLSSession)\n\t */\n\tprivate volatile EndpointContextMatcher endpointContextMatcher;\n\n\tprivate volatile RawDataChannel messageHandler;\n\tprivate AlertHandler alertHandler;\n\tprivate SessionListener sessionListener;\n\tprivate ConnectionExecutionListener connectionExecutionListener;\n\tprivate ExecutorService executorService;\n\tprivate boolean hasInternalExecutor;\n\n\t/**\n\t * Creates a DTLS connector from a given configuration object using the\n\t * standard in-memory {@code ConnectionStore}.\n\t * \n\t * @param configuration the configuration options\n\t * @throws NullPointerException if the configuration is {@code null}\n\t */\n\tpublic DTLSConnector(DtlsConnectorConfig configuration) {\n\t\tthis(configuration, (SessionCache) null);\n\t}\n\n\t/**\n\t * Creates a DTLS connector for a given set of configuration options.\n\t * \n\t * @param configuration The configuration options.\n\t * @param sessionCache An (optional) cache for {@code DTLSSession} objects\n\t *            that can be used for persisting and/or sharing of session\n\t *            state among multiple instances of {@code DTLSConnector}.\n\t *            Whenever a handshake with a client is finished the negotiated\n\t *            session is put to this cache. Similarly, whenever a client\n\t *            wants to perform an abbreviated handshake based on an existing\n\t *            session the connection store will try to retrieve the session\n\t *            from this cache if it is not available from the connection\n\t *            store's in-memory (first-level) cache.\n\t * @throws NullPointerException if the configuration is {@code null}.\n\t */\n\tpublic DTLSConnector(final DtlsConnectorConfig configuration, final SessionCache sessionCache) {\n\t\tthis(configuration, createConnectionStore(configuration, sessionCache));\n\t}\n\n\t/**\n\t * Create and initialize default connection store.\n\t * \n\t * @param configuration configuration for initialization\n\t * @param sessionCache An (optional) cache for {@code DTLSSession} objects\n\t *            that can be used for persisting and/or sharing of session\n\t *            state among multiple instances of {@code DTLSConnector}.\n\t *            Whenever a handshake with a client is finished the negotiated\n\t *            session is put to this cache. Similarly, whenever a client\n\t *            wants to perform an abbreviated handshake based on an existing\n\t *            session the connection store will try to retrieve the session\n\t *            from this cache if it is not available from the connection\n\t *            store's in-memory (first-level) cache.\n\t * @return connection store\n\t * @since 2.5\n\t */\n\tprotected static ResumptionSupportingConnectionStore createConnectionStore(DtlsConnectorConfig configuration,\n\t\t\tSessionCache sessionCache) {\n\t\treturn new InMemoryConnectionStore(configuration.getMaxConnections(),\n\t\t\t\tconfiguration.getStaleConnectionThreshold(), sessionCache).setTag(configuration.getLoggingTag());\n\n\t}\n\n\t/**\n\t * Creates a DTLS connector for a given set of configuration options.\n\t * <p>\n\t * The connection store must use the same connection id generator as\n\t * configured in the provided configuration. The current implementation synchronize on the connection store,\n\t * therefore it is important not to use the connection store within a\n\t * different synchronization scope.\n\t * </p>\n\t * \n\t * @param configuration The configuration options.\n\t * @param connectionStore The registry to use for managing connections to\n\t *            peers.\n\t * @throws NullPointerException if any of the parameters is {@code null}.\n\t * @throws IllegalArgumentException if the connection store uses a different\n\t *             cid generator than the configuration.\n\t */\n\tprotected DTLSConnector(final DtlsConnectorConfig configuration, final ResumptionSupportingConnectionStore connectionStore) {\n\t\tif (configuration == null) {\n\t\t\tthrow new NullPointerException(\"Configuration must not be null\");\n\t\t} else if (connectionStore == null) {\n\t\t\tthrow new NullPointerException(\"Connection store must not be null\");\n\t\t} else {\n\t\t\tthis.config = configuration;\n\t\t\tthis.connectionIdGenerator = config.getConnectionIdGenerator();\n\t\t\tthis.protocolVersionForHelloVerifyRequests = config.getProtocolVersionForHelloVerifyRequests();\n\t\t\tthis.pendingOutboundMessagesCountdown.set(config.getOutboundMessageBufferSize());\n\t\t\tthis.autoResumptionTimeoutMillis = config.getAutoResumptionTimeoutMillis();\n\t\t\tthis.serverOnly = config.isServerOnly();\n\t\t\tthis.defaultHandshakeMode = config.getDefaultHandshakeMode();\n\t\t\tthis.useExtendedWindowFilter = config.useExtendedWindowFilter();\n\t\t\tthis.useFilter = config.useAntiReplayFilter() || useExtendedWindowFilter != 0;\n\t\t\tthis.useCidUpdateAddressOnNewerRecordFilter = config.useCidUpdateAddressOnNewerRecordFilter();\n\t\t\tthis.connectionStore = connectionStore;\n\t\t\tthis.connectionStore.attach(connectionIdGenerator);\n\t\t\tthis.connectionStore.setConnectionListener(config.getConnectionListener());\n\t\t\tConnectionListener listener = config.getConnectionListener();\n\t\t\tif (listener instanceof ConnectionExecutionListener) {\n\t\t\t\tthis.connectionExecutionListener = (ConnectionExecutionListener) listener;\n\t\t\t}\n\t\t\tHandshakeResultHandler handler = new HandshakeResultHandler() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void apply(PskSecretResult secretResult) {\n\t\t\t\t\tprocessAsynchronousHandshakeResult(secretResult);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void apply(HandshakeResult connectionResult) {\n\t\t\t\t\tprocessAsynchronousHandshakeResult(connectionResult);\n\t\t\t\t}\n\t\t\t};\n\t\t\tAdvancedPskStore advancedPskStore = config.getAdvancedPskStore();\n\t\t\tif (advancedPskStore != null) {\n\t\t\t\tadvancedPskStore.setResultHandler(handler);\n\t\t\t}\n\t\t\tNewAdvancedCertificateVerifier certificateVerifier = config.getAdvancedCertificateVerifier();\n\t\t\tif (certificateVerifier != null) {\n\t\t\t\tcertificateVerifier.setResultHandler(handler);\n\t\t\t}\n\t\t\tDtlsHealth healthHandler = config.getHealthHandler();\n\t\t\tInteger healthStatusInterval = config.getHealthStatusInterval();\n\t\t\t// this is a useful health metric\n\t\t\t// that could later be exported to some kind of monitoring interface\n\t\t\tif (healthHandler == null && healthStatusInterval != null && healthStatusInterval > 0) {\n\t\t\t\thealthHandler = createDefaultHealthHandler(config);\n\t\t\t\tif (!healthHandler.isEnabled()) {\n\t\t\t\t\thealthHandler = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.health = healthHandler;\n\t\t\tthis.sessionListener = new SessionAdapter() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void sessionEstablished(Handshaker handshaker, DTLSSession establishedSession)\n\t\t\t\t\t\tthrows HandshakeException {\n\t\t\t\t\tDTLSConnector.this.sessionEstablished(handshaker, establishedSession);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void handshakeCompleted(final Handshaker handshaker) {\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.endHandshake(true);\n\t\t\t\t\t}\n\t\t\t\t\tfinal Connection connection = handshaker.getConnection();\n\t\t\t\t\tScheduledExecutorService timer = DTLSConnector.this.timer;\n\t\t\t\t\tif (timer != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttimer.schedule(new Runnable() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\tconnection.startByClientHello(null);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, CLIENT_HELLO_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} catch (RejectedExecutionException ex) {\n\t\t\t\t\t\t\tLOGGER.debug(\"stopping.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// fallback, if execution is rejected\n\t\t\t\t\tconnection.startByClientHello(null);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void handshakeFailed(Handshaker handshaker, Throwable error) {\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.endHandshake(false);\n\t\t\t\t\t}\n\t\t\t\t\tList<RawData> listOut = handshaker.takeDeferredApplicationData();\n\t\t\t\t\tif (!listOut.isEmpty()) {\n\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] failed, report error to deferred {} messages\",\n\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), listOut.size());\n\t\t\t\t\t\tfor (RawData message : listOut) {\n\t\t\t\t\t\t\tmessage.onError(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tConnection connection = handshaker.getConnection();\n\t\t\t\t\tif (handshaker.isRemovingConnection()) {\n\t\t\t\t\t\tconnectionStore.remove(connection, false);\n\t\t\t\t\t} else if (handshaker.isProbing()) {\n\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] failed within probe!\", handshaker.getPeerAddress());\n\t\t\t\t\t} else if (connection.getEstablishedSession() == handshaker.getSession()) {\n\t\t\t\t\t\tif (error instanceof HandshakeException) {\n\t\t\t\t\t\t\tAlertMessage alert = ((HandshakeException)error).getAlert();\n\t\t\t\t\t\t\tif (alert != null && alert.getDescription() == AlertDescription.CLOSE_NOTIFY) {\n\t\t\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] closed after session was established!\",\n\t\t\t\t\t\t\t\t\t\thandshaker.getPeerAddress());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed after session was established! {}\",\n\t\t\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), alert);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// failure after established (last FINISH),\n\t\t\t\t\t\t\t// but before completed (first data)\n\t\t\t\t\t\t\tif (error instanceof ConnectionEvictedException) {\n\t\t\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] never get APPLICATION_DATA\",\n\t\t\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), error);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed after session was established!\",\n\t\t\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (connection.hasEstablishedSession()) {\n\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed, but has an established session!\",\n\t\t\t\t\t\t\t\thandshaker.getPeerAddress());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed, connection preserved!\", handshaker.getPeerAddress());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tint maxConnections = config.getMaxConnections();\n\t\t\t// calculate absolute threshold from relative.\n\t\t\tlong thresholdInPercent = config.getVerifyPeersOnResumptionThreshold();\n\t\t\tlong threshold = (((long) maxConnections * thresholdInPercent) + 50L) / 100L;\n\t\t\tif (threshold == 0 && thresholdInPercent > 0) {\n\t\t\t\tthreshold = 1;\n\t\t\t}\n\t\t\tthis.thresholdHandshakesWithoutVerifiedPeer = (int) threshold;\n\t\t}\n\t}\n\n\t/**\n\t * Create default health handler.\n\t * \n\t * @param configuration configuration\n\t * @return default health handler.\n\t * @since 2.5\n\t */\n\tprotected DtlsHealth createDefaultHealthHandler(DtlsConnectorConfig configuration) {\n\t\treturn new DtlsHealthLogger(configuration.getLoggingTag());\n\t}\n\n\tprivate final void sessionEstablished(Handshaker handshaker, final DTLSSession establishedSession)\n\t\t\tthrows HandshakeException {\n\t\ttry {\n\t\t\tfinal Connection connection = handshaker.getConnection();\n\t\t\tconnectionStore.putEstablishedSession(establishedSession, connection);\n\t\t\tfinal SerialExecutor serialExecutor = connection.getExecutor();\n\t\t\tList<RawData> listOut = handshaker.takeDeferredApplicationData();\n\t\t\tif (!listOut.isEmpty()) {\n\t\t\t\tLOGGER.trace(\"Session with [{}] established, now process deferred {} messages\",\n\t\t\t\t\t\testablishedSession.getPeer(), listOut.size());\n\t\t\t\tfor (RawData message : listOut) {\n\t\t\t\t\tfinal RawData rawData = message;\n\t\t\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tsendMessage(rawData, connection, establishedSession);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tList<Record> listIn = handshaker.takeDeferredRecords();\n\t\t\tif (!listIn.isEmpty()) {\n\t\t\t\tLOGGER.trace(\"Session with [{}] established, now process deferred {} messages\",\n\t\t\t\t\t\testablishedSession.getPeer(), listIn.size());\n\t\t\t\tfor (Record message : listIn) {\n\t\t\t\t\tfinal Record record = message;\n\t\t\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tprocessRecord(record, connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (RejectedExecutionException ex) {\n\t\t\tLOGGER.debug(\"stopping.\");\n\t\t}\n\t}\n\n\t/**\n\t * Called after initialization of new create handshaker.\n\t * \n\t * Intended to be used for subclass specific handshaker initialization.\n\t * \n\t * @param handshaker new create handshaker\n\t */\n\tprotected void onInitializeHandshaker(final Handshaker handshaker) {\n\t}\n\n\t/**\n\t * Initialize new create handshaker.\n\t * \n\t * Add {@link #sessionListener}.\n\t * \n\t * @param handshaker new create handshaker\n\t */\n\tprivate final void initializeHandshaker(final Handshaker handshaker) {\n\t\tif (sessionListener != null) {\n\t\t\thandshaker.addSessionListener(sessionListener);\n\t\t\tif (health != null) {\n\t\t\t\thealth.startHandshake();\n\t\t\t}\n\t\t}\n\t\tonInitializeHandshaker(handshaker);\n\t}\n\n\t/**\n\t * Sets the executor to be used for processing records.\n\t * <p>\n\t * If this property is not set before invoking the {@linkplain #start()\n\t * start method}, a new {@link ExecutorService} is created with a thread\n\t * pool of {@linkplain DtlsConnectorConfig#getConnectionThreadCount() size}.\n\t * \n\t * This helps with performing multiple handshakes in parallel, in particular if the key exchange\n\t * requires a look up of identities, e.g. in a database or using a web service.\n\t * <p>\n\t * If this method is used to set an executor, the executor will <em>not</em> be shut down\n\t * by the {@linkplain #stop() stop method}.\n\t * \n\t * @param executor The executor.\n\t * @throws IllegalStateException if a new executor is set and this connector is already running.\n\t */\n\tpublic final synchronized void setExecutor(ExecutorService executor) {\n\t\tif (this.executorService != executor) {\n\t\t\tif (running.get()) {\n\t\t\t\tthrow new IllegalStateException(\"cannot set new executor while connector is running\");\n\t\t\t} else {\n\t\t\t\tthis.executorService = executor;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a connection with a given peer.\n\t * \n\t * The connection is gracefully shut down, i.e. a final\n\t * <em>CLOSE_NOTIFY</em> alert message is sent to the peer\n\t * prior to removing all session state.\n\t * \n\t * @param peerAddress the address of the peer to close the connection to\n\t * @throws IllegalStateException if executor cache is exceeded.\n\t */\n\tpublic final void close(InetSocketAddress peerAddress) {\n\t\tfinal Connection connection = getConnection(peerAddress, null, false);\n\t\tif (connection != null && connection.hasEstablishedSession()) {\n\t\t\tSerialExecutor serialExecutor = connection.getExecutor();\n\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tDTLSSession session = connection.getEstablishedSession();\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tterminateConnection(connection, new AlertMessage(AlertLevel.WARNING,\n\t\t\t\t\t\t\t\tAlertDescription.CLOSE_NOTIFY, connection.getPeerAddress()), session);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic final synchronized void start() throws IOException {\n\t\tstart(config.getAddress());\n\t}\n\n\t/**\n\t * Re-starts the connector binding to the same IP address and port as\n\t * on the previous start.\n\t * \n\t * Note: intended for unit tests only!\n\t * \n\t * @throws IOException if the connector cannot be bound to the previous\n\t *            IP address and port\n\t */\n\tfinal synchronized void restart() throws IOException {\n\t\tif (lastBindAddress != null) {\n\t\t\tstart(lastBindAddress);\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"Connector has never been started before\");\n\t\t}\n\t}\n\n\tprivate synchronized ExecutorService getExecutorService() {\n\t\treturn executorService;\n\t}\n\n\t/**\n\t * Start connector.\n\t * \n\t * @param bindAddress address to bind socket.\n\t * @throws IOException I/O error\n\t */\n\tprotected void start(InetSocketAddress bindAddress) throws IOException {\n\t\tif (running.get()) {\n\t\t\treturn;\n\t\t}\n\t\tinit(bindAddress, new DatagramSocket(null), config.getMaxTransmissionUnit());\n\t}\n\n\t/**\n\t * Initialize socket ad start connector.\n\t * \n\t * @param bindAddress address to bind socket\n\t * @param socket socket\n\t * @param mtu mtu of socket, or {@code null}, if socket implementation\n\t *            doesn't use a special mtu.\n\t * @throws IOException I/O error\n\t * @since 2.1\n\t */\n\tprotected void init(InetSocketAddress bindAddress, DatagramSocket socket, Integer mtu) throws IOException {\n\t\tthis.socket = socket;\n\t\tpendingOutboundMessagesCountdown.set(config.getOutboundMessageBufferSize());\n\n\t\tif (bindAddress.getPort() != 0 && config.isAddressReuseEnabled()) {\n\t\t\t// make it easier to stop/start a server consecutively without delays\n\t\t\tLOGGER.info(\"Enable address reuse for socket!\");\n\t\t\tsocket.setReuseAddress(true);\n\t\t\tif (!socket.getReuseAddress()) {\n\t\t\t\tLOGGER.warn(\"Enable address reuse for socket failed!\");\n\t\t\t}\n\t\t}\n\n\t\tInteger size = config.getSocketReceiveBufferSize();\n\t\ttry {\n\t\t\tif (size != null && size != 0) {\n\t\t\t\tsocket.setReceiveBufferSize(size);\n\t\t\t}\n\t\t\tsize = config.getSocketSendBufferSize();\n\t\t\tif (size != null && size != 0) {\n\t\t\t\tsocket.setSendBufferSize(size);\n\t\t\t}\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\tLOGGER.error(\"failed to apply {}\", size, ex);\n\t\t}\n\t\t// don't try to access the buffer sizes,\n\t\t// when receive may already lock the socket!\n\t\tint recvBuffer = socket.getReceiveBufferSize();\n\t\tint sendBuffer = socket.getSendBufferSize();\n\n\t\tif (!socket.isBound()) {\n\t\t\tsocket.bind(bindAddress);\n\t\t}\n\t\tif (lastBindAddress != null && (!socket.getLocalAddress().equals(lastBindAddress.getAddress()) || socket.getLocalPort() != lastBindAddress.getPort())){\n\t\t\tif (connectionStore instanceof ResumptionSupportingConnectionStore) {\n\t\t\t\t((ResumptionSupportingConnectionStore) connectionStore).markAllAsResumptionRequired();\n\t\t\t} else {\n\t\t\t\tconnectionStore.clear();\n\t\t\t}\n\t\t}\n\n\t\tif (config.getMaxFragmentLengthCode() != null) {\n\t\t\tMaxFragmentLengthExtension.Length lengthCode = MaxFragmentLengthExtension.Length.fromCode(\n\t\t\t\t\tconfig.getMaxFragmentLengthCode());\n\t\t\t// reduce inbound buffer size accordingly\n\t\t\tinboundDatagramBufferSize = lengthCode.length()\n\t\t\t\t\t+ MAX_CIPHERTEXT_EXPANSION\n\t\t\t\t\t+ DTLSSession.DTLS_HEADER_LENGTH; // 12 bytes DTLS message headers, 13 bytes DTLS record headers\n\t\t}\n\n\t\tif (config.getMaxTransmissionUnit() != null) {\n\t\t\tthis.maximumTransmissionUnit = config.getMaxTransmissionUnit();\n\t\t\tLOGGER.info(\"Configured MTU [{}]\", this.maximumTransmissionUnit);\n\t\t} else if (mtu != null) {\n\t\t\tthis.maximumTransmissionUnit = mtu;\n\t\t\tLOGGER.info(\"Forced MTU [{}]\", this.maximumTransmissionUnit);\n\t\t} else {\n\t\t\tInetAddress localInterfaceAddress = bindAddress.getAddress();\n\t\t\tif (localInterfaceAddress.isAnyLocalAddress()) {\n\t\t\t\tipv4Mtu = NetworkInterfacesUtil.getIPv4Mtu();\n\t\t\t\tipv6Mtu = NetworkInterfacesUtil.getIPv6Mtu();\n\t\t\t\tLOGGER.info(\"multiple network interfaces, using smallest MTU [IPv4 {}, IPv6 {}]\", ipv4Mtu, ipv6Mtu);\n\t\t\t} else {\n\t\t\t\tNetworkInterface ni = NetworkInterface.getByInetAddress(localInterfaceAddress);\n\t\t\t\tboolean ipv6 = localInterfaceAddress instanceof Inet6Address;\n\t\t\t\tif (ni != null && ni.getMTU() > 0) {\n\t\t\t\t\tif (ipv6) {\n\t\t\t\t\t\tipv6Mtu = ni.getMTU();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tipv4Mtu = ni.getMTU();\n\t\t\t\t\t}\n\t\t\t\t} else if (ipv6) {\n\t\t\t\t\tipv6Mtu = NetworkInterfacesUtil.getIPv6Mtu();\n\t\t\t\t\tLOGGER.info(\"Cannot determine MTU of network interface, using minimum MTU [{}] of IPv6 instead\", ipv6Mtu);\n\t\t\t\t} else {\n\t\t\t\t\tipv4Mtu = NetworkInterfacesUtil.getIPv4Mtu();\n\t\t\t\t\tLOGGER.info(\"Cannot determine MTU of network interface, using minimum MTU [{}] of IPv4 instead\", ipv4Mtu);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (inboundDatagramBufferSize > config.getMaxTransmissionUnitLimit()) {\n\t\t\t\tif (ipv4Mtu > config.getMaxTransmissionUnitLimit()) {\n\t\t\t\t\tipv4Mtu = config.getMaxTransmissionUnitLimit();\n\t\t\t\t\tLOGGER.info(\"Limit MTU IPv4[{}]\", ipv4Mtu);\n\t\t\t\t}\n\t\t\t\tif (ipv6Mtu > config.getMaxTransmissionUnitLimit()) {\n\t\t\t\t\tipv6Mtu = config.getMaxTransmissionUnitLimit();\n\t\t\t\t\tLOGGER.info(\"Limit MTU IPv6[{}]\", ipv6Mtu);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ipv4Mtu > inboundDatagramBufferSize) {\n\t\t\t\t\tipv4Mtu = inboundDatagramBufferSize;\n\t\t\t\t\tLOGGER.info(\"Buffersize MTU IPv4[{}]\", ipv4Mtu);\n\t\t\t\t}\n\t\t\t\tif (ipv6Mtu > inboundDatagramBufferSize) {\n\t\t\t\t\tipv6Mtu = inboundDatagramBufferSize;\n\t\t\t\t\tLOGGER.info(\"Buffersize MTU IPv6[{}]\", ipv6Mtu);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlastBindAddress = new InetSocketAddress(socket.getLocalAddress(), socket.getLocalPort());\n\n\t\tif (executorService instanceof ScheduledExecutorService) {\n\t\t\ttimer = (ScheduledExecutorService) executorService;\n\t\t} else {\n\t\t\ttimer = ExecutorsUtil.newSingleThreadScheduledExecutor(new DaemonThreadFactory(\n\t\t\t\t\t\"DTLS-Timer-\" + lastBindAddress + \"#\", NamedThreadFactory.SCANDIUM_THREAD_GROUP)); //$NON-NLS-1$\n\t\t}\n\n\t\tif (executorService == null) {\n\t\t\tint threadCount = config.getConnectionThreadCount();\n\t\t\tif (threadCount > 1) {\n\t\t\t\texecutorService = ExecutorsUtil.newFixedThreadPool(threadCount - 1, new DaemonThreadFactory(\n\t\t\t\t\t\t\"DTLS-Worker-\" + lastBindAddress + \"#\", NamedThreadFactory.SCANDIUM_THREAD_GROUP)); //$NON-NLS-1$\n\t\t\t} else {\n\t\t\t\texecutorService = timer;\n\t\t\t}\n\t\t\tthis.hasInternalExecutor = true;\n\t\t}\n\n\t\trunning.set(true);\n\n\t\tint receiverThreadCount = config.getReceiverThreadCount();\n\t\tfor (int i = 0; i < receiverThreadCount; i++) {\n\t\t\tWorker receiver = new Worker(\"DTLS-Receiver-\" + i + \"-\" + lastBindAddress) {\n\n\t\t\t\tprivate final byte[] receiverBuffer = new byte[inboundDatagramBufferSize];\n\t\t\t\tprivate final DatagramPacket packet = new DatagramPacket(receiverBuffer, inboundDatagramBufferSize);\n\n\t\t\t\t@Override\n\t\t\t\tpublic void doWork() throws Exception {\n\t\t\t\t\tif (MDC_SUPPORT) {\n\t\t\t\t\t\tMDC.clear();\n\t\t\t\t\t}\n\t\t\t\t\tpacket.setData(receiverBuffer);\n\t\t\t\t\treceiveNextDatagramFromNetwork(packet);\n\t\t\t\t}\n\t\t\t};\n\t\t\treceiver.setDaemon(true);\n\t\t\treceiver.start();\n\t\t\treceiverThreads.add(receiver);\n\t\t}\n\n\t\tString mtuDescription = maximumTransmissionUnit != null ? maximumTransmissionUnit.toString() : \"IPv4 \" + ipv4Mtu + \" / IPv6 \" + ipv6Mtu;\n\t\tLOGGER.info(\"DTLSConnector listening on {}, recv buf = {}, send buf = {}, recv packet size = {}, MTU = {}\",\n\t\t\t\tlastBindAddress, recvBuffer, sendBuffer, inboundDatagramBufferSize, mtuDescription);\n\n\t\t// this is a useful health metric\n\t\t// that could later be exported to some kind of monitoring interface\n\t\tif (health != null && health.isEnabled()) {\n\t\t\tfinal Integer healthStatusInterval = config.getHealthStatusInterval();\n\t\t\tif (healthStatusInterval != null) {\n\t\t\t\tstatusLogger = timer.scheduleAtFixedRate(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\thealth.dump(config.getLoggingTag(), config.getMaxConnections(), connectionStore.remainingCapacity(), pendingHandshakesWithoutVerifiedPeer.get());\n\t\t\t\t\t}\n\n\t\t\t\t}, healthStatusInterval, healthStatusInterval, TimeUnit.SECONDS);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Force connector to an abbreviated handshake. See <a href=\"https://tools.ietf.org/html/rfc5246#section-7.3\">RFC 5246</a>.\n\t * \n\t * The abbreviated handshake will be done next time data will be sent with {@link #send(RawData)}.\n\t * @param peer the peer for which we will force to do an abbreviated handshake\n\t */\n\tpublic final synchronized void forceResumeSessionFor(InetSocketAddress peer) {\n\t\tConnection peerConnection = connectionStore.get(peer);\n\t\tif (peerConnection != null && peerConnection.hasEstablishedSession()) {\n\t\t\tpeerConnection.setResumptionRequired(true);\n\t\t}\n\t}\n\n\t/**\n\t * Marks all established sessions currently maintained by this connector to be resumed by means\n\t * of an <a href=\"https://tools.ietf.org/html/rfc5246#section-7.3\">abbreviated handshake</a> the\n\t * next time a message is being sent to the corresponding peer using {@link #send(RawData)}.\n\t * <p>\n\t * This method's execution time is proportional to the number of connections this connector maintains.\n\t */\n\tpublic final synchronized void forceResumeAllSessions() {\n\t\tconnectionStore.markAllAsResumptionRequired();\n\t}\n\n\t/**\n\t * Clears all connection state this connector maintains for peers.\n\t * <p>\n\t * After invoking this method a new connection needs to be established with a peer using a \n\t * full handshake in order to exchange messages with it again.\n\t */\n\tpublic final synchronized void clearConnectionState() {\n\t\tconnectionStore.clear();\n\t}\n\n\tprivate final DatagramSocket getSocket() {\n\t\treturn socket;\n\t}\n\n\t@Override\n\tpublic void stop() {\n\t\tExecutorService shutdownTimer = null;\n\t\tExecutorService shutdown = null;\n\t\tList<Runnable> pending = new ArrayList<>();\n\t\tsynchronized (this) {\n\t\t\tif (running.compareAndSet(true, false)) {\n\t\t\t\tif (statusLogger != null) {\n\t\t\t\t\tstatusLogger.cancel(false);\n\t\t\t\t\tstatusLogger = null;\n\t\t\t\t}\n\t\t\t\tLOGGER.info(\"Stopping DTLS connector on [{}]\", lastBindAddress);\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t}\n\t\t\t\tif (socket != null) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t\tsocket = null;\n\t\t\t\t}\n\t\t\t\tmaximumTransmissionUnit = null;\n\t\t\t\tipv4Mtu = DEFAULT_IPV4_MTU;\n\t\t\t\tipv6Mtu = DEFAULT_IPV6_MTU;\n\t\t\t\tconnectionStore.stop(pending);\n\t\t\t\tif (executorService != timer) {\n\t\t\t\t\tpending.addAll(timer.shutdownNow());\n\t\t\t\t\tshutdownTimer = timer;\n\t\t\t\t\ttimer = null;\n\t\t\t\t}\n\t\t\t\tif (hasInternalExecutor) {\n\t\t\t\t\tpending.addAll(executorService.shutdownNow());\n\t\t\t\t\tshutdown = executorService;\n\t\t\t\t\texecutorService = null;\n\t\t\t\t\thasInternalExecutor = false;\n\t\t\t\t}\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.join(500);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treceiverThreads.clear();\n\t\t\t}\n\t\t}\n\t\tif (shutdownTimer != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdownTimer.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] timer not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tif (shutdown != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdown.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] executor not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tfor (Runnable job : pending) {\n\t\t\ttry {\n\t\t\t\tjob.run();\n\t\t\t} catch (Throwable e) {\n\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector:\", e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys the connector.\n\t * <p>\n\t * This method invokes {@link #stop()} and clears the <code>ConnectionStore</code>\n\t * used to manage connections to peers. Thus, contrary to the behavior specified\n\t * for {@link Connector#destroy()}, this connector can be re-started using the\n\t * {@link #start()} method but subsequent invocations of the {@link #send(RawData)}\n\t * method will trigger the establishment of a new connection to the corresponding peer.\n\t * </p>\n\t */\n\t@Override\n\tpublic synchronized void destroy() {\n\t\tstop();\n\t\tconnectionStore.clear();\n\t\tmessageHandler = null;\n\t}\n\n\t/**\n\t * Start to terminate connections related to the provided principals.\n\t * \n\t * Note: if {@link SessionCache} is used, it's not possible to remove a\n\t * cache entry, if no related connection is in the connection store.\n\t * \n\t * @param principal principal, which connections are to terminate\n\t * @return future to cancel or wait for completion\n\t */\n\tpublic Future<Void> startDropConnectionsForPrincipal(final Principal principal) {\n\t\tif (principal == null) {\n\t\t\tthrow new NullPointerException(\"principal must not be null!\");\n\t\t}\n\t\tLeastRecentlyUsedCache.Predicate<Principal> handler = new LeastRecentlyUsedCache.Predicate<Principal>() {\n\n\t\t\t@Override\n\t\t\tpublic boolean accept(Principal connectionPrincipal) {\n\t\t\t\treturn principal.equals(connectionPrincipal);\n\t\t\t}\n\t\t};\n\t\treturn startTerminateConnectionsForPrincipal(handler);\n\t}\n\n\t/**\n\t * Start to terminate connections applying the provided handler to the\n\t * principals of all connections.\n\t * \n\t * Note: if {@link SessionCache} is used, it's not possible to remove a\n\t * cache entry, if no related connection is in the connection store. All\n\t * available connections will be removed from that session cache as well.\n\t * \n\t * @param principalHandler handler to be called within the serial execution\n\t *            of the related connection. If {@code true} is returned, the\n\t *            related connection is terminated and the session is removed\n\t *            from the session cache.\n\t * @return future to cancel or wait for completion\n\t * @see #startTerminateConnectionsForPrincipal(org.eclipse.californium.elements.util.LeastRecentlyUsedCache.Predicate,\n\t *      boolean)\n\t */\n\tpublic Future<Void> startTerminateConnectionsForPrincipal(\n\t\t\tLeastRecentlyUsedCache.Predicate<Principal> principalHandler) {\n\t\treturn startTerminateConnectionsForPrincipal(principalHandler, true);\n\t}\n\n\t/**\n\t * Start to terminate connections applying the provided handler to the\n\t * principals of all connections.\n\t * \n\t * Note: if {@link SessionCache} is used, it's not possible to remove a\n\t * cache entry, if no related connection is in the connection store.\n\t * \n\t * @param principalHandler handler to be called within the serial execution\n\t *            of the related connection. If {@code true} is returned, the\n\t *            related connection is terminated\n\t * @param removeFromSessionCache {@code true} if the session of the\n\t *            connection should be removed from the session cache,\n\t *            {@code false}, otherwise\n\t * @return future to cancel or wait for completion\n\t * @see #startTerminateConnectionsForPrincipal(org.eclipse.californium.elements.util.LeastRecentlyUsedCache.Predicate)\n\t * @since 2.6\n\t */\n\tpublic Future<Void> startTerminateConnectionsForPrincipal(\n\t\t\tfinal LeastRecentlyUsedCache.Predicate<Principal> principalHandler, final boolean removeFromSessionCache) {\n\t\tif (principalHandler == null) {\n\t\t\tthrow new NullPointerException(\"principal handler must not be null!\");\n\t\t}\n\t\tLeastRecentlyUsedCache.Predicate<Connection> connectionHandler = new LeastRecentlyUsedCache.Predicate<Connection>() {\n\n\t\t\t@Override\n\t\t\tpublic boolean accept(Connection connection) {\n\t\t\t\tPrincipal peer = null;\n\t\t\t\tSessionTicket ticket = connection.getSessionTicket();\n\t\t\t\tif (ticket != null) {\n\t\t\t\t\tpeer = ticket.getClientIdentity();\n\t\t\t\t} else {\n\t\t\t\t\tDTLSSession session = connection.getSession();\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tpeer = session.getPeerIdentity();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (peer != null && principalHandler.accept(peer)) {\n\t\t\t\t\tconnectionStore.remove(connection, removeFromSessionCache);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\treturn startForEach(connectionHandler);\n\t}\n\n\t/**\n\t * Start applying provided handler to all connections.\n\t * \n\t * @param handler handler to be called within the serial execution of the\n\t *            passed in connection. If {@code true} is returned, iterating\n\t *            is stopped.\n\t * @return future to cancel or wait for completion\n\t */\n\tpublic Future<Void> startForEach(LeastRecentlyUsedCache.Predicate<Connection> handler) {\n\t\tif (handler == null) {\n\t\t\tthrow new NullPointerException(\"handler must not be null!\");\n\t\t}\n\t\tForEachFuture result = new ForEachFuture();\n\t\tnextForEach(connectionStore.iterator(), handler, result);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Calls provided handler for each connection returned be the provided\n\t * iterator.\n\t * \n\t * @param iterator iterator over connections\n\t * @param handler handler to be called for all connections returned by the\n\t *            iterator. Iteration is stopped, when handler returns\n\t *            {@code true}\n\t * @param result future to get cancelled or signal completion\n\t */\n\tprivate void nextForEach(final Iterator<Connection> iterator,\n\t\t\tfinal LeastRecentlyUsedCache.Predicate<Connection> handler, final ForEachFuture result) {\n\n\t\tif (!result.isStopped() && iterator.hasNext()) {\n\t\t\tfinal Connection next = iterator.next();\n\t\t\ttry {\n\t\t\t\tnext.getExecutor().execute(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tboolean done = true;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (!result.isStopped() && !handler.accept(next)) {\n\t\t\t\t\t\t\t\tdone = false;\n\t\t\t\t\t\t\t\tnextForEach(iterator, handler, result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception exception) {\n\t\t\t\t\t\t\tresult.failed(exception);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\t\tresult.done();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} catch (RejectedExecutionException ex) {\n\t\t\t\tif (!handler.accept(next)) {\n\t\t\t\t\twhile (iterator.hasNext()) {\n\t\t\t\t\t\tif (handler.accept(iterator.next())) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (result.isStopped()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult.done();\n\t}\n\n\t/**\n\t * Get connection to communication with peer.\n\t * \n\t * @param peerAddress socket address of peer\n\t * @param cid connection id. {@code null}, if cid extension is not used\n\t * @param create {@code true}, create new connection, if connection is not\n\t *            available.\n\t * @return connection to communication with peer. {@code null}, if store is\n\t *         exhausted or if the connection is not available and the provided\n\t *         parameter create is {@code false}.\n\t */\n\tprivate final Connection getConnection(InetSocketAddress peerAddress, ConnectionId cid, boolean create) {\n\t\tExecutorService executor = getExecutorService();\n\t\tsynchronized (connectionStore) {\n\t\t\tConnection connection;\n\t\t\tif (cid != null) {\n\t\t\t\tconnection = connectionStore.get(cid);\n\t\t\t} else {\n\t\t\t\tconnection = connectionStore.get(peerAddress);\n\t\t\t\tif (connection == null && create) {\n\t\t\t\t\tLOGGER.trace(\"create new connection for {}\", peerAddress);\n\t\t\t\t\tConnection newConnection = new Connection(peerAddress, new SerialExecutor(executor));\n\t\t\t\t\tnewConnection.setExecutionListener(connectionExecutionListener);\n\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t// only add, if connector is running!\n\t\t\t\t\t\tif (!connectionStore.put(newConnection)) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn newConnection;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (connection == null) {\n\t\t\t\tLOGGER.trace(\"no connection available for {},{}\", peerAddress, cid);\n\t\t\t} else if (!connection.isExecuting() && running.get()) {\n\t\t\t\tLOGGER.trace(\"revive connection for {},{}\", peerAddress, cid);\n\t\t\t\tconnection.setExecutor(new SerialExecutor(executor));\n\t\t\t} else {\n\t\t\t\tLOGGER.trace(\"connection available for {},{}\", peerAddress, cid);\n\t\t\t}\n\t\t\treturn connection;\n\t\t}\n\t}\n\n\t/**\n\t * Receive the next datagram from network.\n\t * \n\t * Potentially called by multiple threads.\n\t * \n\t * @param packet datagram the be read from network\n\t * @throws IOException if anio- error occurred\n\t * @see #processDatagram(DatagramPacket)\n\t */\n\tprotected void receiveNextDatagramFromNetwork(DatagramPacket packet) throws IOException {\n\n\t\tDatagramSocket currentSocket = getSocket();\n\t\tif (currentSocket == null) {\n\t\t\t// very unlikely race condition.\n\t\t\treturn;\n\t\t}\n\n\t\tcurrentSocket.receive(packet);\n\n\t\tif (packet.getLength() == 0) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO: when deprecated function is removed, call the new one.\n\t\tprocessDatagram(packet);\n\t}\n\n\t/**\n\t * Process received datagram.\n\t * \n\t * Potentially called by multiple threads.\n\t * \n\t * @param packet datagram filled with the received data and source address.\n\t * @deprecated use {@link #processDatagram(DatagramPacket, InetSocketAddress)}\n\t */\n\t@Deprecated\n\tprotected void processDatagram(DatagramPacket packet) {\n\t\tprocessDatagram(packet, null);\n\t}\n\n\t/**\n\t * Process received datagram.\n\t * \n\t * Potentially called by multiple threads.\n\t * \n\t * @param packet received message\n\t * @param router router address, {@code null}, if no router is used.\n\t * @since 2.5\n\t */\n\tprotected void processDatagram(DatagramPacket packet, InetSocketAddress router) {\n\t\tInetSocketAddress peerAddress = (InetSocketAddress) packet.getSocketAddress();\n\t\tif (MDC_SUPPORT) {\n\t\t\tMDC.put(\"PEER\", StringUtil.toString(peerAddress));\n\t\t}\n\t\tif (health != null) {\n\t\t\thealth.receivingRecord(false);\n\t\t}\n\t\tlong timestamp = ClockUtil.nanoRealtime();\n\n\t\tif (peerAddress.getPort() == 0) {\n\t\t\t// RFC 768\n\t\t\t// Source Port is an optional field, when meaningful, it indicates\n\t\t\t// the port of the sending process, and may be assumed to be the\n\t\t\t// port to which a reply should be addressed in the absence of any\n\t\t\t// other information. If not used, a value of zero is inserted.\n\t\t\tDROP_LOGGER.trace(\"Discarding record with {} bytes from [{}] without source-port\", packet.getLength(),\n\t\t\t\t\tpeerAddress);\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tDatagramReader reader = new DatagramReader(packet.getData(), packet.getOffset(), packet.getLength());\n\t\tList<Record> records = Record.fromReader(reader, peerAddress, router, connectionIdGenerator, timestamp);\n\t\tLOGGER.trace(\"Received {} DTLS records from {} using a {} byte datagram buffer\",\n\t\t\t\trecords.size(), peerAddress, inboundDatagramBufferSize);\n\n\t\tif (records.isEmpty()) {\n\t\t\tDROP_LOGGER.trace(\"Discarding {} malicious record with {} bytes from [{}]\", packet.getLength(), peerAddress);\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!running.get()) {\n\t\t\tDROP_LOGGER.trace(\"Discarding {} records, startting with {} from [{}] on shutdown\", records.size(),\n\t\t\t\t\trecords.get(0).getType(), peerAddress);\n\t\t\tLOGGER.debug(\"Execution shutdown while processing incoming records from peer: {}\", peerAddress);\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Record firstRecord = records.get(0);\n\n\t\tif (records.size() == 1 && firstRecord.isNewClientHello()) {\n\t\t\tgetExecutorService().execute(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tif (MDC_SUPPORT) {\n\t\t\t\t\t\tMDC.put(\"PEER\", StringUtil.toString(firstRecord.getPeerAddress()));\n\t\t\t\t\t}\n\t\t\t\t\tprocessNewClientHello(firstRecord);\n\t\t\t\t\tif (MDC_SUPPORT) {\n\t\t\t\t\t\tMDC.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tfinal ConnectionId connectionId = firstRecord.getConnectionId();\n\t\tfinal Connection connection = getConnection(peerAddress, connectionId, false);\n\n\t\tif (connection == null) {\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\tif (connectionId == null) {\n\t\t\t\tDROP_LOGGER.trace(\"Discarding {} records from [{}] received without existing connection\",\n\t\t\t\t\t\trecords.size(), peerAddress);\n\t\t\t} else {\n\t\t\t\tDROP_LOGGER.trace(\"Discarding {} records from [{},{}] received without existing connection\",\n\t\t\t\t\t\trecords.size(), peerAddress, connectionId);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tSerialExecutor serialExecutor = connection.getExecutor();\n\n\t\tfor (final Record record : records) {\n\t\t\ttry {\n\n\t\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tif (running.get() && connection.isExecuting()) {\n\t\t\t\t\t\t\tprocessRecord(record, connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\tLOGGER.debug(\"Execution rejected while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\tbreak;\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\tterminateConnection(connection, e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Process received record.\n\t * \n\t * @param record received record.\n\t * @param connection connection to process record.\n\t */\n\t@Override\n\tpublic void processRecord(Record record, Connection connection) {\n\n\t\ttry {\n\t\t\t// ensure, that connection is still related to record \n\t\t\t// and not changed by processing an other record before \n\t\t\tif (record.getConnectionId() == null && !connection.equalsPeerAddress(record.getPeerAddress())) {\n\t\t\t\tlong delay = TimeUnit.NANOSECONDS.toMillis(ClockUtil.nanoRealtime() - record.getReceiveNanos());\n\t\t\t\tDROP_LOGGER.debug(\"Drop received record {}, connection changed address {} => {}! (shift {}ms)\", record.getType(),\n\t\t\t\t\t\trecord.getPeerAddress(), connection.getPeerAddress(), delay);\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint epoch = record.getEpoch();\n\t\t\tLOGGER.trace(\"Received DTLS record of type [{}], length: {}, [epoche:{},rseqn:{}]\", \n\t\t\t\t\trecord.getType(), record.getFragmentLength(), epoch, record.getSequenceNumber());\n\n\t\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\t\tif (handshaker != null && handshaker.isExpired()) {\n\t\t\t\t// handshake expired during Android / OS \"deep sleep\"\n\t\t\t\t// on receiving, fail to remove connection, if session is not established \n\t\t\t\thandshaker.handshakeFailed(new Exception(\"handshake already expired!\"));\n\t\t\t\tif (connectionStore.get(connection.getConnectionId()) != connection) {\n\t\t\t\t\t// connection removed, then drop record\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding {} record [epoch {}, rseqn {}] received from peer [{}], handshake expired!\",\n\t\t\t\t\t\t\trecord.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thandshaker = null;\n\t\t\t}\n\n\t\t\tDTLSSession session = connection.getSession(epoch);\n\n\t\t\tif (session == null) {\n\t\t\t\tif (handshaker != null && handshaker.getSession().getReadEpoch() == 0 && epoch == 1) {\n\t\t\t\t\t// future records, apply session after handshake finished.\n\t\t\t\t\thandshaker.addRecordsForDeferredProcessing(record);\n\t\t\t\t} else {\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding {} record [epoch {}, rseqn {}] received from peer [{}] without an active session\",\n\t\t\t\t\t\t\trecord.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The DTLS 1.2 spec (section 4.1.2.6) advises to do replay detection\n\t\t\t// before MAC validation based on the record's sequence numbers\n\t\t\t// see http://tools.ietf.org/html/rfc6347#section-4.1.2.6\n\t\t\tboolean closed = connection.isClosed();\n\t\t\tboolean discard = (useFilter || closed) && (session != null)\n\t\t\t\t\t&& !session.isRecordProcessable(epoch, record.getSequenceNumber(), useExtendedWindowFilter);\n\t\t\t// closed and no session => discard it\n\t\t\tdiscard |= (closed && session == null);\n\t\t\tif (discard) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding {} record [epoch {}, rseqn {}] received from closed peer [{}]\", record.getType(),\n\t\t\t\t\t\t\tepoch, record.getSequenceNumber(), record.getPeerAddress());\n\t\t\t\t} else {\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding duplicate {} record [epoch {}, rseqn {}] received from peer [{}]\",\n\t\t\t\t\t\t\trecord.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());\n\t\t\t\t}\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (record.getType() == ContentType.TLS12_CID) {\n\t\t\t\t// !useCid already dropped in Record.fromByteArray\n\t\t\t\tif (epoch == 0) {\n\t\t\t\t\tDROP_LOGGER.debug(\"Discarding TLS_CID record received from peer [{}] during handshake\",\n\t\t\t\t\t\t\trecord.getPeerAddress());\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (epoch > 0 && connection.expectCid()) {\n\t\t\t\tDROP_LOGGER.debug(\"Discarding record received from peer [{}], CID required!\", record.getPeerAddress());\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.receivingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!record.isDecoded() || record.getType() != ContentType.APPLICATION_DATA) {\n\t\t\t\t// application data may be deferred again until the session is really established\n\t\t\t\trecord.applySession(session);\n\t\t\t}\n\n\t\t\tif (handshaker != null && handshaker.isProbing()) {\n\t\t\t\t// received record, probe successful\n\t\t\t\tif (connection.hasEstablishedSession()) {\n\t\t\t\t\tconnectionStore.removeFromEstablishedSessions(connection.getEstablishedSession(), connection);\n\t\t\t\t}\n\t\t\t\tconnection.resetSession();\n\t\t\t\thandshaker.resetProbing();\n\t\t\t\tLOGGER.trace(\"handshake probe successful {}\", connection.getPeerAddress());\n\t\t\t}\n\n\t\t\tswitch (record.getType()) {\n\t\t\tcase APPLICATION_DATA:\n\t\t\t\tprocessApplicationDataRecord(record, connection);\n\t\t\t\tbreak;\n\t\t\tcase ALERT:\n\t\t\t\tprocessAlertRecord(record, connection, session);\n\t\t\t\tbreak;\n\t\t\tcase CHANGE_CIPHER_SPEC:\n\t\t\t\tprocessChangeCipherSpecRecord(record, connection);\n\t\t\t\tbreak;\n\t\t\tcase HANDSHAKE:\n\t\t\t\tprocessHandshakeRecord(record, connection);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDROP_LOGGER.debug(\"Discarding record of unsupported type [{}] from peer [{}]\",\n\t\t\t\t\trecord.getType(), record.getPeerAddress());\n\t\t\t}\n\t\t} catch (RuntimeException e) {\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record from peer [{}]\",\n\t\t\t\t\trecord.getPeerAddress(), e);\n\t\t\tterminateConnection(connection, e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.debug(\"Discarding {} received from peer [{}] caused by {}\",\n\t\t\t\t\trecord.getType(), record.getPeerAddress(), e.getMessage());\n\t\t\tif (health != null) {\n\t\t\t\thealth.receivingRecord(true);\n\t\t\t}\n\t\t\tLOGGER.debug(\"error occurred while processing record from peer [{}]\",\n\t\t\t\t\trecord.getPeerAddress(), e);\n\t\t} catch (HandshakeException e) {\n\t\t\tLOGGER.debug(\"error occurred while processing record from peer [{}]\",\n\t\t\t\t\trecord.getPeerAddress(), e);\n\t\t}\n\t}\n\n\t/**\n\t * Immediately terminates an ongoing handshake with a peer.\n\t * \n\t * Terminating the handshake includes\n\t * <ul>\n\t * <li>canceling any pending retransmissions to the peer</li>\n\t * <li>destroying any state for an ongoing handshake with the peer</li>\n\t * </ul>\n\t * \n\t * @param connection the peer to terminate the handshake with\n\t * @param cause the exception that is the cause for terminating the handshake\n\t */\n\tprivate void terminateOngoingHandshake(final Connection connection, final HandshakeException cause) {\n\n\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\tif (handshaker != null) {\n\t\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\t\tLOGGER.trace(\"Aborting handshake with peer [{}]:\", connection.getPeerAddress(), cause);\n\t\t\t} else if (LOGGER.isDebugEnabled()) {\n\t\t\t\tLOGGER.debug(\"Aborting handshake with peer [{}]: {}\", connection.getPeerAddress(), cause.getMessage());\n\t\t\t}\n\t\t\thandshaker.setFailureCause(cause);\n\t\t\tAlertMessage causingAlert = cause.getAlert();\n\t\t\tDTLSSession session = handshaker.getSession();\n\t\t\tif (!connection.hasEstablishedSession()) {\n\t\t\t\tterminateConnection(connection, causingAlert, session);\n\t\t\t} else {\n\t\t\t\t// keep established session intact and only terminate ongoing handshake\n\t\t\t\t// failure after established (last FINISH), but before completed (first data)\n\t\t\t\tif (connection.getEstablishedSession() == handshaker.getSession()) {\n\t\t\t\t\tif (causingAlert.getDescription() == AlertDescription.CLOSE_NOTIFY) {\n\t\t\t\t\t\tLOGGER.debug(\"Handshake with [{}] closed after session was established!\",\n\t\t\t\t\t\t\t\thandshaker.getPeerAddress());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed after session was established! {}\",\n\t\t\t\t\t\t\t\thandshaker.getPeerAddress(), causingAlert);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOGGER.warn(\"Handshake with [{}] failed, but has an established session!\", handshaker.getPeerAddress());\n\t\t\t\t}\n\t\t\t\tsend(causingAlert, session);\n\t\t\t}\n\t\t\thandshaker.handshakeFailed(cause);\n\t\t}\n\t}\n\n\tprivate void terminateConnection(Connection connection, Throwable cause, AlertLevel level, AlertDescription description) {\n\t\tif (connection.hasEstablishedSession()) {\n\t\t\tterminateConnection(\n\t\t\t\t\tconnection,\n\t\t\t\t\tnew AlertMessage(level, description, connection.getPeerAddress()),\n\t\t\t\t\tconnection.getEstablishedSession());\n\t\t} else if (connection.hasOngoingHandshake()) {\n\t\t\tterminateConnection(\n\t\t\t\t\tconnection,\n\t\t\t\t\tnew AlertMessage(level, description, connection.getPeerAddress()),\n\t\t\t\t\tconnection.getOngoingHandshake().getSession());\n\t\t}\n\t}\n\n\t/**\n\t * Immediately terminates a connection with a peer.\n\t * \n\t * Terminating the connection includes\n\t * <ul>\n\t * <li>canceling any pending retransmissions to the peer</li>\n\t * <li>destroying any established session with the peer</li>\n\t * <li>destroying any handshakers for the peer</li>\n\t * <li>optionally sending a final ALERT to the peer (if a session exists with the peer)</li>\n\t * </ul>\n\t * \n\t * @param connection the connection to terminate\n\t * @param alert the message to send to the peer before terminating the connection (may be <code>null</code>)\n\t * @param session the parameters to encrypt the alert message with (may be <code>null</code> if alert is\n\t *           <code>null</code>)\n\t * @throws IllegalArgumentException if alert is provided, but session not.\n\t */\n\tprivate void terminateConnection(Connection connection, AlertMessage alert, DTLSSession session) {\n\t\tif (alert == null) {\n\t\t\tLOGGER.trace(\"Terminating connection with peer [{}]\", connection.getPeerAddress());\n\t\t} else {\n\t\t\tif (session == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"Session must not be null, if alert message is to be sent\");\n\t\t\t}\n\t\t\tLOGGER.trace(\"Terminating connection with peer [{}], reason [{}]\", connection.getPeerAddress(),\n\t\t\t\t\talert.getDescription());\n\t\t\tsend(alert, session);\n\t\t}\n\t\tif (alert != null && alert.getLevel() == AlertLevel.WARNING && alert.getDescription() == AlertDescription.CLOSE_NOTIFY) {\n\t\t\t// request resumption, keep connection and session\n\t\t\tconnection.setResumptionRequired(true);\n\t\t} else {\n\t\t\t// clear session & (pending) handshaker\n\t\t\tconnectionStore.remove(connection);\n\t\t}\n\t}\n\n\t/**\n\t * Process application data record.\n\t * \n\t * @param record application data record\n\t * @param connection connection to process the received record\n\t */\n\tprivate void processApplicationDataRecord(final Record record, final Connection connection) {\n\t\tfinal Handshaker ongoingHandshake = connection.getOngoingHandshake();\n\t\tfinal DTLSSession session = connection.getEstablishedSession();\n\t\tif (session != null && !connection.isResumptionRequired()) {\n\t\t\t// APPLICATION_DATA can only be processed within the context of\n\t\t\t// an established, i.e. fully negotiated, session\n\t\t\tApplicationMessage message = (ApplicationMessage) record.getFragment();\n\n\t\t\tupdateConnectionAddress(record, connection, session);\n\n\t\t\tfinal RawDataChannel channel = messageHandler;\n\t\t\t// finally, forward de-crypted message to application layer\n\t\t\tif (channel != null) {\n\t\t\t\t// context\n\t\t\t\tInetSocketAddress peer = session.getPeer();\n\t\t\t\tif (peer == null) {\n\t\t\t\t\t// set peer\n\t\t\t\t\t// endpoint context would fail ...\n\t\t\t\t\tsession.setPeer(record.getPeerAddress());\n\t\t\t\t}\n\t\t\t\t// create application message.\n\t\t\t\tDtlsEndpointContext context = session.getConnectionReadContext();\n\t\t\t\tif (peer == null) {\n\t\t\t\t\t// reset peer\n\t\t\t\t\tsession.setPeer(null);\n\t\t\t\t\tLOGGER.debug(\"Received APPLICATION_DATA from deprecated {}\", record.getPeerAddress());\n\t\t\t\t}\n\t\t\t\tLOGGER.trace(\"Received APPLICATION_DATA for {}\", context);\n\t\t\t\tRawData receivedApplicationMessage = RawData.inbound(message.getData(), context, false,\n\t\t\t\t\t\trecord.getReceiveNanos());\n\t\t\t\tchannel.receiveData(receivedApplicationMessage);\n\t\t\t}\n\t\t} else if (ongoingHandshake != null) {\n\t\t\t// wait for FINISH\n\t\t\t// the record is already decoded, so adding it for deferred processing\n\t\t\t// requires to protect it from applying the session again in processRecord!\n\t\t\tongoingHandshake.addRecordsForDeferredProcessing(record);\n\t\t} else {\n\t\t\tDROP_LOGGER.debug(\"Discarding APPLICATION_DATA record received from peer [{}]\",\n\t\t\t\t\trecord.getPeerAddress());\n\t\t}\n\t}\n\n\t/**\n\t * Process alert record.\n\t * \n\t * @param record alert record\n\t * @param connection connection to process the received record\n\t * @param session session applied to decode record\n\t */\n\tprivate void processAlertRecord(Record record, Connection connection, DTLSSession session) {\n\t\tAlertMessage alert = (AlertMessage) record.getFragment();\n\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\tHandshakeException error = null;\n\t\tLOGGER.trace(\"Processing {} ALERT from [{}]: {}\",\n\t\t\t\talert.getLevel(), alert.getPeer(), alert.getDescription());\n\t\tif (AlertDescription.CLOSE_NOTIFY.equals(alert.getDescription())) {\n\t\t\t// according to section 7.2.1 of the TLS 1.2 spec\n\t\t\t// (http://tools.ietf.org/html/rfc5246#section-7.2.1)\n\t\t\t// we need to respond with a CLOSE_NOTIFY alert and\n\t\t\t// then close and remove the connection immediately\n\t\t\tif (connection.hasEstablishedSession()) {\n\t\t\t\tupdateConnectionAddress(record, connection, session);\n\t\t\t} else {\n\t\t\t\terror = new HandshakeException(\"Received 'close notify'\", alert);\n\t\t\t\tif (handshaker != null) {\n\t\t\t\t\thandshaker.setFailureCause(error);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!connection.isResumptionRequired()) {\n\t\t\t\tif (session.getPeer() != null) {\n\t\t\t\t\tsend(new AlertMessage(AlertLevel.WARNING, AlertDescription.CLOSE_NOTIFY, alert.getPeer()), session);\n\t\t\t\t}\n\t\t\t\tif (connection.hasEstablishedSession()) {\n\t\t\t\t\tconnection.close(record);\n\t\t\t\t} else {\n\t\t\t\t\tconnectionStore.remove(connection);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (AlertLevel.FATAL.equals(alert.getLevel())) {\n\t\t\t// according to section 7.2 of the TLS 1.2 spec\n\t\t\t// (http://tools.ietf.org/html/rfc5246#section-7.2)\n\t\t\t// the connection needs to be terminated immediately\n\t\t\terror = new HandshakeException(\"Received 'fatal alert/\" + alert.getDescription() + \"'\", alert);\n\t\t\tif (handshaker != null) {\n\t\t\t\thandshaker.setFailureCause(error);\n\t\t\t}\n\t\t\tconnectionStore.remove(connection);\n\t\t} else {\n\t\t\t// non-fatal alerts do not require any special handling\n\t\t}\n\t\thandleAlertInternal(alert.getPeer(), alert, connection);\n\t\tif (null != error && null != handshaker) {\n\t\t\thandshaker.handshakeFailed(error);\n\t\t}\n\t}\n\n\t/**\n\t * Update connection address.\n\t * \n\t * @param record received record.\n\t * @param connection connection of received record\n\t * @param session session of received record\n\t * @since 2.5\n\t */\n\tprivate void updateConnectionAddress(Record record, Connection connection, DTLSSession session) {\n\t\tInetSocketAddress newAddress = null;\n\t\tif (session.markRecordAsRead(record.getEpoch(), record.getSequenceNumber())\n\t\t\t\t|| !useCidUpdateAddressOnNewerRecordFilter) {\n\t\t\t// address update, it's a newer record!\n\t\t\tconnection.setRouter(record.getRouter());\n\t\t\tnewAddress = record.getPeerAddress();\n\t\t}\n\t\tconnection.refreshAutoResumptionTime();\n\t\tconnectionStore.update(connection, newAddress);\n\t\tfinal Handshaker ongoingHandshake = connection.getOngoingHandshake();\n\t\tif (ongoingHandshake != null) {\n\t\t\t// the handshake has been completed successfully\n\t\t\tongoingHandshake.handshakeCompleted();\n\t\t}\n\t}\n\n\t/**\n\t * Process change cipher spec record.\n\t * \n\t * @param record change cipher spec record\n\t * @param connection connection to process the received record\n\t */\n\tprivate void processChangeCipherSpecRecord(Record record, Connection connection) {\n\t\tHandshaker ongoingHandshaker = connection.getOngoingHandshake();\n\t\tif (ongoingHandshaker != null) {\n\t\t\t// processing a CCS message does not result in any additional flight to be sent\n\t\t\ttry {\n\t\t\t\tongoingHandshaker.processMessage(record);\n\t\t\t} catch (HandshakeException e) {\n\t\t\t\thandleExceptionDuringHandshake(e, connection, record);\n\t\t\t}\n\t\t} else {\n\t\t\t// change cipher spec can only be processed within the\n\t\t\t// context of an existing handshake -> ignore record\n\t\t\tDROP_LOGGER.debug(\"Received CHANGE_CIPHER_SPEC record from peer [{}] with no handshake going on\", record.getPeerAddress());\n\t\t}\n\t}\n\n\t/**\n\t * Process handshake record.\n\t * \n\t * @param record handshake record\n\t * @param connection connection to process the record.\n\t */\n\tprivate void processHandshakeRecord(final Record record, final Connection connection) {\n\t\tLOGGER.trace(\"Received {} record from peer [{}]\", record.getType(), record.getPeerAddress());\n\t\ttry {\n\t\t\tif (record.isNewClientHello()) {\n\t\t\t\tthrow new IllegalArgumentException(\"new CLIENT_HELLO must be processed by processClientHello!\");\n\t\t\t}\n\t\t\tHandshakeMessage handshakeMessage = (HandshakeMessage) record.getFragment();\n\t\t\tswitch (handshakeMessage.getMessageType()) {\n\t\t\tcase CLIENT_HELLO:\n\t\t\t\t// We do not support re-negotiation as recommended in :\n\t\t\t\t// https://tools.ietf.org/html/rfc7925#section-17\n\t\t\t\tDROP_LOGGER.debug(\"Reject re-negotiation from peer {}\", record.getPeerAddress());\n\t\t\t\tDTLSSession session = connection.getEstablishedSession();\n\t\t\t\tsend(new AlertMessage(AlertLevel.WARNING, AlertDescription.NO_RENEGOTIATION, record.getPeerAddress()),\n\t\t\t\t\t\tsession);\n\t\t\t\tbreak;\n\t\t\tcase HELLO_REQUEST:\n\t\t\t\tprocessHelloRequest(connection);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\tif (handshaker != null) {\n\t\t\t\t\thandshaker.processMessage(record);\n\t\t\t\t} else {\n\t\t\t\t\tDROP_LOGGER.debug(\n\t\t\t\t\t\t\t\"Discarding HANDSHAKE message [epoch={}] from peer [{}], no ongoing handshake!\",\n\t\t\t\t\t\t\trecord.getEpoch(), record.getPeerAddress());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\thandleExceptionDuringHandshake(e, connection, record);\n\t\t}\n\t}\n\n\t/**\n\t * Process HELLO_REQUEST.\n\t * \n\t * @param connection connection to process HELLO_REQUEST message.\n\t * @throws HandshakeException if the message to initiate the handshake with\n\t *             the peer cannot be created\n\t */\n\tprivate void processHelloRequest(final Connection connection) throws HandshakeException {\n\t\tif (connection.hasOngoingHandshake()) {\n\t\t\t// TLS 1.2, Section 7.4 advises to ignore HELLO_REQUEST messages\n\t\t\t// arriving while in an ongoing handshake\n\t\t\t// (http://tools.ietf.org/html/rfc5246#section-7.4)\n\t\t\tDROP_LOGGER.debug(\"Ignoring HELLO_REQUEST received from [{}] while already in an ongoing handshake with peer\",\n\t\t\t\t\tconnection.getPeerAddress());\n\t\t} else {\n\t\t\t// We do not support re-negotiation as recommended in :\n\t\t\t// https://tools.ietf.org/html/rfc7925#section-17\n\t\t\tDTLSSession session = connection.getEstablishedSession();\n\t\t\tsend(new AlertMessage(AlertLevel.WARNING, AlertDescription.NO_RENEGOTIATION, connection.getPeerAddress()),\n\t\t\t\t\tsession);\n\t\t}\n\t}\n\n\t/**\n\t * Process new CLIENT_HELLO message.\n\t * \n\t * Executed outside the serial execution. Checks for either a valid session\n\t * id or a valid cookie. If the check is passed successfully, check next, if\n\t * a connection for that CLIENT_HELLO already exists using the client random\n\t * contained in the CLIENT_HELLO message. If the connection already exists,\n\t * take that, otherwise create a new one and pass the execution to the\n\t * serial execution of that connection.\n\t * \n\t * @param record record of CLIENT_HELLO message\n\t */\n\tprivate void processNewClientHello(final Record record) {\n\t\tInetSocketAddress peerAddress = record.getPeerAddress();\n\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\tStringBuilder msg = new StringBuilder(\"Processing new CLIENT_HELLO from peer [\")\n\t\t\t\t\t.append(peerAddress).append(\"]\").append(\":\").append(StringUtil.lineSeparator()).append(record);\n\t\t\tLOGGER.trace(msg.toString());\n\t\t}\n\t\ttry {\n\t\t\t// CLIENT_HELLO with epoch 0 is not encrypted, so use DTLSConnectionState.NULL \n\t\t\trecord.applySession(null);\n\t\t\tDTLSMessage message = record.getFragment();\n\t\t\tif (message instanceof FragmentedHandshakeMessage) {\n\t\t\t\tLOGGER.debug(\"Received unsupported fragmented CLIENT_HELLO from peer [{}].\", peerAddress);\n\t\t\t\tdiscardRecord(record, new DtlsException(\"Fragmented CLIENT_HELLO is not supported!\", peerAddress));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal ClientHello clientHello = (ClientHello) message;\n\n\t\t\t// before starting a new handshake or resuming an established\n\t\t\t// session we need to make sure that the peer is in possession of\n\t\t\t// the IP address indicated in the client hello message\n\t\t\tfinal AvailableConnections connections = new AvailableConnections();\n\t\t\tif (isClientInControlOfSourceIpAddress(clientHello, record, connections)) {\n\t\t\t\tboolean verify = false;\n\t\t\t\tExecutorService executorService = getExecutorService();\n\t\t\t\tConnection connection;\n\t\t\t\tsynchronized (connectionStore) {\n\t\t\t\t\tconnection = connectionStore.get(peerAddress);\n\t\t\t\t\tif (connection != null && !connection.isStartedByClientHello(clientHello)) {\n\t\t\t\t\t\tConnection sessionConnection = connections.getConnectionBySessionId();\n\t\t\t\t\t\tif (sessionConnection != null && sessionConnection != connection) {\n\t\t\t\t\t\t\t// don't overwrite\n\t\t\t\t\t\t\tverify = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sessionConnection != null && sessionConnection == connection) {\n\t\t\t\t\t\t\t\tconnections.setRemoveConnectionBySessionId(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal Handshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\t\t\t\t\t\tif (establishedSession == null || handshaker.getSession() != establishedSession) {\n\t\t\t\t\t\t\t\t\tfinal DtlsException cause = new DtlsException(\n\t\t\t\t\t\t\t\t\t\t\t\"Received new CLIENT_HELLO from \" + StringUtil.toDisplayString(peerAddress),\n\t\t\t\t\t\t\t\t\t\t\tpeerAddress);\n\t\t\t\t\t\t\t\t\thandshaker.setFailureCause(cause);\n\t\t\t\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\t\t\t\thandshaker.handshakeFailed(cause);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (connection == null) {\n\t\t\t\t\t\tconnection = new Connection(peerAddress, new SerialExecutor(executorService));\n\t\t\t\t\t\tconnection.setExecutionListener(connectionExecutionListener);\n\t\t\t\t\t\tconnection.startByClientHello(clientHello);\n\t\t\t\t\t\tif (!connectionStore.put(connection)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (verify) {\n\t\t\t\t\tsendHelloVerify(clientHello, record, null);\n\t\t\t\t} else {\n\t\t\t\t\tconnections.setConnectionByAddress(connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tif (running.get() && connections.getConnectionByAddress().isExecuting()) {\n\t\t\t\t\t\t\t\t\tprocessClientHello(clientHello, record, connections);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\t\t\tLOGGER.debug(\"Execution rejected while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t\tterminateConnection(connections.getConnectionByAddress(), e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\tLOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (RuntimeException e) {\n\t\t\tLOGGER.warn(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t}\n\t}\n\n\t/**\n\t * Process CLIENT_HELLO message.\n\t * \n\t * @param clientHello CLIENT_HELLO message\n\t * @param record record of CLIENT_HELLO message\n\t * @param connections available connections to process handshake message\n\t */\n\tprivate void processClientHello(ClientHello clientHello, Record record, AvailableConnections connections) {\n\t\tif (connections == null) {\n\t\t\tthrow new NullPointerException(\"available connections must not be null!\");\n\t\t}\n\t\tConnection connection = connections.getConnectionByAddress();\n\t\tif (connection == null) {\n\t\t\tthrow new NullPointerException(\"connection by address must not be null!\");\n\t\t} else if (!connection.equalsPeerAddress(record.getPeerAddress())) {\n\t\t\tDROP_LOGGER.info(\"Drop received CLIENT_HELLO, changed address {} => {}!\", record.getPeerAddress(),\n\t\t\t\t\tconnection.getPeerAddress());\n\t\t\treturn;\n\t\t}\n\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\tStringBuilder msg = new StringBuilder(\"Processing CLIENT_HELLO from peer [\").append(record.getPeerAddress())\n\t\t\t\t\t.append(\"]\").append(\":\").append(StringUtil.lineSeparator()).append(record);\n\t\t\tLOGGER.trace(msg.toString());\n\t\t}\n\n\t\ttry {\n\t\t\tif (connection.hasEstablishedSession() || connection.getOngoingHandshake() != null) {\n\t\t\t\tDROP_LOGGER.debug(\"Discarding received duplicate CLIENT_HELLO message [epoch={}] from peer [{}]!\", record.getEpoch(),\n\t\t\t\t\t\trecord.getPeerAddress());\n\t\t\t} else if (clientHello.hasSessionId()) {\n\t\t\t\t// client wants to resume a cached session\n\t\t\t\tresumeExistingSession(clientHello, record, connections);\n\t\t\t} else {\n\t\t\t\t// At this point the client has demonstrated reachability by completing a cookie exchange\n\t\t\t\t// so we terminate the previous connection and start a new handshake\n\t\t\t\t// (see section 4.2.8 of RFC 6347 (DTLS 1.2))\n\t\t\t\tstartNewHandshake(clientHello, record, connection);\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\thandleExceptionDuringHandshake(e, connection, record);\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether the peer is able to receive data on the IP address indicated\n\t * in its client hello message.\n\t * <p>\n\t * The check is done by means of comparing the cookie contained in the client hello\n\t * message with the cookie computed for the request using the <code>generateCookie</code>\n\t * method.\n\t * </p>\n\t * <p>This method sends a <em>HELLO_VERIFY_REQUEST</em> to the peer if the cookie contained\n\t * in <code>clientHello</code> does not match the expected cookie.\n\t * </p>\n\t * <p>If a matching session id is contained, but no cookie, it depends on the\n\t * number of pending resumption handshakes, if a\n\t * <em>HELLO_VERIFY_REQUEST</em> is send to the peer, of a resumption\n\t * handshake is started without.\n\t * </p>\n\t * May be Executed outside the serial execution, if the connection is\n\t * {@code null}.\n\t * \n\t * @param clientHello the peer's client hello method including the cookie to\n\t *            verify\n\t * @param record the received record\n\t * @param connections used to set the\n\t *            {@link AvailableConnections#bySessionId} with the result of\n\t *            {@link ResumptionSupportingConnectionStore#find(SessionId)}.\n\t * @return <code>true</code> if the client hello message contains a cookie\n\t *         and the cookie is identical to the cookie expected from the peer\n\t *         address, or it contains a matching session id.\n\t */\n\tprivate boolean isClientInControlOfSourceIpAddress(ClientHello clientHello, Record record, AvailableConnections connections) {\n\t\tif (connections == null) {\n\t\t\tthrow new NullPointerException(\"available connections must not be null!\");\n\t\t}\n\t\t// verify client's ability to respond on given IP address\n\t\t// by exchanging a cookie as described in section 4.2.1 of the DTLS 1.2 spec\n\t\t// see http://tools.ietf.org/html/rfc6347#section-4.2.1\n\t\ttry {\n\t\t\tbyte[] expectedCookie = null;\n\t\t\tbyte[] providedCookie = clientHello.getCookie();\n\t\t\tif (providedCookie.length > 0) {\n\t\t\t\texpectedCookie = cookieGenerator.generateCookie(clientHello);\n\t\t\t\t// if cookie is present, it must match\n\t\t\t\tif (MessageDigest.isEqual(expectedCookie, providedCookie)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// check, if cookie of the past period matches\n\t\t\t\tbyte[] pastCookie = cookieGenerator.generatePastCookie(clientHello);\n\t\t\t\tif (pastCookie != null && MessageDigest.isEqual(pastCookie, providedCookie)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (LOGGER.isDebugEnabled()) {\n\t\t\t\t\tLOGGER.debug(\"provided cookie must {} match {}. Send verify request to {}\",\n\t\t\t\t\t\t\tStringUtil.byteArray2HexString(providedCookie, StringUtil.NO_SEPARATOR, 6),\n\t\t\t\t\t\t\tStringUtil.byteArray2HexString(expectedCookie, StringUtil.NO_SEPARATOR, 6),\n\t\t\t\t\t\t\trecord.getPeerAddress());\n\t\t\t\t}\n\t\t\t\t// otherwise send verify request\n\t\t\t} else {\n\t\t\t\t// threshold 0 always use a verify request\n\t\t\t\tif (0 < thresholdHandshakesWithoutVerifiedPeer) {\n\t\t\t\t\tint pending = pendingHandshakesWithoutVerifiedPeer.get();\n\t\t\t\t\tLOGGER.trace(\"pending fast resumptions [{}], threshold [{}]\", pending,\n\t\t\t\t\t\t\tthresholdHandshakesWithoutVerifiedPeer);\n\t\t\t\t\tif (pending < thresholdHandshakesWithoutVerifiedPeer) {\n\t\t\t\t\t\t// use short resumption (without verify request)\n\t\t\t\t\t\t// only, if the number of the pending short\n\t\t\t\t\t\t// resumption handshakes is below the threshold\n\t\t\t\t\t\tConnection sessionConnection = connectionStore.find(clientHello.getSessionId());\n\t\t\t\t\t\tconnections.setConnectionBySessionId(sessionConnection);\n\t\t\t\t\t\tif (sessionConnection != null) {\n\t\t\t\t\t\t\t// found provided session.\n\t\t\t\t\t\t\tSessionTicket ticket;\n\t\t\t\t\t\t\tif (sessionConnection.hasEstablishedSession()) {\n\t\t\t\t\t\t\t\tticket = sessionConnection.getEstablishedSession().getSessionTicket();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tticket = sessionConnection.getSessionTicket();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (verifySessionForResumption(clientHello, ticket)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// for all cases not detected above, use a verify request.\n\t\t\tsendHelloVerify(clientHello, record, expectedCookie);\n\t\t\treturn false;\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tthrow new DtlsHandshakeException(\"Cannot compute cookie for peer\", AlertDescription.INTERNAL_ERROR,\n\t\t\t\t\tAlertLevel.FATAL, clientHello.getPeer(), e);\n\t\t}\n\t}\n\n\t/**\n\t * Start a new handshake.\n\t * \n\t * @param clientHello CLIENT_HELLO message.\n\t * @param record record containing the CLIENT_HELLO message.\n\t * @param connection connection to start handshake.\n\t * @throws HandshakeException if the parameters provided in the client hello message\n\t *           cannot be used to start a handshake with the peer\n\t */\n\tprivate void startNewHandshake(final ClientHello clientHello, final Record record, final Connection connection) throws HandshakeException {\n\t\t// use the record sequence number from CLIENT_HELLO as initial sequence number\n\t\t// for records sent to the client (see section 4.2.1 of RFC 6347 (DTLS 1.2))\n\t\tDTLSSession newSession = new DTLSSession(record.getPeerAddress(), record.getSequenceNumber());\n\t\t// initialize handshaker based on CLIENT_HELLO (this accounts\n\t\t// for the case that multiple cookie exchanges have taken place)\n\t\tHandshaker handshaker = new ServerHandshaker(clientHello.getMessageSeq(), newSession, this, timer, connection, config);\n\t\tinitializeHandshaker(handshaker);\n\t\thandshaker.processMessage(record);\n\t}\n\n\t/**\n\t * Resume existing session.\n\t * \n\t * @param clientHello CLIENT_HELLO message.\n\t * @param record record containing the CLIENT_HELLO message.\n\t * @param connections available connections to resume\n\t * @throws HandshakeException if the session cannot be resumed based on the parameters\n\t *             provided in the client hello message\n\t */\n\tprivate void resumeExistingSession(ClientHello clientHello, Record record, final AvailableConnections connections)\n\t\t\tthrows HandshakeException {\n\t\tInetSocketAddress peerAddress = record.getPeerAddress();\n\t\tLOGGER.trace(\"Client [{}] wants to resume session with ID [{}]\", peerAddress, clientHello.getSessionId());\n\n\t\tif (connections == null) {\n\t\t\tthrow new NullPointerException(\"available connections must not be null!\");\n\t\t}\n\t\tConnection connection = connections.getConnectionByAddress();\n\t\tif (connection == null) {\n\t\t\tthrow new NullPointerException(\"connection by address must not be null!\");\n\t\t} else if (!connection.equalsPeerAddress(peerAddress)) {\n\t\t\tthrow new IllegalArgumentException(\"connection must have records address!\");\n\t\t}\n\n\t\tSessionTicket ticket = null;\n\t\tif (!connections.isConnectionBySessionIdKnown()) {\n\t\t\tconnections.setConnectionBySessionId(connectionStore.find(clientHello.getSessionId()));\n\t\t}\n\t\tConnection previousConnection = connections.getConnectionBySessionId();\n\t\tif (previousConnection != null && previousConnection.isActive()) {\n\t\t\tif (previousConnection.hasEstablishedSession()) {\n\t\t\t\tticket = previousConnection.getEstablishedSession().getSessionTicket();\n\t\t\t} else {\n\t\t\t\tticket = previousConnection.getSessionTicket();\n\t\t\t}\n\t\t\tboolean ok = verifySessionForResumption(clientHello, ticket);\n\t\t\tif (!ok && ticket != null) {\n\t\t\t\tSecretUtil.destroy(ticket);\n\t\t\t\tticket = null;\n\t\t\t}\n\t\t}\n\t\tif (ticket != null) {\n\t\t\t// session has been found in cache, resume it\n\t\t\tfinal DTLSSession sessionToResume = new DTLSSession(clientHello.getSessionId(), peerAddress, ticket,\n\t\t\t\t\trecord.getSequenceNumber());\n\t\t\tfinal Handshaker handshaker = new ResumingServerHandshaker(clientHello.getMessageSeq(), sessionToResume,\n\t\t\t\t\tthis, timer, connection, config);\n\t\t\tinitializeHandshaker(handshaker);\n\t\t\tSecretUtil.destroy(ticket);\n\n\t\t\tif (previousConnection.hasEstablishedSession()) {\n\t\t\t\t// client wants to resume a session that has been negotiated by this node\n\t\t\t\t// make sure that the same client only has a single active connection to this server\n\t\t\t\tif (connections.isRemoveConnectionBySessionId()) {\n\t\t\t\t\t// immediately remove previous connection\n\t\t\t\t\tconnectionStore.remove(previousConnection, false);\n\t\t\t\t} else if (clientHello.getCookie().length == 0) {\n\t\t\t\t\t// short resumption without verify request\n\t\t\t\t\tpendingHandshakesWithoutVerifiedPeer.incrementAndGet();\n\t\t\t\t\thandshaker.addSessionListener(new SessionAdapter() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void sessionEstablished(final Handshaker currentHandshaker,\n\t\t\t\t\t\t\t\tfinal DTLSSession establishedSession) throws HandshakeException {\n\t\t\t\t\t\t\tpendingHandshakesWithoutVerifiedPeer.decrementAndGet();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void handshakeFailed(Handshaker handshaker, Throwable error) {\n\t\t\t\t\t\t\tpendingHandshakesWithoutVerifiedPeer.decrementAndGet();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// process message\n\t\t\thandshaker.processMessage(record);\n\t\t} else {\n\t\t\tLOGGER.trace(\n\t\t\t\t\t\"Client [{}] tries to resume non-existing session [ID={}], performing full handshake instead ...\",\n\t\t\t\t\tpeerAddress, clientHello.getSessionId());\n\t\t\tstartNewHandshake(clientHello, record, connection);\n\t\t}\n\t}\n\t\n\tprivate boolean verifySessionForResumption(ClientHello clientHello, SessionTicket ticket) {\n\t\tboolean ok = true;\n\t\tif (ticket != null && config.isSniEnabled()) {\n\t\t\tServerNames serverNames1 = ticket.getServerNames();\n\t\t\tServerNames serverNames2 = null;\n\t\t\tServerNameExtension extension = clientHello.getServerNameExtension();\n\t\t\tif (extension != null) {\n\t\t\t\tserverNames2 = extension.getServerNames();\n\t\t\t}\n\t\t\tif (serverNames1 != null) {\n\t\t\t\tok = serverNames1.equals(serverNames2);\n\t\t\t} else if (serverNames2 != null) {\n\t\t\t\t// invalidate ticket, server names mismatch\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\n\tprivate void sendHelloVerify(ClientHello clientHello, Record record, byte[] expectedCookie) throws GeneralSecurityException {\n\t\t// send CLIENT_HELLO_VERIFY with cookie in order to prevent\n\t\t// DOS attack as described in DTLS 1.2 spec\n\t\tLOGGER.trace(\"Verifying client IP address [{}] using HELLO_VERIFY_REQUEST\", record.getPeerAddress());\n\t\tif (expectedCookie == null) {\n\t\t\texpectedCookie = cookieGenerator.generateCookie(clientHello);\n\t\t}\n\t\tProtocolVersion version = protocolVersionForHelloVerifyRequests;\n\t\tif (version == null) {\n\t\t\t// no fixed version configured, reply the client's version.\n\t\t\tversion = clientHello.getClientVersion();\n\t\t\tif (version.compareTo(ProtocolVersion.VERSION_DTLS_1_0) < 0) {\n\t\t\t\tversion = ProtocolVersion.VERSION_DTLS_1_0;\n\t\t\t} else if (version.compareTo(ProtocolVersion.VERSION_DTLS_1_2) > 0) {\n\t\t\t\tversion = ProtocolVersion.VERSION_DTLS_1_2;\n\t\t\t}\n\t\t}\n\t\t// according RFC 6347, 4.2.1. Denial-of-Service Countermeasures, the HelloVerifyRequest should use version 1.0\n\t\tHelloVerifyRequest msg = new HelloVerifyRequest(version, expectedCookie, record.getPeerAddress());\n\t\t// because we do not have a handshaker in place yet that\n\t\t// manages message_seq numbers, we need to set it explicitly\n\t\t// use message_seq from CLIENT_HELLO in order to allow for\n\t\t// multiple consecutive cookie exchanges with a client\n\t\tmsg.setMessageSeq(clientHello.getMessageSeq());\n\t\t// use epoch 0 and sequence no from CLIENT_HELLO record as\n\t\t// mandated by section 4.2.1 of the DTLS 1.2 spec\n\t\t// see http://tools.ietf.org/html/rfc6347#section-4.2.1\n\t\tRecord helloVerify = new Record(ContentType.HANDSHAKE, version, record.getSequenceNumber(), msg, record.getPeerAddress());\n\t\ttry {\n\t\t\tsendRecord(helloVerify);\n\t\t} catch (IOException e) {\n\t\t\t// already logged ...\n\t\t}\n\t}\n\n\tvoid send(AlertMessage alert, DTLSSession session) {\n\t\tif (alert == null) {\n\t\t\tthrow new IllegalArgumentException(\"Alert must not be NULL\");\n\t\t} else if (session == null) {\n\t\t\tthrow new IllegalArgumentException(\"Session must not be NULL\");\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tLOGGER.trace(\"send ALERT {} for peer {}.\", alert, session.getPeer());\n\t\t\t\tRecord record;\n\t\t\t\tboolean useCid = session.getWriteEpoch() > 0;\n\t\t\t\tif (useCid || alert.getProtocolVersion() == null) {\n\t\t\t\t\trecord = new Record(ContentType.ALERT, session.getWriteEpoch(), session.getSequenceNumber(), alert,\n\t\t\t\t\t\tsession, useCid, TLS12_CID_PADDING);\n\t\t\t\t} else {\n\t\t\t\t\trecord = new Record(ContentType.ALERT, alert.getProtocolVersion(), session.getSequenceNumber(), alert,\n\t\t\t\t\t\t\tsession.getPeer());\n\t\t\t\t}\n\t\t\t\tsendRecord(record);\n\t\t\t} catch (IOException e) {\n\t\t\t\t// already logged ...\n\t\t\t} catch (GeneralSecurityException e) {\n\t\t\t\tDROP_LOGGER.warn(\"Cannot create ALERT message for peer [{}]\", session.getPeer(), e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void send(final RawData message) {\n\t\tif (message == null) {\n\t\t\tthrow new NullPointerException(\"Message must not be null\");\n\t\t}\n\t\tif (health != null) {\n\t\t\thealth.sendingRecord(false);\n\t\t}\n\t\tif (message.isMulticast()) {\n\t\t\tDROP_LOGGER.warn(\"DTLSConnector drops {} outgoing bytes to multicast {}:{}\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\tmessage.onError(new MulticastNotSupportedException(\"DTLS doesn't support multicast!\"));\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (message.getInetSocketAddress().getPort() == 0) {\n\t\t\tString destination = StringUtil.toString(message.getInetSocketAddress());\n\t\t\tDROP_LOGGER.warn(\"DTLSConnector drops {} outgoing bytes to [{}] without destination-port\",\n\t\t\t\t\tmessage.getSize(), destination);\n\t\t\tmessage.onError(new IOException(\"CoAPs message to \" + destination + \" dropped, destination port 0!\"));\n\t\t\treturn;\n\t\t}\n\t\tfinal Connection connection;\n\t\tRuntimeException error = null;\n\n\t\tif (!running.get()) {\n\t\t\tconnection = null;\n\t\t\terror = new IllegalStateException(\"connector must be started before sending messages is possible\");\n\t\t} else if (message.getSize() > MAX_PLAINTEXT_FRAGMENT_LENGTH) {\n\t\t\tconnection = null;\n\t\t\terror = new IllegalArgumentException(\n\t\t\t\t\t\"Message data must not exceed \" + MAX_PLAINTEXT_FRAGMENT_LENGTH + \" bytes\");\n\t\t} else {\n\t\t\tboolean create = !serverOnly;\n\t\t\tif (create) {\n\t\t\t\tcreate = !getEffectiveHandshakeMode(message).equals(DtlsEndpointContext.HANDSHAKE_MODE_NONE);\n\t\t\t}\n\t\t\tconnection = getConnection(message.getInetSocketAddress(), null, create);\n\t\t\tif (connection == null) {\n\t\t\t\tif (create) {\n\t\t\t\t\terror = new IllegalStateException(\"connection store is exhausted!\");\n\t\t\t\t} else {\n\t\t\t\t\tif (serverOnly) {\n\t\t\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"server only, connection missing!\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"connection missing!\"));\n\t\t\t\t\t}\n\t\t\t\t\tDROP_LOGGER.debug(\"DTLSConnector drops {} outgoing bytes to {}:{}, connection missing!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (error != null) {\n\t\t\tDROP_LOGGER.debug(\"DTLSConnector drops {} outgoing bytes to {}:{}, {}!\", message.getSize(),\n\t\t\t\t\tmessage.getAddress(), message.getPort(), error.getMessage());\n\t\t\tmessage.onError(error);\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\n\t\tfinal long now =ClockUtil.nanoRealtime();\n\t\tif (pendingOutboundMessagesCountdown.decrementAndGet() >= 0) {\n\t\t\ttry {\n\t\t\t\tSerialExecutor executor = connection.getExecutor();\n\t\t\t\tif (executor == null) {\n\t\t\t\t\tthrow new NullPointerException(\"missing executor for connection! \" + connection.getPeerAddress());\n\t\t\t\t}\n\t\t\t\texecutor.execute(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (running.get() && connection.isExecuting()) {\n\t\t\t\t\t\t\t\tsendMessage(now, message, connection);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, connector not running!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\t\t\t\t\tmessage.onError(new InterruptedIOException(\"Connector is not running.\"));\n\t\t\t\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\tLOGGER.warn(\"Exception thrown by executor thread [{}]\",\n\t\t\t\t\t\t\t\t\t\tThread.currentThread().getName(), e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, {}\", message.getSize(), message.getAddress(), message.getPort(), e.getMessage());\n\t\t\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmessage.onError(e);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tpendingOutboundMessagesCountdown.incrementAndGet();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\tLOGGER.debug(\"Execution rejected while sending application record [peer: {}]\",\n\t\t\t\t\t\tmessage.getInetSocketAddress(), e);\n\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, {}\", message.getSize(), message.getAddress(), message.getPort(), e.getMessage());\n\t\t\t\tmessage.onError(new InterruptedIOException(\"Connector is not running.\"));\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tpendingOutboundMessagesCountdown.incrementAndGet();\n\t\t\tDROP_LOGGER.warn(\"Outbound message overflow! Dropping outbound message to peer [{}]\",\n\t\t\t\t\tmessage.getInetSocketAddress());\n\t\t\tmessage.onError(new IllegalStateException(\"Outbound message overflow!\"));\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Sends a raw message to a peer.\n\t * <p>\n\t * This method encrypts and sends the bytes contained in the message using an\n\t * already established session with the peer. If no session exists yet, a\n\t * new handshake with the peer is initiated and the sending of the message is\n\t * deferred to after the handshake has been completed and a session is established.\n\t * </p>\n\t * \n\t * @param nanos system nanoseconds of receiving the data\n\t * @param message the data to send to the peer\n\t * @param connection connection of the peer\n\t * @throws HandshakeException if starting the handshake fails\n\t */\n\tprivate void sendMessage(final long nanos, final RawData message, final Connection connection) throws HandshakeException {\n\n\t\tif (connection.getPeerAddress() == null) {\n\t\t\tlong delay = TimeUnit.NANOSECONDS.toMillis(ClockUtil.nanoRealtime() - nanos);\n\t\t\tDROP_LOGGER.info(\"Drop outgoing record with {} bytes, connection lost address {}! (shift {}ms)\", message.getSize(),\n\t\t\t\t\tmessage.getInetSocketAddress(), delay);\n\t\t\tmessage.onError(new EndpointUnconnectedException(\"connection not longer assigned to address!\"));\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tLOGGER.trace(\"Sending application layer message to [{}]\", message.getEndpointContext());\n\n\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\tif (handshaker != null && !handshaker.hasSessionEstablished()) {\n\t\t\tif (handshaker.isExpired()) {\n\t\t\t\t// handshake expired during Android / OS \"deep sleep\"\n\t\t\t\t// on sending, abort, keep connection for new handshake\n\t\t\t\thandshaker.handshakeAborted(new Exception(\"handshake already expired!\"));\n\t\t\t} else if (handshaker.isProbing()) {\n\t\t\t\tif (checkOutboundEndpointContext(message, null)) {\n\t\t\t\t\tmessage.onConnecting();\n\t\t\t\t\thandshaker.addApplicationDataForDeferredProcessing(message);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (connection.isActive() && !connection.isClosed()) {\n\t\t\tsendMessageWithSession(message, connection);\n\t\t} else {\n\t\t\tsendMessageWithoutSession(message, connection);\n\t\t}\n\t}\n\n\t/**\n\t * Send message without session.\n\t * \n\t * Starts handshake, if not already pending, and queue message.\n\t * \n\t * @param message message to send after handshake completes\n\t * @param connection connection to send message\n\t * @throws HandshakeException If exception occurred starting the handshake\n\t * @since 2.1\n\t */\n\tprivate void sendMessageWithoutSession(final RawData message, final Connection connection)\n\t\t\tthrows HandshakeException {\n\n\t\tif (!checkOutboundEndpointContext(message, null)) {\n\t\t\treturn;\n\t\t}\n\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\tif (handshaker == null) {\n\t\t\tif (serverOnly) {\n\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, server only, connection missing!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"server only, connection missing!\"));\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean none = getEffectiveHandshakeMode(message).contentEquals(DtlsEndpointContext.HANDSHAKE_MODE_NONE);\n\t\t\tif (none) {\n\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, connection missing!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"connection missing!\"));\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDTLSSession session = new DTLSSession(message.getInetSocketAddress());\n\t\t\tsession.setHostName(message.getEndpointContext().getVirtualHost());\n\t\t\t// no session with peer established nor handshaker started yet,\n\t\t\t// create new empty session & start handshake\n\t\t\thandshaker = new ClientHandshaker(session, this, timer, connection, config, false);\n\t\t\tinitializeHandshaker(handshaker);\n\t\t\tmessage.onConnecting();\n\t\t\thandshaker.addApplicationDataForDeferredProcessing(message);\n\t\t\thandshaker.startHandshake(); // may fail with IOException!\n\t\t} else {\n\t\t\tmessage.onConnecting();\n\t\t\thandshaker.addApplicationDataForDeferredProcessing(message);\n\t\t}\n\t}\n\n\t/**\n\t * Send message with session.\n\t * \n\t * Starts handshake, if requested by resumption or {@link DtlsEndpointContext#KEY_HANDSHAKE_MODE}.\n\t * \n\t * @param message message to send\n\t * @param connection connection to send message\n\t * @throws HandshakeException If exception occurred starting the handshake\n\t * @since 2.1\n\t */\n\tprivate void sendMessageWithSession(final RawData message, final Connection connection) throws HandshakeException {\n\n\t\tDTLSSession session = connection.getEstablishedSession();\n\t\tboolean markedAsClosed = session != null && session.isMarkedAsClosed();\n\t\tString handshakeMode = getEffectiveHandshakeMode(message);\n\t\tboolean none = DtlsEndpointContext.HANDSHAKE_MODE_NONE.equals(handshakeMode);\n\t\tif (none) {\n\t\t\tif (markedAsClosed || connection.isResumptionRequired()) {\n\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, resumption required!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"resumption required!\"));\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tboolean probing = DtlsEndpointContext.HANDSHAKE_MODE_PROBE.equals(handshakeMode);\n\t\t\tboolean full = DtlsEndpointContext.HANDSHAKE_MODE_FORCE_FULL.equals(handshakeMode);\n\t\t\tboolean force = probing || full || DtlsEndpointContext.HANDSHAKE_MODE_FORCE.equals(handshakeMode);\n\t\t\tif (force || markedAsClosed || connection.isAutoResumptionRequired(getAutResumptionTimeout(message))) {\n\t\t\t\t// create the session to resume from the previous one.\n\t\t\t\tif (serverOnly) {\n\t\t\t\t\tDROP_LOGGER.trace(\"DTLSConnector drops {} outgoing bytes to {}:{}, server only, resumption requested failed!\", message.getSize(), message.getAddress(), message.getPort());\n\t\t\t\t\tmessage.onError(new EndpointUnconnectedException(\"server only, resumption requested failed!\"));\n\t\t\t\t\tif (health != null) {\n\t\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmessage.onConnecting();\n\t\t\t\tHandshaker previousHandshaker = connection.getOngoingHandshake();\n\t\t\t\tSessionTicket ticket = null;\n\t\t\t\tSessionId sessionId = null;\n\t\t\t\tif (!full) {\n\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\tsessionId = session.getSessionIdentifier();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsessionId = connection.getSessionIdentity();\n\t\t\t\t\t}\n\t\t\t\t\tfull = sessionId.isEmpty();\n\t\t\t\t\tif (!full) {\n\t\t\t\t\t\tif (session != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tticket = session.getSessionTicket();\n\t\t\t\t\t\t\t} catch (IllegalStateException ex) {\n\t\t\t\t\t\t\t\tLOGGER.debug(\"Not possible to resume incomplete session!\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tticket = connection.getSessionTicket();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (session != null) {\n\t\t\t\t\tif (!probing) {\n\t\t\t\t\t\tconnectionStore.removeFromEstablishedSessions(session, connection);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprobing = false;\n\t\t\t\t}\n\t\t\t\tif (probing) {\n\t\t\t\t\t// Only reset the resumption trigger, but keep the session for now\n\t\t\t\t\t// the session will be reseted with the first received data\n\t\t\t\t\tconnection.setResumptionRequired(false);\n\t\t\t\t} else {\n\t\t\t\t\tconnection.resetSession();\n\t\t\t\t}\n\t\t\t\tHandshaker newHandshaker;\n\t\t\t\tif (ticket == null) {\n\t\t\t\t\t// server may use a empty session id to indicate,\n\t\t\t\t\t// that resumption is not supported\n\t\t\t\t\t// https://tools.ietf.org/html/rfc5246#section-7.4.1.3\n\t\t\t\t\tDTLSSession newSession = new DTLSSession(message.getInetSocketAddress());\n\t\t\t\t\tnewSession.setHostName(message.getEndpointContext().getVirtualHost());\n\t\t\t\t\tnewHandshaker = new ClientHandshaker(newSession, this, timer, connection, config, probing);\n\t\t\t\t} else {\n\t\t\t\t\tDTLSSession resumableSession = new DTLSSession(sessionId, message.getInetSocketAddress(), ticket, 0);\n\t\t\t\t\tSecretUtil.destroy(ticket);\n\t\t\t\t\tresumableSession.setHostName(message.getEndpointContext().getVirtualHost());\n\t\t\t\t\tnewHandshaker = new ResumingClientHandshaker(resumableSession, this, timer, connection, config, probing);\n\t\t\t\t}\n\t\t\t\tinitializeHandshaker(newHandshaker);\n\t\t\t\tif (previousHandshaker != null) {\n\t\t\t\t\tnewHandshaker.takeDeferredApplicationData(previousHandshaker);\n\t\t\t\t\t// abort, keep connection\n\t\t\t\t\tpreviousHandshaker.handshakeAborted(new Exception(\"handshake replaced!\"));\n\t\t\t\t}\n\t\t\t\tnewHandshaker.addApplicationDataForDeferredProcessing(message);\n\t\t\t\tnewHandshaker.startHandshake();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// session with peer has already been established,\n\t\t// use it to send encrypted message\n\t\tsendMessage(message, connection, session);\n\t}\n\n\tprivate void sendMessage(final RawData message, final Connection connection, final DTLSSession session) {\n\t\ttry {\n\t\t\tLOGGER.trace(\"send {}-{} using {}-{}\", connection.getConnectionId(), connection.getPeerAddress(),\n\t\t\t\t\tsession.getSessionIdentifier(), session.getPeer());\n\t\t\tfinal EndpointContext ctx = session.getConnectionWriteContext();\n\t\t\tif (!checkOutboundEndpointContext(message, ctx)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.onContextEstablished(ctx);\n\t\t\tRecord record = new Record(\n\t\t\t\t\tContentType.APPLICATION_DATA,\n\t\t\t\t\tsession.getWriteEpoch(),\n\t\t\t\t\tsession.getSequenceNumber(),\n\t\t\t\t\tnew ApplicationMessage(message.getBytes(), message.getInetSocketAddress()),\n\t\t\t\t\tsession, true, TLS12_CID_PADDING);\n\t\t\tsendRecord(record);\n\t\t\tmessage.onSent();\n\t\t\tconnection.refreshAutoResumptionTime();\n\t\t} catch (IOException e) {\n\t\t\tmessage.onError(e);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.warn(\"Cannot send APPLICATION record to peer [{}]\", message.getInetSocketAddress(), e);\n\t\t\tmessage.onError(e);\n\t\t}\n\t}\n\n\t/**\n\t * Check, if the endpoint context match for outgoing messages using\n\t * {@link #endpointContextMatcher}.\n\t * \n\t * @param message message to be checked\n\t * @param connectionContext endpoint context of the connection. May be\n\t *            {@code null}, if not established.\n\t * @return {@code true}, if outgoing message matches, {@code false}, if not\n\t *         and should NOT be send.\n\t * @see EndpointContextMatcher#isToBeSent(EndpointContext, EndpointContext)\n\t */\n\tprivate boolean checkOutboundEndpointContext(final RawData message, final EndpointContext connectionContext) {\n\t\tfinal EndpointContextMatcher endpointMatcher = getEndpointContextMatcher();\n\t\tif (null != endpointMatcher && !endpointMatcher.isToBeSent(message.getEndpointContext(), connectionContext)) {\n\t\t\tif (DROP_LOGGER.isInfoEnabled()) {\n\t\t\t\tDROP_LOGGER.info(\"DTLSConnector ({}) drops {} bytes outgoing, {} != {}\", this, message.getSize(),\n\t\t\t\t\t\tendpointMatcher.toRelevantState(message.getEndpointContext()),\n\t\t\t\t\t\tendpointMatcher.toRelevantState(connectionContext));\n\t\t\t}\n\t\t\tmessage.onError(new EndpointMismatchException());\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(true);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the {@link DTLSSession} related to the given peer address.\n\t * \n\t * @param address the peer address\n\t * @return the {@link DTLSSession} or <code>null</code> if no session found.\n\t */\n\tpublic final DTLSSession getSessionByAddress(InetSocketAddress address) {\n\t\tif (address == null) {\n\t\t\treturn null;\n\t\t}\n\t\tConnection connection = connectionStore.get(address);\n\t\tif (connection != null) {\n\t\t\treturn connection.getEstablishedSession();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void dropReceivedRecord(Record record) {\n\t\tDROP_LOGGER.debug(\"Discarding {} record [epoch {}, rseqn {}] dropped by handshaker for peer [{}]\", record.getType(),\n\t\t\t\trecord.getEpoch(), record.getSequenceNumber(), record.getPeerAddress());\n\t\tif (health != null) {\n\t\t\thealth.receivingRecord(true);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getMaxDatagramSize(boolean ipv6) {\n\t\tint headerSize = ipv6 ? IPV6_HEADER_LENGTH : IPV4_HEADER_LENGTH;\n\t\tint mtu = maximumTransmissionUnit != null ? maximumTransmissionUnit : (ipv6 ? ipv6Mtu : ipv4Mtu);\n\t\tint size = mtu - headerSize;\n\t\tif (size < 64) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\tString.format(\"%s, datagram size %d, mtu %d\", ipv6 ? \"IPV6\" : \"IPv4\", size, mtu));\n\t\t}\n\t\treturn mtu - headerSize;\n\t}\n\n\t@NoPublicAPI\n\t@Override\n\tpublic void sendFlight(List<DatagramPacket> datagrams) throws IOException {\n\t\t// send it over the UDP socket\n\t\tfor (DatagramPacket datagramPacket : datagrams) {\n\t\t\tif (health != null) {\n\t\t\t\thealth.sendingRecord(false);\n\t\t\t}\n\t\t\tsendNextDatagramOverNetwork(datagramPacket);\n\t\t}\n\t}\n\n\tprotected void sendRecord(Record record) throws IOException {\n\t\tif (health != null && record.getType() != ContentType.APPLICATION_DATA) {\n\t\t\thealth.sendingRecord(false);\n\t\t}\n\t\tbyte[] recordBytes = record.toByteArray();\n\t\tDatagramPacket datagram = new DatagramPacket(recordBytes, recordBytes.length, record.getPeerAddress());\n\t\tsendNextDatagramOverNetwork(datagram);\n\t}\n\n\tprotected void sendNextDatagramOverNetwork(final DatagramPacket datagramPacket) throws IOException {\n\t\tDatagramSocket socket = getSocket();\n\t\tif (socket != null && !socket.isClosed()) {\n\t\t\tif (datagramPacket.getPort() == 0) {\n\t\t\t\tString destination = StringUtil.toString((InetSocketAddress) datagramPacket.getSocketAddress());\n\t\t\t\tDROP_LOGGER.trace(\"Discarding record with {} bytes to [{}] without destination-port\",\n\t\t\t\t\t\tdatagramPacket.getLength(), destination);\n\t\t\t\tif (health != null) {\n\t\t\t\t\thealth.sendingRecord(true);\n\t\t\t\t}\n\t\t\t\tthrow new IOException(\"DTLS Record to \" + destination + \" dropped, destination port 0!\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsocket.send(datagramPacket);\n\t\t\t\treturn;\n\t\t\t} catch (PortUnreachableException e) {\n\t\t\t\tif (!socket.isClosed()) {\n\t\t\t\t\tLOGGER.warn(\"Could not send record, destination {} unreachable!\",\n\t\t\t\t\t\t\tStringUtil.toString((InetSocketAddress) datagramPacket.getSocketAddress()));\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tif (!socket.isClosed()) {\n\t\t\t\t\tLOGGER.warn(\"Could not send record\", e);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInetSocketAddress address = lastBindAddress;\n\t\tif (address == null) {\n\t\t\taddress = config.getAddress();\n\t\t}\n\t\tDROP_LOGGER.debug(\"Socket [{}] is closed, discarding packet ...\", address);\n\t\tthrow new IOException(\"Socket closed.\");\n\t}\n\n\t/**\n\t * Process handshake result.\n\t * \n\t * @param handshakeResult asynchronous handshake result\n\t * @since 2.5\n\t */\n\tprivate void processAsynchronousHandshakeResult(final HandshakeResult handshakeResult) {\n\t\tfinal Connection connection = connectionStore.get(handshakeResult.getConnectionId());\n\t\tif (connection != null && connection.hasOngoingHandshake()) {\n\t\t\tSerialExecutor serialExecutor = connection.getExecutor();\n\n\t\t\ttry {\n\n\t\t\t\tserialExecutor.execute(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tif (running.get() && connection.isExecuting()) {\n\t\t\t\t\t\t\tHandshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\thandshaker.processAsyncHandshakeResult(handshakeResult);\n\t\t\t\t\t\t\t\t} catch (HandshakeException e) {\n\t\t\t\t\t\t\t\t\thandleExceptionDuringHandshake(e, connection, null);\n\t\t\t\t\t\t\t\t} catch (IllegalStateException e) {\n\t\t\t\t\t\t\t\t\tLOGGER.warn(\"Exception while processing handshake result [{}]\", connection, e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tLOGGER.debug(\"No ongoing handshake for result [{}]\", connection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGGER.debug(\"Execution stopped while processing handshake result [{}]\", connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\tLOGGER.debug(\"Execution rejected while processing handshake result [{}]\", connection, e);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing handshake result [{}]\", connection, e);\n\t\t\t}\n\t\t} else {\n\t\t\tLOGGER.debug(\"No connection or ongoing handshake for handshake result [{}]\", connection);\n\t\t}\n\t}\n\n\t/**\n\t * Get auto resumption timeout.\n\t * \n\t * Check, if {@link DtlsEndpointContext#KEY_RESUMPTION_TIMEOUT} is provided,\n\t * or use {@link #autoResumptionTimeoutMillis} as default.\n\t * \n\t * @param message message to check for auto resumption timeout.\n\t * @return resulting timeout in milliseconds. {@code null} for no auto\n\t *         resumption.\n\t * @since 2.1\n\t */\n\tprivate Long getAutResumptionTimeout(RawData message) {\n\t\tLong timeout = autoResumptionTimeoutMillis;\n\t\tString contextTimeout = message.getEndpointContext().get(DtlsEndpointContext.KEY_RESUMPTION_TIMEOUT);\n\t\tif (contextTimeout != null) {\n\t\t\tif (contextTimeout.isEmpty()) {\n\t\t\t\ttimeout = null;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\ttimeout = Long.valueOf(contextTimeout);\n\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn timeout;\n\t}\n\n\t/**\n\t * Gets the MTU value of the network interface this connector is bound to.\n\t * <p>\n\t * Applications may use this property to determine the maximum length of application\n\t * layer data that can be sent using this connector without requiring IP fragmentation.\n\t * <p> \n\t * The value returned will be 0 if this connector is not running or the network interface\n\t * this connector is bound to does not provide an MTU value.\n\t * \n\t * @return the MTU provided by the network interface\n\t * @deprecated use {@link #getMaxDatagramSize(boolean)} instead\n\t */\n\t@Deprecated\n\tpublic final int getMaximumTransmissionUnit() {\n\t\treturn maximumTransmissionUnit;\n\t}\n\n\t/**\n\t * Gets the maximum amount of unencrypted payload data that can be sent to a given\n\t * peer in a single DTLS record.\n\t * <p>\n\t * The value of this property serves as an upper boundary for the <em>DTLSPlaintext.length</em>\n\t * field defined in <a href=\"http://tools.ietf.org/html/rfc6347#section-4.3.1\">DTLS 1.2 spec,\n\t * Section 4.3.1</a>. This means that an application can assume that any message containing at\n\t * most as many bytes as indicated by this method, will be delivered to the peer in a single\n\t * unfragmented datagram.\n\t * </p>\n\t * <p>\n\t * The value returned by this method considers the <em>current write state</em> of the connection\n\t * to the peer and any potential ciphertext expansion introduced by this cipher suite used to\n\t * secure the connection. However, if no connection exists to the peer, the value returned is\n\t * determined as follows:\n\t * </p>\n\t * <pre>\n\t *   maxFragmentLength = network interface's <em>Maximum Transmission Unit</em>\n\t *                     - IP header length (20 bytes IPv4, 120 IPv6)\n\t *                     - UDP header length (8 bytes)\n\t *                     - DTLS record header length (13 bytes)\n\t *                     - DTLS message header length (12 bytes)\n\t * </pre>\n\t * \n\t * @param peer the address of the remote endpoint\n\t * \n\t * @return the maximum length in bytes\n\t */\n\tpublic final int getMaximumFragmentLength(InetSocketAddress peer) {\n\t\tConnection con = connectionStore.get(peer);\n\t\tif (con != null && con.hasEstablishedSession()) {\n\t\t\treturn con.getEstablishedSession().getMaxFragmentLength();\n\t\t} else {\n\t\t\treturn getMaxDatagramSize(peer.getAddress() instanceof Inet6Address) - DTLSSession.DTLS_HEADER_LENGTH;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the address this connector is bound to.\n\t * \n\t * @return the IP address and port this connector is bound to or configured to\n\t *            bind to\n\t */\n\t@Override\n\tpublic final InetSocketAddress getAddress() {\n\t\tDatagramSocket socket = getSocket();\n\t\tint localPort = socket == null ? -1 : socket.getLocalPort();\n\t\tif (localPort < 0) {\n\t\t\treturn config.getAddress();\n\t\t} else {\n\t\t\treturn new InetSocketAddress(socket.getLocalAddress(), localPort);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if this connector is running.\n\t * \n\t * @return {@code true} if running.\n\t */\n\t@Override\n\tpublic final boolean isRunning() {\n\t\treturn running.get();\n\t}\n\n\t/**\n\t * A worker thread for continuously doing repetitive tasks.\n\t */\n\tprotected abstract class Worker extends Thread {\n\t\t/**\n\t\t * Instantiates a new worker.\n\t\t *\n\t\t * @param name the name, e.g., of the transport protocol\n\t\t */\n\t\tprotected Worker(String name) {\n\t\t\tsuper(NamedThreadFactory.SCANDIUM_THREAD_GROUP, name);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tLOGGER.info(\"Starting worker thread [{}]\", getName());\n\t\t\t\twhile (running.get()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdoWork();\n\t\t\t\t\t} catch (InterruptedIOException e) {\n\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\tLOGGER.info(\"Worker thread [{}] IO has been interrupted\", getName());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGGER.debug(\"Worker thread [{}] IO has been interrupted\", getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\tLOGGER.info(\"Worker thread [{}] has been interrupted\", getName());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGGER.debug(\"Worker thread [{}] has been interrupted\", getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\tLOGGER.debug(\"Exception thrown by worker thread [{}]\", getName(), e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGGER.trace(\"Exception thrown by worker thread [{}]\", getName(), e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tLOGGER.info(\"Worker thread [{}] has terminated\", getName());\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Does the actual work.\n\t\t * \n\t\t * Subclasses should do the repetitive work here.\n\t\t * \n\t\t * @throws Exception if something goes wrong\n\t\t */\n\t\tprotected abstract void doWork() throws Exception;\n\t}\n\n\t/**\n\t * Future implementation for tasks passed in to the serial executors for each\n\t * connection.\n\t */\n\tprivate static class ForEachFuture implements Future<Void> {\n\n\t\tprivate final Lock lock = new ReentrantLock();\n\t\tprivate final Condition waitDone = lock.newCondition();\n\t\tprivate volatile boolean cancel;\n\t\tprivate volatile boolean done;\n\t\tprivate volatile Exception exception;\n\n\t\t/**\n\t\t * {@inheritDoc}\n\t\t * \n\t\t * Cancel iteration for each connection.\n\t\t * \n\t\t * Note: if a connection serial execution busy executing a different\n\t\t * blocking task, cancel will not interrupt that task!\n\t\t */\n\t\t@Override\n\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\tboolean cancelled = false;\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tif (!done && !cancel) {\n\t\t\t\t\tcancelled = true;\n\t\t\t\t\tcancel = true;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t\treturn cancelled;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCancelled() {\n\t\t\treturn cancel;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDone() {\n\t\t\treturn done;\n\t\t}\n\n\t\t@Override\n\t\tpublic Void get() throws InterruptedException, ExecutionException {\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tif (!done) {\n\t\t\t\t\twaitDone.await();\n\t\t\t\t}\n\t\t\t\tif (exception != null) {\n\t\t\t\t\tthrow new ExecutionException(exception);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tif (!done) {\n\t\t\t\t\twaitDone.await(timeout, unit);\n\t\t\t\t}\n\t\t\t\tif (exception != null) {\n\t\t\t\t\tthrow new ExecutionException(exception);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t/**\n\t\t * Signals, that the task has completed.\n\t\t */\n\t\tpublic void done() {\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tdone = true;\n\t\t\t\twaitDone.signalAll();\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\n\t\tpublic void failed(Exception exception) {\n\t\t\tlock.lock();\n\t\t\ttry {\n\t\t\t\tthis.exception = exception;\n\t\t\t\tdone = true;\n\t\t\t\twaitDone.signalAll();\n\t\t\t} finally {\n\t\t\t\tlock.unlock();\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isStopped() {\n\t\t\treturn done || cancel;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setRawDataReceiver(final RawDataChannel messageHandler) {\n\t\tif (isRunning()) {\n\t\t\tthrow new IllegalStateException(\"message handler cannot be set on running connector\");\n\t\t}\n\t\tthis.messageHandler = messageHandler;\n\t}\n\n\t@Override\n\tpublic void setEndpointContextMatcher(EndpointContextMatcher endpointContextMatcher) {\n\t\tthis.endpointContextMatcher = endpointContextMatcher;\n\t}\n\n\tprivate EndpointContextMatcher getEndpointContextMatcher() {\n\t\treturn endpointContextMatcher;\n\t}\n\n\t/**\n\t * Get effective handshake mode.\n\t * \n\t * Either the handshake mode provided in the message's endpoint-context, see\n\t * {@link DtlsEndpointContext#KEY_HANDSHAKE_MODE}, or, if that is not\n\t * available, the default from the configuration\n\t * {@link DtlsConnectorConfig#getDefaultHandshakeMode()}.\n\t * \n\t * @param message message to be sent\n\t * @return effective handshake mode.\n\t * @since 2.1\n\t */\n\tprivate String getEffectiveHandshakeMode(RawData message) {\n\t\tString mode = message.getEndpointContext().get(DtlsEndpointContext.KEY_HANDSHAKE_MODE);\n\t\tif (mode == null) {\n\t\t\tmode = defaultHandshakeMode;\n\t\t}\n\t\treturn mode;\n\t}\n\t\n\t/**\n\t * Sets a handler to call back if an alert message is received from a peer.\n\t * <p>\n\t * Setting a handler using this method is useful to be notified when a peer closes\n\t * an existing connection, i.e. when the alert message has not been received during\n\t * a handshake but after the connection has been established.\n\t * <p>\n\t * The handler can be set (and changed) at any time, either before the connector has\n\t * been started or when the connector is already running.\n\t * <p>\n\t * Application code interested in being notified when a particular message cannot be sent,\n\t * e.g. due to a failing DTLS handshake that has been triggered as part of sending\n\t * the message, should instead register a\n\t * {@code org.eclipse.californium.core.coap.MessageObserver} on the message and\n\t * implement its <em>onSendError</em> method accordingly.\n\t * \n\t * @param handler The handler to notify.\n\t */\n\tpublic final void setAlertHandler(AlertHandler handler) {\n\t\tsynchronized (alertHandlerLock) {\n\t\t\tthis.alertHandler = handler;\n\t\t}\n\t}\n\n\t/**\n\t * Handle a exception occurring during the handshake.\n\t * \n\t * @param cause exception\n\t * @param level alert level\n\t * @param description alert description\n\t * @param connection connection\n\t * @param record related received record. Since 2.3, this may be\n\t *            {@code null} in order to support exception during processing\n\t *            of a asynchronous master secret result.\n\t */\n\tprivate void handleExceptionDuringHandshake(HandshakeException cause, Connection connection, Record record) {\n\t\tAlertMessage alert = cause.getAlert();\n\t\t// discard none fatal alert exception\n\t\tif (!AlertLevel.FATAL.equals(alert.getLevel())) {\n\t\t\tif (record != null) {\n\t\t\t\tdiscardRecord(record, cause);\n\t\t\t}\n\t\t\thandleAlertInternal(alert.getPeer(), alert, connection);\n\t\t\treturn;\n\t\t}\n\n\t\t// \"Unknown identity\" and \"bad PSK\" should be both handled in a same way.\n\t\t// Generally \"bad PSK\" means invalid MAC on FINISHED message.\n\t\t// In production both should be silently ignored : https://bugs.eclipse.org/bugs/show_bug.cgi?id=533258\n\t\tif (AlertDescription.UNKNOWN_PSK_IDENTITY.equals(alert.getDescription())) {\n\t\t\tif (record != null) {\n\t\t\t\tdiscardRecord(record, cause);\n\t\t\t}\n\t\t\thandleAlertInternal(alert.getPeer(), alert, connection);\n\t\t\treturn;\n\t\t}\n\n\t\t// in other cases terminate handshake\n\t\tterminateOngoingHandshake(connection, cause);\n\t}\n\n\t/**\n\t * Handle alert internally.\n\t * \n\t * Keeps first reported alert as root cause and reports that to the\n\t * {@link AlertHandler}, if available.\n\t * \n\t * @param peer pper's address\n\t * @param alert received alert or detected alert\n\t * @param connection connection affected by that alert\n\t * @since 2.5\n\t */\n\tprivate void handleAlertInternal(InetSocketAddress peer, AlertMessage alert, Connection connection) {\n\t\tif (connection.getRootCauseAlert() == null) {\n\t\t\tconnection.setRootCause(alert);\n\t\t\tAlertHandler handler;\n\t\t\tsynchronized (alertHandlerLock) {\n\t\t\t\thandler = alertHandler;\n\t\t\t}\n\t\t\tif (handler != null) {\n\t\t\t\thandler.onAlert(peer, alert);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void discardRecord(final Record record, final Throwable cause) {\n\t\tif (health != null) {\n\t\t\thealth.receivingRecord(true);\n\t\t}\n\t\tbyte[] bytes = record.getFragmentBytes();\n\t\tif (DROP_LOGGER.isTraceEnabled()) {\n\t\t\tString hexString = StringUtil.byteArray2HexString(bytes, StringUtil.NO_SEPARATOR, 64);\n\t\t\tDROP_LOGGER.trace(\"Discarding received {} record (epoch {}, payload: {}) from peer [{}]: \", record.getType(),\n\t\t\t\t\trecord.getEpoch(), hexString, record.getPeerAddress(), cause);\n\t\t} else if (DROP_LOGGER.isDebugEnabled()) {\n\t\t\tString hexString = StringUtil.byteArray2HexString(bytes, StringUtil.NO_SEPARATOR, 16);\n\t\t\tDROP_LOGGER.debug(\"Discarding received {} record (epoch {}, payload: {}) from peer [{}]: {}\", record.getType(),\n\t\t\t\t\trecord.getEpoch(), hexString, record.getPeerAddress(), cause.getMessage());\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getProtocol() {\n\t\treturn \"DTLS\";\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getProtocol() + \"-\" + StringUtil.toString(getAddress());\n\t}\n\t\n}\n", "/*******************************************************************************\n * Copyright (c) 2015, 2017 Bosch Software Innovations GmbH and others.\n * \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n * \n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v20.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n * \n * Contributors:\n *    Kai Hudalla (Bosch Software Innovations GmbH) - Initial creation\n *    Achim Kraus (Bosch Software Innovations GmbH) - add empty implementation\n *                                                    for handshakeFailed.\n *    Achim Kraus (Bosch Software Innovations GmbH) - use final for collections\n *    Bosch Software Innovations GmbH - migrate to SLF4J\n *    Achim Kraus (Bosch Software Innovations GmbH) - configure LRU to return\n *                                                    expired entries on read access.\n *                                                    See issue #707\n *    Achim Kraus (Bosch Software Innovations GmbH) - configure LRU to update\n *                                                    connection only, if access\n *                                                    is validated with the MAC\n *    Achim Kraus (Bosch Software Innovations GmbH) - fix session resumption with\n *                                                    session cache. issue #712\n *    Achim Kraus (Bosch Software Innovations GmbH) - add more logging\n *    Achim Kraus (Bosch Software Innovations GmbH) - restore connection from\n *                                                    client session cache,\n *                                                    when provided.\n *    Achim Kraus (Bosch Software Innovations GmbH) - add putEstablishedSession\n *                                                    and removeFromEstablishedSessions\n *                                                    for faster find\n ******************************************************************************/\npackage org.eclipse.californium.scandium.dtls;\n\nimport java.net.InetSocketAddress;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.eclipse.californium.elements.util.LeastRecentlyUsedCache;\nimport org.eclipse.californium.elements.util.SerialExecutor;\nimport org.eclipse.californium.elements.util.StringUtil;\nimport org.eclipse.californium.scandium.ConnectionListener;\nimport org.eclipse.californium.scandium.util.SecretUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An in-memory <code>ResumptionSupportingConnectionStore</code> with a\n * configurable maximum capacity and support for evicting stale connections\n * based on a <em>least recently used</em> policy.\n * <p>\n * The store keeps track of the connections' last-access time automatically.\n * Every time a connection is read from or put to the store the access-time is\n * updated.\n * </p>\n * <p>\n * A connection can be successfully added to the store if any of the following\n * conditions is met:\n * </p>\n * <ul>\n * <li>The store's remaining capacity is greater than zero.</li>\n * <li>The store contains at least one <em>stale</em> connection, i.e. a\n * connection that has not been accessed for at least the store's <em>\n * connection expiration threshold</em> period. In such a case the least\n * recently accessed stale connection gets evicted from the store to make place\n * for the new connection to be added.</li>\n * </ul>\n * <p>\n * This implementation uses three <code>java.util.HashMap</code>. One with a\n * connection's id as key as its backing store, one with the peer address as\n * key, and one with the session id as key. In addition to that the store keeps\n * a doubly-linked list of the connections in access-time order.\n * </p>\n * <p>\n * Insertion, lookup and removal of connections is done in <em>O(log n)</em>.\n * </p>\n * <p>\n * Storing and reading to/from the store is thread safe.\n * </p>\n * <p>\n * Supports also a {@link SessionCache} implementation to keep sessions for\n * longer or in a distribute system. If this store evicts a connection in order\n * to gain storage for new connections, the associated session remains in the\n * cache. Therefore the cache requires a own, independent cleanup for stale\n * sessions. If a connection is removed by a critical ALERT, the session get's\n * removed also from the cache.\n * </p>\n */\n@SuppressWarnings(\"deprecation\")\npublic class InMemoryConnectionStore implements ResumptionSupportingConnectionStore, CloseSupportingConnectionStore {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(InMemoryConnectionStore.class);\n\tprivate static final int DEFAULT_SMALL_EXTRA_CID_LENGTH = 2; // extra cid bytes additionally to required bytes for small capacity.\n\tprivate static final int DEFAULT_LARGE_EXTRA_CID_LENGTH = 3; // extra cid bytes additionally to required bytes for large capacity.\n\tprivate static final int DEFAULT_CACHE_SIZE = 150000;\n\tprivate static final long DEFAULT_EXPIRATION_THRESHOLD = 36 * 60 * 60; // 36h\n\tprivate final SessionCache sessionCache;\n\tprotected final LeastRecentlyUsedCache<ConnectionId, Connection> connections;\n\tprotected final ConcurrentMap<InetSocketAddress, Connection> connectionsByAddress;\n\tprotected final ConcurrentMap<SessionId, Connection> connectionsByEstablishedSession;\n\n\tprivate ConnectionListener connectionListener;\n\t/**\n\t * Connection id generator.\n\t * \n\t * @see #attach(ConnectionIdGenerator)\n\t */\n\tprivate ConnectionIdGenerator connectionIdGenerator;\n\n\tprotected String tag = \"\";\n\n\t/**\n\t * Creates a store with a capacity of 500000 connections and\n\t * a connection expiration threshold of 36 hours.\n\t */\n\tpublic InMemoryConnectionStore() {\n\t\tthis(DEFAULT_CACHE_SIZE, DEFAULT_EXPIRATION_THRESHOLD, null);\n\t}\n\n\t/**\n\t * Creates a store with a capacity of 500000 connections and a connection\n\t * expiration threshold of 36 hours.\n\t * \n\t * @param sessionCache a second level cache to use for <em>current</em>\n\t *            connection state of established DTLS sessions.\n\t */\n\tpublic InMemoryConnectionStore(final SessionCache sessionCache) {\n\t\tthis(DEFAULT_CACHE_SIZE, DEFAULT_EXPIRATION_THRESHOLD, sessionCache);\n\t}\n\n\t/**\n\t * Creates a store based on given configuration parameters.\n\t * \n\t * @param capacity the maximum number of connections the store can manage\n\t * @param threshold the period of time of inactivity (in seconds) after which a\n\t *            connection is considered stale and can be evicted from the store if\n\t *            a new connection is to be added to the store\n\t */\n\tpublic InMemoryConnectionStore(final int capacity, final long threshold) {\n\t\tthis(capacity, threshold, null);\n\t}\n\n\t/**\n\t * Creates a store based on given configuration parameters.\n\t * \n\t * @param capacity the maximum number of connections the store can manage\n\t * @param threshold the period of time of inactivity (in seconds) after\n\t *            which a connection is considered stale and can be evicted from\n\t *            the store if a new connection is to be added to the store\n\t * @param sessionCache a second level cache to use for <em>current</em>\n\t *            connection state of established DTLS sessions. If implements\n\t *            {@link ClientSessionCache}, restore connection from the cache\n\t *            and mark them to resume.\n\t */\n\tpublic InMemoryConnectionStore(int capacity, long threshold, SessionCache sessionCache) {\n\t\tthis.connections = new LeastRecentlyUsedCache<>(capacity, threshold);\n\t\tthis.connections.setEvictingOnReadAccess(false);\n\t\tthis.connections.setUpdatingOnReadAccess(false);\n\t\tthis.connectionsByEstablishedSession = new ConcurrentHashMap<>();\n\t\tthis.connectionsByAddress = new ConcurrentHashMap<>();\n\t\tthis.sessionCache = sessionCache;\n\n\t\t// make sure that session state for stale (evicted) connections is removed from second level cache\n\t\tconnections.addEvictionListener(new LeastRecentlyUsedCache.EvictionListener<Connection>() {\n\n\t\t\t@Override\n\t\t\tpublic void onEviction(final Connection staleConnection) {\n\t\t\t\tRunnable remove = new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tHandshaker handshaker = staleConnection.getOngoingHandshake();\n\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\thandshaker.handshakeFailed(new ConnectionEvictedException(\"Evicted!\", staleConnection.getPeerAddress()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsynchronized (InMemoryConnectionStore.this) {\n\t\t\t\t\t\t\tremoveFromAddressConnections(staleConnection);\n\t\t\t\t\t\t\tremoveFromEstablishedSessions(staleConnection);\n\t\t\t\t\t\t\tConnectionListener listener = connectionListener;\n\t\t\t\t\t\t\tif (listener != null) {\n\t\t\t\t\t\t\t\tlistener.onConnectionRemoved(staleConnection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (staleConnection.isExecuting()) {\n\t\t\t\t\tstaleConnection.getExecutor().execute(remove);\n\t\t\t\t} else {\n\t\t\t\t\tremove.run();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tLOG.info(\"Created new InMemoryConnectionStore [capacity: {}, connection expiration threshold: {}s]\",\n\t\t\t\tcapacity, threshold);\n\t}\n\n\t/**\n\t * Set tag for logging outputs.\n\t * \n\t * @param tag tag for logging\n\t * @return this connection store for calls chaining\n\t */\n\tpublic synchronized InMemoryConnectionStore setTag(final String tag) {\n\t\tthis.tag = StringUtil.normalizeLoggingTag(tag);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a new unused connection id.\n\t * \n\t * @return connection id, or {@code null}, if no free connection id could\n\t *         created\n\t * @see #connectionIdGenerator\n\t * @see ConnectionIdGenerator\n\t */\n\tprivate ConnectionId newConnectionId() {\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\tConnectionId cid = connectionIdGenerator.createConnectionId();\n\t\t\tif (connections.get(cid) == null) {\n\t\t\t\treturn cid;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setConnectionListener(ConnectionListener listener) {\n\t\tthis.connectionListener = listener;\n\t}\n\n\t@Override\n\tpublic void attach(ConnectionIdGenerator connectionIdGenerator) {\n\t\tif (this.connectionIdGenerator != null) {\n\t\t\tthrow new IllegalStateException(\"Connection id generator already attached!\");\n\t\t}\n\t\tif (connectionIdGenerator == null || !connectionIdGenerator.useConnectionId()) {\n\t\t\tint bits = Integer.SIZE - Integer.numberOfLeadingZeros(connections.getCapacity());\n\t\t\tint cidLength = ((bits + 7) / 8); // required bytes for capacity\n\t\t\tcidLength += (cidLength < 3) ? DEFAULT_SMALL_EXTRA_CID_LENGTH : DEFAULT_LARGE_EXTRA_CID_LENGTH;\n\t\t\tthis.connectionIdGenerator = new SingleNodeConnectionIdGenerator(cidLength);\n\t\t} else {\n\t\t\tthis.connectionIdGenerator = connectionIdGenerator;\n\t\t}\n\t\tif (sessionCache instanceof ClientSessionCache) {\n\t\t\tClientSessionCache clientCache = (ClientSessionCache) sessionCache;\n\t\t\tLOG.debug(\"resume client sessions {}\", clientCache);\n\t\t\tfor (InetSocketAddress peer : clientCache) {\n\t\t\t\tSessionTicket ticket = clientCache.getSessionTicket(peer);\n\t\t\t\tSessionId id = clientCache.getSessionIdentity(peer);\n\t\t\t\tif (ticket != null && id != null) {\n\t\t\t\t\t// restore connection from session ticket\n\t\t\t\t\tConnection connection = new Connection(ticket, id, peer);\n\t\t\t\t\tConnectionId connectionId = newConnectionId();\n\t\t\t\t\tif (connectionId != null) {\n\t\t\t\t\t\tconnection.setConnectionId(connectionId);\n\t\t\t\t\t\tconnections.put(connectionId, connection);\n\t\t\t\t\t\tconnectionsByAddress.put(peer, connection);\n\t\t\t\t\t\tLOG.debug(\"{}resume {} {}\", tag, peer, id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.info(\"{}drop session {} {}, could not allocated cid!\", tag, peer, id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\n\t/**\n\t * {@inheritDoc}\n\t * <p>\n\t * A connection can be successfully added to the store if any of the\n\t * following conditions is met:\n\t * <ul>\n\t * <li>The store's remaining capacity is greater than zero.</li>\n\t * <li>The store contains at least one <em>stale</em> connection, i.e. a\n\t * connection that has not been accessed for at least the store's <em>\n\t * connection expiration threshold</em> period. In such a case the least-\n\t * recently accessed stale connection gets evicted from the store to make\n\t * place for the new connection to be added.</li>\n\t * </ul>\n\t */\n\t@Override\n\tpublic synchronized boolean put(final Connection connection) {\n\n\t\tif (connection != null) {\n\t\t\tif (!connection.isExecuting()) {\n\t\t\t\tthrow new IllegalStateException(\"Connection is not executing!\");\n\t\t\t}\n\t\t\tConnectionId connectionId = connection.getConnectionId();\n\t\t\tif (connectionId == null) {\n\t\t\t\tif (connectionIdGenerator == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Connection id generator must be attached before!\");\n\t\t\t\t}\n\t\t\t\tconnectionId = newConnectionId();\n\t\t\t\tif (connectionId == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Connection ids exhausted!\");\n\t\t\t\t}\n\t\t\t\tconnection.setConnectionId(connectionId);\n\t\t\t} else if (connectionId.isEmpty()) {\n\t\t\t\tthrow new IllegalStateException(\"Connection must have a none empty connection id!\");\n\t\t\t} else if (connections.get(connectionId) != null) {\n\t\t\t\tthrow new IllegalStateException(\"Connection id already used! \" + connectionId);\n\t\t\t}\n\t\t\tif (connections.put(connectionId, connection)) {\n\t\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\t\tLOG.trace(\"{}connection: add {} (size {})\", tag, connection, connections.size(), new Throwable(\"connection added!\"));\n\t\t\t\t} else {\n\t\t\t\t\tLOG.debug(\"{}connection: add {} (size {})\", tag, connectionId, connections.size());\n\t\t\t\t}\n\t\t\t\taddToAddressConnections(connection);\n\t\t\t\tDTLSSession session = connection.getEstablishedSession();\n\t\t\t\tif (session != null) {\n\t\t\t\t\tputEstablishedSession(session, connection);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tLOG.warn(\"{}connection store is full! {} max. entries.\", tag, connections.getCapacity());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic synchronized boolean update(final Connection connection, InetSocketAddress newPeerAddress) {\n\t\tif (connection == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (connections.update(connection.getConnectionId())) {\n\t\t\tif (newPeerAddress == null) {\n\t\t\t\tLOG.debug(\"{}connection: {} updated usage!\", tag, connection.getConnectionId());\n\t\t\t} else if (!connection.equalsPeerAddress(newPeerAddress)) {\n\t\t\t\tInetSocketAddress oldPeerAddress = connection.getPeerAddress();\n\t\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\t\tLOG.trace(\"{}connection: {} updated, address changed from {} to {}!\", tag,\n\t\t\t\t\t\t\tconnection.getConnectionId(), oldPeerAddress, newPeerAddress,\n\t\t\t\t\t\t\tnew Throwable(\"connection updated!\"));\n\t\t\t\t} else {\n\t\t\t\t\tLOG.debug(\"{}connection: {} updated, address changed from {} to {}!\", tag,\n\t\t\t\t\t\t\tconnection.getConnectionId(), oldPeerAddress, newPeerAddress);\n\t\t\t\t}\n\t\t\t\tif (oldPeerAddress != null) {\n\t\t\t\t\tconnectionsByAddress.remove(oldPeerAddress, connection);\n\t\t\t\t\tconnection.updatePeerAddress(null);\n\t\t\t\t}\n\t\t\t\tconnection.updatePeerAddress(newPeerAddress);\n\t\t\t\taddToAddressConnections(connection);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tLOG.debug(\"{}connection: {} - {} update failed!\", tag, connection.getConnectionId(), newPeerAddress);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * \n\t * @deprecated since 2.3 obsolete, see {@link Connection#close(Record)}.\n\t */\n\t@Deprecated\n\t@Override\n\tpublic synchronized boolean removeFromAddress(final Connection connection) {\n\t\tif (connection != null) {\n\t\t\tInetSocketAddress peerAddress = connection.getPeerAddress();\n\t\t\tif (peerAddress != null) {\n\t\t\t\tLOG.debug(\"{}connection: {} removed from address {}!\", tag, connection.getConnectionId(), peerAddress);\n\t\t\t\tconnectionsByAddress.remove(peerAddress, connection);\n\t\t\t\tconnection.updatePeerAddress(null);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic synchronized void putEstablishedSession(final DTLSSession session, final Connection connection) {\n\t\tConnectionListener listener = connectionListener;\n\t\tif (listener != null) {\n\t\t\tlistener.onConnectionEstablished(connection);\n\t\t}\n\t\tSessionId sessionId = session.getSessionIdentifier();\n\t\tif (!sessionId.isEmpty()) {\n\t\t\tif (sessionCache != null) {\n\t\t\t\tsessionCache.put(session);\n\t\t\t}\n\t\t\tfinal Connection previous = connectionsByEstablishedSession.put(sessionId, connection);\n\t\t\tif (previous != null && previous != connection) {\n\t\t\t\tRunnable removePreviousConnection = new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tremove(previous, false);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (previous.isExecuting()) {\n\t\t\t\t\tprevious.getExecutor().execute(removePreviousConnection);\n\t\t\t\t} else {\n\t\t\t\t\tremovePreviousConnection.run();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic synchronized void removeFromEstablishedSessions(final DTLSSession session, final Connection connection) {\n\t\tSessionId sessionId = session.getSessionIdentifier();\n\t\tif (!sessionId.isEmpty()) {\n\t\t\tconnectionsByEstablishedSession.remove(sessionId, connection);\n\t\t}\n\t}\n\n\t@Override\n\tpublic synchronized Connection find(final SessionId id) {\n\n\t\tif (id == null || id.isEmpty()) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tConnection conFromLocalCache = findLocally(id);\n\n\t\t\tif (sessionCache == null) {\n\n\t\t\t\treturn conFromLocalCache;\n\n\t\t\t} else {\n\n\t\t\t\t// make sure a stale session cannot be resumed\n\t\t\t\tSessionTicket ticket = sessionCache.get(id);\n\t\t\t\tif (ticket == null) {\n\t\t\t\t\t// either a session with the given ID has never been established (on other nodes)\n\t\t\t\t\t// or another node has removed the session from the cache, e.g. because it became\n\t\t\t\t\t// stale\n\n\t\t\t\t\tif (conFromLocalCache != null) {\n\t\t\t\t\t\t// remove corresponding connection from this store\n\t\t\t\t\t\tremove(conFromLocalCache, false);\n\t\t\t\t\t\t// TODO: should we send a fatal alert to peer in this case?\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t} else if (conFromLocalCache == null) {\n\t\t\t\t\t// this probably means that we are taking over the session from a failed node\n\t\t\t\t\treturn new Connection(ticket, id, null);\n\t\t\t\t\t// connection will be put to first level cache as part of\n\t\t\t\t\t// the abbreviated handshake\n\t\t\t\t} else {\n\t\t\t\t\t// resume connection found in local cache (i.e. this store)\n\t\t\t\t\treturn conFromLocalCache;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate synchronized Connection findLocally(final SessionId id) {\n\t\tConnection connection = connectionsByEstablishedSession.get(id);\n\t\tif (connection != null) {\n\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\tif (establishedSession != null) {\n\t\t\t\tif (!establishedSession.getSessionIdentifier().equals(id)) {\n\t\t\t\t\tLOG.warn(\"{}connection {} changed session {}!={}!\", tag, connection.getConnectionId(), id,\n\t\t\t\t\t\t\testablishedSession.getSessionIdentifier());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG.warn(\"{}connection {} lost session {}!\", tag, connection.getConnectionId(), id);\n\t\t\t}\n\t\t\tconnections.update(connection.getConnectionId());\n\t\t}\n\t\treturn connection;\n\t}\n\n\t@Override\n\tpublic synchronized void markAllAsResumptionRequired() {\n\t\tfor (Connection connection : connections.values()) {\n\t\t\tif (connection.getPeerAddress() != null && !connection.isResumptionRequired()) {\n\t\t\t\tconnection.setResumptionRequired(true);\n\t\t\t\tLOG.debug(\"{}connection: mark for resumption {}!\", tag, connection);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic synchronized int remainingCapacity() {\n\t\tint remaining = connections.remainingCapacity();\n\t\tLOG.debug(\"{}connection: size {}, remaining {}!\", tag, connections.size(), remaining);\n\t\treturn remaining;\n\t}\n\n\t@Override\n\tpublic synchronized Connection get(final InetSocketAddress peerAddress) {\n\t\tConnection connection = connectionsByAddress.get(peerAddress);\n\t\tif (connection == null) {\n\t\t\tLOG.debug(\"{}connection: missing connection for {}!\", tag, peerAddress);\n\t\t} else {\n\t\t\tInetSocketAddress address = connection.getPeerAddress();\n\t\t\tif (address == null) {\n\t\t\t\tLOG.warn(\"{}connection {} lost ip-address {}!\", tag, connection.getConnectionId(), peerAddress);\n\t\t\t} else if (!address.equals(peerAddress)) {\n\t\t\t\tLOG.warn(\"{}connection {} changed ip-address {}!={}!\", tag, connection.getConnectionId(), peerAddress, address);\n\t\t\t}\n\t\t}\n\t\treturn connection;\n\t}\n\n\t@Override\n\tpublic synchronized Connection get(final ConnectionId cid) {\n\t\tConnection connection = connections.get(cid);\n\t\tif (connection == null) {\n\t\t\tLOG.debug(\"{}connection: missing connection for {}!\", tag, cid);\n\t\t} else {\n\t\t\tConnectionId connectionId = connection.getConnectionId();\n\t\t\tif (connectionId == null) {\n\t\t\t\tLOG.warn(\"{}connection lost cid {}!\", tag,  cid);\n\t\t\t} else if (!connectionId.equals(cid)) {\n\t\t\t\tLOG.warn(\"{}connection changed cid {}!={}!\", tag, connectionId, cid);\n\t\t\t}\n\t\t}\n\t\treturn connection;\n\t}\n\n\t@Override\n\tpublic boolean remove(final Connection connection) {\n\t\treturn remove(connection, true);\n\t}\n\n\t@Override\n\tpublic synchronized boolean remove(final Connection connection, final boolean removeFromSessionCache) {\n\t\tboolean removed = connections.remove(connection.getConnectionId(), connection) == connection;\n\t\tif (removed) {\n\t\t\tint pending = 0;\n\t\t\tSerialExecutor executor = connection.getExecutor();\n\t\t\tif (executor != null) {\n\t\t\t\tList<Runnable> pendings = connection.getExecutor().shutdownNow();\n\t\t\t\tfor (Runnable job : pendings) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjob.run();\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tLOG.warn(\"Removing connection:\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpending = pendings.size();\n\t\t\t}\n\t\t\tif (LOG.isTraceEnabled()) {\n\t\t\t\tLOG.trace(\"{}connection: remove {} (size {}, left jobs: {})\", tag, connection, connections.size(),\n\t\t\t\t\t\tpending, new Throwable(\"connection removed!\"));\n\t\t\t} else if (pending == 0) {\n\t\t\t\tLOG.debug(\"{}connection: remove {} (size {})\", tag, connection, connections.size());\n\t\t\t} else {\n\t\t\t\tLOG.debug(\"{}connection: remove {} (size {}, left jobs: {})\", tag, connection, connections.size(),\n\t\t\t\t\t\tpending);\n\t\t\t}\n\t\t\tremoveFromEstablishedSessions(connection);\n\t\t\tremoveFromAddressConnections(connection);\n\t\t\tif (removeFromSessionCache) {\n\t\t\t\tremoveSessionFromCache(connection);\n\t\t\t}\n\t\t\tConnectionListener listener = connectionListener;\n\t\t\tif (listener != null) {\n\t\t\t\tlistener.onConnectionRemoved(connection);\n\t\t\t}\n\t\t}\n\t\treturn removed;\n\t}\n\n\tprivate void removeFromEstablishedSessions(Connection connection) {\n\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\tif (establishedSession != null) {\n\t\t\tSessionId sessionId = establishedSession.getSessionIdentifier();\n\t\t\tconnectionsByEstablishedSession.remove(sessionId, connection);\n\t\t\tSecretUtil.destroy(establishedSession);\n\t\t}\n\t}\n\n\tprivate void removeFromAddressConnections(Connection connection) {\n\t\tInetSocketAddress peerAddress = connection.getPeerAddress();\n\t\tif (peerAddress != null) {\n\t\t\tconnectionsByAddress.remove(peerAddress, connection);\n\t\t\tconnection.updatePeerAddress(null);\n\t\t}\n\t}\n\n\tprivate synchronized void removeSessionFromCache(final Connection connection) {\n\t\tif (sessionCache != null) {\n\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\tif (establishedSession != null) {\n\t\t\t\tSessionId sessionId = establishedSession.getSessionIdentifier();\n\t\t\t\tsessionCache.remove(sessionId);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void addToAddressConnections(Connection connection) {\n\t\tfinal InetSocketAddress peerAddress = connection.getPeerAddress();\n\t\tif (peerAddress != null) {\n\t\t\tfinal Connection previous = connectionsByAddress.put(peerAddress, connection);\n\t\t\tif (previous != null && previous != connection) {\n\t\t\t\tRunnable removeAddress = new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tif (previous.equalsPeerAddress(peerAddress)) {\n\t\t\t\t\t\t\tprevious.updatePeerAddress(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tLOG.debug(\"{}connection: {} - {} added! {} removed from address.\", tag, connection.getConnectionId(),\n\t\t\t\t\t\tpeerAddress, previous.getConnectionId());\n\t\t\t\tif (previous.isExecuting()) {\n\t\t\t\t\tprevious.getExecutor().execute(removeAddress);\n\t\t\t\t} else {\n\t\t\t\t\tremoveAddress.run();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG.debug(\"{}connection: {} - {} added!\", tag, connection.getConnectionId(), peerAddress);\n\t\t\t}\n\t\t} else {\n\t\t\tLOG.debug(\"{}connection: {} - missing address!\", tag, connection.getConnectionId());\n\t\t}\n\t}\n\n\t@Override\n\tpublic final synchronized void clear() {\n\t\tfor (Connection connection : connections.values()) {\n\t\t\tSerialExecutor executor = connection.getExecutor();\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.shutdownNow();\n\t\t\t}\n\t\t}\n\t\tconnections.clear();\n\t\tconnectionsByEstablishedSession.clear();\n\t\tconnectionsByAddress.clear();\n\t\t// TODO: does it make sense to clear the SessionCache as well?\n\t}\n\n\t@Override\n\tpublic final synchronized void stop(List<Runnable> pending) {\n\t\tfor (Connection connection : connections.values()) {\n\t\t\tSerialExecutor executor = connection.getExecutor();\n\t\t\tif (executor != null) {\n\t\t\t\texecutor.shutdownNow(pending);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * \n\t * @see LeastRecentlyUsedCache#valuesIterator()\n\t */\n\t@Override\n\tpublic Iterator<Connection> iterator() {\n\t\treturn connections.valuesIterator();\n\t}\n\n}\n"], "filenames": ["scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java", "scandium-core/src/main/java/org/eclipse/californium/scandium/dtls/InMemoryConnectionStore.java"], "buggy_code_start_loc": [1038, 537], "buggy_code_end_loc": [2820, 546], "fixing_code_start_loc": [1038, 537], "fixing_code_end_loc": [2820, 558], "type": "CWE-404", "message": "Eclipse Californium is a Java implementation of RFC7252 - Constrained Application Protocol for IoT Cloud services. In versions prior to 3.7.0, and 2.7.4, Californium is vulnerable to a Denial of Service. Failing handshakes don't cleanup counters for throttling, causing the threshold to be reached without being released again. This results in permanently dropping records. The issue was reported for certificate based handshakes, but may also affect PSK based handshakes. It generally affects client and server as well. This issue is patched in version 3.7.0 and 2.7.4. There are no known workarounds. main: commit 726bac57659410da463dcf404b3e79a7312ac0b9 2.7.x: commit 5648a0c27c2c2667c98419254557a14bac2b1f3f", "other": {"cve": {"id": "CVE-2022-39368", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-10T00:15:10.283", "lastModified": "2022-11-17T21:39:50.133", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Eclipse Californium is a Java implementation of RFC7252 - Constrained Application Protocol for IoT Cloud services. In versions prior to 3.7.0, and 2.7.4, Californium is vulnerable to a Denial of Service. Failing handshakes don't cleanup counters for throttling, causing the threshold to be reached without being released again. This results in permanently dropping records. The issue was reported for certificate based handshakes, but may also affect PSK based handshakes. It generally affects client and server as well. This issue is patched in version 3.7.0 and 2.7.4. There are no known workarounds. main: commit 726bac57659410da463dcf404b3e79a7312ac0b9 2.7.x: commit 5648a0c27c2c2667c98419254557a14bac2b1f3f"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}, {"lang": "en", "value": "CWE-459"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-404"}, {"lang": "en", "value": "CWE-459"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:californium:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.4", "matchCriteriaId": "EDE67472-03E6-4635-93AF-D33ECBEFBFEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:californium:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.7.0", "matchCriteriaId": "9EDA6ED8-417E-47CF-BCF7-991B500850C2"}]}]}], "references": [{"url": "https://github.com/eclipse-californium/californium/commit/5648a0c27c2c2667c98419254557a14bac2b1f3f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/eclipse-californium/californium/commit/726bac57659410da463dcf404b3e79a7312ac0b9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/eclipse-californium/californium/security/advisories/GHSA-p72g-cgh9-ghjg", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eclipse-californium/californium/commit/5648a0c27c2c2667c98419254557a14bac2b1f3f"}}