{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * slip.c\tThis module implements the SLIP protocol for kernel-based\n *\t\tdevices like TTY.  It interfaces between a raw TTY, and the\n *\t\tkernel's INET protocol layers.\n *\n * Version:\t@(#)slip.c\t0.8.3\t12/24/94\n *\n * Authors:\tLaurence Culhane, <loz@holmes.demon.co.uk>\n *\t\tFred N. van Kempen, <waltje@uwalt.nl.mugnet.org>\n *\n * Fixes:\n *\t\tAlan Cox\t: \tSanity checks and avoid tx overruns.\n *\t\t\t\t\tHas a new sl->mtu field.\n *\t\tAlan Cox\t: \tFound cause of overrun. ifconfig sl0\n *\t\t\t\t\tmtu upwards. Driver now spots this\n *\t\t\t\t\tand grows/shrinks its buffers(hack!).\n *\t\t\t\t\tMemory leak if you run out of memory\n *\t\t\t\t\tsetting up a slip driver fixed.\n *\t\tMatt Dillon\t:\tPrintable slip (borrowed from NET2E)\n *\tPauline Middelink\t:\tSlip driver fixes.\n *\t\tAlan Cox\t:\tHonours the old SL_COMPRESSED flag\n *\t\tAlan Cox\t:\tKISS AX.25 and AXUI IP support\n *\t\tMichael Riepe\t:\tAutomatic CSLIP recognition added\n *\t\tCharles Hedrick :\tCSLIP header length problem fix.\n *\t\tAlan Cox\t:\tCorrected non-IP cases of the above.\n *\t\tAlan Cox\t:\tNow uses hardware type as per FvK.\n *\t\tAlan Cox\t:\tDefault to 192.168.0.0 (RFC 1597)\n *\t\tA.N.Kuznetsov\t:\tdev_tint() recursion fix.\n *\tDmitry Gorodchanin\t:\tSLIP memory leaks\n *      Dmitry Gorodchanin      :       Code cleanup. Reduce tty driver\n *                                      buffering from 4096 to 256 bytes.\n *                                      Improving SLIP response time.\n *                                      CONFIG_SLIP_MODE_SLIP6.\n *                                      ifconfig sl? up & down now works\n *\t\t\t\t\tcorrectly.\n *\t\t\t\t\tModularization.\n *              Alan Cox        :       Oops - fix AX.25 buffer lengths\n *      Dmitry Gorodchanin      :       Even more cleanups. Preserve CSLIP\n *                                      statistics. Include CSLIP code only\n *                                      if it really needed.\n *\t\tAlan Cox\t:\tFree slhc buffers in the right place.\n *\t\tAlan Cox\t:\tAllow for digipeated IP over AX.25\n *\t\tMatti Aarnio\t:\tDynamic SLIP devices, with ideas taken\n *\t\t\t\t\tfrom Jim Freeman's <jfree@caldera.com>\n *\t\t\t\t\tdynamic PPP devices.  We do NOT kfree()\n *\t\t\t\t\tdevice entries, just reg./unreg. them\n *\t\t\t\t\tas they are needed.  We kfree() them\n *\t\t\t\t\tat module cleanup.\n *\t\t\t\t\tWith MODULE-loading ``insmod'', user\n *\t\t\t\t\tcan issue parameter:  slip_maxdev=1024\n *\t\t\t\t\t(Or how much he/she wants.. Default\n *\t\t\t\t\tis 256)\n *\tStanislav Voronyi\t:\tSlip line checking, with ideas taken\n *\t\t\t\t\tfrom multislip BSDI driver which was\n *\t\t\t\t\twritten by Igor Chechik, RELCOM Corp.\n *\t\t\t\t\tOnly algorithms have been ported to\n *\t\t\t\t\tLinux SLIP driver.\n *\tVitaly E. Lavrov\t:\tSane behaviour on tty hangup.\n *\tAlexey Kuznetsov\t:\tCleanup interfaces to tty & netdevice\n *\t\t\t\t\tmodules.\n */\n\n#define SL_CHECK_TRANSMIT\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_arp.h>\n#include <linux/if_slip.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include \"slip.h\"\n#ifdef CONFIG_INET\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/slhc_vj.h>\n#endif\n\n#define SLIP_VERSION\t\"0.8.4-NET3.019-NEWTTY\"\n\nstatic struct net_device **slip_devs;\n\nstatic int slip_maxdev = SL_NRUNIT;\nmodule_param(slip_maxdev, int, 0);\nMODULE_PARM_DESC(slip_maxdev, \"Maximum number of slip devices\");\n\nstatic int slip_esc(unsigned char *p, unsigned char *d, int len);\nstatic void slip_unesc(struct slip *sl, unsigned char c);\n#ifdef CONFIG_SLIP_MODE_SLIP6\nstatic int slip_esc6(unsigned char *p, unsigned char *d, int len);\nstatic void slip_unesc6(struct slip *sl, unsigned char c);\n#endif\n#ifdef CONFIG_SLIP_SMART\nstatic void sl_keepalive(struct timer_list *t);\nstatic void sl_outfill(struct timer_list *t);\nstatic int sl_siocdevprivate(struct net_device *dev, struct ifreq *rq, void __user *data, int cmd);\n#endif\n\n/********************************\n*  Buffer administration routines:\n*\tsl_alloc_bufs()\n*\tsl_free_bufs()\n*\tsl_realloc_bufs()\n*\n* NOTE: sl_realloc_bufs != sl_free_bufs + sl_alloc_bufs, because\n*\tsl_realloc_bufs provides strong atomicity and reallocation\n*\ton actively running device.\n*********************************/\n\n/*\n   Allocate channel buffers.\n */\n\nstatic int sl_alloc_bufs(struct slip *sl, int mtu)\n{\n\tint err = -ENOBUFS;\n\tunsigned long len;\n\tchar *rbuff = NULL;\n\tchar *xbuff = NULL;\n#ifdef SL_INCLUDE_CSLIP\n\tchar *cbuff = NULL;\n\tstruct slcompress *slcomp = NULL;\n#endif\n\n\t/*\n\t * Allocate the SLIP frame buffers:\n\t *\n\t * rbuff\tReceive buffer.\n\t * xbuff\tTransmit buffer.\n\t * cbuff        Temporary compression buffer.\n\t */\n\tlen = mtu * 2;\n\n\t/*\n\t * allow for arrival of larger UDP packets, even if we say not to\n\t * also fixes a bug in which SunOS sends 512-byte packets even with\n\t * an MSS of 128\n\t */\n\tif (len < 576 * 2)\n\t\tlen = 576 * 2;\n\trbuff = kmalloc(len + 4, GFP_KERNEL);\n\tif (rbuff == NULL)\n\t\tgoto err_exit;\n\txbuff = kmalloc(len + 4, GFP_KERNEL);\n\tif (xbuff == NULL)\n\t\tgoto err_exit;\n#ifdef SL_INCLUDE_CSLIP\n\tcbuff = kmalloc(len + 4, GFP_KERNEL);\n\tif (cbuff == NULL)\n\t\tgoto err_exit;\n\tslcomp = slhc_init(16, 16);\n\tif (IS_ERR(slcomp))\n\t\tgoto err_exit;\n#endif\n\tspin_lock_bh(&sl->lock);\n\tif (sl->tty == NULL) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\terr = -ENODEV;\n\t\tgoto err_exit;\n\t}\n\tsl->mtu\t     = mtu;\n\tsl->buffsize = len;\n\tsl->rcount   = 0;\n\tsl->xleft    = 0;\n\trbuff = xchg(&sl->rbuff, rbuff);\n\txbuff = xchg(&sl->xbuff, xbuff);\n#ifdef SL_INCLUDE_CSLIP\n\tcbuff = xchg(&sl->cbuff, cbuff);\n\tslcomp = xchg(&sl->slcomp, slcomp);\n#endif\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\tsl->xdata    = 0;\n\tsl->xbits    = 0;\n#endif\n\tspin_unlock_bh(&sl->lock);\n\terr = 0;\n\n\t/* Cleanup */\nerr_exit:\n#ifdef SL_INCLUDE_CSLIP\n\tkfree(cbuff);\n\tslhc_free(slcomp);\n#endif\n\tkfree(xbuff);\n\tkfree(rbuff);\n\treturn err;\n}\n\n/* Free a SLIP channel buffers. */\nstatic void sl_free_bufs(struct slip *sl)\n{\n\t/* Free all SLIP frame buffers. */\n\tkfree(xchg(&sl->rbuff, NULL));\n\tkfree(xchg(&sl->xbuff, NULL));\n#ifdef SL_INCLUDE_CSLIP\n\tkfree(xchg(&sl->cbuff, NULL));\n\tslhc_free(xchg(&sl->slcomp, NULL));\n#endif\n}\n\n/*\n   Reallocate slip channel buffers.\n */\n\nstatic int sl_realloc_bufs(struct slip *sl, int mtu)\n{\n\tint err = 0;\n\tstruct net_device *dev = sl->dev;\n\tunsigned char *xbuff, *rbuff;\n#ifdef SL_INCLUDE_CSLIP\n\tunsigned char *cbuff;\n#endif\n\tint len = mtu * 2;\n\n/*\n * allow for arrival of larger UDP packets, even if we say not to\n * also fixes a bug in which SunOS sends 512-byte packets even with\n * an MSS of 128\n */\n\tif (len < 576 * 2)\n\t\tlen = 576 * 2;\n\n\txbuff = kmalloc(len + 4, GFP_ATOMIC);\n\trbuff = kmalloc(len + 4, GFP_ATOMIC);\n#ifdef SL_INCLUDE_CSLIP\n\tcbuff = kmalloc(len + 4, GFP_ATOMIC);\n#endif\n\n\n#ifdef SL_INCLUDE_CSLIP\n\tif (xbuff == NULL || rbuff == NULL || cbuff == NULL)  {\n#else\n\tif (xbuff == NULL || rbuff == NULL)  {\n#endif\n\t\tif (mtu > sl->mtu) {\n\t\t\tprintk(KERN_WARNING \"%s: unable to grow slip buffers, MTU change cancelled.\\n\",\n\t\t\t       dev->name);\n\t\t\terr = -ENOBUFS;\n\t\t}\n\t\tgoto done;\n\t}\n\tspin_lock_bh(&sl->lock);\n\n\terr = -ENODEV;\n\tif (sl->tty == NULL)\n\t\tgoto done_on_bh;\n\n\txbuff    = xchg(&sl->xbuff, xbuff);\n\trbuff    = xchg(&sl->rbuff, rbuff);\n#ifdef SL_INCLUDE_CSLIP\n\tcbuff    = xchg(&sl->cbuff, cbuff);\n#endif\n\tif (sl->xleft)  {\n\t\tif (sl->xleft <= len)  {\n\t\t\tmemcpy(sl->xbuff, sl->xhead, sl->xleft);\n\t\t} else  {\n\t\t\tsl->xleft = 0;\n\t\t\tdev->stats.tx_dropped++;\n\t\t}\n\t}\n\tsl->xhead = sl->xbuff;\n\n\tif (sl->rcount)  {\n\t\tif (sl->rcount <= len) {\n\t\t\tmemcpy(sl->rbuff, rbuff, sl->rcount);\n\t\t} else  {\n\t\t\tsl->rcount = 0;\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tset_bit(SLF_ERROR, &sl->flags);\n\t\t}\n\t}\n\tsl->mtu      = mtu;\n\tdev->mtu      = mtu;\n\tsl->buffsize = len;\n\terr = 0;\n\ndone_on_bh:\n\tspin_unlock_bh(&sl->lock);\n\ndone:\n\tkfree(xbuff);\n\tkfree(rbuff);\n#ifdef SL_INCLUDE_CSLIP\n\tkfree(cbuff);\n#endif\n\treturn err;\n}\n\n\n/* Set the \"sending\" flag.  This must be atomic hence the set_bit. */\nstatic inline void sl_lock(struct slip *sl)\n{\n\tnetif_stop_queue(sl->dev);\n}\n\n\n/* Clear the \"sending\" flag.  This must be atomic, hence the ASM. */\nstatic inline void sl_unlock(struct slip *sl)\n{\n\tnetif_wake_queue(sl->dev);\n}\n\n/* Send one completely decapsulated IP datagram to the IP layer. */\nstatic void sl_bump(struct slip *sl)\n{\n\tstruct net_device *dev = sl->dev;\n\tstruct sk_buff *skb;\n\tint count;\n\n\tcount = sl->rcount;\n#ifdef SL_INCLUDE_CSLIP\n\tif (sl->mode & (SL_MODE_ADAPTIVE | SL_MODE_CSLIP)) {\n\t\tunsigned char c = sl->rbuff[0];\n\t\tif (c & SL_TYPE_COMPRESSED_TCP) {\n\t\t\t/* ignore compressed packets when CSLIP is off */\n\t\t\tif (!(sl->mode & SL_MODE_CSLIP)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: compressed packet ignored\\n\", dev->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* make sure we've reserved enough space for uncompress\n\t\t\t   to use */\n\t\t\tif (count + 80 > sl->buffsize) {\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcount = slhc_uncompress(sl->slcomp, sl->rbuff, count);\n\t\t\tif (count <= 0)\n\t\t\t\treturn;\n\t\t} else if (c >= SL_TYPE_UNCOMPRESSED_TCP) {\n\t\t\tif (!(sl->mode & SL_MODE_CSLIP)) {\n\t\t\t\t/* turn on header compression */\n\t\t\t\tsl->mode |= SL_MODE_CSLIP;\n\t\t\t\tsl->mode &= ~SL_MODE_ADAPTIVE;\n\t\t\t\tprintk(KERN_INFO \"%s: header compression turned on\\n\", dev->name);\n\t\t\t}\n\t\t\tsl->rbuff[0] &= 0x4f;\n\t\t\tif (slhc_remember(sl->slcomp, sl->rbuff, count) <= 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n#endif  /* SL_INCLUDE_CSLIP */\n\n\tdev->stats.rx_bytes += count;\n\n\tskb = dev_alloc_skb(count);\n\tif (skb == NULL) {\n\t\tprintk(KERN_WARNING \"%s: memory squeeze, dropping packet.\\n\", dev->name);\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tskb->dev = dev;\n\tskb_put_data(skb, sl->rbuff, count);\n\tskb_reset_mac_header(skb);\n\tskb->protocol = htons(ETH_P_IP);\n\tnetif_rx(skb);\n\tdev->stats.rx_packets++;\n}\n\n/* Encapsulate one IP datagram and stuff into a TTY queue. */\nstatic void sl_encaps(struct slip *sl, unsigned char *icp, int len)\n{\n\tunsigned char *p;\n\tint actual, count;\n\n\tif (len > sl->mtu) {\t\t/* Sigh, shouldn't occur BUT ... */\n\t\tprintk(KERN_WARNING \"%s: truncating oversized transmit packet!\\n\", sl->dev->name);\n\t\tsl->dev->stats.tx_dropped++;\n\t\tsl_unlock(sl);\n\t\treturn;\n\t}\n\n\tp = icp;\n#ifdef SL_INCLUDE_CSLIP\n\tif (sl->mode & SL_MODE_CSLIP)\n\t\tlen = slhc_compress(sl->slcomp, p, len, sl->cbuff, &p, 1);\n#endif\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\tif (sl->mode & SL_MODE_SLIP6)\n\t\tcount = slip_esc6(p, sl->xbuff, len);\n\telse\n#endif\n\t\tcount = slip_esc(p, sl->xbuff, len);\n\n\t/* Order of next two lines is *very* important.\n\t * When we are sending a little amount of data,\n\t * the transfer may be completed inside the ops->write()\n\t * routine, because it's running with interrupts enabled.\n\t * In this case we *never* got WRITE_WAKEUP event,\n\t * if we did not request it before write operation.\n\t *       14 Oct 1994  Dmitry Gorodchanin.\n\t */\n\tset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tactual = sl->tty->ops->write(sl->tty, sl->xbuff, count);\n#ifdef SL_CHECK_TRANSMIT\n\tnetif_trans_update(sl->dev);\n#endif\n\tsl->xleft = count - actual;\n\tsl->xhead = sl->xbuff + actual;\n#ifdef CONFIG_SLIP_SMART\n\t/* VSV */\n\tclear_bit(SLF_OUTWAIT, &sl->flags);\t/* reset outfill flag */\n#endif\n}\n\n/* Write out any remaining transmit buffer. Scheduled when tty is writable */\nstatic void slip_transmit(struct work_struct *work)\n{\n\tstruct slip *sl = container_of(work, struct slip, tx_work);\n\tint actual;\n\n\tspin_lock_bh(&sl->lock);\n\t/* First make sure we're connected. */\n\tif (!sl->tty || sl->magic != SLIP_MAGIC || !netif_running(sl->dev)) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn;\n\t}\n\n\tif (sl->xleft <= 0)  {\n\t\t/* Now serial buffer is almost free & we can start\n\t\t * transmission of another packet */\n\t\tsl->dev->stats.tx_packets++;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t\tspin_unlock_bh(&sl->lock);\n\t\tsl_unlock(sl);\n\t\treturn;\n\t}\n\n\tactual = sl->tty->ops->write(sl->tty, sl->xhead, sl->xleft);\n\tsl->xleft -= actual;\n\tsl->xhead += actual;\n\tspin_unlock_bh(&sl->lock);\n}\n\n/*\n * Called by the driver when there's room for more data.\n * Schedule the transmit.\n */\nstatic void slip_write_wakeup(struct tty_struct *tty)\n{\n\tstruct slip *sl;\n\n\trcu_read_lock();\n\tsl = rcu_dereference(tty->disc_data);\n\tif (sl)\n\t\tschedule_work(&sl->tx_work);\n\trcu_read_unlock();\n}\n\nstatic void sl_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tspin_lock(&sl->lock);\n\n\tif (netif_queue_stopped(dev)) {\n\t\tif (!netif_running(dev))\n\t\t\tgoto out;\n\n\t\t/* May be we must check transmitter timeout here ?\n\t\t *      14 Oct 1994 Dmitry Gorodchanin.\n\t\t */\n#ifdef SL_CHECK_TRANSMIT\n\t\tif (time_before(jiffies, dev_trans_start(dev) + 20 * HZ))  {\n\t\t\t/* 20 sec timeout not reached */\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_WARNING \"%s: transmit timed out, %s?\\n\",\n\t\t\tdev->name,\n\t\t\t(tty_chars_in_buffer(sl->tty) || sl->xleft) ?\n\t\t\t\t\"bad line quality\" : \"driver error\");\n\t\tsl->xleft = 0;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t\tsl_unlock(sl);\n#endif\n\t}\nout:\n\tspin_unlock(&sl->lock);\n}\n\n\n/* Encapsulate an IP datagram and kick it into a TTY queue. */\nstatic netdev_tx_t\nsl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tspin_lock(&sl->lock);\n\tif (!netif_running(dev)) {\n\t\tspin_unlock(&sl->lock);\n\t\tprintk(KERN_WARNING \"%s: xmit call when iface is down\\n\", dev->name);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (sl->tty == NULL) {\n\t\tspin_unlock(&sl->lock);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tsl_lock(sl);\n\tdev->stats.tx_bytes += skb->len;\n\tsl_encaps(sl, skb->data, skb->len);\n\tspin_unlock(&sl->lock);\n\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n/******************************************\n *   Routines looking at netdevice side.\n ******************************************/\n\n/* Netdevice UP -> DOWN routine */\n\nstatic int\nsl_close(struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tspin_lock_bh(&sl->lock);\n\tif (sl->tty)\n\t\t/* TTY discipline is running. */\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tnetif_stop_queue(dev);\n\tsl->rcount   = 0;\n\tsl->xleft    = 0;\n\tspin_unlock_bh(&sl->lock);\n\n\treturn 0;\n}\n\n/* Netdevice DOWN -> UP routine */\n\nstatic int sl_open(struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tif (sl->tty == NULL)\n\t\treturn -ENODEV;\n\n\tsl->flags &= (1 << SLF_INUSE);\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n/* Netdevice change MTU request */\n\nstatic int sl_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\treturn sl_realloc_bufs(sl, new_mtu);\n}\n\n/* Netdevice get statistics request */\n\nstatic void\nsl_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct net_device_stats *devstats = &dev->stats;\n#ifdef SL_INCLUDE_CSLIP\n\tstruct slip *sl = netdev_priv(dev);\n\tstruct slcompress *comp = sl->slcomp;\n#endif\n\tstats->rx_packets     = devstats->rx_packets;\n\tstats->tx_packets     = devstats->tx_packets;\n\tstats->rx_bytes       = devstats->rx_bytes;\n\tstats->tx_bytes       = devstats->tx_bytes;\n\tstats->rx_dropped     = devstats->rx_dropped;\n\tstats->tx_dropped     = devstats->tx_dropped;\n\tstats->tx_errors      = devstats->tx_errors;\n\tstats->rx_errors      = devstats->rx_errors;\n\tstats->rx_over_errors = devstats->rx_over_errors;\n\n#ifdef SL_INCLUDE_CSLIP\n\tif (comp) {\n\t\t/* Generic compressed statistics */\n\t\tstats->rx_compressed   = comp->sls_i_compressed;\n\t\tstats->tx_compressed   = comp->sls_o_compressed;\n\n\t\t/* Are we really still needs this? */\n\t\tstats->rx_fifo_errors += comp->sls_i_compressed;\n\t\tstats->rx_dropped     += comp->sls_i_tossed;\n\t\tstats->tx_fifo_errors += comp->sls_o_compressed;\n\t\tstats->collisions     += comp->sls_o_misses;\n\t}\n#endif\n}\n\n/* Netdevice register callback */\n\nstatic int sl_init(struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\t/*\n\t *\tFinish setting up the DEVICE info.\n\t */\n\n\tdev->mtu\t\t= sl->mtu;\n\tdev->type\t\t= ARPHRD_SLIP + sl->mode;\n#ifdef SL_CHECK_TRANSMIT\n\tdev->watchdog_timeo\t= 20*HZ;\n#endif\n\treturn 0;\n}\n\n\nstatic void sl_uninit(struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tsl_free_bufs(sl);\n}\n\n/* Hook the destructor so we can free slip devices at the right point in time */\nstatic void sl_free_netdev(struct net_device *dev)\n{\n\tint i = dev->base_addr;\n\n\tslip_devs[i] = NULL;\n}\n\nstatic const struct net_device_ops sl_netdev_ops = {\n\t.ndo_init\t\t= sl_init,\n\t.ndo_uninit\t  \t= sl_uninit,\n\t.ndo_open\t\t= sl_open,\n\t.ndo_stop\t\t= sl_close,\n\t.ndo_start_xmit\t\t= sl_xmit,\n\t.ndo_get_stats64        = sl_get_stats64,\n\t.ndo_change_mtu\t\t= sl_change_mtu,\n\t.ndo_tx_timeout\t\t= sl_tx_timeout,\n#ifdef CONFIG_SLIP_SMART\n\t.ndo_siocdevprivate\t= sl_siocdevprivate,\n#endif\n};\n\n\nstatic void sl_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &sl_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= sl_free_netdev;\n\n\tdev->hard_header_len\t= 0;\n\tdev->addr_len\t\t= 0;\n\tdev->tx_queue_len\t= 10;\n\n\t/* MTU range: 68 - 65534 */\n\tdev->min_mtu = 68;\n\tdev->max_mtu = 65534;\n\n\t/* New-style flags. */\n\tdev->flags\t\t= IFF_NOARP|IFF_POINTOPOINT|IFF_MULTICAST;\n}\n\n/******************************************\n  Routines looking at TTY side.\n ******************************************/\n\n\n/*\n * Handle the 'receiver data ready' interrupt.\n * This function is called by the 'tty_io' module in the kernel when\n * a block of SLIP data has been received, which can now be decapsulated\n * and sent on to some IP layer for further processing. This will not\n * be re-entered while running but other ldisc functions may be called\n * in parallel\n */\n\nstatic void slip_receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\tconst char *fp, int count)\n{\n\tstruct slip *sl = tty->disc_data;\n\n\tif (!sl || sl->magic != SLIP_MAGIC || !netif_running(sl->dev))\n\t\treturn;\n\n\t/* Read the characters out of the buffer */\n\twhile (count--) {\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SLF_ERROR, &sl->flags))\n\t\t\t\tsl->dev->stats.rx_errors++;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\t\tif (sl->mode & SL_MODE_SLIP6)\n\t\t\tslip_unesc6(sl, *cp++);\n\t\telse\n#endif\n\t\t\tslip_unesc(sl, *cp++);\n\t}\n}\n\n/************************************\n *  slip_open helper routines.\n ************************************/\n\n/* Collect hanged up channels */\nstatic void sl_sync(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slip\t  *sl;\n\n\tfor (i = 0; i < slip_maxdev; i++) {\n\t\tdev = slip_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty || sl->leased)\n\t\t\tcontinue;\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_close(dev);\n\t}\n}\n\n\n/* Find a free SLIP channel, and link in this `tty' line. */\nstatic struct slip *sl_alloc(void)\n{\n\tint i;\n\tchar name[IFNAMSIZ];\n\tstruct net_device *dev = NULL;\n\tstruct slip       *sl;\n\n\tfor (i = 0; i < slip_maxdev; i++) {\n\t\tdev = slip_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\t}\n\t/* Sorry, too many, all slots in use */\n\tif (i >= slip_maxdev)\n\t\treturn NULL;\n\n\tsprintf(name, \"sl%d\", i);\n\tdev = alloc_netdev(sizeof(*sl), name, NET_NAME_UNKNOWN, sl_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->base_addr  = i;\n\tsl = netdev_priv(dev);\n\n\t/* Initialize channel control data */\n\tsl->magic       = SLIP_MAGIC;\n\tsl->dev\t      \t= dev;\n\tspin_lock_init(&sl->lock);\n\tINIT_WORK(&sl->tx_work, slip_transmit);\n\tsl->mode        = SL_MODE_DEFAULT;\n#ifdef CONFIG_SLIP_SMART\n\t/* initialize timer_list struct */\n\ttimer_setup(&sl->keepalive_timer, sl_keepalive, 0);\n\ttimer_setup(&sl->outfill_timer, sl_outfill, 0);\n#endif\n\tslip_devs[i] = dev;\n\treturn sl;\n}\n\n/*\n * Open the high-level part of the SLIP channel.\n * This function is called by the TTY module when the\n * SLIP line discipline is called for.  Because we are\n * sure the tty line exists, we only have to link it to\n * a free SLIP channel...\n *\n * Called in process context serialized from other ldisc calls.\n */\n\nstatic int slip_open(struct tty_struct *tty)\n{\n\tstruct slip *sl;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* RTnetlink lock is misused here to serialize concurrent\n\t   opens of slip channels. There are better ways, but it is\n\t   the simplest one.\n\t */\n\trtnl_lock();\n\n\t/* Collect hanged up channels. */\n\tsl_sync();\n\n\tsl = tty->disc_data;\n\n\terr = -EEXIST;\n\t/* First make sure we're not already connected. */\n\tif (sl && sl->magic == SLIP_MAGIC)\n\t\tgoto err_exit;\n\n\t/* OK.  Find a free SLIP channel to use. */\n\terr = -ENFILE;\n\tsl = sl_alloc();\n\tif (sl == NULL)\n\t\tgoto err_exit;\n\n\tsl->tty = tty;\n\ttty->disc_data = sl;\n\tsl->pid = current->pid;\n\n\tif (!test_bit(SLF_INUSE, &sl->flags)) {\n\t\t/* Perform the low-level SLIP initialization. */\n\t\terr = sl_alloc_bufs(sl, SL_MTU);\n\t\tif (err)\n\t\t\tgoto err_free_chan;\n\n\t\tset_bit(SLF_INUSE, &sl->flags);\n\n\t\terr = register_netdevice(sl->dev);\n\t\tif (err)\n\t\t\tgoto err_free_bufs;\n\t}\n\n#ifdef CONFIG_SLIP_SMART\n\tif (sl->keepalive) {\n\t\tsl->keepalive_timer.expires = jiffies + sl->keepalive * HZ;\n\t\tadd_timer(&sl->keepalive_timer);\n\t}\n\tif (sl->outfill) {\n\t\tsl->outfill_timer.expires = jiffies + sl->outfill * HZ;\n\t\tadd_timer(&sl->outfill_timer);\n\t}\n#endif\n\n\t/* Done.  We have linked the TTY line to a channel. */\n\trtnl_unlock();\n\ttty->receive_room = 65536;\t/* We don't flow control */\n\n\t/* TTY layer expects 0 on success */\n\treturn 0;\n\nerr_free_bufs:\n\tsl_free_bufs(sl);\n\nerr_free_chan:\n\tsl->tty = NULL;\n\ttty->disc_data = NULL;\n\tclear_bit(SLF_INUSE, &sl->flags);\n\tsl_free_netdev(sl->dev);\n\t/* do not call free_netdev before rtnl_unlock */\n\trtnl_unlock();\n\tfree_netdev(sl->dev);\n\treturn err;\n\nerr_exit:\n\trtnl_unlock();\n\n\t/* Count references from TTY module */\n\treturn err;\n}\n\n/*\n * Close down a SLIP channel.\n * This means flushing out any pending queues, and then returning. This\n * call is serialized against other ldisc functions.\n *\n * We also use this method fo a hangup event\n */\n\nstatic void slip_close(struct tty_struct *tty)\n{\n\tstruct slip *sl = tty->disc_data;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLIP_MAGIC || sl->tty != tty)\n\t\treturn;\n\n\tspin_lock_bh(&sl->lock);\n\trcu_assign_pointer(tty->disc_data, NULL);\n\tsl->tty = NULL;\n\tspin_unlock_bh(&sl->lock);\n\n\tsynchronize_rcu();\n\tflush_work(&sl->tx_work);\n\n\t/* VSV = very important to remove timers */\n#ifdef CONFIG_SLIP_SMART\n\tdel_timer_sync(&sl->keepalive_timer);\n\tdel_timer_sync(&sl->outfill_timer);\n#endif\n\t/* Flush network side */\n\tunregister_netdev(sl->dev);\n\t/* This will complete via sl_free_netdev */\n}\n\nstatic void slip_hangup(struct tty_struct *tty)\n{\n\tslip_close(tty);\n}\n /************************************************************************\n  *\t\t\tSTANDARD SLIP ENCAPSULATION\t\t  \t *\n  ************************************************************************/\n\nstatic int slip_esc(unsigned char *s, unsigned char *d, int len)\n{\n\tunsigned char *ptr = d;\n\tunsigned char c;\n\n\t/*\n\t * Send an initial END character to flush out any\n\t * data that may have accumulated in the receiver\n\t * due to line noise.\n\t */\n\n\t*ptr++ = END;\n\n\t/*\n\t * For each byte in the packet, send the appropriate\n\t * character sequence, according to the SLIP protocol.\n\t */\n\n\twhile (len-- > 0) {\n\t\tswitch (c = *s++) {\n\t\tcase END:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_END;\n\t\t\tbreak;\n\t\tcase ESC:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_ESC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*ptr++ = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*ptr++ = END;\n\treturn ptr - d;\n}\n\nstatic void slip_unesc(struct slip *sl, unsigned char s)\n{\n\n\tswitch (s) {\n\tcase END:\n#ifdef CONFIG_SLIP_SMART\n\t\t/* drop keeptest bit = VSV */\n\t\tif (test_bit(SLF_KEEPTEST, &sl->flags))\n\t\t\tclear_bit(SLF_KEEPTEST, &sl->flags);\n#endif\n\n\t\tif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\n\t\t    (sl->rcount > 2))\n\t\t\tsl_bump(sl);\n\t\tclear_bit(SLF_ESCAPE, &sl->flags);\n\t\tsl->rcount = 0;\n\t\treturn;\n\n\tcase ESC:\n\t\tset_bit(SLF_ESCAPE, &sl->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(SLF_ESCAPE, &sl->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(SLF_ESCAPE, &sl->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\tif (!test_bit(SLF_ERROR, &sl->flags))  {\n\t\tif (sl->rcount < sl->buffsize)  {\n\t\t\tsl->rbuff[sl->rcount++] = s;\n\t\t\treturn;\n\t\t}\n\t\tsl->dev->stats.rx_over_errors++;\n\t\tset_bit(SLF_ERROR, &sl->flags);\n\t}\n}\n\n\n#ifdef CONFIG_SLIP_MODE_SLIP6\n/************************************************************************\n *\t\t\t 6 BIT SLIP ENCAPSULATION\t\t\t*\n ************************************************************************/\n\nstatic int slip_esc6(unsigned char *s, unsigned char *d, int len)\n{\n\tunsigned char *ptr = d;\n\tunsigned char c;\n\tint i;\n\tunsigned short v = 0;\n\tshort bits = 0;\n\n\t/*\n\t * Send an initial END character to flush out any\n\t * data that may have accumulated in the receiver\n\t * due to line noise.\n\t */\n\n\t*ptr++ = 0x70;\n\n\t/*\n\t * Encode the packet into printable ascii characters\n\t */\n\n\tfor (i = 0; i < len; ++i) {\n\t\tv = (v << 8) | s[i];\n\t\tbits += 8;\n\t\twhile (bits >= 6) {\n\t\t\tbits -= 6;\n\t\t\tc = 0x30 + ((v >> bits) & 0x3F);\n\t\t\t*ptr++ = c;\n\t\t}\n\t}\n\tif (bits) {\n\t\tc = 0x30 + ((v << (6 - bits)) & 0x3F);\n\t\t*ptr++ = c;\n\t}\n\t*ptr++ = 0x70;\n\treturn ptr - d;\n}\n\nstatic void slip_unesc6(struct slip *sl, unsigned char s)\n{\n\tunsigned char c;\n\n\tif (s == 0x70) {\n#ifdef CONFIG_SLIP_SMART\n\t\t/* drop keeptest bit = VSV */\n\t\tif (test_bit(SLF_KEEPTEST, &sl->flags))\n\t\t\tclear_bit(SLF_KEEPTEST, &sl->flags);\n#endif\n\n\t\tif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\n\t\t    (sl->rcount > 2))\n\t\t\tsl_bump(sl);\n\t\tsl->rcount = 0;\n\t\tsl->xbits = 0;\n\t\tsl->xdata = 0;\n\t} else if (s >= 0x30 && s < 0x70) {\n\t\tsl->xdata = (sl->xdata << 6) | ((s - 0x30) & 0x3F);\n\t\tsl->xbits += 6;\n\t\tif (sl->xbits >= 8) {\n\t\t\tsl->xbits -= 8;\n\t\t\tc = (unsigned char)(sl->xdata >> sl->xbits);\n\t\t\tif (!test_bit(SLF_ERROR, &sl->flags))  {\n\t\t\t\tif (sl->rcount < sl->buffsize)  {\n\t\t\t\t\tsl->rbuff[sl->rcount++] = c;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsl->dev->stats.rx_over_errors++;\n\t\t\t\tset_bit(SLF_ERROR, &sl->flags);\n\t\t\t}\n\t\t}\n\t}\n}\n#endif /* CONFIG_SLIP_MODE_SLIP6 */\n\n/* Perform I/O control on an active SLIP channel. */\nstatic int slip_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct slip *sl = tty->disc_data;\n\tunsigned int tmp;\n\tint __user *p = (int __user *)arg;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLIP_MAGIC)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGIFNAME:\n\t\ttmp = strlen(sl->dev->name) + 1;\n\t\tif (copy_to_user((void __user *)arg, sl->dev->name, tmp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCGIFENCAP:\n\t\tif (put_user(sl->mode, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCSIFENCAP:\n\t\tif (get_user(tmp, p))\n\t\t\treturn -EFAULT;\n#ifndef SL_INCLUDE_CSLIP\n\t\tif (tmp & (SL_MODE_CSLIP|SL_MODE_ADAPTIVE))\n\t\t\treturn -EINVAL;\n#else\n\t\tif ((tmp & (SL_MODE_ADAPTIVE | SL_MODE_CSLIP)) ==\n\t\t    (SL_MODE_ADAPTIVE | SL_MODE_CSLIP))\n\t\t\t/* return -EINVAL; */\n\t\t\ttmp &= ~SL_MODE_ADAPTIVE;\n#endif\n#ifndef CONFIG_SLIP_MODE_SLIP6\n\t\tif (tmp & SL_MODE_SLIP6)\n\t\t\treturn -EINVAL;\n#endif\n\t\tsl->mode = tmp;\n\t\tsl->dev->type = ARPHRD_SLIP + sl->mode;\n\t\treturn 0;\n\n\tcase SIOCSIFHWADDR:\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SLIP_SMART\n\t/* VSV changes start here */\n\tcase SIOCSKEEPALIVE:\n\t\tif (get_user(tmp, p))\n\t\t\treturn -EFAULT;\n\t\tif (tmp > 255) /* max for unchar */\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_bh(&sl->lock);\n\t\tif (!sl->tty) {\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tsl->keepalive = (u8)tmp;\n\t\tif (sl->keepalive != 0) {\n\t\t\tmod_timer(&sl->keepalive_timer,\n\t\t\t\t\tjiffies + sl->keepalive * HZ);\n\t\t\tset_bit(SLF_KEEPTEST, &sl->flags);\n\t\t} else\n\t\t\tdel_timer(&sl->keepalive_timer);\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn 0;\n\n\tcase SIOCGKEEPALIVE:\n\t\tif (put_user(sl->keepalive, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCSOUTFILL:\n\t\tif (get_user(tmp, p))\n\t\t\treturn -EFAULT;\n\t\tif (tmp > 255) /* max for unchar */\n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&sl->lock);\n\t\tif (!sl->tty) {\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tsl->outfill = (u8)tmp;\n\t\tif (sl->outfill != 0) {\n\t\t\tmod_timer(&sl->outfill_timer,\n\t\t\t\t\t\tjiffies + sl->outfill * HZ);\n\t\t\tset_bit(SLF_OUTWAIT, &sl->flags);\n\t\t} else\n\t\t\tdel_timer(&sl->outfill_timer);\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn 0;\n\n\tcase SIOCGOUTFILL:\n\t\tif (put_user(sl->outfill, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t/* VSV changes end */\n#endif\n\tdefault:\n\t\treturn tty_mode_ioctl(tty, cmd, arg);\n\t}\n}\n\n/* VSV changes start here */\n#ifdef CONFIG_SLIP_SMART\n/* function sl_siocdevprivate called from net/core/dev.c\n   to allow get/set outfill/keepalive parameter\n   by ifconfig                                 */\n\nstatic int sl_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t     void __user *data, int cmd)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\tunsigned long *p = (unsigned long *)&rq->ifr_ifru;\n\n\tif (sl == NULL)\t\t/* Allocation failed ?? */\n\t\treturn -ENODEV;\n\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_bh(&sl->lock);\n\n\tif (!sl->tty) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (cmd) {\n\tcase SIOCSKEEPALIVE:\n\t\t/* max for unchar */\n\t\tif ((unsigned)*p > 255) {\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsl->keepalive = (u8)*p;\n\t\tif (sl->keepalive != 0) {\n\t\t\tsl->keepalive_timer.expires =\n\t\t\t\t\t\tjiffies + sl->keepalive * HZ;\n\t\t\tmod_timer(&sl->keepalive_timer,\n\t\t\t\t\t\tjiffies + sl->keepalive * HZ);\n\t\t\tset_bit(SLF_KEEPTEST, &sl->flags);\n\t\t} else\n\t\t\tdel_timer(&sl->keepalive_timer);\n\t\tbreak;\n\n\tcase SIOCGKEEPALIVE:\n\t\t*p = sl->keepalive;\n\t\tbreak;\n\n\tcase SIOCSOUTFILL:\n\t\tif ((unsigned)*p > 255) { /* max for unchar */\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsl->outfill = (u8)*p;\n\t\tif (sl->outfill != 0) {\n\t\t\tmod_timer(&sl->outfill_timer,\n\t\t\t\t\t\tjiffies + sl->outfill * HZ);\n\t\t\tset_bit(SLF_OUTWAIT, &sl->flags);\n\t\t} else\n\t\t\tdel_timer(&sl->outfill_timer);\n\t\tbreak;\n\n\tcase SIOCGOUTFILL:\n\t\t*p = sl->outfill;\n\t\tbreak;\n\n\tcase SIOCSLEASE:\n\t\t/* Resolve race condition, when ioctl'ing hanged up\n\t\t   and opened by another process device.\n\t\t */\n\t\tif (sl->tty != current->signal->tty &&\n\t\t\t\t\t\tsl->pid != current->pid) {\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tsl->leased = 0;\n\t\tif (*p)\n\t\t\tsl->leased = 1;\n\t\tbreak;\n\n\tcase SIOCGLEASE:\n\t\t*p = sl->leased;\n\t}\n\tspin_unlock_bh(&sl->lock);\n\treturn 0;\n}\n#endif\n/* VSV changes end */\n\nstatic struct tty_ldisc_ops sl_ldisc = {\n\t.owner \t\t= THIS_MODULE,\n\t.num\t\t= N_SLIP,\n\t.name \t\t= \"slip\",\n\t.open \t\t= slip_open,\n\t.close\t \t= slip_close,\n\t.hangup\t \t= slip_hangup,\n\t.ioctl\t\t= slip_ioctl,\n\t.receive_buf\t= slip_receive_buf,\n\t.write_wakeup\t= slip_write_wakeup,\n};\n\nstatic int __init slip_init(void)\n{\n\tint status;\n\n\tif (slip_maxdev < 4)\n\t\tslip_maxdev = 4; /* Sanity */\n\n\tprintk(KERN_INFO \"SLIP: version %s (dynamic channels, max=%d)\"\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\t       \" (6 bit encapsulation enabled)\"\n#endif\n\t       \".\\n\",\n\t       SLIP_VERSION, slip_maxdev);\n#if defined(SL_INCLUDE_CSLIP)\n\tprintk(KERN_INFO \"CSLIP: code copyright 1989 Regents of the University of California.\\n\");\n#endif\n#ifdef CONFIG_SLIP_SMART\n\tprintk(KERN_INFO \"SLIP linefill/keepalive option.\\n\");\n#endif\n\n\tslip_devs = kcalloc(slip_maxdev, sizeof(struct net_device *),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!slip_devs)\n\t\treturn -ENOMEM;\n\n\t/* Fill in our line protocol discipline, and register it */\n\tstatus = tty_register_ldisc(&sl_ldisc);\n\tif (status != 0) {\n\t\tprintk(KERN_ERR \"SLIP: can't register line discipline (err = %d)\\n\", status);\n\t\tkfree(slip_devs);\n\t}\n\treturn status;\n}\n\nstatic void __exit slip_exit(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slip *sl;\n\tunsigned long timeout = jiffies + HZ;\n\tint busy = 0;\n\n\tif (slip_devs == NULL)\n\t\treturn;\n\n\t/* First of all: check for active disciplines and hangup them.\n\t */\n\tdo {\n\t\tif (busy)\n\t\t\tmsleep_interruptible(100);\n\n\t\tbusy = 0;\n\t\tfor (i = 0; i < slip_maxdev; i++) {\n\t\t\tdev = slip_devs[i];\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\t\t\tsl = netdev_priv(dev);\n\t\t\tspin_lock_bh(&sl->lock);\n\t\t\tif (sl->tty) {\n\t\t\t\tbusy++;\n\t\t\t\ttty_hangup(sl->tty);\n\t\t\t}\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t}\n\t} while (busy && time_before(jiffies, timeout));\n\n\t/* FIXME: hangup is async so we should wait when doing this second\n\t   phase */\n\n\tfor (i = 0; i < slip_maxdev; i++) {\n\t\tdev = slip_devs[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tslip_devs[i] = NULL;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty) {\n\t\t\tprintk(KERN_ERR \"%s: tty discipline still running\\n\",\n\t\t\t       dev->name);\n\t\t}\n\n\t\tunregister_netdev(dev);\n\t}\n\n\tkfree(slip_devs);\n\tslip_devs = NULL;\n\n\ttty_unregister_ldisc(&sl_ldisc);\n}\n\nmodule_init(slip_init);\nmodule_exit(slip_exit);\n\n#ifdef CONFIG_SLIP_SMART\n/*\n * This is start of the code for multislip style line checking\n * added by Stanislav Voronyi. All changes before marked VSV\n */\n\nstatic void sl_outfill(struct timer_list *t)\n{\n\tstruct slip *sl = from_timer(sl, t, outfill_timer);\n\n\tspin_lock(&sl->lock);\n\n\tif (sl->tty == NULL)\n\t\tgoto out;\n\n\tif (sl->outfill) {\n\t\tif (test_bit(SLF_OUTWAIT, &sl->flags)) {\n\t\t\t/* no packets were transmitted, do outfill */\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\t\t\tunsigned char s = (sl->mode & SL_MODE_SLIP6)?0x70:END;\n#else\n\t\t\tunsigned char s = END;\n#endif\n\t\t\t/* put END into tty queue. Is it right ??? */\n\t\t\tif (!netif_queue_stopped(sl->dev)) {\n\t\t\t\t/* if device busy no outfill */\n\t\t\t\tsl->tty->ops->write(sl->tty, &s, 1);\n\t\t\t}\n\t\t} else\n\t\t\tset_bit(SLF_OUTWAIT, &sl->flags);\n\n\t\tmod_timer(&sl->outfill_timer, jiffies+sl->outfill*HZ);\n\t}\nout:\n\tspin_unlock(&sl->lock);\n}\n\nstatic void sl_keepalive(struct timer_list *t)\n{\n\tstruct slip *sl = from_timer(sl, t, keepalive_timer);\n\n\tspin_lock(&sl->lock);\n\n\tif (sl->tty == NULL)\n\t\tgoto out;\n\n\tif (sl->keepalive) {\n\t\tif (test_bit(SLF_KEEPTEST, &sl->flags)) {\n\t\t\t/* keepalive still high :(, we must hangup */\n\t\t\tif (sl->outfill)\n\t\t\t\t/* outfill timer must be deleted too */\n\t\t\t\t(void)del_timer(&sl->outfill_timer);\n\t\t\tprintk(KERN_DEBUG \"%s: no packets received during keepalive timeout, hangup.\\n\", sl->dev->name);\n\t\t\t/* this must hangup tty & close slip */\n\t\t\ttty_hangup(sl->tty);\n\t\t\t/* I think we need not something else */\n\t\t\tgoto out;\n\t\t} else\n\t\t\tset_bit(SLF_KEEPTEST, &sl->flags);\n\n\t\tmod_timer(&sl->keepalive_timer, jiffies+sl->keepalive*HZ);\n\t}\nout:\n\tspin_unlock(&sl->lock);\n}\n\n#endif\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_SLIP);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * slip.c\tThis module implements the SLIP protocol for kernel-based\n *\t\tdevices like TTY.  It interfaces between a raw TTY, and the\n *\t\tkernel's INET protocol layers.\n *\n * Version:\t@(#)slip.c\t0.8.3\t12/24/94\n *\n * Authors:\tLaurence Culhane, <loz@holmes.demon.co.uk>\n *\t\tFred N. van Kempen, <waltje@uwalt.nl.mugnet.org>\n *\n * Fixes:\n *\t\tAlan Cox\t: \tSanity checks and avoid tx overruns.\n *\t\t\t\t\tHas a new sl->mtu field.\n *\t\tAlan Cox\t: \tFound cause of overrun. ifconfig sl0\n *\t\t\t\t\tmtu upwards. Driver now spots this\n *\t\t\t\t\tand grows/shrinks its buffers(hack!).\n *\t\t\t\t\tMemory leak if you run out of memory\n *\t\t\t\t\tsetting up a slip driver fixed.\n *\t\tMatt Dillon\t:\tPrintable slip (borrowed from NET2E)\n *\tPauline Middelink\t:\tSlip driver fixes.\n *\t\tAlan Cox\t:\tHonours the old SL_COMPRESSED flag\n *\t\tAlan Cox\t:\tKISS AX.25 and AXUI IP support\n *\t\tMichael Riepe\t:\tAutomatic CSLIP recognition added\n *\t\tCharles Hedrick :\tCSLIP header length problem fix.\n *\t\tAlan Cox\t:\tCorrected non-IP cases of the above.\n *\t\tAlan Cox\t:\tNow uses hardware type as per FvK.\n *\t\tAlan Cox\t:\tDefault to 192.168.0.0 (RFC 1597)\n *\t\tA.N.Kuznetsov\t:\tdev_tint() recursion fix.\n *\tDmitry Gorodchanin\t:\tSLIP memory leaks\n *      Dmitry Gorodchanin      :       Code cleanup. Reduce tty driver\n *                                      buffering from 4096 to 256 bytes.\n *                                      Improving SLIP response time.\n *                                      CONFIG_SLIP_MODE_SLIP6.\n *                                      ifconfig sl? up & down now works\n *\t\t\t\t\tcorrectly.\n *\t\t\t\t\tModularization.\n *              Alan Cox        :       Oops - fix AX.25 buffer lengths\n *      Dmitry Gorodchanin      :       Even more cleanups. Preserve CSLIP\n *                                      statistics. Include CSLIP code only\n *                                      if it really needed.\n *\t\tAlan Cox\t:\tFree slhc buffers in the right place.\n *\t\tAlan Cox\t:\tAllow for digipeated IP over AX.25\n *\t\tMatti Aarnio\t:\tDynamic SLIP devices, with ideas taken\n *\t\t\t\t\tfrom Jim Freeman's <jfree@caldera.com>\n *\t\t\t\t\tdynamic PPP devices.  We do NOT kfree()\n *\t\t\t\t\tdevice entries, just reg./unreg. them\n *\t\t\t\t\tas they are needed.  We kfree() them\n *\t\t\t\t\tat module cleanup.\n *\t\t\t\t\tWith MODULE-loading ``insmod'', user\n *\t\t\t\t\tcan issue parameter:  slip_maxdev=1024\n *\t\t\t\t\t(Or how much he/she wants.. Default\n *\t\t\t\t\tis 256)\n *\tStanislav Voronyi\t:\tSlip line checking, with ideas taken\n *\t\t\t\t\tfrom multislip BSDI driver which was\n *\t\t\t\t\twritten by Igor Chechik, RELCOM Corp.\n *\t\t\t\t\tOnly algorithms have been ported to\n *\t\t\t\t\tLinux SLIP driver.\n *\tVitaly E. Lavrov\t:\tSane behaviour on tty hangup.\n *\tAlexey Kuznetsov\t:\tCleanup interfaces to tty & netdevice\n *\t\t\t\t\tmodules.\n */\n\n#define SL_CHECK_TRANSMIT\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_arp.h>\n#include <linux/if_slip.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include \"slip.h\"\n#ifdef CONFIG_INET\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/slhc_vj.h>\n#endif\n\n#define SLIP_VERSION\t\"0.8.4-NET3.019-NEWTTY\"\n\nstatic struct net_device **slip_devs;\n\nstatic int slip_maxdev = SL_NRUNIT;\nmodule_param(slip_maxdev, int, 0);\nMODULE_PARM_DESC(slip_maxdev, \"Maximum number of slip devices\");\n\nstatic int slip_esc(unsigned char *p, unsigned char *d, int len);\nstatic void slip_unesc(struct slip *sl, unsigned char c);\n#ifdef CONFIG_SLIP_MODE_SLIP6\nstatic int slip_esc6(unsigned char *p, unsigned char *d, int len);\nstatic void slip_unesc6(struct slip *sl, unsigned char c);\n#endif\n#ifdef CONFIG_SLIP_SMART\nstatic void sl_keepalive(struct timer_list *t);\nstatic void sl_outfill(struct timer_list *t);\nstatic int sl_siocdevprivate(struct net_device *dev, struct ifreq *rq, void __user *data, int cmd);\n#endif\n\n/********************************\n*  Buffer administration routines:\n*\tsl_alloc_bufs()\n*\tsl_free_bufs()\n*\tsl_realloc_bufs()\n*\n* NOTE: sl_realloc_bufs != sl_free_bufs + sl_alloc_bufs, because\n*\tsl_realloc_bufs provides strong atomicity and reallocation\n*\ton actively running device.\n*********************************/\n\n/*\n   Allocate channel buffers.\n */\n\nstatic int sl_alloc_bufs(struct slip *sl, int mtu)\n{\n\tint err = -ENOBUFS;\n\tunsigned long len;\n\tchar *rbuff = NULL;\n\tchar *xbuff = NULL;\n#ifdef SL_INCLUDE_CSLIP\n\tchar *cbuff = NULL;\n\tstruct slcompress *slcomp = NULL;\n#endif\n\n\t/*\n\t * Allocate the SLIP frame buffers:\n\t *\n\t * rbuff\tReceive buffer.\n\t * xbuff\tTransmit buffer.\n\t * cbuff        Temporary compression buffer.\n\t */\n\tlen = mtu * 2;\n\n\t/*\n\t * allow for arrival of larger UDP packets, even if we say not to\n\t * also fixes a bug in which SunOS sends 512-byte packets even with\n\t * an MSS of 128\n\t */\n\tif (len < 576 * 2)\n\t\tlen = 576 * 2;\n\trbuff = kmalloc(len + 4, GFP_KERNEL);\n\tif (rbuff == NULL)\n\t\tgoto err_exit;\n\txbuff = kmalloc(len + 4, GFP_KERNEL);\n\tif (xbuff == NULL)\n\t\tgoto err_exit;\n#ifdef SL_INCLUDE_CSLIP\n\tcbuff = kmalloc(len + 4, GFP_KERNEL);\n\tif (cbuff == NULL)\n\t\tgoto err_exit;\n\tslcomp = slhc_init(16, 16);\n\tif (IS_ERR(slcomp))\n\t\tgoto err_exit;\n#endif\n\tspin_lock_bh(&sl->lock);\n\tif (sl->tty == NULL) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\terr = -ENODEV;\n\t\tgoto err_exit;\n\t}\n\tsl->mtu\t     = mtu;\n\tsl->buffsize = len;\n\tsl->rcount   = 0;\n\tsl->xleft    = 0;\n\trbuff = xchg(&sl->rbuff, rbuff);\n\txbuff = xchg(&sl->xbuff, xbuff);\n#ifdef SL_INCLUDE_CSLIP\n\tcbuff = xchg(&sl->cbuff, cbuff);\n\tslcomp = xchg(&sl->slcomp, slcomp);\n#endif\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\tsl->xdata    = 0;\n\tsl->xbits    = 0;\n#endif\n\tspin_unlock_bh(&sl->lock);\n\terr = 0;\n\n\t/* Cleanup */\nerr_exit:\n#ifdef SL_INCLUDE_CSLIP\n\tkfree(cbuff);\n\tslhc_free(slcomp);\n#endif\n\tkfree(xbuff);\n\tkfree(rbuff);\n\treturn err;\n}\n\n/* Free a SLIP channel buffers. */\nstatic void sl_free_bufs(struct slip *sl)\n{\n\t/* Free all SLIP frame buffers. */\n\tkfree(xchg(&sl->rbuff, NULL));\n\tkfree(xchg(&sl->xbuff, NULL));\n#ifdef SL_INCLUDE_CSLIP\n\tkfree(xchg(&sl->cbuff, NULL));\n\tslhc_free(xchg(&sl->slcomp, NULL));\n#endif\n}\n\n/*\n   Reallocate slip channel buffers.\n */\n\nstatic int sl_realloc_bufs(struct slip *sl, int mtu)\n{\n\tint err = 0;\n\tstruct net_device *dev = sl->dev;\n\tunsigned char *xbuff, *rbuff;\n#ifdef SL_INCLUDE_CSLIP\n\tunsigned char *cbuff;\n#endif\n\tint len = mtu * 2;\n\n/*\n * allow for arrival of larger UDP packets, even if we say not to\n * also fixes a bug in which SunOS sends 512-byte packets even with\n * an MSS of 128\n */\n\tif (len < 576 * 2)\n\t\tlen = 576 * 2;\n\n\txbuff = kmalloc(len + 4, GFP_ATOMIC);\n\trbuff = kmalloc(len + 4, GFP_ATOMIC);\n#ifdef SL_INCLUDE_CSLIP\n\tcbuff = kmalloc(len + 4, GFP_ATOMIC);\n#endif\n\n\n#ifdef SL_INCLUDE_CSLIP\n\tif (xbuff == NULL || rbuff == NULL || cbuff == NULL)  {\n#else\n\tif (xbuff == NULL || rbuff == NULL)  {\n#endif\n\t\tif (mtu > sl->mtu) {\n\t\t\tprintk(KERN_WARNING \"%s: unable to grow slip buffers, MTU change cancelled.\\n\",\n\t\t\t       dev->name);\n\t\t\terr = -ENOBUFS;\n\t\t}\n\t\tgoto done;\n\t}\n\tspin_lock_bh(&sl->lock);\n\n\terr = -ENODEV;\n\tif (sl->tty == NULL)\n\t\tgoto done_on_bh;\n\n\txbuff    = xchg(&sl->xbuff, xbuff);\n\trbuff    = xchg(&sl->rbuff, rbuff);\n#ifdef SL_INCLUDE_CSLIP\n\tcbuff    = xchg(&sl->cbuff, cbuff);\n#endif\n\tif (sl->xleft)  {\n\t\tif (sl->xleft <= len)  {\n\t\t\tmemcpy(sl->xbuff, sl->xhead, sl->xleft);\n\t\t} else  {\n\t\t\tsl->xleft = 0;\n\t\t\tdev->stats.tx_dropped++;\n\t\t}\n\t}\n\tsl->xhead = sl->xbuff;\n\n\tif (sl->rcount)  {\n\t\tif (sl->rcount <= len) {\n\t\t\tmemcpy(sl->rbuff, rbuff, sl->rcount);\n\t\t} else  {\n\t\t\tsl->rcount = 0;\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tset_bit(SLF_ERROR, &sl->flags);\n\t\t}\n\t}\n\tsl->mtu      = mtu;\n\tdev->mtu      = mtu;\n\tsl->buffsize = len;\n\terr = 0;\n\ndone_on_bh:\n\tspin_unlock_bh(&sl->lock);\n\ndone:\n\tkfree(xbuff);\n\tkfree(rbuff);\n#ifdef SL_INCLUDE_CSLIP\n\tkfree(cbuff);\n#endif\n\treturn err;\n}\n\n\n/* Set the \"sending\" flag.  This must be atomic hence the set_bit. */\nstatic inline void sl_lock(struct slip *sl)\n{\n\tnetif_stop_queue(sl->dev);\n}\n\n\n/* Clear the \"sending\" flag.  This must be atomic, hence the ASM. */\nstatic inline void sl_unlock(struct slip *sl)\n{\n\tnetif_wake_queue(sl->dev);\n}\n\n/* Send one completely decapsulated IP datagram to the IP layer. */\nstatic void sl_bump(struct slip *sl)\n{\n\tstruct net_device *dev = sl->dev;\n\tstruct sk_buff *skb;\n\tint count;\n\n\tcount = sl->rcount;\n#ifdef SL_INCLUDE_CSLIP\n\tif (sl->mode & (SL_MODE_ADAPTIVE | SL_MODE_CSLIP)) {\n\t\tunsigned char c = sl->rbuff[0];\n\t\tif (c & SL_TYPE_COMPRESSED_TCP) {\n\t\t\t/* ignore compressed packets when CSLIP is off */\n\t\t\tif (!(sl->mode & SL_MODE_CSLIP)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: compressed packet ignored\\n\", dev->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* make sure we've reserved enough space for uncompress\n\t\t\t   to use */\n\t\t\tif (count + 80 > sl->buffsize) {\n\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcount = slhc_uncompress(sl->slcomp, sl->rbuff, count);\n\t\t\tif (count <= 0)\n\t\t\t\treturn;\n\t\t} else if (c >= SL_TYPE_UNCOMPRESSED_TCP) {\n\t\t\tif (!(sl->mode & SL_MODE_CSLIP)) {\n\t\t\t\t/* turn on header compression */\n\t\t\t\tsl->mode |= SL_MODE_CSLIP;\n\t\t\t\tsl->mode &= ~SL_MODE_ADAPTIVE;\n\t\t\t\tprintk(KERN_INFO \"%s: header compression turned on\\n\", dev->name);\n\t\t\t}\n\t\t\tsl->rbuff[0] &= 0x4f;\n\t\t\tif (slhc_remember(sl->slcomp, sl->rbuff, count) <= 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n#endif  /* SL_INCLUDE_CSLIP */\n\n\tdev->stats.rx_bytes += count;\n\n\tskb = dev_alloc_skb(count);\n\tif (skb == NULL) {\n\t\tprintk(KERN_WARNING \"%s: memory squeeze, dropping packet.\\n\", dev->name);\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tskb->dev = dev;\n\tskb_put_data(skb, sl->rbuff, count);\n\tskb_reset_mac_header(skb);\n\tskb->protocol = htons(ETH_P_IP);\n\tnetif_rx(skb);\n\tdev->stats.rx_packets++;\n}\n\n/* Encapsulate one IP datagram and stuff into a TTY queue. */\nstatic void sl_encaps(struct slip *sl, unsigned char *icp, int len)\n{\n\tunsigned char *p;\n\tint actual, count;\n\n\tif (len > sl->mtu) {\t\t/* Sigh, shouldn't occur BUT ... */\n\t\tprintk(KERN_WARNING \"%s: truncating oversized transmit packet!\\n\", sl->dev->name);\n\t\tsl->dev->stats.tx_dropped++;\n\t\tsl_unlock(sl);\n\t\treturn;\n\t}\n\n\tp = icp;\n#ifdef SL_INCLUDE_CSLIP\n\tif (sl->mode & SL_MODE_CSLIP)\n\t\tlen = slhc_compress(sl->slcomp, p, len, sl->cbuff, &p, 1);\n#endif\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\tif (sl->mode & SL_MODE_SLIP6)\n\t\tcount = slip_esc6(p, sl->xbuff, len);\n\telse\n#endif\n\t\tcount = slip_esc(p, sl->xbuff, len);\n\n\t/* Order of next two lines is *very* important.\n\t * When we are sending a little amount of data,\n\t * the transfer may be completed inside the ops->write()\n\t * routine, because it's running with interrupts enabled.\n\t * In this case we *never* got WRITE_WAKEUP event,\n\t * if we did not request it before write operation.\n\t *       14 Oct 1994  Dmitry Gorodchanin.\n\t */\n\tset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tactual = sl->tty->ops->write(sl->tty, sl->xbuff, count);\n#ifdef SL_CHECK_TRANSMIT\n\tnetif_trans_update(sl->dev);\n#endif\n\tsl->xleft = count - actual;\n\tsl->xhead = sl->xbuff + actual;\n#ifdef CONFIG_SLIP_SMART\n\t/* VSV */\n\tclear_bit(SLF_OUTWAIT, &sl->flags);\t/* reset outfill flag */\n#endif\n}\n\n/* Write out any remaining transmit buffer. Scheduled when tty is writable */\nstatic void slip_transmit(struct work_struct *work)\n{\n\tstruct slip *sl = container_of(work, struct slip, tx_work);\n\tint actual;\n\n\tspin_lock_bh(&sl->lock);\n\t/* First make sure we're connected. */\n\tif (!sl->tty || sl->magic != SLIP_MAGIC || !netif_running(sl->dev)) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn;\n\t}\n\n\tif (sl->xleft <= 0)  {\n\t\t/* Now serial buffer is almost free & we can start\n\t\t * transmission of another packet */\n\t\tsl->dev->stats.tx_packets++;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t\tspin_unlock_bh(&sl->lock);\n\t\tsl_unlock(sl);\n\t\treturn;\n\t}\n\n\tactual = sl->tty->ops->write(sl->tty, sl->xhead, sl->xleft);\n\tsl->xleft -= actual;\n\tsl->xhead += actual;\n\tspin_unlock_bh(&sl->lock);\n}\n\n/*\n * Called by the driver when there's room for more data.\n * Schedule the transmit.\n */\nstatic void slip_write_wakeup(struct tty_struct *tty)\n{\n\tstruct slip *sl;\n\n\trcu_read_lock();\n\tsl = rcu_dereference(tty->disc_data);\n\tif (sl)\n\t\tschedule_work(&sl->tx_work);\n\trcu_read_unlock();\n}\n\nstatic void sl_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tspin_lock(&sl->lock);\n\n\tif (netif_queue_stopped(dev)) {\n\t\tif (!netif_running(dev) || !sl->tty)\n\t\t\tgoto out;\n\n\t\t/* May be we must check transmitter timeout here ?\n\t\t *      14 Oct 1994 Dmitry Gorodchanin.\n\t\t */\n#ifdef SL_CHECK_TRANSMIT\n\t\tif (time_before(jiffies, dev_trans_start(dev) + 20 * HZ))  {\n\t\t\t/* 20 sec timeout not reached */\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_WARNING \"%s: transmit timed out, %s?\\n\",\n\t\t\tdev->name,\n\t\t\t(tty_chars_in_buffer(sl->tty) || sl->xleft) ?\n\t\t\t\t\"bad line quality\" : \"driver error\");\n\t\tsl->xleft = 0;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t\tsl_unlock(sl);\n#endif\n\t}\nout:\n\tspin_unlock(&sl->lock);\n}\n\n\n/* Encapsulate an IP datagram and kick it into a TTY queue. */\nstatic netdev_tx_t\nsl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tspin_lock(&sl->lock);\n\tif (!netif_running(dev)) {\n\t\tspin_unlock(&sl->lock);\n\t\tprintk(KERN_WARNING \"%s: xmit call when iface is down\\n\", dev->name);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (sl->tty == NULL) {\n\t\tspin_unlock(&sl->lock);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tsl_lock(sl);\n\tdev->stats.tx_bytes += skb->len;\n\tsl_encaps(sl, skb->data, skb->len);\n\tspin_unlock(&sl->lock);\n\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n/******************************************\n *   Routines looking at netdevice side.\n ******************************************/\n\n/* Netdevice UP -> DOWN routine */\n\nstatic int\nsl_close(struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tspin_lock_bh(&sl->lock);\n\tif (sl->tty)\n\t\t/* TTY discipline is running. */\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tnetif_stop_queue(dev);\n\tsl->rcount   = 0;\n\tsl->xleft    = 0;\n\tspin_unlock_bh(&sl->lock);\n\n\treturn 0;\n}\n\n/* Netdevice DOWN -> UP routine */\n\nstatic int sl_open(struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tif (sl->tty == NULL)\n\t\treturn -ENODEV;\n\n\tsl->flags &= (1 << SLF_INUSE);\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n/* Netdevice change MTU request */\n\nstatic int sl_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\treturn sl_realloc_bufs(sl, new_mtu);\n}\n\n/* Netdevice get statistics request */\n\nstatic void\nsl_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct net_device_stats *devstats = &dev->stats;\n#ifdef SL_INCLUDE_CSLIP\n\tstruct slip *sl = netdev_priv(dev);\n\tstruct slcompress *comp = sl->slcomp;\n#endif\n\tstats->rx_packets     = devstats->rx_packets;\n\tstats->tx_packets     = devstats->tx_packets;\n\tstats->rx_bytes       = devstats->rx_bytes;\n\tstats->tx_bytes       = devstats->tx_bytes;\n\tstats->rx_dropped     = devstats->rx_dropped;\n\tstats->tx_dropped     = devstats->tx_dropped;\n\tstats->tx_errors      = devstats->tx_errors;\n\tstats->rx_errors      = devstats->rx_errors;\n\tstats->rx_over_errors = devstats->rx_over_errors;\n\n#ifdef SL_INCLUDE_CSLIP\n\tif (comp) {\n\t\t/* Generic compressed statistics */\n\t\tstats->rx_compressed   = comp->sls_i_compressed;\n\t\tstats->tx_compressed   = comp->sls_o_compressed;\n\n\t\t/* Are we really still needs this? */\n\t\tstats->rx_fifo_errors += comp->sls_i_compressed;\n\t\tstats->rx_dropped     += comp->sls_i_tossed;\n\t\tstats->tx_fifo_errors += comp->sls_o_compressed;\n\t\tstats->collisions     += comp->sls_o_misses;\n\t}\n#endif\n}\n\n/* Netdevice register callback */\n\nstatic int sl_init(struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\t/*\n\t *\tFinish setting up the DEVICE info.\n\t */\n\n\tdev->mtu\t\t= sl->mtu;\n\tdev->type\t\t= ARPHRD_SLIP + sl->mode;\n#ifdef SL_CHECK_TRANSMIT\n\tdev->watchdog_timeo\t= 20*HZ;\n#endif\n\treturn 0;\n}\n\n\nstatic void sl_uninit(struct net_device *dev)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\n\tsl_free_bufs(sl);\n}\n\n/* Hook the destructor so we can free slip devices at the right point in time */\nstatic void sl_free_netdev(struct net_device *dev)\n{\n\tint i = dev->base_addr;\n\n\tslip_devs[i] = NULL;\n}\n\nstatic const struct net_device_ops sl_netdev_ops = {\n\t.ndo_init\t\t= sl_init,\n\t.ndo_uninit\t  \t= sl_uninit,\n\t.ndo_open\t\t= sl_open,\n\t.ndo_stop\t\t= sl_close,\n\t.ndo_start_xmit\t\t= sl_xmit,\n\t.ndo_get_stats64        = sl_get_stats64,\n\t.ndo_change_mtu\t\t= sl_change_mtu,\n\t.ndo_tx_timeout\t\t= sl_tx_timeout,\n#ifdef CONFIG_SLIP_SMART\n\t.ndo_siocdevprivate\t= sl_siocdevprivate,\n#endif\n};\n\n\nstatic void sl_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &sl_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= sl_free_netdev;\n\n\tdev->hard_header_len\t= 0;\n\tdev->addr_len\t\t= 0;\n\tdev->tx_queue_len\t= 10;\n\n\t/* MTU range: 68 - 65534 */\n\tdev->min_mtu = 68;\n\tdev->max_mtu = 65534;\n\n\t/* New-style flags. */\n\tdev->flags\t\t= IFF_NOARP|IFF_POINTOPOINT|IFF_MULTICAST;\n}\n\n/******************************************\n  Routines looking at TTY side.\n ******************************************/\n\n\n/*\n * Handle the 'receiver data ready' interrupt.\n * This function is called by the 'tty_io' module in the kernel when\n * a block of SLIP data has been received, which can now be decapsulated\n * and sent on to some IP layer for further processing. This will not\n * be re-entered while running but other ldisc functions may be called\n * in parallel\n */\n\nstatic void slip_receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\tconst char *fp, int count)\n{\n\tstruct slip *sl = tty->disc_data;\n\n\tif (!sl || sl->magic != SLIP_MAGIC || !netif_running(sl->dev))\n\t\treturn;\n\n\t/* Read the characters out of the buffer */\n\twhile (count--) {\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SLF_ERROR, &sl->flags))\n\t\t\t\tsl->dev->stats.rx_errors++;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\t\tif (sl->mode & SL_MODE_SLIP6)\n\t\t\tslip_unesc6(sl, *cp++);\n\t\telse\n#endif\n\t\t\tslip_unesc(sl, *cp++);\n\t}\n}\n\n/************************************\n *  slip_open helper routines.\n ************************************/\n\n/* Collect hanged up channels */\nstatic void sl_sync(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slip\t  *sl;\n\n\tfor (i = 0; i < slip_maxdev; i++) {\n\t\tdev = slip_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty || sl->leased)\n\t\t\tcontinue;\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_close(dev);\n\t}\n}\n\n\n/* Find a free SLIP channel, and link in this `tty' line. */\nstatic struct slip *sl_alloc(void)\n{\n\tint i;\n\tchar name[IFNAMSIZ];\n\tstruct net_device *dev = NULL;\n\tstruct slip       *sl;\n\n\tfor (i = 0; i < slip_maxdev; i++) {\n\t\tdev = slip_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\t}\n\t/* Sorry, too many, all slots in use */\n\tif (i >= slip_maxdev)\n\t\treturn NULL;\n\n\tsprintf(name, \"sl%d\", i);\n\tdev = alloc_netdev(sizeof(*sl), name, NET_NAME_UNKNOWN, sl_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->base_addr  = i;\n\tsl = netdev_priv(dev);\n\n\t/* Initialize channel control data */\n\tsl->magic       = SLIP_MAGIC;\n\tsl->dev\t      \t= dev;\n\tspin_lock_init(&sl->lock);\n\tINIT_WORK(&sl->tx_work, slip_transmit);\n\tsl->mode        = SL_MODE_DEFAULT;\n#ifdef CONFIG_SLIP_SMART\n\t/* initialize timer_list struct */\n\ttimer_setup(&sl->keepalive_timer, sl_keepalive, 0);\n\ttimer_setup(&sl->outfill_timer, sl_outfill, 0);\n#endif\n\tslip_devs[i] = dev;\n\treturn sl;\n}\n\n/*\n * Open the high-level part of the SLIP channel.\n * This function is called by the TTY module when the\n * SLIP line discipline is called for.  Because we are\n * sure the tty line exists, we only have to link it to\n * a free SLIP channel...\n *\n * Called in process context serialized from other ldisc calls.\n */\n\nstatic int slip_open(struct tty_struct *tty)\n{\n\tstruct slip *sl;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\t/* RTnetlink lock is misused here to serialize concurrent\n\t   opens of slip channels. There are better ways, but it is\n\t   the simplest one.\n\t */\n\trtnl_lock();\n\n\t/* Collect hanged up channels. */\n\tsl_sync();\n\n\tsl = tty->disc_data;\n\n\terr = -EEXIST;\n\t/* First make sure we're not already connected. */\n\tif (sl && sl->magic == SLIP_MAGIC)\n\t\tgoto err_exit;\n\n\t/* OK.  Find a free SLIP channel to use. */\n\terr = -ENFILE;\n\tsl = sl_alloc();\n\tif (sl == NULL)\n\t\tgoto err_exit;\n\n\tsl->tty = tty;\n\ttty->disc_data = sl;\n\tsl->pid = current->pid;\n\n\tif (!test_bit(SLF_INUSE, &sl->flags)) {\n\t\t/* Perform the low-level SLIP initialization. */\n\t\terr = sl_alloc_bufs(sl, SL_MTU);\n\t\tif (err)\n\t\t\tgoto err_free_chan;\n\n\t\tset_bit(SLF_INUSE, &sl->flags);\n\n\t\terr = register_netdevice(sl->dev);\n\t\tif (err)\n\t\t\tgoto err_free_bufs;\n\t}\n\n#ifdef CONFIG_SLIP_SMART\n\tif (sl->keepalive) {\n\t\tsl->keepalive_timer.expires = jiffies + sl->keepalive * HZ;\n\t\tadd_timer(&sl->keepalive_timer);\n\t}\n\tif (sl->outfill) {\n\t\tsl->outfill_timer.expires = jiffies + sl->outfill * HZ;\n\t\tadd_timer(&sl->outfill_timer);\n\t}\n#endif\n\n\t/* Done.  We have linked the TTY line to a channel. */\n\trtnl_unlock();\n\ttty->receive_room = 65536;\t/* We don't flow control */\n\n\t/* TTY layer expects 0 on success */\n\treturn 0;\n\nerr_free_bufs:\n\tsl_free_bufs(sl);\n\nerr_free_chan:\n\tsl->tty = NULL;\n\ttty->disc_data = NULL;\n\tclear_bit(SLF_INUSE, &sl->flags);\n\tsl_free_netdev(sl->dev);\n\t/* do not call free_netdev before rtnl_unlock */\n\trtnl_unlock();\n\tfree_netdev(sl->dev);\n\treturn err;\n\nerr_exit:\n\trtnl_unlock();\n\n\t/* Count references from TTY module */\n\treturn err;\n}\n\n/*\n * Close down a SLIP channel.\n * This means flushing out any pending queues, and then returning. This\n * call is serialized against other ldisc functions.\n *\n * We also use this method fo a hangup event\n */\n\nstatic void slip_close(struct tty_struct *tty)\n{\n\tstruct slip *sl = tty->disc_data;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLIP_MAGIC || sl->tty != tty)\n\t\treturn;\n\n\tspin_lock_bh(&sl->lock);\n\trcu_assign_pointer(tty->disc_data, NULL);\n\tsl->tty = NULL;\n\tspin_unlock_bh(&sl->lock);\n\n\tsynchronize_rcu();\n\tflush_work(&sl->tx_work);\n\n\t/* VSV = very important to remove timers */\n#ifdef CONFIG_SLIP_SMART\n\tdel_timer_sync(&sl->keepalive_timer);\n\tdel_timer_sync(&sl->outfill_timer);\n#endif\n\t/* Flush network side */\n\tunregister_netdev(sl->dev);\n\t/* This will complete via sl_free_netdev */\n}\n\nstatic void slip_hangup(struct tty_struct *tty)\n{\n\tslip_close(tty);\n}\n /************************************************************************\n  *\t\t\tSTANDARD SLIP ENCAPSULATION\t\t  \t *\n  ************************************************************************/\n\nstatic int slip_esc(unsigned char *s, unsigned char *d, int len)\n{\n\tunsigned char *ptr = d;\n\tunsigned char c;\n\n\t/*\n\t * Send an initial END character to flush out any\n\t * data that may have accumulated in the receiver\n\t * due to line noise.\n\t */\n\n\t*ptr++ = END;\n\n\t/*\n\t * For each byte in the packet, send the appropriate\n\t * character sequence, according to the SLIP protocol.\n\t */\n\n\twhile (len-- > 0) {\n\t\tswitch (c = *s++) {\n\t\tcase END:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_END;\n\t\t\tbreak;\n\t\tcase ESC:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_ESC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*ptr++ = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*ptr++ = END;\n\treturn ptr - d;\n}\n\nstatic void slip_unesc(struct slip *sl, unsigned char s)\n{\n\n\tswitch (s) {\n\tcase END:\n#ifdef CONFIG_SLIP_SMART\n\t\t/* drop keeptest bit = VSV */\n\t\tif (test_bit(SLF_KEEPTEST, &sl->flags))\n\t\t\tclear_bit(SLF_KEEPTEST, &sl->flags);\n#endif\n\n\t\tif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\n\t\t    (sl->rcount > 2))\n\t\t\tsl_bump(sl);\n\t\tclear_bit(SLF_ESCAPE, &sl->flags);\n\t\tsl->rcount = 0;\n\t\treturn;\n\n\tcase ESC:\n\t\tset_bit(SLF_ESCAPE, &sl->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(SLF_ESCAPE, &sl->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(SLF_ESCAPE, &sl->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\tif (!test_bit(SLF_ERROR, &sl->flags))  {\n\t\tif (sl->rcount < sl->buffsize)  {\n\t\t\tsl->rbuff[sl->rcount++] = s;\n\t\t\treturn;\n\t\t}\n\t\tsl->dev->stats.rx_over_errors++;\n\t\tset_bit(SLF_ERROR, &sl->flags);\n\t}\n}\n\n\n#ifdef CONFIG_SLIP_MODE_SLIP6\n/************************************************************************\n *\t\t\t 6 BIT SLIP ENCAPSULATION\t\t\t*\n ************************************************************************/\n\nstatic int slip_esc6(unsigned char *s, unsigned char *d, int len)\n{\n\tunsigned char *ptr = d;\n\tunsigned char c;\n\tint i;\n\tunsigned short v = 0;\n\tshort bits = 0;\n\n\t/*\n\t * Send an initial END character to flush out any\n\t * data that may have accumulated in the receiver\n\t * due to line noise.\n\t */\n\n\t*ptr++ = 0x70;\n\n\t/*\n\t * Encode the packet into printable ascii characters\n\t */\n\n\tfor (i = 0; i < len; ++i) {\n\t\tv = (v << 8) | s[i];\n\t\tbits += 8;\n\t\twhile (bits >= 6) {\n\t\t\tbits -= 6;\n\t\t\tc = 0x30 + ((v >> bits) & 0x3F);\n\t\t\t*ptr++ = c;\n\t\t}\n\t}\n\tif (bits) {\n\t\tc = 0x30 + ((v << (6 - bits)) & 0x3F);\n\t\t*ptr++ = c;\n\t}\n\t*ptr++ = 0x70;\n\treturn ptr - d;\n}\n\nstatic void slip_unesc6(struct slip *sl, unsigned char s)\n{\n\tunsigned char c;\n\n\tif (s == 0x70) {\n#ifdef CONFIG_SLIP_SMART\n\t\t/* drop keeptest bit = VSV */\n\t\tif (test_bit(SLF_KEEPTEST, &sl->flags))\n\t\t\tclear_bit(SLF_KEEPTEST, &sl->flags);\n#endif\n\n\t\tif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\n\t\t    (sl->rcount > 2))\n\t\t\tsl_bump(sl);\n\t\tsl->rcount = 0;\n\t\tsl->xbits = 0;\n\t\tsl->xdata = 0;\n\t} else if (s >= 0x30 && s < 0x70) {\n\t\tsl->xdata = (sl->xdata << 6) | ((s - 0x30) & 0x3F);\n\t\tsl->xbits += 6;\n\t\tif (sl->xbits >= 8) {\n\t\t\tsl->xbits -= 8;\n\t\t\tc = (unsigned char)(sl->xdata >> sl->xbits);\n\t\t\tif (!test_bit(SLF_ERROR, &sl->flags))  {\n\t\t\t\tif (sl->rcount < sl->buffsize)  {\n\t\t\t\t\tsl->rbuff[sl->rcount++] = c;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsl->dev->stats.rx_over_errors++;\n\t\t\t\tset_bit(SLF_ERROR, &sl->flags);\n\t\t\t}\n\t\t}\n\t}\n}\n#endif /* CONFIG_SLIP_MODE_SLIP6 */\n\n/* Perform I/O control on an active SLIP channel. */\nstatic int slip_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct slip *sl = tty->disc_data;\n\tunsigned int tmp;\n\tint __user *p = (int __user *)arg;\n\n\t/* First make sure we're connected. */\n\tif (!sl || sl->magic != SLIP_MAGIC)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGIFNAME:\n\t\ttmp = strlen(sl->dev->name) + 1;\n\t\tif (copy_to_user((void __user *)arg, sl->dev->name, tmp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCGIFENCAP:\n\t\tif (put_user(sl->mode, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCSIFENCAP:\n\t\tif (get_user(tmp, p))\n\t\t\treturn -EFAULT;\n#ifndef SL_INCLUDE_CSLIP\n\t\tif (tmp & (SL_MODE_CSLIP|SL_MODE_ADAPTIVE))\n\t\t\treturn -EINVAL;\n#else\n\t\tif ((tmp & (SL_MODE_ADAPTIVE | SL_MODE_CSLIP)) ==\n\t\t    (SL_MODE_ADAPTIVE | SL_MODE_CSLIP))\n\t\t\t/* return -EINVAL; */\n\t\t\ttmp &= ~SL_MODE_ADAPTIVE;\n#endif\n#ifndef CONFIG_SLIP_MODE_SLIP6\n\t\tif (tmp & SL_MODE_SLIP6)\n\t\t\treturn -EINVAL;\n#endif\n\t\tsl->mode = tmp;\n\t\tsl->dev->type = ARPHRD_SLIP + sl->mode;\n\t\treturn 0;\n\n\tcase SIOCSIFHWADDR:\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SLIP_SMART\n\t/* VSV changes start here */\n\tcase SIOCSKEEPALIVE:\n\t\tif (get_user(tmp, p))\n\t\t\treturn -EFAULT;\n\t\tif (tmp > 255) /* max for unchar */\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_bh(&sl->lock);\n\t\tif (!sl->tty) {\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tsl->keepalive = (u8)tmp;\n\t\tif (sl->keepalive != 0) {\n\t\t\tmod_timer(&sl->keepalive_timer,\n\t\t\t\t\tjiffies + sl->keepalive * HZ);\n\t\t\tset_bit(SLF_KEEPTEST, &sl->flags);\n\t\t} else\n\t\t\tdel_timer(&sl->keepalive_timer);\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn 0;\n\n\tcase SIOCGKEEPALIVE:\n\t\tif (put_user(sl->keepalive, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCSOUTFILL:\n\t\tif (get_user(tmp, p))\n\t\t\treturn -EFAULT;\n\t\tif (tmp > 255) /* max for unchar */\n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&sl->lock);\n\t\tif (!sl->tty) {\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tsl->outfill = (u8)tmp;\n\t\tif (sl->outfill != 0) {\n\t\t\tmod_timer(&sl->outfill_timer,\n\t\t\t\t\t\tjiffies + sl->outfill * HZ);\n\t\t\tset_bit(SLF_OUTWAIT, &sl->flags);\n\t\t} else\n\t\t\tdel_timer(&sl->outfill_timer);\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn 0;\n\n\tcase SIOCGOUTFILL:\n\t\tif (put_user(sl->outfill, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t/* VSV changes end */\n#endif\n\tdefault:\n\t\treturn tty_mode_ioctl(tty, cmd, arg);\n\t}\n}\n\n/* VSV changes start here */\n#ifdef CONFIG_SLIP_SMART\n/* function sl_siocdevprivate called from net/core/dev.c\n   to allow get/set outfill/keepalive parameter\n   by ifconfig                                 */\n\nstatic int sl_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t     void __user *data, int cmd)\n{\n\tstruct slip *sl = netdev_priv(dev);\n\tunsigned long *p = (unsigned long *)&rq->ifr_ifru;\n\n\tif (sl == NULL)\t\t/* Allocation failed ?? */\n\t\treturn -ENODEV;\n\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_bh(&sl->lock);\n\n\tif (!sl->tty) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (cmd) {\n\tcase SIOCSKEEPALIVE:\n\t\t/* max for unchar */\n\t\tif ((unsigned)*p > 255) {\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsl->keepalive = (u8)*p;\n\t\tif (sl->keepalive != 0) {\n\t\t\tsl->keepalive_timer.expires =\n\t\t\t\t\t\tjiffies + sl->keepalive * HZ;\n\t\t\tmod_timer(&sl->keepalive_timer,\n\t\t\t\t\t\tjiffies + sl->keepalive * HZ);\n\t\t\tset_bit(SLF_KEEPTEST, &sl->flags);\n\t\t} else\n\t\t\tdel_timer(&sl->keepalive_timer);\n\t\tbreak;\n\n\tcase SIOCGKEEPALIVE:\n\t\t*p = sl->keepalive;\n\t\tbreak;\n\n\tcase SIOCSOUTFILL:\n\t\tif ((unsigned)*p > 255) { /* max for unchar */\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsl->outfill = (u8)*p;\n\t\tif (sl->outfill != 0) {\n\t\t\tmod_timer(&sl->outfill_timer,\n\t\t\t\t\t\tjiffies + sl->outfill * HZ);\n\t\t\tset_bit(SLF_OUTWAIT, &sl->flags);\n\t\t} else\n\t\t\tdel_timer(&sl->outfill_timer);\n\t\tbreak;\n\n\tcase SIOCGOUTFILL:\n\t\t*p = sl->outfill;\n\t\tbreak;\n\n\tcase SIOCSLEASE:\n\t\t/* Resolve race condition, when ioctl'ing hanged up\n\t\t   and opened by another process device.\n\t\t */\n\t\tif (sl->tty != current->signal->tty &&\n\t\t\t\t\t\tsl->pid != current->pid) {\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tsl->leased = 0;\n\t\tif (*p)\n\t\t\tsl->leased = 1;\n\t\tbreak;\n\n\tcase SIOCGLEASE:\n\t\t*p = sl->leased;\n\t}\n\tspin_unlock_bh(&sl->lock);\n\treturn 0;\n}\n#endif\n/* VSV changes end */\n\nstatic struct tty_ldisc_ops sl_ldisc = {\n\t.owner \t\t= THIS_MODULE,\n\t.num\t\t= N_SLIP,\n\t.name \t\t= \"slip\",\n\t.open \t\t= slip_open,\n\t.close\t \t= slip_close,\n\t.hangup\t \t= slip_hangup,\n\t.ioctl\t\t= slip_ioctl,\n\t.receive_buf\t= slip_receive_buf,\n\t.write_wakeup\t= slip_write_wakeup,\n};\n\nstatic int __init slip_init(void)\n{\n\tint status;\n\n\tif (slip_maxdev < 4)\n\t\tslip_maxdev = 4; /* Sanity */\n\n\tprintk(KERN_INFO \"SLIP: version %s (dynamic channels, max=%d)\"\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\t       \" (6 bit encapsulation enabled)\"\n#endif\n\t       \".\\n\",\n\t       SLIP_VERSION, slip_maxdev);\n#if defined(SL_INCLUDE_CSLIP)\n\tprintk(KERN_INFO \"CSLIP: code copyright 1989 Regents of the University of California.\\n\");\n#endif\n#ifdef CONFIG_SLIP_SMART\n\tprintk(KERN_INFO \"SLIP linefill/keepalive option.\\n\");\n#endif\n\n\tslip_devs = kcalloc(slip_maxdev, sizeof(struct net_device *),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!slip_devs)\n\t\treturn -ENOMEM;\n\n\t/* Fill in our line protocol discipline, and register it */\n\tstatus = tty_register_ldisc(&sl_ldisc);\n\tif (status != 0) {\n\t\tprintk(KERN_ERR \"SLIP: can't register line discipline (err = %d)\\n\", status);\n\t\tkfree(slip_devs);\n\t}\n\treturn status;\n}\n\nstatic void __exit slip_exit(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slip *sl;\n\tunsigned long timeout = jiffies + HZ;\n\tint busy = 0;\n\n\tif (slip_devs == NULL)\n\t\treturn;\n\n\t/* First of all: check for active disciplines and hangup them.\n\t */\n\tdo {\n\t\tif (busy)\n\t\t\tmsleep_interruptible(100);\n\n\t\tbusy = 0;\n\t\tfor (i = 0; i < slip_maxdev; i++) {\n\t\t\tdev = slip_devs[i];\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\t\t\tsl = netdev_priv(dev);\n\t\t\tspin_lock_bh(&sl->lock);\n\t\t\tif (sl->tty) {\n\t\t\t\tbusy++;\n\t\t\t\ttty_hangup(sl->tty);\n\t\t\t}\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t}\n\t} while (busy && time_before(jiffies, timeout));\n\n\t/* FIXME: hangup is async so we should wait when doing this second\n\t   phase */\n\n\tfor (i = 0; i < slip_maxdev; i++) {\n\t\tdev = slip_devs[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\t\tslip_devs[i] = NULL;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty) {\n\t\t\tprintk(KERN_ERR \"%s: tty discipline still running\\n\",\n\t\t\t       dev->name);\n\t\t}\n\n\t\tunregister_netdev(dev);\n\t}\n\n\tkfree(slip_devs);\n\tslip_devs = NULL;\n\n\ttty_unregister_ldisc(&sl_ldisc);\n}\n\nmodule_init(slip_init);\nmodule_exit(slip_exit);\n\n#ifdef CONFIG_SLIP_SMART\n/*\n * This is start of the code for multislip style line checking\n * added by Stanislav Voronyi. All changes before marked VSV\n */\n\nstatic void sl_outfill(struct timer_list *t)\n{\n\tstruct slip *sl = from_timer(sl, t, outfill_timer);\n\n\tspin_lock(&sl->lock);\n\n\tif (sl->tty == NULL)\n\t\tgoto out;\n\n\tif (sl->outfill) {\n\t\tif (test_bit(SLF_OUTWAIT, &sl->flags)) {\n\t\t\t/* no packets were transmitted, do outfill */\n#ifdef CONFIG_SLIP_MODE_SLIP6\n\t\t\tunsigned char s = (sl->mode & SL_MODE_SLIP6)?0x70:END;\n#else\n\t\t\tunsigned char s = END;\n#endif\n\t\t\t/* put END into tty queue. Is it right ??? */\n\t\t\tif (!netif_queue_stopped(sl->dev)) {\n\t\t\t\t/* if device busy no outfill */\n\t\t\t\tsl->tty->ops->write(sl->tty, &s, 1);\n\t\t\t}\n\t\t} else\n\t\t\tset_bit(SLF_OUTWAIT, &sl->flags);\n\n\t\tmod_timer(&sl->outfill_timer, jiffies+sl->outfill*HZ);\n\t}\nout:\n\tspin_unlock(&sl->lock);\n}\n\nstatic void sl_keepalive(struct timer_list *t)\n{\n\tstruct slip *sl = from_timer(sl, t, keepalive_timer);\n\n\tspin_lock(&sl->lock);\n\n\tif (sl->tty == NULL)\n\t\tgoto out;\n\n\tif (sl->keepalive) {\n\t\tif (test_bit(SLF_KEEPTEST, &sl->flags)) {\n\t\t\t/* keepalive still high :(, we must hangup */\n\t\t\tif (sl->outfill)\n\t\t\t\t/* outfill timer must be deleted too */\n\t\t\t\t(void)del_timer(&sl->outfill_timer);\n\t\t\tprintk(KERN_DEBUG \"%s: no packets received during keepalive timeout, hangup.\\n\", sl->dev->name);\n\t\t\t/* this must hangup tty & close slip */\n\t\t\ttty_hangup(sl->tty);\n\t\t\t/* I think we need not something else */\n\t\t\tgoto out;\n\t\t} else\n\t\t\tset_bit(SLF_KEEPTEST, &sl->flags);\n\n\t\tmod_timer(&sl->keepalive_timer, jiffies+sl->keepalive*HZ);\n\t}\nout:\n\tspin_unlock(&sl->lock);\n}\n\n#endif\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_SLIP);\n"], "filenames": ["drivers/net/slip/slip.c"], "buggy_code_start_loc": [472], "buggy_code_end_loc": [473], "fixing_code_start_loc": [472], "fixing_code_end_loc": [473], "type": "CWE-416", "message": "A flaw was found in the Linux kernel. A NULL pointer dereference may occur while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c. This issue could allow an attacker to crash the system or leak internal kernel information.", "other": {"cve": {"id": "CVE-2022-41858", "sourceIdentifier": "secalert@redhat.com", "published": "2023-01-17T18:15:11.140", "lastModified": "2023-02-23T19:15:11.400", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in the Linux kernel. A NULL pointer dereference may occur while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c. This issue could allow an attacker to crash the system or leak internal kernel information."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.18", "matchCriteriaId": "FE93544F-B946-47CF-9697-FBF3484FCB92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc1:*:*:*:*:*:*", "matchCriteriaId": "6AD94161-84BB-42E6-9882-4FC0C42E9FC1"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230223-0006/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798"}}