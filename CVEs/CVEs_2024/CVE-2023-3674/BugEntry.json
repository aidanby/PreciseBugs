{"buggy_code": ["import os\nimport string\nimport struct\nfrom typing import Any, Dict, List, Optional, Tuple, Union\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives import hashes, hmac, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec, padding\nfrom cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey\nfrom cryptography.hazmat.primitives.asymmetric.utils import Prehashed\nfrom cryptography.hazmat.primitives.ciphers import Cipher, modes\n\nfrom keylime import config, crypto, json, keylime_logging\nfrom keylime.tpm import ec_crypto_helper, tpm2_objects\n\nlogger = keylime_logging.init_logging(\"tpm_util\")\n\nSupportedKeyTypes = Union[RSAPublicKey, EllipticCurvePublicKey]\n\n\ndef verify(pubkey: SupportedKeyTypes, sig: bytes, digest: bytes, hashfunc: hashes.HashAlgorithm) -> None:\n    \"\"\"Do signature verification with the given public key\"\"\"\n    if isinstance(pubkey, RSAPublicKey):\n        pubkey.verify(sig, digest, padding.PKCS1v15(), Prehashed(hashfunc))\n    elif isinstance(pubkey, EllipticCurvePublicKey):\n        pubkey.verify(sig, digest, ec.ECDSA(Prehashed(hashfunc)))\n\n\ndef __get_pcrs_from_blob(pcrblob: bytes) -> Tuple[int, Dict[int, int], List[bytes]]:\n    \"\"\"This function is specific to the Intel tools with data in little endian format.\n    Data structures were not marshalled but written right from memory.\"\"\"\n    # TPML_PCR_SELECTION:count\n    (pcr_select_count,) = struct.unpack_from(\"<I\", pcrblob, 0)\n\n    o = 4\n    # TPML_PCR_SELECTION:TPMS_PCR_SELECTION[HASH_COUNT]\n    tpml_pcr_selection: Dict[int, int] = {}\n    for _ in range(0, 16):\n        hash_alg, size_of_select = struct.unpack_from(\"<HB\", pcrblob, o)\n        if size_of_select not in [0, 3]:\n            raise ValueError(f\"size_of_select must be either 0 or 3 but it is {size_of_select}\")\n        o = o + 3\n\n        if size_of_select == 3:\n            (pcr_select_bytes,) = struct.unpack_from(\"3s\", pcrblob, o)\n            pcr_select = pcr_select_bytes[0] | pcr_select_bytes[1] << 8 | pcr_select_bytes[2] << 16\n        else:\n            pcr_select = 0\n\n        tpml_pcr_selection[hash_alg] = pcr_select\n\n        # always advance by size_of_select = 3 and 2 bytes alignment\n        o = o + 3 + 2\n\n    # Number of subsequent TPML_DIGEST's\n    (pcrs_count,) = struct.unpack_from(\"<I\", pcrblob, o)\n    o = o + 4\n\n    pcr_values: List[bytes] = []\n\n    for _ in range(0, pcrs_count):\n        # TPML_DIGEST::count\n        (_,) = struct.unpack_from(\"<I\", pcrblob, o)\n        o = o + 4\n\n        # TPML_DIGEST::TPM2B_DIGEST[8]\n        for _ in range(0, 8):\n            (sz,) = struct.unpack_from(\"<H\", pcrblob, o)\n            o = o + 2\n            if sz:\n                (pcr_value,) = struct.unpack_from(f\"{sz}s\", pcrblob, o)\n                pcr_values.append(pcr_value)\n            # Always advance by the size of TPMU_HA (= size of SHA512)\n            o = o + 64\n\n    if o != len(pcrblob):\n        raise ValueError(\"Failed to parse the entire pcrblob\")\n\n    return pcr_select_count, tpml_pcr_selection, pcr_values\n\n\ndef __hash_pcr_banks(\n    hash_alg: int, pcr_select_count: int, tpml_pcr_selection: Dict[int, int], pcr_values: List[bytes]\n) -> Tuple[bytes, Dict[int, str]]:\n    \"\"\"From the tpml_pcr_selection determine which PCRs were quoted and hash these PCRs to get\n    the hash that was used for the quote. Build a dict that contains the PCR values.\"\"\"\n    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)\n    if not hashfunc:\n        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")\n\n    digest = hashes.Hash(hashfunc, backend=backends.default_backend())\n\n    idx = 0\n    pcrs_dict: Dict[int, str] = {}\n\n    for _ in range(0, pcr_select_count):\n        for pcr_id in range(0, 24):\n            if tpml_pcr_selection[hash_alg] & (1 << pcr_id) == 0:\n                continue\n            if idx >= len(pcr_values):\n                raise ValueError(f\"pcr_values list is too short to get item {idx}\")\n            digest.update(pcr_values[idx])\n            pcrs_dict[pcr_id] = pcr_values[idx].hex()\n            idx = idx + 1\n\n    if idx != len(pcr_values):\n        raise ValueError(\"Did not consume all entries in pcr_values list\")\n\n    quote_digest = digest.finalize()\n\n    return quote_digest, pcrs_dict\n\n\ndef __get_and_hash_pcrs(pcrblob: bytes, hash_alg: int) -> Tuple[bytes, Dict[int, str]]:\n    pcr_select_count, tpml_pcr_selection, pcr_values = __get_pcrs_from_blob(pcrblob)\n    return __hash_pcr_banks(hash_alg, pcr_select_count, tpml_pcr_selection, pcr_values)\n\n\ndef checkquote(\n    aikblob: bytes, nonce: str, sigblob: bytes, quoteblob: bytes, pcrblob: bytes, exp_hash_alg: str\n) -> Dict[int, str]:\n    \"\"\"Check the given quote by checking the signature, then the nonce and then the used hash\n\n    Parameters\n    ----------\n    aikblob: PEM-formatted public RSA or EC key\n    nonce: The nonce that was used during the quote\n    sigblob: Signature blob containing signature algorithm, hash used for signing, and plain signature\n    quoteblob: Marshalled TPMS_ATTEST\n    pcrblob: The state of the PCRs that were quoted; Intel tpm2-tools specific format\n    exp_hash_alg: The hash that was expected to have been used for quoting\n    \"\"\"\n    sig_alg, hash_alg, sig_size = struct.unpack_from(\">HHH\", sigblob, 0)\n\n    (signature,) = struct.unpack_from(f\"{sig_size}s\", sigblob, 6)\n\n    pubkey = serialization.load_pem_public_key(aikblob, backend=backends.default_backend())\n    if not isinstance(pubkey, (RSAPublicKey, EllipticCurvePublicKey)):\n        raise ValueError(f\"Unsupported key type {type(pubkey).__name__}\")\n\n    if isinstance(pubkey, RSAPublicKey) and sig_alg not in [tpm2_objects.TPM_ALG_RSASSA]:\n        raise ValueError(f\"Unsupported quote signature algorithm '{sig_alg:#x}' for RSA keys\")\n    if isinstance(pubkey, EllipticCurvePublicKey) and sig_alg not in [tpm2_objects.TPM_ALG_ECDSA]:\n        raise ValueError(f\"Unsupported quote signature algorithm '{sig_alg:#x}' for EC keys\")\n\n    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)\n    if not hashfunc:\n        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")\n    if hashfunc.name != exp_hash_alg:\n        raise ValueError(f\"Quote was expected to use {exp_hash_alg} but used {hashfunc.name} instead\")\n\n    digest = hashes.Hash(hashfunc, backend=backends.default_backend())\n    digest.update(quoteblob)\n    quote_digest = digest.finalize()\n\n    try:\n        verify(pubkey, signature, quote_digest, hashfunc)\n    except InvalidSignature:\n        logger.error(\"Invalid quote signature!\")\n\n    # Check that reported nonce is expected one\n    retDict = tpm2_objects.unmarshal_tpms_attest(quoteblob)\n    extradata = retDict[\"extraData\"]\n    if extradata.decode(\"utf-8\") != nonce:\n        raise Exception(\"The nonce from the attestation differs from the expected nonce\")\n\n    # Check that correct quote_digest was used which is equivalent to hash(quoteblob)\n    compare_digest, pcrs_dict = __get_and_hash_pcrs(pcrblob, hash_alg)\n    if retDict[\"attested.quote.pcrDigest\"] != compare_digest:\n        raise Exception(\"The digest used for quoting is different than the one that was calculated\")\n\n    return pcrs_dict\n\n\ndef label_to_bytes(label: str) -> bytes:\n    return bytes(label, \"UTF-8\") + b\"\\x00\"\n\n\ndef makecredential(ek_tpm: bytes, challenge: bytes, aik_name: bytes) -> bytes:\n    \"\"\"TPM_MakeCredential implementation\n\n    Parameters\n    ----------\n    ek_tpm: marshalled TPMT_PUBKEY\n    challenge: random 'password'\n    aik_name: name of the object (AIK)\n    \"\"\"\n    public_key, hash_alg = tpm2_objects.pubkey_parms_from_tpm2b_public(ek_tpm)\n\n    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)\n    if not hashfunc:\n        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")\n\n    if isinstance(public_key, RSAPublicKey):\n        random = os.urandom(hashfunc.digest_size)\n\n        secret = public_key.encrypt(\n            random,\n            padding.OAEP(mgf=padding.MGF1(algorithm=hashfunc), algorithm=hashfunc, label=label_to_bytes(\"IDENTITY\")),\n        )\n    elif isinstance(public_key, EllipticCurvePublicKey):\n        random, secret = crypt_secret_encrypt_ecc(public_key, hashfunc)\n    else:\n        raise ValueError(f\"Unsupported public key type {type(public_key)} for makecredential\")\n\n    credentialblob = secret_to_credential(challenge, aik_name, random, ek_tpm, hashfunc)\n\n    # Create tpm2-tools-specific result format\n    hdr = struct.pack(\">II\", 0xBADCC0DE, 1)\n    tail = struct.pack(f\">H{len(secret)}s\", len(secret), secret)\n\n    return hdr + credentialblob + tail\n\n\ndef crypt_secret_encrypt_ecc(public_key: EllipticCurvePublicKey, hashfunc: hashes.HashAlgorithm) -> Tuple[bytes, bytes]:\n    my_private_key = ec.generate_private_key(public_key.curve)\n\n    my_public_key = my_private_key.public_key()\n    point = tpm2_objects.tpms_ecc_point_marshal(my_public_key)\n\n    ecc_secret_x = ec_crypto_helper.EcCryptoHelper.get_instance().point_multiply_x(public_key, my_private_key)\n\n    digest_size = hashfunc.digest_size\n\n    x = my_public_key.public_numbers().x\n    party_x = x.to_bytes((x.bit_length() + 7) >> 3, \"big\")\n\n    x = public_key.public_numbers().x\n    party_y = x.to_bytes((x.bit_length() + 7) >> 3, \"big\")\n\n    data = crypt_kdfe(hashfunc, ecc_secret_x, \"IDENTITY\", party_x, party_y, digest_size << 3)\n\n    return data, point\n\n\ndef secret_to_credential(\n    secret: bytes, name: bytes, seed: bytes, ek_tpm: bytes, hashfunc: hashes.HashAlgorithm\n) -> bytes:\n    \"\"\"TPM 2's SecretToCredential\n\n    Parameters\n    ----------\n    secret: the secret\n    name: name of the object\n    seed: external seed\n    ek_tpm: marshalled TPMT_PUBKEY\n    hashfunc: the hash function used by the public key (extracted from ek_tpm)\n    \"\"\"\n    # sensitive data is the 2nd part in TPM2B_ID_OBJECT\n    sensitive_data_2b = struct.pack(f\">H{len(secret)}s\", len(secret), secret)\n    integrity, sensitive_data_enc = produce_outer_wrap(ek_tpm, name, hashfunc, seed, sensitive_data_2b)\n\n    tpms_id_object = struct.pack(\n        f\">H{len(integrity)}s{len(sensitive_data_enc)}s\",\n        len(integrity),\n        integrity,\n        sensitive_data_enc,\n    )\n\n    return struct.pack(f\">H{len(tpms_id_object)}s\", len(tpms_id_object), tpms_id_object)\n\n\ndef produce_outer_wrap(\n    ek_tpm: bytes,\n    name: bytes,\n    hashfunc: hashes.HashAlgorithm,\n    seed: bytes,\n    sensitive_data_2b: bytes,\n) -> Tuple[bytes, bytes]:\n    \"\"\"TPM 2's ProduceOuterWrap implementing encrypt-then-MAC of a secret\n\n    Parameters\n    ----------\n    ek_tpm: marshalled TPMT_PUBKEY\n    name: name of the object\n    hashfunc: the hash function used by the public key (extracted from ek_tpm)\n    seed: external seed\n    sensitive_data_2b: marshalled TPM2B buffer holding a secret\n    \"\"\"\n    symkey, sym_alg = compute_protection_key_parms(ek_tpm, hashfunc, name, seed)\n\n    # Encrypt inner buffer\n    symcipherfunc = tpm2_objects.SYMCIPHER_FUNCS.get(sym_alg)\n    if not symcipherfunc:\n        raise ValueError(f\"Unsupported symmetric cipher with Id {sym_alg:#x} was requested\")\n\n    symcipher = symcipherfunc(symkey)\n    block_size = symcipher.block_size >> 3\n    encryptor = Cipher(symcipher, modes.CFB(b\"\\x00\" * block_size)).encryptor()\n    ciphertext = encryptor.update(sensitive_data_2b) + encryptor.finalize()\n\n    # Compute outer integrity\n    hmac_signature = compute_outer_integrity(name, hashfunc, seed, ciphertext)\n\n    return hmac_signature, ciphertext\n\n\ndef compute_outer_integrity(\n    name: bytes,\n    hashfunc: hashes.HashAlgorithm,\n    seed: bytes,\n    ciphertext: bytes,\n) -> bytes:\n    \"\"\"TPM 2's ComputeOuterIntegrity HMAC'ing a ciphertext\n\n    Parameters\n    ----------\n    name: name of the object; this will be part of the HMAC'ed data\n    hashfunc: hash function to use for HMAC\n    seed: external seed\n    ciphertext: ciphertext to HMAC\n    \"\"\"\n    digest_size = hashfunc.digest_size\n\n    hmac_key = crypt_kdfa(hashfunc, seed, \"INTEGRITY\", b\"\", b\"\", digest_size << 3)\n\n    h = hmac.HMAC(hmac_key, hashfunc)\n    h.update(ciphertext)\n    h.update(name)\n    return h.finalize()\n\n\ndef compute_protection_key_parms(\n    ek_tpm: bytes, hashfunc: hashes.HashAlgorithm, name: bytes, seed: bytes\n) -> Tuple[bytes, int]:\n    \"\"\"TPM 2's ComputeProtectionKeyParms deriving a symmetric key using KDFa\n\n    Parameters\n    ----------\n    ek_tpm: marshalled TPMT_PUBKEY\n    hashfunc: hash function to use for key derivation\n    name: name of the object\n    seed: external seed\n    \"\"\"\n    assert len(seed) > 0\n\n    sym_alg, symkey_bits = tpm2_objects.get_tpm2b_public_symkey_params(ek_tpm)\n\n    symkey = crypt_kdfa(hashfunc, seed, \"STORAGE\", name, b\"\", symkey_bits)\n\n    return symkey, sym_alg\n\n\ndef crypt_kdfa(\n    hashfunc: hashes.HashAlgorithm,\n    key: bytes,\n    label: str,\n    context_u: bytes,\n    context_v: bytes,\n    size_in_bits: int,\n) -> bytes:\n    \"\"\"TPM 2's KDFa\n\n    Parameters\n    ----------\n    hashfunc: hash function\n    key: key to use for HMAC\n    label: a label to add to the HMAC\n    context_u: context to add to the HMAC\n    context_v: context to add to the HMAC\n    size_in_bits: how many bits of random data to generate\n    \"\"\"\n    size_in_bytes = (size_in_bits + 7) >> 3\n    label_bytes = label_to_bytes(label)\n    context = context_u + context_v\n\n    ctr = 0\n    result = b\"\"\n\n    size = size_in_bytes\n\n    while size > 0:\n        h = hmac.HMAC(key, hashfunc)\n        ctr += 1\n        h.update(struct.pack(\">I\", ctr))\n        h.update(label_bytes)\n        if context:\n            h.update(context)\n        h.update(struct.pack(\">I\", size_in_bits))\n        result += h.finalize()\n\n        size -= hashfunc.digest_size\n\n    return result[:size_in_bytes]\n\n\ndef crypt_kdfe(\n    hashfunc: hashes.HashAlgorithm,\n    secret_x: bytes,\n    label: str,\n    party_x: bytes,\n    party_y: bytes,\n    size_in_bits: int,\n) -> bytes:\n    \"\"\"TPM 2's KDFe\n\n    Parameters\n    ----------\n    hashfunc: hash function\n    secret_x: the X coordinate of the product of a public ECC key and a different private ECC key\n    label: a label to add to the digest\n    party_x: context to add to the digest\n    party_y: context to add to the digest\n    size_in_bits: how many bits of random data to generate\n    \"\"\"\n    size_in_bytes = (size_in_bits + 7) >> 3\n    label_bytes = label_to_bytes(label)\n    party = party_x + party_y\n\n    ctr = 0\n    result = b\"\"\n\n    size = size_in_bytes\n\n    while size > 0:\n        digest = hashes.Hash(hashfunc, backend=backends.default_backend())\n        ctr += 1\n        digest.update(struct.pack(\">I\", ctr))\n        if secret_x:\n            digest.update(secret_x)\n        digest.update(label_bytes)\n        if party:\n            digest.update(party)\n        result += digest.finalize()\n\n        size -= hashfunc.digest_size\n\n    return result[:size_in_bytes]\n\n\ndef check_mask(mask: Optional[str], pcr: int) -> bool:\n    if mask is None:\n        return False\n    return bool(1 << pcr & int(mask, 0))\n\n\ndef random_password(length: int = 20) -> str:\n    rand = crypto.generate_random_key(length)\n    chars = string.ascii_uppercase + string.digits + string.ascii_lowercase\n    password = \"\"\n    for i in range(length):\n        password += chars[(rand[i]) % len(chars)]\n    return password\n\n\ndef readPolicy(configval: str) -> Dict[str, Any]:\n    policy: Dict[str, Any] = json.loads(configval)\n\n    # compute PCR mask from tpm_policy\n    mask = 0\n    for key in policy:\n        if not key.isdigit() or int(key) > 24:\n            raise Exception(f\"Invalid tpm policy pcr number: {key}\")\n\n        if int(key) == config.TPM_DATA_PCR:\n            raise Exception(f\"Invalid allowlist PCR number {key}, keylime uses this PCR to bind data.\")\n        if int(key) == config.IMA_PCR:\n            raise Exception(f\"Invalid allowlist PCR number {key}, this PCR is used for IMA.\")\n\n        mask = mask | (1 << int(key))\n\n        # wrap it in a list if it is a singleton\n        if isinstance(policy[key], str):\n            policy[key] = [policy[key]]\n\n        # convert all hash values to lowercase\n        policy[key] = [x.lower() for x in policy[key]]\n\n    policy[\"mask\"] = hex(mask)\n    return policy\n", "import base64\nimport unittest\nfrom unittest import mock\n\nfrom cryptography.hazmat.primitives.asymmetric.ec import (\n    SECP256R1,\n    EllipticCurve,\n    EllipticCurvePrivateKey,\n    EllipticCurvePrivateNumbers,\n    EllipticCurvePublicNumbers,\n)\n\nfrom keylime.tpm.tpm_util import checkquote, makecredential\n\n\nclass TestTpmUtil(unittest.TestCase):\n    def test_checkquote(self) -> None:\n        aikblob = bytes(\n            \"-----BEGIN PUBLIC KEY-----\\n\"\n            \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw3owm7uitOaspMCDlhEv\\n\"\n            \"bxNgGsxa1MpbHytT/Y9K0sdpTxgay571B8zvLOUbJHEJ0gt4NHY0+/NCzIAzT6kB\\n\"\n            \"n7aL67BV8QiyKBcywlVGS9PqYGoB9uxozDap/O9Bc5WrQUCso4m4TxrW1QOOBkNX\\n\"\n            \"x5OnresvsRv5O3m6BYZeUk2pJOyiBXM0HEkEC/Q/hxsfF1KfJG3JYOhpdF0E//dy\\n\"\n            \"LHOtdW9FP8Dt3YZuchJmyhFDjMKuxF2Zt7YVk9Pg4ZvmJ64CmOtshUj9k+Ctj44Z\\n\"\n            \"gMS/cIVmMrk7cdUBEBtq8x3g0cARZ5cUb4KB+dO0v/fvZkb4Qt5zwym1eUzmvVfD\\n\"\n            \"6QIDAQAB\\n\"\n            \"-----END PUBLIC KEY-----\",\n            \"utf-8\",\n        )\n        sigblob = base64.b64decode(\n            \"ABQACwEAgkUGLLuWpJETl3E5G2mvoVqbgVxzwAluOtyUwkoZEC2j4DeqOrl/q7jLaAC2KxDcoJbk\"\n            \"QPqu2sgwV84lfZOqRNhCydiwxbBTPIXImoDsCnkpkYwrk9NJcM+18qm/+f5V2/8QBQQmbN+6EV3I\"\n            \"gpSOYor2XcVntHCIrcloh/qN2gjihXDSjtHH9aSwOH7Z69gzyTt/4yVul7QRAOQCjqnasaSEGvoA\"\n            \"vtIin0aJLfD9wo1wlRzRDU62t3oHKLY49tMA3hQYF15+If/NsTKCTmUKmiKLBTk3yWAE64ThCxpB\"\n            \"EED6peiJlSxhdkyRm632IWAt8ahuyrfi/iEDVfyV+LnTBw==\"\n        )\n        quoteblob = base64.b64decode(\n            \"/1RDR4AYACIACzi1x2WoenP+buZXpt2LdpW0GTj5lBE6PXQmPZ0upQM0ABRBaTVNNVNqWWpua3l2\"\n            \"NFA3aXRIMQAAAABMlE7mAAAAAwAAAAABIBkQIwAWNjYAAAABAAsDAAABACBtTTdJEy9iVxchZM1f\"\n            \"8xNfRHlz1KXITgGJAfZ1NwW3AQ==\"\n        )\n        pcrblob = base64.b64decode(\n            \"AQAAAAsAAwAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAgANRxwGdJUfDvB1rs3UL776bspgGYIK3QvSItHE5i\"\n            \"Qs5vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\n        )\n        nonce = \"Ai5M5SjYjnkyv4P7itH1\"\n\n        try:\n            checkquote(aikblob, nonce, sigblob, quoteblob, pcrblob, \"sha256\")\n        except Exception as e:\n            self.fail(f\"checkquote failed with {e}\")\n\n    @staticmethod\n    def not_random(numbytes: int) -> bytes:\n        return b\"\\x12\" * numbytes\n\n    def test_makecredential(self) -> None:\n        with mock.patch(\"os.urandom\", TestTpmUtil.not_random):\n            ek_tpm = bytes.fromhex(\n                \"013a0001000b000300b20020837197674484b3f81a90cc8d46a5d724fd52d76e06520b64f2a1\"\n                \"da1b331469aa00060080004300100800000000000100aef12278a9b8d8a1e5700fb835ff3d9b\"\n                \"613d0d6fc17df186711260244f3f24847eb3ef1f5ff9b53d01cfebf291104385fbd71ead80a8\"\n                \"294ebc76f671859b7c3c9a998300f30859ef3fdba00c5229f17092fd97f19128243000205cfe\"\n                \"5ba24f5fc55538e52bf849c6f777690919929c7d2d9328070a2a6bdd67355a516b94afdceda0\"\n                \"0a0d27988a28644b30ac11beae23a51d9038cd9d789ae39cae15c1312ef174e217449771a602\"\n                \"ade4daf35b20e072017c85a2f211fe5512319184059ddeaab94fa331c49c3f213bc3fbccd1e8\"\n                \"56b8984353ac92e3df0f72f1e5c0b97b9cdc333702872e9e63565c809d81fa8bb6c6da86867c\"\n                \"ead2adedc0cee80bb6617183\"\n            )\n            challenge = bytes.fromhex(\"5a4e524b4f4e6e777552754831683734785a466a42416f314758676c484d4149\")\n            aik_name = bytes.fromhex(\"000b9601163463aacdb45be7ad1f6d11ad3dae0578d5aeeb5125e1075c5601b7c7fa\")\n\n            credential = makecredential(ek_tpm, challenge, aik_name)\n\n            # the signature is not 'constant' due to OAEP padding\n            self.assertEqual(\n                credential[:80],\n                bytes.fromhex(\n                    \"badcc0de00000001004400206f0c4b08cfa00f21b474ca75623d098309c2cd7fac8d10\"\n                    \"ae3caf0da40162496db140cc6a5ae79a2bd7c22dc52cee372f34b356bf9bcd5176fa94\"\n                    \"239ee93191a0a75d0100\"\n                ),\n            )\n\n    @staticmethod\n    def create_fixed_ec_key(curve: EllipticCurve) -> EllipticCurvePrivateKey:\n        assert isinstance(curve, SECP256R1)\n        priv = int(\"75548318724506252006992803713632448754009807765151974952668642988315053146586\")\n        x = int(\"24475970435455602523615976476876273915861210750530480136577912291006924068625\")\n        y = int(\"54663881618849781513153369976321537514677018641256406838874390754930401176808\")\n        pub = EllipticCurvePublicNumbers(x, y, curve)\n        priv_numbers = EllipticCurvePrivateNumbers(priv, pub)\n        return priv_numbers.private_key()\n\n    def test_makecredential_ecc(self) -> None:\n        with mock.patch(\n            \"cryptography.hazmat.primitives.asymmetric.ec.generate_private_key\", TestTpmUtil.create_fixed_ec_key\n        ):\n            ek_tpm = bytes.fromhex(\n                \"007a0023000b000300b20020837197674484b3f81a90cc8d46a5d724fd52d76e06520b64f2a1\"\n                \"da1b331469aa0006008000430010000300100020d31f0e190c36691abdc5c8cef7201139664f\"\n                \"93bcc45e68861a62d649d9a157d400209bf3cc57da9b2c09539cae40f0518e651b65befaab84\"\n                \"f26a3285d88be134b0cf\"\n            )\n            challenge = bytes.fromhex(\"7756666e6e4574706552556d717932656e7954474c64434f576a523545654a69\")\n            aik_name = bytes.fromhex(\"000b9f7f75b0564ea96bd70ef98baafbf6bf779641d17576bd11b5c6979273d2ba21\")\n\n            credential = makecredential(ek_tpm, challenge, aik_name)\n\n            # the signature is not 'constant' due to OAEP padding\n            self.assertEqual(\n                credential,\n                bytes.fromhex(\n                    \"badcc0de00000001004400207d7934f023133b07f7d9bce3062451ea4da5f1917c95e1\"\n                    \"42da1c3277e658f66bbea694a7c1b30d006a09b28dc534876d59b644b9223c5f3c3432\"\n                    \"d8bae35f3ea3fba600440020361ce888d5152797aaca04838003976967c0c0a0a0e969\"\n                    \"8b7b5e6e5294e21711002078daa91b35fb5efc70052a470064a96dd556bd53a784d737\"\n                    \"e40966edc5f36ce8\"\n                ),\n            )\n"], "fixing_code": ["import os\nimport string\nimport struct\nfrom typing import Any, Dict, List, Optional, Tuple, Union\n\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives import hashes, hmac, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec, padding\nfrom cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey\nfrom cryptography.hazmat.primitives.asymmetric.utils import Prehashed\nfrom cryptography.hazmat.primitives.ciphers import Cipher, modes\n\nfrom keylime import config, crypto, json, keylime_logging\nfrom keylime.tpm import ec_crypto_helper, tpm2_objects\n\nlogger = keylime_logging.init_logging(\"tpm_util\")\n\nSupportedKeyTypes = Union[RSAPublicKey, EllipticCurvePublicKey]\n\n\ndef verify(pubkey: SupportedKeyTypes, sig: bytes, digest: bytes, hashfunc: hashes.HashAlgorithm) -> None:\n    \"\"\"Do signature verification with the given public key\"\"\"\n    if isinstance(pubkey, RSAPublicKey):\n        pubkey.verify(sig, digest, padding.PKCS1v15(), Prehashed(hashfunc))\n    elif isinstance(pubkey, EllipticCurvePublicKey):\n        pubkey.verify(sig, digest, ec.ECDSA(Prehashed(hashfunc)))\n\n\ndef __get_pcrs_from_blob(pcrblob: bytes) -> Tuple[int, Dict[int, int], List[bytes]]:\n    \"\"\"This function is specific to the Intel tools with data in little endian format.\n    Data structures were not marshalled but written right from memory.\"\"\"\n    # TPML_PCR_SELECTION:count\n    (pcr_select_count,) = struct.unpack_from(\"<I\", pcrblob, 0)\n\n    o = 4\n    # TPML_PCR_SELECTION:TPMS_PCR_SELECTION[HASH_COUNT]\n    tpml_pcr_selection: Dict[int, int] = {}\n    for _ in range(0, 16):\n        hash_alg, size_of_select = struct.unpack_from(\"<HB\", pcrblob, o)\n        if size_of_select not in [0, 3]:\n            raise ValueError(f\"size_of_select must be either 0 or 3 but it is {size_of_select}\")\n        o = o + 3\n\n        if size_of_select == 3:\n            (pcr_select_bytes,) = struct.unpack_from(\"3s\", pcrblob, o)\n            pcr_select = pcr_select_bytes[0] | pcr_select_bytes[1] << 8 | pcr_select_bytes[2] << 16\n        else:\n            pcr_select = 0\n\n        tpml_pcr_selection[hash_alg] = pcr_select\n\n        # always advance by size_of_select = 3 and 2 bytes alignment\n        o = o + 3 + 2\n\n    # Number of subsequent TPML_DIGEST's\n    (pcrs_count,) = struct.unpack_from(\"<I\", pcrblob, o)\n    o = o + 4\n\n    pcr_values: List[bytes] = []\n\n    for _ in range(0, pcrs_count):\n        # TPML_DIGEST::count\n        (_,) = struct.unpack_from(\"<I\", pcrblob, o)\n        o = o + 4\n\n        # TPML_DIGEST::TPM2B_DIGEST[8]\n        for _ in range(0, 8):\n            (sz,) = struct.unpack_from(\"<H\", pcrblob, o)\n            o = o + 2\n            if sz:\n                (pcr_value,) = struct.unpack_from(f\"{sz}s\", pcrblob, o)\n                pcr_values.append(pcr_value)\n            # Always advance by the size of TPMU_HA (= size of SHA512)\n            o = o + 64\n\n    if o != len(pcrblob):\n        raise ValueError(\"Failed to parse the entire pcrblob\")\n\n    return pcr_select_count, tpml_pcr_selection, pcr_values\n\n\ndef __hash_pcr_banks(\n    hash_alg: int, pcr_select_count: int, tpml_pcr_selection: Dict[int, int], pcr_values: List[bytes]\n) -> Tuple[bytes, Dict[int, str]]:\n    \"\"\"From the tpml_pcr_selection determine which PCRs were quoted and hash these PCRs to get\n    the hash that was used for the quote. Build a dict that contains the PCR values.\"\"\"\n    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)\n    if not hashfunc:\n        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")\n\n    digest = hashes.Hash(hashfunc, backend=backends.default_backend())\n\n    idx = 0\n    pcrs_dict: Dict[int, str] = {}\n\n    for _ in range(0, pcr_select_count):\n        for pcr_id in range(0, 24):\n            if tpml_pcr_selection[hash_alg] & (1 << pcr_id) == 0:\n                continue\n            if idx >= len(pcr_values):\n                raise ValueError(f\"pcr_values list is too short to get item {idx}\")\n            digest.update(pcr_values[idx])\n            pcrs_dict[pcr_id] = pcr_values[idx].hex()\n            idx = idx + 1\n\n    if idx != len(pcr_values):\n        raise ValueError(\"Did not consume all entries in pcr_values list\")\n\n    quote_digest = digest.finalize()\n\n    return quote_digest, pcrs_dict\n\n\ndef __get_and_hash_pcrs(pcrblob: bytes, hash_alg: int) -> Tuple[bytes, Dict[int, str]]:\n    pcr_select_count, tpml_pcr_selection, pcr_values = __get_pcrs_from_blob(pcrblob)\n    return __hash_pcr_banks(hash_alg, pcr_select_count, tpml_pcr_selection, pcr_values)\n\n\ndef checkquote(\n    aikblob: bytes, nonce: str, sigblob: bytes, quoteblob: bytes, pcrblob: bytes, exp_hash_alg: str\n) -> Dict[int, str]:\n    \"\"\"Check the given quote by checking the signature, then the nonce and then the used hash\n\n    Parameters\n    ----------\n    aikblob: PEM-formatted public RSA or EC key\n    nonce: The nonce that was used during the quote\n    sigblob: Signature blob containing signature algorithm, hash used for signing, and plain signature\n    quoteblob: Marshalled TPMS_ATTEST\n    pcrblob: The state of the PCRs that were quoted; Intel tpm2-tools specific format\n    exp_hash_alg: The hash that was expected to have been used for quoting\n    \"\"\"\n    sig_alg, hash_alg, sig_size = struct.unpack_from(\">HHH\", sigblob, 0)\n\n    (signature,) = struct.unpack_from(f\"{sig_size}s\", sigblob, 6)\n\n    pubkey = serialization.load_pem_public_key(aikblob, backend=backends.default_backend())\n    if not isinstance(pubkey, (RSAPublicKey, EllipticCurvePublicKey)):\n        raise ValueError(f\"Unsupported key type {type(pubkey).__name__}\")\n\n    if isinstance(pubkey, RSAPublicKey) and sig_alg not in [tpm2_objects.TPM_ALG_RSASSA]:\n        raise ValueError(f\"Unsupported quote signature algorithm '{sig_alg:#x}' for RSA keys\")\n    if isinstance(pubkey, EllipticCurvePublicKey) and sig_alg not in [tpm2_objects.TPM_ALG_ECDSA]:\n        raise ValueError(f\"Unsupported quote signature algorithm '{sig_alg:#x}' for EC keys\")\n\n    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)\n    if not hashfunc:\n        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")\n    if hashfunc.name != exp_hash_alg:\n        raise ValueError(f\"Quote was expected to use {exp_hash_alg} but used {hashfunc.name} instead\")\n\n    digest = hashes.Hash(hashfunc, backend=backends.default_backend())\n    digest.update(quoteblob)\n    quote_digest = digest.finalize()\n\n    verify(pubkey, signature, quote_digest, hashfunc)\n\n    # Check that reported nonce is expected one\n    retDict = tpm2_objects.unmarshal_tpms_attest(quoteblob)\n    extradata = retDict[\"extraData\"]\n    if extradata.decode(\"utf-8\") != nonce:\n        raise Exception(\"The nonce from the attestation differs from the expected nonce\")\n\n    # Check that correct quote_digest was used which is equivalent to hash(quoteblob)\n    compare_digest, pcrs_dict = __get_and_hash_pcrs(pcrblob, hash_alg)\n    if retDict[\"attested.quote.pcrDigest\"] != compare_digest:\n        raise Exception(\"The digest used for quoting is different than the one that was calculated\")\n\n    return pcrs_dict\n\n\ndef label_to_bytes(label: str) -> bytes:\n    return bytes(label, \"UTF-8\") + b\"\\x00\"\n\n\ndef makecredential(ek_tpm: bytes, challenge: bytes, aik_name: bytes) -> bytes:\n    \"\"\"TPM_MakeCredential implementation\n\n    Parameters\n    ----------\n    ek_tpm: marshalled TPMT_PUBKEY\n    challenge: random 'password'\n    aik_name: name of the object (AIK)\n    \"\"\"\n    public_key, hash_alg = tpm2_objects.pubkey_parms_from_tpm2b_public(ek_tpm)\n\n    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)\n    if not hashfunc:\n        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")\n\n    if isinstance(public_key, RSAPublicKey):\n        random = os.urandom(hashfunc.digest_size)\n\n        secret = public_key.encrypt(\n            random,\n            padding.OAEP(mgf=padding.MGF1(algorithm=hashfunc), algorithm=hashfunc, label=label_to_bytes(\"IDENTITY\")),\n        )\n    elif isinstance(public_key, EllipticCurvePublicKey):\n        random, secret = crypt_secret_encrypt_ecc(public_key, hashfunc)\n    else:\n        raise ValueError(f\"Unsupported public key type {type(public_key)} for makecredential\")\n\n    credentialblob = secret_to_credential(challenge, aik_name, random, ek_tpm, hashfunc)\n\n    # Create tpm2-tools-specific result format\n    hdr = struct.pack(\">II\", 0xBADCC0DE, 1)\n    tail = struct.pack(f\">H{len(secret)}s\", len(secret), secret)\n\n    return hdr + credentialblob + tail\n\n\ndef crypt_secret_encrypt_ecc(public_key: EllipticCurvePublicKey, hashfunc: hashes.HashAlgorithm) -> Tuple[bytes, bytes]:\n    my_private_key = ec.generate_private_key(public_key.curve)\n\n    my_public_key = my_private_key.public_key()\n    point = tpm2_objects.tpms_ecc_point_marshal(my_public_key)\n\n    ecc_secret_x = ec_crypto_helper.EcCryptoHelper.get_instance().point_multiply_x(public_key, my_private_key)\n\n    digest_size = hashfunc.digest_size\n\n    x = my_public_key.public_numbers().x\n    party_x = x.to_bytes((x.bit_length() + 7) >> 3, \"big\")\n\n    x = public_key.public_numbers().x\n    party_y = x.to_bytes((x.bit_length() + 7) >> 3, \"big\")\n\n    data = crypt_kdfe(hashfunc, ecc_secret_x, \"IDENTITY\", party_x, party_y, digest_size << 3)\n\n    return data, point\n\n\ndef secret_to_credential(\n    secret: bytes, name: bytes, seed: bytes, ek_tpm: bytes, hashfunc: hashes.HashAlgorithm\n) -> bytes:\n    \"\"\"TPM 2's SecretToCredential\n\n    Parameters\n    ----------\n    secret: the secret\n    name: name of the object\n    seed: external seed\n    ek_tpm: marshalled TPMT_PUBKEY\n    hashfunc: the hash function used by the public key (extracted from ek_tpm)\n    \"\"\"\n    # sensitive data is the 2nd part in TPM2B_ID_OBJECT\n    sensitive_data_2b = struct.pack(f\">H{len(secret)}s\", len(secret), secret)\n    integrity, sensitive_data_enc = produce_outer_wrap(ek_tpm, name, hashfunc, seed, sensitive_data_2b)\n\n    tpms_id_object = struct.pack(\n        f\">H{len(integrity)}s{len(sensitive_data_enc)}s\",\n        len(integrity),\n        integrity,\n        sensitive_data_enc,\n    )\n\n    return struct.pack(f\">H{len(tpms_id_object)}s\", len(tpms_id_object), tpms_id_object)\n\n\ndef produce_outer_wrap(\n    ek_tpm: bytes,\n    name: bytes,\n    hashfunc: hashes.HashAlgorithm,\n    seed: bytes,\n    sensitive_data_2b: bytes,\n) -> Tuple[bytes, bytes]:\n    \"\"\"TPM 2's ProduceOuterWrap implementing encrypt-then-MAC of a secret\n\n    Parameters\n    ----------\n    ek_tpm: marshalled TPMT_PUBKEY\n    name: name of the object\n    hashfunc: the hash function used by the public key (extracted from ek_tpm)\n    seed: external seed\n    sensitive_data_2b: marshalled TPM2B buffer holding a secret\n    \"\"\"\n    symkey, sym_alg = compute_protection_key_parms(ek_tpm, hashfunc, name, seed)\n\n    # Encrypt inner buffer\n    symcipherfunc = tpm2_objects.SYMCIPHER_FUNCS.get(sym_alg)\n    if not symcipherfunc:\n        raise ValueError(f\"Unsupported symmetric cipher with Id {sym_alg:#x} was requested\")\n\n    symcipher = symcipherfunc(symkey)\n    block_size = symcipher.block_size >> 3\n    encryptor = Cipher(symcipher, modes.CFB(b\"\\x00\" * block_size)).encryptor()\n    ciphertext = encryptor.update(sensitive_data_2b) + encryptor.finalize()\n\n    # Compute outer integrity\n    hmac_signature = compute_outer_integrity(name, hashfunc, seed, ciphertext)\n\n    return hmac_signature, ciphertext\n\n\ndef compute_outer_integrity(\n    name: bytes,\n    hashfunc: hashes.HashAlgorithm,\n    seed: bytes,\n    ciphertext: bytes,\n) -> bytes:\n    \"\"\"TPM 2's ComputeOuterIntegrity HMAC'ing a ciphertext\n\n    Parameters\n    ----------\n    name: name of the object; this will be part of the HMAC'ed data\n    hashfunc: hash function to use for HMAC\n    seed: external seed\n    ciphertext: ciphertext to HMAC\n    \"\"\"\n    digest_size = hashfunc.digest_size\n\n    hmac_key = crypt_kdfa(hashfunc, seed, \"INTEGRITY\", b\"\", b\"\", digest_size << 3)\n\n    h = hmac.HMAC(hmac_key, hashfunc)\n    h.update(ciphertext)\n    h.update(name)\n    return h.finalize()\n\n\ndef compute_protection_key_parms(\n    ek_tpm: bytes, hashfunc: hashes.HashAlgorithm, name: bytes, seed: bytes\n) -> Tuple[bytes, int]:\n    \"\"\"TPM 2's ComputeProtectionKeyParms deriving a symmetric key using KDFa\n\n    Parameters\n    ----------\n    ek_tpm: marshalled TPMT_PUBKEY\n    hashfunc: hash function to use for key derivation\n    name: name of the object\n    seed: external seed\n    \"\"\"\n    assert len(seed) > 0\n\n    sym_alg, symkey_bits = tpm2_objects.get_tpm2b_public_symkey_params(ek_tpm)\n\n    symkey = crypt_kdfa(hashfunc, seed, \"STORAGE\", name, b\"\", symkey_bits)\n\n    return symkey, sym_alg\n\n\ndef crypt_kdfa(\n    hashfunc: hashes.HashAlgorithm,\n    key: bytes,\n    label: str,\n    context_u: bytes,\n    context_v: bytes,\n    size_in_bits: int,\n) -> bytes:\n    \"\"\"TPM 2's KDFa\n\n    Parameters\n    ----------\n    hashfunc: hash function\n    key: key to use for HMAC\n    label: a label to add to the HMAC\n    context_u: context to add to the HMAC\n    context_v: context to add to the HMAC\n    size_in_bits: how many bits of random data to generate\n    \"\"\"\n    size_in_bytes = (size_in_bits + 7) >> 3\n    label_bytes = label_to_bytes(label)\n    context = context_u + context_v\n\n    ctr = 0\n    result = b\"\"\n\n    size = size_in_bytes\n\n    while size > 0:\n        h = hmac.HMAC(key, hashfunc)\n        ctr += 1\n        h.update(struct.pack(\">I\", ctr))\n        h.update(label_bytes)\n        if context:\n            h.update(context)\n        h.update(struct.pack(\">I\", size_in_bits))\n        result += h.finalize()\n\n        size -= hashfunc.digest_size\n\n    return result[:size_in_bytes]\n\n\ndef crypt_kdfe(\n    hashfunc: hashes.HashAlgorithm,\n    secret_x: bytes,\n    label: str,\n    party_x: bytes,\n    party_y: bytes,\n    size_in_bits: int,\n) -> bytes:\n    \"\"\"TPM 2's KDFe\n\n    Parameters\n    ----------\n    hashfunc: hash function\n    secret_x: the X coordinate of the product of a public ECC key and a different private ECC key\n    label: a label to add to the digest\n    party_x: context to add to the digest\n    party_y: context to add to the digest\n    size_in_bits: how many bits of random data to generate\n    \"\"\"\n    size_in_bytes = (size_in_bits + 7) >> 3\n    label_bytes = label_to_bytes(label)\n    party = party_x + party_y\n\n    ctr = 0\n    result = b\"\"\n\n    size = size_in_bytes\n\n    while size > 0:\n        digest = hashes.Hash(hashfunc, backend=backends.default_backend())\n        ctr += 1\n        digest.update(struct.pack(\">I\", ctr))\n        if secret_x:\n            digest.update(secret_x)\n        digest.update(label_bytes)\n        if party:\n            digest.update(party)\n        result += digest.finalize()\n\n        size -= hashfunc.digest_size\n\n    return result[:size_in_bytes]\n\n\ndef check_mask(mask: Optional[str], pcr: int) -> bool:\n    if mask is None:\n        return False\n    return bool(1 << pcr & int(mask, 0))\n\n\ndef random_password(length: int = 20) -> str:\n    rand = crypto.generate_random_key(length)\n    chars = string.ascii_uppercase + string.digits + string.ascii_lowercase\n    password = \"\"\n    for i in range(length):\n        password += chars[(rand[i]) % len(chars)]\n    return password\n\n\ndef readPolicy(configval: str) -> Dict[str, Any]:\n    policy: Dict[str, Any] = json.loads(configval)\n\n    # compute PCR mask from tpm_policy\n    mask = 0\n    for key in policy:\n        if not key.isdigit() or int(key) > 24:\n            raise Exception(f\"Invalid tpm policy pcr number: {key}\")\n\n        if int(key) == config.TPM_DATA_PCR:\n            raise Exception(f\"Invalid allowlist PCR number {key}, keylime uses this PCR to bind data.\")\n        if int(key) == config.IMA_PCR:\n            raise Exception(f\"Invalid allowlist PCR number {key}, this PCR is used for IMA.\")\n\n        mask = mask | (1 << int(key))\n\n        # wrap it in a list if it is a singleton\n        if isinstance(policy[key], str):\n            policy[key] = [policy[key]]\n\n        # convert all hash values to lowercase\n        policy[key] = [x.lower() for x in policy[key]]\n\n    policy[\"mask\"] = hex(mask)\n    return policy\n", "import base64\nimport unittest\nfrom unittest import mock\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives.asymmetric.ec import (\n    SECP256R1,\n    EllipticCurve,\n    EllipticCurvePrivateKey,\n    EllipticCurvePrivateNumbers,\n    EllipticCurvePublicNumbers,\n)\n\nfrom keylime.tpm.tpm_util import checkquote, makecredential\n\n\nclass TestTpmUtil(unittest.TestCase):\n    def test_checkquote(self) -> None:\n        aikblob = bytes(\n            \"-----BEGIN PUBLIC KEY-----\\n\"\n            \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw3owm7uitOaspMCDlhEv\\n\"\n            \"bxNgGsxa1MpbHytT/Y9K0sdpTxgay571B8zvLOUbJHEJ0gt4NHY0+/NCzIAzT6kB\\n\"\n            \"n7aL67BV8QiyKBcywlVGS9PqYGoB9uxozDap/O9Bc5WrQUCso4m4TxrW1QOOBkNX\\n\"\n            \"x5OnresvsRv5O3m6BYZeUk2pJOyiBXM0HEkEC/Q/hxsfF1KfJG3JYOhpdF0E//dy\\n\"\n            \"LHOtdW9FP8Dt3YZuchJmyhFDjMKuxF2Zt7YVk9Pg4ZvmJ64CmOtshUj9k+Ctj44Z\\n\"\n            \"gMS/cIVmMrk7cdUBEBtq8x3g0cARZ5cUb4KB+dO0v/fvZkb4Qt5zwym1eUzmvVfD\\n\"\n            \"6QIDAQAB\\n\"\n            \"-----END PUBLIC KEY-----\",\n            \"utf-8\",\n        )\n        sigblob = base64.b64decode(\n            \"ABQACwEAgkUGLLuWpJETl3E5G2mvoVqbgVxzwAluOtyUwkoZEC2j4DeqOrl/q7jLaAC2KxDcoJbk\"\n            \"QPqu2sgwV84lfZOqRNhCydiwxbBTPIXImoDsCnkpkYwrk9NJcM+18qm/+f5V2/8QBQQmbN+6EV3I\"\n            \"gpSOYor2XcVntHCIrcloh/qN2gjihXDSjtHH9aSwOH7Z69gzyTt/4yVul7QRAOQCjqnasaSEGvoA\"\n            \"vtIin0aJLfD9wo1wlRzRDU62t3oHKLY49tMA3hQYF15+If/NsTKCTmUKmiKLBTk3yWAE64ThCxpB\"\n            \"EED6peiJlSxhdkyRm632IWAt8ahuyrfi/iEDVfyV+LnTBw==\"\n        )\n        quoteblob = base64.b64decode(\n            \"/1RDR4AYACIACzi1x2WoenP+buZXpt2LdpW0GTj5lBE6PXQmPZ0upQM0ABRBaTVNNVNqWWpua3l2\"\n            \"NFA3aXRIMQAAAABMlE7mAAAAAwAAAAABIBkQIwAWNjYAAAABAAsDAAABACBtTTdJEy9iVxchZM1f\"\n            \"8xNfRHlz1KXITgGJAfZ1NwW3AQ==\"\n        )\n        pcrblob = base64.b64decode(\n            \"AQAAAAsAAwAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAgANRxwGdJUfDvB1rs3UL776bspgGYIK3QvSItHE5i\"\n            \"Qs5vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\n        )\n        nonce = \"Ai5M5SjYjnkyv4P7itH1\"\n\n        try:\n            checkquote(aikblob, nonce, sigblob, quoteblob, pcrblob, \"sha256\")\n        except Exception as e:\n            self.fail(f\"checkquote failed with {e}\")\n\n        # test bad input\n        bad_quoteblob = bytearray(quoteblob)\n        bad_quoteblob[5] ^= 0x1\n        with self.assertRaises(InvalidSignature):\n            checkquote(aikblob, nonce, sigblob, bad_quoteblob, pcrblob, \"sha256\")\n\n        l = list(nonce)\n        l[0] = \"a\"\n        bad_nonce = \"\".join(l)\n        with self.assertRaises(Exception):\n            checkquote(aikblob, bad_nonce, sigblob, quoteblob, pcrblob, \"sha256\")\n\n        bad_pcrblob = bytearray(pcrblob)\n        bad_pcrblob[5] ^= 0x1\n        with self.assertRaises(Exception):\n            checkquote(aikblob, nonce, sigblob, quoteblob, bad_pcrblob, \"sha256\")\n\n        with self.assertRaises(ValueError):\n            checkquote(aikblob, nonce, sigblob, quoteblob, pcrblob, \"sha1\")\n\n    @staticmethod\n    def not_random(numbytes: int) -> bytes:\n        return b\"\\x12\" * numbytes\n\n    def test_makecredential(self) -> None:\n        with mock.patch(\"os.urandom\", TestTpmUtil.not_random):\n            ek_tpm = bytes.fromhex(\n                \"013a0001000b000300b20020837197674484b3f81a90cc8d46a5d724fd52d76e06520b64f2a1\"\n                \"da1b331469aa00060080004300100800000000000100aef12278a9b8d8a1e5700fb835ff3d9b\"\n                \"613d0d6fc17df186711260244f3f24847eb3ef1f5ff9b53d01cfebf291104385fbd71ead80a8\"\n                \"294ebc76f671859b7c3c9a998300f30859ef3fdba00c5229f17092fd97f19128243000205cfe\"\n                \"5ba24f5fc55538e52bf849c6f777690919929c7d2d9328070a2a6bdd67355a516b94afdceda0\"\n                \"0a0d27988a28644b30ac11beae23a51d9038cd9d789ae39cae15c1312ef174e217449771a602\"\n                \"ade4daf35b20e072017c85a2f211fe5512319184059ddeaab94fa331c49c3f213bc3fbccd1e8\"\n                \"56b8984353ac92e3df0f72f1e5c0b97b9cdc333702872e9e63565c809d81fa8bb6c6da86867c\"\n                \"ead2adedc0cee80bb6617183\"\n            )\n            challenge = bytes.fromhex(\"5a4e524b4f4e6e777552754831683734785a466a42416f314758676c484d4149\")\n            aik_name = bytes.fromhex(\"000b9601163463aacdb45be7ad1f6d11ad3dae0578d5aeeb5125e1075c5601b7c7fa\")\n\n            credential = makecredential(ek_tpm, challenge, aik_name)\n\n            # the signature is not 'constant' due to OAEP padding\n            self.assertEqual(\n                credential[:80],\n                bytes.fromhex(\n                    \"badcc0de00000001004400206f0c4b08cfa00f21b474ca75623d098309c2cd7fac8d10\"\n                    \"ae3caf0da40162496db140cc6a5ae79a2bd7c22dc52cee372f34b356bf9bcd5176fa94\"\n                    \"239ee93191a0a75d0100\"\n                ),\n            )\n\n    @staticmethod\n    def create_fixed_ec_key(curve: EllipticCurve) -> EllipticCurvePrivateKey:\n        assert isinstance(curve, SECP256R1)\n        priv = int(\"75548318724506252006992803713632448754009807765151974952668642988315053146586\")\n        x = int(\"24475970435455602523615976476876273915861210750530480136577912291006924068625\")\n        y = int(\"54663881618849781513153369976321537514677018641256406838874390754930401176808\")\n        pub = EllipticCurvePublicNumbers(x, y, curve)\n        priv_numbers = EllipticCurvePrivateNumbers(priv, pub)\n        return priv_numbers.private_key()\n\n    def test_makecredential_ecc(self) -> None:\n        with mock.patch(\n            \"cryptography.hazmat.primitives.asymmetric.ec.generate_private_key\", TestTpmUtil.create_fixed_ec_key\n        ):\n            ek_tpm = bytes.fromhex(\n                \"007a0023000b000300b20020837197674484b3f81a90cc8d46a5d724fd52d76e06520b64f2a1\"\n                \"da1b331469aa0006008000430010000300100020d31f0e190c36691abdc5c8cef7201139664f\"\n                \"93bcc45e68861a62d649d9a157d400209bf3cc57da9b2c09539cae40f0518e651b65befaab84\"\n                \"f26a3285d88be134b0cf\"\n            )\n            challenge = bytes.fromhex(\"7756666e6e4574706552556d717932656e7954474c64434f576a523545654a69\")\n            aik_name = bytes.fromhex(\"000b9f7f75b0564ea96bd70ef98baafbf6bf779641d17576bd11b5c6979273d2ba21\")\n\n            credential = makecredential(ek_tpm, challenge, aik_name)\n\n            # the signature is not 'constant' due to OAEP padding\n            self.assertEqual(\n                credential,\n                bytes.fromhex(\n                    \"badcc0de00000001004400207d7934f023133b07f7d9bce3062451ea4da5f1917c95e1\"\n                    \"42da1c3277e658f66bbea694a7c1b30d006a09b28dc534876d59b644b9223c5f3c3432\"\n                    \"d8bae35f3ea3fba600440020361ce888d5152797aaca04838003976967c0c0a0a0e969\"\n                    \"8b7b5e6e5294e21711002078daa91b35fb5efc70052a470064a96dd556bd53a784d737\"\n                    \"e40966edc5f36ce8\"\n                ),\n            )\n"], "filenames": ["keylime/tpm/tpm_util.py", "keylime/tpm/tpm_util_test.py"], "buggy_code_start_loc": [6, 4], "buggy_code_end_loc": [162, 61], "fixing_code_start_loc": [5, 5], "fixing_code_end_loc": [158, 83], "type": "NVD-CWE-Other", "message": "A flaw was found in the keylime attestation verifier, which fails to flag a device's submitted TPM quote as faulty when the quote's signature does not validate for some reason. Instead, it will only emit an error in the log without flagging the device as untrusted.", "other": {"cve": {"id": "CVE-2023-3674", "sourceIdentifier": "secalert@redhat.com", "published": "2023-07-19T19:15:12.213", "lastModified": "2023-11-07T04:19:18.220", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in the keylime attestation verifier, which fails to flag a device's submitted TPM quote as faulty when the quote's signature does not validate for some reason. Instead, it will only emit an error in the log without flagging the device as untrusted."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.8, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.3, "baseSeverity": "LOW"}, "exploitabilityScore": 0.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1283"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keylime:keylime:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.2.5", "matchCriteriaId": "B302DE8A-15E2-4275-B8AB-A8350EEFF5E2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-3674", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2222903", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/keylime/keylime/commit/95ce3d86bd2c53009108ffda2dcf553312d733db", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/keylime/keylime/commit/95ce3d86bd2c53009108ffda2dcf553312d733db"}}