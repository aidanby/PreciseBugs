{"buggy_code": ["/* global host, bridge, data, context */\n\n'use strict';\n\nconst {\n\tObject: localObject,\n\tArray: localArray,\n\tError: LocalError,\n\tReflect: localReflect,\n\tProxy: LocalProxy,\n\tWeakMap: LocalWeakMap,\n\tFunction: localFunction,\n\tPromise: localPromise,\n\teval: localEval\n} = global;\n\nconst {\n\tfreeze: localObjectFreeze\n} = localObject;\n\nconst {\n\tgetPrototypeOf: localReflectGetPrototypeOf,\n\tapply: localReflectApply,\n\tdeleteProperty: localReflectDeleteProperty,\n\thas: localReflectHas,\n\tdefineProperty: localReflectDefineProperty,\n\tsetPrototypeOf: localReflectSetPrototypeOf,\n\tgetOwnPropertyDescriptor: localReflectGetOwnPropertyDescriptor\n} = localReflect;\n\nconst {\n\tisArray: localArrayIsArray\n} = localArray;\n\nconst {\n\tensureThis,\n\tReadOnlyHandler,\n\tfrom,\n\tfromWithFactory,\n\treadonlyFactory,\n\tconnect,\n\taddProtoMapping,\n\tVMError,\n\tReadOnlyMockHandler\n} = bridge;\n\nconst {\n\tallowAsync,\n\tGeneratorFunction,\n\tAsyncFunction,\n\tAsyncGeneratorFunction\n} = data;\n\nconst {\n\tget: localWeakMapGet,\n\tset: localWeakMapSet\n} = LocalWeakMap.prototype;\n\nfunction localUnexpected() {\n\treturn new VMError('Should not happen');\n}\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nif (!localReflectSetPrototypeOf(context, localObject.prototype)) throw localUnexpected();\n\nObject.defineProperties(global, {\n\tglobal: {value: global, writable: true, configurable: true, enumerable: true},\n\tglobalThis: {value: global, writable: true, configurable: true},\n\tGLOBAL: {value: global, writable: true, configurable: true},\n\troot: {value: global, writable: true, configurable: true},\n\tError: {value: LocalError}\n});\n\nif (!localReflectDefineProperty(global, 'VMError', {\n\t__proto__: null,\n\tvalue: VMError,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\n// Fixes buffer unsafe allocation\n/* eslint-disable no-use-before-define */\nclass BufferHandler extends ReadOnlyHandler {\n\n\tapply(target, thiz, args) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n\tconstruct(target, args, newTarget) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n}\n/* eslint-enable no-use-before-define */\n\nconst LocalBuffer = fromWithFactory(obj => new BufferHandler(obj), host.Buffer);\n\n\nif (!localReflectDefineProperty(global, 'Buffer', {\n\t__proto__: null,\n\tvalue: LocalBuffer,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\naddProtoMapping(LocalBuffer.prototype, host.Buffer.prototype, 'Uint8Array');\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafe(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafe, host.Buffer.allocUnsafe);\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafeSlow(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafeSlow, host.Buffer.allocUnsafeSlow);\n\n/**\n * Replacement for Buffer inspect\n *\n * @param {*} recurseTimes\n * @param {*} ctx\n * @this LocalBuffer\n * @return {string}\n */\nfunction inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n}\n\nconnect(inspect, host.Buffer.prototype.inspect);\n\nconnect(localFunction.prototype.bind, host.Function.prototype.bind);\n\nconnect(localObject.prototype.__defineGetter__, host.Object.prototype.__defineGetter__);\nconnect(localObject.prototype.__defineSetter__, host.Object.prototype.__defineSetter__);\nconnect(localObject.prototype.__lookupGetter__, host.Object.prototype.__lookupGetter__);\nconnect(localObject.prototype.__lookupSetter__, host.Object.prototype.__lookupSetter__);\n\n/*\n * PrepareStackTrace sanitization\n */\n\nconst oldPrepareStackTraceDesc = localReflectGetOwnPropertyDescriptor(LocalError, 'prepareStackTrace');\n\nlet currentPrepareStackTrace = LocalError.prepareStackTrace;\nconst wrappedPrepareStackTrace = new LocalWeakMap();\nif (typeof currentPrepareStackTrace === 'function') {\n\twrappedPrepareStackTrace.set(currentPrepareStackTrace, currentPrepareStackTrace);\n}\n\nlet OriginalCallSite;\nLocalError.prepareStackTrace = (e, sst) => {\n\tOriginalCallSite = sst[0].constructor;\n};\nnew LocalError().stack;\nif (typeof OriginalCallSite === 'function') {\n\tLocalError.prepareStackTrace = undefined;\n\n\tfunction makeCallSiteGetters(list) {\n\t\tconst callSiteGetters = [];\n\t\tfor (let i=0; i<list.length; i++) {\n\t\t\tconst name = list[i];\n\t\t\tconst func = OriginalCallSite.prototype[name];\n\t\t\tcallSiteGetters[i] = {__proto__: null,\n\t\t\t\tname,\n\t\t\t\tpropName: '_' + name,\n\t\t\t\tfunc: (thiz) => {\n\t\t\t\t\treturn localReflectApply(func, thiz, []);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn callSiteGetters;\n\t}\n\n\tfunction applyCallSiteGetters(thiz, callSite, getters) {\n\t\tfor (let i=0; i<getters.length; i++) {\n\t\t\tconst getter = getters[i];\n\t\t\tlocalReflectDefineProperty(thiz, getter.propName, {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: getter.func(callSite)\n\t\t\t});\n\t\t}\n\t}\n\n\tconst callSiteGetters = makeCallSiteGetters([\n\t\t'getTypeName',\n\t\t'getFunctionName',\n\t\t'getMethodName',\n\t\t'getFileName',\n\t\t'getLineNumber',\n\t\t'getColumnNumber',\n\t\t'getEvalOrigin',\n\t\t'isToplevel',\n\t\t'isEval',\n\t\t'isNative',\n\t\t'isConstructor',\n\t\t'isAsync',\n\t\t'isPromiseAll',\n\t\t'getPromiseIndex'\n\t]);\n\n\tclass CallSite {\n\t\tconstructor(callSite) {\n\t\t\tapplyCallSiteGetters(this, callSite, callSiteGetters);\n\t\t}\n\t\tgetThis() {\n\t\t\treturn undefined;\n\t\t}\n\t\tgetFunction() {\n\t\t\treturn undefined;\n\t\t}\n\t\ttoString() {\n\t\t\treturn 'CallSite {}';\n\t\t}\n\t}\n\n\n\tfor (let i=0; i<callSiteGetters.length; i++) {\n\t\tconst name = callSiteGetters[i].name;\n\t\tconst funcProp = localReflectGetOwnPropertyDescriptor(OriginalCallSite.prototype, name);\n\t\tif (!funcProp) continue;\n\t\tconst propertyName = callSiteGetters[i].propName;\n\t\tconst func = {func() {\n\t\t\treturn this[propertyName];\n\t\t}}.func;\n\t\tconst nameProp = localReflectGetOwnPropertyDescriptor(func, 'name');\n\t\tif (!nameProp) throw localUnexpected();\n\t\tnameProp.value = name;\n\t\tif (!localReflectDefineProperty(func, 'name', nameProp)) throw localUnexpected();\n\t\tfuncProp.value = func;\n\t\tif (!localReflectDefineProperty(CallSite.prototype, name, funcProp)) throw localUnexpected();\n\t}\n\n\tif (!localReflectDefineProperty(LocalError, 'prepareStackTrace', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tget() {\n\t\t\treturn currentPrepareStackTrace;\n\t\t},\n\t\tset(value) {\n\t\t\tif (typeof(value) !== 'function') {\n\t\t\t\tcurrentPrepareStackTrace = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst wrapped = localReflectApply(localWeakMapGet, wrappedPrepareStackTrace, [value]);\n\t\t\tif (wrapped) {\n\t\t\t\tcurrentPrepareStackTrace = wrapped;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newWrapped = (error, sst) => {\n\t\t\t\tconst sandboxSst = ensureThis(sst);\n\t\t\t\tif (localArrayIsArray(sst)) {\n\t\t\t\t\tif (sst === sandboxSst) {\n\t\t\t\t\t\tfor (let i=0; i < sst.length; i++) {\n\t\t\t\t\t\t\tconst cs = sst[i];\n\t\t\t\t\t\t\tif (typeof cs === 'object' && localReflectGetPrototypeOf(cs) === OriginalCallSite.prototype) {\n\t\t\t\t\t\t\t\tsst[i] = new CallSite(cs);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsst = [];\n\t\t\t\t\t\tfor (let i=0; i < sandboxSst.length; i++) {\n\t\t\t\t\t\t\tconst cs = sandboxSst[i];\n\t\t\t\t\t\t\tlocalReflectDefineProperty(sst, i, {\n\t\t\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\t\t\tvalue: new CallSite(cs),\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\twritable: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsst = sandboxSst;\n\t\t\t\t}\n\t\t\t\treturn value(error, sst);\n\t\t\t};\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [value, newWrapped]);\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [newWrapped, newWrapped]);\n\t\t\tcurrentPrepareStackTrace = newWrapped;\n\t\t}\n\t})) throw localUnexpected();\n} else if (oldPrepareStackTraceDesc) {\n\tlocalReflectDefineProperty(LocalError, 'prepareStackTrace', oldPrepareStackTraceDesc);\n} else {\n\tlocalReflectDeleteProperty(LocalError, 'prepareStackTrace');\n}\n\n/*\n * Exception sanitization\n */\n\nconst withProxy = localObjectFreeze({\n\t__proto__: null,\n\thas(target, key) {\n\t\tif (key === host.INTERNAL_STATE_NAME) return false;\n\t\treturn localReflectHas(target, key);\n\t}\n});\n\nconst interanState = localObjectFreeze({\n\t__proto__: null,\n\twrapWith(x) {\n\t\tif (x === null || x === undefined) return x;\n\t\treturn new LocalProxy(localObject(x), withProxy);\n\t},\n\thandleException: ensureThis,\n\timport(what) {\n\t\tthrow new VMError('Dynamic Import not supported');\n\t}\n});\n\nif (!localReflectDefineProperty(global, host.INTERNAL_STATE_NAME, {\n\t__proto__: null,\n\tconfigurable: false,\n\tenumerable: false,\n\twritable: false,\n\tvalue: interanState\n})) throw localUnexpected();\n\n/*\n * Eval sanitization\n */\n\nfunction throwAsync() {\n\treturn new VMError('Async not available');\n}\n\nfunction makeFunction(inputArgs, isAsync, isGenerator) {\n\tconst lastArgs = inputArgs.length - 1;\n\tlet code = lastArgs >= 0 ? `${inputArgs[lastArgs]}` : '';\n\tlet args = lastArgs > 0 ? `${inputArgs[0]}` : '';\n\tfor (let i = 1; i < lastArgs; i++) {\n\t\targs += `,${inputArgs[i]}`;\n\t}\n\ttry {\n\t\tcode = host.transformAndCheck(args, code, isAsync, isGenerator, allowAsync);\n\t} catch (e) {\n\t\tthrow bridge.from(e);\n\t}\n\treturn localEval(code);\n}\n\nconst FunctionHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t},\n\tconstruct(target, args, newTarget) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t}\n};\n\nconst EvalHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tif (args.length === 0) return undefined;\n\t\tlet code = `${args[0]}`;\n\t\ttry {\n\t\t\tcode = host.transformAndCheck(null, code, false, false, allowAsync);\n\t\t} catch (e) {\n\t\t\tthrow bridge.from(e);\n\t\t}\n\t\treturn localEval(code);\n\t}\n};\n\nconst AsyncErrorHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tthrow throwAsync();\n\t},\n\tconstruct(target, args, newTarget) {\n\t\tthrow throwAsync();\n\t}\n};\n\nfunction makeCheckFunction(isAsync, isGenerator) {\n\tif (isAsync && !allowAsync) return AsyncErrorHandler;\n\treturn {\n\t\t__proto__: FunctionHandler,\n\t\tisAsync,\n\t\tisGenerator\n\t};\n}\n\nfunction overrideWithProxy(obj, prop, value, handler) {\n\tconst proxy = new LocalProxy(value, handler);\n\tif (!localReflectDefineProperty(obj, prop, {__proto__: null, value: proxy})) throw localUnexpected();\n\treturn proxy;\n}\n\nconst proxiedFunction = overrideWithProxy(localFunction.prototype, 'constructor', localFunction, makeCheckFunction(false, false));\nif (GeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(GeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(GeneratorFunction.prototype, 'constructor', GeneratorFunction, makeCheckFunction(false, true));\n}\nif (AsyncFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncFunction.prototype, 'constructor', AsyncFunction, makeCheckFunction(true, false));\n}\nif (AsyncGeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncGeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncGeneratorFunction.prototype, 'constructor', AsyncGeneratorFunction, makeCheckFunction(true, true));\n}\n\nglobal.Function = proxiedFunction;\nglobal.eval = new LocalProxy(localEval, EvalHandler);\n\n/*\n * Promise sanitization\n */\n\nif (localPromise) {\n\n\tconst PromisePrototype = localPromise.prototype;\n\n\tif (!allowAsync) {\n\n\t\toverrideWithProxy(PromisePrototype, 'then', PromisePrototype.then, AsyncErrorHandler);\n\t\t// This seems not to work, and will produce\n\t\t// UnhandledPromiseRejectionWarning: TypeError: Method Promise.prototype.then called on incompatible receiver [object Object].\n\t\t// This is likely caused since the host.Promise.prototype.then cannot use the VM Proxy object.\n\t\t// Contextify.connect(host.Promise.prototype.then, Promise.prototype.then);\n\n\t} else {\n\n\t\toverrideWithProxy(PromisePrototype, 'then', PromisePrototype.then, {\n\t\t\t__proto__: null,\n\t\t\tapply(target, thiz, args) {\n\t\t\t\tif (args.length > 1) {\n\t\t\t\t\tconst onRejected = args[1];\n\t\t\t\t\tif (typeof onRejected === 'function') {\n\t\t\t\t\t\targs[1] = function wrapper(error) {\n\t\t\t\t\t\t\terror = ensureThis(error);\n\t\t\t\t\t\t\treturn localReflectApply(onRejected, this, [error]);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn localReflectApply(target, thiz, args);\n\t\t\t}\n\t\t});\n\n\t}\n\n}\n\nfunction readonly(other, mock) {\n\t// Note: other@other(unsafe) mock@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\tif (!mock) return fromWithFactory(readonlyFactory, other);\n\tconst tmock = from(mock);\n\treturn fromWithFactory(obj=>new ReadOnlyMockHandler(obj, tmock), other);\n}\n\nreturn {\n\t__proto__: null,\n\treadonly,\n\tglobal\n};\n"], "fixing_code": ["/* global host, bridge, data, context */\n\n'use strict';\n\nconst {\n\tObject: localObject,\n\tArray: localArray,\n\tError: LocalError,\n\tReflect: localReflect,\n\tProxy: LocalProxy,\n\tWeakMap: LocalWeakMap,\n\tFunction: localFunction,\n\tPromise: localPromise,\n\teval: localEval\n} = global;\n\nconst {\n\tfreeze: localObjectFreeze\n} = localObject;\n\nconst {\n\tgetPrototypeOf: localReflectGetPrototypeOf,\n\tapply: localReflectApply,\n\tconstruct: localReflectConstruct,\n\tdeleteProperty: localReflectDeleteProperty,\n\thas: localReflectHas,\n\tdefineProperty: localReflectDefineProperty,\n\tsetPrototypeOf: localReflectSetPrototypeOf,\n\tgetOwnPropertyDescriptor: localReflectGetOwnPropertyDescriptor\n} = localReflect;\n\nconst {\n\tisArray: localArrayIsArray\n} = localArray;\n\nconst {\n\tensureThis,\n\tReadOnlyHandler,\n\tfrom,\n\tfromWithFactory,\n\treadonlyFactory,\n\tconnect,\n\taddProtoMapping,\n\tVMError,\n\tReadOnlyMockHandler\n} = bridge;\n\nconst {\n\tallowAsync,\n\tGeneratorFunction,\n\tAsyncFunction,\n\tAsyncGeneratorFunction\n} = data;\n\nconst {\n\tget: localWeakMapGet,\n\tset: localWeakMapSet\n} = LocalWeakMap.prototype;\n\nfunction localUnexpected() {\n\treturn new VMError('Should not happen');\n}\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nif (!localReflectSetPrototypeOf(context, localObject.prototype)) throw localUnexpected();\n\nObject.defineProperties(global, {\n\tglobal: {value: global, writable: true, configurable: true, enumerable: true},\n\tglobalThis: {value: global, writable: true, configurable: true},\n\tGLOBAL: {value: global, writable: true, configurable: true},\n\troot: {value: global, writable: true, configurable: true},\n\tError: {value: LocalError}\n});\n\nif (!localReflectDefineProperty(global, 'VMError', {\n\t__proto__: null,\n\tvalue: VMError,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\n// Fixes buffer unsafe allocation\n/* eslint-disable no-use-before-define */\nclass BufferHandler extends ReadOnlyHandler {\n\n\tapply(target, thiz, args) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n\tconstruct(target, args, newTarget) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n}\n/* eslint-enable no-use-before-define */\n\nconst LocalBuffer = fromWithFactory(obj => new BufferHandler(obj), host.Buffer);\n\n\nif (!localReflectDefineProperty(global, 'Buffer', {\n\t__proto__: null,\n\tvalue: LocalBuffer,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\naddProtoMapping(LocalBuffer.prototype, host.Buffer.prototype, 'Uint8Array');\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafe(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafe, host.Buffer.allocUnsafe);\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafeSlow(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafeSlow, host.Buffer.allocUnsafeSlow);\n\n/**\n * Replacement for Buffer inspect\n *\n * @param {*} recurseTimes\n * @param {*} ctx\n * @this LocalBuffer\n * @return {string}\n */\nfunction inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n}\n\nconnect(inspect, host.Buffer.prototype.inspect);\n\nconnect(localFunction.prototype.bind, host.Function.prototype.bind);\n\nconnect(localObject.prototype.__defineGetter__, host.Object.prototype.__defineGetter__);\nconnect(localObject.prototype.__defineSetter__, host.Object.prototype.__defineSetter__);\nconnect(localObject.prototype.__lookupGetter__, host.Object.prototype.__lookupGetter__);\nconnect(localObject.prototype.__lookupSetter__, host.Object.prototype.__lookupSetter__);\n\n/*\n * PrepareStackTrace sanitization\n */\n\nconst oldPrepareStackTraceDesc = localReflectGetOwnPropertyDescriptor(LocalError, 'prepareStackTrace');\n\nlet currentPrepareStackTrace = LocalError.prepareStackTrace;\nconst wrappedPrepareStackTrace = new LocalWeakMap();\nif (typeof currentPrepareStackTrace === 'function') {\n\twrappedPrepareStackTrace.set(currentPrepareStackTrace, currentPrepareStackTrace);\n}\n\nlet OriginalCallSite;\nLocalError.prepareStackTrace = (e, sst) => {\n\tOriginalCallSite = sst[0].constructor;\n};\nnew LocalError().stack;\nif (typeof OriginalCallSite === 'function') {\n\tLocalError.prepareStackTrace = undefined;\n\n\tfunction makeCallSiteGetters(list) {\n\t\tconst callSiteGetters = [];\n\t\tfor (let i=0; i<list.length; i++) {\n\t\t\tconst name = list[i];\n\t\t\tconst func = OriginalCallSite.prototype[name];\n\t\t\tcallSiteGetters[i] = {__proto__: null,\n\t\t\t\tname,\n\t\t\t\tpropName: '_' + name,\n\t\t\t\tfunc: (thiz) => {\n\t\t\t\t\treturn localReflectApply(func, thiz, []);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn callSiteGetters;\n\t}\n\n\tfunction applyCallSiteGetters(thiz, callSite, getters) {\n\t\tfor (let i=0; i<getters.length; i++) {\n\t\t\tconst getter = getters[i];\n\t\t\tlocalReflectDefineProperty(thiz, getter.propName, {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: getter.func(callSite)\n\t\t\t});\n\t\t}\n\t}\n\n\tconst callSiteGetters = makeCallSiteGetters([\n\t\t'getTypeName',\n\t\t'getFunctionName',\n\t\t'getMethodName',\n\t\t'getFileName',\n\t\t'getLineNumber',\n\t\t'getColumnNumber',\n\t\t'getEvalOrigin',\n\t\t'isToplevel',\n\t\t'isEval',\n\t\t'isNative',\n\t\t'isConstructor',\n\t\t'isAsync',\n\t\t'isPromiseAll',\n\t\t'getPromiseIndex'\n\t]);\n\n\tclass CallSite {\n\t\tconstructor(callSite) {\n\t\t\tapplyCallSiteGetters(this, callSite, callSiteGetters);\n\t\t}\n\t\tgetThis() {\n\t\t\treturn undefined;\n\t\t}\n\t\tgetFunction() {\n\t\t\treturn undefined;\n\t\t}\n\t\ttoString() {\n\t\t\treturn 'CallSite {}';\n\t\t}\n\t}\n\n\n\tfor (let i=0; i<callSiteGetters.length; i++) {\n\t\tconst name = callSiteGetters[i].name;\n\t\tconst funcProp = localReflectGetOwnPropertyDescriptor(OriginalCallSite.prototype, name);\n\t\tif (!funcProp) continue;\n\t\tconst propertyName = callSiteGetters[i].propName;\n\t\tconst func = {func() {\n\t\t\treturn this[propertyName];\n\t\t}}.func;\n\t\tconst nameProp = localReflectGetOwnPropertyDescriptor(func, 'name');\n\t\tif (!nameProp) throw localUnexpected();\n\t\tnameProp.value = name;\n\t\tif (!localReflectDefineProperty(func, 'name', nameProp)) throw localUnexpected();\n\t\tfuncProp.value = func;\n\t\tif (!localReflectDefineProperty(CallSite.prototype, name, funcProp)) throw localUnexpected();\n\t}\n\n\tif (!localReflectDefineProperty(LocalError, 'prepareStackTrace', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tget() {\n\t\t\treturn currentPrepareStackTrace;\n\t\t},\n\t\tset(value) {\n\t\t\tif (typeof(value) !== 'function') {\n\t\t\t\tcurrentPrepareStackTrace = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst wrapped = localReflectApply(localWeakMapGet, wrappedPrepareStackTrace, [value]);\n\t\t\tif (wrapped) {\n\t\t\t\tcurrentPrepareStackTrace = wrapped;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newWrapped = (error, sst) => {\n\t\t\t\tconst sandboxSst = ensureThis(sst);\n\t\t\t\tif (localArrayIsArray(sst)) {\n\t\t\t\t\tif (sst === sandboxSst) {\n\t\t\t\t\t\tfor (let i=0; i < sst.length; i++) {\n\t\t\t\t\t\t\tconst cs = sst[i];\n\t\t\t\t\t\t\tif (typeof cs === 'object' && localReflectGetPrototypeOf(cs) === OriginalCallSite.prototype) {\n\t\t\t\t\t\t\t\tsst[i] = new CallSite(cs);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsst = [];\n\t\t\t\t\t\tfor (let i=0; i < sandboxSst.length; i++) {\n\t\t\t\t\t\t\tconst cs = sandboxSst[i];\n\t\t\t\t\t\t\tlocalReflectDefineProperty(sst, i, {\n\t\t\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\t\t\tvalue: new CallSite(cs),\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\twritable: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsst = sandboxSst;\n\t\t\t\t}\n\t\t\t\treturn value(error, sst);\n\t\t\t};\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [value, newWrapped]);\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [newWrapped, newWrapped]);\n\t\t\tcurrentPrepareStackTrace = newWrapped;\n\t\t}\n\t})) throw localUnexpected();\n} else if (oldPrepareStackTraceDesc) {\n\tlocalReflectDefineProperty(LocalError, 'prepareStackTrace', oldPrepareStackTraceDesc);\n} else {\n\tlocalReflectDeleteProperty(LocalError, 'prepareStackTrace');\n}\n\n/*\n * Exception sanitization\n */\n\nconst withProxy = localObjectFreeze({\n\t__proto__: null,\n\thas(target, key) {\n\t\tif (key === host.INTERNAL_STATE_NAME) return false;\n\t\treturn localReflectHas(target, key);\n\t}\n});\n\nconst interanState = localObjectFreeze({\n\t__proto__: null,\n\twrapWith(x) {\n\t\tif (x === null || x === undefined) return x;\n\t\treturn new LocalProxy(localObject(x), withProxy);\n\t},\n\thandleException: ensureThis,\n\timport(what) {\n\t\tthrow new VMError('Dynamic Import not supported');\n\t}\n});\n\nif (!localReflectDefineProperty(global, host.INTERNAL_STATE_NAME, {\n\t__proto__: null,\n\tconfigurable: false,\n\tenumerable: false,\n\twritable: false,\n\tvalue: interanState\n})) throw localUnexpected();\n\n/*\n * Eval sanitization\n */\n\nfunction throwAsync() {\n\treturn new VMError('Async not available');\n}\n\nfunction makeFunction(inputArgs, isAsync, isGenerator) {\n\tconst lastArgs = inputArgs.length - 1;\n\tlet code = lastArgs >= 0 ? `${inputArgs[lastArgs]}` : '';\n\tlet args = lastArgs > 0 ? `${inputArgs[0]}` : '';\n\tfor (let i = 1; i < lastArgs; i++) {\n\t\targs += `,${inputArgs[i]}`;\n\t}\n\ttry {\n\t\tcode = host.transformAndCheck(args, code, isAsync, isGenerator, allowAsync);\n\t} catch (e) {\n\t\tthrow bridge.from(e);\n\t}\n\treturn localEval(code);\n}\n\nconst FunctionHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t},\n\tconstruct(target, args, newTarget) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t}\n};\n\nconst EvalHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tif (args.length === 0) return undefined;\n\t\tlet code = `${args[0]}`;\n\t\ttry {\n\t\t\tcode = host.transformAndCheck(null, code, false, false, allowAsync);\n\t\t} catch (e) {\n\t\t\tthrow bridge.from(e);\n\t\t}\n\t\treturn localEval(code);\n\t}\n};\n\nconst AsyncErrorHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tthrow throwAsync();\n\t},\n\tconstruct(target, args, newTarget) {\n\t\tthrow throwAsync();\n\t}\n};\n\nfunction makeCheckFunction(isAsync, isGenerator) {\n\tif (isAsync && !allowAsync) return AsyncErrorHandler;\n\treturn {\n\t\t__proto__: FunctionHandler,\n\t\tisAsync,\n\t\tisGenerator\n\t};\n}\n\nfunction overrideWithProxy(obj, prop, value, handler) {\n\tconst proxy = new LocalProxy(value, handler);\n\tif (!localReflectDefineProperty(obj, prop, {__proto__: null, value: proxy})) throw localUnexpected();\n\treturn proxy;\n}\n\nconst proxiedFunction = overrideWithProxy(localFunction.prototype, 'constructor', localFunction, makeCheckFunction(false, false));\nif (GeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(GeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(GeneratorFunction.prototype, 'constructor', GeneratorFunction, makeCheckFunction(false, true));\n}\nif (AsyncFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncFunction.prototype, 'constructor', AsyncFunction, makeCheckFunction(true, false));\n}\nif (AsyncGeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncGeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncGeneratorFunction.prototype, 'constructor', AsyncGeneratorFunction, makeCheckFunction(true, true));\n}\n\nfunction makeSafeHandlerArgs(args) {\n\tconst sArgs = ensureThis(args);\n\tif (sArgs === args) return args;\n\tconst a = [];\n\tfor (let i=0; i < sArgs.length; i++) {\n\t\tlocalReflectDefineProperty(a, i, {\n\t\t\t__proto__: null,\n\t\t\tvalue: sArgs[i],\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t});\n\t}\n\treturn a;\n}\n\nconst makeSafeArgs = Object.freeze({\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\treturn localReflectApply(target, thiz, makeSafeHandlerArgs(args));\n\t},\n\tconstruct(target, args, newTarget) {\n\t\treturn localReflectConstruct(target, makeSafeHandlerArgs(args), newTarget);\n\t}\n});\n\nconst proxyHandlerHandler = Object.freeze({\n\t__proto__: null,\n\tget(target, name, receiver) {\n\t\tconst value = target.handler[name];\n\t\tif (typeof value !== 'function') return value;\n\t\treturn new LocalProxy(value, makeSafeArgs);\n\t}\n});\n\nfunction wrapProxyHandler(args) {\n\tif (args.length < 2) return args;\n\tconst handler = args[1];\n\targs[1] = new LocalProxy({__proto__: null, handler}, proxyHandlerHandler);\n\treturn args;\n}\n\nconst proxyHandler = Object.freeze({\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\treturn localReflectApply(target, thiz, wrapProxyHandler(args));\n\t},\n\tconstruct(target, args, newTarget) {\n\t\treturn localReflectConstruct(target, wrapProxyHandler(args), newTarget);\n\t}\n});\n\nconst proxiedProxy = new LocalProxy(LocalProxy, proxyHandler);\n\noverrideWithProxy(LocalProxy, 'revocable', LocalProxy.revocable, proxyHandler);\n\nglobal.Proxy = proxiedProxy;\nglobal.Function = proxiedFunction;\nglobal.eval = new LocalProxy(localEval, EvalHandler);\n\n/*\n * Promise sanitization\n */\n\nif (localPromise) {\n\n\tconst PromisePrototype = localPromise.prototype;\n\n\tif (!allowAsync) {\n\n\t\toverrideWithProxy(PromisePrototype, 'then', PromisePrototype.then, AsyncErrorHandler);\n\t\t// This seems not to work, and will produce\n\t\t// UnhandledPromiseRejectionWarning: TypeError: Method Promise.prototype.then called on incompatible receiver [object Object].\n\t\t// This is likely caused since the host.Promise.prototype.then cannot use the VM Proxy object.\n\t\t// Contextify.connect(host.Promise.prototype.then, Promise.prototype.then);\n\n\t} else {\n\n\t\toverrideWithProxy(PromisePrototype, 'then', PromisePrototype.then, {\n\t\t\t__proto__: null,\n\t\t\tapply(target, thiz, args) {\n\t\t\t\tif (args.length > 1) {\n\t\t\t\t\tconst onRejected = args[1];\n\t\t\t\t\tif (typeof onRejected === 'function') {\n\t\t\t\t\t\targs[1] = function wrapper(error) {\n\t\t\t\t\t\t\terror = ensureThis(error);\n\t\t\t\t\t\t\treturn localReflectApply(onRejected, this, [error]);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn localReflectApply(target, thiz, args);\n\t\t\t}\n\t\t});\n\n\t}\n\n}\n\nfunction readonly(other, mock) {\n\t// Note: other@other(unsafe) mock@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\tif (!mock) return fromWithFactory(readonlyFactory, other);\n\tconst tmock = from(mock);\n\treturn fromWithFactory(obj=>new ReadOnlyMockHandler(obj, tmock), other);\n}\n\nreturn {\n\t__proto__: null,\n\treadonly,\n\tglobal\n};\n"], "filenames": ["lib/setup-sandbox.js"], "buggy_code_start_loc": [23], "buggy_code_end_loc": [434], "fixing_code_start_loc": [24], "fixing_code_end_loc": [493], "type": "NVD-CWE-noinfo", "message": "vm2 is a sandbox that can run untrusted code with Node's built-in modules. A sandbox escape vulnerability exists in vm2 for versions up to and including 3.9.17. It abuses an unexpected creation of a host object based on the specification of `Proxy`. As a result a threat actor can bypass the sandbox protections to gain remote code execution rights on the host running the sandbox. This vulnerability was patched in the release of version `3.9.18` of `vm2`. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-32314", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-15T20:15:09.177", "lastModified": "2023-05-24T20:50:46.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vm2 is a sandbox that can run untrusted code with Node's built-in modules. A sandbox escape vulnerability exists in vm2 for versions up to and including 3.9.17. It abuses an unexpected creation of a host object based on the specification of `Proxy`. As a result a threat actor can bypass the sandbox protections to gain remote code execution rights on the host running the sandbox. This vulnerability was patched in the release of version `3.9.18` of `vm2`. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vm2_project:vm2:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.9.18", "matchCriteriaId": "80ED3198-E3DA-4ACD-883B-10CDB835BA33"}]}]}], "references": [{"url": "https://gist.github.com/arkark/e9f5cf5782dec8321095be3e52acf5ac", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/patriksimek/vm2/commit/d88105f99752305c5b8a77b63ddee3ec86912daf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/patriksimek/vm2/releases/tag/3.9.18", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/patriksimek/vm2/security/advisories/GHSA-whpj-8f3w-67p5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/patriksimek/vm2/commit/d88105f99752305c5b8a77b63ddee3ec86912daf"}}