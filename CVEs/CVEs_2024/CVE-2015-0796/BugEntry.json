{"buggy_code": ["#!/usr/bin/perl -w\n#\n# Copyright (c) 2006, 2007 Michael Schroeder, Novell Inc.\n# Copyright (c) 2008 Adrian Schroeter, Novell Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License version 2 as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program (see the file COPYING); if not, write to the\n# Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA\n#\n################################################################\n#\n# The Source Server\n#\n\nBEGIN {\n  my ($wd) = $0 =~ m-(.*)/- ;\n  $wd ||= '.';\n  chdir($wd);\n  unshift @INC,  \"$wd/build\";\n  unshift @INC,  \"$wd\";\n}\n\nuse XML::Structured ':bytes';\nuse POSIX;\nuse Digest::MD5 ();\nuse Data::Dumper;\nuse Storable ();\nuse Symbol;\nuse MIME::Base64 ();\nuse JSON::XS ();\n\nuse BSConfiguration;\nuse BSRPC ':https';\nuse BSServer;\nuse BSUtil;\nuse BSFileDB;\nuse BSXML;\nuse BSProductXML;\nuse BSVerify;\nuse BSHandoff;\nuse BSWatcher ':https';\nuse BSXPath;\nuse BSStdServer;\nuse BSSrcdiff;\nuse Build;\nuse BSNotify;\n\nuse BSXPath;\nuse BSXPathKeys;\nuse BSDB;\nuse BSDBIndex;\n\n$Build::Rpm::unfilteredprereqs = 1 if defined $Build::Rpm::unfilteredprereqs;\n\nuse strict;\n\nmy $port = 5352;\t#'SR'\n$port = $1 if $BSConfig::srcserver =~ /:(\\d+)$/;\nmy $proxy;\n$proxy = $BSConfig::proxy if defined($BSConfig::proxy);\n\nBSUtil::set_fdatasync_before_rename() unless $BSConfig::disable_data_sync || $BSConfig::disable_data_sync;\n\nmy $projectsdir = \"$BSConfig::bsdir/projects\";\nmy $eventdir = \"$BSConfig::bsdir/events\";\nmy $srcrep = \"$BSConfig::bsdir/sources\";\nmy $treesdir = $BSConfig::nosharedtrees ? \"$BSConfig::bsdir/trees\" : $srcrep;\nmy $requestsdir = \"$BSConfig::bsdir/requests\";\nmy $oldrequestsdir = \"$BSConfig::bsdir/requests.old\";\nmy $rundir = $BSConfig::rundir || \"$BSConfig::bsdir/run\";\nmy $diffcache = \"$BSConfig::bsdir/diffcache\";\n\nmy $reqindexdb = \"$BSConfig::bsdir/db/request\";\nmy $extrepodb = \"$BSConfig::bsdir/db/published\";\nmy $sourcedb = \"$BSConfig::bsdir/db/source\";\n\nmy $remotecache = \"$BSConfig::bsdir/remotecache\";\nmy $notificationpayloaddir = \"$BSConfig::bsdir/notificationpayload\";\n\nmy $srcrevlay = [qw{rev vrev srcmd5 version time user comment requestid}];\nmy $eventlay = [qw{number time type project package repository arch}];\nmy $notificationlay = [qw{number type time data []}];\n\n\nmy $ajaxsocket = \"$rundir/bs_srcserver.ajax\";\nmy $uploaddir = \"$srcrep/:upload\";\n\nmy @binsufs = qw{rpm deb pkg.tar.gz pkg.tar.xz};\nmy $binsufsre = join('|', map {\"\\Q$_\\E\"} @binsufs);\n\nmy $repoid;\nmy %packagequota;\n\n# This is the md5sum of an empty file\nmy $emptysrcmd5 = 'd41d8cd98f00b204e9800998ecf8427e';\n\n# remote getrev cache\nmy $collect_remote_getrev;\nmy $remote_getrev_todo;\nmy %remote_getrev_cache;\nmy $frozenlinks_cache;\n\nsub notify {\n  my ($type, $p) = @_;\n  my $time = $p->{'time'} || time();\n  delete $p->{'time'};\n  if ($type eq 'PACKTRACK' && BSServer::have_content()) {\n    my $payload = Storable::thaw(BSServer::read_data());\n    if ($payload) {\n      my $json_payload = JSON::XS::encode_json($payload);\n      my $payloadkey = \"$time.\".Digest::MD5::md5_hex($json_payload);\n      mkdir_p($notificationpayloaddir);\n      writestr(\"$notificationpayloaddir/.$payloadkey\", \"$notificationpayloaddir/$payloadkey\", $json_payload);\n      $p->{'payload'} = $payloadkey;\n      print \"notification payload for $p->{'project'}/$p->{'repo'} stored in $payloadkey\\n\" if $p->{'project'} && $p->{'repo'};\n    }\n  }\n  my @n = map {\"$_=$p->{$_}\"} grep {defined($p->{$_}) && !ref($p->{$_})} sort keys %{$p || {}};\n  mkdir_p($eventdir);\n  BSFileDB::fdb_add_i(\"$eventdir/lastnotifications\", $notificationlay, {'type' => $type, 'time' => $time, 'data' => \\@n});\n}\n\nsub prune_notificationpayloads {\n  my ($cuttime) = @_;\n  my @pl = ls($notificationpayloaddir);\n  for my $p (@pl) {\n    next unless $p =~ /^(\\d+)\\./;\n    unlink(\"$notificationpayloaddir/$p\") if $1 < $cuttime;\n  }\n}\n\nsub prune_lastnotifications {\n  my ($cutoff) = @_;\n  local *F;\n  return unless BSUtil::lockopen(\\*F, '<', \"$eventdir/lastnotifications\", 1);\n  my $filter = sub { $_[0]->{'number'} >= $cutoff ? 1 : 0 };\n  my @l = BSFileDB::fdb_getall(\"$eventdir/lastnotifications\", $notificationlay, undef, $filter);\n  if (@l) {\n    unlink(\"$eventdir/.lastnotifications.$$\");\n    if (! -e \"$eventdir/.lastnotifications.$$\") {\n      BSFileDB::fdb_add_multiple(\"$eventdir/.lastnotifications.$$\", $notificationlay, @l);\n      rename(\"$eventdir/.lastnotifications.$$\", \"$eventdir/lastnotifications\") || die(\"rename $eventdir/.lastnotifications.$$ $eventdir/lastnotifications: $!\\n\");\n      prune_notificationpayloads($l[0]->{'time'} - 240 * 3600) if -d $notificationpayloaddir;\t# keep 10 days\n    }\n  }\n  close F;\n}\n\nsub lastnotifications {\n  my ($cgi) = @_;\n  my $view = $cgi->{'view'};\n  die(\"unsupported view\\n\") if $view && $view ne 'json';\n  if (!$cgi->{'start'}) {\n    # just fetch the current event number\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastnotifications\", $notificationlay);\n    my $lastno = $lastev ? $lastev->{'number'} : 0;\n    my $ret = {'next' => $lastno + 1, 'sync' => 'lost'};\n    return (JSON::XS::encode_json($ret), 'Content-Type: application/json') if $view && $view eq 'json';\n    return ($ret, $BSXML::notifications);\n  }\n  # check if we need to prune\n  if (!$BSStdServer::isajax && !$cgi->{'noprune'}) {\n    my $firstev = (BSFileDB::fdb_getall(\"$eventdir/lastnotifications\", $notificationlay, undef, sub {-1}))[0];\n    if ($firstev && $cgi->{'start'} - $firstev->{'number'} > 1000) {\n      my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastnotifications\", $notificationlay);\n      prune_lastnotifications($cgi->{'start'} - 500) if $lastev && $cgi->{'start'} <= $lastev->{'number'} + 1;\n    }\n  }\n  my $filter = sub { $cgi->{'start'} > $_[0]->{'number'} ? -2 : 1 };\n  my @l = BSFileDB::fdb_getall_reverse(\"$eventdir/lastnotifications\", $notificationlay, undef, $filter);\n  if ($cgi->{'block'} && !@l) {\n    # pass on to AJAX\n    if (!$BSStdServer::isajax) {\n      my @args;\n      push @args, \"start=$cgi->{'start'}\";\n      push @args, \"block=1\";\n      BSHandoff::handoff($ajaxsocket, '/lastnotifications', undef, @args);\n      exit(0);\n    }\n    # wait untill we have a winner\n    BSWatcher::addfilewatcher(\"$eventdir/lastnotifications\");\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastnotifications\", $notificationlay);\n    return undef if !$lastev || $lastev->{'number'} < $cgi->{'start'};\n    if ($cgi->{'start'} == $lastev->{'number'}) {\n      @l = ($lastev);\n    } else {\n      @l = BSFileDB::fdb_getall_reverse(\"$eventdir/lastnotifications\", $notificationlay, undef, $filter);\n      return undef unless @l;\n    }\n  }\n  my $res = {};\n  @l = reverse @l;\n  if (@l) {\n    $res->{'next'} = $l[-1]->{'number'} + 1;\n  } else {\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastnotifications\", $notificationlay);\n    my $no = ($lastev->{'number'} || 0);\n    $no = $cgi->{'start'} - 1 if $no >= $cgi->{'start'};\n    $res->{'next'} = $no + 1;\n  }\n  if (@l && $l[0]->{'number'} > $cgi->{'start'}) {\n    $res->{'sync'} = 'lost';\n    @l = ();\n  }\n  # don't send more than 1000 notifications to the poor api\n  if (@l > 1000) {\n    $res->{'limit_reached'} = 1; # tell the api that there is more\n    $res->{'next'} = $l[1000]->{'number'};\n    @l = splice(@l, 0, 1000);\n  }\n  $res->{'notification'} = \\@l;\n  delete $_->{'number'} for @l;\t\t# XXX: why?\n  if ($view && $view eq 'json') {\n    for my $l (@l) {\n      my %d;\n      for (@{$l->{'data'} || []}) {\n        my @s = split('=', $_, 2);\n        $d{$s[0]} = $s[1];\n      }\n      $l->{'data'} = \\%d;\n    }\n    return (JSON::XS::encode_json($res), 'Content-Type: application/json');\n  }\n  for my $l (@l) {\n    for (@{$l->{'data'} || []}) {\n      my @s = split('=', $_, 2);\n      $_ = {'key' => $s[0]};\n      $_->{'_content'} = $s[1] if defined $s[1];\n    }\n  }\n  return ($res, $BSXML::notifications);\n}\n\nsub getnotificationpayload {\n  my ($cgi, $payloadkey) = @_;\n  my $file = \"$notificationpayloaddir/$payloadkey\";\n  die(\"404 payload does not exist!\\n\") unless -e $file;\n  return (readstr($file), 'Content-Type: application/json');\n}\n\nsub deletenotificationpayload {\n  my ($cgi, $payloadkey) = @_;\n  unlink(\"$notificationpayloaddir/$payloadkey\");\n  return $BSStdServer::return_ok;\n}\n\nsub notify_repservers {\n  my ($type, $projid, $packid) = @_;\n\n  my $ev = {'type' => $type, 'project' => $projid};\n  $ev->{'package'} = $packid if defined $packid;\n  addevent($ev);\n\n  my @args = (\"type=$type\", \"project=$projid\");\n  push @args, \"package=$packid\" if defined $packid;\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/event\",\n    'request'   => 'POST',\n    'background' => 1,\n  };\n  eval {\n    BSWatcher::rpc($param, undef, @args);\n  };\n  print \"warning: $reposerver: $@\" if $@;\n}\n\n# this is only used from getfilelist_ajax.\n# as projid is a remote project, we don't know which reposerver\n# we need to notify. so send the event to all of them.\n# we also do not call addevent in this specific case.\nsub notify_all_repservers {\n  my ($type, $projid, $packid) = @_;\n\n  my %reposervers;\n  if ($BSConfig::partitioning) {\n    %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);\n  } else {\n    %reposervers = ($BSConfig::reposerver => 1);\n  }\n  my @args = (\"type=$type\", \"project=$projid\");\n  push @args, \"package=$packid\" if defined $packid;\n  for my $reposerver (sort keys %reposervers) {\n    my $param = {\n      'uri' => \"$reposerver/event\",\n      'request'   => 'POST',\n      'background' => 1,\n    };\n    eval {\n      BSWatcher::rpc($param, undef, @args);\n    };\n    print \"warning: $reposerver: $@\" if $@;\n  }\n}\n\n# check if a service run is needed for the upcoming commit\nsub genservicemark {\n  my ($projid, $packid, $files, $rev, $force) = @_;\n  \n  return undef if $BSConfig::old_style_services;\n\n  return undef if $packid eq '_project';\t# just in case...\n  return undef if defined $rev;\t# don't mark if upload/repository/internal\n  return undef if $packid eq '_pattern' || $packid eq '_product';\t# for now...\n  return undef if $files->{'/SERVICE'};\t# already marked\n\n  # check if we really need to run the service\n  if (!$files->{'_service'} && !$force) {\n    # XXX: getprojectservices may die!\n    my ($projectservices, undef) = getprojectservices({}, $projid, $packid);\n    return undef unless $projectservices && $projectservices->{'service'} && @{$projectservices->{'service'}};\n  }\n\n  # argh, somewhat racy. luckily we just need something unique...\n  # (files is not unique enough because we want a different id\n  # for each commit, even if it has the same srcmd5)\n  # (maybe we should use the same time as in the upcoming rev)\n  my $smd5 = \"sourceservice/$projid/$packid/\".time().\"\\n\";\n  eval {\n    my $rev_old = getrev($projid, $packid);\n    $smd5 .= \"$rev_old->{'rev'}\" if $rev_old->{'rev'};\n  };\n  $smd5 .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n  $smd5 = Digest::MD5::md5_hex($smd5);\n\n  # return the mark\n  return $smd5;\n}\n\n# called from runservice when the service run is finished. it\n# either does the service commit (old style), or creates the\n# xsrcmd5 service revision (new style).\nsub addrev_service {\n  my ($cgi, $rev, $files, $error) = @_;\n\n  if ($error) {\n    chomp $error;\n    $error ||= 'unknown service error';\n  }\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  if (!$files->{'/SERVICE'}) {\n    # old style, do a commit\n    if ($error) {\n      mkdir_p($uploaddir);\n      writestr(\"$uploaddir/_service_error$$\", undef, \"$error\\n\");\n      $files->{'_service_error'} = addfile($projid, $packid, \"$uploaddir/_service_error$$\", '_service_error');\n    }\n    addrev({%{$cgi || {}}, 'user' => '_service', 'comment' => 'generated via source service', 'noservice' => 1}, $projid, $packid, $files);\n    return;\n  }\n  # new style services\n  if ($files->{'_service_error'} && !$error) {\n    $error = repreadstr($rev, '_service_error', $files->{'_service_error'});\n    chomp $error;\n    $error ||= 'unknown service error';\n  }\n  my $srcmd5 = $files->{'/SERVICE'};\n  if ($error) {\n    addmeta_serviceerror($projid, $packid, $srcmd5, $error);\n    $error =~ s/[\\r\\n]+$//s;\n    $error =~ s/.*[\\r\\n]//s;\n    $error = str2utf8xml($error) || 'unknown service error';\n  } else {\n    addmeta_service($projid, $packid, $files, $srcmd5, $rev->{'srcmd5'});\n  }\n  my $user = $cgi->{'user'};\n  my $comment = $cgi->{'comment'};\n  my $requestid = $cgi->{'requestid'};\n  $user = '' unless defined $user;\n  $user = 'unknown' if $user eq '';\n  $user = str2utf8xml($user);\n  $comment = '' unless defined $comment;\n  $comment = str2utf8xml($comment);\n  if ($error) {\n    notify('SRCSRV_SERVICE_FAIL', {project => $projid, package => $packid,\n\t\t\t\t   error => $error, rev => $rev->{'rev'},\n\t\t\t\t   user => $user, comment => $comment,\n\t\t\t\t   'requestid' => $requestid});\n  } else {\n    notify('SRCSRV_SERVICE_SUCCESS', {project => $projid, package => $packid,\n\t\t\t\t      rev => $rev->{'rev'},\n\t\t\t\t      user => $user, comment => $comment,\n\t\t\t\t      'requestid' => $requestid});\n  }\n}\n\n# store the faked result of a service run. Note that this is done before\n# the addrev call that stores the reference to the run.\n# only used for new style services.\nsub fake_service_run {\n  my ($projid, $packid, $files, $sfiles, $servicemark) = @_;\n  $files->{'/SERVICE'} = $servicemark;\n  $sfiles->{'/SERVICE'} = $servicemark;\n  my $nsrcmd5 = calcsrcmd5($files);\n  addrev_service({}, {'project' => $projid, 'package' => $packid, 'srcmd5' => $nsrcmd5}, $sfiles);\n  delete $files->{'/SERVICE'};\n  delete $sfiles->{'/SERVICE'};\n}\n\n# called *after* addrev to trigger service run\nsub runservice {\n  my ($cgi, $rev, $files) = @_;\n\n  return if !$BSConfig::old_style_services && !$files->{'/SERVICE'};\n\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  die(\"No project defined for source update!\") unless defined $projid;\n  die(\"No package defined for source update!\") unless defined $packid;\n  return if $packid eq '_project';\n\n  my $oldfiles = {};\n  if ($files->{'/SERVICE'}) {\n    # check serialization\n    return unless addmeta_serialize_servicerun($rev->{'project'}, $rev->{'package'}, $files->{'/SERVICE'});\n    # get last servicerun result into oldfiles hash\n    my $revno = $rev->{'rev'};\n    if (length($revno || '') >= 32) {\n      # argh, find commit for that srcmd5\n      $revno = (findlastrev($rev) || {})->{'rev'};\n    }\n    while ($revno && $revno > 1) {\n      $revno = $revno - 1;\t# get the commit before this one\n      eval {\n        my $oldfilerev = getrev($projid, $packid, $revno);\n\t$oldfiles = lsrev_service($oldfilerev) || {};\n      };\n      if ($@) {\n        warn($@);\n        next if $@ =~ /service in progress/;\n      }\n      $oldfiles = {} if !$oldfiles || $oldfiles->{'_service_error'};\n      # strip all non-service results;\n      delete $oldfiles->{$_} for grep {!/^_service:/} keys %$oldfiles;\n      last;\n    }\n  }\n\n  return if $packid eq '_project';\n  return if $rev->{'rev'} && ($rev->{'rev'} eq 'repository' || $rev->{'rev'} eq 'upload');\n\n  # die when a source service is still running\n  my $lockfile = \"$eventdir/service/${projid}::$packid\";\n  die(\"403 service still running\\n\") if $cgi->{'triggerservicerun'} && -e $lockfile;\n\n  my $projectservices;\n  eval {\n    ($projectservices, undef) = getprojectservices({}, $projid, $packid);\n  };\n  if ($@) {\n    addrev_service($cgi, $rev, $files, $@);\n    return;\n  }\n  undef $projectservices unless $projectservices && $projectservices->{'service'} && @{$projectservices->{'service'}};\n\n  # collect current sources to POST them\n  if (!$files->{'_service'} && !$projectservices) {\n    die(\"404 no source service defined!\\n\") if $cgi->{'triggerservicerun'};\n    # drop all existing service files\n    my $dirty;\n    for my $pfile (keys %$files) {\n      if ($pfile =~ /^_service[_:]/) {\n        delete $files->{$pfile};\n        $dirty = 1;\n      }\n    }\n    if ($dirty || $files->{'/SERVICE'}) {\n      addrev_service($cgi, $rev, $files);\n      notify_repservers('package', $projid, $packid);\n    }\n    return;\n  }\n\n  my $linkfiles;\n  if ($files->{'_link'}) {\n    # make sure it's a branch\n    my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);\n    if (!$l || !$l->{'patches'} || @{$l->{'patches'}->{''} || []} != 1 || (keys %{$l->{'patches'}->{''}->[0]})[0] ne 'branch') {\n      #addrev_service($cgi, $rev, $files, \"services only work on branches\\n\");\n      #notify_repservers('package', $projid, $packid);\n      #return;\n      # uh oh, not a branch!\n      $linkfiles = { %$files };\n      delete $files->{'/SERVICE'};\n      eval {\n        $files = handlelinks({%$rev, 'linkrev' => 'base'}, $files);\n        die(\"bad link: $files\\n\") unless ref $files;\n      };\n      if ($@) {\n\tif (($@ =~ /service in progress/) && $linkfiles->{'/SERVICE'}) {\n\t  # delay, hope for an event. remove lock for now to re-trigger the service run.\n\t  addmeta_serviceerror($rev->{'project'}, $rev->{'package'}, $linkfiles->{'/SERVICE'}, undef);\n\t  return;\n\t}\n        $files = $linkfiles;\n        addrev_service($cgi, $rev, $files, $@);\n        notify_repservers('package', $projid, $packid);\n        return;\n      }\n      $files->{'/SERVICE'} = $linkfiles->{'/SERVICE'} if $linkfiles->{'/SERVICE'}\n    }\n  }\n\n  return unless $BSConfig::serviceserver;\n\n  if (!$files->{'/SERVICE'}) {\n    mkdir_p(\"$eventdir/service\");\n    BSUtil::touch($lockfile);\n  }\n\n  my @send = map {{'name' => $_, 'filename' => \"$srcrep/$packid/$files->{$_}-$_\"}} grep {$_ ne '/SERVICE'} sort(keys %$files);\n  push @send, {'name' => '_serviceproject', 'data' => XMLout($BSXML::services, $projectservices)} if $projectservices;\n  push @send, map {{'name' => $_, 'filename' => \"$srcrep/$packid/$oldfiles->{$_}-$_\"}} grep {!$files->{$_}} sort(keys %$oldfiles);\n\n  # run the source update in own process (do not wait for it)\n  my $pid = xfork();\n  return if $pid;\n\n  # child continues...\n  my $odir = \"$srcrep/:service/$$\";\n  BSUtil::cleandir($odir) if -d $odir;\n  mkdir_p($odir);\n  my $receive;\n  eval {\n    $receive = BSRPC::rpc({\n      'uri'       => \"$BSConfig::serviceserver/sourceupdate/$projid/$packid\",\n      'request'   => 'POST',\n      'headers'   => [ 'Content-Type: application/x-cpio' ],\n      'chunked'   => 1,\n      'data'      => \\&BSHTTP::cpio_sender,\n      'cpiofiles' => \\@send,\n      'directory' => $odir,\n      'timeout'   => 3600,\n      'withmd5'   => 1,\n      'receiver' => \\&BSHTTP::cpio_receiver,\n    }, undef);\n  };\n\n  my $error = $@;\n  \n  # make sure that there was no other commit in the meantime\n  if (!$files->{'/SERVICE'}) {\n    my $newrev = getrev($projid, $packid);\n    if ($newrev->{'rev'} ne $rev->{'rev'}) {\n      unlink($lockfile);\n      exit(1);\n    }\n  }\n\n  # and update source repository with the result\n  if ($receive) {\n    # drop all existing service files\n    for my $pfile (keys %$files) {\n      delete $files->{$pfile} if $pfile =~ /^_service[_:]/;\n    }\n    # add new service files\n    eval {\n      for my $pfile (ls($odir)) {\n        if ($pfile eq '.errors') {\n          my $e = readstr(\"$odir/.errors\");\n          $e ||= 'empty .errors file';\n          die($e);\n        }\n\tunless ($pfile =~ /^_service[_:]/) {\n\t  unlink($lockfile);\n\t  die(\"service returned a non-_service file: $pfile\\n\");\n\t}\n\tBSVerify::verify_filename($pfile);\n\t$files->{$pfile} = addfile($projid, $packid, \"$odir/$pfile\", $pfile);\n      }\n    };\n    $error = $@ if $@;\n  } else {\n    $error ||= 'error';\n    $error = \"service daemon error:\\n $error\";\n  }\n  if ($linkfiles) {\n    # argh, a link! put service run result in old filelist\n    if (!$error) {\n      $linkfiles->{$_} = $files->{$_} for grep {/^_service[_:]/} keys %$files;\n    }\n    $files = $linkfiles;\n  }\n  addrev_service($cgi, $rev, $files, $error);\n  BSUtil::cleandir($odir);\n  rmdir($odir);\n  unlink($lockfile);\n  notify_repservers('package', $projid, $packid);\n  exit(0);\n}\n\nsub triggerservicerun {\n  my ($cgi, $projid, $packid) = @_;\n  my $rev = getrev($projid, $packid);\n  my $linkinfo = {};\n  my $files = lsrev($rev, $linkinfo);\n  $cgi->{'triggerservicerun'} = 1;\t# hack\n  if ($BSConfig::old_style_services) {\n    # old style, just run the service again...\n    runservice($cgi, $rev, $files);\n  } else {\n    my $servicemark = genservicemark($projid, $packid, $files);\n    if ($servicemark || $linkinfo->{'xservicemd5'} || $packid eq '_product') {\n      # have to do a new commit...\n      $cgi->{'comment'} ||= 'trigger service run';\n      $cgi->{'servicemark'} = $servicemark;\n      $rev = addrev($cgi, $projid, $packid, $files);\n      runservice($cgi, $rev, $files);\n    } else {\n      die(\"404 no source service defined!\\n\");\n    }\n  }\n  return $BSStdServer::return_ok;\n}\n\n#\n# run the productconverter on _product to create/update/delete\n# all _product:xxx packages\n#\nsub expandproduct {\n  my ($projid, $packid, $rev, $files, $user, $fail) = @_;\n\n  if (!$files) {\n    # gone!\n    # {} argument makes findpackages ignore packages from project links\n    my @packages = grep {/^\\Q${packid}:\\E/} findpackages($projid, {});\n    for my $opid (@packages) {\n      unlink(\"$projectsdir/$projid.pkg/$opid.upload-MD5SUMS\");\n      unlink(\"$projectsdir/$projid.pkg/$opid.rev\");\n      unlink(\"$projectsdir/$projid.pkg/$opid.xml\");\n      notify_repservers('package', $projid, $opid);\n    }\n    return 1;\n  }\n  if ($files->{'_link'}) {\n    eval {\n      $files = handlelinks({ %$rev, 'project' => $projid, 'package' => $packid }, $files);\n      die(\"$files\\n\") unless ref $files;\n    };\n    if ($@) {\n      die($@) if $fail;\n      return undef;\n    }\n  }\n  my $dir = \"$uploaddir/expandproduct_$$\";\n  BSUtil::cleandir($dir);\n  mkdir_p($dir);\n  for my $file (sort keys %$files) {\n    link(\"$srcrep/$packid/$files->{$file}-$file\", \"$dir/$file\") || die(\"link $srcrep/$packid/$files->{$file}-$file $dir/$file: $!\\n\");\n  }\n  my @prods = grep {/.product$/}  sort keys %$files;\n  my %pids;\n  for my $prod (@prods) {\n    print \"converting product $prod\\n\";\n    my $odir = \"$dir/$prod.out\";\n    my $olog = \"$dir/$prod.logfile\";\n    system('rm', '-rf', $odir) if -d $odir;\n    unlink($olog) if -e $olog;\n    mkdir_p($odir);\n    # run product converter and read stdout\n    my $pid;\n    if (!($pid = xfork())) {\n      delete $SIG{'__DIE__'};\n      open(STDOUT, '>>', $olog) || die(\"$olog: $!\\n\");\n      open(STDERR, '>&STDOUT');\n      $| = 1;\n      exec(\"./bs_productconvert\", \"$dir/$prod\", $odir, $projid);\n      die(\"500 bs_productconvert: $!\\n\");\n    }\n    waitpid($pid, 0) == $pid || die(\"500 waitpid $pid: $!\\n\");\n    if ($?) {\n      my $s = readstr($olog);\n      $s =~ s/^\\n+//s;\n      $s =~ s/\\n+$//s;\n      warn(\"bs_productconvert failed: $?\\n\");\n      BSUtil::cleandir($dir);\n      rmdir($dir);\n      die(\"$s\\n\") if $fail;\n      return undef;\n    }\n    my @out = sort(ls($odir));\n    if (!@out) {\n      warn(\"bs_productconvert produced nothing\\n\");\n      BSUtil::cleandir($dir);\n      rmdir($dir);\n      return undef;\n    }\n    for my $p (@out) {\n      my $pdir = \"$odir/$p\";\n      my $pid = $p;\n      $pid =~ s/^_product[_:]//;\n      $pid =~ s/[:\\000-\\037]/_/sg;\n      $pid = \"$packid:$pid\";\n      $pids{$pid} = 1;\n      my %pfiles;\n      for my $pfile (sort(ls($pdir))) {\n        next if $pfile eq '_meta';\n\t$pfiles{$pfile} = addfile($projid, $pid, \"$pdir/$pfile\", $pfile);\n      }\n      my $srcmd5 = addmeta($projid, $pid, \\%pfiles);\n      my @oldrevs = BSFileDB::fdb_getall(\"$projectsdir/$projid.pkg/$pid.rev\", $srcrevlay);\n      if (@oldrevs == 1 && $oldrevs[0]->{'srcmd5'} eq $srcmd5 && $oldrevs[0]->{'rev'}) {\n\t# we're lucky, no change\n\tnext;\n      }\n      mkdir_p(\"$projectsdir/$projid.pkg\");\n      my $prev = {'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => 'autogenerated', 'version' => '1', 'vrev' => '1'};\n      #unlink(\"$projectsdir/$projid.pkg/$pid.rev\");\n      #BSFileDB::fdb_add_i2(\"$projectsdir/$projid.pkg/$pid.rev\", $srcrevlay, $prev, 'vrev', 'version', $prev->{'version'});\n      BSFileDB::fdb_add_i(\"$projectsdir/$projid.pkg/$pid.rev\", $srcrevlay, $prev);\n      if (! -e \"$projectsdir/$projid.pkg/$pid.xml\") {\n        my $pidpack = {\n         'name' => $pid,\n         'title' => $pid,\n         'description' => \"autogenerated from $packid by source server\",\n        };\n\t$pidpack = readxml(\"$pdir/_meta\", $BSXML::pack, 0) if ( -e \"$pdir/_meta\" );\n\twritexml(\"$projectsdir/$projid.pkg/.$pid.xml\", \"$projectsdir/$projid.pkg/$pid.xml\", $pidpack, $BSXML::pack);\n      }\n      rmdir($pdir);\n      notify_repservers('package', $projid, $pid);\n    }\n    rmdir($odir);\n  }\n  BSUtil::cleandir($dir);\n  rmdir($dir);\n  # now do away with the old packages\n  my @packages = grep {/^\\Q${packid}:\\E/} findpackages($projid, {});\n  @packages = grep {!$pids{$_}} @packages;\n  for my $opid (@packages) {\n    unlink(\"$projectsdir/$projid.pkg/$opid.upload-MD5SUMS\");\n    unlink(\"$projectsdir/$projid.pkg/$opid.rev\");\n    unlink(\"$projectsdir/$projid.pkg/$opid.xml\");\n    notify_repservers('package', $projid, $opid);\n  }\n  return 1;\n}\n\n#\n# return version and release of commit\n#\nsub getcommitinfo {\n  my ($projid, $packid, $srcmd5, $files) = @_;\n\n  # get version/release from rpm spec/deb dsc/kiwi xml file\n  my $version = 'unknown';\n  my $release;\n  if ($files->{'_link'}) {\n    # can't know the version/release of a link as it is\n    # a moving target\n    return ('unknown', '0');\n  }\n  my $cfile;\n  $cfile = \"$projectsdir/$projid.conf\" if -e \"$projectsdir/$projid.conf\";\n  my $bconf = Build::read_config('noarch', $cfile);\n  for my $type ('spec', 'dsc', 'kiwi') {\n    my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $srcmd5};\n    my (undef, $file) = findfile($rev, undef, $type, $files);\n    next unless defined $file;\n    my $d = Build::parse($bconf, \"$srcrep/$packid/$files->{$file}-$file\");\n    next unless defined $d->{'version'};\n    $version = $d->{'version'};\n    $release = $d->{'release'} if defined $d->{'release'};\n    $version = 'unknown' if $d->{'multiversion'};\n    last;\n  }\n  if (defined($release)) {\n    if ($release =~ /(\\d+)\\.<B_CNT>/) {\n      $release = $1;\n    } elsif ($release =~ /<RELEASE(\\d+)>/) {\n      $release = $1;\n    } elsif ($release =~ /^(\\d+)/) {\n      $release = $1;\n    } else {\n      $release = '0';\n    }\n  }\n  $release ||= '0';\n  if ($bconf->{'cicntstart'} && $bconf->{'cicntstart'} =~ /(\\d+)$/) {\n    my $r = $release;\n    $release = $bconf->{'cicntstart'};\n    $release =~  s/\\d+$/$r/ if $r > $1;\n  }\n  return ($version, $release);\n}\n\nsub checksourceaccess {\n  my ($projid, $packid) = @_;\n\n  my $proj = readproj($projid, 1);\n  return unless $proj;\n  my $pack = readpack($projid, $packid, 1);\n  my $sourceaccess = 1;\n  $sourceaccess = BSUtil::enabled('', $proj->{'sourceaccess'}, $sourceaccess, '');\n  $sourceaccess = BSUtil::enabled('', $pack->{'sourceaccess'}, $sourceaccess, '') if $pack;\n  die(\"403 source access denied\\n\") unless $sourceaccess;\n  my $access = 1;\n  $access = BSUtil::enabled('', $proj->{'access'}, $access, '');\n  $access = BSUtil::enabled('', $pack->{'access'}, $access, '') if $pack;\n  die(\"404 package '$packid' does not exist\\n\") unless $access;\t# hmm...\n  return 1;\n}\n\n###########################################################################\n###\n###  low level source handling: tree and revision management\n###\n\nsub repgitdir {\n  my ($rev) = @_;\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  my $gitdir = \"$projectsdir/$projid.pkg/$packid.git\";\n  die(\"$projid/$packid is not a git repository\\n\") unless -d $gitdir;\n  return $gitdir;\n}\n\nsub repstat_git {\n  my ($rev, $filename, $id) = @_;\n  my $gitdir = repgitdir($rev);\n  open(F, '-|', 'git', \"--git-dir=$gitdir\", 'cat-file', '-s', $id) || return ();\n  my $size= '';\n  1 while sysread(F, $size, 4096, length($size));\n  if (!close(F)) {\n    $! = POSIX::ENOENT;\n    return ();\n  }\n  my @s = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  $s[7] = 0 + $size;\n  return @s;\n}\n\nsub repopen_git {\n  my ($rev, $filename, $id, $fd) = @_;\n  my $gitdir = repgitdir($rev);\n  return open($fd, '-|', 'git', \"--git-dir=$gitdir\", 'cat-file', 'blob', $id);\n}\n\n\nsub repstat {\n  my ($rev, $filename, $md5) = @_;\n  return repstat_git($rev, $filename, $md5) if length($md5) == 40;\n  return stat(repfilename($rev, $filename, $md5)) if $filename eq '_serviceerror';\n  return stat(\"$srcrep/$rev->{'package'}/$md5-$filename\");\n}\n\nsub repopen {\n  my ($rev, $filename, $md5, $fd) = @_;\n  return repopen_git($rev, $filename, $md5, $fd) if length($md5) == 40;\n  return open($fd, '<', repfilename($rev, $filename, $md5)) if $filename eq '_serviceerror';\n  return open($fd, '<', \"$srcrep/$rev->{'package'}/$md5-$filename\");\n}\n\nsub repreadstr {\n  my ($rev, $filename, $md5, $nonfatal) = @_;\n  my $packid = $rev->{'package'};\n  return readstr(\"$srcrep/$packid/$md5-$filename\", $nonfatal);\n}\n\nsub repreadxml {\n  my ($rev, $filename, $md5, $dtd, $nonfatal) = @_;\n  my $packid = $rev->{'package'};\n  return readxml(\"$srcrep/$packid/$md5-$filename\", $dtd, $nonfatal);\n}\n\nsub repfilename {\n  my ($rev, $filename, $md5) = @_;\n  if ($filename eq '_serviceerror') {\n    # sigh, _serviceerror files live in the trees...\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$rev->{'project'}/$rev->{'package'}\" : \"$treesdir/$rev->{'package'}\";\n    return \"$treedir/$md5-_serviceerror\" if -e \"$treedir/$md5-_serviceerror\";\n  }\n  return \"$srcrep/$rev->{'package'}/$md5-$filename\";\n}\n\n#\n# add a file to the repository\n#\nsub addfile {\n  my ($projid, $packid, $tmpfile, $filename, $md5) = @_;\n\n  if (!$md5) {\n    open(F, '<', $tmpfile) || die(\"$tmpfile: $!\\n\");\n    my $ctx = Digest::MD5->new;\n    $ctx->addfile(*F);\n    close F;\n    $md5 = $ctx->hexdigest();\n  }\n  if (! -e \"$srcrep/$packid/$md5-$filename\") {\n    if (!rename($tmpfile, \"$srcrep/$packid/$md5-$filename\")) {\n      mkdir_p(\"$srcrep/$packid\");\n      if (!rename($tmpfile, \"$srcrep/$packid/$md5-$filename\")) {\n        my $err = $!;\n        if (! -e \"$srcrep/$packid/$md5-$filename\") {\n          $! = $err;\n          die(\"rename $tmpfile $srcrep/$packid/$md5-$filename: $!\\n\");\n        }\n      }\n    }\n  } else {\n    unlink($tmpfile);\n  }\n  return $md5;\n}\n\n#\n# make files available in oprojid/opackid available from projid/packid\n#\nsub copyfiles {\n  my ($projid, $packid, $oprojid, $opackid, $files, $except) = @_;\n\n  return if $packid eq $opackid;\n  return unless %$files;\n  mkdir_p(\"$srcrep/$packid\");\n  for my $f (sort keys %$files) {\n    next if $except && $except->{$f};\n    next if -e \"$srcrep/$packid/$files->{$f}-$f\";\n    link(\"$srcrep/$opackid/$files->{$f}-$f\", \"$srcrep/$packid/$files->{$f}-$f\");\n    die(\"link error $srcrep/$opackid/$files->{$f}-$f\\n\") unless -e \"$srcrep/$packid/$files->{$f}-$f\";\n  }\n}\n\nsub getrev_git {\n  my ($projid, $packid, $rev) = @_;\n  my $gitdir = \"$projectsdir/$projid.pkg/$packid.git\";\n  die(\"$projid/$packid is not a git repository\") unless -d $gitdir;\n  if (!$rev) {\n    my $master = readstr(\"$gitdir/refs/heads/master\");\n    chomp $master;\n    $rev = $master;\n  }\n  die(\"revision is not a valid git id\\n\") unless $rev =~ /^[0-9a-f]{40}/s;\n  open(F, '-|', 'git', \"--git-dir=$gitdir\", 'cat-file', 'commit', $rev) || return undef;\n  my $commit = '';\n  1 while sysread(F, $commit, 4096, length($commit));\n  close F;\n  $commit =~ s/.*?\\n\\n//;\n  $rev = {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};\n  $rev->{'comment'} = $commit if $commit ne '';\n  return $rev;\n}\n\nsub get_frozenlinks {\n  my ($projid) = @_;\n  return $frozenlinks_cache->{$projid} if $frozenlinks_cache && exists $frozenlinks_cache->{$projid};\n  my $rev = getrev_meta($projid);\n  my $files = lsrev($rev);\n  my $frozen;\n  if ($files->{'_frozenlinks'}) {\n    my $frozenx = repreadxml($rev, '_frozenlinks', $files->{'_frozenlinks'}, $BSXML::frozenlinks);\n    $frozen = {};\n    for my $fp (@{$frozenx->{'frozenlink'} || []}) {\n      my $n = defined($fp->{'project'}) ? $fp->{'project'} : '/all';\n      for my $p (@{$fp->{'package'} || []}) {\n\tmy $pn = delete $p->{'name'};\n        $frozen->{$n}->{$pn} = $p if defined($pn) && $p->{'srcmd5'};\n      }\n    }\n  }\n  $frozenlinks_cache->{$projid} = $frozen if $frozenlinks_cache;\n  return $frozen;\n}\n\n#\n# get a revision object from a revision identifier\n#\nsub getrev {\n  my ($projid, $packid, $rev, $linked, $missingok) = @_;\n  die(\"bad projid\\n\") if $projid =~ /\\// || $projid =~ /^\\./;\n  die(\"bad packid\\n\") if $packid =~ /\\// || $packid =~ /^\\./;\n  if ($packid ne '_project' && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n    my $proj = readproj($projid, 1);\n    if ($proj && $proj->{'link'}) {\n      my $collect_error;\n      $linked ||= [];\n      my $frozen = get_frozenlinks($projid);\n      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {\n\tnext if $lprojid eq $projid;\n\tnext if grep {$_->{'project'} eq $lprojid && $_->{'package'} eq $packid} @$linked;\n\tpush @$linked, {'project' => $lprojid, 'package' => $packid};\n        my $frozenp = $frozen->{'/all'} || $frozen->{$lprojid};\n\tmy $lrev;\n        if ($frozenp->{$packid} && !($rev && $rev =~ /^[0-9a-f]{32}$/)) {\n\t  eval {\n\t    $lrev = getrev($lprojid, $packid, $frozenp->{$packid}->{'srcmd5'}, $linked, $missingok);\n\t    $lrev->{'vrev'} = $frozenp->{$packid}->{'vrev'} if defined $frozenp->{$packid}->{'vrev'};\n\t  };\n\t} else {\n\t  eval {\n\t    $lrev = getrev($lprojid, $packid, $rev, $linked, $missingok);\n\t  };\n\t}\n\tnext if $collect_error;\n\tif ($@ && $@ !~ /^404/) {\n\t  if ($collect_remote_getrev && $@ =~ /collect_remote_getrev$/) {\n\t    # special case for project links, we don't know if the package exists yet,\n\t    # so collect from all link elements\n\t    $collect_error = $@;\n\t    next;\n\t  }\n\t  die($@);\n\t}\n\tif ($lrev) {\n\t  # make sure that we may access the sources of this package\n\t  checksourceaccess($lprojid, $packid);\n\t  my $files = lsrev($lrev);\n\t  copyfiles($projid, $packid, $lprojid, $packid, $files);\n\t  my $srcmd5 = $lrev->{'srcmd5'};\n\t  if ($BSConfig::nosharedtrees && $srcmd5 ne $emptysrcmd5) {\n\t    # copy the tree\n\t    my $treedir = \"$treesdir/$projid/$packid\";\n\t    if (! -e \"$treedir/$srcmd5-MD5SUMS\") {\n\t      my $ltreedir = \"$treesdir/$lprojid/$packid\";\n\t      $ltreedir = \"$srcrep/$packid\" if $BSConfig::nosharedtrees == 2 && ! -e \"$ltreedir/$srcmd5-MD5SUMS\";\n\t      if (-e \"$ltreedir/$srcmd5-MD5SUMS\") {\n\t\tmy $meta = readstr(\"$ltreedir/$srcmd5-MD5SUMS\");\n\t        mkdir_p($treedir);\n\t\twritestr(\"$uploaddir/$$\", \"$treedir/$srcmd5-MD5SUMS\", $meta);\n\t      } else {\n\t\taddmeta($projid, $packid, $files);\t# last resort...\n\t      }\n\t    }\n\t  }\n\t  $lrev->{'originproject'} ||= $lprojid;\n\t  $lrev->{'project'} = $projid;\n\t  return $lrev;\n\t}\n      }\n      die($collect_error) if $collect_error;\n    }\n    if (defined($rev) && $rev =~ /^[0-9a-f]{32}$/) {\n      # getrev by srcmd5. we allow access to packages that were deleted.\n      my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n      if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e \"$treedir/$rev-MD5SUMS\") {\n\t$treedir = \"$srcrep/$packid\";\n      }\n      if ($rev eq $emptysrcmd5 || -e \"$treedir/$rev-MD5SUMS\") {\n        # tree exists. make sure we knew the project/package at one time in the past\n        if (-e \"$projectsdir/$projid.pkg/$packid.mrev.del\" ||\n            -e \"$projectsdir/_deleted/$projid.pkg/$packid.mrev\" ||\n            -e \"$projectsdir/_deleted/$projid.pkg/$packid.mrev.del\") {\n          return {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};\n        }\n      }\n    }\n    return remote_getrev($projid, $packid, $rev, $linked, $missingok);\n  }\n  undef $rev if $rev && ($rev eq 'latest' || $rev eq 'build');\n  undef $rev if $rev && $rev eq 'upload' && ! -e \"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\";\n  if (!defined($rev)) {\n    $rev = BSFileDB::fdb_getlast(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay);\n    if (!$rev && -d \"$projectsdir/$projid.pkg/$packid.git\") {\n      return getrev_git($projid, $packid);\n    }\n    if (!$rev && ($packid eq '_project' && -e \"$projectsdir/$projid.conf\")) {\n      addrev_meta({'user' => 'internal', 'comment' => 'initial commit'}, $projid, undef, undef, undef, undef, 'rev');\n      $rev = BSFileDB::fdb_getlast(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay);\n    }\n    $rev = {'srcmd5' => $emptysrcmd5} unless $rev;\n  } elsif ($rev =~ /^[0-9a-f]{32}$/) {\n    return undef unless -e \"$projectsdir/$projid.pkg/$packid.rev\" || -e \"$projectsdir/$projid.pkg/$packid.mrev\";\n    $rev = {'srcmd5' => $rev, 'rev' => $rev};\n  } elsif ($rev =~ /^[0-9a-f]{40}$/) {\n    return getrev_git($projid, $packid, $rev);\n  } elsif ($rev eq 'upload') {\n    $rev = {'srcmd5' => 'upload', 'rev' => 'upload'}\n  } elsif ($rev eq 'repository') {\n    $rev = {'srcmd5' => $emptysrcmd5, 'rev' => 'repository'}\n  } else {\n    if ($rev eq '0') {\n      $rev = {'srcmd5' => $emptysrcmd5};\n    } else {\n      $rev = BSFileDB::fdb_getmatch(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, 'rev', $rev);\n      die(\"no such revision\\n\") unless defined $rev;\n    }\n  }\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n  return $rev;\n}\n\n# get a revision object for a deleted project/package\n# XXX: fold into getrev\nsub getrev_deleted {\n  my ($projid, $packid, $rev) = @_;\n  undef $rev if $rev && ($rev eq 'latest' || $rev eq 'build');\n  return getrev($projid, $packid, $rev) if defined($rev) && $rev !~ /^\\d{1,31}$/;\n  my $revfile = $packid ne '_project' ? \"$projectsdir/$projid.pkg/$packid.rev.del\" : \"$projectsdir/_deleted/$projid.pkg/_project.rev\";\n  if ($packid ne '_project' && ! -e $revfile && ! -e \"$projectsdir/$projid.xml\" && -e \"$projectsdir/_deleted/$projid.pkg\") {\n    $revfile = \"$projectsdir/_deleted/$projid.pkg/$packid.rev\";\n  }\n  if (!defined($rev)) {\n    $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);\n  } elsif ($rev eq '0') {\n    $rev = {'srcmd5' => $emptysrcmd5};\n  } else {\n    $rev = BSFileDB::fdb_getmatch($revfile, $srcrevlay, 'rev', $rev);\n  }\n  die(\"no such revision\\n\") unless defined $rev;\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n  return $rev;\n}\n\nsub addmeta {\n  my ($projid, $packid, $files, $rev) = @_;\n\n  # calculate new meta sum\n  my $meta = '';\n  $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n  my $srcmd5 = Digest::MD5::md5_hex($meta);\n  if ($rev && $rev eq 'upload') {\n    mkdir_p($uploaddir);\n    mkdir_p(\"$projectsdir/$projid.pkg\");\n    writestr(\"$uploaddir/addmeta$$\", \"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\", $meta);\n  } else {\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n    if (! -e \"$treedir/$srcmd5-MD5SUMS\") {\n      mkdir_p($uploaddir);\n      mkdir_p($treedir);\n      writestr(\"$uploaddir/addmeta$$\", \"$treedir/$srcmd5-MD5SUMS\", $meta);\n    }\n  }\n  return $srcmd5;\n}\n\n# used only in fake_service_run. must match addmeta\nsub calcsrcmd5 {\n  my ($files) = @_;\n  my $meta = '';\n  $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n  return Digest::MD5::md5_hex($meta);\n}\n\n# like addmeta, but adds link information. also stores\n# under the \"wrong\" md5sum.\nsub addmeta_link {\n  my ($projid, $packid, $files, $srcmd5, $linkinfo) = @_;\n\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  if (! -e \"$treedir/$srcmd5-MD5SUMS\") {\n    my $meta = '';\n    $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n    $meta .= \"$linkinfo->{'srcmd5'}  /LINK\\n\";\n    $meta .= \"$linkinfo->{'lsrcmd5'}  /LOCAL\\n\";\n    mkdir_p($uploaddir);\n    mkdir_p($treedir);\n    writestr(\"$uploaddir/$$\", \"$treedir/$srcmd5-MD5SUMS\", $meta);\n  }\n}\n\n\n# like addmeta, but adds service information after a source\n# service finished successfully. stores under the \"wrong\" md5sum.\nsub addmeta_service {\n  my ($projid, $packid, $files, $srcmd5, $lservicemd5) = @_;\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  return if -e \"$treedir/$srcmd5-MD5SUMS\";\t# huh? why did we run twice?\n  my $meta = '';\n  $meta .= \"$files->{$_}  $_\\n\" for grep {$_ ne '/SERVICE' && $_ ne '/LSERVICE'} sort keys %$files;\n  $meta .= \"$lservicemd5  /LSERVICE\\n\";\n  mkdir_p($uploaddir);\n  mkdir_p($treedir);\n  writestr(\"$uploaddir/$$\", \"$treedir/$srcmd5-MD5SUMS\", $meta);\n  unlink(\"$treedir/$srcmd5-_serviceerror\");\n}\n\nsub addmeta_serviceerror {\n  my ($projid, $packid, $srcmd5, $error) = @_;\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  if (!defined($error)) {\n    unlink(\"$treedir/$srcmd5-_serviceerror\");\n  } else {\n    # normalize the error\n    $error =~ s/[\\r\\n]+$//s;\n    $error ||= 'unknown service error';\n    mkdir_p($treedir);\n    writestr(\"$treedir/.$srcmd5-_serviceerror\", \"$treedir/$srcmd5-_serviceerror\", \"$error\\n\");\n  }\n}\n\nsub addmeta_serialize_servicerun {\n  my ($projid, $packid, $srcmd5) = @_;\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  mkdir_p($treedir);\n  local *FF;\n  BSUtil::lockopen(\\*FF, '+>>', \"$treedir/$srcmd5-_serviceerror\");\n  if (-s FF) {\n    # already running or failed!\n    close FF;\t# free lock\n    return undef;\n  }\n  writestr(\"$treedir/.$srcmd5-_serviceerror\", \"$treedir/$srcmd5-_serviceerror\", \"service in progress\\n\");\n  close FF;\t# free lock\n  return 1;\n}\n\nsub updatelinkinfodb {\n  my ($projid, $packid, $rev, $files) = @_;\n\n  mkdir_p($sourcedb) unless -d $sourcedb;\n  my $linkdb = BSDB::opendb($sourcedb, 'linkinfo');\n  my $linkinfo;\n  if ($files && $files->{'_link'}) {\n    my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);\n    if ($l) {\n      $linkinfo = {};\n      $linkinfo->{'project'} = defined $l->{'project'} ? $l->{'project'} : $projid;\n      $linkinfo->{'package'} = defined $l->{'package'} ? $l->{'package'} : $packid;\n      $linkinfo->{'rev'} = $l->{'rev'} if defined $l->{'rev'};\n    }\n  }\n  $linkdb->store(\"$projid/$packid\", $linkinfo);\n}\n\n# ugly hack to support 'noservice' uploads. we fake a service run\n# result and strip all files from the commit that look like they\n# were generated by a service run.\n\nsub can_reuse_oldservicemark {\n  my ($projid, $packid, $files, $oldservicemark) = @_;\n\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  return 0 if -e \"$treedir/$oldservicemark-_serviceerror\";\n  my $oldmeta = readstr(\"$treedir/$oldservicemark-MD5SUMS\", 1);\n  # does not exist -> reuse it and hope for the best\n  return 1 if !$oldmeta;\n  # be extra carful here and make sure our data matches\n  # calculate LSRCMD5 from file list\n  my $nfiles = { %$files };\n  delete $nfiles->{$_} for grep {/^_service[:_]/} keys %$nfiles;\n  $nfiles->{'/SERVICE'} = $oldservicemark;\n  my $meta = '';\n  $meta .= \"$nfiles->{$_}  $_\\n\" for sort keys %$nfiles;\n  my $nsrcmd5 = Digest::MD5::md5_hex($meta);\n  # calculate new meta\n  $meta = '';\n  $meta .= \"$files->{$_}  $_\\n\" for grep {$_ ne '/SERVICE' && $_ ne '/LSERVICE'} sort keys %$files;\n  $meta .= \"$nsrcmd5  /LSERVICE\\n\";\n  return 1 if $oldmeta eq $meta;\n  return 0;\n}\n\nsub servicemark_noservice {\n  my ($cgi, $projid, $packid, $files, $target, $oldservicemark) = @_;\n\n  my $servicemark;\n  if (exists($cgi->{'servicemark'})) {\n    $servicemark = $cgi->{'servicemark'};\n  } else {\n    # if not given via cgi, autodetect\n    if ($oldservicemark && can_reuse_oldservicemark($projid, $packid, $files, $oldservicemark)) {\n      $servicemark = $oldservicemark;\n    } else {\n      if ($files->{'_service'} || grep {/^_service[:_]/} keys %$files) {\n        $servicemark = genservicemark($projid, $packid, $files, $target, 1);\n      }\n    }\n  }\n  return (undef, $files) unless $servicemark;\n\n  # ok, fake a service run\n  my $nfiles = { %$files };\n  delete $nfiles->{$_} for grep {/^_service[:_]/} keys %$nfiles;\n  fake_service_run($projid, $packid, $nfiles, $files, $servicemark);\n  return ($servicemark, $nfiles);\n}\n\n##\n# generate_commit_flist($files_old, $files_new)\n#\n#   $files_old/$files_new are hash references as returned by lsrep\n#\n#   returns a list of changed files categorized similar to svn commit mails\n#\nsub generate_commit_flist {\n  my $ret = \"\";\n  my %categorized_files;\n  my ($files_old, $files_new) = @_;\n  my %files_all = (%$files_new, %$files_old);\n  for my $fname (sort keys %files_all) {\n    if(!$files_old->{$fname}) {\n      my $flist = $categorized_files{\"Added:\"} ||= [];\n      push(@$flist, $fname);\n    } elsif(!$files_new->{$fname}) {\n      my $flist = $categorized_files{\"Deleted:\"} ||= [];\n      push(@$flist, $fname);\n    } elsif($files_old->{$fname} ne $files_new->{$fname}) {\n      my $flist = $categorized_files{\"Modified:\"} ||= [];\n      push(@$flist, $fname);\n    }\n  }\n\n  for my $cat (sort keys %categorized_files) {\n    $ret .= \"$cat\\n\";\n    for my $fname (@{$categorized_files{$cat}}) {\n      $ret .= \"  $fname\\n\";\n    }\n    $ret .= \"\\n\";\n  }\n  return $ret;\n}\n\n#\n# create a new revision from a file list, returns revision object\n#\nsub addrev {\n  my ($cgi, $projid, $packid, $files, $target) = @_;\n  die(\"404 project '$projid' does not exist\\n\") unless -e \"$projectsdir/$projid.xml\";\n  if ($packid =~ /^_product:/) {\n    die(\"403 package '$packid' is read-only if a '_product' package exists\\n\") if -e \"$projectsdir/$projid.pkg/_product.xml\";\n  }\n  my $user = $cgi->{'user'};\n  my $comment = $cgi->{'comment'};\n  my $requestid = $cgi->{'requestid'};\n  $user = '' unless defined $user;\n  $user = 'unknown' if $user eq '';\n  $comment = '' unless defined $comment;\n  $user = str2utf8xml($user);\n  $comment = str2utf8xml($comment);\n\n  # check if the commit will need a service run\n  my $servicemark;\n  delete $files->{'/SERVICE'};\t# just in case...\n  if (!$BSConfig::old_style_services && $packid ne '_project') {\n    if ($cgi->{'noservice'}) {\n      ($servicemark, $files) = servicemark_noservice($cgi, $projid, $packid, $files, $target);\n    } else {\n      # we do not want any generated files in the commit!\n      delete $files->{$_} for grep {/^_service[:_]/} keys %$files;\n      $servicemark = exists($cgi->{'servicemark'}) ? $cgi->{'servicemark'} : genservicemark($projid, $packid, $files, $target);\n    }\n  }\n  if ($packid eq '_pattern' && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n    # upgrade pseudo _pattern package to real package\n    my $pack = {\n      'name' => $packid,\n      'project' => $projid,\n      'title' => 'pseudo package to store pattern information',\n      'description' => \"pseudo package to store pattern information\\n\",\n    };\n    mkdir_p($uploaddir);\n    writexml(\"$uploaddir/$$.2\", undef, $pack, $BSXML::pack);\n    mkdir_p(\"$projectsdir/$projid.pkg\");\n    addrev_meta($cgi, $projid, $packid, \"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/$packid.xml\", '_meta');\n  }\n  die(\"404 package '$packid' does not exist\\n\") unless $packid eq '_project' || -e \"$projectsdir/$projid.pkg/$packid.xml\";\n  if ($target && $target eq 'upload') {\n    my $srcmd5 = addmeta($projid, $packid, $files, 'upload');\n    my $filenames = join( ', ', keys %$files );\n    notify(\"SRCSRV_UPLOAD\", {project => $projid, package => $packid, filename => $filenames, comment => $comment, \n                             target => $target, requestid => $requestid, user => $user});\n    return {'project' => $projid, 'package' => $packid, 'rev' => 'upload', 'srcmd5' => $srcmd5};\n  } elsif ($target && $target eq 'repository') {\n    # repository only upload.\n    return {'project' => $projid, 'package' => $packid, 'rev' => 'repository', 'srcmd5' => $emptysrcmd5};\n  } elsif (defined($target)) {\n    # internal version only upload.\n    my $srcmd5 = addmeta($projid, $packid, $files);\n    return {'project' => $projid, 'package' => $packid, 'rev' => $srcmd5, 'srcmd5' => $srcmd5};\n  }\n  die(\"bad projid\\n\") if $projid =~ /\\// || $projid =~ /^\\./;\n  die(\"bad packid\\n\") if $packid =~ /\\// || $packid =~ /^\\./;\n  die(\"bad files (slash)\\n\") if grep {/\\// && $_ ne '/SERVICE'} keys %$files;\n  die(\"bad files (glyph)\\n\") if grep {!/^[0-9a-f]{32}$/} values %$files;\n\n  if ($files->{'_patchinfo'}) {\n    die(\"bad files in patchinfo container\\n\") if grep {$_ ne '_patchinfo'} keys %$files;\n    my $p = repreadxml({'project' => $projid, 'package' => $packid}, '_patchinfo', $files->{'_patchinfo'}, $BSXML::patchinfo);\n    BSVerify::verify_patchinfo($p);\n  }\n\n  # create tree entry\n  $files->{'/SERVICE'} = $servicemark if $servicemark;\n  my $srcmd5 = addmeta($projid, $packid, $files);\n  delete $files->{'/SERVICE'};\n\n  my $rev = {'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $requestid};\n\n  if ($packid eq '_product') {\n    expandproduct($projid, $packid, $rev, $files, $user, 1);\n  }\n\n  if ($packid ne '_project' && $packid ne '_pattern') {\n    my ($version, $release) = getcommitinfo($projid, $packid, $srcmd5, $files);\n    $rev->{'version'} = $version;\n    $rev->{'vrev'} = $release;\n  }\n  \n  my $rev_old = getrev($projid, $packid);\n  $rev_old->{'keepsignkey'} = 1;\n  my $files_old = lsrev($rev_old);\n  delete $rev_old->{'keepsignkey'};\n  my $filestr = generate_commit_flist($files_old, $files);\n\n  $rev->{'version'} = $cgi->{'version'} if defined $cgi->{'version'};\n  $rev->{'vrev'} = $cgi->{'vrev'} if defined $cgi->{'vrev'};\n  if ($cgi->{'time'}) {\n    die(\"specified time is less than time in last commit\\n\") if ($rev_old->{'time'} || 0) > $cgi->{'time'};\n    $rev->{'time'} = $cgi->{'time'};\n  }\n\n  my $acceptinfo;\n  if ($requestid) {\n    $acceptinfo = {};\n    $acceptinfo->{'osrcmd5'} = $rev_old->{'srcmd5'} if $rev_old->{'srcmd5'} ne 'empty';\n    if ($files_old->{'_link'}) {\n      # see if we can expand it\n      eval {\n\tmy %rev = %$rev_old;\n\thandlelinks(\\%rev, $files_old);\n\t$acceptinfo->{'oxsrcmd5'} = $rev{'srcmd5'};\n      };\n    }\n  }\n  if ($packid eq '_project') {\n    $rev = BSFileDB::fdb_add_i(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, $rev);\n    $rev->{'project'} = $projid;\n    $rev->{'package'} = $packid;\n    if ($acceptinfo) {\n      $acceptinfo->{'rev'} = $rev->{'rev'};\n      $acceptinfo->{'srcmd5'} = $rev->{'srcmd5'};\n      $rev->{'acceptinfo'} = $acceptinfo if $cgi->{'withacceptinfo'};\n    }\n    extract_old_prjsource($projid, $rev);\n    unlink(\"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\");\n    notify_repservers('project', $projid);\n    notify(\"SRCSRV_UPDATE_PROJECT_CONFIG\", { \"project\" => $projid, \"files\" => $filestr, \"comment\" => $comment, \"sender\" => $user });\n    return $rev;\n  }\n\n  # help a little with link<->nolink and singleversion<->multiversion changes\n  if (defined($rev->{'version'}) && defined($rev_old->{'version'}) && !defined($cgi->{'vrev'})) {\n    # if this is a known -> unknown version change, max with vrev of last commit\n    # same for unknown -> known\n    if (($rev->{'version'} eq 'unknown' && $rev_old->{'version'} ne 'unknown') ||\n        ($rev->{'version'} ne 'unknown' && $rev_old->{'version'} eq 'unknown')) {\n      my $l_old = 0;\n      $l_old = $1 if $rev_old->{'vrev'} =~ /(\\d+)$/;\n      my $l_new = 0;\n      $l_new = $1 if $rev->{'vrev'} =~ /(\\d+)$/;\n      $rev->{'vrev'} =~ s/\\d+$/$l_old + 1/e if $l_old + 1 > $l_new;\n    }\n  }\n\n  # add to revision database\n  if (defined($rev->{'version'}) && !defined($cgi->{'vrev'})) {\n    $rev = BSFileDB::fdb_add_i2(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, $rev, 'vrev', 'version', $rev->{'version'});\n  } else {\n    $rev = BSFileDB::fdb_add_i(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, $rev);\n  }\n\n  # add missing data to complete the revision object\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n\n  # update linked package database\n  updatelinkinfodb($projid, $packid, $rev, $files);\n\n  # update request acceptinfo\n  if ($acceptinfo) {\n    $acceptinfo->{'rev'} = $rev->{'rev'};\n    $acceptinfo->{'srcmd5'} = $rev->{'srcmd5'};\n    if ($files->{'_link'}) {\n      # see if we can expand it\n      eval {\n\tmy %rev = %$rev;\n\thandlelinks(\\%rev, $files);\n\t$acceptinfo->{'xsrcmd5'} = $rev{'srcmd5'};\n      };\n    }\n    $rev->{'acceptinfo'} = $acceptinfo if $cgi->{'withacceptinfo'};\n  }\n\n  # send out notification\n  notify(\"SRCSRV_COMMIT\", {project => $projid, package => $packid, files => $filestr, rev => $rev->{'rev'}, user => $user, comment => $comment, 'requestid' => $requestid});\n  $rev_old->{'version'} = \"unknown\" unless defined($rev_old->{'version'});\n  notify(\"SRCSRV_VERSION_CHANGE\", {project => $projid, package => $packid, files => $filestr, rev => $rev->{'rev'},\n                                   oldversion => $rev_old->{'version'}, newversion => $rev->{'version'},\n                                   user => $user, comment => $comment, 'requestid' => $requestid})\n    if defined($rev->{'version'}) && defined($rev_old->{'version'}) && $rev->{'version'} ne $rev_old->{'version'};\n\n  # kill upload revision as we did a real commit\n  unlink(\"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\");\n  # kill obsolete _pattern file\n  unlink(\"$projectsdir/$projid.pkg/pattern-MD5SUMS\") if $packid eq '_pattern';\n\n  notify_repservers('package', $projid, $packid);\n\n  # put marker back\n  $files->{'/SERVICE'} = $servicemark if $servicemark;\n  return $rev;\n}\n\nsub lsrev_git {\n  my ($rev, $linkinfo) = @_;\n  my $id = $rev->{'srcmd5'};\n  local *F;\n  my $gitdir = repgitdir($rev);\n  open(F, '-|', 'git', \"--git-dir=$gitdir\", 'cat-file', 'tree', $id) || die(\"git: $!\\n\");\n  my $tree = '';\n  1 while sysread(F, $tree, 4096, length($tree));\n  close(F) || die(\"bad id\\n\");\n  my $files = {};\n  while ($tree =~ /(\\d+) ([^\\000]*)\\000(.{20})/sg) {\n    next if $1 eq '40000';\t\t# ignore dirs for now\n    next if substr($2, 0, 1) eq '.';\t# ignore files starting with . for now\n    $files->{$2} = unpack('H*', $3);\n  }\n  return $files;\n}\n\n#\n# retrieve the file list of a revision object or tree object\n# store merge info in linkinfo if available\n#\nsub lsrev {\n  my ($rev, $linkinfo) = @_;\n\n  die(\"nothing known\\n\") unless $rev;\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  my $srcmd5 = $rev->{'srcmd5'};\n  die(\"revision project missing\\n\") unless defined $projid;\n  die(\"revision package missing\\n\") unless defined $packid;\n  die(\"no such revision\\n\") unless defined $srcmd5;\n  local *F;\n  die(\"bad packid\\n\") if $packid =~ /\\// || $packid =~ /^\\./;\n  if ($srcmd5 eq 'upload') {\n    open(F, '<', \"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\") || die(\"$packid/$srcmd5-$packid: not in repository\\n\");\n  } elsif ($srcmd5 eq 'pattern') {\n    open(F, '<', \"$projectsdir/$projid.pkg/pattern-MD5SUMS\") || return {};\n  } elsif ($srcmd5 eq 'empty' || $srcmd5 eq $emptysrcmd5) {\n    return {};\n  } elsif (length($srcmd5) == 40) {\n     return lsrev_git($rev, $linkinfo);\n  } else {\n    die(\"bad srcmd5 '$srcmd5'\\n\") if $srcmd5 !~ /^[0-9a-f]{32}$/;\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n    if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e \"$treedir/$srcmd5-MD5SUMS\" && -e \"$srcrep/$packid/$srcmd5-MD5SUMS\") {\n      $treedir = \"$srcrep/$packid\";\n    }\n    if (!open(F, '<', \"$treedir/$srcmd5-MD5SUMS\")) {\n      return {'_linkerror' => $srcmd5} if -e \"$srcrep/$packid/$srcmd5-_linkerror\";\n      return {'_serviceerror' => $srcmd5} if -s \"$treedir/$srcmd5-_serviceerror\";\n      die(\"$projid/$packid/$srcmd5: not in repository. Either not existing or misconfigured server setting for '\\$nosharedtrees' setting in BSConfig.pm\\n\");\n    }\n  }\n  my @files = <F>;\n  close F;\n  chomp @files;\n  my $files = {map {substr($_, 34) => substr($_, 0, 32)} @files};\n  # hack: do not list _signkey in project meta\n  delete $files->{'_signkey'} if $packid eq '_project' && !$rev->{'keepsignkey'};\n  if ($linkinfo) {\n    $linkinfo->{'lsrcmd5'} = $files->{'/LOCAL'} if $files->{'/LOCAL'};\n    $linkinfo->{'srcmd5'} = $files->{'/LINK'} if $files->{'/LINK'};\n    $linkinfo->{'xservicemd5'} = $files->{'/SERVICE'} if $files->{'/SERVICE'};\n    $linkinfo->{'lservicemd5'} = $files->{'/LSERVICE'} if $files->{'/LSERVICE'};\n  }\n  delete $files->{'/LINK'};\n  delete $files->{'/LOCAL'};\n  delete $files->{'/SERVICE'};\n  delete $files->{'/LSERVICE'};\n  return $files;\n}\n\n\n# find last revision that consisted of the tree object\nsub findlastrev {\n  my ($tree) = @_;\n  my $rev = BSFileDB::fdb_getmatch(\"$projectsdir/$tree->{'project'}.pkg/$tree->{'package'}.rev\", $srcrevlay, 'srcmd5', $tree->{'srcmd5'});\n  return undef unless $rev;\n  $rev->{'project'} = $tree->{'project'};\n  $rev->{'package'} = $tree->{'package'};\n  return $rev;\n}\n\n\n\n###########################################################################\n###\n###  source link handling\n###\n\nsub patchspec {\n  my ($p, $dir, $spec) = @_;\n  local *F;\n  open(F, '<', \"$dir/$spec\") || die(\"$dir/$spec: $!\\n\");\n  my @preamble;\n  while(<F>) {\n    chomp;\n    push @preamble, $_;\n    last if /^\\s*%(package|prep|build|install|check|clean|preun|postun|pretrans|posttrans|pre|post|files|changelog|description|triggerpostun|triggerun|triggerin|trigger|verifyscript)(\\s|$)/;\n  }\n  my %patches;\n  for (@preamble) {\n    next unless /^patch(\\d*)\\s*:/i;  \n    $patches{0 + ($1 eq '' ? 0 : $1)} = $_;\n  }\n  my @patches = sort {$a <=> $b} keys %patches;\n  my $nr = 0;\n  if (exists $p->{'after'}) {\n    $nr = 0 + $p->{'after'};\n    $nr++ while $patches{$nr};\n  } else {\n    $nr = $patches[-1] + 1 if @patches;\n  }\n  my @after;\n  @after = map {$patches{$_}} grep {$_ < $nr} @patches if @patches;\n  @after = grep {/^source(\\d*)\\s*:/i} @preamble if !@after;\n  @after = grep {/^name(\\d*)\\s*:/i} @preamble if !@after;\n  @after = $preamble[-2] if @preamble > 1 && !@after;\n  return \"could not find a place to insert the patch\" if !@after;\n  my $nrx = $nr;\n  $nrx = '' if $nrx == 0;\n  local *O;\n  open(O, '>', \"$dir/.patchspec$$\") || die(\"$dir/.patchspec$$: $!\\n\");\n  for (@preamble) {\n    print O \"$_\\n\";\n    next unless @after && $_ eq $after[-1];\n    print O \"Patch$nrx: $p->{'name'}\\n\";\n    @after = ();\n  }\n  if ($preamble[-1] !~ /^\\s*%prep(\\s|$)/) {\n    while (1) {\n      my $l = <F>;\n      return \"specfile has no %prep section\" if !defined $l;\n      chomp $l;\n      print O \"$l\\n\";\n      last if $l =~ /^\\s*%prep(\\s|$)/;\n    }\n  }\n  my @prep;\n  while(<F>) {\n    chomp;\n    push @prep, $_;\n    last if /^\\s*%(package|prep|build|install|check|clean|preun|postun|pretrans|posttrans|pre|post|files|changelog|description|triggerpostun|triggerun|triggerin|trigger|verifyscript)(\\s|$)/;\n  }\n  %patches = ();\n  my $ln = -1;\n  # find outmost pushd/popd calls and insert new patches after a pushd/popd block\n  # $blevel == 0 indicates the outmost block\n  my %bend = ();\n  my $bln = undef;\n  $$bln = $ln;\n  my $blevel = -1;\n  for (@prep) {\n    $ln++;\n    $blevel++ if /^pushd/;\n    if (/^popd/) {\n      unless ($blevel) {\n        $$bln = $ln;\n        undef $bln;\n        $$bln = $ln;\n      }\n      $blevel--;\n    }\n    next unless /%patch(\\d*)(.*)/;\n    if ($1 ne '') {\n      $patches{0 + $1} = $ln;\n      $bend{0 + $1} = $bln if $blevel >= 0;\n      next;\n    }\n    my $pnum = 0;\n    my @a = split(' ', $2);\n    if (! grep {$_ eq '-P'} @a) {\n      $patches{$pnum} = $ln;\n    } else {\n      while (@a) {\n        next if shift(@a) ne '-P';\n        next if !@a || $a[0] !~ /^\\d+$/;\n        $pnum = 0 + shift(@a);\n        $patches{$pnum} = $ln;\n      }\n    }\n    $bend{$pnum} = $bln if $blevel >= 0;\n  }\n  return \"specfile has broken %prep section\" unless $blevel == -1;\n  @patches = sort {$a <=> $b} keys %patches;\n  $nr = 1 + $p->{'after'} if exists $p->{'after'};\n  %patches = map { $_ => exists $bend{$_} ? ${$bend{$_}} : $patches{$_} } @patches;\n  @after = map {$patches{$_}} grep {$_ < $nr} @patches if @patches;\n  @after = ($patches[0] - 1) if !@after && @patches;\n  @after = (@prep - 2) if !@after;\n  my $after = $after[-1];\n  $after = -1 if $after < -1;\n  $ln = -1;\n  push @prep, '' if $after >= @prep;\n  #print \"insert %patch after line $after\\n\";\n  for (@prep) {\n    if (defined($after) && $ln == $after) {\n      print O \"pushd $p->{'dir'}\\n\" if exists $p->{'dir'};\n      if ($p->{'popt'}) {\n        print O \"%patch$nrx -p$p->{'popt'}\\n\";\n      } else {\n        print O \"%patch$nrx\\n\";\n      }\n      print O \"popd\\n\" if exists $p->{'dir'};\n      undef $after;\n    }\n    print O \"$_\\n\";\n    $ln++;\n  }\n  while(<F>) {\n    chomp;\n    print O \"$_\\n\";\n  }\n  close(O) || die(\"close: $!\\n\");\n  rename(\"$dir/.patchspec$$\", \"$dir/$spec\") || die(\"rename $dir/.patchspec$$ $dir/$spec: $!\\n\");\n  return '';\n}\n# \" Make emacs wired syntax highlighting happy\n\nsub topaddspec {\n  my ($p, $dir, $spec) = @_;\n  local (*F, *O);\n  open(F, '<', \"$dir/$spec\") || die(\"$dir/$spec: $!\\n\");\n  open(O, '>', \"$dir/.topaddspec$$\") || die(\"$dir/.topaddspec$$: $!\\n\");\n  my $text = $p->{'text'};\n  $text = '' if !defined $text;\n  $text .= \"\\n\" if $text ne '' && substr($text, -1, 1) ne \"\\n\";\n  print O $text;\n  while(<F>) {\n    chomp;\n    print O \"$_\\n\";\n  }\n  close(O) || die(\"close: $!\\n\");\n  rename(\"$dir/.topaddspec$$\", \"$dir/$spec\") || die(\"rename $dir/.topaddspec$$ $dir/$spec: $!\\n\");\n}\n\n#\n# apply a single link step\n# store the result under the identifier \"$md5\"\n#\n# if \"$md5\" is not set, store the result in \"$uploaddir/applylink$$\"\n#\nsub applylink {\n  my ($md5, $lsrc, $llnk) = @_;\n  if ($md5 && -e \"$srcrep/$llnk->{'package'}/$md5-_linkerror\") {\n    # no need to do all the work again...\n    my $log = readstr(\"$srcrep/$llnk->{'package'}/$md5-_linkerror\", 1);\n    $log ||= \"unknown error\";\n    chomp $log;\n    $log =~ s/.*\\n//s;\n    $log ||= \"unknown error\";\n    return str2utf8xml($log);\n  }\n  my $flnk = lsrev($llnk);\n  my $fsrc = lsrev($lsrc);\n  my $l = $llnk->{'link'};\n  my $patches = $l->{'patches'} || {};\n  my @patches = ();\n  my $simple = 1;\n  my @simple_delete;\n  my $isbranch;\n  if ($l->{'patches'}) {\n    for (@{$l->{'patches'}->{''} || []}) {\n      my $type = (keys %$_)[0];\n      if (!$type) {\n\t$simple = 0;\n\tnext;\n      }\n      if ($type eq 'topadd') {\n        push @patches, { 'type' => $type, 'text' => $_->{$type}};\n\t$simple = 0;\n      } elsif ($type eq 'delete') {\n        push @patches, { 'type' => $type, %{$_->{$type} || {}}};\n\tpush @simple_delete, $patches[-1]->{'name'};\n      } else {\n        push @patches, { 'type' => $type, %{$_->{$type} || {}}};\n\t$simple = 0;\n\t$isbranch = 1 if $type eq 'branch';\n      }\n    }\n  }\n  $simple = 0 unless $md5;\n  if ($simple) {\n    # simple source link with no patching\n    # copy all files but the ones we have locally\n    copyfiles($llnk->{'project'}, $llnk->{'package'}, $lsrc->{'project'}, $lsrc->{'package'}, $fsrc, $flnk);\n    # calculate meta\n    my $newf = { %$fsrc };\n    for my $f (sort keys %$flnk) {\n      $newf->{$f} = $flnk->{$f} unless $f eq '_link';\n    }\n    delete $newf->{$_} for @simple_delete;\n    # store filelist in md5\n    my $linkinfo = {\n      'srcmd5'  => $lsrc->{'srcmd5'},\n      'lsrcmd5' => $llnk->{'srcmd5'},\n    };\n    addmeta_link($llnk->{'project'}, $llnk->{'package'}, $newf, $md5, $linkinfo);\n    return '';\n  }\n\n  # sanity checking...\n  for my $p (@patches) {\n    return \"patch has no type\" unless exists $p->{'type'};\n    return \"patch has illegal type \\'$p->{'type'}\\'\" unless $p->{'type'} eq 'apply' || $p->{'type'} eq 'add' || $p->{'type'} eq 'topadd' || $p->{'type'} eq 'delete' || $p->{'type'} eq 'branch';\n    if ($p->{'type'} ne 'topadd' && $p->{'type'} ne 'delete' && $p->{'type'} ne 'branch') {\n      return \"patch has no patchfile\" unless exists $p->{'name'};\n      return \"patch \\'$p->{'name'}\\' does not exist\" unless $flnk->{$p->{'name'}};\n    }\n  }\n  my $tmpdir = \"$uploaddir/applylink$$\";\n  mkdir_p($tmpdir);\n  die(\"$tmpdir: $!\\n\") unless -d $tmpdir;\n  unlink(\"$tmpdir/$_\") for ls($tmpdir);\t# remove old stuff\n  my %apply = map {$_->{'name'} => 1} grep {$_->{'type'} eq 'apply'} @patches;\n  $apply{$_} = 1 for keys %{$llnk->{'ignore'} || {}};\t# also ignore those files, used in keeplink\n  my %fl;\n  if (!$isbranch) {\n    for my $f (sort keys %$fsrc) {\n      next if $flnk->{$f} && !$apply{$f};\n      link(\"$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f\", \"$tmpdir/$f\") || die(\"$f: $!\\n\");\n      $fl{$f} = \"$lsrc->{'package'}/$fsrc->{$f}-$f\";\n    }\n    for my $f (sort keys %$flnk) {\n      next if $apply{$f} || $f eq '_link';\n      link(\"$srcrep/$llnk->{'package'}/$flnk->{$f}-$f\", \"$tmpdir/$f\") || die(\"$f: $!\\n\");\n      $fl{$f} = \"$llnk->{'package'}/$flnk->{$f}-$f\";\n    }\n  }\n  my $failed;\n  for my $p (@patches) {\n    my $pn = $p->{'name'};\n    if ($p->{'type'} eq 'delete') {\n      unlink(\"$tmpdir/$pn\");\n      next;\n    }\n    if ($p->{'type'} eq 'branch') {\n      # flnk: mine\n      # fbas: old\n      # fsrc: new\n      my $baserev = $l->{'baserev'};\n      return \"no baserev in branch patch\" unless $baserev;\n      return \"baserev is not srcmd5\" unless $baserev =~ /^[0-9a-f]{32}$/s;\n      my %brev = (%$lsrc, 'srcmd5' => $baserev);\n      my $fbas;\n      eval {\n        $fbas = lsrev(\\%brev);\n      };\n      return \"baserev $baserev does not exist\" unless $fbas;\n      return \"baserev is link\" if $fbas->{'_link'};\n\n      # ignore linked generated service files if our link contains service files\n      if (grep {/^_service/} keys %$flnk) {\n\tdelete $fbas->{$_} for grep {/^_service[:_]/} keys %$fbas;\n\tdelete $fsrc->{$_} for grep {/^_service[:_]/} keys %$fsrc;\n      }\n      # do 3-way merge\n      my %destnames = (%$fsrc, %$flnk);\n      delete $destnames{'_link'};\n      for my $f (sort {length($a) <=> length($b) || $a cmp $b} keys %destnames) {\n\tmy $mbas = $fbas->{$f} || '';\n\tmy $msrc = $fsrc->{$f} || '';\n\tmy $mlnk = $flnk->{$f} || '';\n\tif ($mbas eq $mlnk) {\n\t  next if $msrc eq '';\n\t  link(\"$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f\", \"$tmpdir/$f\") || die(\"$fsrc->{$f}-$f: $!\\n\");\n\t  $fl{$f} = \"$lsrc->{'package'}/$fsrc->{$f}-$f\";\n\t  next;\n\t}\n\tif ($mbas eq $msrc || $mlnk eq $msrc) {\n\t  next if $mlnk eq '';\n\t  link(\"$srcrep/$llnk->{'package'}/$flnk->{$f}-$f\", \"$tmpdir/$f\") || die(\"$flnk->{$f}-$f: $!\\n\");\n\t  $fl{$f} = \"$llnk->{'package'}/$flnk->{$f}-$f\";\n\t  next;\n\t}\n\tif ($mbas eq '' || $msrc eq '' || $mlnk eq '') {\n\t  $failed = \"conflict in file $f\";\n\t  last;\n\t}\n        # run merge tools\n\tlink(\"$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f\", \"$tmpdir/$f.new\") || die(\"link $fsrc->{$f}-$f: $!\\n\");\n\tlink(\"$srcrep/$lsrc->{'package'}/$fbas->{$f}-$f\", \"$tmpdir/$f.old\") || die(\"link $fbas->{$f}-$f: $!\\n\");\n\tlink(\"$srcrep/$llnk->{'package'}/$flnk->{$f}-$f\", \"$tmpdir/$f.mine\") || die(\"link $flnk->{$f}-$f: $!\\n\");\n\tif (!isascii(\"$tmpdir/$f.new\") || !isascii(\"$tmpdir/$f.old\") || !isascii(\"$tmpdir/$f.mine\")) {\n\t  $failed = \"conflict in file $f\";\n\t  last;\n\t}\n\tmy $pid;\n        if ( $f =~ /\\.changes$/ ) {\n          # try our changelog merge tool first\n  \t  if (!($pid = xfork())) {\n\t    delete $SIG{'__DIE__'};\n\t    open(STDERR, '>>', \"$tmpdir/.log\") || die(\".log: $!\\n\");\n\t    open(STDOUT, '>', \"$tmpdir/$f\") || die(\"$f: $!\\n\");\n            print STDERR \"running merge tool on $f\\n\";\n\t    exec('./bs_mergechanges', \"$tmpdir/$f.old\", \"$tmpdir/$f.new\", \"$tmpdir/$f.mine\");\n\t    die(\"./bs_mergechanges: $!\\n\");\n\t  }\n  \t  waitpid($pid, 0) == $pid || die(\"waitpid $pid: $!\\n\");\n\t  $pid = undef if $?;\n        }\n\tif (!$pid) {\n          # default diff3 merge tool. always using as fallback\n\t  if (!($pid = xfork())) {\n\t    delete $SIG{'__DIE__'};\n\t    chdir($tmpdir) || die(\"$tmpdir: $!\\n\");\n\t    open(STDERR, '>>', \".log\") || die(\".log: $!\\n\");\n\t    open(STDOUT, '>', $f) || die(\"$f: $!\\n\");\n            print STDERR \"running diff3 on $f\\n\";\n\t    exec('/usr/bin/diff3', '-m', '-E', \"$f.mine\", \"$f.old\", \"$f.new\");\n\t    die(\"/usr/bin/diff3: $!\\n\");\n\t  }\n\t  waitpid($pid, 0) == $pid || die(\"waitpid $pid: $!\\n\");\n\t  if ($?) {\n\t    $failed = \"conflict in file $f\";\n\t    last;\n\t  }\n\t}\n\tunlink(\"$tmpdir/$f.old\");\n\tunlink(\"$tmpdir/$f.new\");\n\tunlink(\"$tmpdir/$f.mine\");\n      }\n      last if $failed;\n      next;\n    }\n    if ($p->{'type'} eq 'add') {\n      for my $spec (grep {/\\.spec$/} ls($tmpdir)) {\n\tlocal *F;\n\topen(F, '>>', \"$tmpdir/.log\") || die(\"$tmpdir/.log: $!\\n\");\n\tprint F \"adding patch $pn to $spec\\n\";\n\tclose F;\n        my $err = patchspec($p, $tmpdir, $spec);\n        if ($err) {\n\t  open(F, '>>', \"$tmpdir/.log\") || die(\"$tmpdir/.log: $!\\n\");\n\t  print F \"error: $err\\n\";\n\t  close F;\n\t  $failed = \"could not add patch '$pn'\";\n\t  last;\n\t  unlink(\"$tmpdir/$_\") for ls($tmpdir);\n\t  rmdir($tmpdir);\n\t  return \"could not add patch '$pn'\";\n\t}\n        delete $fl{$spec};\n      }\n      last if $failed;\n      next;\n    }\n    if ($p->{'type'} eq 'topadd') {\n      for my $spec (grep {/\\.spec$/} ls($tmpdir)) {\n\tlocal *F;\n\topen(F, '>>', \"$tmpdir/.log\") || die(\"$tmpdir/.log: $!\\n\");\n\tprint F \"adding text at top of $spec\\n\";\n\tclose F;\n        topaddspec($p, $tmpdir, $spec);\n        delete $fl{$spec};\n      }\n      next;\n    }\n    next unless $p->{'type'} eq 'apply';\n    my $pid;\n    if (!($pid = xfork())) {\n      delete $SIG{'__DIE__'};\n      chdir($tmpdir) || die(\"$tmpdir: $!\\n\");\n      open(STDIN, '<', \"$srcrep/$llnk->{'package'}/$flnk->{$pn}-$pn\") || die(\"$srcrep/$llnk->{'package'}/$flnk->{$pn}-$pn: $!\\n\");\n      open(STDOUT, '>>', \".log\") || die(\".log: $!\\n\");\n      open(STDERR, '>&STDOUT');\n      $| = 1;\n      print \"applying patch $pn\\n\";\n      $::ENV{'TMPDIR'} = '.';\n      # Old patch command still supported --unified-reject-files and --global-reject-file.\n      # exec('/usr/bin/patch', '--no-backup-if-mismatch', '--unified-reject-files', '--global-reject-file=.rejects', '-g', '0', '-f');\n      exec('/usr/bin/patch', '--no-backup-if-mismatch', '-g', '0', '-f');\n      die(\"/usr/bin/patch: $!\\n\");\n    }\n    waitpid($pid, 0) == $pid || die(\"waitpid $pid: $!\\n\");\n    if ($?) {\n      $failed = \"could not apply patch '$pn'\";\n      last;\n    }\n  }\n  if ($failed) {\n    local *F;\n    # add result as last line\n    open(F, '>>', \"$tmpdir/.log\") || die(\"$tmpdir/.log: $!\\n\");\n    print F \"\\n$failed\\n\";\n    close F;\n    # link error marker\n    if ($md5 && !link(\"$tmpdir/.log\", \"$srcrep/$llnk->{'package'}/$md5-_linkerror\")) {\n      my $err = \"link $tmpdir/.log $srcrep/$llnk->{'package'}/$md5-_linkerror: $!\\n\";\n      die($err) unless -e \"$srcrep/$llnk->{'package'}/$md5-_linkerror\";\n    }\n    unlink(\"$tmpdir/$_\") for ls($tmpdir);\n    rmdir($tmpdir);\n    return str2utf8xml($failed);\n  }\n  my @newf = grep {!/^\\./} ls($tmpdir);\n  my $newf = {};\n  local *F;\n  for my $f (@newf) {\n    my @s = stat \"$tmpdir/$f\";\n    die(\"$tmpdir/$f: $!\\n\") unless @s;\n    if ($s[3] > 1 && $fl{$f}) {\n      my @s2 = stat \"$srcrep/$fl{$f}\";\n      die(\"$srcrep/$fl{$f}: $!\\n\") unless @s2;\n      if (\"$s[0]/$s[1]\" eq \"$s2[0]/$s2[1]\") {\n        $newf->{$f} = $fl{$f};\n        $newf->{$f} =~ s/.*\\///;\n        $newf->{$f} = substr($newf->{$f}, 0, 32);\n\tnext;\n      }\n    }\n    open(F, '<', \"$tmpdir/$f\") || die(\"$tmpdir/$f: $!\\n\");\n    my $ctx = Digest::MD5->new;\n    $ctx->addfile(*F);\n    close F;\n    $newf->{$f} = $ctx->hexdigest();\n  }\n\n  # if we just want the patched files we're finished\n  if (!$md5) {\n    # rename into md5 form, sort so that there's no collision\n    for my $f (sort {length($b) <=> length($a) || $a cmp $b} @newf) {\n      rename(\"$tmpdir/$f\", \"$tmpdir/$newf->{$f}-$f\");\n    }\n    return $newf;\n  }\n\n  # otherwise link everything over\n  for my $f (@newf) {\n    addfile($llnk->{'project'}, $llnk->{'package'}, \"$tmpdir/$f\", $f, $newf->{$f});\n  }\n  # clean up tmpdir\n  unlink(\"$tmpdir/$_\") for ls($tmpdir);\n  rmdir($tmpdir);\n  # store filelist\n  my $linkinfo = {\n    'srcmd5'  => $lsrc->{'srcmd5'},\n    'lsrcmd5' => $llnk->{'srcmd5'},\n  };\n  addmeta_link($llnk->{'project'}, $llnk->{'package'}, $newf, $md5, $linkinfo);\n  return '';\n}\n\n#\n# expand a source link\n# - returns expanded file list\n# - side effects:\n#   modifies $rev->{'srcmd5'}, $rev->{'vrev'}, $rev->{'linkrev'}\n#   modifies $li->{'srcmd5'}, $li->{'lsrcmd5'}\n#   modifies $li->{'linked'} if exists\n#\nsub handlelinks {\n  my ($rev, $files, $li) = @_;\n\n  my @linkinfo;\n  my %seen;\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  my $linkrev = $rev->{'linkrev'};\n  push @linkinfo, {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}, 'rev' => $rev->{'rev'}};\n  delete $rev->{'srcmd5'};\n  delete $rev->{'linkrev'};\n  my $oldvrev = 0;\n  my $vrevdone;\n  my $lrev = $rev;\n  while ($files->{'_link'}) {\n    my $l = repreadxml($lrev, '_link', $files->{'_link'}, $BSXML::link, 1);\n    return '_link is bad' unless $l;\n    my $cicount = $l->{'cicount'} || 'add';\n    eval {\n      BSVerify::verify_link($l);\n      die(\"illegal cicount\\n\") unless $cicount eq 'copy' || $cicount eq 'add' || $cicount eq 'local';\n      if (!exists($l->{'package'}) && exists($l->{'project'}) && $l->{'project'} ne $linkinfo[-1]->{'project'}) {\n        # be extra careful if the package attribute doesn't exist, but the\n        # link points to some other project\n        checksourceaccess($l->{'project'}, $linkinfo[-1]->{'package'});\n      }\n    };\n    if ($@) {\n      my $err = $@;\n      $err =~ s/\\n$//s;\n      return \"_link is bad: $err\" if @linkinfo == 1;\n      return \"$lrev->{'project'}/$lrev->{'package'}: _link is bad: $err\";\n    }\n    $l->{'project'} = $linkinfo[-1]->{'project'} unless exists $l->{'project'};\n    $l->{'package'} = $linkinfo[-1]->{'package'} unless exists $l->{'package'};\n    $linkrev = $l->{'baserev'} if $linkrev && $linkrev eq 'base';\n    ($l->{'rev'}, $linkrev) = ($linkrev, undef) if $linkrev;\n    $linkinfo[-1]->{'link'} = $l;\n    $projid = $l->{'project'};\n    $packid = $l->{'package'};\n    $lrev = $l->{'rev'} || '';\n    return 'circular package link' if $seen{\"$projid/$packid/$lrev\"};\n    $seen{\"$projid/$packid/$lrev\"} = 1;\n    # record link target for projpack\n    push @{$li->{'linked'}}, {'project' => $projid, 'package' => $packid} if $li && $li->{'linked'}; \n    eval {\n      if ($l->{'missingok'}) {\n        # be careful with 'missingok' pointing to protected packages\n        checksourceaccess($projid, $packid);\n      }\n      $lrev = getrev($projid, $packid, $l->{'rev'}, $li ? $li->{'linked'} : undef, $l->{'missingok'} ? 1 : 0);\n    };\n    if ($@) {\n      my $error = $@;\n      chomp $error;\n      $error = $2 if $error =~ /^(\\d+) +(.*?)$/s;\n      return \"$projid/$packid: $error\";\n    }\n    return \"linked package '$packid' does not exist in project '$projid'\" unless $lrev;\n    return \"linked package '$packid' is empty\" if $lrev->{'srcmd5'} eq 'empty';\n    return \"linked package '$packid' is strange\" unless $lrev->{'srcmd5'} =~ /^[0-9a-f]{32}$/;\n    $lrev->{'vrev'} = $l->{'vrev'} if defined $l->{'vrev'};\n    undef $files;\n    eval {\n      # links *always* point to expanded services\n      $files = lsrev_service($lrev);\n    };\n    if ($@) {\n      my $error = $@;\n      chomp $error;\n      return \"$projid/$packid: $error\";\n    }\n    $rev->{'vrev'} = $oldvrev if $cicount eq 'copy';\n    $oldvrev = $rev->{'vrev'};\n    $vrevdone = 1 if $cicount eq 'local';\n    if (!$vrevdone) {\n      my $v = $rev->{'vrev'} || 0;\n      $v =~ s/^.*\\D//;\n      $rev->{'vrev'} = $lrev->{'vrev'} || 0;\n      $rev->{'vrev'} =~ s/(\\d+)$/$1+$v/e;\n    }\n\n    push @linkinfo, {'project' => $projid, 'package' => $packid, 'srcmd5' => $lrev->{'srcmd5'}, 'rev' => $lrev->{'rev'}};\n  }\n  my $md5;\n  my $oldl;\n  for my $l (reverse @linkinfo) {\n    if (!$md5) {\n      $md5 = $l->{'srcmd5'};\n      $oldl = $l;\n      next;\n    }\n    my $md5c = \"$md5  /LINK\\n$l->{'srcmd5'}  /LOCAL\\n\";\n    $md5 = Digest::MD5::md5_hex($md5c);\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$l->{'project'}/$l->{'package'}\" : \"$treesdir/$l->{'package'}\";\n    if (! -e \"$treedir/$md5-MD5SUMS\") {\n      my $error = applylink($md5, $oldl, $l);\n      if ($error) {\n        $rev->{'srcmd5'} = $md5 if $l == $linkinfo[0];\n\t$error = \"$l->{'project'}/$l->{'package'}: $error\" if $l != $linkinfo[0];\n        return $error;\n      }\n    }\n    $l->{'srcmd5'} = $md5;\n    $oldl = $l;\n  }\n  $rev->{'srcmd5'} = $md5;\n  $files = lsrev($rev, $li);\n  return $files;\n}\n\n# - returns expanded file list\n# - side effects:\n#   modifies $rev->{'srcmd5'}\nsub handleservice {\n  my ($rev, $files, $servicemark) = @_;\n\n  my $lsrcmd5 = $rev->{'srcmd5'};\n  $rev->{'srcmd5'} = $servicemark;\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$rev->{'project'}/$rev->{'package'}\" : \"$treesdir/$rev->{'package'}\";\n  my $sfiles;\n  if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e \"$treedir/$servicemark-MD5SUMS\" && -e \"$srcrep/$rev->{'package'}/$servicemark-MD5SUMS\") {\n    $sfiles = lsrev($rev);\n  } elsif (-e \"$treedir/$servicemark-MD5SUMS\") {\n    $sfiles = lsrev($rev);\n  } elsif (! -e \"$projectsdir/$rev->{'project'}.pkg/$rev->{'package'}.xml\") {\n    # not our own package, don't run service. try getrev/lsrev instead.\n    my $rrev = getrev($rev->{'project'}, $rev->{'package'}, $servicemark);\n    $sfiles = lsrev($rrev);\n  }\n  if ($sfiles) {\n    # tree is available, i.e. the service has finished\n    if ($sfiles->{'_service_error'}) {\n      # old style...\n      my $error = repreadstr($rev, '_service_error', $sfiles->{'_service_error'});\n      $error =~ s/[\\r\\n]+$//s;\n      $error =~ s/.*[\\r\\n]//s;\n      die(str2utf8xml($error ? \"$error\\n\" : \"unknown service error\\n\"));\n    }\n    return $sfiles;\n  }\n  # don't have the tree yet\n  if (-s \"$treedir/$servicemark-_serviceerror\") {\n    local *SERROR;\n    if (open(SERROR, '<', \"$treedir/$servicemark-_serviceerror\")) {\n      my $size = -s SERROR;\n      sysseek(SERROR, $size - 1024, 0) if $size > 1024;\n      my $error = '';\n      1 while sysread(SERROR, $error, 1024, length($error));\n      close SERROR;\n      $error =~ s/[\\r\\n]+$//s;\n      $error =~ s/.*[\\r\\n]//s;\n      $error ||= 'unknown service error';\n      die(str2utf8xml(\"$error\\n\"));\n    }\n  }\n  my %nfiles = %$files;\n  $nfiles{'/SERVICE'} = $servicemark;\n  $rev->{'srcmd5'} = $lsrcmd5;\t# put it back so that runservice can put it in /LSRCMD5\n  runservice({}, $rev, \\%nfiles);\n  $rev->{'srcmd5'} = $servicemark;\n  die(\"service in progress\\n\");\n}\n\n# returns service expanded filelist\n# modifies $rev->{'srcmd5'}\nsub lsrev_service {\n  my ($rev, $linkinfo) = @_;\n  $linkinfo ||= {};\n  my $files = lsrev($rev, $linkinfo);\n  $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'}) if $linkinfo->{'xservicemd5'};\n  return $files;\n}\n\n# returns expanded filelist\n# modifies $rev->{'srcmd5'}, $rev->{'vrev'}\nsub lsrev_expanded {\n  my ($rev, $linkinfo) = @_;\n  my $files = lsrev_service($rev, $linkinfo);\n  return $files unless $files->{'_link'};\n  $files = handlelinks($rev, $files, $linkinfo);\n  die(\"$files\\n\") unless ref $files;\n  return $files;\n}\n\n# add missing target information to linkinfo\nsub linkinfo_addtarget {\n  my ($rev, $linkinfo) = @_;\n  my %lrev = %$rev;\n  $lrev{'srcmd5'} = $linkinfo->{'lsrcmd5'} if $linkinfo->{'lsrcmd5'};\n  my $files = lsrev(\\%lrev);\n  die(\"linkinfo_addtarget: not a link?\\n\") unless $files->{'_link'};\n  my $l = repreadxml(\\%lrev, '_link', $files->{'_link'}, $BSXML::link, 1);\n  if ($l) {\n    $linkinfo->{'project'} = defined($l->{'project'}) ? $l->{'project'} : $lrev{'project'};\n    $linkinfo->{'package'} = defined($l->{'package'}) ? $l->{'package'} : $lrev{'package'};\n    $linkinfo->{'missingok'} = \"true\" if $l->{'missingok'};\n    $linkinfo->{'rev'} = $l->{'rev'} if $l->{'rev'};\n    $linkinfo->{'baserev'} = $l->{'baserev'} if $l->{'baserev'};\n  }\n}\n\nsub findlastworkinglink {\n  my ($rev) = @_;\n\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  my @cand = grep {s/-MD5SUMS$//} ls($treedir);\n  if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2) {\n    push @cand, grep {s/-MD5SUMS$//} ls(\"$srcrep/$packid\");\n    @cand = unify(@cand);\n  }\n  my %cand;\n  for my $cand (@cand) {\n    my $candrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cand};\n    my %li;\n    my $files = lsrev($candrev, \\%li);\n    next unless $li{'lsrcmd5'} && $li{'lsrcmd5'} eq $rev->{'srcmd5'};\n    $cand{$cand} = $li{'srcmd5'};\n  }\n  return undef unless %cand;\n  @cand = sort keys %cand;\n  return $cand[0] if @cand == 1;\n\n  while (1) {\n    my $lrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}};\n    my $lfiles = lsrev($lrev);\n    return undef unless $lfiles;\n    my $l = repreadxml($lrev, '_link', $lfiles->{'_link'}, $BSXML::link, 1);\n    return undef unless $l;\n    $projid = $l->{'project'} if exists $l->{'project'};\n    $packid = $l->{'package'} if exists $l->{'package'};\n    my $lastcand;\n    for my $cand (splice @cand) {\n      next unless $cand{$cand};\n      my %li;\n      my $candrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cand{$cand}};\n      lsrev($candrev, \\%li);\n      $candrev->{'srcmd5'} = $li{'lsrcmd5'} if $li{'lsrcmd5'};\n      $candrev = findlastrev($candrev);\n      next unless $candrev;\n      next if $lastcand && $lastcand->{'rev'} > $candrev->{'rev'};\n      $cand{$cand} = $li{'srcmd5'} ? $li{'srcmd5'} : undef;\n      if ($lastcand && $lastcand->{'rev'} == $candrev->{'rev'}) {\n        push @cand, $cand;\n\tnext;\n      }\n      @cand = ($cand);\n      $lastcand = $candrev;\n    }\n    return undef unless @cand;\n    return $cand[0] if @cand == 1;\n    $rev = $lastcand;\n  }\n}\n\n\n###########################################################################\n###\n###  project/package management\n###\n\nsub identical {\n  my ($d1, $d2, $except) = @_;\n\n  return 0 unless defined($d1) && defined($d2);\n  my $r = ref($d1);\n  return 0 if $r ne ref($d2);\n  if ($r eq '') {\n    return 0 if $d1 ne $d2;\n  } elsif ($r eq 'HASH') {\n    my %k = (%$d1, %$d2);\n    for my $k (keys %k) {\n      next if $except && $except->{$k};\n      return 0 unless identical($d1->{$k}, $d2->{$k}, $except);\n    }\n  } elsif ($r eq 'ARRAY') {\n    return 0 unless @$d1 == @$d2;\n    for (my $i = 0; $i < @$d1; $i++) {\n      return 0 unless identical($d1->[$i], $d2->[$i], $except);\n    }\n  } else {\n    return 0;\n  }\n  return 1;\n}\n\nsub findprojects {\n  my ($deleted) = @_;\n  if ($deleted) {\n    my @projids = grep {s/\\.pkg$//} ls(\"$projectsdir/_deleted\");\n    @projids = grep {! -e \"$projectsdir/$_.xml\"} @projids;\n    return sort @projids;\n  }\n  local *D;\n  mkdir_p(\"$projectsdir\") || die(\"creating $projectsdir: $!\\n\");\n  opendir(D, $projectsdir) || die(\"$projectsdir: $!\\n\");\n  my @projids = grep {s/\\.xml$//} readdir(D);\n  closedir(D);\n  return sort @projids;\n}\n\nsub findpackages {\n  my ($projid, $proj, $nonfatal, $seen, $origins, $noexpand, $deleted) = @_;\n  $proj ||= readproj($projid, 1) || {};\n  local *D;\n  my @packids;\n\n  # if this is a remote project, forward to remote server\n  if ($proj->{'remoteurl'}) {\n    my $r;\n    my @args;\n    push @args, 'deleted=1' if $deleted;\n    push @args, 'expand=1' unless $noexpand || $deleted;\n    eval {\n      $r = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}\", 'proxy' => $proxy}, $BSXML::dir, @args);\n    };\n    if ($@ && $@ =~ /^404/) {\n      # remote project does not exist\n      die($@) unless $nonfatal;\n      return @packids;\n    }\n    if ($@) {\n      die($@) unless $nonfatal && $nonfatal > 0;\t# -1: internal projectlink recursion, errors are still fatal\n      warn($@);\n      push @packids, ':missing_packages' if $nonfatal == 2;\n      return @packids;\n    }\n    @packids = map {$_->{'name'}} @{($r || {})->{'entry'} || []};\n    if ($origins) {\n      for my $entry (@{($r || {})->{'entry'} || []}) {\n\t$origins->{$entry->{'name'}} = defined($entry->{'originproject'}) ? maptoremote($proj, $entry->{'originproject'}) : $projid;\n      }\n    }\n    return @packids;\n  }\n\n  # handle deleted packages\n  if ($deleted) {\n    # we never expand deleted packages\n    if (! -e \"$projectsdir/$projid.xml\" && -d \"$projectsdir/_deleted/$projid.pkg\") {\n      @packids = grep {$_ ne '_meta' && $_ ne '_project'} grep {s/\\.mrev$//} ls(\"$projectsdir/_deleted/$projid.pkg\");\n    } else {\n      @packids = grep {s/\\.mrev\\.del$//} ls(\"$projectsdir/$projid.pkg\");\n      @packids = grep {! -e \"$projectsdir/$projid.pkg/$_.xml\"} @packids;\n    }\n    @packids = sort @packids;\n    if ($origins) {\n      for (@packids) {\n        $origins->{$_} = $projid unless defined $origins->{$_};\n      }\n    }\n    return @packids;\n  }\n\n  # get local packages\n  if (opendir(D, \"$projectsdir/$projid.pkg\")) {\n    @packids = grep {s/\\.xml$//} readdir(D);\n    closedir(D);\n    if ($origins) {\n      for (@packids) {\n        $origins->{$_} = $projid unless defined $origins->{$_};\n      }\n    }\n  }\n\n  # handle project links\n  if ($proj->{'link'} && !$noexpand) {\n    $seen ||= {};\n    $seen->{$projid} = 1;\n    my $frozen = get_frozenlinks($projid);\n    for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {\n      next if $seen->{$lprojid};\n      $seen->{$lprojid} = 1;\n      my @lpackids;\n      my $frozenp = $frozen->{'/all'} || $frozen->{$lprojid};\n      my $lorigins = defined($origins) ? {} : undef;\n      if ($frozenp) {\n\t@lpackids = sort keys %$frozenp;\n\tif ($lorigins) {\n\t  $lorigins->{$_} = $lprojid for @lpackids;\n\t}\n      } else {\n        my $lproj = readproj($lprojid, 1);\n        if (!$lproj || $lproj->{'remoteurl'}) {\n          $lproj = remoteprojid($lprojid);\n\t  next unless $lproj;\t# linked project does not exist\n        }\n        @lpackids = findpackages($lprojid, $lproj, $nonfatal || -1, $seen, $lorigins);\n      }\n      if (grep {$_ eq '_product'} @packids) {\n\t@lpackids = grep {$_ ne '_product' && !/^_product:/} @lpackids;\n      }\n      push @packids, @lpackids;\n      if ($origins && $lorigins) {\n        for (@lpackids) {\n          $origins->{$_} = $lorigins->{$_} unless defined $origins->{$_};\n        }\n      }\n    }\n    @packids = unify(@packids);\n  }\n\n  return sort @packids;\n}\n\nsub getrev_meta {\n  my ($projid, $packid, $revid, $deleted, $nonfatal) = @_;\n  my $revfile = defined($packid) ? \"$projectsdir/$projid.pkg/$packid.mrev\" : \"$projectsdir/$projid.pkg/_project.mrev\";\n  if ($deleted) {\n    $revfile = defined($packid) ? \"$projectsdir/$projid.pkg/$packid.mrev.del\" : \"$projectsdir/_deleted/$projid.pkg/_project.mrev\";\n    if (defined($packid) && ! -e $revfile && ! -e \"$projectsdir/$projid.xml\" && -e \"$projectsdir/_deleted/$projid.pkg\") {\n      $revfile = \"$projectsdir/_deleted/$projid.pkg/$packid.mrev\";\n    }\n  }\n  my $rev;\n  if (!defined($revid) || $revid eq 'latest') {\n    $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);\n    $rev = { 'srcmd5' => $emptysrcmd5 } unless $rev;\n  } elsif ($revid =~ /^[0-9a-f]{32}$/) {\n    $rev = { 'srcmd5' => $revid };\n  } else {\n    $rev = BSFileDB::fdb_getmatch($revfile, $srcrevlay, 'rev', $revid);\n  }\n  if ($rev) {\n    $rev->{'project'} = $projid;\n    $rev->{'package'} = defined($packid) ? $packid : '_project';\n  } elsif (!$nonfatal) {\n    die(\"404 revision '$revid' does not exist\\n\") if $revid;\n    die(\"404 no revision\\n\");\n  }\n  return $rev;\n}\n\nsub retrofit_old_prjsource {\n  my ($projid) = @_;\n  my $files = {};\n  my $packid = '_project';\n  if (-e \"$projectsdir/$projid.conf\") {\n    BSUtil::cp(\"$projectsdir/$projid.conf\", \"$uploaddir/addrev_meta$$\");\n    $files->{'_config'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_config');\n  }\n  return $files;\n}\n\nsub retrofit_old_meta {\n  my ($projid, $packid) = @_;\n  my $files = {};\n  if (defined($packid) && $packid ne '_project') {\n    if (-e \"$projectsdir/$projid.pkg/$packid.xml\") {\n      BSUtil::cp(\"$projectsdir/$projid.pkg/$packid.xml\", \"$uploaddir/addrev_meta$$\");\n      $files->{'_meta'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_meta');\n    }\n  } else {\n    $packid = '_project';\n    if (-e \"$projectsdir/$projid.xml\") {\n      BSUtil::cp(\"$projectsdir/$projid.xml\", \"$uploaddir/addrev_meta$$\");\n      $files->{'_meta'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_meta');\n    }\n    if (-e \"$projectsdir/$projid.pkg/_sslcert\") {\n      # FIXME: this is only needed for the test suite. But as long we do not have a signing\n      #        stub there we need this to inject keys.\n      BSUtil::cp(\"$projectsdir/$projid.pkg/_sslcert\", \"$uploaddir/addrev_meta$$\");\n      $files->{'_sslcert'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_sslcert');\n    }\n    if (-e \"$projectsdir/$projid.pkg/_pubkey\") {\n      BSUtil::cp(\"$projectsdir/$projid.pkg/_pubkey\", \"$uploaddir/addrev_meta$$\");\n      $files->{'_pubkey'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_pubkey');\n    }\n    if (-e \"$projectsdir/$projid.pkg/_signkey\") {\n      BSUtil::cp(\"$projectsdir/$projid.pkg/_signkey\", \"$uploaddir/addrev_meta$$\");\n      chmod(0600, \"$uploaddir/addrev_meta$$\");\n      $files->{'_signkey'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_signkey');\n    }\n  }\n  return $files;\n}\n\nsub extract_old_prjsource {\n  my ($projid, $rev) = @_;\n  my $files = lsrev($rev);\n  my $config;\n  $config = repreadstr($rev, '_config', $files->{'_config'}, 1) if $files->{'_config'};\n  writestr(\"$uploaddir/$$.2\", \"$projectsdir/$projid.conf\", $config) if $config;\n}\n\nsub extract_old_meta {\n  my ($projid, $packid, $rev) = @_;\n  $rev->{'keepsignkey'} = 1;\n  my $files = lsrev($rev);\n  delete $rev->{'keepsignkey'};\n  if (!defined($packid) || $packid eq '_project') {\n    $packid = '_project';\n    my $pubkey;\n    $pubkey = repreadstr($rev, '_pubkey', $files->{'_pubkey'}, 1) if $files->{'_pubkey'};\n    writestr(\"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/_pubkey\", $pubkey) if $pubkey;\n    my $signkey;\n    $signkey = repreadstr($rev, '_signkey', $files->{'_signkey'}, 1) if $files->{'_signkey'};\n    if ($signkey) {\n      writestr(\"$uploaddir/$$.2\", undef, $signkey);\n      chmod(0600, \"$uploaddir/$$.2\");\n      rename(\"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/_signkey\") || die(\"rename $uploaddir/$$.2 $projectsdir/$projid.pkg/_signkey: $!\\n\");\n    }\n    my $meta;\n    $meta = repreadstr($rev, '_meta', $files->{'_meta'}, 1) if $files->{'_meta'};\n    writestr(\"$uploaddir/$$.2\", \"$projectsdir/$projid.xml\", $meta) if $meta;\n  } else {\n    my $meta;\n    $meta = repreadstr($rev, '_meta', $files->{'_meta'}, 1) if $files->{'_meta'};\n    writestr(\"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/$packid.xml\", $meta) if $meta;\n  }\n}\n\nsub addrev_meta_multiple {\n  my ($cgi, $projid, $packid, $suf, @todo) = @_;\n\n  $suf ||= 'mrev';\n  undef $packid if $packid && $packid eq '_project';\n  my $rpackid = defined($packid) ? $packid : '_project';\n\n  # first commit content into internal repository\n  my %rfilemd5;\n  for my $todo (@todo) {\n    my ($tmpfile, $file, $rfile) = @$todo;\n    next unless defined($tmpfile);\n    mkdir_p($uploaddir);\n    unlink(\"$uploaddir/addrev_meta$$\");\n    BSUtil::cp($tmpfile, \"$uploaddir/addrev_meta$$\");\n    chmod(0600, \"$uploaddir/addrev_meta$$\") if !defined($packid) && $suf eq 'mrev' && $rfile eq '_signkey';\n    $rfilemd5{$rfile} = addfile($projid, $rpackid, \"$uploaddir/addrev_meta$$\", $rfile);\n  }\n\n  mkdir_p(\"$projectsdir/$projid.pkg\");\n  my $revfile = \"$projectsdir/$projid.pkg/$rpackid.$suf\";\n  local *FF;\n  BSUtil::lockopen(\\*FF, '+>>', $revfile);\n  my $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);\n  my $files;\n  if ($rev) {\n    $rev->{'project'} = $projid;\n    $rev->{'package'} = $rpackid;\n    $rev->{'keepsignkey'} = 1;\n    $files = lsrev($rev);\n    delete $rev->{'keepsignkey'};\n  } else {\n    $files = {};\n    if ((defined($packid) && -e \"$projectsdir/$projid.pkg/$packid.xml\") || (!defined($packid) && -e \"$projectsdir/$projid.xml\")) {\n      if ($suf eq 'mrev') {\n        $files = retrofit_old_meta($projid, $packid);\n      } elsif (!defined($packid)) {\n        $files = retrofit_old_prjsource($projid);\n      }\n    }\n  }\n\n  for my $todo (@todo) {\n    my ($tmpfile, $file, $rfile) = @$todo;\n    if (defined($tmpfile)) {\n      $files->{$rfile} = $rfilemd5{$rfile};\n    } else {\n      delete $files->{$rfile};\n    }\n  }\n\n  my $srcmd5 = addmeta($projid, $rpackid, $files);\n  my $user = defined($cgi->{'user'}) ? str2utf8xml($cgi->{'user'}) : 'unknown';\n  my $comment = defined($cgi->{'comment'}) ? str2utf8xml($cgi->{'comment'}) : '';\n  my $nrev = { 'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $cgi->{'requestid'} };\n  # copy version/vref in initial commit case\n  if (!@todo && defined($packid) && $suf ne 'mrev' && $rev) {\n    $nrev->{'version'} = $rev->{'version'} if defined $rev->{'version'};\n    $nrev->{'vrev'} = $rev->{'vrev'} if defined $rev->{'vrev'};\n  }\n  BSFileDB::fdb_add_i(\\*FF, $srcrevlay, $nrev);\n\n  for my $todo (@todo) {\n    my ($tmpfile, $file, $rfile) = @$todo;\n    if (defined($file)) {\n      if (defined($tmpfile)) {\n        rename($tmpfile, $file) || die(\"rename $tmpfile $file: $!\\n\");\n      } else {\n        unlink($file);\n      }\n    } elsif (defined($tmpfile)) {\n      unlink($tmpfile);\n    }\n  }\n  close FF;\t# free lock\n  $nrev->{'project'} = $projid;\n  $nrev->{'package'} = $rpackid;\n  return $nrev;\n}\n\nsub addrev_meta {\n  my ($cgi, $projid, $packid, $tmpfile, $file, $rfile, $suf) = @_;\n  if (defined($rfile)) {\n    return addrev_meta_multiple($cgi, $projid, $packid, $suf,  [ $tmpfile, $file, $rfile ]);\n  } else {\n    return addrev_meta_multiple($cgi, $projid, $packid, $suf);\n  }\n}\n\nsub readproj {\n  my ($projid, $nonfatal, $revid) = @_;\n  my $proj;\n  if ($revid) {\n    my $rev = getrev_meta($projid, undef, $revid);\n    my $files = $rev ? lsrev($rev) : {};\n    $proj = repreadxml($rev, '_meta', $files->{'_meta'}, $BSXML::proj, 1) if $files->{'_meta'};\n  } else {\n    $proj = readxml(\"$projectsdir/$projid.xml\", $BSXML::proj, 1);\n  }\n  die(\"404 project '$projid' does not exist\\n\") if !$proj && !$nonfatal;\n  return $proj;\n}\n\nsub readpack {\n  my ($projid, $packid, $nonfatal, $revid) = @_;\n  my $pack;\n  if ($revid) {\n    my $rev = getrev_meta($projid, $packid, $revid, undef, $nonfatal);\n    my $files = $rev ? lsrev($rev) : {};\n    $pack = repreadxml($rev, '_meta', $files->{'_meta'}, $BSXML::pack, 1) if $files->{'_meta'};\n  } else {\n    $pack = readxml(\"$projectsdir/$projid.pkg/$packid.xml\", $BSXML::pack, 1);\n  }\n  if (!$pack && !$nonfatal) {\n    readproj($projid);\n    die(\"404 package '$packid' does not exist in project '$projid'\\n\");\n  }\n  return $pack;\n}\n\n# collect all global source services via all package and project links\nsub getprojectservices {\n  my ($cgi, $projid, $packid, $projectloop) = @_;\n  my $services = {};\n\n  # protection against loops and double matches\n  $projectloop ||= {};\n  return ({}, $BSXML::services) if $projectloop->{$projid};\n  $projectloop->{$projid} = 1;\n\n  # get source services from this project\n  my $projectrev = getrev($projid, '_project');\n  my $projectfiles = lsrev($projectrev);\n  if ($projectfiles->{'_service'}) {\n    $services = readxml(\"$srcrep/_project/$projectfiles->{'_service'}-_service\", $BSXML::services, 1) || {};\n  }\n\n  # find further projects via project link\n  my $proj = readproj($projid, 1);\n  for my $lprojid (map {$_->{'project'}} @{$proj->{'link'} || []}) {\n    my $lpack;\n    eval {\n      ($lpack, undef) = getpackage($cgi, $lprojid, $packid);\n    };\n    if ($lpack) {\n      my ($as, undef) = getprojectservices($cgi, $lprojid, $packid, $projectloop);\n      if (defined($as) && defined($as->{'service'})) {\n        push @{$services->{'service'}}, @{$as->{'service'}};\n      }\n    }\n  }\n\n  # find further projects via package link\n  my $packagerev;\n  eval {\n     $packagerev = getrev($projid, $packid, $cgi->{'rev'});\n  };\n  return ($services, $BSXML::services) unless $packagerev;\n\n  my $packagefiles = lsrev($packagerev);\n  my $l;\n  $l = repreadxml($packagerev, '_link', $packagefiles->{'_link'}, $BSXML::link, 1) if $packagefiles->{'_link'};\n  if ($l) {\n    my $lprojid = $projid;\n    my $lpackid = $packid;\n    $lprojid = $l->{'project'} if defined $l->{'project'};\n    $lpackid = $l->{'package'} if defined $l->{'package'};\n    # honor project links\n    my $lpack;\n    eval {\n      ($lpack, undef) = getpackage($cgi, $lprojid, $lpackid);\n    };\n    if ($lpack) {\n      my ($as, undef) = getprojectservices({%$cgi, 'rev' => $l->{'rev'}}, $lprojid, $lpackid, $projectloop);\n      if (defined($as) && defined($as->{'service'})) {\n        push @{$services->{'service'}}, @{$as->{'service'}};\n      }\n    }\n  }\n\n  return ($services, $BSXML::services);\n}\n\n# find matching .spec/.dsc/.kiwi file depending on packid and/or repoid\nsub findfile {\n  my ($rev, $repoid, $ext, $files) = @_;\n\n  return (undef, undef) if !$ext || $ext eq 'none';\n  $files = lsrev($rev) unless $files;\n  return (undef, undef) unless $files;\n\n  # create filename -> return value hash\n  my %files = map {$_ => [$files->{$_}, $_]} keys %$files;\n\n  # map services files to their real name\n  if ($files{'_service'}) {\n    for (sort keys %files) {\n      next unless /^_service:.*:(.*?)$/s;\n      next unless $files{$_};\n      $files{$1} = $files{$_};\n      delete $files{$_};\n    }\n  }\n\n  return @{$files{'_preinstallimage'}} if $ext ne 'kiwi' && keys(%files) == 1 && $files{'_preinstallimage'};\n  return @{$files{'simpleimage'}} if $files{'simpleimage'};\n\n  if ($ext eq 'arch') {\n    return @{$files{'PKGBUILD'}} if $files{'PKGBUILD'};\n    return (undef, undef);\n  }\n\n  my $packid = $rev->{'package'};\n  return (@{$files{\"$packid-$repoid.$ext\"}}) if defined($repoid) && $files{\"$packid-$repoid.$ext\"};\n  # 28.4.2009 mls: deleted \"&& defined($repoid)\"\n  return @{$files{\"$packid.$ext\"}} if $files{\"$packid.$ext\"};\n  # try again without last components\n  if ($packid =~ /^(.*?)\\./) {\n    return @{$files{\"$1.$ext\"}} if $files{\"$1.$ext\"};\n  }\n  my @files = grep {/\\.$ext$/} keys %files;\n  @files = grep {/^\\Q$packid\\E/i} @files if @files > 1;\n  return @{$files{$files[0]}} if @files == 1;\n  if (@files > 1) {\n    if (!defined($repoid)) {\n      # return (undef, undef);\n      @files = sort @files;\n      return @{$files{$files[0]}};\n    }\n    @files = grep {/^\\Q$packid-$repoid\\E/i} @files if @files > 1;\n    return @{$files{$files[0]}} if @files == 1;\n  }\n  return (undef, undef);\n}\n\nsub unify {\n  my %h = map {$_ => 1} @_;\n  return grep(delete($h{$_}), @_);\n}\n\n#########################################################################\n\n# set up kiwi project callback\n\nsub kiwibootcallback {\n  my ($projid, $packid) = @_;\n  BSVerify::verify_projid($projid);\n  BSVerify::verify_packid($packid);\n  checksourceaccess($projid, $packid);\n  my $rev = getrev($projid, $packid);\n  my $files = lsrev($rev);\n  my ($md5, $file) = findfile($rev, undef, 'kiwi', $files);\n  die(\"no kiwi file found\\n\") unless $md5 && $file;\n  my $xml = readstr(\"$srcrep/$packid/$md5-$file\");\n  return ($xml, {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}, 'file' => $file});\n}\n$Build::Kiwi::bootcallback = \\&kiwibootcallback;\n\n#########################################################################\n\nsub projid2reposerver {\n  my ($projid) = @_;\n  return $BSConfig::reposerver unless $BSConfig::partitionservers;\n  my @p = @{$BSConfig::partitioning || []};\n  my $par;\n  while (@p) {\n    if ($projid =~ /^$p[0]/) {\n      $par = $p[1];\n      last;\n    }\n    splice(@p, 0, 2);\n  }\n  $par = $BSConfig::partition unless defined $par;\n  die(\"cannot determine partition for $projid\\n\") unless defined $par;\n  die(\"partition '$par' from partitioning does not exist\\n\") unless $BSConfig::partitionservers->{$par};\n  return $BSConfig::partitionservers->{$par};\n}\n\nsub projid2partition {\n  my ($projid) = @_;\n  return undef unless $BSConfig::partitioning;\n  my @p = @{$BSConfig::partitioning || []};\n  my $par;\n  while (@p) {\n    if ($projid =~ /^$p[0]/) {\n      $par = $p[1];\n      last;\n    }\n    splice(@p, 0, 2);\n  }\n  $par = $BSConfig::partition unless defined $par;\n  return $par;\n}\n\nsub checkpartition {\n  my ($remotemap, $projid, $proj) = @_;\n  $remotemap->{':partitions'}->{$projid} = 1;\n  return if $remotemap->{$projid};\n  my @p = @{$BSConfig::partitioning || []};\n  my $par;\n  while (@p) {\n    if ($projid =~ /^$p[0]/) {\n      $par = $p[1];\n      last;\n    }\n    splice(@p, 0, 2);\n  }\n  $par = $BSConfig::partition unless defined $par;\n  die(\"cannot determine partition for $projid\\n\") unless defined $par;\n  return if $par eq $remotemap->{':partition'};\n  my $reposerver = $BSConfig::reposerver;\n  if ($BSConfig::partitionservers) {\n    $reposerver = $BSConfig::partitionservers->{$par};\n    die(\"partition '$par' from partitioning does not exist\\n\") unless $reposerver;\n  }\n  $remotemap->{$projid} = {\n    'name' => $projid, 'remoteurl' => $reposerver, 'remoteproject' => $projid, 'partition' => $par,\n  };\n  $proj ||= readproj($projid, 1);\n  if (!$proj) {\n    $remotemap->{$projid} = { 'name' => $projid };\t# gone!\n    return;\n  }\n  $remotemap->{$projid}->{'repository'} = $proj->{'repository'} if $proj->{'repository'};\n  $remotemap->{$projid}->{'kind'} = $proj->{'kind'} if $proj->{'kind'};\n  if ($proj->{'access'}) {\n    for ('access', 'publish', 'person', 'group') {\n      $remotemap->{$projid}->{$_} = $proj->{$_} if exists $proj->{$_};\n    }\n  }\n}\n\nsub getprojquotapackage {\n  my ($projid) = @_;\n  if (!exists($packagequota{':packages'})) {\n    my $quotaxml = readxml($BSConfig::bsquotafile, $BSXML::quota, 1);\n    for my $p (@{$quotaxml->{'project'} || []}) {\n      $packagequota{$p->{'name'}} = $p->{'packages'};\n    }\n    $packagequota{':packages'} = $quotaxml->{'packages'};\n  }\n  while ($projid) {\n    return $packagequota{$projid} if exists $packagequota{$projid};\n    last unless $projid =~ s/:[^:]*$//;\n  }\n  return $packagequota{':packages'};\n}\n\n# this is kind of a snapshot in time, but good enough for now \nsub mergeroles {\n  my ($projid, $proj) = @_; \n  my @person;\n  my @group;\n  while ($projid ne '') {\n    $proj ||= readproj($projid, 1); \n    if ($proj) {\n      push @person, @{$proj->{'person'} || []};\n      push @group , @{$proj->{'group'} || []};\n    }   \n    last unless $projid =~ s/:[^:]*$//;\n    undef $proj;\n  }\n  return (\\@person, \\@group);\n}\n\nsub getprojpack {\n  my ($cgi, $projids, $repoids, $packids, $arch) = @_;\n  local *oldbsrpc = *BSRPC::rpc;\n  local *BSRPC::rpc;\n  die(\"unsupported view\\n\") if $cgi->{'view'} && $cgi->{'view'} ne 'storable';\n  if ($cgi->{'noremote'}) {\n    *BSRPC::rpc = sub {die(\"400 interconnect error: noremote option\\n\");};\n  } else {\n    *BSRPC::rpc = sub {\n      my $r = eval { oldbsrpc(@_) };\n      if ($@) {\n\t$@ = \"interconnect error: $@\" unless $@ =~ /(?:remote|interconnect) error:/;\n\tdie($@);\n      }\n      return $r;\n    };\n  }\n  $arch ||= 'noarch';\n  my $partition = $cgi->{'partition'};\n  die(\"No such partition '$partition'\\n\") if $partition && $BSConfig::partitionservers && !$BSConfig::partitionservers->{$partition};\n  my $remotemap = $cgi->{'withremotemap'} ? {} : undef;\n  if ($remotemap && $partition) {\n    $remotemap->{':partition'} = $partition;\n    $remotemap->{':partitions'} = {};\n  }\n  $projids = [ findprojects() ] unless $projids;\n  if ($partition) {\n    for my $projid (splice @$projids) {\n      my $par = projid2partition($projid);\n      die(\"cannot determine partition for $projid\\n\") unless defined $par;\n      die(\"partition '$par' from partitioning does not exist\\n\") if $BSConfig::partitionservers && !$BSConfig::partitionservers->{$par};\n      if ($par ne $partition) {\n\t# check if it is remote, if not then it belongs to another partition\n\tmy $r = readproj($projid, 1);\n\t$r = remoteprojid($projid) unless defined $r;\n\tif (!($r && $r->{'remoteurl'})) {\n\t  # not remote, but on wrong partition\n\t  # if asked for a specific project, put it in remotemap\n\t  next unless $remotemap && $cgi->{'project'};\n\t  checkpartition($remotemap, $projid, $r) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$projid};\n\t  if ($remotemap->{$projid} && $cgi->{'withconfig'}) {\n\t    # also put config in remotemap is asked for a specific project\n\t    my $c = readstr(\"$projectsdir/$projid.conf\", 1);\n\t    $remotemap->{$projid}->{'config'} = defined($c) ? $c : '' if ($remotemap->{$projid} || {})->{'partition'};\n\t  }\n\t  next;\n\t}\n      }\n      push @$projids, $projid;\n    }\n  }\n  if ($BSConfig::limit_projects && $BSConfig::limit_projects->{$arch}) {\n    my %limit_projids = map {$_ => 1} @{$BSConfig::limit_projects->{$arch}};\n    $projids = [ grep {$limit_projids{$_}} @$projids ];\n  }\n  $repoids = { map {$_ => 1} @$repoids } if $repoids;\n  $packids = { map {$_ => 1} @$packids } if $packids;\n  my $bconf = Build::read_config($arch);\n\n  $frozenlinks_cache = {};\n  my %channeldata;\n  my @res;\n  for my $projid (@$projids) {\n    my $jinfo = { 'name' => $projid };\n    my $proj = readproj($projid, 1);\n    if ($remotemap && (!$proj || $proj->{'remoteurl'}) && !exists($remotemap->{$projid})) {\n      my $r = remoteprojid($projid);\n      $remotemap->{$projid} = {%$r, 'proto' => 1} if $r;\n    }\n    next unless $proj;\n    for (qw{kind}) {\n      $jinfo->{$_} = $proj->{$_} if exists $proj->{$_};\n    }\n\n    my %expandedrepos;\n\n    if ($cgi->{'withrepos'}) {\n      if ($repoids) {\n\t$jinfo->{'repository'} = [ grep {$repoids->{$_->{'name'}}} @{$proj->{'repository'} || []} ];\n      } else {\n        $jinfo->{'repository'} = $proj->{'repository'} || [];\n      }\n      if ($cgi->{'expandedrepos'}) {\n\t$jinfo->{'repository'} = Storable::dclone($jinfo->{'repository'});\n\tfor my $repo (@{$jinfo->{'repository'}}) {\n\t  my $base = {};\n\t  my @prps = expandsearchpath($projid, $repo->{'name'}, $remotemap, $base);\n\t  $expandedrepos{\"$projid/$repo->{'name'}\"} = [ @prps ];\n\t  for my $prp (@prps) {\n\t    my @s = split('/', $prp, 2);\n\t    $prp = {'project' => $s[0], 'repository' => $s[1]};\n\t  }\n\t  $repo->{'path'} = \\@prps;\n\t  $repo->{'base'} = $base;\n\t}\n      } elsif ($remotemap) {\n\tfor my $repo (@{$jinfo->{'repository'}}) {\n\t  eval {\n\t    my @prps = expandsearchpath($projid, $repo->{'name'}, $remotemap);\n            $expandedrepos{\"$projid/$repo->{'name'}\"} = [ @prps ];\n\t  };\n\t  $expandedrepos{\"$projid/$repo->{'name'}\"} = $@ if $@;\n\t}\n      }\n    }\n\n    if ($remotemap) {\n      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'} || []}) {\n        my $lproj = remoteprojid($lprojid);\n\teval {\n\t  fetchremoteproj($lproj, $lprojid, $remotemap) if $lproj;\n\t};\n        checkpartition($remotemap, $lprojid) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$lprojid};\n      }\n    }\n\n    if ($cgi->{'withconfig'}) {\n      my $config = readstr(\"$projectsdir/$projid.conf\", 1);\n      if ($config) {\n\t#my $s1 = '^\\s*macros:\\s*$.*?^\\s*:macros\\s*$';\n\t#my $s2 = '^\\s*macros:\\s*$.*\\Z';\n\t#$config =~ s/$s1//gmsi;\n\t#$config =~ s/$s2//gmsi;\n\t$jinfo->{'config'} = $config unless $config =~ /^\\s*$/s;\n      }\n    }\n    if ($cgi->{'withsrcmd5'} && -s \"$projectsdir/$projid.pkg/pattern-MD5SUMS\") {\n      my $patterns = readstr(\"$projectsdir/$projid.pkg/pattern-MD5SUMS\", 1);\n      $jinfo->{'patternmd5'} = Digest::MD5::md5_hex($patterns) if $patterns;\n    } elsif ($cgi->{'withsrcmd5'} && $cgi->{'nopackages'}) {\n      # used by publisher to get patternmd5\n      eval {\n\tmy $rev = getrev($projid, '_pattern');\n\tmy $files = lsrev_expanded($rev);\n\t$jinfo->{'patternmd5'} = $rev->{'srcmd5'};\n      };\n    }\n    my @packages;\n    @packages = findpackages($projid, $proj, 2) unless $cgi->{'nopackages'} || $proj->{'remoteurl'};\n    my $missing_packages = grep {$_ eq ':missing_packages'} @packages;\n    if ($missing_packages) {\n      @packages = grep {$_ ne ':missing_packages'} @packages;\n      $jinfo->{'missingpackages'} = 1;\n    }\n    next if $repoids && !grep {$repoids->{$_->{'name'}}} @{$proj->{'repository'} || []};\n    next if $packids && !grep {$packids->{$_}} @packages;\n    for (qw{title description build publish debuginfo useforbuild remoteurl remoteproject download link sourceaccess privacy access lock}) {\n      $jinfo->{$_} = $proj->{$_} if exists $proj->{$_};\n    }\n    if ($proj->{'access'}) {\n      # we need the roles if the project is protected, see checkroles() in the scheduler\n      my ($person, $group) = mergeroles($projid, $proj);\n      $jinfo->{'person'} = $person if $person && @$person;\n      $jinfo->{'group'} = $group if $group && @$group;\n    }\n    # Check build flags in project meta data\n    # packages inherit the project wide settings and may override them\n    my $pdisabled;\n    my $pdisable = {};\n    my $penable = {};\n    undef($penable) if $cgi->{'ignoredisable'};\n    if ($jinfo->{'build'} && $penable) {\n      for (@{$proj->{'repository'} || []}) {\n        my $disen = BSUtil::enabled($_->{'name'}, $jinfo->{'build'}, 1, $arch);\n        if ($disen) {\n          $penable->{$_->{'name'}} = 1;\n        } else {\n          $pdisable->{$_->{'name'}} = 1;\n        }\n      }\n      $pdisabled = 1 if !keys(%$penable);\n    } else {\n      # build is enabled\n      undef($penable);\n    }\n\n    # Check package number quota\n    my $quota_exceeded;\n    if ($BSConfig::bsquotafile) {\n      my $pquota = getprojquotapackage($projid);\n      $quota_exceeded = 1 if defined($pquota) && @packages > $pquota;\n    }\n\n    if (!$cgi->{'ignoredisable'} && !grep {!$_->{'status'} || $_->{'status'} ne 'disabled'} @{$proj->{'repository'} || []}) {\n      # either no repositories or all disabled. No need to check packages\n      @packages = ();\n    }\n    @packages = () if $cgi->{'nopackages'};\n    my @pinfo;\n    my %bconfs;\n\n    my $exclude_all;\n    my $exclude_repos;\n    if (!$cgi->{'ignoredisable'} && defined($cgi->{'arch'})) {\n      $exclude_repos = {};\n      $exclude_all = 1;\n      for (@{$proj->{'repository'} || []}) {\n\tif (grep {$_ eq $arch} @{$_->{'arch'} || []}) {\n\t  undef $exclude_all;\n\t} else {\n          $exclude_repos->{$_->{'name'}} = 1;\n\t}\n      }\n    }\n\n    my @packages_delayed;\n    my $packages_pass = 0;\n    while (1) {\n      if (!@packages) {\n\tlast if !@packages_delayed || $packages_pass;\n\t$packages_pass = 1;\n\tfill_remote_getrev_cache();\n\t@packages = @packages_delayed;\n\tnext;\n      }\n      my $packid = shift(@packages);\n\n      next if $packids && !$packids->{$packid};\n      my $pinfo = {'name' => $packid};\n      push @pinfo, $pinfo;\n      my $pack = readpack($projid, $packid, 1);\n      $pack ||= {} if $proj->{'link'};\n      if (!$pack) {\n\t$pinfo->{'error'} = 'no metadata';\n\tnext;\n      }\n      for (qw{build publish debuginfo useforbuild bcntsynctag sourceaccess privacy access lock}) {\n\t$pinfo->{$_} = $pack->{$_} if $pack->{$_};\n      }\n      if (!$pinfo->{'build'}) {\n        $pinfo->{'build'}->{'enable'} = $pack->{'enable'} if $pack->{'enable'};\n        $pinfo->{'build'}->{'disable'} = $pack->{'disable'} if $pack->{'disable'};\n      }\n      if ($exclude_all) {\n\t$pinfo->{'error'} = 'excluded';\n\tnext;\n      }\n\n      my $enable = defined($penable) ? {%$penable} : undef;\n      my $disable = {%$pdisable};\n      if (!$cgi->{'ignoredisable'} && $pinfo->{'build'}) {\n        for (@{$proj->{'repository'} || []}) {\n          my $default = exists($disable->{$_->{'name'}}) ? 0 : 1;\n          my $disen = BSUtil::enabled($_->{'name'}, $pinfo->{'build'}, $default, $arch);\n          if ($disen) {\n            $enable->{$_->{'name'}} = 1;\n            delete $disable->{$_->{'name'}};\n          } else {\n            $disable->{$_->{'name'}} = 1;\n            delete $enable->{$_->{'name'}};\n          }\n        }\n      }\n      undef($disable) if $enable && !keys(%$enable);\n      undef($enable) if $disable && !keys(%$disable);\n      if ((!$disable || $pdisabled) && $enable && !%$enable) {\n\t$pinfo->{'error'} = 'disabled';\n\tnext;\n      }\n      if ($quota_exceeded) {\n\t$pinfo->{'error'} = 'quota exceeded';\n\tnext;\n      }\n      if ($cgi->{'withsrcmd5'} || $cgi->{'withdeps'}) {\n        my $rev;\n\tmy $linked = [];\n\t$collect_remote_getrev = 1 unless $packages_pass;\n\teval {\n\t  $rev = getrev($projid, $packid, 'build', $linked);\n\t};\n\t$collect_remote_getrev = 0;\n        $pinfo->{'originproject'} = $rev->{'originproject'} if $rev && $rev->{'originproject'};\n        $pinfo->{'linked'} = $linked if @$linked;\n\tif ($@) {\n\t  $pinfo->{'error'} = $@;\n\t  $pinfo->{'error'} =~ s/\\n$//s;\n\t  if (!$packages_pass && $pinfo->{'error'} =~ /collect_remote_getrev$/) {\n\t    pop @pinfo;\n\t    push @packages_delayed, $packid;\n\t  }\n \t  next;\n\t}\n\tif (!$rev || $rev->{'srcmd5'} eq 'empty' || $rev->{'srcmd5'} eq $emptysrcmd5) {\n\t  $pinfo->{'error'} = 'no source uploaded';\n\t  next;\n\t}\n\t$pinfo->{'srcmd5'} = $rev->{'srcmd5'};\n\t$pinfo->{'rev'} = $rev->{'rev'};\n\t$pinfo->{'revtime'} = $rev->{'time'} if $rev->{'time'};\n\tmy $files;\n\teval {\n\t  my $linkinfo = {};\n          $files = lsrev($rev, $linkinfo);\n\t  if ($linkinfo->{'xservicemd5'}) {\n\t    $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'});\n\t    $pinfo->{'srcmd5'} = $rev->{'srcmd5'};\n\t  }\n\t  if ($linkinfo->{'xservicemd5'} || $linkinfo->{'lservicemd5'} || $linkinfo->{'lsrcmd5'}) {\n\t    my $meta = '';\n\t    $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n\t    $pinfo->{'verifymd5'} = Digest::MD5::md5_hex($meta);\n\t  }\n\t};\n\tif ($@) {\n\t  $pinfo->{'error'} = $@;\n\t  $pinfo->{'error'} =~ s/\\n$//s;\n \t  next;\n\t}\n\tif ($files->{'_service'} && -e \"$eventdir/service/${projid}::$packid\") {\n\t  $pinfo->{'error'} = 'source update running';\n \t  next;\n\t}\n        if ($files->{'_service_error'}) {\n\t  $pinfo->{'error'} = 'source service failed';\n \t  next;\n        }\n\tif ($files->{'_link'}) {\n\t  $collect_remote_getrev = 1 unless $packages_pass;\n\t  eval {\n\t    $files = handlelinks($rev, $files, {'linked' => $linked});\n\t  };\n\t  $collect_remote_getrev = 0;\n\t  if ($@) {\n\t    $files = \"$@\";\n\t    $files =~ s/\\n$//;\n\t  }\n\t  if (@$linked) {\n\t    $pinfo->{'linked'} = $linked;\n\t    if ($remotemap && $remotemap->{':partitions'}) {\n\t      # we need to have all partition infos set for the links\n\t      for my $li (@$linked) {\n\t\tmy $lprojid = $li->{'project'};\n\t\tnext if $remotemap->{$lprojid} || $remotemap->{':partitions'}->{$lprojid};\n\t\tmy $lproj = readproj($lprojid, 1);\n\t\tif ($lproj && !$lproj->{'remoteurl'}) {\n\t\t  checkpartition($remotemap, $lprojid, $lproj);\n\t\t} else {\n\t\t  $remotemap->{':partitions'}->{$lprojid} = 1;  # not on a partition\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  if (!ref $files) {\n\t    $pinfo->{'error'} = defined($files) ? $files : \"could not get file list\";\n\t    if (!$packages_pass && $pinfo->{'error'} =~ /collect_remote_getrev$/) {\n\t      pop @pinfo;\n\t      push @packages_delayed, $packid;\n\t    }\n\t    next;\n\t  }\n\t  $pinfo->{'srcmd5'} = $rev->{'srcmd5'};\n\t  my $meta = '';\n\t  $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n\t  $pinfo->{'verifymd5'} = Digest::MD5::md5_hex($meta);\n\t}\n\tif ($packid eq '_pattern') {\n\t  $jinfo->{'patternmd5'} = $pinfo->{'srcmd5'};\n\t  $pinfo->{'error'} = 'excluded';\n\t  next;\n\t}\n\tif ($files->{'_aggregate'}) {\n\t  my $aggregatelist = repreadxml($rev, '_aggregate', $files->{'_aggregate'}, $BSXML::aggregatelist, 1);\n\t  if (!$aggregatelist) {\n\t    $pinfo->{'error'} = \"bad aggregatelist data\";\n\t    next;\n\t  }\n          eval {\n\t    BSVerify::verify_aggregatelist($aggregatelist);\n          };\n\t  if ($@) {\n\t    my $err = $@;\n\t    $err =~ s/\\n$//s;\n\t    $pinfo->{'error'} = \"bad aggregatelist: $err\";\n\t    next;\n\t  }\n\t  $pinfo->{'aggregatelist'} = $aggregatelist;\n\t  if ($remotemap && $aggregatelist) {\n\t    for my $aggregate (@{$aggregatelist->{'aggregate'} || []}) {\n\t      my $aprojid = $aggregate->{'project'};\n\t      next if $remotemap->{$aprojid} && !$remotemap->{$aprojid}->{'proto'};\n\t      my $aproj = readproj($aprojid, 1);\n\t      if (!$aproj || $aproj->{'remoteurl'}) {\n\t\t$aproj = remoteprojid($aprojid);\n\t\teval {\n\t\t  fetchremoteproj($aproj, $aprojid, $remotemap) if $aproj;\n\t\t};\n\t      } else {\n\t\tcheckpartition($remotemap, $aprojid, $aproj) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$aprojid};\n\t      }\n\t    }\n\t  }\n\t  if (($enable && %$enable) || ($disable && %$disable)) {\n\t    my @dinfo = ();\n\t    for my $repo (@{$proj->{'repository'} || []}) {\n\t      my $repoid = $repo->{'name'};\n\t      next if $repoids && !$repoids->{$repoid};\n\t      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {\n\t        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};\n\t\tnext;\n\t      }\n\t    }\n\t    $pinfo->{'info'} = \\@dinfo if @dinfo;\n\t  }\n\t} elsif ($files->{'_patchinfo'}) {\n\t  my $patchinfo = repreadxml($rev, '_patchinfo', $files->{'_patchinfo'}, $BSXML::patchinfo, 1);\n          if (!$patchinfo) {\n\t    $pinfo->{'error'} = \"bad patchinfo data\";\n\t    next;\n\t  }\n          eval {\n\t    BSVerify::verify_patchinfo($patchinfo);\n          };\n\t  if ($@) {\n\t    my $err = $@;\n\t    chomp $err;\n\t    $pinfo->{'error'} = \"bad patchinfo: $err\";\n\t    next;\n\t  }\n\t  $pinfo->{'patchinfo'} = $patchinfo;\n\t  if (($enable && %$enable) || ($disable && %$disable)) {\n\t    my @dinfo = ();\n\t    for my $repo (@{$proj->{'repository'} || []}) {\n\t      my $repoid = $repo->{'name'};\n\t      next if $repoids && !$repoids->{$repoid};\n\t      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {\n\t        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};\n\t\tnext;\n\t      }\n\t    }\n\t    $pinfo->{'info'} = \\@dinfo if @dinfo;\n\t  }\n\t} elsif ($files->{'_channel'}) {\n\t  if (!exists($channeldata{$files->{'_channel'}})) {\n\t    eval {\n\t      my $channel = repreadxml($rev, '_channel', $files->{'_channel'}, $BSXML::channel);\n\t      BSVerify::verify_channel($channel);\n\t      $channeldata{$files->{'_channel'}} = $channel;\n\t    };\n\t    if ($@) {\n\t      my $err = $@;\n\t      chomp $err;\n\t      $channeldata{$files->{'_channel'}} = $err;\n\t    }\n\t  }\n\t  my $channel = $channeldata{$files->{'_channel'}} || 'bad data';\n          if (!ref($channel)) {\n\t    $pinfo->{'error'} = \"bad channel: $channel\";\n\t    next;\n\t  }\n          $pinfo->{'channelmd5'} = $files->{'_channel'};\n\t  if (($enable && %$enable) || ($disable && %$disable)) {\n\t    my @dinfo = ();\n\t    for my $repo (@{$proj->{'repository'} || []}) {\n\t      my $repoid = $repo->{'name'};\n\t      next if $repoids && !$repoids->{$repoid};\n\t      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {\n\t        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};\n\t\tnext;\n\t      }\n\t    }\n\t    $pinfo->{'info'} = \\@dinfo if @dinfo;\n\t  }\n        } elsif ($cgi->{'withdeps'}) {\n\t  my @dinfo;\n\n\t  $pinfo->{'constraintsmd5'} = $files->{'_constraints'} if $files->{'_constraints'};\n\t  $pinfo->{'hasbuildenv'} = 1 if $files->{'_buildenv'};\n\t  for my $repo (@{$proj->{'repository'} || []}) {\n\t    my $repoid = $repo->{'name'};\n\t    next if $repoids && !$repoids->{$repoid};\n\n\t    my $rinfo = {'repository' => $repoid};\n\t    push @dinfo, $rinfo;\n\t    if ($exclude_repos && $exclude_repos->{$repoid}) {\n\t      $rinfo->{'error'} = 'excluded';\n\t      next;\n\t    }\n\t    if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {\n\t      $rinfo->{'error'} = 'disabled';\n\t      next;\n\t    }\n            if (!$bconfs{$repoid}) {\n\t      print \"calculating config for $projid/$repoid $arch\\n\";\n\t      my $path = $expandedrepos{\"$projid/$repoid\"};\n\t      if (!$path) {\n\t        eval {\n\t\t  my @path = expandsearchpath($projid, $repoid, $remotemap);\n\t\t  $expandedrepos{\"$projid/$repoid\"} = \\@path;\n\t\t};\n\t\t$expandedrepos{\"$projid/$repoid\"} = $@ if $@;\n\t\t$path = $expandedrepos{\"$projid/$repoid\"};\n\t      }\n\t      eval {\n\t\tdie($path) unless ref $path;\n\t\tmy $c = concatconfigs($projid, $repoid, $remotemap, @$path);\n\t        $bconfs{$repoid} = Build::read_config($arch, [ split(\"\\n\", $c) ]);\n\t      };\n\t      if ($@) {\n\t        my $err = $@;\n\t        chomp $err;\n\t        $bconfs{$repoid} = {'error' => $err};\n\t      }\n            }\n\t    my $conf = $bconfs{$repoid};\n\t    if ($conf->{'error'}) {\n\t      $rinfo->{'error'} = $conf->{'error'};\n\t      next;\n\t    }\n\t    my $type = $conf->{'type'};\n\t    if (!$type || $type eq 'UNDEFINED') {\n\t      $rinfo->{'error'} = 'bad build configuration, no build type defined or detected';\n\t      next;\n\t    }\n            my ($md5, $file) = findfile($rev, $repoid, $type, $files);\n\t    if (!$md5) {\n\t      # no spec/dsc/kiwi file found\n\t      if ($files->{'_preinstallimage'} || $files->{'simpleimage'}  || grep {/\\.(?:spec|dsc|kiwi)$/} keys %$files) {\n\t\t# only different types available\n\t\t$rinfo->{'error'} = 'excluded';\n\t      }\n\t      next;\n\t    }\n\t    $rinfo->{'file'} = $file;\n\t    my $buildtype = Build::recipe2buildtype($file);\n\t    if (!$buildtype) {\n\t      $rinfo->{'error'} = \"don't know how to build $file\";\n\t      next;\n\t    }\n\t    if (($type eq 'kiwi' || $buildtype eq 'kiwi') && $BSConfig::kiwiprojects && !$cgi->{'ignoredisable'}) {\n\t      my %kiwiprojects = map {$_ => 1} @$BSConfig::kiwiprojects;\n\t      if (!$kiwiprojects{$projid}) {\n\t\t$rinfo->{'error'} = 'kiwi image building is not enabled for this project';\n\t        next;\n\t      }\n\t    }\n\t    # get build dependency info\n\t    my $d = Build::parse_typed($conf, \"$srcrep/$packid/$md5-$file\", $buildtype);\n\t    data2utf8xml($d);\n\t    if (!$d || !defined($d->{'name'})) {\n\t      $rinfo->{'error'} = \"can not parse package name from $file\";\n\t      $rinfo->{'error'} .= \" because: \".$d->{'error'} if $d->{'error'};\n\t      next;\n\t    }\n\t    my $version = defined($d->{'version'}) ? $d->{'version'} : 'unknown';\n\t    $pinfo->{'versrel'} ||= \"$version-$rev->{'vrev'}\";\n\t    $rinfo->{'name'} = $d->{'name'};\n\t    $rinfo->{'dep'} = $d->{'deps'};\n\t    if ($d->{'prereqs'}) {\n\t      my %deps = map {$_ => 1} (@{$d->{'deps'} || []}, @{$d->{'subpacks'} || []});\n\t      my @prereqs = grep {!$deps{$_} && !/^%/} @{$d->{'prereqs'}};\n\t      $rinfo->{'prereq'} = \\@prereqs if @prereqs;\n\t    }\n            # add all source services to be used at build time\n\t    if ($files->{'_service'}) {\n              my $services = repreadxml($rev, '_service', $files->{'_service'}, $BSXML::services, 1);\n              for my $service (@{$services->{'service'} || []}) {\n                next unless $service->{'mode'} && $service->{'mode'} eq \"buildtime\";\n                push @{$rinfo->{'dep'}}, \"obs-service-$service->{'name'}\";\n              }\n            }\n\t    # KIWI Products support debugmedium and sourcemedium filters\n\t    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') eq 'product') {\n\t      $rinfo->{'nodbgpkgs'} = 1 if defined($d->{'debugmedium'}) && $d->{'debugmedium'} <= 0;\n\t      $rinfo->{'nosrcpkgs'} = 1 if defined($d->{'sourcemedium'}) && $d->{'sourcemedium'} <= 0;\n\t    }\n\t    # KIWI Images don't build with local arch\n\t    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') ne 'product') {\n\t      $rinfo->{'error'} = 'excluded' if defined($BSConfig::localarch) && $arch eq 'local';\n\t    }\n\t    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') eq 'product') {\n\t      # KIWI Products always build on the first repo arch\n\t      $rinfo->{'imagearch'} = [ @{$d->{'exclarch'}} ] if $d->{'exclarch'};\n\t    } else {\n\t      my $myarch = $conf->{'target'} ? (split('-', $conf->{'target'}))[0] : $arch;\n\t      $rinfo->{'error'} = 'excluded' if $d->{'exclarch'} && !grep {$_ eq $myarch} @{$d->{'exclarch'}};\n\t      $rinfo->{'error'} = 'excluded' if $d->{'badarch'} && grep {$_ eq $myarch} @{$d->{'badarch'}};\n\t    }\n\t    for ('imagetype', 'path', 'extrasource') {\n\t      $rinfo->{$_} = $d->{$_} if exists $d->{$_};\n\t    }\n\t    if ($remotemap && $rinfo->{'path'}) {\n\t      # simple way to fill the remote map\n\t      eval {\n\t\tconcatconfigs($projid, $repoid, $remotemap, map {\"$_->{'project'}/$_->{'repository'}\"} grep {$_->{'project'} ne '_obsrepositories'} @{$rinfo->{'path'}});\n\t      };\n\t    }\n\t  }\n\t  $pinfo->{'info'} = \\@dinfo if @dinfo;\n\t}\n      }\n    }\n    $jinfo->{'package'} = \\@pinfo;\n    push @res, $jinfo;\n  }\n  $frozenlinks_cache = undef;\n  my $ret = {'repoid' => $repoid, 'project' => \\@res};\n  if ($remotemap) {\n    delete $remotemap->{':partition'};\n    delete $remotemap->{':partitions'};\n  }\n  #print Dumper($remotemap);\n  if ($remotemap && %$remotemap) {\n    for my $p (sort keys %$remotemap) {\n      next unless $remotemap->{$p};\n      my $r = {'project' => $p};\n      # keep in sync with BSXML! (we only use access/publish from the flags)\n      for (qw{kind root remoteurl remoteproject remoteroot partition proto config publish access person group repository error}) {\n        $r->{$_} = $remotemap->{$p}->{$_} if defined($remotemap->{$p}->{$_});\n      }\n      $r->{'error'} =~ s/\\n$// if $r->{'error'};\n      push @{$ret->{'remotemap'}}, $r;\n    }\n  }\n  if (%channeldata) {\n    for my $md5 (sort keys %channeldata) {\n      next unless ref($channeldata{$md5});\n      push  @{$ret->{'channeldata'}}, {'md5' => $md5, 'channel' => $channeldata{$md5} };\n    }\n  }\n  if ($cgi->{'view'} && $cgi->{'view'} eq 'storable') {\n    return ($ret, \\&BSUtil::tostorable, 'Content-Type: application/octet-stream');\n  }\n  return ($ret, $BSXML::projpack);\n}\n\nsub getprojectlist {\n  my ($cgi) = @_;\n  my @projects = findprojects($cgi->{'deleted'});\n  @projects = map {{'name' => $_}} @projects;\n  return ({'entry' => \\@projects}, $BSXML::dir);\n}\n\nsub getproject {\n  my ($cgi, $projid) = @_;\n  # Read the project xml file\n  my $proj = readproj($projid, 1, $cgi->{'rev'});\n  $proj = remoteprojid($projid) if !$proj || $proj->{'remoteurl'};\n  die(\"404 project '$projid' does not exist\\n\") unless $proj;\n  if ($proj->{'remoteurl'}) {\n    my $p = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_meta\", 'proxy' => $proxy}, $BSXML::proj);\n    # map remote names to local names\n    $p->{'name'} = $projid;\n    for my $r (@{$p->{'repository'} || []}) {\n      for my $re (@{$r->{'path'} || []}) {\n\t$re->{'project'} = maptoremote($proj, $re->{'project'});\n      }\n      for my $re (@{$r->{'releasetarget'} || []}) {\n\t$re->{'project'} = maptoremote($proj, $re->{'project'});\n      }\n    }\n    for my $pp (@{$p->{'link'} || []}) {\n      $pp->{'project'} = maptoremote($proj, $pp->{'project'});\n    }\n    delete $p->{'person'};\n    delete $p->{'group'};\n    $p->{'mountproject'} = $proj->{'root'} if defined $proj->{'root'};\n    $proj = $p;\n  }\n  return ($proj, $BSXML::proj);\n}\n\n#########################################################################\n\nsub pubkey2sslcert {\n  my ($projid, $pubkeyfile, $signkeyfile) = @_;\n  die(\"don't know how to generate a ssl cert\\n\") unless $BSConfig::sign;\n  $pubkeyfile ||= \"$projectsdir/$projid.pkg/_pubkey\";\n  $signkeyfile ||= \"$projectsdir/$projid.pkg/_signkey\";\n  my @signargs;\n  push @signargs, '--project', $projid if $BSConfig::sign_project;\n  my $cert = '';\n  eval {\n    $cert = BSUtil::xsystem(undef, $BSConfig::sign, @signargs, '-P', $signkeyfile, '-C', $pubkeyfile);\n  };\n  if ($@) {\n    die(\"Need an RSA key for openssl signing, please create a new key for $projid\\n\") if $@ =~ /not an RSA private key/i;\n    die($@);\n  }\n  return $cert;\n}\n\nsub updatesslcert {\n  my ($projid, $pubkeyfile, $signkeyfile) = @_;\n  my $rev = getrev_meta($projid, undef);\n  return undef unless $rev;\n  my $files = lsrev($rev);\n  return undef unless $files->{'_sslcert'};\n  my $cert = pubkey2sslcert($projid, $pubkeyfile, $signkeyfile);\n  mkdir_p($uploaddir);\n  writestr(\"$uploaddir/sslcert.$$\", undef, $cert);\n  return \"$uploaddir/sslcert.$$\";\n}\n\nsub createkey {\n  my ($cgi, $projid) = @_;\n  $cgi->{'comment'} ||= 'create sign key';\n  die(\"don't know how to create a key\\n\") unless $BSConfig::sign;\n  die(\"404 project $projid does not exist\\n\") unless -s \"$projectsdir/$projid.xml\";\n  mkdir_p($uploaddir);\n  my $pubkey = '';\n  my @keyargs = ('rsa@2048', '800');\n  my @signargs;\n  push @signargs, '--project', $projid if $BSConfig::sign_project;\n  my $obsname = $BSConfig::obsname || 'build.opensuse.org';\n  local *F;\n  open(F, '-|', $BSConfig::sign, @signargs, '-P', \"$uploaddir/signkey.$$\", '-g', @keyargs, \"$projid OBS Project\", \"$projid\\@$obsname\") || die(\"$BSConfig::sign: $!\\n\");\n  1 while sysread(F, $pubkey, 4096, length($pubkey));\n  close(F) || die(\"$BSConfig::sign: $?\\n\");\n  die(\"sign did not create signkey\\n\") unless -s \"$uploaddir/signkey.$$\";\n  mkdir_p(\"$projectsdir/$projid.pkg\");\n  writestr(\"$uploaddir/pubkey.$$\", undef, $pubkey);\n  my $certfile = updatesslcert($projid, \"$uploaddir/pubkey.$$\", \"$uploaddir/signkey.$$\");\n  addrev_meta_multiple($cgi, $projid, undef, 'mrev',\n\t[ \"$uploaddir/pubkey.$$\",  \"$projectsdir/$projid.pkg/_pubkey\",  '_pubkey' ],\n\t[ \"$uploaddir/signkey.$$\", \"$projectsdir/$projid.pkg/_signkey\", '_signkey' ],\n\t[ $certfile, undef, '_sslcert' ]);\n  return $BSStdServer::return_ok;\n}\n\nsub extendkey {\n  my ($cgi, $projid) = @_;\n  $cgi->{'comment'} ||= 'extend public key expiry date';\n  die(\"don't know how to extend a key\\n\") unless $BSConfig::sign;\n  die(\"project does not have a key\\n\") unless -s \"$projectsdir/$projid.pkg/_pubkey\";\n  die(\"project does not have a signkey\\n\") unless -s \"$projectsdir/$projid.pkg/_signkey\";\n  my @keyargs = ('800');\n  my @signargs;\n  push @signargs, '--project', $projid if $BSConfig::sign_project;\n  my $pubkey = '';\n  local *F;\n  open(F, '-|', $BSConfig::sign, @signargs, '-P', \"$projectsdir/$projid.pkg/_signkey\", '-x', @keyargs, \"$projectsdir/$projid.pkg/_pubkey\") || die(\"$BSConfig::sign: $!\\n\");\n  1 while sysread(F, $pubkey, 4096, length($pubkey));\n  close(F) || die(\"$BSConfig::sign: $?\\n\");\n  mkdir_p($uploaddir);\n  writestr(\"$uploaddir/pubkey.$$\", undef, $pubkey);\n  my $certfile = updatesslcert($projid, \"$uploaddir/pubkey.$$\");\n  addrev_meta_multiple($cgi, $projid, undef, 'mrev',\n\t[ \"$uploaddir/pubkey.$$\",  \"$projectsdir/$projid.pkg/_pubkey\",  '_pubkey' ],\n\t[ $certfile, undef, '_sslcert' ]);\n  return $BSStdServer::return_ok;\n}\n\nsub deletekey {\n  my ($cgi, $projid) = @_;\n  $cgi->{'comment'} ||= 'delete sign key';\n  if ($BSConfig::forceprojectkeys) {\n    my $pprojid = $projid;\n    $pprojid =~ s/:[^:]*$//;\n    my $sk;\n    ($sk) = getsignkey({}, $pprojid) if $projid ne $pprojid;\n    die(\"must have a key for signing in this or upper project\\n\") unless $sk;\n  }\n  addrev_meta_multiple($cgi, $projid, undef, 'mrev',\n\t[ undef, \"$projectsdir/$projid.pkg/_pubkey\",  '_pubkey' ],\n\t[ undef, \"$projectsdir/$projid.pkg/_signkey\", '_signkey' ],\n\t[ undef, undef,                               '_sslcert' ]);\n  rmdir(\"$projectsdir/$projid.pkg\");\n  return $BSStdServer::return_ok;\n}\n\nsub getpubkey {\n  my ($cgi, $projid) = @_;\n  my $pubkey;\n\n  my $proj = readproj($projid, 1, $cgi->{'rev'});\n  $proj = remoteprojid($projid) if !$proj || $proj->{'remoteurl'};\n  die(\"404 project '$projid' does not exist\\n\") unless $proj;\n\n  if ($proj->{'remoteurl'}) {\n    $pubkey = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_pubkey\", 'proxy' => $proxy}, undef);\n  } else {\n    if ($cgi->{'rev'}) {\n      my $rev = getrev_meta($projid, undef, $cgi->{'rev'});\n      my $files = $rev ? lsrev($rev) : {};\n      $pubkey = repreadstr($rev, '_pubkey', $files->{'_pubkey'}, 1) if $files->{'_pubkey'};\n    } else {\n      $pubkey = readstr(\"$projectsdir/$projid.pkg/_pubkey\", 1);\n    }\n  }\n  die(\"404 $projid: no pubkey available\\n\") unless $pubkey;\n  return ($pubkey, 'Content-Type: text/plain');\n}\n\n#########################################################################\n\nsub putproject {\n  my ($cgi, $projid) = @_;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $proj = readxml(\"$uploaddir/$$\", $BSXML::proj);\n  $proj->{'name'} = $projid unless defined $proj->{'name'};\n  BSVerify::verify_proj($proj, $projid);\n  writexml(\"$uploaddir/$$.2\", undef, $proj, $BSXML::proj);\n  unlink(\"$uploaddir/$$\");\n  my $oldproj = readxml(\"$projectsdir/$projid.xml\", $BSXML::proj, 1);\n  notify($oldproj ? \"SRCSRV_UPDATE_PROJECT\" : \"SRCSRV_CREATE_PROJECT\", { \"project\" => $projid, \"sender\" => ($cgi->{'user'} || \"unknown\") });\n  mkdir_p(\"$projectsdir\") || die(\"creating $projectsdir: $!\\n\");\n  addrev_meta($cgi, $projid, undef, \"$uploaddir/$$.2\", \"$projectsdir/$projid.xml\", '_meta');\n  if ($BSConfig::forceprojectkeys) {\n    my ($sk) = getsignkey({}, $projid);\n    createkey({ %$cgi, 'comment' => 'autocreate key' }, $projid) if $sk eq '';\n  }\n\n  my %except = map {$_ => 1} qw{title description person group url attributes};\n  if (!identical($oldproj, $proj, \\%except)) {\n    if ($cgi->{'lowprio'}) {\n      notify_repservers('lowprioproject', $projid);\n    } else {\n      notify_repservers('project', $projid);\n    }\n  }\n\n  $proj = readproj($projid);\n  return ($proj, $BSXML::proj);\n}\n\nsub delproject {\n  my ($cgi, $projid) = @_;\n\n  $cgi->{'comment'} ||= 'project was deleted';\n  die(\"404 project '$projid' does not exist\\n\") unless -e \"$projectsdir/$projid.xml\";\n  # add delete commit to both source and meta\n  addrev_meta($cgi, $projid, undef, undef, undef, undef, 'rev');\n  addrev_meta($cgi, $projid, undef, undef, undef, undef);\n  if (-d \"$projectsdir/$projid.pkg\") {\n    # delete packages in sub process to avoid timeout errors\n    my $pid;\n    if (!($pid = xfork())) {\n      # delete those packages and keys\n      mkdir_p(\"$projectsdir/_deleted/$projid.pkg\");\n      # make room in old delete by deleting all old packages\n      for my $f (ls(\"$projectsdir/_deleted/$projid.pkg\")) {\n        if ($f =~ /\\.m?rev$/) {\n          my $oldrev = readstr(\"$projectsdir/_deleted/$projid.pkg/$f\", 1);\n          if (defined($oldrev) && $oldrev ne '') {\n            BSUtil::lockopen(\\*F, '+>>', \"$projectsdir/_deleted/$projid.pkg/$f.del\");\n            BSUtil::appendstr(\"$projectsdir/_deleted/$projid.pkg/$f.del\", $oldrev);\n            # XXX: add comment\n            close F;\n          }\n          unlink(\"$projectsdir/_deleted/$projid.pkg/$f\");\n        }\n      }\n      for my $f (ls(\"$projectsdir/$projid.pkg\")) {\n        if ($f =~ /^(.*)\\.xml$/) {\n          my $packid = $1;\n          if (! -f \"$projectsdir/$projid.pkg/$1.mrev\") {\n            # create initial meta revision in case it does not exist yet\n            addrev_meta($cgi, $projid, $packid, undef, undef, undef);\n          }\n        }\n      }\n      for my $f (ls(\"$projectsdir/$projid.pkg\")) {\n        if ($f =~ /\\.m?rev(?:\\.del)?$/) {\n          updatelinkinfodb($projid, $1) if $f =~ /^(.*)\\.rev$/;\n          my $oldrev = readstr(\"$projectsdir/$projid.pkg/$f\", 1);\n          if (defined($oldrev) && $oldrev ne '') {\n            BSUtil::lockopen(\\*F, '+>>', \"$projectsdir/_deleted/$projid.pkg/$f\");\n            BSUtil::appendstr(\"$projectsdir/_deleted/$projid.pkg/$f\", $oldrev);\n            close F;\n          }\n        }\n        unlink(\"$projectsdir/$projid.pkg/$f\");\n      }\n      rmdir(\"$projectsdir/$projid.pkg\") || die(\"rmdir $projectsdir/$projid.pkg: $!\\n\");\n    }\n  }\n  unlink(\"$projectsdir/$projid.conf\");\n  unlink(\"$projectsdir/$projid.xml\");\n  notify_repservers('project', $projid);\n\n  notify(\"SRCSRV_DELETE_PROJECT\", { \"project\" => $projid, \"comment\" => $cgi->{'comment'}, \"sender\" => ($cgi->{'user'} || \"unknown\"), \"requestid\" => $cgi->{'requestid'} });\n\n  return $BSStdServer::return_ok;\n}\n\nsub undeleteproject {\n  my ($cgi, $projid) = @_;\n\n  die(\"404 project '$projid' already exists\\n\") if -e \"$projectsdir/$projid.xml\";\n  die(\"404 project '$projid' is not deleted\\n\") unless -e \"$projectsdir/_deleted/$projid.pkg\";\n  $cgi->{'comment'} ||= 'project was undeleted';\n  mkdir_p($uploaddir);\n  mkdir_p(\"$projectsdir/$projid.pkg\");\n  for my $f (ls(\"$projectsdir/_deleted/$projid.pkg\")) {\n    if ($f =~ /\\.m?rev\\.del$/) {\n      BSUtil::cp(\"$projectsdir/_deleted/$projid.pkg/$f\", \"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/$f\");\n    } elsif ($f =~ /^(.*)\\.(m?rev)$/) {\n      my $packid = $1;\n      my $suf = $2;\n      my $rev = undelete_rev($cgi, \"$projectsdir/_deleted/$projid.pkg/$f\", \"$projectsdir/$projid.pkg/$f\");\n      $rev->{'project'} = $projid;\n      $rev->{'package'} = $packid;\n      # extract legacy files\n      if ($suf eq 'rev') {\n\tif ($packid eq '_project') {\n          extract_old_prjsource($projid, $rev);\n\t} else {\n\t  updatelinkinfodb($projid, $packid, $rev, lsrev($rev));\n\t}\n      } elsif ($suf eq 'mrev') {\n        extract_old_meta($projid, $packid, $rev);\n      }\n    }\n  }\n  notify_repservers('project', $projid);\n  notify(\"SRCSRV_UNDELETE_PROJECT\", { \"project\" => $projid, \"comment\" => $cgi->{'comment'}, \"sender\" => ($cgi->{'user'} || \"unknown\") });\n\n  return $BSStdServer::return_ok;\n}\n\n#########################################################################\n\nsub getpackagelist {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n  my $origins = $cgi->{'noorigins'} ? undef : {};\n  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1) unless $cgi->{'deleted'};\n  my @packages = findpackages($projid, $proj, 0, {}, $origins, !$cgi->{'expand'}, $cgi->{'deleted'});\n  for (@packages) {\n    $_ = {'name' => $_};\n    $_->{'originproject'} = $origins->{$_->{'name'}} if $origins && $origins->{$_->{'name'}} ne $projid;\n  }\n  return ({'entry' => \\@packages}, $BSXML::dir);\n}\n\nsub getpackage {\n  my ($cgi, $projid, $packid) = @_;\n  my $proj;\n  $proj = checkprojrepoarch($projid, undef, undef, 1) unless $cgi->{'deleted'};\n  if ($proj && $proj->{'remoteurl'}) {\n    my @args;\n    push @args, \"rev=$cgi->{'rev'}\" if $cgi->{'rev'};\n    my $pack = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/_meta\", 'proxy' => $proxy}, $BSXML::pack, @args);\n    $pack->{'project'} = $projid;\t# local name\n    if ($pack->{'devel'} && exists($pack->{'devel'}->{'project'})) {\n      $pack->{'devel'}->{'project'} = maptoremote($proj, $pack->{'devel'}->{'project'});\n    }\n    delete $pack->{'person'};\n    delete $pack->{'group'};\n    delete $pack->{$_} for map {$_->[0]} @BSXML::flags;\n    return ($pack, $BSXML::pack);\n  }\n  if ($cgi->{'rev'} || $cgi->{'deleted'} || $packid eq '_project') {\n    # return the exact file here\n    # we also do not look at project links\n    # we return the data as string so that the md5 sum matches\n    my $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});\n    my $files = lsrev($rev);\n    die(\"404 _meta: no such file\\n\") unless $files->{'_meta'};\n    my $meta = repreadstr($rev, '_meta', $files->{'_meta'});\n    return ($meta);\n  }\n  my $pack = readpack($projid, $packid, 1);\n  $pack->{'project'} ||= $projid if $pack;\n  if (!$pack && $proj->{'link'}) {\n    my %checked = ($projid => 1);\n    my @todo = map {$_->{'project'}} @{$proj->{'link'}};\n    while (@todo) {\n      my $lprojid = shift @todo;\n      next if $checked{$lprojid};\n      $checked{$lprojid} = 1;\n      my $lproj = readproj($lprojid, 1);\n      $lproj = remoteprojid($lprojid) if !$lproj || $lproj->{'remoteurl'};\n      if ($lproj->{'remoteurl'}) {\n\teval {\n\t  $pack = BSRPC::rpc({'uri' => \"$lproj->{'remoteurl'}/source/$lproj->{'remoteproject'}/$packid/_meta\", 'proxy' => $proxy}, $BSXML::pack);\n\t};\n        die($@) if $@ && $@ !~ /^404/;\n\tif ($pack) {\n\t  $pack->{'project'} = $lprojid;\t# local name\n\t  if ($pack->{'devel'} && exists($pack->{'devel'}->{'project'})) {\n\t    $pack->{'devel'}->{'project'} = maptoremote($lproj, $pack->{'devel'}->{'project'});\n\t  }\n\t}\n      } else {\n        $pack = readpack($lprojid, $packid, 1);\n        $pack->{'project'} ||= $lprojid if $pack;\n        unshift @todo, map {$_->{'project'}} @{$lproj->{'link'}} if !$pack && $lproj->{'link'};\n      }\n      last if $pack;\n    }\n  }\n  die(\"404 package '$packid' does not exist in project '$projid'\\n\") unless $pack;\n  return ($pack, $BSXML::pack);\n}\n\nsub putpackage {\n  my ($cgi, $projid, $packid) = @_;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $pack = readxml(\"$uploaddir/$$\", $BSXML::pack);\n  $pack->{'name'} = $packid unless defined $pack->{'name'};\n  BSVerify::verify_pack($pack, $packid);\n  die(\"package contains revision data\\n\") if grep {exists $pack->{$_}} @$srcrevlay;\n  # XXX\n  # delete rev stuff, just in case...\n  # delete $pack->{$_} for @$srcrevlay;\n  # $pack->{'name'} = $packid;\n  writexml(\"$uploaddir/$$.2\", undef, $pack, $BSXML::pack);\n  unlink(\"$uploaddir/$$\");\n  my $proj = readproj($projid);\n  die(\"$projid is a remote project\\n\") if $proj->{'remoteurl'};\n  if ($packid eq '_product' && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n    # creating a _product package, make sure that there is no _product:xxx package\n    my @pkgs = findpackages($projid, $proj, 1, undef, undef, 1);\n    die(\"cannot create '$packid' if _product:* packages already exist\\n\") if grep {/^_product:/} @pkgs;\n  }\n  if (($packid =~ /^_product:/) && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n    die(\"403 cannot create '$packid' if a '_product' package exists\\n\") if -e \"$projectsdir/$projid.pkg/_product.xml\";\n  }\n  mkdir_p(\"$projectsdir/$projid.pkg\");\n\n  my $oldpack = readxml(\"$projectsdir/$projid.pkg/$packid.xml\", $BSXML::pack, 1);\n  notify($oldpack ? \"SRCSRV_UPDATE_PACKAGE\" : \"SRCSRV_CREATE_PACKAGE\", { \"project\" => $projid, \"package\" => $packid, \"sender\" => ($cgi->{'user'} || \"unknown\")});\n\n  addrev_meta($cgi, $projid, $packid, \"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/$packid.xml\", '_meta');\n  my %except = map {$_ => 1} qw{title description devel person group url};\n  if (!identical($oldpack, $pack, \\%except)) {\n    notify_repservers('package', $projid, $packid);\n  }\n  $pack = readpack($projid, $packid);\n  return ($pack, $BSXML::pack);\n}\n\nsub delpackage {\n  my ($cgi, $projid, $packid) = @_;\n  $cgi->{'comment'} ||= 'package was deleted';\n  die(\"404 project '$projid' does not exist\\n\") unless -e \"$projectsdir/$projid.xml\";\n  die(\"404 package '$packid' does not exist in project '$projid'\\n\") unless -e \"$projectsdir/$projid.pkg/$packid.xml\";\n  if ($packid =~ /^_product:/) {\n    die(\"403 cannot delete '$packid' if a '_product' package exists\\n\") if -e \"$projectsdir/$projid.pkg/_product.xml\";\n  }\n  # add delete commit to both source and meta\n  addrev_meta($cgi, $projid, $packid, undef, undef, undef, 'rev');\n  addrev_meta($cgi, $projid, $packid, undef, undef, undef);\n  unlink(\"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\");\n  unlink(\"$projectsdir/$projid.pkg/$packid.xml\");\n  my $oldrev = readstr(\"$projectsdir/$projid.pkg/$packid.rev\", 1);\n  if (defined($oldrev) && $oldrev ne '') {\n    BSUtil::lockopen(\\*F, '+>>', \"$projectsdir/$projid.pkg/$packid.rev.del\");\n    BSUtil::appendstr(\"$projectsdir/$projid.pkg/$packid.rev.del\", $oldrev);\n    close F;\n    updatelinkinfodb($projid, $packid);\n  }\n  unlink(\"$projectsdir/$projid.pkg/$packid.rev\");\n  $oldrev = readstr(\"$projectsdir/$projid.pkg/$packid.mrev\", 1);\n  if (defined($oldrev) && $oldrev ne '') {\n    BSUtil::lockopen(\\*F, '+>>', \"$projectsdir/$projid.pkg/$packid.mrev.del\");\n    BSUtil::appendstr(\"$projectsdir/$projid.pkg/$packid.mrev.del\", $oldrev);\n    close F;\n  }\n  unlink(\"$projectsdir/$projid.pkg/$packid.mrev\");\n  if ($packid eq '_product') {\n    expandproduct($projid, $packid, undef, undef);\n  }\n  notify_repservers('package', $projid, $packid);\n  notify(\"SRCSRV_DELETE_PACKAGE\", { \"project\" => $projid, \"package\" => $packid, \"sender\" => ($cgi->{'user'} || \"unknown\"), \"comment\" => $cgi->{'comment'}, \"requestid\" => $cgi->{'requestid'} });\n  return $BSStdServer::return_ok;\n}\n\nsub undelete_rev {\n  my ($cgi, $revfilefrom, $revfileto) = @_;\n  my @rev = BSFileDB::fdb_getall($revfilefrom, $srcrevlay);\n  die(\"$revfilefrom: no entries\\n\") unless @rev;\n  # XXX add way to specify which block to restore\n  for my $rev (reverse splice @rev) {\n    unshift @rev, $rev;\n    last if $rev->{'rev'} == 1;\n  }\n  my $rev = $rev[-1];\n  my $user = defined($cgi->{'user'}) ? str2utf8xml($cgi->{'user'}) : 'unknown';\n  my $comment = defined($cgi->{'comment'}) ? str2utf8xml($cgi->{'comment'}) : '';\n  my $nrev = { 'srcmd5' => $rev->{'srcmd5'}, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $cgi->{'requestid'} };\n  $nrev->{'version'} = $rev->{'version'} if $rev && defined $rev->{'version'};\n  $nrev->{'vrev'} = $rev->{'vrev'} if $rev && defined $rev->{'vrev'};\n  $nrev->{'rev'} = $rev->{'rev'} + 1;\n  if ($cgi->{'time'}) {\n    die(\"specified time is less than time in last commit\\n\") if $rev && $rev->{'time'} > $cgi->{'time'};\n    $nrev->{'time'} = $cgi->{'time'};\n  }\n  push @rev, $nrev;\n  BSFileDB::fdb_add_multiple($revfileto, $srcrevlay, @rev);\n  return $nrev;\n}\n\nsub undeletepackage {\n  my ($cgi, $projid, $packid) = @_;\n  $cgi->{'comment'} ||= 'package was undeleted';\n  die(\"404 project '$projid' does not exist\\n\") unless -e \"$projectsdir/$projid.xml\";\n  die(\"403 package '$packid' already exists\\n\") if -e \"$projectsdir/$projid.pkg/$packid.xml\";\n  die(\"403 package '$packid' was not deleted\\n\") unless -e \"$projectsdir/$projid.pkg/$packid.rev.del\";\n  my $rev = undelete_rev($cgi, \"$projectsdir/$projid.pkg/$packid.mrev.del\", \"$projectsdir/$projid.pkg/$packid.mrev\");\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n  extract_old_meta($projid, $packid, $rev);\n  if (-s \"$projectsdir/$projid.pkg/$packid.rev.del\") {\n    my $nrev = undelete_rev($cgi, \"$projectsdir/$projid.pkg/$packid.rev.del\", \"$projectsdir/$projid.pkg/$packid.rev\");\n    $nrev->{'project'} = $projid;\n    $nrev->{'package'} = $packid;\n    updatelinkinfodb($projid, $packid, $nrev, lsrev($nrev));\n  }\n  notify_repservers('package', $projid, $packid);\n  notify(\"SRCSRV_UNDELETE_PACKAGE\", { \"project\" => $projid, \"package\" => $packid, \"sender\" => ($cgi->{'user'} || \"unknown\"), \"comment\" => $cgi->{'comment'} });\n\n  return $BSStdServer::return_ok;\n}\n\nsub getpackagehistory {\n  my ($cgi, $projid, $packid) = @_;\n  my @res;\n  my $revfile;\n  $packid = '_project' unless defined $packid;\n\n  if (!$cgi->{'deleted'}) {\n    my $proj = checkprojrepoarch($projid, undef, undef, 1);\n    if ($proj->{'remoteurl'}) {\n      my @args;\n      push @args, \"rev=$cgi->{'rev'}\" if $cgi->{'rev'};\n      my $h = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/_history\", 'proxy' => $proxy}, $BSXML::revisionlist, @args);\n      return ($h, $BSXML::revisionlist);\n    }\n    if ($packid ne '_project' && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n      # check project links\n      die(\"404 package '$packid' does not exist\\n\") unless $proj->{'link'};\n      $cgi->{'_checked'} ||= {};\n      $cgi->{'_checked'}->{$projid} = 1;\n      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {\n\tnext if $cgi->{'_checked'}->{$lprojid};\n\t$cgi->{'_checked'}->{$lprojid} = 1;\n\tmy $h;\n\teval {\n\t  $h = (getpackagehistory($cgi, $lprojid, $packid))[0];\n\t};\n\tdie($@) if $@ && $@ !~ /^404/;\n\treturn ($h, $BSXML::revisionlist) if $h;\n      }\n      die(\"404 package '$packid' does not exist\\n\");\n    }\n  }\n\n  $revfile = \"$projectsdir/$projid.pkg\";\n  $revfile = \"$projectsdir/_deleted/$projid.pkg\" if $packid eq '_project' && $cgi->{'deleted'};\n  $revfile .= $cgi->{'meta'} ? \"/$packid.mrev\" : \"/$packid.rev\";\n  if ($packid ne '_project' && $cgi->{'deleted'}) {\n    $revfile .= '.del';\n    if (! -e $revfile && ! -e \"$projectsdir/$projid.xml\" && -e \"$projectsdir/_deleted/$projid.pkg\") {\n      $revfile = \"$projectsdir/_deleted/$projid.pkg/$packid.mrev\";\n    }\n  }\n  my $filter;\n  if ($cgi->{'rev'}) {\n    $filter = sub { return $cgi->{'rev'} eq $_[0]->{'rev'} || $cgi->{'rev'} eq $_[0]->{'srcmd5'} ? 1 : 0 };\n  }\n  for (BSFileDB::fdb_getall_reverse($revfile, $srcrevlay, $cgi->{'limit'}, $filter)) {\n    $_->{'comment'} = str2utf8xml($_->{'comment'}) if $_->{'comment'};\n    unshift @res, $_;\n  }\n  return ({'revision' => \\@res}, $BSXML::revisionlist);\n}\n\n##########################################################################\n\n##########################################################################\n\n# XXX -> library\n\nsub remoteprojid {\n  my ($projid) = @_;\n  my $rsuf = '';\n  my $origprojid = $projid;\n\n  my $proj = readproj($projid, 1);\n  if ($proj) {\n    return undef unless $proj->{'remoteurl'};\n    return undef unless $proj->{'remoteproject'};\n    return {\n      'name' => $projid,\n      'root' => $projid,\n      'remoteroot' => $proj->{'remoteproject'},\n      'remoteurl' => $proj->{'remoteurl'},\n      'remoteproject' => $proj->{'remoteproject'},\n    };\n  }\n  while ($projid =~ /^(.*)(:.*?)$/) {\n    $projid = $1;\n    $rsuf = \"$2$rsuf\";\n    $proj = readproj($projid, 1);\n    if ($proj) {\n      return undef unless $proj->{'remoteurl'};\n      if ($proj->{'remoteproject'}) {\n        $rsuf = \"$proj->{'remoteproject'}$rsuf\";\n      } else {\n        $rsuf =~ s/^://;\n      }\n      return {\n        'name' => $origprojid,\n        'root' => $projid,\n        'remoteroot' => $proj->{'remoteproject'},\n        'remoteurl' => $proj->{'remoteurl'},\n        'remoteproject' => $rsuf,\n      };\n    }\n  }\n  return undef;\n}\n\nsub maptoremote {\n  my ($proj, $projid) = @_;\n  return \"$proj->{'root'}:$projid\" unless $proj->{'remoteroot'};\n  return $proj->{'root'} if $projid eq $proj->{'remoteroot'};\n  return '_unavailable' if $projid !~ /^\\Q$proj->{'remoteroot'}\\E:(.*)$/;\n  return \"$proj->{'root'}:$1\";\n}\n\nsub fetchremoteproj {\n  my ($proj, $projid, $remotemap) = @_;\n  return undef unless $proj && $proj->{'remoteurl'} && $proj->{'remoteproject'};\n  $projid ||= $proj->{'name'};\n  my $rproj;\n  my $c;\n  if ($remotemap) {\n    $rproj = $remotemap->{$projid};\n    if ($rproj) {\n      die($rproj->{'error'}) if $rproj->{'error'};\n      return $rproj unless $rproj->{'proto'};\n      $c = $rproj->{'config'};\t# save old config\n      undef $rproj;\n    }\n  }\n  print \"fetching remote project data for $projid\\n\";\n  my $param = {\n    'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_meta\",\n    'timeout' => 60,\n    'proxy' => $proxy,\n  };\n  eval {\n    $rproj = BSRPC::rpc($param, $BSXML::proj);\n  };\n  if ($@) {\n    if ($remotemap) {\n      $rproj = {%$proj, 'error' => $@, 'proto' => 1};\n      $rproj->{'config'} = $c if defined $c;\n      $remotemap->{$projid} = $rproj;\n    }\n    die($@);\n  }\n  for (qw{name kind root remoteroot remoteurl remoteproject}) {\n    $rproj->{$_} = $proj->{$_};\n  }\n  for my $repo (@{$rproj->{'repository'} || []}) {\n    for my $pathel (@{$repo->{'path'} || []}) {\n      $pathel->{'project'} = maptoremote($proj, $pathel->{'project'});\n    }\n    for my $pathel (@{$repo->{'releasetarget'} || []}) {\n      $pathel->{'project'} = maptoremote($proj, $pathel->{'project'});\n    }\n  }\n  for my $link (@{$rproj->{'link'} || []}) {\n    $link->{'project'} = maptoremote($proj, $link->{'project'});\n  }\n  $remotemap->{$projid} = $rproj if $remotemap;\n  return $rproj;\n}\n\nsub fetchremoteconfig {\n  my ($proj, $projid, $remotemap) = @_;\n  return undef unless $proj && $proj->{'remoteurl'} && $proj->{'remoteproject'};\n  $projid ||= $proj->{'name'};\n  if ($remotemap) {\n    my $rproj = $remotemap->{$projid};\n    if ($rproj) {\n      die($rproj->{'error'}) if $rproj->{'error'};\n      return $rproj->{'config'} if defined $rproj->{'config'};\n    } else {\n      $remotemap->{$projid} = {%$proj, 'proto' => 1};\n    }\n  }\n  print \"fetching remote project config for $projid\\n\";\n  my $param = {\n    'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_config\",\n    'timeout' => 60,\n    'proxy' => $proxy,\n  };\n  my $c;\n  eval {\n    $c = BSRPC::rpc($param, undef);\n  };\n  if ($@) {\n    $remotemap->{$projid}->{'error'} = $@ if $remotemap;\n    die($@);\n  }\n  $remotemap->{$projid}->{'config'} = $c if $remotemap;\n  return $c;\n}\n\nsub fill_remote_getrev_cache_projid {\n  my ($projid, $packids) = @_;\n\n  return unless $packids && @$packids;\n  print \"filling remote_getrev cache for $projid @$packids\\n\";\n  my $proj = remoteprojid($projid);\n  return unless $proj;\n  my $silist;\n  my @args;\n  push @args, 'view=info';\n  push @args, 'nofilename=1';\n  push @args, map {\"package=$_\"} @$packids;\n  eval {\n    $silist = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}\", 'proxy' => $proxy}, $BSXML::sourceinfolist, @args);\n  };\n  warn($@) if $@;\n  return unless $silist;\n  for my $si (@{$silist->{'sourceinfo'} || []}) {\n    my $packid = $si->{'package'};\n    my $rev = {};\n    if ($si->{'linked'}) {\n      $rev->{'linked'} = [];\n      for my $l (@{$si->{'linked'}}) {\n        $l->{'project'} = maptoremote($proj, $l->{'project'});\n        push @{$rev->{'linked'}}, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';\n      }\n    }\n    $rev->{'srcmd5'} = $si->{'verifymd5'} || $si->{'srcmd5'};\n    delete $rev->{'srcmd5'} unless defined $rev->{'srcmd5'};\n    if ($si->{'error'}) {\n      if ($si->{'error'} =~ /^(\\d+) +(.*?)$/) {\n        $si->{'error'} = \"$1 remote error: $2\";\n      } else {\n        $si->{'error'} = \"remote error: $si->{'error'}\";\n      }\n      if ($si->{'error'} eq 'no source uploaded') {\n\tdelete $si->{'error'};\n\t$rev->{'srcmd5'} = $emptysrcmd5;\n      } elsif ($si->{'verifymd5'} || $si->{'error'} =~ /^404[^\\d]/) {\n\t$rev->{'error'} = $si->{'error'};\n\t$remote_getrev_cache{\"$projid/$packid/\"} = $rev;\n      } else {\n\tnext;\n      }\n    }\n    next unless $rev->{'srcmd5'};\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n    next unless -e \"$treedir/$rev->{'srcmd5'}-MD5SUMS\";\n    $rev->{'vrev'} = $si->{'vrev'} || '0';\n    $rev->{'rev'} = $si->{'rev'} || $rev->{'srcmd5'};\n    $remote_getrev_cache{\"$projid/$packid/\"} = $rev;\n  }\n}\n\nsub fill_remote_getrev_cache {\n  for my $projid (sort keys %{$remote_getrev_todo || {}}) {\n    my @packids = sort keys %{$remote_getrev_todo->{$projid} || {}};\n    next if @packids <= 1;\n    while (@packids) {\n      my @chunk;\n      my $len = 20;\n      while (@packids) {\n\tmy $packid = shift @packids;\n\tpush @chunk, $packid;\n\t$len += 9 + length($packid);\n\tlast if $len > 1900;\n      }\n      fill_remote_getrev_cache_projid($projid, \\@chunk);\n    }\n  }\n  $remote_getrev_todo = {};\n}\n\nsub remote_getrev {\n  my ($projid, $packid, $rev, $linked, $missingok) = @_;\n  my $proj = remoteprojid($projid);\n  if (!$proj) {\n    return {'project' => $projid, 'package' => $packid, 'srcmd5' => 'pattern', 'rev' => 'pattern'} if $packid eq '_pattern';\n    return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok;\n    die(\"404 package '$packid' does not exist\\n\") if -e \"$projectsdir/$projid.xml\";\n    die(\"404 project '$projid' does not exist\\n\");\n  }\n  # check if we already know this srcmd5, if yes don't bother to contact\n  # the remote server\n  if ($rev && $rev =~ /^[0-9a-f]{32}$/) {\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n    if ($rev eq $emptysrcmd5 || -e \"$treedir/$rev-MD5SUMS\") {\n      return {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};\n    }        \n  }\n  if (defined($rev) && $rev eq '0') {\n    return {'srcmd5' => $emptysrcmd5, 'project' => $projid, 'package' => $packid};\n  }\n  my @args;\n  push @args, 'expand=1';\n  push @args, \"rev=$rev\" if defined $rev;\n  my $cacherev = !defined($rev) || $rev eq 'build' ? '' : $rev;\n  if ($remote_getrev_cache{\"$projid/$packid/$cacherev\"}) {\n    $rev = { %{$remote_getrev_cache{\"$projid/$packid/$cacherev\"}} };\n    push @$linked, map { { %$_ } } @{$rev->{'linked'}} if $linked && $rev->{'linked'};\n    if ($rev->{'error'}) {\n      return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok && $rev->{'error'} =~ /^404[^\\d]/;\n      die(\"$rev->{'error'}\\n\");\n    }\n    delete $rev->{'linked'};\n    $rev->{'project'} = $projid;\n    $rev->{'package'} = $packid;\n    return $rev;\n  }\n  if ($collect_remote_getrev && $cacherev eq '') {\n    $remote_getrev_todo->{$projid}->{$packid} = 1;\n    die(\"collect_remote_getrev\\n\");\n  }\n  my $dir;\n  eval {\n    $dir = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid\", 'proxy' => $proxy}, $BSXML::dir, @args, 'withlinked') if $linked;\n  };\n  if (!$dir || $@) {\n    eval {\n      $dir = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid\", 'proxy' => $proxy}, $BSXML::dir, @args);\n    };\n    if ($@) {\n      return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok && $@ =~ /^404[^\\d]/;\n      die($@);\n    }\n  }\n  if ($dir->{'error'}) {\n    if ($linked && $dir->{'linkinfo'} && $dir->{'linkinfo'}->{'linked'}) {\n      # add linked info for getprojpack\n      for my $l (@{$dir->{'linkinfo'}->{'linked'}}) {\n        $l->{'project'} = maptoremote($proj, $l->{'project'});\n        push @$linked, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';\n      }\n    }\n    die(\"$dir->{'error'}\\n\");\n  }\n  $rev = {};\n  $rev->{'rev'} = $dir->{'rev'} || $dir->{'srcmd5'};\n  $rev->{'srcmd5'} = $dir->{'srcmd5'};\n  $rev->{'vrev'} = $dir->{'vrev'};\n  $rev->{'vrev'} ||= '0';\n  # now put everything in local srcrep\n  my $files = {};\n  for my $entry (@{$dir->{'entry'} || []}) {\n    $files->{$entry->{'name'}} = $entry->{'md5'};\n    next if -e \"$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}\";\n    if ($linked && $entry->{'size'} > 8192) {\n      # getprojpack request, hand over to AJAX\n      BSHandoff::rpc($ajaxsocket, \"/source/$projid/$packid\", undef, \"rev=$dir->{'srcmd5'}\", 'view=notify');\n      die(\"download in progress\\n\");\n    }\n    mkdir_p($uploaddir);\n    my $param = {\n      'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/$entry->{'name'}\",\n      'filename' => \"$uploaddir/$$\",\n      'withmd5' => 1,\n      'receiver' => \\&BSHTTP::file_receiver,\n      'proxy' => $proxy,\n    };\n    my $res = BSRPC::rpc($param, undef, \"rev=$rev->{'srcmd5'}\");\n    die(\"file download failed\\n\") unless $res && $res->{'md5'} eq $entry->{'md5'};\n    addfile($projid, $packid, \"$uploaddir/$$\", $entry->{'name'}, $entry->{'md5'});\n  }\n  my $srcmd5 = addmeta($projid, $packid, $files);\n  if ($dir->{'serviceinfo'}) {\n    $dir->{'srcmd5'} = $rev->{'srcmd5'} = $srcmd5;\n  }\n  my @linked;\n  if ($dir->{'linkinfo'}) {\n    $dir->{'srcmd5'} = $rev->{'srcmd5'} = $srcmd5;\n    $rev->{'rev'} = $rev->{'srcmd5'} unless $dir->{'rev'};\n    if ($linked) {\n      # add linked info for getprojpack\n      my $li = $dir->{'linkinfo'};\n      if ($li->{'linked'}) {\n\tfor my $l (@{$li->{'linked'}}) {\n\t  $l->{'project'} = maptoremote($proj, $l->{'project'});\n\t  push @linked, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';\n\t}\n\tundef $li;\n      }\n      while ($li) {\n        my $lprojid = $li->{'project'};\n        my $lpackid = $li->{'package'};\n        last unless defined($lprojid) && defined($lpackid);\n        my $mlprojid = maptoremote($proj, $lprojid);\n        last unless defined($mlprojid) && $mlprojid ne '_unavailable';\n        push @linked, {'project' => $mlprojid, 'package' => $lpackid};\n\tlast unless $li->{'srcmd5'} && !$li->{'error'};\n\tmy $ldir;\n\teval {\n\t  $ldir = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$lprojid/$lpackid\", 'proxy' => $proxy}, $BSXML::dir, \"rev=$li->{'srcmd5'}\");\n\t};\n\tlast if $@ || !$ldir;\n\t$li = $ldir->{'linkinfo'};\n      }\n      push @$linked, @linked;\n    }\n  }\n  die(\"srcmd5 mismatch\\n\") if $dir->{'srcmd5'} ne $srcmd5;\n  if (!$dir->{'linkinfo'} || $linked) {\n    my %revcopy = %$rev;\n    $revcopy{'linked'} = [ map { { %$_ } } @linked ] if $dir->{'linkinfo'};\n    $remote_getrev_cache{\"$projid/$packid/$cacherev\"} = \\%revcopy;\n  }\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n  return $rev;\n}\n\nsub expandsearchpath {\n  my ($projid, $repoid, $remotemap, $base) = @_;\n  my %done;\n  my @ret;\n  my @path = {project => $projid, repository => $repoid};\n  while (@path) {\n    my $t = shift @path;\n    my $prp = \"$t->{'project'}/$t->{'repository'}\";\n    push @ret, $prp unless $done{$prp};\n    $done{$prp} = 1;\n    if (!@path) {\n      ($base->{'project'}, $base->{'repository'}) = ($t->{'project'}, $t->{'repository'}) if $base;\n      last if $done{\"/$prp\"};\n      my ($pid, $tid) = ($t->{'project'}, $t->{'repository'});\n      my $proj = readproj($pid, 1);\n      if (!$proj || $proj->{'remoteurl'}) {\n\tundef $proj;\n\t$proj = $remotemap->{$pid} if $remotemap && $remotemap->{$pid};\n\tif (!$proj || $proj->{'proto'}) {\n          $proj = remoteprojid($pid);\n          $proj = fetchremoteproj($proj, $pid, $remotemap);\n          die(\"404 project '$pid' does not exist\\n\") unless $proj;\n        }\n      }\n      checkpartition($remotemap, $pid, $proj) if $remotemap && $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$pid};\n      $done{\"/$prp\"} = 1;       # mark expanded\n      my @repo = grep {$_->{'name'} eq $tid} @{$proj->{'repository'} || []};\n      push @path, @{$repo[0]->{'path'}} if @repo && $repo[0]->{'path'};\n    } elsif ($remotemap) {\n      my $pid = $t->{'project'};\n      my $proj = readproj($pid, 1);\n      if ((!$proj || $proj->{'remoteurl'}) && !$remotemap->{$pid}) {\n        my $r = remoteprojid($pid);\n        $remotemap->{$pid} = {%$r, 'proto' => 1} if $r;\n      }\n      checkpartition($remotemap, $pid, $proj) if $remotemap && $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$pid};\n    }\n  }\n  return @ret;\n}\n\nsub concatconfigs {\n  my ($projid, $repoid, $remotemap, @path) = @_;\n\n  my $config = \"%define _project $projid\\n\";\n  my $macros = '';\n\n  #$macros .= \"%vendor Open Build Service\\n\";\n\n  # find the sign project, this is what we use as vendor\n  my $vprojid = $projid;\n  while ($vprojid ne '') {\n    last if -s \"$projectsdir/$vprojid.pkg/_signkey\";\n    $vprojid =~ s/[^:]*$//;\n    $vprojid =~ s/:$//;\n  }\n  $vprojid = $projid if $vprojid eq '';\n  my $obsname = $BSConfig::obsname || 'build.opensuse.org';\n  $macros .= \"%vendor obs://$obsname/$vprojid\\n\";\n\n  $macros .= \"%_project $projid\\n\";\n  my $lastr = '';\n\n  my $distinfo = \"$projid / $repoid\";\n  if ($repoid eq 'standard') {\n    $distinfo = $projid;\n  } \n\n  for my $prp (reverse @path) {\n    if ($prp eq \"$projid/$repoid\") {\n      $macros .= \"\\n%distribution $distinfo\\n\";\n      $macros .= \"%_project $projid\\n\";\n    }\n    my ($p, $r) = split('/', $prp, 2);\n    my $c;\n    if (-s \"$projectsdir/$p.conf\") {\n      $c = readstr(\"$projectsdir/$p.conf\");\n    } elsif (!-e \"$projectsdir/$p.xml\") {\n      my $proj = remoteprojid($p);\n      $c = fetchremoteconfig($proj, $p, $remotemap);\n    }\n    if ($remotemap && $remotemap->{':partitions'}) {\n      checkpartition($remotemap, $p) if !$remotemap->{':partitions'}->{$p};\n      $remotemap->{$p}->{'config'} = defined($c) ? $c : '' if ($remotemap->{$p} || {})->{'partition'};\n    }\n    next unless defined $c;\n    $config .= \"\\n### from $p\\n\";\n    $config .= \"%define _repository $r\\n\";\n\n    if ($c =~ /^\\s*:macros\\s*$/im) {\n      # probably some multiple macro sections with %if statements\n      # flush out macros\n      $macros .= \"\\n### from $p\\n\";\n      $macros .= \"\\n%_repository $r\\n\";\n      $config .= \"\\nMacros:\\n$macros:Macros\\n\\n\";\n      $macros = '';\n      $lastr = $r;\n      my $s1 = '\\A(.*^\\s*:macros\\s*$)(.*?)\\Z';\t# should always match\n      if ($c =~ /$s1/msi) {\n        $config .= $1;\n\t$c = $2;\n      } else {\n        $config .= $c;\n\t$c = '';\n      }\n    }\n    if ($c =~ /^(.*\\n)?\\s*macros:[^\\n]*\\n(.*)/si) {\n      # has single macro section at end. cumulate\n      $c = defined($1) ? $1 : '';\n      $macros .= \"\\n### from $p\\n\";\n      $macros .= \"%_repository $r\\n\";\n      $macros .= $2;\n      $lastr = $r;\n    }\n    $config .= $c;\n  }\n  if ($lastr ne $repoid) {\n    $macros .= \"\\n### from $projid\\n\";\n    $macros .= \"%_repository $repoid\\n\";\n  }\n  if (!@path || $path[0] ne \"$projid/$repoid\") {\n    $macros .= \"\\n%distribution $distinfo\\n\";\n    $macros .= \"%_project $projid\\n\";\n  }\n  if ($BSConfig::extramacros) {\n    for (sort keys %{$BSConfig::extramacros}) {\n      $macros .= $BSConfig::extramacros->{$_} if $projid =~ /$_/;\n    }\n  }\n  if ($BSConfig::extraconfig) {\n    my $extraconfig = '';\n    for (sort keys %{$BSConfig::extraconfig}) {\n      $extraconfig .= $BSConfig::extraconfig->{$_} if $projid =~ /$_/;\n    }\n    $config .= \"\\n$extraconfig\" if $extraconfig;\n  }\n  $config .= \"\\nMacros:\\n$macros\" if $macros ne '';\n  return $config;\n}\n\nsub getbuildconfig {\n  my ($cgi, $projid, $repoid) = @_;\n  my @path;\n  if ($cgi->{'path'}) {\n    @path = @{$cgi->{'path'}};\n  } else {\n    @path = expandsearchpath($projid, $repoid);\n  }\n  my $config = concatconfigs($projid, $repoid, undef, @path);\n  return ($config, 'Content-Type: text/plain');\n}\n\nsub getprojectconfig {\n  my ($cgi, $projid) = @_;\n  my $proj = checkprojrepoarch($projid, undef, undef, 1);\n  if ($proj->{'remoteurl'}) {\n    my $config = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_config\", 'proxy' => $proxy}, undef);\n    return ($config, 'Content-Type: text/plain');\n  }\n  my $config;\n  if ($cgi->{'rev'}) {\n    my $rev = getrev($projid, '_project', $cgi->{'rev'});\n    my $files = $rev ? lsrev($rev) : {};\n    $config = repreadstr($rev, '_config', $files->{'_config'}, 1) if $files->{'_config'};\n  } else {\n    $config = readstr(\"$projectsdir/$projid.conf\", 1);\n  }\n  $config = '' unless defined $config;\n  return ($config, 'Content-Type: text/plain');\n}\n\nsub putprojectconfig {\n  my ($cgi, $projid) = @_;\n  my $proj = readproj($projid);\n  mkdir_p($uploaddir);\n  my $uploadfile = \"$uploaddir/$$\";\n  die(\"upload failed\\n\") unless BSServer::read_file($uploadfile);\n  if (! -s $uploadfile) {\n    unlink($uploadfile);\n    $uploadfile = undef;\n  }\n  addrev_meta($cgi, $projid, undef, $uploadfile, \"$projectsdir/$projid.conf\", '_config', 'rev');\n  notify_repservers('project', $projid);\n  notify(\"SRCSRV_UPDATE_PROJECT_CONFIG\", { \"project\" => $projid, \"sender\" => ($cgi->{'user'} || \"unknown\") });\n  return $BSStdServer::return_ok;\n}\n\nsub delprojectconfig {\n  my ($cgi, $projid) = @_;\n  addrev_meta($cgi, $projid, undef, undef, \"$projectsdir/$projid.conf\", '_config', 'rev');\n  notify_repservers('project', $projid);\n  notify(\"SRCSRV_UPDATE_PROJECT_CONFIG\", { \"project\" => $projid, \"sender\" => ($cgi->{'user'} || \"unknown\") });\n  return $BSStdServer::return_ok;\n}\n\n##########################################################################\n\nsub getsources {\n  my ($cgi, $projid, $packid, $srcmd5) = @_;\n  my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $srcmd5};\n  my $files = lsrev($rev);\n  my @send = map {{'name' => $_, 'filename' => \"$srcrep/$packid/$files->{$_}-$_\"}} keys %$files;\n  BSServer::reply_cpio(\\@send);\n  return undef;\n}\n\nsub detach {\n  my $jev = $BSServerEvents::gev;\n  return unless exists $jev->{'fd'};\n  my $ev = BSEvents::new('never');\n  for (keys %$jev) {\n    $ev->{$_} = $jev->{$_} unless $_ eq 'id' || $_ eq 'handler' || $_ eq 'fd';\n  }\n  $jev->{'conf'}->{'stdreply'}->(@_) if $jev->{'conf'}->{'stdreply'};\n  $BSServerEvents::gev = $ev;\n  return $ev;\n}\n\nmy %getfilelist_ajax_inprogress;\n\nsub getfilelist_ajax {\n  my ($cgi, $projid, $packid) = @_;\n\n  if ($cgi->{'view'} eq 'cpio') {\n    my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cgi->{'rev'}};\n    my $files = lsrev($rev);\n    my @send = map {{'name' => $_, 'filename' => \"$srcrep/$packid/$files->{$_}-$_\"}} keys %$files;\n    BSWatcher::reply_cpio(\\@send);\n    return undef;\n  }\n  die(\"unknown view '$cgi->{'view'}'\\n\") unless $cgi->{'view'} eq 'notify';\n  my $jev = $BSServerEvents::gev;\n  if (!$jev->{'remoteurl'}) {\n    die unless $cgi->{'rev'};\n    my $proj = remoteprojid($projid);\n    die(\"missing project/package\\n\") unless $proj;\n    $jev->{'remoteurl'} = $proj->{'remoteurl'};\n    $jev->{'remoteproject'} = $proj->{'remoteproject'};\n  }\n  if (!$jev->{'filelist'}) {\n    my $rev = $cgi->{'rev'};\n    return $BSStdServer::return_ok if $getfilelist_ajax_inprogress{\"$projid/$packid/$rev\"};\n    my $param = {\n      'uri' => \"$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid\",\n      'proxy' => $proxy,\n    };\n    eval {\n      $jev->{'filelist'} = BSWatcher::rpc($param, $BSXML::dir, \"rev=$rev\");\n    };\n    if ($@) {\n      my $err = $@;\n      notify_all_repservers('package', $projid, $packid);\n      die($err);\n    }\n    return undef unless $jev->{'filelist'};\n    $jev = detach($BSStdServer::return_ok);\n    $jev->{'idstring'} = \"$projid/$packid/$rev\";\n    $getfilelist_ajax_inprogress{\"$projid/$packid/$rev\"} = $jev;\n    $jev->{'handler'} = sub {delete $getfilelist_ajax_inprogress{\"$projid/$packid/$rev\"}};\n  }\n  my $havesize = 0;\n  my $needsize = 0;\n  my @need;\n  for my $entry (@{$jev->{'filelist'}->{'entry'} || []}) {\n    if (-e \"$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}\") {\n      $havesize += $entry->{'size'};\n    } else {\n      push @need, $entry;\n      $needsize += $entry->{'size'};\n    }\n  }\n  my $serial;\n  if (@need) {\n    $serial = BSWatcher::serialize(\"$jev->{'remoteurl'}/source\");\n    return undef unless $serial;\n    mkdir_p($uploaddir);\n  }\n  if (@need > 1 && $havesize < 8192) {\n    # download full cpio source\n    my %need = map {$_->{'name'} => $_} @need;\n    my $tmpcpiofile = \"$$-$jev->{'id'}-tmpcpio\";\n    my $param = {\n      'uri' => \"$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid\",\n      'directory' => $uploaddir,\n      'tmpcpiofile' => \"$uploaddir/$tmpcpiofile\",\n      'withmd5' => 1,\n      'receiver' => \\&BSHTTP::cpio_receiver,\n      'proxy' => $proxy,\n      'map' => sub { $need{$_[1]} ? \"$tmpcpiofile.$_[1]\" : undef },\n      'cpiopostfile' => sub {\n\tmy $name = substr($_[1]->{'name'}, length(\"$tmpcpiofile.\"));\n\tdie(\"file download confused\\n\") unless $need{$name} && $_[1]->{'md5'} eq $need{$name}->{'md5'};\n        addfile($projid, $packid, \"$uploaddir/$_[1]->{'name'}\", $name, $_[1]->{'md5'});\n       },\n    };\n    my $res;\n    eval {\n      $res = BSWatcher::rpc($param, undef, \"rev=$cgi->{'rev'}\", 'view=cpio');\n    };\n    if ($@) {\n      # notify scheduler that the download failed\n      my $err = $@;\n      BSWatcher::serialize_end($serial) if $serial;\n      notify_all_repservers('package', $projid, $packid);\n      die($err);\n    }\n    return undef unless $res;\n  }\n  for my $entry (@need) {\n    next if -e \"$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}\";\n    my $param = {\n      'uri' => \"$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid/$entry->{'name'}\",\n      'filename' => \"$uploaddir/$$-$jev->{'id'}\",\n      'withmd5' => 1,\n      'receiver' => \\&BSHTTP::file_receiver,\n      'proxy' => $proxy,\n    };\n    my $res;\n    eval {\n      $res = BSWatcher::rpc($param, undef, \"rev=$cgi->{'rev'}\");\n    };\n    if ($@) {\n      # notify scheduler that the download failed\n      my $err = $@;\n      BSWatcher::serialize_end($serial) if $serial;\n      notify_all_repservers('package', $projid, $packid);\n      die($err);\n    }\n    return undef unless $res;\n    die(\"file download failed\\n\") unless $res && $res->{'md5'} eq $entry->{'md5'};\n    die unless -e \"$uploaddir/$$-$jev->{'id'}\";\n    addfile($projid, $packid, \"$uploaddir/$$-$jev->{'id'}\", $entry->{'name'}, $entry->{'md5'});\n  }\n  BSWatcher::serialize_end($serial) if $serial;\n  delete $getfilelist_ajax_inprogress{\"$projid/$packid/$cgi->{'rev'}\"};\n  notify_all_repservers('package', $projid, $packid);\n  return '';\n}\n\nsub getproductrepositories {\n  my ($xml) = @_;\n\n  my @res;\n  for my $product (@{$xml->{'products'}->{'product'}}) {\n    my @pr;\n    for my $repo (@{$product->{'register'}->{'updates'}->{'repository'}}) {\n      my @p = published_path(undef, $repo->{'project'}, $repo->{'name'});\n      my $path = { 'path' => $p[0]{'path'}, 'update' => undef };\n      $path->{'arch'} = $repo->{'arch'} if $repo->{'arch'};\n      $path->{'zypp'} = $repo->{'zypp'} if $repo->{'zypp'};\n      $path->{'debug'} = undef if $repo->{'name'} =~ m/_debug$/;\n      push @pr, $path;\n    }\n    for my $repo (@{$product->{'register'}->{'pool'}->{'repository'}}) {\n      die(\"getproductrepositories: path AND url is set!\\n\") if defined ($repo->{'project'}) && defined($repo->{'url'});\n      my $path;\n      if (defined($repo->{'url'})) {\n        $path = { 'url' => $repo->{'url'} };\n      } else {\n        my @p = published_path({\"medium\" => $repo->{'medium'}}, $repo->{'project'}, $repo->{'name'});\n        $path = { 'path' => $p[0]{'path'} };\n      }\n      $path->{'arch'} = $repo->{'arch'} if $repo->{'arch'};\n      $path->{'zypp'} = $repo->{'zypp'} if $repo->{'zypp'};\n      $path->{'debug'} = undef if $repo->{'medium'} =~ m/_debug$/;\n      push @pr, $path;\n    }\n    my $prod = { 'name' => $product->{'name'}, 'repository' => \\@pr };\n    $prod->{'distrotarget'} = $product->{'register'}->{'updates'}->{'distrotarget'} if $product->{'register'}->{'updates'}->{'distrotarget'};\n    push @res, $prod;\n  }\n  return @res;\n}\n\nsub getfilelist {\n  my ($cgi, $projid, $packid) = @_;\n\n  my $view = $cgi->{'view'};\n  my $rev;\n  if ($cgi->{'meta'}) {\n    $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});\n  } elsif ($cgi->{'deleted'}) {\n    $rev = getrev_deleted($projid, $packid, $cgi->{'rev'});\n  } else {\n    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  }\n  my $li = {};\n  my $files = lsrev($rev, $li);\n\n  # show state of current source service run, if defined\n  my $serviceinfo;\n  if ($li->{'xservicemd5'} || $li->{'lservicemd5'}) {\n    # new style\n    $serviceinfo = {};\n    $serviceinfo->{'lsrcmd5'} = $li->{'lservicemd5'} if $li->{'lservicemd5'};\n    if ($li->{'xservicemd5'}) {\n      if ($cgi->{'expand'}) {\n\t$serviceinfo->{'lsrcmd5'} = $rev->{'srcmd5'};\n\t$files = handleservice($rev, $files, $li->{'xservicemd5'});\n\t$serviceinfo->{'code'} = 'succeeded';\t# otherwise it already died...\n      } else {\n        eval { handleservice({ %$rev }, $files, $li->{'xservicemd5'}) };\n\tmy $error = $@;\n\tchomp $error if $error;\n\tif (!$error) {\n\t  $serviceinfo->{'code'} = 'succeeded';\n\t  $serviceinfo->{'xsrcmd5'} = $li->{'xservicemd5'};\n\t} elsif ($error eq 'service in progress') {\n\t  $serviceinfo->{'code'} = 'running';\n\t} else {\n\t  $serviceinfo->{'code'} = 'failed';\n\t  $serviceinfo->{'xsrcmd5'} = $li->{'xservicemd5'};\n\t  $serviceinfo->{'error'} = $error;\n\t}\n      }\n    }\n    delete $li->{'xservicemd5'};\n    delete $li->{'lservicemd5'};\n  } elsif ($files->{'_service'} && $packid ne '_project' && !$cgi->{'meta'} && !defined($cgi->{'rev'})) {\n    # check error/in progress\n    $serviceinfo = {};\n    my $lockfile = \"$eventdir/service/${projid}::$packid\";\n    if (-e $lockfile) {\n      $serviceinfo->{'code'} = 'running';\n    } elsif ($files->{'_service_error'}) {\n      $serviceinfo->{'code'} = 'failed';\n      $serviceinfo->{'error'} = repreadstr($rev, '_service_error', $files->{'_service_error'});\n    } else {\n      $serviceinfo->{'code'} = 'succeeded';\n    }\n  } elsif ($files->{'_service_error'}) {\n    $serviceinfo = {'code' => 'failed'};\n    $serviceinfo->{'error'} = repreadstr($rev, '_service_error', $files->{'_service_error'});\n  }\n\n  if ($files->{'_link'}) {\n    if ($cgi->{'emptylink'}) {\n      my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);\n      delete $l->{'patches'};\n      mkdir_p($uploaddir);\n      writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n      $files = {};\n      $files->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link');\n      $rev = addrev({}, $projid, $packid, $files, '');\n    }\n    my %lrev = %$rev;\n    $lrev{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n    $li->{'linked'} = [] if $cgi->{'withlinked'};\n    my $lfiles = handlelinks(\\%lrev, $files, $li);\n    if ($cgi->{'expand'}) {\n      if (!ref($lfiles)) {\n\tif ($cgi->{'withlinked'} && !$view) {\n\t  my $ret = {};\n\t  $ret->{'name'} = $packid;\n\t  $ret->{'error'} = $lfiles || 'internal error';\n\t  $ret->{'linkinfo'} = $li;\n\t  return ($ret, $BSXML::dir);\n\t}\n\tdie(\"$lfiles\\n\");\n      }\n      $files = $lfiles;\n      %$rev = %lrev;\n      $rev->{'rev'} = $rev->{'srcmd5'};\n    } else {\n      if (ref $lfiles) {\n        $li->{'xsrcmd5'} = $lrev{'srcmd5'};\n      } else {\n\t# link is broken\n\t$li->{'error'} = $lfiles;\n\t# set xsrcmd5 if we have a link error file\n\t$li->{'xsrcmd5'} = $lrev{'srcmd5'} if $lrev{'srcmd5'} && -e \"$srcrep/$packid/$lrev{'srcmd5'}-_linkerror\";\n\tif ($cgi->{'lastworking'}) {\n\t  my $lastworking = findlastworkinglink($rev);\n\t  $li->{'lastworking'} = $lastworking if $lastworking;\n\t}\n      }\n    }\n  }\n\n  if ($cgi->{'extension'}) {\n    for (keys %$files) {\n      delete $files->{$_} unless /\\.\\Q$cgi->{'extension'}\\E$/;\n    }\n  }\n\n  if ($view && $view eq 'cpio') {\n    if (!$cgi->{'extension'} && $rev->{'srcmd5'} && $rev->{'srcmd5'} ne 'upload' && $rev->{'srcmd5'} ne 'pattern' && $rev->{'srcmd5'} ne 'empty' && $rev->{'srcmd5'} ne $emptysrcmd5) {\n      # hack: we identify remote source downloads by looking at the user agent\n      my $useragent = $BSServer::request->{'headers'}->{'user-agent'} || '';\n      if ($useragent =~ /BSRPC/) {\n\tBSHandoff::handoff($ajaxsocket, \"/source/$projid/$packid\", undef, \"rev=$rev->{'srcmd5'}\", 'view=cpio');\n\texit(0);\n      }\n    }\n    my @files = map {{'name' => $_, 'filename' => \"$srcrep/$packid/$files->{$_}-$_\"}} sort keys %$files;\n    # sigh\n    $files->[0]->{'filename'} = repfilename($rev, '_serviceerror', $files->{'_serviceerror'}) if @files == 1 && $files->{'_serviceerror'};\n    BSServer::reply_cpio(\\@files);\n    return undef;\n  }\n\n  if ($view && ($view eq 'products' || $view eq 'productrepositories') ) {\n    my @res;\n    for my $filename (sort keys %$files) {\n      next unless $filename =~ /\\.product$/;\n      next if $cgi->{'product'} && $filename ne \"$cgi->{'product'}.product\";\n      my $xml = BSProductXML::readproductxml(\"$srcrep/$rev->{'package'}/$files->{$filename}-$filename\", 0, undef, $files);\n      die(\"400 Unable to parse $filename\\n\") unless $xml;\n      if ($view eq 'productrepositories') {\n        push @res, getproductrepositories($xml);\n      } else {\n        push @res, $xml;\n      }\n    }\n    if ($view eq 'productrepositories') {\n      return ({\"product\" => \\@res}, $BSProductXML::productlistrepositories);\n    }\n    my $ret = {};\n    $ret->{'productdefinition'} = \\@res;\n    return ($ret, $BSProductXML::products);\n  }\n\n  my $ret = {};\n  $ret->{'name'} = $packid;\n  $ret->{'srcmd5'} = $rev->{'srcmd5'} if $rev->{'srcmd5'} ne 'empty';\n  $ret->{'rev'} = $rev->{'rev'} if exists $rev->{'rev'};\n  $ret->{'vrev'} = $rev->{'vrev'} if exists $rev->{'vrev'};\n  $ret->{'serviceinfo'} = $serviceinfo if $serviceinfo;\n  my @res;\n  for my $filename (sort keys %$files) {\n    my @s = repstat($rev, $filename, $files->{$filename});\n    if (@s) {\n      push @res, {'name' => $filename, 'md5' => $files->{$filename}, 'size' => $s[7], 'mtime' => $s[9]};\n    } else {\n      push @res, {'name' => $filename, 'md5' => $files->{$filename}, 'error' => \"$!\"};\n    }\n  }\n  if (%$li) {\n    linkinfo_addtarget($rev, $li);\n    $ret->{'linkinfo'} = $li;\n  }\n  $ret->{'entry'} = \\@res;\n  return ($ret, $BSXML::dir);\n}\n\nsub getfile {\n  my ($cgi, $projid, $packid, $filename) = @_;\n  die(\"no filename\\n\") unless defined($filename) && $filename ne '';\n  die(\"bad filename\\n\") if $filename =~ /\\// || $filename =~ /^\\./;\n  my $rev;\n  if ($cgi->{'meta'}) {\n    $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});\n  } elsif ($cgi->{'deleted'}) {\n    $rev = getrev_deleted($projid, $packid, $cgi->{'rev'});\n  } else {\n    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  }\n  my $files;\n  if ($cgi->{'expand'}) {\n    $files = lsrev_expanded($rev);\n  } else {\n    $files = lsrev($rev);\n  }\n  die(\"404 $filename: no such file\\n\") unless $files->{$filename};\n  my @s = repstat($rev, $filename, $files->{$filename});\n  die(\"$projid/$packid/$files->{$filename}-$filename: $!\\n\") unless @s;\n  if (!$BSStdServer::isajax && $rev->{'srcmd5'} && $rev->{'srcmd5'} ne 'upload' && $rev->{'srcmd5'} ne 'pattern' && $rev->{'srcmd5'} ne 'empty' && $rev->{'srcmd5'} ne $emptysrcmd5) {\n    # hack: we identify remote source downloads by looking at the user agent\n    my $useragent = $BSServer::request->{'headers'}->{'user-agent'} || '';\n    if ($useragent =~ /BSRPC/) {\n      BSHandoff::handoff($ajaxsocket, \"/source/$projid/$packid/$filename\", undef, \"rev=$rev->{'srcmd5'}\");\n      exit(0);\n    }\n  }\n  my $fd = gensym;\n  repopen($rev, $filename, $files->{$filename}, $fd) || die(\"$projid/$packid/$files->{$filename}-$filename: $!\\n\");\n  BSWatcher::reply_file($fd);\n  return undef;\n}\n\nsub putfile {\n  my ($cgi, $projid, $packid, $filename) = @_;\n  die(\"no filename\\n\") unless defined($filename) && $filename ne '';\n  die(\"bad filename\\n\") if $filename =~ /\\// || $filename =~ /^\\./;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\", 'withmd5' => 1);\n  die(\"upload failed\\n\") unless $uploaded;\n\n  if ($cgi->{'meta'}) {\n    if ($filename eq '_attribute') {\n      my $attribs = readxml(\"$uploaddir/$$\", $BSXML::attributes);\n      BSVerify::verify_attributes($attribs);\n      writexml(\"$uploaddir/$$\", undef, $attribs, $BSXML::attributes);\n    } elsif ($filename eq '_frozenlinks') {\n      my $frozenx = readxml(\"$uploaddir/$$\", $BSXML::frozenlinks);\n      BSVerify::verify_frozenlinks($frozenx);\n      writexml(\"$uploaddir/$$\", undef, $frozenx, $BSXML::frozenlinks);\n    } else {\n      die(\"unsupported meta operation\\n\");\n    }\n    my $rev = addrev_meta($cgi, $projid, $packid, \"$uploaddir/$$\", undef, $filename);\n    notify_repservers('package', $projid) if $cgi->{'meta'} && $filename eq '_frozenlinks';\n    delete $rev->{'project'};\n    delete $rev->{'package'};\n    return ($rev, $BSXML::revision);\n  }\n\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  die(\"file '$filename' is read-only\\n\") if ($filename =~ /^_service:/) && !$cgi->{'force'};\n  addfile($projid, $packid, \"$uploaddir/$$\", $filename, $uploaded->{'md5'});\n  # create new meta file\n  my $files;\n  if ($cgi->{'keeplink'}) {\n    $files = lsrev_expanded($rev);\n  } else {\n    $files = lsrev($rev);\n  }\n  $files->{$filename} = $uploaded->{'md5'};\n  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};\n  $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});\n  runservice($cgi, $rev, $files);\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub getsourcediffcache {\n  my ($cgi, $cacheid) = @_;\n\n  my $view = $cgi->{'view'} || '';\n  my $cn = \"$diffcache/\".substr($cacheid, 0, 2).\"/$cacheid\";\n  BSWatcher::addfilewatcher($cn) if $BSStdServer::isajax;\n  my $lockc = BSUtil::lockcheck('>>', \"$cn.run\");\n  my $fd = gensym;\n  if (open($fd, '<', $cn)) {\n    unlink(\"$cn.run\");\n    utime(time, time, $cn);\n    BSWatcher::reply_file($fd, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');\n    return undef;\n  }\n  return undef if $BSStdServer::isajax && !$lockc;\n  die(\"cache entry '$cacheid' does not exist\\n\");\n}\n\nsub sourcediff {\n  my ($cgi, $projid, $packid) = @_;\n\n  BSVerify::verify_linkrev($cgi->{'olinkrev'}) if defined($cgi->{'olinkrev'}) && $cgi->{'olinkrev'} ne 'linkrev';\n  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;\n  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;\n\n  my $fmax = 200;\n  my $tmax = 16000;\n  $fmax = $cgi->{'filelimit'} if defined $cgi->{'filelimit'};\n  $tmax = $cgi->{'tarlimit'} if defined $cgi->{'tarlimit'};\n  undef $fmax unless $fmax;\n  undef $tmax unless $tmax;\n\n  my $have0rev = (defined($cgi->{'rev'}) && $cgi->{'rev'} eq '0') || (defined($cgi->{'orev'}) && $cgi->{'orev'} eq '0');\n  my $rev;\n  if ($cgi->{'meta'}) {\n    $rev = getrev_meta($projid, $packid, $cgi->{'rev'});\n  } else {\n    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload', undef, $cgi->{'missingok'});\n  }\n  my $linkinfo = {};\n  my $files = lsrev($rev, $linkinfo);\n  $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'}) if $cgi->{'expand'} && $linkinfo->{'xservicemd5'};\n  my $orev = $cgi->{'orev'};\n  if (!defined($cgi->{'oproject'}) && !defined($cgi->{'opackage'}) && !defined($cgi->{'orev'}) && $rev->{'rev'}) {\n    die(\"revision is not a simple commit\\n\") unless $rev->{'rev'} =~ /^\\d+$/s;\n    $orev = $rev->{'rev'} - 1;\n    $have0rev = 1 if $orev == 0;\n    $cgi->{'olinkrev'} = 'linkrev' if !defined($cgi->{'olinkrev'});\n  }\n  if ($cgi->{'meta'}) {\n    $orev = getrev_meta($oprojid, $opackid, $orev);\n  } else {\n    $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest', undef, $cgi->{'missingok'});\n  }\n  my $olinkinfo = {};\n  my $ofiles = lsrev($orev, $olinkinfo);\n  $ofiles = handleservice($orev, $ofiles, $olinkinfo->{'xservicemd5'}) if $cgi->{'expand'} && $olinkinfo->{'xservicemd5'};\n  if ($cgi->{'expand'} || (!$have0rev && $files->{'_link'} && !$ofiles->{'_link'}) || (!$have0rev && $ofiles->{'_link'} && !$files->{'_link'})) {\n    # expand links\n    if ($files->{'_link'}) {\n      $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n      my %li;\n      my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);\n      if ($l) {\n        $l->{'project'} = $rev->{'project'} unless defined $l->{'project'};\n        $l->{'package'} = $rev->{'package'} unless defined $l->{'package'};\n      }\n      $files = handlelinks($rev, $files, \\%li);\n      die(\"bad link: $files\\n\") unless ref $files;\n\n      # some nasty magic to improve diff usability\n      if ($l && $cgi->{'linkrev'} && $l->{'project'} eq $oprojid && $l->{'package'} eq $opackid && !$l->{'rev'} && !$cgi->{'orev'}) {\n        # we're diffing against the link target. As the user specified a baserev, we should use it\n        # instead of the latest source\n        $orev = getrev($oprojid, $opackid, $li{'srcmd5'});\n        $ofiles = lsrev($orev);\n      }\n      # olinkrev=linkrev: reuse same linkrev if the link target matches\n      if ($cgi->{'olinkrev'} && $cgi->{'olinkrev'} eq 'linkrev' && $ofiles->{'_link'}) {\n\tmy $ol = repreadxml($orev, '_link', $ofiles->{'_link'}, $BSXML::link, 1);\n\tif ($ol) {\n\t  $ol->{'project'} = $orev->{'project'} unless defined $ol->{'project'};\n\t  $ol->{'package'} = $orev->{'package'} unless defined $ol->{'package'};\n\t}\n\t$cgi->{'olinkrev'} = $li{'srcmd5'} if $l && $ol && $l->{'project'} eq $ol->{'project'} && $l->{'package'} eq $ol->{'package'};\n      }\n    }\n    if ($ofiles->{'_link'}) {\n      $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'} && $cgi->{'olinkrev'} ne 'linkrev';\n      $ofiles = handlelinks($orev, $ofiles);\n      die(\"bad link: $ofiles\\n\") unless ref $ofiles;\n    }\n  }\n  my $view = $cgi->{'view'} || '';\n  $view = 'unified' if $cgi->{'unified'};\n  die(\"unsupported view '$view'\\n\") if $view && ($view ne 'xml' && $view ne 'unified');\n  my $cacheid = \"//cacheversion:2/\";\n  $cacheid .= \"$orev->{'srcmd5'}/$rev->{'srcmd5'}\";\n  $cacheid .= \"/unified:1\" if $view && $view eq 'unified';\n  $cacheid .= \"/view:$cgi->{'view'}\" if $view && $view ne 'unified';\n  $cacheid .= \"/fmax:$fmax\" if defined $fmax;\n  $cacheid .= \"/tmax:$tmax\" if defined $tmax;\n  $cgi->{'withissues'} = 1 if $cgi->{'onlyissues'};\n  if ($cgi->{'withissues'}) {\n    my @s = stat(\"$BSConfig::bsdir/issuetrackers.xml\");\n    $cacheid .= \"/withissues:$s[9]/$s[7]/$s[1]\" if @s;\n    $cacheid .= \"/onlyissues\" if $cgi->{'onlyissues'};\n  }\n  if ($cgi->{'file'}) {\n    my %file = map {$_ => 1} @{$cgi->{'file'}};\n    $cacheid .= \"/file:$_\" for sort keys %file;\n    for (keys %$ofiles) {\n      delete $ofiles->{$_} unless $file{$_};\n    }\n    for (keys %$files) {\n      delete $files->{$_} unless $file{$_};\n    }\n  }\n  $cacheid = Digest::MD5::md5_hex($cacheid);\n  my $xmlret;\n  if ($view eq 'xml') {\n    $xmlret = {};\n    $xmlret->{'key'} = $cacheid;\n    $rev->{'rev'} ||= 0;\n    $rev->{'srcmd5'} = $emptysrcmd5 if $rev->{'srcmd5'} eq 'empty';\n    $orev->{'rev'} ||= 0;\n    $orev->{'srcmd5'} = $emptysrcmd5 if $rev->{'srcmd5'} eq 'empty';\n    $xmlret->{'old'} = { 'project' => $orev->{'project'}, 'package' => $orev->{'package'}, 'rev' => $orev->{'rev'}, 'srcmd5' => $orev->{'srcmd5'} };\n    $xmlret->{'new'} = { 'project' => $rev->{'project'}, 'package' => $rev->{'package'}, 'rev' => $rev->{'rev'}, 'srcmd5' => $rev->{'srcmd5'} };\n    $xmlret->{'files'} = {};\n  }\n  if (!grep {($ofiles->{$_} || '') ne ($files->{$_} || '')} (keys %$ofiles, keys %$files)) {\n    # all files identical, don't bother\n    return ($xmlret, $BSXML::sourcediff) if $view eq 'xml';\n    return ('', 'Content-Type: text/plain');\n  }\n  local *F;\n  my $cn = \"$diffcache/\".substr($cacheid, 0, 2).\"/$cacheid\";\n  if (open(F, '<', $cn)) {\n    utime(time, time, $cn);\n    BSServer::reply_file(\\*F, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');\n    return undef;\n  }\n  local *LF;\n  mkdir_p(\"$diffcache/\".substr($cacheid, 0, 2));\n  if (!BSUtil::lockcheck('>>', \"$cn.run\")) {\n    my @args;\n    push @args, \"view=$view\" if $view;\n    BSHandoff::handoff($ajaxsocket, \"/sourcediffcache/$cacheid\", undef, @args);\n    exit(0);\n  }\n  BSUtil::lockopen(\\*LF, '>>', \"$cn.run\");\n  # retry open, maybe somebody else has created the diff meanwhile\n  if (open(F, '<', $cn)) {\n    unlink(\"$cn.run\");\n    close LF;\n    utime(time, time, $cn);\n    BSServer::reply_file(\\*F, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');\n    return undef;\n  }\n  my $tmpdir = \"$uploaddir/srcdiff$$\";\n  my $d;\n  if ($view eq 'xml') {\n    my %opts = ('edir' => $tmpdir, 'similar' => 1, 'doarchive' => 1, 'fmax' => $fmax, 'tmax' => $tmax);\n    if (!$cgi->{'onlyissues'}) {\n      $xmlret->{'files'} = { 'file' => BSSrcdiff::datadiff(\"$srcrep/$opackid\", $ofiles, $orev->{'rev'}, \"$srcrep/$packid\", $files, $rev->{'rev'}, %opts) };\n    }\n    if ($cgi->{'withissues'}) {\n      my $trackers = readxml(\"$BSConfig::bsdir/issuetrackers.xml\", $BSXML::issue_trackers, 1) || {};\n      $trackers = $trackers->{'issue-tracker'} || [];\n      $xmlret->{'issues'} = { 'issue' => BSSrcdiff::issuediff(\"$srcrep/$opackid\", $ofiles, $orev->{'rev'}, \"$srcrep/$packid\", $files, $rev->{'rev'}, $trackers, %opts) };\n    }\n    BSUtil::data2utf8xml($xmlret);\n    $d = XMLout($BSXML::sourcediff, $xmlret);\n  } else {\n    $d = BSSrcdiff::diff(\"$srcrep/$opackid\", $ofiles, $orev->{'rev'}, \"$srcrep/$packid\", $files, $rev->{'rev'}, $fmax, $tmax, $tmpdir, $view eq 'unified' ? 1 : 0);\n  }\n  mkdir_p(\"$diffcache/\".substr($cacheid, 0, 2));\n  writestr(\"$diffcache/.new$$\", $cn, $d);\n  unlink(\"$cn.run\");\n  close LF;\n  return ($d, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');\n}\n\nsub linkdiff {\n  my ($cgi, $projid, $packid) = @_;\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n  my $linkinfo = {};\n  my $files = lsrev_expanded($rev, $linkinfo);\n  die(\"not a link\\n\") unless $linkinfo->{'srcmd5'};\n  linkinfo_addtarget($rev, $linkinfo);\n  return sourcediff({\n    %$cgi, 'expand' => 0,\n    'oproject' => $linkinfo->{'project'},\n    'opackage' => $linkinfo->{'package'},\n    'orev' => $linkinfo->{'srcmd5'},\n    'missingok' => $linkinfo->{'missingok'},\n    'rev' => $rev->{'srcmd5'},\n  }, $projid, $packid);\n}\n\nsub servicediff {\n  my ($cgi, $projid, $packid) = @_;\n  die(\"servicediff only works for new style services\\n\") if $BSConfig::old_style_services;\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  my $linkinfo = {};\n  my $files = lsrev($rev, $linkinfo);\n  if ($linkinfo->{'xservicemd5'}) {\n    return sourcediff({%$cgi, 'expand' => 0, 'orev' => $rev->{'srcmd5'}, 'rev' => $linkinfo->{'xservicemd5'}}, $projid, $packid);\n  } elsif ($linkinfo->{'lservicemd5'}) {\n    return sourcediff({%$cgi, 'expand' => 0, 'orev' => $linkinfo->{'lservicemd5'}, 'rev' => $rev->{'srcmd5'}}, $projid, $packid);\n  } else {\n    die(\"no service was run for this revision\\n\");\n  }\n}\n\nsub isascii {\n  my ($file) = @_;\n  local *F;\n  open(F, '<', $file) || die(\"$file: $!\\n\");\n  my $buf = '';\n  sysread(F, $buf, 4096);\n  close F;\n  return 1 unless $buf =~ /[\\000-\\010\\016-\\037]/s;\n  return 0;\n}\n\nsub rundiff {\n  my ($file1, $file2, $label, $outfile) = @_;\n  my $pid;\n  if (!($pid = xfork())) {\n    if (!open(STDOUT, '>>', $outfile)) {\n      print STDERR \"$outfile: $!\\n\";\n      exit(2);\n    }\n    exec('diff', '-up', '--label', \"$label.orig\", '--label', $label, $file1, $file2);\n    exit(2);\n  }\n  waitpid($pid, 0) == $pid || die(\"waitpid $pid: $!\\n\");\n  my $status = $?;\n  return 1 if $status == 0 || $status == 0x100;\n  return undef;\n}\n\nsub findprojectpatchname {\n  my ($files) = @_;\n\n  my $i = \"\";\n  while ($files->{\"project$i.diff\"}) {\n    $i = '0' unless $i;\n    $i++;\n  }\n  return \"project$i.diff\";\n}\n\n#\n# we are going to commit files to projid/packid, all data is already present\n# in the src repository.\n# if it was a link before, try to keep this link\n# files: expanded file set\n#\nsub keeplink {\n  my ($cgi, $projid, $packid, $files, $orev) = @_;\n\n  my $repair = $cgi->{'repairlink'};\n  return $files if !defined($files) || !%$files;\n  return $files if $files->{'_link'};\n  $orev ||= getrev($projid, $packid, 'latest');\n  my $ofilesl = lsrev($orev);\n  return $files unless $ofilesl && $ofilesl->{'_link'};\n  my $l = repreadxml($orev, '_link', $ofilesl->{'_link'}, $BSXML::link);\n  my $changedlink = 0;\n  my %lignore;\n  my $isbranch;\n\n  if (@{$l->{'patches'}->{''} || []} == 1) {\n    my $type = (keys %{$l->{'patches'}->{''}->[0]})[0];\n    if ($type eq 'branch') {\n      $isbranch = 1;\n    }\n  }\n  undef $isbranch if $cgi->{'convertbranchtopatch'};\n\n  if (!$isbranch && $l->{'patches'}) {\n    if ($repair) {\n      for (@{$l->{'patches'}->{''} || []}) {\n        my $type = (keys %$_)[0];\n        if ($type eq 'apply' || $type eq 'delete' || $changedlink) {\n          $lignore{$_->{$type}->{'name'}} = 1 if $type ne 'topadd' && $type ne 'delete';\n\t  $_ = undef;\n\t  $changedlink = 1;\n\t}\n      }\n    } else {\n      for (reverse @{$l->{'patches'}->{''} || []}) {\n        my $type = (keys %$_)[0];\n        if ($type eq 'apply' || $type eq 'delete' || $type eq 'branch') {\n          $lignore{$_->{$type}->{'name'}} = 1 if $type eq 'apply';\n\t  $_ = undef;\n\t  $changedlink = 1;\n\t  next;\n\t}\n\tlast;\n      }\n    }\n    $l->{'patches'}->{''} = [ grep {defined($_)} @{$l->{'patches'}->{''}} ];\n  }\n\n  my $linkrev = $cgi->{'linkrev'};\n  $linkrev = $l->{'baserev'} if $linkrev && $linkrev eq 'base';\n\n  my $ltgtsrcmd5;\n  my $ofiles;\n  my $ofilesdir;\n  if (!$repair) {\n    # expand old link\n    my %olrev = %$orev;\n    my %li;\n    $olrev{'linkrev'} = $linkrev if $linkrev;\n    $ofiles = handlelinks(\\%olrev, $ofilesl, \\%li);\n    die(\"bad link: $ofiles\\n\") unless ref $ofiles;\n    $ltgtsrcmd5 = $li{'srcmd5'};\n    $ofilesdir = \"$srcrep/$packid\";\n  }\n\n  # get link target file list\n  my $ltgtprojid = defined($l->{'project'}) ? $l->{'project'} : $projid;\n  my $ltgtpackid = defined($l->{'package'}) ? $l->{'package'} : $packid;\n  my $ltgtfiles;\n  if ($ltgtsrcmd5) {\n    my $ltgtrev = {'project' => $ltgtprojid, 'package' => $ltgtpackid, 'srcmd5' => $ltgtsrcmd5};\n    $ltgtfiles = lsrev($ltgtrev);\n  } else {\n    my $ltgtrev = getrev($ltgtprojid, $ltgtpackid, $linkrev || $l->{'rev'});\n    $ltgtfiles = lsrev_expanded($ltgtrev);\n    $ltgtsrcmd5 = $ltgtrev->{'srcmd5'};\n  }\n\n  if ($l->{'missingok'} && $ltgtfiles->{'srcmd5'} ne $emptysrcmd5) {\n    # delete missingok flag as it's no longer needed\n    eval {\n      checksourceaccess($ltgtprojid, $ltgtpackid);\n      delete $l->{'missingok'};\n    };\n  }\n  # easy for branches: just copy file list and update baserev\n  if ($isbranch) {\n    my $nfiles = { %$files };\n    $nfiles->{'_link'} = $ofilesl->{'_link'};\n    my $lchanged;\n    my $baserev = $linkrev || $ltgtsrcmd5;\n    if (($l->{'baserev'} || '') ne $baserev) {\n      $l->{'baserev'} = $baserev;\n      $lchanged = 1;\n    }\n    $cgi->{'setrev'} = $baserev if $cgi->{'setrev'} && $cgi->{'setrev'} eq 'base';\n    if ($cgi->{'setrev'} && ($l->{'rev'} || '') ne $cgi->{'setrev'}) {\n      $l->{'rev'} = $cgi->{'setrev'};\n      $lchanged = 1;\n    }\n    if ($lchanged) {\n      $l->{'patches'}->{''} = [ { 'branch' => undef} ]; # work around xml problem\n      mkdir_p($uploaddir);\n      writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n      $nfiles->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link')\n    }\n    return $nfiles;\n  }\n\n  if ($cgi->{'convertbranchtopatch'}) {\n    $ofilesl = {};\n    $ofiles = $ltgtfiles;\n    $ofilesdir = \"$srcrep/$ltgtpackid\";\n  } elsif ($repair || $changedlink) {\n    # apply changed link\n    my $frominfo = {'project' => $ltgtprojid, 'package' => $ltgtpackid, 'srcmd5' => $ltgtsrcmd5};\n    my $linkinfo = {'project' => $projid, 'package' => $packid, 'srcmd5' => $orev->{'srcmd5'}, 'link' => $l};\n    $linkinfo->{'ignore'} = \\%lignore;\n    $ofiles = applylink(undef, $frominfo, $linkinfo);\n    die(\"bad link: $ofiles\\n\") unless ref $ofiles;\n    $ofilesdir = \"$uploaddir/applylink$$\";\n  }\n\n  #print \"-- ofilesl:\\n\";\n  #print \"  $ofilesl->{$_}  $_\\n\" for sort keys %$ofilesl;\n  #print \"-- ofiles:\\n\";\n  #print \"  $ofiles->{$_}  $_\\n\" for sort keys %$ofiles;\n  #print \"-- files:\\n\";\n  #print \"  $files->{$_}  $_\\n\" for sort keys %$files;\n\n  # now create diff between old $ofiles and $files\n  my $nfiles = { %$ofilesl };\n  delete $nfiles->{$_} for keys %lignore;\t# no longer used in link\n  mkdir_p($uploaddir);\n  unlink(\"$uploaddir/$$\");\n  my @dfiles;\n  for my $file (sort keys %{{%$files, %$ofiles}}) {\n    if ($ofiles->{$file}) {\n      if (!$files->{$file}) {\n\tif (!$ltgtfiles->{$file} && $ofilesl->{$file} && $ofilesl->{$file} eq ($ofiles->{$file} || '')) {\n\t  # local file no longer needed\n\t  delete $nfiles->{$file};\n\t}\n\tpush @dfiles, $file;\n\tdelete $nfiles->{$file};\n\tnext;\n      }\n      if ($ofiles->{$file} eq $files->{$file}) {\n\tnext;\n      }\n      if (!isascii(\"$srcrep/$packid/$files->{$file}-$file\") || !isascii(\"$ofilesdir/$ofiles->{$file}-$file\")) {\n\t$nfiles->{$file} = $files->{$file};\n\tnext;\n      }\n    } else {\n      if (!isascii(\"$srcrep/$packid/$files->{$file}-$file\")) {\n\t$nfiles->{$file} = $files->{$file};\n\tnext;\n      }\n    }\n    if (($ofilesl->{$file} || '') eq ($ofiles->{$file} || '')) {\n      # link did not change file, just record new content\n      if ($files->{$file} eq ($ltgtfiles->{$file} || '')) {\n\t# local overwrite already in link target\n\tdelete $nfiles->{$file};\n\tnext;\n      }\n      $nfiles->{$file} = $files->{$file};\n      next;\n    }\n    # both are ascii, create diff\n    mkdir_p($uploaddir);\n    if (!rundiff($ofiles->{$file} ? \"$ofilesdir/$ofiles->{$file}-$file\" : '/dev/null', \"$srcrep/$packid/$files->{$file}-$file\", $file, \"$uploaddir/$$\")) {\n      $nfiles->{$file} = $files->{$file};\n    }\n  }\n  my $lchanged;\n  $lchanged = 1 if $changedlink;\n  for (@dfiles) {\n    push @{$l->{'patches'}->{''}}, {'delete' => {'name' => $_}};\n    $lchanged = 1;\n  }\n  if (-s \"$uploaddir/$$\") {\n    my $ppatch = findprojectpatchname($nfiles);\n    $nfiles->{$ppatch} = addfile($projid, $packid, \"$uploaddir/$$\", $ppatch);\n    push @{$l->{'patches'}->{''}}, {'apply' => {'name' => $ppatch}};\n    $lchanged = 1;\n  } else {\n    unlink(\"$uploaddir/$$\");\n  }\n  my $baserev = $linkrev || $ltgtsrcmd5;\n  if (($l->{'baserev'} || '') ne $baserev) {\n    $l->{'baserev'} = $baserev;\n    $lchanged = 1;\n  }\n  $cgi->{'setrev'} = $baserev if $cgi->{'setrev'} && $cgi->{'setrev'} eq 'base';\n  if ($cgi->{'setrev'} && ($l->{'rev'} || '') ne $cgi->{'setrev'}) {\n    $l->{'rev'} = $cgi->{'setrev'};\n    $lchanged = 1;\n  }\n  if ($lchanged) {\n    writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n    $nfiles->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link')\n  }\n  if ($ofilesdir eq \"$uploaddir/applylink$$\") {\n    BSUtil::cleandir(\"$uploaddir/applylink$$\");\n    rmdir(\"$uploaddir/applylink$$\");\n  }\n  return $nfiles;\n}\n\n# integrate link from opackid to packid into packid\nsub integratelink {\n  my ($files, $projid, $packid, $rev, $ofiles, $oprojid, $opackid, $l, $orev) = @_;\n\n  # append patches from link l to link nl\n  my $nl = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);\n\n  # FIXME: remove hunks from patches that deal with replaced/deleted files\n  my $nlchanged;\n  my %dontcopy;\n  $dontcopy{'_link'} = 1;\n  my $nlisbranch;\n  if ($nl->{'patches'}) {\n    for (@{$nl->{'patches'}->{''} || []}) {\n      my $type = (keys %$_)[0];\n      if ($type eq 'add' || $type eq 'apply') {\n\t$dontcopy{$_->{$type}->{'name'}} = 1;\n      }\n      $nlisbranch = 1 if $type eq 'branch';\n    }\n  }\n  my $lisbranch;\n  if ($l->{'patches'}) {\n    for (@{$l->{'patches'}->{''} || []}) {\n      my $type = (keys %$_)[0];\n      $lisbranch = 1 if $type eq 'branch';\n    }\n  }\n\n  if ($nlisbranch) {\n    # we linked/branched a branch. expand.\n    #my %xrev = (%$rev, 'linkrev' => 'base');\n    my %xrev = %$rev;\n    my $linkinfo = {};\n    lsrev_expanded(\\%xrev, $linkinfo);\n    my %oxrev = (%$orev, 'linkrev' => $xrev{'srcmd5'});\n    $ofiles = lsrev_expanded(\\%oxrev);\n    copyfiles($projid, $packid, $oprojid, $opackid, $ofiles);\n    # find new base\n    if ($linkinfo->{'srcmd5'} ne $nl->{'baserev'}) {\n      # update base rev\n      $nl->{'baserev'} = $linkinfo->{'srcmd5'};\n      $nlchanged = 1;\n    }\n    # delete everything but the link\n    delete $files->{$_} for grep {$_ ne '_link'} keys %$files;\n  }\n\n  if ($lisbranch && !$nlisbranch) {\n    # we branched a link. convert branch to link\n    # and integrate\n    delete $ofiles->{'_link'};\n    $ofiles = keeplink({'convertbranchtopatch' => 1, 'linkrev' => 'base'}, $oprojid, $opackid, $ofiles, $orev);\n    $l = repreadxml($orev, '_link', $ofiles->{'_link'}, $BSXML::link);\n  }\n\n  if (!$nlisbranch && $l->{'patches'}) {\n    for (@{$l->{'patches'}->{''} || []}) {\n      my $type = (keys %$_)[0];\n      if ($type eq 'delete' && $files->{$_->{'delete'}->{'name'}} && !$dontcopy{$_->{'delete'}->{'name'}}) {\n\tdelete $files->{$_->{'delete'}->{'name'}};\n      } else {\n\t$nlchanged = 1;\n\t$nl->{'patches'} ||= {};\n\tif ($type eq 'apply') {\n\t  my $oppatch = $_->{'apply'}->{'name'};\n\t  if ($files->{$oppatch}) {\n\t    $dontcopy{$oppatch} = 1;\n\t    # argh, patch file already exists, rename...\n\t    my $ppatch = findprojectpatchname($files);\n\t    mkdir_p($uploaddir);\n\t    unlink(\"$uploaddir/$$\");\n\t    link(\"$srcrep/$opackid/$ofiles->{$oppatch}-$oppatch\", \"$uploaddir/$$\") || die(\"link $srcrep/$opackid/$ofiles->{$oppatch}-$oppatch $uploaddir/$$: $!\\n\");\n            $files->{$ppatch} = addfile($projid, $packid, \"$uploaddir/$$\", $ppatch);\n\t    push @{$nl->{'patches'}->{''}}, {'apply' => {'name' => $ppatch}};\n\t    next;\n\t  }\n\t}\n\tif ($type eq 'add') {\n\t  my $oppatch = $_->{'add'}->{'name'};\n\t  die(\"cannot apply patch $oppatch twice\\n\") if $dontcopy{$oppatch};\n\t}\n        push @{$nl->{'patches'}->{''}}, $_;\n      }\n    }\n  }\n  if ($nlchanged) {\n    mkdir_p($uploaddir);\n    writexml(\"$uploaddir/$$\", undef, $nl, $BSXML::link);\n    $files->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link');\n  }\n  for (sort keys %$ofiles) {\n    next if $dontcopy{$_};\n    $files->{$_} = $ofiles->{$_};\n  }\n  return $files;\n}\n\nsub sourcecommit {\n  my ($cgi, $projid, $packid) = @_;\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  my $files = lsrev($rev);\n  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};\n  $rev = addrev($cgi, $projid, $packid, $files);\n  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub sourcecommitfilelist {\n  my ($cgi, $projid, $packid) = @_;\n  BSVerify::verify_md5($cgi->{'servicemark'}) if $cgi->{'servicemark'};\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $fl = readxml(\"$uploaddir/$$\", $BSXML::dir);\n  unlink(\"$srcrep/:upload/$$\");\n  # make sure we know every file\n  my @missing;\n  my $files = {};\n  for my $entry (@{$fl->{'entry'} || []}) {\n    BSVerify::verify_filename($entry->{'name'});\n    BSVerify::verify_md5($entry->{'md5'});\n    if (! -e \"$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}\") {\n      push @missing, $entry;\n    } else {\n      die(\"duplicate file: $entry->{'name'}\\n\") if exists $files->{$entry->{'name'}};\n      $files->{$entry->{'name'}} = $entry->{'md5'};\n    }\n  }\n  if (@missing) {\n    my $res = {'name' => $packid, 'error' => 'missing', 'entry' => \\@missing};\n    return ($res, $BSXML::dir);\n  }\n  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};\n  if (-e \"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\") {\n    # autocommit old update revision so that it doesn't get lost\n    my $uploadrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => 'upload'};\n    my $uploadfiles = lsrev($uploadrev);\n    addrev({ %$cgi, 'comment' => 'autocommit update revision'}, $projid, $packid, $uploadfiles);\n  }\n  my $rev = addrev($cgi, $projid, $packid, $files);\n  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};\n  $cgi->{'rev'} = $rev->{'rev'};\n  return getfilelist($cgi, $projid, $packid);\n}\n\n# admin only, move entire project\nsub moveproject {\n  my ($cgi, $projid) = @_;\n  my $oprojid = $cgi->{'oproject'};\n  return $BSStdServer::return_ok if $oprojid eq $projid;\n\n  my $oproj = readproj($oprojid);\n\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;\n  if ($reposerver ne $oreposerver) {\n    die(\"cannot copy binaries between different reposiory servers yet\\n\");\n  }\n  if (-e \"$projectsdir/$projid.pkg\" || -e \"$projectsdir/$projid.conf\" || -e \"$projectsdir/$projid.xml\") {\n    die(\"target project already exists\\n\");\n  }\n\n  rename(\"$projectsdir/$oprojid.xml\", \"$projectsdir/$projid.xml\");\n  rename(\"$projectsdir/$oprojid.pkg\", \"$projectsdir/$projid.pkg\") if -e \"$projectsdir/$oprojid.pkg\";\n  rename(\"$projectsdir/$oprojid.conf\", \"$projectsdir/$projid.conf\") if -e \"$projectsdir/$oprojid.conf\";\n  rename(\"$treesdir/$oprojid\", \"$treesdir/$projid\") if $BSConfig::nosharedtrees && -e \"$treesdir/$oprojid\";\n\n  # move entries in linkinfo database\n  if (-d $sourcedb) {\n    my $linkdb = BSDB::opendb($sourcedb, 'linkinfo');\n    if ($linkdb) {\n      my @packids = grep {s/\\Q$oprojid\\E\\///} $linkdb->keys();\n      for my $packid (@packids) {\n\tnext unless -e \"$projectsdir/$projid.pkg/$packid.xml\";\n\teval {\n\t  my $rev = getrev($projid, $packid);\n\t  updatelinkinfodb($projid, $packid, $rev, lsrev($rev)) if $rev;\n\t};\n\twarn($@) if $@;\n\tupdatelinkinfodb($oprojid, $packid);\n      }\n    }\n  }\n\n  # move in the backend as well\n  my @args;\n  push @args, \"cmd=move\";\n  push @args, \"oproject=$oprojid\";\n  my $param = {\n    'uri' => \"$reposerver/build/$projid\",\n    'request' => 'POST',\n  };\n  eval {\n    # ignore failures for now\n    BSWatcher::rpc($param, undef, @args);\n  };\n  warn($@) if $@;\n\n  # check all packages in project\n  notify_repservers('package', $projid);\n  notify_repservers('package', $oprojid);\n  return $BSStdServer::return_ok;\n}\n\n# copy sources of entire project, project exists ensured by api.\nsub copyproject {\n  my ($cgi, $projid) = @_;\n  my $oprojid = $cgi->{'oproject'};\n  return $BSStdServer::return_ok if $oprojid eq $projid;\n\n  my $proj = readproj($projid);\n  my $oproj = readproj($oprojid);\n\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;\n  if ($cgi->{'withbinaries'} && $reposerver ne $oreposerver) {\n    die(\"cannot copy binaries between different reposiory servers yet\\n\");\n  }\n\n  my $user = defined($cgi->{'user'}) && $cgi->{'user'} ne '' ? $cgi->{'user'} : 'unknown';\n  my $comment = defined($cgi->{'comment'}) ? $cgi->{'comment'} : '';\n  $user = str2utf8xml($user);\n  $comment = str2utf8xml($comment);\n\n  # copy _project data\n  if (-e \"$projectsdir/$oprojid.pkg/_project.rev\" || -e \"$projectsdir/$oprojid.conf\") {\n    my $lastorev = getrev($oprojid, '_project');\n    my $files = lsrev($lastorev);\n    copyfiles($projid, '_project', $oprojid, '_project', $files);\n    addrev($cgi, $projid, '_project', $files);\n  }\n\n  # use {} as we do not want to copy project linked packages\n  my @pkgs = findpackages($oprojid, {});\n  delete $cgi->{'servicemark'};\t\t# just in case...\n  for my $packid (@pkgs) {\n    if (! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n      # new package, create. hopefully the API can deal with this\n      my $opack = readpack($oprojid, $packid);\n      my $pack = {\n\t'project' => $projid,\n\t'name' => $packid,\n      };\n      # everything except person, group, devel and lock\n      for (keys %$opack) {\n        next if $_ eq 'project' || $_ eq 'name';\n        next if $_ eq 'person' || $_ eq 'group' || $_ eq 'devel' || $_ eq 'lock';\n        $pack->{$_} = $opack->{$_} if defined $opack->{$_};\n      }\n      mkdir_p($uploaddir);\n      writexml(\"$uploaddir/copyproject$$\", undef, $pack, $BSXML::pack);\n      addrev_meta($cgi, $projid, $packid, \"$uploaddir/copyproject$$\", \"$projectsdir/$projid.pkg/$packid.xml\", '_meta');\n      # need to do this now because the binary copy will fail otherwise\n      notify_repservers('package', $projid, $packid) if $cgi->{'withbinaries'};\n    }\n    if ($cgi->{'makeolder'} || -s \"$projectsdir/$oprojid.pkg/$packid.rev\") {\n      my $lastorev;\n      if ($cgi->{'withhistory'}) {\n\t# FIXME: races ahead\n\t# history copying is a bit tricky, as it renumbers the revisions\n\tmy @allrevs = BSFileDB::fdb_getall(\"$projectsdir/$oprojid.pkg/$packid.rev\", $srcrevlay);\n\tif (-e \"$projectsdir/$projid.pkg/$packid.rev\") {\n\t  my $lastrev = BSFileDB::fdb_getlast(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay);\n\t  if ($lastrev && $lastrev->{'rev'}) {\n\t    for my $rev (@allrevs) {\n\t      $rev->{'rev'} += $lastrev->{'rev'};\n\t    }\n\t  }\n\t}\n\t# make trees available in new project\n\tmy $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n\tif ($BSConfig::nosharedtrees) {\n\t  my $treedir = \"$treesdir/$projid/$packid\";\n\t  for my $rev (@allrevs) {\n\t    next if -e \"$treedir/$rev->{'srcmd5'}-MD5SUMS\";\n\t    my $files = lsrev({ %$rev, 'project' => $oprojid, 'package' => $packid });\n\t    copyfiles($projid, $packid, $oprojid, $packid, $files);\n\t    addmeta($projid, $packid, $files);\n\t  }\n\t}\n\tBSFileDB::fdb_add_multiple(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, @allrevs);\n\t$lastorev = $allrevs[-1];\n      } else {\n\t$lastorev = BSFileDB::fdb_getlast(\"$projectsdir/$oprojid.pkg/$packid.rev\", $srcrevlay);\n      }\n      if (!$lastorev || !$lastorev->{'rev'}) {\n\tnext unless $cgi->{'makeolder'};\n\t# fake empty commit\n\t$lastorev = { 'version' => 'unknown', 'rev' => 0, 'vrev' => 0, 'srcmd5' => $emptysrcmd5 };\n      }\n      # always do one new commit, we don't use addrev to have full control over vrev\n      my $linkinfo = {};\n      my $frev = { %$lastorev, 'project' => $oprojid, 'package' => $packid };\n      my $files = lsrev($frev, $linkinfo);\n\n      my $servicemark;\n      if ($linkinfo->{'xservicemd5'}) {\n        if ($cgi->{'noservice'}) {\n\t  eval {\n\t    $files = handleservice($frev, $files, $linkinfo->{'xservicemd5'});\n\t  };\n\t  if ($@) {\t\n\t    warn($@);\t# hmm, could not expand service\n\t    $servicemark = genservicemark($projid, $packid, $files, undef, 1);\n\t  } else {\n            copyfiles($projid, $packid, $oprojid, $packid, $files);\n\t    ($servicemark, $files) = servicemark_noservice($cgi, $projid, $packid, $files, undef, $linkinfo->{'xservicemd5'});\n\t  }\n\t} else {\n\t  $servicemark = genservicemark($projid, $packid, $files, undef, 1);\n\t}\n      }\n      copyfiles($projid, $packid, $oprojid, $packid, $files);\n      $files->{'/SERVICE'} = $servicemark if $servicemark;\n      my $newrev = { %$lastorev };\n      $newrev->{'srcmd5'} = addmeta($projid, $packid, $files);\n      $newrev->{'user'} = $user;\n      $newrev->{'comment'} = $comment;\n      $newrev->{'requestid'} = $cgi->{'requestid'};\n      $newrev->{'time'} = time();\n      if ($cgi->{'makeolder'}) {\n\t$newrev->{'vrev'} =~ s/(\\d+)$/($1+1).\".1\"/e;\n      } else {\n\t$newrev->{'vrev'} =~ s/(\\d+)$/$1+1/e;\n      }\n      delete $newrev->{'rev'};\n      $newrev = BSFileDB::fdb_add_i(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, $newrev);\n      updatelinkinfodb($projid, $packid, { %$newrev, 'project' => $oprojid, 'package' => $packid }, $files);\n      if ($cgi->{'makeolder'}) {\n\t$lastorev->{'user'} = $user;\n\t$lastorev->{'comment'} = $comment;\n\t$lastorev->{'requestid'} = $cgi->{'requestid'};\n\t$lastorev->{'time'} = time();\n\t$lastorev->{'vrev'} =~ s/(\\d+)$/$1+2/e;\n\tdelete $lastorev->{'rev'};\n\t$lastorev = BSFileDB::fdb_add_i(\"$projectsdir/$oprojid.pkg/$packid.rev\", $srcrevlay, $lastorev);\n      }\n    }\n    # XXX: does this make any sense?\n    if ($cgi->{'withbinaries'}) {\n      for my $repo (@{$proj->{'repository'} || []}) {\n\tmy $orepo = (grep {$_->{'name'} eq $repo->{'name'}} @{$oproj->{'repository'} || []})[0];\n\tnext unless $orepo;\n\tfor my $arch (@{$repo->{'arch'} || []}) {\n\t  next unless grep {$_ eq $arch} @{$orepo->{'arch'} || []};\n\n\t  # same source and target repo/arch in both projects exists\n\t  my @args;\n\t  push @args, \"cmd=copy\";\n\t  push @args, \"oproject=$oprojid\";\n\t  push @args, \"opackage=$packid\"; # same package name\n\t  push @args, \"orepository=$repo->{'name'}\"; # same repo name\n\t  push @args, 'resign=1' if $cgi->{'resign'};\n\t  my $param = {\n\t    'uri' => \"$reposerver/build/$projid/$repo->{'name'}/$arch/$packid\",\n\t    'request' => 'POST',\n\t  };\n\t  eval {\n\t    # ignore failures for now\n\t    BSWatcher::rpc($param, undef, @args);\n\t  };\n          warn($@) if $@;\n\t}\n      }\n    }\n  }\n  # check all packages in project\n  notify_repservers('package', $projid);\n  return $BSStdServer::return_ok;\n}\n\n# we're going to auto-update a link. this means we must also\n# auto-update the corresponding service result\nsub update_link_in_service {\n  my ($rev, $files, $xservicemd5, $isbranch) = @_;\n\n  return undef unless defined $xservicemd5;\n  return $xservicemd5 if $BSConfig::old_style_services;\n  return $xservicemd5 unless $files->{'_link'};\n  my $sfiles;\n  eval {\n    $sfiles = lsrev({%$rev, 'srcmd5' => $xservicemd5});\n  };\n  return $xservicemd5 unless $sfiles && $sfiles->{'_link'};\n  return $xservicemd5 if $sfiles->{'_link'} && $sfiles->{'_link'} eq $files->{'_link'};\t# nothing changed\n  # okay, we need to generate a new service commit\n  my $servicemark = genservicemark($rev->{'project'}, $rev->{'package'}, $files, undef, 1);\n  return undef unless $servicemark;\n  # delete all non-service files unless it's a branch\n  if (!$isbranch) {\n    delete $sfiles->{$_} for grep {!/^_service[_:]/} keys %$sfiles;\n  }\n  # copy new link\n  $sfiles->{'_link'} = $files->{'_link'};\n  # write back new service result\n  fake_service_run($rev->{'project'}, $rev->{'package'}, $files, $sfiles, $servicemark);\n  return $servicemark;\n}\n\nsub sourcecopy {\n  my ($cgi, $projid, $packid) = @_;\n  die(\"illegal rev parameter\\n\") if $cgi->{'rev'} && $cgi->{'rev'} ne 'upload';\n  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;\n  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;\n  die(\"makeoriginolder only makes sense with withvrev\\n\") if $cgi->{'makeoriginolder'} && !$cgi->{'withvrev'};\n  my $orev = $cgi->{'orev'};\n  $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest');\n  die(\"origin must not be virtual for makeoriginolder\\n\") if $cgi->{'makeoriginolder'} && $orev->{'originproject'};\n  $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'};\n  my $orev_srcmd5 = $orev->{'srcmd5'};  # so that we can restore it later\n  my $files = $cgi->{'noservice'} || $cgi->{'expand'} ? lsrev_service($orev) : lsrev($orev);\n  die(\"need a revision to copy\\n\") if !$cgi->{'rev'} && !$cgi->{'orev'} && $oprojid eq $projid && $opackid eq $packid && !($files->{'_link'} && $cgi->{'expand'});\n\n  die(\"makeoriginolder currently does not work on links\\n\") if $cgi->{'makeoriginolder'} && $files->{'_link'};\n\n  my $autosimplifylink;\n  my $autosimplifylink_lrev;\n\n  if ($files->{'_link'} && !$cgi->{'dontupdatesource'} && !$cgi->{'rev'}) {\n    # fix me: do this in a more generic way\n    my $ol = repreadxml($orev, '_link', $files->{'_link'}, $BSXML::link, 1);\n    if ($ol) {\n      my $lprojid = $oprojid;\n      my $lpackid = $opackid;\n      my $lrev = $ol->{'rev'};\n      $lprojid = $ol->{'project'} if exists $ol->{'project'};\n      $lpackid = $ol->{'package'} if exists $ol->{'package'};\n      if ($lprojid eq $projid && $lpackid eq $packid) {\n\t# copy destination is target of link\n\t# we're integrating this link\n\t$lrev = getrev($lprojid, $lpackid, $lrev);\n\t$autosimplifylink_lrev = { %$lrev };\n\tmy $lfiles = $cgi->{'noservice'} && !$cgi->{'expand'} ? lsrev_service({ %$lrev }) : lsrev($lrev);\n\tif ($lfiles->{'_link'} && !$cgi->{'expand'}) {\n\t  # link to a link, join\n\t  $files = integratelink($lfiles, $lprojid, $lpackid, $lrev, $files, $oprojid, $opackid, $ol, $orev);\n\t} else {\n\t  # auto expand\n\t  $cgi->{'expand'} = 1;\n\t}\n\t$autosimplifylink = $ol;\n      }\n    }\n  }\n\n  my $oldvrev = $orev->{'vrev'};\n  if ($files->{'_link'} && $cgi->{'expand'}) {\n    my %olrev = %$orev;\t\t# copy so that orev still points to unexpanded sources\n    $files = handlelinks(\\%olrev, $files);\n    die(\"broken link in $oprojid/$opackid: $files\\n\") unless ref $files;\n    $oldvrev = $olrev{'vrev'};\n  }\n\n  copyfiles($projid, $packid, $oprojid, $opackid, $files);\n\n  if ($cgi->{'withvrev'} && !$cgi->{'vrev'} && defined($oldvrev)) {\n    $cgi->{'vrev'} = $oldvrev;\n    # bump vrev so that new builds will have a bigger release number\n    # (just like in copyproject)\n    if ($cgi->{'makeoriginolder'}) {\n      $cgi->{'vrev'} =~ s/(\\d+)$/$1+2/e;\n    } else {\n      $cgi->{'vrev'} =~ s/(\\d+)$/$1+1/e;\n    }\n  }\n  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};\n  my $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});\n  delete $cgi->{'vrev'};\n\n  if ($cgi->{'makeoriginolder'}) {\n    # add dummy commit\n    my $lastline = BSFileDB::fdb_getlast(\"$projectsdir/$oprojid.pkg/$opackid.rev\", $srcrevlay);\n    die(\"makeoriginolder: $oprojid/$opackid does not exists?\\n\") unless defined $lastline;\n    delete $lastline->{'requestid'};\n    delete $lastline->{'rev'};\n    $lastline->{'user'} = 'buildservice-autocommit';\n    $lastline->{'comment'} = \"makeolder vrev update for $projid/$packid\";\n    $lastline->{'requestid'} = $cgi->{'requestid'} if $cgi->{'requestid'};\n    $lastline->{'vrev'} =~ s/(\\d+)$/($1+1).\".1\"/e;\n    BSFileDB::fdb_add_i(\"$projectsdir/$oprojid.pkg/$opackid.rev\", $srcrevlay, $lastline);\n    notify_repservers('package', $oprojid, $opackid);\n  }\n\n  if ($autosimplifylink && !defined($autosimplifylink->{'rev'})) {\n    $orev->{'srcmd5'} = $orev_srcmd5;\t# back to unexpanded\n\n    # make sure that vrev doesn't decrease when copying to the\n    # link target\n    my $vrevbump = 0;\n    if ($rev && $autosimplifylink_lrev && $rev->{'version'} ne $autosimplifylink_lrev->{'version'}) {\n      # version change, check if vrev went down\n      my $vrev1 = $rev->{'vrev'} || '0';\n      my $vrev2 = $autosimplifylink_lrev->{'vrev'} || '0';\n      $vrev1 =~ s/.*?(\\d+)$/$1/;\n      $vrev2 =~ s/.*?(\\d+)$/$1/;\n      $vrevbump = $vrev2 > $vrev1 ? $vrev2 - $vrev1 : 0;\n    }\n\n    my $isbranch = grep {(keys %$_)[0] eq 'branch'} @{$autosimplifylink->{'patches'}->{''} || []};\n    if ($isbranch) {\n      # update base rev so that there are no changes\n      # FIXME: this is a gross hack...\n      # we should not need to update the baserev, instead we should change\n      # the way branches get applied\n\n      my $ofiles = lsrev($orev);\n      delete $ofiles->{'_link'};\n      copyfiles($projid, $packid, $oprojid, $opackid, $ofiles);\n      my $newbase = addmeta($projid, $packid, $ofiles);\n      if ($autosimplifylink->{'baserev'} ne $newbase) {\n\teval {\n          my $latestorev = getrev($oprojid, $opackid);\n\t  my $latestlinkinfo = {};\n          my $latestfiles = lsrev($latestorev, $latestlinkinfo);\n          if ($latestfiles->{'_link'}) {\n\t    my $latestl = repreadxml($latestorev, '_link', $latestfiles->{'_link'}, $BSXML::link, 1);\n\t    my $latestisbranch = grep {(keys %$_)[0] eq 'branch'} @{$latestl->{'patches'}->{''} || []};\n\t    if ($latestisbranch && $latestl->{'baserev'} eq $autosimplifylink->{'baserev'}) {\n\t      $latestl->{'baserev'} = $newbase;\n\t      $latestl->{'patches'}->{''} = [ { 'branch' => undef} ]; # work around xml problem\n\t      if ($latestl->{'missingok'} &&\n\t\t(defined($latestl->{'project'}) ? $latestl->{'project'} : $oprojid) eq $projid &&\n\t\t(defined($latestl->{'package'}) ? $latestl->{'package'} : $opackid) eq $packid) {\n\t\teval {\n\t          checksourceaccess($projid, $packid);\n\t\t  delete $latestl->{'missingok'};\n\t\t};\n\t      }\n\t      mkdir_p($uploaddir);\n\t      writexml(\"$uploaddir/$$\", undef, $latestl, $BSXML::link);\n              $latestfiles->{'_link'} = addfile($oprojid, $opackid, \"$uploaddir/$$\", '_link');\n              my $servicemark = update_link_in_service($latestorev, $latestfiles, $latestlinkinfo->{'xservicemd5'}, 1);\n\t      if ($vrevbump) {\n\t\t$cgi->{'vrev'} = $latestorev->{'vrev'};\n\t\t$cgi->{'vrev'} =~ s/(\\d+)$/$1 + $vrevbump/e;\n\t      }\n              addrev({ %$cgi, 'user' => 'buildservice-autocommit', 'comment' => 'baserev update by copy to link target', 'servicemark' => $servicemark }, $oprojid, $opackid, $latestfiles);\n\t    }\n\t  }\n\t};\n        warn($@) if $@;\n      }\n    } else {\n      eval {\n        my $latestorev = getrev($oprojid, $opackid);\n        if ($latestorev->{'srcmd5'} eq $orev->{'srcmd5'}) {\n          # simplify link\n\t  my $latestlinkinfo = {};\n          my $latestfiles = lsrev($latestorev, $latestlinkinfo);\n          my $nl = { %$autosimplifylink };\n          delete $nl->{'patches'};\n          delete $nl->{'baserev'};\n\t  mkdir_p($uploaddir);\n          writexml(\"$uploaddir/$$\", undef, $nl, $BSXML::link);\n          my $ofiles = {};\n          $ofiles->{'_link'} = addfile($oprojid, $opackid, \"$uploaddir/$$\", '_link');\n          my $servicemark = update_link_in_service($latestorev, $ofiles, $latestlinkinfo->{'xservicemd5'}, 0);\n\t  if ($vrevbump) {\n\t    $cgi->{'vrev'} = $latestorev->{'vrev'};\n\t    $cgi->{'vrev'} =~ s/(\\d+)$/$1 + $vrevbump/e;\n\t  }\n          addrev({ %$cgi, 'user' => 'buildservice-autocommit', 'comment' => 'auto commit by copy to link target', 'servicemark' => $servicemark }, $oprojid, $opackid, $ofiles);\n        }\n      };\n      warn($@) if $@;\n    }\n    delete $cgi->{'vrev'} if $vrevbump;\n  }\n\n  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};\n\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision_acceptinfo);\n}\n\nsub sourcebranch {\n  my ($cgi, $projid, $packid) = @_;\n\n  my $usebranch = 1;\n  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;\n  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;\n  my $orev = $cgi->{'orev'};\n  die(\"cannot branch myself\\n\") if $oprojid eq $projid && $opackid eq $packid;\n  $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest', undef, $cgi->{'missingok'});\n  $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'};\n  print \"SOURCEBRANCH $oprojid $opackid\\n\";\n  my $files = lsrev_expanded($orev);\t# modifies srcmd5, thus also needed for keepcontent case\n  if ($cgi->{'keepcontent'}) {\n    die(\"keepcontent is only supported for branches\\n\") unless $usebranch;\n    my $nrev = getrev($projid, $packid, 'latest');\n    $files = lsrev_expanded($nrev);\n  }\n  my $l = {};\n  $l->{'project'} = $oprojid if $oprojid ne $projid;\n  $l->{'package'} = $opackid if $opackid ne $packid;\n  # a missing package entry is bad if the project has sourceaccess\n  # disabled, so check if that's the case\n  eval {\n    checksourceaccess($oprojid, $opackid) if $opackid eq $packid && $oprojid ne $projid;\n  };\n  $l->{'package'} = $opackid if $@;\n  $l->{'missingok'} = \"true\" if defined $cgi->{'missingok'} && $orev->{'srcmd5'} eq $emptysrcmd5;\n  $l->{'rev'} = $cgi->{'orev'} if defined $cgi->{'orev'};\n  $l->{'baserev'} = $orev->{'srcmd5'};\n  my $lfiles = {};\n  mkdir_p(\"$srcrep/$packid\");\n  if ($usebranch) {\n    $l->{'patches'}->{''} = [ { 'branch' => undef} ];\n    copyfiles($projid, $packid, $oprojid, $opackid, $files) unless $cgi->{'keepcontent'};\n    $lfiles->{$_} = $files->{$_} for keys %$files;\n  }\n  mkdir_p($uploaddir);\n  writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n  $lfiles->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link');\n  my $rev = addrev($cgi, $projid, $packid, $lfiles);\n  runservice($cgi, $rev, $lfiles) unless $cgi->{'noservice'};\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision_acceptinfo);\n}\n\nsub linktobranch {\n  my ($cgi, $projid, $packid) = @_;\n  my $rev = getrev($projid, $packid);\n  $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n  my $files = lsrev($rev);\n  die(\"package is not a link\\n\") unless $files->{'_link'};\n  my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);\n  die(\"package is already a branch\\n\") if $l->{'patches'} && grep {(keys %$_)[0] eq 'branch'} @{$l->{'patches'}->{''} || []};\n  my $linkinfo = {};\n  $files = lsrev_expanded($rev, $linkinfo);\n  $l->{'baserev'} = $linkinfo->{'srcmd5'};\n  $l->{'patches'}->{''} = [ { 'branch' => undef} ];\n  mkdir_p($uploaddir);\n  writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n  $files->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link');\n  $cgi->{'comment'} ||= 'converted link to branch';\n  $rev = addrev($cgi, $projid, $packid, $files);\n  runservice($cgi, $rev, $files);\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub sourcecollectbuildenv {\n  my ($cgi, $projid, $packid) = @_;\n  my $oprojid = $cgi->{'oproject'} || $projid;\n  my $opackid = $cgi->{'opackage'} || $packid;\n  die(\"cannot collect from myself\\n\") if $oprojid eq $projid && $opackid eq $packid;\n  my $proj = checkprojrepoarch($projid);\n  my $oproj = checkprojrepoarch($oprojid);\n  my %orepoids;\n  for (@{$oproj->{'repository'} || []}) {\n    $orepoids{\"$oprojid/$_->{'name'}\"} = $_;\n  }\n  for (@{$oproj->{'repository'} || []}) {\n    for my $rt (@{$_->{'releasetarget'} || []}) {\n      $orepoids{\"$rt->{'project'}/$rt->{'repository'}\"} ||= $_;\n    }\n  }\n  my %buildenvs;\n  for my $repo (@{$proj->{'repository'} || []}) {\n    next unless @{$repo->{'arch'} || []};\n    my $repoid = $repo->{'name'};\n    my @xpath = expandsearchpath($projid, $repoid);\n    my $orepo;\n    for my $xr (@xpath) {\n      $orepo = $orepoids{$xr};\n      last if $orepo;\n    }\n    if ($orepo) {\n      my $orepoid = $orepo->{'name'};\n      my %oarchs = map {$_ => 1} @{$orepo->{'arch'} || []};\n      for my $arch (@{$repo->{'arch'}}) {\n\tmy $be;\n\tif (!$oarchs{$arch}) {\n\t  # arch not included, use error buildenv\n\t  $be = { 'error', \"$arch missing in $oprojid/$orepoid\" };\n\t} else {\n\t  my $reposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;\n\t  eval {\n\t    $be = BSRPC::rpc(\"$reposerver/build/$oprojid/$orepoid/$arch/$opackid/_buildenv\", $BSXML::buildinfo);\n\t  };\n\t  if ($@) {\n\t    die($@) if $@ !~ /^404/;\n\t    $be = { 'error', \"_buildenv missing in $oprojid/$orepoid\" };\n\t  }\n\t  $be ||= { 'error', \"could not get _buildenv in $oprojid/$orepoid\" };\n\t}\n        $buildenvs{\"_buildenv.$repoid.$arch\"} = BSUtil::toxml($be, $BSXML::buildinfo);\n      }\n    }\n  }\n  die(\"could not get any buildenv, something is wrong\\n\") unless %buildenvs;\n  # add master buildenv, in our case a \"fallback error\" buildenv\n  my $be = { 'error', \"no buildenv for this repo/arch\" };\n  $buildenvs{'_buildenv'} = BSUtil::toxml($be, $BSXML::buildinfo);\n  # now add all the buildenvs to the last commit (unexpanded is enough for us)\n  my $rev = getrev($projid, $packid);\n  my $files = lsrev($rev);\n  delete $files->{$_} for grep {/^_buildenv/} keys %$files;\n  mkdir_p($uploaddir);\n  for my $file (sort keys %buildenvs) {\n    writestr(\"$uploaddir/_be$$\", undef, $buildenvs{$file});\n    $files->{$file} = addfile($projid, $packid, \"$uploaddir/_be$$\", $file);\n  }\n  $rev = addrev($cgi, $projid, $packid, $files);\n  runservice($cgi, $rev, $files);\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub deleteuploadrev {\n  my ($cgi, $projid, $packid) = @_;\n  unlink(\"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\");\n  return $BSStdServer::return_ok;\n}\n\nsub unknowncmd {\n  my ($cgi, $projid, $packid) = @_;\n  die(\"unknown command \\\"$cgi->{'cmd'}\\\"\\n\");\n}\n\nsub delfile {\n  my ($cgi, $projid, $packid, $filename) = @_;\n  die(\"no filename\\n\") unless defined($filename) && $filename ne '';\n  die(\"bad filename\\n\") if $filename =~ /\\// || $filename =~ /^\\./;\n  if ($cgi->{'meta'}) {\n    if ($filename ne '_attribute' && $filename ne '_frozenlinks') {\n      die(\"unsupported meta operation\\n\");\n    }\n    my $rev = addrev_meta($cgi, $projid, $packid, undef, undef, $filename);\n    notify_repservers('package', $projid) if $filename eq '_frozenlinks';\n    delete $rev->{'project'};\n    delete $rev->{'package'};\n    return ($rev, $BSXML::revision);\n  }\n  die(\"file '$filename' is read-only\\n\") if ($filename =~ /^_service:/) && !$cgi->{'force'};\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  my $files;\n  if ($cgi->{'keeplink'}) {\n    $files = lsrev_expanded($rev);\n  } else {\n    $files = lsrev($rev);\n  }\n  die(\"404 file '$filename' does not exist\\n\") unless $files->{$filename};\n  delete $files->{$filename};\n  $files = keeplink($projid, $packid, $files) if $cgi->{'keeplink'};\n  $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});\n  runservice($cgi, $rev, $files);\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub getrepositorylist {\n  my ($cgi, $projid) = @_;\n  my $proj = checkprojrepoarch($projid, undef, undef, 1);\n  if ($proj->{'remoteurl'}) {\n    return (BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}\", 'proxy' => $proxy}, $BSXML::dir), $BSXML::dir);\n  }\n  my @res = map {{'name' => $_->{'name'}}} @{$proj->{'repository'} || []};\n  return ({'entry' => \\@res}, $BSXML::dir);\n}\n\nsub getrepository {\n  my ($cgi, $projid, $repoid) = @_;\n  my $proj = readproj($projid);\n  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];\n  die(\"404 $repoid: no such repository\\n\") unless $repo;\n  return ($repo, $BSXML::repo);\n}\n\nsub getarchlist {\n  my ($cgi, $projid, $repoid) = @_;\n  my $proj = checkprojrepoarch($projid, $repoid, undef, 1);\n  if ($proj->{'remoteurl'}) {\n    return (BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid\", 'proxy' => $proxy}, $BSXML::dir), $BSXML::dir);\n  }\n  my @repo = grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []};\n  die(\"404 $repoid: no such repository\\n\") unless @repo;\n  my @res = map {{'name' => $_}} @{$repo[0]->{'arch'} || []};\n  return ({'entry' => \\@res}, $BSXML::dir);\n}\n\nsub getresult {\n  my ($cgi, $projid) = @_;\n\n  my $proj = checkprojrepoarch($projid, undef, undef, 1);\n  if ($proj->{'remoteurl'}) {\n    die(\"oldstate not supported for remote projects\\n\") if $cgi->{'oldstate'};\n    my @args;\n    push @args, \"lastbuild\" if $cgi->{'lastbuild'};\n    push @args, map {\"view=$_\"} @{$cgi->{'view'} || []};\n    push @args, map {\"repository=$_\"} @{$cgi->{'repository'} || []};\n    push @args, map {\"arch=$_\"} @{$cgi->{'arch'} || []};\n    push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n    push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n    return (BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/_result\", 'proxy' => $proxy}, $BSXML::resultlist, @args), $BSXML::resultlist);\n  }\n  if ($cgi->{'oldstate'} && !$BSStdServer::isajax) {\n    my @args = \"oldstate=$cgi->{'oldstate'}\";\n    push @args, \"lastbuild\" if $cgi->{'lastbuild'};\n    push @args, map {\"view=$_\"} @{$cgi->{'view'} || []};\n    push @args, map {\"repository=$_\"} @{$cgi->{'repository'} || []};\n    push @args, map {\"arch=$_\"} @{$cgi->{'arch'} || []};\n    push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n    push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n    BSHandoff::handoff($ajaxsocket, \"/build/$projid/_result\", undef, @args);\n    exit(0);\n  }\n\n  my %repoidfilter = map {$_ => 1} @{$cgi->{'repository'} || []};\n  my %archfilter = map {$_ => 1} @{$cgi->{'arch'} || []};\n  my %view = map {$_ => 1} @{$cgi->{'view'} || ['status']};\n  my %code = map {$_ => 1} @{$cgi->{'code'} || []};\n\n  if ($cgi->{'repository'}) {\n    my %knownrepoids = map {$_->{'name'} => 1} @{$proj->{'repository'} || []};\n    for (@{$cgi->{'repository'}}) {\n      die(\"404 unknown repository '$_'\\n\") if !$knownrepoids{$_};\n    }\n  }\n  if ($cgi->{'package'}) {\n    my %knownpackids = map {$_ => 1} findpackages($projid, $proj, 1);\n    for (@{$cgi->{'package'}}) {\n      die(\"404 unknown package '$_'\\n\") if !$knownpackids{$_};\n    }\n  }\n  my @prpas;\n  for my $repo (@{$proj->{'repository'} || []}) {\n    next if %repoidfilter && !$repoidfilter{$repo->{'name'}};\n    my @archs = @{$repo->{'arch'} || []};\n    @archs = grep {$archfilter{$_}} @archs if %archfilter;\n    push @prpas, map {\"$projid/$repo->{'name'}/$_\"} @archs;\n  }\n\n  BSWatcher::addfilewatcher(\"$projectsdir/$projid.xml\") if $BSStdServer::isajax;\n\n  if (!@prpas) {\n    my $state = \"00000000000000000000000000000000\";\n    return undef if $BSStdServer::isajax && $cgi->{'oldstate'} && $state eq $cgi->{'oldstate'};\n    return ({'state' => $state}, $BSXML::resultlist);\n  }\n\n  my $ps = {};\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, 'lastbuild' if $cgi->{'lastbuild'};\n  push @args, \"oldstate=$cgi->{'oldstate'}\" if $cgi->{'oldstate'};\n  push @args, map {\"prpa=$_\"} @prpas;\n  push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n  push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n  push @args, 'withbinarylist' if $view{'binarylist'};\n  push @args, 'withstats' if $view{'stats'};\n  push @args, 'summary' if $view{'summary'} && !$view{'status'};\n  eval {\n    $ps = BSWatcher::rpc(\"$reposerver/_result\", $BSXML::resultlist, @args);\n  };\n  if ($@) {\n    print \"warning: $reposerver: $@\";\n    $ps = {};\n  }\n  return if $BSStdServer::isajax && !defined($ps);\n  if ($view{'summary'} && $view{'status'}) {\n    my @order = ('succeeded', 'failed', 'unresolvable', 'broken', 'scheduled');\n    my %order = map {$_ => 1} @order;\n    for my $p (@{$ps->{'result'} || []}) {\n      my %sum;\n      for my $pp (@{$p->{'status'} || []}) {\n        $sum{$pp->{'code'}}++ if $pp->{'code'};\n      }\n      my @sum = grep {exists $sum{$_}} @order;\n      push @sum, grep {!$order{$_}} sort keys %sum;\n      $p->{'summary'} = {'statuscount' => [ map {{'code' => $_, 'count' => $sum{$_}}} @sum ] };\n    }\n  }\n  if (!$view{'status'}) {\n    for my $p (@{$ps->{'result'} || []}) {\n      delete $p->{'status'};\n    }\n  }\n  return ($ps, $BSXML::resultlist);\n}\n\nsub docommand {\n  my ($cgi, $projid) = @_;\n\n  my %repoidfilter = map {$_ => 1} @{$cgi->{'repository'} || []};\n  my %archfilter = map {$_ => 1} @{$cgi->{'arch'} || []};\n\n  my $proj = readproj($projid);\n  my @prpas;\n  for my $repo (@{$proj->{'repository'} || []}) {\n    next if %repoidfilter && !$repoidfilter{$repo->{'name'}};\n    my @archs = @{$repo->{'arch'} || []};\n    @archs = grep {$archfilter{$_}} @archs if %archfilter;\n    push @prpas, map {\"$projid/$repo->{'name'}/$_\"} @archs;\n  }\n  die(\"no repository defined\\n\") unless @prpas;\n  my @packids = @{$cgi->{'package'} || []};\n  if ($cgi->{'cmd'} eq 'wipepublishedlocked') {\n    die(\"wipepublishedlocked can only wipe complete repos\\n\") if $cgi->{'arch'} || $cgi->{'code'} || @packids;\n  } else {\n    if (@packids) {\n      my %packids = map {$_ => 1} findpackages($projid, $proj, 1);\n      my @badpacks = grep {!$packids{$_}} @packids;\n      die(\"404 unknown package: @badpacks\\n\") if @badpacks;\n    } else {\n      @packids = findpackages($projid, $proj);\n    }\n    die(\"no packages defined\\n\") unless @packids;\n  }\n  die(\"illegal wipe parameter\\n\") if $cgi->{'wipe'} && $cgi->{'cmd'} ne 'wipe';\n  \n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $res;\n  my @args;\n  push @args, map {\"prpa=$_\"} @prpas;\n  push @args, map {\"package=$_\"} @packids;\n  push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n  push @args, map {\"wipe=$_\"} @{$cgi->{'wipe'} || []};\n  push @args, \"cmd=$cgi->{'cmd'}\";\n  my $param = {\n    'uri' => \"$reposerver/_command\",\n    'request' => 'POST',\n  };\n  $res = BSWatcher::rpc($param, undef, @args);\n  return $res;\n}\n\nsub checkprojrepoarch {\n  my ($projid, $repoid, $arch, $remoteok) = @_;\n  my $proj = readproj($projid, 1);\n  $proj = remoteprojid($projid) if $remoteok && (!$proj || $proj->{'remoteurl'});\n  die(\"404 project '$projid' does not exist\\n\") if !$proj;\n  die(\"404 project '$projid' is remote\\n\") if $proj->{'remoteurl'} && !$remoteok;\n  return $proj if $proj->{'remoteurl'};\n  return $proj unless defined $repoid;\n  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];\n  die(\"404 project '$projid' has no repository '$repoid'\\n\") unless $repo;\n  return $proj unless defined $arch;\n  die(\"404 repository '$projid/$repoid' has no architecture '$arch'\\n\") unless grep {$_ eq $arch} @{$repo->{'arch'} || []};\n  return $proj;\n}\n\nsub getbuilddepinfo {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n  push @args, \"view=$cgi->{'view'}\" if $cgi->{'view'};\n  my $res = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/_builddepinfo\", $BSXML::builddepinfo, @args);\n  return ($res, $BSXML::builddepinfo);\n}\n\nsub getjobhistory {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, \"limit=$cgi->{'limit'}\" if $cgi->{'limit'};\n  push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n  push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n  my $res = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/_jobhistory\", $BSXML::jobhistlist, @args);\n  return ($res, $BSXML::jobhistlist);\n}\n\nsub getpackagelist_build {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n  if ($cgi->{'view'}) {\n    die(\"unknown view '$cgi->{'view'}'\\n\") unless $cgi->{'view'} eq 'binaryversions' || $cgi->{'view'} eq 'binaryversionscode';\n    my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);\n    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n    my @args = (\"view=$cgi->{'view'}\");\n    push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n    my $param = {\n      'uri' => \"$reposerver/build/$projid/$repoid/$arch\",\n      'ignorestatus' => 1,\n      'receiver' => \\&BSServer::reply_receiver,\n    };\n    if ($proj->{'remoteurl'}) {\n      if (!$BSStdServer::isajax) {\n\tBSHandoff::handoff($ajaxsocket, \"/build/$projid/$repoid/$arch\", undef, @args);\n\texit(0);\n      }\n      $param->{'uri'} = \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch\";\n      $param->{'proxy'} = $proxy;\n    }\n    BSWatcher::rpc($param, undef, @args);\n    return undef;\n  }\n  return getpackagelist({ %$cgi, 'expand' => 1, 'noorigins' => 1 }, $projid, $repoid, $arch);\n}\n\nsub getbinarylist {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n\n  my $view = $cgi->{'view'};\n  my $nosource = $cgi->{'nosource'};\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, \"view=$view\" if $view;\n  push @args, \"nosource=1\" if $nosource;\n  push @args, \"withmd5=1\" if $cgi->{'withmd5'};\n  push @args, map {\"binary=$_\"} @{$cgi->{'binary'} || []};\n  if ($view && ($view eq 'cache' || $view eq 'cpio' || $view eq 'solv' || $view eq 'solvstate')) {\n    # do not check arch in interconnect mode\n    my $proj = checkprojrepoarch($projid, $repoid, undef, 1);\n    if (!$BSStdServer::isajax) {\n      if ($proj->{'remoteurl'} && $view eq 'cpio' && $packid eq '_repository' && !$nosource && @{$cgi->{'binary'} || []}) {\n\t# hand over to worker_getbinaries to get the answer cached\n\t@args = ();\n\tpush @args, \"project=$projid\";\n\tpush @args, \"repository=$repoid\";\n\tpush @args, \"arch=$arch\";\n\tpush @args, \"binaries=\".join(',', @{$cgi->{'binary'} || []});\n\tBSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);\n\texit(0);\n      }\n      BSHandoff::handoff($ajaxsocket, \"/build/$projid/$repoid/$arch/$packid\", undef, @args);\n      exit(0);\n    }\n    my $param = {\n      'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid\",\n      'ignorestatus' => 1,\n      'receiver' => \\&BSServer::reply_receiver,\n    };\n    if ($proj->{'remoteurl'}) {\n      $param->{'uri'} = \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid\";\n      $param->{'proxy'} = $proxy;\n    }\n    BSWatcher::rpc($param, undef, @args);\n    return undef;\n  }\n  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid\",\n  };\n  if ($proj->{'remoteurl'}) {\n    $param->{'uri'} = \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid\";\n    $param->{'proxy'} = $proxy;\n  }\n  if ($view && $view eq 'binaryversions') {\n    push @args, 'nometa=1' if $cgi->{'nometa'};\n    my $bvl = BSWatcher::rpc($param, $BSXML::binaryversionlist, @args);\n    return ($bvl, $BSXML::binaryversionlist);\n  }\n  if ($view && $view eq 'cpioheaders') {\n     $param->{'ignorestatus'} = 1;\n     $param->{'receiver'} = \\&BSServer::reply_receiver;\n     BSWatcher::rpc($param, undef, @args);\n     return undef;\n  }\n  my $bl = BSWatcher::rpc($param, $BSXML::binarylist, @args);\n  return ($bl, $BSXML::binarylist);\n}\n\nsub getbinary {\n  my ($cgi, $projid, $repoid, $arch, $packid, $filename) = @_;\n  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);\n  my $view = $cgi->{'view'} || '';\n  if ($proj->{'remoteurl'} && $packid eq '_repository' && !$view) {\n    # hack: reroute to /getbinaries so that our local cache is used\n    die(\"need the raw package name as filename for remote repository access\\n\") if $filename =~ /\\.(?:$binsufsre)$/;\n    my @args;\n    push @args, \"project=$projid\";\n    push @args, \"repository=$repoid\";\n    push @args, \"arch=$arch\";\n    push @args, \"binaries=$filename\";\n    push @args, \"raw=1\";\n    BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);\n    exit(0);\n  }\n  if ($view eq 'publishedpath') {\n    die(\"publishedpath does not work for _repository\\n\") if $packid eq '_repository';\n    return published_path($cgi, $projid, $repoid);\n  }\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, \"view=$view\" if $view;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid/$filename\",\n    'ignorestatus' => 1,\n    'receiver' => \\&BSServer::reply_receiver,\n  };\n  if ($view && $view eq 'fileinfo_ext') {\n    my $partition = projid2partition($projid);\n    my $projpack = (getprojpack({'nopackages' => 1, 'withrepos' => 1, 'expandedrepos' => 1, 'withremotemap' => 1, 'withconfig' => 1, 'partition' => $partition}, [ $projid ], [ $repoid ], undef, $arch))[0];\n    if ($projpack) {\n      if ($projpack->{'project'} && $projpack->{'project'}->[0]->{'name'} eq $projid) {\n        my $config = (getbuildconfig({}, $projid, $repoid))[0];\n\t$projpack->{'project'}->[0]->{'config'} = $config if $config;\n      }\n      $param->{'request'} = 'POST';\n      $param->{'data'} = BSUtil::toxml($projpack, $BSXML::projpack);\n      $param->{'headers'} = [ 'Content-Type: application/octet-stream' ];\n    }\n  }\n  if ($proj->{'remoteurl'}) {\n    $param->{'uri'} = \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid/$filename\";\n    $param->{'proxy'} = $proxy;\n  }\n  BSWatcher::rpc($param, undef, @args);\n  return undef;\n}\n\nsub putbinary {\n  my ($cgi, $projid, $repoid, $arch, $filename) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, 'ignoreolder=1' if $cgi->{'ignoreolder'};\n  push @args, 'wipe=1' if $cgi->{'wipe'};\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/_repository/$filename\",\n    'request' => 'PUT',\n    'data' => \\&BSServer::forward_sender,\n    'chunked' => 1,\n  };\n  # XXX add return type checking\n  return BSWatcher::rpc($param, undef, @args);\n}\n\nsub delbinary {\n  my ($cgi, $projid, $repoid, $arch, $filename) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/_repository/$filename\",\n    'request' => 'DELETE',\n  };\n  return BSWatcher::rpc($param, undef);\n}\n\nsub copybuild {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  die(\"illegal package '$packid'\\n\") if $packid =~ /^_/ && !($packid =~ /^_product:/);\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $oprojid = defined($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;\n  my $opackid = defined($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;\n  my $orepoid = defined($cgi->{'orepository'}) ? $cgi->{'orepository'} : $repoid;\n  die(\"nothing to do\\n\") if \"$oprojid/$opackid/$orepoid\" eq \"$projid/$packid/$repoid\";\n  checkprojrepoarch($oprojid, $orepoid, $arch);\n  # make sure the packages exist. not cheap, but does everything we need\n  getrev($projid, $packid);\n  getrev($oprojid, $opackid);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;\n  if ($reposerver ne $oreposerver) {\n    die(\"cannot copy binaries between different reposiory servers yet\\n\");\n  }\n  my @args;\n  push @args, \"cmd=copy\";\n  push @args, \"oproject=$oprojid\";\n  push @args, \"opackage=$opackid\";\n  push @args, \"orepository=$orepoid\";\n  push @args, \"setupdateinfoid=$cgi->{'setupdateinfoid'}\" if $cgi->{'setupdateinfoid'};\n  push @args, \"setrelease=$cgi->{'setrelease'}\" if $cgi->{'setrelease'};\n  push @args, 'resign=1' if $cgi->{'resign'};\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid\",\n    'request' => 'POST',\n  };\n  # XXX add return type checking\n  return BSWatcher::rpc($param, undef, @args);\n}\n\nsub uploadbuild {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  die(\"illegal package '$packid'\\n\") if $packid =~ /^_/ && !($packid =~ /^_product:/);\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid\",\n    'request' => 'POST',\n    'data' => \\&BSServer::forward_sender,\n    'chunked' => 1,\n  };\n  # XXX add return type checking\n  return BSWatcher::rpc($param, undef);\n}\n\n\nsub getlogfile {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n\n  if (!$cgi->{'start'}) {\n    # check if the package is broken\n    my $rev = getrev($projid, $packid, 'build');\n    eval {\n      lsrev_expanded($rev);\n    };\n    if ($@) {\n      my $error = $@;\n      if ($rev->{'srcmd5'}) {\n        my $files = lsrev($rev);\n\tif ($files->{'_serviceerror'}) {\n\t  $error = repreadstr($rev, '_serviceerror', $files->{'_serviceerror'});\n\t} elsif ($files->{'_linkerror'}) {\n\t  $error = repreadstr($rev, '_linkerror', $files->{'_linkerror'});\n\t}\n      }\n      if ($cgi->{'view'} && $cgi->{'view'} eq 'entry') {\n        my $entry = {'name' => '_log', 'size' => length($error)};\n        return ({'entry' => [ $entry ]}, $BSXML::dir);\n      }\n      return $error;\n    }\n  }\n\n  my @args;\n  push @args, 'last' if $cgi->{'last'};\n  push @args, 'nostream' if $cgi->{'nostream'};\n  push @args, \"start=$cgi->{'start'}\" if defined $cgi->{'start'};\n  push @args, \"end=$cgi->{'end'}\" if defined $cgi->{'end'};\n  push @args, \"view=$cgi->{'view'}\" if $cgi->{'view'};\n  if (!$BSStdServer::isajax && !$cgi->{'view'}) {\n    my $url = \"/build/$projid/$repoid/$arch/$packid/_log\";\n    BSHandoff::handoff($ajaxsocket, $url, undef, @args);\n    exit(0);\n  }\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid/_log\",\n    'ignorestatus' => 1,\n    'receiver' => \\&BSServer::reply_receiver,\n    'joinable' => 1,\n  };\n  BSWatcher::rpc($param, undef, @args);\n  return undef; # always streams result\n}\n\nsub getjobstatus {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $jobstatus = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_jobstatus\", $BSXML::jobstatus);\n  return ($jobstatus, $BSXML::jobstatus);\n}\n\nsub getbuildhistory {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, \"limit=$cgi->{'limit'}\" if $cgi->{'limit'};\n  my $buildhist = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_history\", $BSXML::buildhist, @args);\n  return ($buildhist, $BSXML::buildhist);\n}\n\nsub getbuildinfo {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  $arch = $BSConfig::localarch if $arch eq 'local' && defined($BSConfig::localarch);\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, 'internal=1' if $cgi->{'internal'};\n  push @args, 'debug=1' if $cgi->{'debug'};\n  push @args, map {\"add=$_\"} @{$cgi->{'add'} || []};\n  my $buildinfo = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_buildinfo\", $BSXML::buildinfo, @args);\n  return ($buildinfo, $BSXML::buildinfo);\n}\n\nsub getbuildinfo_post {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  $arch = $BSConfig::localarch if $arch eq 'local' && defined($BSConfig::localarch);\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, 'debug=1' if $cgi->{'debug'};\n  push @args, map {\"add=$_\"} @{$cgi->{'add'} || []};\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid/_buildinfo\",\n    'request' => 'POST',\n    'data' => \\&BSServer::forward_sender,\n    'chunked' => 1,\n  };\n  my $buildinfo = BSWatcher::rpc($param, $BSXML::buildinfo, @args);\n  return ($buildinfo, $BSXML::buildinfo);\n}\n\nsub getbuildreason {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $reason = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_reason\", $BSXML::buildreason);\n  return ($reason, $BSXML::buildreason);\n}\n\nsub getbuildstatus {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $status = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_status\", $BSXML::buildstatus);\n  return ($status, $BSXML::buildstatus);\n}\n\nsub getworkerstatus {\n  my ($cgi) = @_;\n  # compat\n  if ($cgi->{'scheduleronly'} && !$cgi->{'daemonsonly'}) {\n    $cgi->{'daemonsonly'} = delete $cgi->{'scheduleronly'};\n  }\n  my @args;\n  push @args, 'daemonsonly' if $cgi->{'daemonsonly'};\n  push @args, map {\"arch=$_\"} @{$cgi->{'arch'} || []};\n\n  if (!$BSConfig::partitioning || !$BSConfig::partitionservers) {\n    my $reposerver = $BSConfig::reposerver;\n    my $ws = BSWatcher::rpc(\"$reposerver/workerstatus\", $BSXML::workerstatus, @args);\n    delete $_->{'uri'} for @{$ws->{'idle'} || []};\n    delete $_->{'uri'} for @{$ws->{'building'} || []};\n    return ($ws, $BSXML::workerstatus);\n  }\n\n  # cummulated worker status\n  my $cws;\n  if (!$cgi->{'daemonsonly'}) {\n    $cws->{'clients'} = 0;\n    $cws->{'building'} = [];\n    $cws->{'waiting'} = [];\n    $cws->{'blocked'} = [];\n    $cws->{'buildavg'} = [];\n    $cws->{'idle'} = [];\n  }\n  $cws->{'partition'} = [];\n\n  my %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);\n  for my $reposerver (sort keys %reposervers) {\n    my $ws = BSWatcher::rpc(\"$reposerver/workerstatus\", $BSXML::workerstatus, @args);\n\n    push @{$cws->{'partition'}}, @{$ws->{'partition'}};\n    next if $cgi->{'daemonsonly'};\n\n    delete $_->{'uri'} for @{$ws->{'idle'} || []};\n    delete $_->{'uri'} for @{$ws->{'building'} || []};\n    push @{$cws->{'idle'}}, @{$ws->{'idle'} || []};\n    push @{$cws->{'building'}}, @{$ws->{'building'} || []};\n    for my $b (@{$ws->{'waiting'} || []}) {\n      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'waiting'} || []})[0];\n      if (!$ob) {\n        $ob = {'arch' => $b->{'arch'}, 'jobs' => 0};\n        push @{$cws->{'waiting'}}, $ob;\n      }\n      $ob->{'jobs'} += $b->{'jobs'};\n    }\n    for my $b (@{$ws->{'blocked'} || []}) {\n      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'blocked'} || []})[0];\n      if (!$ob) {\n        $ob = {'arch' => $b->{'arch'}, 'jobs' => 0};\n        push @{$cws->{'blocked'}}, $ob;\n      }\n      $ob->{'jobs'} += $b->{'jobs'};\n    }\n    for my $b (@{$ws->{'buildavg'} || []}) {\n      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'buildavg'} || []})[0];\n      if (!$ob) {\n        $ob = {'arch' => $b->{'arch'}, 'buildavg' => 0, 'count' => 0};\n        push @{$cws->{'buildavg'}}, $ob;\n      }\n      $ob->{'buildavg'} += $b->{'buildavg'};\n      $ob->{'count'} += 1;\n    }\n    $cws->{'clients'} += $ws->{'clients'} if $ws->{'clients'};\n  }\n  for my $b (@{$cws->{'buildavg'} || []}) {\n    $b->{'buildavg'} /= delete $b->{'count'};\n  }\n\n  # sort\n  if (!$cgi->{'daemonsonly'}) {\n    $cws->{'idle'} = [ sort {$a->{'workerid'} cmp $b->{'workerid'} || $a->{'uri'} cmp $b->{'uri'} || $a cmp $b} @{$cws->{'idle'}} ];\n    $cws->{'building'} = [ sort {$a->{'workerid'} cmp $b->{'workerid'} || $a->{'uri'} cmp $b->{'uri'} || $a cmp $b} @{$cws->{'building'}} ];\n    $cws->{'waiting'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'waiting'}} ];\n    $cws->{'blocked'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'blocked'}} ];\n    $cws->{'buildavg'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'buildavg'}} ];\n  }\n  \n  return ($cws, $BSXML::workerstatus);\n}\n\nsub getajaxstatus {\n  my ($cgi) = @_;\n  if (!$BSStdServer::isajax) {\n    BSHandoff::handoff($ajaxsocket, '/ajaxstatus');\n    exit(0);\n  }\n  my $r = BSWatcher::getstatus();\n  return ($r, $BSXML::ajaxstatus);\n}\n\nsub search_proj {\n  my ($cgi, $match, $id) = @_;\n  $match =~ s/^\\[(.*)\\]$/$1/s;\n  my $data = [];\n  for my $projid (findprojects()) {\n    my $proj = readproj($projid);\n    push @$data, $proj;\n  }\n  $data = BSXPath::match($data, $match);\n  if ($id) {\n    for (@{$data || []}) {\n      $_ = {'name' => $_->{'name'}};\n    }\n  }\n  my $res = {'project' => $data};\n  return ($res, $BSXML::collection);\n}\n\nsub pkgsearch_fetch {\n  my ($db, $k) = @_;\n  my ($projid, $packid) = split('/', $k, 2);\n  my $pack = readpack($projid, $packid, 1) || {'name' => $packid};\n  $pack->{'project'} = $projid;\n  #my @linkinfo = BSDBIndex::getvalues($db, 'linkinfo', $k);\n  #$pack->{'linkinfo'} = $linkinfo[0] if @linkinfo;\n  return $pack;\n}\n\nsub pkgsearch_indexfunc {\n  my ($db, $path, $value, $lkeys) = @_;\n  if (!defined($path)) {\n    return @{$db->{'_allkeys'}} if $db->{'_allkeys'};\n    my @projids = findprojects();\n    my @r;\n    for my $projid (@projids) {\n      push @r, map {\"$projid/$_\"} findpackages($projid, {}, 1);\n    }\n    $db->{'_allkeys'} = \\@r;\n    return @r;\n  } elsif (!defined($value)) {\n    return BSDBIndex::getkeys($db, \"$db->{'index'}$path\") if $path =~ /^linkinfo\\//;\n    return findprojects() if $path eq 'project';\n    if ($path eq 'name') {\n      $lkeys = [ pkgsearch_indexfunc($db) ] unless $lkeys;\n      my %v = map {$_ => 1} grep {s/^.*\\///} map {$_} @$lkeys;\n      return sort keys %v;\n    }\n  } else {\n    return BSDBIndex::getvalues($db, \"$db->{'index'}$path\", $value) if $path =~ /^linkinfo\\//;\n    return map {\"$value/$_\"} findpackages($value, {}, 1) if $path eq 'project';\n    if ($path eq 'name') {\n      $lkeys = [ pkgsearch_indexfunc($db) ] unless $lkeys;\n      return grep {/\\Q$value\\E$/} @$lkeys;\n    }\n  }\n  return ();\n}\n\nsub search_pack {\n  my ($cgi, $match, $id) = @_;\n  $match =~ s/^\\[(.*)\\]$/$1/s;\n  # really ugly hack to speed up needed api call\n  if ($match =~ /^\\@project='(.+)' and starts-with\\(\\@name,'(.+)'\\)$/) {\n    my $projid = $1;\n    my $startswith = $2;\n    $projid =~ s/''/'/g;\n    $startswith =~ s/''/'/g;\n    my @packages = findpackages($projid, {});\n    my $data = [];\n    for my $packid (grep {/^\\Q$startswith\\E/} @packages) {\n      my ($pack, undef) = getpackage($cgi, $projid, $packid);\n      $pack->{'project'} = $projid;\n      push @$data, $pack;\n    }\n    my $res = {'package' => $data};\n    return ($res, $BSXML::collection);\n  }\n  my $db = BSDB::opendb($sourcedb, '');\n  $db->{'indexfunc'} = {\n    'project' => \\&pkgsearch_indexfunc,\n    'name' => \\&pkgsearch_indexfunc,\n    'linkinfo/project' => \\&pkgsearch_indexfunc,\n    'linkinfo/package' => \\&pkgsearch_indexfunc,\n    'linkinfo/rev' => \\&pkgsearch_indexfunc,\n  };\n  $db->{'noindexatall'} = 1;\n  $db->{'fetch'} = \\&pkgsearch_fetch;\n  my $data = BSXPathKeys::node($db, '');\n  if ($id) {\n    $data = $data->keymatch($match);\n    for (@$data) {\n      my @p = split('/', $_, 2);\n      $_ = {'name' => $p[1], 'project' => $p[0]};\n    }\n  } else {\n    $data = BSXPath::match($data, $match);\n    delete $_->{'linkinfo'} for @$data;\n  }\n  my $res = {'package' => $data};\n  return ($res, $BSXML::collection);\n}\n\nsub search_proj_id {\n  return search_proj(@_, 1);\n}\n\nsub search_pack_id {\n  return search_pack(@_, 1);\n}\n\n#############################################################################\n\nsub search_published_updatedb {\n  my ($cgi) = @_;\n  die(\"unknown command '$cgi->{'cmd'}'\\n\") unless $cgi->{'cmd'} eq 'updatedb';\n  my $data = BSServer::read_data();\n  $data = Storable::thaw($data);\n  die(\"no data\\n\") unless $data && @$data;\n  my $patterndb;\n  my $binarydb;\n  my $repoinfodb;\n  mkdir_p($extrepodb) unless -d $extrepodb;\n  while (@$data) {\n    my ($w, $k, $v) = splice(@$data, 0, 3);\n    if ($w eq 'binary') {\n      $binarydb = BSDB::opendb($extrepodb, 'binary') unless $binarydb;\n      $binarydb->updateindex_rel($k || [], $v || []);\n    } elsif ($w eq 'pattern') {\n      $patterndb = BSDB::opendb($extrepodb, 'pattern') unless $patterndb;\n      $patterndb->store($k, $v);\n    } elsif ($w eq 'repoinfo') {\n      if (!$repoinfodb) {\n        $repoinfodb = BSDB::opendb($extrepodb, 'repoinfo');\n        $repoinfodb->{'noindexatall'} = 1;\n      }\n      $repoinfodb->store($k, $v);\n    } else {\n      die(\"bad data type: '$w'\\n\");\n    }\n  }\n  return $BSStdServer::return_ok;\n}\n\n#sub search_published_id {\n#  my ($cgi, $what, $match) = @_;\n#  my $res;\n#  for my $rrserver ($BSConfig::reposerver) {\n#    $res = BSRPC::rpc(\"$rrserver/search/published/$what/id\", $BSXML::collection, \"match=$match\");\n#    last if $res;\n#  }\n#  return ($res, $BSXML::collection);\n#}\n#\n#sub search_published_binary_id {\n#  return search_published_id($_[0], 'binary', $_[1]);\n#}\n#\n#sub search_published_pattern_id {\n#  return search_published_id($_[0], 'pattern', $_[1]);\n#}\n\nmy %prp_to_repoinfo;\n\nsub prp_to_repoinfo {\n  my ($prp) = @_;\n\n  my $repoinfo = $prp_to_repoinfo{$prp};\n  if (!$repoinfo) {\n    my $repoinfodb = BSDB::opendb($extrepodb, 'repoinfo');\n    $repoinfo = $repoinfodb->fetch($prp);\n    if ($repoinfo) {\n      for (@{$repoinfo->{'prpsearchpath'} || []}) {\n\tnext if ref($_);\t# legacy\n\tmy ($p, $r) = split('/', $_, 2);\n\t$_ = {'project' => $p, 'repository' => $r};\n      }\n    } else {\n      $repoinfo = {'binaryorigins' => {}};\n    }\n    $prp_to_repoinfo{$prp} = $repoinfo;\n  }\n  return $repoinfo;\n}\n\nsub binary_key_to_data {\n  my ($db, $key) = @_; \n  my @p = split('/', $key);\n  my $binary = pop(@p);\n  my $name = $binary;\n  my $versrel = '';\n  if ($name =~ s/-([^-]+-[^-]+)\\.[^\\.]+\\.rpm$//) {\n    $versrel = $1;\n  } elsif ($name =~ s/_([^_]+)_[^_]+\\.deb$//) {\n    $versrel = $1;\n  } elsif ($name =~ s/-([^-]+-[^-]+)-[^-]+\\.pkg\\.tar\\..z$//) {\n    $versrel = $1;\n  }\n  my ($version, $release) = ($versrel, undef);\n  ($version, $release) = ($1, $2) if $version =~ /^(.*)-(.*?)$/;\n  my $arch = pop(@p);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  my $project = shift(@p);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  my $repository = shift(@p);\n  my $prp = \"$project/$repository\";\n  my $repoinfo = $prp_to_repoinfo{$prp} || prp_to_repoinfo($prp);\n  my $type;\n  $type = 'rpm' if $binary =~ /\\.rpm$/;\n  $type = 'deb' if $binary =~ /\\.deb$/;\n  $type = 'arch' if $binary =~ /\\.pkg\\.tar\\..z$/;\n  my $res = {\n    'name' => $name,\n    'versrel' => $versrel,\n    'version' => $version,\n    'arch' => $arch,\n    'type' => $type,\n    'project' => $project,\n    'repository' => $repository,\n    'filename' => $binary,\n    'filepath' => $key,\n  };\n  $res->{'release'} = $release if defined $release;\n  $res->{'path'} = $repoinfo->{'prpsearchpath'} if $repoinfo->{'prpsearchpath'};\n  my $location = join('/', @p, $arch, $binary);\n  $res->{'package'} = $repoinfo->{'binaryorigins'}->{$location} if defined $repoinfo->{'binaryorigins'}->{$location};\n  if ($repoinfo->{'base'}) {\n    $res->{'baseproject'} = $repoinfo->{'base'}->{'project'};\n  } elsif ($res->{'path'}) {\n    $res->{'baseproject'} = $res->{'path'}->[-1]->{'project'};\n  }\n  return $res;\n}\n\nsub binary_key_to_project {\n  my ($db, $key) = @_;  \n  my @p = split('/', $key);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  return shift @p;\n}\n\nsub pattern_key_to_data {\n  my ($db, $key) = @_; \n  my @p = split('/', $key);\n  my $filename = pop(@p);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  my $project = shift(@p);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  my $repository = shift(@p);\n  my @v = BSDBIndex::getvalues($db, $db->{'table'}, $key);\n  return {} unless @v;\n  my $res = $v[0];\n  $res->{'baseproject'} = $res->{'path'}->[-1]->{'project'} if $res->{'path'};\n  $res->{'project'} = $project;\n  $res->{'repository'} = $repository;\n  $res->{'filename'} = $filename;\n  $res->{'filepath'} = $key;\n  return $res;\n}\n\nsub published_projectindexfunc {\n  my ($db, $path, $value) = @_;\n  return findprojects() unless defined $value;\n  my $proj = readproj($value);\n  return () unless $proj;\n  my @repoids = map {$_->{'name'}} @{$proj->{'repository'} || []};\n  my %bins;\n  for my $repoid (@repoids) {\n    my $prp = \"$value/$repoid\";\n    my $prp_ext = $prp;\n    $prp_ext =~ s/:/:\\//g;\n    my $repoinfo = $prp_to_repoinfo{$prp} || prp_to_repoinfo($prp);\n    for (keys %{$repoinfo->{'binaryorigins'} || {}}) {\n      next unless /\\//;\n      # keep in sync with updatebinaryindex in bs_publish\n      next unless /\\.(?:rpm|deb|pkg\\.tar\\..z)$/;\n      $bins{\"$prp_ext/$_\"} = 1;\n    }\n  }\n  return sort keys %bins;\n}\n\nsub search_published_binary_id {\n  my ($cgi, $match) = @_;\n  my $binarydb = BSDB::opendb($extrepodb, 'binary');\n  $binarydb->{'allkeyspath'} = 'name';\n  $binarydb->{'noindex'} = {'version' => 1, 'release' => 1, 'versrel' => 1, 'arch' => 1, 'project' => 1, 'repository' => 1, 'package' => 1, 'type' => 1, 'path/project' => 1, 'path/repository' => 1, 'baseproject' => 1};\n  $binarydb->{'indexfunc'} = {'project' => \\&published_projectindexfunc };\n  $binarydb->{'fetch'} = \\&binary_key_to_data;\n  $binarydb->{'fetch_project'} = \\&binary_key_to_project;\n  $binarydb->{'cheapfetch'} = 1;\n  my $limit = defined($cgi->{'limit'}) ? $cgi->{'limit'} : 1000;\n  my $rootnode = BSXPathKeys::node($binarydb, '', $limit && $limit < 10 ? 1000 : $limit * 100);\n  my $data = BSXPath::match($rootnode, $match) || [];\n  # epoch?\n  @$data = sort {Build::Rpm::verscmp($b->{'version'}, $a->{'version'}) || $a->{'name'} cmp $b->{'name'} || $a->{'arch'} cmp $b->{'arch'}} @$data;\n  delete $_->{'versrel'} for @$data;\n  my $res = {};\n  $res->{'matches'} = @$data;\n  $res->{'limited'} = 'true' if $limit && @$data > $limit;\n  splice(@$data, $limit) if $limit && @$data > $limit;\n  delete $_->{'path'} for @$data;\n  $res->{'binary'} = $data;\n  return ($res, $BSXML::collection);\n}\n\nsub search_published_pattern_id {\n  my ($cgi, $match) = @_;\n  my $patterndb = BSDB::opendb($extrepodb, 'pattern');\n  $patterndb->{'noindex'} = {'project' => 1, 'repository' => 1};\n  $patterndb->{'fetch'} = \\&pattern_key_to_data;\n  my $limit = defined($cgi->{'limit'}) ? $cgi->{'limit'} : 1000;\n  my $rootnode = BSXPathKeys::node($patterndb, '', $limit && $limit < 10 ? 1000 : $limit * 100);\n  my $data = BSXPath::match($rootnode, $match) || [];\n  my $res = {};\n  $res->{'matches'} = @$data;\n  $res->{'limited'} = 'true' if $limit && @$data > $limit;\n  splice(@$data, $limit) if $limit && @$data > $limit;\n  for (@$data) {\n    delete $_->{'path'};\n    delete $_->{'description'};\n    delete $_->{'summary'};\n  }\n  $res->{'pattern'} = $data;\n  return ($res, $BSXML::collection);\n}\n\n#############################################################################\n\nsub search {\n  my ($cgi, $in, $match) = @_;\n  # gather all data\n  my $data = [];\n  if ($in eq 'projects') {\n    for my $projid (findprojects()) {\n      my $proj = readproj($projid);\n      push @$data, $proj;\n    }\n  } elsif ($in eq 'packages') {\n    for my $projid (findprojects()) {\n      my @packages = findpackages($projid, {});\n      for my $packid (@packages) {\n        my ($pack, undef) = getpackage($cgi, $projid, $packid);\n\t$pack->{'project'} = $projid;\n        push @$data, $pack;\n      }\n    }\n  } else {\n    die(\"'in' parameter needs to be either 'projects' or 'packages'\\n\");\n  }\n  my $res;\n  if ($cgi->{'values'}) {\n    $data = BSXPath::valuematch($data, $match);\n    $res = {'value' => $data};\n  } else {\n    $data = BSXPath::match($data, $match);\n    if (exists $cgi->{'return'}) {\n      $data = BSXPath::valuematch($data, $cgi->{'return'});\n      $res = {'value' => $data};\n    } elsif ($in eq 'projects') {\n      $res = {'project' => $data};\n    } else {\n      $res = {'package' => $data};\n    }\n  }\n  return ($res, $BSXML::collection);\n}\n\nsub postrepo {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/_repository\",\n    'request' => 'POST',\n  };\n  my $res = BSWatcher::rpc($param, $BSXML::collection, \"match=$cgi->{'match'}\");\n  return ($res, $BSXML::collection);\n}\n\nsub service {\n  my ($cgi, $service) = @_;\n  die(\"404 no such service '$service'\\n\") unless $BSConfig::serviceserver;\n  return BSWatcher::rpc(\"$BSConfig::serviceserver/service/$service\", undef);\n}\n\nsub listservices {\n  my ($cgi) = @_;\n  return \"<servicelist/>\\n\" unless $BSConfig::serviceserver;\n  return BSWatcher::rpc(\"$BSConfig::serviceserver/service\", undef);\n}\n\nsub published {\n  my ($cgi, $projid, $repoid, $arch, $filename, $subfilename) = @_;\n  my @args;\n  my $projpack;\n  die(\"unknown view '$cgi->{'view'}'\\n\") if $cgi->{'view'} && $cgi->{'view'} ne 'ymp' && $cgi->{'view'} ne 'fileinfo';\n  if (defined($projid) && defined($repoid) && $cgi->{'view'} && $cgi->{'view'} eq 'ymp') {\n    # attach projpack data so that the repo server does not need to\n    # reconnect us\n    $projpack = (getprojpack({'nopackages' => 1, 'withrepos' => 1, 'expandedrepos' => 1}, [ $projid ], [ $repoid ], undef, 'noarch'))[0];\n    my $proj = $projpack->{'project'}->[0];\n    die(\"no such project\\n\") unless $proj && $proj->{'name'} eq $projid;\n    my $repo = $proj->{'repository'}->[0];\n    die(\"no such repository\\n\") unless $repo && $repo->{'name'} eq $repoid;\n    $projpack->{'project'} = [ $proj ];\n    my @nprojids = grep {$_ ne $projid} map {$_->{'project'}} @{$repo->{'path'} || []};\n    @nprojids = unify(@nprojids);\n    for my $nprojid (@nprojids) {\n      my $nproj = (getproject({}, $nprojid))[0];\n      push @{$projpack->{'project'}}, {\n\t'name' => $nprojid,\n\t'title' => $nproj->{'title'} || '',\n\t'description' => $nproj->{'description'} || '',\n      };\n    }\n  }\n  push @args, \"view=$cgi->{'view'}\" if $cgi->{'view'};\n  my $p = \"/published\";\n  $p .= \"/$projid\" if defined $projid;\n  $p .= \"/$repoid\" if defined $repoid;\n  $p .= \"/$arch\" if defined $arch;\n  $p .= \"/$filename\" if defined $filename;\n  $p .= \"/$subfilename\" if defined $subfilename;\n  if (defined($projid) || !$BSConfig::partitioning || !$BSConfig::partitionservers) {\n    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n    my $param = {\n      'uri' => \"$reposerver$p\",\n      'ignorestatus' => 1,\n      'receiver' => \\&BSServer::reply_receiver,\n    };\n    if ($projpack) {\n      $param->{'request'} = 'POST';\n      $param->{'data'} = BSUtil::toxml($projpack, $BSXML::projpack);\n      $param->{'headers'} = [ 'Content-Type: application/octet-stream' ];\n    }\n    BSWatcher::rpc($param, undef, @args);\n    return undef;\n  }\n  my %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);\n  my %pubprojids;\n  for my $reposerver (sort keys %reposervers) {\n    my $res;\n    eval {\n      $res = BSWatcher::rpc(\"$reposerver/published\", $BSXML::dir, @args);\n    };\n    warn($@) if $@;\n    next unless $res;\n    $pubprojids{$_->{'name'}} = 1 for @{$res->{'entry'} || []};\n  }\n  my @res = sort(keys %pubprojids);\n  @res = map {{'name' => $_}} @res;\n  return ({'entry' => \\@res}, $BSXML::dir);\n}\n\nmy $extrepodir = \"$BSConfig::bsdir/repos\";\n\nsub map_to_extrep {\n  my ($prp, $prp_ext) = @_;\n  \n  my $extrep = \"$BSConfig::bsdir/repos/$prp_ext\";\n  return $extrep unless $BSConfig::publishredirect;\n  if ($BSConfig::publishedredirect_use_regex || $BSConfig::publishedredirect_use_regex) {\n    for my $key (sort {$b cmp $a} keys %{$BSConfig::publishredirect}) {\n      if ($prp =~ /^$key/) {\n        $extrep = $BSConfig::publishredirect->{$key};\n        last;\n      }    \n    }    \n  } elsif (exists($BSConfig::publishredirect->{$prp})) {\n    $extrep = $BSConfig::publishredirect->{$prp};\n  }\n  $extrep = $extrep->($prp, $prp_ext) if $extrep && ref($extrep) eq 'CODE';\n  return $extrep;\n}\n\nsub published_path {\n  my ($cgi, $projid, $repoid) = @_;\n  my $medium = $cgi->{'medium'};\n  my $prp = \"$projid/$repoid\";\n  my $prp_ext = $prp;\n  my $ret = {'project' => $projid, 'repository' => $repoid};\n  $ret->{'medium'} = $medium if $medium;\n  $prp_ext =~ s/:/:\\//g;\n  my $extrep = map_to_extrep($prp, $prp_ext);\n  $extrep = [ $extrep ] unless ref $extrep;\n  my ($path, $url) = ($extrep->[1], $extrep->[2]);\n  # update to get fresh version of repodownload\n  BSConfiguration::update_from_configuration();\n  if ($BSConfig::prp_ext_map && $BSConfig::prp_ext_map->{$prp}) {\n    $url = $BSConfig::prp_ext_map->{$prp} unless defined $url;\n  }\n  if ($extrep->[0] =~ /^\\Q$BSConfig::bsdir\\E\\/repos\\/(.*)$/) {\n    $path = $1 unless defined $path;\n    if ($BSConfig::repodownload) {\n      $url = \"$BSConfig::repodownload/\".BSRPC::urlencode($1) unless defined $url;\n    }\n  }\n  if ($cgi->{'filename'}) {\n    # called from getbinary\n    my $bin = $cgi->{'filename'};\n    my $p;\n    if ($bin =~ /^.+-[^-]+-[^-]+\\.([a-zA-Z][^\\/\\.\\-]*)\\.d?rpm$/) {\n      $p = \"$1/$bin\";\n    } elsif ($bin =~ /^.+_[^_]+_([^_\\.]+)\\.deb$/) {\n      $p = \"$1/$bin\";\n    } elsif ($bin =~ /\\.exe$/) {\n      $p = $bin;\n    } elsif ($bin =~ /\\.(?:pkg\\.tar\\.gz|pkg\\.tar\\.xz)$/) {\n      $p = ($cgi->{'arch'} eq 'i586' ? 'i686' : $cgi->{'arch'}).\"/$bin\";\n    } elsif ($bin =~ /\\.iso(?:\\.report)$/) {\n      $p = \"iso/$bin\";\n    } elsif ($bin =~ /-Media\\d+$/) {\n      $medium = $bin;\n    }\n    if (defined $p) {\n      $path .= \"/$p\" if defined $path;\n      $url .= \"/\".BSRPC::urlencode($p) if defined $url;\n    }\n  }\n  if ($medium && $medium =~ /\\.iso$/) {\n    $medium = \"iso/$medium\";\n  } elsif ($medium) {\n    my @path = expandsearchpath($projid, $repoid);\n    my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);\n    my $bconf = Build::read_config('noarch', [ split(\"\\n\", $c) ]);\n    my %repotype;\n    for (@{$bconf->{'repotype'} || []}) {\n      if (/^(.*?):(.*)$/) {\n        $repotype{$1} = [ split(':', $2) ];\n      } else {\n        $repotype{$_} = [];\n      }    \n    }\n    if ($repotype{'slepool'}) {\n      my $name = $repotype{'slepool'}->[0] || 'product';\n      if ($medium =~ /-Media1$/) {\n\t$medium = $name;\n      } elsif ($medium =~ /-Media3$/) {\n\t$medium = \"${name}_debug\";\n      } elsif ($medium =~ /-Media2$/) {\n        my $repoinfo;\n\teval {\n\t  $repoinfo = $prp_to_repoinfo{$prp};\n\t};\n\tmy $binaryorigins = ($repoinfo || {})->{'binaryorigins'};\n\t$medium = $binaryorigins->{\"${name}_source\"} ? \"${name}_source\" : \"${name}_debug\";\n      }\n    } else {\n      $medium = \"repo/$medium\";\n    }\n  }\n  if ($medium) {\n    $path .= \"/$medium\" if defined $path;\n    $url .= \"/\".BSRPC::urlencode($medium) if defined $url;\n  }\n  $ret->{'path'} = $path if defined $path;\n  $ret->{'url'} = $url if defined $url;\n  return ($ret, $BSXML::publishedpath);\n}\n  \n\nsub pkdecodetaglenoff {\n  my ($pkg) = @_;\n  my $tag = unpack('C', $pkg);\n  die(\"not a gpg packet\\n\") unless $tag & 128;\n  my $len;\n  my $off = 1;\n  if ($tag & 64) {\n    # new packet format\n    $tag &= 63; \n    $len = unpack('C', substr($pkg, 1));\n    if ($len < 192) {\n      $off = 2;\n    } elsif ($len != 255) {\n      $len = (($len - 192) << 8) + unpack('C', substr($pkg, 2)) + 192;\n      $off = 3;\n    } else {\n      $len = unpack('N', substr($pkg, 2));\n      $off = 5;\n    }   \n  } else {\n    # old packet format\n    if (($tag & 3) == 0) {\n      $len = unpack('C', substr($pkg, 1));\n      $off = 2;\n    } elsif (($tag & 3) == 1) {\n      $len = unpack('n', substr($pkg, 1));\n      $off = 3;\n    } elsif (($tag & 3) == 1) {\n      $len = unpack('N', substr($pkg, 1));\n      $off = 6;\n    } else {\n      die(\"can't deal with not specified packet length\\n\");\n    }   \n    $tag = ($tag & 60) >> 2;\n  }\n  return ($tag, $len, $off);\n}\n\nsub pk2expire {\n  my ($pk) = @_;\n  # oh my! hard work!\n  $pk =~ s/.*\\n\\n//s;\n  $pk =~ s/\\n=.*/\\n/s;\n  $pk = MIME::Base64::decode($pk);\n  return 0 unless $pk;\n  my ($rex, $rct);\n  eval {\n    while ($pk ne '') {\n      my ($tag, $len, $off) = pkdecodetaglenoff($pk);\n      my $pack = substr($pk, $off, $len);\n      $pk = substr($pk, $len + $off);\n      next if $tag != 2;\n      my $sver = unpack('C', substr($pack, 0, 1));\n      next unless $sver == 4;\n      my $stype = unpack('C', substr($pack, 1, 1));\n      next unless $stype == 19; # positive certification of userid and pubkey\n      my $plen = unpack('n', substr($pack, 4, 2));\n      $pack = substr($pack, 6, $plen);\n      my ($ct, $ex);\n      while ($pack ne '') {\n        $pack = pack('C', 0xc0).$pack;\n        my ($stag, $slen, $soff) = pkdecodetaglenoff($pack);\n        my $spack = substr($pack, $soff, $slen);\n        $pack = substr($pack, $slen + $soff);\n        $stag = unpack('C', substr($spack, 0, 1));\n        $ct = unpack('N', substr($spack, 1, 4)) if $stag == 2;\n        $ex = unpack('N', substr($spack, 1, 4)) if $stag == 9;\n      }\n      $rex = $ex if defined($ex) && (!defined($rex) || $rex > $ex);\n      $rct = $ct if defined($ct) && (!defined($rct) || $rct > $ct);\n    }\n  };\n  return 0 if $@;\n  return defined($rct) && defined($rex) ? $rct + $rex : undef;\n}\n\nsub getsignkey {\n  my ($cgi, $projid) = @_;\n\n  while ($projid ne '') {\n    my $sk = readstr(\"$projectsdir/$projid.pkg/_signkey\", 1);\n    if ($sk) {\n      if ($cgi->{'withpubkey'}) {\n        my $pk = readstr(\"$projectsdir/$projid.pkg/_pubkey\", 1);\n        if ($pk && $cgi->{'autoextend'}) {\n\t  my $expiredate = pk2expire($pk);\n\t  if ($expiredate && $expiredate < time() + 24 * 3600) {\n\t    extendkey({'comment' => 'auto-extend public key expiry date'}, $projid);\n            $pk = readstr(\"$projectsdir/$projid.pkg/_pubkey\", 1);\n\t  }\n\t}\n        $sk .= \"\\n\" unless $sk =~ /\\n$/s;\n        $sk .= $pk;\n      }\n      return ($sk, 'Content-Type: text/plain') if $sk;\n    }\n    $projid =~ s/[^:]*$//;\n    $projid =~ s/:$//;\n  }\n  return ('', 'Content-Type: text/plain');\n}\n\nsub getsslcert {\n  my ($cgi, $projid) = @_;\n\n  my $origprojid = $projid;\n  while ($projid ne '') {\n    my $sk = readstr(\"$projectsdir/$projid.pkg/_signkey\", 1);\n    if (!$sk) {\n      $projid =~ s/[^:]*$//;\n      $projid =~ s/:$//;\n      next;\n    }\n    my $pk = readstr(\"$projectsdir/$projid.pkg/_pubkey\", 1);\n    if ($pk && $cgi->{'autoextend'}) {\n      my $expiredate = pk2expire($pk);\n      if ($expiredate && $expiredate < time() + 24 * 3600) {\n        extendkey({'comment' => 'auto-extend public key expiry date'}, $projid);\n      }\n    }\n    my $rev = getrev_meta($projid, undef);\n    my $files = lsrev($rev);\n    my $cert;\n    if (!$files->{'_sslcert'}) {\n      # length(signkey) <= 2 means special handling, don't commit it\n      if (length($sk) <= 2) {\n        $cert = pubkey2sslcert($origprojid, \"$projectsdir/$projid.pkg/_pubkey\");\n        return ($cert, 'Content-Type: text/plain');\n      }\n      $cert = pubkey2sslcert($projid);\n      mkdir_p($uploaddir);\n      writestr(\"$uploaddir/sslcert.$$\", undef, $cert);\n      addrev_meta({'comment' => 'automatic cert creation'}, $projid, undef, \"$uploaddir/sslcert.$$\", undef, '_sslcert');\n    } else {\n      $cert = repreadstr($rev, '_sslcert', $files->{'_sslcert'});\n    }\n    return ($cert, 'Content-Type: text/plain');\n  }\n  if ($BSConfig::sign_project && $BSConfig::sign) {\n    # request default cert\n    my $cert = '';\n    local *F;\n    open(F, '-|', $BSConfig::sign, '--project', $origprojid, '-C') || die(\"$BSConfig::sign: $!\\n\");\n    1 while sysread(F, $cert, 4096, length($cert));\n    close(F) || die(\"$BSConfig::sign: $?\\n\");\n    return ($cert, 'Content-Type: text/plain');\n  }\n  return ('', 'Content-Type: text/plain');\n}\n\n####################################################################\n\n# needed for migrations to 2.4\nsub getlastidrequest {\n  my $lastid = readstr(\"$requestsdir/.nextid\", 1) - 1;\n  \n  return (\"$lastid\", 'Content-Type: text/plain');\n}\n\n# needed for migrations to 2.4\nsub getrequest {\n  my ($cgi, $id) = @_;\n  local *F;\n  my $rdir = $requestsdir;\n  if (!open(F, '<', \"$rdir/$id\")) {\n    $rdir = $oldrequestsdir;\n    if (!open(F, '<', \"$rdir/$id\")) {\n      die(\"404 no such request '$id'\\n\");\n    }\n  }\n  my $reqxml = '';\n  1 while sysread(F, $reqxml, 8192, length($reqxml));\n  my @s = stat(F);\n  close F;\n  die unless @s;\n  my $req = XMLin($BSXML::request, $reqxml);\n  return ($req, $BSXML::request);\n}\n\n####################################################################\n\nsub findremote {\n  my ($projid) = @_;\n\n  my $proj = readproj($projid, 1);\n  if ($proj) {\n    if (!$proj->{'remoteurl'}) {\n      my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n      return ($reposerver, $projid, undef);\n    }\n    die(\"no remoteproject specified\\n\") unless $proj->{'remoteproject'};\n    return ($proj->{'remoteurl'}, $proj->{'remoteproject'}, $proxy);\n  }\n  my $origprojid = $projid;\n  my $rsuf = '';\n  while ($projid =~ /^(.*)(:.*?)$/) {\n    $projid = $1;\n    $rsuf = \"$2$rsuf\";\n    $proj = readproj($projid, 1);\n    next unless $proj;\n    die(\"404 project '$origprojid' does not exist\\n\") unless $proj->{'remoteurl'};\n    if ($proj->{'remoteproject'}) {\n      return ($proj->{'remoteurl'}, \"$proj->{'remoteproject'}$rsuf\", $proxy);\n    }\n    $rsuf =~ s/^://;\n    return ($proj->{'remoteurl'}, $rsuf, $proxy);\n  }\n  die(\"404 project '$origprojid' does not exist\\n\");\n}\n\nsub worker_getbinaries {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  if (!$BSStdServer::isajax) {\n    my @args;\n    push @args, \"project=$projid\";\n    push @args, \"repository=$repoid\";\n    push @args, \"arch=$arch\";\n    push @args, \"binaries=$cgi->{'binaries'}\";\n    BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);\n    exit(0);\n  }\n  my @binaries = split(',', $cgi->{'binaries'});\n  my ($remoteurl, $remoteprojid, $remoteproxy) = findremote($projid);\n\n  my $jev = $BSServerEvents::gev;\n  my $binarylist;\n  $binarylist = $jev->{'binarylist'} if $BSStdServer::isajax;\n  $binarylist ||= {};\n  $jev->{'binarylist'} = $binarylist if $BSStdServer::isajax;\n\n  # fill binarylist\n  my @missing = grep {!exists $binarylist->{$_}} @binaries;\n  while (@missing) {\n    my $param = {\n      'uri' => \"$remoteurl/build/$remoteprojid/$repoid/$arch/_repository\",\n      'proxy' => $remoteproxy,\n    };\n    # chunk it\n    my $binchunkl = 0;\n    for (splice @missing) {\n      $binchunkl += 10 + length($_);\n      last if @missing && $binchunkl > 1900;\n      push @missing, $_;\n    }\n    my $binarylistcpio = BSWatcher::rpc($param, $BSXML::binarylist, \"view=names\", map {\"binary=$_\"} @missing);\n    return undef if $BSStdServer::isajax && !$binarylistcpio;\n    for my $b (@{$binarylistcpio->{'binary'} || []}) {\n      my $bin = $b->{'filename'};\n      $bin =~ s/\\.(?:$binsufsre)$//;\n      $binarylist->{$bin} = $b;\n    }\n    # make sure that we don't loop forever if the server returns incomplete data\n    for (@missing) {\n      $binarylist->{$_} = {'filename' => $_, 'size' => 0} unless $binarylist->{$_};\n    }\n    @missing = grep {!exists $binarylist->{$_}} @binaries;\n  }\n\n  my @fetch;\n  my @reply;\n  local *LOCK;\n  mkdir_p($remotecache);\n  BSUtil::lockopen(\\*LOCK, '>>', \"$remotecache/lock\");\n  for my $bin (@binaries) {\n    my $b = $binarylist->{$bin};\n    if (!$b || !$b->{'size'} || !$b->{'mtime'}) {\n      push @reply, {'name' => $bin, 'error' => 'not available'};\n      next;\n    }\n    my $cachemd5 = Digest::MD5::md5_hex(\"$projid/$repoid/$arch/$bin\");\n    substr($cachemd5, 2, 0, '/');\n    my @s = stat(\"$remotecache/$cachemd5\");\n    if (!@s || $s[9] != $b->{'mtime'} || $s[7] != $b->{'size'}) {\n      push @fetch, $bin;\n    } else {\n      utime time(), $s[9], \"$remotecache/$cachemd5\";\n      push @reply, {'name' => $b->{'filename'}, 'filename' => \"$remotecache/$cachemd5\"};\n    }\n  }\n  my $slot = sprintf(\"%02x\", (int(rand(256))));\n  print \"cleaning slot $slot\\n\";\n  if (-d \"$remotecache/$slot\") {\n    my $now = time();\n    my $num = 0;\n    for my $f (ls(\"$remotecache/$slot\")) {\n      my @s = stat(\"$remotecache/$slot/$f\");\n      next if $s[8] >= $now - 24*3600;\n      unlink(\"$remotecache/$slot/$f\");\n      $num++;\n    }\n    print \"removed $num unused files\\n\" if $num;\n  }\n  close(LOCK);\n\n  if (@fetch) {\n    my $serialmd5 = Digest::MD5::md5_hex(\"$projid/$repoid/$arch\");\n\n    # serialize this upload\n    my $serial = BSWatcher::serialize(\"$remotecache/$serialmd5.lock\");\n    return undef unless $serial;\n\n    print \"fetch: @fetch\\n\";\n    my %fetch = map {$_ => $binarylist->{$_}} @fetch;\n    my $param = {\n      'uri' => \"$remoteurl/build/$remoteprojid/$repoid/$arch/_repository\",\n      'receiver' => \\&BSHTTP::cpio_receiver,\n      'tmpcpiofile' => \"$remotecache/upload$serialmd5.cpio\",\n      'directory' => $remotecache,\n      'map' => \"upload$serialmd5:\",\n      'proxy' => $remoteproxy,\n    };\n    # work around api bug: only get 50 packages at a time\n    @fetch = splice(@fetch, 0, 50) if @fetch > 50;\n    my $cpio = BSWatcher::rpc($param, undef, \"view=cpio\", map {\"binary=$_\"} @fetch);\n    return undef if $BSStdServer::isajax && !$cpio;\n    for my $f (@{$cpio || []}) {\n      my $bin = $f->{'name'};\n      $bin =~ s/^upload.*?://;\n      $bin =~ s/\\.(?:$binsufsre)$//;\n      if (!$fetch{$bin}) {\n        unlink(\"$remotecache/$f->{'name'}\");\n\tnext;\n      }\n      $binarylist->{$bin}->{'size'} = $f->{'size'};\n      $binarylist->{$bin}->{'mtime'} = $f->{'mtime'};\n      my $cachemd5 = Digest::MD5::md5_hex(\"$projid/$repoid/$arch/$bin\");\n      substr($cachemd5, 2, 0, '/');\n      mkdir_p(\"$remotecache/\".substr($cachemd5, 0, 2));\n      rename(\"$remotecache/$f->{'name'}\", \"$remotecache/$cachemd5\");\n      push @reply, {'name' => $fetch{$bin}->{'filename'}, 'filename' => \"$remotecache/$cachemd5\"};\n      delete $fetch{$bin};\n    }\n    BSWatcher::serialize_end($serial);\n\n    if (@{$cpio || []} >= 50) {\n      # work around api bug: get rest\n      delete $jev->{'binarylist'} if $BSStdServer::isajax;\n      return worker_getbinaries($cgi, $projid, $repoid, $arch);\n    }\n\n    for (sort keys %fetch) {\n      push @reply, {'name' => $_, 'error' => 'not available'};\n    }\n  }\n  if ($cgi->{'raw'}) {\n    die(\"can only transport one binary in raw mode\\n\") unless @reply == 1;\n    my $f = $reply[0];\n    die(\"$f->{'name'}: $f->{'error'}\\n\") if $f->{'error'};\n    die(\"$f->{'name'}: not found\\n\") unless $f->{'filename'};\n    BSWatcher::reply_file($f->{'filename'});\n    return undef;\n  }\n  BSWatcher::reply_cpio(\\@reply);\n  return undef;\n}\n\nsub worker_getbinaryversions {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  if (0 && !$BSStdServer::isajax) {\n    my @args;\n    push @args, \"project=$projid\";\n    push @args, \"repository=$repoid\";\n    push @args, \"arch=$arch\";\n    push @args, \"binaries=$cgi->{'binaries'}\";\n    push @args, \"nometa=1\" if $cgi->{'nometa'};\n    BSHandoff::handoff($ajaxsocket, '/getbinaryversions', undef, @args);\n    exit(0);\n  }\n  my @binaries = split(',', $cgi->{'binaries'});\n  my ($remoteurl, $remoteprojid, $remoteproxy) = findremote($projid);\n\n  my $jev = $BSServerEvents::gev;\n  my $binaryversions;\n  $binaryversions = $jev->{'binaryversions'} if $BSStdServer::isajax;\n  $binaryversions ||= {};\n  $jev->{'binaryversions'} = $binaryversions if $BSStdServer::isajax;\n\n  # fill binaryversions\n  my @missing = grep {!exists $binaryversions->{$_}} @binaries;\n  while (@missing) {\n    # chunk it\n    my $binchunkl = 0;\n    for (splice @missing) {\n      $binchunkl += 10 + length($_);\n      last if @missing && $binchunkl > 1900;\n      push @missing, $_;\n    }\n    my $param = {\n      'uri' => \"$remoteurl/build/$remoteprojid/$repoid/$arch/_repository\",\n      'proxy' => $remoteproxy,\n    };\n    my $bvl = BSWatcher::rpc($param, $BSXML::binaryversionlist, 'view=binaryversions', 'nometa=1', map {\"binary=$_\"} @missing);\n    return undef if $BSStdServer::isajax && !$bvl;\n    for (@{$bvl->{'binary'} || []}) {\n      my $bin = $_->{'name'};\n      $bin =~ s/\\.(?:$binsufsre)$//;\n      $binaryversions->{$bin} = $_;\n    }\n    # make sure that we don't loop forever if the server returns incomplete data\n    for (@missing) {\n      $binaryversions->{$_} = {'name' => $_, 'error' => 'not available'} unless $binaryversions->{$_};\n    }\n    @missing = grep {!exists $binaryversions->{$_}} @binaries;\n  }\n  my $bvl = {};\n  $bvl->{'binary'} = [ map {$binaryversions->{$_}} @binaries];\n  return ($bvl, $BSXML::binaryversionlist);\n}\n\n# this is shared for AJAX requests\nmy @lastev_cache;\nmy @lastev_stat;\n\nsub lastevents {\n  my ($cgi, $filter) = @_;\n  if (!$cgi->{'start'}) {\n    # just fetch the current event number\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastevents\", $eventlay);\n    my $lastno = $lastev ? $lastev->{'number'} : 0;\n    my $ret = {'next' => $lastno, 'sync' => 'lost'};\n    return ($ret, $BSXML::events);\n  }\n  if (!$BSStdServer::isajax) {\n    my @args;\n    push @args, \"obsname=$cgi->{'obsname'}\" if $cgi->{'obsname'};\n    push @args, map {\"filter=$_\"} @{$filter || []};\n    push @args, \"start=$cgi->{'start'}\";\n    BSHandoff::handoff($ajaxsocket, '/lastevents', undef, @args);\n    exit(0);\n  }\n  BSWatcher::addfilewatcher(\"$eventdir/lastevents\");\n\n  my @s = stat(\"$eventdir/lastevents\");\n  my @events;\n  my ($firstno, $nextno);\n  if (@s && @lastev_stat && \"$s[9]/$s[7]/$s[1]\" eq \"$lastev_stat[9]/$lastev_stat[7]/$lastev_stat[1]\") {\n    @events = @lastev_cache;\n  } else {\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastevents\", $eventlay);\n    push @events, $lastev if $lastev;\n    @lastev_cache = @events;\n    @lastev_stat = @s;\n  }\n  $firstno = @events ? $events[0]->{'number'} : 0;\n  $nextno = @events ? $events[-1]->{'number'} + 1 : 1;\n\n  if ($cgi->{'start'} < $firstno) {\n    # get last 5\n    @events = BSFileDB::fdb_getall_reverse(\"$eventdir/lastevents\", $eventlay, 5);\n    @events = reverse @events;\n    @lastev_cache = @events;\n    @lastev_stat = @s;\n    $firstno = @events ? $events[0]->{'number'} : 0;\n    $nextno = @events ? $events[-1]->{'number'} + 1 : 1;\n  }\n\n  if ($cgi->{'start'} < $firstno) {\n    my $cnt = $nextno - $cgi->{'start'};\n    if ($cnt > 5) {\n      @events = BSFileDB::fdb_getall_reverse(\"$eventdir/lastevents\", $eventlay, $cnt);\n      @events = reverse @events;\n      if (@events < 20) {\n        @lastev_cache = @events;\n        @lastev_stat = @s;\n      }\n      $firstno = @events ? $events[0]->{'number'} : 0;\n      $nextno = @events ? $events[-1]->{'number'} + 1 : 1;\n    }\n  }\n\n  if ($cgi->{'start'} < $firstno) {\n    # we have to get them all\n    @events = BSFileDB::fdb_getall(\"$eventdir/lastevents\", $eventlay);\n    # re-calculate in case something has changed\n    $firstno = @events ? $events[0]->{'number'} : 0;\n    $nextno = @events ? $events[-1]->{'number'} + 1 : 1;\n    if ($firstno > $cgi->{'start'}) {\n      # out of sync!\n      return ({'next' => $nextno, 'sync' => 'lost'}, $BSXML::events);\n    }\n  }\n\n  # filter\n  @events = grep {$_->{'number'} >= $cgi->{'start'}} @events;\n  if ($filter && @events) {\n    my %filter = map {$_ => 1} @$filter;\n    for my $ev (splice @events) {\n      if ($ev->{'type'} eq 'package') {\n        next unless defined $ev->{'package'};\n        next unless $filter{\"package/$ev->{'project'}/$ev->{'package'}\"} || $filter{\"package/$ev->{'project'}\"};\n      } elsif ($ev->{'type'} eq 'project') {\n        next unless $filter{\"project/$ev->{'project'}\"};\n      } elsif ($ev->{'type'} eq 'repository') {\n        next unless $filter{\"repository/$ev->{'project'}/$ev->{'repository'}/$ev->{'arch'}\"};\n      } else {\n\tnext;\n      }\n      push @events, $ev;\n    }\n  }\n  # return a sync reply every 100 events / 5 minutes for two reasons\n  # - get rid of old peers\n  # - survive history truncation\n  $cgi->{'start_orig'} ||= $cgi->{'start'};\n  $cgi->{'req_time'} ||= time();\n  if ($BSStdServer::isajax && !@events && $nextno < $cgi->{'start_orig'} + 100 && $s[9] < $cgi->{'req_time'} + 300) {\n    # small hack: update cgi to the next event number\n    $cgi->{'start'} = $nextno if $cgi->{'start'} < $nextno;\n    return undef;\n  }\n  for (@events) {\n    $_ = { %$_ };\t# clone em\n    # delete unwanted fields\n    delete $_->{'time'};\n    delete $_->{'number'};\n    # clean up a bit\n    delete $_->{'package'} unless defined($_->{'package'}) && $_->{'package'} ne '';\n  }\n  my $ret = {'next' => $nextno};\n  $ret->{'event'} = \\@events if @events;\n  return ($ret, $BSXML::events);\n}\n\n#\n# add an event to the \"lastevents\" queue used in the build service\n# interconnect implementation\n#\nsub addevent {\n  my ($ev) = @_;\n\n  # check the \"access\" flag. if the project has access turned\n  # off, do not add it to lastevents.\n  # XXX: maybe better to add a \"noaccess\" marker to the event\n  # and filter in the request\n  if (defined($ev->{'project'})) {\n    my $access = 1;\n    my $proj = readproj($ev->{'project'}, 1);\n    if ($proj && $proj->{'access'}) {\n      $access = BSUtil::enabled('', $proj->{'access'}, $access, '');\n    }\n    # XXX: may also check packages in the future\n    return unless $access;\n  }\n  $ev->{'time'} = time();\n  mkdir_p($eventdir);\n  my $size = 262144;\t#keep at least 256k of data\n  if (-s \"$eventdir/lastevents\" && -s _ >= $size * 2) {\n    local *F;\n    BSUtil::lockopen(\\*F, '+>>', \"$eventdir/lastevents\");\n    my $events = readstr(\"$eventdir/lastevents\");\n    if (length($events) >= $size * 2) {\n      $events = substr($events, -$size);\n      $events =~ s/^[^\\n]*\\n//s;\n      writestr(\"$eventdir/.lastevents\", \"$eventdir/lastevents\", $events);\n    }\n    close F;\n  }\n  BSFileDB::fdb_add_i(\"$eventdir/lastevents\", $eventlay, $ev);\n}\n\nsub newevent {\n  my ($cgi) = @_;\n  my $ev = {};\n  for ('type', 'project', 'package', 'repository', 'arch', 'job') {\n    $ev->{$_} = $cgi->{$_} if defined $cgi->{$_};\n  }\n  addevent($ev);\n  return $BSStdServer::return_ok;\n}\n\nsub getrelsync {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/_relsync\",\n    'ignorestatus' => 1,\n    'receiver' => \\&BSServer::reply_receiver,\n  };\n  BSWatcher::rpc($param, undef);\n  return undef;\n}\n\nsub postrelsync {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  my $proj = checkprojrepoarch($projid, $repoid, $arch);\n  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];\n  my $relsyncdata = BSServer::read_data(10000000);\n  for my $a (@{$repo->{'arch'} || []}) {\n    next if $a eq $arch;\n    next if $BSConfig::relsync_pool && ($BSConfig::relsync_pool->{$arch} || '') ne ($BSConfig::relsync_pool->{$a} || '');\n    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n    my $param = {\n      'uri' => \"$reposerver/build/$projid/$repoid/$a/_relsync\",\n      'request' => 'POST',\n      'data' => $relsyncdata,\n    };\n    eval {\n      BSRPC::rpc($param);\n    };\n    if ($@) {\n      warn($@);\n    }\n  }\n  return $BSStdServer::return_ok;\n}\n\n# XXX: support multiple dispatchers\nsub putdispatchprios {\n  my ($cgi) = @_;\n  my $dispatcher = $BSConfig::masterdispatcher || $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$dispatcher/build/_dispatchprios\",\n    'request' => 'PUT',\n    'data' => \\&BSServer::forward_sender,\n    'chunked' => 1,\n  };\n  return BSWatcher::rpc($param, undef);\n}\n\nsub getdispatchprios {\n  my ($cgi) = @_;\n  my $dispatcher = $BSConfig::masterdispatcher || $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$dispatcher/build/_dispatchprios\",\n    'ignorestatus' => 1,\n    'receiver' => \\&BSServer::reply_receiver,\n  };\n  BSWatcher::rpc($param, undef);\n  return undef;\n}\n\nsub sourceinfo {\n  my ($cgi, $projid, $packid, $bconf) = @_;\n  my $r = {'package' => $packid};\n  my $linked = [];\n  my $rev;\n  my $files;\n  eval {\n    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'build', $linked);\n    $r->{'srcmd5'} = $rev->{'srcmd5'} if $rev->{'srcmd5'} ne 'empty';\n    $r->{'rev'} = $rev->{'rev'} if $rev->{'rev'};\n    $r->{'vrev'} = $rev->{'vrev'} if $rev->{'vrev'};\n    if (!$rev || $rev->{'srcmd5'} eq 'empty' || $rev->{'srcmd5'} eq $emptysrcmd5) {\n      die(\"no source uploaded\\n\") unless $cgi->{'nofilename'};\n      $rev = {'srcmd5' => $emptysrcmd5, 'project' => $projid, 'package' => $packid };\n    }\n    my $linkinfo = {};\n    $files = lsrev($rev, $linkinfo);\n    if ($linkinfo->{'xservicemd5'}) {\n      $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'});\n      $r->{'srcmd5'} = $rev->{'srcmd5'};\n    }\n    my $meta = '';\n    $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n    $r->{'verifymd5'} = Digest::MD5::md5_hex($meta);\n    die(\"source update running\\n\") if $files->{'_service'} && -e \"$eventdir/service/${projid}::$packid\";\n    die(\"source update failed\\n\") if $files->{'_service_error'};\n  };\n  $r->{'originproject'} = $rev->{'originproject'} if $rev && $rev->{'originproject'};\n  $r->{'linked'} = $linked if @$linked;\n  if ($@) {\n    $r->{'error'} = $@;\n    $r->{'error'} =~ s/\\n$//s;\n    return $r;\n  }\n  if ($files->{'_link'}) {\n    $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n    eval {\n      $files = handlelinks($rev, $files, {'linked' => $linked});\n    };\n    if ($@) {\n      $files = \"$@\";\n      $files =~ s/\\n$//;\n    }\n    $r->{'linked'} = $linked if @$linked;\n    $r->{'vrev'} = $rev->{'vrev'} if $rev->{'vrev'};\n    if (!ref $files) {\n      $r->{'error'} = $files || 'could not get file list';\n      return $r;\n    }\n    $r->{'lsrcmd5'} = $r->{'srcmd5'};\n    $r->{'srcmd5'} = $rev->{'srcmd5'};\n    my $meta = '';\n    $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n    $r->{'verifymd5'} = Digest::MD5::md5_hex($meta);\n  }\n  if ($cgi->{'withchangesmd5'}) {\n    $r->{'revtime'} = $rev->{'time'};\n    $r->{'changesmd5'} = $files->{\"$packid.changes\"} if $files->{\"$packid.changes\"};\n  }\n  return $r if $cgi->{'nofilename'};\n  return $r if $packid eq '_pattern';\n  if ($files->{'_aggregate'}) {\n    $r->{'filename'} = '_aggregate';\n    return $r;\n  } elsif ($files->{'_patchinfo'}) {\n    $r->{'filename'} = '_patchinfo';\n    return $r;\n  }\n  my $type = $bconf->{'type'};\n  my $file;\n  if (!$type || $type eq 'UNDEFINED') {\n    undef $type;\n    for my $t ('spec', 'dsc', 'kiwi') {\n      (undef, $file) = findfile($rev, $cgi->{'repository'}, $t, $files);\n      next unless defined $file;\n      $type = $t;\n      last;\n    }\n  } else {\n    (undef, $file) = findfile($rev, $cgi->{'repository'}, $type, $files);\n  }\n  if (!$type) {\n    $r->{'error'} = 'bad build configuration, no build type defined or detected';\n    return $r;\n  }\n  if (!$file) {\n    $r->{'error'} = \"no file found for build type '$type'\";\n    return $r;\n  }\n  $r->{'filename'} = $file;\n  return $r unless $cgi->{'parse'};\n  my $buildtype = Build::recipe2buildtype($file);\n  if (!$buildtype) {\n    $r->{'error'} = \"don't know how to build $file\";\n    return $r;\n  }\n  my $d = Build::parse_typed($bconf, \"$srcrep/$packid/$files->{$file}-$file\", $buildtype);\n  if (!$d) {\n    $r->{'error'} = \"parse error\";\n    return $r;\n  }\n  for (qw{name version release subpacks deps prereqs exclarch badarch}) {\n    $r->{$_} = $d->{$_} if defined $d->{$_};\n  }\n  return $r;\n}\n\nsub getprojectsourceinfo {\n  my ($cgi, $projid) = @_;\n  my $proj = checkprojrepoarch($projid, $cgi->{'repository'}, $cgi->{'arch'}, 1);\n  my @packages = @{$cgi->{'package'} || []};\n  $frozenlinks_cache = {};\n  @packages = findpackages($projid, $proj) unless @packages;\n  my $bconf;\n  if (!$cgi->{'nofilename'}) {\n    if (!$cgi->{'repository'}) {\n      my $cfile;\n      $cfile = \"$projectsdir/$projid.conf\" if -e \"$projectsdir/$projid.conf\";\n      $bconf = Build::read_config($cgi->{'arch'} || 'noarch', $cfile);\n    } else {\n      my @path = expandsearchpath($projid, $cgi->{'repository'});\n      my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);\n      $bconf = Build::read_config($cgi->{'arch'} || 'noarch', [ split(\"\\n\", $c) ]);\n    }\n  }\n  my @res;\n  if (@packages > 1) {\n    $collect_remote_getrev = 1;\n    for my $packid (splice @packages) {\n      my $r = sourceinfo($cgi, $projid, $packid, $bconf);\n      if ($r->{'error'} && $r->{'error'} =~ /collect_remote_getrev$/) {\n\tpush @packages, $packid;\n\tnext;\n      }\n      push @res, $r;\n    }\n    $collect_remote_getrev = 0;\n    fill_remote_getrev_cache();\n  }\n  for my $packid (@packages) {\n    push @res, sourceinfo($cgi, $projid, $packid, $bconf);\n  }\n  $frozenlinks_cache = undef;\n  return ({'sourceinfo' => \\@res}, $BSXML::sourceinfolist);\n}\n\nsub getpackagesourceinfo {\n  my ($cgi, $projid, $packid) = @_;\n  checkprojrepoarch($projid, $cgi->{'repository'}, $cgi->{'arch'}, 1); #remoteok\n  my $bconf;\n  if (!$cgi->{'nofilename'}) {\n    my $cfile;\n    if (!$cgi->{'repository'}) {\n      $cfile = \"$projectsdir/$projid.conf\" if -e \"$projectsdir/$projid.conf\";\n    } else {\n      print \"expandsearchpath $projid $cgi->{'repository'}...\\n\";\n      my @path = expandsearchpath($projid, $cgi->{'repository'});\n      my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);\n      $cfile = [ split(\"\\n\", $c) ];\n    }\n    $bconf = Build::read_config($cgi->{'arch'} || 'noarch', $cfile);\n  }\n  my $res = sourceinfo($cgi, $projid, $packid, $bconf);\n  return ($res, $BSXML::sourceinfo);\n}\n\n####################################################################\n\nsub putconfiguration {\n  my ($cgi) = @_;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $configuration = readxml(\"$uploaddir/$$\", $BSXML::configuration);\n  unlink(\"$uploaddir/$$\");\n  my $configurationxml = BSUtil::toxml($configuration, $BSXML::configuration);\n  writestr(\"$BSConfig::bsdir/.configuration.xml\", \"$BSConfig::bsdir/configuration.xml\", $configurationxml);\n  # distribute to repo servers\n  my %reposervers;\n  if ($BSConfig::partitionservers) {\n    %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);\n  } else {\n    $reposervers{$BSConfig::reposerver} = 1;\n  }\n  for my $server (sort keys %reposervers) {\n    my $param = {\n      'uri' => \"$server/configuration\",\n      'request' => 'PUT',\n      'data' => $configurationxml,\n    };\n    eval {\n      BSRPC::rpc($param, undef);\n    };\n    warn($@) if $@;\t# XXX: what now?\n  }\n  return $BSStdServer::return_ok;\n}\n\nsub getconfiguration {\n  my $configuration = readxml(\"$BSConfig::bsdir/configuration.xml\", $BSXML::configuration, 1) || {};\n  return ($configuration, $BSXML::configuration);\n}\n\n####################################################################\n\nsub putissuetrackers {\n  my ($cgi) = @_;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $trackers = readxml(\"$uploaddir/$$\", $BSXML::issue_trackers);\n  unlink(\"$uploaddir/$$\");\n  writexml(\"$BSConfig::bsdir/.issuetrackers.xml\", \"$BSConfig::bsdir/issuetrackers.xml\", $trackers, $BSXML::issue_trackers);\n  return $BSStdServer::return_ok;\n}\n\nsub getissuetrackers {\n  my $trackers = readxml(\"$BSConfig::bsdir/issuetrackers.xml\", $BSXML::issue_trackers, 1) || {};\n  return ($trackers, $BSXML::issue_trackers);\n}\n\n####################################################################\n\nsub external_notification {\n  my ($cgi, $type) = @_;\n  my $param = {};\n  for (keys %$cgi) {\n    $param->{$_} = $cgi->{$_} unless $_ eq '_type' || /^\\./;\n  }\n  notify($type, $param);\n  return $BSStdServer::return_ok;\n}\n\nsub notify_plugins {\n  my ($cgi, $type) = @_;\n  my $param = {};\n  if (BSServer::have_content()) {\n    my $jsonbody = BSServer::read_data(10000000);\n    $param = JSON::XS::decode_json($jsonbody);\n  } else {\n    for (keys %$cgi) {\n      $param->{$_} = $cgi->{$_} unless $_ eq '_type' || /^\\./;\n    }\n  }\n\n  BSNotify::notify_plugins($type, $param);\n  return $BSStdServer::return_ok;\n}\n\n\n####################################################################\n\nsub hello {\n  my ($cgi) = @_;\n  return \"<hello name=\\\"Source Repository Ajax Server\\\" repoid=\\\"$repoid\\\" />\\n\" if $BSStdServer::isajax;\n  return \"<hello name=\\\"Source Repository Server\\\" repoid=\\\"$repoid\\\" />\\n\";\n}\n\n####################################################################\n\nmy $dispatches = [\n  '/' => \\&hello,\n\n  '!rw :' => undef,\n  '!- GET:' => undef,\n  '!- HEAD:' => undef,\n\n  # /source name space: manage project and package data\n  '/source deleted:bool?' => \\&getprojectlist,\n\n  'POST:/source/$project cmd=createkey user:? comment:?' => \\&createkey,\n  'POST:/source/$project cmd=extendkey user:? comment:?' => \\&extendkey,\n  'POST:/source/$project cmd=undelete user:? comment:?' => \\&undeleteproject,\n  'POST:/source/$project cmd=copy user:? comment:? oproject:project withbinaries:bool? withhistory:bool? makeolder:bool? resign:bool? noservice:bool?' => \\&copyproject,\n  'POST:/source/$project cmd=move oproject:project' => \\&moveproject,\n  'POST:/source/$project cmd: *:*' => \\&unknowncmd,\n  '/source/$project view=info parse:bool? nofilename:bool? repository? arch? package* withchangesmd5:bool?' => \\&getprojectsourceinfo,\n  '/source/$project deleted:bool? expand:bool? noorigins:bool?' => \\&getpackagelist,\n\n  'DELETE:/source/$project user:? comment:? requestid:num?' => \\&delproject,\n  '/source/$project/_meta rev?' => \\&getproject,\n  'PUT:/source/$project/_meta user:? comment:? requestid:num? lowprio:bool?' => \\&putproject,\n\n  '/source/$project/_pubkey rev?' => \\&getpubkey,\n  'DELETE:/source/$project/_pubkey user:? comment:?' => \\&deletekey,\n\n  '/source/$project/_config rev?' => \\&getprojectconfig,\n  'PUT:/source/$project/_config user:? comment:?' => \\&putprojectconfig,\n  'DELETE:/source/$project/_config user:? comment:?' => \\&delprojectconfig,\n\n  '/source/$project/_history rev? meta:bool? deleted:bool? limit:num?' => \\&getpackagehistory,\n\n  'POST:/source/$project/$package cmd=diff rev? orev:rev? oproject:project? opackage:package? expand:bool? linkrev? olinkrev:? unified:bool? missingok:bool? meta:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \\&sourcediff,\n  'POST:/source/$project/$package cmd=linkdiff rev? linkrev? unified:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \\&linkdiff,\n  'POST:/source/$project/$package cmd=servicediff rev? unified:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \\&servicediff,\n  'POST:/source/$project/$package cmd=commit rev? user:? comment:? keeplink:bool? repairlink:bool? linkrev? setrev:bool? requestid:num? noservice:bool?' => \\&sourcecommit,\n  'POST:/source/$project/$package cmd=commitfilelist rev? user:? comment:? keeplink:bool? repairlink:bool? linkrev? setrev:bool? requestid:num? time:num? version:? vrev:? noservice:bool? servicemark:?' => \\&sourcecommitfilelist,\n  'POST:/source/$project/$package cmd=copy rev? user:? comment:? orev:rev? oproject:project? opackage:package? expand:bool? keeplink:bool? repairlink:bool? linkrev? setrev:linkrev? olinkrev:linkrev? requestid:num? dontupdatesource:bool? noservice:bool? withvrev:bool? withacceptinfo:bool? makeoriginolder:bool?' => \\&sourcecopy,\n  'POST:/source/$project/$package cmd=collectbuildenv user:? comment:? orev:rev? oproject:project? opackage:package?' => \\&sourcecollectbuildenv,\n  'POST:/source/$project/$package cmd=branch rev? user:? comment:? orev:rev? oproject:project? opackage:package? olinkrev:linkrev? requestid:num? force:bool? keepcontent:bool? missingok:bool? noservice:bool? withacceptinfo:bool?' => \\&sourcebranch,\n  'POST:/source/$project/$package cmd=linktobranch rev? user:? comment:? linkrev?' => \\&linktobranch,\n  'POST:/source/$project/$package cmd=deleteuploadrev' => \\&deleteuploadrev,\n  'POST:/source/$project/$package cmd=undelete user:? comment:? time:num?' => \\&undeletepackage,\n  'POST:/source/$project/$package cmd=runservice user:? comment:?' => \\&triggerservicerun,\n  'POST:/source/$project/$package cmd=getprojectservices' => \\&getprojectservices,\n  'POST:/source/$project/$package cmd: *:*' => \\&unknowncmd,\n\n  'PUT:/source/$project/$package cmd: rev? user:? comment:?' => \\&sourcecommitfilelist,\t# obsolete\n\n  '/source/$project/$package view=info rev? linkrev? parse:bool? nofilename:bool? repository? arch? withchangesmd5:bool?' => \\&getpackagesourceinfo,\n  '/source/$project/$package rev? linkrev? emptylink:bool? deleted:bool? expand:bool? view:? extension:? lastworking:bool? withlinked:bool? meta:bool? product:?' => \\&getfilelist,\n  '/source/$project/$package/_history rev? meta:bool? deleted:bool? limit:num?' => \\&getpackagehistory,\n  '/source/$project/$package/_meta rev? expand:bool? meta:bool? deleted:bool?' => \\&getpackage,\n  'PUT:/source/$project/$package/_meta user:? comment:? requestid:num?' => \\&putpackage,\n  'DELETE:/source/$project/$package user:? comment:? requestid:num?' => \\&delpackage,\n  '/source/$project/$package/$filename rev? expand:bool? meta:bool? deleted:bool?' => \\&getfile,\n  'PUT:/source/$project/$package/$filename rev? user:? comment:? keeplink:bool? force:bool? meta:bool?' => \\&putfile,\n  'DELETE:/source/$project/$package/$filename rev? user:? comment:? keeplink:bool? force:bool? meta:bool?' => \\&delfile,\n\n  # /published name spec: access published binaries\n  '/published' => \\&published,\n  '/published/$project' => \\&published,\n  '/published/$project/$repository view=publishedpath medium:?' => \\&published_path,\n  '/published/$project/$repository' => \\&published,\n  '/published/$project/$repository/$arch:filename view:?' => \\&published,\n  '/published/$project/$repository/$arch:filename/$filename view:?' => \\&published,\n  '/published/$project/$repository/$arch:filename/$filename/$subfilename:filename view:?' => \\&published,\n\n  # scheduler calls\n  '/getprojpack $project* $repository* $package* $arch? withrepos:bool? withsrcmd5:bool? withdeps:bool? withconfig:bool? expandedrepos:bool? ignoredisable:bool? nopackages:bool? withremotemap:bool? noremote:bool? partition:? view:?' => \\&getprojpack,\n  'POST:/relsync $project $repository $arch' => \\&postrelsync,\n  '/relsync $project $repository $arch' => \\&getrelsync,\n\n  # worker calls\n  '/getsources $project $package $srcmd5:md5' => \\&getsources,\n  '/getconfig $project $repository path:prp*' => \\&getbuildconfig,\n\n  '/getsignkey $project withpubkey:bool? autoextend:bool?' => \\&getsignkey,\n  '/getsslcert $project autoextend:bool?' => \\&getsslcert,\n  '/getbinaries $project $repository $arch binaries: nometa:bool?' => \\&worker_getbinaries,\n  '/getbinaryversions $project $repository $arch binaries: nometa:bool?' => \\&worker_getbinaryversions,\n  '!- /lastevents $filter:* start:num? obsname:?' => \\&lastevents,\n  '/lastnotifications start:num? view:? block:bool? noprune:bool?' => \\&lastnotifications,\n  '/notificationpayload/$payloadkey:filename' => \\&getnotificationpayload,\n  'DELETE:/notificationpayload/$payloadkey:filename' => \\&deletenotificationpayload,\n  'POST:/event type: project: package:? repository:? arch:? job:?' => \\&newevent,\n  # tmp until lightty gets fixed\n  '/public/lastevents $filter:* start:num? obsname:?' => \\&lastevents,\n\n  # search interface\n  '/search $in: $match: return:? values:bool?' => \\&search,\n  '/search/project $match:' => \\&search_proj,\n  '/search/project/id $match:' => \\&search_proj_id,\n  '/search/package $match:' => \\&search_pack,\n  '/search/package/id $match:' => \\&search_pack_id,\n\n  'POST:/search/published cmd:' => \\&search_published_updatedb,\n  '/search/published/binary/id $match: limit:num?' => \\&search_published_binary_id,\n  '/search/published/pattern/id $match: limit:num?' => \\&search_published_pattern_id,\n\n  # service interface, just for listing for now\n  '/service' => \\&listservices,\n#  '/service/$service' => \\&service,\n\n  # configuration\n  'PUT:/configuration' => \\&putconfiguration,\n  '/configuration' => \\&getconfiguration,\n\n  # issue trackers\n  'PUT:/issue_trackers' => \\&putissuetrackers,\n  '/issue_trackers' => \\&getissuetrackers,\n\n  # build calls for binary files\n  '/build' => \\&getprojectlist,\n  '/build/_workerstatus scheduleronly:bool? daemonsonly:bool? arch*' => \\&getworkerstatus,\n  'PUT:/build/_dispatchprios' => \\&putdispatchprios,\n  '/build/_dispatchprios' => \\&getdispatchprios,\n  'POST:/build/$project cmd: repository* arch* package* code:* wipe:*' => \\&docommand,\n  '/build/$project' => \\&getrepositorylist,\n  '/build/$project/_result oldstate:md5? view:resultview* lastbuild:bool? repository* arch* package* code:*' => \\&getresult,\n  '/build/$project/$repository' => \\&getarchlist,\n  '/build/$project/$repository/_buildconfig path:prp*' => \\&getbuildconfig,\n  '/build/$project/$repository/$arch package* view:?' => \\&getpackagelist_build,\n  '/build/$project/$repository/$arch/_builddepinfo package* view:?' => \\&getbuilddepinfo,\n  '/build/$project/$repository/$arch/_jobhistory package* code:* limit:num?' => \\&getjobhistory,\n  'POST:/build/$project/$repository/$arch/_repository match:' =>  \\&postrepo,\n  'POST:/build/$project/$repository/$arch/$package cmd=copy oproject:project? opackage:package? orepository:repository? setupdateinfoid:? resign:bool? setrelease:?' => \\&copybuild,\n  'POST:/build/$project/$repository/$arch/$package' => \\&uploadbuild,\n  '/build/$project/$repository/$arch/$package_repository view:? binary:filename* nometa:bool? nosource:bool? withmd5:bool?' => \\&getbinarylist,\n  'POST:/build/$project/$repository/$arch/$package_repository/_buildinfo add:* debug:bool?' => \\&getbuildinfo_post,\n  '/build/$project/$repository/$arch/$package/_buildinfo add:* internal:bool? debug:bool?' => \\&getbuildinfo,\n  '/build/$project/$repository/$arch/$package/_jobstatus' => \\&getjobstatus,\n  '/build/$project/$repository/$arch/$package/_log nostream:bool? last:bool? start:intnum? end:num? view:?' => \\&getlogfile,\n  '/build/$project/$repository/$arch/$package/_reason' => \\&getbuildreason,\n  '/build/$project/$repository/$arch/$package/_status' => \\&getbuildstatus,\n  '/build/$project/$repository/$arch/$package/_history limit:num?' => \\&getbuildhistory,\n  '/build/$project/$repository/$arch/$package_repository/$filename view:?' => \\&getbinary,\n  'PUT:/build/$project/$repository/$arch/_repository/$filename ignoreolder:bool? wipe:bool?' => \\&putbinary,\n  'DELETE:/build/$project/$repository/$arch/_repository/$filename' => \\&delbinary,\n\n  'POST:/request cmd: user:?' => \\&createrequest,\n  '/request' => \\&getrequestlist,\n  'POST:/request/$id:num cmd: newstate:? user:? comment:? by_user:? by_group:? by_project:? by_package:? superseded_by:?' => \\&postrequest,\n  '/request/_lastid' => \\&getlastidrequest,                     # just required for migration into api\n  '/request/$id:num' => \\&getrequest, # just required for migration into api\n\n  # notifications from publisher/repserver - CGI\n  'POST:/notify/$_type: *:?' => \\&external_notification,\n  # called from the API to notify hermes/rabbitmq\n  'POST:/notify_plugins/$_type:' => \\&notify_plugins,\n\n  '/ajaxstatus' => \\&getajaxstatus,\n  '/serverstatus' => \\&BSStdServer::serverstatus,\n];\n\n####################################################################\n\nmy $dispatches_ajax = [\n  '/' => \\&hello,\n  '/ajaxstatus' => \\&getajaxstatus,\n  '/build/$project/_result oldstate:md5? view:resultview* repository* arch* package* code:*' => \\&getresult,\n  '/build/$project/$repository/$arch package* view:?' => \\&getpackagelist_build,\n  '/build/$project/$repository/$arch/$package/_log nostream:bool? last:bool? start:intnum? end:num?' => \\&getlogfile,\n  '/build/$project/$repository/$arch/$package_repository view:? binary:filename* nometa:bool? nosource:bool? withmd5:bool?' => \\&getbinarylist,\n  '/getbinaries $project $repository $arch binaries: nometa:bool? raw:bool?' => \\&worker_getbinaries,\n  '/getbinaryversions $project $repository $arch binaries: nometa:bool?' => \\&worker_getbinaryversions,\n  '/lastevents $filter:* start:num? obsname:?' => \\&lastevents,\n  '/lastnotifications start:num? view:? block:bool?' => \\&lastnotifications,\n  '/source/$project/$package rev view:' => \\&getfilelist_ajax,\n  '/source/$project/$package:package/$filename rev?' => \\&getfile,\n  '/request/$id:num withkey:bool? oldkey:md5?' => \\&getrequest,\n  '/sourcediffcache/$cacheid:md5 view:?' => \\&getsourcediffcache,\n];\n\n####################################################################\n\nmy $conf = {\n  'port' => $port,\n  'dispatches' => $dispatches,\n  'setkeepalive' => 1,\n  'maxchild' => 20,\n  'maxchild2' => 20,\n};\n\nmy $aconf = {\n  'socketpath' => $ajaxsocket,\n  'dispatches' => $dispatches_ajax,\n  'getrequest_timeout' => 10,\n  'replrequest_timeout' => 10,\n  'getrequest_recvfd' => \\&BSHandoff::receive,\n  'setkeepalive' => 1,\n};\n\nif ($BSConfig::workersrcserver) {\n  my $wport = $port;\n  $wport = $1 if $BSConfig::workersrcserver =~ /:(\\d+)$/;\n  $conf->{'port2'} = $wport if $wport != $port;\n}\n\n# set a repoid for identification of this data repository\nBSUtil::mkdir_p_chown(\"$projectsdir\", $BSConfig::bsuser, $BSConfig::bsgroup) unless -d \"$projectsdir\";\nif (! -e \"$projectsdir/_repoid\") {\n  my $randomid = int(rand(1000000000));\n  writestr(\"$projectsdir/._repoid\", \"$projectsdir/_repoid\", sprintf(\"%09d\", $randomid));\n}\n$repoid = readstr(\"$projectsdir/_repoid\");\n\nBSStdServer::server('bs_srcserver', \\@ARGV, $conf, $aconf);\n\n"], "fixing_code": ["#!/usr/bin/perl -w\n#\n# Copyright (c) 2006, 2007 Michael Schroeder, Novell Inc.\n# Copyright (c) 2008 Adrian Schroeter, Novell Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License version 2 as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program (see the file COPYING); if not, write to the\n# Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA\n#\n################################################################\n#\n# The Source Server\n#\n\nBEGIN {\n  my ($wd) = $0 =~ m-(.*)/- ;\n  $wd ||= '.';\n  chdir($wd);\n  unshift @INC,  \"$wd/build\";\n  unshift @INC,  \"$wd\";\n}\n\nuse XML::Structured ':bytes';\nuse POSIX;\nuse Digest::MD5 ();\nuse Data::Dumper;\nuse Storable ();\nuse Symbol;\nuse MIME::Base64 ();\nuse JSON::XS ();\n\nuse BSConfiguration;\nuse BSRPC ':https';\nuse BSServer;\nuse BSUtil;\nuse BSFileDB;\nuse BSXML;\nuse BSProductXML;\nuse BSVerify;\nuse BSHandoff;\nuse BSWatcher ':https';\nuse BSXPath;\nuse BSStdServer;\nuse BSSrcdiff;\nuse Build;\nuse BSNotify;\n\nuse BSXPath;\nuse BSXPathKeys;\nuse BSDB;\nuse BSDBIndex;\n\n$Build::Rpm::unfilteredprereqs = 1 if defined $Build::Rpm::unfilteredprereqs;\n\nuse strict;\n\nmy $port = 5352;\t#'SR'\n$port = $1 if $BSConfig::srcserver =~ /:(\\d+)$/;\nmy $proxy;\n$proxy = $BSConfig::proxy if defined($BSConfig::proxy);\n\nBSUtil::set_fdatasync_before_rename() unless $BSConfig::disable_data_sync || $BSConfig::disable_data_sync;\n\nmy $projectsdir = \"$BSConfig::bsdir/projects\";\nmy $eventdir = \"$BSConfig::bsdir/events\";\nmy $srcrep = \"$BSConfig::bsdir/sources\";\nmy $treesdir = $BSConfig::nosharedtrees ? \"$BSConfig::bsdir/trees\" : $srcrep;\nmy $requestsdir = \"$BSConfig::bsdir/requests\";\nmy $oldrequestsdir = \"$BSConfig::bsdir/requests.old\";\nmy $rundir = $BSConfig::rundir || \"$BSConfig::bsdir/run\";\nmy $diffcache = \"$BSConfig::bsdir/diffcache\";\n\nmy $reqindexdb = \"$BSConfig::bsdir/db/request\";\nmy $extrepodb = \"$BSConfig::bsdir/db/published\";\nmy $sourcedb = \"$BSConfig::bsdir/db/source\";\n\nmy $remotecache = \"$BSConfig::bsdir/remotecache\";\nmy $notificationpayloaddir = \"$BSConfig::bsdir/notificationpayload\";\n\nmy $srcrevlay = [qw{rev vrev srcmd5 version time user comment requestid}];\nmy $eventlay = [qw{number time type project package repository arch}];\nmy $notificationlay = [qw{number type time data []}];\n\n\nmy $ajaxsocket = \"$rundir/bs_srcserver.ajax\";\nmy $uploaddir = \"$srcrep/:upload\";\n\nmy @binsufs = qw{rpm deb pkg.tar.gz pkg.tar.xz};\nmy $binsufsre = join('|', map {\"\\Q$_\\E\"} @binsufs);\n\nmy $repoid;\nmy %packagequota;\n\n# This is the md5sum of an empty file\nmy $emptysrcmd5 = 'd41d8cd98f00b204e9800998ecf8427e';\n\n# remote getrev cache\nmy $collect_remote_getrev;\nmy $remote_getrev_todo;\nmy %remote_getrev_cache;\nmy $frozenlinks_cache;\n\nsub notify {\n  my ($type, $p) = @_;\n  my $time = $p->{'time'} || time();\n  delete $p->{'time'};\n  if ($type eq 'PACKTRACK' && BSServer::have_content()) {\n    my $payload = Storable::thaw(BSServer::read_data());\n    if ($payload) {\n      my $json_payload = JSON::XS::encode_json($payload);\n      my $payloadkey = \"$time.\".Digest::MD5::md5_hex($json_payload);\n      mkdir_p($notificationpayloaddir);\n      writestr(\"$notificationpayloaddir/.$payloadkey\", \"$notificationpayloaddir/$payloadkey\", $json_payload);\n      $p->{'payload'} = $payloadkey;\n      print \"notification payload for $p->{'project'}/$p->{'repo'} stored in $payloadkey\\n\" if $p->{'project'} && $p->{'repo'};\n    }\n  }\n  my @n = map {\"$_=$p->{$_}\"} grep {defined($p->{$_}) && !ref($p->{$_})} sort keys %{$p || {}};\n  mkdir_p($eventdir);\n  BSFileDB::fdb_add_i(\"$eventdir/lastnotifications\", $notificationlay, {'type' => $type, 'time' => $time, 'data' => \\@n});\n}\n\nsub prune_notificationpayloads {\n  my ($cuttime) = @_;\n  my @pl = ls($notificationpayloaddir);\n  for my $p (@pl) {\n    next unless $p =~ /^(\\d+)\\./;\n    unlink(\"$notificationpayloaddir/$p\") if $1 < $cuttime;\n  }\n}\n\nsub prune_lastnotifications {\n  my ($cutoff) = @_;\n  local *F;\n  return unless BSUtil::lockopen(\\*F, '<', \"$eventdir/lastnotifications\", 1);\n  my $filter = sub { $_[0]->{'number'} >= $cutoff ? 1 : 0 };\n  my @l = BSFileDB::fdb_getall(\"$eventdir/lastnotifications\", $notificationlay, undef, $filter);\n  if (@l) {\n    unlink(\"$eventdir/.lastnotifications.$$\");\n    if (! -e \"$eventdir/.lastnotifications.$$\") {\n      BSFileDB::fdb_add_multiple(\"$eventdir/.lastnotifications.$$\", $notificationlay, @l);\n      rename(\"$eventdir/.lastnotifications.$$\", \"$eventdir/lastnotifications\") || die(\"rename $eventdir/.lastnotifications.$$ $eventdir/lastnotifications: $!\\n\");\n      prune_notificationpayloads($l[0]->{'time'} - 240 * 3600) if -d $notificationpayloaddir;\t# keep 10 days\n    }\n  }\n  close F;\n}\n\nsub lastnotifications {\n  my ($cgi) = @_;\n  my $view = $cgi->{'view'};\n  die(\"unsupported view\\n\") if $view && $view ne 'json';\n  if (!$cgi->{'start'}) {\n    # just fetch the current event number\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastnotifications\", $notificationlay);\n    my $lastno = $lastev ? $lastev->{'number'} : 0;\n    my $ret = {'next' => $lastno + 1, 'sync' => 'lost'};\n    return (JSON::XS::encode_json($ret), 'Content-Type: application/json') if $view && $view eq 'json';\n    return ($ret, $BSXML::notifications);\n  }\n  # check if we need to prune\n  if (!$BSStdServer::isajax && !$cgi->{'noprune'}) {\n    my $firstev = (BSFileDB::fdb_getall(\"$eventdir/lastnotifications\", $notificationlay, undef, sub {-1}))[0];\n    if ($firstev && $cgi->{'start'} - $firstev->{'number'} > 1000) {\n      my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastnotifications\", $notificationlay);\n      prune_lastnotifications($cgi->{'start'} - 500) if $lastev && $cgi->{'start'} <= $lastev->{'number'} + 1;\n    }\n  }\n  my $filter = sub { $cgi->{'start'} > $_[0]->{'number'} ? -2 : 1 };\n  my @l = BSFileDB::fdb_getall_reverse(\"$eventdir/lastnotifications\", $notificationlay, undef, $filter);\n  if ($cgi->{'block'} && !@l) {\n    # pass on to AJAX\n    if (!$BSStdServer::isajax) {\n      my @args;\n      push @args, \"start=$cgi->{'start'}\";\n      push @args, \"block=1\";\n      BSHandoff::handoff($ajaxsocket, '/lastnotifications', undef, @args);\n      exit(0);\n    }\n    # wait untill we have a winner\n    BSWatcher::addfilewatcher(\"$eventdir/lastnotifications\");\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastnotifications\", $notificationlay);\n    return undef if !$lastev || $lastev->{'number'} < $cgi->{'start'};\n    if ($cgi->{'start'} == $lastev->{'number'}) {\n      @l = ($lastev);\n    } else {\n      @l = BSFileDB::fdb_getall_reverse(\"$eventdir/lastnotifications\", $notificationlay, undef, $filter);\n      return undef unless @l;\n    }\n  }\n  my $res = {};\n  @l = reverse @l;\n  if (@l) {\n    $res->{'next'} = $l[-1]->{'number'} + 1;\n  } else {\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastnotifications\", $notificationlay);\n    my $no = ($lastev->{'number'} || 0);\n    $no = $cgi->{'start'} - 1 if $no >= $cgi->{'start'};\n    $res->{'next'} = $no + 1;\n  }\n  if (@l && $l[0]->{'number'} > $cgi->{'start'}) {\n    $res->{'sync'} = 'lost';\n    @l = ();\n  }\n  # don't send more than 1000 notifications to the poor api\n  if (@l > 1000) {\n    $res->{'limit_reached'} = 1; # tell the api that there is more\n    $res->{'next'} = $l[1000]->{'number'};\n    @l = splice(@l, 0, 1000);\n  }\n  $res->{'notification'} = \\@l;\n  delete $_->{'number'} for @l;\t\t# XXX: why?\n  if ($view && $view eq 'json') {\n    for my $l (@l) {\n      my %d;\n      for (@{$l->{'data'} || []}) {\n        my @s = split('=', $_, 2);\n        $d{$s[0]} = $s[1];\n      }\n      $l->{'data'} = \\%d;\n    }\n    return (JSON::XS::encode_json($res), 'Content-Type: application/json');\n  }\n  for my $l (@l) {\n    for (@{$l->{'data'} || []}) {\n      my @s = split('=', $_, 2);\n      $_ = {'key' => $s[0]};\n      $_->{'_content'} = $s[1] if defined $s[1];\n    }\n  }\n  return ($res, $BSXML::notifications);\n}\n\nsub getnotificationpayload {\n  my ($cgi, $payloadkey) = @_;\n  my $file = \"$notificationpayloaddir/$payloadkey\";\n  die(\"404 payload does not exist!\\n\") unless -e $file;\n  return (readstr($file), 'Content-Type: application/json');\n}\n\nsub deletenotificationpayload {\n  my ($cgi, $payloadkey) = @_;\n  unlink(\"$notificationpayloaddir/$payloadkey\");\n  return $BSStdServer::return_ok;\n}\n\nsub notify_repservers {\n  my ($type, $projid, $packid) = @_;\n\n  my $ev = {'type' => $type, 'project' => $projid};\n  $ev->{'package'} = $packid if defined $packid;\n  addevent($ev);\n\n  my @args = (\"type=$type\", \"project=$projid\");\n  push @args, \"package=$packid\" if defined $packid;\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/event\",\n    'request'   => 'POST',\n    'background' => 1,\n  };\n  eval {\n    BSWatcher::rpc($param, undef, @args);\n  };\n  print \"warning: $reposerver: $@\" if $@;\n}\n\n# this is only used from getfilelist_ajax.\n# as projid is a remote project, we don't know which reposerver\n# we need to notify. so send the event to all of them.\n# we also do not call addevent in this specific case.\nsub notify_all_repservers {\n  my ($type, $projid, $packid) = @_;\n\n  my %reposervers;\n  if ($BSConfig::partitioning) {\n    %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);\n  } else {\n    %reposervers = ($BSConfig::reposerver => 1);\n  }\n  my @args = (\"type=$type\", \"project=$projid\");\n  push @args, \"package=$packid\" if defined $packid;\n  for my $reposerver (sort keys %reposervers) {\n    my $param = {\n      'uri' => \"$reposerver/event\",\n      'request'   => 'POST',\n      'background' => 1,\n    };\n    eval {\n      BSWatcher::rpc($param, undef, @args);\n    };\n    print \"warning: $reposerver: $@\" if $@;\n  }\n}\n\n# check if a service run is needed for the upcoming commit\nsub genservicemark {\n  my ($projid, $packid, $files, $rev, $force) = @_;\n  \n  return undef if $BSConfig::old_style_services;\n\n  return undef if $packid eq '_project';\t# just in case...\n  return undef if defined $rev;\t# don't mark if upload/repository/internal\n  return undef if $packid eq '_pattern' || $packid eq '_product';\t# for now...\n  return undef if $files->{'/SERVICE'};\t# already marked\n\n  # check if we really need to run the service\n  if (!$files->{'_service'} && !$force) {\n    # XXX: getprojectservices may die!\n    my ($projectservices, undef) = getprojectservices({}, $projid, $packid);\n    return undef unless $projectservices && $projectservices->{'service'} && @{$projectservices->{'service'}};\n  }\n\n  # argh, somewhat racy. luckily we just need something unique...\n  # (files is not unique enough because we want a different id\n  # for each commit, even if it has the same srcmd5)\n  # (maybe we should use the same time as in the upcoming rev)\n  my $smd5 = \"sourceservice/$projid/$packid/\".time().\"\\n\";\n  eval {\n    my $rev_old = getrev($projid, $packid);\n    $smd5 .= \"$rev_old->{'rev'}\" if $rev_old->{'rev'};\n  };\n  $smd5 .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n  $smd5 = Digest::MD5::md5_hex($smd5);\n\n  # return the mark\n  return $smd5;\n}\n\n# called from runservice when the service run is finished. it\n# either does the service commit (old style), or creates the\n# xsrcmd5 service revision (new style).\nsub addrev_service {\n  my ($cgi, $rev, $files, $error) = @_;\n\n  if ($error) {\n    chomp $error;\n    $error ||= 'unknown service error';\n  }\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  if (!$files->{'/SERVICE'}) {\n    # old style, do a commit\n    if ($error) {\n      mkdir_p($uploaddir);\n      writestr(\"$uploaddir/_service_error$$\", undef, \"$error\\n\");\n      $files->{'_service_error'} = addfile($projid, $packid, \"$uploaddir/_service_error$$\", '_service_error');\n    }\n    addrev({%{$cgi || {}}, 'user' => '_service', 'comment' => 'generated via source service', 'noservice' => 1}, $projid, $packid, $files);\n    return;\n  }\n  # new style services\n  if ($files->{'_service_error'} && !$error) {\n    $error = repreadstr($rev, '_service_error', $files->{'_service_error'});\n    chomp $error;\n    $error ||= 'unknown service error';\n  }\n  my $srcmd5 = $files->{'/SERVICE'};\n  if ($error) {\n    addmeta_serviceerror($projid, $packid, $srcmd5, $error);\n    $error =~ s/[\\r\\n]+$//s;\n    $error =~ s/.*[\\r\\n]//s;\n    $error = str2utf8xml($error) || 'unknown service error';\n  } else {\n    addmeta_service($projid, $packid, $files, $srcmd5, $rev->{'srcmd5'});\n  }\n  my $user = $cgi->{'user'};\n  my $comment = $cgi->{'comment'};\n  my $requestid = $cgi->{'requestid'};\n  $user = '' unless defined $user;\n  $user = 'unknown' if $user eq '';\n  $user = str2utf8xml($user);\n  $comment = '' unless defined $comment;\n  $comment = str2utf8xml($comment);\n  if ($error) {\n    notify('SRCSRV_SERVICE_FAIL', {project => $projid, package => $packid,\n\t\t\t\t   error => $error, rev => $rev->{'rev'},\n\t\t\t\t   user => $user, comment => $comment,\n\t\t\t\t   'requestid' => $requestid});\n  } else {\n    notify('SRCSRV_SERVICE_SUCCESS', {project => $projid, package => $packid,\n\t\t\t\t      rev => $rev->{'rev'},\n\t\t\t\t      user => $user, comment => $comment,\n\t\t\t\t      'requestid' => $requestid});\n  }\n}\n\n# store the faked result of a service run. Note that this is done before\n# the addrev call that stores the reference to the run.\n# only used for new style services.\nsub fake_service_run {\n  my ($projid, $packid, $files, $sfiles, $servicemark) = @_;\n  $files->{'/SERVICE'} = $servicemark;\n  $sfiles->{'/SERVICE'} = $servicemark;\n  my $nsrcmd5 = calcsrcmd5($files);\n  addrev_service({}, {'project' => $projid, 'package' => $packid, 'srcmd5' => $nsrcmd5}, $sfiles);\n  delete $files->{'/SERVICE'};\n  delete $sfiles->{'/SERVICE'};\n}\n\n# called *after* addrev to trigger service run\nsub runservice {\n  my ($cgi, $rev, $files) = @_;\n\n  return if !$BSConfig::old_style_services && !$files->{'/SERVICE'};\n\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  die(\"No project defined for source update!\") unless defined $projid;\n  die(\"No package defined for source update!\") unless defined $packid;\n  return if $packid eq '_project';\n\n  my $oldfiles = {};\n  if ($files->{'/SERVICE'}) {\n    # check serialization\n    return unless addmeta_serialize_servicerun($rev->{'project'}, $rev->{'package'}, $files->{'/SERVICE'});\n    # get last servicerun result into oldfiles hash\n    my $revno = $rev->{'rev'};\n    if (length($revno || '') >= 32) {\n      # argh, find commit for that srcmd5\n      $revno = (findlastrev($rev) || {})->{'rev'};\n    }\n    while ($revno && $revno > 1) {\n      $revno = $revno - 1;\t# get the commit before this one\n      eval {\n        my $oldfilerev = getrev($projid, $packid, $revno);\n\t$oldfiles = lsrev_service($oldfilerev) || {};\n      };\n      if ($@) {\n        warn($@);\n        next if $@ =~ /service in progress/;\n      }\n      $oldfiles = {} if !$oldfiles || $oldfiles->{'_service_error'};\n      # strip all non-service results;\n      delete $oldfiles->{$_} for grep {!/^_service:/} keys %$oldfiles;\n      last;\n    }\n  }\n\n  return if $packid eq '_project';\n  return if $rev->{'rev'} && ($rev->{'rev'} eq 'repository' || $rev->{'rev'} eq 'upload');\n\n  # die when a source service is still running\n  my $lockfile = \"$eventdir/service/${projid}::$packid\";\n  die(\"403 service still running\\n\") if $cgi->{'triggerservicerun'} && -e $lockfile;\n\n  my $projectservices;\n  eval {\n    ($projectservices, undef) = getprojectservices({}, $projid, $packid);\n  };\n  if ($@) {\n    addrev_service($cgi, $rev, $files, $@);\n    return;\n  }\n  undef $projectservices unless $projectservices && $projectservices->{'service'} && @{$projectservices->{'service'}};\n\n  # collect current sources to POST them\n  if (!$files->{'_service'} && !$projectservices) {\n    die(\"404 no source service defined!\\n\") if $cgi->{'triggerservicerun'};\n    # drop all existing service files\n    my $dirty;\n    for my $pfile (keys %$files) {\n      if ($pfile =~ /^_service[_:]/) {\n        delete $files->{$pfile};\n        $dirty = 1;\n      }\n    }\n    if ($dirty || $files->{'/SERVICE'}) {\n      addrev_service($cgi, $rev, $files);\n      notify_repservers('package', $projid, $packid);\n    }\n    return;\n  }\n\n  my $linkfiles;\n  if ($files->{'_link'}) {\n    # make sure it's a branch\n    my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);\n    if (!$l || !$l->{'patches'} || @{$l->{'patches'}->{''} || []} != 1 || (keys %{$l->{'patches'}->{''}->[0]})[0] ne 'branch') {\n      #addrev_service($cgi, $rev, $files, \"services only work on branches\\n\");\n      #notify_repservers('package', $projid, $packid);\n      #return;\n      # uh oh, not a branch!\n      $linkfiles = { %$files };\n      delete $files->{'/SERVICE'};\n      eval {\n        $files = handlelinks({%$rev, 'linkrev' => 'base'}, $files);\n        die(\"bad link: $files\\n\") unless ref $files;\n      };\n      if ($@) {\n\tif (($@ =~ /service in progress/) && $linkfiles->{'/SERVICE'}) {\n\t  # delay, hope for an event. remove lock for now to re-trigger the service run.\n\t  addmeta_serviceerror($rev->{'project'}, $rev->{'package'}, $linkfiles->{'/SERVICE'}, undef);\n\t  return;\n\t}\n        $files = $linkfiles;\n        addrev_service($cgi, $rev, $files, $@);\n        notify_repservers('package', $projid, $packid);\n        return;\n      }\n      $files->{'/SERVICE'} = $linkfiles->{'/SERVICE'} if $linkfiles->{'/SERVICE'}\n    }\n  }\n\n  return unless $BSConfig::serviceserver;\n\n  if (!$files->{'/SERVICE'}) {\n    mkdir_p(\"$eventdir/service\");\n    BSUtil::touch($lockfile);\n  }\n\n  my @send = map {{'name' => $_, 'filename' => \"$srcrep/$packid/$files->{$_}-$_\"}} grep {$_ ne '/SERVICE'} sort(keys %$files);\n  push @send, {'name' => '_serviceproject', 'data' => XMLout($BSXML::services, $projectservices)} if $projectservices;\n  push @send, map {{'name' => $_, 'filename' => \"$srcrep/$packid/$oldfiles->{$_}-$_\"}} grep {!$files->{$_}} sort(keys %$oldfiles);\n\n  # run the source update in own process (do not wait for it)\n  my $pid = xfork();\n  return if $pid;\n\n  # child continues...\n  my $odir = \"$srcrep/:service/$$\";\n  BSUtil::cleandir($odir) if -d $odir;\n  mkdir_p($odir);\n  my $receive;\n  eval {\n    $receive = BSRPC::rpc({\n      'uri'       => \"$BSConfig::serviceserver/sourceupdate/$projid/$packid\",\n      'request'   => 'POST',\n      'headers'   => [ 'Content-Type: application/x-cpio' ],\n      'chunked'   => 1,\n      'data'      => \\&BSHTTP::cpio_sender,\n      'cpiofiles' => \\@send,\n      'directory' => $odir,\n      'timeout'   => 3600,\n      'withmd5'   => 1,\n      'receiver' => \\&BSHTTP::cpio_receiver,\n    }, undef);\n  };\n\n  my $error = $@;\n  \n  # make sure that there was no other commit in the meantime\n  if (!$files->{'/SERVICE'}) {\n    my $newrev = getrev($projid, $packid);\n    if ($newrev->{'rev'} ne $rev->{'rev'}) {\n      unlink($lockfile);\n      exit(1);\n    }\n  }\n\n  # and update source repository with the result\n  if ($receive) {\n    # drop all existing service files\n    for my $pfile (keys %$files) {\n      delete $files->{$pfile} if $pfile =~ /^_service[_:]/;\n    }\n    # add new service files\n    eval {\n      for my $pfile (ls($odir)) {\n        if ($pfile eq '.errors') {\n          my $e = readstr(\"$odir/.errors\");\n          $e ||= 'empty .errors file';\n          die($e);\n        }\n\tunless ($pfile =~ /^_service[_:]/) {\n\t  unlink($lockfile);\n\t  die(\"service returned a non-_service file: $pfile\\n\");\n\t}\n\tBSVerify::verify_filename($pfile);\n\t$files->{$pfile} = addfile($projid, $packid, \"$odir/$pfile\", $pfile);\n      }\n    };\n    $error = $@ if $@;\n  } else {\n    $error ||= 'error';\n    $error = \"service daemon error:\\n $error\";\n  }\n  if ($linkfiles) {\n    # argh, a link! put service run result in old filelist\n    if (!$error) {\n      $linkfiles->{$_} = $files->{$_} for grep {/^_service[_:]/} keys %$files;\n    }\n    $files = $linkfiles;\n  }\n  addrev_service($cgi, $rev, $files, $error);\n  BSUtil::cleandir($odir);\n  rmdir($odir);\n  unlink($lockfile);\n  notify_repservers('package', $projid, $packid);\n  exit(0);\n}\n\nsub triggerservicerun {\n  my ($cgi, $projid, $packid) = @_;\n  my $rev = getrev($projid, $packid);\n  my $linkinfo = {};\n  my $files = lsrev($rev, $linkinfo);\n  $cgi->{'triggerservicerun'} = 1;\t# hack\n  if ($BSConfig::old_style_services) {\n    # old style, just run the service again...\n    runservice($cgi, $rev, $files);\n  } else {\n    my $servicemark = genservicemark($projid, $packid, $files);\n    if ($servicemark || $linkinfo->{'xservicemd5'} || $packid eq '_product') {\n      # have to do a new commit...\n      $cgi->{'comment'} ||= 'trigger service run';\n      $cgi->{'servicemark'} = $servicemark;\n      $rev = addrev($cgi, $projid, $packid, $files);\n      runservice($cgi, $rev, $files);\n    } else {\n      die(\"404 no source service defined!\\n\");\n    }\n  }\n  return $BSStdServer::return_ok;\n}\n\n#\n# run the productconverter on _product to create/update/delete\n# all _product:xxx packages\n#\nsub expandproduct {\n  my ($projid, $packid, $rev, $files, $user, $fail) = @_;\n\n  if (!$files) {\n    # gone!\n    # {} argument makes findpackages ignore packages from project links\n    my @packages = grep {/^\\Q${packid}:\\E/} findpackages($projid, {});\n    for my $opid (@packages) {\n      unlink(\"$projectsdir/$projid.pkg/$opid.upload-MD5SUMS\");\n      unlink(\"$projectsdir/$projid.pkg/$opid.rev\");\n      unlink(\"$projectsdir/$projid.pkg/$opid.xml\");\n      notify_repservers('package', $projid, $opid);\n    }\n    return 1;\n  }\n  if ($files->{'_link'}) {\n    eval {\n      $files = handlelinks({ %$rev, 'project' => $projid, 'package' => $packid }, $files);\n      die(\"$files\\n\") unless ref $files;\n    };\n    if ($@) {\n      die($@) if $fail;\n      return undef;\n    }\n  }\n  my $dir = \"$uploaddir/expandproduct_$$\";\n  BSUtil::cleandir($dir);\n  mkdir_p($dir);\n  for my $file (sort keys %$files) {\n    link(\"$srcrep/$packid/$files->{$file}-$file\", \"$dir/$file\") || die(\"link $srcrep/$packid/$files->{$file}-$file $dir/$file: $!\\n\");\n  }\n  my @prods = grep {/.product$/}  sort keys %$files;\n  my %pids;\n  for my $prod (@prods) {\n    print \"converting product $prod\\n\";\n    my $odir = \"$dir/$prod.out\";\n    my $olog = \"$dir/$prod.logfile\";\n    system('rm', '-rf', $odir) if -d $odir;\n    unlink($olog) if -e $olog;\n    mkdir_p($odir);\n    # run product converter and read stdout\n    my $pid;\n    if (!($pid = xfork())) {\n      delete $SIG{'__DIE__'};\n      open(STDOUT, '>>', $olog) || die(\"$olog: $!\\n\");\n      open(STDERR, '>&STDOUT');\n      $| = 1;\n      exec(\"./bs_productconvert\", \"$dir/$prod\", $odir, $projid);\n      die(\"500 bs_productconvert: $!\\n\");\n    }\n    waitpid($pid, 0) == $pid || die(\"500 waitpid $pid: $!\\n\");\n    if ($?) {\n      my $s = readstr($olog);\n      $s =~ s/^\\n+//s;\n      $s =~ s/\\n+$//s;\n      warn(\"bs_productconvert failed: $?\\n\");\n      BSUtil::cleandir($dir);\n      rmdir($dir);\n      die(\"$s\\n\") if $fail;\n      return undef;\n    }\n    my @out = sort(ls($odir));\n    if (!@out) {\n      warn(\"bs_productconvert produced nothing\\n\");\n      BSUtil::cleandir($dir);\n      rmdir($dir);\n      return undef;\n    }\n    for my $p (@out) {\n      my $pdir = \"$odir/$p\";\n      my $pid = $p;\n      $pid =~ s/^_product[_:]//;\n      $pid =~ s/[:\\000-\\037]/_/sg;\n      $pid = \"$packid:$pid\";\n      $pids{$pid} = 1;\n      my %pfiles;\n      for my $pfile (sort(ls($pdir))) {\n        next if $pfile eq '_meta';\n\t$pfiles{$pfile} = addfile($projid, $pid, \"$pdir/$pfile\", $pfile);\n      }\n      my $srcmd5 = addmeta($projid, $pid, \\%pfiles);\n      my @oldrevs = BSFileDB::fdb_getall(\"$projectsdir/$projid.pkg/$pid.rev\", $srcrevlay);\n      if (@oldrevs == 1 && $oldrevs[0]->{'srcmd5'} eq $srcmd5 && $oldrevs[0]->{'rev'}) {\n\t# we're lucky, no change\n\tnext;\n      }\n      mkdir_p(\"$projectsdir/$projid.pkg\");\n      my $prev = {'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => 'autogenerated', 'version' => '1', 'vrev' => '1'};\n      #unlink(\"$projectsdir/$projid.pkg/$pid.rev\");\n      #BSFileDB::fdb_add_i2(\"$projectsdir/$projid.pkg/$pid.rev\", $srcrevlay, $prev, 'vrev', 'version', $prev->{'version'});\n      BSFileDB::fdb_add_i(\"$projectsdir/$projid.pkg/$pid.rev\", $srcrevlay, $prev);\n      if (! -e \"$projectsdir/$projid.pkg/$pid.xml\") {\n        my $pidpack = {\n         'name' => $pid,\n         'title' => $pid,\n         'description' => \"autogenerated from $packid by source server\",\n        };\n\t$pidpack = readxml(\"$pdir/_meta\", $BSXML::pack, 0) if ( -e \"$pdir/_meta\" );\n\twritexml(\"$projectsdir/$projid.pkg/.$pid.xml\", \"$projectsdir/$projid.pkg/$pid.xml\", $pidpack, $BSXML::pack);\n      }\n      rmdir($pdir);\n      notify_repservers('package', $projid, $pid);\n    }\n    rmdir($odir);\n  }\n  BSUtil::cleandir($dir);\n  rmdir($dir);\n  # now do away with the old packages\n  my @packages = grep {/^\\Q${packid}:\\E/} findpackages($projid, {});\n  @packages = grep {!$pids{$_}} @packages;\n  for my $opid (@packages) {\n    unlink(\"$projectsdir/$projid.pkg/$opid.upload-MD5SUMS\");\n    unlink(\"$projectsdir/$projid.pkg/$opid.rev\");\n    unlink(\"$projectsdir/$projid.pkg/$opid.xml\");\n    notify_repservers('package', $projid, $opid);\n  }\n  return 1;\n}\n\n#\n# return version and release of commit\n#\nsub getcommitinfo {\n  my ($projid, $packid, $srcmd5, $files) = @_;\n\n  # get version/release from rpm spec/deb dsc/kiwi xml file\n  my $version = 'unknown';\n  my $release;\n  if ($files->{'_link'}) {\n    # can't know the version/release of a link as it is\n    # a moving target\n    return ('unknown', '0');\n  }\n  my $cfile;\n  $cfile = \"$projectsdir/$projid.conf\" if -e \"$projectsdir/$projid.conf\";\n  my $bconf = Build::read_config('noarch', $cfile);\n  for my $type ('spec', 'dsc', 'kiwi') {\n    my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $srcmd5};\n    my (undef, $file) = findfile($rev, undef, $type, $files);\n    next unless defined $file;\n    my $d = Build::parse($bconf, \"$srcrep/$packid/$files->{$file}-$file\");\n    next unless defined $d->{'version'};\n    $version = $d->{'version'};\n    $release = $d->{'release'} if defined $d->{'release'};\n    $version = 'unknown' if $d->{'multiversion'};\n    last;\n  }\n  if (defined($release)) {\n    if ($release =~ /(\\d+)\\.<B_CNT>/) {\n      $release = $1;\n    } elsif ($release =~ /<RELEASE(\\d+)>/) {\n      $release = $1;\n    } elsif ($release =~ /^(\\d+)/) {\n      $release = $1;\n    } else {\n      $release = '0';\n    }\n  }\n  $release ||= '0';\n  if ($bconf->{'cicntstart'} && $bconf->{'cicntstart'} =~ /(\\d+)$/) {\n    my $r = $release;\n    $release = $bconf->{'cicntstart'};\n    $release =~  s/\\d+$/$r/ if $r > $1;\n  }\n  return ($version, $release);\n}\n\nsub checksourceaccess {\n  my ($projid, $packid) = @_;\n\n  my $proj = readproj($projid, 1);\n  return unless $proj;\n  my $pack = readpack($projid, $packid, 1);\n  my $sourceaccess = 1;\n  $sourceaccess = BSUtil::enabled('', $proj->{'sourceaccess'}, $sourceaccess, '');\n  $sourceaccess = BSUtil::enabled('', $pack->{'sourceaccess'}, $sourceaccess, '') if $pack;\n  die(\"403 source access denied\\n\") unless $sourceaccess;\n  my $access = 1;\n  $access = BSUtil::enabled('', $proj->{'access'}, $access, '');\n  $access = BSUtil::enabled('', $pack->{'access'}, $access, '') if $pack;\n  die(\"404 package '$packid' does not exist\\n\") unless $access;\t# hmm...\n  return 1;\n}\n\n###########################################################################\n###\n###  low level source handling: tree and revision management\n###\n\nsub repgitdir {\n  my ($rev) = @_;\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  my $gitdir = \"$projectsdir/$projid.pkg/$packid.git\";\n  die(\"$projid/$packid is not a git repository\\n\") unless -d $gitdir;\n  return $gitdir;\n}\n\nsub repstat_git {\n  my ($rev, $filename, $id) = @_;\n  my $gitdir = repgitdir($rev);\n  open(F, '-|', 'git', \"--git-dir=$gitdir\", 'cat-file', '-s', $id) || return ();\n  my $size= '';\n  1 while sysread(F, $size, 4096, length($size));\n  if (!close(F)) {\n    $! = POSIX::ENOENT;\n    return ();\n  }\n  my @s = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  $s[7] = 0 + $size;\n  return @s;\n}\n\nsub repopen_git {\n  my ($rev, $filename, $id, $fd) = @_;\n  my $gitdir = repgitdir($rev);\n  return open($fd, '-|', 'git', \"--git-dir=$gitdir\", 'cat-file', 'blob', $id);\n}\n\n\nsub repstat {\n  my ($rev, $filename, $md5) = @_;\n  return repstat_git($rev, $filename, $md5) if length($md5) == 40;\n  return stat(repfilename($rev, $filename, $md5)) if $filename eq '_serviceerror';\n  return stat(\"$srcrep/$rev->{'package'}/$md5-$filename\");\n}\n\nsub repopen {\n  my ($rev, $filename, $md5, $fd) = @_;\n  return repopen_git($rev, $filename, $md5, $fd) if length($md5) == 40;\n  return open($fd, '<', repfilename($rev, $filename, $md5)) if $filename eq '_serviceerror';\n  return open($fd, '<', \"$srcrep/$rev->{'package'}/$md5-$filename\");\n}\n\nsub repreadstr {\n  my ($rev, $filename, $md5, $nonfatal) = @_;\n  my $packid = $rev->{'package'};\n  return readstr(\"$srcrep/$packid/$md5-$filename\", $nonfatal);\n}\n\nsub repreadxml {\n  my ($rev, $filename, $md5, $dtd, $nonfatal) = @_;\n  my $packid = $rev->{'package'};\n  return readxml(\"$srcrep/$packid/$md5-$filename\", $dtd, $nonfatal);\n}\n\nsub repfilename {\n  my ($rev, $filename, $md5) = @_;\n  if ($filename eq '_serviceerror') {\n    # sigh, _serviceerror files live in the trees...\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$rev->{'project'}/$rev->{'package'}\" : \"$treesdir/$rev->{'package'}\";\n    return \"$treedir/$md5-_serviceerror\" if -e \"$treedir/$md5-_serviceerror\";\n  }\n  return \"$srcrep/$rev->{'package'}/$md5-$filename\";\n}\n\n#\n# add a file to the repository\n#\nsub addfile {\n  my ($projid, $packid, $tmpfile, $filename, $md5) = @_;\n\n  if (!$md5) {\n    open(F, '<', $tmpfile) || die(\"$tmpfile: $!\\n\");\n    my $ctx = Digest::MD5->new;\n    $ctx->addfile(*F);\n    close F;\n    $md5 = $ctx->hexdigest();\n  }\n  if (! -e \"$srcrep/$packid/$md5-$filename\") {\n    if (!rename($tmpfile, \"$srcrep/$packid/$md5-$filename\")) {\n      mkdir_p(\"$srcrep/$packid\");\n      if (!rename($tmpfile, \"$srcrep/$packid/$md5-$filename\")) {\n        my $err = $!;\n        if (! -e \"$srcrep/$packid/$md5-$filename\") {\n          $! = $err;\n          die(\"rename $tmpfile $srcrep/$packid/$md5-$filename: $!\\n\");\n        }\n      }\n    }\n  } else {\n    unlink($tmpfile);\n  }\n  return $md5;\n}\n\n#\n# make files available in oprojid/opackid available from projid/packid\n#\nsub copyfiles {\n  my ($projid, $packid, $oprojid, $opackid, $files, $except) = @_;\n\n  return if $packid eq $opackid;\n  return unless %$files;\n  mkdir_p(\"$srcrep/$packid\");\n  for my $f (sort keys %$files) {\n    next if $except && $except->{$f};\n    next if -e \"$srcrep/$packid/$files->{$f}-$f\";\n    link(\"$srcrep/$opackid/$files->{$f}-$f\", \"$srcrep/$packid/$files->{$f}-$f\");\n    die(\"link error $srcrep/$opackid/$files->{$f}-$f\\n\") unless -e \"$srcrep/$packid/$files->{$f}-$f\";\n  }\n}\n\nsub getrev_git {\n  my ($projid, $packid, $rev) = @_;\n  my $gitdir = \"$projectsdir/$projid.pkg/$packid.git\";\n  die(\"$projid/$packid is not a git repository\") unless -d $gitdir;\n  if (!$rev) {\n    my $master = readstr(\"$gitdir/refs/heads/master\");\n    chomp $master;\n    $rev = $master;\n  }\n  die(\"revision is not a valid git id\\n\") unless $rev =~ /^[0-9a-f]{40}/s;\n  open(F, '-|', 'git', \"--git-dir=$gitdir\", 'cat-file', 'commit', $rev) || return undef;\n  my $commit = '';\n  1 while sysread(F, $commit, 4096, length($commit));\n  close F;\n  $commit =~ s/.*?\\n\\n//;\n  $rev = {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};\n  $rev->{'comment'} = $commit if $commit ne '';\n  return $rev;\n}\n\nsub get_frozenlinks {\n  my ($projid) = @_;\n  return $frozenlinks_cache->{$projid} if $frozenlinks_cache && exists $frozenlinks_cache->{$projid};\n  my $rev = getrev_meta($projid);\n  my $files = lsrev($rev);\n  my $frozen;\n  if ($files->{'_frozenlinks'}) {\n    my $frozenx = repreadxml($rev, '_frozenlinks', $files->{'_frozenlinks'}, $BSXML::frozenlinks);\n    $frozen = {};\n    for my $fp (@{$frozenx->{'frozenlink'} || []}) {\n      my $n = defined($fp->{'project'}) ? $fp->{'project'} : '/all';\n      for my $p (@{$fp->{'package'} || []}) {\n\tmy $pn = delete $p->{'name'};\n        $frozen->{$n}->{$pn} = $p if defined($pn) && $p->{'srcmd5'};\n      }\n    }\n  }\n  $frozenlinks_cache->{$projid} = $frozen if $frozenlinks_cache;\n  return $frozen;\n}\n\n#\n# get a revision object from a revision identifier\n#\nsub getrev {\n  my ($projid, $packid, $rev, $linked, $missingok) = @_;\n  die(\"bad projid\\n\") if $projid =~ /\\// || $projid =~ /^\\./;\n  die(\"bad packid\\n\") if $packid =~ /\\// || $packid =~ /^\\./;\n  if ($packid ne '_project' && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n    my $proj = readproj($projid, 1);\n    if ($proj && $proj->{'link'}) {\n      my $collect_error;\n      $linked ||= [];\n      my $frozen = get_frozenlinks($projid);\n      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {\n\tnext if $lprojid eq $projid;\n\tnext if grep {$_->{'project'} eq $lprojid && $_->{'package'} eq $packid} @$linked;\n\tpush @$linked, {'project' => $lprojid, 'package' => $packid};\n        my $frozenp = $frozen->{'/all'} || $frozen->{$lprojid};\n\tmy $lrev;\n        if ($frozenp->{$packid} && !($rev && $rev =~ /^[0-9a-f]{32}$/)) {\n\t  eval {\n\t    $lrev = getrev($lprojid, $packid, $frozenp->{$packid}->{'srcmd5'}, $linked, $missingok);\n\t    $lrev->{'vrev'} = $frozenp->{$packid}->{'vrev'} if defined $frozenp->{$packid}->{'vrev'};\n\t  };\n\t} else {\n\t  eval {\n\t    $lrev = getrev($lprojid, $packid, $rev, $linked, $missingok);\n\t  };\n\t}\n\tnext if $collect_error;\n\tif ($@ && $@ !~ /^404/) {\n\t  if ($collect_remote_getrev && $@ =~ /collect_remote_getrev$/) {\n\t    # special case for project links, we don't know if the package exists yet,\n\t    # so collect from all link elements\n\t    $collect_error = $@;\n\t    next;\n\t  }\n\t  die($@);\n\t}\n\tif ($lrev) {\n\t  # make sure that we may access the sources of this package\n\t  checksourceaccess($lprojid, $packid);\n\t  my $files = lsrev($lrev);\n\t  copyfiles($projid, $packid, $lprojid, $packid, $files);\n\t  my $srcmd5 = $lrev->{'srcmd5'};\n\t  if ($BSConfig::nosharedtrees && $srcmd5 ne $emptysrcmd5) {\n\t    # copy the tree\n\t    my $treedir = \"$treesdir/$projid/$packid\";\n\t    if (! -e \"$treedir/$srcmd5-MD5SUMS\") {\n\t      my $ltreedir = \"$treesdir/$lprojid/$packid\";\n\t      $ltreedir = \"$srcrep/$packid\" if $BSConfig::nosharedtrees == 2 && ! -e \"$ltreedir/$srcmd5-MD5SUMS\";\n\t      if (-e \"$ltreedir/$srcmd5-MD5SUMS\") {\n\t\tmy $meta = readstr(\"$ltreedir/$srcmd5-MD5SUMS\");\n\t        mkdir_p($treedir);\n\t\twritestr(\"$uploaddir/$$\", \"$treedir/$srcmd5-MD5SUMS\", $meta);\n\t      } else {\n\t\taddmeta($projid, $packid, $files);\t# last resort...\n\t      }\n\t    }\n\t  }\n\t  $lrev->{'originproject'} ||= $lprojid;\n\t  $lrev->{'project'} = $projid;\n\t  return $lrev;\n\t}\n      }\n      die($collect_error) if $collect_error;\n    }\n    if (defined($rev) && $rev =~ /^[0-9a-f]{32}$/) {\n      # getrev by srcmd5. we allow access to packages that were deleted.\n      my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n      if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e \"$treedir/$rev-MD5SUMS\") {\n\t$treedir = \"$srcrep/$packid\";\n      }\n      if ($rev eq $emptysrcmd5 || -e \"$treedir/$rev-MD5SUMS\") {\n        # tree exists. make sure we knew the project/package at one time in the past\n        if (-e \"$projectsdir/$projid.pkg/$packid.mrev.del\" ||\n            -e \"$projectsdir/_deleted/$projid.pkg/$packid.mrev\" ||\n            -e \"$projectsdir/_deleted/$projid.pkg/$packid.mrev.del\") {\n          return {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};\n        }\n      }\n    }\n    return remote_getrev($projid, $packid, $rev, $linked, $missingok);\n  }\n  undef $rev if $rev && ($rev eq 'latest' || $rev eq 'build');\n  undef $rev if $rev && $rev eq 'upload' && ! -e \"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\";\n  if (!defined($rev)) {\n    $rev = BSFileDB::fdb_getlast(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay);\n    if (!$rev && -d \"$projectsdir/$projid.pkg/$packid.git\") {\n      return getrev_git($projid, $packid);\n    }\n    if (!$rev && ($packid eq '_project' && -e \"$projectsdir/$projid.conf\")) {\n      addrev_meta({'user' => 'internal', 'comment' => 'initial commit'}, $projid, undef, undef, undef, undef, 'rev');\n      $rev = BSFileDB::fdb_getlast(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay);\n    }\n    $rev = {'srcmd5' => $emptysrcmd5} unless $rev;\n  } elsif ($rev =~ /^[0-9a-f]{32}$/) {\n    return undef unless -e \"$projectsdir/$projid.pkg/$packid.rev\" || -e \"$projectsdir/$projid.pkg/$packid.mrev\";\n    $rev = {'srcmd5' => $rev, 'rev' => $rev};\n  } elsif ($rev =~ /^[0-9a-f]{40}$/) {\n    return getrev_git($projid, $packid, $rev);\n  } elsif ($rev eq 'upload') {\n    $rev = {'srcmd5' => 'upload', 'rev' => 'upload'}\n  } elsif ($rev eq 'repository') {\n    $rev = {'srcmd5' => $emptysrcmd5, 'rev' => 'repository'}\n  } else {\n    if ($rev eq '0') {\n      $rev = {'srcmd5' => $emptysrcmd5};\n    } else {\n      $rev = BSFileDB::fdb_getmatch(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, 'rev', $rev);\n      die(\"no such revision\\n\") unless defined $rev;\n    }\n  }\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n  return $rev;\n}\n\n# get a revision object for a deleted project/package\n# XXX: fold into getrev\nsub getrev_deleted {\n  my ($projid, $packid, $rev) = @_;\n  undef $rev if $rev && ($rev eq 'latest' || $rev eq 'build');\n  return getrev($projid, $packid, $rev) if defined($rev) && $rev !~ /^\\d{1,31}$/;\n  my $revfile = $packid ne '_project' ? \"$projectsdir/$projid.pkg/$packid.rev.del\" : \"$projectsdir/_deleted/$projid.pkg/_project.rev\";\n  if ($packid ne '_project' && ! -e $revfile && ! -e \"$projectsdir/$projid.xml\" && -e \"$projectsdir/_deleted/$projid.pkg\") {\n    $revfile = \"$projectsdir/_deleted/$projid.pkg/$packid.rev\";\n  }\n  if (!defined($rev)) {\n    $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);\n  } elsif ($rev eq '0') {\n    $rev = {'srcmd5' => $emptysrcmd5};\n  } else {\n    $rev = BSFileDB::fdb_getmatch($revfile, $srcrevlay, 'rev', $rev);\n  }\n  die(\"no such revision\\n\") unless defined $rev;\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n  return $rev;\n}\n\nsub addmeta {\n  my ($projid, $packid, $files, $rev) = @_;\n\n  # calculate new meta sum\n  my $meta = '';\n  $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n  my $srcmd5 = Digest::MD5::md5_hex($meta);\n  if ($rev && $rev eq 'upload') {\n    mkdir_p($uploaddir);\n    mkdir_p(\"$projectsdir/$projid.pkg\");\n    writestr(\"$uploaddir/addmeta$$\", \"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\", $meta);\n  } else {\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n    if (! -e \"$treedir/$srcmd5-MD5SUMS\") {\n      mkdir_p($uploaddir);\n      mkdir_p($treedir);\n      writestr(\"$uploaddir/addmeta$$\", \"$treedir/$srcmd5-MD5SUMS\", $meta);\n    }\n  }\n  return $srcmd5;\n}\n\n# used only in fake_service_run. must match addmeta\nsub calcsrcmd5 {\n  my ($files) = @_;\n  my $meta = '';\n  $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n  return Digest::MD5::md5_hex($meta);\n}\n\n# like addmeta, but adds link information. also stores\n# under the \"wrong\" md5sum.\nsub addmeta_link {\n  my ($projid, $packid, $files, $srcmd5, $linkinfo) = @_;\n\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  if (! -e \"$treedir/$srcmd5-MD5SUMS\") {\n    my $meta = '';\n    $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n    $meta .= \"$linkinfo->{'srcmd5'}  /LINK\\n\";\n    $meta .= \"$linkinfo->{'lsrcmd5'}  /LOCAL\\n\";\n    mkdir_p($uploaddir);\n    mkdir_p($treedir);\n    writestr(\"$uploaddir/$$\", \"$treedir/$srcmd5-MD5SUMS\", $meta);\n  }\n}\n\n\n# like addmeta, but adds service information after a source\n# service finished successfully. stores under the \"wrong\" md5sum.\nsub addmeta_service {\n  my ($projid, $packid, $files, $srcmd5, $lservicemd5) = @_;\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  return if -e \"$treedir/$srcmd5-MD5SUMS\";\t# huh? why did we run twice?\n  my $meta = '';\n  $meta .= \"$files->{$_}  $_\\n\" for grep {$_ ne '/SERVICE' && $_ ne '/LSERVICE'} sort keys %$files;\n  $meta .= \"$lservicemd5  /LSERVICE\\n\";\n  mkdir_p($uploaddir);\n  mkdir_p($treedir);\n  writestr(\"$uploaddir/$$\", \"$treedir/$srcmd5-MD5SUMS\", $meta);\n  unlink(\"$treedir/$srcmd5-_serviceerror\");\n}\n\nsub addmeta_serviceerror {\n  my ($projid, $packid, $srcmd5, $error) = @_;\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  if (!defined($error)) {\n    unlink(\"$treedir/$srcmd5-_serviceerror\");\n  } else {\n    # normalize the error\n    $error =~ s/[\\r\\n]+$//s;\n    $error ||= 'unknown service error';\n    mkdir_p($treedir);\n    writestr(\"$treedir/.$srcmd5-_serviceerror\", \"$treedir/$srcmd5-_serviceerror\", \"$error\\n\");\n  }\n}\n\nsub addmeta_serialize_servicerun {\n  my ($projid, $packid, $srcmd5) = @_;\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  mkdir_p($treedir);\n  local *FF;\n  BSUtil::lockopen(\\*FF, '+>>', \"$treedir/$srcmd5-_serviceerror\");\n  if (-s FF) {\n    # already running or failed!\n    close FF;\t# free lock\n    return undef;\n  }\n  writestr(\"$treedir/.$srcmd5-_serviceerror\", \"$treedir/$srcmd5-_serviceerror\", \"service in progress\\n\");\n  close FF;\t# free lock\n  return 1;\n}\n\nsub updatelinkinfodb {\n  my ($projid, $packid, $rev, $files) = @_;\n\n  mkdir_p($sourcedb) unless -d $sourcedb;\n  my $linkdb = BSDB::opendb($sourcedb, 'linkinfo');\n  my $linkinfo;\n  if ($files && $files->{'_link'}) {\n    my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);\n    if ($l) {\n      $linkinfo = {};\n      $linkinfo->{'project'} = defined $l->{'project'} ? $l->{'project'} : $projid;\n      $linkinfo->{'package'} = defined $l->{'package'} ? $l->{'package'} : $packid;\n      $linkinfo->{'rev'} = $l->{'rev'} if defined $l->{'rev'};\n    }\n  }\n  $linkdb->store(\"$projid/$packid\", $linkinfo);\n}\n\n# ugly hack to support 'noservice' uploads. we fake a service run\n# result and strip all files from the commit that look like they\n# were generated by a service run.\n\nsub can_reuse_oldservicemark {\n  my ($projid, $packid, $files, $oldservicemark) = @_;\n\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  return 0 if -e \"$treedir/$oldservicemark-_serviceerror\";\n  my $oldmeta = readstr(\"$treedir/$oldservicemark-MD5SUMS\", 1);\n  # does not exist -> reuse it and hope for the best\n  return 1 if !$oldmeta;\n  # be extra carful here and make sure our data matches\n  # calculate LSRCMD5 from file list\n  my $nfiles = { %$files };\n  delete $nfiles->{$_} for grep {/^_service[:_]/} keys %$nfiles;\n  $nfiles->{'/SERVICE'} = $oldservicemark;\n  my $meta = '';\n  $meta .= \"$nfiles->{$_}  $_\\n\" for sort keys %$nfiles;\n  my $nsrcmd5 = Digest::MD5::md5_hex($meta);\n  # calculate new meta\n  $meta = '';\n  $meta .= \"$files->{$_}  $_\\n\" for grep {$_ ne '/SERVICE' && $_ ne '/LSERVICE'} sort keys %$files;\n  $meta .= \"$nsrcmd5  /LSERVICE\\n\";\n  return 1 if $oldmeta eq $meta;\n  return 0;\n}\n\nsub servicemark_noservice {\n  my ($cgi, $projid, $packid, $files, $target, $oldservicemark) = @_;\n\n  my $servicemark;\n  if (exists($cgi->{'servicemark'})) {\n    $servicemark = $cgi->{'servicemark'};\n  } else {\n    # if not given via cgi, autodetect\n    if ($oldservicemark && can_reuse_oldservicemark($projid, $packid, $files, $oldservicemark)) {\n      $servicemark = $oldservicemark;\n    } else {\n      if ($files->{'_service'} || grep {/^_service[:_]/} keys %$files) {\n        $servicemark = genservicemark($projid, $packid, $files, $target, 1);\n      }\n    }\n  }\n  return (undef, $files) unless $servicemark;\n\n  # ok, fake a service run\n  my $nfiles = { %$files };\n  delete $nfiles->{$_} for grep {/^_service[:_]/} keys %$nfiles;\n  fake_service_run($projid, $packid, $nfiles, $files, $servicemark);\n  return ($servicemark, $nfiles);\n}\n\n##\n# generate_commit_flist($files_old, $files_new)\n#\n#   $files_old/$files_new are hash references as returned by lsrep\n#\n#   returns a list of changed files categorized similar to svn commit mails\n#\nsub generate_commit_flist {\n  my $ret = \"\";\n  my %categorized_files;\n  my ($files_old, $files_new) = @_;\n  my %files_all = (%$files_new, %$files_old);\n  for my $fname (sort keys %files_all) {\n    if(!$files_old->{$fname}) {\n      my $flist = $categorized_files{\"Added:\"} ||= [];\n      push(@$flist, $fname);\n    } elsif(!$files_new->{$fname}) {\n      my $flist = $categorized_files{\"Deleted:\"} ||= [];\n      push(@$flist, $fname);\n    } elsif($files_old->{$fname} ne $files_new->{$fname}) {\n      my $flist = $categorized_files{\"Modified:\"} ||= [];\n      push(@$flist, $fname);\n    }\n  }\n\n  for my $cat (sort keys %categorized_files) {\n    $ret .= \"$cat\\n\";\n    for my $fname (@{$categorized_files{$cat}}) {\n      $ret .= \"  $fname\\n\";\n    }\n    $ret .= \"\\n\";\n  }\n  return $ret;\n}\n\n#\n# create a new revision from a file list, returns revision object\n#\nsub addrev {\n  my ($cgi, $projid, $packid, $files, $target) = @_;\n  die(\"404 project '$projid' does not exist\\n\") unless -e \"$projectsdir/$projid.xml\";\n  if ($packid =~ /^_product:/) {\n    die(\"403 package '$packid' is read-only if a '_product' package exists\\n\") if -e \"$projectsdir/$projid.pkg/_product.xml\";\n  }\n  my $user = $cgi->{'user'};\n  my $comment = $cgi->{'comment'};\n  my $requestid = $cgi->{'requestid'};\n  $user = '' unless defined $user;\n  $user = 'unknown' if $user eq '';\n  $comment = '' unless defined $comment;\n  $user = str2utf8xml($user);\n  $comment = str2utf8xml($comment);\n\n  # check if the commit will need a service run\n  my $servicemark;\n  delete $files->{'/SERVICE'};\t# just in case...\n  if (!$BSConfig::old_style_services && $packid ne '_project') {\n    if ($cgi->{'noservice'}) {\n      ($servicemark, $files) = servicemark_noservice($cgi, $projid, $packid, $files, $target);\n    } else {\n      # we do not want any generated files in the commit!\n      delete $files->{$_} for grep {/^_service[:_]/} keys %$files;\n      $servicemark = exists($cgi->{'servicemark'}) ? $cgi->{'servicemark'} : genservicemark($projid, $packid, $files, $target);\n    }\n  }\n  if ($packid eq '_pattern' && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n    # upgrade pseudo _pattern package to real package\n    my $pack = {\n      'name' => $packid,\n      'project' => $projid,\n      'title' => 'pseudo package to store pattern information',\n      'description' => \"pseudo package to store pattern information\\n\",\n    };\n    mkdir_p($uploaddir);\n    writexml(\"$uploaddir/$$.2\", undef, $pack, $BSXML::pack);\n    mkdir_p(\"$projectsdir/$projid.pkg\");\n    addrev_meta($cgi, $projid, $packid, \"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/$packid.xml\", '_meta');\n  }\n  die(\"404 package '$packid' does not exist\\n\") unless $packid eq '_project' || -e \"$projectsdir/$projid.pkg/$packid.xml\";\n  if ($target && $target eq 'upload') {\n    my $srcmd5 = addmeta($projid, $packid, $files, 'upload');\n    my $filenames = join( ', ', keys %$files );\n    notify(\"SRCSRV_UPLOAD\", {project => $projid, package => $packid, filename => $filenames, comment => $comment, \n                             target => $target, requestid => $requestid, user => $user});\n    return {'project' => $projid, 'package' => $packid, 'rev' => 'upload', 'srcmd5' => $srcmd5};\n  } elsif ($target && $target eq 'repository') {\n    # repository only upload.\n    return {'project' => $projid, 'package' => $packid, 'rev' => 'repository', 'srcmd5' => $emptysrcmd5};\n  } elsif (defined($target)) {\n    # internal version only upload.\n    my $srcmd5 = addmeta($projid, $packid, $files);\n    return {'project' => $projid, 'package' => $packid, 'rev' => $srcmd5, 'srcmd5' => $srcmd5};\n  }\n  die(\"bad projid\\n\") if $projid =~ /\\// || $projid =~ /^\\./;\n  die(\"bad packid\\n\") if $packid =~ /\\// || $packid =~ /^\\./;\n  die(\"bad files (slash)\\n\") if grep {/\\// && $_ ne '/SERVICE'} keys %$files;\n  die(\"bad files (glyph)\\n\") if grep {!/^[0-9a-f]{32}$/} values %$files;\n\n  if ($files->{'_patchinfo'}) {\n    die(\"bad files in patchinfo container\\n\") if grep {$_ ne '_patchinfo'} keys %$files;\n    my $p = repreadxml({'project' => $projid, 'package' => $packid}, '_patchinfo', $files->{'_patchinfo'}, $BSXML::patchinfo);\n    BSVerify::verify_patchinfo($p);\n  }\n\n  # create tree entry\n  $files->{'/SERVICE'} = $servicemark if $servicemark;\n  my $srcmd5 = addmeta($projid, $packid, $files);\n  delete $files->{'/SERVICE'};\n\n  my $rev = {'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $requestid};\n\n  if ($packid eq '_product') {\n    expandproduct($projid, $packid, $rev, $files, $user, 1);\n  }\n\n  if ($packid ne '_project' && $packid ne '_pattern') {\n    my ($version, $release) = getcommitinfo($projid, $packid, $srcmd5, $files);\n    $rev->{'version'} = $version;\n    $rev->{'vrev'} = $release;\n  }\n  \n  my $rev_old = getrev($projid, $packid);\n  $rev_old->{'keepsignkey'} = 1;\n  my $files_old = lsrev($rev_old);\n  delete $rev_old->{'keepsignkey'};\n  my $filestr = generate_commit_flist($files_old, $files);\n\n  $rev->{'version'} = $cgi->{'version'} if defined $cgi->{'version'};\n  $rev->{'vrev'} = $cgi->{'vrev'} if defined $cgi->{'vrev'};\n  if ($cgi->{'time'}) {\n    die(\"specified time is less than time in last commit\\n\") if ($rev_old->{'time'} || 0) > $cgi->{'time'};\n    $rev->{'time'} = $cgi->{'time'};\n  }\n\n  my $acceptinfo;\n  if ($requestid) {\n    $acceptinfo = {};\n    $acceptinfo->{'osrcmd5'} = $rev_old->{'srcmd5'} if $rev_old->{'srcmd5'} ne 'empty';\n    if ($files_old->{'_link'}) {\n      # see if we can expand it\n      eval {\n\tmy %rev = %$rev_old;\n\thandlelinks(\\%rev, $files_old);\n\t$acceptinfo->{'oxsrcmd5'} = $rev{'srcmd5'};\n      };\n    }\n  }\n  if ($packid eq '_project') {\n    $rev = BSFileDB::fdb_add_i(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, $rev);\n    $rev->{'project'} = $projid;\n    $rev->{'package'} = $packid;\n    if ($acceptinfo) {\n      $acceptinfo->{'rev'} = $rev->{'rev'};\n      $acceptinfo->{'srcmd5'} = $rev->{'srcmd5'};\n      $rev->{'acceptinfo'} = $acceptinfo if $cgi->{'withacceptinfo'};\n    }\n    extract_old_prjsource($projid, $rev);\n    unlink(\"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\");\n    notify_repservers('project', $projid);\n    notify(\"SRCSRV_UPDATE_PROJECT_CONFIG\", { \"project\" => $projid, \"files\" => $filestr, \"comment\" => $comment, \"sender\" => $user });\n    return $rev;\n  }\n\n  # help a little with link<->nolink and singleversion<->multiversion changes\n  if (defined($rev->{'version'}) && defined($rev_old->{'version'}) && !defined($cgi->{'vrev'})) {\n    # if this is a known -> unknown version change, max with vrev of last commit\n    # same for unknown -> known\n    if (($rev->{'version'} eq 'unknown' && $rev_old->{'version'} ne 'unknown') ||\n        ($rev->{'version'} ne 'unknown' && $rev_old->{'version'} eq 'unknown')) {\n      my $l_old = 0;\n      $l_old = $1 if $rev_old->{'vrev'} =~ /(\\d+)$/;\n      my $l_new = 0;\n      $l_new = $1 if $rev->{'vrev'} =~ /(\\d+)$/;\n      $rev->{'vrev'} =~ s/\\d+$/$l_old + 1/e if $l_old + 1 > $l_new;\n    }\n  }\n\n  # add to revision database\n  if (defined($rev->{'version'}) && !defined($cgi->{'vrev'})) {\n    $rev = BSFileDB::fdb_add_i2(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, $rev, 'vrev', 'version', $rev->{'version'});\n  } else {\n    $rev = BSFileDB::fdb_add_i(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, $rev);\n  }\n\n  # add missing data to complete the revision object\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n\n  # update linked package database\n  updatelinkinfodb($projid, $packid, $rev, $files);\n\n  # update request acceptinfo\n  if ($acceptinfo) {\n    $acceptinfo->{'rev'} = $rev->{'rev'};\n    $acceptinfo->{'srcmd5'} = $rev->{'srcmd5'};\n    if ($files->{'_link'}) {\n      # see if we can expand it\n      eval {\n\tmy %rev = %$rev;\n\thandlelinks(\\%rev, $files);\n\t$acceptinfo->{'xsrcmd5'} = $rev{'srcmd5'};\n      };\n    }\n    $rev->{'acceptinfo'} = $acceptinfo if $cgi->{'withacceptinfo'};\n  }\n\n  # send out notification\n  notify(\"SRCSRV_COMMIT\", {project => $projid, package => $packid, files => $filestr, rev => $rev->{'rev'}, user => $user, comment => $comment, 'requestid' => $requestid});\n  $rev_old->{'version'} = \"unknown\" unless defined($rev_old->{'version'});\n  notify(\"SRCSRV_VERSION_CHANGE\", {project => $projid, package => $packid, files => $filestr, rev => $rev->{'rev'},\n                                   oldversion => $rev_old->{'version'}, newversion => $rev->{'version'},\n                                   user => $user, comment => $comment, 'requestid' => $requestid})\n    if defined($rev->{'version'}) && defined($rev_old->{'version'}) && $rev->{'version'} ne $rev_old->{'version'};\n\n  # kill upload revision as we did a real commit\n  unlink(\"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\");\n  # kill obsolete _pattern file\n  unlink(\"$projectsdir/$projid.pkg/pattern-MD5SUMS\") if $packid eq '_pattern';\n\n  notify_repservers('package', $projid, $packid);\n\n  # put marker back\n  $files->{'/SERVICE'} = $servicemark if $servicemark;\n  return $rev;\n}\n\nsub lsrev_git {\n  my ($rev, $linkinfo) = @_;\n  my $id = $rev->{'srcmd5'};\n  local *F;\n  my $gitdir = repgitdir($rev);\n  open(F, '-|', 'git', \"--git-dir=$gitdir\", 'cat-file', 'tree', $id) || die(\"git: $!\\n\");\n  my $tree = '';\n  1 while sysread(F, $tree, 4096, length($tree));\n  close(F) || die(\"bad id\\n\");\n  my $files = {};\n  while ($tree =~ /(\\d+) ([^\\000]*)\\000(.{20})/sg) {\n    next if $1 eq '40000';\t\t# ignore dirs for now\n    next if substr($2, 0, 1) eq '.';\t# ignore files starting with . for now\n    $files->{$2} = unpack('H*', $3);\n  }\n  return $files;\n}\n\n#\n# retrieve the file list of a revision object or tree object\n# store merge info in linkinfo if available\n#\nsub lsrev {\n  my ($rev, $linkinfo) = @_;\n\n  die(\"nothing known\\n\") unless $rev;\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  my $srcmd5 = $rev->{'srcmd5'};\n  die(\"revision project missing\\n\") unless defined $projid;\n  die(\"revision package missing\\n\") unless defined $packid;\n  die(\"no such revision\\n\") unless defined $srcmd5;\n  local *F;\n  die(\"bad packid\\n\") if $packid =~ /\\// || $packid =~ /^\\./;\n  if ($srcmd5 eq 'upload') {\n    open(F, '<', \"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\") || die(\"$packid/$srcmd5-$packid: not in repository\\n\");\n  } elsif ($srcmd5 eq 'pattern') {\n    open(F, '<', \"$projectsdir/$projid.pkg/pattern-MD5SUMS\") || return {};\n  } elsif ($srcmd5 eq 'empty' || $srcmd5 eq $emptysrcmd5) {\n    return {};\n  } elsif (length($srcmd5) == 40) {\n     return lsrev_git($rev, $linkinfo);\n  } else {\n    die(\"bad srcmd5 '$srcmd5'\\n\") if $srcmd5 !~ /^[0-9a-f]{32}$/;\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n    if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e \"$treedir/$srcmd5-MD5SUMS\" && -e \"$srcrep/$packid/$srcmd5-MD5SUMS\") {\n      $treedir = \"$srcrep/$packid\";\n    }\n    if (!open(F, '<', \"$treedir/$srcmd5-MD5SUMS\")) {\n      return {'_linkerror' => $srcmd5} if -e \"$srcrep/$packid/$srcmd5-_linkerror\";\n      return {'_serviceerror' => $srcmd5} if -s \"$treedir/$srcmd5-_serviceerror\";\n      die(\"$projid/$packid/$srcmd5: not in repository. Either not existing or misconfigured server setting for '\\$nosharedtrees' setting in BSConfig.pm\\n\");\n    }\n  }\n  my @files = <F>;\n  close F;\n  chomp @files;\n  my $files = {map {substr($_, 34) => substr($_, 0, 32)} @files};\n  # hack: do not list _signkey in project meta\n  delete $files->{'_signkey'} if $packid eq '_project' && !$rev->{'keepsignkey'};\n  if ($linkinfo) {\n    $linkinfo->{'lsrcmd5'} = $files->{'/LOCAL'} if $files->{'/LOCAL'};\n    $linkinfo->{'srcmd5'} = $files->{'/LINK'} if $files->{'/LINK'};\n    $linkinfo->{'xservicemd5'} = $files->{'/SERVICE'} if $files->{'/SERVICE'};\n    $linkinfo->{'lservicemd5'} = $files->{'/LSERVICE'} if $files->{'/LSERVICE'};\n  }\n  delete $files->{'/LINK'};\n  delete $files->{'/LOCAL'};\n  delete $files->{'/SERVICE'};\n  delete $files->{'/LSERVICE'};\n  return $files;\n}\n\n\n# find last revision that consisted of the tree object\nsub findlastrev {\n  my ($tree) = @_;\n  my $rev = BSFileDB::fdb_getmatch(\"$projectsdir/$tree->{'project'}.pkg/$tree->{'package'}.rev\", $srcrevlay, 'srcmd5', $tree->{'srcmd5'});\n  return undef unless $rev;\n  $rev->{'project'} = $tree->{'project'};\n  $rev->{'package'} = $tree->{'package'};\n  return $rev;\n}\n\n\n\n###########################################################################\n###\n###  source link handling\n###\n\nsub patchspec {\n  my ($p, $dir, $spec) = @_;\n  local *F;\n  open(F, '<', \"$dir/$spec\") || die(\"$dir/$spec: $!\\n\");\n  my @preamble;\n  while(<F>) {\n    chomp;\n    push @preamble, $_;\n    last if /^\\s*%(package|prep|build|install|check|clean|preun|postun|pretrans|posttrans|pre|post|files|changelog|description|triggerpostun|triggerun|triggerin|trigger|verifyscript)(\\s|$)/;\n  }\n  my %patches;\n  for (@preamble) {\n    next unless /^patch(\\d*)\\s*:/i;  \n    $patches{0 + ($1 eq '' ? 0 : $1)} = $_;\n  }\n  my @patches = sort {$a <=> $b} keys %patches;\n  my $nr = 0;\n  if (exists $p->{'after'}) {\n    $nr = 0 + $p->{'after'};\n    $nr++ while $patches{$nr};\n  } else {\n    $nr = $patches[-1] + 1 if @patches;\n  }\n  my @after;\n  @after = map {$patches{$_}} grep {$_ < $nr} @patches if @patches;\n  @after = grep {/^source(\\d*)\\s*:/i} @preamble if !@after;\n  @after = grep {/^name(\\d*)\\s*:/i} @preamble if !@after;\n  @after = $preamble[-2] if @preamble > 1 && !@after;\n  return \"could not find a place to insert the patch\" if !@after;\n  my $nrx = $nr;\n  $nrx = '' if $nrx == 0;\n  local *O;\n  open(O, '>', \"$dir/.patchspec$$\") || die(\"$dir/.patchspec$$: $!\\n\");\n  for (@preamble) {\n    print O \"$_\\n\";\n    next unless @after && $_ eq $after[-1];\n    print O \"Patch$nrx: $p->{'name'}\\n\";\n    @after = ();\n  }\n  if ($preamble[-1] !~ /^\\s*%prep(\\s|$)/) {\n    while (1) {\n      my $l = <F>;\n      return \"specfile has no %prep section\" if !defined $l;\n      chomp $l;\n      print O \"$l\\n\";\n      last if $l =~ /^\\s*%prep(\\s|$)/;\n    }\n  }\n  my @prep;\n  while(<F>) {\n    chomp;\n    push @prep, $_;\n    last if /^\\s*%(package|prep|build|install|check|clean|preun|postun|pretrans|posttrans|pre|post|files|changelog|description|triggerpostun|triggerun|triggerin|trigger|verifyscript)(\\s|$)/;\n  }\n  %patches = ();\n  my $ln = -1;\n  # find outmost pushd/popd calls and insert new patches after a pushd/popd block\n  # $blevel == 0 indicates the outmost block\n  my %bend = ();\n  my $bln = undef;\n  $$bln = $ln;\n  my $blevel = -1;\n  for (@prep) {\n    $ln++;\n    $blevel++ if /^pushd/;\n    if (/^popd/) {\n      unless ($blevel) {\n        $$bln = $ln;\n        undef $bln;\n        $$bln = $ln;\n      }\n      $blevel--;\n    }\n    next unless /%patch(\\d*)(.*)/;\n    if ($1 ne '') {\n      $patches{0 + $1} = $ln;\n      $bend{0 + $1} = $bln if $blevel >= 0;\n      next;\n    }\n    my $pnum = 0;\n    my @a = split(' ', $2);\n    if (! grep {$_ eq '-P'} @a) {\n      $patches{$pnum} = $ln;\n    } else {\n      while (@a) {\n        next if shift(@a) ne '-P';\n        next if !@a || $a[0] !~ /^\\d+$/;\n        $pnum = 0 + shift(@a);\n        $patches{$pnum} = $ln;\n      }\n    }\n    $bend{$pnum} = $bln if $blevel >= 0;\n  }\n  return \"specfile has broken %prep section\" unless $blevel == -1;\n  @patches = sort {$a <=> $b} keys %patches;\n  $nr = 1 + $p->{'after'} if exists $p->{'after'};\n  %patches = map { $_ => exists $bend{$_} ? ${$bend{$_}} : $patches{$_} } @patches;\n  @after = map {$patches{$_}} grep {$_ < $nr} @patches if @patches;\n  @after = ($patches[0] - 1) if !@after && @patches;\n  @after = (@prep - 2) if !@after;\n  my $after = $after[-1];\n  $after = -1 if $after < -1;\n  $ln = -1;\n  push @prep, '' if $after >= @prep;\n  #print \"insert %patch after line $after\\n\";\n  for (@prep) {\n    if (defined($after) && $ln == $after) {\n      print O \"pushd $p->{'dir'}\\n\" if exists $p->{'dir'};\n      if ($p->{'popt'}) {\n        print O \"%patch$nrx -p$p->{'popt'}\\n\";\n      } else {\n        print O \"%patch$nrx\\n\";\n      }\n      print O \"popd\\n\" if exists $p->{'dir'};\n      undef $after;\n    }\n    print O \"$_\\n\";\n    $ln++;\n  }\n  while(<F>) {\n    chomp;\n    print O \"$_\\n\";\n  }\n  close(O) || die(\"close: $!\\n\");\n  rename(\"$dir/.patchspec$$\", \"$dir/$spec\") || die(\"rename $dir/.patchspec$$ $dir/$spec: $!\\n\");\n  return '';\n}\n# \" Make emacs wired syntax highlighting happy\n\nsub topaddspec {\n  my ($p, $dir, $spec) = @_;\n  local (*F, *O);\n  open(F, '<', \"$dir/$spec\") || die(\"$dir/$spec: $!\\n\");\n  open(O, '>', \"$dir/.topaddspec$$\") || die(\"$dir/.topaddspec$$: $!\\n\");\n  my $text = $p->{'text'};\n  $text = '' if !defined $text;\n  $text .= \"\\n\" if $text ne '' && substr($text, -1, 1) ne \"\\n\";\n  print O $text;\n  while(<F>) {\n    chomp;\n    print O \"$_\\n\";\n  }\n  close(O) || die(\"close: $!\\n\");\n  rename(\"$dir/.topaddspec$$\", \"$dir/$spec\") || die(\"rename $dir/.topaddspec$$ $dir/$spec: $!\\n\");\n}\n\n#\n# apply a single link step\n# store the result under the identifier \"$md5\"\n#\n# if \"$md5\" is not set, store the result in \"$uploaddir/applylink$$\"\n#\nsub applylink {\n  my ($md5, $lsrc, $llnk) = @_;\n  if ($md5 && -e \"$srcrep/$llnk->{'package'}/$md5-_linkerror\") {\n    # no need to do all the work again...\n    my $log = readstr(\"$srcrep/$llnk->{'package'}/$md5-_linkerror\", 1);\n    $log ||= \"unknown error\";\n    chomp $log;\n    $log =~ s/.*\\n//s;\n    $log ||= \"unknown error\";\n    return str2utf8xml($log);\n  }\n  my $flnk = lsrev($llnk);\n  my $fsrc = lsrev($lsrc);\n  my $l = $llnk->{'link'};\n  my $patches = $l->{'patches'} || {};\n  my @patches = ();\n  my $simple = 1;\n  my @simple_delete;\n  my $isbranch;\n  if ($l->{'patches'}) {\n    for (@{$l->{'patches'}->{''} || []}) {\n      my $type = (keys %$_)[0];\n      if (!$type) {\n\t$simple = 0;\n\tnext;\n      }\n      if ($type eq 'topadd') {\n        push @patches, { 'type' => $type, 'text' => $_->{$type}};\n\t$simple = 0;\n      } elsif ($type eq 'delete') {\n        push @patches, { 'type' => $type, %{$_->{$type} || {}}};\n\tpush @simple_delete, $patches[-1]->{'name'};\n      } else {\n        push @patches, { 'type' => $type, %{$_->{$type} || {}}};\n\t$simple = 0;\n\t$isbranch = 1 if $type eq 'branch';\n      }\n    }\n  }\n  $simple = 0 unless $md5;\n  if ($simple) {\n    # simple source link with no patching\n    # copy all files but the ones we have locally\n    copyfiles($llnk->{'project'}, $llnk->{'package'}, $lsrc->{'project'}, $lsrc->{'package'}, $fsrc, $flnk);\n    # calculate meta\n    my $newf = { %$fsrc };\n    for my $f (sort keys %$flnk) {\n      $newf->{$f} = $flnk->{$f} unless $f eq '_link';\n    }\n    delete $newf->{$_} for @simple_delete;\n    # store filelist in md5\n    my $linkinfo = {\n      'srcmd5'  => $lsrc->{'srcmd5'},\n      'lsrcmd5' => $llnk->{'srcmd5'},\n    };\n    addmeta_link($llnk->{'project'}, $llnk->{'package'}, $newf, $md5, $linkinfo);\n    return '';\n  }\n\n  # sanity checking...\n  for my $p (@patches) {\n    return \"patch has no type\" unless exists $p->{'type'};\n    return \"patch has illegal type \\'$p->{'type'}\\'\" unless $p->{'type'} eq 'apply' || $p->{'type'} eq 'add' || $p->{'type'} eq 'topadd' || $p->{'type'} eq 'delete' || $p->{'type'} eq 'branch';\n    if ($p->{'type'} ne 'topadd' && $p->{'type'} ne 'delete' && $p->{'type'} ne 'branch') {\n      return \"patch has no patchfile\" unless exists $p->{'name'};\n      return \"patch \\'$p->{'name'}\\' does not exist\" unless $flnk->{$p->{'name'}};\n    }\n  }\n  my $tmpdir = \"$uploaddir/applylink$$\";\n  mkdir_p($tmpdir);\n  die(\"$tmpdir: $!\\n\") unless -d $tmpdir;\n  unlink(\"$tmpdir/$_\") for ls($tmpdir);\t# remove old stuff\n  my %apply = map {$_->{'name'} => 1} grep {$_->{'type'} eq 'apply'} @patches;\n  $apply{$_} = 1 for keys %{$llnk->{'ignore'} || {}};\t# also ignore those files, used in keeplink\n  my %fl;\n  if (!$isbranch) {\n    for my $f (sort keys %$fsrc) {\n      next if $flnk->{$f} && !$apply{$f};\n      link(\"$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f\", \"$tmpdir/$f\") || die(\"$f: $!\\n\");\n      $fl{$f} = \"$lsrc->{'package'}/$fsrc->{$f}-$f\";\n    }\n    for my $f (sort keys %$flnk) {\n      next if $apply{$f} || $f eq '_link';\n      link(\"$srcrep/$llnk->{'package'}/$flnk->{$f}-$f\", \"$tmpdir/$f\") || die(\"$f: $!\\n\");\n      $fl{$f} = \"$llnk->{'package'}/$flnk->{$f}-$f\";\n    }\n  }\n  my $failed;\n  for my $p (@patches) {\n    my $pn = $p->{'name'};\n    if ($p->{'type'} eq 'delete') {\n      unlink(\"$tmpdir/$pn\");\n      next;\n    }\n    if ($p->{'type'} eq 'branch') {\n      # flnk: mine\n      # fbas: old\n      # fsrc: new\n      my $baserev = $l->{'baserev'};\n      return \"no baserev in branch patch\" unless $baserev;\n      return \"baserev is not srcmd5\" unless $baserev =~ /^[0-9a-f]{32}$/s;\n      my %brev = (%$lsrc, 'srcmd5' => $baserev);\n      my $fbas;\n      eval {\n        $fbas = lsrev(\\%brev);\n      };\n      return \"baserev $baserev does not exist\" unless $fbas;\n      return \"baserev is link\" if $fbas->{'_link'};\n\n      # ignore linked generated service files if our link contains service files\n      if (grep {/^_service/} keys %$flnk) {\n\tdelete $fbas->{$_} for grep {/^_service[:_]/} keys %$fbas;\n\tdelete $fsrc->{$_} for grep {/^_service[:_]/} keys %$fsrc;\n      }\n      # do 3-way merge\n      my %destnames = (%$fsrc, %$flnk);\n      delete $destnames{'_link'};\n      for my $f (sort {length($a) <=> length($b) || $a cmp $b} keys %destnames) {\n\tmy $mbas = $fbas->{$f} || '';\n\tmy $msrc = $fsrc->{$f} || '';\n\tmy $mlnk = $flnk->{$f} || '';\n\tif ($mbas eq $mlnk) {\n\t  next if $msrc eq '';\n\t  link(\"$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f\", \"$tmpdir/$f\") || die(\"$fsrc->{$f}-$f: $!\\n\");\n\t  $fl{$f} = \"$lsrc->{'package'}/$fsrc->{$f}-$f\";\n\t  next;\n\t}\n\tif ($mbas eq $msrc || $mlnk eq $msrc) {\n\t  next if $mlnk eq '';\n\t  link(\"$srcrep/$llnk->{'package'}/$flnk->{$f}-$f\", \"$tmpdir/$f\") || die(\"$flnk->{$f}-$f: $!\\n\");\n\t  $fl{$f} = \"$llnk->{'package'}/$flnk->{$f}-$f\";\n\t  next;\n\t}\n\tif ($mbas eq '' || $msrc eq '' || $mlnk eq '') {\n\t  $failed = \"conflict in file $f\";\n\t  last;\n\t}\n        # run merge tools\n\tlink(\"$srcrep/$lsrc->{'package'}/$fsrc->{$f}-$f\", \"$tmpdir/$f.new\") || die(\"link $fsrc->{$f}-$f: $!\\n\");\n\tlink(\"$srcrep/$lsrc->{'package'}/$fbas->{$f}-$f\", \"$tmpdir/$f.old\") || die(\"link $fbas->{$f}-$f: $!\\n\");\n\tlink(\"$srcrep/$llnk->{'package'}/$flnk->{$f}-$f\", \"$tmpdir/$f.mine\") || die(\"link $flnk->{$f}-$f: $!\\n\");\n\tif (!isascii(\"$tmpdir/$f.new\") || !isascii(\"$tmpdir/$f.old\") || !isascii(\"$tmpdir/$f.mine\")) {\n\t  $failed = \"conflict in file $f\";\n\t  last;\n\t}\n\tmy $pid;\n        if ( $f =~ /\\.changes$/ ) {\n          # try our changelog merge tool first\n  \t  if (!($pid = xfork())) {\n\t    delete $SIG{'__DIE__'};\n\t    open(STDERR, '>>', \"$tmpdir/.log\") || die(\".log: $!\\n\");\n\t    open(STDOUT, '>', \"$tmpdir/$f\") || die(\"$f: $!\\n\");\n            print STDERR \"running merge tool on $f\\n\";\n\t    exec('./bs_mergechanges', \"$tmpdir/$f.old\", \"$tmpdir/$f.new\", \"$tmpdir/$f.mine\");\n\t    die(\"./bs_mergechanges: $!\\n\");\n\t  }\n  \t  waitpid($pid, 0) == $pid || die(\"waitpid $pid: $!\\n\");\n\t  $pid = undef if $?;\n        }\n\tif (!$pid) {\n          # default diff3 merge tool. always using as fallback\n\t  if (!($pid = xfork())) {\n\t    delete $SIG{'__DIE__'};\n\t    chdir($tmpdir) || die(\"$tmpdir: $!\\n\");\n\t    open(STDERR, '>>', \".log\") || die(\".log: $!\\n\");\n\t    open(STDOUT, '>', $f) || die(\"$f: $!\\n\");\n            print STDERR \"running diff3 on $f\\n\";\n\t    exec('/usr/bin/diff3', '-m', '-E', \"$f.mine\", \"$f.old\", \"$f.new\");\n\t    die(\"/usr/bin/diff3: $!\\n\");\n\t  }\n\t  waitpid($pid, 0) == $pid || die(\"waitpid $pid: $!\\n\");\n\t  if ($?) {\n\t    $failed = \"conflict in file $f\";\n\t    last;\n\t  }\n\t}\n\tunlink(\"$tmpdir/$f.old\");\n\tunlink(\"$tmpdir/$f.new\");\n\tunlink(\"$tmpdir/$f.mine\");\n      }\n      last if $failed;\n      next;\n    }\n    if ($p->{'type'} eq 'add') {\n      for my $spec (grep {/\\.spec$/} ls($tmpdir)) {\n\tlocal *F;\n\topen(F, '>>', \"$tmpdir/.log\") || die(\"$tmpdir/.log: $!\\n\");\n\tprint F \"adding patch $pn to $spec\\n\";\n\tclose F;\n        my $err = patchspec($p, $tmpdir, $spec);\n        if ($err) {\n\t  open(F, '>>', \"$tmpdir/.log\") || die(\"$tmpdir/.log: $!\\n\");\n\t  print F \"error: $err\\n\";\n\t  close F;\n\t  $failed = \"could not add patch '$pn'\";\n\t  last;\n\t  unlink(\"$tmpdir/$_\") for ls($tmpdir);\n\t  rmdir($tmpdir);\n\t  return \"could not add patch '$pn'\";\n\t}\n        delete $fl{$spec};\n      }\n      last if $failed;\n      next;\n    }\n    if ($p->{'type'} eq 'topadd') {\n      for my $spec (grep {/\\.spec$/} ls($tmpdir)) {\n\tlocal *F;\n\topen(F, '>>', \"$tmpdir/.log\") || die(\"$tmpdir/.log: $!\\n\");\n\tprint F \"adding text at top of $spec\\n\";\n\tclose F;\n        topaddspec($p, $tmpdir, $spec);\n        delete $fl{$spec};\n      }\n      next;\n    }\n    next unless $p->{'type'} eq 'apply';\n    my $pid;\n    if (!($pid = xfork())) {\n      delete $SIG{'__DIE__'};\n      chdir($tmpdir) || die(\"$tmpdir: $!\\n\");\n      open(STDIN, '<', \"$srcrep/$llnk->{'package'}/$flnk->{$pn}-$pn\") || die(\"$srcrep/$llnk->{'package'}/$flnk->{$pn}-$pn: $!\\n\");\n      open(STDOUT, '>>', \".log\") || die(\".log: $!\\n\");\n      open(STDERR, '>&STDOUT');\n      $| = 1;\n      print \"applying patch $pn\\n\";\n      $::ENV{'TMPDIR'} = '.';\n      # Old patch command still supported --unified-reject-files and --global-reject-file.\n      # exec('/usr/bin/patch', '--no-backup-if-mismatch', '--unified-reject-files', '--global-reject-file=.rejects', '-g', '0', '-f');\n      exec('/usr/bin/patch', '--no-backup-if-mismatch', '-g', '0', '-f');\n      die(\"/usr/bin/patch: $!\\n\");\n    }\n    waitpid($pid, 0) == $pid || die(\"waitpid $pid: $!\\n\");\n    $failed = \"could not apply patch '$pn'\" if $?;\n    # clean up patch fallout...\n    for my $f (ls($tmpdir)) {\n      my @s = lstat(\"$tmpdir/$f\");\n      die(\"$tmpdir/$f: $!\\n\") unless @s;\n      if (-l _ || ! -f _) {\n        unlink(\"$tmpdir/$f\");\n\t$failed = \"patch created a non-file\";\n\tnext;\n      }\n      eval {\n\tdie(\"cannot create a link from a patch\") if $f eq '_link';\n\tBSVerify::verify_filename($f) unless $f eq '.log';\n      };\n      if ($@) {\n        unlink(\"$tmpdir/$f\");\n\t$failed = \"patch created an illegal file\";\n\tnext;\n      }\n      chmod(($s[2] & 077) | 0600, \"$tmpdir/$f\") if ($s[2] & 07700) != 0600;\n    }\n    last if $failed;\n  }\n  if ($failed) {\n    local *F;\n    # add result as last line\n    open(F, '>>', \"$tmpdir/.log\") || die(\"$tmpdir/.log: $!\\n\");\n    print F \"\\n$failed\\n\";\n    close F;\n    # link error marker\n    if ($md5 && !link(\"$tmpdir/.log\", \"$srcrep/$llnk->{'package'}/$md5-_linkerror\")) {\n      my $err = \"link $tmpdir/.log $srcrep/$llnk->{'package'}/$md5-_linkerror: $!\\n\";\n      die($err) unless -e \"$srcrep/$llnk->{'package'}/$md5-_linkerror\";\n    }\n    unlink(\"$tmpdir/$_\") for ls($tmpdir);\n    rmdir($tmpdir);\n    return str2utf8xml($failed);\n  }\n  my @newf = grep {!/^\\./} ls($tmpdir);\n  my $newf = {};\n  local *F;\n  for my $f (@newf) {\n    my @s = stat \"$tmpdir/$f\";\n    die(\"$tmpdir/$f: $!\\n\") unless @s;\n    if ($s[3] > 1 && $fl{$f}) {\n      my @s2 = stat \"$srcrep/$fl{$f}\";\n      die(\"$srcrep/$fl{$f}: $!\\n\") unless @s2;\n      if (\"$s[0]/$s[1]\" eq \"$s2[0]/$s2[1]\") {\n        $newf->{$f} = $fl{$f};\n        $newf->{$f} =~ s/.*\\///;\n        $newf->{$f} = substr($newf->{$f}, 0, 32);\n\tnext;\n      }\n    }\n    open(F, '<', \"$tmpdir/$f\") || die(\"$tmpdir/$f: $!\\n\");\n    my $ctx = Digest::MD5->new;\n    $ctx->addfile(*F);\n    close F;\n    $newf->{$f} = $ctx->hexdigest();\n  }\n\n  # if we just want the patched files we're finished\n  if (!$md5) {\n    # rename into md5 form, sort so that there's no collision\n    for my $f (sort {length($b) <=> length($a) || $a cmp $b} @newf) {\n      rename(\"$tmpdir/$f\", \"$tmpdir/$newf->{$f}-$f\");\n    }\n    return $newf;\n  }\n\n  # otherwise link everything over\n  for my $f (@newf) {\n    addfile($llnk->{'project'}, $llnk->{'package'}, \"$tmpdir/$f\", $f, $newf->{$f});\n  }\n  # clean up tmpdir\n  unlink(\"$tmpdir/$_\") for ls($tmpdir);\n  rmdir($tmpdir);\n  # store filelist\n  my $linkinfo = {\n    'srcmd5'  => $lsrc->{'srcmd5'},\n    'lsrcmd5' => $llnk->{'srcmd5'},\n  };\n  addmeta_link($llnk->{'project'}, $llnk->{'package'}, $newf, $md5, $linkinfo);\n  return '';\n}\n\n#\n# expand a source link\n# - returns expanded file list\n# - side effects:\n#   modifies $rev->{'srcmd5'}, $rev->{'vrev'}, $rev->{'linkrev'}\n#   modifies $li->{'srcmd5'}, $li->{'lsrcmd5'}\n#   modifies $li->{'linked'} if exists\n#\nsub handlelinks {\n  my ($rev, $files, $li) = @_;\n\n  my @linkinfo;\n  my %seen;\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  my $linkrev = $rev->{'linkrev'};\n  push @linkinfo, {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}, 'rev' => $rev->{'rev'}};\n  delete $rev->{'srcmd5'};\n  delete $rev->{'linkrev'};\n  my $oldvrev = 0;\n  my $vrevdone;\n  my $lrev = $rev;\n  while ($files->{'_link'}) {\n    my $l = repreadxml($lrev, '_link', $files->{'_link'}, $BSXML::link, 1);\n    return '_link is bad' unless $l;\n    my $cicount = $l->{'cicount'} || 'add';\n    eval {\n      BSVerify::verify_link($l);\n      die(\"illegal cicount\\n\") unless $cicount eq 'copy' || $cicount eq 'add' || $cicount eq 'local';\n      if (!exists($l->{'package'}) && exists($l->{'project'}) && $l->{'project'} ne $linkinfo[-1]->{'project'}) {\n        # be extra careful if the package attribute doesn't exist, but the\n        # link points to some other project\n        checksourceaccess($l->{'project'}, $linkinfo[-1]->{'package'});\n      }\n    };\n    if ($@) {\n      my $err = $@;\n      $err =~ s/\\n$//s;\n      return \"_link is bad: $err\" if @linkinfo == 1;\n      return \"$lrev->{'project'}/$lrev->{'package'}: _link is bad: $err\";\n    }\n    $l->{'project'} = $linkinfo[-1]->{'project'} unless exists $l->{'project'};\n    $l->{'package'} = $linkinfo[-1]->{'package'} unless exists $l->{'package'};\n    $linkrev = $l->{'baserev'} if $linkrev && $linkrev eq 'base';\n    ($l->{'rev'}, $linkrev) = ($linkrev, undef) if $linkrev;\n    $linkinfo[-1]->{'link'} = $l;\n    $projid = $l->{'project'};\n    $packid = $l->{'package'};\n    $lrev = $l->{'rev'} || '';\n    return 'circular package link' if $seen{\"$projid/$packid/$lrev\"};\n    $seen{\"$projid/$packid/$lrev\"} = 1;\n    # record link target for projpack\n    push @{$li->{'linked'}}, {'project' => $projid, 'package' => $packid} if $li && $li->{'linked'}; \n    eval {\n      if ($l->{'missingok'}) {\n        # be careful with 'missingok' pointing to protected packages\n        checksourceaccess($projid, $packid);\n      }\n      $lrev = getrev($projid, $packid, $l->{'rev'}, $li ? $li->{'linked'} : undef, $l->{'missingok'} ? 1 : 0);\n    };\n    if ($@) {\n      my $error = $@;\n      chomp $error;\n      $error = $2 if $error =~ /^(\\d+) +(.*?)$/s;\n      return \"$projid/$packid: $error\";\n    }\n    return \"linked package '$packid' does not exist in project '$projid'\" unless $lrev;\n    return \"linked package '$packid' is empty\" if $lrev->{'srcmd5'} eq 'empty';\n    return \"linked package '$packid' is strange\" unless $lrev->{'srcmd5'} =~ /^[0-9a-f]{32}$/;\n    $lrev->{'vrev'} = $l->{'vrev'} if defined $l->{'vrev'};\n    undef $files;\n    eval {\n      # links *always* point to expanded services\n      $files = lsrev_service($lrev);\n    };\n    if ($@) {\n      my $error = $@;\n      chomp $error;\n      return \"$projid/$packid: $error\";\n    }\n    $rev->{'vrev'} = $oldvrev if $cicount eq 'copy';\n    $oldvrev = $rev->{'vrev'};\n    $vrevdone = 1 if $cicount eq 'local';\n    if (!$vrevdone) {\n      my $v = $rev->{'vrev'} || 0;\n      $v =~ s/^.*\\D//;\n      $rev->{'vrev'} = $lrev->{'vrev'} || 0;\n      $rev->{'vrev'} =~ s/(\\d+)$/$1+$v/e;\n    }\n\n    push @linkinfo, {'project' => $projid, 'package' => $packid, 'srcmd5' => $lrev->{'srcmd5'}, 'rev' => $lrev->{'rev'}};\n  }\n  my $md5;\n  my $oldl;\n  for my $l (reverse @linkinfo) {\n    if (!$md5) {\n      $md5 = $l->{'srcmd5'};\n      $oldl = $l;\n      next;\n    }\n    my $md5c = \"$md5  /LINK\\n$l->{'srcmd5'}  /LOCAL\\n\";\n    $md5 = Digest::MD5::md5_hex($md5c);\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$l->{'project'}/$l->{'package'}\" : \"$treesdir/$l->{'package'}\";\n    if (! -e \"$treedir/$md5-MD5SUMS\") {\n      my $error = applylink($md5, $oldl, $l);\n      if ($error) {\n        $rev->{'srcmd5'} = $md5 if $l == $linkinfo[0];\n\t$error = \"$l->{'project'}/$l->{'package'}: $error\" if $l != $linkinfo[0];\n        return $error;\n      }\n    }\n    $l->{'srcmd5'} = $md5;\n    $oldl = $l;\n  }\n  $rev->{'srcmd5'} = $md5;\n  $files = lsrev($rev, $li);\n  return $files;\n}\n\n# - returns expanded file list\n# - side effects:\n#   modifies $rev->{'srcmd5'}\nsub handleservice {\n  my ($rev, $files, $servicemark) = @_;\n\n  my $lsrcmd5 = $rev->{'srcmd5'};\n  $rev->{'srcmd5'} = $servicemark;\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$rev->{'project'}/$rev->{'package'}\" : \"$treesdir/$rev->{'package'}\";\n  my $sfiles;\n  if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2 && ! -e \"$treedir/$servicemark-MD5SUMS\" && -e \"$srcrep/$rev->{'package'}/$servicemark-MD5SUMS\") {\n    $sfiles = lsrev($rev);\n  } elsif (-e \"$treedir/$servicemark-MD5SUMS\") {\n    $sfiles = lsrev($rev);\n  } elsif (! -e \"$projectsdir/$rev->{'project'}.pkg/$rev->{'package'}.xml\") {\n    # not our own package, don't run service. try getrev/lsrev instead.\n    my $rrev = getrev($rev->{'project'}, $rev->{'package'}, $servicemark);\n    $sfiles = lsrev($rrev);\n  }\n  if ($sfiles) {\n    # tree is available, i.e. the service has finished\n    if ($sfiles->{'_service_error'}) {\n      # old style...\n      my $error = repreadstr($rev, '_service_error', $sfiles->{'_service_error'});\n      $error =~ s/[\\r\\n]+$//s;\n      $error =~ s/.*[\\r\\n]//s;\n      die(str2utf8xml($error ? \"$error\\n\" : \"unknown service error\\n\"));\n    }\n    return $sfiles;\n  }\n  # don't have the tree yet\n  if (-s \"$treedir/$servicemark-_serviceerror\") {\n    local *SERROR;\n    if (open(SERROR, '<', \"$treedir/$servicemark-_serviceerror\")) {\n      my $size = -s SERROR;\n      sysseek(SERROR, $size - 1024, 0) if $size > 1024;\n      my $error = '';\n      1 while sysread(SERROR, $error, 1024, length($error));\n      close SERROR;\n      $error =~ s/[\\r\\n]+$//s;\n      $error =~ s/.*[\\r\\n]//s;\n      $error ||= 'unknown service error';\n      die(str2utf8xml(\"$error\\n\"));\n    }\n  }\n  my %nfiles = %$files;\n  $nfiles{'/SERVICE'} = $servicemark;\n  $rev->{'srcmd5'} = $lsrcmd5;\t# put it back so that runservice can put it in /LSRCMD5\n  runservice({}, $rev, \\%nfiles);\n  $rev->{'srcmd5'} = $servicemark;\n  die(\"service in progress\\n\");\n}\n\n# returns service expanded filelist\n# modifies $rev->{'srcmd5'}\nsub lsrev_service {\n  my ($rev, $linkinfo) = @_;\n  $linkinfo ||= {};\n  my $files = lsrev($rev, $linkinfo);\n  $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'}) if $linkinfo->{'xservicemd5'};\n  return $files;\n}\n\n# returns expanded filelist\n# modifies $rev->{'srcmd5'}, $rev->{'vrev'}\nsub lsrev_expanded {\n  my ($rev, $linkinfo) = @_;\n  my $files = lsrev_service($rev, $linkinfo);\n  return $files unless $files->{'_link'};\n  $files = handlelinks($rev, $files, $linkinfo);\n  die(\"$files\\n\") unless ref $files;\n  return $files;\n}\n\n# add missing target information to linkinfo\nsub linkinfo_addtarget {\n  my ($rev, $linkinfo) = @_;\n  my %lrev = %$rev;\n  $lrev{'srcmd5'} = $linkinfo->{'lsrcmd5'} if $linkinfo->{'lsrcmd5'};\n  my $files = lsrev(\\%lrev);\n  die(\"linkinfo_addtarget: not a link?\\n\") unless $files->{'_link'};\n  my $l = repreadxml(\\%lrev, '_link', $files->{'_link'}, $BSXML::link, 1);\n  if ($l) {\n    $linkinfo->{'project'} = defined($l->{'project'}) ? $l->{'project'} : $lrev{'project'};\n    $linkinfo->{'package'} = defined($l->{'package'}) ? $l->{'package'} : $lrev{'package'};\n    $linkinfo->{'missingok'} = \"true\" if $l->{'missingok'};\n    $linkinfo->{'rev'} = $l->{'rev'} if $l->{'rev'};\n    $linkinfo->{'baserev'} = $l->{'baserev'} if $l->{'baserev'};\n  }\n}\n\nsub findlastworkinglink {\n  my ($rev) = @_;\n\n  my $projid = $rev->{'project'};\n  my $packid = $rev->{'package'};\n  my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n  my @cand = grep {s/-MD5SUMS$//} ls($treedir);\n  if ($BSConfig::nosharedtrees && $BSConfig::nosharedtrees == 2) {\n    push @cand, grep {s/-MD5SUMS$//} ls(\"$srcrep/$packid\");\n    @cand = unify(@cand);\n  }\n  my %cand;\n  for my $cand (@cand) {\n    my $candrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cand};\n    my %li;\n    my $files = lsrev($candrev, \\%li);\n    next unless $li{'lsrcmd5'} && $li{'lsrcmd5'} eq $rev->{'srcmd5'};\n    $cand{$cand} = $li{'srcmd5'};\n  }\n  return undef unless %cand;\n  @cand = sort keys %cand;\n  return $cand[0] if @cand == 1;\n\n  while (1) {\n    my $lrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}};\n    my $lfiles = lsrev($lrev);\n    return undef unless $lfiles;\n    my $l = repreadxml($lrev, '_link', $lfiles->{'_link'}, $BSXML::link, 1);\n    return undef unless $l;\n    $projid = $l->{'project'} if exists $l->{'project'};\n    $packid = $l->{'package'} if exists $l->{'package'};\n    my $lastcand;\n    for my $cand (splice @cand) {\n      next unless $cand{$cand};\n      my %li;\n      my $candrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cand{$cand}};\n      lsrev($candrev, \\%li);\n      $candrev->{'srcmd5'} = $li{'lsrcmd5'} if $li{'lsrcmd5'};\n      $candrev = findlastrev($candrev);\n      next unless $candrev;\n      next if $lastcand && $lastcand->{'rev'} > $candrev->{'rev'};\n      $cand{$cand} = $li{'srcmd5'} ? $li{'srcmd5'} : undef;\n      if ($lastcand && $lastcand->{'rev'} == $candrev->{'rev'}) {\n        push @cand, $cand;\n\tnext;\n      }\n      @cand = ($cand);\n      $lastcand = $candrev;\n    }\n    return undef unless @cand;\n    return $cand[0] if @cand == 1;\n    $rev = $lastcand;\n  }\n}\n\n\n###########################################################################\n###\n###  project/package management\n###\n\nsub identical {\n  my ($d1, $d2, $except) = @_;\n\n  return 0 unless defined($d1) && defined($d2);\n  my $r = ref($d1);\n  return 0 if $r ne ref($d2);\n  if ($r eq '') {\n    return 0 if $d1 ne $d2;\n  } elsif ($r eq 'HASH') {\n    my %k = (%$d1, %$d2);\n    for my $k (keys %k) {\n      next if $except && $except->{$k};\n      return 0 unless identical($d1->{$k}, $d2->{$k}, $except);\n    }\n  } elsif ($r eq 'ARRAY') {\n    return 0 unless @$d1 == @$d2;\n    for (my $i = 0; $i < @$d1; $i++) {\n      return 0 unless identical($d1->[$i], $d2->[$i], $except);\n    }\n  } else {\n    return 0;\n  }\n  return 1;\n}\n\nsub findprojects {\n  my ($deleted) = @_;\n  if ($deleted) {\n    my @projids = grep {s/\\.pkg$//} ls(\"$projectsdir/_deleted\");\n    @projids = grep {! -e \"$projectsdir/$_.xml\"} @projids;\n    return sort @projids;\n  }\n  local *D;\n  mkdir_p(\"$projectsdir\") || die(\"creating $projectsdir: $!\\n\");\n  opendir(D, $projectsdir) || die(\"$projectsdir: $!\\n\");\n  my @projids = grep {s/\\.xml$//} readdir(D);\n  closedir(D);\n  return sort @projids;\n}\n\nsub findpackages {\n  my ($projid, $proj, $nonfatal, $seen, $origins, $noexpand, $deleted) = @_;\n  $proj ||= readproj($projid, 1) || {};\n  local *D;\n  my @packids;\n\n  # if this is a remote project, forward to remote server\n  if ($proj->{'remoteurl'}) {\n    my $r;\n    my @args;\n    push @args, 'deleted=1' if $deleted;\n    push @args, 'expand=1' unless $noexpand || $deleted;\n    eval {\n      $r = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}\", 'proxy' => $proxy}, $BSXML::dir, @args);\n    };\n    if ($@ && $@ =~ /^404/) {\n      # remote project does not exist\n      die($@) unless $nonfatal;\n      return @packids;\n    }\n    if ($@) {\n      die($@) unless $nonfatal && $nonfatal > 0;\t# -1: internal projectlink recursion, errors are still fatal\n      warn($@);\n      push @packids, ':missing_packages' if $nonfatal == 2;\n      return @packids;\n    }\n    @packids = map {$_->{'name'}} @{($r || {})->{'entry'} || []};\n    if ($origins) {\n      for my $entry (@{($r || {})->{'entry'} || []}) {\n\t$origins->{$entry->{'name'}} = defined($entry->{'originproject'}) ? maptoremote($proj, $entry->{'originproject'}) : $projid;\n      }\n    }\n    return @packids;\n  }\n\n  # handle deleted packages\n  if ($deleted) {\n    # we never expand deleted packages\n    if (! -e \"$projectsdir/$projid.xml\" && -d \"$projectsdir/_deleted/$projid.pkg\") {\n      @packids = grep {$_ ne '_meta' && $_ ne '_project'} grep {s/\\.mrev$//} ls(\"$projectsdir/_deleted/$projid.pkg\");\n    } else {\n      @packids = grep {s/\\.mrev\\.del$//} ls(\"$projectsdir/$projid.pkg\");\n      @packids = grep {! -e \"$projectsdir/$projid.pkg/$_.xml\"} @packids;\n    }\n    @packids = sort @packids;\n    if ($origins) {\n      for (@packids) {\n        $origins->{$_} = $projid unless defined $origins->{$_};\n      }\n    }\n    return @packids;\n  }\n\n  # get local packages\n  if (opendir(D, \"$projectsdir/$projid.pkg\")) {\n    @packids = grep {s/\\.xml$//} readdir(D);\n    closedir(D);\n    if ($origins) {\n      for (@packids) {\n        $origins->{$_} = $projid unless defined $origins->{$_};\n      }\n    }\n  }\n\n  # handle project links\n  if ($proj->{'link'} && !$noexpand) {\n    $seen ||= {};\n    $seen->{$projid} = 1;\n    my $frozen = get_frozenlinks($projid);\n    for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {\n      next if $seen->{$lprojid};\n      $seen->{$lprojid} = 1;\n      my @lpackids;\n      my $frozenp = $frozen->{'/all'} || $frozen->{$lprojid};\n      my $lorigins = defined($origins) ? {} : undef;\n      if ($frozenp) {\n\t@lpackids = sort keys %$frozenp;\n\tif ($lorigins) {\n\t  $lorigins->{$_} = $lprojid for @lpackids;\n\t}\n      } else {\n        my $lproj = readproj($lprojid, 1);\n        if (!$lproj || $lproj->{'remoteurl'}) {\n          $lproj = remoteprojid($lprojid);\n\t  next unless $lproj;\t# linked project does not exist\n        }\n        @lpackids = findpackages($lprojid, $lproj, $nonfatal || -1, $seen, $lorigins);\n      }\n      if (grep {$_ eq '_product'} @packids) {\n\t@lpackids = grep {$_ ne '_product' && !/^_product:/} @lpackids;\n      }\n      push @packids, @lpackids;\n      if ($origins && $lorigins) {\n        for (@lpackids) {\n          $origins->{$_} = $lorigins->{$_} unless defined $origins->{$_};\n        }\n      }\n    }\n    @packids = unify(@packids);\n  }\n\n  return sort @packids;\n}\n\nsub getrev_meta {\n  my ($projid, $packid, $revid, $deleted, $nonfatal) = @_;\n  my $revfile = defined($packid) ? \"$projectsdir/$projid.pkg/$packid.mrev\" : \"$projectsdir/$projid.pkg/_project.mrev\";\n  if ($deleted) {\n    $revfile = defined($packid) ? \"$projectsdir/$projid.pkg/$packid.mrev.del\" : \"$projectsdir/_deleted/$projid.pkg/_project.mrev\";\n    if (defined($packid) && ! -e $revfile && ! -e \"$projectsdir/$projid.xml\" && -e \"$projectsdir/_deleted/$projid.pkg\") {\n      $revfile = \"$projectsdir/_deleted/$projid.pkg/$packid.mrev\";\n    }\n  }\n  my $rev;\n  if (!defined($revid) || $revid eq 'latest') {\n    $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);\n    $rev = { 'srcmd5' => $emptysrcmd5 } unless $rev;\n  } elsif ($revid =~ /^[0-9a-f]{32}$/) {\n    $rev = { 'srcmd5' => $revid };\n  } else {\n    $rev = BSFileDB::fdb_getmatch($revfile, $srcrevlay, 'rev', $revid);\n  }\n  if ($rev) {\n    $rev->{'project'} = $projid;\n    $rev->{'package'} = defined($packid) ? $packid : '_project';\n  } elsif (!$nonfatal) {\n    die(\"404 revision '$revid' does not exist\\n\") if $revid;\n    die(\"404 no revision\\n\");\n  }\n  return $rev;\n}\n\nsub retrofit_old_prjsource {\n  my ($projid) = @_;\n  my $files = {};\n  my $packid = '_project';\n  if (-e \"$projectsdir/$projid.conf\") {\n    BSUtil::cp(\"$projectsdir/$projid.conf\", \"$uploaddir/addrev_meta$$\");\n    $files->{'_config'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_config');\n  }\n  return $files;\n}\n\nsub retrofit_old_meta {\n  my ($projid, $packid) = @_;\n  my $files = {};\n  if (defined($packid) && $packid ne '_project') {\n    if (-e \"$projectsdir/$projid.pkg/$packid.xml\") {\n      BSUtil::cp(\"$projectsdir/$projid.pkg/$packid.xml\", \"$uploaddir/addrev_meta$$\");\n      $files->{'_meta'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_meta');\n    }\n  } else {\n    $packid = '_project';\n    if (-e \"$projectsdir/$projid.xml\") {\n      BSUtil::cp(\"$projectsdir/$projid.xml\", \"$uploaddir/addrev_meta$$\");\n      $files->{'_meta'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_meta');\n    }\n    if (-e \"$projectsdir/$projid.pkg/_sslcert\") {\n      # FIXME: this is only needed for the test suite. But as long we do not have a signing\n      #        stub there we need this to inject keys.\n      BSUtil::cp(\"$projectsdir/$projid.pkg/_sslcert\", \"$uploaddir/addrev_meta$$\");\n      $files->{'_sslcert'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_sslcert');\n    }\n    if (-e \"$projectsdir/$projid.pkg/_pubkey\") {\n      BSUtil::cp(\"$projectsdir/$projid.pkg/_pubkey\", \"$uploaddir/addrev_meta$$\");\n      $files->{'_pubkey'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_pubkey');\n    }\n    if (-e \"$projectsdir/$projid.pkg/_signkey\") {\n      BSUtil::cp(\"$projectsdir/$projid.pkg/_signkey\", \"$uploaddir/addrev_meta$$\");\n      chmod(0600, \"$uploaddir/addrev_meta$$\");\n      $files->{'_signkey'} = addfile($projid, $packid, \"$uploaddir/addrev_meta$$\", '_signkey');\n    }\n  }\n  return $files;\n}\n\nsub extract_old_prjsource {\n  my ($projid, $rev) = @_;\n  my $files = lsrev($rev);\n  my $config;\n  $config = repreadstr($rev, '_config', $files->{'_config'}, 1) if $files->{'_config'};\n  writestr(\"$uploaddir/$$.2\", \"$projectsdir/$projid.conf\", $config) if $config;\n}\n\nsub extract_old_meta {\n  my ($projid, $packid, $rev) = @_;\n  $rev->{'keepsignkey'} = 1;\n  my $files = lsrev($rev);\n  delete $rev->{'keepsignkey'};\n  if (!defined($packid) || $packid eq '_project') {\n    $packid = '_project';\n    my $pubkey;\n    $pubkey = repreadstr($rev, '_pubkey', $files->{'_pubkey'}, 1) if $files->{'_pubkey'};\n    writestr(\"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/_pubkey\", $pubkey) if $pubkey;\n    my $signkey;\n    $signkey = repreadstr($rev, '_signkey', $files->{'_signkey'}, 1) if $files->{'_signkey'};\n    if ($signkey) {\n      writestr(\"$uploaddir/$$.2\", undef, $signkey);\n      chmod(0600, \"$uploaddir/$$.2\");\n      rename(\"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/_signkey\") || die(\"rename $uploaddir/$$.2 $projectsdir/$projid.pkg/_signkey: $!\\n\");\n    }\n    my $meta;\n    $meta = repreadstr($rev, '_meta', $files->{'_meta'}, 1) if $files->{'_meta'};\n    writestr(\"$uploaddir/$$.2\", \"$projectsdir/$projid.xml\", $meta) if $meta;\n  } else {\n    my $meta;\n    $meta = repreadstr($rev, '_meta', $files->{'_meta'}, 1) if $files->{'_meta'};\n    writestr(\"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/$packid.xml\", $meta) if $meta;\n  }\n}\n\nsub addrev_meta_multiple {\n  my ($cgi, $projid, $packid, $suf, @todo) = @_;\n\n  $suf ||= 'mrev';\n  undef $packid if $packid && $packid eq '_project';\n  my $rpackid = defined($packid) ? $packid : '_project';\n\n  # first commit content into internal repository\n  my %rfilemd5;\n  for my $todo (@todo) {\n    my ($tmpfile, $file, $rfile) = @$todo;\n    next unless defined($tmpfile);\n    mkdir_p($uploaddir);\n    unlink(\"$uploaddir/addrev_meta$$\");\n    BSUtil::cp($tmpfile, \"$uploaddir/addrev_meta$$\");\n    chmod(0600, \"$uploaddir/addrev_meta$$\") if !defined($packid) && $suf eq 'mrev' && $rfile eq '_signkey';\n    $rfilemd5{$rfile} = addfile($projid, $rpackid, \"$uploaddir/addrev_meta$$\", $rfile);\n  }\n\n  mkdir_p(\"$projectsdir/$projid.pkg\");\n  my $revfile = \"$projectsdir/$projid.pkg/$rpackid.$suf\";\n  local *FF;\n  BSUtil::lockopen(\\*FF, '+>>', $revfile);\n  my $rev = BSFileDB::fdb_getlast($revfile, $srcrevlay);\n  my $files;\n  if ($rev) {\n    $rev->{'project'} = $projid;\n    $rev->{'package'} = $rpackid;\n    $rev->{'keepsignkey'} = 1;\n    $files = lsrev($rev);\n    delete $rev->{'keepsignkey'};\n  } else {\n    $files = {};\n    if ((defined($packid) && -e \"$projectsdir/$projid.pkg/$packid.xml\") || (!defined($packid) && -e \"$projectsdir/$projid.xml\")) {\n      if ($suf eq 'mrev') {\n        $files = retrofit_old_meta($projid, $packid);\n      } elsif (!defined($packid)) {\n        $files = retrofit_old_prjsource($projid);\n      }\n    }\n  }\n\n  for my $todo (@todo) {\n    my ($tmpfile, $file, $rfile) = @$todo;\n    if (defined($tmpfile)) {\n      $files->{$rfile} = $rfilemd5{$rfile};\n    } else {\n      delete $files->{$rfile};\n    }\n  }\n\n  my $srcmd5 = addmeta($projid, $rpackid, $files);\n  my $user = defined($cgi->{'user'}) ? str2utf8xml($cgi->{'user'}) : 'unknown';\n  my $comment = defined($cgi->{'comment'}) ? str2utf8xml($cgi->{'comment'}) : '';\n  my $nrev = { 'srcmd5' => $srcmd5, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $cgi->{'requestid'} };\n  # copy version/vref in initial commit case\n  if (!@todo && defined($packid) && $suf ne 'mrev' && $rev) {\n    $nrev->{'version'} = $rev->{'version'} if defined $rev->{'version'};\n    $nrev->{'vrev'} = $rev->{'vrev'} if defined $rev->{'vrev'};\n  }\n  BSFileDB::fdb_add_i(\\*FF, $srcrevlay, $nrev);\n\n  for my $todo (@todo) {\n    my ($tmpfile, $file, $rfile) = @$todo;\n    if (defined($file)) {\n      if (defined($tmpfile)) {\n        rename($tmpfile, $file) || die(\"rename $tmpfile $file: $!\\n\");\n      } else {\n        unlink($file);\n      }\n    } elsif (defined($tmpfile)) {\n      unlink($tmpfile);\n    }\n  }\n  close FF;\t# free lock\n  $nrev->{'project'} = $projid;\n  $nrev->{'package'} = $rpackid;\n  return $nrev;\n}\n\nsub addrev_meta {\n  my ($cgi, $projid, $packid, $tmpfile, $file, $rfile, $suf) = @_;\n  if (defined($rfile)) {\n    return addrev_meta_multiple($cgi, $projid, $packid, $suf,  [ $tmpfile, $file, $rfile ]);\n  } else {\n    return addrev_meta_multiple($cgi, $projid, $packid, $suf);\n  }\n}\n\nsub readproj {\n  my ($projid, $nonfatal, $revid) = @_;\n  my $proj;\n  if ($revid) {\n    my $rev = getrev_meta($projid, undef, $revid);\n    my $files = $rev ? lsrev($rev) : {};\n    $proj = repreadxml($rev, '_meta', $files->{'_meta'}, $BSXML::proj, 1) if $files->{'_meta'};\n  } else {\n    $proj = readxml(\"$projectsdir/$projid.xml\", $BSXML::proj, 1);\n  }\n  die(\"404 project '$projid' does not exist\\n\") if !$proj && !$nonfatal;\n  return $proj;\n}\n\nsub readpack {\n  my ($projid, $packid, $nonfatal, $revid) = @_;\n  my $pack;\n  if ($revid) {\n    my $rev = getrev_meta($projid, $packid, $revid, undef, $nonfatal);\n    my $files = $rev ? lsrev($rev) : {};\n    $pack = repreadxml($rev, '_meta', $files->{'_meta'}, $BSXML::pack, 1) if $files->{'_meta'};\n  } else {\n    $pack = readxml(\"$projectsdir/$projid.pkg/$packid.xml\", $BSXML::pack, 1);\n  }\n  if (!$pack && !$nonfatal) {\n    readproj($projid);\n    die(\"404 package '$packid' does not exist in project '$projid'\\n\");\n  }\n  return $pack;\n}\n\n# collect all global source services via all package and project links\nsub getprojectservices {\n  my ($cgi, $projid, $packid, $projectloop) = @_;\n  my $services = {};\n\n  # protection against loops and double matches\n  $projectloop ||= {};\n  return ({}, $BSXML::services) if $projectloop->{$projid};\n  $projectloop->{$projid} = 1;\n\n  # get source services from this project\n  my $projectrev = getrev($projid, '_project');\n  my $projectfiles = lsrev($projectrev);\n  if ($projectfiles->{'_service'}) {\n    $services = readxml(\"$srcrep/_project/$projectfiles->{'_service'}-_service\", $BSXML::services, 1) || {};\n  }\n\n  # find further projects via project link\n  my $proj = readproj($projid, 1);\n  for my $lprojid (map {$_->{'project'}} @{$proj->{'link'} || []}) {\n    my $lpack;\n    eval {\n      ($lpack, undef) = getpackage($cgi, $lprojid, $packid);\n    };\n    if ($lpack) {\n      my ($as, undef) = getprojectservices($cgi, $lprojid, $packid, $projectloop);\n      if (defined($as) && defined($as->{'service'})) {\n        push @{$services->{'service'}}, @{$as->{'service'}};\n      }\n    }\n  }\n\n  # find further projects via package link\n  my $packagerev;\n  eval {\n     $packagerev = getrev($projid, $packid, $cgi->{'rev'});\n  };\n  return ($services, $BSXML::services) unless $packagerev;\n\n  my $packagefiles = lsrev($packagerev);\n  my $l;\n  $l = repreadxml($packagerev, '_link', $packagefiles->{'_link'}, $BSXML::link, 1) if $packagefiles->{'_link'};\n  if ($l) {\n    my $lprojid = $projid;\n    my $lpackid = $packid;\n    $lprojid = $l->{'project'} if defined $l->{'project'};\n    $lpackid = $l->{'package'} if defined $l->{'package'};\n    # honor project links\n    my $lpack;\n    eval {\n      ($lpack, undef) = getpackage($cgi, $lprojid, $lpackid);\n    };\n    if ($lpack) {\n      my ($as, undef) = getprojectservices({%$cgi, 'rev' => $l->{'rev'}}, $lprojid, $lpackid, $projectloop);\n      if (defined($as) && defined($as->{'service'})) {\n        push @{$services->{'service'}}, @{$as->{'service'}};\n      }\n    }\n  }\n\n  return ($services, $BSXML::services);\n}\n\n# find matching .spec/.dsc/.kiwi file depending on packid and/or repoid\nsub findfile {\n  my ($rev, $repoid, $ext, $files) = @_;\n\n  return (undef, undef) if !$ext || $ext eq 'none';\n  $files = lsrev($rev) unless $files;\n  return (undef, undef) unless $files;\n\n  # create filename -> return value hash\n  my %files = map {$_ => [$files->{$_}, $_]} keys %$files;\n\n  # map services files to their real name\n  if ($files{'_service'}) {\n    for (sort keys %files) {\n      next unless /^_service:.*:(.*?)$/s;\n      next unless $files{$_};\n      $files{$1} = $files{$_};\n      delete $files{$_};\n    }\n  }\n\n  return @{$files{'_preinstallimage'}} if $ext ne 'kiwi' && keys(%files) == 1 && $files{'_preinstallimage'};\n  return @{$files{'simpleimage'}} if $files{'simpleimage'};\n\n  if ($ext eq 'arch') {\n    return @{$files{'PKGBUILD'}} if $files{'PKGBUILD'};\n    return (undef, undef);\n  }\n\n  my $packid = $rev->{'package'};\n  return (@{$files{\"$packid-$repoid.$ext\"}}) if defined($repoid) && $files{\"$packid-$repoid.$ext\"};\n  # 28.4.2009 mls: deleted \"&& defined($repoid)\"\n  return @{$files{\"$packid.$ext\"}} if $files{\"$packid.$ext\"};\n  # try again without last components\n  if ($packid =~ /^(.*?)\\./) {\n    return @{$files{\"$1.$ext\"}} if $files{\"$1.$ext\"};\n  }\n  my @files = grep {/\\.$ext$/} keys %files;\n  @files = grep {/^\\Q$packid\\E/i} @files if @files > 1;\n  return @{$files{$files[0]}} if @files == 1;\n  if (@files > 1) {\n    if (!defined($repoid)) {\n      # return (undef, undef);\n      @files = sort @files;\n      return @{$files{$files[0]}};\n    }\n    @files = grep {/^\\Q$packid-$repoid\\E/i} @files if @files > 1;\n    return @{$files{$files[0]}} if @files == 1;\n  }\n  return (undef, undef);\n}\n\nsub unify {\n  my %h = map {$_ => 1} @_;\n  return grep(delete($h{$_}), @_);\n}\n\n#########################################################################\n\n# set up kiwi project callback\n\nsub kiwibootcallback {\n  my ($projid, $packid) = @_;\n  BSVerify::verify_projid($projid);\n  BSVerify::verify_packid($packid);\n  checksourceaccess($projid, $packid);\n  my $rev = getrev($projid, $packid);\n  my $files = lsrev($rev);\n  my ($md5, $file) = findfile($rev, undef, 'kiwi', $files);\n  die(\"no kiwi file found\\n\") unless $md5 && $file;\n  my $xml = readstr(\"$srcrep/$packid/$md5-$file\");\n  return ($xml, {'project' => $projid, 'package' => $packid, 'srcmd5' => $rev->{'srcmd5'}, 'file' => $file});\n}\n$Build::Kiwi::bootcallback = \\&kiwibootcallback;\n\n#########################################################################\n\nsub projid2reposerver {\n  my ($projid) = @_;\n  return $BSConfig::reposerver unless $BSConfig::partitionservers;\n  my @p = @{$BSConfig::partitioning || []};\n  my $par;\n  while (@p) {\n    if ($projid =~ /^$p[0]/) {\n      $par = $p[1];\n      last;\n    }\n    splice(@p, 0, 2);\n  }\n  $par = $BSConfig::partition unless defined $par;\n  die(\"cannot determine partition for $projid\\n\") unless defined $par;\n  die(\"partition '$par' from partitioning does not exist\\n\") unless $BSConfig::partitionservers->{$par};\n  return $BSConfig::partitionservers->{$par};\n}\n\nsub projid2partition {\n  my ($projid) = @_;\n  return undef unless $BSConfig::partitioning;\n  my @p = @{$BSConfig::partitioning || []};\n  my $par;\n  while (@p) {\n    if ($projid =~ /^$p[0]/) {\n      $par = $p[1];\n      last;\n    }\n    splice(@p, 0, 2);\n  }\n  $par = $BSConfig::partition unless defined $par;\n  return $par;\n}\n\nsub checkpartition {\n  my ($remotemap, $projid, $proj) = @_;\n  $remotemap->{':partitions'}->{$projid} = 1;\n  return if $remotemap->{$projid};\n  my @p = @{$BSConfig::partitioning || []};\n  my $par;\n  while (@p) {\n    if ($projid =~ /^$p[0]/) {\n      $par = $p[1];\n      last;\n    }\n    splice(@p, 0, 2);\n  }\n  $par = $BSConfig::partition unless defined $par;\n  die(\"cannot determine partition for $projid\\n\") unless defined $par;\n  return if $par eq $remotemap->{':partition'};\n  my $reposerver = $BSConfig::reposerver;\n  if ($BSConfig::partitionservers) {\n    $reposerver = $BSConfig::partitionservers->{$par};\n    die(\"partition '$par' from partitioning does not exist\\n\") unless $reposerver;\n  }\n  $remotemap->{$projid} = {\n    'name' => $projid, 'remoteurl' => $reposerver, 'remoteproject' => $projid, 'partition' => $par,\n  };\n  $proj ||= readproj($projid, 1);\n  if (!$proj) {\n    $remotemap->{$projid} = { 'name' => $projid };\t# gone!\n    return;\n  }\n  $remotemap->{$projid}->{'repository'} = $proj->{'repository'} if $proj->{'repository'};\n  $remotemap->{$projid}->{'kind'} = $proj->{'kind'} if $proj->{'kind'};\n  if ($proj->{'access'}) {\n    for ('access', 'publish', 'person', 'group') {\n      $remotemap->{$projid}->{$_} = $proj->{$_} if exists $proj->{$_};\n    }\n  }\n}\n\nsub getprojquotapackage {\n  my ($projid) = @_;\n  if (!exists($packagequota{':packages'})) {\n    my $quotaxml = readxml($BSConfig::bsquotafile, $BSXML::quota, 1);\n    for my $p (@{$quotaxml->{'project'} || []}) {\n      $packagequota{$p->{'name'}} = $p->{'packages'};\n    }\n    $packagequota{':packages'} = $quotaxml->{'packages'};\n  }\n  while ($projid) {\n    return $packagequota{$projid} if exists $packagequota{$projid};\n    last unless $projid =~ s/:[^:]*$//;\n  }\n  return $packagequota{':packages'};\n}\n\n# this is kind of a snapshot in time, but good enough for now \nsub mergeroles {\n  my ($projid, $proj) = @_; \n  my @person;\n  my @group;\n  while ($projid ne '') {\n    $proj ||= readproj($projid, 1); \n    if ($proj) {\n      push @person, @{$proj->{'person'} || []};\n      push @group , @{$proj->{'group'} || []};\n    }   \n    last unless $projid =~ s/:[^:]*$//;\n    undef $proj;\n  }\n  return (\\@person, \\@group);\n}\n\nsub getprojpack {\n  my ($cgi, $projids, $repoids, $packids, $arch) = @_;\n  local *oldbsrpc = *BSRPC::rpc;\n  local *BSRPC::rpc;\n  die(\"unsupported view\\n\") if $cgi->{'view'} && $cgi->{'view'} ne 'storable';\n  if ($cgi->{'noremote'}) {\n    *BSRPC::rpc = sub {die(\"400 interconnect error: noremote option\\n\");};\n  } else {\n    *BSRPC::rpc = sub {\n      my $r = eval { oldbsrpc(@_) };\n      if ($@) {\n\t$@ = \"interconnect error: $@\" unless $@ =~ /(?:remote|interconnect) error:/;\n\tdie($@);\n      }\n      return $r;\n    };\n  }\n  $arch ||= 'noarch';\n  my $partition = $cgi->{'partition'};\n  die(\"No such partition '$partition'\\n\") if $partition && $BSConfig::partitionservers && !$BSConfig::partitionservers->{$partition};\n  my $remotemap = $cgi->{'withremotemap'} ? {} : undef;\n  if ($remotemap && $partition) {\n    $remotemap->{':partition'} = $partition;\n    $remotemap->{':partitions'} = {};\n  }\n  $projids = [ findprojects() ] unless $projids;\n  if ($partition) {\n    for my $projid (splice @$projids) {\n      my $par = projid2partition($projid);\n      die(\"cannot determine partition for $projid\\n\") unless defined $par;\n      die(\"partition '$par' from partitioning does not exist\\n\") if $BSConfig::partitionservers && !$BSConfig::partitionservers->{$par};\n      if ($par ne $partition) {\n\t# check if it is remote, if not then it belongs to another partition\n\tmy $r = readproj($projid, 1);\n\t$r = remoteprojid($projid) unless defined $r;\n\tif (!($r && $r->{'remoteurl'})) {\n\t  # not remote, but on wrong partition\n\t  # if asked for a specific project, put it in remotemap\n\t  next unless $remotemap && $cgi->{'project'};\n\t  checkpartition($remotemap, $projid, $r) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$projid};\n\t  if ($remotemap->{$projid} && $cgi->{'withconfig'}) {\n\t    # also put config in remotemap is asked for a specific project\n\t    my $c = readstr(\"$projectsdir/$projid.conf\", 1);\n\t    $remotemap->{$projid}->{'config'} = defined($c) ? $c : '' if ($remotemap->{$projid} || {})->{'partition'};\n\t  }\n\t  next;\n\t}\n      }\n      push @$projids, $projid;\n    }\n  }\n  if ($BSConfig::limit_projects && $BSConfig::limit_projects->{$arch}) {\n    my %limit_projids = map {$_ => 1} @{$BSConfig::limit_projects->{$arch}};\n    $projids = [ grep {$limit_projids{$_}} @$projids ];\n  }\n  $repoids = { map {$_ => 1} @$repoids } if $repoids;\n  $packids = { map {$_ => 1} @$packids } if $packids;\n  my $bconf = Build::read_config($arch);\n\n  $frozenlinks_cache = {};\n  my %channeldata;\n  my @res;\n  for my $projid (@$projids) {\n    my $jinfo = { 'name' => $projid };\n    my $proj = readproj($projid, 1);\n    if ($remotemap && (!$proj || $proj->{'remoteurl'}) && !exists($remotemap->{$projid})) {\n      my $r = remoteprojid($projid);\n      $remotemap->{$projid} = {%$r, 'proto' => 1} if $r;\n    }\n    next unless $proj;\n    for (qw{kind}) {\n      $jinfo->{$_} = $proj->{$_} if exists $proj->{$_};\n    }\n\n    my %expandedrepos;\n\n    if ($cgi->{'withrepos'}) {\n      if ($repoids) {\n\t$jinfo->{'repository'} = [ grep {$repoids->{$_->{'name'}}} @{$proj->{'repository'} || []} ];\n      } else {\n        $jinfo->{'repository'} = $proj->{'repository'} || [];\n      }\n      if ($cgi->{'expandedrepos'}) {\n\t$jinfo->{'repository'} = Storable::dclone($jinfo->{'repository'});\n\tfor my $repo (@{$jinfo->{'repository'}}) {\n\t  my $base = {};\n\t  my @prps = expandsearchpath($projid, $repo->{'name'}, $remotemap, $base);\n\t  $expandedrepos{\"$projid/$repo->{'name'}\"} = [ @prps ];\n\t  for my $prp (@prps) {\n\t    my @s = split('/', $prp, 2);\n\t    $prp = {'project' => $s[0], 'repository' => $s[1]};\n\t  }\n\t  $repo->{'path'} = \\@prps;\n\t  $repo->{'base'} = $base;\n\t}\n      } elsif ($remotemap) {\n\tfor my $repo (@{$jinfo->{'repository'}}) {\n\t  eval {\n\t    my @prps = expandsearchpath($projid, $repo->{'name'}, $remotemap);\n            $expandedrepos{\"$projid/$repo->{'name'}\"} = [ @prps ];\n\t  };\n\t  $expandedrepos{\"$projid/$repo->{'name'}\"} = $@ if $@;\n\t}\n      }\n    }\n\n    if ($remotemap) {\n      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'} || []}) {\n        my $lproj = remoteprojid($lprojid);\n\teval {\n\t  fetchremoteproj($lproj, $lprojid, $remotemap) if $lproj;\n\t};\n        checkpartition($remotemap, $lprojid) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$lprojid};\n      }\n    }\n\n    if ($cgi->{'withconfig'}) {\n      my $config = readstr(\"$projectsdir/$projid.conf\", 1);\n      if ($config) {\n\t#my $s1 = '^\\s*macros:\\s*$.*?^\\s*:macros\\s*$';\n\t#my $s2 = '^\\s*macros:\\s*$.*\\Z';\n\t#$config =~ s/$s1//gmsi;\n\t#$config =~ s/$s2//gmsi;\n\t$jinfo->{'config'} = $config unless $config =~ /^\\s*$/s;\n      }\n    }\n    if ($cgi->{'withsrcmd5'} && -s \"$projectsdir/$projid.pkg/pattern-MD5SUMS\") {\n      my $patterns = readstr(\"$projectsdir/$projid.pkg/pattern-MD5SUMS\", 1);\n      $jinfo->{'patternmd5'} = Digest::MD5::md5_hex($patterns) if $patterns;\n    } elsif ($cgi->{'withsrcmd5'} && $cgi->{'nopackages'}) {\n      # used by publisher to get patternmd5\n      eval {\n\tmy $rev = getrev($projid, '_pattern');\n\tmy $files = lsrev_expanded($rev);\n\t$jinfo->{'patternmd5'} = $rev->{'srcmd5'};\n      };\n    }\n    my @packages;\n    @packages = findpackages($projid, $proj, 2) unless $cgi->{'nopackages'} || $proj->{'remoteurl'};\n    my $missing_packages = grep {$_ eq ':missing_packages'} @packages;\n    if ($missing_packages) {\n      @packages = grep {$_ ne ':missing_packages'} @packages;\n      $jinfo->{'missingpackages'} = 1;\n    }\n    next if $repoids && !grep {$repoids->{$_->{'name'}}} @{$proj->{'repository'} || []};\n    next if $packids && !grep {$packids->{$_}} @packages;\n    for (qw{title description build publish debuginfo useforbuild remoteurl remoteproject download link sourceaccess privacy access lock}) {\n      $jinfo->{$_} = $proj->{$_} if exists $proj->{$_};\n    }\n    if ($proj->{'access'}) {\n      # we need the roles if the project is protected, see checkroles() in the scheduler\n      my ($person, $group) = mergeroles($projid, $proj);\n      $jinfo->{'person'} = $person if $person && @$person;\n      $jinfo->{'group'} = $group if $group && @$group;\n    }\n    # Check build flags in project meta data\n    # packages inherit the project wide settings and may override them\n    my $pdisabled;\n    my $pdisable = {};\n    my $penable = {};\n    undef($penable) if $cgi->{'ignoredisable'};\n    if ($jinfo->{'build'} && $penable) {\n      for (@{$proj->{'repository'} || []}) {\n        my $disen = BSUtil::enabled($_->{'name'}, $jinfo->{'build'}, 1, $arch);\n        if ($disen) {\n          $penable->{$_->{'name'}} = 1;\n        } else {\n          $pdisable->{$_->{'name'}} = 1;\n        }\n      }\n      $pdisabled = 1 if !keys(%$penable);\n    } else {\n      # build is enabled\n      undef($penable);\n    }\n\n    # Check package number quota\n    my $quota_exceeded;\n    if ($BSConfig::bsquotafile) {\n      my $pquota = getprojquotapackage($projid);\n      $quota_exceeded = 1 if defined($pquota) && @packages > $pquota;\n    }\n\n    if (!$cgi->{'ignoredisable'} && !grep {!$_->{'status'} || $_->{'status'} ne 'disabled'} @{$proj->{'repository'} || []}) {\n      # either no repositories or all disabled. No need to check packages\n      @packages = ();\n    }\n    @packages = () if $cgi->{'nopackages'};\n    my @pinfo;\n    my %bconfs;\n\n    my $exclude_all;\n    my $exclude_repos;\n    if (!$cgi->{'ignoredisable'} && defined($cgi->{'arch'})) {\n      $exclude_repos = {};\n      $exclude_all = 1;\n      for (@{$proj->{'repository'} || []}) {\n\tif (grep {$_ eq $arch} @{$_->{'arch'} || []}) {\n\t  undef $exclude_all;\n\t} else {\n          $exclude_repos->{$_->{'name'}} = 1;\n\t}\n      }\n    }\n\n    my @packages_delayed;\n    my $packages_pass = 0;\n    while (1) {\n      if (!@packages) {\n\tlast if !@packages_delayed || $packages_pass;\n\t$packages_pass = 1;\n\tfill_remote_getrev_cache();\n\t@packages = @packages_delayed;\n\tnext;\n      }\n      my $packid = shift(@packages);\n\n      next if $packids && !$packids->{$packid};\n      my $pinfo = {'name' => $packid};\n      push @pinfo, $pinfo;\n      my $pack = readpack($projid, $packid, 1);\n      $pack ||= {} if $proj->{'link'};\n      if (!$pack) {\n\t$pinfo->{'error'} = 'no metadata';\n\tnext;\n      }\n      for (qw{build publish debuginfo useforbuild bcntsynctag sourceaccess privacy access lock}) {\n\t$pinfo->{$_} = $pack->{$_} if $pack->{$_};\n      }\n      if (!$pinfo->{'build'}) {\n        $pinfo->{'build'}->{'enable'} = $pack->{'enable'} if $pack->{'enable'};\n        $pinfo->{'build'}->{'disable'} = $pack->{'disable'} if $pack->{'disable'};\n      }\n      if ($exclude_all) {\n\t$pinfo->{'error'} = 'excluded';\n\tnext;\n      }\n\n      my $enable = defined($penable) ? {%$penable} : undef;\n      my $disable = {%$pdisable};\n      if (!$cgi->{'ignoredisable'} && $pinfo->{'build'}) {\n        for (@{$proj->{'repository'} || []}) {\n          my $default = exists($disable->{$_->{'name'}}) ? 0 : 1;\n          my $disen = BSUtil::enabled($_->{'name'}, $pinfo->{'build'}, $default, $arch);\n          if ($disen) {\n            $enable->{$_->{'name'}} = 1;\n            delete $disable->{$_->{'name'}};\n          } else {\n            $disable->{$_->{'name'}} = 1;\n            delete $enable->{$_->{'name'}};\n          }\n        }\n      }\n      undef($disable) if $enable && !keys(%$enable);\n      undef($enable) if $disable && !keys(%$disable);\n      if ((!$disable || $pdisabled) && $enable && !%$enable) {\n\t$pinfo->{'error'} = 'disabled';\n\tnext;\n      }\n      if ($quota_exceeded) {\n\t$pinfo->{'error'} = 'quota exceeded';\n\tnext;\n      }\n      if ($cgi->{'withsrcmd5'} || $cgi->{'withdeps'}) {\n        my $rev;\n\tmy $linked = [];\n\t$collect_remote_getrev = 1 unless $packages_pass;\n\teval {\n\t  $rev = getrev($projid, $packid, 'build', $linked);\n\t};\n\t$collect_remote_getrev = 0;\n        $pinfo->{'originproject'} = $rev->{'originproject'} if $rev && $rev->{'originproject'};\n        $pinfo->{'linked'} = $linked if @$linked;\n\tif ($@) {\n\t  $pinfo->{'error'} = $@;\n\t  $pinfo->{'error'} =~ s/\\n$//s;\n\t  if (!$packages_pass && $pinfo->{'error'} =~ /collect_remote_getrev$/) {\n\t    pop @pinfo;\n\t    push @packages_delayed, $packid;\n\t  }\n \t  next;\n\t}\n\tif (!$rev || $rev->{'srcmd5'} eq 'empty' || $rev->{'srcmd5'} eq $emptysrcmd5) {\n\t  $pinfo->{'error'} = 'no source uploaded';\n\t  next;\n\t}\n\t$pinfo->{'srcmd5'} = $rev->{'srcmd5'};\n\t$pinfo->{'rev'} = $rev->{'rev'};\n\t$pinfo->{'revtime'} = $rev->{'time'} if $rev->{'time'};\n\tmy $files;\n\teval {\n\t  my $linkinfo = {};\n          $files = lsrev($rev, $linkinfo);\n\t  if ($linkinfo->{'xservicemd5'}) {\n\t    $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'});\n\t    $pinfo->{'srcmd5'} = $rev->{'srcmd5'};\n\t  }\n\t  if ($linkinfo->{'xservicemd5'} || $linkinfo->{'lservicemd5'} || $linkinfo->{'lsrcmd5'}) {\n\t    my $meta = '';\n\t    $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n\t    $pinfo->{'verifymd5'} = Digest::MD5::md5_hex($meta);\n\t  }\n\t};\n\tif ($@) {\n\t  $pinfo->{'error'} = $@;\n\t  $pinfo->{'error'} =~ s/\\n$//s;\n \t  next;\n\t}\n\tif ($files->{'_service'} && -e \"$eventdir/service/${projid}::$packid\") {\n\t  $pinfo->{'error'} = 'source update running';\n \t  next;\n\t}\n        if ($files->{'_service_error'}) {\n\t  $pinfo->{'error'} = 'source service failed';\n \t  next;\n        }\n\tif ($files->{'_link'}) {\n\t  $collect_remote_getrev = 1 unless $packages_pass;\n\t  eval {\n\t    $files = handlelinks($rev, $files, {'linked' => $linked});\n\t  };\n\t  $collect_remote_getrev = 0;\n\t  if ($@) {\n\t    $files = \"$@\";\n\t    $files =~ s/\\n$//;\n\t  }\n\t  if (@$linked) {\n\t    $pinfo->{'linked'} = $linked;\n\t    if ($remotemap && $remotemap->{':partitions'}) {\n\t      # we need to have all partition infos set for the links\n\t      for my $li (@$linked) {\n\t\tmy $lprojid = $li->{'project'};\n\t\tnext if $remotemap->{$lprojid} || $remotemap->{':partitions'}->{$lprojid};\n\t\tmy $lproj = readproj($lprojid, 1);\n\t\tif ($lproj && !$lproj->{'remoteurl'}) {\n\t\t  checkpartition($remotemap, $lprojid, $lproj);\n\t\t} else {\n\t\t  $remotemap->{':partitions'}->{$lprojid} = 1;  # not on a partition\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  if (!ref $files) {\n\t    $pinfo->{'error'} = defined($files) ? $files : \"could not get file list\";\n\t    if (!$packages_pass && $pinfo->{'error'} =~ /collect_remote_getrev$/) {\n\t      pop @pinfo;\n\t      push @packages_delayed, $packid;\n\t    }\n\t    next;\n\t  }\n\t  $pinfo->{'srcmd5'} = $rev->{'srcmd5'};\n\t  my $meta = '';\n\t  $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n\t  $pinfo->{'verifymd5'} = Digest::MD5::md5_hex($meta);\n\t}\n\tif ($packid eq '_pattern') {\n\t  $jinfo->{'patternmd5'} = $pinfo->{'srcmd5'};\n\t  $pinfo->{'error'} = 'excluded';\n\t  next;\n\t}\n\tif ($files->{'_aggregate'}) {\n\t  my $aggregatelist = repreadxml($rev, '_aggregate', $files->{'_aggregate'}, $BSXML::aggregatelist, 1);\n\t  if (!$aggregatelist) {\n\t    $pinfo->{'error'} = \"bad aggregatelist data\";\n\t    next;\n\t  }\n          eval {\n\t    BSVerify::verify_aggregatelist($aggregatelist);\n          };\n\t  if ($@) {\n\t    my $err = $@;\n\t    $err =~ s/\\n$//s;\n\t    $pinfo->{'error'} = \"bad aggregatelist: $err\";\n\t    next;\n\t  }\n\t  $pinfo->{'aggregatelist'} = $aggregatelist;\n\t  if ($remotemap && $aggregatelist) {\n\t    for my $aggregate (@{$aggregatelist->{'aggregate'} || []}) {\n\t      my $aprojid = $aggregate->{'project'};\n\t      next if $remotemap->{$aprojid} && !$remotemap->{$aprojid}->{'proto'};\n\t      my $aproj = readproj($aprojid, 1);\n\t      if (!$aproj || $aproj->{'remoteurl'}) {\n\t\t$aproj = remoteprojid($aprojid);\n\t\teval {\n\t\t  fetchremoteproj($aproj, $aprojid, $remotemap) if $aproj;\n\t\t};\n\t      } else {\n\t\tcheckpartition($remotemap, $aprojid, $aproj) if $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$aprojid};\n\t      }\n\t    }\n\t  }\n\t  if (($enable && %$enable) || ($disable && %$disable)) {\n\t    my @dinfo = ();\n\t    for my $repo (@{$proj->{'repository'} || []}) {\n\t      my $repoid = $repo->{'name'};\n\t      next if $repoids && !$repoids->{$repoid};\n\t      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {\n\t        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};\n\t\tnext;\n\t      }\n\t    }\n\t    $pinfo->{'info'} = \\@dinfo if @dinfo;\n\t  }\n\t} elsif ($files->{'_patchinfo'}) {\n\t  my $patchinfo = repreadxml($rev, '_patchinfo', $files->{'_patchinfo'}, $BSXML::patchinfo, 1);\n          if (!$patchinfo) {\n\t    $pinfo->{'error'} = \"bad patchinfo data\";\n\t    next;\n\t  }\n          eval {\n\t    BSVerify::verify_patchinfo($patchinfo);\n          };\n\t  if ($@) {\n\t    my $err = $@;\n\t    chomp $err;\n\t    $pinfo->{'error'} = \"bad patchinfo: $err\";\n\t    next;\n\t  }\n\t  $pinfo->{'patchinfo'} = $patchinfo;\n\t  if (($enable && %$enable) || ($disable && %$disable)) {\n\t    my @dinfo = ();\n\t    for my $repo (@{$proj->{'repository'} || []}) {\n\t      my $repoid = $repo->{'name'};\n\t      next if $repoids && !$repoids->{$repoid};\n\t      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {\n\t        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};\n\t\tnext;\n\t      }\n\t    }\n\t    $pinfo->{'info'} = \\@dinfo if @dinfo;\n\t  }\n\t} elsif ($files->{'_channel'}) {\n\t  if (!exists($channeldata{$files->{'_channel'}})) {\n\t    eval {\n\t      my $channel = repreadxml($rev, '_channel', $files->{'_channel'}, $BSXML::channel);\n\t      BSVerify::verify_channel($channel);\n\t      $channeldata{$files->{'_channel'}} = $channel;\n\t    };\n\t    if ($@) {\n\t      my $err = $@;\n\t      chomp $err;\n\t      $channeldata{$files->{'_channel'}} = $err;\n\t    }\n\t  }\n\t  my $channel = $channeldata{$files->{'_channel'}} || 'bad data';\n          if (!ref($channel)) {\n\t    $pinfo->{'error'} = \"bad channel: $channel\";\n\t    next;\n\t  }\n          $pinfo->{'channelmd5'} = $files->{'_channel'};\n\t  if (($enable && %$enable) || ($disable && %$disable)) {\n\t    my @dinfo = ();\n\t    for my $repo (@{$proj->{'repository'} || []}) {\n\t      my $repoid = $repo->{'name'};\n\t      next if $repoids && !$repoids->{$repoid};\n\t      if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {\n\t        push @dinfo, {'repository' => $repoid, 'error' => 'disabled'};\n\t\tnext;\n\t      }\n\t    }\n\t    $pinfo->{'info'} = \\@dinfo if @dinfo;\n\t  }\n        } elsif ($cgi->{'withdeps'}) {\n\t  my @dinfo;\n\n\t  $pinfo->{'constraintsmd5'} = $files->{'_constraints'} if $files->{'_constraints'};\n\t  $pinfo->{'hasbuildenv'} = 1 if $files->{'_buildenv'};\n\t  for my $repo (@{$proj->{'repository'} || []}) {\n\t    my $repoid = $repo->{'name'};\n\t    next if $repoids && !$repoids->{$repoid};\n\n\t    my $rinfo = {'repository' => $repoid};\n\t    push @dinfo, $rinfo;\n\t    if ($exclude_repos && $exclude_repos->{$repoid}) {\n\t      $rinfo->{'error'} = 'excluded';\n\t      next;\n\t    }\n\t    if ((!$disable || $disable->{$repoid}) && !(!$enable || $enable->{$repoid})) {\n\t      $rinfo->{'error'} = 'disabled';\n\t      next;\n\t    }\n            if (!$bconfs{$repoid}) {\n\t      print \"calculating config for $projid/$repoid $arch\\n\";\n\t      my $path = $expandedrepos{\"$projid/$repoid\"};\n\t      if (!$path) {\n\t        eval {\n\t\t  my @path = expandsearchpath($projid, $repoid, $remotemap);\n\t\t  $expandedrepos{\"$projid/$repoid\"} = \\@path;\n\t\t};\n\t\t$expandedrepos{\"$projid/$repoid\"} = $@ if $@;\n\t\t$path = $expandedrepos{\"$projid/$repoid\"};\n\t      }\n\t      eval {\n\t\tdie($path) unless ref $path;\n\t\tmy $c = concatconfigs($projid, $repoid, $remotemap, @$path);\n\t        $bconfs{$repoid} = Build::read_config($arch, [ split(\"\\n\", $c) ]);\n\t      };\n\t      if ($@) {\n\t        my $err = $@;\n\t        chomp $err;\n\t        $bconfs{$repoid} = {'error' => $err};\n\t      }\n            }\n\t    my $conf = $bconfs{$repoid};\n\t    if ($conf->{'error'}) {\n\t      $rinfo->{'error'} = $conf->{'error'};\n\t      next;\n\t    }\n\t    my $type = $conf->{'type'};\n\t    if (!$type || $type eq 'UNDEFINED') {\n\t      $rinfo->{'error'} = 'bad build configuration, no build type defined or detected';\n\t      next;\n\t    }\n            my ($md5, $file) = findfile($rev, $repoid, $type, $files);\n\t    if (!$md5) {\n\t      # no spec/dsc/kiwi file found\n\t      if ($files->{'_preinstallimage'} || $files->{'simpleimage'}  || grep {/\\.(?:spec|dsc|kiwi)$/} keys %$files) {\n\t\t# only different types available\n\t\t$rinfo->{'error'} = 'excluded';\n\t      }\n\t      next;\n\t    }\n\t    $rinfo->{'file'} = $file;\n\t    my $buildtype = Build::recipe2buildtype($file);\n\t    if (!$buildtype) {\n\t      $rinfo->{'error'} = \"don't know how to build $file\";\n\t      next;\n\t    }\n\t    if (($type eq 'kiwi' || $buildtype eq 'kiwi') && $BSConfig::kiwiprojects && !$cgi->{'ignoredisable'}) {\n\t      my %kiwiprojects = map {$_ => 1} @$BSConfig::kiwiprojects;\n\t      if (!$kiwiprojects{$projid}) {\n\t\t$rinfo->{'error'} = 'kiwi image building is not enabled for this project';\n\t        next;\n\t      }\n\t    }\n\t    # get build dependency info\n\t    my $d = Build::parse_typed($conf, \"$srcrep/$packid/$md5-$file\", $buildtype);\n\t    data2utf8xml($d);\n\t    if (!$d || !defined($d->{'name'})) {\n\t      $rinfo->{'error'} = \"can not parse package name from $file\";\n\t      $rinfo->{'error'} .= \" because: \".$d->{'error'} if $d->{'error'};\n\t      next;\n\t    }\n\t    my $version = defined($d->{'version'}) ? $d->{'version'} : 'unknown';\n\t    $pinfo->{'versrel'} ||= \"$version-$rev->{'vrev'}\";\n\t    $rinfo->{'name'} = $d->{'name'};\n\t    $rinfo->{'dep'} = $d->{'deps'};\n\t    if ($d->{'prereqs'}) {\n\t      my %deps = map {$_ => 1} (@{$d->{'deps'} || []}, @{$d->{'subpacks'} || []});\n\t      my @prereqs = grep {!$deps{$_} && !/^%/} @{$d->{'prereqs'}};\n\t      $rinfo->{'prereq'} = \\@prereqs if @prereqs;\n\t    }\n            # add all source services to be used at build time\n\t    if ($files->{'_service'}) {\n              my $services = repreadxml($rev, '_service', $files->{'_service'}, $BSXML::services, 1);\n              for my $service (@{$services->{'service'} || []}) {\n                next unless $service->{'mode'} && $service->{'mode'} eq \"buildtime\";\n                push @{$rinfo->{'dep'}}, \"obs-service-$service->{'name'}\";\n              }\n            }\n\t    # KIWI Products support debugmedium and sourcemedium filters\n\t    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') eq 'product') {\n\t      $rinfo->{'nodbgpkgs'} = 1 if defined($d->{'debugmedium'}) && $d->{'debugmedium'} <= 0;\n\t      $rinfo->{'nosrcpkgs'} = 1 if defined($d->{'sourcemedium'}) && $d->{'sourcemedium'} <= 0;\n\t    }\n\t    # KIWI Images don't build with local arch\n\t    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') ne 'product') {\n\t      $rinfo->{'error'} = 'excluded' if defined($BSConfig::localarch) && $arch eq 'local';\n\t    }\n\t    if ($type eq 'kiwi' && ($d->{'imagetype'}[0] || '') eq 'product') {\n\t      # KIWI Products always build on the first repo arch\n\t      $rinfo->{'imagearch'} = [ @{$d->{'exclarch'}} ] if $d->{'exclarch'};\n\t    } else {\n\t      my $myarch = $conf->{'target'} ? (split('-', $conf->{'target'}))[0] : $arch;\n\t      $rinfo->{'error'} = 'excluded' if $d->{'exclarch'} && !grep {$_ eq $myarch} @{$d->{'exclarch'}};\n\t      $rinfo->{'error'} = 'excluded' if $d->{'badarch'} && grep {$_ eq $myarch} @{$d->{'badarch'}};\n\t    }\n\t    for ('imagetype', 'path', 'extrasource') {\n\t      $rinfo->{$_} = $d->{$_} if exists $d->{$_};\n\t    }\n\t    if ($remotemap && $rinfo->{'path'}) {\n\t      # simple way to fill the remote map\n\t      eval {\n\t\tconcatconfigs($projid, $repoid, $remotemap, map {\"$_->{'project'}/$_->{'repository'}\"} grep {$_->{'project'} ne '_obsrepositories'} @{$rinfo->{'path'}});\n\t      };\n\t    }\n\t  }\n\t  $pinfo->{'info'} = \\@dinfo if @dinfo;\n\t}\n      }\n    }\n    $jinfo->{'package'} = \\@pinfo;\n    push @res, $jinfo;\n  }\n  $frozenlinks_cache = undef;\n  my $ret = {'repoid' => $repoid, 'project' => \\@res};\n  if ($remotemap) {\n    delete $remotemap->{':partition'};\n    delete $remotemap->{':partitions'};\n  }\n  #print Dumper($remotemap);\n  if ($remotemap && %$remotemap) {\n    for my $p (sort keys %$remotemap) {\n      next unless $remotemap->{$p};\n      my $r = {'project' => $p};\n      # keep in sync with BSXML! (we only use access/publish from the flags)\n      for (qw{kind root remoteurl remoteproject remoteroot partition proto config publish access person group repository error}) {\n        $r->{$_} = $remotemap->{$p}->{$_} if defined($remotemap->{$p}->{$_});\n      }\n      $r->{'error'} =~ s/\\n$// if $r->{'error'};\n      push @{$ret->{'remotemap'}}, $r;\n    }\n  }\n  if (%channeldata) {\n    for my $md5 (sort keys %channeldata) {\n      next unless ref($channeldata{$md5});\n      push  @{$ret->{'channeldata'}}, {'md5' => $md5, 'channel' => $channeldata{$md5} };\n    }\n  }\n  if ($cgi->{'view'} && $cgi->{'view'} eq 'storable') {\n    return ($ret, \\&BSUtil::tostorable, 'Content-Type: application/octet-stream');\n  }\n  return ($ret, $BSXML::projpack);\n}\n\nsub getprojectlist {\n  my ($cgi) = @_;\n  my @projects = findprojects($cgi->{'deleted'});\n  @projects = map {{'name' => $_}} @projects;\n  return ({'entry' => \\@projects}, $BSXML::dir);\n}\n\nsub getproject {\n  my ($cgi, $projid) = @_;\n  # Read the project xml file\n  my $proj = readproj($projid, 1, $cgi->{'rev'});\n  $proj = remoteprojid($projid) if !$proj || $proj->{'remoteurl'};\n  die(\"404 project '$projid' does not exist\\n\") unless $proj;\n  if ($proj->{'remoteurl'}) {\n    my $p = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_meta\", 'proxy' => $proxy}, $BSXML::proj);\n    # map remote names to local names\n    $p->{'name'} = $projid;\n    for my $r (@{$p->{'repository'} || []}) {\n      for my $re (@{$r->{'path'} || []}) {\n\t$re->{'project'} = maptoremote($proj, $re->{'project'});\n      }\n      for my $re (@{$r->{'releasetarget'} || []}) {\n\t$re->{'project'} = maptoremote($proj, $re->{'project'});\n      }\n    }\n    for my $pp (@{$p->{'link'} || []}) {\n      $pp->{'project'} = maptoremote($proj, $pp->{'project'});\n    }\n    delete $p->{'person'};\n    delete $p->{'group'};\n    $p->{'mountproject'} = $proj->{'root'} if defined $proj->{'root'};\n    $proj = $p;\n  }\n  return ($proj, $BSXML::proj);\n}\n\n#########################################################################\n\nsub pubkey2sslcert {\n  my ($projid, $pubkeyfile, $signkeyfile) = @_;\n  die(\"don't know how to generate a ssl cert\\n\") unless $BSConfig::sign;\n  $pubkeyfile ||= \"$projectsdir/$projid.pkg/_pubkey\";\n  $signkeyfile ||= \"$projectsdir/$projid.pkg/_signkey\";\n  my @signargs;\n  push @signargs, '--project', $projid if $BSConfig::sign_project;\n  my $cert = '';\n  eval {\n    $cert = BSUtil::xsystem(undef, $BSConfig::sign, @signargs, '-P', $signkeyfile, '-C', $pubkeyfile);\n  };\n  if ($@) {\n    die(\"Need an RSA key for openssl signing, please create a new key for $projid\\n\") if $@ =~ /not an RSA private key/i;\n    die($@);\n  }\n  return $cert;\n}\n\nsub updatesslcert {\n  my ($projid, $pubkeyfile, $signkeyfile) = @_;\n  my $rev = getrev_meta($projid, undef);\n  return undef unless $rev;\n  my $files = lsrev($rev);\n  return undef unless $files->{'_sslcert'};\n  my $cert = pubkey2sslcert($projid, $pubkeyfile, $signkeyfile);\n  mkdir_p($uploaddir);\n  writestr(\"$uploaddir/sslcert.$$\", undef, $cert);\n  return \"$uploaddir/sslcert.$$\";\n}\n\nsub createkey {\n  my ($cgi, $projid) = @_;\n  $cgi->{'comment'} ||= 'create sign key';\n  die(\"don't know how to create a key\\n\") unless $BSConfig::sign;\n  die(\"404 project $projid does not exist\\n\") unless -s \"$projectsdir/$projid.xml\";\n  mkdir_p($uploaddir);\n  my $pubkey = '';\n  my @keyargs = ('rsa@2048', '800');\n  my @signargs;\n  push @signargs, '--project', $projid if $BSConfig::sign_project;\n  my $obsname = $BSConfig::obsname || 'build.opensuse.org';\n  local *F;\n  open(F, '-|', $BSConfig::sign, @signargs, '-P', \"$uploaddir/signkey.$$\", '-g', @keyargs, \"$projid OBS Project\", \"$projid\\@$obsname\") || die(\"$BSConfig::sign: $!\\n\");\n  1 while sysread(F, $pubkey, 4096, length($pubkey));\n  close(F) || die(\"$BSConfig::sign: $?\\n\");\n  die(\"sign did not create signkey\\n\") unless -s \"$uploaddir/signkey.$$\";\n  mkdir_p(\"$projectsdir/$projid.pkg\");\n  writestr(\"$uploaddir/pubkey.$$\", undef, $pubkey);\n  my $certfile = updatesslcert($projid, \"$uploaddir/pubkey.$$\", \"$uploaddir/signkey.$$\");\n  addrev_meta_multiple($cgi, $projid, undef, 'mrev',\n\t[ \"$uploaddir/pubkey.$$\",  \"$projectsdir/$projid.pkg/_pubkey\",  '_pubkey' ],\n\t[ \"$uploaddir/signkey.$$\", \"$projectsdir/$projid.pkg/_signkey\", '_signkey' ],\n\t[ $certfile, undef, '_sslcert' ]);\n  return $BSStdServer::return_ok;\n}\n\nsub extendkey {\n  my ($cgi, $projid) = @_;\n  $cgi->{'comment'} ||= 'extend public key expiry date';\n  die(\"don't know how to extend a key\\n\") unless $BSConfig::sign;\n  die(\"project does not have a key\\n\") unless -s \"$projectsdir/$projid.pkg/_pubkey\";\n  die(\"project does not have a signkey\\n\") unless -s \"$projectsdir/$projid.pkg/_signkey\";\n  my @keyargs = ('800');\n  my @signargs;\n  push @signargs, '--project', $projid if $BSConfig::sign_project;\n  my $pubkey = '';\n  local *F;\n  open(F, '-|', $BSConfig::sign, @signargs, '-P', \"$projectsdir/$projid.pkg/_signkey\", '-x', @keyargs, \"$projectsdir/$projid.pkg/_pubkey\") || die(\"$BSConfig::sign: $!\\n\");\n  1 while sysread(F, $pubkey, 4096, length($pubkey));\n  close(F) || die(\"$BSConfig::sign: $?\\n\");\n  mkdir_p($uploaddir);\n  writestr(\"$uploaddir/pubkey.$$\", undef, $pubkey);\n  my $certfile = updatesslcert($projid, \"$uploaddir/pubkey.$$\");\n  addrev_meta_multiple($cgi, $projid, undef, 'mrev',\n\t[ \"$uploaddir/pubkey.$$\",  \"$projectsdir/$projid.pkg/_pubkey\",  '_pubkey' ],\n\t[ $certfile, undef, '_sslcert' ]);\n  return $BSStdServer::return_ok;\n}\n\nsub deletekey {\n  my ($cgi, $projid) = @_;\n  $cgi->{'comment'} ||= 'delete sign key';\n  if ($BSConfig::forceprojectkeys) {\n    my $pprojid = $projid;\n    $pprojid =~ s/:[^:]*$//;\n    my $sk;\n    ($sk) = getsignkey({}, $pprojid) if $projid ne $pprojid;\n    die(\"must have a key for signing in this or upper project\\n\") unless $sk;\n  }\n  addrev_meta_multiple($cgi, $projid, undef, 'mrev',\n\t[ undef, \"$projectsdir/$projid.pkg/_pubkey\",  '_pubkey' ],\n\t[ undef, \"$projectsdir/$projid.pkg/_signkey\", '_signkey' ],\n\t[ undef, undef,                               '_sslcert' ]);\n  rmdir(\"$projectsdir/$projid.pkg\");\n  return $BSStdServer::return_ok;\n}\n\nsub getpubkey {\n  my ($cgi, $projid) = @_;\n  my $pubkey;\n\n  my $proj = readproj($projid, 1, $cgi->{'rev'});\n  $proj = remoteprojid($projid) if !$proj || $proj->{'remoteurl'};\n  die(\"404 project '$projid' does not exist\\n\") unless $proj;\n\n  if ($proj->{'remoteurl'}) {\n    $pubkey = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_pubkey\", 'proxy' => $proxy}, undef);\n  } else {\n    if ($cgi->{'rev'}) {\n      my $rev = getrev_meta($projid, undef, $cgi->{'rev'});\n      my $files = $rev ? lsrev($rev) : {};\n      $pubkey = repreadstr($rev, '_pubkey', $files->{'_pubkey'}, 1) if $files->{'_pubkey'};\n    } else {\n      $pubkey = readstr(\"$projectsdir/$projid.pkg/_pubkey\", 1);\n    }\n  }\n  die(\"404 $projid: no pubkey available\\n\") unless $pubkey;\n  return ($pubkey, 'Content-Type: text/plain');\n}\n\n#########################################################################\n\nsub putproject {\n  my ($cgi, $projid) = @_;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $proj = readxml(\"$uploaddir/$$\", $BSXML::proj);\n  $proj->{'name'} = $projid unless defined $proj->{'name'};\n  BSVerify::verify_proj($proj, $projid);\n  writexml(\"$uploaddir/$$.2\", undef, $proj, $BSXML::proj);\n  unlink(\"$uploaddir/$$\");\n  my $oldproj = readxml(\"$projectsdir/$projid.xml\", $BSXML::proj, 1);\n  notify($oldproj ? \"SRCSRV_UPDATE_PROJECT\" : \"SRCSRV_CREATE_PROJECT\", { \"project\" => $projid, \"sender\" => ($cgi->{'user'} || \"unknown\") });\n  mkdir_p(\"$projectsdir\") || die(\"creating $projectsdir: $!\\n\");\n  addrev_meta($cgi, $projid, undef, \"$uploaddir/$$.2\", \"$projectsdir/$projid.xml\", '_meta');\n  if ($BSConfig::forceprojectkeys) {\n    my ($sk) = getsignkey({}, $projid);\n    createkey({ %$cgi, 'comment' => 'autocreate key' }, $projid) if $sk eq '';\n  }\n\n  my %except = map {$_ => 1} qw{title description person group url attributes};\n  if (!identical($oldproj, $proj, \\%except)) {\n    if ($cgi->{'lowprio'}) {\n      notify_repservers('lowprioproject', $projid);\n    } else {\n      notify_repservers('project', $projid);\n    }\n  }\n\n  $proj = readproj($projid);\n  return ($proj, $BSXML::proj);\n}\n\nsub delproject {\n  my ($cgi, $projid) = @_;\n\n  $cgi->{'comment'} ||= 'project was deleted';\n  die(\"404 project '$projid' does not exist\\n\") unless -e \"$projectsdir/$projid.xml\";\n  # add delete commit to both source and meta\n  addrev_meta($cgi, $projid, undef, undef, undef, undef, 'rev');\n  addrev_meta($cgi, $projid, undef, undef, undef, undef);\n  if (-d \"$projectsdir/$projid.pkg\") {\n    # delete packages in sub process to avoid timeout errors\n    my $pid;\n    if (!($pid = xfork())) {\n      # delete those packages and keys\n      mkdir_p(\"$projectsdir/_deleted/$projid.pkg\");\n      # make room in old delete by deleting all old packages\n      for my $f (ls(\"$projectsdir/_deleted/$projid.pkg\")) {\n        if ($f =~ /\\.m?rev$/) {\n          my $oldrev = readstr(\"$projectsdir/_deleted/$projid.pkg/$f\", 1);\n          if (defined($oldrev) && $oldrev ne '') {\n            BSUtil::lockopen(\\*F, '+>>', \"$projectsdir/_deleted/$projid.pkg/$f.del\");\n            BSUtil::appendstr(\"$projectsdir/_deleted/$projid.pkg/$f.del\", $oldrev);\n            # XXX: add comment\n            close F;\n          }\n          unlink(\"$projectsdir/_deleted/$projid.pkg/$f\");\n        }\n      }\n      for my $f (ls(\"$projectsdir/$projid.pkg\")) {\n        if ($f =~ /^(.*)\\.xml$/) {\n          my $packid = $1;\n          if (! -f \"$projectsdir/$projid.pkg/$1.mrev\") {\n            # create initial meta revision in case it does not exist yet\n            addrev_meta($cgi, $projid, $packid, undef, undef, undef);\n          }\n        }\n      }\n      for my $f (ls(\"$projectsdir/$projid.pkg\")) {\n        if ($f =~ /\\.m?rev(?:\\.del)?$/) {\n          updatelinkinfodb($projid, $1) if $f =~ /^(.*)\\.rev$/;\n          my $oldrev = readstr(\"$projectsdir/$projid.pkg/$f\", 1);\n          if (defined($oldrev) && $oldrev ne '') {\n            BSUtil::lockopen(\\*F, '+>>', \"$projectsdir/_deleted/$projid.pkg/$f\");\n            BSUtil::appendstr(\"$projectsdir/_deleted/$projid.pkg/$f\", $oldrev);\n            close F;\n          }\n        }\n        unlink(\"$projectsdir/$projid.pkg/$f\");\n      }\n      rmdir(\"$projectsdir/$projid.pkg\") || die(\"rmdir $projectsdir/$projid.pkg: $!\\n\");\n    }\n  }\n  unlink(\"$projectsdir/$projid.conf\");\n  unlink(\"$projectsdir/$projid.xml\");\n  notify_repservers('project', $projid);\n\n  notify(\"SRCSRV_DELETE_PROJECT\", { \"project\" => $projid, \"comment\" => $cgi->{'comment'}, \"sender\" => ($cgi->{'user'} || \"unknown\"), \"requestid\" => $cgi->{'requestid'} });\n\n  return $BSStdServer::return_ok;\n}\n\nsub undeleteproject {\n  my ($cgi, $projid) = @_;\n\n  die(\"404 project '$projid' already exists\\n\") if -e \"$projectsdir/$projid.xml\";\n  die(\"404 project '$projid' is not deleted\\n\") unless -e \"$projectsdir/_deleted/$projid.pkg\";\n  $cgi->{'comment'} ||= 'project was undeleted';\n  mkdir_p($uploaddir);\n  mkdir_p(\"$projectsdir/$projid.pkg\");\n  for my $f (ls(\"$projectsdir/_deleted/$projid.pkg\")) {\n    if ($f =~ /\\.m?rev\\.del$/) {\n      BSUtil::cp(\"$projectsdir/_deleted/$projid.pkg/$f\", \"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/$f\");\n    } elsif ($f =~ /^(.*)\\.(m?rev)$/) {\n      my $packid = $1;\n      my $suf = $2;\n      my $rev = undelete_rev($cgi, \"$projectsdir/_deleted/$projid.pkg/$f\", \"$projectsdir/$projid.pkg/$f\");\n      $rev->{'project'} = $projid;\n      $rev->{'package'} = $packid;\n      # extract legacy files\n      if ($suf eq 'rev') {\n\tif ($packid eq '_project') {\n          extract_old_prjsource($projid, $rev);\n\t} else {\n\t  updatelinkinfodb($projid, $packid, $rev, lsrev($rev));\n\t}\n      } elsif ($suf eq 'mrev') {\n        extract_old_meta($projid, $packid, $rev);\n      }\n    }\n  }\n  notify_repservers('project', $projid);\n  notify(\"SRCSRV_UNDELETE_PROJECT\", { \"project\" => $projid, \"comment\" => $cgi->{'comment'}, \"sender\" => ($cgi->{'user'} || \"unknown\") });\n\n  return $BSStdServer::return_ok;\n}\n\n#########################################################################\n\nsub getpackagelist {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n  my $origins = $cgi->{'noorigins'} ? undef : {};\n  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1) unless $cgi->{'deleted'};\n  my @packages = findpackages($projid, $proj, 0, {}, $origins, !$cgi->{'expand'}, $cgi->{'deleted'});\n  for (@packages) {\n    $_ = {'name' => $_};\n    $_->{'originproject'} = $origins->{$_->{'name'}} if $origins && $origins->{$_->{'name'}} ne $projid;\n  }\n  return ({'entry' => \\@packages}, $BSXML::dir);\n}\n\nsub getpackage {\n  my ($cgi, $projid, $packid) = @_;\n  my $proj;\n  $proj = checkprojrepoarch($projid, undef, undef, 1) unless $cgi->{'deleted'};\n  if ($proj && $proj->{'remoteurl'}) {\n    my @args;\n    push @args, \"rev=$cgi->{'rev'}\" if $cgi->{'rev'};\n    my $pack = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/_meta\", 'proxy' => $proxy}, $BSXML::pack, @args);\n    $pack->{'project'} = $projid;\t# local name\n    if ($pack->{'devel'} && exists($pack->{'devel'}->{'project'})) {\n      $pack->{'devel'}->{'project'} = maptoremote($proj, $pack->{'devel'}->{'project'});\n    }\n    delete $pack->{'person'};\n    delete $pack->{'group'};\n    delete $pack->{$_} for map {$_->[0]} @BSXML::flags;\n    return ($pack, $BSXML::pack);\n  }\n  if ($cgi->{'rev'} || $cgi->{'deleted'} || $packid eq '_project') {\n    # return the exact file here\n    # we also do not look at project links\n    # we return the data as string so that the md5 sum matches\n    my $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});\n    my $files = lsrev($rev);\n    die(\"404 _meta: no such file\\n\") unless $files->{'_meta'};\n    my $meta = repreadstr($rev, '_meta', $files->{'_meta'});\n    return ($meta);\n  }\n  my $pack = readpack($projid, $packid, 1);\n  $pack->{'project'} ||= $projid if $pack;\n  if (!$pack && $proj->{'link'}) {\n    my %checked = ($projid => 1);\n    my @todo = map {$_->{'project'}} @{$proj->{'link'}};\n    while (@todo) {\n      my $lprojid = shift @todo;\n      next if $checked{$lprojid};\n      $checked{$lprojid} = 1;\n      my $lproj = readproj($lprojid, 1);\n      $lproj = remoteprojid($lprojid) if !$lproj || $lproj->{'remoteurl'};\n      if ($lproj->{'remoteurl'}) {\n\teval {\n\t  $pack = BSRPC::rpc({'uri' => \"$lproj->{'remoteurl'}/source/$lproj->{'remoteproject'}/$packid/_meta\", 'proxy' => $proxy}, $BSXML::pack);\n\t};\n        die($@) if $@ && $@ !~ /^404/;\n\tif ($pack) {\n\t  $pack->{'project'} = $lprojid;\t# local name\n\t  if ($pack->{'devel'} && exists($pack->{'devel'}->{'project'})) {\n\t    $pack->{'devel'}->{'project'} = maptoremote($lproj, $pack->{'devel'}->{'project'});\n\t  }\n\t}\n      } else {\n        $pack = readpack($lprojid, $packid, 1);\n        $pack->{'project'} ||= $lprojid if $pack;\n        unshift @todo, map {$_->{'project'}} @{$lproj->{'link'}} if !$pack && $lproj->{'link'};\n      }\n      last if $pack;\n    }\n  }\n  die(\"404 package '$packid' does not exist in project '$projid'\\n\") unless $pack;\n  return ($pack, $BSXML::pack);\n}\n\nsub putpackage {\n  my ($cgi, $projid, $packid) = @_;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $pack = readxml(\"$uploaddir/$$\", $BSXML::pack);\n  $pack->{'name'} = $packid unless defined $pack->{'name'};\n  BSVerify::verify_pack($pack, $packid);\n  die(\"package contains revision data\\n\") if grep {exists $pack->{$_}} @$srcrevlay;\n  # XXX\n  # delete rev stuff, just in case...\n  # delete $pack->{$_} for @$srcrevlay;\n  # $pack->{'name'} = $packid;\n  writexml(\"$uploaddir/$$.2\", undef, $pack, $BSXML::pack);\n  unlink(\"$uploaddir/$$\");\n  my $proj = readproj($projid);\n  die(\"$projid is a remote project\\n\") if $proj->{'remoteurl'};\n  if ($packid eq '_product' && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n    # creating a _product package, make sure that there is no _product:xxx package\n    my @pkgs = findpackages($projid, $proj, 1, undef, undef, 1);\n    die(\"cannot create '$packid' if _product:* packages already exist\\n\") if grep {/^_product:/} @pkgs;\n  }\n  if (($packid =~ /^_product:/) && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n    die(\"403 cannot create '$packid' if a '_product' package exists\\n\") if -e \"$projectsdir/$projid.pkg/_product.xml\";\n  }\n  mkdir_p(\"$projectsdir/$projid.pkg\");\n\n  my $oldpack = readxml(\"$projectsdir/$projid.pkg/$packid.xml\", $BSXML::pack, 1);\n  notify($oldpack ? \"SRCSRV_UPDATE_PACKAGE\" : \"SRCSRV_CREATE_PACKAGE\", { \"project\" => $projid, \"package\" => $packid, \"sender\" => ($cgi->{'user'} || \"unknown\")});\n\n  addrev_meta($cgi, $projid, $packid, \"$uploaddir/$$.2\", \"$projectsdir/$projid.pkg/$packid.xml\", '_meta');\n  my %except = map {$_ => 1} qw{title description devel person group url};\n  if (!identical($oldpack, $pack, \\%except)) {\n    notify_repservers('package', $projid, $packid);\n  }\n  $pack = readpack($projid, $packid);\n  return ($pack, $BSXML::pack);\n}\n\nsub delpackage {\n  my ($cgi, $projid, $packid) = @_;\n  $cgi->{'comment'} ||= 'package was deleted';\n  die(\"404 project '$projid' does not exist\\n\") unless -e \"$projectsdir/$projid.xml\";\n  die(\"404 package '$packid' does not exist in project '$projid'\\n\") unless -e \"$projectsdir/$projid.pkg/$packid.xml\";\n  if ($packid =~ /^_product:/) {\n    die(\"403 cannot delete '$packid' if a '_product' package exists\\n\") if -e \"$projectsdir/$projid.pkg/_product.xml\";\n  }\n  # add delete commit to both source and meta\n  addrev_meta($cgi, $projid, $packid, undef, undef, undef, 'rev');\n  addrev_meta($cgi, $projid, $packid, undef, undef, undef);\n  unlink(\"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\");\n  unlink(\"$projectsdir/$projid.pkg/$packid.xml\");\n  my $oldrev = readstr(\"$projectsdir/$projid.pkg/$packid.rev\", 1);\n  if (defined($oldrev) && $oldrev ne '') {\n    BSUtil::lockopen(\\*F, '+>>', \"$projectsdir/$projid.pkg/$packid.rev.del\");\n    BSUtil::appendstr(\"$projectsdir/$projid.pkg/$packid.rev.del\", $oldrev);\n    close F;\n    updatelinkinfodb($projid, $packid);\n  }\n  unlink(\"$projectsdir/$projid.pkg/$packid.rev\");\n  $oldrev = readstr(\"$projectsdir/$projid.pkg/$packid.mrev\", 1);\n  if (defined($oldrev) && $oldrev ne '') {\n    BSUtil::lockopen(\\*F, '+>>', \"$projectsdir/$projid.pkg/$packid.mrev.del\");\n    BSUtil::appendstr(\"$projectsdir/$projid.pkg/$packid.mrev.del\", $oldrev);\n    close F;\n  }\n  unlink(\"$projectsdir/$projid.pkg/$packid.mrev\");\n  if ($packid eq '_product') {\n    expandproduct($projid, $packid, undef, undef);\n  }\n  notify_repservers('package', $projid, $packid);\n  notify(\"SRCSRV_DELETE_PACKAGE\", { \"project\" => $projid, \"package\" => $packid, \"sender\" => ($cgi->{'user'} || \"unknown\"), \"comment\" => $cgi->{'comment'}, \"requestid\" => $cgi->{'requestid'} });\n  return $BSStdServer::return_ok;\n}\n\nsub undelete_rev {\n  my ($cgi, $revfilefrom, $revfileto) = @_;\n  my @rev = BSFileDB::fdb_getall($revfilefrom, $srcrevlay);\n  die(\"$revfilefrom: no entries\\n\") unless @rev;\n  # XXX add way to specify which block to restore\n  for my $rev (reverse splice @rev) {\n    unshift @rev, $rev;\n    last if $rev->{'rev'} == 1;\n  }\n  my $rev = $rev[-1];\n  my $user = defined($cgi->{'user'}) ? str2utf8xml($cgi->{'user'}) : 'unknown';\n  my $comment = defined($cgi->{'comment'}) ? str2utf8xml($cgi->{'comment'}) : '';\n  my $nrev = { 'srcmd5' => $rev->{'srcmd5'}, 'time' => time(), 'user' => $user, 'comment' => $comment, 'requestid' => $cgi->{'requestid'} };\n  $nrev->{'version'} = $rev->{'version'} if $rev && defined $rev->{'version'};\n  $nrev->{'vrev'} = $rev->{'vrev'} if $rev && defined $rev->{'vrev'};\n  $nrev->{'rev'} = $rev->{'rev'} + 1;\n  if ($cgi->{'time'}) {\n    die(\"specified time is less than time in last commit\\n\") if $rev && $rev->{'time'} > $cgi->{'time'};\n    $nrev->{'time'} = $cgi->{'time'};\n  }\n  push @rev, $nrev;\n  BSFileDB::fdb_add_multiple($revfileto, $srcrevlay, @rev);\n  return $nrev;\n}\n\nsub undeletepackage {\n  my ($cgi, $projid, $packid) = @_;\n  $cgi->{'comment'} ||= 'package was undeleted';\n  die(\"404 project '$projid' does not exist\\n\") unless -e \"$projectsdir/$projid.xml\";\n  die(\"403 package '$packid' already exists\\n\") if -e \"$projectsdir/$projid.pkg/$packid.xml\";\n  die(\"403 package '$packid' was not deleted\\n\") unless -e \"$projectsdir/$projid.pkg/$packid.rev.del\";\n  my $rev = undelete_rev($cgi, \"$projectsdir/$projid.pkg/$packid.mrev.del\", \"$projectsdir/$projid.pkg/$packid.mrev\");\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n  extract_old_meta($projid, $packid, $rev);\n  if (-s \"$projectsdir/$projid.pkg/$packid.rev.del\") {\n    my $nrev = undelete_rev($cgi, \"$projectsdir/$projid.pkg/$packid.rev.del\", \"$projectsdir/$projid.pkg/$packid.rev\");\n    $nrev->{'project'} = $projid;\n    $nrev->{'package'} = $packid;\n    updatelinkinfodb($projid, $packid, $nrev, lsrev($nrev));\n  }\n  notify_repservers('package', $projid, $packid);\n  notify(\"SRCSRV_UNDELETE_PACKAGE\", { \"project\" => $projid, \"package\" => $packid, \"sender\" => ($cgi->{'user'} || \"unknown\"), \"comment\" => $cgi->{'comment'} });\n\n  return $BSStdServer::return_ok;\n}\n\nsub getpackagehistory {\n  my ($cgi, $projid, $packid) = @_;\n  my @res;\n  my $revfile;\n  $packid = '_project' unless defined $packid;\n\n  if (!$cgi->{'deleted'}) {\n    my $proj = checkprojrepoarch($projid, undef, undef, 1);\n    if ($proj->{'remoteurl'}) {\n      my @args;\n      push @args, \"rev=$cgi->{'rev'}\" if $cgi->{'rev'};\n      my $h = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/_history\", 'proxy' => $proxy}, $BSXML::revisionlist, @args);\n      return ($h, $BSXML::revisionlist);\n    }\n    if ($packid ne '_project' && ! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n      # check project links\n      die(\"404 package '$packid' does not exist\\n\") unless $proj->{'link'};\n      $cgi->{'_checked'} ||= {};\n      $cgi->{'_checked'}->{$projid} = 1;\n      for my $lprojid (map {$_->{'project'}} @{$proj->{'link'}}) {\n\tnext if $cgi->{'_checked'}->{$lprojid};\n\t$cgi->{'_checked'}->{$lprojid} = 1;\n\tmy $h;\n\teval {\n\t  $h = (getpackagehistory($cgi, $lprojid, $packid))[0];\n\t};\n\tdie($@) if $@ && $@ !~ /^404/;\n\treturn ($h, $BSXML::revisionlist) if $h;\n      }\n      die(\"404 package '$packid' does not exist\\n\");\n    }\n  }\n\n  $revfile = \"$projectsdir/$projid.pkg\";\n  $revfile = \"$projectsdir/_deleted/$projid.pkg\" if $packid eq '_project' && $cgi->{'deleted'};\n  $revfile .= $cgi->{'meta'} ? \"/$packid.mrev\" : \"/$packid.rev\";\n  if ($packid ne '_project' && $cgi->{'deleted'}) {\n    $revfile .= '.del';\n    if (! -e $revfile && ! -e \"$projectsdir/$projid.xml\" && -e \"$projectsdir/_deleted/$projid.pkg\") {\n      $revfile = \"$projectsdir/_deleted/$projid.pkg/$packid.mrev\";\n    }\n  }\n  my $filter;\n  if ($cgi->{'rev'}) {\n    $filter = sub { return $cgi->{'rev'} eq $_[0]->{'rev'} || $cgi->{'rev'} eq $_[0]->{'srcmd5'} ? 1 : 0 };\n  }\n  for (BSFileDB::fdb_getall_reverse($revfile, $srcrevlay, $cgi->{'limit'}, $filter)) {\n    $_->{'comment'} = str2utf8xml($_->{'comment'}) if $_->{'comment'};\n    unshift @res, $_;\n  }\n  return ({'revision' => \\@res}, $BSXML::revisionlist);\n}\n\n##########################################################################\n\n##########################################################################\n\n# XXX -> library\n\nsub remoteprojid {\n  my ($projid) = @_;\n  my $rsuf = '';\n  my $origprojid = $projid;\n\n  my $proj = readproj($projid, 1);\n  if ($proj) {\n    return undef unless $proj->{'remoteurl'};\n    return undef unless $proj->{'remoteproject'};\n    return {\n      'name' => $projid,\n      'root' => $projid,\n      'remoteroot' => $proj->{'remoteproject'},\n      'remoteurl' => $proj->{'remoteurl'},\n      'remoteproject' => $proj->{'remoteproject'},\n    };\n  }\n  while ($projid =~ /^(.*)(:.*?)$/) {\n    $projid = $1;\n    $rsuf = \"$2$rsuf\";\n    $proj = readproj($projid, 1);\n    if ($proj) {\n      return undef unless $proj->{'remoteurl'};\n      if ($proj->{'remoteproject'}) {\n        $rsuf = \"$proj->{'remoteproject'}$rsuf\";\n      } else {\n        $rsuf =~ s/^://;\n      }\n      return {\n        'name' => $origprojid,\n        'root' => $projid,\n        'remoteroot' => $proj->{'remoteproject'},\n        'remoteurl' => $proj->{'remoteurl'},\n        'remoteproject' => $rsuf,\n      };\n    }\n  }\n  return undef;\n}\n\nsub maptoremote {\n  my ($proj, $projid) = @_;\n  return \"$proj->{'root'}:$projid\" unless $proj->{'remoteroot'};\n  return $proj->{'root'} if $projid eq $proj->{'remoteroot'};\n  return '_unavailable' if $projid !~ /^\\Q$proj->{'remoteroot'}\\E:(.*)$/;\n  return \"$proj->{'root'}:$1\";\n}\n\nsub fetchremoteproj {\n  my ($proj, $projid, $remotemap) = @_;\n  return undef unless $proj && $proj->{'remoteurl'} && $proj->{'remoteproject'};\n  $projid ||= $proj->{'name'};\n  my $rproj;\n  my $c;\n  if ($remotemap) {\n    $rproj = $remotemap->{$projid};\n    if ($rproj) {\n      die($rproj->{'error'}) if $rproj->{'error'};\n      return $rproj unless $rproj->{'proto'};\n      $c = $rproj->{'config'};\t# save old config\n      undef $rproj;\n    }\n  }\n  print \"fetching remote project data for $projid\\n\";\n  my $param = {\n    'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_meta\",\n    'timeout' => 60,\n    'proxy' => $proxy,\n  };\n  eval {\n    $rproj = BSRPC::rpc($param, $BSXML::proj);\n  };\n  if ($@) {\n    if ($remotemap) {\n      $rproj = {%$proj, 'error' => $@, 'proto' => 1};\n      $rproj->{'config'} = $c if defined $c;\n      $remotemap->{$projid} = $rproj;\n    }\n    die($@);\n  }\n  for (qw{name kind root remoteroot remoteurl remoteproject}) {\n    $rproj->{$_} = $proj->{$_};\n  }\n  for my $repo (@{$rproj->{'repository'} || []}) {\n    for my $pathel (@{$repo->{'path'} || []}) {\n      $pathel->{'project'} = maptoremote($proj, $pathel->{'project'});\n    }\n    for my $pathel (@{$repo->{'releasetarget'} || []}) {\n      $pathel->{'project'} = maptoremote($proj, $pathel->{'project'});\n    }\n  }\n  for my $link (@{$rproj->{'link'} || []}) {\n    $link->{'project'} = maptoremote($proj, $link->{'project'});\n  }\n  $remotemap->{$projid} = $rproj if $remotemap;\n  return $rproj;\n}\n\nsub fetchremoteconfig {\n  my ($proj, $projid, $remotemap) = @_;\n  return undef unless $proj && $proj->{'remoteurl'} && $proj->{'remoteproject'};\n  $projid ||= $proj->{'name'};\n  if ($remotemap) {\n    my $rproj = $remotemap->{$projid};\n    if ($rproj) {\n      die($rproj->{'error'}) if $rproj->{'error'};\n      return $rproj->{'config'} if defined $rproj->{'config'};\n    } else {\n      $remotemap->{$projid} = {%$proj, 'proto' => 1};\n    }\n  }\n  print \"fetching remote project config for $projid\\n\";\n  my $param = {\n    'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_config\",\n    'timeout' => 60,\n    'proxy' => $proxy,\n  };\n  my $c;\n  eval {\n    $c = BSRPC::rpc($param, undef);\n  };\n  if ($@) {\n    $remotemap->{$projid}->{'error'} = $@ if $remotemap;\n    die($@);\n  }\n  $remotemap->{$projid}->{'config'} = $c if $remotemap;\n  return $c;\n}\n\nsub fill_remote_getrev_cache_projid {\n  my ($projid, $packids) = @_;\n\n  return unless $packids && @$packids;\n  print \"filling remote_getrev cache for $projid @$packids\\n\";\n  my $proj = remoteprojid($projid);\n  return unless $proj;\n  my $silist;\n  my @args;\n  push @args, 'view=info';\n  push @args, 'nofilename=1';\n  push @args, map {\"package=$_\"} @$packids;\n  eval {\n    $silist = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}\", 'proxy' => $proxy}, $BSXML::sourceinfolist, @args);\n  };\n  warn($@) if $@;\n  return unless $silist;\n  for my $si (@{$silist->{'sourceinfo'} || []}) {\n    my $packid = $si->{'package'};\n    my $rev = {};\n    if ($si->{'linked'}) {\n      $rev->{'linked'} = [];\n      for my $l (@{$si->{'linked'}}) {\n        $l->{'project'} = maptoremote($proj, $l->{'project'});\n        push @{$rev->{'linked'}}, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';\n      }\n    }\n    $rev->{'srcmd5'} = $si->{'verifymd5'} || $si->{'srcmd5'};\n    delete $rev->{'srcmd5'} unless defined $rev->{'srcmd5'};\n    if ($si->{'error'}) {\n      if ($si->{'error'} =~ /^(\\d+) +(.*?)$/) {\n        $si->{'error'} = \"$1 remote error: $2\";\n      } else {\n        $si->{'error'} = \"remote error: $si->{'error'}\";\n      }\n      if ($si->{'error'} eq 'no source uploaded') {\n\tdelete $si->{'error'};\n\t$rev->{'srcmd5'} = $emptysrcmd5;\n      } elsif ($si->{'verifymd5'} || $si->{'error'} =~ /^404[^\\d]/) {\n\t$rev->{'error'} = $si->{'error'};\n\t$remote_getrev_cache{\"$projid/$packid/\"} = $rev;\n      } else {\n\tnext;\n      }\n    }\n    next unless $rev->{'srcmd5'};\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n    next unless -e \"$treedir/$rev->{'srcmd5'}-MD5SUMS\";\n    $rev->{'vrev'} = $si->{'vrev'} || '0';\n    $rev->{'rev'} = $si->{'rev'} || $rev->{'srcmd5'};\n    $remote_getrev_cache{\"$projid/$packid/\"} = $rev;\n  }\n}\n\nsub fill_remote_getrev_cache {\n  for my $projid (sort keys %{$remote_getrev_todo || {}}) {\n    my @packids = sort keys %{$remote_getrev_todo->{$projid} || {}};\n    next if @packids <= 1;\n    while (@packids) {\n      my @chunk;\n      my $len = 20;\n      while (@packids) {\n\tmy $packid = shift @packids;\n\tpush @chunk, $packid;\n\t$len += 9 + length($packid);\n\tlast if $len > 1900;\n      }\n      fill_remote_getrev_cache_projid($projid, \\@chunk);\n    }\n  }\n  $remote_getrev_todo = {};\n}\n\nsub remote_getrev {\n  my ($projid, $packid, $rev, $linked, $missingok) = @_;\n  my $proj = remoteprojid($projid);\n  if (!$proj) {\n    return {'project' => $projid, 'package' => $packid, 'srcmd5' => 'pattern', 'rev' => 'pattern'} if $packid eq '_pattern';\n    return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok;\n    die(\"404 package '$packid' does not exist\\n\") if -e \"$projectsdir/$projid.xml\";\n    die(\"404 project '$projid' does not exist\\n\");\n  }\n  # check if we already know this srcmd5, if yes don't bother to contact\n  # the remote server\n  if ($rev && $rev =~ /^[0-9a-f]{32}$/) {\n    my $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n    if ($rev eq $emptysrcmd5 || -e \"$treedir/$rev-MD5SUMS\") {\n      return {'project' => $projid, 'package' => $packid, 'rev' => $rev, 'srcmd5' => $rev};\n    }        \n  }\n  if (defined($rev) && $rev eq '0') {\n    return {'srcmd5' => $emptysrcmd5, 'project' => $projid, 'package' => $packid};\n  }\n  my @args;\n  push @args, 'expand=1';\n  push @args, \"rev=$rev\" if defined $rev;\n  my $cacherev = !defined($rev) || $rev eq 'build' ? '' : $rev;\n  if ($remote_getrev_cache{\"$projid/$packid/$cacherev\"}) {\n    $rev = { %{$remote_getrev_cache{\"$projid/$packid/$cacherev\"}} };\n    push @$linked, map { { %$_ } } @{$rev->{'linked'}} if $linked && $rev->{'linked'};\n    if ($rev->{'error'}) {\n      return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok && $rev->{'error'} =~ /^404[^\\d]/;\n      die(\"$rev->{'error'}\\n\");\n    }\n    delete $rev->{'linked'};\n    $rev->{'project'} = $projid;\n    $rev->{'package'} = $packid;\n    return $rev;\n  }\n  if ($collect_remote_getrev && $cacherev eq '') {\n    $remote_getrev_todo->{$projid}->{$packid} = 1;\n    die(\"collect_remote_getrev\\n\");\n  }\n  my $dir;\n  eval {\n    $dir = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid\", 'proxy' => $proxy}, $BSXML::dir, @args, 'withlinked') if $linked;\n  };\n  if (!$dir || $@) {\n    eval {\n      $dir = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid\", 'proxy' => $proxy}, $BSXML::dir, @args);\n    };\n    if ($@) {\n      return {'project' => $projid, 'package' => $packid, 'srcmd5' => $emptysrcmd5} if $missingok && $@ =~ /^404[^\\d]/;\n      die($@);\n    }\n  }\n  if ($dir->{'error'}) {\n    if ($linked && $dir->{'linkinfo'} && $dir->{'linkinfo'}->{'linked'}) {\n      # add linked info for getprojpack\n      for my $l (@{$dir->{'linkinfo'}->{'linked'}}) {\n        $l->{'project'} = maptoremote($proj, $l->{'project'});\n        push @$linked, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';\n      }\n    }\n    die(\"$dir->{'error'}\\n\");\n  }\n  $rev = {};\n  $rev->{'rev'} = $dir->{'rev'} || $dir->{'srcmd5'};\n  $rev->{'srcmd5'} = $dir->{'srcmd5'};\n  $rev->{'vrev'} = $dir->{'vrev'};\n  $rev->{'vrev'} ||= '0';\n  # now put everything in local srcrep\n  my $files = {};\n  for my $entry (@{$dir->{'entry'} || []}) {\n    $files->{$entry->{'name'}} = $entry->{'md5'};\n    next if -e \"$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}\";\n    if ($linked && $entry->{'size'} > 8192) {\n      # getprojpack request, hand over to AJAX\n      BSHandoff::rpc($ajaxsocket, \"/source/$projid/$packid\", undef, \"rev=$dir->{'srcmd5'}\", 'view=notify');\n      die(\"download in progress\\n\");\n    }\n    mkdir_p($uploaddir);\n    my $param = {\n      'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/$packid/$entry->{'name'}\",\n      'filename' => \"$uploaddir/$$\",\n      'withmd5' => 1,\n      'receiver' => \\&BSHTTP::file_receiver,\n      'proxy' => $proxy,\n    };\n    my $res = BSRPC::rpc($param, undef, \"rev=$rev->{'srcmd5'}\");\n    die(\"file download failed\\n\") unless $res && $res->{'md5'} eq $entry->{'md5'};\n    addfile($projid, $packid, \"$uploaddir/$$\", $entry->{'name'}, $entry->{'md5'});\n  }\n  my $srcmd5 = addmeta($projid, $packid, $files);\n  if ($dir->{'serviceinfo'}) {\n    $dir->{'srcmd5'} = $rev->{'srcmd5'} = $srcmd5;\n  }\n  my @linked;\n  if ($dir->{'linkinfo'}) {\n    $dir->{'srcmd5'} = $rev->{'srcmd5'} = $srcmd5;\n    $rev->{'rev'} = $rev->{'srcmd5'} unless $dir->{'rev'};\n    if ($linked) {\n      # add linked info for getprojpack\n      my $li = $dir->{'linkinfo'};\n      if ($li->{'linked'}) {\n\tfor my $l (@{$li->{'linked'}}) {\n\t  $l->{'project'} = maptoremote($proj, $l->{'project'});\n\t  push @linked, $l if defined($l->{'project'}) && $l->{'project'} ne '_unavailable';\n\t}\n\tundef $li;\n      }\n      while ($li) {\n        my $lprojid = $li->{'project'};\n        my $lpackid = $li->{'package'};\n        last unless defined($lprojid) && defined($lpackid);\n        my $mlprojid = maptoremote($proj, $lprojid);\n        last unless defined($mlprojid) && $mlprojid ne '_unavailable';\n        push @linked, {'project' => $mlprojid, 'package' => $lpackid};\n\tlast unless $li->{'srcmd5'} && !$li->{'error'};\n\tmy $ldir;\n\teval {\n\t  $ldir = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$lprojid/$lpackid\", 'proxy' => $proxy}, $BSXML::dir, \"rev=$li->{'srcmd5'}\");\n\t};\n\tlast if $@ || !$ldir;\n\t$li = $ldir->{'linkinfo'};\n      }\n      push @$linked, @linked;\n    }\n  }\n  die(\"srcmd5 mismatch\\n\") if $dir->{'srcmd5'} ne $srcmd5;\n  if (!$dir->{'linkinfo'} || $linked) {\n    my %revcopy = %$rev;\n    $revcopy{'linked'} = [ map { { %$_ } } @linked ] if $dir->{'linkinfo'};\n    $remote_getrev_cache{\"$projid/$packid/$cacherev\"} = \\%revcopy;\n  }\n  $rev->{'project'} = $projid;\n  $rev->{'package'} = $packid;\n  return $rev;\n}\n\nsub expandsearchpath {\n  my ($projid, $repoid, $remotemap, $base) = @_;\n  my %done;\n  my @ret;\n  my @path = {project => $projid, repository => $repoid};\n  while (@path) {\n    my $t = shift @path;\n    my $prp = \"$t->{'project'}/$t->{'repository'}\";\n    push @ret, $prp unless $done{$prp};\n    $done{$prp} = 1;\n    if (!@path) {\n      ($base->{'project'}, $base->{'repository'}) = ($t->{'project'}, $t->{'repository'}) if $base;\n      last if $done{\"/$prp\"};\n      my ($pid, $tid) = ($t->{'project'}, $t->{'repository'});\n      my $proj = readproj($pid, 1);\n      if (!$proj || $proj->{'remoteurl'}) {\n\tundef $proj;\n\t$proj = $remotemap->{$pid} if $remotemap && $remotemap->{$pid};\n\tif (!$proj || $proj->{'proto'}) {\n          $proj = remoteprojid($pid);\n          $proj = fetchremoteproj($proj, $pid, $remotemap);\n          die(\"404 project '$pid' does not exist\\n\") unless $proj;\n        }\n      }\n      checkpartition($remotemap, $pid, $proj) if $remotemap && $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$pid};\n      $done{\"/$prp\"} = 1;       # mark expanded\n      my @repo = grep {$_->{'name'} eq $tid} @{$proj->{'repository'} || []};\n      push @path, @{$repo[0]->{'path'}} if @repo && $repo[0]->{'path'};\n    } elsif ($remotemap) {\n      my $pid = $t->{'project'};\n      my $proj = readproj($pid, 1);\n      if ((!$proj || $proj->{'remoteurl'}) && !$remotemap->{$pid}) {\n        my $r = remoteprojid($pid);\n        $remotemap->{$pid} = {%$r, 'proto' => 1} if $r;\n      }\n      checkpartition($remotemap, $pid, $proj) if $remotemap && $remotemap->{':partitions'} && !$remotemap->{':partitions'}->{$pid};\n    }\n  }\n  return @ret;\n}\n\nsub concatconfigs {\n  my ($projid, $repoid, $remotemap, @path) = @_;\n\n  my $config = \"%define _project $projid\\n\";\n  my $macros = '';\n\n  #$macros .= \"%vendor Open Build Service\\n\";\n\n  # find the sign project, this is what we use as vendor\n  my $vprojid = $projid;\n  while ($vprojid ne '') {\n    last if -s \"$projectsdir/$vprojid.pkg/_signkey\";\n    $vprojid =~ s/[^:]*$//;\n    $vprojid =~ s/:$//;\n  }\n  $vprojid = $projid if $vprojid eq '';\n  my $obsname = $BSConfig::obsname || 'build.opensuse.org';\n  $macros .= \"%vendor obs://$obsname/$vprojid\\n\";\n\n  $macros .= \"%_project $projid\\n\";\n  my $lastr = '';\n\n  my $distinfo = \"$projid / $repoid\";\n  if ($repoid eq 'standard') {\n    $distinfo = $projid;\n  } \n\n  for my $prp (reverse @path) {\n    if ($prp eq \"$projid/$repoid\") {\n      $macros .= \"\\n%distribution $distinfo\\n\";\n      $macros .= \"%_project $projid\\n\";\n    }\n    my ($p, $r) = split('/', $prp, 2);\n    my $c;\n    if (-s \"$projectsdir/$p.conf\") {\n      $c = readstr(\"$projectsdir/$p.conf\");\n    } elsif (!-e \"$projectsdir/$p.xml\") {\n      my $proj = remoteprojid($p);\n      $c = fetchremoteconfig($proj, $p, $remotemap);\n    }\n    if ($remotemap && $remotemap->{':partitions'}) {\n      checkpartition($remotemap, $p) if !$remotemap->{':partitions'}->{$p};\n      $remotemap->{$p}->{'config'} = defined($c) ? $c : '' if ($remotemap->{$p} || {})->{'partition'};\n    }\n    next unless defined $c;\n    $config .= \"\\n### from $p\\n\";\n    $config .= \"%define _repository $r\\n\";\n\n    if ($c =~ /^\\s*:macros\\s*$/im) {\n      # probably some multiple macro sections with %if statements\n      # flush out macros\n      $macros .= \"\\n### from $p\\n\";\n      $macros .= \"\\n%_repository $r\\n\";\n      $config .= \"\\nMacros:\\n$macros:Macros\\n\\n\";\n      $macros = '';\n      $lastr = $r;\n      my $s1 = '\\A(.*^\\s*:macros\\s*$)(.*?)\\Z';\t# should always match\n      if ($c =~ /$s1/msi) {\n        $config .= $1;\n\t$c = $2;\n      } else {\n        $config .= $c;\n\t$c = '';\n      }\n    }\n    if ($c =~ /^(.*\\n)?\\s*macros:[^\\n]*\\n(.*)/si) {\n      # has single macro section at end. cumulate\n      $c = defined($1) ? $1 : '';\n      $macros .= \"\\n### from $p\\n\";\n      $macros .= \"%_repository $r\\n\";\n      $macros .= $2;\n      $lastr = $r;\n    }\n    $config .= $c;\n  }\n  if ($lastr ne $repoid) {\n    $macros .= \"\\n### from $projid\\n\";\n    $macros .= \"%_repository $repoid\\n\";\n  }\n  if (!@path || $path[0] ne \"$projid/$repoid\") {\n    $macros .= \"\\n%distribution $distinfo\\n\";\n    $macros .= \"%_project $projid\\n\";\n  }\n  if ($BSConfig::extramacros) {\n    for (sort keys %{$BSConfig::extramacros}) {\n      $macros .= $BSConfig::extramacros->{$_} if $projid =~ /$_/;\n    }\n  }\n  if ($BSConfig::extraconfig) {\n    my $extraconfig = '';\n    for (sort keys %{$BSConfig::extraconfig}) {\n      $extraconfig .= $BSConfig::extraconfig->{$_} if $projid =~ /$_/;\n    }\n    $config .= \"\\n$extraconfig\" if $extraconfig;\n  }\n  $config .= \"\\nMacros:\\n$macros\" if $macros ne '';\n  return $config;\n}\n\nsub getbuildconfig {\n  my ($cgi, $projid, $repoid) = @_;\n  my @path;\n  if ($cgi->{'path'}) {\n    @path = @{$cgi->{'path'}};\n  } else {\n    @path = expandsearchpath($projid, $repoid);\n  }\n  my $config = concatconfigs($projid, $repoid, undef, @path);\n  return ($config, 'Content-Type: text/plain');\n}\n\nsub getprojectconfig {\n  my ($cgi, $projid) = @_;\n  my $proj = checkprojrepoarch($projid, undef, undef, 1);\n  if ($proj->{'remoteurl'}) {\n    my $config = BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/source/$proj->{'remoteproject'}/_config\", 'proxy' => $proxy}, undef);\n    return ($config, 'Content-Type: text/plain');\n  }\n  my $config;\n  if ($cgi->{'rev'}) {\n    my $rev = getrev($projid, '_project', $cgi->{'rev'});\n    my $files = $rev ? lsrev($rev) : {};\n    $config = repreadstr($rev, '_config', $files->{'_config'}, 1) if $files->{'_config'};\n  } else {\n    $config = readstr(\"$projectsdir/$projid.conf\", 1);\n  }\n  $config = '' unless defined $config;\n  return ($config, 'Content-Type: text/plain');\n}\n\nsub putprojectconfig {\n  my ($cgi, $projid) = @_;\n  my $proj = readproj($projid);\n  mkdir_p($uploaddir);\n  my $uploadfile = \"$uploaddir/$$\";\n  die(\"upload failed\\n\") unless BSServer::read_file($uploadfile);\n  if (! -s $uploadfile) {\n    unlink($uploadfile);\n    $uploadfile = undef;\n  }\n  addrev_meta($cgi, $projid, undef, $uploadfile, \"$projectsdir/$projid.conf\", '_config', 'rev');\n  notify_repservers('project', $projid);\n  notify(\"SRCSRV_UPDATE_PROJECT_CONFIG\", { \"project\" => $projid, \"sender\" => ($cgi->{'user'} || \"unknown\") });\n  return $BSStdServer::return_ok;\n}\n\nsub delprojectconfig {\n  my ($cgi, $projid) = @_;\n  addrev_meta($cgi, $projid, undef, undef, \"$projectsdir/$projid.conf\", '_config', 'rev');\n  notify_repservers('project', $projid);\n  notify(\"SRCSRV_UPDATE_PROJECT_CONFIG\", { \"project\" => $projid, \"sender\" => ($cgi->{'user'} || \"unknown\") });\n  return $BSStdServer::return_ok;\n}\n\n##########################################################################\n\nsub getsources {\n  my ($cgi, $projid, $packid, $srcmd5) = @_;\n  my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $srcmd5};\n  my $files = lsrev($rev);\n  my @send = map {{'name' => $_, 'filename' => \"$srcrep/$packid/$files->{$_}-$_\"}} keys %$files;\n  BSServer::reply_cpio(\\@send);\n  return undef;\n}\n\nsub detach {\n  my $jev = $BSServerEvents::gev;\n  return unless exists $jev->{'fd'};\n  my $ev = BSEvents::new('never');\n  for (keys %$jev) {\n    $ev->{$_} = $jev->{$_} unless $_ eq 'id' || $_ eq 'handler' || $_ eq 'fd';\n  }\n  $jev->{'conf'}->{'stdreply'}->(@_) if $jev->{'conf'}->{'stdreply'};\n  $BSServerEvents::gev = $ev;\n  return $ev;\n}\n\nmy %getfilelist_ajax_inprogress;\n\nsub getfilelist_ajax {\n  my ($cgi, $projid, $packid) = @_;\n\n  if ($cgi->{'view'} eq 'cpio') {\n    my $rev = {'project' => $projid, 'package' => $packid, 'srcmd5' => $cgi->{'rev'}};\n    my $files = lsrev($rev);\n    my @send = map {{'name' => $_, 'filename' => \"$srcrep/$packid/$files->{$_}-$_\"}} keys %$files;\n    BSWatcher::reply_cpio(\\@send);\n    return undef;\n  }\n  die(\"unknown view '$cgi->{'view'}'\\n\") unless $cgi->{'view'} eq 'notify';\n  my $jev = $BSServerEvents::gev;\n  if (!$jev->{'remoteurl'}) {\n    die unless $cgi->{'rev'};\n    my $proj = remoteprojid($projid);\n    die(\"missing project/package\\n\") unless $proj;\n    $jev->{'remoteurl'} = $proj->{'remoteurl'};\n    $jev->{'remoteproject'} = $proj->{'remoteproject'};\n  }\n  if (!$jev->{'filelist'}) {\n    my $rev = $cgi->{'rev'};\n    return $BSStdServer::return_ok if $getfilelist_ajax_inprogress{\"$projid/$packid/$rev\"};\n    my $param = {\n      'uri' => \"$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid\",\n      'proxy' => $proxy,\n    };\n    eval {\n      $jev->{'filelist'} = BSWatcher::rpc($param, $BSXML::dir, \"rev=$rev\");\n    };\n    if ($@) {\n      my $err = $@;\n      notify_all_repservers('package', $projid, $packid);\n      die($err);\n    }\n    return undef unless $jev->{'filelist'};\n    $jev = detach($BSStdServer::return_ok);\n    $jev->{'idstring'} = \"$projid/$packid/$rev\";\n    $getfilelist_ajax_inprogress{\"$projid/$packid/$rev\"} = $jev;\n    $jev->{'handler'} = sub {delete $getfilelist_ajax_inprogress{\"$projid/$packid/$rev\"}};\n  }\n  my $havesize = 0;\n  my $needsize = 0;\n  my @need;\n  for my $entry (@{$jev->{'filelist'}->{'entry'} || []}) {\n    if (-e \"$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}\") {\n      $havesize += $entry->{'size'};\n    } else {\n      push @need, $entry;\n      $needsize += $entry->{'size'};\n    }\n  }\n  my $serial;\n  if (@need) {\n    $serial = BSWatcher::serialize(\"$jev->{'remoteurl'}/source\");\n    return undef unless $serial;\n    mkdir_p($uploaddir);\n  }\n  if (@need > 1 && $havesize < 8192) {\n    # download full cpio source\n    my %need = map {$_->{'name'} => $_} @need;\n    my $tmpcpiofile = \"$$-$jev->{'id'}-tmpcpio\";\n    my $param = {\n      'uri' => \"$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid\",\n      'directory' => $uploaddir,\n      'tmpcpiofile' => \"$uploaddir/$tmpcpiofile\",\n      'withmd5' => 1,\n      'receiver' => \\&BSHTTP::cpio_receiver,\n      'proxy' => $proxy,\n      'map' => sub { $need{$_[1]} ? \"$tmpcpiofile.$_[1]\" : undef },\n      'cpiopostfile' => sub {\n\tmy $name = substr($_[1]->{'name'}, length(\"$tmpcpiofile.\"));\n\tdie(\"file download confused\\n\") unless $need{$name} && $_[1]->{'md5'} eq $need{$name}->{'md5'};\n        addfile($projid, $packid, \"$uploaddir/$_[1]->{'name'}\", $name, $_[1]->{'md5'});\n       },\n    };\n    my $res;\n    eval {\n      $res = BSWatcher::rpc($param, undef, \"rev=$cgi->{'rev'}\", 'view=cpio');\n    };\n    if ($@) {\n      # notify scheduler that the download failed\n      my $err = $@;\n      BSWatcher::serialize_end($serial) if $serial;\n      notify_all_repservers('package', $projid, $packid);\n      die($err);\n    }\n    return undef unless $res;\n  }\n  for my $entry (@need) {\n    next if -e \"$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}\";\n    my $param = {\n      'uri' => \"$jev->{'remoteurl'}/source/$jev->{'remoteproject'}/$packid/$entry->{'name'}\",\n      'filename' => \"$uploaddir/$$-$jev->{'id'}\",\n      'withmd5' => 1,\n      'receiver' => \\&BSHTTP::file_receiver,\n      'proxy' => $proxy,\n    };\n    my $res;\n    eval {\n      $res = BSWatcher::rpc($param, undef, \"rev=$cgi->{'rev'}\");\n    };\n    if ($@) {\n      # notify scheduler that the download failed\n      my $err = $@;\n      BSWatcher::serialize_end($serial) if $serial;\n      notify_all_repservers('package', $projid, $packid);\n      die($err);\n    }\n    return undef unless $res;\n    die(\"file download failed\\n\") unless $res && $res->{'md5'} eq $entry->{'md5'};\n    die unless -e \"$uploaddir/$$-$jev->{'id'}\";\n    addfile($projid, $packid, \"$uploaddir/$$-$jev->{'id'}\", $entry->{'name'}, $entry->{'md5'});\n  }\n  BSWatcher::serialize_end($serial) if $serial;\n  delete $getfilelist_ajax_inprogress{\"$projid/$packid/$cgi->{'rev'}\"};\n  notify_all_repservers('package', $projid, $packid);\n  return '';\n}\n\nsub getproductrepositories {\n  my ($xml) = @_;\n\n  my @res;\n  for my $product (@{$xml->{'products'}->{'product'}}) {\n    my @pr;\n    for my $repo (@{$product->{'register'}->{'updates'}->{'repository'}}) {\n      my @p = published_path(undef, $repo->{'project'}, $repo->{'name'});\n      my $path = { 'path' => $p[0]{'path'}, 'update' => undef };\n      $path->{'arch'} = $repo->{'arch'} if $repo->{'arch'};\n      $path->{'zypp'} = $repo->{'zypp'} if $repo->{'zypp'};\n      $path->{'debug'} = undef if $repo->{'name'} =~ m/_debug$/;\n      push @pr, $path;\n    }\n    for my $repo (@{$product->{'register'}->{'pool'}->{'repository'}}) {\n      die(\"getproductrepositories: path AND url is set!\\n\") if defined ($repo->{'project'}) && defined($repo->{'url'});\n      my $path;\n      if (defined($repo->{'url'})) {\n        $path = { 'url' => $repo->{'url'} };\n      } else {\n        my @p = published_path({\"medium\" => $repo->{'medium'}}, $repo->{'project'}, $repo->{'name'});\n        $path = { 'path' => $p[0]{'path'} };\n      }\n      $path->{'arch'} = $repo->{'arch'} if $repo->{'arch'};\n      $path->{'zypp'} = $repo->{'zypp'} if $repo->{'zypp'};\n      $path->{'debug'} = undef if $repo->{'medium'} =~ m/_debug$/;\n      push @pr, $path;\n    }\n    my $prod = { 'name' => $product->{'name'}, 'repository' => \\@pr };\n    $prod->{'distrotarget'} = $product->{'register'}->{'updates'}->{'distrotarget'} if $product->{'register'}->{'updates'}->{'distrotarget'};\n    push @res, $prod;\n  }\n  return @res;\n}\n\nsub getfilelist {\n  my ($cgi, $projid, $packid) = @_;\n\n  my $view = $cgi->{'view'};\n  my $rev;\n  if ($cgi->{'meta'}) {\n    $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});\n  } elsif ($cgi->{'deleted'}) {\n    $rev = getrev_deleted($projid, $packid, $cgi->{'rev'});\n  } else {\n    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  }\n  my $li = {};\n  my $files = lsrev($rev, $li);\n\n  # show state of current source service run, if defined\n  my $serviceinfo;\n  if ($li->{'xservicemd5'} || $li->{'lservicemd5'}) {\n    # new style\n    $serviceinfo = {};\n    $serviceinfo->{'lsrcmd5'} = $li->{'lservicemd5'} if $li->{'lservicemd5'};\n    if ($li->{'xservicemd5'}) {\n      if ($cgi->{'expand'}) {\n\t$serviceinfo->{'lsrcmd5'} = $rev->{'srcmd5'};\n\t$files = handleservice($rev, $files, $li->{'xservicemd5'});\n\t$serviceinfo->{'code'} = 'succeeded';\t# otherwise it already died...\n      } else {\n        eval { handleservice({ %$rev }, $files, $li->{'xservicemd5'}) };\n\tmy $error = $@;\n\tchomp $error if $error;\n\tif (!$error) {\n\t  $serviceinfo->{'code'} = 'succeeded';\n\t  $serviceinfo->{'xsrcmd5'} = $li->{'xservicemd5'};\n\t} elsif ($error eq 'service in progress') {\n\t  $serviceinfo->{'code'} = 'running';\n\t} else {\n\t  $serviceinfo->{'code'} = 'failed';\n\t  $serviceinfo->{'xsrcmd5'} = $li->{'xservicemd5'};\n\t  $serviceinfo->{'error'} = $error;\n\t}\n      }\n    }\n    delete $li->{'xservicemd5'};\n    delete $li->{'lservicemd5'};\n  } elsif ($files->{'_service'} && $packid ne '_project' && !$cgi->{'meta'} && !defined($cgi->{'rev'})) {\n    # check error/in progress\n    $serviceinfo = {};\n    my $lockfile = \"$eventdir/service/${projid}::$packid\";\n    if (-e $lockfile) {\n      $serviceinfo->{'code'} = 'running';\n    } elsif ($files->{'_service_error'}) {\n      $serviceinfo->{'code'} = 'failed';\n      $serviceinfo->{'error'} = repreadstr($rev, '_service_error', $files->{'_service_error'});\n    } else {\n      $serviceinfo->{'code'} = 'succeeded';\n    }\n  } elsif ($files->{'_service_error'}) {\n    $serviceinfo = {'code' => 'failed'};\n    $serviceinfo->{'error'} = repreadstr($rev, '_service_error', $files->{'_service_error'});\n  }\n\n  if ($files->{'_link'}) {\n    if ($cgi->{'emptylink'}) {\n      my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);\n      delete $l->{'patches'};\n      mkdir_p($uploaddir);\n      writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n      $files = {};\n      $files->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link');\n      $rev = addrev({}, $projid, $packid, $files, '');\n    }\n    my %lrev = %$rev;\n    $lrev{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n    $li->{'linked'} = [] if $cgi->{'withlinked'};\n    my $lfiles = handlelinks(\\%lrev, $files, $li);\n    if ($cgi->{'expand'}) {\n      if (!ref($lfiles)) {\n\tif ($cgi->{'withlinked'} && !$view) {\n\t  my $ret = {};\n\t  $ret->{'name'} = $packid;\n\t  $ret->{'error'} = $lfiles || 'internal error';\n\t  $ret->{'linkinfo'} = $li;\n\t  return ($ret, $BSXML::dir);\n\t}\n\tdie(\"$lfiles\\n\");\n      }\n      $files = $lfiles;\n      %$rev = %lrev;\n      $rev->{'rev'} = $rev->{'srcmd5'};\n    } else {\n      if (ref $lfiles) {\n        $li->{'xsrcmd5'} = $lrev{'srcmd5'};\n      } else {\n\t# link is broken\n\t$li->{'error'} = $lfiles;\n\t# set xsrcmd5 if we have a link error file\n\t$li->{'xsrcmd5'} = $lrev{'srcmd5'} if $lrev{'srcmd5'} && -e \"$srcrep/$packid/$lrev{'srcmd5'}-_linkerror\";\n\tif ($cgi->{'lastworking'}) {\n\t  my $lastworking = findlastworkinglink($rev);\n\t  $li->{'lastworking'} = $lastworking if $lastworking;\n\t}\n      }\n    }\n  }\n\n  if ($cgi->{'extension'}) {\n    for (keys %$files) {\n      delete $files->{$_} unless /\\.\\Q$cgi->{'extension'}\\E$/;\n    }\n  }\n\n  if ($view && $view eq 'cpio') {\n    if (!$cgi->{'extension'} && $rev->{'srcmd5'} && $rev->{'srcmd5'} ne 'upload' && $rev->{'srcmd5'} ne 'pattern' && $rev->{'srcmd5'} ne 'empty' && $rev->{'srcmd5'} ne $emptysrcmd5) {\n      # hack: we identify remote source downloads by looking at the user agent\n      my $useragent = $BSServer::request->{'headers'}->{'user-agent'} || '';\n      if ($useragent =~ /BSRPC/) {\n\tBSHandoff::handoff($ajaxsocket, \"/source/$projid/$packid\", undef, \"rev=$rev->{'srcmd5'}\", 'view=cpio');\n\texit(0);\n      }\n    }\n    my @files = map {{'name' => $_, 'filename' => \"$srcrep/$packid/$files->{$_}-$_\"}} sort keys %$files;\n    # sigh\n    $files->[0]->{'filename'} = repfilename($rev, '_serviceerror', $files->{'_serviceerror'}) if @files == 1 && $files->{'_serviceerror'};\n    BSServer::reply_cpio(\\@files);\n    return undef;\n  }\n\n  if ($view && ($view eq 'products' || $view eq 'productrepositories') ) {\n    my @res;\n    for my $filename (sort keys %$files) {\n      next unless $filename =~ /\\.product$/;\n      next if $cgi->{'product'} && $filename ne \"$cgi->{'product'}.product\";\n      my $xml = BSProductXML::readproductxml(\"$srcrep/$rev->{'package'}/$files->{$filename}-$filename\", 0, undef, $files);\n      die(\"400 Unable to parse $filename\\n\") unless $xml;\n      if ($view eq 'productrepositories') {\n        push @res, getproductrepositories($xml);\n      } else {\n        push @res, $xml;\n      }\n    }\n    if ($view eq 'productrepositories') {\n      return ({\"product\" => \\@res}, $BSProductXML::productlistrepositories);\n    }\n    my $ret = {};\n    $ret->{'productdefinition'} = \\@res;\n    return ($ret, $BSProductXML::products);\n  }\n\n  my $ret = {};\n  $ret->{'name'} = $packid;\n  $ret->{'srcmd5'} = $rev->{'srcmd5'} if $rev->{'srcmd5'} ne 'empty';\n  $ret->{'rev'} = $rev->{'rev'} if exists $rev->{'rev'};\n  $ret->{'vrev'} = $rev->{'vrev'} if exists $rev->{'vrev'};\n  $ret->{'serviceinfo'} = $serviceinfo if $serviceinfo;\n  my @res;\n  for my $filename (sort keys %$files) {\n    my @s = repstat($rev, $filename, $files->{$filename});\n    if (@s) {\n      push @res, {'name' => $filename, 'md5' => $files->{$filename}, 'size' => $s[7], 'mtime' => $s[9]};\n    } else {\n      push @res, {'name' => $filename, 'md5' => $files->{$filename}, 'error' => \"$!\"};\n    }\n  }\n  if (%$li) {\n    linkinfo_addtarget($rev, $li);\n    $ret->{'linkinfo'} = $li;\n  }\n  $ret->{'entry'} = \\@res;\n  return ($ret, $BSXML::dir);\n}\n\nsub getfile {\n  my ($cgi, $projid, $packid, $filename) = @_;\n  die(\"no filename\\n\") unless defined($filename) && $filename ne '';\n  die(\"bad filename\\n\") if $filename =~ /\\// || $filename =~ /^\\./;\n  my $rev;\n  if ($cgi->{'meta'}) {\n    $rev = getrev_meta($projid, $packid, $cgi->{'rev'}, $cgi->{'deleted'});\n  } elsif ($cgi->{'deleted'}) {\n    $rev = getrev_deleted($projid, $packid, $cgi->{'rev'});\n  } else {\n    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  }\n  my $files;\n  if ($cgi->{'expand'}) {\n    $files = lsrev_expanded($rev);\n  } else {\n    $files = lsrev($rev);\n  }\n  die(\"404 $filename: no such file\\n\") unless $files->{$filename};\n  my @s = repstat($rev, $filename, $files->{$filename});\n  die(\"$projid/$packid/$files->{$filename}-$filename: $!\\n\") unless @s;\n  if (!$BSStdServer::isajax && $rev->{'srcmd5'} && $rev->{'srcmd5'} ne 'upload' && $rev->{'srcmd5'} ne 'pattern' && $rev->{'srcmd5'} ne 'empty' && $rev->{'srcmd5'} ne $emptysrcmd5) {\n    # hack: we identify remote source downloads by looking at the user agent\n    my $useragent = $BSServer::request->{'headers'}->{'user-agent'} || '';\n    if ($useragent =~ /BSRPC/) {\n      BSHandoff::handoff($ajaxsocket, \"/source/$projid/$packid/$filename\", undef, \"rev=$rev->{'srcmd5'}\");\n      exit(0);\n    }\n  }\n  my $fd = gensym;\n  repopen($rev, $filename, $files->{$filename}, $fd) || die(\"$projid/$packid/$files->{$filename}-$filename: $!\\n\");\n  BSWatcher::reply_file($fd);\n  return undef;\n}\n\nsub putfile {\n  my ($cgi, $projid, $packid, $filename) = @_;\n  die(\"no filename\\n\") unless defined($filename) && $filename ne '';\n  die(\"bad filename\\n\") if $filename =~ /\\// || $filename =~ /^\\./;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\", 'withmd5' => 1);\n  die(\"upload failed\\n\") unless $uploaded;\n\n  if ($cgi->{'meta'}) {\n    if ($filename eq '_attribute') {\n      my $attribs = readxml(\"$uploaddir/$$\", $BSXML::attributes);\n      BSVerify::verify_attributes($attribs);\n      writexml(\"$uploaddir/$$\", undef, $attribs, $BSXML::attributes);\n    } elsif ($filename eq '_frozenlinks') {\n      my $frozenx = readxml(\"$uploaddir/$$\", $BSXML::frozenlinks);\n      BSVerify::verify_frozenlinks($frozenx);\n      writexml(\"$uploaddir/$$\", undef, $frozenx, $BSXML::frozenlinks);\n    } else {\n      die(\"unsupported meta operation\\n\");\n    }\n    my $rev = addrev_meta($cgi, $projid, $packid, \"$uploaddir/$$\", undef, $filename);\n    notify_repservers('package', $projid) if $cgi->{'meta'} && $filename eq '_frozenlinks';\n    delete $rev->{'project'};\n    delete $rev->{'package'};\n    return ($rev, $BSXML::revision);\n  }\n\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  die(\"file '$filename' is read-only\\n\") if ($filename =~ /^_service:/) && !$cgi->{'force'};\n  addfile($projid, $packid, \"$uploaddir/$$\", $filename, $uploaded->{'md5'});\n  # create new meta file\n  my $files;\n  if ($cgi->{'keeplink'}) {\n    $files = lsrev_expanded($rev);\n  } else {\n    $files = lsrev($rev);\n  }\n  $files->{$filename} = $uploaded->{'md5'};\n  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};\n  $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});\n  runservice($cgi, $rev, $files);\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub getsourcediffcache {\n  my ($cgi, $cacheid) = @_;\n\n  my $view = $cgi->{'view'} || '';\n  my $cn = \"$diffcache/\".substr($cacheid, 0, 2).\"/$cacheid\";\n  BSWatcher::addfilewatcher($cn) if $BSStdServer::isajax;\n  my $lockc = BSUtil::lockcheck('>>', \"$cn.run\");\n  my $fd = gensym;\n  if (open($fd, '<', $cn)) {\n    unlink(\"$cn.run\");\n    utime(time, time, $cn);\n    BSWatcher::reply_file($fd, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');\n    return undef;\n  }\n  return undef if $BSStdServer::isajax && !$lockc;\n  die(\"cache entry '$cacheid' does not exist\\n\");\n}\n\nsub sourcediff {\n  my ($cgi, $projid, $packid) = @_;\n\n  BSVerify::verify_linkrev($cgi->{'olinkrev'}) if defined($cgi->{'olinkrev'}) && $cgi->{'olinkrev'} ne 'linkrev';\n  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;\n  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;\n\n  my $fmax = 200;\n  my $tmax = 16000;\n  $fmax = $cgi->{'filelimit'} if defined $cgi->{'filelimit'};\n  $tmax = $cgi->{'tarlimit'} if defined $cgi->{'tarlimit'};\n  undef $fmax unless $fmax;\n  undef $tmax unless $tmax;\n\n  my $have0rev = (defined($cgi->{'rev'}) && $cgi->{'rev'} eq '0') || (defined($cgi->{'orev'}) && $cgi->{'orev'} eq '0');\n  my $rev;\n  if ($cgi->{'meta'}) {\n    $rev = getrev_meta($projid, $packid, $cgi->{'rev'});\n  } else {\n    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload', undef, $cgi->{'missingok'});\n  }\n  my $linkinfo = {};\n  my $files = lsrev($rev, $linkinfo);\n  $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'}) if $cgi->{'expand'} && $linkinfo->{'xservicemd5'};\n  my $orev = $cgi->{'orev'};\n  if (!defined($cgi->{'oproject'}) && !defined($cgi->{'opackage'}) && !defined($cgi->{'orev'}) && $rev->{'rev'}) {\n    die(\"revision is not a simple commit\\n\") unless $rev->{'rev'} =~ /^\\d+$/s;\n    $orev = $rev->{'rev'} - 1;\n    $have0rev = 1 if $orev == 0;\n    $cgi->{'olinkrev'} = 'linkrev' if !defined($cgi->{'olinkrev'});\n  }\n  if ($cgi->{'meta'}) {\n    $orev = getrev_meta($oprojid, $opackid, $orev);\n  } else {\n    $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest', undef, $cgi->{'missingok'});\n  }\n  my $olinkinfo = {};\n  my $ofiles = lsrev($orev, $olinkinfo);\n  $ofiles = handleservice($orev, $ofiles, $olinkinfo->{'xservicemd5'}) if $cgi->{'expand'} && $olinkinfo->{'xservicemd5'};\n  if ($cgi->{'expand'} || (!$have0rev && $files->{'_link'} && !$ofiles->{'_link'}) || (!$have0rev && $ofiles->{'_link'} && !$files->{'_link'})) {\n    # expand links\n    if ($files->{'_link'}) {\n      $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n      my %li;\n      my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link, 1);\n      if ($l) {\n        $l->{'project'} = $rev->{'project'} unless defined $l->{'project'};\n        $l->{'package'} = $rev->{'package'} unless defined $l->{'package'};\n      }\n      $files = handlelinks($rev, $files, \\%li);\n      die(\"bad link: $files\\n\") unless ref $files;\n\n      # some nasty magic to improve diff usability\n      if ($l && $cgi->{'linkrev'} && $l->{'project'} eq $oprojid && $l->{'package'} eq $opackid && !$l->{'rev'} && !$cgi->{'orev'}) {\n        # we're diffing against the link target. As the user specified a baserev, we should use it\n        # instead of the latest source\n        $orev = getrev($oprojid, $opackid, $li{'srcmd5'});\n        $ofiles = lsrev($orev);\n      }\n      # olinkrev=linkrev: reuse same linkrev if the link target matches\n      if ($cgi->{'olinkrev'} && $cgi->{'olinkrev'} eq 'linkrev' && $ofiles->{'_link'}) {\n\tmy $ol = repreadxml($orev, '_link', $ofiles->{'_link'}, $BSXML::link, 1);\n\tif ($ol) {\n\t  $ol->{'project'} = $orev->{'project'} unless defined $ol->{'project'};\n\t  $ol->{'package'} = $orev->{'package'} unless defined $ol->{'package'};\n\t}\n\t$cgi->{'olinkrev'} = $li{'srcmd5'} if $l && $ol && $l->{'project'} eq $ol->{'project'} && $l->{'package'} eq $ol->{'package'};\n      }\n    }\n    if ($ofiles->{'_link'}) {\n      $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'} && $cgi->{'olinkrev'} ne 'linkrev';\n      $ofiles = handlelinks($orev, $ofiles);\n      die(\"bad link: $ofiles\\n\") unless ref $ofiles;\n    }\n  }\n  my $view = $cgi->{'view'} || '';\n  $view = 'unified' if $cgi->{'unified'};\n  die(\"unsupported view '$view'\\n\") if $view && ($view ne 'xml' && $view ne 'unified');\n  my $cacheid = \"//cacheversion:2/\";\n  $cacheid .= \"$orev->{'srcmd5'}/$rev->{'srcmd5'}\";\n  $cacheid .= \"/unified:1\" if $view && $view eq 'unified';\n  $cacheid .= \"/view:$cgi->{'view'}\" if $view && $view ne 'unified';\n  $cacheid .= \"/fmax:$fmax\" if defined $fmax;\n  $cacheid .= \"/tmax:$tmax\" if defined $tmax;\n  $cgi->{'withissues'} = 1 if $cgi->{'onlyissues'};\n  if ($cgi->{'withissues'}) {\n    my @s = stat(\"$BSConfig::bsdir/issuetrackers.xml\");\n    $cacheid .= \"/withissues:$s[9]/$s[7]/$s[1]\" if @s;\n    $cacheid .= \"/onlyissues\" if $cgi->{'onlyissues'};\n  }\n  if ($cgi->{'file'}) {\n    my %file = map {$_ => 1} @{$cgi->{'file'}};\n    $cacheid .= \"/file:$_\" for sort keys %file;\n    for (keys %$ofiles) {\n      delete $ofiles->{$_} unless $file{$_};\n    }\n    for (keys %$files) {\n      delete $files->{$_} unless $file{$_};\n    }\n  }\n  $cacheid = Digest::MD5::md5_hex($cacheid);\n  my $xmlret;\n  if ($view eq 'xml') {\n    $xmlret = {};\n    $xmlret->{'key'} = $cacheid;\n    $rev->{'rev'} ||= 0;\n    $rev->{'srcmd5'} = $emptysrcmd5 if $rev->{'srcmd5'} eq 'empty';\n    $orev->{'rev'} ||= 0;\n    $orev->{'srcmd5'} = $emptysrcmd5 if $rev->{'srcmd5'} eq 'empty';\n    $xmlret->{'old'} = { 'project' => $orev->{'project'}, 'package' => $orev->{'package'}, 'rev' => $orev->{'rev'}, 'srcmd5' => $orev->{'srcmd5'} };\n    $xmlret->{'new'} = { 'project' => $rev->{'project'}, 'package' => $rev->{'package'}, 'rev' => $rev->{'rev'}, 'srcmd5' => $rev->{'srcmd5'} };\n    $xmlret->{'files'} = {};\n  }\n  if (!grep {($ofiles->{$_} || '') ne ($files->{$_} || '')} (keys %$ofiles, keys %$files)) {\n    # all files identical, don't bother\n    return ($xmlret, $BSXML::sourcediff) if $view eq 'xml';\n    return ('', 'Content-Type: text/plain');\n  }\n  local *F;\n  my $cn = \"$diffcache/\".substr($cacheid, 0, 2).\"/$cacheid\";\n  if (open(F, '<', $cn)) {\n    utime(time, time, $cn);\n    BSServer::reply_file(\\*F, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');\n    return undef;\n  }\n  local *LF;\n  mkdir_p(\"$diffcache/\".substr($cacheid, 0, 2));\n  if (!BSUtil::lockcheck('>>', \"$cn.run\")) {\n    my @args;\n    push @args, \"view=$view\" if $view;\n    BSHandoff::handoff($ajaxsocket, \"/sourcediffcache/$cacheid\", undef, @args);\n    exit(0);\n  }\n  BSUtil::lockopen(\\*LF, '>>', \"$cn.run\");\n  # retry open, maybe somebody else has created the diff meanwhile\n  if (open(F, '<', $cn)) {\n    unlink(\"$cn.run\");\n    close LF;\n    utime(time, time, $cn);\n    BSServer::reply_file(\\*F, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');\n    return undef;\n  }\n  my $tmpdir = \"$uploaddir/srcdiff$$\";\n  my $d;\n  if ($view eq 'xml') {\n    my %opts = ('edir' => $tmpdir, 'similar' => 1, 'doarchive' => 1, 'fmax' => $fmax, 'tmax' => $tmax);\n    if (!$cgi->{'onlyissues'}) {\n      $xmlret->{'files'} = { 'file' => BSSrcdiff::datadiff(\"$srcrep/$opackid\", $ofiles, $orev->{'rev'}, \"$srcrep/$packid\", $files, $rev->{'rev'}, %opts) };\n    }\n    if ($cgi->{'withissues'}) {\n      my $trackers = readxml(\"$BSConfig::bsdir/issuetrackers.xml\", $BSXML::issue_trackers, 1) || {};\n      $trackers = $trackers->{'issue-tracker'} || [];\n      $xmlret->{'issues'} = { 'issue' => BSSrcdiff::issuediff(\"$srcrep/$opackid\", $ofiles, $orev->{'rev'}, \"$srcrep/$packid\", $files, $rev->{'rev'}, $trackers, %opts) };\n    }\n    BSUtil::data2utf8xml($xmlret);\n    $d = XMLout($BSXML::sourcediff, $xmlret);\n  } else {\n    $d = BSSrcdiff::diff(\"$srcrep/$opackid\", $ofiles, $orev->{'rev'}, \"$srcrep/$packid\", $files, $rev->{'rev'}, $fmax, $tmax, $tmpdir, $view eq 'unified' ? 1 : 0);\n  }\n  mkdir_p(\"$diffcache/\".substr($cacheid, 0, 2));\n  writestr(\"$diffcache/.new$$\", $cn, $d);\n  unlink(\"$cn.run\");\n  close LF;\n  return ($d, $view eq 'xml' ? 'Content-Type: text/xml' : 'Content-Type: text/plain');\n}\n\nsub linkdiff {\n  my ($cgi, $projid, $packid) = @_;\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n  my $linkinfo = {};\n  my $files = lsrev_expanded($rev, $linkinfo);\n  die(\"not a link\\n\") unless $linkinfo->{'srcmd5'};\n  linkinfo_addtarget($rev, $linkinfo);\n  return sourcediff({\n    %$cgi, 'expand' => 0,\n    'oproject' => $linkinfo->{'project'},\n    'opackage' => $linkinfo->{'package'},\n    'orev' => $linkinfo->{'srcmd5'},\n    'missingok' => $linkinfo->{'missingok'},\n    'rev' => $rev->{'srcmd5'},\n  }, $projid, $packid);\n}\n\nsub servicediff {\n  my ($cgi, $projid, $packid) = @_;\n  die(\"servicediff only works for new style services\\n\") if $BSConfig::old_style_services;\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  my $linkinfo = {};\n  my $files = lsrev($rev, $linkinfo);\n  if ($linkinfo->{'xservicemd5'}) {\n    return sourcediff({%$cgi, 'expand' => 0, 'orev' => $rev->{'srcmd5'}, 'rev' => $linkinfo->{'xservicemd5'}}, $projid, $packid);\n  } elsif ($linkinfo->{'lservicemd5'}) {\n    return sourcediff({%$cgi, 'expand' => 0, 'orev' => $linkinfo->{'lservicemd5'}, 'rev' => $rev->{'srcmd5'}}, $projid, $packid);\n  } else {\n    die(\"no service was run for this revision\\n\");\n  }\n}\n\nsub isascii {\n  my ($file) = @_;\n  local *F;\n  open(F, '<', $file) || die(\"$file: $!\\n\");\n  my $buf = '';\n  sysread(F, $buf, 4096);\n  close F;\n  return 1 unless $buf =~ /[\\000-\\010\\016-\\037]/s;\n  return 0;\n}\n\nsub rundiff {\n  my ($file1, $file2, $label, $outfile) = @_;\n  my $pid;\n  if (!($pid = xfork())) {\n    if (!open(STDOUT, '>>', $outfile)) {\n      print STDERR \"$outfile: $!\\n\";\n      exit(2);\n    }\n    exec('diff', '-up', '--label', \"$label.orig\", '--label', $label, $file1, $file2);\n    exit(2);\n  }\n  waitpid($pid, 0) == $pid || die(\"waitpid $pid: $!\\n\");\n  my $status = $?;\n  return 1 if $status == 0 || $status == 0x100;\n  return undef;\n}\n\nsub findprojectpatchname {\n  my ($files) = @_;\n\n  my $i = \"\";\n  while ($files->{\"project$i.diff\"}) {\n    $i = '0' unless $i;\n    $i++;\n  }\n  return \"project$i.diff\";\n}\n\n#\n# we are going to commit files to projid/packid, all data is already present\n# in the src repository.\n# if it was a link before, try to keep this link\n# files: expanded file set\n#\nsub keeplink {\n  my ($cgi, $projid, $packid, $files, $orev) = @_;\n\n  my $repair = $cgi->{'repairlink'};\n  return $files if !defined($files) || !%$files;\n  return $files if $files->{'_link'};\n  $orev ||= getrev($projid, $packid, 'latest');\n  my $ofilesl = lsrev($orev);\n  return $files unless $ofilesl && $ofilesl->{'_link'};\n  my $l = repreadxml($orev, '_link', $ofilesl->{'_link'}, $BSXML::link);\n  my $changedlink = 0;\n  my %lignore;\n  my $isbranch;\n\n  if (@{$l->{'patches'}->{''} || []} == 1) {\n    my $type = (keys %{$l->{'patches'}->{''}->[0]})[0];\n    if ($type eq 'branch') {\n      $isbranch = 1;\n    }\n  }\n  undef $isbranch if $cgi->{'convertbranchtopatch'};\n\n  if (!$isbranch && $l->{'patches'}) {\n    if ($repair) {\n      for (@{$l->{'patches'}->{''} || []}) {\n        my $type = (keys %$_)[0];\n        if ($type eq 'apply' || $type eq 'delete' || $changedlink) {\n          $lignore{$_->{$type}->{'name'}} = 1 if $type ne 'topadd' && $type ne 'delete';\n\t  $_ = undef;\n\t  $changedlink = 1;\n\t}\n      }\n    } else {\n      for (reverse @{$l->{'patches'}->{''} || []}) {\n        my $type = (keys %$_)[0];\n        if ($type eq 'apply' || $type eq 'delete' || $type eq 'branch') {\n          $lignore{$_->{$type}->{'name'}} = 1 if $type eq 'apply';\n\t  $_ = undef;\n\t  $changedlink = 1;\n\t  next;\n\t}\n\tlast;\n      }\n    }\n    $l->{'patches'}->{''} = [ grep {defined($_)} @{$l->{'patches'}->{''}} ];\n  }\n\n  my $linkrev = $cgi->{'linkrev'};\n  $linkrev = $l->{'baserev'} if $linkrev && $linkrev eq 'base';\n\n  my $ltgtsrcmd5;\n  my $ofiles;\n  my $ofilesdir;\n  if (!$repair) {\n    # expand old link\n    my %olrev = %$orev;\n    my %li;\n    $olrev{'linkrev'} = $linkrev if $linkrev;\n    $ofiles = handlelinks(\\%olrev, $ofilesl, \\%li);\n    die(\"bad link: $ofiles\\n\") unless ref $ofiles;\n    $ltgtsrcmd5 = $li{'srcmd5'};\n    $ofilesdir = \"$srcrep/$packid\";\n  }\n\n  # get link target file list\n  my $ltgtprojid = defined($l->{'project'}) ? $l->{'project'} : $projid;\n  my $ltgtpackid = defined($l->{'package'}) ? $l->{'package'} : $packid;\n  my $ltgtfiles;\n  if ($ltgtsrcmd5) {\n    my $ltgtrev = {'project' => $ltgtprojid, 'package' => $ltgtpackid, 'srcmd5' => $ltgtsrcmd5};\n    $ltgtfiles = lsrev($ltgtrev);\n  } else {\n    my $ltgtrev = getrev($ltgtprojid, $ltgtpackid, $linkrev || $l->{'rev'});\n    $ltgtfiles = lsrev_expanded($ltgtrev);\n    $ltgtsrcmd5 = $ltgtrev->{'srcmd5'};\n  }\n\n  if ($l->{'missingok'} && $ltgtfiles->{'srcmd5'} ne $emptysrcmd5) {\n    # delete missingok flag as it's no longer needed\n    eval {\n      checksourceaccess($ltgtprojid, $ltgtpackid);\n      delete $l->{'missingok'};\n    };\n  }\n  # easy for branches: just copy file list and update baserev\n  if ($isbranch) {\n    my $nfiles = { %$files };\n    $nfiles->{'_link'} = $ofilesl->{'_link'};\n    my $lchanged;\n    my $baserev = $linkrev || $ltgtsrcmd5;\n    if (($l->{'baserev'} || '') ne $baserev) {\n      $l->{'baserev'} = $baserev;\n      $lchanged = 1;\n    }\n    $cgi->{'setrev'} = $baserev if $cgi->{'setrev'} && $cgi->{'setrev'} eq 'base';\n    if ($cgi->{'setrev'} && ($l->{'rev'} || '') ne $cgi->{'setrev'}) {\n      $l->{'rev'} = $cgi->{'setrev'};\n      $lchanged = 1;\n    }\n    if ($lchanged) {\n      $l->{'patches'}->{''} = [ { 'branch' => undef} ]; # work around xml problem\n      mkdir_p($uploaddir);\n      writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n      $nfiles->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link')\n    }\n    return $nfiles;\n  }\n\n  if ($cgi->{'convertbranchtopatch'}) {\n    $ofilesl = {};\n    $ofiles = $ltgtfiles;\n    $ofilesdir = \"$srcrep/$ltgtpackid\";\n  } elsif ($repair || $changedlink) {\n    # apply changed link\n    my $frominfo = {'project' => $ltgtprojid, 'package' => $ltgtpackid, 'srcmd5' => $ltgtsrcmd5};\n    my $linkinfo = {'project' => $projid, 'package' => $packid, 'srcmd5' => $orev->{'srcmd5'}, 'link' => $l};\n    $linkinfo->{'ignore'} = \\%lignore;\n    $ofiles = applylink(undef, $frominfo, $linkinfo);\n    die(\"bad link: $ofiles\\n\") unless ref $ofiles;\n    $ofilesdir = \"$uploaddir/applylink$$\";\n  }\n\n  #print \"-- ofilesl:\\n\";\n  #print \"  $ofilesl->{$_}  $_\\n\" for sort keys %$ofilesl;\n  #print \"-- ofiles:\\n\";\n  #print \"  $ofiles->{$_}  $_\\n\" for sort keys %$ofiles;\n  #print \"-- files:\\n\";\n  #print \"  $files->{$_}  $_\\n\" for sort keys %$files;\n\n  # now create diff between old $ofiles and $files\n  my $nfiles = { %$ofilesl };\n  delete $nfiles->{$_} for keys %lignore;\t# no longer used in link\n  mkdir_p($uploaddir);\n  unlink(\"$uploaddir/$$\");\n  my @dfiles;\n  for my $file (sort keys %{{%$files, %$ofiles}}) {\n    if ($ofiles->{$file}) {\n      if (!$files->{$file}) {\n\tif (!$ltgtfiles->{$file} && $ofilesl->{$file} && $ofilesl->{$file} eq ($ofiles->{$file} || '')) {\n\t  # local file no longer needed\n\t  delete $nfiles->{$file};\n\t}\n\tpush @dfiles, $file;\n\tdelete $nfiles->{$file};\n\tnext;\n      }\n      if ($ofiles->{$file} eq $files->{$file}) {\n\tnext;\n      }\n      if (!isascii(\"$srcrep/$packid/$files->{$file}-$file\") || !isascii(\"$ofilesdir/$ofiles->{$file}-$file\")) {\n\t$nfiles->{$file} = $files->{$file};\n\tnext;\n      }\n    } else {\n      if (!isascii(\"$srcrep/$packid/$files->{$file}-$file\")) {\n\t$nfiles->{$file} = $files->{$file};\n\tnext;\n      }\n    }\n    if (($ofilesl->{$file} || '') eq ($ofiles->{$file} || '')) {\n      # link did not change file, just record new content\n      if ($files->{$file} eq ($ltgtfiles->{$file} || '')) {\n\t# local overwrite already in link target\n\tdelete $nfiles->{$file};\n\tnext;\n      }\n      $nfiles->{$file} = $files->{$file};\n      next;\n    }\n    # both are ascii, create diff\n    mkdir_p($uploaddir);\n    if (!rundiff($ofiles->{$file} ? \"$ofilesdir/$ofiles->{$file}-$file\" : '/dev/null', \"$srcrep/$packid/$files->{$file}-$file\", $file, \"$uploaddir/$$\")) {\n      $nfiles->{$file} = $files->{$file};\n    }\n  }\n  my $lchanged;\n  $lchanged = 1 if $changedlink;\n  for (@dfiles) {\n    push @{$l->{'patches'}->{''}}, {'delete' => {'name' => $_}};\n    $lchanged = 1;\n  }\n  if (-s \"$uploaddir/$$\") {\n    my $ppatch = findprojectpatchname($nfiles);\n    $nfiles->{$ppatch} = addfile($projid, $packid, \"$uploaddir/$$\", $ppatch);\n    push @{$l->{'patches'}->{''}}, {'apply' => {'name' => $ppatch}};\n    $lchanged = 1;\n  } else {\n    unlink(\"$uploaddir/$$\");\n  }\n  my $baserev = $linkrev || $ltgtsrcmd5;\n  if (($l->{'baserev'} || '') ne $baserev) {\n    $l->{'baserev'} = $baserev;\n    $lchanged = 1;\n  }\n  $cgi->{'setrev'} = $baserev if $cgi->{'setrev'} && $cgi->{'setrev'} eq 'base';\n  if ($cgi->{'setrev'} && ($l->{'rev'} || '') ne $cgi->{'setrev'}) {\n    $l->{'rev'} = $cgi->{'setrev'};\n    $lchanged = 1;\n  }\n  if ($lchanged) {\n    writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n    $nfiles->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link')\n  }\n  if ($ofilesdir eq \"$uploaddir/applylink$$\") {\n    BSUtil::cleandir(\"$uploaddir/applylink$$\");\n    rmdir(\"$uploaddir/applylink$$\");\n  }\n  return $nfiles;\n}\n\n# integrate link from opackid to packid into packid\nsub integratelink {\n  my ($files, $projid, $packid, $rev, $ofiles, $oprojid, $opackid, $l, $orev) = @_;\n\n  # append patches from link l to link nl\n  my $nl = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);\n\n  # FIXME: remove hunks from patches that deal with replaced/deleted files\n  my $nlchanged;\n  my %dontcopy;\n  $dontcopy{'_link'} = 1;\n  my $nlisbranch;\n  if ($nl->{'patches'}) {\n    for (@{$nl->{'patches'}->{''} || []}) {\n      my $type = (keys %$_)[0];\n      if ($type eq 'add' || $type eq 'apply') {\n\t$dontcopy{$_->{$type}->{'name'}} = 1;\n      }\n      $nlisbranch = 1 if $type eq 'branch';\n    }\n  }\n  my $lisbranch;\n  if ($l->{'patches'}) {\n    for (@{$l->{'patches'}->{''} || []}) {\n      my $type = (keys %$_)[0];\n      $lisbranch = 1 if $type eq 'branch';\n    }\n  }\n\n  if ($nlisbranch) {\n    # we linked/branched a branch. expand.\n    #my %xrev = (%$rev, 'linkrev' => 'base');\n    my %xrev = %$rev;\n    my $linkinfo = {};\n    lsrev_expanded(\\%xrev, $linkinfo);\n    my %oxrev = (%$orev, 'linkrev' => $xrev{'srcmd5'});\n    $ofiles = lsrev_expanded(\\%oxrev);\n    copyfiles($projid, $packid, $oprojid, $opackid, $ofiles);\n    # find new base\n    if ($linkinfo->{'srcmd5'} ne $nl->{'baserev'}) {\n      # update base rev\n      $nl->{'baserev'} = $linkinfo->{'srcmd5'};\n      $nlchanged = 1;\n    }\n    # delete everything but the link\n    delete $files->{$_} for grep {$_ ne '_link'} keys %$files;\n  }\n\n  if ($lisbranch && !$nlisbranch) {\n    # we branched a link. convert branch to link\n    # and integrate\n    delete $ofiles->{'_link'};\n    $ofiles = keeplink({'convertbranchtopatch' => 1, 'linkrev' => 'base'}, $oprojid, $opackid, $ofiles, $orev);\n    $l = repreadxml($orev, '_link', $ofiles->{'_link'}, $BSXML::link);\n  }\n\n  if (!$nlisbranch && $l->{'patches'}) {\n    for (@{$l->{'patches'}->{''} || []}) {\n      my $type = (keys %$_)[0];\n      if ($type eq 'delete' && $files->{$_->{'delete'}->{'name'}} && !$dontcopy{$_->{'delete'}->{'name'}}) {\n\tdelete $files->{$_->{'delete'}->{'name'}};\n      } else {\n\t$nlchanged = 1;\n\t$nl->{'patches'} ||= {};\n\tif ($type eq 'apply') {\n\t  my $oppatch = $_->{'apply'}->{'name'};\n\t  if ($files->{$oppatch}) {\n\t    $dontcopy{$oppatch} = 1;\n\t    # argh, patch file already exists, rename...\n\t    my $ppatch = findprojectpatchname($files);\n\t    mkdir_p($uploaddir);\n\t    unlink(\"$uploaddir/$$\");\n\t    link(\"$srcrep/$opackid/$ofiles->{$oppatch}-$oppatch\", \"$uploaddir/$$\") || die(\"link $srcrep/$opackid/$ofiles->{$oppatch}-$oppatch $uploaddir/$$: $!\\n\");\n            $files->{$ppatch} = addfile($projid, $packid, \"$uploaddir/$$\", $ppatch);\n\t    push @{$nl->{'patches'}->{''}}, {'apply' => {'name' => $ppatch}};\n\t    next;\n\t  }\n\t}\n\tif ($type eq 'add') {\n\t  my $oppatch = $_->{'add'}->{'name'};\n\t  die(\"cannot apply patch $oppatch twice\\n\") if $dontcopy{$oppatch};\n\t}\n        push @{$nl->{'patches'}->{''}}, $_;\n      }\n    }\n  }\n  if ($nlchanged) {\n    mkdir_p($uploaddir);\n    writexml(\"$uploaddir/$$\", undef, $nl, $BSXML::link);\n    $files->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link');\n  }\n  for (sort keys %$ofiles) {\n    next if $dontcopy{$_};\n    $files->{$_} = $ofiles->{$_};\n  }\n  return $files;\n}\n\nsub sourcecommit {\n  my ($cgi, $projid, $packid) = @_;\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  my $files = lsrev($rev);\n  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};\n  $rev = addrev($cgi, $projid, $packid, $files);\n  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub sourcecommitfilelist {\n  my ($cgi, $projid, $packid) = @_;\n  BSVerify::verify_md5($cgi->{'servicemark'}) if $cgi->{'servicemark'};\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $fl = readxml(\"$uploaddir/$$\", $BSXML::dir);\n  unlink(\"$srcrep/:upload/$$\");\n  # make sure we know every file\n  my @missing;\n  my $files = {};\n  for my $entry (@{$fl->{'entry'} || []}) {\n    BSVerify::verify_filename($entry->{'name'});\n    BSVerify::verify_md5($entry->{'md5'});\n    if (! -e \"$srcrep/$packid/$entry->{'md5'}-$entry->{'name'}\") {\n      push @missing, $entry;\n    } else {\n      die(\"duplicate file: $entry->{'name'}\\n\") if exists $files->{$entry->{'name'}};\n      $files->{$entry->{'name'}} = $entry->{'md5'};\n    }\n  }\n  if (@missing) {\n    my $res = {'name' => $packid, 'error' => 'missing', 'entry' => \\@missing};\n    return ($res, $BSXML::dir);\n  }\n  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};\n  if (-e \"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\") {\n    # autocommit old update revision so that it doesn't get lost\n    my $uploadrev = {'project' => $projid, 'package' => $packid, 'srcmd5' => 'upload'};\n    my $uploadfiles = lsrev($uploadrev);\n    addrev({ %$cgi, 'comment' => 'autocommit update revision'}, $projid, $packid, $uploadfiles);\n  }\n  my $rev = addrev($cgi, $projid, $packid, $files);\n  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};\n  $cgi->{'rev'} = $rev->{'rev'};\n  return getfilelist($cgi, $projid, $packid);\n}\n\n# admin only, move entire project\nsub moveproject {\n  my ($cgi, $projid) = @_;\n  my $oprojid = $cgi->{'oproject'};\n  return $BSStdServer::return_ok if $oprojid eq $projid;\n\n  my $oproj = readproj($oprojid);\n\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;\n  if ($reposerver ne $oreposerver) {\n    die(\"cannot copy binaries between different reposiory servers yet\\n\");\n  }\n  if (-e \"$projectsdir/$projid.pkg\" || -e \"$projectsdir/$projid.conf\" || -e \"$projectsdir/$projid.xml\") {\n    die(\"target project already exists\\n\");\n  }\n\n  rename(\"$projectsdir/$oprojid.xml\", \"$projectsdir/$projid.xml\");\n  rename(\"$projectsdir/$oprojid.pkg\", \"$projectsdir/$projid.pkg\") if -e \"$projectsdir/$oprojid.pkg\";\n  rename(\"$projectsdir/$oprojid.conf\", \"$projectsdir/$projid.conf\") if -e \"$projectsdir/$oprojid.conf\";\n  rename(\"$treesdir/$oprojid\", \"$treesdir/$projid\") if $BSConfig::nosharedtrees && -e \"$treesdir/$oprojid\";\n\n  # move entries in linkinfo database\n  if (-d $sourcedb) {\n    my $linkdb = BSDB::opendb($sourcedb, 'linkinfo');\n    if ($linkdb) {\n      my @packids = grep {s/\\Q$oprojid\\E\\///} $linkdb->keys();\n      for my $packid (@packids) {\n\tnext unless -e \"$projectsdir/$projid.pkg/$packid.xml\";\n\teval {\n\t  my $rev = getrev($projid, $packid);\n\t  updatelinkinfodb($projid, $packid, $rev, lsrev($rev)) if $rev;\n\t};\n\twarn($@) if $@;\n\tupdatelinkinfodb($oprojid, $packid);\n      }\n    }\n  }\n\n  # move in the backend as well\n  my @args;\n  push @args, \"cmd=move\";\n  push @args, \"oproject=$oprojid\";\n  my $param = {\n    'uri' => \"$reposerver/build/$projid\",\n    'request' => 'POST',\n  };\n  eval {\n    # ignore failures for now\n    BSWatcher::rpc($param, undef, @args);\n  };\n  warn($@) if $@;\n\n  # check all packages in project\n  notify_repservers('package', $projid);\n  notify_repservers('package', $oprojid);\n  return $BSStdServer::return_ok;\n}\n\n# copy sources of entire project, project exists ensured by api.\nsub copyproject {\n  my ($cgi, $projid) = @_;\n  my $oprojid = $cgi->{'oproject'};\n  return $BSStdServer::return_ok if $oprojid eq $projid;\n\n  my $proj = readproj($projid);\n  my $oproj = readproj($oprojid);\n\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;\n  if ($cgi->{'withbinaries'} && $reposerver ne $oreposerver) {\n    die(\"cannot copy binaries between different reposiory servers yet\\n\");\n  }\n\n  my $user = defined($cgi->{'user'}) && $cgi->{'user'} ne '' ? $cgi->{'user'} : 'unknown';\n  my $comment = defined($cgi->{'comment'}) ? $cgi->{'comment'} : '';\n  $user = str2utf8xml($user);\n  $comment = str2utf8xml($comment);\n\n  # copy _project data\n  if (-e \"$projectsdir/$oprojid.pkg/_project.rev\" || -e \"$projectsdir/$oprojid.conf\") {\n    my $lastorev = getrev($oprojid, '_project');\n    my $files = lsrev($lastorev);\n    copyfiles($projid, '_project', $oprojid, '_project', $files);\n    addrev($cgi, $projid, '_project', $files);\n  }\n\n  # use {} as we do not want to copy project linked packages\n  my @pkgs = findpackages($oprojid, {});\n  delete $cgi->{'servicemark'};\t\t# just in case...\n  for my $packid (@pkgs) {\n    if (! -e \"$projectsdir/$projid.pkg/$packid.xml\") {\n      # new package, create. hopefully the API can deal with this\n      my $opack = readpack($oprojid, $packid);\n      my $pack = {\n\t'project' => $projid,\n\t'name' => $packid,\n      };\n      # everything except person, group, devel and lock\n      for (keys %$opack) {\n        next if $_ eq 'project' || $_ eq 'name';\n        next if $_ eq 'person' || $_ eq 'group' || $_ eq 'devel' || $_ eq 'lock';\n        $pack->{$_} = $opack->{$_} if defined $opack->{$_};\n      }\n      mkdir_p($uploaddir);\n      writexml(\"$uploaddir/copyproject$$\", undef, $pack, $BSXML::pack);\n      addrev_meta($cgi, $projid, $packid, \"$uploaddir/copyproject$$\", \"$projectsdir/$projid.pkg/$packid.xml\", '_meta');\n      # need to do this now because the binary copy will fail otherwise\n      notify_repservers('package', $projid, $packid) if $cgi->{'withbinaries'};\n    }\n    if ($cgi->{'makeolder'} || -s \"$projectsdir/$oprojid.pkg/$packid.rev\") {\n      my $lastorev;\n      if ($cgi->{'withhistory'}) {\n\t# FIXME: races ahead\n\t# history copying is a bit tricky, as it renumbers the revisions\n\tmy @allrevs = BSFileDB::fdb_getall(\"$projectsdir/$oprojid.pkg/$packid.rev\", $srcrevlay);\n\tif (-e \"$projectsdir/$projid.pkg/$packid.rev\") {\n\t  my $lastrev = BSFileDB::fdb_getlast(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay);\n\t  if ($lastrev && $lastrev->{'rev'}) {\n\t    for my $rev (@allrevs) {\n\t      $rev->{'rev'} += $lastrev->{'rev'};\n\t    }\n\t  }\n\t}\n\t# make trees available in new project\n\tmy $treedir = $BSConfig::nosharedtrees ? \"$treesdir/$projid/$packid\" : \"$treesdir/$packid\";\n\tif ($BSConfig::nosharedtrees) {\n\t  my $treedir = \"$treesdir/$projid/$packid\";\n\t  for my $rev (@allrevs) {\n\t    next if -e \"$treedir/$rev->{'srcmd5'}-MD5SUMS\";\n\t    my $files = lsrev({ %$rev, 'project' => $oprojid, 'package' => $packid });\n\t    copyfiles($projid, $packid, $oprojid, $packid, $files);\n\t    addmeta($projid, $packid, $files);\n\t  }\n\t}\n\tBSFileDB::fdb_add_multiple(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, @allrevs);\n\t$lastorev = $allrevs[-1];\n      } else {\n\t$lastorev = BSFileDB::fdb_getlast(\"$projectsdir/$oprojid.pkg/$packid.rev\", $srcrevlay);\n      }\n      if (!$lastorev || !$lastorev->{'rev'}) {\n\tnext unless $cgi->{'makeolder'};\n\t# fake empty commit\n\t$lastorev = { 'version' => 'unknown', 'rev' => 0, 'vrev' => 0, 'srcmd5' => $emptysrcmd5 };\n      }\n      # always do one new commit, we don't use addrev to have full control over vrev\n      my $linkinfo = {};\n      my $frev = { %$lastorev, 'project' => $oprojid, 'package' => $packid };\n      my $files = lsrev($frev, $linkinfo);\n\n      my $servicemark;\n      if ($linkinfo->{'xservicemd5'}) {\n        if ($cgi->{'noservice'}) {\n\t  eval {\n\t    $files = handleservice($frev, $files, $linkinfo->{'xservicemd5'});\n\t  };\n\t  if ($@) {\t\n\t    warn($@);\t# hmm, could not expand service\n\t    $servicemark = genservicemark($projid, $packid, $files, undef, 1);\n\t  } else {\n            copyfiles($projid, $packid, $oprojid, $packid, $files);\n\t    ($servicemark, $files) = servicemark_noservice($cgi, $projid, $packid, $files, undef, $linkinfo->{'xservicemd5'});\n\t  }\n\t} else {\n\t  $servicemark = genservicemark($projid, $packid, $files, undef, 1);\n\t}\n      }\n      copyfiles($projid, $packid, $oprojid, $packid, $files);\n      $files->{'/SERVICE'} = $servicemark if $servicemark;\n      my $newrev = { %$lastorev };\n      $newrev->{'srcmd5'} = addmeta($projid, $packid, $files);\n      $newrev->{'user'} = $user;\n      $newrev->{'comment'} = $comment;\n      $newrev->{'requestid'} = $cgi->{'requestid'};\n      $newrev->{'time'} = time();\n      if ($cgi->{'makeolder'}) {\n\t$newrev->{'vrev'} =~ s/(\\d+)$/($1+1).\".1\"/e;\n      } else {\n\t$newrev->{'vrev'} =~ s/(\\d+)$/$1+1/e;\n      }\n      delete $newrev->{'rev'};\n      $newrev = BSFileDB::fdb_add_i(\"$projectsdir/$projid.pkg/$packid.rev\", $srcrevlay, $newrev);\n      updatelinkinfodb($projid, $packid, { %$newrev, 'project' => $oprojid, 'package' => $packid }, $files);\n      if ($cgi->{'makeolder'}) {\n\t$lastorev->{'user'} = $user;\n\t$lastorev->{'comment'} = $comment;\n\t$lastorev->{'requestid'} = $cgi->{'requestid'};\n\t$lastorev->{'time'} = time();\n\t$lastorev->{'vrev'} =~ s/(\\d+)$/$1+2/e;\n\tdelete $lastorev->{'rev'};\n\t$lastorev = BSFileDB::fdb_add_i(\"$projectsdir/$oprojid.pkg/$packid.rev\", $srcrevlay, $lastorev);\n      }\n    }\n    # XXX: does this make any sense?\n    if ($cgi->{'withbinaries'}) {\n      for my $repo (@{$proj->{'repository'} || []}) {\n\tmy $orepo = (grep {$_->{'name'} eq $repo->{'name'}} @{$oproj->{'repository'} || []})[0];\n\tnext unless $orepo;\n\tfor my $arch (@{$repo->{'arch'} || []}) {\n\t  next unless grep {$_ eq $arch} @{$orepo->{'arch'} || []};\n\n\t  # same source and target repo/arch in both projects exists\n\t  my @args;\n\t  push @args, \"cmd=copy\";\n\t  push @args, \"oproject=$oprojid\";\n\t  push @args, \"opackage=$packid\"; # same package name\n\t  push @args, \"orepository=$repo->{'name'}\"; # same repo name\n\t  push @args, 'resign=1' if $cgi->{'resign'};\n\t  my $param = {\n\t    'uri' => \"$reposerver/build/$projid/$repo->{'name'}/$arch/$packid\",\n\t    'request' => 'POST',\n\t  };\n\t  eval {\n\t    # ignore failures for now\n\t    BSWatcher::rpc($param, undef, @args);\n\t  };\n          warn($@) if $@;\n\t}\n      }\n    }\n  }\n  # check all packages in project\n  notify_repservers('package', $projid);\n  return $BSStdServer::return_ok;\n}\n\n# we're going to auto-update a link. this means we must also\n# auto-update the corresponding service result\nsub update_link_in_service {\n  my ($rev, $files, $xservicemd5, $isbranch) = @_;\n\n  return undef unless defined $xservicemd5;\n  return $xservicemd5 if $BSConfig::old_style_services;\n  return $xservicemd5 unless $files->{'_link'};\n  my $sfiles;\n  eval {\n    $sfiles = lsrev({%$rev, 'srcmd5' => $xservicemd5});\n  };\n  return $xservicemd5 unless $sfiles && $sfiles->{'_link'};\n  return $xservicemd5 if $sfiles->{'_link'} && $sfiles->{'_link'} eq $files->{'_link'};\t# nothing changed\n  # okay, we need to generate a new service commit\n  my $servicemark = genservicemark($rev->{'project'}, $rev->{'package'}, $files, undef, 1);\n  return undef unless $servicemark;\n  # delete all non-service files unless it's a branch\n  if (!$isbranch) {\n    delete $sfiles->{$_} for grep {!/^_service[_:]/} keys %$sfiles;\n  }\n  # copy new link\n  $sfiles->{'_link'} = $files->{'_link'};\n  # write back new service result\n  fake_service_run($rev->{'project'}, $rev->{'package'}, $files, $sfiles, $servicemark);\n  return $servicemark;\n}\n\nsub sourcecopy {\n  my ($cgi, $projid, $packid) = @_;\n  die(\"illegal rev parameter\\n\") if $cgi->{'rev'} && $cgi->{'rev'} ne 'upload';\n  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;\n  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;\n  die(\"makeoriginolder only makes sense with withvrev\\n\") if $cgi->{'makeoriginolder'} && !$cgi->{'withvrev'};\n  my $orev = $cgi->{'orev'};\n  $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest');\n  die(\"origin must not be virtual for makeoriginolder\\n\") if $cgi->{'makeoriginolder'} && $orev->{'originproject'};\n  $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'};\n  my $orev_srcmd5 = $orev->{'srcmd5'};  # so that we can restore it later\n  my $files = $cgi->{'noservice'} || $cgi->{'expand'} ? lsrev_service($orev) : lsrev($orev);\n  die(\"need a revision to copy\\n\") if !$cgi->{'rev'} && !$cgi->{'orev'} && $oprojid eq $projid && $opackid eq $packid && !($files->{'_link'} && $cgi->{'expand'});\n\n  die(\"makeoriginolder currently does not work on links\\n\") if $cgi->{'makeoriginolder'} && $files->{'_link'};\n\n  my $autosimplifylink;\n  my $autosimplifylink_lrev;\n\n  if ($files->{'_link'} && !$cgi->{'dontupdatesource'} && !$cgi->{'rev'}) {\n    # fix me: do this in a more generic way\n    my $ol = repreadxml($orev, '_link', $files->{'_link'}, $BSXML::link, 1);\n    if ($ol) {\n      my $lprojid = $oprojid;\n      my $lpackid = $opackid;\n      my $lrev = $ol->{'rev'};\n      $lprojid = $ol->{'project'} if exists $ol->{'project'};\n      $lpackid = $ol->{'package'} if exists $ol->{'package'};\n      if ($lprojid eq $projid && $lpackid eq $packid) {\n\t# copy destination is target of link\n\t# we're integrating this link\n\t$lrev = getrev($lprojid, $lpackid, $lrev);\n\t$autosimplifylink_lrev = { %$lrev };\n\tmy $lfiles = $cgi->{'noservice'} && !$cgi->{'expand'} ? lsrev_service({ %$lrev }) : lsrev($lrev);\n\tif ($lfiles->{'_link'} && !$cgi->{'expand'}) {\n\t  # link to a link, join\n\t  $files = integratelink($lfiles, $lprojid, $lpackid, $lrev, $files, $oprojid, $opackid, $ol, $orev);\n\t} else {\n\t  # auto expand\n\t  $cgi->{'expand'} = 1;\n\t}\n\t$autosimplifylink = $ol;\n      }\n    }\n  }\n\n  my $oldvrev = $orev->{'vrev'};\n  if ($files->{'_link'} && $cgi->{'expand'}) {\n    my %olrev = %$orev;\t\t# copy so that orev still points to unexpanded sources\n    $files = handlelinks(\\%olrev, $files);\n    die(\"broken link in $oprojid/$opackid: $files\\n\") unless ref $files;\n    $oldvrev = $olrev{'vrev'};\n  }\n\n  copyfiles($projid, $packid, $oprojid, $opackid, $files);\n\n  if ($cgi->{'withvrev'} && !$cgi->{'vrev'} && defined($oldvrev)) {\n    $cgi->{'vrev'} = $oldvrev;\n    # bump vrev so that new builds will have a bigger release number\n    # (just like in copyproject)\n    if ($cgi->{'makeoriginolder'}) {\n      $cgi->{'vrev'} =~ s/(\\d+)$/$1+2/e;\n    } else {\n      $cgi->{'vrev'} =~ s/(\\d+)$/$1+1/e;\n    }\n  }\n  $files = keeplink($cgi, $projid, $packid, $files) if $cgi->{'keeplink'};\n  my $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});\n  delete $cgi->{'vrev'};\n\n  if ($cgi->{'makeoriginolder'}) {\n    # add dummy commit\n    my $lastline = BSFileDB::fdb_getlast(\"$projectsdir/$oprojid.pkg/$opackid.rev\", $srcrevlay);\n    die(\"makeoriginolder: $oprojid/$opackid does not exists?\\n\") unless defined $lastline;\n    delete $lastline->{'requestid'};\n    delete $lastline->{'rev'};\n    $lastline->{'user'} = 'buildservice-autocommit';\n    $lastline->{'comment'} = \"makeolder vrev update for $projid/$packid\";\n    $lastline->{'requestid'} = $cgi->{'requestid'} if $cgi->{'requestid'};\n    $lastline->{'vrev'} =~ s/(\\d+)$/($1+1).\".1\"/e;\n    BSFileDB::fdb_add_i(\"$projectsdir/$oprojid.pkg/$opackid.rev\", $srcrevlay, $lastline);\n    notify_repservers('package', $oprojid, $opackid);\n  }\n\n  if ($autosimplifylink && !defined($autosimplifylink->{'rev'})) {\n    $orev->{'srcmd5'} = $orev_srcmd5;\t# back to unexpanded\n\n    # make sure that vrev doesn't decrease when copying to the\n    # link target\n    my $vrevbump = 0;\n    if ($rev && $autosimplifylink_lrev && $rev->{'version'} ne $autosimplifylink_lrev->{'version'}) {\n      # version change, check if vrev went down\n      my $vrev1 = $rev->{'vrev'} || '0';\n      my $vrev2 = $autosimplifylink_lrev->{'vrev'} || '0';\n      $vrev1 =~ s/.*?(\\d+)$/$1/;\n      $vrev2 =~ s/.*?(\\d+)$/$1/;\n      $vrevbump = $vrev2 > $vrev1 ? $vrev2 - $vrev1 : 0;\n    }\n\n    my $isbranch = grep {(keys %$_)[0] eq 'branch'} @{$autosimplifylink->{'patches'}->{''} || []};\n    if ($isbranch) {\n      # update base rev so that there are no changes\n      # FIXME: this is a gross hack...\n      # we should not need to update the baserev, instead we should change\n      # the way branches get applied\n\n      my $ofiles = lsrev($orev);\n      delete $ofiles->{'_link'};\n      copyfiles($projid, $packid, $oprojid, $opackid, $ofiles);\n      my $newbase = addmeta($projid, $packid, $ofiles);\n      if ($autosimplifylink->{'baserev'} ne $newbase) {\n\teval {\n          my $latestorev = getrev($oprojid, $opackid);\n\t  my $latestlinkinfo = {};\n          my $latestfiles = lsrev($latestorev, $latestlinkinfo);\n          if ($latestfiles->{'_link'}) {\n\t    my $latestl = repreadxml($latestorev, '_link', $latestfiles->{'_link'}, $BSXML::link, 1);\n\t    my $latestisbranch = grep {(keys %$_)[0] eq 'branch'} @{$latestl->{'patches'}->{''} || []};\n\t    if ($latestisbranch && $latestl->{'baserev'} eq $autosimplifylink->{'baserev'}) {\n\t      $latestl->{'baserev'} = $newbase;\n\t      $latestl->{'patches'}->{''} = [ { 'branch' => undef} ]; # work around xml problem\n\t      if ($latestl->{'missingok'} &&\n\t\t(defined($latestl->{'project'}) ? $latestl->{'project'} : $oprojid) eq $projid &&\n\t\t(defined($latestl->{'package'}) ? $latestl->{'package'} : $opackid) eq $packid) {\n\t\teval {\n\t          checksourceaccess($projid, $packid);\n\t\t  delete $latestl->{'missingok'};\n\t\t};\n\t      }\n\t      mkdir_p($uploaddir);\n\t      writexml(\"$uploaddir/$$\", undef, $latestl, $BSXML::link);\n              $latestfiles->{'_link'} = addfile($oprojid, $opackid, \"$uploaddir/$$\", '_link');\n              my $servicemark = update_link_in_service($latestorev, $latestfiles, $latestlinkinfo->{'xservicemd5'}, 1);\n\t      if ($vrevbump) {\n\t\t$cgi->{'vrev'} = $latestorev->{'vrev'};\n\t\t$cgi->{'vrev'} =~ s/(\\d+)$/$1 + $vrevbump/e;\n\t      }\n              addrev({ %$cgi, 'user' => 'buildservice-autocommit', 'comment' => 'baserev update by copy to link target', 'servicemark' => $servicemark }, $oprojid, $opackid, $latestfiles);\n\t    }\n\t  }\n\t};\n        warn($@) if $@;\n      }\n    } else {\n      eval {\n        my $latestorev = getrev($oprojid, $opackid);\n        if ($latestorev->{'srcmd5'} eq $orev->{'srcmd5'}) {\n          # simplify link\n\t  my $latestlinkinfo = {};\n          my $latestfiles = lsrev($latestorev, $latestlinkinfo);\n          my $nl = { %$autosimplifylink };\n          delete $nl->{'patches'};\n          delete $nl->{'baserev'};\n\t  mkdir_p($uploaddir);\n          writexml(\"$uploaddir/$$\", undef, $nl, $BSXML::link);\n          my $ofiles = {};\n          $ofiles->{'_link'} = addfile($oprojid, $opackid, \"$uploaddir/$$\", '_link');\n          my $servicemark = update_link_in_service($latestorev, $ofiles, $latestlinkinfo->{'xservicemd5'}, 0);\n\t  if ($vrevbump) {\n\t    $cgi->{'vrev'} = $latestorev->{'vrev'};\n\t    $cgi->{'vrev'} =~ s/(\\d+)$/$1 + $vrevbump/e;\n\t  }\n          addrev({ %$cgi, 'user' => 'buildservice-autocommit', 'comment' => 'auto commit by copy to link target', 'servicemark' => $servicemark }, $oprojid, $opackid, $ofiles);\n        }\n      };\n      warn($@) if $@;\n    }\n    delete $cgi->{'vrev'} if $vrevbump;\n  }\n\n  runservice($cgi, $rev, $files) unless $cgi->{'noservice'};\n\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision_acceptinfo);\n}\n\nsub sourcebranch {\n  my ($cgi, $projid, $packid) = @_;\n\n  my $usebranch = 1;\n  my $oprojid = exists($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;\n  my $opackid = exists($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;\n  my $orev = $cgi->{'orev'};\n  die(\"cannot branch myself\\n\") if $oprojid eq $projid && $opackid eq $packid;\n  $orev = getrev($oprojid, $opackid, defined($orev) ? $orev : 'latest', undef, $cgi->{'missingok'});\n  $orev->{'linkrev'} = $cgi->{'olinkrev'} if $cgi->{'olinkrev'};\n  print \"SOURCEBRANCH $oprojid $opackid\\n\";\n  my $files = lsrev_expanded($orev);\t# modifies srcmd5, thus also needed for keepcontent case\n  if ($cgi->{'keepcontent'}) {\n    die(\"keepcontent is only supported for branches\\n\") unless $usebranch;\n    my $nrev = getrev($projid, $packid, 'latest');\n    $files = lsrev_expanded($nrev);\n  }\n  my $l = {};\n  $l->{'project'} = $oprojid if $oprojid ne $projid;\n  $l->{'package'} = $opackid if $opackid ne $packid;\n  # a missing package entry is bad if the project has sourceaccess\n  # disabled, so check if that's the case\n  eval {\n    checksourceaccess($oprojid, $opackid) if $opackid eq $packid && $oprojid ne $projid;\n  };\n  $l->{'package'} = $opackid if $@;\n  $l->{'missingok'} = \"true\" if defined $cgi->{'missingok'} && $orev->{'srcmd5'} eq $emptysrcmd5;\n  $l->{'rev'} = $cgi->{'orev'} if defined $cgi->{'orev'};\n  $l->{'baserev'} = $orev->{'srcmd5'};\n  my $lfiles = {};\n  mkdir_p(\"$srcrep/$packid\");\n  if ($usebranch) {\n    $l->{'patches'}->{''} = [ { 'branch' => undef} ];\n    copyfiles($projid, $packid, $oprojid, $opackid, $files) unless $cgi->{'keepcontent'};\n    $lfiles->{$_} = $files->{$_} for keys %$files;\n  }\n  mkdir_p($uploaddir);\n  writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n  $lfiles->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link');\n  my $rev = addrev($cgi, $projid, $packid, $lfiles);\n  runservice($cgi, $rev, $lfiles) unless $cgi->{'noservice'};\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision_acceptinfo);\n}\n\nsub linktobranch {\n  my ($cgi, $projid, $packid) = @_;\n  my $rev = getrev($projid, $packid);\n  $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n  my $files = lsrev($rev);\n  die(\"package is not a link\\n\") unless $files->{'_link'};\n  my $l = repreadxml($rev, '_link', $files->{'_link'}, $BSXML::link);\n  die(\"package is already a branch\\n\") if $l->{'patches'} && grep {(keys %$_)[0] eq 'branch'} @{$l->{'patches'}->{''} || []};\n  my $linkinfo = {};\n  $files = lsrev_expanded($rev, $linkinfo);\n  $l->{'baserev'} = $linkinfo->{'srcmd5'};\n  $l->{'patches'}->{''} = [ { 'branch' => undef} ];\n  mkdir_p($uploaddir);\n  writexml(\"$uploaddir/$$\", undef, $l, $BSXML::link);\n  $files->{'_link'} = addfile($projid, $packid, \"$uploaddir/$$\", '_link');\n  $cgi->{'comment'} ||= 'converted link to branch';\n  $rev = addrev($cgi, $projid, $packid, $files);\n  runservice($cgi, $rev, $files);\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub sourcecollectbuildenv {\n  my ($cgi, $projid, $packid) = @_;\n  my $oprojid = $cgi->{'oproject'} || $projid;\n  my $opackid = $cgi->{'opackage'} || $packid;\n  die(\"cannot collect from myself\\n\") if $oprojid eq $projid && $opackid eq $packid;\n  my $proj = checkprojrepoarch($projid);\n  my $oproj = checkprojrepoarch($oprojid);\n  my %orepoids;\n  for (@{$oproj->{'repository'} || []}) {\n    $orepoids{\"$oprojid/$_->{'name'}\"} = $_;\n  }\n  for (@{$oproj->{'repository'} || []}) {\n    for my $rt (@{$_->{'releasetarget'} || []}) {\n      $orepoids{\"$rt->{'project'}/$rt->{'repository'}\"} ||= $_;\n    }\n  }\n  my %buildenvs;\n  for my $repo (@{$proj->{'repository'} || []}) {\n    next unless @{$repo->{'arch'} || []};\n    my $repoid = $repo->{'name'};\n    my @xpath = expandsearchpath($projid, $repoid);\n    my $orepo;\n    for my $xr (@xpath) {\n      $orepo = $orepoids{$xr};\n      last if $orepo;\n    }\n    if ($orepo) {\n      my $orepoid = $orepo->{'name'};\n      my %oarchs = map {$_ => 1} @{$orepo->{'arch'} || []};\n      for my $arch (@{$repo->{'arch'}}) {\n\tmy $be;\n\tif (!$oarchs{$arch}) {\n\t  # arch not included, use error buildenv\n\t  $be = { 'error', \"$arch missing in $oprojid/$orepoid\" };\n\t} else {\n\t  my $reposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;\n\t  eval {\n\t    $be = BSRPC::rpc(\"$reposerver/build/$oprojid/$orepoid/$arch/$opackid/_buildenv\", $BSXML::buildinfo);\n\t  };\n\t  if ($@) {\n\t    die($@) if $@ !~ /^404/;\n\t    $be = { 'error', \"_buildenv missing in $oprojid/$orepoid\" };\n\t  }\n\t  $be ||= { 'error', \"could not get _buildenv in $oprojid/$orepoid\" };\n\t}\n        $buildenvs{\"_buildenv.$repoid.$arch\"} = BSUtil::toxml($be, $BSXML::buildinfo);\n      }\n    }\n  }\n  die(\"could not get any buildenv, something is wrong\\n\") unless %buildenvs;\n  # add master buildenv, in our case a \"fallback error\" buildenv\n  my $be = { 'error', \"no buildenv for this repo/arch\" };\n  $buildenvs{'_buildenv'} = BSUtil::toxml($be, $BSXML::buildinfo);\n  # now add all the buildenvs to the last commit (unexpanded is enough for us)\n  my $rev = getrev($projid, $packid);\n  my $files = lsrev($rev);\n  delete $files->{$_} for grep {/^_buildenv/} keys %$files;\n  mkdir_p($uploaddir);\n  for my $file (sort keys %buildenvs) {\n    writestr(\"$uploaddir/_be$$\", undef, $buildenvs{$file});\n    $files->{$file} = addfile($projid, $packid, \"$uploaddir/_be$$\", $file);\n  }\n  $rev = addrev($cgi, $projid, $packid, $files);\n  runservice($cgi, $rev, $files);\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub deleteuploadrev {\n  my ($cgi, $projid, $packid) = @_;\n  unlink(\"$projectsdir/$projid.pkg/$packid.upload-MD5SUMS\");\n  return $BSStdServer::return_ok;\n}\n\nsub unknowncmd {\n  my ($cgi, $projid, $packid) = @_;\n  die(\"unknown command \\\"$cgi->{'cmd'}\\\"\\n\");\n}\n\nsub delfile {\n  my ($cgi, $projid, $packid, $filename) = @_;\n  die(\"no filename\\n\") unless defined($filename) && $filename ne '';\n  die(\"bad filename\\n\") if $filename =~ /\\// || $filename =~ /^\\./;\n  if ($cgi->{'meta'}) {\n    if ($filename ne '_attribute' && $filename ne '_frozenlinks') {\n      die(\"unsupported meta operation\\n\");\n    }\n    my $rev = addrev_meta($cgi, $projid, $packid, undef, undef, $filename);\n    notify_repservers('package', $projid) if $filename eq '_frozenlinks';\n    delete $rev->{'project'};\n    delete $rev->{'package'};\n    return ($rev, $BSXML::revision);\n  }\n  die(\"file '$filename' is read-only\\n\") if ($filename =~ /^_service:/) && !$cgi->{'force'};\n  my $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'upload');\n  my $files;\n  if ($cgi->{'keeplink'}) {\n    $files = lsrev_expanded($rev);\n  } else {\n    $files = lsrev($rev);\n  }\n  die(\"404 file '$filename' does not exist\\n\") unless $files->{$filename};\n  delete $files->{$filename};\n  $files = keeplink($projid, $packid, $files) if $cgi->{'keeplink'};\n  $rev = addrev($cgi, $projid, $packid, $files, $cgi->{'rev'});\n  runservice($cgi, $rev, $files);\n  delete $rev->{'project'};\n  delete $rev->{'package'};\n  return ($rev, $BSXML::revision);\n}\n\nsub getrepositorylist {\n  my ($cgi, $projid) = @_;\n  my $proj = checkprojrepoarch($projid, undef, undef, 1);\n  if ($proj->{'remoteurl'}) {\n    return (BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}\", 'proxy' => $proxy}, $BSXML::dir), $BSXML::dir);\n  }\n  my @res = map {{'name' => $_->{'name'}}} @{$proj->{'repository'} || []};\n  return ({'entry' => \\@res}, $BSXML::dir);\n}\n\nsub getrepository {\n  my ($cgi, $projid, $repoid) = @_;\n  my $proj = readproj($projid);\n  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];\n  die(\"404 $repoid: no such repository\\n\") unless $repo;\n  return ($repo, $BSXML::repo);\n}\n\nsub getarchlist {\n  my ($cgi, $projid, $repoid) = @_;\n  my $proj = checkprojrepoarch($projid, $repoid, undef, 1);\n  if ($proj->{'remoteurl'}) {\n    return (BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid\", 'proxy' => $proxy}, $BSXML::dir), $BSXML::dir);\n  }\n  my @repo = grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []};\n  die(\"404 $repoid: no such repository\\n\") unless @repo;\n  my @res = map {{'name' => $_}} @{$repo[0]->{'arch'} || []};\n  return ({'entry' => \\@res}, $BSXML::dir);\n}\n\nsub getresult {\n  my ($cgi, $projid) = @_;\n\n  my $proj = checkprojrepoarch($projid, undef, undef, 1);\n  if ($proj->{'remoteurl'}) {\n    die(\"oldstate not supported for remote projects\\n\") if $cgi->{'oldstate'};\n    my @args;\n    push @args, \"lastbuild\" if $cgi->{'lastbuild'};\n    push @args, map {\"view=$_\"} @{$cgi->{'view'} || []};\n    push @args, map {\"repository=$_\"} @{$cgi->{'repository'} || []};\n    push @args, map {\"arch=$_\"} @{$cgi->{'arch'} || []};\n    push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n    push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n    return (BSRPC::rpc({'uri' => \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/_result\", 'proxy' => $proxy}, $BSXML::resultlist, @args), $BSXML::resultlist);\n  }\n  if ($cgi->{'oldstate'} && !$BSStdServer::isajax) {\n    my @args = \"oldstate=$cgi->{'oldstate'}\";\n    push @args, \"lastbuild\" if $cgi->{'lastbuild'};\n    push @args, map {\"view=$_\"} @{$cgi->{'view'} || []};\n    push @args, map {\"repository=$_\"} @{$cgi->{'repository'} || []};\n    push @args, map {\"arch=$_\"} @{$cgi->{'arch'} || []};\n    push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n    push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n    BSHandoff::handoff($ajaxsocket, \"/build/$projid/_result\", undef, @args);\n    exit(0);\n  }\n\n  my %repoidfilter = map {$_ => 1} @{$cgi->{'repository'} || []};\n  my %archfilter = map {$_ => 1} @{$cgi->{'arch'} || []};\n  my %view = map {$_ => 1} @{$cgi->{'view'} || ['status']};\n  my %code = map {$_ => 1} @{$cgi->{'code'} || []};\n\n  if ($cgi->{'repository'}) {\n    my %knownrepoids = map {$_->{'name'} => 1} @{$proj->{'repository'} || []};\n    for (@{$cgi->{'repository'}}) {\n      die(\"404 unknown repository '$_'\\n\") if !$knownrepoids{$_};\n    }\n  }\n  if ($cgi->{'package'}) {\n    my %knownpackids = map {$_ => 1} findpackages($projid, $proj, 1);\n    for (@{$cgi->{'package'}}) {\n      die(\"404 unknown package '$_'\\n\") if !$knownpackids{$_};\n    }\n  }\n  my @prpas;\n  for my $repo (@{$proj->{'repository'} || []}) {\n    next if %repoidfilter && !$repoidfilter{$repo->{'name'}};\n    my @archs = @{$repo->{'arch'} || []};\n    @archs = grep {$archfilter{$_}} @archs if %archfilter;\n    push @prpas, map {\"$projid/$repo->{'name'}/$_\"} @archs;\n  }\n\n  BSWatcher::addfilewatcher(\"$projectsdir/$projid.xml\") if $BSStdServer::isajax;\n\n  if (!@prpas) {\n    my $state = \"00000000000000000000000000000000\";\n    return undef if $BSStdServer::isajax && $cgi->{'oldstate'} && $state eq $cgi->{'oldstate'};\n    return ({'state' => $state}, $BSXML::resultlist);\n  }\n\n  my $ps = {};\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, 'lastbuild' if $cgi->{'lastbuild'};\n  push @args, \"oldstate=$cgi->{'oldstate'}\" if $cgi->{'oldstate'};\n  push @args, map {\"prpa=$_\"} @prpas;\n  push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n  push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n  push @args, 'withbinarylist' if $view{'binarylist'};\n  push @args, 'withstats' if $view{'stats'};\n  push @args, 'summary' if $view{'summary'} && !$view{'status'};\n  eval {\n    $ps = BSWatcher::rpc(\"$reposerver/_result\", $BSXML::resultlist, @args);\n  };\n  if ($@) {\n    print \"warning: $reposerver: $@\";\n    $ps = {};\n  }\n  return if $BSStdServer::isajax && !defined($ps);\n  if ($view{'summary'} && $view{'status'}) {\n    my @order = ('succeeded', 'failed', 'unresolvable', 'broken', 'scheduled');\n    my %order = map {$_ => 1} @order;\n    for my $p (@{$ps->{'result'} || []}) {\n      my %sum;\n      for my $pp (@{$p->{'status'} || []}) {\n        $sum{$pp->{'code'}}++ if $pp->{'code'};\n      }\n      my @sum = grep {exists $sum{$_}} @order;\n      push @sum, grep {!$order{$_}} sort keys %sum;\n      $p->{'summary'} = {'statuscount' => [ map {{'code' => $_, 'count' => $sum{$_}}} @sum ] };\n    }\n  }\n  if (!$view{'status'}) {\n    for my $p (@{$ps->{'result'} || []}) {\n      delete $p->{'status'};\n    }\n  }\n  return ($ps, $BSXML::resultlist);\n}\n\nsub docommand {\n  my ($cgi, $projid) = @_;\n\n  my %repoidfilter = map {$_ => 1} @{$cgi->{'repository'} || []};\n  my %archfilter = map {$_ => 1} @{$cgi->{'arch'} || []};\n\n  my $proj = readproj($projid);\n  my @prpas;\n  for my $repo (@{$proj->{'repository'} || []}) {\n    next if %repoidfilter && !$repoidfilter{$repo->{'name'}};\n    my @archs = @{$repo->{'arch'} || []};\n    @archs = grep {$archfilter{$_}} @archs if %archfilter;\n    push @prpas, map {\"$projid/$repo->{'name'}/$_\"} @archs;\n  }\n  die(\"no repository defined\\n\") unless @prpas;\n  my @packids = @{$cgi->{'package'} || []};\n  if ($cgi->{'cmd'} eq 'wipepublishedlocked') {\n    die(\"wipepublishedlocked can only wipe complete repos\\n\") if $cgi->{'arch'} || $cgi->{'code'} || @packids;\n  } else {\n    if (@packids) {\n      my %packids = map {$_ => 1} findpackages($projid, $proj, 1);\n      my @badpacks = grep {!$packids{$_}} @packids;\n      die(\"404 unknown package: @badpacks\\n\") if @badpacks;\n    } else {\n      @packids = findpackages($projid, $proj);\n    }\n    die(\"no packages defined\\n\") unless @packids;\n  }\n  die(\"illegal wipe parameter\\n\") if $cgi->{'wipe'} && $cgi->{'cmd'} ne 'wipe';\n  \n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $res;\n  my @args;\n  push @args, map {\"prpa=$_\"} @prpas;\n  push @args, map {\"package=$_\"} @packids;\n  push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n  push @args, map {\"wipe=$_\"} @{$cgi->{'wipe'} || []};\n  push @args, \"cmd=$cgi->{'cmd'}\";\n  my $param = {\n    'uri' => \"$reposerver/_command\",\n    'request' => 'POST',\n  };\n  $res = BSWatcher::rpc($param, undef, @args);\n  return $res;\n}\n\nsub checkprojrepoarch {\n  my ($projid, $repoid, $arch, $remoteok) = @_;\n  my $proj = readproj($projid, 1);\n  $proj = remoteprojid($projid) if $remoteok && (!$proj || $proj->{'remoteurl'});\n  die(\"404 project '$projid' does not exist\\n\") if !$proj;\n  die(\"404 project '$projid' is remote\\n\") if $proj->{'remoteurl'} && !$remoteok;\n  return $proj if $proj->{'remoteurl'};\n  return $proj unless defined $repoid;\n  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];\n  die(\"404 project '$projid' has no repository '$repoid'\\n\") unless $repo;\n  return $proj unless defined $arch;\n  die(\"404 repository '$projid/$repoid' has no architecture '$arch'\\n\") unless grep {$_ eq $arch} @{$repo->{'arch'} || []};\n  return $proj;\n}\n\nsub getbuilddepinfo {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n  push @args, \"view=$cgi->{'view'}\" if $cgi->{'view'};\n  my $res = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/_builddepinfo\", $BSXML::builddepinfo, @args);\n  return ($res, $BSXML::builddepinfo);\n}\n\nsub getjobhistory {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, \"limit=$cgi->{'limit'}\" if $cgi->{'limit'};\n  push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n  push @args, map {\"code=$_\"} @{$cgi->{'code'} || []};\n  my $res = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/_jobhistory\", $BSXML::jobhistlist, @args);\n  return ($res, $BSXML::jobhistlist);\n}\n\nsub getpackagelist_build {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n  if ($cgi->{'view'}) {\n    die(\"unknown view '$cgi->{'view'}'\\n\") unless $cgi->{'view'} eq 'binaryversions' || $cgi->{'view'} eq 'binaryversionscode';\n    my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);\n    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n    my @args = (\"view=$cgi->{'view'}\");\n    push @args, map {\"package=$_\"} @{$cgi->{'package'} || []};\n    my $param = {\n      'uri' => \"$reposerver/build/$projid/$repoid/$arch\",\n      'ignorestatus' => 1,\n      'receiver' => \\&BSServer::reply_receiver,\n    };\n    if ($proj->{'remoteurl'}) {\n      if (!$BSStdServer::isajax) {\n\tBSHandoff::handoff($ajaxsocket, \"/build/$projid/$repoid/$arch\", undef, @args);\n\texit(0);\n      }\n      $param->{'uri'} = \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch\";\n      $param->{'proxy'} = $proxy;\n    }\n    BSWatcher::rpc($param, undef, @args);\n    return undef;\n  }\n  return getpackagelist({ %$cgi, 'expand' => 1, 'noorigins' => 1 }, $projid, $repoid, $arch);\n}\n\nsub getbinarylist {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n\n  my $view = $cgi->{'view'};\n  my $nosource = $cgi->{'nosource'};\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, \"view=$view\" if $view;\n  push @args, \"nosource=1\" if $nosource;\n  push @args, \"withmd5=1\" if $cgi->{'withmd5'};\n  push @args, map {\"binary=$_\"} @{$cgi->{'binary'} || []};\n  if ($view && ($view eq 'cache' || $view eq 'cpio' || $view eq 'solv' || $view eq 'solvstate')) {\n    # do not check arch in interconnect mode\n    my $proj = checkprojrepoarch($projid, $repoid, undef, 1);\n    if (!$BSStdServer::isajax) {\n      if ($proj->{'remoteurl'} && $view eq 'cpio' && $packid eq '_repository' && !$nosource && @{$cgi->{'binary'} || []}) {\n\t# hand over to worker_getbinaries to get the answer cached\n\t@args = ();\n\tpush @args, \"project=$projid\";\n\tpush @args, \"repository=$repoid\";\n\tpush @args, \"arch=$arch\";\n\tpush @args, \"binaries=\".join(',', @{$cgi->{'binary'} || []});\n\tBSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);\n\texit(0);\n      }\n      BSHandoff::handoff($ajaxsocket, \"/build/$projid/$repoid/$arch/$packid\", undef, @args);\n      exit(0);\n    }\n    my $param = {\n      'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid\",\n      'ignorestatus' => 1,\n      'receiver' => \\&BSServer::reply_receiver,\n    };\n    if ($proj->{'remoteurl'}) {\n      $param->{'uri'} = \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid\";\n      $param->{'proxy'} = $proxy;\n    }\n    BSWatcher::rpc($param, undef, @args);\n    return undef;\n  }\n  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid\",\n  };\n  if ($proj->{'remoteurl'}) {\n    $param->{'uri'} = \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid\";\n    $param->{'proxy'} = $proxy;\n  }\n  if ($view && $view eq 'binaryversions') {\n    push @args, 'nometa=1' if $cgi->{'nometa'};\n    my $bvl = BSWatcher::rpc($param, $BSXML::binaryversionlist, @args);\n    return ($bvl, $BSXML::binaryversionlist);\n  }\n  if ($view && $view eq 'cpioheaders') {\n     $param->{'ignorestatus'} = 1;\n     $param->{'receiver'} = \\&BSServer::reply_receiver;\n     BSWatcher::rpc($param, undef, @args);\n     return undef;\n  }\n  my $bl = BSWatcher::rpc($param, $BSXML::binarylist, @args);\n  return ($bl, $BSXML::binarylist);\n}\n\nsub getbinary {\n  my ($cgi, $projid, $repoid, $arch, $packid, $filename) = @_;\n  my $proj = checkprojrepoarch($projid, $repoid, $arch, 1);\n  my $view = $cgi->{'view'} || '';\n  if ($proj->{'remoteurl'} && $packid eq '_repository' && !$view) {\n    # hack: reroute to /getbinaries so that our local cache is used\n    die(\"need the raw package name as filename for remote repository access\\n\") if $filename =~ /\\.(?:$binsufsre)$/;\n    my @args;\n    push @args, \"project=$projid\";\n    push @args, \"repository=$repoid\";\n    push @args, \"arch=$arch\";\n    push @args, \"binaries=$filename\";\n    push @args, \"raw=1\";\n    BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);\n    exit(0);\n  }\n  if ($view eq 'publishedpath') {\n    die(\"publishedpath does not work for _repository\\n\") if $packid eq '_repository';\n    return published_path($cgi, $projid, $repoid);\n  }\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, \"view=$view\" if $view;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid/$filename\",\n    'ignorestatus' => 1,\n    'receiver' => \\&BSServer::reply_receiver,\n  };\n  if ($view && $view eq 'fileinfo_ext') {\n    my $partition = projid2partition($projid);\n    my $projpack = (getprojpack({'nopackages' => 1, 'withrepos' => 1, 'expandedrepos' => 1, 'withremotemap' => 1, 'withconfig' => 1, 'partition' => $partition}, [ $projid ], [ $repoid ], undef, $arch))[0];\n    if ($projpack) {\n      if ($projpack->{'project'} && $projpack->{'project'}->[0]->{'name'} eq $projid) {\n        my $config = (getbuildconfig({}, $projid, $repoid))[0];\n\t$projpack->{'project'}->[0]->{'config'} = $config if $config;\n      }\n      $param->{'request'} = 'POST';\n      $param->{'data'} = BSUtil::toxml($projpack, $BSXML::projpack);\n      $param->{'headers'} = [ 'Content-Type: application/octet-stream' ];\n    }\n  }\n  if ($proj->{'remoteurl'}) {\n    $param->{'uri'} = \"$proj->{'remoteurl'}/build/$proj->{'remoteproject'}/$repoid/$arch/$packid/$filename\";\n    $param->{'proxy'} = $proxy;\n  }\n  BSWatcher::rpc($param, undef, @args);\n  return undef;\n}\n\nsub putbinary {\n  my ($cgi, $projid, $repoid, $arch, $filename) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, 'ignoreolder=1' if $cgi->{'ignoreolder'};\n  push @args, 'wipe=1' if $cgi->{'wipe'};\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/_repository/$filename\",\n    'request' => 'PUT',\n    'data' => \\&BSServer::forward_sender,\n    'chunked' => 1,\n  };\n  # XXX add return type checking\n  return BSWatcher::rpc($param, undef, @args);\n}\n\nsub delbinary {\n  my ($cgi, $projid, $repoid, $arch, $filename) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/_repository/$filename\",\n    'request' => 'DELETE',\n  };\n  return BSWatcher::rpc($param, undef);\n}\n\nsub copybuild {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  die(\"illegal package '$packid'\\n\") if $packid =~ /^_/ && !($packid =~ /^_product:/);\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $oprojid = defined($cgi->{'oproject'}) ? $cgi->{'oproject'} : $projid;\n  my $opackid = defined($cgi->{'opackage'}) ? $cgi->{'opackage'} : $packid;\n  my $orepoid = defined($cgi->{'orepository'}) ? $cgi->{'orepository'} : $repoid;\n  die(\"nothing to do\\n\") if \"$oprojid/$opackid/$orepoid\" eq \"$projid/$packid/$repoid\";\n  checkprojrepoarch($oprojid, $orepoid, $arch);\n  # make sure the packages exist. not cheap, but does everything we need\n  getrev($projid, $packid);\n  getrev($oprojid, $opackid);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $oreposerver = $BSConfig::partitioning ? projid2reposerver($oprojid) : $BSConfig::reposerver;\n  if ($reposerver ne $oreposerver) {\n    die(\"cannot copy binaries between different reposiory servers yet\\n\");\n  }\n  my @args;\n  push @args, \"cmd=copy\";\n  push @args, \"oproject=$oprojid\";\n  push @args, \"opackage=$opackid\";\n  push @args, \"orepository=$orepoid\";\n  push @args, \"setupdateinfoid=$cgi->{'setupdateinfoid'}\" if $cgi->{'setupdateinfoid'};\n  push @args, \"setrelease=$cgi->{'setrelease'}\" if $cgi->{'setrelease'};\n  push @args, 'resign=1' if $cgi->{'resign'};\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid\",\n    'request' => 'POST',\n  };\n  # XXX add return type checking\n  return BSWatcher::rpc($param, undef, @args);\n}\n\nsub uploadbuild {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  die(\"illegal package '$packid'\\n\") if $packid =~ /^_/ && !($packid =~ /^_product:/);\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid\",\n    'request' => 'POST',\n    'data' => \\&BSServer::forward_sender,\n    'chunked' => 1,\n  };\n  # XXX add return type checking\n  return BSWatcher::rpc($param, undef);\n}\n\n\nsub getlogfile {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n\n  if (!$cgi->{'start'}) {\n    # check if the package is broken\n    my $rev = getrev($projid, $packid, 'build');\n    eval {\n      lsrev_expanded($rev);\n    };\n    if ($@) {\n      my $error = $@;\n      if ($rev->{'srcmd5'}) {\n        my $files = lsrev($rev);\n\tif ($files->{'_serviceerror'}) {\n\t  $error = repreadstr($rev, '_serviceerror', $files->{'_serviceerror'});\n\t} elsif ($files->{'_linkerror'}) {\n\t  $error = repreadstr($rev, '_linkerror', $files->{'_linkerror'});\n\t}\n      }\n      if ($cgi->{'view'} && $cgi->{'view'} eq 'entry') {\n        my $entry = {'name' => '_log', 'size' => length($error)};\n        return ({'entry' => [ $entry ]}, $BSXML::dir);\n      }\n      return $error;\n    }\n  }\n\n  my @args;\n  push @args, 'last' if $cgi->{'last'};\n  push @args, 'nostream' if $cgi->{'nostream'};\n  push @args, \"start=$cgi->{'start'}\" if defined $cgi->{'start'};\n  push @args, \"end=$cgi->{'end'}\" if defined $cgi->{'end'};\n  push @args, \"view=$cgi->{'view'}\" if $cgi->{'view'};\n  if (!$BSStdServer::isajax && !$cgi->{'view'}) {\n    my $url = \"/build/$projid/$repoid/$arch/$packid/_log\";\n    BSHandoff::handoff($ajaxsocket, $url, undef, @args);\n    exit(0);\n  }\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid/_log\",\n    'ignorestatus' => 1,\n    'receiver' => \\&BSServer::reply_receiver,\n    'joinable' => 1,\n  };\n  BSWatcher::rpc($param, undef, @args);\n  return undef; # always streams result\n}\n\nsub getjobstatus {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $jobstatus = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_jobstatus\", $BSXML::jobstatus);\n  return ($jobstatus, $BSXML::jobstatus);\n}\n\nsub getbuildhistory {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, \"limit=$cgi->{'limit'}\" if $cgi->{'limit'};\n  my $buildhist = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_history\", $BSXML::buildhist, @args);\n  return ($buildhist, $BSXML::buildhist);\n}\n\nsub getbuildinfo {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  $arch = $BSConfig::localarch if $arch eq 'local' && defined($BSConfig::localarch);\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, 'internal=1' if $cgi->{'internal'};\n  push @args, 'debug=1' if $cgi->{'debug'};\n  push @args, map {\"add=$_\"} @{$cgi->{'add'} || []};\n  my $buildinfo = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_buildinfo\", $BSXML::buildinfo, @args);\n  return ($buildinfo, $BSXML::buildinfo);\n}\n\nsub getbuildinfo_post {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  $arch = $BSConfig::localarch if $arch eq 'local' && defined($BSConfig::localarch);\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my @args;\n  push @args, 'debug=1' if $cgi->{'debug'};\n  push @args, map {\"add=$_\"} @{$cgi->{'add'} || []};\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/$packid/_buildinfo\",\n    'request' => 'POST',\n    'data' => \\&BSServer::forward_sender,\n    'chunked' => 1,\n  };\n  my $buildinfo = BSWatcher::rpc($param, $BSXML::buildinfo, @args);\n  return ($buildinfo, $BSXML::buildinfo);\n}\n\nsub getbuildreason {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $reason = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_reason\", $BSXML::buildreason);\n  return ($reason, $BSXML::buildreason);\n}\n\nsub getbuildstatus {\n  my ($cgi, $projid, $repoid, $arch, $packid) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $status = BSWatcher::rpc(\"$reposerver/build/$projid/$repoid/$arch/$packid/_status\", $BSXML::buildstatus);\n  return ($status, $BSXML::buildstatus);\n}\n\nsub getworkerstatus {\n  my ($cgi) = @_;\n  # compat\n  if ($cgi->{'scheduleronly'} && !$cgi->{'daemonsonly'}) {\n    $cgi->{'daemonsonly'} = delete $cgi->{'scheduleronly'};\n  }\n  my @args;\n  push @args, 'daemonsonly' if $cgi->{'daemonsonly'};\n  push @args, map {\"arch=$_\"} @{$cgi->{'arch'} || []};\n\n  if (!$BSConfig::partitioning || !$BSConfig::partitionservers) {\n    my $reposerver = $BSConfig::reposerver;\n    my $ws = BSWatcher::rpc(\"$reposerver/workerstatus\", $BSXML::workerstatus, @args);\n    delete $_->{'uri'} for @{$ws->{'idle'} || []};\n    delete $_->{'uri'} for @{$ws->{'building'} || []};\n    return ($ws, $BSXML::workerstatus);\n  }\n\n  # cummulated worker status\n  my $cws;\n  if (!$cgi->{'daemonsonly'}) {\n    $cws->{'clients'} = 0;\n    $cws->{'building'} = [];\n    $cws->{'waiting'} = [];\n    $cws->{'blocked'} = [];\n    $cws->{'buildavg'} = [];\n    $cws->{'idle'} = [];\n  }\n  $cws->{'partition'} = [];\n\n  my %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);\n  for my $reposerver (sort keys %reposervers) {\n    my $ws = BSWatcher::rpc(\"$reposerver/workerstatus\", $BSXML::workerstatus, @args);\n\n    push @{$cws->{'partition'}}, @{$ws->{'partition'}};\n    next if $cgi->{'daemonsonly'};\n\n    delete $_->{'uri'} for @{$ws->{'idle'} || []};\n    delete $_->{'uri'} for @{$ws->{'building'} || []};\n    push @{$cws->{'idle'}}, @{$ws->{'idle'} || []};\n    push @{$cws->{'building'}}, @{$ws->{'building'} || []};\n    for my $b (@{$ws->{'waiting'} || []}) {\n      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'waiting'} || []})[0];\n      if (!$ob) {\n        $ob = {'arch' => $b->{'arch'}, 'jobs' => 0};\n        push @{$cws->{'waiting'}}, $ob;\n      }\n      $ob->{'jobs'} += $b->{'jobs'};\n    }\n    for my $b (@{$ws->{'blocked'} || []}) {\n      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'blocked'} || []})[0];\n      if (!$ob) {\n        $ob = {'arch' => $b->{'arch'}, 'jobs' => 0};\n        push @{$cws->{'blocked'}}, $ob;\n      }\n      $ob->{'jobs'} += $b->{'jobs'};\n    }\n    for my $b (@{$ws->{'buildavg'} || []}) {\n      my $ob = (grep {$_->{'arch'} eq $b->{'arch'}} @{$cws->{'buildavg'} || []})[0];\n      if (!$ob) {\n        $ob = {'arch' => $b->{'arch'}, 'buildavg' => 0, 'count' => 0};\n        push @{$cws->{'buildavg'}}, $ob;\n      }\n      $ob->{'buildavg'} += $b->{'buildavg'};\n      $ob->{'count'} += 1;\n    }\n    $cws->{'clients'} += $ws->{'clients'} if $ws->{'clients'};\n  }\n  for my $b (@{$cws->{'buildavg'} || []}) {\n    $b->{'buildavg'} /= delete $b->{'count'};\n  }\n\n  # sort\n  if (!$cgi->{'daemonsonly'}) {\n    $cws->{'idle'} = [ sort {$a->{'workerid'} cmp $b->{'workerid'} || $a->{'uri'} cmp $b->{'uri'} || $a cmp $b} @{$cws->{'idle'}} ];\n    $cws->{'building'} = [ sort {$a->{'workerid'} cmp $b->{'workerid'} || $a->{'uri'} cmp $b->{'uri'} || $a cmp $b} @{$cws->{'building'}} ];\n    $cws->{'waiting'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'waiting'}} ];\n    $cws->{'blocked'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'blocked'}} ];\n    $cws->{'buildavg'} = [ sort {$a->{'arch'} cmp $b->{'arch'} || $a cmp $b}  @{$cws->{'buildavg'}} ];\n  }\n  \n  return ($cws, $BSXML::workerstatus);\n}\n\nsub getajaxstatus {\n  my ($cgi) = @_;\n  if (!$BSStdServer::isajax) {\n    BSHandoff::handoff($ajaxsocket, '/ajaxstatus');\n    exit(0);\n  }\n  my $r = BSWatcher::getstatus();\n  return ($r, $BSXML::ajaxstatus);\n}\n\nsub search_proj {\n  my ($cgi, $match, $id) = @_;\n  $match =~ s/^\\[(.*)\\]$/$1/s;\n  my $data = [];\n  for my $projid (findprojects()) {\n    my $proj = readproj($projid);\n    push @$data, $proj;\n  }\n  $data = BSXPath::match($data, $match);\n  if ($id) {\n    for (@{$data || []}) {\n      $_ = {'name' => $_->{'name'}};\n    }\n  }\n  my $res = {'project' => $data};\n  return ($res, $BSXML::collection);\n}\n\nsub pkgsearch_fetch {\n  my ($db, $k) = @_;\n  my ($projid, $packid) = split('/', $k, 2);\n  my $pack = readpack($projid, $packid, 1) || {'name' => $packid};\n  $pack->{'project'} = $projid;\n  #my @linkinfo = BSDBIndex::getvalues($db, 'linkinfo', $k);\n  #$pack->{'linkinfo'} = $linkinfo[0] if @linkinfo;\n  return $pack;\n}\n\nsub pkgsearch_indexfunc {\n  my ($db, $path, $value, $lkeys) = @_;\n  if (!defined($path)) {\n    return @{$db->{'_allkeys'}} if $db->{'_allkeys'};\n    my @projids = findprojects();\n    my @r;\n    for my $projid (@projids) {\n      push @r, map {\"$projid/$_\"} findpackages($projid, {}, 1);\n    }\n    $db->{'_allkeys'} = \\@r;\n    return @r;\n  } elsif (!defined($value)) {\n    return BSDBIndex::getkeys($db, \"$db->{'index'}$path\") if $path =~ /^linkinfo\\//;\n    return findprojects() if $path eq 'project';\n    if ($path eq 'name') {\n      $lkeys = [ pkgsearch_indexfunc($db) ] unless $lkeys;\n      my %v = map {$_ => 1} grep {s/^.*\\///} map {$_} @$lkeys;\n      return sort keys %v;\n    }\n  } else {\n    return BSDBIndex::getvalues($db, \"$db->{'index'}$path\", $value) if $path =~ /^linkinfo\\//;\n    return map {\"$value/$_\"} findpackages($value, {}, 1) if $path eq 'project';\n    if ($path eq 'name') {\n      $lkeys = [ pkgsearch_indexfunc($db) ] unless $lkeys;\n      return grep {/\\Q$value\\E$/} @$lkeys;\n    }\n  }\n  return ();\n}\n\nsub search_pack {\n  my ($cgi, $match, $id) = @_;\n  $match =~ s/^\\[(.*)\\]$/$1/s;\n  # really ugly hack to speed up needed api call\n  if ($match =~ /^\\@project='(.+)' and starts-with\\(\\@name,'(.+)'\\)$/) {\n    my $projid = $1;\n    my $startswith = $2;\n    $projid =~ s/''/'/g;\n    $startswith =~ s/''/'/g;\n    my @packages = findpackages($projid, {});\n    my $data = [];\n    for my $packid (grep {/^\\Q$startswith\\E/} @packages) {\n      my ($pack, undef) = getpackage($cgi, $projid, $packid);\n      $pack->{'project'} = $projid;\n      push @$data, $pack;\n    }\n    my $res = {'package' => $data};\n    return ($res, $BSXML::collection);\n  }\n  my $db = BSDB::opendb($sourcedb, '');\n  $db->{'indexfunc'} = {\n    'project' => \\&pkgsearch_indexfunc,\n    'name' => \\&pkgsearch_indexfunc,\n    'linkinfo/project' => \\&pkgsearch_indexfunc,\n    'linkinfo/package' => \\&pkgsearch_indexfunc,\n    'linkinfo/rev' => \\&pkgsearch_indexfunc,\n  };\n  $db->{'noindexatall'} = 1;\n  $db->{'fetch'} = \\&pkgsearch_fetch;\n  my $data = BSXPathKeys::node($db, '');\n  if ($id) {\n    $data = $data->keymatch($match);\n    for (@$data) {\n      my @p = split('/', $_, 2);\n      $_ = {'name' => $p[1], 'project' => $p[0]};\n    }\n  } else {\n    $data = BSXPath::match($data, $match);\n    delete $_->{'linkinfo'} for @$data;\n  }\n  my $res = {'package' => $data};\n  return ($res, $BSXML::collection);\n}\n\nsub search_proj_id {\n  return search_proj(@_, 1);\n}\n\nsub search_pack_id {\n  return search_pack(@_, 1);\n}\n\n#############################################################################\n\nsub search_published_updatedb {\n  my ($cgi) = @_;\n  die(\"unknown command '$cgi->{'cmd'}'\\n\") unless $cgi->{'cmd'} eq 'updatedb';\n  my $data = BSServer::read_data();\n  $data = Storable::thaw($data);\n  die(\"no data\\n\") unless $data && @$data;\n  my $patterndb;\n  my $binarydb;\n  my $repoinfodb;\n  mkdir_p($extrepodb) unless -d $extrepodb;\n  while (@$data) {\n    my ($w, $k, $v) = splice(@$data, 0, 3);\n    if ($w eq 'binary') {\n      $binarydb = BSDB::opendb($extrepodb, 'binary') unless $binarydb;\n      $binarydb->updateindex_rel($k || [], $v || []);\n    } elsif ($w eq 'pattern') {\n      $patterndb = BSDB::opendb($extrepodb, 'pattern') unless $patterndb;\n      $patterndb->store($k, $v);\n    } elsif ($w eq 'repoinfo') {\n      if (!$repoinfodb) {\n        $repoinfodb = BSDB::opendb($extrepodb, 'repoinfo');\n        $repoinfodb->{'noindexatall'} = 1;\n      }\n      $repoinfodb->store($k, $v);\n    } else {\n      die(\"bad data type: '$w'\\n\");\n    }\n  }\n  return $BSStdServer::return_ok;\n}\n\n#sub search_published_id {\n#  my ($cgi, $what, $match) = @_;\n#  my $res;\n#  for my $rrserver ($BSConfig::reposerver) {\n#    $res = BSRPC::rpc(\"$rrserver/search/published/$what/id\", $BSXML::collection, \"match=$match\");\n#    last if $res;\n#  }\n#  return ($res, $BSXML::collection);\n#}\n#\n#sub search_published_binary_id {\n#  return search_published_id($_[0], 'binary', $_[1]);\n#}\n#\n#sub search_published_pattern_id {\n#  return search_published_id($_[0], 'pattern', $_[1]);\n#}\n\nmy %prp_to_repoinfo;\n\nsub prp_to_repoinfo {\n  my ($prp) = @_;\n\n  my $repoinfo = $prp_to_repoinfo{$prp};\n  if (!$repoinfo) {\n    my $repoinfodb = BSDB::opendb($extrepodb, 'repoinfo');\n    $repoinfo = $repoinfodb->fetch($prp);\n    if ($repoinfo) {\n      for (@{$repoinfo->{'prpsearchpath'} || []}) {\n\tnext if ref($_);\t# legacy\n\tmy ($p, $r) = split('/', $_, 2);\n\t$_ = {'project' => $p, 'repository' => $r};\n      }\n    } else {\n      $repoinfo = {'binaryorigins' => {}};\n    }\n    $prp_to_repoinfo{$prp} = $repoinfo;\n  }\n  return $repoinfo;\n}\n\nsub binary_key_to_data {\n  my ($db, $key) = @_; \n  my @p = split('/', $key);\n  my $binary = pop(@p);\n  my $name = $binary;\n  my $versrel = '';\n  if ($name =~ s/-([^-]+-[^-]+)\\.[^\\.]+\\.rpm$//) {\n    $versrel = $1;\n  } elsif ($name =~ s/_([^_]+)_[^_]+\\.deb$//) {\n    $versrel = $1;\n  } elsif ($name =~ s/-([^-]+-[^-]+)-[^-]+\\.pkg\\.tar\\..z$//) {\n    $versrel = $1;\n  }\n  my ($version, $release) = ($versrel, undef);\n  ($version, $release) = ($1, $2) if $version =~ /^(.*)-(.*?)$/;\n  my $arch = pop(@p);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  my $project = shift(@p);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  my $repository = shift(@p);\n  my $prp = \"$project/$repository\";\n  my $repoinfo = $prp_to_repoinfo{$prp} || prp_to_repoinfo($prp);\n  my $type;\n  $type = 'rpm' if $binary =~ /\\.rpm$/;\n  $type = 'deb' if $binary =~ /\\.deb$/;\n  $type = 'arch' if $binary =~ /\\.pkg\\.tar\\..z$/;\n  my $res = {\n    'name' => $name,\n    'versrel' => $versrel,\n    'version' => $version,\n    'arch' => $arch,\n    'type' => $type,\n    'project' => $project,\n    'repository' => $repository,\n    'filename' => $binary,\n    'filepath' => $key,\n  };\n  $res->{'release'} = $release if defined $release;\n  $res->{'path'} = $repoinfo->{'prpsearchpath'} if $repoinfo->{'prpsearchpath'};\n  my $location = join('/', @p, $arch, $binary);\n  $res->{'package'} = $repoinfo->{'binaryorigins'}->{$location} if defined $repoinfo->{'binaryorigins'}->{$location};\n  if ($repoinfo->{'base'}) {\n    $res->{'baseproject'} = $repoinfo->{'base'}->{'project'};\n  } elsif ($res->{'path'}) {\n    $res->{'baseproject'} = $res->{'path'}->[-1]->{'project'};\n  }\n  return $res;\n}\n\nsub binary_key_to_project {\n  my ($db, $key) = @_;  \n  my @p = split('/', $key);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  return shift @p;\n}\n\nsub pattern_key_to_data {\n  my ($db, $key) = @_; \n  my @p = split('/', $key);\n  my $filename = pop(@p);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  my $project = shift(@p);\n  while (@p > 1 && $p[0] =~ /:$/) {\n    splice(@p, 0, 2, \"$p[0]$p[1]\");\n  }\n  my $repository = shift(@p);\n  my @v = BSDBIndex::getvalues($db, $db->{'table'}, $key);\n  return {} unless @v;\n  my $res = $v[0];\n  $res->{'baseproject'} = $res->{'path'}->[-1]->{'project'} if $res->{'path'};\n  $res->{'project'} = $project;\n  $res->{'repository'} = $repository;\n  $res->{'filename'} = $filename;\n  $res->{'filepath'} = $key;\n  return $res;\n}\n\nsub published_projectindexfunc {\n  my ($db, $path, $value) = @_;\n  return findprojects() unless defined $value;\n  my $proj = readproj($value);\n  return () unless $proj;\n  my @repoids = map {$_->{'name'}} @{$proj->{'repository'} || []};\n  my %bins;\n  for my $repoid (@repoids) {\n    my $prp = \"$value/$repoid\";\n    my $prp_ext = $prp;\n    $prp_ext =~ s/:/:\\//g;\n    my $repoinfo = $prp_to_repoinfo{$prp} || prp_to_repoinfo($prp);\n    for (keys %{$repoinfo->{'binaryorigins'} || {}}) {\n      next unless /\\//;\n      # keep in sync with updatebinaryindex in bs_publish\n      next unless /\\.(?:rpm|deb|pkg\\.tar\\..z)$/;\n      $bins{\"$prp_ext/$_\"} = 1;\n    }\n  }\n  return sort keys %bins;\n}\n\nsub search_published_binary_id {\n  my ($cgi, $match) = @_;\n  my $binarydb = BSDB::opendb($extrepodb, 'binary');\n  $binarydb->{'allkeyspath'} = 'name';\n  $binarydb->{'noindex'} = {'version' => 1, 'release' => 1, 'versrel' => 1, 'arch' => 1, 'project' => 1, 'repository' => 1, 'package' => 1, 'type' => 1, 'path/project' => 1, 'path/repository' => 1, 'baseproject' => 1};\n  $binarydb->{'indexfunc'} = {'project' => \\&published_projectindexfunc };\n  $binarydb->{'fetch'} = \\&binary_key_to_data;\n  $binarydb->{'fetch_project'} = \\&binary_key_to_project;\n  $binarydb->{'cheapfetch'} = 1;\n  my $limit = defined($cgi->{'limit'}) ? $cgi->{'limit'} : 1000;\n  my $rootnode = BSXPathKeys::node($binarydb, '', $limit && $limit < 10 ? 1000 : $limit * 100);\n  my $data = BSXPath::match($rootnode, $match) || [];\n  # epoch?\n  @$data = sort {Build::Rpm::verscmp($b->{'version'}, $a->{'version'}) || $a->{'name'} cmp $b->{'name'} || $a->{'arch'} cmp $b->{'arch'}} @$data;\n  delete $_->{'versrel'} for @$data;\n  my $res = {};\n  $res->{'matches'} = @$data;\n  $res->{'limited'} = 'true' if $limit && @$data > $limit;\n  splice(@$data, $limit) if $limit && @$data > $limit;\n  delete $_->{'path'} for @$data;\n  $res->{'binary'} = $data;\n  return ($res, $BSXML::collection);\n}\n\nsub search_published_pattern_id {\n  my ($cgi, $match) = @_;\n  my $patterndb = BSDB::opendb($extrepodb, 'pattern');\n  $patterndb->{'noindex'} = {'project' => 1, 'repository' => 1};\n  $patterndb->{'fetch'} = \\&pattern_key_to_data;\n  my $limit = defined($cgi->{'limit'}) ? $cgi->{'limit'} : 1000;\n  my $rootnode = BSXPathKeys::node($patterndb, '', $limit && $limit < 10 ? 1000 : $limit * 100);\n  my $data = BSXPath::match($rootnode, $match) || [];\n  my $res = {};\n  $res->{'matches'} = @$data;\n  $res->{'limited'} = 'true' if $limit && @$data > $limit;\n  splice(@$data, $limit) if $limit && @$data > $limit;\n  for (@$data) {\n    delete $_->{'path'};\n    delete $_->{'description'};\n    delete $_->{'summary'};\n  }\n  $res->{'pattern'} = $data;\n  return ($res, $BSXML::collection);\n}\n\n#############################################################################\n\nsub search {\n  my ($cgi, $in, $match) = @_;\n  # gather all data\n  my $data = [];\n  if ($in eq 'projects') {\n    for my $projid (findprojects()) {\n      my $proj = readproj($projid);\n      push @$data, $proj;\n    }\n  } elsif ($in eq 'packages') {\n    for my $projid (findprojects()) {\n      my @packages = findpackages($projid, {});\n      for my $packid (@packages) {\n        my ($pack, undef) = getpackage($cgi, $projid, $packid);\n\t$pack->{'project'} = $projid;\n        push @$data, $pack;\n      }\n    }\n  } else {\n    die(\"'in' parameter needs to be either 'projects' or 'packages'\\n\");\n  }\n  my $res;\n  if ($cgi->{'values'}) {\n    $data = BSXPath::valuematch($data, $match);\n    $res = {'value' => $data};\n  } else {\n    $data = BSXPath::match($data, $match);\n    if (exists $cgi->{'return'}) {\n      $data = BSXPath::valuematch($data, $cgi->{'return'});\n      $res = {'value' => $data};\n    } elsif ($in eq 'projects') {\n      $res = {'project' => $data};\n    } else {\n      $res = {'package' => $data};\n    }\n  }\n  return ($res, $BSXML::collection);\n}\n\nsub postrepo {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/_repository\",\n    'request' => 'POST',\n  };\n  my $res = BSWatcher::rpc($param, $BSXML::collection, \"match=$cgi->{'match'}\");\n  return ($res, $BSXML::collection);\n}\n\nsub service {\n  my ($cgi, $service) = @_;\n  die(\"404 no such service '$service'\\n\") unless $BSConfig::serviceserver;\n  return BSWatcher::rpc(\"$BSConfig::serviceserver/service/$service\", undef);\n}\n\nsub listservices {\n  my ($cgi) = @_;\n  return \"<servicelist/>\\n\" unless $BSConfig::serviceserver;\n  return BSWatcher::rpc(\"$BSConfig::serviceserver/service\", undef);\n}\n\nsub published {\n  my ($cgi, $projid, $repoid, $arch, $filename, $subfilename) = @_;\n  my @args;\n  my $projpack;\n  die(\"unknown view '$cgi->{'view'}'\\n\") if $cgi->{'view'} && $cgi->{'view'} ne 'ymp' && $cgi->{'view'} ne 'fileinfo';\n  if (defined($projid) && defined($repoid) && $cgi->{'view'} && $cgi->{'view'} eq 'ymp') {\n    # attach projpack data so that the repo server does not need to\n    # reconnect us\n    $projpack = (getprojpack({'nopackages' => 1, 'withrepos' => 1, 'expandedrepos' => 1}, [ $projid ], [ $repoid ], undef, 'noarch'))[0];\n    my $proj = $projpack->{'project'}->[0];\n    die(\"no such project\\n\") unless $proj && $proj->{'name'} eq $projid;\n    my $repo = $proj->{'repository'}->[0];\n    die(\"no such repository\\n\") unless $repo && $repo->{'name'} eq $repoid;\n    $projpack->{'project'} = [ $proj ];\n    my @nprojids = grep {$_ ne $projid} map {$_->{'project'}} @{$repo->{'path'} || []};\n    @nprojids = unify(@nprojids);\n    for my $nprojid (@nprojids) {\n      my $nproj = (getproject({}, $nprojid))[0];\n      push @{$projpack->{'project'}}, {\n\t'name' => $nprojid,\n\t'title' => $nproj->{'title'} || '',\n\t'description' => $nproj->{'description'} || '',\n      };\n    }\n  }\n  push @args, \"view=$cgi->{'view'}\" if $cgi->{'view'};\n  my $p = \"/published\";\n  $p .= \"/$projid\" if defined $projid;\n  $p .= \"/$repoid\" if defined $repoid;\n  $p .= \"/$arch\" if defined $arch;\n  $p .= \"/$filename\" if defined $filename;\n  $p .= \"/$subfilename\" if defined $subfilename;\n  if (defined($projid) || !$BSConfig::partitioning || !$BSConfig::partitionservers) {\n    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n    my $param = {\n      'uri' => \"$reposerver$p\",\n      'ignorestatus' => 1,\n      'receiver' => \\&BSServer::reply_receiver,\n    };\n    if ($projpack) {\n      $param->{'request'} = 'POST';\n      $param->{'data'} = BSUtil::toxml($projpack, $BSXML::projpack);\n      $param->{'headers'} = [ 'Content-Type: application/octet-stream' ];\n    }\n    BSWatcher::rpc($param, undef, @args);\n    return undef;\n  }\n  my %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);\n  my %pubprojids;\n  for my $reposerver (sort keys %reposervers) {\n    my $res;\n    eval {\n      $res = BSWatcher::rpc(\"$reposerver/published\", $BSXML::dir, @args);\n    };\n    warn($@) if $@;\n    next unless $res;\n    $pubprojids{$_->{'name'}} = 1 for @{$res->{'entry'} || []};\n  }\n  my @res = sort(keys %pubprojids);\n  @res = map {{'name' => $_}} @res;\n  return ({'entry' => \\@res}, $BSXML::dir);\n}\n\nmy $extrepodir = \"$BSConfig::bsdir/repos\";\n\nsub map_to_extrep {\n  my ($prp, $prp_ext) = @_;\n  \n  my $extrep = \"$BSConfig::bsdir/repos/$prp_ext\";\n  return $extrep unless $BSConfig::publishredirect;\n  if ($BSConfig::publishedredirect_use_regex || $BSConfig::publishedredirect_use_regex) {\n    for my $key (sort {$b cmp $a} keys %{$BSConfig::publishredirect}) {\n      if ($prp =~ /^$key/) {\n        $extrep = $BSConfig::publishredirect->{$key};\n        last;\n      }    \n    }    \n  } elsif (exists($BSConfig::publishredirect->{$prp})) {\n    $extrep = $BSConfig::publishredirect->{$prp};\n  }\n  $extrep = $extrep->($prp, $prp_ext) if $extrep && ref($extrep) eq 'CODE';\n  return $extrep;\n}\n\nsub published_path {\n  my ($cgi, $projid, $repoid) = @_;\n  my $medium = $cgi->{'medium'};\n  my $prp = \"$projid/$repoid\";\n  my $prp_ext = $prp;\n  my $ret = {'project' => $projid, 'repository' => $repoid};\n  $ret->{'medium'} = $medium if $medium;\n  $prp_ext =~ s/:/:\\//g;\n  my $extrep = map_to_extrep($prp, $prp_ext);\n  $extrep = [ $extrep ] unless ref $extrep;\n  my ($path, $url) = ($extrep->[1], $extrep->[2]);\n  # update to get fresh version of repodownload\n  BSConfiguration::update_from_configuration();\n  if ($BSConfig::prp_ext_map && $BSConfig::prp_ext_map->{$prp}) {\n    $url = $BSConfig::prp_ext_map->{$prp} unless defined $url;\n  }\n  if ($extrep->[0] =~ /^\\Q$BSConfig::bsdir\\E\\/repos\\/(.*)$/) {\n    $path = $1 unless defined $path;\n    if ($BSConfig::repodownload) {\n      $url = \"$BSConfig::repodownload/\".BSRPC::urlencode($1) unless defined $url;\n    }\n  }\n  if ($cgi->{'filename'}) {\n    # called from getbinary\n    my $bin = $cgi->{'filename'};\n    my $p;\n    if ($bin =~ /^.+-[^-]+-[^-]+\\.([a-zA-Z][^\\/\\.\\-]*)\\.d?rpm$/) {\n      $p = \"$1/$bin\";\n    } elsif ($bin =~ /^.+_[^_]+_([^_\\.]+)\\.deb$/) {\n      $p = \"$1/$bin\";\n    } elsif ($bin =~ /\\.exe$/) {\n      $p = $bin;\n    } elsif ($bin =~ /\\.(?:pkg\\.tar\\.gz|pkg\\.tar\\.xz)$/) {\n      $p = ($cgi->{'arch'} eq 'i586' ? 'i686' : $cgi->{'arch'}).\"/$bin\";\n    } elsif ($bin =~ /\\.iso(?:\\.report)$/) {\n      $p = \"iso/$bin\";\n    } elsif ($bin =~ /-Media\\d+$/) {\n      $medium = $bin;\n    }\n    if (defined $p) {\n      $path .= \"/$p\" if defined $path;\n      $url .= \"/\".BSRPC::urlencode($p) if defined $url;\n    }\n  }\n  if ($medium && $medium =~ /\\.iso$/) {\n    $medium = \"iso/$medium\";\n  } elsif ($medium) {\n    my @path = expandsearchpath($projid, $repoid);\n    my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);\n    my $bconf = Build::read_config('noarch', [ split(\"\\n\", $c) ]);\n    my %repotype;\n    for (@{$bconf->{'repotype'} || []}) {\n      if (/^(.*?):(.*)$/) {\n        $repotype{$1} = [ split(':', $2) ];\n      } else {\n        $repotype{$_} = [];\n      }    \n    }\n    if ($repotype{'slepool'}) {\n      my $name = $repotype{'slepool'}->[0] || 'product';\n      if ($medium =~ /-Media1$/) {\n\t$medium = $name;\n      } elsif ($medium =~ /-Media3$/) {\n\t$medium = \"${name}_debug\";\n      } elsif ($medium =~ /-Media2$/) {\n        my $repoinfo;\n\teval {\n\t  $repoinfo = $prp_to_repoinfo{$prp};\n\t};\n\tmy $binaryorigins = ($repoinfo || {})->{'binaryorigins'};\n\t$medium = $binaryorigins->{\"${name}_source\"} ? \"${name}_source\" : \"${name}_debug\";\n      }\n    } else {\n      $medium = \"repo/$medium\";\n    }\n  }\n  if ($medium) {\n    $path .= \"/$medium\" if defined $path;\n    $url .= \"/\".BSRPC::urlencode($medium) if defined $url;\n  }\n  $ret->{'path'} = $path if defined $path;\n  $ret->{'url'} = $url if defined $url;\n  return ($ret, $BSXML::publishedpath);\n}\n  \n\nsub pkdecodetaglenoff {\n  my ($pkg) = @_;\n  my $tag = unpack('C', $pkg);\n  die(\"not a gpg packet\\n\") unless $tag & 128;\n  my $len;\n  my $off = 1;\n  if ($tag & 64) {\n    # new packet format\n    $tag &= 63; \n    $len = unpack('C', substr($pkg, 1));\n    if ($len < 192) {\n      $off = 2;\n    } elsif ($len != 255) {\n      $len = (($len - 192) << 8) + unpack('C', substr($pkg, 2)) + 192;\n      $off = 3;\n    } else {\n      $len = unpack('N', substr($pkg, 2));\n      $off = 5;\n    }   \n  } else {\n    # old packet format\n    if (($tag & 3) == 0) {\n      $len = unpack('C', substr($pkg, 1));\n      $off = 2;\n    } elsif (($tag & 3) == 1) {\n      $len = unpack('n', substr($pkg, 1));\n      $off = 3;\n    } elsif (($tag & 3) == 1) {\n      $len = unpack('N', substr($pkg, 1));\n      $off = 6;\n    } else {\n      die(\"can't deal with not specified packet length\\n\");\n    }   \n    $tag = ($tag & 60) >> 2;\n  }\n  return ($tag, $len, $off);\n}\n\nsub pk2expire {\n  my ($pk) = @_;\n  # oh my! hard work!\n  $pk =~ s/.*\\n\\n//s;\n  $pk =~ s/\\n=.*/\\n/s;\n  $pk = MIME::Base64::decode($pk);\n  return 0 unless $pk;\n  my ($rex, $rct);\n  eval {\n    while ($pk ne '') {\n      my ($tag, $len, $off) = pkdecodetaglenoff($pk);\n      my $pack = substr($pk, $off, $len);\n      $pk = substr($pk, $len + $off);\n      next if $tag != 2;\n      my $sver = unpack('C', substr($pack, 0, 1));\n      next unless $sver == 4;\n      my $stype = unpack('C', substr($pack, 1, 1));\n      next unless $stype == 19; # positive certification of userid and pubkey\n      my $plen = unpack('n', substr($pack, 4, 2));\n      $pack = substr($pack, 6, $plen);\n      my ($ct, $ex);\n      while ($pack ne '') {\n        $pack = pack('C', 0xc0).$pack;\n        my ($stag, $slen, $soff) = pkdecodetaglenoff($pack);\n        my $spack = substr($pack, $soff, $slen);\n        $pack = substr($pack, $slen + $soff);\n        $stag = unpack('C', substr($spack, 0, 1));\n        $ct = unpack('N', substr($spack, 1, 4)) if $stag == 2;\n        $ex = unpack('N', substr($spack, 1, 4)) if $stag == 9;\n      }\n      $rex = $ex if defined($ex) && (!defined($rex) || $rex > $ex);\n      $rct = $ct if defined($ct) && (!defined($rct) || $rct > $ct);\n    }\n  };\n  return 0 if $@;\n  return defined($rct) && defined($rex) ? $rct + $rex : undef;\n}\n\nsub getsignkey {\n  my ($cgi, $projid) = @_;\n\n  while ($projid ne '') {\n    my $sk = readstr(\"$projectsdir/$projid.pkg/_signkey\", 1);\n    if ($sk) {\n      if ($cgi->{'withpubkey'}) {\n        my $pk = readstr(\"$projectsdir/$projid.pkg/_pubkey\", 1);\n        if ($pk && $cgi->{'autoextend'}) {\n\t  my $expiredate = pk2expire($pk);\n\t  if ($expiredate && $expiredate < time() + 24 * 3600) {\n\t    extendkey({'comment' => 'auto-extend public key expiry date'}, $projid);\n            $pk = readstr(\"$projectsdir/$projid.pkg/_pubkey\", 1);\n\t  }\n\t}\n        $sk .= \"\\n\" unless $sk =~ /\\n$/s;\n        $sk .= $pk;\n      }\n      return ($sk, 'Content-Type: text/plain') if $sk;\n    }\n    $projid =~ s/[^:]*$//;\n    $projid =~ s/:$//;\n  }\n  return ('', 'Content-Type: text/plain');\n}\n\nsub getsslcert {\n  my ($cgi, $projid) = @_;\n\n  my $origprojid = $projid;\n  while ($projid ne '') {\n    my $sk = readstr(\"$projectsdir/$projid.pkg/_signkey\", 1);\n    if (!$sk) {\n      $projid =~ s/[^:]*$//;\n      $projid =~ s/:$//;\n      next;\n    }\n    my $pk = readstr(\"$projectsdir/$projid.pkg/_pubkey\", 1);\n    if ($pk && $cgi->{'autoextend'}) {\n      my $expiredate = pk2expire($pk);\n      if ($expiredate && $expiredate < time() + 24 * 3600) {\n        extendkey({'comment' => 'auto-extend public key expiry date'}, $projid);\n      }\n    }\n    my $rev = getrev_meta($projid, undef);\n    my $files = lsrev($rev);\n    my $cert;\n    if (!$files->{'_sslcert'}) {\n      # length(signkey) <= 2 means special handling, don't commit it\n      if (length($sk) <= 2) {\n        $cert = pubkey2sslcert($origprojid, \"$projectsdir/$projid.pkg/_pubkey\");\n        return ($cert, 'Content-Type: text/plain');\n      }\n      $cert = pubkey2sslcert($projid);\n      mkdir_p($uploaddir);\n      writestr(\"$uploaddir/sslcert.$$\", undef, $cert);\n      addrev_meta({'comment' => 'automatic cert creation'}, $projid, undef, \"$uploaddir/sslcert.$$\", undef, '_sslcert');\n    } else {\n      $cert = repreadstr($rev, '_sslcert', $files->{'_sslcert'});\n    }\n    return ($cert, 'Content-Type: text/plain');\n  }\n  if ($BSConfig::sign_project && $BSConfig::sign) {\n    # request default cert\n    my $cert = '';\n    local *F;\n    open(F, '-|', $BSConfig::sign, '--project', $origprojid, '-C') || die(\"$BSConfig::sign: $!\\n\");\n    1 while sysread(F, $cert, 4096, length($cert));\n    close(F) || die(\"$BSConfig::sign: $?\\n\");\n    return ($cert, 'Content-Type: text/plain');\n  }\n  return ('', 'Content-Type: text/plain');\n}\n\n####################################################################\n\n# needed for migrations to 2.4\nsub getlastidrequest {\n  my $lastid = readstr(\"$requestsdir/.nextid\", 1) - 1;\n  \n  return (\"$lastid\", 'Content-Type: text/plain');\n}\n\n# needed for migrations to 2.4\nsub getrequest {\n  my ($cgi, $id) = @_;\n  local *F;\n  my $rdir = $requestsdir;\n  if (!open(F, '<', \"$rdir/$id\")) {\n    $rdir = $oldrequestsdir;\n    if (!open(F, '<', \"$rdir/$id\")) {\n      die(\"404 no such request '$id'\\n\");\n    }\n  }\n  my $reqxml = '';\n  1 while sysread(F, $reqxml, 8192, length($reqxml));\n  my @s = stat(F);\n  close F;\n  die unless @s;\n  my $req = XMLin($BSXML::request, $reqxml);\n  return ($req, $BSXML::request);\n}\n\n####################################################################\n\nsub findremote {\n  my ($projid) = @_;\n\n  my $proj = readproj($projid, 1);\n  if ($proj) {\n    if (!$proj->{'remoteurl'}) {\n      my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n      return ($reposerver, $projid, undef);\n    }\n    die(\"no remoteproject specified\\n\") unless $proj->{'remoteproject'};\n    return ($proj->{'remoteurl'}, $proj->{'remoteproject'}, $proxy);\n  }\n  my $origprojid = $projid;\n  my $rsuf = '';\n  while ($projid =~ /^(.*)(:.*?)$/) {\n    $projid = $1;\n    $rsuf = \"$2$rsuf\";\n    $proj = readproj($projid, 1);\n    next unless $proj;\n    die(\"404 project '$origprojid' does not exist\\n\") unless $proj->{'remoteurl'};\n    if ($proj->{'remoteproject'}) {\n      return ($proj->{'remoteurl'}, \"$proj->{'remoteproject'}$rsuf\", $proxy);\n    }\n    $rsuf =~ s/^://;\n    return ($proj->{'remoteurl'}, $rsuf, $proxy);\n  }\n  die(\"404 project '$origprojid' does not exist\\n\");\n}\n\nsub worker_getbinaries {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  if (!$BSStdServer::isajax) {\n    my @args;\n    push @args, \"project=$projid\";\n    push @args, \"repository=$repoid\";\n    push @args, \"arch=$arch\";\n    push @args, \"binaries=$cgi->{'binaries'}\";\n    BSHandoff::handoff($ajaxsocket, '/getbinaries', undef, @args);\n    exit(0);\n  }\n  my @binaries = split(',', $cgi->{'binaries'});\n  my ($remoteurl, $remoteprojid, $remoteproxy) = findremote($projid);\n\n  my $jev = $BSServerEvents::gev;\n  my $binarylist;\n  $binarylist = $jev->{'binarylist'} if $BSStdServer::isajax;\n  $binarylist ||= {};\n  $jev->{'binarylist'} = $binarylist if $BSStdServer::isajax;\n\n  # fill binarylist\n  my @missing = grep {!exists $binarylist->{$_}} @binaries;\n  while (@missing) {\n    my $param = {\n      'uri' => \"$remoteurl/build/$remoteprojid/$repoid/$arch/_repository\",\n      'proxy' => $remoteproxy,\n    };\n    # chunk it\n    my $binchunkl = 0;\n    for (splice @missing) {\n      $binchunkl += 10 + length($_);\n      last if @missing && $binchunkl > 1900;\n      push @missing, $_;\n    }\n    my $binarylistcpio = BSWatcher::rpc($param, $BSXML::binarylist, \"view=names\", map {\"binary=$_\"} @missing);\n    return undef if $BSStdServer::isajax && !$binarylistcpio;\n    for my $b (@{$binarylistcpio->{'binary'} || []}) {\n      my $bin = $b->{'filename'};\n      $bin =~ s/\\.(?:$binsufsre)$//;\n      $binarylist->{$bin} = $b;\n    }\n    # make sure that we don't loop forever if the server returns incomplete data\n    for (@missing) {\n      $binarylist->{$_} = {'filename' => $_, 'size' => 0} unless $binarylist->{$_};\n    }\n    @missing = grep {!exists $binarylist->{$_}} @binaries;\n  }\n\n  my @fetch;\n  my @reply;\n  local *LOCK;\n  mkdir_p($remotecache);\n  BSUtil::lockopen(\\*LOCK, '>>', \"$remotecache/lock\");\n  for my $bin (@binaries) {\n    my $b = $binarylist->{$bin};\n    if (!$b || !$b->{'size'} || !$b->{'mtime'}) {\n      push @reply, {'name' => $bin, 'error' => 'not available'};\n      next;\n    }\n    my $cachemd5 = Digest::MD5::md5_hex(\"$projid/$repoid/$arch/$bin\");\n    substr($cachemd5, 2, 0, '/');\n    my @s = stat(\"$remotecache/$cachemd5\");\n    if (!@s || $s[9] != $b->{'mtime'} || $s[7] != $b->{'size'}) {\n      push @fetch, $bin;\n    } else {\n      utime time(), $s[9], \"$remotecache/$cachemd5\";\n      push @reply, {'name' => $b->{'filename'}, 'filename' => \"$remotecache/$cachemd5\"};\n    }\n  }\n  my $slot = sprintf(\"%02x\", (int(rand(256))));\n  print \"cleaning slot $slot\\n\";\n  if (-d \"$remotecache/$slot\") {\n    my $now = time();\n    my $num = 0;\n    for my $f (ls(\"$remotecache/$slot\")) {\n      my @s = stat(\"$remotecache/$slot/$f\");\n      next if $s[8] >= $now - 24*3600;\n      unlink(\"$remotecache/$slot/$f\");\n      $num++;\n    }\n    print \"removed $num unused files\\n\" if $num;\n  }\n  close(LOCK);\n\n  if (@fetch) {\n    my $serialmd5 = Digest::MD5::md5_hex(\"$projid/$repoid/$arch\");\n\n    # serialize this upload\n    my $serial = BSWatcher::serialize(\"$remotecache/$serialmd5.lock\");\n    return undef unless $serial;\n\n    print \"fetch: @fetch\\n\";\n    my %fetch = map {$_ => $binarylist->{$_}} @fetch;\n    my $param = {\n      'uri' => \"$remoteurl/build/$remoteprojid/$repoid/$arch/_repository\",\n      'receiver' => \\&BSHTTP::cpio_receiver,\n      'tmpcpiofile' => \"$remotecache/upload$serialmd5.cpio\",\n      'directory' => $remotecache,\n      'map' => \"upload$serialmd5:\",\n      'proxy' => $remoteproxy,\n    };\n    # work around api bug: only get 50 packages at a time\n    @fetch = splice(@fetch, 0, 50) if @fetch > 50;\n    my $cpio = BSWatcher::rpc($param, undef, \"view=cpio\", map {\"binary=$_\"} @fetch);\n    return undef if $BSStdServer::isajax && !$cpio;\n    for my $f (@{$cpio || []}) {\n      my $bin = $f->{'name'};\n      $bin =~ s/^upload.*?://;\n      $bin =~ s/\\.(?:$binsufsre)$//;\n      if (!$fetch{$bin}) {\n        unlink(\"$remotecache/$f->{'name'}\");\n\tnext;\n      }\n      $binarylist->{$bin}->{'size'} = $f->{'size'};\n      $binarylist->{$bin}->{'mtime'} = $f->{'mtime'};\n      my $cachemd5 = Digest::MD5::md5_hex(\"$projid/$repoid/$arch/$bin\");\n      substr($cachemd5, 2, 0, '/');\n      mkdir_p(\"$remotecache/\".substr($cachemd5, 0, 2));\n      rename(\"$remotecache/$f->{'name'}\", \"$remotecache/$cachemd5\");\n      push @reply, {'name' => $fetch{$bin}->{'filename'}, 'filename' => \"$remotecache/$cachemd5\"};\n      delete $fetch{$bin};\n    }\n    BSWatcher::serialize_end($serial);\n\n    if (@{$cpio || []} >= 50) {\n      # work around api bug: get rest\n      delete $jev->{'binarylist'} if $BSStdServer::isajax;\n      return worker_getbinaries($cgi, $projid, $repoid, $arch);\n    }\n\n    for (sort keys %fetch) {\n      push @reply, {'name' => $_, 'error' => 'not available'};\n    }\n  }\n  if ($cgi->{'raw'}) {\n    die(\"can only transport one binary in raw mode\\n\") unless @reply == 1;\n    my $f = $reply[0];\n    die(\"$f->{'name'}: $f->{'error'}\\n\") if $f->{'error'};\n    die(\"$f->{'name'}: not found\\n\") unless $f->{'filename'};\n    BSWatcher::reply_file($f->{'filename'});\n    return undef;\n  }\n  BSWatcher::reply_cpio(\\@reply);\n  return undef;\n}\n\nsub worker_getbinaryversions {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  if (0 && !$BSStdServer::isajax) {\n    my @args;\n    push @args, \"project=$projid\";\n    push @args, \"repository=$repoid\";\n    push @args, \"arch=$arch\";\n    push @args, \"binaries=$cgi->{'binaries'}\";\n    push @args, \"nometa=1\" if $cgi->{'nometa'};\n    BSHandoff::handoff($ajaxsocket, '/getbinaryversions', undef, @args);\n    exit(0);\n  }\n  my @binaries = split(',', $cgi->{'binaries'});\n  my ($remoteurl, $remoteprojid, $remoteproxy) = findremote($projid);\n\n  my $jev = $BSServerEvents::gev;\n  my $binaryversions;\n  $binaryversions = $jev->{'binaryversions'} if $BSStdServer::isajax;\n  $binaryversions ||= {};\n  $jev->{'binaryversions'} = $binaryversions if $BSStdServer::isajax;\n\n  # fill binaryversions\n  my @missing = grep {!exists $binaryversions->{$_}} @binaries;\n  while (@missing) {\n    # chunk it\n    my $binchunkl = 0;\n    for (splice @missing) {\n      $binchunkl += 10 + length($_);\n      last if @missing && $binchunkl > 1900;\n      push @missing, $_;\n    }\n    my $param = {\n      'uri' => \"$remoteurl/build/$remoteprojid/$repoid/$arch/_repository\",\n      'proxy' => $remoteproxy,\n    };\n    my $bvl = BSWatcher::rpc($param, $BSXML::binaryversionlist, 'view=binaryversions', 'nometa=1', map {\"binary=$_\"} @missing);\n    return undef if $BSStdServer::isajax && !$bvl;\n    for (@{$bvl->{'binary'} || []}) {\n      my $bin = $_->{'name'};\n      $bin =~ s/\\.(?:$binsufsre)$//;\n      $binaryversions->{$bin} = $_;\n    }\n    # make sure that we don't loop forever if the server returns incomplete data\n    for (@missing) {\n      $binaryversions->{$_} = {'name' => $_, 'error' => 'not available'} unless $binaryversions->{$_};\n    }\n    @missing = grep {!exists $binaryversions->{$_}} @binaries;\n  }\n  my $bvl = {};\n  $bvl->{'binary'} = [ map {$binaryversions->{$_}} @binaries];\n  return ($bvl, $BSXML::binaryversionlist);\n}\n\n# this is shared for AJAX requests\nmy @lastev_cache;\nmy @lastev_stat;\n\nsub lastevents {\n  my ($cgi, $filter) = @_;\n  if (!$cgi->{'start'}) {\n    # just fetch the current event number\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastevents\", $eventlay);\n    my $lastno = $lastev ? $lastev->{'number'} : 0;\n    my $ret = {'next' => $lastno, 'sync' => 'lost'};\n    return ($ret, $BSXML::events);\n  }\n  if (!$BSStdServer::isajax) {\n    my @args;\n    push @args, \"obsname=$cgi->{'obsname'}\" if $cgi->{'obsname'};\n    push @args, map {\"filter=$_\"} @{$filter || []};\n    push @args, \"start=$cgi->{'start'}\";\n    BSHandoff::handoff($ajaxsocket, '/lastevents', undef, @args);\n    exit(0);\n  }\n  BSWatcher::addfilewatcher(\"$eventdir/lastevents\");\n\n  my @s = stat(\"$eventdir/lastevents\");\n  my @events;\n  my ($firstno, $nextno);\n  if (@s && @lastev_stat && \"$s[9]/$s[7]/$s[1]\" eq \"$lastev_stat[9]/$lastev_stat[7]/$lastev_stat[1]\") {\n    @events = @lastev_cache;\n  } else {\n    my $lastev = BSFileDB::fdb_getlast(\"$eventdir/lastevents\", $eventlay);\n    push @events, $lastev if $lastev;\n    @lastev_cache = @events;\n    @lastev_stat = @s;\n  }\n  $firstno = @events ? $events[0]->{'number'} : 0;\n  $nextno = @events ? $events[-1]->{'number'} + 1 : 1;\n\n  if ($cgi->{'start'} < $firstno) {\n    # get last 5\n    @events = BSFileDB::fdb_getall_reverse(\"$eventdir/lastevents\", $eventlay, 5);\n    @events = reverse @events;\n    @lastev_cache = @events;\n    @lastev_stat = @s;\n    $firstno = @events ? $events[0]->{'number'} : 0;\n    $nextno = @events ? $events[-1]->{'number'} + 1 : 1;\n  }\n\n  if ($cgi->{'start'} < $firstno) {\n    my $cnt = $nextno - $cgi->{'start'};\n    if ($cnt > 5) {\n      @events = BSFileDB::fdb_getall_reverse(\"$eventdir/lastevents\", $eventlay, $cnt);\n      @events = reverse @events;\n      if (@events < 20) {\n        @lastev_cache = @events;\n        @lastev_stat = @s;\n      }\n      $firstno = @events ? $events[0]->{'number'} : 0;\n      $nextno = @events ? $events[-1]->{'number'} + 1 : 1;\n    }\n  }\n\n  if ($cgi->{'start'} < $firstno) {\n    # we have to get them all\n    @events = BSFileDB::fdb_getall(\"$eventdir/lastevents\", $eventlay);\n    # re-calculate in case something has changed\n    $firstno = @events ? $events[0]->{'number'} : 0;\n    $nextno = @events ? $events[-1]->{'number'} + 1 : 1;\n    if ($firstno > $cgi->{'start'}) {\n      # out of sync!\n      return ({'next' => $nextno, 'sync' => 'lost'}, $BSXML::events);\n    }\n  }\n\n  # filter\n  @events = grep {$_->{'number'} >= $cgi->{'start'}} @events;\n  if ($filter && @events) {\n    my %filter = map {$_ => 1} @$filter;\n    for my $ev (splice @events) {\n      if ($ev->{'type'} eq 'package') {\n        next unless defined $ev->{'package'};\n        next unless $filter{\"package/$ev->{'project'}/$ev->{'package'}\"} || $filter{\"package/$ev->{'project'}\"};\n      } elsif ($ev->{'type'} eq 'project') {\n        next unless $filter{\"project/$ev->{'project'}\"};\n      } elsif ($ev->{'type'} eq 'repository') {\n        next unless $filter{\"repository/$ev->{'project'}/$ev->{'repository'}/$ev->{'arch'}\"};\n      } else {\n\tnext;\n      }\n      push @events, $ev;\n    }\n  }\n  # return a sync reply every 100 events / 5 minutes for two reasons\n  # - get rid of old peers\n  # - survive history truncation\n  $cgi->{'start_orig'} ||= $cgi->{'start'};\n  $cgi->{'req_time'} ||= time();\n  if ($BSStdServer::isajax && !@events && $nextno < $cgi->{'start_orig'} + 100 && $s[9] < $cgi->{'req_time'} + 300) {\n    # small hack: update cgi to the next event number\n    $cgi->{'start'} = $nextno if $cgi->{'start'} < $nextno;\n    return undef;\n  }\n  for (@events) {\n    $_ = { %$_ };\t# clone em\n    # delete unwanted fields\n    delete $_->{'time'};\n    delete $_->{'number'};\n    # clean up a bit\n    delete $_->{'package'} unless defined($_->{'package'}) && $_->{'package'} ne '';\n  }\n  my $ret = {'next' => $nextno};\n  $ret->{'event'} = \\@events if @events;\n  return ($ret, $BSXML::events);\n}\n\n#\n# add an event to the \"lastevents\" queue used in the build service\n# interconnect implementation\n#\nsub addevent {\n  my ($ev) = @_;\n\n  # check the \"access\" flag. if the project has access turned\n  # off, do not add it to lastevents.\n  # XXX: maybe better to add a \"noaccess\" marker to the event\n  # and filter in the request\n  if (defined($ev->{'project'})) {\n    my $access = 1;\n    my $proj = readproj($ev->{'project'}, 1);\n    if ($proj && $proj->{'access'}) {\n      $access = BSUtil::enabled('', $proj->{'access'}, $access, '');\n    }\n    # XXX: may also check packages in the future\n    return unless $access;\n  }\n  $ev->{'time'} = time();\n  mkdir_p($eventdir);\n  my $size = 262144;\t#keep at least 256k of data\n  if (-s \"$eventdir/lastevents\" && -s _ >= $size * 2) {\n    local *F;\n    BSUtil::lockopen(\\*F, '+>>', \"$eventdir/lastevents\");\n    my $events = readstr(\"$eventdir/lastevents\");\n    if (length($events) >= $size * 2) {\n      $events = substr($events, -$size);\n      $events =~ s/^[^\\n]*\\n//s;\n      writestr(\"$eventdir/.lastevents\", \"$eventdir/lastevents\", $events);\n    }\n    close F;\n  }\n  BSFileDB::fdb_add_i(\"$eventdir/lastevents\", $eventlay, $ev);\n}\n\nsub newevent {\n  my ($cgi) = @_;\n  my $ev = {};\n  for ('type', 'project', 'package', 'repository', 'arch', 'job') {\n    $ev->{$_} = $cgi->{$_} if defined $cgi->{$_};\n  }\n  addevent($ev);\n  return $BSStdServer::return_ok;\n}\n\nsub getrelsync {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n  checkprojrepoarch($projid, $repoid, $arch);\n  my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$reposerver/build/$projid/$repoid/$arch/_relsync\",\n    'ignorestatus' => 1,\n    'receiver' => \\&BSServer::reply_receiver,\n  };\n  BSWatcher::rpc($param, undef);\n  return undef;\n}\n\nsub postrelsync {\n  my ($cgi, $projid, $repoid, $arch) = @_;\n\n  my $proj = checkprojrepoarch($projid, $repoid, $arch);\n  my $repo = (grep {$_->{'name'} eq $repoid} @{$proj->{'repository'} || []})[0];\n  my $relsyncdata = BSServer::read_data(10000000);\n  for my $a (@{$repo->{'arch'} || []}) {\n    next if $a eq $arch;\n    next if $BSConfig::relsync_pool && ($BSConfig::relsync_pool->{$arch} || '') ne ($BSConfig::relsync_pool->{$a} || '');\n    my $reposerver = $BSConfig::partitioning ? projid2reposerver($projid) : $BSConfig::reposerver;\n    my $param = {\n      'uri' => \"$reposerver/build/$projid/$repoid/$a/_relsync\",\n      'request' => 'POST',\n      'data' => $relsyncdata,\n    };\n    eval {\n      BSRPC::rpc($param);\n    };\n    if ($@) {\n      warn($@);\n    }\n  }\n  return $BSStdServer::return_ok;\n}\n\n# XXX: support multiple dispatchers\nsub putdispatchprios {\n  my ($cgi) = @_;\n  my $dispatcher = $BSConfig::masterdispatcher || $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$dispatcher/build/_dispatchprios\",\n    'request' => 'PUT',\n    'data' => \\&BSServer::forward_sender,\n    'chunked' => 1,\n  };\n  return BSWatcher::rpc($param, undef);\n}\n\nsub getdispatchprios {\n  my ($cgi) = @_;\n  my $dispatcher = $BSConfig::masterdispatcher || $BSConfig::reposerver;\n  my $param = {\n    'uri' => \"$dispatcher/build/_dispatchprios\",\n    'ignorestatus' => 1,\n    'receiver' => \\&BSServer::reply_receiver,\n  };\n  BSWatcher::rpc($param, undef);\n  return undef;\n}\n\nsub sourceinfo {\n  my ($cgi, $projid, $packid, $bconf) = @_;\n  my $r = {'package' => $packid};\n  my $linked = [];\n  my $rev;\n  my $files;\n  eval {\n    $rev = getrev($projid, $packid, defined($cgi->{'rev'}) ? $cgi->{'rev'} : 'build', $linked);\n    $r->{'srcmd5'} = $rev->{'srcmd5'} if $rev->{'srcmd5'} ne 'empty';\n    $r->{'rev'} = $rev->{'rev'} if $rev->{'rev'};\n    $r->{'vrev'} = $rev->{'vrev'} if $rev->{'vrev'};\n    if (!$rev || $rev->{'srcmd5'} eq 'empty' || $rev->{'srcmd5'} eq $emptysrcmd5) {\n      die(\"no source uploaded\\n\") unless $cgi->{'nofilename'};\n      $rev = {'srcmd5' => $emptysrcmd5, 'project' => $projid, 'package' => $packid };\n    }\n    my $linkinfo = {};\n    $files = lsrev($rev, $linkinfo);\n    if ($linkinfo->{'xservicemd5'}) {\n      $files = handleservice($rev, $files, $linkinfo->{'xservicemd5'});\n      $r->{'srcmd5'} = $rev->{'srcmd5'};\n    }\n    my $meta = '';\n    $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n    $r->{'verifymd5'} = Digest::MD5::md5_hex($meta);\n    die(\"source update running\\n\") if $files->{'_service'} && -e \"$eventdir/service/${projid}::$packid\";\n    die(\"source update failed\\n\") if $files->{'_service_error'};\n  };\n  $r->{'originproject'} = $rev->{'originproject'} if $rev && $rev->{'originproject'};\n  $r->{'linked'} = $linked if @$linked;\n  if ($@) {\n    $r->{'error'} = $@;\n    $r->{'error'} =~ s/\\n$//s;\n    return $r;\n  }\n  if ($files->{'_link'}) {\n    $rev->{'linkrev'} = $cgi->{'linkrev'} if $cgi->{'linkrev'};\n    eval {\n      $files = handlelinks($rev, $files, {'linked' => $linked});\n    };\n    if ($@) {\n      $files = \"$@\";\n      $files =~ s/\\n$//;\n    }\n    $r->{'linked'} = $linked if @$linked;\n    $r->{'vrev'} = $rev->{'vrev'} if $rev->{'vrev'};\n    if (!ref $files) {\n      $r->{'error'} = $files || 'could not get file list';\n      return $r;\n    }\n    $r->{'lsrcmd5'} = $r->{'srcmd5'};\n    $r->{'srcmd5'} = $rev->{'srcmd5'};\n    my $meta = '';\n    $meta .= \"$files->{$_}  $_\\n\" for sort keys %$files;\n    $r->{'verifymd5'} = Digest::MD5::md5_hex($meta);\n  }\n  if ($cgi->{'withchangesmd5'}) {\n    $r->{'revtime'} = $rev->{'time'};\n    $r->{'changesmd5'} = $files->{\"$packid.changes\"} if $files->{\"$packid.changes\"};\n  }\n  return $r if $cgi->{'nofilename'};\n  return $r if $packid eq '_pattern';\n  if ($files->{'_aggregate'}) {\n    $r->{'filename'} = '_aggregate';\n    return $r;\n  } elsif ($files->{'_patchinfo'}) {\n    $r->{'filename'} = '_patchinfo';\n    return $r;\n  }\n  my $type = $bconf->{'type'};\n  my $file;\n  if (!$type || $type eq 'UNDEFINED') {\n    undef $type;\n    for my $t ('spec', 'dsc', 'kiwi') {\n      (undef, $file) = findfile($rev, $cgi->{'repository'}, $t, $files);\n      next unless defined $file;\n      $type = $t;\n      last;\n    }\n  } else {\n    (undef, $file) = findfile($rev, $cgi->{'repository'}, $type, $files);\n  }\n  if (!$type) {\n    $r->{'error'} = 'bad build configuration, no build type defined or detected';\n    return $r;\n  }\n  if (!$file) {\n    $r->{'error'} = \"no file found for build type '$type'\";\n    return $r;\n  }\n  $r->{'filename'} = $file;\n  return $r unless $cgi->{'parse'};\n  my $buildtype = Build::recipe2buildtype($file);\n  if (!$buildtype) {\n    $r->{'error'} = \"don't know how to build $file\";\n    return $r;\n  }\n  my $d = Build::parse_typed($bconf, \"$srcrep/$packid/$files->{$file}-$file\", $buildtype);\n  if (!$d) {\n    $r->{'error'} = \"parse error\";\n    return $r;\n  }\n  for (qw{name version release subpacks deps prereqs exclarch badarch}) {\n    $r->{$_} = $d->{$_} if defined $d->{$_};\n  }\n  return $r;\n}\n\nsub getprojectsourceinfo {\n  my ($cgi, $projid) = @_;\n  my $proj = checkprojrepoarch($projid, $cgi->{'repository'}, $cgi->{'arch'}, 1);\n  my @packages = @{$cgi->{'package'} || []};\n  $frozenlinks_cache = {};\n  @packages = findpackages($projid, $proj) unless @packages;\n  my $bconf;\n  if (!$cgi->{'nofilename'}) {\n    if (!$cgi->{'repository'}) {\n      my $cfile;\n      $cfile = \"$projectsdir/$projid.conf\" if -e \"$projectsdir/$projid.conf\";\n      $bconf = Build::read_config($cgi->{'arch'} || 'noarch', $cfile);\n    } else {\n      my @path = expandsearchpath($projid, $cgi->{'repository'});\n      my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);\n      $bconf = Build::read_config($cgi->{'arch'} || 'noarch', [ split(\"\\n\", $c) ]);\n    }\n  }\n  my @res;\n  if (@packages > 1) {\n    $collect_remote_getrev = 1;\n    for my $packid (splice @packages) {\n      my $r = sourceinfo($cgi, $projid, $packid, $bconf);\n      if ($r->{'error'} && $r->{'error'} =~ /collect_remote_getrev$/) {\n\tpush @packages, $packid;\n\tnext;\n      }\n      push @res, $r;\n    }\n    $collect_remote_getrev = 0;\n    fill_remote_getrev_cache();\n  }\n  for my $packid (@packages) {\n    push @res, sourceinfo($cgi, $projid, $packid, $bconf);\n  }\n  $frozenlinks_cache = undef;\n  return ({'sourceinfo' => \\@res}, $BSXML::sourceinfolist);\n}\n\nsub getpackagesourceinfo {\n  my ($cgi, $projid, $packid) = @_;\n  checkprojrepoarch($projid, $cgi->{'repository'}, $cgi->{'arch'}, 1); #remoteok\n  my $bconf;\n  if (!$cgi->{'nofilename'}) {\n    my $cfile;\n    if (!$cgi->{'repository'}) {\n      $cfile = \"$projectsdir/$projid.conf\" if -e \"$projectsdir/$projid.conf\";\n    } else {\n      print \"expandsearchpath $projid $cgi->{'repository'}...\\n\";\n      my @path = expandsearchpath($projid, $cgi->{'repository'});\n      my $c = concatconfigs($projid, $cgi->{'repository'}, undef, @path);\n      $cfile = [ split(\"\\n\", $c) ];\n    }\n    $bconf = Build::read_config($cgi->{'arch'} || 'noarch', $cfile);\n  }\n  my $res = sourceinfo($cgi, $projid, $packid, $bconf);\n  return ($res, $BSXML::sourceinfo);\n}\n\n####################################################################\n\nsub putconfiguration {\n  my ($cgi) = @_;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $configuration = readxml(\"$uploaddir/$$\", $BSXML::configuration);\n  unlink(\"$uploaddir/$$\");\n  my $configurationxml = BSUtil::toxml($configuration, $BSXML::configuration);\n  writestr(\"$BSConfig::bsdir/.configuration.xml\", \"$BSConfig::bsdir/configuration.xml\", $configurationxml);\n  # distribute to repo servers\n  my %reposervers;\n  if ($BSConfig::partitionservers) {\n    %reposervers = map {$_ => 1} values(%$BSConfig::partitionservers);\n  } else {\n    $reposervers{$BSConfig::reposerver} = 1;\n  }\n  for my $server (sort keys %reposervers) {\n    my $param = {\n      'uri' => \"$server/configuration\",\n      'request' => 'PUT',\n      'data' => $configurationxml,\n    };\n    eval {\n      BSRPC::rpc($param, undef);\n    };\n    warn($@) if $@;\t# XXX: what now?\n  }\n  return $BSStdServer::return_ok;\n}\n\nsub getconfiguration {\n  my $configuration = readxml(\"$BSConfig::bsdir/configuration.xml\", $BSXML::configuration, 1) || {};\n  return ($configuration, $BSXML::configuration);\n}\n\n####################################################################\n\nsub putissuetrackers {\n  my ($cgi) = @_;\n  mkdir_p($uploaddir);\n  my $uploaded = BSServer::read_file(\"$uploaddir/$$\");\n  die(\"upload failed\\n\") unless $uploaded;\n  my $trackers = readxml(\"$uploaddir/$$\", $BSXML::issue_trackers);\n  unlink(\"$uploaddir/$$\");\n  writexml(\"$BSConfig::bsdir/.issuetrackers.xml\", \"$BSConfig::bsdir/issuetrackers.xml\", $trackers, $BSXML::issue_trackers);\n  return $BSStdServer::return_ok;\n}\n\nsub getissuetrackers {\n  my $trackers = readxml(\"$BSConfig::bsdir/issuetrackers.xml\", $BSXML::issue_trackers, 1) || {};\n  return ($trackers, $BSXML::issue_trackers);\n}\n\n####################################################################\n\nsub external_notification {\n  my ($cgi, $type) = @_;\n  my $param = {};\n  for (keys %$cgi) {\n    $param->{$_} = $cgi->{$_} unless $_ eq '_type' || /^\\./;\n  }\n  notify($type, $param);\n  return $BSStdServer::return_ok;\n}\n\nsub notify_plugins {\n  my ($cgi, $type) = @_;\n  my $param = {};\n  if (BSServer::have_content()) {\n    my $jsonbody = BSServer::read_data(10000000);\n    $param = JSON::XS::decode_json($jsonbody);\n  } else {\n    for (keys %$cgi) {\n      $param->{$_} = $cgi->{$_} unless $_ eq '_type' || /^\\./;\n    }\n  }\n\n  BSNotify::notify_plugins($type, $param);\n  return $BSStdServer::return_ok;\n}\n\n\n####################################################################\n\nsub hello {\n  my ($cgi) = @_;\n  return \"<hello name=\\\"Source Repository Ajax Server\\\" repoid=\\\"$repoid\\\" />\\n\" if $BSStdServer::isajax;\n  return \"<hello name=\\\"Source Repository Server\\\" repoid=\\\"$repoid\\\" />\\n\";\n}\n\n####################################################################\n\nmy $dispatches = [\n  '/' => \\&hello,\n\n  '!rw :' => undef,\n  '!- GET:' => undef,\n  '!- HEAD:' => undef,\n\n  # /source name space: manage project and package data\n  '/source deleted:bool?' => \\&getprojectlist,\n\n  'POST:/source/$project cmd=createkey user:? comment:?' => \\&createkey,\n  'POST:/source/$project cmd=extendkey user:? comment:?' => \\&extendkey,\n  'POST:/source/$project cmd=undelete user:? comment:?' => \\&undeleteproject,\n  'POST:/source/$project cmd=copy user:? comment:? oproject:project withbinaries:bool? withhistory:bool? makeolder:bool? resign:bool? noservice:bool?' => \\&copyproject,\n  'POST:/source/$project cmd=move oproject:project' => \\&moveproject,\n  'POST:/source/$project cmd: *:*' => \\&unknowncmd,\n  '/source/$project view=info parse:bool? nofilename:bool? repository? arch? package* withchangesmd5:bool?' => \\&getprojectsourceinfo,\n  '/source/$project deleted:bool? expand:bool? noorigins:bool?' => \\&getpackagelist,\n\n  'DELETE:/source/$project user:? comment:? requestid:num?' => \\&delproject,\n  '/source/$project/_meta rev?' => \\&getproject,\n  'PUT:/source/$project/_meta user:? comment:? requestid:num? lowprio:bool?' => \\&putproject,\n\n  '/source/$project/_pubkey rev?' => \\&getpubkey,\n  'DELETE:/source/$project/_pubkey user:? comment:?' => \\&deletekey,\n\n  '/source/$project/_config rev?' => \\&getprojectconfig,\n  'PUT:/source/$project/_config user:? comment:?' => \\&putprojectconfig,\n  'DELETE:/source/$project/_config user:? comment:?' => \\&delprojectconfig,\n\n  '/source/$project/_history rev? meta:bool? deleted:bool? limit:num?' => \\&getpackagehistory,\n\n  'POST:/source/$project/$package cmd=diff rev? orev:rev? oproject:project? opackage:package? expand:bool? linkrev? olinkrev:? unified:bool? missingok:bool? meta:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \\&sourcediff,\n  'POST:/source/$project/$package cmd=linkdiff rev? linkrev? unified:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \\&linkdiff,\n  'POST:/source/$project/$package cmd=servicediff rev? unified:bool? file:filename* filelimit:num? tarlimit:num? view:? withissues:bool? onlyissues:bool?' => \\&servicediff,\n  'POST:/source/$project/$package cmd=commit rev? user:? comment:? keeplink:bool? repairlink:bool? linkrev? setrev:bool? requestid:num? noservice:bool?' => \\&sourcecommit,\n  'POST:/source/$project/$package cmd=commitfilelist rev? user:? comment:? keeplink:bool? repairlink:bool? linkrev? setrev:bool? requestid:num? time:num? version:? vrev:? noservice:bool? servicemark:?' => \\&sourcecommitfilelist,\n  'POST:/source/$project/$package cmd=copy rev? user:? comment:? orev:rev? oproject:project? opackage:package? expand:bool? keeplink:bool? repairlink:bool? linkrev? setrev:linkrev? olinkrev:linkrev? requestid:num? dontupdatesource:bool? noservice:bool? withvrev:bool? withacceptinfo:bool? makeoriginolder:bool?' => \\&sourcecopy,\n  'POST:/source/$project/$package cmd=collectbuildenv user:? comment:? orev:rev? oproject:project? opackage:package?' => \\&sourcecollectbuildenv,\n  'POST:/source/$project/$package cmd=branch rev? user:? comment:? orev:rev? oproject:project? opackage:package? olinkrev:linkrev? requestid:num? force:bool? keepcontent:bool? missingok:bool? noservice:bool? withacceptinfo:bool?' => \\&sourcebranch,\n  'POST:/source/$project/$package cmd=linktobranch rev? user:? comment:? linkrev?' => \\&linktobranch,\n  'POST:/source/$project/$package cmd=deleteuploadrev' => \\&deleteuploadrev,\n  'POST:/source/$project/$package cmd=undelete user:? comment:? time:num?' => \\&undeletepackage,\n  'POST:/source/$project/$package cmd=runservice user:? comment:?' => \\&triggerservicerun,\n  'POST:/source/$project/$package cmd=getprojectservices' => \\&getprojectservices,\n  'POST:/source/$project/$package cmd: *:*' => \\&unknowncmd,\n\n  'PUT:/source/$project/$package cmd: rev? user:? comment:?' => \\&sourcecommitfilelist,\t# obsolete\n\n  '/source/$project/$package view=info rev? linkrev? parse:bool? nofilename:bool? repository? arch? withchangesmd5:bool?' => \\&getpackagesourceinfo,\n  '/source/$project/$package rev? linkrev? emptylink:bool? deleted:bool? expand:bool? view:? extension:? lastworking:bool? withlinked:bool? meta:bool? product:?' => \\&getfilelist,\n  '/source/$project/$package/_history rev? meta:bool? deleted:bool? limit:num?' => \\&getpackagehistory,\n  '/source/$project/$package/_meta rev? expand:bool? meta:bool? deleted:bool?' => \\&getpackage,\n  'PUT:/source/$project/$package/_meta user:? comment:? requestid:num?' => \\&putpackage,\n  'DELETE:/source/$project/$package user:? comment:? requestid:num?' => \\&delpackage,\n  '/source/$project/$package/$filename rev? expand:bool? meta:bool? deleted:bool?' => \\&getfile,\n  'PUT:/source/$project/$package/$filename rev? user:? comment:? keeplink:bool? force:bool? meta:bool?' => \\&putfile,\n  'DELETE:/source/$project/$package/$filename rev? user:? comment:? keeplink:bool? force:bool? meta:bool?' => \\&delfile,\n\n  # /published name spec: access published binaries\n  '/published' => \\&published,\n  '/published/$project' => \\&published,\n  '/published/$project/$repository view=publishedpath medium:?' => \\&published_path,\n  '/published/$project/$repository' => \\&published,\n  '/published/$project/$repository/$arch:filename view:?' => \\&published,\n  '/published/$project/$repository/$arch:filename/$filename view:?' => \\&published,\n  '/published/$project/$repository/$arch:filename/$filename/$subfilename:filename view:?' => \\&published,\n\n  # scheduler calls\n  '/getprojpack $project* $repository* $package* $arch? withrepos:bool? withsrcmd5:bool? withdeps:bool? withconfig:bool? expandedrepos:bool? ignoredisable:bool? nopackages:bool? withremotemap:bool? noremote:bool? partition:? view:?' => \\&getprojpack,\n  'POST:/relsync $project $repository $arch' => \\&postrelsync,\n  '/relsync $project $repository $arch' => \\&getrelsync,\n\n  # worker calls\n  '/getsources $project $package $srcmd5:md5' => \\&getsources,\n  '/getconfig $project $repository path:prp*' => \\&getbuildconfig,\n\n  '/getsignkey $project withpubkey:bool? autoextend:bool?' => \\&getsignkey,\n  '/getsslcert $project autoextend:bool?' => \\&getsslcert,\n  '/getbinaries $project $repository $arch binaries: nometa:bool?' => \\&worker_getbinaries,\n  '/getbinaryversions $project $repository $arch binaries: nometa:bool?' => \\&worker_getbinaryversions,\n  '!- /lastevents $filter:* start:num? obsname:?' => \\&lastevents,\n  '/lastnotifications start:num? view:? block:bool? noprune:bool?' => \\&lastnotifications,\n  '/notificationpayload/$payloadkey:filename' => \\&getnotificationpayload,\n  'DELETE:/notificationpayload/$payloadkey:filename' => \\&deletenotificationpayload,\n  'POST:/event type: project: package:? repository:? arch:? job:?' => \\&newevent,\n  # tmp until lightty gets fixed\n  '/public/lastevents $filter:* start:num? obsname:?' => \\&lastevents,\n\n  # search interface\n  '/search $in: $match: return:? values:bool?' => \\&search,\n  '/search/project $match:' => \\&search_proj,\n  '/search/project/id $match:' => \\&search_proj_id,\n  '/search/package $match:' => \\&search_pack,\n  '/search/package/id $match:' => \\&search_pack_id,\n\n  'POST:/search/published cmd:' => \\&search_published_updatedb,\n  '/search/published/binary/id $match: limit:num?' => \\&search_published_binary_id,\n  '/search/published/pattern/id $match: limit:num?' => \\&search_published_pattern_id,\n\n  # service interface, just for listing for now\n  '/service' => \\&listservices,\n#  '/service/$service' => \\&service,\n\n  # configuration\n  'PUT:/configuration' => \\&putconfiguration,\n  '/configuration' => \\&getconfiguration,\n\n  # issue trackers\n  'PUT:/issue_trackers' => \\&putissuetrackers,\n  '/issue_trackers' => \\&getissuetrackers,\n\n  # build calls for binary files\n  '/build' => \\&getprojectlist,\n  '/build/_workerstatus scheduleronly:bool? daemonsonly:bool? arch*' => \\&getworkerstatus,\n  'PUT:/build/_dispatchprios' => \\&putdispatchprios,\n  '/build/_dispatchprios' => \\&getdispatchprios,\n  'POST:/build/$project cmd: repository* arch* package* code:* wipe:*' => \\&docommand,\n  '/build/$project' => \\&getrepositorylist,\n  '/build/$project/_result oldstate:md5? view:resultview* lastbuild:bool? repository* arch* package* code:*' => \\&getresult,\n  '/build/$project/$repository' => \\&getarchlist,\n  '/build/$project/$repository/_buildconfig path:prp*' => \\&getbuildconfig,\n  '/build/$project/$repository/$arch package* view:?' => \\&getpackagelist_build,\n  '/build/$project/$repository/$arch/_builddepinfo package* view:?' => \\&getbuilddepinfo,\n  '/build/$project/$repository/$arch/_jobhistory package* code:* limit:num?' => \\&getjobhistory,\n  'POST:/build/$project/$repository/$arch/_repository match:' =>  \\&postrepo,\n  'POST:/build/$project/$repository/$arch/$package cmd=copy oproject:project? opackage:package? orepository:repository? setupdateinfoid:? resign:bool? setrelease:?' => \\&copybuild,\n  'POST:/build/$project/$repository/$arch/$package' => \\&uploadbuild,\n  '/build/$project/$repository/$arch/$package_repository view:? binary:filename* nometa:bool? nosource:bool? withmd5:bool?' => \\&getbinarylist,\n  'POST:/build/$project/$repository/$arch/$package_repository/_buildinfo add:* debug:bool?' => \\&getbuildinfo_post,\n  '/build/$project/$repository/$arch/$package/_buildinfo add:* internal:bool? debug:bool?' => \\&getbuildinfo,\n  '/build/$project/$repository/$arch/$package/_jobstatus' => \\&getjobstatus,\n  '/build/$project/$repository/$arch/$package/_log nostream:bool? last:bool? start:intnum? end:num? view:?' => \\&getlogfile,\n  '/build/$project/$repository/$arch/$package/_reason' => \\&getbuildreason,\n  '/build/$project/$repository/$arch/$package/_status' => \\&getbuildstatus,\n  '/build/$project/$repository/$arch/$package/_history limit:num?' => \\&getbuildhistory,\n  '/build/$project/$repository/$arch/$package_repository/$filename view:?' => \\&getbinary,\n  'PUT:/build/$project/$repository/$arch/_repository/$filename ignoreolder:bool? wipe:bool?' => \\&putbinary,\n  'DELETE:/build/$project/$repository/$arch/_repository/$filename' => \\&delbinary,\n\n  'POST:/request cmd: user:?' => \\&createrequest,\n  '/request' => \\&getrequestlist,\n  'POST:/request/$id:num cmd: newstate:? user:? comment:? by_user:? by_group:? by_project:? by_package:? superseded_by:?' => \\&postrequest,\n  '/request/_lastid' => \\&getlastidrequest,                     # just required for migration into api\n  '/request/$id:num' => \\&getrequest, # just required for migration into api\n\n  # notifications from publisher/repserver - CGI\n  'POST:/notify/$_type: *:?' => \\&external_notification,\n  # called from the API to notify hermes/rabbitmq\n  'POST:/notify_plugins/$_type:' => \\&notify_plugins,\n\n  '/ajaxstatus' => \\&getajaxstatus,\n  '/serverstatus' => \\&BSStdServer::serverstatus,\n];\n\n####################################################################\n\nmy $dispatches_ajax = [\n  '/' => \\&hello,\n  '/ajaxstatus' => \\&getajaxstatus,\n  '/build/$project/_result oldstate:md5? view:resultview* repository* arch* package* code:*' => \\&getresult,\n  '/build/$project/$repository/$arch package* view:?' => \\&getpackagelist_build,\n  '/build/$project/$repository/$arch/$package/_log nostream:bool? last:bool? start:intnum? end:num?' => \\&getlogfile,\n  '/build/$project/$repository/$arch/$package_repository view:? binary:filename* nometa:bool? nosource:bool? withmd5:bool?' => \\&getbinarylist,\n  '/getbinaries $project $repository $arch binaries: nometa:bool? raw:bool?' => \\&worker_getbinaries,\n  '/getbinaryversions $project $repository $arch binaries: nometa:bool?' => \\&worker_getbinaryversions,\n  '/lastevents $filter:* start:num? obsname:?' => \\&lastevents,\n  '/lastnotifications start:num? view:? block:bool?' => \\&lastnotifications,\n  '/source/$project/$package rev view:' => \\&getfilelist_ajax,\n  '/source/$project/$package:package/$filename rev?' => \\&getfile,\n  '/request/$id:num withkey:bool? oldkey:md5?' => \\&getrequest,\n  '/sourcediffcache/$cacheid:md5 view:?' => \\&getsourcediffcache,\n];\n\n####################################################################\n\nmy $conf = {\n  'port' => $port,\n  'dispatches' => $dispatches,\n  'setkeepalive' => 1,\n  'maxchild' => 20,\n  'maxchild2' => 20,\n};\n\nmy $aconf = {\n  'socketpath' => $ajaxsocket,\n  'dispatches' => $dispatches_ajax,\n  'getrequest_timeout' => 10,\n  'replrequest_timeout' => 10,\n  'getrequest_recvfd' => \\&BSHandoff::receive,\n  'setkeepalive' => 1,\n};\n\nif ($BSConfig::workersrcserver) {\n  my $wport = $port;\n  $wport = $1 if $BSConfig::workersrcserver =~ /:(\\d+)$/;\n  $conf->{'port2'} = $wport if $wport != $port;\n}\n\n# set a repoid for identification of this data repository\nBSUtil::mkdir_p_chown(\"$projectsdir\", $BSConfig::bsuser, $BSConfig::bsgroup) unless -d \"$projectsdir\";\nif (! -e \"$projectsdir/_repoid\") {\n  my $randomid = int(rand(1000000000));\n  writestr(\"$projectsdir/._repoid\", \"$projectsdir/_repoid\", sprintf(\"%09d\", $randomid));\n}\n$repoid = readstr(\"$projectsdir/_repoid\");\n\nBSStdServer::server('bs_srcserver', \\@ARGV, $conf, $aconf);\n\n"], "filenames": ["src/backend/bs_srcserver"], "buggy_code_start_loc": [1982], "buggy_code_end_loc": [1986], "fixing_code_start_loc": [1982], "fixing_code_end_loc": [2004], "type": "CWE-59", "message": "In open buildservice 2.6 before 2.6.3, 2.5 before 2.5.7 and 2.4 before 2.4.8 the source service patch application could generate non-standard files like symlinks or device nodes, which could allow buildservice users to break of confinement or cause denial of service attacks on the source service.", "other": {"cve": {"id": "CVE-2015-0796", "sourceIdentifier": "meissner@suse.de", "published": "2018-03-02T20:29:00.207", "lastModified": "2019-10-09T23:12:58.687", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In open buildservice 2.6 before 2.6.3, 2.5 before 2.5.7 and 2.4 before 2.4.8 the source service patch application could generate non-standard files like symlinks or device nodes, which could allow buildservice users to break of confinement or cause denial of service attacks on the source service."}, {"lang": "es", "value": "n open buildservice, en versiones 2.6 anteriores a la 2.6.3, versiones 2.5 anteriores a la 2.5.7 y versiones 2.4 anteriores a la 2.4.8, la aplicaci\u00f3n origen de parche de servicio podr\u00eda generar archivos no est\u00e1ndar como symlinks o nodos de dispositivo. Esto podr\u00eda permitir que los usuarios buildservice salgan de su confinamiento o provoquen ataques de denegaci\u00f3n de servicio (DoS) en el servicio origen."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "meissner@suse.de", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "meissner@suse.de", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:open_buildservice:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4", "versionEndExcluding": "2.4.8", "matchCriteriaId": "E4AF3CA3-F883-4301-85CD-2C71DB0FD6F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:open_buildservice:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5", "versionEndExcluding": "2.5.7", "matchCriteriaId": "701DD07C-6709-4E18-A2A5-BEF1482B21FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:open_buildservice:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6", "versionEndExcluding": "2.6.3", "matchCriteriaId": "5241ECAA-7075-4CD1-87D3-5ADD1840E81E"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=941099", "source": "meissner@suse.de", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/openSUSE/open-build-service/commit/474a3db19498765f0118ba3dbc0b1cc90b0097fc", "source": "meissner@suse.de", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openSUSE/open-build-service/commit/474a3db19498765f0118ba3dbc0b1cc90b0097fc"}}