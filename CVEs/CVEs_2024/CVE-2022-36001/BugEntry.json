{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n// See ../ops/image_ops.cc for details.\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nstd::vector<std::vector<float>> DefaultColorTable(int depth) {\n  std::vector<std::vector<float>> color_table;\n  color_table.emplace_back(std::vector<float>({1, 1, 0, 1}));      // 0: yellow\n  color_table.emplace_back(std::vector<float>({0, 0, 1, 1}));      // 1: blue\n  color_table.emplace_back(std::vector<float>({1, 0, 0, 1}));      // 2: red\n  color_table.emplace_back(std::vector<float>({0, 1, 0, 1}));      // 3: lime\n  color_table.emplace_back(std::vector<float>({0.5, 0, 0.5, 1}));  // 4: purple\n  color_table.emplace_back(std::vector<float>({0.5, 0.5, 0, 1}));  // 5: olive\n  color_table.emplace_back(std::vector<float>({0.5, 0, 0, 1}));    // 6: maroon\n  color_table.emplace_back(std::vector<float>({0, 0, 0.5, 1}));  // 7: navy blue\n  color_table.emplace_back(std::vector<float>({0, 1, 1, 1}));    // 8: aqua\n  color_table.emplace_back(std::vector<float>({1, 0, 1, 1}));    // 9: fuchsia\n\n  if (depth == 1) {\n    for (int64_t i = 0; i < color_table.size(); i++) {\n      color_table[i][0] = 1;\n    }\n  }\n  return color_table;\n}\n}  // namespace\n\ntemplate <class T>\nclass DrawBoundingBoxesOp : public OpKernel {\n public:\n  explicit DrawBoundingBoxesOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& images = context->input(0);\n    const Tensor& boxes = context->input(1);\n    const int64_t depth = images.dim_size(3);\n\n    OP_REQUIRES(context, images.dims() == 4,\n                errors::InvalidArgument(\"The rank of the images should be 4\"));\n    OP_REQUIRES(\n        context, boxes.dims() == 3,\n        errors::InvalidArgument(\"The rank of the boxes tensor should be 3\"));\n    OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),\n                errors::InvalidArgument(\"The batch sizes should be the same\"));\n\n    OP_REQUIRES(\n        context, depth == 4 || depth == 1 || depth == 3,\n        errors::InvalidArgument(\"Channel depth should be either 1 (GRY), \"\n                                \"3 (RGB), or 4 (RGBA)\"));\n\n    OP_REQUIRES(\n        context, boxes.dim_size(2) == 4,\n        errors::InvalidArgument(\n            \"The size of the third dimension of the box must be 4. Received: \",\n            boxes.dim_size(2)));\n\n    const int64_t batch_size = images.dim_size(0);\n    const int64_t height = images.dim_size(1);\n    const int64_t width = images.dim_size(2);\n    std::vector<std::vector<float>> color_table;\n    if (context->num_inputs() == 3) {\n      const Tensor& colors_tensor = context->input(2);\n      OP_REQUIRES(context, colors_tensor.shape().dims() == 2,\n                  errors::InvalidArgument(\"colors must be a 2-D matrix\",\n                                          colors_tensor.shape().DebugString()));\n      OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,\n                  errors::InvalidArgument(\"colors must have equal or more \",\n                                          \"channels than the image provided: \",\n                                          colors_tensor.shape().DebugString()));\n      if (colors_tensor.NumElements() != 0) {\n        color_table.clear();\n\n        auto colors = colors_tensor.matrix<float>();\n        for (int64_t i = 0; i < colors.dimension(0); i++) {\n          std::vector<float> color_value(depth);\n          for (int64_t j = 0; j < depth; j++) {\n            color_value[j] = colors(i, j);\n          }\n          color_table.emplace_back(color_value);\n        }\n      }\n    }\n    if (color_table.empty()) {\n      color_table = DefaultColorTable(depth);\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, height, width, depth}), &output));\n\n    output->tensor<T, 4>() = images.tensor<T, 4>();\n    auto canvas = output->tensor<T, 4>();\n\n    for (int64_t b = 0; b < batch_size; ++b) {\n      const int64_t num_boxes = boxes.dim_size(1);\n      const auto tboxes = boxes.tensor<T, 3>();\n      for (int64_t bb = 0; bb < num_boxes; ++bb) {\n        int64_t color_index = bb % color_table.size();\n        const int64_t min_box_row =\n            static_cast<float>(tboxes(b, bb, 0)) * (height - 1);\n        const int64_t min_box_row_clamp =\n            std::max<int64_t>(min_box_row, int64_t{0});\n        const int64_t max_box_row =\n            static_cast<float>(tboxes(b, bb, 2)) * (height - 1);\n        const int64_t max_box_row_clamp =\n            std::min<int64_t>(max_box_row, height - 1);\n        const int64_t min_box_col =\n            static_cast<float>(tboxes(b, bb, 1)) * (width - 1);\n        const int64_t min_box_col_clamp =\n            std::max<int64_t>(min_box_col, int64_t{0});\n        const int64_t max_box_col =\n            static_cast<float>(tboxes(b, bb, 3)) * (width - 1);\n        const int64_t max_box_col_clamp =\n            std::min<int64_t>(max_box_col, width - 1);\n\n        if (min_box_row > max_box_row || min_box_col > max_box_col) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is inverted and will not be drawn.\";\n          continue;\n        }\n        if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||\n            max_box_col < 0) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is completely outside the image\"\n                       << \" and will not be drawn.\";\n          continue;\n        }\n\n        // At this point, {min,max}_box_{row,col}_clamp are inside the\n        // image.\n        OP_REQUIRES(\n            context, min_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Min box row clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Max box row clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Min box row clamp is greater than height.\"));\n        OP_REQUIRES(context, max_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Max box row clamp is greater than height.\"));\n\n        OP_REQUIRES(\n            context, min_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Min box col clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Max box col clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Min box col clamp is greater than width.\"));\n        OP_REQUIRES(context, max_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Max box col clamp is greater than width.\"));\n\n        // At this point, the min_box_row and min_box_col are either\n        // in the image or above/left of it, and max_box_row and\n        // max_box_col are either in the image or below/right or it.\n\n        OP_REQUIRES(\n            context, min_box_row <= height,\n            errors::InvalidArgument(\"Min box row is greater than height.\"));\n        OP_REQUIRES(context, max_box_row >= 0,\n                    errors::InvalidArgument(\"Max box row is less than 0.\"));\n        OP_REQUIRES(\n            context, min_box_col <= width,\n            errors::InvalidArgument(\"Min box col is greater than width.\"));\n        OP_REQUIRES(context, max_box_col >= 0,\n                    errors::InvalidArgument(\"Max box col is less than 0.\"));\n\n        // Draw top line.\n        if (min_box_row >= 0) {\n          for (int64_t j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64_t c = 0; c < depth; c++) {\n              canvas(b, min_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw bottom line.\n        if (max_box_row < height) {\n          for (int64_t j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64_t c = 0; c < depth; c++) {\n              canvas(b, max_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw left line.\n        if (min_box_col >= 0) {\n          for (int64_t i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64_t c = 0; c < depth; c++) {\n              canvas(b, i, min_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw right line.\n        if (max_box_col < width) {\n          for (int64_t i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64_t c = 0; c < depth; c++) {\n              canvas(b, i, max_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n      }\n    }\n  }\n};\n\n#define REGISTER_CPU_KERNEL(T)                                               \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(\"DrawBoundingBoxes\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      DrawBoundingBoxesOp<T>);                                               \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(\"DrawBoundingBoxesV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      DrawBoundingBoxesOp<T>);\nTF_CALL_half(REGISTER_CPU_KERNEL);\nTF_CALL_float(REGISTER_CPU_KERNEL);\n\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for draw_bounding_box_op.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import image_ops\nfrom tensorflow.python.ops import image_ops_impl\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.platform import test\n\n\nclass DrawBoundingBoxOpTest(test.TestCase):\n\n  def _fillBorder(self, image, color):\n    \"\"\"Fill the border of the image.\n\n    Args:\n      image: Numpy array of shape [height, width, depth].\n      color: Numpy color of shape [depth] and either contents RGB/RGBA.\n\n    Returns:\n      image of original shape with border filled with \"color\".\n\n    Raises:\n      ValueError: Depths of image and color don\"t match.\n    \"\"\"\n    height, width, depth = image.shape\n    if depth != color.shape[0]:\n      raise ValueError(\"Image (%d) and color (%d) depths must match.\" %\n                       (depth, color.shape[0]))\n    image[0:height, 0, 0:depth] = color\n    image[0:height, width - 1, 0:depth] = color\n    image[0, 0:width, 0:depth] = color\n    image[height - 1, 0:width, 0:depth] = color\n    return image\n\n  def _testDrawBoundingBoxColorCycling(self, img, colors=None):\n    \"\"\"Tests if cycling works appropriately.\n\n    Args:\n      img: 3-D numpy image on which to draw.\n    \"\"\"\n    color_table = colors\n    if colors is None:\n      # THIS TABLE MUST MATCH draw_bounding_box_op.cc\n      color_table = np.asarray([[1, 1, 0, 1], [0, 0, 1, 1], [1, 0, 0, 1],\n                                [0, 1, 0, 1], [0.5, 0, 0.5,\n                                               1], [0.5, 0.5, 0, 1],\n                                [0.5, 0, 0, 1], [0, 0, 0.5, 1], [0, 1, 1, 1],\n                                [1, 0, 1, 1]])\n    assert len(img.shape) == 3\n    depth = img.shape[2]\n    assert depth <= color_table.shape[1]\n    assert depth == 1 or depth == 3 or depth == 4\n    ## Set red channel to 1 if image is GRY.\n    if depth == 1:\n      color_table[:, 0] = 1\n    num_colors = color_table.shape[0]\n    for num_boxes in range(1, num_colors + 2):\n      # Generate draw_bounding_box_op drawn image\n      image = np.copy(img)\n      color = color_table[(num_boxes - 1) % num_colors, 0:depth]\n      test_drawn_image = self._fillBorder(image, color)\n      bboxes = np.asarray([0, 0, 1, 1])\n      bboxes = np.vstack([bboxes for _ in range(num_boxes)])\n      bboxes = math_ops.cast(bboxes, dtypes.float32)\n      bboxes = array_ops.expand_dims(bboxes, 0)\n      image = ops.convert_to_tensor(image)\n      image = image_ops_impl.convert_image_dtype(image, dtypes.float32)\n      image = array_ops.expand_dims(image, 0)\n      image = image_ops.draw_bounding_boxes(image, bboxes, colors=colors)\n      with self.cached_session(use_gpu=False) as sess:\n        op_drawn_image = np.squeeze(sess.run(image), 0)\n        self.assertAllEqual(test_drawn_image, op_drawn_image)\n\n  def testDrawBoundingBoxRGBColorCycling(self):\n    \"\"\"Test if RGB color cycling works correctly.\"\"\"\n    image = np.zeros([10, 10, 3], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxRGBAColorCycling(self):\n    \"\"\"Test if RGBA color cycling works correctly.\"\"\"\n    image = np.zeros([10, 10, 4], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxGRY(self):\n    \"\"\"Test if drawing bounding box on a GRY image works.\"\"\"\n    image = np.zeros([4, 4, 1], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxRGBColorCyclingWithColors(self):\n    \"\"\"Test if RGB color cycling works correctly with provided colors.\"\"\"\n    image = np.zeros([10, 10, 3], \"float32\")\n    colors = np.asarray([[1, 1, 0, 1], [0, 0, 1, 1], [0.5, 0, 0.5, 1],\n                         [0.5, 0.5, 0, 1], [0, 1, 1, 1], [1, 0, 1, 1]])\n    self._testDrawBoundingBoxColorCycling(image, colors=colors)\n\n  def testDrawBoundingBoxRGBAColorCyclingWithColors(self):\n    \"\"\"Test if RGBA color cycling works correctly with provided colors.\"\"\"\n    image = np.zeros([10, 10, 4], \"float32\")\n    colors = np.asarray([[0.5, 0, 0.5, 1], [0.5, 0.5, 0, 1], [0.5, 0, 0, 1],\n                         [0, 0, 0.5, 1]])\n    self._testDrawBoundingBoxColorCycling(image, colors=colors)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n// See ../ops/image_ops.cc for details.\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\nnamespace tensorflow {\n\nnamespace {\n\nstd::vector<std::vector<float>> DefaultColorTable(int depth) {\n  std::vector<std::vector<float>> color_table;\n  color_table.emplace_back(std::vector<float>({1, 1, 0, 1}));      // 0: yellow\n  color_table.emplace_back(std::vector<float>({0, 0, 1, 1}));      // 1: blue\n  color_table.emplace_back(std::vector<float>({1, 0, 0, 1}));      // 2: red\n  color_table.emplace_back(std::vector<float>({0, 1, 0, 1}));      // 3: lime\n  color_table.emplace_back(std::vector<float>({0.5, 0, 0.5, 1}));  // 4: purple\n  color_table.emplace_back(std::vector<float>({0.5, 0.5, 0, 1}));  // 5: olive\n  color_table.emplace_back(std::vector<float>({0.5, 0, 0, 1}));    // 6: maroon\n  color_table.emplace_back(std::vector<float>({0, 0, 0.5, 1}));  // 7: navy blue\n  color_table.emplace_back(std::vector<float>({0, 1, 1, 1}));    // 8: aqua\n  color_table.emplace_back(std::vector<float>({1, 0, 1, 1}));    // 9: fuchsia\n\n  if (depth == 1) {\n    for (int64_t i = 0; i < color_table.size(); i++) {\n      color_table[i][0] = 1;\n    }\n  }\n  return color_table;\n}\n}  // namespace\n\ntemplate <class T>\nclass DrawBoundingBoxesOp : public OpKernel {\n public:\n  explicit DrawBoundingBoxesOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& images = context->input(0);\n    const Tensor& boxes = context->input(1);\n    const int64_t depth = images.dim_size(3);\n\n    OP_REQUIRES(context, images.dims() == 4,\n                errors::InvalidArgument(\"The rank of the images should be 4\"));\n    OP_REQUIRES(\n        context, boxes.dims() == 3,\n        errors::InvalidArgument(\"The rank of the boxes tensor should be 3\"));\n    OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),\n                errors::InvalidArgument(\"The batch sizes should be the same\"));\n\n    OP_REQUIRES(\n        context, depth == 4 || depth == 1 || depth == 3,\n        errors::InvalidArgument(\"Channel depth should be either 1 (GRY), \"\n                                \"3 (RGB), or 4 (RGBA)\"));\n\n    OP_REQUIRES(\n        context, boxes.dim_size(2) == 4,\n        errors::InvalidArgument(\n            \"The size of the third dimension of the box must be 4. Received: \",\n            boxes.dim_size(2)));\n\n    const int64_t batch_size = images.dim_size(0);\n    const int64_t height = images.dim_size(1);\n    const int64_t width = images.dim_size(2);\n    std::vector<std::vector<float>> color_table;\n    if (context->num_inputs() == 3) {\n      const Tensor& colors_tensor = context->input(2);\n      OP_REQUIRES(context, colors_tensor.shape().dims() == 2,\n                  errors::InvalidArgument(\"colors must be a 2-D matrix\",\n                                          colors_tensor.shape().DebugString()));\n      OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,\n                  errors::InvalidArgument(\"colors must have equal or more \",\n                                          \"channels than the image provided: \",\n                                          colors_tensor.shape().DebugString()));\n      if (colors_tensor.NumElements() != 0) {\n        color_table.clear();\n\n        auto colors = colors_tensor.matrix<float>();\n        for (int64_t i = 0; i < colors.dimension(0); i++) {\n          std::vector<float> color_value(depth);\n          for (int64_t j = 0; j < depth; j++) {\n            color_value[j] = colors(i, j);\n          }\n          color_table.emplace_back(color_value);\n        }\n      }\n    }\n    if (color_table.empty()) {\n      color_table = DefaultColorTable(depth);\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, height, width, depth}), &output));\n\n    output->tensor<T, 4>() = images.tensor<T, 4>();\n    auto canvas = output->tensor<T, 4>();\n\n    for (int64_t b = 0; b < batch_size; ++b) {\n      const int64_t num_boxes = boxes.dim_size(1);\n      const auto tboxes = boxes.tensor<float, 3>();\n      for (int64_t bb = 0; bb < num_boxes; ++bb) {\n        int64_t color_index = bb % color_table.size();\n        const int64_t min_box_row =\n            static_cast<float>(tboxes(b, bb, 0)) * (height - 1);\n        const int64_t min_box_row_clamp =\n            std::max<int64_t>(min_box_row, int64_t{0});\n        const int64_t max_box_row =\n            static_cast<float>(tboxes(b, bb, 2)) * (height - 1);\n        const int64_t max_box_row_clamp =\n            std::min<int64_t>(max_box_row, height - 1);\n        const int64_t min_box_col =\n            static_cast<float>(tboxes(b, bb, 1)) * (width - 1);\n        const int64_t min_box_col_clamp =\n            std::max<int64_t>(min_box_col, int64_t{0});\n        const int64_t max_box_col =\n            static_cast<float>(tboxes(b, bb, 3)) * (width - 1);\n        const int64_t max_box_col_clamp =\n            std::min<int64_t>(max_box_col, width - 1);\n\n        if (min_box_row > max_box_row || min_box_col > max_box_col) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is inverted and will not be drawn.\";\n          continue;\n        }\n        if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||\n            max_box_col < 0) {\n          LOG(WARNING) << \"Bounding box (\" << min_box_row << \",\" << min_box_col\n                       << \",\" << max_box_row << \",\" << max_box_col\n                       << \") is completely outside the image\"\n                       << \" and will not be drawn.\";\n          continue;\n        }\n\n        // At this point, {min,max}_box_{row,col}_clamp are inside the\n        // image.\n        OP_REQUIRES(\n            context, min_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Min box row clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_row_clamp >= 0,\n            errors::InvalidArgument(\"Max box row clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Min box row clamp is greater than height.\"));\n        OP_REQUIRES(context, max_box_row_clamp <= height,\n                    errors::InvalidArgument(\n                        \"Max box row clamp is greater than height.\"));\n\n        OP_REQUIRES(\n            context, min_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Min box col clamp is less than 0.\"));\n        OP_REQUIRES(\n            context, max_box_col_clamp >= 0,\n            errors::InvalidArgument(\"Max box col clamp is less than 0.\"));\n        OP_REQUIRES(context, min_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Min box col clamp is greater than width.\"));\n        OP_REQUIRES(context, max_box_col_clamp <= width,\n                    errors::InvalidArgument(\n                        \"Max box col clamp is greater than width.\"));\n\n        // At this point, the min_box_row and min_box_col are either\n        // in the image or above/left of it, and max_box_row and\n        // max_box_col are either in the image or below/right or it.\n\n        OP_REQUIRES(\n            context, min_box_row <= height,\n            errors::InvalidArgument(\"Min box row is greater than height.\"));\n        OP_REQUIRES(context, max_box_row >= 0,\n                    errors::InvalidArgument(\"Max box row is less than 0.\"));\n        OP_REQUIRES(\n            context, min_box_col <= width,\n            errors::InvalidArgument(\"Min box col is greater than width.\"));\n        OP_REQUIRES(context, max_box_col >= 0,\n                    errors::InvalidArgument(\"Max box col is less than 0.\"));\n\n        // Draw top line.\n        if (min_box_row >= 0) {\n          for (int64_t j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64_t c = 0; c < depth; c++) {\n              canvas(b, min_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw bottom line.\n        if (max_box_row < height) {\n          for (int64_t j = min_box_col_clamp; j <= max_box_col_clamp; ++j)\n            for (int64_t c = 0; c < depth; c++) {\n              canvas(b, max_box_row, j, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw left line.\n        if (min_box_col >= 0) {\n          for (int64_t i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64_t c = 0; c < depth; c++) {\n              canvas(b, i, min_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n        // Draw right line.\n        if (max_box_col < width) {\n          for (int64_t i = min_box_row_clamp; i <= max_box_row_clamp; ++i)\n            for (int64_t c = 0; c < depth; c++) {\n              canvas(b, i, max_box_col, c) =\n                  static_cast<T>(color_table[color_index][c]);\n            }\n        }\n      }\n    }\n  }\n};\n\n#define REGISTER_CPU_KERNEL(T)                                               \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(\"DrawBoundingBoxes\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"),   \\\n      DrawBoundingBoxesOp<T>);                                               \\\n  REGISTER_KERNEL_BUILDER(                                                   \\\n      Name(\"DrawBoundingBoxesV2\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      DrawBoundingBoxesOp<T>);\nTF_CALL_half(REGISTER_CPU_KERNEL);\nTF_CALL_float(REGISTER_CPU_KERNEL);\n\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for draw_bounding_box_op.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import image_ops\nfrom tensorflow.python.ops import image_ops_impl\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.platform import test\n\n\nclass DrawBoundingBoxOpTest(test.TestCase):\n\n  def _fillBorder(self, image, color):\n    \"\"\"Fill the border of the image.\n\n    Args:\n      image: Numpy array of shape [height, width, depth].\n      color: Numpy color of shape [depth] and either contents RGB/RGBA.\n\n    Returns:\n      image of original shape with border filled with \"color\".\n\n    Raises:\n      ValueError: Depths of image and color don\"t match.\n    \"\"\"\n    height, width, depth = image.shape\n    if depth != color.shape[0]:\n      raise ValueError(\"Image (%d) and color (%d) depths must match.\" %\n                       (depth, color.shape[0]))\n    image[0:height, 0, 0:depth] = color\n    image[0:height, width - 1, 0:depth] = color\n    image[0, 0:width, 0:depth] = color\n    image[height - 1, 0:width, 0:depth] = color\n    return image\n\n  def _testDrawBoundingBoxColorCycling(self,\n                                       img,\n                                       dtype=dtypes.float32,\n                                       colors=None):\n    \"\"\"Tests if cycling works appropriately.\n\n    Args:\n      img: 3-D numpy image on which to draw.\n      dtype: image dtype (float, half).\n      colors: color table.\n    \"\"\"\n    color_table = colors\n    if colors is None:\n      # THIS TABLE MUST MATCH draw_bounding_box_op.cc\n      color_table = np.asarray([[1, 1, 0, 1], [0, 0, 1, 1], [1, 0, 0, 1],\n                                [0, 1, 0, 1], [0.5, 0, 0.5,\n                                               1], [0.5, 0.5, 0, 1],\n                                [0.5, 0, 0, 1], [0, 0, 0.5, 1], [0, 1, 1, 1],\n                                [1, 0, 1, 1]])\n    assert len(img.shape) == 3\n    depth = img.shape[2]\n    assert depth <= color_table.shape[1]\n    assert depth == 1 or depth == 3 or depth == 4\n    ## Set red channel to 1 if image is GRY.\n    if depth == 1:\n      color_table[:, 0] = 1\n    num_colors = color_table.shape[0]\n    for num_boxes in range(1, num_colors + 2):\n      # Generate draw_bounding_box_op drawn image\n      image = np.copy(img)\n      color = color_table[(num_boxes - 1) % num_colors, 0:depth]\n      test_drawn_image = self._fillBorder(image, color)\n      bboxes = np.asarray([0, 0, 1, 1])\n      bboxes = np.vstack([bboxes for _ in range(num_boxes)])\n      bboxes = math_ops.cast(bboxes, dtypes.float32)\n      bboxes = array_ops.expand_dims(bboxes, 0)\n      image = ops.convert_to_tensor(image)\n      image = image_ops_impl.convert_image_dtype(image, dtype)\n      image = array_ops.expand_dims(image, 0)\n      image = image_ops.draw_bounding_boxes(image, bboxes, colors=colors)\n      with self.cached_session(use_gpu=False) as sess:\n        op_drawn_image = np.squeeze(sess.run(image), 0)\n        self.assertAllEqual(test_drawn_image, op_drawn_image)\n\n  def testDrawBoundingBoxRGBColorCycling(self):\n    \"\"\"Test if RGB color cycling works correctly.\"\"\"\n    image = np.zeros([10, 10, 3], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxRGBAColorCycling(self):\n    \"\"\"Test if RGBA color cycling works correctly.\"\"\"\n    image = np.zeros([10, 10, 4], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxGRY(self):\n    \"\"\"Test if drawing bounding box on a GRY image works.\"\"\"\n    image = np.zeros([4, 4, 1], \"float32\")\n    self._testDrawBoundingBoxColorCycling(image)\n\n  def testDrawBoundingBoxRGBColorCyclingWithColors(self):\n    \"\"\"Test if RGB color cycling works correctly with provided colors.\"\"\"\n    image = np.zeros([10, 10, 3], \"float32\")\n    colors = np.asarray([[1, 1, 0, 1], [0, 0, 1, 1], [0.5, 0, 0.5, 1],\n                         [0.5, 0.5, 0, 1], [0, 1, 1, 1], [1, 0, 1, 1]])\n    self._testDrawBoundingBoxColorCycling(image, colors=colors)\n\n  def testDrawBoundingBoxRGBAColorCyclingWithColors(self):\n    \"\"\"Test if RGBA color cycling works correctly with provided colors.\"\"\"\n    image = np.zeros([10, 10, 4], \"float32\")\n    colors = np.asarray([[0.5, 0, 0.5, 1], [0.5, 0.5, 0, 1], [0.5, 0, 0, 1],\n                         [0, 0, 0.5, 1]])\n    self._testDrawBoundingBoxColorCycling(image, colors=colors)\n\n  def testDrawBoundingBoxHalf(self):\n    \"\"\"Test if RGBA color cycling works correctly with provided colors.\"\"\"\n    image = np.zeros([10, 10, 4], \"float32\")\n    colors = np.asarray([[0.5, 0, 0.5, 1], [0.5, 0.5, 0, 1], [0.5, 0, 0, 1],\n                         [0, 0, 0.5, 1]])\n    self._testDrawBoundingBoxColorCycling(\n        image, dtype=dtypes.half, colors=colors)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/image/draw_bounding_box_op.cc", "tensorflow/python/kernel_tests/image_ops/draw_bounding_box_op_test.py"], "buggy_code_start_loc": [122, 53], "buggy_code_end_loc": [123, 120], "fixing_code_start_loc": [122, 53], "fixing_code_end_loc": [123, 134], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. When `DrawBoundingBoxes` receives an input `boxes` that is not of dtype `float`, it gives a `CHECK` fail that can trigger a denial of service attack. We have patched the issue in GitHub commit da0d65cdc1270038e72157ba35bf74b85d9bda11. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-36001", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T23:15:10.707", "lastModified": "2022-09-20T14:43:12.100", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. When `DrawBoundingBoxes` receives an input `boxes` that is not of dtype `float`, it gives a `CHECK` fail that can trigger a denial of service attack. We have patched the issue in GitHub commit da0d65cdc1270038e72157ba35bf74b85d9bda11. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. Cuando \"DrawBoundingBoxes\" recibe una entrada \"boxes\" que no es de tipo \"float\", da un fallo \"CHECK\" que puede desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit da0d65cdc1270038e72157ba35bf74b85d9bda11 de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C6622D95-1C86-45C5-AB55-E6EEEA0996DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/da0d65cdc1270038e72157ba35bf74b85d9bda11", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-jqm7-m5q7-3hm5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/da0d65cdc1270038e72157ba35bf74b85d9bda11"}}