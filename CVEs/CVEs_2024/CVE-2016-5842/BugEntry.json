{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               PPPP   RRRR    OOO   FFFFF  IIIII  L      EEEEE               %\n%               P   P  R   R  O   O  F        I    L      E                   %\n%               PPPP   RRRR   O   O  FFF      I    L      EEE                 %\n%               P      R R    O   O  F        I    L      E                   %\n%               P      R  R    OOO   F      IIIII  LLLLL  EEEEE               %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Image Profile Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/profile-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS_LCMS2_H)\n#include <wchar.h>\n#include <lcms/lcms2.h>\n#else\n#include <wchar.h>\n#include \"lcms2.h\"\n#endif\n#endif\n\f\n/*\n  Forward declarations\n*/\nstatic MagickBooleanType\n  SetImageProfileInternal(Image *,const char *,const StringInfo *,\n    const MagickBooleanType,ExceptionInfo *);\n\nstatic void\n  WriteTo8BimProfile(Image *,const char*,const StringInfo *);\n\f\n/*\n  Typedef declarations\n*/\nstruct _ProfileInfo\n{\n  char\n    *name;\n\n  size_t\n    length;\n\n  unsigned char\n    *info;\n\n  size_t\n    signature;\n};\n\ntypedef struct _CMSExceptionInfo\n{\n  Image\n    *image;\n\n  ExceptionInfo\n    *exception;\n} CMSExceptionInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o f i l e s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProfiles() clones one or more image profiles.\n%\n%  The format of the CloneImageProfiles method is:\n%\n%      MagickBooleanType CloneImageProfiles(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProfiles(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->profiles != (void *) NULL)\n    {\n      if (image->profiles != (void *) NULL)\n        DestroyImageProfiles(image);\n      image->profiles=CloneSplayTree((SplayTreeInfo *) clone_image->profiles,\n        (void *(*)(void *)) ConstantString,(void *(*)(void *)) CloneStringInfo);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProfile() deletes a profile from the image by its name.\n%\n%  The format of the DeleteImageProfile method is:\n%\n%      MagickBooleanTyupe DeleteImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return(MagickFalse);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->profiles,name));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o f i l e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProfiles() releases memory associated with an image profile map.\n%\n%  The format of the DestroyProfiles method is:\n%\n%      void DestroyImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProfiles(Image *image)\n{\n  if (image->profiles != (SplayTreeInfo *) NULL)\n    image->profiles=DestroySplayTree((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProfile() gets a profile associated with an image by name.\n%\n%  The format of the GetImageProfile method is:\n%\n%      const StringInfo *GetImageProfile(const Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport const StringInfo *GetImageProfile(const Image *image,\n  const char *name)\n{\n  const StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  profile=(const StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o f i l e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProfile() gets the next profile name for an image.\n%\n%  The format of the GetNextImageProfile method is:\n%\n%      char *GetNextImageProfile(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o hash_info: the hash info.\n%\n*/\nMagickExport char *GetNextImageProfile(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((char *) NULL);\n  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P r o f i l e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProfileImage() associates, applies, or removes an ICM, IPTC, or generic\n%  profile with / to / from an image.  If the profile is NULL, it is removed\n%  from the image otherwise added or applied.  Use a name of '*' and a profile\n%  of NULL to remove all profiles from the image.\n%\n%  ICC and ICM profiles are handled as follows: If the image does not have\n%  an associated color profile, the one you provide is associated with the\n%  image and the image pixels are not transformed.  Otherwise, the colorspace\n%  transform defined by the existing and new profile are applied to the image\n%  pixels and the new profile is associated with the image.\n%\n%  The format of the ProfileImage method is:\n%\n%      MagickBooleanType ProfileImage(Image *image,const char *name,\n%        const void *datum,const size_t length,const MagickBooleanType clone)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: Name of profile to add or remove: ICC, IPTC, or generic profile.\n%\n%    o datum: the profile data.\n%\n%    o length: the length of the profile.\n%\n%    o clone: should be MagickFalse.\n%\n*/\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\nstatic unsigned short **DestroyPixelThreadSet(unsigned short **pixels)\n{\n  register ssize_t\n    i;\n\n  assert(pixels != (unsigned short **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (unsigned short *) NULL)\n      pixels[i]=(unsigned short *) RelinquishMagickMemory(pixels[i]);\n  pixels=(unsigned short **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic unsigned short **AcquirePixelThreadSet(const size_t columns,\n  const size_t channels)\n{\n  register ssize_t\n    i;\n\n  unsigned short\n    **pixels;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(unsigned short **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (unsigned short **) NULL)\n    return((unsigned short **) NULL);\n  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=(unsigned short *) AcquireQuantumMemory(columns,channels*\n      sizeof(**pixels));\n    if (pixels[i] == (unsigned short *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n  }\n  return(pixels);\n}\n\nstatic cmsHTRANSFORM *DestroyTransformThreadSet(cmsHTRANSFORM *transform)\n{\n  register ssize_t\n    i;\n\n  assert(transform != (cmsHTRANSFORM *) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (transform[i] != (cmsHTRANSFORM) NULL)\n      cmsDeleteTransform(transform[i]);\n  transform=(cmsHTRANSFORM *) RelinquishMagickMemory(transform);\n  return(transform);\n}\n\nstatic cmsHTRANSFORM *AcquireTransformThreadSet(Image *image,\n  const cmsHPROFILE source_profile,const cmsUInt32Number source_type,\n  const cmsHPROFILE target_profile,const cmsUInt32Number target_type,\n  const int intent,const cmsUInt32Number flags)\n{\n  cmsHTRANSFORM\n    *transform;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  transform=(cmsHTRANSFORM *) AcquireQuantumMemory(number_threads,\n    sizeof(*transform));\n  if (transform == (cmsHTRANSFORM *) NULL)\n    return((cmsHTRANSFORM *) NULL);\n  (void) ResetMagickMemory(transform,0,number_threads*sizeof(*transform));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    transform[i]=cmsCreateTransformTHR((cmsContext) image,source_profile,\n      source_type,target_profile,target_type,intent,flags);\n    if (transform[i] == (cmsHTRANSFORM) NULL)\n      return(DestroyTransformThreadSet(transform));\n  }\n  return(transform);\n}\n#endif\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\nstatic void CMSExceptionHandler(cmsContext context,cmsUInt32Number severity,\n  const char *message)\n{\n  CMSExceptionInfo\n    *cms_exception;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  cms_exception=(CMSExceptionInfo *) context;\n  image=cms_exception->image;\n  exception=cms_exception->exception;\n  if (image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n        \"UnableToTransformColorspace\",\"`%s'\",\"unknown context\");\n      return;\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"lcms: #%u, %s\",\n      severity,message != (char *) NULL ? message : \"no message\");\n  (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n    \"UnableToTransformColorspace\",\"`%s'\",image->filename);\n}\n#endif\n\nstatic MagickBooleanType SetsRGBImageProfile(Image *image,\n  ExceptionInfo *exception)\n{\n  static unsigned char\n    sRGBProfile[] =\n    {\n      0x00, 0x00, 0x0c, 0x8c, 0x61, 0x72, 0x67, 0x6c, 0x02, 0x20, 0x00, 0x00,\n      0x6d, 0x6e, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5a, 0x20,\n      0x07, 0xde, 0x00, 0x01, 0x00, 0x06, 0x00, 0x16, 0x00, 0x0f, 0x00, 0x3a,\n      0x61, 0x63, 0x73, 0x70, 0x4d, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,\n      0x49, 0x45, 0x43, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xd6,\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d, 0x61, 0x72, 0x67, 0x6c,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x99,\n      0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x01, 0xec, 0x00, 0x00, 0x00, 0x67,\n      0x64, 0x6d, 0x6e, 0x64, 0x00, 0x00, 0x02, 0x54, 0x00, 0x00, 0x00, 0x70,\n      0x64, 0x6d, 0x64, 0x64, 0x00, 0x00, 0x02, 0xc4, 0x00, 0x00, 0x00, 0x88,\n      0x74, 0x65, 0x63, 0x68, 0x00, 0x00, 0x03, 0x4c, 0x00, 0x00, 0x00, 0x0c,\n      0x76, 0x75, 0x65, 0x64, 0x00, 0x00, 0x03, 0x58, 0x00, 0x00, 0x00, 0x67,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x24,\n      0x6c, 0x75, 0x6d, 0x69, 0x00, 0x00, 0x03, 0xe4, 0x00, 0x00, 0x00, 0x14,\n      0x6d, 0x65, 0x61, 0x73, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x24,\n      0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x6b, 0x70, 0x74, 0x00, 0x00, 0x04, 0x30, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x44, 0x00, 0x00, 0x00, 0x14,\n      0x67, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x58, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x6c, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,\n      0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36,\n      0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75, 0x69, 0x76,\n      0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77, 0x77, 0x77,\n      0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20, 0x31, 0x39,\n      0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c,\n      0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x3f, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31,\n      0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75,\n      0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77,\n      0x77, 0x77, 0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20,\n      0x31, 0x39, 0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66,\n      0x69, 0x6c, 0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x43, 0x72, 0x65, 0x61,\n      0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x47, 0x72, 0x61, 0x65, 0x6d,\n      0x65, 0x20, 0x57, 0x2e, 0x20, 0x47, 0x69, 0x6c, 0x6c, 0x2e, 0x20, 0x52,\n      0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x6f,\n      0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,\n      0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x20, 0x4e, 0x6f, 0x20, 0x57,\n      0x61, 0x72, 0x72, 0x61, 0x6e, 0x74, 0x79, 0x2c, 0x20, 0x55, 0x73, 0x65,\n      0x20, 0x61, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6f, 0x77, 0x6e,\n      0x20, 0x72, 0x69, 0x73, 0x6b, 0x2e, 0x00, 0x00, 0x64, 0x65, 0x73, 0x63,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20,\n      0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69,\n      0x65, 0x63, 0x2e, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20, 0x68, 0x74, 0x74,\n      0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x65, 0x63, 0x2e,\n      0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e,\n      0x49, 0x45, 0x43, 0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e,\n      0x31, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47,\n      0x42, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61,\n      0x63, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x49, 0x45, 0x43,\n      0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x44,\n      0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47, 0x42, 0x20, 0x63,\n      0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,\n      0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x73, 0x69, 0x67, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x43, 0x52, 0x54, 0x20, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xa4, 0x7c,\n      0x00, 0x14, 0x5f, 0x30, 0x00, 0x10, 0xce, 0x02, 0x00, 0x03, 0xed, 0xb2,\n      0x00, 0x04, 0x13, 0x0a, 0x00, 0x03, 0x5c, 0x67, 0x00, 0x00, 0x00, 0x01,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x0a, 0x3d,\n      0x00, 0x50, 0x00, 0x00, 0x00, 0x57, 0x1e, 0xb8, 0x6d, 0x65, 0x61, 0x73,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x02, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x51, 0x00, 0x01, 0x00, 0x00,\n      0x00, 0x01, 0x16, 0xcc, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xa0,\n      0x00, 0x00, 0x38, 0xf5, 0x00, 0x00, 0x03, 0x90, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x97, 0x00, 0x00, 0xb7, 0x87,\n      0x00, 0x00, 0x18, 0xd9, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x24, 0x9f, 0x00, 0x00, 0x0f, 0x84, 0x00, 0x00, 0xb6, 0xc4,\n      0x63, 0x75, 0x72, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n      0x00, 0x00, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x0f, 0x00, 0x14, 0x00, 0x19,\n      0x00, 0x1e, 0x00, 0x23, 0x00, 0x28, 0x00, 0x2d, 0x00, 0x32, 0x00, 0x37,\n      0x00, 0x3b, 0x00, 0x40, 0x00, 0x45, 0x00, 0x4a, 0x00, 0x4f, 0x00, 0x54,\n      0x00, 0x59, 0x00, 0x5e, 0x00, 0x63, 0x00, 0x68, 0x00, 0x6d, 0x00, 0x72,\n      0x00, 0x77, 0x00, 0x7c, 0x00, 0x81, 0x00, 0x86, 0x00, 0x8b, 0x00, 0x90,\n      0x00, 0x95, 0x00, 0x9a, 0x00, 0x9f, 0x00, 0xa4, 0x00, 0xa9, 0x00, 0xae,\n      0x00, 0xb2, 0x00, 0xb7, 0x00, 0xbc, 0x00, 0xc1, 0x00, 0xc6, 0x00, 0xcb,\n      0x00, 0xd0, 0x00, 0xd5, 0x00, 0xdb, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0xeb,\n      0x00, 0xf0, 0x00, 0xf6, 0x00, 0xfb, 0x01, 0x01, 0x01, 0x07, 0x01, 0x0d,\n      0x01, 0x13, 0x01, 0x19, 0x01, 0x1f, 0x01, 0x25, 0x01, 0x2b, 0x01, 0x32,\n      0x01, 0x38, 0x01, 0x3e, 0x01, 0x45, 0x01, 0x4c, 0x01, 0x52, 0x01, 0x59,\n      0x01, 0x60, 0x01, 0x67, 0x01, 0x6e, 0x01, 0x75, 0x01, 0x7c, 0x01, 0x83,\n      0x01, 0x8b, 0x01, 0x92, 0x01, 0x9a, 0x01, 0xa1, 0x01, 0xa9, 0x01, 0xb1,\n      0x01, 0xb9, 0x01, 0xc1, 0x01, 0xc9, 0x01, 0xd1, 0x01, 0xd9, 0x01, 0xe1,\n      0x01, 0xe9, 0x01, 0xf2, 0x01, 0xfa, 0x02, 0x03, 0x02, 0x0c, 0x02, 0x14,\n      0x02, 0x1d, 0x02, 0x26, 0x02, 0x2f, 0x02, 0x38, 0x02, 0x41, 0x02, 0x4b,\n      0x02, 0x54, 0x02, 0x5d, 0x02, 0x67, 0x02, 0x71, 0x02, 0x7a, 0x02, 0x84,\n      0x02, 0x8e, 0x02, 0x98, 0x02, 0xa2, 0x02, 0xac, 0x02, 0xb6, 0x02, 0xc1,\n      0x02, 0xcb, 0x02, 0xd5, 0x02, 0xe0, 0x02, 0xeb, 0x02, 0xf5, 0x03, 0x00,\n      0x03, 0x0b, 0x03, 0x16, 0x03, 0x21, 0x03, 0x2d, 0x03, 0x38, 0x03, 0x43,\n      0x03, 0x4f, 0x03, 0x5a, 0x03, 0x66, 0x03, 0x72, 0x03, 0x7e, 0x03, 0x8a,\n      0x03, 0x96, 0x03, 0xa2, 0x03, 0xae, 0x03, 0xba, 0x03, 0xc7, 0x03, 0xd3,\n      0x03, 0xe0, 0x03, 0xec, 0x03, 0xf9, 0x04, 0x06, 0x04, 0x13, 0x04, 0x20,\n      0x04, 0x2d, 0x04, 0x3b, 0x04, 0x48, 0x04, 0x55, 0x04, 0x63, 0x04, 0x71,\n      0x04, 0x7e, 0x04, 0x8c, 0x04, 0x9a, 0x04, 0xa8, 0x04, 0xb6, 0x04, 0xc4,\n      0x04, 0xd3, 0x04, 0xe1, 0x04, 0xf0, 0x04, 0xfe, 0x05, 0x0d, 0x05, 0x1c,\n      0x05, 0x2b, 0x05, 0x3a, 0x05, 0x49, 0x05, 0x58, 0x05, 0x67, 0x05, 0x77,\n      0x05, 0x86, 0x05, 0x96, 0x05, 0xa6, 0x05, 0xb5, 0x05, 0xc5, 0x05, 0xd5,\n      0x05, 0xe5, 0x05, 0xf6, 0x06, 0x06, 0x06, 0x16, 0x06, 0x27, 0x06, 0x37,\n      0x06, 0x48, 0x06, 0x59, 0x06, 0x6a, 0x06, 0x7b, 0x06, 0x8c, 0x06, 0x9d,\n      0x06, 0xaf, 0x06, 0xc0, 0x06, 0xd1, 0x06, 0xe3, 0x06, 0xf5, 0x07, 0x07,\n      0x07, 0x19, 0x07, 0x2b, 0x07, 0x3d, 0x07, 0x4f, 0x07, 0x61, 0x07, 0x74,\n      0x07, 0x86, 0x07, 0x99, 0x07, 0xac, 0x07, 0xbf, 0x07, 0xd2, 0x07, 0xe5,\n      0x07, 0xf8, 0x08, 0x0b, 0x08, 0x1f, 0x08, 0x32, 0x08, 0x46, 0x08, 0x5a,\n      0x08, 0x6e, 0x08, 0x82, 0x08, 0x96, 0x08, 0xaa, 0x08, 0xbe, 0x08, 0xd2,\n      0x08, 0xe7, 0x08, 0xfb, 0x09, 0x10, 0x09, 0x25, 0x09, 0x3a, 0x09, 0x4f,\n      0x09, 0x64, 0x09, 0x79, 0x09, 0x8f, 0x09, 0xa4, 0x09, 0xba, 0x09, 0xcf,\n      0x09, 0xe5, 0x09, 0xfb, 0x0a, 0x11, 0x0a, 0x27, 0x0a, 0x3d, 0x0a, 0x54,\n      0x0a, 0x6a, 0x0a, 0x81, 0x0a, 0x98, 0x0a, 0xae, 0x0a, 0xc5, 0x0a, 0xdc,\n      0x0a, 0xf3, 0x0b, 0x0b, 0x0b, 0x22, 0x0b, 0x39, 0x0b, 0x51, 0x0b, 0x69,\n      0x0b, 0x80, 0x0b, 0x98, 0x0b, 0xb0, 0x0b, 0xc8, 0x0b, 0xe1, 0x0b, 0xf9,\n      0x0c, 0x12, 0x0c, 0x2a, 0x0c, 0x43, 0x0c, 0x5c, 0x0c, 0x75, 0x0c, 0x8e,\n      0x0c, 0xa7, 0x0c, 0xc0, 0x0c, 0xd9, 0x0c, 0xf3, 0x0d, 0x0d, 0x0d, 0x26,\n      0x0d, 0x40, 0x0d, 0x5a, 0x0d, 0x74, 0x0d, 0x8e, 0x0d, 0xa9, 0x0d, 0xc3,\n      0x0d, 0xde, 0x0d, 0xf8, 0x0e, 0x13, 0x0e, 0x2e, 0x0e, 0x49, 0x0e, 0x64,\n      0x0e, 0x7f, 0x0e, 0x9b, 0x0e, 0xb6, 0x0e, 0xd2, 0x0e, 0xee, 0x0f, 0x09,\n      0x0f, 0x25, 0x0f, 0x41, 0x0f, 0x5e, 0x0f, 0x7a, 0x0f, 0x96, 0x0f, 0xb3,\n      0x0f, 0xcf, 0x0f, 0xec, 0x10, 0x09, 0x10, 0x26, 0x10, 0x43, 0x10, 0x61,\n      0x10, 0x7e, 0x10, 0x9b, 0x10, 0xb9, 0x10, 0xd7, 0x10, 0xf5, 0x11, 0x13,\n      0x11, 0x31, 0x11, 0x4f, 0x11, 0x6d, 0x11, 0x8c, 0x11, 0xaa, 0x11, 0xc9,\n      0x11, 0xe8, 0x12, 0x07, 0x12, 0x26, 0x12, 0x45, 0x12, 0x64, 0x12, 0x84,\n      0x12, 0xa3, 0x12, 0xc3, 0x12, 0xe3, 0x13, 0x03, 0x13, 0x23, 0x13, 0x43,\n      0x13, 0x63, 0x13, 0x83, 0x13, 0xa4, 0x13, 0xc5, 0x13, 0xe5, 0x14, 0x06,\n      0x14, 0x27, 0x14, 0x49, 0x14, 0x6a, 0x14, 0x8b, 0x14, 0xad, 0x14, 0xce,\n      0x14, 0xf0, 0x15, 0x12, 0x15, 0x34, 0x15, 0x56, 0x15, 0x78, 0x15, 0x9b,\n      0x15, 0xbd, 0x15, 0xe0, 0x16, 0x03, 0x16, 0x26, 0x16, 0x49, 0x16, 0x6c,\n      0x16, 0x8f, 0x16, 0xb2, 0x16, 0xd6, 0x16, 0xfa, 0x17, 0x1d, 0x17, 0x41,\n      0x17, 0x65, 0x17, 0x89, 0x17, 0xae, 0x17, 0xd2, 0x17, 0xf7, 0x18, 0x1b,\n      0x18, 0x40, 0x18, 0x65, 0x18, 0x8a, 0x18, 0xaf, 0x18, 0xd5, 0x18, 0xfa,\n      0x19, 0x20, 0x19, 0x45, 0x19, 0x6b, 0x19, 0x91, 0x19, 0xb7, 0x19, 0xdd,\n      0x1a, 0x04, 0x1a, 0x2a, 0x1a, 0x51, 0x1a, 0x77, 0x1a, 0x9e, 0x1a, 0xc5,\n      0x1a, 0xec, 0x1b, 0x14, 0x1b, 0x3b, 0x1b, 0x63, 0x1b, 0x8a, 0x1b, 0xb2,\n      0x1b, 0xda, 0x1c, 0x02, 0x1c, 0x2a, 0x1c, 0x52, 0x1c, 0x7b, 0x1c, 0xa3,\n      0x1c, 0xcc, 0x1c, 0xf5, 0x1d, 0x1e, 0x1d, 0x47, 0x1d, 0x70, 0x1d, 0x99,\n      0x1d, 0xc3, 0x1d, 0xec, 0x1e, 0x16, 0x1e, 0x40, 0x1e, 0x6a, 0x1e, 0x94,\n      0x1e, 0xbe, 0x1e, 0xe9, 0x1f, 0x13, 0x1f, 0x3e, 0x1f, 0x69, 0x1f, 0x94,\n      0x1f, 0xbf, 0x1f, 0xea, 0x20, 0x15, 0x20, 0x41, 0x20, 0x6c, 0x20, 0x98,\n      0x20, 0xc4, 0x20, 0xf0, 0x21, 0x1c, 0x21, 0x48, 0x21, 0x75, 0x21, 0xa1,\n      0x21, 0xce, 0x21, 0xfb, 0x22, 0x27, 0x22, 0x55, 0x22, 0x82, 0x22, 0xaf,\n      0x22, 0xdd, 0x23, 0x0a, 0x23, 0x38, 0x23, 0x66, 0x23, 0x94, 0x23, 0xc2,\n      0x23, 0xf0, 0x24, 0x1f, 0x24, 0x4d, 0x24, 0x7c, 0x24, 0xab, 0x24, 0xda,\n      0x25, 0x09, 0x25, 0x38, 0x25, 0x68, 0x25, 0x97, 0x25, 0xc7, 0x25, 0xf7,\n      0x26, 0x27, 0x26, 0x57, 0x26, 0x87, 0x26, 0xb7, 0x26, 0xe8, 0x27, 0x18,\n      0x27, 0x49, 0x27, 0x7a, 0x27, 0xab, 0x27, 0xdc, 0x28, 0x0d, 0x28, 0x3f,\n      0x28, 0x71, 0x28, 0xa2, 0x28, 0xd4, 0x29, 0x06, 0x29, 0x38, 0x29, 0x6b,\n      0x29, 0x9d, 0x29, 0xd0, 0x2a, 0x02, 0x2a, 0x35, 0x2a, 0x68, 0x2a, 0x9b,\n      0x2a, 0xcf, 0x2b, 0x02, 0x2b, 0x36, 0x2b, 0x69, 0x2b, 0x9d, 0x2b, 0xd1,\n      0x2c, 0x05, 0x2c, 0x39, 0x2c, 0x6e, 0x2c, 0xa2, 0x2c, 0xd7, 0x2d, 0x0c,\n      0x2d, 0x41, 0x2d, 0x76, 0x2d, 0xab, 0x2d, 0xe1, 0x2e, 0x16, 0x2e, 0x4c,\n      0x2e, 0x82, 0x2e, 0xb7, 0x2e, 0xee, 0x2f, 0x24, 0x2f, 0x5a, 0x2f, 0x91,\n      0x2f, 0xc7, 0x2f, 0xfe, 0x30, 0x35, 0x30, 0x6c, 0x30, 0xa4, 0x30, 0xdb,\n      0x31, 0x12, 0x31, 0x4a, 0x31, 0x82, 0x31, 0xba, 0x31, 0xf2, 0x32, 0x2a,\n      0x32, 0x63, 0x32, 0x9b, 0x32, 0xd4, 0x33, 0x0d, 0x33, 0x46, 0x33, 0x7f,\n      0x33, 0xb8, 0x33, 0xf1, 0x34, 0x2b, 0x34, 0x65, 0x34, 0x9e, 0x34, 0xd8,\n      0x35, 0x13, 0x35, 0x4d, 0x35, 0x87, 0x35, 0xc2, 0x35, 0xfd, 0x36, 0x37,\n      0x36, 0x72, 0x36, 0xae, 0x36, 0xe9, 0x37, 0x24, 0x37, 0x60, 0x37, 0x9c,\n      0x37, 0xd7, 0x38, 0x14, 0x38, 0x50, 0x38, 0x8c, 0x38, 0xc8, 0x39, 0x05,\n      0x39, 0x42, 0x39, 0x7f, 0x39, 0xbc, 0x39, 0xf9, 0x3a, 0x36, 0x3a, 0x74,\n      0x3a, 0xb2, 0x3a, 0xef, 0x3b, 0x2d, 0x3b, 0x6b, 0x3b, 0xaa, 0x3b, 0xe8,\n      0x3c, 0x27, 0x3c, 0x65, 0x3c, 0xa4, 0x3c, 0xe3, 0x3d, 0x22, 0x3d, 0x61,\n      0x3d, 0xa1, 0x3d, 0xe0, 0x3e, 0x20, 0x3e, 0x60, 0x3e, 0xa0, 0x3e, 0xe0,\n      0x3f, 0x21, 0x3f, 0x61, 0x3f, 0xa2, 0x3f, 0xe2, 0x40, 0x23, 0x40, 0x64,\n      0x40, 0xa6, 0x40, 0xe7, 0x41, 0x29, 0x41, 0x6a, 0x41, 0xac, 0x41, 0xee,\n      0x42, 0x30, 0x42, 0x72, 0x42, 0xb5, 0x42, 0xf7, 0x43, 0x3a, 0x43, 0x7d,\n      0x43, 0xc0, 0x44, 0x03, 0x44, 0x47, 0x44, 0x8a, 0x44, 0xce, 0x45, 0x12,\n      0x45, 0x55, 0x45, 0x9a, 0x45, 0xde, 0x46, 0x22, 0x46, 0x67, 0x46, 0xab,\n      0x46, 0xf0, 0x47, 0x35, 0x47, 0x7b, 0x47, 0xc0, 0x48, 0x05, 0x48, 0x4b,\n      0x48, 0x91, 0x48, 0xd7, 0x49, 0x1d, 0x49, 0x63, 0x49, 0xa9, 0x49, 0xf0,\n      0x4a, 0x37, 0x4a, 0x7d, 0x4a, 0xc4, 0x4b, 0x0c, 0x4b, 0x53, 0x4b, 0x9a,\n      0x4b, 0xe2, 0x4c, 0x2a, 0x4c, 0x72, 0x4c, 0xba, 0x4d, 0x02, 0x4d, 0x4a,\n      0x4d, 0x93, 0x4d, 0xdc, 0x4e, 0x25, 0x4e, 0x6e, 0x4e, 0xb7, 0x4f, 0x00,\n      0x4f, 0x49, 0x4f, 0x93, 0x4f, 0xdd, 0x50, 0x27, 0x50, 0x71, 0x50, 0xbb,\n      0x51, 0x06, 0x51, 0x50, 0x51, 0x9b, 0x51, 0xe6, 0x52, 0x31, 0x52, 0x7c,\n      0x52, 0xc7, 0x53, 0x13, 0x53, 0x5f, 0x53, 0xaa, 0x53, 0xf6, 0x54, 0x42,\n      0x54, 0x8f, 0x54, 0xdb, 0x55, 0x28, 0x55, 0x75, 0x55, 0xc2, 0x56, 0x0f,\n      0x56, 0x5c, 0x56, 0xa9, 0x56, 0xf7, 0x57, 0x44, 0x57, 0x92, 0x57, 0xe0,\n      0x58, 0x2f, 0x58, 0x7d, 0x58, 0xcb, 0x59, 0x1a, 0x59, 0x69, 0x59, 0xb8,\n      0x5a, 0x07, 0x5a, 0x56, 0x5a, 0xa6, 0x5a, 0xf5, 0x5b, 0x45, 0x5b, 0x95,\n      0x5b, 0xe5, 0x5c, 0x35, 0x5c, 0x86, 0x5c, 0xd6, 0x5d, 0x27, 0x5d, 0x78,\n      0x5d, 0xc9, 0x5e, 0x1a, 0x5e, 0x6c, 0x5e, 0xbd, 0x5f, 0x0f, 0x5f, 0x61,\n      0x5f, 0xb3, 0x60, 0x05, 0x60, 0x57, 0x60, 0xaa, 0x60, 0xfc, 0x61, 0x4f,\n      0x61, 0xa2, 0x61, 0xf5, 0x62, 0x49, 0x62, 0x9c, 0x62, 0xf0, 0x63, 0x43,\n      0x63, 0x97, 0x63, 0xeb, 0x64, 0x40, 0x64, 0x94, 0x64, 0xe9, 0x65, 0x3d,\n      0x65, 0x92, 0x65, 0xe7, 0x66, 0x3d, 0x66, 0x92, 0x66, 0xe8, 0x67, 0x3d,\n      0x67, 0x93, 0x67, 0xe9, 0x68, 0x3f, 0x68, 0x96, 0x68, 0xec, 0x69, 0x43,\n      0x69, 0x9a, 0x69, 0xf1, 0x6a, 0x48, 0x6a, 0x9f, 0x6a, 0xf7, 0x6b, 0x4f,\n      0x6b, 0xa7, 0x6b, 0xff, 0x6c, 0x57, 0x6c, 0xaf, 0x6d, 0x08, 0x6d, 0x60,\n      0x6d, 0xb9, 0x6e, 0x12, 0x6e, 0x6b, 0x6e, 0xc4, 0x6f, 0x1e, 0x6f, 0x78,\n      0x6f, 0xd1, 0x70, 0x2b, 0x70, 0x86, 0x70, 0xe0, 0x71, 0x3a, 0x71, 0x95,\n      0x71, 0xf0, 0x72, 0x4b, 0x72, 0xa6, 0x73, 0x01, 0x73, 0x5d, 0x73, 0xb8,\n      0x74, 0x14, 0x74, 0x70, 0x74, 0xcc, 0x75, 0x28, 0x75, 0x85, 0x75, 0xe1,\n      0x76, 0x3e, 0x76, 0x9b, 0x76, 0xf8, 0x77, 0x56, 0x77, 0xb3, 0x78, 0x11,\n      0x78, 0x6e, 0x78, 0xcc, 0x79, 0x2a, 0x79, 0x89, 0x79, 0xe7, 0x7a, 0x46,\n      0x7a, 0xa5, 0x7b, 0x04, 0x7b, 0x63, 0x7b, 0xc2, 0x7c, 0x21, 0x7c, 0x81,\n      0x7c, 0xe1, 0x7d, 0x41, 0x7d, 0xa1, 0x7e, 0x01, 0x7e, 0x62, 0x7e, 0xc2,\n      0x7f, 0x23, 0x7f, 0x84, 0x7f, 0xe5, 0x80, 0x47, 0x80, 0xa8, 0x81, 0x0a,\n      0x81, 0x6b, 0x81, 0xcd, 0x82, 0x30, 0x82, 0x92, 0x82, 0xf4, 0x83, 0x57,\n      0x83, 0xba, 0x84, 0x1d, 0x84, 0x80, 0x84, 0xe3, 0x85, 0x47, 0x85, 0xab,\n      0x86, 0x0e, 0x86, 0x72, 0x86, 0xd7, 0x87, 0x3b, 0x87, 0x9f, 0x88, 0x04,\n      0x88, 0x69, 0x88, 0xce, 0x89, 0x33, 0x89, 0x99, 0x89, 0xfe, 0x8a, 0x64,\n      0x8a, 0xca, 0x8b, 0x30, 0x8b, 0x96, 0x8b, 0xfc, 0x8c, 0x63, 0x8c, 0xca,\n      0x8d, 0x31, 0x8d, 0x98, 0x8d, 0xff, 0x8e, 0x66, 0x8e, 0xce, 0x8f, 0x36,\n      0x8f, 0x9e, 0x90, 0x06, 0x90, 0x6e, 0x90, 0xd6, 0x91, 0x3f, 0x91, 0xa8,\n      0x92, 0x11, 0x92, 0x7a, 0x92, 0xe3, 0x93, 0x4d, 0x93, 0xb6, 0x94, 0x20,\n      0x94, 0x8a, 0x94, 0xf4, 0x95, 0x5f, 0x95, 0xc9, 0x96, 0x34, 0x96, 0x9f,\n      0x97, 0x0a, 0x97, 0x75, 0x97, 0xe0, 0x98, 0x4c, 0x98, 0xb8, 0x99, 0x24,\n      0x99, 0x90, 0x99, 0xfc, 0x9a, 0x68, 0x9a, 0xd5, 0x9b, 0x42, 0x9b, 0xaf,\n      0x9c, 0x1c, 0x9c, 0x89, 0x9c, 0xf7, 0x9d, 0x64, 0x9d, 0xd2, 0x9e, 0x40,\n      0x9e, 0xae, 0x9f, 0x1d, 0x9f, 0x8b, 0x9f, 0xfa, 0xa0, 0x69, 0xa0, 0xd8,\n      0xa1, 0x47, 0xa1, 0xb6, 0xa2, 0x26, 0xa2, 0x96, 0xa3, 0x06, 0xa3, 0x76,\n      0xa3, 0xe6, 0xa4, 0x56, 0xa4, 0xc7, 0xa5, 0x38, 0xa5, 0xa9, 0xa6, 0x1a,\n      0xa6, 0x8b, 0xa6, 0xfd, 0xa7, 0x6e, 0xa7, 0xe0, 0xa8, 0x52, 0xa8, 0xc4,\n      0xa9, 0x37, 0xa9, 0xa9, 0xaa, 0x1c, 0xaa, 0x8f, 0xab, 0x02, 0xab, 0x75,\n      0xab, 0xe9, 0xac, 0x5c, 0xac, 0xd0, 0xad, 0x44, 0xad, 0xb8, 0xae, 0x2d,\n      0xae, 0xa1, 0xaf, 0x16, 0xaf, 0x8b, 0xb0, 0x00, 0xb0, 0x75, 0xb0, 0xea,\n      0xb1, 0x60, 0xb1, 0xd6, 0xb2, 0x4b, 0xb2, 0xc2, 0xb3, 0x38, 0xb3, 0xae,\n      0xb4, 0x25, 0xb4, 0x9c, 0xb5, 0x13, 0xb5, 0x8a, 0xb6, 0x01, 0xb6, 0x79,\n      0xb6, 0xf0, 0xb7, 0x68, 0xb7, 0xe0, 0xb8, 0x59, 0xb8, 0xd1, 0xb9, 0x4a,\n      0xb9, 0xc2, 0xba, 0x3b, 0xba, 0xb5, 0xbb, 0x2e, 0xbb, 0xa7, 0xbc, 0x21,\n      0xbc, 0x9b, 0xbd, 0x15, 0xbd, 0x8f, 0xbe, 0x0a, 0xbe, 0x84, 0xbe, 0xff,\n      0xbf, 0x7a, 0xbf, 0xf5, 0xc0, 0x70, 0xc0, 0xec, 0xc1, 0x67, 0xc1, 0xe3,\n      0xc2, 0x5f, 0xc2, 0xdb, 0xc3, 0x58, 0xc3, 0xd4, 0xc4, 0x51, 0xc4, 0xce,\n      0xc5, 0x4b, 0xc5, 0xc8, 0xc6, 0x46, 0xc6, 0xc3, 0xc7, 0x41, 0xc7, 0xbf,\n      0xc8, 0x3d, 0xc8, 0xbc, 0xc9, 0x3a, 0xc9, 0xb9, 0xca, 0x38, 0xca, 0xb7,\n      0xcb, 0x36, 0xcb, 0xb6, 0xcc, 0x35, 0xcc, 0xb5, 0xcd, 0x35, 0xcd, 0xb5,\n      0xce, 0x36, 0xce, 0xb6, 0xcf, 0x37, 0xcf, 0xb8, 0xd0, 0x39, 0xd0, 0xba,\n      0xd1, 0x3c, 0xd1, 0xbe, 0xd2, 0x3f, 0xd2, 0xc1, 0xd3, 0x44, 0xd3, 0xc6,\n      0xd4, 0x49, 0xd4, 0xcb, 0xd5, 0x4e, 0xd5, 0xd1, 0xd6, 0x55, 0xd6, 0xd8,\n      0xd7, 0x5c, 0xd7, 0xe0, 0xd8, 0x64, 0xd8, 0xe8, 0xd9, 0x6c, 0xd9, 0xf1,\n      0xda, 0x76, 0xda, 0xfb, 0xdb, 0x80, 0xdc, 0x05, 0xdc, 0x8a, 0xdd, 0x10,\n      0xdd, 0x96, 0xde, 0x1c, 0xde, 0xa2, 0xdf, 0x29, 0xdf, 0xaf, 0xe0, 0x36,\n      0xe0, 0xbd, 0xe1, 0x44, 0xe1, 0xcc, 0xe2, 0x53, 0xe2, 0xdb, 0xe3, 0x63,\n      0xe3, 0xeb, 0xe4, 0x73, 0xe4, 0xfc, 0xe5, 0x84, 0xe6, 0x0d, 0xe6, 0x96,\n      0xe7, 0x1f, 0xe7, 0xa9, 0xe8, 0x32, 0xe8, 0xbc, 0xe9, 0x46, 0xe9, 0xd0,\n      0xea, 0x5b, 0xea, 0xe5, 0xeb, 0x70, 0xeb, 0xfb, 0xec, 0x86, 0xed, 0x11,\n      0xed, 0x9c, 0xee, 0x28, 0xee, 0xb4, 0xef, 0x40, 0xef, 0xcc, 0xf0, 0x58,\n      0xf0, 0xe5, 0xf1, 0x72, 0xf1, 0xff, 0xf2, 0x8c, 0xf3, 0x19, 0xf3, 0xa7,\n      0xf4, 0x34, 0xf4, 0xc2, 0xf5, 0x50, 0xf5, 0xde, 0xf6, 0x6d, 0xf6, 0xfb,\n      0xf7, 0x8a, 0xf8, 0x19, 0xf8, 0xa8, 0xf9, 0x38, 0xf9, 0xc7, 0xfa, 0x57,\n      0xfa, 0xe7, 0xfb, 0x77, 0xfc, 0x07, 0xfc, 0x98, 0xfd, 0x29, 0xfd, 0xba,\n      0xfe, 0x4b, 0xfe, 0xdc, 0xff, 0x6d, 0xff, 0xff\n    };\n\n  StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (GetImageProfile(image,\"icc\") != (const StringInfo *) NULL)\n    return(MagickFalse);\n  profile=AcquireStringInfo(sizeof(sRGBProfile));\n  SetStringInfoDatum(profile,sRGBProfile);\n  status=SetImageProfile(image,\"icc\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name,\n  const void *datum,const size_t length,ExceptionInfo *exception)\n{\n#define ProfileImageTag  \"Profile/Image\"\n#define ThrowProfileException(severity,tag,context) \\\n{ \\\n  if (source_profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(source_profile); \\\n  if (target_profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(target_profile); \\\n  ThrowBinaryException(severity,tag,context); \\\n}\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(name != (const char *) NULL);\n  if ((datum == (const void *) NULL) || (length == 0))\n    {\n      char\n        *next;\n\n      /*\n        Delete image profile(s).\n      */\n      ResetImageProfileIterator(image);\n      for (next=GetNextImageProfile(image); next != (const char *) NULL; )\n      {\n        if (IsOptionMember(next,name) != MagickFalse)\n          {\n            (void) DeleteImageProfile(image,next);\n            ResetImageProfileIterator(image);\n          }\n        next=GetNextImageProfile(image);\n      }\n      return(MagickTrue);\n    }\n  /*\n    Add a ICC, IPTC, or generic profile to the image.\n  */\n  status=MagickTrue;\n  profile=AcquireStringInfo((size_t) length);\n  SetStringInfoDatum(profile,(unsigned char *) datum);\n  if ((LocaleCompare(name,\"icc\") != 0) && (LocaleCompare(name,\"icm\") != 0))\n    status=SetImageProfile(image,name,profile,exception);\n  else\n    {\n      const StringInfo\n        *icc_profile;\n\n      icc_profile=GetImageProfile(image,\"icc\");\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          const char\n            *value;\n\n          value=GetImageProperty(image,\"exif:ColorSpace\",exception);\n          (void) value;\n          if (LocaleCompare(value,\"1\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R98.\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          /* Future.\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R03.\") != 0)\n            (void) SetAdobeRGB1998ImageProfile(image,exception);\n          */\n          icc_profile=GetImageProfile(image,\"icc\");\n        }\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          profile=DestroyStringInfo(profile);\n          return(MagickTrue);\n        }\n#if !defined(MAGICKCORE_LCMS_DELEGATE)\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n        \"'%s' (LCMS)\",image->filename);\n#else\n      {\n        cmsHPROFILE\n          source_profile;\n\n        CMSExceptionInfo\n          cms_exception;\n\n        /*\n          Transform pixel colors as defined by the color profiles.\n        */\n        cmsSetLogErrorHandler(CMSExceptionHandler);\n        cms_exception.image=image;\n        cms_exception.exception=exception;\n        (void) cms_exception;\n        source_profile=cmsOpenProfileFromMemTHR((cmsContext) &cms_exception,\n          GetStringInfoDatum(profile),(cmsUInt32Number)\n          GetStringInfoLength(profile));\n        if (source_profile == (cmsHPROFILE) NULL)\n          ThrowBinaryException(ResourceLimitError,\n            \"ColorspaceColorProfileMismatch\",name);\n        if ((cmsGetDeviceClass(source_profile) != cmsSigLinkClass) &&\n            (icc_profile == (StringInfo *) NULL))\n          status=SetImageProfile(image,name,profile,exception);\n        else\n          {\n            CacheView\n              *image_view;\n\n            ColorspaceType\n              source_colorspace,\n              target_colorspace;\n\n            cmsColorSpaceSignature\n              signature;\n\n            cmsHPROFILE\n              target_profile;\n\n            cmsHTRANSFORM\n              *magick_restrict transform;\n\n            cmsUInt32Number\n              flags,\n              source_type,\n              target_type;\n\n            int\n              intent;\n\n            MagickOffsetType\n              progress;\n\n            size_t\n              source_channels,\n              target_channels;\n\n            ssize_t\n              y;\n\n            unsigned short\n              **magick_restrict source_pixels,\n              **magick_restrict target_pixels;\n\n            target_profile=(cmsHPROFILE) NULL;\n            if (icc_profile != (StringInfo *) NULL)\n              {\n                target_profile=source_profile;\n                source_profile=cmsOpenProfileFromMemTHR((cmsContext)\n                  &cms_exception,GetStringInfoDatum(icc_profile),\n                  (cmsUInt32Number) GetStringInfoLength(icc_profile));\n                if (source_profile == (cmsHPROFILE) NULL)\n                  ThrowProfileException(ResourceLimitError,\n                    \"ColorspaceColorProfileMismatch\",name);\n              }\n            switch (cmsGetColorSpace(source_profile))\n            {\n              case cmsSigCmykData:\n              {\n                source_colorspace=CMYKColorspace;\n                source_type=(cmsUInt32Number) TYPE_CMYK_16;\n                source_channels=4;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                source_colorspace=GRAYColorspace;\n                source_type=(cmsUInt32Number) TYPE_GRAY_16;\n                source_channels=1;\n                break;\n              }\n              case cmsSigLabData:\n              {\n                source_colorspace=LabColorspace;\n                source_type=(cmsUInt32Number) TYPE_Lab_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigLuvData:\n              {\n                source_colorspace=YUVColorspace;\n                source_type=(cmsUInt32Number) TYPE_YUV_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                source_colorspace=sRGBColorspace;\n                source_type=(cmsUInt32Number) TYPE_RGB_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                source_colorspace=XYZColorspace;\n                source_type=(cmsUInt32Number) TYPE_XYZ_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigYCbCrData:\n              {\n                source_colorspace=YCbCrColorspace;\n                source_type=(cmsUInt32Number) TYPE_YCbCr_16;\n                source_channels=3;\n                break;\n              }\n              default:\n              {\n                source_colorspace=UndefinedColorspace;\n                source_type=(cmsUInt32Number) TYPE_RGB_16;\n                source_channels=3;\n                break;\n              }\n            }\n            signature=cmsGetPCS(source_profile);\n            if (target_profile != (cmsHPROFILE) NULL)\n              signature=cmsGetColorSpace(target_profile);\n            switch (signature)\n            {\n              case cmsSigCmykData:\n              {\n                target_colorspace=CMYKColorspace;\n                target_type=(cmsUInt32Number) TYPE_CMYK_16;\n                target_channels=4;\n                break;\n              }\n              case cmsSigLabData:\n              {\n                target_colorspace=LabColorspace;\n                target_type=(cmsUInt32Number) TYPE_Lab_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                target_colorspace=GRAYColorspace;\n                target_type=(cmsUInt32Number) TYPE_GRAY_16;\n                target_channels=1;\n                break;\n              }\n              case cmsSigLuvData:\n              {\n                target_colorspace=YUVColorspace;\n                target_type=(cmsUInt32Number) TYPE_YUV_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                target_colorspace=sRGBColorspace;\n                target_type=(cmsUInt32Number) TYPE_RGB_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                target_colorspace=XYZColorspace;\n                target_type=(cmsUInt32Number) TYPE_XYZ_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigYCbCrData:\n              {\n                target_colorspace=YCbCrColorspace;\n                target_type=(cmsUInt32Number) TYPE_YCbCr_16;\n                target_channels=3;\n                break;\n              }\n              default:\n              {\n                target_colorspace=UndefinedColorspace;\n                target_type=(cmsUInt32Number) TYPE_RGB_16;\n                target_channels=3;\n                break;\n              }\n            }\n            if ((source_colorspace == UndefinedColorspace) ||\n                (target_colorspace == UndefinedColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == GRAYColorspace) &&\n                 (SetImageGray(image,exception) == MagickFalse))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == CMYKColorspace) &&\n                 (image->colorspace != CMYKColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == XYZColorspace) &&\n                 (image->colorspace != XYZColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == YCbCrColorspace) &&\n                 (image->colorspace != YCbCrColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace != CMYKColorspace) &&\n                 (source_colorspace != LabColorspace) &&\n                 (source_colorspace != XYZColorspace) &&\n                 (source_colorspace != YCbCrColorspace) &&\n                 (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n            switch (image->rendering_intent)\n            {\n              case AbsoluteIntent: intent=INTENT_ABSOLUTE_COLORIMETRIC; break;\n              case PerceptualIntent: intent=INTENT_PERCEPTUAL; break;\n              case RelativeIntent: intent=INTENT_RELATIVE_COLORIMETRIC; break;\n              case SaturationIntent: intent=INTENT_SATURATION; break;\n              default: intent=INTENT_PERCEPTUAL; break;\n            }\n            flags=cmsFLAGS_HIGHRESPRECALC;\n#if defined(cmsFLAGS_BLACKPOINTCOMPENSATION)\n            if (image->black_point_compensation != MagickFalse)\n              flags|=cmsFLAGS_BLACKPOINTCOMPENSATION;\n#endif\n            transform=AcquireTransformThreadSet(image,source_profile,\n              source_type,target_profile,target_type,intent,flags);\n            if (transform == (cmsHTRANSFORM *) NULL)\n              ThrowProfileException(ImageError,\"UnableToCreateColorTransform\",\n                name);\n            /*\n              Transform image as dictated by the source & target image profiles.\n            */\n            source_pixels=AcquirePixelThreadSet(image->columns,source_channels);\n            target_pixels=AcquirePixelThreadSet(image->columns,target_channels);\n            if ((source_pixels == (unsigned short **) NULL) ||\n                (target_pixels == (unsigned short **) NULL))\n              {\n                transform=DestroyTransformThreadSet(transform);\n                ThrowProfileException(ResourceLimitError,\n                  \"MemoryAllocationFailed\",image->filename);\n              }\n            if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n              {\n                target_pixels=DestroyPixelThreadSet(target_pixels);\n                source_pixels=DestroyPixelThreadSet(source_pixels);\n                transform=DestroyTransformThreadSet(transform);\n                if (source_profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(source_profile);\n                if (target_profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(target_profile);\n                return(MagickFalse);\n              }\n            if (target_colorspace == CMYKColorspace)\n              (void) SetImageColorspace(image,target_colorspace,exception);\n            progress=0;\n            image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel for schedule(static,4) shared(status) \\\n              magick_threads(image,image,image->rows,1)\n#endif\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const int\n                id = GetOpenMPThreadId();\n\n              MagickBooleanType\n                sync;\n\n              register ssize_t\n                x;\n\n              register Quantum\n                *magick_restrict q;\n\n              register unsigned short\n                *p;\n\n              if (status == MagickFalse)\n                continue;\n              q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                {\n                  status=MagickFalse;\n                  continue;\n                }\n              p=source_pixels[id];\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *p++=ScaleQuantumToShort(GetPixelRed(image,q));\n                if (source_channels > 1)\n                  {\n                    *p++=ScaleQuantumToShort(GetPixelGreen(image,q));\n                    *p++=ScaleQuantumToShort(GetPixelBlue(image,q));\n                  }\n                if (source_channels > 3)\n                  *p++=ScaleQuantumToShort(GetPixelBlack(image,q));\n                q+=GetPixelChannels(image);\n              }\n              cmsDoTransform(transform[id],source_pixels[id],target_pixels[id],\n                (unsigned int) image->columns);\n              p=target_pixels[id];\n              q-=GetPixelChannels(image)*image->columns;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (target_channels == 1)\n                  SetPixelGray(image,ScaleShortToQuantum(*p),q);\n                else\n                  SetPixelRed(image,ScaleShortToQuantum(*p),q);\n                p++;\n                if (target_channels > 1)\n                  {\n                    SetPixelGreen(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                    SetPixelBlue(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                  }\n                if (target_channels > 3)\n                  {\n                    SetPixelBlack(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                  }\n                q+=GetPixelChannels(image);\n              }\n              sync=SyncCacheViewAuthenticPixels(image_view,exception);\n              if (sync == MagickFalse)\n                status=MagickFalse;\n              if (image->progress_monitor != (MagickProgressMonitor) NULL)\n                {\n                  MagickBooleanType\n                    proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n                  #pragma omp critical (MagickCore_ProfileImage)\n#endif\n                  proceed=SetImageProgress(image,ProfileImageTag,progress++,\n                    image->rows);\n                  if (proceed == MagickFalse)\n                    status=MagickFalse;\n                }\n            }\n            image_view=DestroyCacheView(image_view);\n            (void) SetImageColorspace(image,target_colorspace,exception);\n            switch (signature)\n            {\n              case cmsSigRgbData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  TrueColorType : TrueColorAlphaType;\n                break;\n              }\n              case cmsSigCmykData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  ColorSeparationType : ColorSeparationAlphaType;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  GrayscaleType : GrayscaleAlphaType;\n                break;\n              }\n              default:\n                break;\n            }\n            target_pixels=DestroyPixelThreadSet(target_pixels);\n            source_pixels=DestroyPixelThreadSet(source_pixels);\n            transform=DestroyTransformThreadSet(transform);\n            if ((status != MagickFalse) &&\n                (cmsGetDeviceClass(source_profile) != cmsSigLinkClass))\n              status=SetImageProfile(image,name,profile,exception);\n            if (target_profile != (cmsHPROFILE) NULL)\n              (void) cmsCloseProfile(target_profile);\n          }\n        (void) cmsCloseProfile(source_profile);\n      }\n#endif\n    }\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProfile() removes a named profile from the image and returns its\n%  value.\n%\n%  The format of the RemoveImageProfile method is:\n%\n%      void *RemoveImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport StringInfo *RemoveImageProfile(Image *image,const char *name)\n{\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  profile=(StringInfo *) RemoveNodeFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t P r o f i l e I t e r a t o r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImageProfileIterator() resets the image profile iterator.  Use it in\n%  conjunction with GetNextImageProfile() to iterate over all the profiles\n%  associated with an image.\n%\n%  The format of the ResetImageProfileIterator method is:\n%\n%      ResetImageProfileIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImageProfileIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProfile() adds a named profile to the image.  If a profile with the\n%  same name already exists, it is replaced.  This method differs from the\n%  ProfileImage() method in that it does not apply CMS color profiles.\n%\n%  The format of the SetImageProfile method is:\n%\n%      MagickBooleanType SetImageProfile(Image *image,const char *name,\n%        const StringInfo *profile)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name, for example icc, exif, and 8bim (8bim is the\n%      Photoshop wrapper for iptc profiles).\n%\n%    o profile: A StringInfo structure that contains the named profile.\n%\n*/\n\nstatic void *DestroyProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n\nstatic inline const unsigned char *ReadResourceByte(const unsigned char *p,\n  unsigned char *quantum)\n{\n  *quantum=(*p++);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceLong(const unsigned char *p,\n  unsigned int *quantum)\n{\n  *quantum=(size_t) (*p++ << 24);\n  *quantum|=(size_t) (*p++ << 16);\n  *quantum|=(size_t) (*p++ << 8);\n  *quantum|=(size_t) (*p++ << 0);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceShort(const unsigned char *p,\n  unsigned short *quantum)\n{\n  *quantum=(unsigned short) (*p++ << 8);\n  *quantum|=(unsigned short) (*p++ << 0);\n  return(p);\n}static inline void WriteResourceLong(unsigned char *p,\n  const unsigned int quantum)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) (quantum >> 24);\n  buffer[1]=(unsigned char) (quantum >> 16);\n  buffer[2]=(unsigned char) (quantum >> 8);\n  buffer[3]=(unsigned char) quantum;\n  (void) CopyMagickMemory(p,buffer,4);\n}\n\nstatic void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n  const unsigned char\n    *datum,\n    *q;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((count & 0x01) != 0)\n      count++;\n    if ((count < 0) || (p > (datum+length-count)) ||\n        (count > (ssize_t) length))\n      break;\n    if (id != profile_id)\n      p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_count;\n\n        StringInfo\n          *extract_profile;\n\n        extract_count=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_count=profile->length;\n            if ((extract_count & 0x01) != 0)\n              extract_count++;\n            extract_profile=AcquireStringInfo(offset+extract_count+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset-4);\n            WriteResourceLong(extract_profile->datum+offset-4,\n              (unsigned int)profile->length);\n            (void) CopyMagickMemory(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) CopyMagickMemory(extract_profile->datum+offset+extract_count,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}\n\nstatic void GetProfilesFromResourceBlock(Image *image,\n  const StringInfo *resource_block,ExceptionInfo *exception)\n{\n  const unsigned char\n    *datum;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    length_byte;\n\n   unsigned int\n     value;\n\n  unsigned short\n    id;\n\n  datum=GetStringInfoDatum(resource_block);\n  length=GetStringInfoLength(resource_block);\n  for (p=datum; p < (datum+length-16); )\n  {\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length) ||\n        (count < 0))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        unsigned int\n          resolution;\n\n        unsigned short\n          units;\n\n        /*\n          Resolution.\n        */\n        p=ReadResourceLong(p,&resolution);\n        image->resolution.x=((double) resolution)/65536.0;\n        p=ReadResourceShort(p,&units)+2;\n        p=ReadResourceLong(p,&resolution)+4;\n        image->resolution.y=((double) resolution)/65536.0;\n        /*\n          Values are always stored as pixels per inch.\n        */\n        if ((ResolutionType) units != PixelsPerCentimeterResolution)\n          image->units=PixelsPerInchResolution;\n        else\n          {\n            image->units=PixelsPerCentimeterResolution;\n            image->resolution.x/=2.54;\n            image->resolution.y/=2.54;\n          }\n        break;\n      }\n      case 0x0404:\n      {\n        /*\n          IPTC Profile\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"iptc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x040c:\n      {\n        /*\n          Thumbnail.\n        */\n        p+=count;\n        break;\n      }\n      case 0x040f:\n      {\n        /*\n          ICC Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"icc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0422:\n      {\n        /*\n          EXIF Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"exif\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0424:\n      {\n        /*\n          XMP Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"xmp\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic MagickBooleanType SetImageProfileInternal(Image *image,const char *name,\n  const StringInfo *profile,const MagickBooleanType recursive,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    property[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MagickPathExtent);\n  LocaleLower(key);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if (status != MagickFalse)\n    {\n      if (LocaleCompare(name,\"8bim\") == 0)\n        GetProfilesFromResourceBlock(image,profile,exception);\n      else if (recursive == MagickFalse)\n        WriteTo8BimProfile(image,name,profile);\n    }\n  /*\n    Inject profile into image properties.\n  */\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s:*\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  return(SetImageProfileInternal(image,name,profile,MagickFalse,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e P r o f i l e s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageProfiles() synchronizes image properties with the image profiles.\n%  Currently we only support updating the EXIF resolution and orientation.\n%\n%  The format of the SyncImageProfiles method is:\n%\n%      MagickBooleanType SyncImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic inline int ReadProfileByte(unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed short ReadProfileShort(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) ((buffer[1] << 8) | buffer[0]);\n      quantum.unsigned_value=(value & 0xffff);\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) ((((unsigned char *) buffer)[0] << 8) |\n    ((unsigned char *) buffer)[1]);\n  quantum.unsigned_value=(value & 0xffff);\n  return(quantum.signed_value);\n}\n\nstatic inline signed int ReadProfileLong(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      quantum.unsigned_value=(value & 0xffffffff);\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  quantum.unsigned_value=(value & 0xffffffff);\n  return(quantum.signed_value);\n}\n\nstatic inline signed int ReadProfileMSBLong(unsigned char **p,size_t *length)\n{\n  signed int\n    value;\n\n  if (*length < 4)\n    return(0);\n  value=ReadProfileLong(MSBEndian,*p);\n  (*length)-=4;\n  *p+=4;\n  return(value);\n}\n\nstatic inline signed short ReadProfileMSBShort(unsigned char **p,\n  size_t *length)\n{\n  signed short\n    value;\n\n  if (*length < 2)\n    return(0);\n  value=ReadProfileShort(MSBEndian,*p);\n  (*length)-=2;\n  *p+=2;\n  return(value);\n}\n\nstatic inline void WriteProfileLong(const EndianType endian,\n  const size_t value,unsigned char *p)\n{\n  unsigned char\n    buffer[4];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      (void) CopyMagickMemory(p,buffer,4);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  (void) CopyMagickMemory(p,buffer,4);\n}\n\nstatic void WriteProfileShort(const EndianType endian,\n  const unsigned short value,unsigned char *p)\n{\n  unsigned char\n    buffer[2];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      (void) CopyMagickMemory(p,buffer,2);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  (void) CopyMagickMemory(p,buffer,2);\n}\n\nstatic MagickBooleanType Sync8BimProfile(Image *image,StringInfo *profile)\n{\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *p;\n\n  unsigned short\n    id;\n\n  length=GetStringInfoLength(profile);\n  p=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadProfileByte(&p,&length) != 0x38)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x42)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x49)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x4D)\n      continue;\n    if (length < 7)\n      return(MagickFalse);\n    id=ReadProfileMSBShort(&p,&length);\n    count=(ssize_t) ReadProfileByte(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return(MagickFalse);\n    p+=count;\n    if ((*p & 0x01) == 0)\n      (void) ReadProfileByte(&p,&length);\n    count=(ssize_t) ReadProfileMSBLong(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return(MagickFalse);\n    if ((id == 0x3ED) && (count == 16))\n      {\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.x*2.54*\n            65536.0),p);\n        else\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.x*\n            65536.0),p);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+4);\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.y*2.54*\n            65536.0),p+8);\n        else\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.y*\n            65536.0),p+8);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+12);\n      }\n    p+=count;\n    length-=count;\n  }\n  return(MagickTrue);\n}\n\nMagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format-1) >= EXIF_NUM_FORMATS)\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}\n\nMagickPrivate MagickBooleanType SyncImageProfiles(Image *image)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  status=MagickTrue;\n  profile=(StringInfo *) GetImageProfile(image,\"8BIM\");\n  if (profile != (StringInfo *) NULL)\n    if (Sync8BimProfile(image,profile) == MagickFalse)\n      status=MagickFalse;\n  profile=(StringInfo *) GetImageProfile(image,\"EXIF\");\n  if (profile != (StringInfo *) NULL)\n    if (SyncExifProfile(image,profile) == MagickFalse)\n      status=MagickFalse;\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%            PPPP    RRRR    OOO   PPPP   EEEEE  RRRR   TTTTT  Y   Y          %\n%            P   P   R   R  O   O  P   P  E      R   R    T     Y Y           %\n%            PPPP    RRRR   O   O  PPPP   EEE    RRRR     T      Y            %\n%            P       R R    O   O  P      E      R R      T      Y            %\n%            P       R  R    OOO   P      EEEEE  R  R     T      Y            %\n%                                                                             %\n%                                                                             %\n%                         MagickCore Property Methods                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/compare.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/fx-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/locale-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS2_LCMS2_H)\n#include <lcms2/lcms2.h>\n#elif defined(MAGICKCORE_HAVE_LCMS2_H)\n#include \"lcms2.h\"\n#elif defined(MAGICKCORE_HAVE_LCMS_LCMS_H)\n#include <lcms/lcms.h>\n#else\n#include \"lcms.h\"\n#endif\n#endif\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o p e r t i e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProperties() clones all the image properties to another image.\n%\n%  The format of the CloneImageProperties method is:\n%\n%      MagickBooleanType CloneImageProperties(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProperties(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      clone_image->filename);\n  (void) CopyMagickString(image->filename,clone_image->filename,MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,clone_image->magick_filename,\n    MagickPathExtent);\n  image->compression=clone_image->compression;\n  image->quality=clone_image->quality;\n  image->depth=clone_image->depth;\n  image->alpha_color=clone_image->alpha_color;\n  image->background_color=clone_image->background_color;\n  image->border_color=clone_image->border_color;\n  image->transparent_color=clone_image->transparent_color;\n  image->gamma=clone_image->gamma;\n  image->chromaticity=clone_image->chromaticity;\n  image->rendering_intent=clone_image->rendering_intent;\n  image->black_point_compensation=clone_image->black_point_compensation;\n  image->units=clone_image->units;\n  image->montage=(char *) NULL;\n  image->directory=(char *) NULL;\n  (void) CloneString(&image->geometry,clone_image->geometry);\n  image->offset=clone_image->offset;\n  image->resolution.x=clone_image->resolution.x;\n  image->resolution.y=clone_image->resolution.y;\n  image->page=clone_image->page;\n  image->tile_offset=clone_image->tile_offset;\n  image->extract_info=clone_image->extract_info;\n  image->filter=clone_image->filter;\n  image->fuzz=clone_image->fuzz;\n  image->intensity=clone_image->intensity;\n  image->interlace=clone_image->interlace;\n  image->interpolate=clone_image->interpolate;\n  image->endian=clone_image->endian;\n  image->gravity=clone_image->gravity;\n  image->compose=clone_image->compose;\n  image->orientation=clone_image->orientation;\n  image->scene=clone_image->scene;\n  image->dispose=clone_image->dispose;\n  image->delay=clone_image->delay;\n  image->ticks_per_second=clone_image->ticks_per_second;\n  image->iterations=clone_image->iterations;\n  image->total_colors=clone_image->total_colors;\n  image->taint=clone_image->taint;\n  image->progress_monitor=clone_image->progress_monitor;\n  image->client_data=clone_image->client_data;\n  image->start_loop=clone_image->start_loop;\n  image->error=clone_image->error;\n  image->signature=clone_image->signature;\n  if (clone_image->properties != (void *) NULL)\n    {\n      if (image->properties != (void *) NULL)\n        DestroyImageProperties(image);\n      image->properties=CloneSplayTree((SplayTreeInfo *)\n        clone_image->properties,(void *(*)(void *)) ConstantString,\n        (void *(*)(void *)) ConstantString);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e f i n e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefineImageProperty() associates an assignment string of the form\n%  \"key=value\" with an artifact or options. It is equivelent to\n%  SetImageProperty()\n%\n%  The format of the DefineImageProperty method is:\n%\n%      MagickBooleanType DefineImageProperty(Image *image,const char *property,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DefineImageProperty(Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n\n  register char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(property != (const char *) NULL);\n  (void) CopyMagickString(key,property,MagickPathExtent-1);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageProperty(image,key,value,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProperty() deletes an image property.\n%\n%  The format of the DeleteImageProperty method is:\n%\n%      MagickBooleanType DeleteImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProperty(Image *image,\n  const char *property)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return(MagickFalse);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->properties,property));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o p e r t i e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProperties() destroys all properties and associated memory\n%  attached to the given image.\n%\n%  The format of the DestroyDefines method is:\n%\n%      void DestroyImageProperties(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t I m a g e P r o p e r t y                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatImageProperty() permits formatted property/value pairs to be saved as\n%  an image property.\n%\n%  The format of the FormatImageProperty method is:\n%\n%      MagickBooleanType FormatImageProperty(Image *image,const char *property,\n%        const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o  image:  The image.\n%\n%   o  property:  The attribute property.\n%\n%   o  format:  A string describing the format to use to write the remaining\n%      arguments.\n%\n*/\nMagickExport MagickBooleanType FormatImageProperty(Image *image,\n  const char *property,const char *format,...)\n{\n  char\n    value[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(value,MagickPathExtent,format,operands);\n  (void) n;\n  va_end(operands);\n  exception=AcquireExceptionInfo();\n  status=SetImageProperty(image,property,value,exception);\n  exception=DestroyExceptionInfo(exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProperty() gets a value associated with an image property.\n%\n%  This includes,  profile prefixes, such as \"exif:\", \"iptc:\" and \"8bim:\"\n%  It does not handle non-prifile prefixes, such as \"fx:\", \"option:\", or\n%  \"artifact:\".\n%\n%  The returned string is stored as a properity of the same name for faster\n%  lookup later. It should NOT be freed by the caller.\n%\n%  The format of the GetImageProperty method is:\n%\n%      const char *GetImageProperty(const Image *image,const char *key,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char\n  *TracePSClippath(const unsigned char *,size_t),\n  *TraceSVGClippath(const unsigned char *,size_t,const size_t,\n    const size_t);\n\nstatic MagickBooleanType GetIPTCProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    *message;\n\n  const StringInfo\n    *profile;\n\n  long\n    count,\n    dataset,\n    record;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=sscanf(key,\"IPTC:%ld:%ld\",&dataset,&record);\n  if (count != 2)\n    return(MagickFalse);\n  attribute=(char *) NULL;\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=(ssize_t) length)\n  {\n    length=1;\n    if ((ssize_t) GetStringInfoDatum(profile)[i] != 0x1c)\n      continue;\n    length=(size_t) (GetStringInfoDatum(profile)[i+3] << 8);\n    length|=GetStringInfoDatum(profile)[i+4];\n    if (((long) GetStringInfoDatum(profile)[i+1] == dataset) &&\n        ((long) GetStringInfoDatum(profile)[i+2] == record))\n      {\n        message=(char *) NULL;\n        if (~length >= 1)\n          message=(char *) AcquireQuantumMemory(length+1UL,sizeof(*message));\n        if (message != (char *) NULL)\n          {\n            (void) CopyMagickString(message,(char *) GetStringInfoDatum(\n              profile)+i+5,length+1);\n            (void) ConcatenateString(&attribute,message);\n            (void) ConcatenateString(&attribute,\";\");\n            message=DestroyString(message);\n          }\n      }\n    i+=5;\n  }\n  if ((attribute == (char *) NULL) || (*attribute == ';'))\n    {\n      if (attribute != (char *) NULL)\n        attribute=DestroyString(attribute);\n      return(MagickFalse);\n    }\n  attribute[strlen(attribute)-1]='\\0';\n  (void) SetImageProperty((Image *) image,key,(const char *) attribute,\n    exception);\n  attribute=DestroyString(attribute);\n  return(MagickTrue);\n}\n\nstatic inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed int ReadPropertyMSBLong(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[4];\n\n  size_t\n    value;\n\n  if (*length < 4)\n    return(-1);\n  for (i=0; i < 4; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(size_t) (buffer[0] << 24);\n  value|=buffer[1] << 16;\n  value|=buffer[2] << 8;\n  value|=buffer[3];\n  quantum.unsigned_value=(value & 0xffffffff);\n  return(quantum.signed_value);\n}\n\nstatic inline signed short ReadPropertyMSBShort(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[2];\n\n  unsigned short\n    value;\n\n  if (*length < 2)\n    return((unsigned short) ~0);\n  for (i=0; i < 2; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned short) (buffer[0] << 8);\n  value|=buffer[1];\n  quantum.unsigned_value=(value & 0xffff);\n  return(quantum.signed_value);\n}\n\nstatic MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  size_t\n    length;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *)\n            attribute,exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}\n\nstatic inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      quantum.unsigned_value=(value & 0xffffffff);\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  quantum.unsigned_value=(value & 0xffffffff);\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned int ReadPropertyUnsignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      return((unsigned int) (value & 0xffffffff));\n    }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  return((unsigned int) (value & 0xffffffff));\n}   \n\nstatic inline signed short ReadPropertySignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) ((buffer[1] << 8) | buffer[0]);\n      quantum.unsigned_value=(value & 0xffff);\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) ((((unsigned char *) buffer)[0] << 8) |\n    ((unsigned char *) buffer)[1]);\n  quantum.unsigned_value=(value & 0xffff);\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned short ReadPropertyUnsignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) ((buffer[1] << 8) | buffer[0]);\n      return((unsigned short) (value & 0xffff));\n    }\n  value=(unsigned short) ((((unsigned char *) buffer)[0] << 8) |\n    ((unsigned char *) buffer)[1]);\n  return((unsigned short) (value & 0xffff));\n}\n\nstatic MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",arg); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n      *description;\n  } TagInfo;\n\n  static TagInfo\n    EXIFTag[] =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002, \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\" },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\" },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\" },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\" },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\" },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\" },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\" },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\" },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\" },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\" },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\" },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\" },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\" },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\" },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\" },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\" },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\" },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\" },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\" },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\" },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\" },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\" },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\" },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\" },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\" },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\" },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\" },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\" },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203, \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\" },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\" },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\" },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\" },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\" },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301, \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\" },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\" },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n      {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\" },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\" },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\" },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\" },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\" },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\" },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\" },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\" },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\" },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n      {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026, \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\" },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\" },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\" },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n      {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\" },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\" },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\" },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\" },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\" },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\" },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\" },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\" },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\" },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\" },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\" },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\" },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769, \"exif:ExifOffset\" },\n      {  0x8773, \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\" },\n      {  0x8827, \"exif:ISOSpeedRatings\" },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\" },\n      {  0x9000, \"exif:ExifVersion\" },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\" },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n      {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\" },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\" },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\" },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\" },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\" },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9211, \"exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n      {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\" },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\" },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\" },\n      {  0x9C9f, \"exif:WinXP-Subject\" },\n      {  0x9286, \"exif:UserComment\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },\n      {  0xa000, \"exif:FlashPixVersion\" },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:ExifImageWidth\" },\n      {  0xa003, \"exif:ExifImageLength\" },\n      {  0xa004, \"exif:RelatedSoundFile\" },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\" },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\" },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\" },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\" },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\" },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\" },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\" },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n      {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\" },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\" },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\" },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\" },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\" },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\" },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\" },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\" },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\" },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\" },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\" },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\" },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\" },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\" },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\" },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\" },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\" },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\" },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\" },\n      { 0x00000, (const char *) NULL }\n    };\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property) <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in description=value format */\n      break;\n    }\n    case '!':\n    {\n      tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n        n;\n\n      /*\n        Check for a hex based tag specification first.\n      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n          c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A') && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n              if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n              else\n                return(MagickFalse);\n        }\n      } while (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n        Try to match the text with a tag name instead.\n      */\n      for (i=0; ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n        if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n            tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n      }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length) != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n      number_bytes=(size_t) components*tag_bytes[format];\n      if (number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if ((offset < 0) || (size_t) offset >= length)\n            continue;\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          p=(unsigned char *) (exif+offset);\n        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n          char\n            buffer[MagickPathExtent],\n            *value;\n\n          value=(char *) NULL;\n          *buffer='\\0';\n          switch (format)\n          {\n            case EXIF_FMT_BYTE:\n            case EXIF_FMT_UNDEFINED:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(unsigned char *) p1));\n              break;\n            }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_SLONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SRATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n                ReadPropertySignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SINGLE:\n            {\n              EXIFMultipleValues(4,\"%f\",(double) *(float *) p1);\n              break;\n            }\n            case EXIF_FMT_DOUBLE:\n            {\n              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n              break;\n            }\n            default:\n            case EXIF_FMT_STRING:\n            {\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  register ssize_t\n                    i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n          }\n          if (value != (char *) NULL)\n            {\n              char\n                *key;\n\n              register const char\n                *p;\n\n              key=AcquireString(property);\n              switch (all)\n              {\n                case 1:\n                {\n                  const char\n                    *description;\n\n                  register ssize_t\n                    i;\n\n                  description=\"unknown\";\n                  for (i=0; ; i++)\n                  {\n                    if (EXIFTag[i].tag == 0)\n                      break;\n                    if (EXIFTag[i].tag == tag_value)\n                      {\n                        description=EXIFTag[i].description;\n                        break;\n                      }\n                  }\n                  (void) FormatLocaleString(key,MagickPathExtent,\"%s\",\n                    description);\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n                case 2:\n                {\n                  if (tag_value < 0x10000)\n                    (void) FormatLocaleString(key,MagickPathExtent,\"#%04lx\",\n                      (unsigned long) tag_value);\n                  else\n                    if (tag_value < 0x20000)\n                      (void) FormatLocaleString(key,MagickPathExtent,\"@%04lx\",\n                        (unsigned long) (tag_value & 0xffff));\n                    else\n                      (void) FormatLocaleString(key,MagickPathExtent,\"unknown\");\n                  break;\n                }\n                default:\n                {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                }\n              }\n              p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                  image->properties,key);\n              if (p == (const char *) NULL)\n                (void) SetImageProperty((Image *) image,key,value,exception);\n              value=DestroyString(value);\n              key=DestroyString(key);\n              status=MagickTrue;\n            }\n        }\n        if ((tag_value == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n            if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n              {\n                ssize_t\n                  tag_offset1;\n\n                tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                  0);\n                directory_stack[level].directory=directory;\n                entry++;\n                directory_stack[level].entry=entry;\n                directory_stack[level].offset=tag_offset;\n                level++;\n                directory_stack[level].directory=exif+offset;\n                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n                level++;\n                if ((directory+2+(12*number_entries)) > (exif+length))\n                  break;\n                offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n                if ((offset != 0) && ((size_t) offset < length) &&\n                    (level < (MaxDirectoryStack-2)))\n                  {\n                    directory_stack[level].directory=exif+offset;\n                    directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n                    level++;\n                  }\n              }\n            break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}\n\nstatic MagickBooleanType GetICCProperty(const Image *image,const char *property,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  magick_unreferenced(property);\n\n  profile=GetImageProfile(image,\"icc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"icm\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 128)\n    return(MagickFalse);  /* minimum ICC profile length */\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n  {\n    cmsHPROFILE\n      icc_profile;\n\n    icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n      (cmsUInt32Number) GetStringInfoLength(profile));\n    if (icc_profile != (cmsHPROFILE *) NULL)\n      {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n        const char\n          *name;\n\n        name=cmsTakeProductName(icc_profile);\n        if (name != (const char *) NULL)\n          (void) SetImageProperty((Image *) image,\"icc:name\",name,exception);\n#else\n        char\n          info[MagickPathExtent];\n\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n          \"en\",\"US\",info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:description\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoManufacturer,\n          \"en\",\"US\",info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:manufacturer\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoModel,\"en\",\n          \"US\",info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:model\",info,exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoCopyright,\n          \"en\",\"US\",info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:copyright\",info,exception);\n#endif\n        (void) cmsCloseProfile(icc_profile);\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType SkipXMPValue(const char *value)\n{\n  if (value == (const char*) NULL)\n    return(MagickTrue);\n  while (*value != '\\0')\n  {\n    if (isspace((int) ((unsigned char) *value)) == 0)\n      return(MagickFalse);\n    value++;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType GetXMPProperty(const Image *image,const char *property)\n{\n  char\n    *xmp_profile;\n\n  const char\n    *content;\n\n  const StringInfo\n    *profile;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  XMLTreeInfo\n    *child,\n    *description,\n    *node,\n    *rdf,\n    *xmp;\n\n  profile=GetImageProfile(image,\"xmp\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  xmp_profile=StringInfoToString(profile);\n  if (xmp_profile == (char *) NULL)\n    return(MagickFalse);\n  for (p=xmp_profile; *p != '\\0'; p++)\n    if ((*p == '<') && (*(p+1) == 'x'))\n      break;\n  exception=AcquireExceptionInfo();\n  xmp=NewXMLTree((char *) p,exception);\n  xmp_profile=DestroyString(xmp_profile);\n  exception=DestroyExceptionInfo(exception);\n  if (xmp == (XMLTreeInfo *) NULL)\n    return(MagickFalse);\n  status=MagickFalse;\n  rdf=GetXMLTreeChild(xmp,\"rdf:RDF\");\n  if (rdf != (XMLTreeInfo *) NULL)\n    {\n      if (image->properties == (void *) NULL)\n        ((Image *) image)->properties=NewSplayTree(CompareSplayTreeString,\n          RelinquishMagickMemory,RelinquishMagickMemory);\n      description=GetXMLTreeChild(rdf,\"rdf:Description\");\n      while (description != (XMLTreeInfo *) NULL)\n      {\n        node=GetXMLTreeChild(description,(const char *) NULL);\n        while (node != (XMLTreeInfo *) NULL)\n        {\n          child=GetXMLTreeChild(node,(const char *) NULL);\n          content=GetXMLTreeContent(node);\n          if ((child == (XMLTreeInfo *) NULL) &&\n              (SkipXMPValue(content) == MagickFalse))\n            (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n              ConstantString(GetXMLTreeTag(node)),ConstantString(content));\n          while (child != (XMLTreeInfo *) NULL)\n          {\n            content=GetXMLTreeContent(child);\n            if (SkipXMPValue(content) == MagickFalse)\n              (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                ConstantString(GetXMLTreeTag(child)),ConstantString(content));\n            child=GetXMLTreeSibling(child);\n          }\n          node=GetXMLTreeSibling(node);\n        }\n        description=GetNextXMLTreeTag(description);\n      }\n    }\n  xmp=DestroyXMLTree(xmp);\n  return(status);\n}\n\nstatic char *TracePSClippath(const unsigned char *blob,size_t length)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    knot_count,\n    selector,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,\"/ClipImage\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"{\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  /c {curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  /l {lineto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  /m {moveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /v {currentpoint 6 2 roll curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /y {2 copy curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /z {closepath} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  newpath\\n\");\n  (void) ConcatenateString(&path,message);\n  /*\n    The clipping path format is defined in \"Adobe Photoshop File\n    Formats Specification\" version 6.0 downloadable from adobe.com.\n  */\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length > 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          size_t\n            xx,\n            yy;\n\n          yy=(size_t) ReadPropertyMSBLong(&blob,&length);\n          xx=(size_t) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x/4096/4096;\n          point[i].y=1.0-(double) y/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"  %g %g m\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l\\n\",point[1].x,point[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v\\n\",point[0].x,point[0].y,\n                  point[1].x,point[1].y);\n              else\n                if ((point[0].x == point[1].x) && (point[0].y == point[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y\\n\",last[2].x,last[2].y,\n                    point[1].x,point[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c\\n\",last[2].x,\n                    last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n            /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l z\\n\",first[1].x,first[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v z\\n\",first[0].x,first[0].y,\n                  first[1].x,first[1].y);\n              else\n                if ((first[0].x == first[1].x) && (first[0].y == first[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y z\\n\",last[2].x,last[2].y,\n                    first[1].x,first[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c z\\n\",last[2].x,\n                    last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Returns an empty PS path if the path has no knots.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"  eoclip\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"} bind def\");\n  (void) ConcatenateString(&path,message);\n  message=DestroyString(message);\n  return(path);\n}\n\nstatic char *TraceSVGClippath(const unsigned char *blob,size_t length,\n  const size_t columns,const size_t rows)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i;\n\n  ssize_t\n    knot_count,\n    selector,\n    x,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n    (void) FormatLocaleString(message,MagickPathExtent,\n    (\"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\\n\"\n    \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"\n    \" width=\\\"%.20g\\\" height=\\\"%.20g\\\">\\n\"\n    \"<g>\\n\"\n    \"<path fill-rule=\\\"evenodd\\\" style=\\\"fill:#00000000;stroke:#00000000;\"\n    \"stroke-width:0;stroke-antialiasing:false\\\" d=\\\"\\n\"),\n    (double) columns,(double) rows);\n  (void) ConcatenateString(&path,message);\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length != 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot.\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          unsigned int\n            xx,\n            yy;\n\n          yy=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          xx=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x*columns/4096/4096;\n          point[i].y=(double) y*rows/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"M %g %g\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g\\n\",point[1].x,point[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g\\n\",last[2].x,\n                last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n           /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g Z\\n\",first[1].x,first[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g Z\\n\",last[2].x,\n                last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Return an empty SVG image if the path does not have knots.\n  */\n  (void) ConcatenateString(&path,\"\\\"/>\\n</g>\\n</svg>\\n\");\n  message=DestroyString(message);\n  return(path);\n}\n\nMagickExport const char *GetImageProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  register const char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  p=(const char *) NULL;\n  if (image->properties != (void *) NULL)\n    {\n      if (property == (const char *) NULL)\n        {\n          ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n          p=(const char *) GetNextValueInSplayTree((SplayTreeInfo *)\n            image->properties);\n          return(p);\n        }\n        p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n          image->properties,property);\n        if (p != (const char *) NULL)\n          return(p);\n    }\n  if ((property == (const char *) NULL) ||\n      (strchr(property,':') == (char *) NULL))\n    return(p);\n  switch (*property)\n  {\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) Get8BIMProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) GetEXIFProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if ((LocaleNCompare(\"icc:\",property,4) == 0) ||\n          (LocaleNCompare(\"icm:\",property,4) == 0))\n        {\n          (void) GetICCProperty(image,property,exception);\n          break;\n        }\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) GetIPTCProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) GetXMPProperty(image,property);\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  if (image->properties != (void *) NULL)\n    {\n      p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n        image->properties,property);\n      return(p);\n    }\n  return((const char *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t M a g i c k P r o p e r t y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickProperty() gets attributes or calculated values that is associated\n%  with a fixed known property name, or single letter property. It may be\n%  called if no image is defined (IMv7), in which case only global image_info\n%  values are available:\n%\n%    \\n   newline\n%    \\r   carriage return\n%    <    less-than character.\n%    >    greater-than character.\n%    &    ampersand character.\n%    %%   a percent sign\n%    %b   file size of image read in\n%    %c   comment meta-data property\n%    %d   directory component of path\n%    %e   filename extension or suffix\n%    %f   filename (including suffix)\n%    %g   layer canvas page geometry   (equivalent to \"%Wx%H%X%Y\")\n%    %h   current image height in pixels\n%    %i   image filename (note: becomes output filename for \"info:\")\n%    %k   CALCULATED: number of unique colors\n%    %l   label meta-data property\n%    %m   image file format (file magic)\n%    %n   number of images in current image sequence\n%    %o   output filename  (used for delegates)\n%    %p   index of image in current image list\n%    %q   quantum depth (compile-time constant)\n%    %r   image class and colorspace\n%    %s   scene number (from input unless re-assigned)\n%    %t   filename without directory or extension (suffix)\n%    %u   unique temporary filename (used for delegates)\n%    %w   current width in pixels\n%    %x   x resolution (density)\n%    %y   y resolution (density)\n%    %z   image depth (as read in unless modified, image save depth)\n%    %A   image transparency channel enabled (true/false)\n%    %C   image compression type\n%    %D   image GIF dispose method\n%    %G   original image size (%wx%h; before any resizes)\n%    %H   page (canvas) height\n%    %M   Magick filename (original file exactly as given,  including read mods)\n%    %O   page (canvas) offset ( = %X%Y )\n%    %P   page (canvas) size ( = %Wx%H )\n%    %Q   image compression quality ( 0 = default )\n%    %S   ?? scenes ??\n%    %T   image time delay (in centi-seconds)\n%    %U   image resolution units\n%    %W   page (canvas) width\n%    %X   page (canvas) x offset (including sign)\n%    %Y   page (canvas) y offset (including sign)\n%    %Z   unique filename (used for delegates)\n%    %@   CALCULATED: trim bounding box (without actually trimming)\n%    %#   CALCULATED: 'signature' hash of image values\n%\n%  This routine only handles specifically known properties.  It does not\n%  handle special prefixed properties, profiles, or expressions. Nor does\n%  it return any free-form property strings.\n%\n%  The returned string is stored in a structure somewhere, and should not be\n%  directly freed.  If the string was generated (common) the string will be\n%  stored as as either as artifact or option 'get-property'.  These may be\n%  deleted (cleaned up) when no longer required, but neither artifact or\n%  option is guranteed to exist.\n%\n%  The format of the GetMagickProperty method is:\n%\n%      const char *GetMagickProperty(ImageInfo *image_info,Image *image,\n%        const char *property,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info (optional)\n%\n%    o image: the image (optional)\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const char *GetMagickPropertyLetter(ImageInfo *image_info,\n  Image *image,const char letter,ExceptionInfo *exception)\n{\n#define WarnNoImageReturn(format,arg) \\\n  if (image == (Image *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n#define WarnNoImageInfoReturn(format,arg) \\\n  if (image_info == (ImageInfo *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageInfoForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n\n  char\n    value[MagickPathExtent];  /* formated string to store as a returned artifact */\n\n  const char\n    *string;     /* return a string already stored somewher */\n\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formatted string */\n  string=(char *) NULL;  /* constant string reference */\n  /*\n    Get properities that are directly defined by images.\n  */\n  switch (letter)\n  {\n    case 'b':  /* image size read in - in bytes */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatMagickSize(image->extent,MagickFalse,\"B\",MagickPathExtent,\n        value);\n      if (image->extent == 0)\n        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n          MagickPathExtent,value);\n      break;\n    }\n    case 'c':  /* image comment property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"comment\",exception);\n      if ( string == (const char *) NULL )\n        string=\"\";\n      break;\n    }\n    case 'd':  /* Directory component of filename */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,HeadPath,value);\n      if (*value == '\\0') string=\"\";\n      break;\n    }\n    case 'e': /* Filename extension (suffix) of image file */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,ExtensionPath,value);\n      if (*value == '\\0') string=\"\";\n      break;\n    }\n    case 'f': /* Filename without directory component */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,TailPath,value);\n      if (*value == '\\0') string=\"\";\n      break;\n    }\n    case 'g': /* Image geometry, canvas and offset  %Wx%H+%X+%Y */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n        image->page.height,(double) image->page.x,(double) image->page.y);\n      break;\n    }\n    case 'h': /* Image height (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->rows != 0 ? image->rows : image->magick_rows));\n      break;\n    }\n    case 'i': /* Filename last used for an image (read or write) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->filename;\n      break;\n    }\n    case 'k': /* Number of unique colors  */\n    {\n      /*\n        FUTURE: ensure this does not generate the formatted comment!\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetNumberColors(image,(FILE *) NULL,exception));\n      break;\n    }\n    case 'l': /* Image label property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"label\",exception);\n      if ( string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'm': /* Image format (file magick) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick;\n      break;\n    }\n    case 'n': /* Number of images in the list.  */\n    {\n      if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          GetImageListLength(image));\n      else\n        string=\"0\";    /* no images or scenes */\n      break;\n    }\n    case 'o': /* Output Filename - for delegate use only */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->filename;\n      break;\n    case 'p': /* Image index in current image list */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetImageIndexInList(image));\n      break;\n    }\n    case 'q': /* Quantum depth of image in memory */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n    case 'r': /* Image storage class, colorspace, and alpha enabled.  */\n    {\n      ColorspaceType\n        colorspace;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      colorspace=image->colorspace;\n      if (SetImageGray(image,exception) != MagickFalse)\n        colorspace=GRAYColorspace;   /* FUTURE: this is IMv6 not IMv7 */\n      (void) FormatLocaleString(value,MagickPathExtent,\"%s %s %s\",\n        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n        (ssize_t) colorspace),image->alpha_trait != UndefinedPixelTrait ?\n        \"Alpha\" : \"\");\n      break;\n    }\n    case 's': /* Image scene number */\n    {\n#if 0  /* this seems non-sensical -- simplifing */\n      if (image_info->number_scenes != 0)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image_info->scene);\n      else if (image != (Image *) NULL)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image->scene);\n      else\n          string=\"0\";\n#else\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n         image->scene);\n#endif\n      break;\n    }\n    case 't': /* Base filename without directory or extention */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,BasePath,value);\n      if (*value == '\\0') string=\"\";\n      break;\n    }\n    case 'u': /* Unique filename */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->unique;\n      break;\n    }\n    case 'w': /* Image width (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->columns != 0 ? image->columns : image->magick_columns));\n      break;\n    }\n    case 'x': /* Image horizontal resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.x) > MagickEpsilon ? image->resolution.x : 72.0);\n      break;\n    }\n    case 'y': /* Image vertical resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.y) > MagickEpsilon ? image->resolution.y : 72.0);\n      break;\n    }\n    case 'z': /* Image depth as read in */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        (double) image->depth);\n      break;\n    }\n    case 'A': /* Image alpha channel  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n        image->alpha_trait);\n      break;\n    }\n    case 'C': /* Image compression method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickCompressOptions,\n        (ssize_t) image->compression);\n      break;\n    }\n    case 'D': /* Image dispose method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickDisposeOptions,\n        (ssize_t) image->dispose);\n      break;\n    }\n    case 'G': /* Image size as geometry = \"%wx%h\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",\n        (double)image->magick_columns,(double) image->magick_rows);\n      break;\n    }\n    case 'H': /* layer canvas height */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        (double) image->page.height);\n      break;\n    }\n    case 'M': /* Magick filename - filename given incl. coder & read mods */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick_filename;\n      break;\n    }\n    case 'O': /* layer canvas offset with sign = \"+%X+%Y\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+ld%+ld\",(long)\n        image->page.x,(long) image->page.y);\n      break;\n    }\n    case 'P': /* layer canvas page size = \"%Wx%H\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",\n        (double) image->page.width,(double) image->page.height);\n      break;\n    }\n    case 'Q': /* image compression quality */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->quality == 0 ? 92 : image->quality));\n      break;\n    }\n    case 'S': /* Number of scenes in image list.  */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n#if 0 /* What is this number? -- it makes no sense - simplifing */\n      if (image_info->number_scenes == 0)\n         string=\"2147483647\";\n      else if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n                image_info->scene+image_info->number_scenes);\n      else\n        string=\"0\";\n#else\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image_info->number_scenes == 0 ? 2147483647 :\n         image_info->number_scenes));\n#endif\n      break;\n    }\n    case 'T': /* image time delay for animations */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->delay);\n      break;\n    }\n    case 'U': /* Image resolution units. */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickResolutionOptions,\n        (ssize_t) image->units);\n      break;\n    }\n    case 'W': /* layer canvas width */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.width);\n      break;\n    }\n    case 'X': /* layer canvas X offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.x);\n      break;\n    }\n    case 'Y': /* layer canvas Y offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.y);\n      break;\n    }\n    case '%': /* percent escaped */\n    {\n      string=\"%\";\n      break;\n    }\n    case '@': /* Trim bounding box, without actually Trimming! */\n    {\n      RectangleInfo\n        page;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      page=GetImageBoundingBox(image,exception);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) page.width,(double) page.height,\n        (double) page.x,(double)page.y);\n      break;\n    }\n    case '#':\n    {\n      /*\n        Image signature.\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) SignatureImage(image,exception);\n      string=GetImageProperty(image,\"signature\",exception);\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n\nMagickExport const char *GetMagickProperty(ImageInfo *image_info,\n  Image *image,const char *property,ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *string;\n\n  assert(property[0] != '\\0');\n  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );\n\n  if (property[1] == '\\0')  /* single letter property request */\n    return(GetMagickPropertyLetter(image_info,image,*property,exception));\n\n  if (image != (Image *) NULL && image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else if( image_info != (ImageInfo *) NULL && image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n\n  *value='\\0';           /* formated string */\n  string=(char *) NULL;  /* constant string reference */\n  switch (*property)\n  {\n    case 'b':\n    {\n      if (LocaleCompare(\"basename\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,BasePath,value);\n          if (*value == '\\0') string=\"\";\n          break;\n        }\n      if (LocaleCompare(\"bit-depth\",property) == 0)\n        {\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageDepth(image, exception));\n          break;\n        }\n      break;\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual image channels */\n          (void) FormatLocaleString(value,MagickPathExtent,\"%s\",\n            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace));\n          LocaleLower(value);\n          if( image->alpha_trait != UndefinedPixelTrait )\n            (void) ConcatenateMagickString(value,\"a\",MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual colorspace - no 'gray' stuff */\n          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n        {\n          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->depth);\n          break;\n        }\n      if (LocaleCompare(\"directory\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,HeadPath,value);\n          if (*value == '\\0') string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"entropy\",property) == 0)\n        {\n          double\n            entropy;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageEntropy(image,&entropy,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),entropy);\n          break;\n        }\n      if (LocaleCompare(\"extension\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,ExtensionPath,value);\n          if (*value == '\\0') string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),image->gamma);\n          break;\n        }\n      break;\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);\n          break;\n        }\n      break;\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"input\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->filename;\n          break;\n        }\n      break;\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),kurtosis);\n          break;\n        }\n      break;\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magick\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->magick;\n          break;\n        }\n      if ((LocaleCompare(\"maxima\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),maximum);\n          break;\n        }\n      if (LocaleCompare(\"mean\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),mean);\n          break;\n        }\n      if ((LocaleCompare(\"minima\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),minimum);\n          break;\n        }\n      break;\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)\n            IsImageOpaque(image,exception));\n          break;\n        }\n      if (LocaleCompare(\"orientation\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n            image->orientation);\n          break;\n        }\n      if (LocaleCompare(\"output\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);\n          break;\n        }\n     break;\n    }\n    case 'p':\n    {\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n      if (LocaleCompare(\"profile:icc\",property) == 0 ||\n          LocaleCompare(\"profile:icm\",property) == 0)\n        {\n#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n\n          const StringInfo\n            *profile;\n\n          cmsHPROFILE\n            icc_profile;\n\n          profile=GetImageProfile(image,property+8);\n          if (profile == (StringInfo *) NULL)\n            break;\n          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n            (cmsUInt32Number) GetStringInfoLength(profile));\n          if (icc_profile != (cmsHPROFILE *) NULL)\n            {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n              string=cmsTakeProductName(icc_profile);\n#else\n              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n                \"en\",\"US\",value,MagickPathExtent);\n#endif\n              (void) cmsCloseProfile(icc_profile);\n            }\n      }\n#endif\n      if (LocaleCompare(\"profiles\",property) == 0)\n        {\n          const char\n            *name;\n\n          ResetImageProfileIterator(image);\n          name=GetNextImageProfile(image);\n          if (name != (char *) NULL)\n            {\n              (void) CopyMagickString(value,name,MagickPathExtent);\n              name=GetNextImageProfile(image);\n              while (name != (char *) NULL)\n              {\n                ConcatenateMagickString(value,\",\",MagickPathExtent);\n                ConcatenateMagickString(value,name,MagickPathExtent);\n                name=GetNextImageProfile(image);\n              }\n            }\n          break;\n        }\n      break;\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"resolution.x\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.x);\n          break;\n        }\n      if (LocaleCompare(\"resolution.y\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.y);\n          break;\n        }\n      break;\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"scene\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          if (image_info->number_scenes != 0)\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image_info->scene);\n          else {\n            WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image->scene);\n          }\n          break;\n        }\n      if (LocaleCompare(\"scenes\",property) == 0)\n        {\n          /* FUTURE: equivelent to %n? */\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageListLength(image));\n          break;\n        }\n      if (LocaleCompare(\"size\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n            MagickPathExtent,value);\n          break;\n        }\n      if (LocaleCompare(\"skewness\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),skewness);\n          break;\n        }\n      if (LocaleCompare(\"standard-deviation\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),standard_deviation);\n          break;\n        }\n       break;\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"type\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)\n            IdentifyImageType(image,exception));\n          break;\n        }\n       break;\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image_info->unique;\n          break;\n        }\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n            image->units);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n      break;\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          string=GetMagickVersion((size_t *) NULL);\n          break;\n        }\n      break;\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            (image->magick_columns != 0 ? image->magick_columns : 256));\n          break;\n        }\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n  {\n    /* create a cloned copy of result, that will get cleaned up, eventually */\n    if (image != (Image *) NULL)\n      {\n        (void) SetImageArtifact(image,\"get-property\",value);\n        return(GetImageArtifact(image,\"get-property\"));\n      }\n    else\n      {\n        (void) SetImageOption(image_info,\"get-property\",value);\n        return(GetImageOption(image_info,\"get-property\"));\n      }\n  }\n  return((char *) NULL);\n}\n#undef WarnNoImageReturn\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o p e r t y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProperty() gets the next free-form string property name.\n%\n%  The format of the GetNextImageProperty method is:\n%\n%      char *GetNextImageProperty(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const char *GetNextImageProperty(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return((const char *) NULL);\n  return((const char *) GetNextKeyInSplayTree(\n    (SplayTreeInfo *) image->properties));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n t e r p r e t I m a g e P r o p e r t i e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageProperties() replaces any embedded formatting characters with\n%  the appropriate image property and returns the interpreted text.\n%\n%  This searches for and replaces\n%     \\n \\r \\%          replaced by newline, return, and percent resp.\n%     &lt; &gt; &amp;   replaced by '<', '>', '&' resp.\n%     %%                replaced by percent\n%\n%     %x %[x]       where 'x' is a single letter properity, case sensitive).\n%     %[type:name]  where 'type' a is special and known prefix.\n%     %[name]       where 'name' is a specifically known attribute, calculated\n%                   value, or a per-image property string name, or a per-image\n%                   'artifact' (as generated from a global option).\n%                   It may contain ':' as long as the prefix is not special.\n%\n%  Single letter % substitutions will only happen if the character before the\n%  percent is NOT a number. But braced substitutions will always be performed.\n%  This prevents the typical usage of percent in a interpreted geometry\n%  argument from being substituted when the percent is a geometry flag.\n%\n%  If 'glob-expresions' ('*' or '?' characters) is used for 'name' it may be\n%  used as a search pattern to print multiple lines of \"name=value\\n\" pairs of\n%  the associacted set of properties.\n%\n%  The returned string must be freed using DestoryString() by the caller.\n%\n%  The format of the InterpretImageProperties method is:\n%\n%      char *InterpretImageProperties(ImageInfo *image_info,\n%        Image *image,const char *embed_text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info. (required)\n%\n%    o image: the image. (optional)\n%\n%    o embed_text: the address of a character string containing the embedded\n%      formatting characters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport char *InterpretImageProperties(ImageInfo *image_info,\n  Image *image,const char *embed_text,ExceptionInfo *exception)\n{\n#define ExtendInterpretText(string_length) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=(string_length); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n   } \\\n} \\\nRestoreMSCWarning\n\n#define AppendKeyValue2Text(key,value)\\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen(key)+strlen(value)+2; \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n     } \\\n   q+=FormatLocaleString(q,extent,\"%s=%s\\n\",(key),(value)); \\\n} \\\nRestoreMSCWarning\n\n#define AppendString2Text(string) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen((string)); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n    } \\\n  (void) CopyMagickString(q,(string),extent); \\\n  q+=length; \\\n} \\\nRestoreMSCWarning\n\n  char\n    *interpret_text;\n\n  register char\n    *q;  /* current position in interpret_text */\n\n  register const char\n    *p;  /* position in embed_text string being expanded */\n\n  size_t\n    extent;  /* allocated length of interpret_text */\n\n  MagickBooleanType\n    number;\n\n  assert(image == NULL || image->signature == MagickCoreSignature);\n  assert(image_info == NULL || image_info->signature == MagickCoreSignature);\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n   if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-image\");\n  if (embed_text == (const char *) NULL)\n    return(ConstantString(\"\"));\n  p=embed_text;\n  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\\0'))\n    p++;\n  if (*p == '\\0')\n    return(ConstantString(\"\"));\n  if ((*p == '@') && (IsPathAccessible(p+1) != MagickFalse))\n    {\n      /*\n        Handle a '@' replace string from file.\n      */\n      if (IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,p) == MagickFalse)\n        {\n          errno=EPERM;\n          (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n            \"NotAuthorized\",\"`%s'\",p);\n          return(ConstantString(\"\"));\n        }\n      interpret_text=FileToString(p+1,~0UL,exception);\n      if (interpret_text != (char *) NULL)\n        return(interpret_text);\n    }\n  /*\n    Translate any embedded format characters.\n  */\n  interpret_text=AcquireString(embed_text); /* new string with extra space */\n  extent=MagickPathExtent;                     /* allocated space in string */\n  number=MagickFalse;                       /* is last char a number? */\n  for (q=interpret_text; *p!='\\0';\n    number=isdigit(*p) ? MagickTrue : MagickFalse,p++)\n  {\n    /*\n      Look for the various escapes, (and handle other specials)\n    */\n    *q='\\0';\n    ExtendInterpretText(MagickPathExtent);\n    switch (*p)\n    {\n      case '\\\\':\n      {\n        switch (*(p+1))\n        {\n          case '\\0':\n            continue;\n          case 'r':  /* convert to RETURN */\n          {\n            *q++='\\r';\n            p++;\n            continue;\n          }\n          case 'n':  /* convert to NEWLINE */\n          {\n            *q++='\\n';\n            p++;\n            continue;\n          }\n          case '\\n':  /* EOL removal UNIX,MacOSX */\n          {\n            p++;\n            continue;\n          }\n          case '\\r':  /* EOL removal DOS,Windows */\n          {\n            p++;\n            if (*p == '\\n') /* return-newline EOL */\n              p++;\n            continue;\n          }\n          default:\n          {\n            p++;\n            *q++=(*p);\n          }\n        }\n        continue;\n      }\n      case '&':\n      {\n        if (LocaleNCompare(\"&lt;\",p,4) == 0)\n          {\n            *q++='<';\n            p+=3;\n          }\n        else\n          if (LocaleNCompare(\"&gt;\",p,4) == 0)\n            {\n              *q++='>';\n              p+=3;\n            }\n          else\n            if (LocaleNCompare(\"&amp;\",p,5) == 0)\n              {\n                *q++='&';\n                p+=4;\n              }\n            else\n              *q++=(*p);\n        continue;\n      }\n      case '%':\n        break;  /* continue to next set of handlers */\n      default:\n      {\n        *q++=(*p);  /* any thing else is 'as normal' */\n        continue;\n      }\n    }\n    p++; /* advance beyond the percent */\n    /*\n      Doubled Percent - or percent at end of string.\n    */\n    if ((*p == '\\0') || (*p == '\\'') || (*p == '\"'))\n      p--;\n    if (*p == '%')\n      {\n        *q++='%';\n        continue;\n      }\n    /*\n      Single letter escapes %c.\n    */\n    if (*p != '[')\n      {\n        const char\n          *string;\n\n        if (number != MagickFalse)\n          {\n            /*\n              But only if not preceeded by a number!\n            */\n            *q++='%'; /* do NOT substitute the percent */\n            p--;      /* back up one */\n            continue;\n          }\n        string=GetMagickPropertyLetter(image_info,image,*p, exception);\n        if (string != (char *) NULL)\n          {\n            AppendString2Text(string);\n            if (image != (Image *) NULL)\n              (void) DeleteImageArtifact(image,\"get-property\");\n            if (image_info != (ImageInfo *) NULL)\n              (void) DeleteImageOption(image_info,\"get-property\");\n            continue;\n          }\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n          \"UnknownImageProperty\",\"\\\"%%%c\\\"\",*p);\n        continue;\n      }\n    {\n      char\n        pattern[2*MagickPathExtent];\n\n      const char\n        *key,\n        *string;\n\n      register ssize_t\n        len;\n\n      ssize_t\n        depth;\n\n      /*\n        Braced Percent Escape %[...].\n      */\n      p++;  /* advance p to just inside the opening brace */\n      depth=1;\n      if (*p == ']')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"UnknownImageProperty\",\"\\\"%%[]\\\"\");\n          break;\n        }\n      for (len=0; len<(MagickPathExtent-1L) && (*p != '\\0');)\n      {\n        if ((*p == '\\\\') && (*(p+1) != '\\0'))\n          {\n            /*\n              Skip escaped braces within braced pattern.\n            */\n            pattern[len++]=(*p++);\n            pattern[len++]=(*p++);\n            continue;\n          }\n        if (*p == '[')\n          depth++;\n        if (*p == ']')\n          depth--;\n        if (depth <= 0)\n          break;\n        pattern[len++]=(*p++);\n      }\n      pattern[len]='\\0';\n      if (depth != 0)\n        {\n          /*\n            Check for unmatched final ']' for \"%[...]\".\n          */\n          if (len >= 64)\n            {\n              pattern[61] = '.';  /* truncate string for error message */\n              pattern[62] = '.';\n              pattern[63] = '.';\n              pattern[64] = '\\0';\n            }\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError,\"UnbalancedBraces\",\"\\\"%%[%s\\\"\",pattern);\n          interpret_text=DestroyString(interpret_text);\n          return((char *) NULL);\n        }\n      /*\n        Special Lookup Prefixes %[prefix:...].\n      */\n      if (LocaleNCompare(\"fx:\",pattern,3) == 0)\n        {\n          FxInfo\n            *fx_info;\n\n          double\n            value;\n\n          MagickBooleanType\n            status;\n\n          /*\n            FX - value calculator.\n          */\n          if (image == (Image *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          fx_info=AcquireFxInfo(image,pattern+3,exception);\n          status=FxEvaluateChannelExpression(fx_info,IntensityPixelChannel,0,0,\n            &value,exception);\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%.*g\",\n                GetMagickPrecision(),(double) value);\n              AppendString2Text(result);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"pixel:\",pattern,6) == 0)\n        {\n          FxInfo\n            *fx_info;\n\n          double\n            value;\n\n          MagickStatusType\n            status;\n\n          PixelInfo\n            pixel;\n\n          /*\n            Pixel - color value calculator.\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          GetPixelInfo(image,&pixel);\n          fx_info=AcquireFxInfo(image,pattern+6,exception);\n          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,0,0,\n            &value,exception);\n          pixel.red=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,0,0,\n            &value,exception);\n          pixel.green=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,0,0,\n            &value,exception);\n          pixel.blue=(double) QuantumRange*value;\n          if (image->colorspace == CMYKColorspace)\n            {\n              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,0,0,\n                &value,exception);\n              pixel.black=(double) QuantumRange*value;\n            }\n          status&=FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,0,0,\n            &value,exception);\n          pixel.alpha=(double) QuantumRange*value;\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                name[MagickPathExtent];\n\n              (void) QueryColorname(image,&pixel,SVGCompliance,name,\n                exception);\n              AppendString2Text(name);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"option:\",pattern,7) == 0)\n        {\n          /*\n            Option - direct global option lookup (with globbing).\n          */\n          if (image_info == (ImageInfo *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+7) != MagickFalse)\n            {\n              ResetImageOptionIterator(image_info);\n              while ((key=GetNextImageOption(image_info)) != (const char *) NULL)\n                if (GlobExpression(key,pattern+7,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageOption(image_info,key);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? key found but no string value! */\n                  }\n              continue;\n            }\n          string=GetImageOption(image_info,pattern+7);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"artifact:\",pattern,9) == 0)\n        {\n          /*\n            Artifact - direct image artifact lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImageArtifactIterator(image);\n              while ((key=GetNextImageArtifact(image)) != (const char *) NULL)\n              if (GlobExpression(key,pattern+9,MagickTrue) != MagickFalse)\n                {\n                  string=GetImageArtifact(image,key);\n                  if (string != (const char *) NULL)\n                    AppendKeyValue2Text(key,string);\n                  /* else - assertion failure? key found but no string value! */\n                }\n              continue;\n            }\n          string=GetImageArtifact(image,pattern+9);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"property:\",pattern,9) == 0)\n        {\n          /*\n            Property - direct image property lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImagePropertyIterator(image);\n              while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n                if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageProperty(image,key,exception);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? */\n                  }\n              continue;\n            }\n          string=GetImageProperty(image,pattern+9,exception);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (image != (Image *) NULL)\n        {\n          /*\n            Properties without special prefix.  This handles attributes,\n            properties, and profiles such as %[exif:...].  Note the profile\n            properties may also include a glob expansion pattern.\n          */\n          string=GetImageProperty(image,pattern,exception);\n          if (string != (const char *) NULL)\n            {\n              AppendString2Text(string);\n              if (image != (Image *) NULL)\n                (void)DeleteImageArtifact(image,\"get-property\");\n              if (image_info != (ImageInfo *) NULL)\n                (void)DeleteImageOption(image_info,\"get-property\");\n              continue;\n            }\n        }\n      if (IsGlob(pattern) != MagickFalse)\n        {\n          /*\n            Handle property 'glob' patterns such as:\n            %[*] %[user:array_??] %[filename:e*]>\n          */\n          if (image == (Image *) NULL)\n            continue; /* else no image to retrieve proprty - no list */\n          ResetImagePropertyIterator(image);\n          while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n            if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n              {\n                string=GetImageProperty(image,key,exception);\n                if (string != (const char *) NULL)\n                  AppendKeyValue2Text(key,string);\n                /* else - assertion failure? */\n              }\n          continue;\n        }\n      /*\n        Look for a known property or image attribute such as\n        %[basename] %[denisty] %[delay].  Also handles a braced single\n        letter: %[b] %[G] %[g].\n      */\n      string=GetMagickProperty(image_info,image,pattern,exception);\n      if (string != (const char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        Look for a per-image artifact. This includes option lookup\n        (FUTURE: interpreted according to image).\n      */\n      if (image != (Image *) NULL)\n        {\n          string=GetImageArtifact(image,pattern);\n          if (string != (char *) NULL)\n            {\n              AppendString2Text(string);\n              continue;\n            }\n        }\n      else\n        if (image_info != (ImageInfo *) NULL)\n          {\n            /*\n              No image, so direct 'option' lookup (no delayed percent escapes).\n            */\n            string=GetImageOption(image_info,pattern);\n            if (string != (char *) NULL)\n              {\n                AppendString2Text(string);\n                continue;\n              }\n          }\nPropertyLookupFailure:\n      /*\n        Failed to find any match anywhere!\n      */\n      if (len >= 64)\n        {\n          pattern[61] = '.';  /* truncate string for error message */\n          pattern[62] = '.';\n          pattern[63] = '.';\n          pattern[64] = '\\0';\n        }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"UnknownImageProperty\",\"\\\"%%[%s]\\\"\",pattern);\n    }\n  }\n  *q='\\0';\n  return(interpret_text);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProperty() removes a property from the image and returns its\n%  value.\n%\n%  In this case the ConstantString() value returned should be freed by the\n%  caller when finished.\n%\n%  The format of the RemoveImageProperty method is:\n%\n%      char *RemoveImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport char *RemoveImageProperty(Image *image,\n  const char *property)\n{\n  char\n    *value;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return((char *) NULL);\n  value=(char *) RemoveNodeFromSplayTree((SplayTreeInfo *) image->properties,\n    property);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P r o p e r t y I t e r a t o r                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePropertyIterator() resets the image properties iterator.  Use it\n%  in conjunction with GetNextImageProperty() to iterate over all the values\n%  associated with an image property.\n%\n%  The format of the ResetImagePropertyIterator method is:\n%\n%      ResetImagePropertyIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImagePropertyIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProperty() saves the given string value either to specific known\n%  attribute or to a freeform property string.\n%\n%  Attempting to set a property that is normally calculated will produce\n%  an exception.\n%\n%  The format of the SetImageProperty method is:\n%\n%      MagickBooleanType SetImageProperty(Image *image,const char *property,\n%        const char *value,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o values: the image property values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n    {\n      /*\n        Do not 'set' single letter properties - read only shorthand.\n       */\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"SetReadOnlyProperty\",\"`%s'\",property);\n      return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ( (LocaleCompare(\"magick\",property) == 0) ||\n           (LocaleCompare(\"max\",property) == 0) ||\n           (LocaleCompare(\"mean\",property) == 0) ||\n           (LocaleCompare(\"min\",property) == 0) ||\n           (LocaleCompare(\"min\",property) == 0) )\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ( (LocaleCompare(\"size\",property) == 0) ||\n           (LocaleCompare(\"skewness\",property) == 0) ||\n           (LocaleCompare(\"scenes\",property) == 0) ||\n           (LocaleCompare(\"standard-deviation\",property) == 0) )\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               PPPP   RRRR    OOO   FFFFF  IIIII  L      EEEEE               %\n%               P   P  R   R  O   O  F        I    L      E                   %\n%               PPPP   RRRR   O   O  FFF      I    L      EEE                 %\n%               P      R R    O   O  F        I    L      E                   %\n%               P      R  R    OOO   F      IIIII  LLLLL  EEEEE               %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Image Profile Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/profile-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS_LCMS2_H)\n#include <wchar.h>\n#include <lcms/lcms2.h>\n#else\n#include <wchar.h>\n#include \"lcms2.h\"\n#endif\n#endif\n\f\n/*\n  Forward declarations\n*/\nstatic MagickBooleanType\n  SetImageProfileInternal(Image *,const char *,const StringInfo *,\n    const MagickBooleanType,ExceptionInfo *);\n\nstatic void\n  WriteTo8BimProfile(Image *,const char*,const StringInfo *);\n\f\n/*\n  Typedef declarations\n*/\nstruct _ProfileInfo\n{\n  char\n    *name;\n\n  size_t\n    length;\n\n  unsigned char\n    *info;\n\n  size_t\n    signature;\n};\n\ntypedef struct _CMSExceptionInfo\n{\n  Image\n    *image;\n\n  ExceptionInfo\n    *exception;\n} CMSExceptionInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o f i l e s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProfiles() clones one or more image profiles.\n%\n%  The format of the CloneImageProfiles method is:\n%\n%      MagickBooleanType CloneImageProfiles(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProfiles(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->profiles != (void *) NULL)\n    {\n      if (image->profiles != (void *) NULL)\n        DestroyImageProfiles(image);\n      image->profiles=CloneSplayTree((SplayTreeInfo *) clone_image->profiles,\n        (void *(*)(void *)) ConstantString,(void *(*)(void *)) CloneStringInfo);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProfile() deletes a profile from the image by its name.\n%\n%  The format of the DeleteImageProfile method is:\n%\n%      MagickBooleanTyupe DeleteImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return(MagickFalse);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->profiles,name));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o f i l e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProfiles() releases memory associated with an image profile map.\n%\n%  The format of the DestroyProfiles method is:\n%\n%      void DestroyImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProfiles(Image *image)\n{\n  if (image->profiles != (SplayTreeInfo *) NULL)\n    image->profiles=DestroySplayTree((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProfile() gets a profile associated with an image by name.\n%\n%  The format of the GetImageProfile method is:\n%\n%      const StringInfo *GetImageProfile(const Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport const StringInfo *GetImageProfile(const Image *image,\n  const char *name)\n{\n  const StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  profile=(const StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o f i l e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProfile() gets the next profile name for an image.\n%\n%  The format of the GetNextImageProfile method is:\n%\n%      char *GetNextImageProfile(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o hash_info: the hash info.\n%\n*/\nMagickExport char *GetNextImageProfile(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((char *) NULL);\n  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P r o f i l e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProfileImage() associates, applies, or removes an ICM, IPTC, or generic\n%  profile with / to / from an image.  If the profile is NULL, it is removed\n%  from the image otherwise added or applied.  Use a name of '*' and a profile\n%  of NULL to remove all profiles from the image.\n%\n%  ICC and ICM profiles are handled as follows: If the image does not have\n%  an associated color profile, the one you provide is associated with the\n%  image and the image pixels are not transformed.  Otherwise, the colorspace\n%  transform defined by the existing and new profile are applied to the image\n%  pixels and the new profile is associated with the image.\n%\n%  The format of the ProfileImage method is:\n%\n%      MagickBooleanType ProfileImage(Image *image,const char *name,\n%        const void *datum,const size_t length,const MagickBooleanType clone)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: Name of profile to add or remove: ICC, IPTC, or generic profile.\n%\n%    o datum: the profile data.\n%\n%    o length: the length of the profile.\n%\n%    o clone: should be MagickFalse.\n%\n*/\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\nstatic unsigned short **DestroyPixelThreadSet(unsigned short **pixels)\n{\n  register ssize_t\n    i;\n\n  assert(pixels != (unsigned short **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (unsigned short *) NULL)\n      pixels[i]=(unsigned short *) RelinquishMagickMemory(pixels[i]);\n  pixels=(unsigned short **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic unsigned short **AcquirePixelThreadSet(const size_t columns,\n  const size_t channels)\n{\n  register ssize_t\n    i;\n\n  unsigned short\n    **pixels;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(unsigned short **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (unsigned short **) NULL)\n    return((unsigned short **) NULL);\n  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=(unsigned short *) AcquireQuantumMemory(columns,channels*\n      sizeof(**pixels));\n    if (pixels[i] == (unsigned short *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n  }\n  return(pixels);\n}\n\nstatic cmsHTRANSFORM *DestroyTransformThreadSet(cmsHTRANSFORM *transform)\n{\n  register ssize_t\n    i;\n\n  assert(transform != (cmsHTRANSFORM *) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (transform[i] != (cmsHTRANSFORM) NULL)\n      cmsDeleteTransform(transform[i]);\n  transform=(cmsHTRANSFORM *) RelinquishMagickMemory(transform);\n  return(transform);\n}\n\nstatic cmsHTRANSFORM *AcquireTransformThreadSet(Image *image,\n  const cmsHPROFILE source_profile,const cmsUInt32Number source_type,\n  const cmsHPROFILE target_profile,const cmsUInt32Number target_type,\n  const int intent,const cmsUInt32Number flags)\n{\n  cmsHTRANSFORM\n    *transform;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  transform=(cmsHTRANSFORM *) AcquireQuantumMemory(number_threads,\n    sizeof(*transform));\n  if (transform == (cmsHTRANSFORM *) NULL)\n    return((cmsHTRANSFORM *) NULL);\n  (void) ResetMagickMemory(transform,0,number_threads*sizeof(*transform));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    transform[i]=cmsCreateTransformTHR((cmsContext) image,source_profile,\n      source_type,target_profile,target_type,intent,flags);\n    if (transform[i] == (cmsHTRANSFORM) NULL)\n      return(DestroyTransformThreadSet(transform));\n  }\n  return(transform);\n}\n#endif\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\nstatic void CMSExceptionHandler(cmsContext context,cmsUInt32Number severity,\n  const char *message)\n{\n  CMSExceptionInfo\n    *cms_exception;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  cms_exception=(CMSExceptionInfo *) context;\n  image=cms_exception->image;\n  exception=cms_exception->exception;\n  if (image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n        \"UnableToTransformColorspace\",\"`%s'\",\"unknown context\");\n      return;\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"lcms: #%u, %s\",\n      severity,message != (char *) NULL ? message : \"no message\");\n  (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n    \"UnableToTransformColorspace\",\"`%s'\",image->filename);\n}\n#endif\n\nstatic MagickBooleanType SetsRGBImageProfile(Image *image,\n  ExceptionInfo *exception)\n{\n  static unsigned char\n    sRGBProfile[] =\n    {\n      0x00, 0x00, 0x0c, 0x8c, 0x61, 0x72, 0x67, 0x6c, 0x02, 0x20, 0x00, 0x00,\n      0x6d, 0x6e, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5a, 0x20,\n      0x07, 0xde, 0x00, 0x01, 0x00, 0x06, 0x00, 0x16, 0x00, 0x0f, 0x00, 0x3a,\n      0x61, 0x63, 0x73, 0x70, 0x4d, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,\n      0x49, 0x45, 0x43, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xd6,\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d, 0x61, 0x72, 0x67, 0x6c,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x99,\n      0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x01, 0xec, 0x00, 0x00, 0x00, 0x67,\n      0x64, 0x6d, 0x6e, 0x64, 0x00, 0x00, 0x02, 0x54, 0x00, 0x00, 0x00, 0x70,\n      0x64, 0x6d, 0x64, 0x64, 0x00, 0x00, 0x02, 0xc4, 0x00, 0x00, 0x00, 0x88,\n      0x74, 0x65, 0x63, 0x68, 0x00, 0x00, 0x03, 0x4c, 0x00, 0x00, 0x00, 0x0c,\n      0x76, 0x75, 0x65, 0x64, 0x00, 0x00, 0x03, 0x58, 0x00, 0x00, 0x00, 0x67,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x24,\n      0x6c, 0x75, 0x6d, 0x69, 0x00, 0x00, 0x03, 0xe4, 0x00, 0x00, 0x00, 0x14,\n      0x6d, 0x65, 0x61, 0x73, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x24,\n      0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x6b, 0x70, 0x74, 0x00, 0x00, 0x04, 0x30, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x44, 0x00, 0x00, 0x00, 0x14,\n      0x67, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x58, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x6c, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,\n      0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36,\n      0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75, 0x69, 0x76,\n      0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77, 0x77, 0x77,\n      0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20, 0x31, 0x39,\n      0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c,\n      0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x3f, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31,\n      0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75,\n      0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77,\n      0x77, 0x77, 0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20,\n      0x31, 0x39, 0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66,\n      0x69, 0x6c, 0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x43, 0x72, 0x65, 0x61,\n      0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x47, 0x72, 0x61, 0x65, 0x6d,\n      0x65, 0x20, 0x57, 0x2e, 0x20, 0x47, 0x69, 0x6c, 0x6c, 0x2e, 0x20, 0x52,\n      0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x6f,\n      0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,\n      0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x20, 0x4e, 0x6f, 0x20, 0x57,\n      0x61, 0x72, 0x72, 0x61, 0x6e, 0x74, 0x79, 0x2c, 0x20, 0x55, 0x73, 0x65,\n      0x20, 0x61, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6f, 0x77, 0x6e,\n      0x20, 0x72, 0x69, 0x73, 0x6b, 0x2e, 0x00, 0x00, 0x64, 0x65, 0x73, 0x63,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20,\n      0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69,\n      0x65, 0x63, 0x2e, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20, 0x68, 0x74, 0x74,\n      0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x65, 0x63, 0x2e,\n      0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e,\n      0x49, 0x45, 0x43, 0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e,\n      0x31, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47,\n      0x42, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61,\n      0x63, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x49, 0x45, 0x43,\n      0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x44,\n      0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47, 0x42, 0x20, 0x63,\n      0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,\n      0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x73, 0x69, 0x67, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x43, 0x52, 0x54, 0x20, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xa4, 0x7c,\n      0x00, 0x14, 0x5f, 0x30, 0x00, 0x10, 0xce, 0x02, 0x00, 0x03, 0xed, 0xb2,\n      0x00, 0x04, 0x13, 0x0a, 0x00, 0x03, 0x5c, 0x67, 0x00, 0x00, 0x00, 0x01,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x0a, 0x3d,\n      0x00, 0x50, 0x00, 0x00, 0x00, 0x57, 0x1e, 0xb8, 0x6d, 0x65, 0x61, 0x73,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x02, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x51, 0x00, 0x01, 0x00, 0x00,\n      0x00, 0x01, 0x16, 0xcc, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xa0,\n      0x00, 0x00, 0x38, 0xf5, 0x00, 0x00, 0x03, 0x90, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x97, 0x00, 0x00, 0xb7, 0x87,\n      0x00, 0x00, 0x18, 0xd9, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x24, 0x9f, 0x00, 0x00, 0x0f, 0x84, 0x00, 0x00, 0xb6, 0xc4,\n      0x63, 0x75, 0x72, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n      0x00, 0x00, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x0f, 0x00, 0x14, 0x00, 0x19,\n      0x00, 0x1e, 0x00, 0x23, 0x00, 0x28, 0x00, 0x2d, 0x00, 0x32, 0x00, 0x37,\n      0x00, 0x3b, 0x00, 0x40, 0x00, 0x45, 0x00, 0x4a, 0x00, 0x4f, 0x00, 0x54,\n      0x00, 0x59, 0x00, 0x5e, 0x00, 0x63, 0x00, 0x68, 0x00, 0x6d, 0x00, 0x72,\n      0x00, 0x77, 0x00, 0x7c, 0x00, 0x81, 0x00, 0x86, 0x00, 0x8b, 0x00, 0x90,\n      0x00, 0x95, 0x00, 0x9a, 0x00, 0x9f, 0x00, 0xa4, 0x00, 0xa9, 0x00, 0xae,\n      0x00, 0xb2, 0x00, 0xb7, 0x00, 0xbc, 0x00, 0xc1, 0x00, 0xc6, 0x00, 0xcb,\n      0x00, 0xd0, 0x00, 0xd5, 0x00, 0xdb, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0xeb,\n      0x00, 0xf0, 0x00, 0xf6, 0x00, 0xfb, 0x01, 0x01, 0x01, 0x07, 0x01, 0x0d,\n      0x01, 0x13, 0x01, 0x19, 0x01, 0x1f, 0x01, 0x25, 0x01, 0x2b, 0x01, 0x32,\n      0x01, 0x38, 0x01, 0x3e, 0x01, 0x45, 0x01, 0x4c, 0x01, 0x52, 0x01, 0x59,\n      0x01, 0x60, 0x01, 0x67, 0x01, 0x6e, 0x01, 0x75, 0x01, 0x7c, 0x01, 0x83,\n      0x01, 0x8b, 0x01, 0x92, 0x01, 0x9a, 0x01, 0xa1, 0x01, 0xa9, 0x01, 0xb1,\n      0x01, 0xb9, 0x01, 0xc1, 0x01, 0xc9, 0x01, 0xd1, 0x01, 0xd9, 0x01, 0xe1,\n      0x01, 0xe9, 0x01, 0xf2, 0x01, 0xfa, 0x02, 0x03, 0x02, 0x0c, 0x02, 0x14,\n      0x02, 0x1d, 0x02, 0x26, 0x02, 0x2f, 0x02, 0x38, 0x02, 0x41, 0x02, 0x4b,\n      0x02, 0x54, 0x02, 0x5d, 0x02, 0x67, 0x02, 0x71, 0x02, 0x7a, 0x02, 0x84,\n      0x02, 0x8e, 0x02, 0x98, 0x02, 0xa2, 0x02, 0xac, 0x02, 0xb6, 0x02, 0xc1,\n      0x02, 0xcb, 0x02, 0xd5, 0x02, 0xe0, 0x02, 0xeb, 0x02, 0xf5, 0x03, 0x00,\n      0x03, 0x0b, 0x03, 0x16, 0x03, 0x21, 0x03, 0x2d, 0x03, 0x38, 0x03, 0x43,\n      0x03, 0x4f, 0x03, 0x5a, 0x03, 0x66, 0x03, 0x72, 0x03, 0x7e, 0x03, 0x8a,\n      0x03, 0x96, 0x03, 0xa2, 0x03, 0xae, 0x03, 0xba, 0x03, 0xc7, 0x03, 0xd3,\n      0x03, 0xe0, 0x03, 0xec, 0x03, 0xf9, 0x04, 0x06, 0x04, 0x13, 0x04, 0x20,\n      0x04, 0x2d, 0x04, 0x3b, 0x04, 0x48, 0x04, 0x55, 0x04, 0x63, 0x04, 0x71,\n      0x04, 0x7e, 0x04, 0x8c, 0x04, 0x9a, 0x04, 0xa8, 0x04, 0xb6, 0x04, 0xc4,\n      0x04, 0xd3, 0x04, 0xe1, 0x04, 0xf0, 0x04, 0xfe, 0x05, 0x0d, 0x05, 0x1c,\n      0x05, 0x2b, 0x05, 0x3a, 0x05, 0x49, 0x05, 0x58, 0x05, 0x67, 0x05, 0x77,\n      0x05, 0x86, 0x05, 0x96, 0x05, 0xa6, 0x05, 0xb5, 0x05, 0xc5, 0x05, 0xd5,\n      0x05, 0xe5, 0x05, 0xf6, 0x06, 0x06, 0x06, 0x16, 0x06, 0x27, 0x06, 0x37,\n      0x06, 0x48, 0x06, 0x59, 0x06, 0x6a, 0x06, 0x7b, 0x06, 0x8c, 0x06, 0x9d,\n      0x06, 0xaf, 0x06, 0xc0, 0x06, 0xd1, 0x06, 0xe3, 0x06, 0xf5, 0x07, 0x07,\n      0x07, 0x19, 0x07, 0x2b, 0x07, 0x3d, 0x07, 0x4f, 0x07, 0x61, 0x07, 0x74,\n      0x07, 0x86, 0x07, 0x99, 0x07, 0xac, 0x07, 0xbf, 0x07, 0xd2, 0x07, 0xe5,\n      0x07, 0xf8, 0x08, 0x0b, 0x08, 0x1f, 0x08, 0x32, 0x08, 0x46, 0x08, 0x5a,\n      0x08, 0x6e, 0x08, 0x82, 0x08, 0x96, 0x08, 0xaa, 0x08, 0xbe, 0x08, 0xd2,\n      0x08, 0xe7, 0x08, 0xfb, 0x09, 0x10, 0x09, 0x25, 0x09, 0x3a, 0x09, 0x4f,\n      0x09, 0x64, 0x09, 0x79, 0x09, 0x8f, 0x09, 0xa4, 0x09, 0xba, 0x09, 0xcf,\n      0x09, 0xe5, 0x09, 0xfb, 0x0a, 0x11, 0x0a, 0x27, 0x0a, 0x3d, 0x0a, 0x54,\n      0x0a, 0x6a, 0x0a, 0x81, 0x0a, 0x98, 0x0a, 0xae, 0x0a, 0xc5, 0x0a, 0xdc,\n      0x0a, 0xf3, 0x0b, 0x0b, 0x0b, 0x22, 0x0b, 0x39, 0x0b, 0x51, 0x0b, 0x69,\n      0x0b, 0x80, 0x0b, 0x98, 0x0b, 0xb0, 0x0b, 0xc8, 0x0b, 0xe1, 0x0b, 0xf9,\n      0x0c, 0x12, 0x0c, 0x2a, 0x0c, 0x43, 0x0c, 0x5c, 0x0c, 0x75, 0x0c, 0x8e,\n      0x0c, 0xa7, 0x0c, 0xc0, 0x0c, 0xd9, 0x0c, 0xf3, 0x0d, 0x0d, 0x0d, 0x26,\n      0x0d, 0x40, 0x0d, 0x5a, 0x0d, 0x74, 0x0d, 0x8e, 0x0d, 0xa9, 0x0d, 0xc3,\n      0x0d, 0xde, 0x0d, 0xf8, 0x0e, 0x13, 0x0e, 0x2e, 0x0e, 0x49, 0x0e, 0x64,\n      0x0e, 0x7f, 0x0e, 0x9b, 0x0e, 0xb6, 0x0e, 0xd2, 0x0e, 0xee, 0x0f, 0x09,\n      0x0f, 0x25, 0x0f, 0x41, 0x0f, 0x5e, 0x0f, 0x7a, 0x0f, 0x96, 0x0f, 0xb3,\n      0x0f, 0xcf, 0x0f, 0xec, 0x10, 0x09, 0x10, 0x26, 0x10, 0x43, 0x10, 0x61,\n      0x10, 0x7e, 0x10, 0x9b, 0x10, 0xb9, 0x10, 0xd7, 0x10, 0xf5, 0x11, 0x13,\n      0x11, 0x31, 0x11, 0x4f, 0x11, 0x6d, 0x11, 0x8c, 0x11, 0xaa, 0x11, 0xc9,\n      0x11, 0xe8, 0x12, 0x07, 0x12, 0x26, 0x12, 0x45, 0x12, 0x64, 0x12, 0x84,\n      0x12, 0xa3, 0x12, 0xc3, 0x12, 0xe3, 0x13, 0x03, 0x13, 0x23, 0x13, 0x43,\n      0x13, 0x63, 0x13, 0x83, 0x13, 0xa4, 0x13, 0xc5, 0x13, 0xe5, 0x14, 0x06,\n      0x14, 0x27, 0x14, 0x49, 0x14, 0x6a, 0x14, 0x8b, 0x14, 0xad, 0x14, 0xce,\n      0x14, 0xf0, 0x15, 0x12, 0x15, 0x34, 0x15, 0x56, 0x15, 0x78, 0x15, 0x9b,\n      0x15, 0xbd, 0x15, 0xe0, 0x16, 0x03, 0x16, 0x26, 0x16, 0x49, 0x16, 0x6c,\n      0x16, 0x8f, 0x16, 0xb2, 0x16, 0xd6, 0x16, 0xfa, 0x17, 0x1d, 0x17, 0x41,\n      0x17, 0x65, 0x17, 0x89, 0x17, 0xae, 0x17, 0xd2, 0x17, 0xf7, 0x18, 0x1b,\n      0x18, 0x40, 0x18, 0x65, 0x18, 0x8a, 0x18, 0xaf, 0x18, 0xd5, 0x18, 0xfa,\n      0x19, 0x20, 0x19, 0x45, 0x19, 0x6b, 0x19, 0x91, 0x19, 0xb7, 0x19, 0xdd,\n      0x1a, 0x04, 0x1a, 0x2a, 0x1a, 0x51, 0x1a, 0x77, 0x1a, 0x9e, 0x1a, 0xc5,\n      0x1a, 0xec, 0x1b, 0x14, 0x1b, 0x3b, 0x1b, 0x63, 0x1b, 0x8a, 0x1b, 0xb2,\n      0x1b, 0xda, 0x1c, 0x02, 0x1c, 0x2a, 0x1c, 0x52, 0x1c, 0x7b, 0x1c, 0xa3,\n      0x1c, 0xcc, 0x1c, 0xf5, 0x1d, 0x1e, 0x1d, 0x47, 0x1d, 0x70, 0x1d, 0x99,\n      0x1d, 0xc3, 0x1d, 0xec, 0x1e, 0x16, 0x1e, 0x40, 0x1e, 0x6a, 0x1e, 0x94,\n      0x1e, 0xbe, 0x1e, 0xe9, 0x1f, 0x13, 0x1f, 0x3e, 0x1f, 0x69, 0x1f, 0x94,\n      0x1f, 0xbf, 0x1f, 0xea, 0x20, 0x15, 0x20, 0x41, 0x20, 0x6c, 0x20, 0x98,\n      0x20, 0xc4, 0x20, 0xf0, 0x21, 0x1c, 0x21, 0x48, 0x21, 0x75, 0x21, 0xa1,\n      0x21, 0xce, 0x21, 0xfb, 0x22, 0x27, 0x22, 0x55, 0x22, 0x82, 0x22, 0xaf,\n      0x22, 0xdd, 0x23, 0x0a, 0x23, 0x38, 0x23, 0x66, 0x23, 0x94, 0x23, 0xc2,\n      0x23, 0xf0, 0x24, 0x1f, 0x24, 0x4d, 0x24, 0x7c, 0x24, 0xab, 0x24, 0xda,\n      0x25, 0x09, 0x25, 0x38, 0x25, 0x68, 0x25, 0x97, 0x25, 0xc7, 0x25, 0xf7,\n      0x26, 0x27, 0x26, 0x57, 0x26, 0x87, 0x26, 0xb7, 0x26, 0xe8, 0x27, 0x18,\n      0x27, 0x49, 0x27, 0x7a, 0x27, 0xab, 0x27, 0xdc, 0x28, 0x0d, 0x28, 0x3f,\n      0x28, 0x71, 0x28, 0xa2, 0x28, 0xd4, 0x29, 0x06, 0x29, 0x38, 0x29, 0x6b,\n      0x29, 0x9d, 0x29, 0xd0, 0x2a, 0x02, 0x2a, 0x35, 0x2a, 0x68, 0x2a, 0x9b,\n      0x2a, 0xcf, 0x2b, 0x02, 0x2b, 0x36, 0x2b, 0x69, 0x2b, 0x9d, 0x2b, 0xd1,\n      0x2c, 0x05, 0x2c, 0x39, 0x2c, 0x6e, 0x2c, 0xa2, 0x2c, 0xd7, 0x2d, 0x0c,\n      0x2d, 0x41, 0x2d, 0x76, 0x2d, 0xab, 0x2d, 0xe1, 0x2e, 0x16, 0x2e, 0x4c,\n      0x2e, 0x82, 0x2e, 0xb7, 0x2e, 0xee, 0x2f, 0x24, 0x2f, 0x5a, 0x2f, 0x91,\n      0x2f, 0xc7, 0x2f, 0xfe, 0x30, 0x35, 0x30, 0x6c, 0x30, 0xa4, 0x30, 0xdb,\n      0x31, 0x12, 0x31, 0x4a, 0x31, 0x82, 0x31, 0xba, 0x31, 0xf2, 0x32, 0x2a,\n      0x32, 0x63, 0x32, 0x9b, 0x32, 0xd4, 0x33, 0x0d, 0x33, 0x46, 0x33, 0x7f,\n      0x33, 0xb8, 0x33, 0xf1, 0x34, 0x2b, 0x34, 0x65, 0x34, 0x9e, 0x34, 0xd8,\n      0x35, 0x13, 0x35, 0x4d, 0x35, 0x87, 0x35, 0xc2, 0x35, 0xfd, 0x36, 0x37,\n      0x36, 0x72, 0x36, 0xae, 0x36, 0xe9, 0x37, 0x24, 0x37, 0x60, 0x37, 0x9c,\n      0x37, 0xd7, 0x38, 0x14, 0x38, 0x50, 0x38, 0x8c, 0x38, 0xc8, 0x39, 0x05,\n      0x39, 0x42, 0x39, 0x7f, 0x39, 0xbc, 0x39, 0xf9, 0x3a, 0x36, 0x3a, 0x74,\n      0x3a, 0xb2, 0x3a, 0xef, 0x3b, 0x2d, 0x3b, 0x6b, 0x3b, 0xaa, 0x3b, 0xe8,\n      0x3c, 0x27, 0x3c, 0x65, 0x3c, 0xa4, 0x3c, 0xe3, 0x3d, 0x22, 0x3d, 0x61,\n      0x3d, 0xa1, 0x3d, 0xe0, 0x3e, 0x20, 0x3e, 0x60, 0x3e, 0xa0, 0x3e, 0xe0,\n      0x3f, 0x21, 0x3f, 0x61, 0x3f, 0xa2, 0x3f, 0xe2, 0x40, 0x23, 0x40, 0x64,\n      0x40, 0xa6, 0x40, 0xe7, 0x41, 0x29, 0x41, 0x6a, 0x41, 0xac, 0x41, 0xee,\n      0x42, 0x30, 0x42, 0x72, 0x42, 0xb5, 0x42, 0xf7, 0x43, 0x3a, 0x43, 0x7d,\n      0x43, 0xc0, 0x44, 0x03, 0x44, 0x47, 0x44, 0x8a, 0x44, 0xce, 0x45, 0x12,\n      0x45, 0x55, 0x45, 0x9a, 0x45, 0xde, 0x46, 0x22, 0x46, 0x67, 0x46, 0xab,\n      0x46, 0xf0, 0x47, 0x35, 0x47, 0x7b, 0x47, 0xc0, 0x48, 0x05, 0x48, 0x4b,\n      0x48, 0x91, 0x48, 0xd7, 0x49, 0x1d, 0x49, 0x63, 0x49, 0xa9, 0x49, 0xf0,\n      0x4a, 0x37, 0x4a, 0x7d, 0x4a, 0xc4, 0x4b, 0x0c, 0x4b, 0x53, 0x4b, 0x9a,\n      0x4b, 0xe2, 0x4c, 0x2a, 0x4c, 0x72, 0x4c, 0xba, 0x4d, 0x02, 0x4d, 0x4a,\n      0x4d, 0x93, 0x4d, 0xdc, 0x4e, 0x25, 0x4e, 0x6e, 0x4e, 0xb7, 0x4f, 0x00,\n      0x4f, 0x49, 0x4f, 0x93, 0x4f, 0xdd, 0x50, 0x27, 0x50, 0x71, 0x50, 0xbb,\n      0x51, 0x06, 0x51, 0x50, 0x51, 0x9b, 0x51, 0xe6, 0x52, 0x31, 0x52, 0x7c,\n      0x52, 0xc7, 0x53, 0x13, 0x53, 0x5f, 0x53, 0xaa, 0x53, 0xf6, 0x54, 0x42,\n      0x54, 0x8f, 0x54, 0xdb, 0x55, 0x28, 0x55, 0x75, 0x55, 0xc2, 0x56, 0x0f,\n      0x56, 0x5c, 0x56, 0xa9, 0x56, 0xf7, 0x57, 0x44, 0x57, 0x92, 0x57, 0xe0,\n      0x58, 0x2f, 0x58, 0x7d, 0x58, 0xcb, 0x59, 0x1a, 0x59, 0x69, 0x59, 0xb8,\n      0x5a, 0x07, 0x5a, 0x56, 0x5a, 0xa6, 0x5a, 0xf5, 0x5b, 0x45, 0x5b, 0x95,\n      0x5b, 0xe5, 0x5c, 0x35, 0x5c, 0x86, 0x5c, 0xd6, 0x5d, 0x27, 0x5d, 0x78,\n      0x5d, 0xc9, 0x5e, 0x1a, 0x5e, 0x6c, 0x5e, 0xbd, 0x5f, 0x0f, 0x5f, 0x61,\n      0x5f, 0xb3, 0x60, 0x05, 0x60, 0x57, 0x60, 0xaa, 0x60, 0xfc, 0x61, 0x4f,\n      0x61, 0xa2, 0x61, 0xf5, 0x62, 0x49, 0x62, 0x9c, 0x62, 0xf0, 0x63, 0x43,\n      0x63, 0x97, 0x63, 0xeb, 0x64, 0x40, 0x64, 0x94, 0x64, 0xe9, 0x65, 0x3d,\n      0x65, 0x92, 0x65, 0xe7, 0x66, 0x3d, 0x66, 0x92, 0x66, 0xe8, 0x67, 0x3d,\n      0x67, 0x93, 0x67, 0xe9, 0x68, 0x3f, 0x68, 0x96, 0x68, 0xec, 0x69, 0x43,\n      0x69, 0x9a, 0x69, 0xf1, 0x6a, 0x48, 0x6a, 0x9f, 0x6a, 0xf7, 0x6b, 0x4f,\n      0x6b, 0xa7, 0x6b, 0xff, 0x6c, 0x57, 0x6c, 0xaf, 0x6d, 0x08, 0x6d, 0x60,\n      0x6d, 0xb9, 0x6e, 0x12, 0x6e, 0x6b, 0x6e, 0xc4, 0x6f, 0x1e, 0x6f, 0x78,\n      0x6f, 0xd1, 0x70, 0x2b, 0x70, 0x86, 0x70, 0xe0, 0x71, 0x3a, 0x71, 0x95,\n      0x71, 0xf0, 0x72, 0x4b, 0x72, 0xa6, 0x73, 0x01, 0x73, 0x5d, 0x73, 0xb8,\n      0x74, 0x14, 0x74, 0x70, 0x74, 0xcc, 0x75, 0x28, 0x75, 0x85, 0x75, 0xe1,\n      0x76, 0x3e, 0x76, 0x9b, 0x76, 0xf8, 0x77, 0x56, 0x77, 0xb3, 0x78, 0x11,\n      0x78, 0x6e, 0x78, 0xcc, 0x79, 0x2a, 0x79, 0x89, 0x79, 0xe7, 0x7a, 0x46,\n      0x7a, 0xa5, 0x7b, 0x04, 0x7b, 0x63, 0x7b, 0xc2, 0x7c, 0x21, 0x7c, 0x81,\n      0x7c, 0xe1, 0x7d, 0x41, 0x7d, 0xa1, 0x7e, 0x01, 0x7e, 0x62, 0x7e, 0xc2,\n      0x7f, 0x23, 0x7f, 0x84, 0x7f, 0xe5, 0x80, 0x47, 0x80, 0xa8, 0x81, 0x0a,\n      0x81, 0x6b, 0x81, 0xcd, 0x82, 0x30, 0x82, 0x92, 0x82, 0xf4, 0x83, 0x57,\n      0x83, 0xba, 0x84, 0x1d, 0x84, 0x80, 0x84, 0xe3, 0x85, 0x47, 0x85, 0xab,\n      0x86, 0x0e, 0x86, 0x72, 0x86, 0xd7, 0x87, 0x3b, 0x87, 0x9f, 0x88, 0x04,\n      0x88, 0x69, 0x88, 0xce, 0x89, 0x33, 0x89, 0x99, 0x89, 0xfe, 0x8a, 0x64,\n      0x8a, 0xca, 0x8b, 0x30, 0x8b, 0x96, 0x8b, 0xfc, 0x8c, 0x63, 0x8c, 0xca,\n      0x8d, 0x31, 0x8d, 0x98, 0x8d, 0xff, 0x8e, 0x66, 0x8e, 0xce, 0x8f, 0x36,\n      0x8f, 0x9e, 0x90, 0x06, 0x90, 0x6e, 0x90, 0xd6, 0x91, 0x3f, 0x91, 0xa8,\n      0x92, 0x11, 0x92, 0x7a, 0x92, 0xe3, 0x93, 0x4d, 0x93, 0xb6, 0x94, 0x20,\n      0x94, 0x8a, 0x94, 0xf4, 0x95, 0x5f, 0x95, 0xc9, 0x96, 0x34, 0x96, 0x9f,\n      0x97, 0x0a, 0x97, 0x75, 0x97, 0xe0, 0x98, 0x4c, 0x98, 0xb8, 0x99, 0x24,\n      0x99, 0x90, 0x99, 0xfc, 0x9a, 0x68, 0x9a, 0xd5, 0x9b, 0x42, 0x9b, 0xaf,\n      0x9c, 0x1c, 0x9c, 0x89, 0x9c, 0xf7, 0x9d, 0x64, 0x9d, 0xd2, 0x9e, 0x40,\n      0x9e, 0xae, 0x9f, 0x1d, 0x9f, 0x8b, 0x9f, 0xfa, 0xa0, 0x69, 0xa0, 0xd8,\n      0xa1, 0x47, 0xa1, 0xb6, 0xa2, 0x26, 0xa2, 0x96, 0xa3, 0x06, 0xa3, 0x76,\n      0xa3, 0xe6, 0xa4, 0x56, 0xa4, 0xc7, 0xa5, 0x38, 0xa5, 0xa9, 0xa6, 0x1a,\n      0xa6, 0x8b, 0xa6, 0xfd, 0xa7, 0x6e, 0xa7, 0xe0, 0xa8, 0x52, 0xa8, 0xc4,\n      0xa9, 0x37, 0xa9, 0xa9, 0xaa, 0x1c, 0xaa, 0x8f, 0xab, 0x02, 0xab, 0x75,\n      0xab, 0xe9, 0xac, 0x5c, 0xac, 0xd0, 0xad, 0x44, 0xad, 0xb8, 0xae, 0x2d,\n      0xae, 0xa1, 0xaf, 0x16, 0xaf, 0x8b, 0xb0, 0x00, 0xb0, 0x75, 0xb0, 0xea,\n      0xb1, 0x60, 0xb1, 0xd6, 0xb2, 0x4b, 0xb2, 0xc2, 0xb3, 0x38, 0xb3, 0xae,\n      0xb4, 0x25, 0xb4, 0x9c, 0xb5, 0x13, 0xb5, 0x8a, 0xb6, 0x01, 0xb6, 0x79,\n      0xb6, 0xf0, 0xb7, 0x68, 0xb7, 0xe0, 0xb8, 0x59, 0xb8, 0xd1, 0xb9, 0x4a,\n      0xb9, 0xc2, 0xba, 0x3b, 0xba, 0xb5, 0xbb, 0x2e, 0xbb, 0xa7, 0xbc, 0x21,\n      0xbc, 0x9b, 0xbd, 0x15, 0xbd, 0x8f, 0xbe, 0x0a, 0xbe, 0x84, 0xbe, 0xff,\n      0xbf, 0x7a, 0xbf, 0xf5, 0xc0, 0x70, 0xc0, 0xec, 0xc1, 0x67, 0xc1, 0xe3,\n      0xc2, 0x5f, 0xc2, 0xdb, 0xc3, 0x58, 0xc3, 0xd4, 0xc4, 0x51, 0xc4, 0xce,\n      0xc5, 0x4b, 0xc5, 0xc8, 0xc6, 0x46, 0xc6, 0xc3, 0xc7, 0x41, 0xc7, 0xbf,\n      0xc8, 0x3d, 0xc8, 0xbc, 0xc9, 0x3a, 0xc9, 0xb9, 0xca, 0x38, 0xca, 0xb7,\n      0xcb, 0x36, 0xcb, 0xb6, 0xcc, 0x35, 0xcc, 0xb5, 0xcd, 0x35, 0xcd, 0xb5,\n      0xce, 0x36, 0xce, 0xb6, 0xcf, 0x37, 0xcf, 0xb8, 0xd0, 0x39, 0xd0, 0xba,\n      0xd1, 0x3c, 0xd1, 0xbe, 0xd2, 0x3f, 0xd2, 0xc1, 0xd3, 0x44, 0xd3, 0xc6,\n      0xd4, 0x49, 0xd4, 0xcb, 0xd5, 0x4e, 0xd5, 0xd1, 0xd6, 0x55, 0xd6, 0xd8,\n      0xd7, 0x5c, 0xd7, 0xe0, 0xd8, 0x64, 0xd8, 0xe8, 0xd9, 0x6c, 0xd9, 0xf1,\n      0xda, 0x76, 0xda, 0xfb, 0xdb, 0x80, 0xdc, 0x05, 0xdc, 0x8a, 0xdd, 0x10,\n      0xdd, 0x96, 0xde, 0x1c, 0xde, 0xa2, 0xdf, 0x29, 0xdf, 0xaf, 0xe0, 0x36,\n      0xe0, 0xbd, 0xe1, 0x44, 0xe1, 0xcc, 0xe2, 0x53, 0xe2, 0xdb, 0xe3, 0x63,\n      0xe3, 0xeb, 0xe4, 0x73, 0xe4, 0xfc, 0xe5, 0x84, 0xe6, 0x0d, 0xe6, 0x96,\n      0xe7, 0x1f, 0xe7, 0xa9, 0xe8, 0x32, 0xe8, 0xbc, 0xe9, 0x46, 0xe9, 0xd0,\n      0xea, 0x5b, 0xea, 0xe5, 0xeb, 0x70, 0xeb, 0xfb, 0xec, 0x86, 0xed, 0x11,\n      0xed, 0x9c, 0xee, 0x28, 0xee, 0xb4, 0xef, 0x40, 0xef, 0xcc, 0xf0, 0x58,\n      0xf0, 0xe5, 0xf1, 0x72, 0xf1, 0xff, 0xf2, 0x8c, 0xf3, 0x19, 0xf3, 0xa7,\n      0xf4, 0x34, 0xf4, 0xc2, 0xf5, 0x50, 0xf5, 0xde, 0xf6, 0x6d, 0xf6, 0xfb,\n      0xf7, 0x8a, 0xf8, 0x19, 0xf8, 0xa8, 0xf9, 0x38, 0xf9, 0xc7, 0xfa, 0x57,\n      0xfa, 0xe7, 0xfb, 0x77, 0xfc, 0x07, 0xfc, 0x98, 0xfd, 0x29, 0xfd, 0xba,\n      0xfe, 0x4b, 0xfe, 0xdc, 0xff, 0x6d, 0xff, 0xff\n    };\n\n  StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (GetImageProfile(image,\"icc\") != (const StringInfo *) NULL)\n    return(MagickFalse);\n  profile=AcquireStringInfo(sizeof(sRGBProfile));\n  SetStringInfoDatum(profile,sRGBProfile);\n  status=SetImageProfile(image,\"icc\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name,\n  const void *datum,const size_t length,ExceptionInfo *exception)\n{\n#define ProfileImageTag  \"Profile/Image\"\n#define ThrowProfileException(severity,tag,context) \\\n{ \\\n  if (source_profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(source_profile); \\\n  if (target_profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(target_profile); \\\n  ThrowBinaryException(severity,tag,context); \\\n}\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(name != (const char *) NULL);\n  if ((datum == (const void *) NULL) || (length == 0))\n    {\n      char\n        *next;\n\n      /*\n        Delete image profile(s).\n      */\n      ResetImageProfileIterator(image);\n      for (next=GetNextImageProfile(image); next != (const char *) NULL; )\n      {\n        if (IsOptionMember(next,name) != MagickFalse)\n          {\n            (void) DeleteImageProfile(image,next);\n            ResetImageProfileIterator(image);\n          }\n        next=GetNextImageProfile(image);\n      }\n      return(MagickTrue);\n    }\n  /*\n    Add a ICC, IPTC, or generic profile to the image.\n  */\n  status=MagickTrue;\n  profile=AcquireStringInfo((size_t) length);\n  SetStringInfoDatum(profile,(unsigned char *) datum);\n  if ((LocaleCompare(name,\"icc\") != 0) && (LocaleCompare(name,\"icm\") != 0))\n    status=SetImageProfile(image,name,profile,exception);\n  else\n    {\n      const StringInfo\n        *icc_profile;\n\n      icc_profile=GetImageProfile(image,\"icc\");\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          const char\n            *value;\n\n          value=GetImageProperty(image,\"exif:ColorSpace\",exception);\n          (void) value;\n          if (LocaleCompare(value,\"1\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R98.\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          /* Future.\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R03.\") != 0)\n            (void) SetAdobeRGB1998ImageProfile(image,exception);\n          */\n          icc_profile=GetImageProfile(image,\"icc\");\n        }\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          profile=DestroyStringInfo(profile);\n          return(MagickTrue);\n        }\n#if !defined(MAGICKCORE_LCMS_DELEGATE)\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n        \"'%s' (LCMS)\",image->filename);\n#else\n      {\n        cmsHPROFILE\n          source_profile;\n\n        CMSExceptionInfo\n          cms_exception;\n\n        /*\n          Transform pixel colors as defined by the color profiles.\n        */\n        cmsSetLogErrorHandler(CMSExceptionHandler);\n        cms_exception.image=image;\n        cms_exception.exception=exception;\n        (void) cms_exception;\n        source_profile=cmsOpenProfileFromMemTHR((cmsContext) &cms_exception,\n          GetStringInfoDatum(profile),(cmsUInt32Number)\n          GetStringInfoLength(profile));\n        if (source_profile == (cmsHPROFILE) NULL)\n          ThrowBinaryException(ResourceLimitError,\n            \"ColorspaceColorProfileMismatch\",name);\n        if ((cmsGetDeviceClass(source_profile) != cmsSigLinkClass) &&\n            (icc_profile == (StringInfo *) NULL))\n          status=SetImageProfile(image,name,profile,exception);\n        else\n          {\n            CacheView\n              *image_view;\n\n            ColorspaceType\n              source_colorspace,\n              target_colorspace;\n\n            cmsColorSpaceSignature\n              signature;\n\n            cmsHPROFILE\n              target_profile;\n\n            cmsHTRANSFORM\n              *magick_restrict transform;\n\n            cmsUInt32Number\n              flags,\n              source_type,\n              target_type;\n\n            int\n              intent;\n\n            MagickOffsetType\n              progress;\n\n            size_t\n              source_channels,\n              target_channels;\n\n            ssize_t\n              y;\n\n            unsigned short\n              **magick_restrict source_pixels,\n              **magick_restrict target_pixels;\n\n            target_profile=(cmsHPROFILE) NULL;\n            if (icc_profile != (StringInfo *) NULL)\n              {\n                target_profile=source_profile;\n                source_profile=cmsOpenProfileFromMemTHR((cmsContext)\n                  &cms_exception,GetStringInfoDatum(icc_profile),\n                  (cmsUInt32Number) GetStringInfoLength(icc_profile));\n                if (source_profile == (cmsHPROFILE) NULL)\n                  ThrowProfileException(ResourceLimitError,\n                    \"ColorspaceColorProfileMismatch\",name);\n              }\n            switch (cmsGetColorSpace(source_profile))\n            {\n              case cmsSigCmykData:\n              {\n                source_colorspace=CMYKColorspace;\n                source_type=(cmsUInt32Number) TYPE_CMYK_16;\n                source_channels=4;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                source_colorspace=GRAYColorspace;\n                source_type=(cmsUInt32Number) TYPE_GRAY_16;\n                source_channels=1;\n                break;\n              }\n              case cmsSigLabData:\n              {\n                source_colorspace=LabColorspace;\n                source_type=(cmsUInt32Number) TYPE_Lab_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigLuvData:\n              {\n                source_colorspace=YUVColorspace;\n                source_type=(cmsUInt32Number) TYPE_YUV_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                source_colorspace=sRGBColorspace;\n                source_type=(cmsUInt32Number) TYPE_RGB_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                source_colorspace=XYZColorspace;\n                source_type=(cmsUInt32Number) TYPE_XYZ_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigYCbCrData:\n              {\n                source_colorspace=YCbCrColorspace;\n                source_type=(cmsUInt32Number) TYPE_YCbCr_16;\n                source_channels=3;\n                break;\n              }\n              default:\n              {\n                source_colorspace=UndefinedColorspace;\n                source_type=(cmsUInt32Number) TYPE_RGB_16;\n                source_channels=3;\n                break;\n              }\n            }\n            signature=cmsGetPCS(source_profile);\n            if (target_profile != (cmsHPROFILE) NULL)\n              signature=cmsGetColorSpace(target_profile);\n            switch (signature)\n            {\n              case cmsSigCmykData:\n              {\n                target_colorspace=CMYKColorspace;\n                target_type=(cmsUInt32Number) TYPE_CMYK_16;\n                target_channels=4;\n                break;\n              }\n              case cmsSigLabData:\n              {\n                target_colorspace=LabColorspace;\n                target_type=(cmsUInt32Number) TYPE_Lab_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                target_colorspace=GRAYColorspace;\n                target_type=(cmsUInt32Number) TYPE_GRAY_16;\n                target_channels=1;\n                break;\n              }\n              case cmsSigLuvData:\n              {\n                target_colorspace=YUVColorspace;\n                target_type=(cmsUInt32Number) TYPE_YUV_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                target_colorspace=sRGBColorspace;\n                target_type=(cmsUInt32Number) TYPE_RGB_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                target_colorspace=XYZColorspace;\n                target_type=(cmsUInt32Number) TYPE_XYZ_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigYCbCrData:\n              {\n                target_colorspace=YCbCrColorspace;\n                target_type=(cmsUInt32Number) TYPE_YCbCr_16;\n                target_channels=3;\n                break;\n              }\n              default:\n              {\n                target_colorspace=UndefinedColorspace;\n                target_type=(cmsUInt32Number) TYPE_RGB_16;\n                target_channels=3;\n                break;\n              }\n            }\n            if ((source_colorspace == UndefinedColorspace) ||\n                (target_colorspace == UndefinedColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == GRAYColorspace) &&\n                 (SetImageGray(image,exception) == MagickFalse))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == CMYKColorspace) &&\n                 (image->colorspace != CMYKColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == XYZColorspace) &&\n                 (image->colorspace != XYZColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == YCbCrColorspace) &&\n                 (image->colorspace != YCbCrColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace != CMYKColorspace) &&\n                 (source_colorspace != LabColorspace) &&\n                 (source_colorspace != XYZColorspace) &&\n                 (source_colorspace != YCbCrColorspace) &&\n                 (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n            switch (image->rendering_intent)\n            {\n              case AbsoluteIntent: intent=INTENT_ABSOLUTE_COLORIMETRIC; break;\n              case PerceptualIntent: intent=INTENT_PERCEPTUAL; break;\n              case RelativeIntent: intent=INTENT_RELATIVE_COLORIMETRIC; break;\n              case SaturationIntent: intent=INTENT_SATURATION; break;\n              default: intent=INTENT_PERCEPTUAL; break;\n            }\n            flags=cmsFLAGS_HIGHRESPRECALC;\n#if defined(cmsFLAGS_BLACKPOINTCOMPENSATION)\n            if (image->black_point_compensation != MagickFalse)\n              flags|=cmsFLAGS_BLACKPOINTCOMPENSATION;\n#endif\n            transform=AcquireTransformThreadSet(image,source_profile,\n              source_type,target_profile,target_type,intent,flags);\n            if (transform == (cmsHTRANSFORM *) NULL)\n              ThrowProfileException(ImageError,\"UnableToCreateColorTransform\",\n                name);\n            /*\n              Transform image as dictated by the source & target image profiles.\n            */\n            source_pixels=AcquirePixelThreadSet(image->columns,source_channels);\n            target_pixels=AcquirePixelThreadSet(image->columns,target_channels);\n            if ((source_pixels == (unsigned short **) NULL) ||\n                (target_pixels == (unsigned short **) NULL))\n              {\n                transform=DestroyTransformThreadSet(transform);\n                ThrowProfileException(ResourceLimitError,\n                  \"MemoryAllocationFailed\",image->filename);\n              }\n            if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n              {\n                target_pixels=DestroyPixelThreadSet(target_pixels);\n                source_pixels=DestroyPixelThreadSet(source_pixels);\n                transform=DestroyTransformThreadSet(transform);\n                if (source_profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(source_profile);\n                if (target_profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(target_profile);\n                return(MagickFalse);\n              }\n            if (target_colorspace == CMYKColorspace)\n              (void) SetImageColorspace(image,target_colorspace,exception);\n            progress=0;\n            image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel for schedule(static,4) shared(status) \\\n              magick_threads(image,image,image->rows,1)\n#endif\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const int\n                id = GetOpenMPThreadId();\n\n              MagickBooleanType\n                sync;\n\n              register ssize_t\n                x;\n\n              register Quantum\n                *magick_restrict q;\n\n              register unsigned short\n                *p;\n\n              if (status == MagickFalse)\n                continue;\n              q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                {\n                  status=MagickFalse;\n                  continue;\n                }\n              p=source_pixels[id];\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *p++=ScaleQuantumToShort(GetPixelRed(image,q));\n                if (source_channels > 1)\n                  {\n                    *p++=ScaleQuantumToShort(GetPixelGreen(image,q));\n                    *p++=ScaleQuantumToShort(GetPixelBlue(image,q));\n                  }\n                if (source_channels > 3)\n                  *p++=ScaleQuantumToShort(GetPixelBlack(image,q));\n                q+=GetPixelChannels(image);\n              }\n              cmsDoTransform(transform[id],source_pixels[id],target_pixels[id],\n                (unsigned int) image->columns);\n              p=target_pixels[id];\n              q-=GetPixelChannels(image)*image->columns;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (target_channels == 1)\n                  SetPixelGray(image,ScaleShortToQuantum(*p),q);\n                else\n                  SetPixelRed(image,ScaleShortToQuantum(*p),q);\n                p++;\n                if (target_channels > 1)\n                  {\n                    SetPixelGreen(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                    SetPixelBlue(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                  }\n                if (target_channels > 3)\n                  {\n                    SetPixelBlack(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                  }\n                q+=GetPixelChannels(image);\n              }\n              sync=SyncCacheViewAuthenticPixels(image_view,exception);\n              if (sync == MagickFalse)\n                status=MagickFalse;\n              if (image->progress_monitor != (MagickProgressMonitor) NULL)\n                {\n                  MagickBooleanType\n                    proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n                  #pragma omp critical (MagickCore_ProfileImage)\n#endif\n                  proceed=SetImageProgress(image,ProfileImageTag,progress++,\n                    image->rows);\n                  if (proceed == MagickFalse)\n                    status=MagickFalse;\n                }\n            }\n            image_view=DestroyCacheView(image_view);\n            (void) SetImageColorspace(image,target_colorspace,exception);\n            switch (signature)\n            {\n              case cmsSigRgbData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  TrueColorType : TrueColorAlphaType;\n                break;\n              }\n              case cmsSigCmykData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  ColorSeparationType : ColorSeparationAlphaType;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  GrayscaleType : GrayscaleAlphaType;\n                break;\n              }\n              default:\n                break;\n            }\n            target_pixels=DestroyPixelThreadSet(target_pixels);\n            source_pixels=DestroyPixelThreadSet(source_pixels);\n            transform=DestroyTransformThreadSet(transform);\n            if ((status != MagickFalse) &&\n                (cmsGetDeviceClass(source_profile) != cmsSigLinkClass))\n              status=SetImageProfile(image,name,profile,exception);\n            if (target_profile != (cmsHPROFILE) NULL)\n              (void) cmsCloseProfile(target_profile);\n          }\n        (void) cmsCloseProfile(source_profile);\n      }\n#endif\n    }\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProfile() removes a named profile from the image and returns its\n%  value.\n%\n%  The format of the RemoveImageProfile method is:\n%\n%      void *RemoveImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport StringInfo *RemoveImageProfile(Image *image,const char *name)\n{\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  profile=(StringInfo *) RemoveNodeFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t P r o f i l e I t e r a t o r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImageProfileIterator() resets the image profile iterator.  Use it in\n%  conjunction with GetNextImageProfile() to iterate over all the profiles\n%  associated with an image.\n%\n%  The format of the ResetImageProfileIterator method is:\n%\n%      ResetImageProfileIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImageProfileIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProfile() adds a named profile to the image.  If a profile with the\n%  same name already exists, it is replaced.  This method differs from the\n%  ProfileImage() method in that it does not apply CMS color profiles.\n%\n%  The format of the SetImageProfile method is:\n%\n%      MagickBooleanType SetImageProfile(Image *image,const char *name,\n%        const StringInfo *profile)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name, for example icc, exif, and 8bim (8bim is the\n%      Photoshop wrapper for iptc profiles).\n%\n%    o profile: A StringInfo structure that contains the named profile.\n%\n*/\n\nstatic void *DestroyProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n\nstatic inline const unsigned char *ReadResourceByte(const unsigned char *p,\n  unsigned char *quantum)\n{\n  *quantum=(*p++);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceLong(const unsigned char *p,\n  unsigned int *quantum)\n{\n  *quantum=(unsigned int) (*p++) << 24;\n  *quantum|=(unsigned int) (*p++) << 16;\n  *quantum|=(unsigned int) (*p++) << 8;\n  *quantum|=(unsigned int) (*p++) << 0;\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceShort(const unsigned char *p,\n  unsigned short *quantum)\n{\n  *quantum=(unsigned short) (*p++) << 8;\n  *quantum|=(unsigned short) (*p++);\n  return(p);\n}\n\nstatic inline void WriteResourceLong(unsigned char *p,\n  const unsigned int quantum)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) (quantum >> 24);\n  buffer[1]=(unsigned char) (quantum >> 16);\n  buffer[2]=(unsigned char) (quantum >> 8);\n  buffer[3]=(unsigned char) quantum;\n  (void) CopyMagickMemory(p,buffer,4);\n}\n\nstatic void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n  const unsigned char\n    *datum,\n    *q;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((count & 0x01) != 0)\n      count++;\n    if ((count < 0) || (p > (datum+length-count)) ||\n        (count > (ssize_t) length))\n      break;\n    if (id != profile_id)\n      p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_count;\n\n        StringInfo\n          *extract_profile;\n\n        extract_count=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_count=profile->length;\n            if ((extract_count & 0x01) != 0)\n              extract_count++;\n            extract_profile=AcquireStringInfo(offset+extract_count+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset-4);\n            WriteResourceLong(extract_profile->datum+offset-4,\n              (unsigned int)profile->length);\n            (void) CopyMagickMemory(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) CopyMagickMemory(extract_profile->datum+offset+extract_count,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}\n\nstatic void GetProfilesFromResourceBlock(Image *image,\n  const StringInfo *resource_block,ExceptionInfo *exception)\n{\n  const unsigned char\n    *datum;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    length_byte;\n\n   unsigned int\n     value;\n\n  unsigned short\n    id;\n\n  datum=GetStringInfoDatum(resource_block);\n  length=GetStringInfoLength(resource_block);\n  for (p=datum; p < (datum+length-16); )\n  {\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length) ||\n        (count < 0))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        unsigned int\n          resolution;\n\n        unsigned short\n          units;\n\n        /*\n          Resolution.\n        */\n        p=ReadResourceLong(p,&resolution);\n        image->resolution.x=((double) resolution)/65536.0;\n        p=ReadResourceShort(p,&units)+2;\n        p=ReadResourceLong(p,&resolution)+4;\n        image->resolution.y=((double) resolution)/65536.0;\n        /*\n          Values are always stored as pixels per inch.\n        */\n        if ((ResolutionType) units != PixelsPerCentimeterResolution)\n          image->units=PixelsPerInchResolution;\n        else\n          {\n            image->units=PixelsPerCentimeterResolution;\n            image->resolution.x/=2.54;\n            image->resolution.y/=2.54;\n          }\n        break;\n      }\n      case 0x0404:\n      {\n        /*\n          IPTC Profile\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"iptc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x040c:\n      {\n        /*\n          Thumbnail.\n        */\n        p+=count;\n        break;\n      }\n      case 0x040f:\n      {\n        /*\n          ICC Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"icc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0422:\n      {\n        /*\n          EXIF Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"exif\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0424:\n      {\n        /*\n          XMP Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"xmp\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic MagickBooleanType SetImageProfileInternal(Image *image,const char *name,\n  const StringInfo *profile,const MagickBooleanType recursive,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    property[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MagickPathExtent);\n  LocaleLower(key);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if (status != MagickFalse)\n    {\n      if (LocaleCompare(name,\"8bim\") == 0)\n        GetProfilesFromResourceBlock(image,profile,exception);\n      else if (recursive == MagickFalse)\n        WriteTo8BimProfile(image,name,profile);\n    }\n  /*\n    Inject profile into image properties.\n  */\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s:*\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  return(SetImageProfileInternal(image,name,profile,MagickFalse,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e P r o f i l e s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageProfiles() synchronizes image properties with the image profiles.\n%  Currently we only support updating the EXIF resolution and orientation.\n%\n%  The format of the SyncImageProfiles method is:\n%\n%      MagickBooleanType SyncImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic inline int ReadProfileByte(unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed short ReadProfileShort(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      quantum.unsigned_value=value & 0xffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed int ReadProfileLong(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed int ReadProfileMSBLong(unsigned char **p,size_t *length)\n{\n  signed int\n    value;\n\n  if (*length < 4)\n    return(0);\n  value=ReadProfileLong(MSBEndian,*p);\n  (*length)-=4;\n  *p+=4;\n  return(value);\n}\n\nstatic inline signed short ReadProfileMSBShort(unsigned char **p,\n  size_t *length)\n{\n  signed short\n    value;\n\n  if (*length < 2)\n    return(0);\n  value=ReadProfileShort(MSBEndian,*p);\n  (*length)-=2;\n  *p+=2;\n  return(value);\n}\n\nstatic inline void WriteProfileLong(const EndianType endian,\n  const size_t value,unsigned char *p)\n{\n  unsigned char\n    buffer[4];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      (void) CopyMagickMemory(p,buffer,4);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  (void) CopyMagickMemory(p,buffer,4);\n}\n\nstatic void WriteProfileShort(const EndianType endian,\n  const unsigned short value,unsigned char *p)\n{\n  unsigned char\n    buffer[2];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      (void) CopyMagickMemory(p,buffer,2);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  (void) CopyMagickMemory(p,buffer,2);\n}\n\nstatic MagickBooleanType Sync8BimProfile(Image *image,StringInfo *profile)\n{\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *p;\n\n  unsigned short\n    id;\n\n  length=GetStringInfoLength(profile);\n  p=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadProfileByte(&p,&length) != 0x38)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x42)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x49)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x4D)\n      continue;\n    if (length < 7)\n      return(MagickFalse);\n    id=ReadProfileMSBShort(&p,&length);\n    count=(ssize_t) ReadProfileByte(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return(MagickFalse);\n    p+=count;\n    if ((*p & 0x01) == 0)\n      (void) ReadProfileByte(&p,&length);\n    count=(ssize_t) ReadProfileMSBLong(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return(MagickFalse);\n    if ((id == 0x3ED) && (count == 16))\n      {\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.x*2.54*\n            65536.0),p);\n        else\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.x*\n            65536.0),p);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+4);\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.y*2.54*\n            65536.0),p+8);\n        else\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.y*\n            65536.0),p+8);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+12);\n      }\n    p+=count;\n    length-=count;\n  }\n  return(MagickTrue);\n}\n\nMagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format-1) >= EXIF_NUM_FORMATS)\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}\n\nMagickPrivate MagickBooleanType SyncImageProfiles(Image *image)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  status=MagickTrue;\n  profile=(StringInfo *) GetImageProfile(image,\"8BIM\");\n  if (profile != (StringInfo *) NULL)\n    if (Sync8BimProfile(image,profile) == MagickFalse)\n      status=MagickFalse;\n  profile=(StringInfo *) GetImageProfile(image,\"EXIF\");\n  if (profile != (StringInfo *) NULL)\n    if (SyncExifProfile(image,profile) == MagickFalse)\n      status=MagickFalse;\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%            PPPP    RRRR    OOO   PPPP   EEEEE  RRRR   TTTTT  Y   Y          %\n%            P   P   R   R  O   O  P   P  E      R   R    T     Y Y           %\n%            PPPP    RRRR   O   O  PPPP   EEE    RRRR     T      Y            %\n%            P       R R    O   O  P      E      R R      T      Y            %\n%            P       R  R    OOO   P      EEEEE  R  R     T      Y            %\n%                                                                             %\n%                                                                             %\n%                         MagickCore Property Methods                         %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/compare.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/fx-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/locale-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/signature.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS2_LCMS2_H)\n#include <lcms2/lcms2.h>\n#elif defined(MAGICKCORE_HAVE_LCMS2_H)\n#include \"lcms2.h\"\n#elif defined(MAGICKCORE_HAVE_LCMS_LCMS_H)\n#include <lcms/lcms.h>\n#else\n#include \"lcms.h\"\n#endif\n#endif\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o p e r t i e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProperties() clones all the image properties to another image.\n%\n%  The format of the CloneImageProperties method is:\n%\n%      MagickBooleanType CloneImageProperties(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProperties(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      clone_image->filename);\n  (void) CopyMagickString(image->filename,clone_image->filename,MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,clone_image->magick_filename,\n    MagickPathExtent);\n  image->compression=clone_image->compression;\n  image->quality=clone_image->quality;\n  image->depth=clone_image->depth;\n  image->alpha_color=clone_image->alpha_color;\n  image->background_color=clone_image->background_color;\n  image->border_color=clone_image->border_color;\n  image->transparent_color=clone_image->transparent_color;\n  image->gamma=clone_image->gamma;\n  image->chromaticity=clone_image->chromaticity;\n  image->rendering_intent=clone_image->rendering_intent;\n  image->black_point_compensation=clone_image->black_point_compensation;\n  image->units=clone_image->units;\n  image->montage=(char *) NULL;\n  image->directory=(char *) NULL;\n  (void) CloneString(&image->geometry,clone_image->geometry);\n  image->offset=clone_image->offset;\n  image->resolution.x=clone_image->resolution.x;\n  image->resolution.y=clone_image->resolution.y;\n  image->page=clone_image->page;\n  image->tile_offset=clone_image->tile_offset;\n  image->extract_info=clone_image->extract_info;\n  image->filter=clone_image->filter;\n  image->fuzz=clone_image->fuzz;\n  image->intensity=clone_image->intensity;\n  image->interlace=clone_image->interlace;\n  image->interpolate=clone_image->interpolate;\n  image->endian=clone_image->endian;\n  image->gravity=clone_image->gravity;\n  image->compose=clone_image->compose;\n  image->orientation=clone_image->orientation;\n  image->scene=clone_image->scene;\n  image->dispose=clone_image->dispose;\n  image->delay=clone_image->delay;\n  image->ticks_per_second=clone_image->ticks_per_second;\n  image->iterations=clone_image->iterations;\n  image->total_colors=clone_image->total_colors;\n  image->taint=clone_image->taint;\n  image->progress_monitor=clone_image->progress_monitor;\n  image->client_data=clone_image->client_data;\n  image->start_loop=clone_image->start_loop;\n  image->error=clone_image->error;\n  image->signature=clone_image->signature;\n  if (clone_image->properties != (void *) NULL)\n    {\n      if (image->properties != (void *) NULL)\n        DestroyImageProperties(image);\n      image->properties=CloneSplayTree((SplayTreeInfo *)\n        clone_image->properties,(void *(*)(void *)) ConstantString,\n        (void *(*)(void *)) ConstantString);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e f i n e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DefineImageProperty() associates an assignment string of the form\n%  \"key=value\" with an artifact or options. It is equivelent to\n%  SetImageProperty()\n%\n%  The format of the DefineImageProperty method is:\n%\n%      MagickBooleanType DefineImageProperty(Image *image,const char *property,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType DefineImageProperty(Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n\n  register char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(property != (const char *) NULL);\n  (void) CopyMagickString(key,property,MagickPathExtent-1);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageProperty(image,key,value,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProperty() deletes an image property.\n%\n%  The format of the DeleteImageProperty method is:\n%\n%      MagickBooleanType DeleteImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProperty(Image *image,\n  const char *property)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return(MagickFalse);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->properties,property));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o p e r t i e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProperties() destroys all properties and associated memory\n%  attached to the given image.\n%\n%  The format of the DestroyDefines method is:\n%\n%      void DestroyImageProperties(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t I m a g e P r o p e r t y                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatImageProperty() permits formatted property/value pairs to be saved as\n%  an image property.\n%\n%  The format of the FormatImageProperty method is:\n%\n%      MagickBooleanType FormatImageProperty(Image *image,const char *property,\n%        const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o  image:  The image.\n%\n%   o  property:  The attribute property.\n%\n%   o  format:  A string describing the format to use to write the remaining\n%      arguments.\n%\n*/\nMagickExport MagickBooleanType FormatImageProperty(Image *image,\n  const char *property,const char *format,...)\n{\n  char\n    value[MagickPathExtent];\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(value,MagickPathExtent,format,operands);\n  (void) n;\n  va_end(operands);\n  exception=AcquireExceptionInfo();\n  status=SetImageProperty(image,property,value,exception);\n  exception=DestroyExceptionInfo(exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProperty() gets a value associated with an image property.\n%\n%  This includes,  profile prefixes, such as \"exif:\", \"iptc:\" and \"8bim:\"\n%  It does not handle non-prifile prefixes, such as \"fx:\", \"option:\", or\n%  \"artifact:\".\n%\n%  The returned string is stored as a properity of the same name for faster\n%  lookup later. It should NOT be freed by the caller.\n%\n%  The format of the GetImageProperty method is:\n%\n%      const char *GetImageProperty(const Image *image,const char *key,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char\n  *TracePSClippath(const unsigned char *,size_t),\n  *TraceSVGClippath(const unsigned char *,size_t,const size_t,\n    const size_t);\n\nstatic MagickBooleanType GetIPTCProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    *message;\n\n  const StringInfo\n    *profile;\n\n  long\n    count,\n    dataset,\n    record;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=sscanf(key,\"IPTC:%ld:%ld\",&dataset,&record);\n  if (count != 2)\n    return(MagickFalse);\n  attribute=(char *) NULL;\n  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=(ssize_t) length)\n  {\n    length=1;\n    if ((ssize_t) GetStringInfoDatum(profile)[i] != 0x1c)\n      continue;\n    length=(size_t) (GetStringInfoDatum(profile)[i+3] << 8);\n    length|=GetStringInfoDatum(profile)[i+4];\n    if (((long) GetStringInfoDatum(profile)[i+1] == dataset) &&\n        ((long) GetStringInfoDatum(profile)[i+2] == record))\n      {\n        message=(char *) NULL;\n        if (~length >= 1)\n          message=(char *) AcquireQuantumMemory(length+1UL,sizeof(*message));\n        if (message != (char *) NULL)\n          {\n            (void) CopyMagickString(message,(char *) GetStringInfoDatum(\n              profile)+i+5,length+1);\n            (void) ConcatenateString(&attribute,message);\n            (void) ConcatenateString(&attribute,\";\");\n            message=DestroyString(message);\n          }\n      }\n    i+=5;\n  }\n  if ((attribute == (char *) NULL) || (*attribute == ';'))\n    {\n      if (attribute != (char *) NULL)\n        attribute=DestroyString(attribute);\n      return(MagickFalse);\n    }\n  attribute[strlen(attribute)-1]='\\0';\n  (void) SetImageProperty((Image *) image,key,(const char *) attribute,\n    exception);\n  attribute=DestroyString(attribute);\n  return(MagickTrue);\n}\n\nstatic inline int ReadPropertyByte(const unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline signed int ReadPropertyMSBLong(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[4];\n\n  unsigned int\n    value;\n\n  if (*length < 4)\n    return(-1);\n  for (i=0; i < 4; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline signed short ReadPropertyMSBShort(const unsigned char **p,\n  size_t *length)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  unsigned char\n    buffer[2];\n\n  unsigned short\n    value;\n\n  if (*length < 2)\n    return((unsigned short) ~0);\n  for (i=0; i < 2; i++)\n  {\n    c=(int) (*(*p)++);\n    (*length)--;\n    buffer[i]=(unsigned char) c;\n  }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n  ExceptionInfo *exception)\n{\n  char\n    *attribute,\n    format[MagickPathExtent],\n    name[MagickPathExtent],\n    *resource;\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *info;\n\n  long\n    start,\n    stop;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    id,\n    sub_number;\n\n  size_t\n    length;\n\n  /*\n    There are no newlines in path names, so it's safe as terminator.\n  */\n  profile=GetImageProfile(image,\"8bim\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  count=(ssize_t) sscanf(key,\"8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]\",&start,&stop,\n    name,format);\n  if ((count != 2) && (count != 3) && (count != 4))\n    return(MagickFalse);\n  if (count < 4)\n    (void) CopyMagickString(format,\"SVG\",MagickPathExtent);\n  if (count < 3)\n    *name='\\0';\n  sub_number=1;\n  if (*name == '#')\n    sub_number=(ssize_t) StringToLong(&name[1]);\n  sub_number=MagickMax(sub_number,1L);\n  resource=(char *) NULL;\n  status=MagickFalse;\n  length=GetStringInfoLength(profile);\n  info=GetStringInfoDatum(profile);\n  while ((length > 0) && (status == MagickFalse))\n  {\n    if (ReadPropertyByte(&info,&length) != (unsigned char) '8')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'B')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'I')\n      continue;\n    if (ReadPropertyByte(&info,&length) != (unsigned char) 'M')\n      continue;\n    id=(ssize_t) ReadPropertyMSBShort(&info,&length);\n    if (id < (ssize_t) start)\n      continue;\n    if (id > (ssize_t) stop)\n      continue;\n    if (resource != (char *) NULL)\n      resource=DestroyString(resource);\n    count=(ssize_t) ReadPropertyByte(&info,&length);\n    if ((count != 0) && ((size_t) count <= length))\n      {\n        resource=(char *) NULL;\n        if (~((size_t) count) >= (MagickPathExtent-1))\n          resource=(char *) AcquireQuantumMemory((size_t) count+\n            MagickPathExtent,sizeof(*resource));\n        if (resource != (char *) NULL)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              resource[i]=(char) ReadPropertyByte(&info,&length);\n            resource[count]='\\0';\n          }\n      }\n    if ((count & 0x01) == 0)\n      (void) ReadPropertyByte(&info,&length);\n    count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n    if ((*name != '\\0') && (*name != '#'))\n      if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n        {\n          /*\n            No name match, scroll forward and try next.\n          */\n          info+=count;\n          length-=MagickMin(count,(ssize_t) length);\n          continue;\n        }\n    if ((*name == '#') && (sub_number != 1))\n      {\n        /*\n          No numbered match, scroll forward and try next.\n        */\n        sub_number--;\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        continue;\n      }\n    /*\n      We have the resource of interest.\n    */\n    attribute=(char *) NULL;\n    if (~((size_t) count) >= (MagickPathExtent-1))\n      attribute=(char *) AcquireQuantumMemory((size_t) count+MagickPathExtent,\n        sizeof(*attribute));\n    if (attribute != (char *) NULL)\n      {\n        (void) CopyMagickMemory(attribute,(char *) info,(size_t) count);\n        attribute[count]='\\0';\n        info+=count;\n        length-=MagickMin(count,(ssize_t) length);\n        if ((id <= 1999) || (id >= 2999))\n          (void) SetImageProperty((Image *) image,key,(const char *)\n            attribute,exception);\n        else\n          {\n            char\n              *path;\n\n            if (LocaleCompare(format,\"svg\") == 0)\n              path=TraceSVGClippath((unsigned char *) attribute,(size_t) count,\n                image->columns,image->rows);\n            else\n              path=TracePSClippath((unsigned char *) attribute,(size_t) count);\n            (void) SetImageProperty((Image *) image,key,(const char *) path,\n              exception);\n            path=DestroyString(path);\n          }\n        attribute=DestroyString(attribute);\n        status=MagickTrue;\n      }\n  }\n  if (resource != (char *) NULL)\n    resource=DestroyString(resource);\n  return(status);\n}\n\nstatic inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      quantum.unsigned_value=value & 0xffffffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  quantum.unsigned_value=value & 0xffffffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned int ReadPropertyUnsignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) buffer[3] << 24;\n      value|=(unsigned int) buffer[2] << 16;\n      value|=(unsigned int) buffer[1] << 8;\n      value|=(unsigned int) buffer[0];\n      return(value & 0xffffffff);\n    }\n  value=(unsigned int) buffer[0] << 24;\n  value|=(unsigned int) buffer[1] << 16;\n  value|=(unsigned int) buffer[2] << 8;\n  value|=(unsigned int) buffer[3];\n  return(value & 0xffffffff);\n}   \n\nstatic inline signed short ReadPropertySignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      quantum.unsigned_value=value & 0xffff;\n      return(quantum.signed_value);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  quantum.unsigned_value=value & 0xffff;\n  return(quantum.signed_value);\n}\n\nstatic inline unsigned short ReadPropertyUnsignedShort(const EndianType endian,\n  const unsigned char *buffer)\n{\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) buffer[1] << 8;\n      value|=(unsigned short) buffer[0];\n      return(value & 0xffff);\n    }\n  value=(unsigned short) buffer[0] << 8;\n  value|=(unsigned short) buffer[1];\n  return(value & 0xffff);\n}\n\nstatic MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",arg); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MagickPathExtent-length, \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MagickPathExtent-1)) \\\n       length=MagickPathExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n      *description;\n  } TagInfo;\n\n  static TagInfo\n    EXIFTag[] =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002, \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\" },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\" },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\" },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\" },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\" },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\" },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\" },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\" },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\" },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\" },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\" },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\" },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\" },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\" },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\" },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\" },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\" },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\" },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\" },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\" },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\" },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\" },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\" },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\" },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\" },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\" },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\" },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\" },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203, \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\" },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\" },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\" },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\" },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\" },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301, \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\" },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\" },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n      {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\" },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\" },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\" },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\" },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\" },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\" },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\" },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\" },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\" },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\" },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n      {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\" },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\" },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026, \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\" },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\" },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\" },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\" },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\" },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\" },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\" },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038, \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\" },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n      {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\" },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\" },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\" },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\" },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\" },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\" },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\" },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\" },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\" },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\" },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\" },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\" },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769, \"exif:ExifOffset\" },\n      {  0x8773, \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\" },\n      {  0x8827, \"exif:ISOSpeedRatings\" },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\" },\n      {  0x9000, \"exif:ExifVersion\" },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\" },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n      {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\" },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\" },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\" },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\" },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\" },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9211, \"exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n      {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\" },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\" },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\" },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\" },\n      {  0x9C9f, \"exif:WinXP-Subject\" },\n      {  0x9286, \"exif:UserComment\" },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\" },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },\n      {  0xa000, \"exif:FlashPixVersion\" },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:ExifImageWidth\" },\n      {  0xa003, \"exif:ExifImageLength\" },\n      {  0xa004, \"exif:RelatedSoundFile\" },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\" },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\" },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\" },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\" },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\" },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\" },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\" },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n      {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\" },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\" },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\" },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\" },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\" },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\" },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\" },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\" },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\" },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\" },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\" },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\" },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\" },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\" },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\" },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\" },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\" },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\" },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\" },\n      { 0x00000, (const char *) NULL }\n    };\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property) <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in description=value format */\n      break;\n    }\n    case '!':\n    {\n      tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n        n;\n\n      /*\n        Check for a hex based tag specification first.\n      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n          c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A') && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n              if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n              else\n                return(MagickFalse);\n        }\n      } while (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n        Try to match the text with a tag name instead.\n      */\n      for (i=0; ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n        if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n            tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n      }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length) != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=(size_t) ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n      format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*tag_bytes[format];\n      if (number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if ((offset < 0) || (size_t) offset >= length)\n            continue;\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          p=(unsigned char *) (exif+offset);\n        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n          char\n            buffer[MagickPathExtent],\n            *value;\n\n          value=(char *) NULL;\n          *buffer='\\0';\n          switch (format)\n          {\n            case EXIF_FMT_BYTE:\n            case EXIF_FMT_UNDEFINED:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(unsigned char *) p1));\n              break;\n            }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"%.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"%hd\",ReadPropertySignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"%hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n            }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_SLONG:\n            {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n              break;\n            }\n            case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SRATIONAL:\n            {\n              EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n                ReadPropertySignedLong(endian,p1+4));\n              break;\n            }\n            case EXIF_FMT_SINGLE:\n            {\n              EXIFMultipleValues(4,\"%f\",(double) *(float *) p1);\n              break;\n            }\n            case EXIF_FMT_DOUBLE:\n            {\n              EXIFMultipleValues(8,\"%f\",*(double *) p1);\n              break;\n            }\n            default:\n            case EXIF_FMT_STRING:\n            {\n              value=(char *) NULL;\n              if (~((size_t) number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n              if (value != (char *) NULL)\n                {\n                  register ssize_t\n                    i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n                    value[i]='.';\n                    if ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char) p[i];\n                  }\n                  value[i]='\\0';\n                }\n              break;\n            }\n          }\n          if (value != (char *) NULL)\n            {\n              char\n                *key;\n\n              register const char\n                *p;\n\n              key=AcquireString(property);\n              switch (all)\n              {\n                case 1:\n                {\n                  const char\n                    *description;\n\n                  register ssize_t\n                    i;\n\n                  description=\"unknown\";\n                  for (i=0; ; i++)\n                  {\n                    if (EXIFTag[i].tag == 0)\n                      break;\n                    if (EXIFTag[i].tag == tag_value)\n                      {\n                        description=EXIFTag[i].description;\n                        break;\n                      }\n                  }\n                  (void) FormatLocaleString(key,MagickPathExtent,\"%s\",\n                    description);\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n                case 2:\n                {\n                  if (tag_value < 0x10000)\n                    (void) FormatLocaleString(key,MagickPathExtent,\"#%04lx\",\n                      (unsigned long) tag_value);\n                  else\n                    if (tag_value < 0x20000)\n                      (void) FormatLocaleString(key,MagickPathExtent,\"@%04lx\",\n                        (unsigned long) (tag_value & 0xffff));\n                    else\n                      (void) FormatLocaleString(key,MagickPathExtent,\"unknown\");\n                  break;\n                }\n                default:\n                {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"exif:\",\"exif:thumbnail:\");\n                }\n              }\n              p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n                  image->properties,key);\n              if (p == (const char *) NULL)\n                (void) SetImageProperty((Image *) image,key,value,exception);\n              value=DestroyString(value);\n              key=DestroyString(key);\n              status=MagickTrue;\n            }\n        }\n        if ((tag_value == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n            if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n              {\n                ssize_t\n                  tag_offset1;\n\n                tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n                  0);\n                directory_stack[level].directory=directory;\n                entry++;\n                directory_stack[level].entry=entry;\n                directory_stack[level].offset=tag_offset;\n                level++;\n                directory_stack[level].directory=exif+offset;\n                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n                level++;\n                if ((directory+2+(12*number_entries)) > (exif+length))\n                  break;\n                offset=(ssize_t) ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n                if ((offset != 0) && ((size_t) offset < length) &&\n                    (level < (MaxDirectoryStack-2)))\n                  {\n                    directory_stack[level].directory=exif+offset;\n                    directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n                    level++;\n                  }\n              }\n            break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(status);\n}\n\nstatic MagickBooleanType GetICCProperty(const Image *image,const char *property,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *profile;\n\n  magick_unreferenced(property);\n\n  profile=GetImageProfile(image,\"icc\");\n  if (profile == (StringInfo *) NULL)\n    profile=GetImageProfile(image,\"icm\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if (GetStringInfoLength(profile) < 128)\n    return(MagickFalse);  /* minimum ICC profile length */\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n  {\n    cmsHPROFILE\n      icc_profile;\n\n    icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n      (cmsUInt32Number) GetStringInfoLength(profile));\n    if (icc_profile != (cmsHPROFILE *) NULL)\n      {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n        const char\n          *name;\n\n        name=cmsTakeProductName(icc_profile);\n        if (name != (const char *) NULL)\n          (void) SetImageProperty((Image *) image,\"icc:name\",name,exception);\n#else\n        char\n          info[MagickPathExtent];\n\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n          \"en\",\"US\",info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:description\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoManufacturer,\n          \"en\",\"US\",info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:manufacturer\",info,\n          exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoModel,\"en\",\n          \"US\",info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:model\",info,exception);\n        (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoCopyright,\n          \"en\",\"US\",info,MagickPathExtent);\n        (void) SetImageProperty((Image *) image,\"icc:copyright\",info,exception);\n#endif\n        (void) cmsCloseProfile(icc_profile);\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType SkipXMPValue(const char *value)\n{\n  if (value == (const char*) NULL)\n    return(MagickTrue);\n  while (*value != '\\0')\n  {\n    if (isspace((int) ((unsigned char) *value)) == 0)\n      return(MagickFalse);\n    value++;\n  }\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType GetXMPProperty(const Image *image,const char *property)\n{\n  char\n    *xmp_profile;\n\n  const char\n    *content;\n\n  const StringInfo\n    *profile;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  register const char\n    *p;\n\n  XMLTreeInfo\n    *child,\n    *description,\n    *node,\n    *rdf,\n    *xmp;\n\n  profile=GetImageProfile(image,\"xmp\");\n  if (profile == (StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property == (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  xmp_profile=StringInfoToString(profile);\n  if (xmp_profile == (char *) NULL)\n    return(MagickFalse);\n  for (p=xmp_profile; *p != '\\0'; p++)\n    if ((*p == '<') && (*(p+1) == 'x'))\n      break;\n  exception=AcquireExceptionInfo();\n  xmp=NewXMLTree((char *) p,exception);\n  xmp_profile=DestroyString(xmp_profile);\n  exception=DestroyExceptionInfo(exception);\n  if (xmp == (XMLTreeInfo *) NULL)\n    return(MagickFalse);\n  status=MagickFalse;\n  rdf=GetXMLTreeChild(xmp,\"rdf:RDF\");\n  if (rdf != (XMLTreeInfo *) NULL)\n    {\n      if (image->properties == (void *) NULL)\n        ((Image *) image)->properties=NewSplayTree(CompareSplayTreeString,\n          RelinquishMagickMemory,RelinquishMagickMemory);\n      description=GetXMLTreeChild(rdf,\"rdf:Description\");\n      while (description != (XMLTreeInfo *) NULL)\n      {\n        node=GetXMLTreeChild(description,(const char *) NULL);\n        while (node != (XMLTreeInfo *) NULL)\n        {\n          child=GetXMLTreeChild(node,(const char *) NULL);\n          content=GetXMLTreeContent(node);\n          if ((child == (XMLTreeInfo *) NULL) &&\n              (SkipXMPValue(content) == MagickFalse))\n            (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n              ConstantString(GetXMLTreeTag(node)),ConstantString(content));\n          while (child != (XMLTreeInfo *) NULL)\n          {\n            content=GetXMLTreeContent(child);\n            if (SkipXMPValue(content) == MagickFalse)\n              (void) AddValueToSplayTree((SplayTreeInfo *) image->properties,\n                ConstantString(GetXMLTreeTag(child)),ConstantString(content));\n            child=GetXMLTreeSibling(child);\n          }\n          node=GetXMLTreeSibling(node);\n        }\n        description=GetNextXMLTreeTag(description);\n      }\n    }\n  xmp=DestroyXMLTree(xmp);\n  return(status);\n}\n\nstatic char *TracePSClippath(const unsigned char *blob,size_t length)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    knot_count,\n    selector,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n  (void) FormatLocaleString(message,MagickPathExtent,\"/ClipImage\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"{\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  /c {curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  /l {lineto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  /m {moveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /v {currentpoint 6 2 roll curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /y {2 copy curveto} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"  /z {closepath} bind def\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"  newpath\\n\");\n  (void) ConcatenateString(&path,message);\n  /*\n    The clipping path format is defined in \"Adobe Photoshop File\n    Formats Specification\" version 6.0 downloadable from adobe.com.\n  */\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length > 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          size_t\n            xx,\n            yy;\n\n          yy=(size_t) ReadPropertyMSBLong(&blob,&length);\n          xx=(size_t) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x/4096/4096;\n          point[i].y=1.0-(double) y/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"  %g %g m\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l\\n\",point[1].x,point[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v\\n\",point[0].x,point[0].y,\n                  point[1].x,point[1].y);\n              else\n                if ((point[0].x == point[1].x) && (point[0].y == point[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y\\n\",last[2].x,last[2].y,\n                    point[1].x,point[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c\\n\",last[2].x,\n                    last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n            /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"  %g %g l z\\n\",first[1].x,first[1].y);\n            else\n              if ((last[1].x == last[2].x) && (last[1].y == last[2].y))\n                (void) FormatLocaleString(message,MagickPathExtent,\n                  \"  %g %g %g %g v z\\n\",first[0].x,first[0].y,\n                  first[1].x,first[1].y);\n              else\n                if ((first[0].x == first[1].x) && (first[0].y == first[1].y))\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g y z\\n\",last[2].x,last[2].y,\n                    first[1].x,first[1].y);\n                else\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"  %g %g %g %g %g %g c z\\n\",last[2].x,\n                    last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Returns an empty PS path if the path has no knots.\n  */\n  (void) FormatLocaleString(message,MagickPathExtent,\"  eoclip\\n\");\n  (void) ConcatenateString(&path,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"} bind def\");\n  (void) ConcatenateString(&path,message);\n  message=DestroyString(message);\n  return(path);\n}\n\nstatic char *TraceSVGClippath(const unsigned char *blob,size_t length,\n  const size_t columns,const size_t rows)\n{\n  char\n    *path,\n    *message;\n\n  MagickBooleanType\n    in_subpath;\n\n  PointInfo\n    first[3],\n    last[3],\n    point[3];\n\n  register ssize_t\n    i;\n\n  ssize_t\n    knot_count,\n    selector,\n    x,\n    y;\n\n  path=AcquireString((char *) NULL);\n  if (path == (char *) NULL)\n    return((char *) NULL);\n  message=AcquireString((char *) NULL);\n    (void) FormatLocaleString(message,MagickPathExtent,\n    (\"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\\n\"\n    \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"\n    \" width=\\\"%.20g\\\" height=\\\"%.20g\\\">\\n\"\n    \"<g>\\n\"\n    \"<path fill-rule=\\\"evenodd\\\" style=\\\"fill:#00000000;stroke:#00000000;\"\n    \"stroke-width:0;stroke-antialiasing:false\\\" d=\\\"\\n\"),\n    (double) columns,(double) rows);\n  (void) ConcatenateString(&path,message);\n  (void) ResetMagickMemory(point,0,sizeof(point));\n  (void) ResetMagickMemory(first,0,sizeof(first));\n  (void) ResetMagickMemory(last,0,sizeof(last));\n  knot_count=0;\n  in_subpath=MagickFalse;\n  while (length != 0)\n  {\n    selector=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n    switch (selector)\n    {\n      case 0:\n      case 3:\n      {\n        if (knot_count != 0)\n          {\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Expected subpath length record.\n        */\n        knot_count=(ssize_t) ReadPropertyMSBShort(&blob,&length);\n        blob+=22;\n        length-=MagickMin(22,(ssize_t) length);\n        break;\n      }\n      case 1:\n      case 2:\n      case 4:\n      case 5:\n      {\n        if (knot_count == 0)\n          {\n            /*\n              Unexpected subpath knot.\n            */\n            blob+=24;\n            length-=MagickMin(24,(ssize_t) length);\n            break;\n          }\n        /*\n          Add sub-path knot\n        */\n        for (i=0; i < 3; i++)\n        {\n          unsigned int\n            xx,\n            yy;\n\n          yy=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          xx=(unsigned int) ReadPropertyMSBLong(&blob,&length);\n          x=(ssize_t) xx;\n          if (xx > 2147483647)\n            x=(ssize_t) xx-4294967295U-1;\n          y=(ssize_t) yy;\n          if (yy > 2147483647)\n            y=(ssize_t) yy-4294967295U-1;\n          point[i].x=(double) x*columns/4096/4096;\n          point[i].y=(double) y*rows/4096/4096;\n        }\n        if (in_subpath == MagickFalse)\n          {\n            (void) FormatLocaleString(message,MagickPathExtent,\"M %g %g\\n\",\n              point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n            {\n              first[i]=point[i];\n              last[i]=point[i];\n            }\n          }\n        else\n          {\n            /*\n              Handle special cases when Bezier curves are used to describe\n              corners and straight lines.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (point[0].x == point[1].x) && (point[0].y == point[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g\\n\",point[1].x,point[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g\\n\",last[2].x,\n                last[2].y,point[0].x,point[0].y,point[1].x,point[1].y);\n            for (i=0; i < 3; i++)\n              last[i]=point[i];\n          }\n        (void) ConcatenateString(&path,message);\n        in_subpath=MagickTrue;\n        knot_count--;\n        /*\n          Close the subpath if there are no more knots.\n        */\n        if (knot_count == 0)\n          {\n           /*\n              Same special handling as above except we compare to the\n              first point in the path and close the path.\n            */\n            if ((last[1].x == last[2].x) && (last[1].y == last[2].y) &&\n                (first[0].x == first[1].x) && (first[0].y == first[1].y))\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"L %g %g Z\\n\",first[1].x,first[1].y);\n            else\n              (void) FormatLocaleString(message,MagickPathExtent,\n                \"C %g %g %g %g %g %g Z\\n\",last[2].x,\n                last[2].y,first[0].x,first[0].y,first[1].x,first[1].y);\n            (void) ConcatenateString(&path,message);\n            in_subpath=MagickFalse;\n          }\n        break;\n      }\n      case 6:\n      case 7:\n      case 8:\n      default:\n      {\n        blob+=24;\n        length-=MagickMin(24,(ssize_t) length);\n        break;\n      }\n    }\n  }\n  /*\n    Return an empty SVG image if the path does not have knots.\n  */\n  (void) ConcatenateString(&path,\"\\\"/>\\n</g>\\n</svg>\\n\");\n  message=DestroyString(message);\n  return(path);\n}\n\nMagickExport const char *GetImageProperty(const Image *image,\n  const char *property,ExceptionInfo *exception)\n{\n  register const char\n    *p;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  p=(const char *) NULL;\n  if (image->properties != (void *) NULL)\n    {\n      if (property == (const char *) NULL)\n        {\n          ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n          p=(const char *) GetNextValueInSplayTree((SplayTreeInfo *)\n            image->properties);\n          return(p);\n        }\n        p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n          image->properties,property);\n        if (p != (const char *) NULL)\n          return(p);\n    }\n  if ((property == (const char *) NULL) ||\n      (strchr(property,':') == (char *) NULL))\n    return(p);\n  switch (*property)\n  {\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) Get8BIMProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) GetEXIFProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if ((LocaleNCompare(\"icc:\",property,4) == 0) ||\n          (LocaleNCompare(\"icm:\",property,4) == 0))\n        {\n          (void) GetICCProperty(image,property,exception);\n          break;\n        }\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) GetIPTCProperty(image,property,exception);\n          break;\n        }\n      break;\n    }\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) GetXMPProperty(image,property);\n          break;\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  if (image->properties != (void *) NULL)\n    {\n      p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n        image->properties,property);\n      return(p);\n    }\n  return((const char *) NULL);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t M a g i c k P r o p e r t y                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickProperty() gets attributes or calculated values that is associated\n%  with a fixed known property name, or single letter property. It may be\n%  called if no image is defined (IMv7), in which case only global image_info\n%  values are available:\n%\n%    \\n   newline\n%    \\r   carriage return\n%    <    less-than character.\n%    >    greater-than character.\n%    &    ampersand character.\n%    %%   a percent sign\n%    %b   file size of image read in\n%    %c   comment meta-data property\n%    %d   directory component of path\n%    %e   filename extension or suffix\n%    %f   filename (including suffix)\n%    %g   layer canvas page geometry   (equivalent to \"%Wx%H%X%Y\")\n%    %h   current image height in pixels\n%    %i   image filename (note: becomes output filename for \"info:\")\n%    %k   CALCULATED: number of unique colors\n%    %l   label meta-data property\n%    %m   image file format (file magic)\n%    %n   number of images in current image sequence\n%    %o   output filename  (used for delegates)\n%    %p   index of image in current image list\n%    %q   quantum depth (compile-time constant)\n%    %r   image class and colorspace\n%    %s   scene number (from input unless re-assigned)\n%    %t   filename without directory or extension (suffix)\n%    %u   unique temporary filename (used for delegates)\n%    %w   current width in pixels\n%    %x   x resolution (density)\n%    %y   y resolution (density)\n%    %z   image depth (as read in unless modified, image save depth)\n%    %A   image transparency channel enabled (true/false)\n%    %C   image compression type\n%    %D   image GIF dispose method\n%    %G   original image size (%wx%h; before any resizes)\n%    %H   page (canvas) height\n%    %M   Magick filename (original file exactly as given,  including read mods)\n%    %O   page (canvas) offset ( = %X%Y )\n%    %P   page (canvas) size ( = %Wx%H )\n%    %Q   image compression quality ( 0 = default )\n%    %S   ?? scenes ??\n%    %T   image time delay (in centi-seconds)\n%    %U   image resolution units\n%    %W   page (canvas) width\n%    %X   page (canvas) x offset (including sign)\n%    %Y   page (canvas) y offset (including sign)\n%    %Z   unique filename (used for delegates)\n%    %@   CALCULATED: trim bounding box (without actually trimming)\n%    %#   CALCULATED: 'signature' hash of image values\n%\n%  This routine only handles specifically known properties.  It does not\n%  handle special prefixed properties, profiles, or expressions. Nor does\n%  it return any free-form property strings.\n%\n%  The returned string is stored in a structure somewhere, and should not be\n%  directly freed.  If the string was generated (common) the string will be\n%  stored as as either as artifact or option 'get-property'.  These may be\n%  deleted (cleaned up) when no longer required, but neither artifact or\n%  option is guranteed to exist.\n%\n%  The format of the GetMagickProperty method is:\n%\n%      const char *GetMagickProperty(ImageInfo *image_info,Image *image,\n%        const char *property,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info (optional)\n%\n%    o image: the image (optional)\n%\n%    o key: the key.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const char *GetMagickPropertyLetter(ImageInfo *image_info,\n  Image *image,const char letter,ExceptionInfo *exception)\n{\n#define WarnNoImageReturn(format,arg) \\\n  if (image == (Image *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n#define WarnNoImageInfoReturn(format,arg) \\\n  if (image_info == (ImageInfo *) NULL ) { \\\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, \\\n      \"NoImageInfoForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n\n  char\n    value[MagickPathExtent];  /* formated string to store as a returned artifact */\n\n  const char\n    *string;     /* return a string already stored somewher */\n\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n    if ((image_info != (ImageInfo *) NULL) &&\n        (image_info->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n  *value='\\0';           /* formatted string */\n  string=(char *) NULL;  /* constant string reference */\n  /*\n    Get properities that are directly defined by images.\n  */\n  switch (letter)\n  {\n    case 'b':  /* image size read in - in bytes */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatMagickSize(image->extent,MagickFalse,\"B\",MagickPathExtent,\n        value);\n      if (image->extent == 0)\n        (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n          MagickPathExtent,value);\n      break;\n    }\n    case 'c':  /* image comment property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"comment\",exception);\n      if ( string == (const char *) NULL )\n        string=\"\";\n      break;\n    }\n    case 'd':  /* Directory component of filename */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,HeadPath,value);\n      if (*value == '\\0') string=\"\";\n      break;\n    }\n    case 'e': /* Filename extension (suffix) of image file */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,ExtensionPath,value);\n      if (*value == '\\0') string=\"\";\n      break;\n    }\n    case 'f': /* Filename without directory component */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,TailPath,value);\n      if (*value == '\\0') string=\"\";\n      break;\n    }\n    case 'g': /* Image geometry, canvas and offset  %Wx%H+%X+%Y */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) image->page.width,(double)\n        image->page.height,(double) image->page.x,(double) image->page.y);\n      break;\n    }\n    case 'h': /* Image height (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->rows != 0 ? image->rows : image->magick_rows));\n      break;\n    }\n    case 'i': /* Filename last used for an image (read or write) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->filename;\n      break;\n    }\n    case 'k': /* Number of unique colors  */\n    {\n      /*\n        FUTURE: ensure this does not generate the formatted comment!\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetNumberColors(image,(FILE *) NULL,exception));\n      break;\n    }\n    case 'l': /* Image label property - empty string by default */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=GetImageProperty(image,\"label\",exception);\n      if ( string == (const char *) NULL)\n        string=\"\";\n      break;\n    }\n    case 'm': /* Image format (file magick) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick;\n      break;\n    }\n    case 'n': /* Number of images in the list.  */\n    {\n      if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          GetImageListLength(image));\n      else\n        string=\"0\";    /* no images or scenes */\n      break;\n    }\n    case 'o': /* Output Filename - for delegate use only */\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->filename;\n      break;\n    case 'p': /* Image index in current image list */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        GetImageIndexInList(image));\n      break;\n    }\n    case 'q': /* Quantum depth of image in memory */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        MAGICKCORE_QUANTUM_DEPTH);\n      break;\n    }\n    case 'r': /* Image storage class, colorspace, and alpha enabled.  */\n    {\n      ColorspaceType\n        colorspace;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      colorspace=image->colorspace;\n      if (SetImageGray(image,exception) != MagickFalse)\n        colorspace=GRAYColorspace;   /* FUTURE: this is IMv6 not IMv7 */\n      (void) FormatLocaleString(value,MagickPathExtent,\"%s %s %s\",\n        CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n        image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n        (ssize_t) colorspace),image->alpha_trait != UndefinedPixelTrait ?\n        \"Alpha\" : \"\");\n      break;\n    }\n    case 's': /* Image scene number */\n    {\n#if 0  /* this seems non-sensical -- simplifing */\n      if (image_info->number_scenes != 0)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image_info->scene);\n      else if (image != (Image *) NULL)\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n          image->scene);\n      else\n          string=\"0\";\n#else\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n         image->scene);\n#endif\n      break;\n    }\n    case 't': /* Base filename without directory or extention */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      GetPathComponent(image->magick_filename,BasePath,value);\n      if (*value == '\\0') string=\"\";\n      break;\n    }\n    case 'u': /* Unique filename */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n      string=image_info->unique;\n      break;\n    }\n    case 'w': /* Image width (current) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->columns != 0 ? image->columns : image->magick_columns));\n      break;\n    }\n    case 'x': /* Image horizontal resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.x) > MagickEpsilon ? image->resolution.x : 72.0);\n      break;\n    }\n    case 'y': /* Image vertical resolution (with units) */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        fabs(image->resolution.y) > MagickEpsilon ? image->resolution.y : 72.0);\n      break;\n    }\n    case 'z': /* Image depth as read in */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        (double) image->depth);\n      break;\n    }\n    case 'A': /* Image alpha channel  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n        image->alpha_trait);\n      break;\n    }\n    case 'C': /* Image compression method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickCompressOptions,\n        (ssize_t) image->compression);\n      break;\n    }\n    case 'D': /* Image dispose method.  */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickDisposeOptions,\n        (ssize_t) image->dispose);\n      break;\n    }\n    case 'G': /* Image size as geometry = \"%wx%h\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",\n        (double)image->magick_columns,(double) image->magick_rows);\n      break;\n    }\n    case 'H': /* layer canvas height */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n        (double) image->page.height);\n      break;\n    }\n    case 'M': /* Magick filename - filename given incl. coder & read mods */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=image->magick_filename;\n      break;\n    }\n    case 'O': /* layer canvas offset with sign = \"+%X+%Y\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+ld%+ld\",(long)\n        image->page.x,(long) image->page.y);\n      break;\n    }\n    case 'P': /* layer canvas page size = \"%Wx%H\" */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20gx%.20g\",\n        (double) image->page.width,(double) image->page.height);\n      break;\n    }\n    case 'Q': /* image compression quality */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image->quality == 0 ? 92 : image->quality));\n      break;\n    }\n    case 'S': /* Number of scenes in image list.  */\n    {\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n#if 0 /* What is this number? -- it makes no sense - simplifing */\n      if (image_info->number_scenes == 0)\n         string=\"2147483647\";\n      else if ( image != (Image *) NULL )\n        (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n                image_info->scene+image_info->number_scenes);\n      else\n        string=\"0\";\n#else\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        (image_info->number_scenes == 0 ? 2147483647 :\n         image_info->number_scenes));\n#endif\n      break;\n    }\n    case 'T': /* image time delay for animations */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->delay);\n      break;\n    }\n    case 'U': /* Image resolution units. */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      string=CommandOptionToMnemonic(MagickResolutionOptions,\n        (ssize_t) image->units);\n      break;\n    }\n    case 'W': /* layer canvas width */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n        image->page.width);\n      break;\n    }\n    case 'X': /* layer canvas X offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.x);\n      break;\n    }\n    case 'Y': /* layer canvas Y offset */\n    {\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) FormatLocaleString(value,MagickPathExtent,\"%+.20g\",(double)\n        image->page.y);\n      break;\n    }\n    case '%': /* percent escaped */\n    {\n      string=\"%\";\n      break;\n    }\n    case '@': /* Trim bounding box, without actually Trimming! */\n    {\n      RectangleInfo\n        page;\n\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      page=GetImageBoundingBox(image,exception);\n      (void) FormatLocaleString(value,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) page.width,(double) page.height,\n        (double) page.x,(double)page.y);\n      break;\n    }\n    case '#':\n    {\n      /*\n        Image signature.\n      */\n      WarnNoImageReturn(\"\\\"%%%c\\\"\",letter);\n      (void) SignatureImage(image,exception);\n      string=GetImageProperty(image,\"signature\",exception);\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n    {\n      /*\n        Create a cloned copy of result.\n      */\n      if (image != (Image *) NULL)\n        {\n          (void) SetImageArtifact(image,\"get-property\",value);\n          return(GetImageArtifact(image,\"get-property\"));\n        }\n      else\n        {\n          (void) SetImageOption(image_info,\"get-property\",value);\n          return(GetImageOption(image_info,\"get-property\"));\n        }\n    }\n  return((char *) NULL);\n}\n\nMagickExport const char *GetMagickProperty(ImageInfo *image_info,\n  Image *image,const char *property,ExceptionInfo *exception)\n{\n  char\n    value[MagickPathExtent];\n\n  const char\n    *string;\n\n  assert(property[0] != '\\0');\n  assert(image != (Image *) NULL || image_info != (ImageInfo *) NULL );\n\n  if (property[1] == '\\0')  /* single letter property request */\n    return(GetMagickPropertyLetter(image_info,image,*property,exception));\n\n  if (image != (Image *) NULL && image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else if( image_info != (ImageInfo *) NULL && image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-images\");\n\n  *value='\\0';           /* formated string */\n  string=(char *) NULL;  /* constant string reference */\n  switch (*property)\n  {\n    case 'b':\n    {\n      if (LocaleCompare(\"basename\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,BasePath,value);\n          if (*value == '\\0') string=\"\";\n          break;\n        }\n      if (LocaleCompare(\"bit-depth\",property) == 0)\n        {\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageDepth(image, exception));\n          break;\n        }\n      break;\n    }\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual image channels */\n          (void) FormatLocaleString(value,MagickPathExtent,\"%s\",\n            CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace));\n          LocaleLower(value);\n          if( image->alpha_trait != UndefinedPixelTrait )\n            (void) ConcatenateMagickString(value,\"a\",MagickPathExtent);\n          break;\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          /* FUTURE: return actual colorspace - no 'gray' stuff */\n          string=CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n            image->colorspace);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n        {\n          (void) CopyMagickString(value,GetMagickCopyright(),MagickPathExtent);\n          break;\n        }\n      break;\n    }\n    case 'd':\n    {\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            image->depth);\n          break;\n        }\n      if (LocaleCompare(\"directory\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,HeadPath,value);\n          if (*value == '\\0') string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'e':\n    {\n      if (LocaleCompare(\"entropy\",property) == 0)\n        {\n          double\n            entropy;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageEntropy(image,&entropy,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),entropy);\n          break;\n        }\n      if (LocaleCompare(\"extension\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          GetPathComponent(image->magick_filename,ExtensionPath,value);\n          if (*value == '\\0') string=\"\";\n          break;\n        }\n      break;\n    }\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),image->gamma);\n          break;\n        }\n      break;\n    }\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",\n            image->magick_rows != 0 ? (double) image->magick_rows : 256.0);\n          break;\n        }\n      break;\n    }\n    case 'i':\n    {\n      if (LocaleCompare(\"input\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->filename;\n          break;\n        }\n      break;\n    }\n    case 'k':\n    {\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),kurtosis);\n          break;\n        }\n      break;\n    }\n    case 'm':\n    {\n      if (LocaleCompare(\"magick\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image->magick;\n          break;\n        }\n      if ((LocaleCompare(\"maxima\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),maximum);\n          break;\n        }\n      if (LocaleCompare(\"mean\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),mean);\n          break;\n        }\n      if ((LocaleCompare(\"minima\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          double\n            maximum,\n            minimum;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageRange(image,&minimum,&maximum,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),minimum);\n          break;\n        }\n      break;\n    }\n    case 'o':\n    {\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t)\n            IsImageOpaque(image,exception));\n          break;\n        }\n      if (LocaleCompare(\"orientation\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n            image->orientation);\n          break;\n        }\n      if (LocaleCompare(\"output\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) CopyMagickString(value,image_info->filename,MagickPathExtent);\n          break;\n        }\n     break;\n    }\n    case 'p':\n    {\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n      if (LocaleCompare(\"profile:icc\",property) == 0 ||\n          LocaleCompare(\"profile:icm\",property) == 0)\n        {\n#if !defined(LCMS_VERSION) || (LCMS_VERSION < 2000)\n#define cmsUInt32Number  DWORD\n#endif\n\n          const StringInfo\n            *profile;\n\n          cmsHPROFILE\n            icc_profile;\n\n          profile=GetImageProfile(image,property+8);\n          if (profile == (StringInfo *) NULL)\n            break;\n          icc_profile=cmsOpenProfileFromMem(GetStringInfoDatum(profile),\n            (cmsUInt32Number) GetStringInfoLength(profile));\n          if (icc_profile != (cmsHPROFILE *) NULL)\n            {\n#if defined(LCMS_VERSION) && (LCMS_VERSION < 2000)\n              string=cmsTakeProductName(icc_profile);\n#else\n              (void) cmsGetProfileInfoASCII(icc_profile,cmsInfoDescription,\n                \"en\",\"US\",value,MagickPathExtent);\n#endif\n              (void) cmsCloseProfile(icc_profile);\n            }\n      }\n#endif\n      if (LocaleCompare(\"profiles\",property) == 0)\n        {\n          const char\n            *name;\n\n          ResetImageProfileIterator(image);\n          name=GetNextImageProfile(image);\n          if (name != (char *) NULL)\n            {\n              (void) CopyMagickString(value,name,MagickPathExtent);\n              name=GetNextImageProfile(image);\n              while (name != (char *) NULL)\n              {\n                ConcatenateMagickString(value,\",\",MagickPathExtent);\n                ConcatenateMagickString(value,name,MagickPathExtent);\n                name=GetNextImageProfile(image);\n              }\n            }\n          break;\n        }\n      break;\n    }\n    case 'r':\n    {\n      if (LocaleCompare(\"resolution.x\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.x);\n          break;\n        }\n      if (LocaleCompare(\"resolution.y\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n            image->resolution.y);\n          break;\n        }\n      break;\n    }\n    case 's':\n    {\n      if (LocaleCompare(\"scene\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          if (image_info->number_scenes != 0)\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image_info->scene);\n          else {\n            WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n            (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n              image->scene);\n          }\n          break;\n        }\n      if (LocaleCompare(\"scenes\",property) == 0)\n        {\n          /* FUTURE: equivelent to %n? */\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            GetImageListLength(image));\n          break;\n        }\n      if (LocaleCompare(\"size\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatMagickSize(GetBlobSize(image),MagickFalse,\"B\",\n            MagickPathExtent,value);\n          break;\n        }\n      if (LocaleCompare(\"skewness\",property) == 0)\n        {\n          double\n            kurtosis,\n            skewness;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),skewness);\n          break;\n        }\n      if (LocaleCompare(\"standard-deviation\",property) == 0)\n        {\n          double\n            mean,\n            standard_deviation;\n\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) GetImageMean(image,&mean,&standard_deviation,exception);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.*g\",\n            GetMagickPrecision(),standard_deviation);\n          break;\n        }\n       break;\n    }\n    case 't':\n    {\n      if (LocaleCompare(\"type\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickTypeOptions,(ssize_t)\n            IdentifyImageType(image,exception));\n          break;\n        }\n       break;\n    }\n    case 'u':\n    {\n      if (LocaleCompare(\"unique\",property) == 0)\n        {\n          WarnNoImageInfoReturn(\"\\\"%%[%s]\\\"\",property);\n          string=image_info->unique;\n          break;\n        }\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          string=CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n            image->units);\n          break;\n        }\n      if (LocaleCompare(\"copyright\",property) == 0)\n      break;\n    }\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          string=GetMagickVersion((size_t *) NULL);\n          break;\n        }\n      break;\n    }\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          WarnNoImageReturn(\"\\\"%%[%s]\\\"\",property);\n          (void) FormatLocaleString(value,MagickPathExtent,\"%.20g\",(double)\n            (image->magick_columns != 0 ? image->magick_columns : 256));\n          break;\n        }\n      break;\n    }\n  }\n  if (string != (char *) NULL)\n    return(string);\n  if (*value != '\\0')\n  {\n    /* create a cloned copy of result, that will get cleaned up, eventually */\n    if (image != (Image *) NULL)\n      {\n        (void) SetImageArtifact(image,\"get-property\",value);\n        return(GetImageArtifact(image,\"get-property\"));\n      }\n    else\n      {\n        (void) SetImageOption(image_info,\"get-property\",value);\n        return(GetImageOption(image_info,\"get-property\"));\n      }\n  }\n  return((char *) NULL);\n}\n#undef WarnNoImageReturn\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o p e r t y                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProperty() gets the next free-form string property name.\n%\n%  The format of the GetNextImageProperty method is:\n%\n%      char *GetNextImageProperty(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const char *GetNextImageProperty(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return((const char *) NULL);\n  return((const char *) GetNextKeyInSplayTree(\n    (SplayTreeInfo *) image->properties));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n t e r p r e t I m a g e P r o p e r t i e s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretImageProperties() replaces any embedded formatting characters with\n%  the appropriate image property and returns the interpreted text.\n%\n%  This searches for and replaces\n%     \\n \\r \\%          replaced by newline, return, and percent resp.\n%     &lt; &gt; &amp;   replaced by '<', '>', '&' resp.\n%     %%                replaced by percent\n%\n%     %x %[x]       where 'x' is a single letter properity, case sensitive).\n%     %[type:name]  where 'type' a is special and known prefix.\n%     %[name]       where 'name' is a specifically known attribute, calculated\n%                   value, or a per-image property string name, or a per-image\n%                   'artifact' (as generated from a global option).\n%                   It may contain ':' as long as the prefix is not special.\n%\n%  Single letter % substitutions will only happen if the character before the\n%  percent is NOT a number. But braced substitutions will always be performed.\n%  This prevents the typical usage of percent in a interpreted geometry\n%  argument from being substituted when the percent is a geometry flag.\n%\n%  If 'glob-expresions' ('*' or '?' characters) is used for 'name' it may be\n%  used as a search pattern to print multiple lines of \"name=value\\n\" pairs of\n%  the associacted set of properties.\n%\n%  The returned string must be freed using DestoryString() by the caller.\n%\n%  The format of the InterpretImageProperties method is:\n%\n%      char *InterpretImageProperties(ImageInfo *image_info,\n%        Image *image,const char *embed_text,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info. (required)\n%\n%    o image: the image. (optional)\n%\n%    o embed_text: the address of a character string containing the embedded\n%      formatting characters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport char *InterpretImageProperties(ImageInfo *image_info,\n  Image *image,const char *embed_text,ExceptionInfo *exception)\n{\n#define ExtendInterpretText(string_length) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=(string_length); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n   } \\\n} \\\nRestoreMSCWarning\n\n#define AppendKeyValue2Text(key,value)\\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen(key)+strlen(value)+2; \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n     } \\\n   q+=FormatLocaleString(q,extent,\"%s=%s\\n\",(key),(value)); \\\n} \\\nRestoreMSCWarning\n\n#define AppendString2Text(string) \\\nDisableMSCWarning(4127) \\\n{ \\\n  size_t length=strlen((string)); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MaxTextExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        return((char *) NULL); \\\n      q=interpret_text+strlen(interpret_text); \\\n    } \\\n  (void) CopyMagickString(q,(string),extent); \\\n  q+=length; \\\n} \\\nRestoreMSCWarning\n\n  char\n    *interpret_text;\n\n  register char\n    *q;  /* current position in interpret_text */\n\n  register const char\n    *p;  /* position in embed_text string being expanded */\n\n  size_t\n    extent;  /* allocated length of interpret_text */\n\n  MagickBooleanType\n    number;\n\n  assert(image == NULL || image->signature == MagickCoreSignature);\n  assert(image_info == NULL || image_info->signature == MagickCoreSignature);\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n   if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no-image\");\n  if (embed_text == (const char *) NULL)\n    return(ConstantString(\"\"));\n  p=embed_text;\n  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\\0'))\n    p++;\n  if (*p == '\\0')\n    return(ConstantString(\"\"));\n  if ((*p == '@') && (IsPathAccessible(p+1) != MagickFalse))\n    {\n      /*\n        Handle a '@' replace string from file.\n      */\n      if (IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,p) == MagickFalse)\n        {\n          errno=EPERM;\n          (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n            \"NotAuthorized\",\"`%s'\",p);\n          return(ConstantString(\"\"));\n        }\n      interpret_text=FileToString(p+1,~0UL,exception);\n      if (interpret_text != (char *) NULL)\n        return(interpret_text);\n    }\n  /*\n    Translate any embedded format characters.\n  */\n  interpret_text=AcquireString(embed_text); /* new string with extra space */\n  extent=MagickPathExtent;                     /* allocated space in string */\n  number=MagickFalse;                       /* is last char a number? */\n  for (q=interpret_text; *p!='\\0';\n    number=isdigit(*p) ? MagickTrue : MagickFalse,p++)\n  {\n    /*\n      Look for the various escapes, (and handle other specials)\n    */\n    *q='\\0';\n    ExtendInterpretText(MagickPathExtent);\n    switch (*p)\n    {\n      case '\\\\':\n      {\n        switch (*(p+1))\n        {\n          case '\\0':\n            continue;\n          case 'r':  /* convert to RETURN */\n          {\n            *q++='\\r';\n            p++;\n            continue;\n          }\n          case 'n':  /* convert to NEWLINE */\n          {\n            *q++='\\n';\n            p++;\n            continue;\n          }\n          case '\\n':  /* EOL removal UNIX,MacOSX */\n          {\n            p++;\n            continue;\n          }\n          case '\\r':  /* EOL removal DOS,Windows */\n          {\n            p++;\n            if (*p == '\\n') /* return-newline EOL */\n              p++;\n            continue;\n          }\n          default:\n          {\n            p++;\n            *q++=(*p);\n          }\n        }\n        continue;\n      }\n      case '&':\n      {\n        if (LocaleNCompare(\"&lt;\",p,4) == 0)\n          {\n            *q++='<';\n            p+=3;\n          }\n        else\n          if (LocaleNCompare(\"&gt;\",p,4) == 0)\n            {\n              *q++='>';\n              p+=3;\n            }\n          else\n            if (LocaleNCompare(\"&amp;\",p,5) == 0)\n              {\n                *q++='&';\n                p+=4;\n              }\n            else\n              *q++=(*p);\n        continue;\n      }\n      case '%':\n        break;  /* continue to next set of handlers */\n      default:\n      {\n        *q++=(*p);  /* any thing else is 'as normal' */\n        continue;\n      }\n    }\n    p++; /* advance beyond the percent */\n    /*\n      Doubled Percent - or percent at end of string.\n    */\n    if ((*p == '\\0') || (*p == '\\'') || (*p == '\"'))\n      p--;\n    if (*p == '%')\n      {\n        *q++='%';\n        continue;\n      }\n    /*\n      Single letter escapes %c.\n    */\n    if (*p != '[')\n      {\n        const char\n          *string;\n\n        if (number != MagickFalse)\n          {\n            /*\n              But only if not preceeded by a number!\n            */\n            *q++='%'; /* do NOT substitute the percent */\n            p--;      /* back up one */\n            continue;\n          }\n        string=GetMagickPropertyLetter(image_info,image,*p, exception);\n        if (string != (char *) NULL)\n          {\n            AppendString2Text(string);\n            if (image != (Image *) NULL)\n              (void) DeleteImageArtifact(image,\"get-property\");\n            if (image_info != (ImageInfo *) NULL)\n              (void) DeleteImageOption(image_info,\"get-property\");\n            continue;\n          }\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n          \"UnknownImageProperty\",\"\\\"%%%c\\\"\",*p);\n        continue;\n      }\n    {\n      char\n        pattern[2*MagickPathExtent];\n\n      const char\n        *key,\n        *string;\n\n      register ssize_t\n        len;\n\n      ssize_t\n        depth;\n\n      /*\n        Braced Percent Escape %[...].\n      */\n      p++;  /* advance p to just inside the opening brace */\n      depth=1;\n      if (*p == ']')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"UnknownImageProperty\",\"\\\"%%[]\\\"\");\n          break;\n        }\n      for (len=0; len<(MagickPathExtent-1L) && (*p != '\\0');)\n      {\n        if ((*p == '\\\\') && (*(p+1) != '\\0'))\n          {\n            /*\n              Skip escaped braces within braced pattern.\n            */\n            pattern[len++]=(*p++);\n            pattern[len++]=(*p++);\n            continue;\n          }\n        if (*p == '[')\n          depth++;\n        if (*p == ']')\n          depth--;\n        if (depth <= 0)\n          break;\n        pattern[len++]=(*p++);\n      }\n      pattern[len]='\\0';\n      if (depth != 0)\n        {\n          /*\n            Check for unmatched final ']' for \"%[...]\".\n          */\n          if (len >= 64)\n            {\n              pattern[61] = '.';  /* truncate string for error message */\n              pattern[62] = '.';\n              pattern[63] = '.';\n              pattern[64] = '\\0';\n            }\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            OptionError,\"UnbalancedBraces\",\"\\\"%%[%s\\\"\",pattern);\n          interpret_text=DestroyString(interpret_text);\n          return((char *) NULL);\n        }\n      /*\n        Special Lookup Prefixes %[prefix:...].\n      */\n      if (LocaleNCompare(\"fx:\",pattern,3) == 0)\n        {\n          FxInfo\n            *fx_info;\n\n          double\n            value;\n\n          MagickBooleanType\n            status;\n\n          /*\n            FX - value calculator.\n          */\n          if (image == (Image *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          fx_info=AcquireFxInfo(image,pattern+3,exception);\n          status=FxEvaluateChannelExpression(fx_info,IntensityPixelChannel,0,0,\n            &value,exception);\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%.*g\",\n                GetMagickPrecision(),(double) value);\n              AppendString2Text(result);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"pixel:\",pattern,6) == 0)\n        {\n          FxInfo\n            *fx_info;\n\n          double\n            value;\n\n          MagickStatusType\n            status;\n\n          PixelInfo\n            pixel;\n\n          /*\n            Pixel - color value calculator.\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          GetPixelInfo(image,&pixel);\n          fx_info=AcquireFxInfo(image,pattern+6,exception);\n          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,0,0,\n            &value,exception);\n          pixel.red=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,0,0,\n            &value,exception);\n          pixel.green=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,0,0,\n            &value,exception);\n          pixel.blue=(double) QuantumRange*value;\n          if (image->colorspace == CMYKColorspace)\n            {\n              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,0,0,\n                &value,exception);\n              pixel.black=(double) QuantumRange*value;\n            }\n          status&=FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,0,0,\n            &value,exception);\n          pixel.alpha=(double) QuantumRange*value;\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                name[MagickPathExtent];\n\n              (void) QueryColorname(image,&pixel,SVGCompliance,name,\n                exception);\n              AppendString2Text(name);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"option:\",pattern,7) == 0)\n        {\n          /*\n            Option - direct global option lookup (with globbing).\n          */\n          if (image_info == (ImageInfo *) NULL )\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+7) != MagickFalse)\n            {\n              ResetImageOptionIterator(image_info);\n              while ((key=GetNextImageOption(image_info)) != (const char *) NULL)\n                if (GlobExpression(key,pattern+7,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageOption(image_info,key);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? key found but no string value! */\n                  }\n              continue;\n            }\n          string=GetImageOption(image_info,pattern+7);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"artifact:\",pattern,9) == 0)\n        {\n          /*\n            Artifact - direct image artifact lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImageArtifactIterator(image);\n              while ((key=GetNextImageArtifact(image)) != (const char *) NULL)\n              if (GlobExpression(key,pattern+9,MagickTrue) != MagickFalse)\n                {\n                  string=GetImageArtifact(image,key);\n                  if (string != (const char *) NULL)\n                    AppendKeyValue2Text(key,string);\n                  /* else - assertion failure? key found but no string value! */\n                }\n              continue;\n            }\n          string=GetImageArtifact(image,pattern+9);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"property:\",pattern,9) == 0)\n        {\n          /*\n            Property - direct image property lookup (with glob).\n          */\n          if (image == (Image *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"NoImageForProperty\",\"\\\"%%[%s]\\\"\",pattern);\n              continue; /* else no image to retrieve artifact */\n            }\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImagePropertyIterator(image);\n              while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n                if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageProperty(image,key,exception);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? */\n                  }\n              continue;\n            }\n          string=GetImageProperty(image,pattern+9,exception);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (image != (Image *) NULL)\n        {\n          /*\n            Properties without special prefix.  This handles attributes,\n            properties, and profiles such as %[exif:...].  Note the profile\n            properties may also include a glob expansion pattern.\n          */\n          string=GetImageProperty(image,pattern,exception);\n          if (string != (const char *) NULL)\n            {\n              AppendString2Text(string);\n              if (image != (Image *) NULL)\n                (void)DeleteImageArtifact(image,\"get-property\");\n              if (image_info != (ImageInfo *) NULL)\n                (void)DeleteImageOption(image_info,\"get-property\");\n              continue;\n            }\n        }\n      if (IsGlob(pattern) != MagickFalse)\n        {\n          /*\n            Handle property 'glob' patterns such as:\n            %[*] %[user:array_??] %[filename:e*]>\n          */\n          if (image == (Image *) NULL)\n            continue; /* else no image to retrieve proprty - no list */\n          ResetImagePropertyIterator(image);\n          while ((key=GetNextImageProperty(image)) != (const char *) NULL)\n            if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n              {\n                string=GetImageProperty(image,key,exception);\n                if (string != (const char *) NULL)\n                  AppendKeyValue2Text(key,string);\n                /* else - assertion failure? */\n              }\n          continue;\n        }\n      /*\n        Look for a known property or image attribute such as\n        %[basename] %[denisty] %[delay].  Also handles a braced single\n        letter: %[b] %[G] %[g].\n      */\n      string=GetMagickProperty(image_info,image,pattern,exception);\n      if (string != (const char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        Look for a per-image artifact. This includes option lookup\n        (FUTURE: interpreted according to image).\n      */\n      if (image != (Image *) NULL)\n        {\n          string=GetImageArtifact(image,pattern);\n          if (string != (char *) NULL)\n            {\n              AppendString2Text(string);\n              continue;\n            }\n        }\n      else\n        if (image_info != (ImageInfo *) NULL)\n          {\n            /*\n              No image, so direct 'option' lookup (no delayed percent escapes).\n            */\n            string=GetImageOption(image_info,pattern);\n            if (string != (char *) NULL)\n              {\n                AppendString2Text(string);\n                continue;\n              }\n          }\nPropertyLookupFailure:\n      /*\n        Failed to find any match anywhere!\n      */\n      if (len >= 64)\n        {\n          pattern[61] = '.';  /* truncate string for error message */\n          pattern[62] = '.';\n          pattern[63] = '.';\n          pattern[64] = '\\0';\n        }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"UnknownImageProperty\",\"\\\"%%[%s]\\\"\",pattern);\n    }\n  }\n  *q='\\0';\n  return(interpret_text);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o p e r t y                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProperty() removes a property from the image and returns its\n%  value.\n%\n%  In this case the ConstantString() value returned should be freed by the\n%  caller when finished.\n%\n%  The format of the RemoveImageProperty method is:\n%\n%      char *RemoveImageProperty(Image *image,const char *property)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n*/\nMagickExport char *RemoveImageProperty(Image *image,\n  const char *property)\n{\n  char\n    *value;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return((char *) NULL);\n  value=(char *) RemoveNodeFromSplayTree((SplayTreeInfo *) image->properties,\n    property);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t I m a g e P r o p e r t y I t e r a t o r                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImagePropertyIterator() resets the image properties iterator.  Use it\n%  in conjunction with GetNextImageProperty() to iterate over all the values\n%  associated with an image property.\n%\n%  The format of the ResetImagePropertyIterator method is:\n%\n%      ResetImagePropertyIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImagePropertyIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image->filename);\n  if (image->properties == (void *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o p e r t y                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProperty() saves the given string value either to specific known\n%  attribute or to a freeform property string.\n%\n%  Attempting to set a property that is normally calculated will produce\n%  an exception.\n%\n%  The format of the SetImageProperty method is:\n%\n%      MagickBooleanType SetImageProperty(Image *image,const char *property,\n%        const char *value,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o property: the image property.\n%\n%    o values: the image property values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n    {\n      /*\n        Do not 'set' single letter properties - read only shorthand.\n       */\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"SetReadOnlyProperty\",\"`%s'\",property);\n      return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ( (LocaleCompare(\"magick\",property) == 0) ||\n           (LocaleCompare(\"max\",property) == 0) ||\n           (LocaleCompare(\"mean\",property) == 0) ||\n           (LocaleCompare(\"min\",property) == 0) ||\n           (LocaleCompare(\"min\",property) == 0) )\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ( (LocaleCompare(\"size\",property) == 0) ||\n           (LocaleCompare(\"skewness\",property) == 0) ||\n           (LocaleCompare(\"scenes\",property) == 0) ||\n           (LocaleCompare(\"standard-deviation\",property) == 0) )\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n               OptionError,\"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n"], "filenames": ["MagickCore/profile.c", "MagickCore/property.c"], "buggy_code_start_loc": [1366, 530], "buggy_code_end_loc": [2037, 1411], "fixing_code_start_loc": [1366, 530], "fixing_code_end_loc": [2049, 1426], "type": "CWE-125", "message": "MagickCore/property.c in ImageMagick before 7.0.2-1 allows remote attackers to obtain sensitive memory information via vectors involving the q variable, which triggers an out-of-bounds read.", "other": {"cve": {"id": "CVE-2016-5842", "sourceIdentifier": "cve@mitre.org", "published": "2016-12-13T15:59:07.997", "lastModified": "2021-04-28T16:33:39.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MagickCore/property.c in ImageMagick before 7.0.2-1 allows remote attackers to obtain sensitive memory information via vectors involving the q variable, which triggers an out-of-bounds read."}, {"lang": "es", "value": "MagickCore/property.c en ImageMagick en versiones anteriores a 7.0.2-1 permite a atacantes remotos obtener informaci\u00f3n de memoria sensible a trav\u00e9s de vectores que implican a la variable q, lo que desencadena una lectura fuera de l\u00edmites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.4-10", "matchCriteriaId": "A8A98172-FAA7-4CED-8DA1-B8E1A92F9EEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.2-1", "matchCriteriaId": "3CD031CA-53C3-455E-AF92-C0846DDE254A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:10:*:*:*:*:*:*:*", "matchCriteriaId": "964B57CD-CB8A-4520-B358-1C93EC5EF2DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:11.3:*:*:*:*:*:*:*", "matchCriteriaId": "79A602C5-61FE-47BA-9786-F045B6C6DBA8"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/06/23/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/06/25/3", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjul2016-3090568.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91394", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commits/7.0.2-1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201611-21", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b"}}