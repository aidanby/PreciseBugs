{"buggy_code": ["/*\n *   fs/cifs/dir.c\n *\n *   vfs operations that deal with dentries\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2009\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n\nstatic void\nrenew_parental_timestamps(struct dentry *direntry)\n{\n\t/* BB check if there is a way to get the kernel to do this or if we\n\t   really need this */\n\tdo {\n\t\tdirentry->d_time = jiffies;\n\t\tdirentry = direntry->d_parent;\n\t} while (!IS_ROOT(direntry));\n}\n\n/* Note: caller must free return buffer */\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcERROR(1, \"corrupt dentry\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcFYI(0, \"name: %s\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcERROR(1, \"corrupt dentry\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcFYI(1, \"did not end path lookup where expected. namelen=%d \"\n\t\t\t\"dfsplen=%d\", namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}\n\n/* Inode operations in similar order to how they appear in Linux file fs.h */\n\nint\ncifs_create(struct inode *inode, struct dentry *direntry, int mode,\n\t\tstruct nameidata *nd)\n{\n\tint rc = -ENOENT;\n\tint xid;\n\tint create_options = CREATE_NOT_DIR;\n\t__u32 oplock = 0;\n\tint oflags;\n\t/*\n\t * BB below access is probably too much for mknod to request\n\t *    but we have to do query and setpathinfo so requesting\n\t *    less could fail (unless we want to request getatr and setatr\n\t *    permissions (only).  At least for POSIX we do not have to\n\t *    request so much.\n\t */\n\tint desiredAccess = GENERIC_READ | GENERIC_WRITE;\n\t__u16 fileHandle;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tchar *full_path = NULL;\n\tFILE_ALL_INFO *buf = NULL;\n\tstruct inode *newinode = NULL;\n\tint disposition = FILE_OVERWRITE_IF;\n\n\txid = GetXid();\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn PTR_ERR(tlink);\n\t}\n\ttcon = tlink_tcon(tlink);\n\n\tif (enable_oplocks)\n\t\toplock = REQ_OPLOCK;\n\n\tif (nd)\n\t\toflags = nd->intent.open.file->f_flags;\n\telse\n\t\toflags = O_RDONLY | O_CREAT;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_create_out;\n\t}\n\n\tif (tcon->unix_ext && (tcon->ses->capabilities & CAP_UNIX) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode,\n\t\t\tinode->i_sb, mode, oflags, &oplock, &fileHandle, xid);\n\t\t/* EIO could indicate that (posix open) operation is not\n\t\t   supported, despite what server claimed in capability\n\t\t   negotiation.  EREMOTE indicates DFS junction, which is not\n\t\t   handled in posix open */\n\n\t\tif (rc == 0) {\n\t\t\tif (newinode == NULL) /* query inode info */\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\telse /* success, no need to query */\n\t\t\t\tgoto cifs_create_set_dentry;\n\t\t} else if ((rc != -EIO) && (rc != -EREMOTE) &&\n\t\t\t (rc != -EOPNOTSUPP) && (rc != -EINVAL))\n\t\t\tgoto cifs_create_out;\n\t\t/* else fallthrough to retry, using older open call, this is\n\t\t   case where server does not support this SMB level, and\n\t\t   falsely claims capability (also get here for DFS case\n\t\t   which should be rare for path not covered on files) */\n\t}\n\n\tif (nd) {\n\t\t/* if the file is going to stay open, then we\n\t\t   need to set the desired access properly */\n\t\tdesiredAccess = 0;\n\t\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\t\tdesiredAccess |= GENERIC_READ; /* is this too little? */\n\t\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\t\tdesiredAccess |= GENERIC_WRITE;\n\n\t\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\t\tdisposition = FILE_CREATE;\n\t\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\t\tdisposition = FILE_OVERWRITE_IF;\n\t\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\t\tdisposition = FILE_OPEN_IF;\n\t\telse\n\t\t\tcFYI(1, \"Create flag not set in create function\");\n\t}\n\n\t/* BB add processing to set equivalent of mode - e.g. via CreateX with\n\t   ACLs */\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_create_out;\n\t}\n\n\t/*\n\t * if we're not using unix extensions, see if we need to set\n\t * ATTR_READONLY on the create call\n\t */\n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (tcon->ses->capabilities & CAP_NT_SMBS)\n\t\trc = CIFSSMBOpen(xid, tcon, full_path, disposition,\n\t\t\t desiredAccess, create_options,\n\t\t\t &fileHandle, &oplock, buf, cifs_sb->local_nls,\n\t\t\t cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\telse\n\t\trc = -EIO; /* no NT SMB support fall into legacy open below */\n\n\tif (rc == -EIO) {\n\t\t/* old server, retry the open legacy style */\n\t\trc = SMBLegacyOpen(xid, tcon, full_path, disposition,\n\t\t\tdesiredAccess, create_options,\n\t\t\t&fileHandle, &oplock, buf, cifs_sb->local_nls,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t}\n\tif (rc) {\n\t\tcFYI(1, \"cifs_create returned 0x%x\", rc);\n\t\tgoto cifs_create_out;\n\t}\n\n\t/* If Open reported that we actually created a file\n\t   then we now have to set the mode if possible */\n\tif ((tcon->unix_ext) && (oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = (__u64) current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = (__u64) inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = (__u64) current_fsgid();\n\t\t} else {\n\t\t\targs.uid = NO_CHANGE_64;\n\t\t\targs.gid = NO_CHANGE_64;\n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fileHandle,\n\t\t\t\t\tcurrent->tgid);\n\t} else {\n\t\t/* BB implement mode setting via Windows security\n\t\t   descriptors e.g. */\n\t\t/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/\n\n\t\t/* Could set r/o dos attribute if mode & 0222 == 0 */\n\t}\n\ncifs_create_get_file_info:\n\t/* server might mask mode so we have to query for it */\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t      inode->i_sb, xid);\n\telse {\n\t\trc = cifs_get_inode_info(&newinode, full_path, buf,\n\t\t\t\t\t inode->i_sb, xid, &fileHandle);\n\t\tif (newinode) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\tnewinode->i_mode = mode;\n\t\t\tif ((oplock & CIFS_CREATE_ACTION) &&\n\t\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)) {\n\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\telse\n\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t}\n\t\t}\n\t}\n\ncifs_create_set_dentry:\n\tif (rc == 0)\n\t\td_instantiate(direntry, newinode);\n\telse\n\t\tcFYI(1, \"Create worked, get_inode_info failed rc = %d\", rc);\n\n\tif (newinode && nd) {\n\t\tstruct cifsFileInfo *pfile_info;\n\t\tstruct file *filp;\n\n\t\tfilp = lookup_instantiate_filp(nd, direntry, generic_file_open);\n\t\tif (IS_ERR(filp)) {\n\t\t\trc = PTR_ERR(filp);\n\t\t\tCIFSSMBClose(xid, tcon, fileHandle);\n\t\t\tgoto cifs_create_out;\n\t\t}\n\n\t\tpfile_info = cifs_new_fileinfo(fileHandle, filp, tlink, oplock);\n\t\tif (pfile_info == NULL) {\n\t\t\tfput(filp);\n\t\t\tCIFSSMBClose(xid, tcon, fileHandle);\n\t\t\trc = -ENOMEM;\n\t\t}\n\t} else {\n\t\tCIFSSMBClose(xid, tcon, fileHandle);\n\t}\n\ncifs_create_out:\n\tkfree(buf);\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn rc;\n}\n\nint cifs_mknod(struct inode *inode, struct dentry *direntry, int mode,\n\t\tdev_t device_number)\n{\n\tint rc = -EPERM;\n\tint xid;\n\tint create_options = CREATE_NOT_DIR | CREATE_OPTION_SPECIAL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifs_io_parms io_parms;\n\tchar *full_path = NULL;\n\tstruct inode *newinode = NULL;\n\tint oplock = 0;\n\tu16 fileHandle;\n\tFILE_ALL_INFO *buf = NULL;\n\tunsigned int bytes_written;\n\tstruct win_dev *pdev;\n\n\tif (!old_valid_dev(device_number))\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\tpTcon = tlink_tcon(tlink);\n\n\txid = GetXid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mknod_out;\n\t}\n\n\tif (pTcon->unix_ext) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode & ~current_umask(),\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= device_number,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = (__u64) current_fsuid();\n\t\t\targs.gid = (__u64) current_fsgid();\n\t\t} else {\n\t\t\targs.uid = NO_CHANGE_64;\n\t\t\targs.gid = NO_CHANGE_64;\n\t\t}\n\t\trc = CIFSSMBUnixSetPathInfo(xid, pTcon, full_path, &args,\n\t\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t\t    cifs_sb->mnt_cifs_flags &\n\t\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (rc)\n\t\t\tgoto mknod_out;\n\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t\tinode->i_sb, xid);\n\n\t\tif (rc == 0)\n\t\t\td_instantiate(direntry, newinode);\n\t\tgoto mknod_out;\n\t}\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL))\n\t\tgoto mknod_out;\n\n\n\tcFYI(1, \"sfu compat create special file\");\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tkfree(full_path);\n\t\trc = -ENOMEM;\n\t\tFreeXid(xid);\n\t\treturn rc;\n\t}\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\trc = CIFSSMBOpen(xid, pTcon, full_path, FILE_CREATE,\n\t\t\t GENERIC_WRITE, create_options,\n\t\t\t &fileHandle, &oplock, buf, cifs_sb->local_nls,\n\t\t\t cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\tif (rc)\n\t\tgoto mknod_out;\n\n\t/* BB Do not bother to decode buf since no local inode yet to put\n\t * timestamps in, but we can reuse it safely */\n\n\tpdev = (struct win_dev *)buf;\n\tio_parms.netfid = fileHandle;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = pTcon;\n\tio_parms.offset = 0;\n\tio_parms.length = sizeof(struct win_dev);\n\tif (S_ISCHR(mode)) {\n\t\tmemcpy(pdev->type, \"IntxCHR\", 8);\n\t\tpdev->major =\n\t\t      cpu_to_le64(MAJOR(device_number));\n\t\tpdev->minor =\n\t\t      cpu_to_le64(MINOR(device_number));\n\t\trc = CIFSSMBWrite(xid, &io_parms,\n\t\t\t&bytes_written, (char *)pdev,\n\t\t\tNULL, 0);\n\t} else if (S_ISBLK(mode)) {\n\t\tmemcpy(pdev->type, \"IntxBLK\", 8);\n\t\tpdev->major =\n\t\t      cpu_to_le64(MAJOR(device_number));\n\t\tpdev->minor =\n\t\t      cpu_to_le64(MINOR(device_number));\n\t\trc = CIFSSMBWrite(xid, &io_parms,\n\t\t\t&bytes_written, (char *)pdev,\n\t\t\tNULL, 0);\n\t} /* else if (S_ISFIFO) */\n\tCIFSSMBClose(xid, pTcon, fileHandle);\n\td_drop(direntry);\n\n\t/* FIXME: add code here to set EAs */\n\nmknod_out:\n\tkfree(full_path);\n\tkfree(buf);\n\tFreeXid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstruct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\t\tposix_open = true;\n\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}\n\nstatic int\ncifs_d_revalidate(struct dentry *direntry, struct nameidata *nd)\n{\n\tif (nd && (nd->flags & LOOKUP_RCU))\n\t\treturn -ECHILD;\n\n\tif (direntry->d_inode) {\n\t\tif (cifs_revalidate_dentry(direntry))\n\t\t\treturn 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * Forcibly invalidate automounting directory inodes\n\t\t\t * (remote DFS directories) so to have them\n\t\t\t * instantiated again for automount\n\t\t\t */\n\t\t\tif (IS_AUTOMOUNT(direntry->d_inode))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!nd)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (nd->flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\tif (time_after(jiffies, direntry->d_time + HZ) || !lookupCacheEnabled)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* static int cifs_d_delete(struct dentry *direntry)\n{\n\tint rc = 0;\n\n\tcFYI(1, \"In cifs d_delete, name = %s\", direntry->d_name.name);\n\n\treturn rc;\n}     */\n\nconst struct dentry_operations cifs_dentry_ops = {\n\t.d_revalidate = cifs_d_revalidate,\n\t.d_automount = cifs_dfs_d_automount,\n/* d_delete:       cifs_d_delete,      */ /* not needed except for debugging */\n};\n\nstatic int cifs_ci_hash(const struct dentry *dentry, const struct inode *inode,\n\t\tstruct qstr *q)\n{\n\tstruct nls_table *codepage = CIFS_SB(dentry->d_sb)->local_nls;\n\tunsigned long hash;\n\tint i;\n\n\thash = init_name_hash();\n\tfor (i = 0; i < q->len; i++)\n\t\thash = partial_name_hash(nls_tolower(codepage, q->name[i]),\n\t\t\t\t\t hash);\n\tq->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\nstatic int cifs_ci_compare(const struct dentry *parent,\n\t\tconst struct inode *pinode,\n\t\tconst struct dentry *dentry, const struct inode *inode,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *codepage = CIFS_SB(pinode->i_sb)->local_nls;\n\n\tif ((name->len == len) &&\n\t    (nls_strnicmp(codepage, name->name, str, len) == 0))\n\t\treturn 0;\n\treturn 1;\n}\n\nconst struct dentry_operations cifs_ci_dentry_ops = {\n\t.d_revalidate = cifs_d_revalidate,\n\t.d_hash = cifs_ci_hash,\n\t.d_compare = cifs_ci_compare,\n\t.d_automount = cifs_dfs_d_automount,\n};\n"], "fixing_code": ["/*\n *   fs/cifs/dir.c\n *\n *   vfs operations that deal with dentries\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2009\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n#include <linux/fs.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include \"cifsfs.h\"\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n\nstatic void\nrenew_parental_timestamps(struct dentry *direntry)\n{\n\t/* BB check if there is a way to get the kernel to do this or if we\n\t   really need this */\n\tdo {\n\t\tdirentry->d_time = jiffies;\n\t\tdirentry = direntry->d_parent;\n\t} while (!IS_ROOT(direntry));\n}\n\n/* Note: caller must free return buffer */\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcERROR(1, \"corrupt dentry\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcFYI(0, \"name: %s\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcERROR(1, \"corrupt dentry\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcFYI(1, \"did not end path lookup where expected. namelen=%d \"\n\t\t\t\"dfsplen=%d\", namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}\n\n/* Inode operations in similar order to how they appear in Linux file fs.h */\n\nint\ncifs_create(struct inode *inode, struct dentry *direntry, int mode,\n\t\tstruct nameidata *nd)\n{\n\tint rc = -ENOENT;\n\tint xid;\n\tint create_options = CREATE_NOT_DIR;\n\t__u32 oplock = 0;\n\tint oflags;\n\t/*\n\t * BB below access is probably too much for mknod to request\n\t *    but we have to do query and setpathinfo so requesting\n\t *    less could fail (unless we want to request getatr and setatr\n\t *    permissions (only).  At least for POSIX we do not have to\n\t *    request so much.\n\t */\n\tint desiredAccess = GENERIC_READ | GENERIC_WRITE;\n\t__u16 fileHandle;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tchar *full_path = NULL;\n\tFILE_ALL_INFO *buf = NULL;\n\tstruct inode *newinode = NULL;\n\tint disposition = FILE_OVERWRITE_IF;\n\n\txid = GetXid();\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn PTR_ERR(tlink);\n\t}\n\ttcon = tlink_tcon(tlink);\n\n\tif (enable_oplocks)\n\t\toplock = REQ_OPLOCK;\n\n\tif (nd)\n\t\toflags = nd->intent.open.file->f_flags;\n\telse\n\t\toflags = O_RDONLY | O_CREAT;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_create_out;\n\t}\n\n\tif (tcon->unix_ext && (tcon->ses->capabilities & CAP_UNIX) &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode,\n\t\t\tinode->i_sb, mode, oflags, &oplock, &fileHandle, xid);\n\t\t/* EIO could indicate that (posix open) operation is not\n\t\t   supported, despite what server claimed in capability\n\t\t   negotiation.  EREMOTE indicates DFS junction, which is not\n\t\t   handled in posix open */\n\n\t\tif (rc == 0) {\n\t\t\tif (newinode == NULL) /* query inode info */\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\telse /* success, no need to query */\n\t\t\t\tgoto cifs_create_set_dentry;\n\t\t} else if ((rc != -EIO) && (rc != -EREMOTE) &&\n\t\t\t (rc != -EOPNOTSUPP) && (rc != -EINVAL))\n\t\t\tgoto cifs_create_out;\n\t\t/* else fallthrough to retry, using older open call, this is\n\t\t   case where server does not support this SMB level, and\n\t\t   falsely claims capability (also get here for DFS case\n\t\t   which should be rare for path not covered on files) */\n\t}\n\n\tif (nd) {\n\t\t/* if the file is going to stay open, then we\n\t\t   need to set the desired access properly */\n\t\tdesiredAccess = 0;\n\t\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\t\tdesiredAccess |= GENERIC_READ; /* is this too little? */\n\t\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\t\tdesiredAccess |= GENERIC_WRITE;\n\n\t\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\t\tdisposition = FILE_CREATE;\n\t\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\t\tdisposition = FILE_OVERWRITE_IF;\n\t\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\t\tdisposition = FILE_OPEN_IF;\n\t\telse\n\t\t\tcFYI(1, \"Create flag not set in create function\");\n\t}\n\n\t/* BB add processing to set equivalent of mode - e.g. via CreateX with\n\t   ACLs */\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto cifs_create_out;\n\t}\n\n\t/*\n\t * if we're not using unix extensions, see if we need to set\n\t * ATTR_READONLY on the create call\n\t */\n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\tif (tcon->ses->capabilities & CAP_NT_SMBS)\n\t\trc = CIFSSMBOpen(xid, tcon, full_path, disposition,\n\t\t\t desiredAccess, create_options,\n\t\t\t &fileHandle, &oplock, buf, cifs_sb->local_nls,\n\t\t\t cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\telse\n\t\trc = -EIO; /* no NT SMB support fall into legacy open below */\n\n\tif (rc == -EIO) {\n\t\t/* old server, retry the open legacy style */\n\t\trc = SMBLegacyOpen(xid, tcon, full_path, disposition,\n\t\t\tdesiredAccess, create_options,\n\t\t\t&fileHandle, &oplock, buf, cifs_sb->local_nls,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t}\n\tif (rc) {\n\t\tcFYI(1, \"cifs_create returned 0x%x\", rc);\n\t\tgoto cifs_create_out;\n\t}\n\n\t/* If Open reported that we actually created a file\n\t   then we now have to set the mode if possible */\n\tif ((tcon->unix_ext) && (oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = (__u64) current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = (__u64) inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = (__u64) current_fsgid();\n\t\t} else {\n\t\t\targs.uid = NO_CHANGE_64;\n\t\t\targs.gid = NO_CHANGE_64;\n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fileHandle,\n\t\t\t\t\tcurrent->tgid);\n\t} else {\n\t\t/* BB implement mode setting via Windows security\n\t\t   descriptors e.g. */\n\t\t/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/\n\n\t\t/* Could set r/o dos attribute if mode & 0222 == 0 */\n\t}\n\ncifs_create_get_file_info:\n\t/* server might mask mode so we have to query for it */\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t      inode->i_sb, xid);\n\telse {\n\t\trc = cifs_get_inode_info(&newinode, full_path, buf,\n\t\t\t\t\t inode->i_sb, xid, &fileHandle);\n\t\tif (newinode) {\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\tnewinode->i_mode = mode;\n\t\t\tif ((oplock & CIFS_CREATE_ACTION) &&\n\t\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)) {\n\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\telse\n\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t}\n\t\t}\n\t}\n\ncifs_create_set_dentry:\n\tif (rc == 0)\n\t\td_instantiate(direntry, newinode);\n\telse\n\t\tcFYI(1, \"Create worked, get_inode_info failed rc = %d\", rc);\n\n\tif (newinode && nd) {\n\t\tstruct cifsFileInfo *pfile_info;\n\t\tstruct file *filp;\n\n\t\tfilp = lookup_instantiate_filp(nd, direntry, generic_file_open);\n\t\tif (IS_ERR(filp)) {\n\t\t\trc = PTR_ERR(filp);\n\t\t\tCIFSSMBClose(xid, tcon, fileHandle);\n\t\t\tgoto cifs_create_out;\n\t\t}\n\n\t\tpfile_info = cifs_new_fileinfo(fileHandle, filp, tlink, oplock);\n\t\tif (pfile_info == NULL) {\n\t\t\tfput(filp);\n\t\t\tCIFSSMBClose(xid, tcon, fileHandle);\n\t\t\trc = -ENOMEM;\n\t\t}\n\t} else {\n\t\tCIFSSMBClose(xid, tcon, fileHandle);\n\t}\n\ncifs_create_out:\n\tkfree(buf);\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn rc;\n}\n\nint cifs_mknod(struct inode *inode, struct dentry *direntry, int mode,\n\t\tdev_t device_number)\n{\n\tint rc = -EPERM;\n\tint xid;\n\tint create_options = CREATE_NOT_DIR | CREATE_OPTION_SPECIAL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifs_io_parms io_parms;\n\tchar *full_path = NULL;\n\tstruct inode *newinode = NULL;\n\tint oplock = 0;\n\tu16 fileHandle;\n\tFILE_ALL_INFO *buf = NULL;\n\tunsigned int bytes_written;\n\tstruct win_dev *pdev;\n\n\tif (!old_valid_dev(device_number))\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\tpTcon = tlink_tcon(tlink);\n\n\txid = GetXid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mknod_out;\n\t}\n\n\tif (pTcon->unix_ext) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode & ~current_umask(),\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= device_number,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = (__u64) current_fsuid();\n\t\t\targs.gid = (__u64) current_fsgid();\n\t\t} else {\n\t\t\targs.uid = NO_CHANGE_64;\n\t\t\targs.gid = NO_CHANGE_64;\n\t\t}\n\t\trc = CIFSSMBUnixSetPathInfo(xid, pTcon, full_path, &args,\n\t\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t\t    cifs_sb->mnt_cifs_flags &\n\t\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (rc)\n\t\t\tgoto mknod_out;\n\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t\tinode->i_sb, xid);\n\n\t\tif (rc == 0)\n\t\t\td_instantiate(direntry, newinode);\n\t\tgoto mknod_out;\n\t}\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL))\n\t\tgoto mknod_out;\n\n\n\tcFYI(1, \"sfu compat create special file\");\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tkfree(full_path);\n\t\trc = -ENOMEM;\n\t\tFreeXid(xid);\n\t\treturn rc;\n\t}\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\trc = CIFSSMBOpen(xid, pTcon, full_path, FILE_CREATE,\n\t\t\t GENERIC_WRITE, create_options,\n\t\t\t &fileHandle, &oplock, buf, cifs_sb->local_nls,\n\t\t\t cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\tif (rc)\n\t\tgoto mknod_out;\n\n\t/* BB Do not bother to decode buf since no local inode yet to put\n\t * timestamps in, but we can reuse it safely */\n\n\tpdev = (struct win_dev *)buf;\n\tio_parms.netfid = fileHandle;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = pTcon;\n\tio_parms.offset = 0;\n\tio_parms.length = sizeof(struct win_dev);\n\tif (S_ISCHR(mode)) {\n\t\tmemcpy(pdev->type, \"IntxCHR\", 8);\n\t\tpdev->major =\n\t\t      cpu_to_le64(MAJOR(device_number));\n\t\tpdev->minor =\n\t\t      cpu_to_le64(MINOR(device_number));\n\t\trc = CIFSSMBWrite(xid, &io_parms,\n\t\t\t&bytes_written, (char *)pdev,\n\t\t\tNULL, 0);\n\t} else if (S_ISBLK(mode)) {\n\t\tmemcpy(pdev->type, \"IntxBLK\", 8);\n\t\tpdev->major =\n\t\t      cpu_to_le64(MAJOR(device_number));\n\t\tpdev->minor =\n\t\t      cpu_to_le64(MINOR(device_number));\n\t\trc = CIFSSMBWrite(xid, &io_parms,\n\t\t\t&bytes_written, (char *)pdev,\n\t\t\tNULL, 0);\n\t} /* else if (S_ISFIFO) */\n\tCIFSSMBClose(xid, pTcon, fileHandle);\n\td_drop(direntry);\n\n\t/* FIXME: add code here to set EAs */\n\nmknod_out:\n\tkfree(full_path);\n\tkfree(buf);\n\tFreeXid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nstruct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase -ENOENT:\n\t\t\t\tposix_open = true;\n\t\t\tcase -EOPNOTSUPP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t\t}\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}\n\nstatic int\ncifs_d_revalidate(struct dentry *direntry, struct nameidata *nd)\n{\n\tif (nd && (nd->flags & LOOKUP_RCU))\n\t\treturn -ECHILD;\n\n\tif (direntry->d_inode) {\n\t\tif (cifs_revalidate_dentry(direntry))\n\t\t\treturn 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * Forcibly invalidate automounting directory inodes\n\t\t\t * (remote DFS directories) so to have them\n\t\t\t * instantiated again for automount\n\t\t\t */\n\t\t\tif (IS_AUTOMOUNT(direntry->d_inode))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!nd)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (nd->flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\tif (time_after(jiffies, direntry->d_time + HZ) || !lookupCacheEnabled)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* static int cifs_d_delete(struct dentry *direntry)\n{\n\tint rc = 0;\n\n\tcFYI(1, \"In cifs d_delete, name = %s\", direntry->d_name.name);\n\n\treturn rc;\n}     */\n\nconst struct dentry_operations cifs_dentry_ops = {\n\t.d_revalidate = cifs_d_revalidate,\n\t.d_automount = cifs_dfs_d_automount,\n/* d_delete:       cifs_d_delete,      */ /* not needed except for debugging */\n};\n\nstatic int cifs_ci_hash(const struct dentry *dentry, const struct inode *inode,\n\t\tstruct qstr *q)\n{\n\tstruct nls_table *codepage = CIFS_SB(dentry->d_sb)->local_nls;\n\tunsigned long hash;\n\tint i;\n\n\thash = init_name_hash();\n\tfor (i = 0; i < q->len; i++)\n\t\thash = partial_name_hash(nls_tolower(codepage, q->name[i]),\n\t\t\t\t\t hash);\n\tq->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\nstatic int cifs_ci_compare(const struct dentry *parent,\n\t\tconst struct inode *pinode,\n\t\tconst struct dentry *dentry, const struct inode *inode,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *codepage = CIFS_SB(pinode->i_sb)->local_nls;\n\n\tif ((name->len == len) &&\n\t    (nls_strnicmp(codepage, name->name, str, len) == 0))\n\t\treturn 0;\n\treturn 1;\n}\n\nconst struct dentry_operations cifs_ci_dentry_ops = {\n\t.d_revalidate = cifs_d_revalidate,\n\t.d_hash = cifs_ci_hash,\n\t.d_compare = cifs_ci_compare,\n\t.d_automount = cifs_dfs_d_automount,\n};\n"], "filenames": ["fs/cifs/dir.c"], "buggy_code_start_loc": [587], "buggy_code_end_loc": [590], "fixing_code_start_loc": [587], "fixing_code_end_loc": [607], "type": "CWE-20", "message": "The cifs_lookup function in fs/cifs/dir.c in the Linux kernel before 3.2.10 allows local users to cause a denial of service (OOPS) via attempted access to a special file, as demonstrated by a FIFO.", "other": {"cve": {"id": "CVE-2012-1090", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:37.053", "lastModified": "2021-07-15T19:16:09.750", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The cifs_lookup function in fs/cifs/dir.c in the Linux kernel before 3.2.10 allows local users to cause a denial of service (OOPS) via attempted access to a special file, as demonstrated by a FIFO."}, {"lang": "es", "value": "La funci\u00f3n cifs_lookup en fs/cifs/dir.c en el n\u00facleo de Linux anteriores a v3.2.10 permite a usuarios locales causar una denegaci\u00f3n de servicio (OOPS) a trav\u00e9s de intentos de acceso a un archivo especial, como lo demuestra un FIFO."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.10", "matchCriteriaId": "3C16692B-B239-405B-998B-114907D6243D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_mrg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "C60FA8B1-1802-4522-A088-22171DCF7A93"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "60FBDD82-691C-4D9D-B71B-F9AFF6931B53"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "00720D8C-3FF3-4B1C-B74B-91F01A544399"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "EB74DEB4-2BD1-4A65-AFDA-C331BC20C178"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "DF49412C-CF41-4251-B1FB-F0E63AC9E019"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "EE26596F-F10E-44EF-88CA-0080646E91B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:*:vmware:*:*", "matchCriteriaId": "A6B7CDCA-6F39-4113-B5D3-3AA9D7F3D809"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:*:vmware:*:*", "matchCriteriaId": "DB4D6749-81A1-41D7-BF4F-1C45A7F49A22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:-:*:*:*", "matchCriteriaId": "1A9E2971-0D30-4A8D-8BF8-99E4E9E4CF86"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2012-04/msg00021.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2012-05/msg00013.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-0481.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-0531.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.2.10", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/02/28/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=798293", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08"}}