{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                                 FFFFF  X   X                                %\n%                                 F       X X                                 %\n%                                 FFF      X                                  %\n%                                 F       X X                                 %\n%                                 F      X   X                                %\n%                                                                             %\n%                                                                             %\n%                   MagickCore Image Special Effects Methods                  %\n%                                                                             %\n%                               Software Design                               %\n%                                    Cristy                                   %\n%                                 October 1996                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/accelerate-private.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/fx-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/gem-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/random-private.h\"\n#include \"MagickCore/resample.h\"\n#include \"MagickCore/resample-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/transform-private.h\"\n#include \"MagickCore/utility.h\"\n\n\n/*\n  Define declarations.\n*/\n#define LeftShiftOperator  0xf5U\n#define RightShiftOperator  0xf6U\n#define LessThanEqualOperator  0xf7U\n#define GreaterThanEqualOperator  0xf8U\n#define EqualOperator  0xf9U\n#define NotEqualOperator  0xfaU\n#define LogicalAndOperator  0xfbU\n#define LogicalOrOperator  0xfcU\n#define ExponentialNotation 0xfdU\n\nstruct _FxInfo\n{\n  const Image\n    *images;\n\n  char\n    *expression;\n\n  FILE\n    *file;\n\n  SplayTreeInfo\n    *colors,\n    *symbols;\n\n  CacheView\n    **view;\n\n  RandomInfo\n    *random_info;\n\n  ExceptionInfo\n    *exception;\n};\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e F x I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireFxInfo() allocates the FxInfo structure.\n%\n%  The format of the AcquireFxInfo method is:\n%\n%      FxInfo *AcquireFxInfo(Image *image,const char *expression,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o expression: the expression.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate FxInfo *AcquireFxInfo(const Image *image,const char *expression,\n  ExceptionInfo *exception)\n{\n  char\n    fx_op[2];\n\n  const Image\n    *next;\n\n  FxInfo\n    *fx_info;\n\n  register ssize_t\n    i;\n\n  fx_info=(FxInfo *) AcquireMagickMemory(sizeof(*fx_info));\n  if (fx_info == (FxInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(fx_info,0,sizeof(*fx_info));\n  fx_info->exception=AcquireExceptionInfo();\n  fx_info->images=image;\n  fx_info->colors=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n    RelinquishAlignedMemory);\n  fx_info->symbols=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n    RelinquishMagickMemory);\n  fx_info->view=(CacheView **) AcquireQuantumMemory(GetImageListLength(\n    fx_info->images),sizeof(*fx_info->view));\n  if (fx_info->view == (CacheView **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  i=0;\n  next=GetFirstImageInList(fx_info->images);\n  for ( ; next != (Image *) NULL; next=next->next)\n  {\n    fx_info->view[i]=AcquireVirtualCacheView(next,exception);\n    i++;\n  }\n  fx_info->random_info=AcquireRandomInfo();\n  fx_info->expression=ConstantString(expression);\n  fx_info->file=stderr;\n  (void) SubstituteString(&fx_info->expression,\" \",\"\");  /* compact string */\n  /*\n    Force right-to-left associativity for unary negation.\n  */\n  (void) SubstituteString(&fx_info->expression,\"-\",\"-1.0*\");\n  (void) SubstituteString(&fx_info->expression,\"^-1.0*\",\"^-\");\n  (void) SubstituteString(&fx_info->expression,\"E-1.0*\",\"E-\");\n  (void) SubstituteString(&fx_info->expression,\"e-1.0*\",\"e-\");\n  /*\n    Convert compound to simple operators.\n  */\n  fx_op[1]='\\0';\n  *fx_op=(char) LeftShiftOperator;\n  (void) SubstituteString(&fx_info->expression,\"<<\",fx_op);\n  *fx_op=(char) RightShiftOperator;\n  (void) SubstituteString(&fx_info->expression,\">>\",fx_op);\n  *fx_op=(char) LessThanEqualOperator;\n  (void) SubstituteString(&fx_info->expression,\"<=\",fx_op);\n  *fx_op=(char) GreaterThanEqualOperator;\n  (void) SubstituteString(&fx_info->expression,\">=\",fx_op);\n  *fx_op=(char) EqualOperator;\n  (void) SubstituteString(&fx_info->expression,\"==\",fx_op);\n  *fx_op=(char) NotEqualOperator;\n  (void) SubstituteString(&fx_info->expression,\"!=\",fx_op);\n  *fx_op=(char) LogicalAndOperator;\n  (void) SubstituteString(&fx_info->expression,\"&&\",fx_op);\n  *fx_op=(char) LogicalOrOperator;\n  (void) SubstituteString(&fx_info->expression,\"||\",fx_op);\n  *fx_op=(char) ExponentialNotation;\n  (void) SubstituteString(&fx_info->expression,\"**\",fx_op);\n  return(fx_info);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A d d N o i s e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AddNoiseImage() adds random noise to the image.\n%\n%  The format of the AddNoiseImage method is:\n%\n%      Image *AddNoiseImage(const Image *image,const NoiseType noise_type,\n%        const double attenuate,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel type.\n%\n%    o noise_type:  The type of noise: Uniform, Gaussian, Multiplicative,\n%      Impulse, Laplacian, or Poisson.\n%\n%    o attenuate:  attenuate the random distribution.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AddNoiseImage(const Image *image,const NoiseType noise_type,\n  const double attenuate,ExceptionInfo *exception)\n{\n#define AddNoiseImageTag  \"AddNoise/Image\"\n\n  CacheView\n    *image_view,\n    *noise_view;\n\n  Image\n    *noise_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  /*\n    Initialize noise image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  noise_image=AccelerateAddNoiseImage(image,noise_type,exception);\n  if (noise_image != (Image *) NULL)\n    return(noise_image);\n#endif\n  noise_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (noise_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(noise_image,DirectClass,exception) == MagickFalse)\n    {\n      noise_image=DestroyImage(noise_image);\n      return((Image *) NULL);\n    }\n  /*\n    Add noise in each row.\n  */\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  image_view=AcquireVirtualCacheView(image,exception);\n  noise_view=AcquireAuthenticCacheView(noise_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,noise_image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(noise_view,0,y,noise_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait noise_traits=GetPixelChannelTraits(noise_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (noise_traits == UndefinedPixelTrait))\n          continue;\n        if (((noise_traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(image,p) == 0))\n          {\n            SetPixelChannel(noise_image,channel,p[i],q);\n            continue;\n          }\n        SetPixelChannel(noise_image,channel,ClampToQuantum(\n          GenerateDifferentialNoise(random_info[id],p[i],noise_type,attenuate)),\n          q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(noise_image);\n    }\n    sync=SyncCacheViewAuthenticPixels(noise_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_AddNoiseImage)\n#endif\n        proceed=SetImageProgress(image,AddNoiseImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  noise_view=DestroyCacheView(noise_view);\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  if (status == MagickFalse)\n    noise_image=DestroyImage(noise_image);\n  return(noise_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B l u e S h i f t I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlueShiftImage() mutes the colors of the image to simulate a scene at\n%  nighttime in the moonlight.\n%\n%  The format of the BlueShiftImage method is:\n%\n%      Image *BlueShiftImage(const Image *image,const double factor,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o factor: the shift factor.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *BlueShiftImage(const Image *image,const double factor,\n  ExceptionInfo *exception)\n{\n#define BlueShiftImageTag  \"BlueShift/Image\"\n\n  CacheView\n    *image_view,\n    *shift_view;\n\n  Image\n    *shift_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate blue shift image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  shift_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (shift_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(shift_image,DirectClass,exception) == MagickFalse)\n    {\n      shift_image=DestroyImage(shift_image);\n      return((Image *) NULL);\n    }\n  /*\n    Blue-shift DirectClass image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  shift_view=AcquireAuthenticCacheView(shift_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,shift_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    PixelInfo\n      pixel;\n\n    Quantum\n      quantum;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(shift_view,0,y,shift_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      quantum=GetPixelRed(image,p);\n      if (GetPixelGreen(image,p) < quantum)\n        quantum=GetPixelGreen(image,p);\n      if (GetPixelBlue(image,p) < quantum)\n        quantum=GetPixelBlue(image,p);\n      pixel.red=0.5*(GetPixelRed(image,p)+factor*quantum);\n      pixel.green=0.5*(GetPixelGreen(image,p)+factor*quantum);\n      pixel.blue=0.5*(GetPixelBlue(image,p)+factor*quantum);\n      quantum=GetPixelRed(image,p);\n      if (GetPixelGreen(image,p) > quantum)\n        quantum=GetPixelGreen(image,p);\n      if (GetPixelBlue(image,p) > quantum)\n        quantum=GetPixelBlue(image,p);\n      pixel.red=0.5*(pixel.red+factor*quantum);\n      pixel.green=0.5*(pixel.green+factor*quantum);\n      pixel.blue=0.5*(pixel.blue+factor*quantum);\n      SetPixelRed(shift_image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(shift_image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(shift_image,ClampToQuantum(pixel.blue),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(shift_image);\n    }\n    sync=SyncCacheViewAuthenticPixels(shift_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_BlueShiftImage)\n#endif\n        proceed=SetImageProgress(image,BlueShiftImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  shift_view=DestroyCacheView(shift_view);\n  if (status == MagickFalse)\n    shift_image=DestroyImage(shift_image);\n  return(shift_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C h a r c o a l I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CharcoalImage() creates a new image that is a copy of an existing one with\n%  the edge highlighted.  It allocates the memory necessary for the new Image\n%  structure and returns a pointer to the new image.\n%\n%  The format of the CharcoalImage method is:\n%\n%      Image *CharcoalImage(const Image *image,const double radius,\n%        const double sigma,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o radius: the radius of the pixel neighborhood.\n%\n%    o sigma: the standard deviation of the Gaussian, in pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CharcoalImage(const Image *image,const double radius,\n  const double sigma,ExceptionInfo *exception)\n{\n  Image\n    *charcoal_image,\n    *clone_image,\n    *edge_image;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  clone_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (clone_image == (Image *) NULL)\n    return((Image *) NULL);\n  edge_image=EdgeImage(clone_image,radius,exception);\n  clone_image=DestroyImage(clone_image);\n  if (edge_image == (Image *) NULL)\n    return((Image *) NULL);\n  charcoal_image=BlurImage(edge_image,radius,sigma,exception);\n  edge_image=DestroyImage(edge_image);\n  if (charcoal_image == (Image *) NULL)\n    return((Image *) NULL);\n  (void) NormalizeImage(charcoal_image,exception);\n  (void) NegateImage(charcoal_image,MagickFalse,exception);\n  (void) GrayscaleImage(charcoal_image,image->intensity,exception);\n  return(charcoal_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o l o r i z e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ColorizeImage() blends the fill color with each pixel in the image.\n%  A percentage blend is specified with opacity.  Control the application\n%  of different color components by specifying a different percentage for\n%  each component (e.g. 90/100/10 is 90% red, 100% green, and 10% blue).\n%\n%  The format of the ColorizeImage method is:\n%\n%      Image *ColorizeImage(const Image *image,const char *blend,\n%        const PixelInfo *colorize,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o blend:  A character string indicating the level of blending as a\n%      percentage.\n%\n%    o colorize: A color value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ColorizeImage(const Image *image,const char *blend,\n  const PixelInfo *colorize,ExceptionInfo *exception)\n{\n#define ColorizeImageTag  \"Colorize/Image\"\n#define Colorize(pixel,blend_percentage,colorize)  \\\n  (((pixel)*(100.0-(blend_percentage))+(colorize)*(blend_percentage))/100.0)\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *colorize_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickStatusType\n    flags;\n\n  PixelInfo\n    blend_percentage;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate colorized image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  colorize_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (colorize_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(colorize_image,DirectClass,exception) == MagickFalse)\n    {\n      colorize_image=DestroyImage(colorize_image);\n      return((Image *) NULL);\n    }\n  if ((IsGrayColorspace(colorize_image->colorspace) != MagickFalse) ||\n      (IsPixelInfoGray(colorize) != MagickFalse))\n    (void) SetImageColorspace(colorize_image,sRGBColorspace,exception);\n  if ((colorize_image->alpha_trait == UndefinedPixelTrait) &&\n      (colorize->alpha_trait != UndefinedPixelTrait))\n    (void) SetImageAlpha(colorize_image,OpaqueAlpha,exception);\n  if (blend == (const char *) NULL)\n    return(colorize_image);\n  GetPixelInfo(colorize_image,&blend_percentage);\n  flags=ParseGeometry(blend,&geometry_info);\n  blend_percentage.red=geometry_info.rho;\n  blend_percentage.green=geometry_info.rho;\n  blend_percentage.blue=geometry_info.rho;\n  blend_percentage.black=geometry_info.rho;\n  blend_percentage.alpha=(MagickRealType) TransparentAlpha;\n  if ((flags & SigmaValue) != 0)\n    blend_percentage.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    blend_percentage.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    blend_percentage.alpha=geometry_info.psi;\n  if (blend_percentage.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        blend_percentage.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        blend_percentage.alpha=geometry_info.chi;\n    }\n  /*\n    Colorize DirectClass image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(colorize_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(colorize_image,colorize_image,colorize_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) colorize_image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,colorize_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) colorize_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(colorize_image); i++)\n      {\n        PixelTrait traits=GetPixelChannelTraits(colorize_image,\n          (PixelChannel) i);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if (((traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(colorize_image,q) == 0))\n          continue;\n        SetPixelChannel(colorize_image,(PixelChannel) i,ClampToQuantum(\n          Colorize(q[i],GetPixelInfoChannel(&blend_percentage,(PixelChannel) i),\n          GetPixelInfoChannel(colorize,(PixelChannel) i))),q);\n      }\n      q+=GetPixelChannels(colorize_image);\n    }\n    sync=SyncCacheViewAuthenticPixels(image_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ColorizeImage)\n#endif\n        proceed=SetImageProgress(image,ColorizeImageTag,progress++,\n          colorize_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    colorize_image=DestroyImage(colorize_image);\n  return(colorize_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o l o r M a t r i x I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ColorMatrixImage() applies color transformation to an image. This method\n%  permits saturation changes, hue rotation, luminance to alpha, and various\n%  other effects.  Although variable-sized transformation matrices can be used,\n%  typically one uses a 5x5 matrix for an RGBA image and a 6x6 for CMYKA\n%  (or RGBA with offsets).  The matrix is similar to those used by Adobe Flash\n%  except offsets are in column 6 rather than 5 (in support of CMYKA images)\n%  and offsets are normalized (divide Flash offset by 255).\n%\n%  The format of the ColorMatrixImage method is:\n%\n%      Image *ColorMatrixImage(const Image *image,\n%        const KernelInfo *color_matrix,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o color_matrix:  the color matrix.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n/* FUTURE: modify to make use of a MagickMatrix Mutliply function\n   That should be provided in \"matrix.c\"\n   (ASIDE: actually distorts should do this too but currently doesn't)\n*/\n\nMagickExport Image *ColorMatrixImage(const Image *image,\n  const KernelInfo *color_matrix,ExceptionInfo *exception)\n{\n#define ColorMatrixImageTag  \"ColorMatrix/Image\"\n\n  CacheView\n    *color_view,\n    *image_view;\n\n  double\n    ColorMatrix[6][6] =\n    {\n      { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n      { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },\n      { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },\n      { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },\n      { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },\n      { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 }\n    };\n\n  Image\n    *color_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    u,\n    v,\n    y;\n\n  /*\n    Map given color_matrix, into a 6x6 matrix   RGBKA and a constant\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  i=0;\n  for (v=0; v < (ssize_t) color_matrix->height; v++)\n    for (u=0; u < (ssize_t) color_matrix->width; u++)\n    {\n      if ((v < 6) && (u < 6))\n        ColorMatrix[v][u]=color_matrix->values[i];\n      i++;\n    }\n  /*\n    Initialize color image.\n  */\n  color_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (color_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(color_image,DirectClass,exception) == MagickFalse)\n    {\n      color_image=DestroyImage(color_image);\n      return((Image *) NULL);\n    }\n  if (image->debug != MagickFalse)\n    {\n      char\n        format[MagickPathExtent],\n        *message;\n\n      (void) LogMagickEvent(TransformEvent,GetMagickModule(),\n        \"  ColorMatrix image with color matrix:\");\n      message=AcquireString(\"\");\n      for (v=0; v < 6; v++)\n      {\n        *message='\\0';\n        (void) FormatLocaleString(format,MagickPathExtent,\"%.20g: \",(double) v);\n        (void) ConcatenateString(&message,format);\n        for (u=0; u < 6; u++)\n        {\n          (void) FormatLocaleString(format,MagickPathExtent,\"%+f \",\n            ColorMatrix[v][u]);\n          (void) ConcatenateString(&message,format);\n        }\n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message);\n      }\n      message=DestroyString(message);\n    }\n  /*\n    Apply the ColorMatrix to image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  color_view=AcquireAuthenticCacheView(color_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,color_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelInfo\n      pixel;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(color_view,0,y,color_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    GetPixelInfo(image,&pixel);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        v;\n\n      size_t\n        height;\n\n      GetPixelInfoPixel(image,p,&pixel);\n      height=color_matrix->height > 6 ? 6UL : color_matrix->height;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        double\n          sum;\n\n        sum=ColorMatrix[v][0]*GetPixelRed(image,p)+ColorMatrix[v][1]*\n          GetPixelGreen(image,p)+ColorMatrix[v][2]*GetPixelBlue(image,p);\n        if (image->colorspace == CMYKColorspace)\n          sum+=ColorMatrix[v][3]*GetPixelBlack(image,p);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          sum+=ColorMatrix[v][4]*GetPixelAlpha(image,p);\n        sum+=QuantumRange*ColorMatrix[v][5];\n        switch (v)\n        {\n          case 0: pixel.red=sum; break;\n          case 1: pixel.green=sum; break;\n          case 2: pixel.blue=sum; break;\n          case 3: pixel.black=sum; break;\n          case 4: pixel.alpha=sum; break;\n          default: break;\n        }\n      }\n      SetPixelViaPixelInfo(color_image,&pixel,q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(color_image);\n    }\n    if (SyncCacheViewAuthenticPixels(color_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ColorMatrixImage)\n#endif\n        proceed=SetImageProgress(image,ColorMatrixImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  color_view=DestroyCacheView(color_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    color_image=DestroyImage(color_image);\n  return(color_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y F x I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyFxInfo() deallocates memory associated with an FxInfo structure.\n%\n%  The format of the DestroyFxInfo method is:\n%\n%      ImageInfo *DestroyFxInfo(ImageInfo *fx_info)\n%\n%  A description of each parameter follows:\n%\n%    o fx_info: the fx info.\n%\n*/\nMagickPrivate FxInfo *DestroyFxInfo(FxInfo *fx_info)\n{\n  register ssize_t\n    i;\n\n  fx_info->exception=DestroyExceptionInfo(fx_info->exception);\n  fx_info->expression=DestroyString(fx_info->expression);\n  fx_info->symbols=DestroySplayTree(fx_info->symbols);\n  fx_info->colors=DestroySplayTree(fx_info->colors);\n  for (i=(ssize_t) GetImageListLength(fx_info->images)-1; i >= 0; i--)\n    fx_info->view[i]=DestroyCacheView(fx_info->view[i]);\n  fx_info->view=(CacheView **) RelinquishMagickMemory(fx_info->view);\n  fx_info->random_info=DestroyRandomInfo(fx_info->random_info);\n  fx_info=(FxInfo *) RelinquishMagickMemory(fx_info);\n  return(fx_info);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     F x E v a l u a t e C h a n n e l E x p r e s s i o n                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FxEvaluateChannelExpression() evaluates an expression and returns the\n%  results.\n%\n%  The format of the FxEvaluateExpression method is:\n%\n%      double FxEvaluateChannelExpression(FxInfo *fx_info,\n%        const PixelChannel channel,const ssize_t x,const ssize_t y,\n%        double *alpha,Exceptioninfo *exception)\n%      double FxEvaluateExpression(FxInfo *fx_info,\n%        double *alpha,Exceptioninfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o fx_info: the fx info.\n%\n%    o channel: the channel.\n%\n%    o x,y: the pixel position.\n%\n%    o alpha: the result.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic double FxChannelStatistics(FxInfo *fx_info,Image *image,\n  PixelChannel channel,const char *symbol,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  char\n    key[MagickPathExtent],\n    statistic[MagickPathExtent];\n\n  const char\n    *value;\n\n  register const char\n    *p;\n\n  channel_mask=UndefinedChannel;\n  for (p=symbol; (*p != '.') && (*p != '\\0'); p++) ;\n  if (*p == '.')\n    {\n      ssize_t\n        option;\n\n      option=ParseCommandOption(MagickPixelChannelOptions,MagickTrue,p+1);\n      if (option >= 0)\n        {\n          channel=(PixelChannel) option;\n          channel_mask=(ChannelType) (channel_mask | (1 << channel));\n          (void) SetPixelChannelMask(image,channel_mask);\n        }\n    }\n  (void) FormatLocaleString(key,MagickPathExtent,\"%p.%.20g.%s\",(void *) image,\n    (double) channel,symbol);\n  value=(const char *) GetValueFromSplayTree(fx_info->symbols,key);\n  if (value != (const char *) NULL)\n    {\n      if (channel_mask != UndefinedChannel)\n        (void) SetPixelChannelMask(image,channel_mask);\n      return(QuantumScale*StringToDouble(value,(char **) NULL));\n    }\n  (void) DeleteNodeFromSplayTree(fx_info->symbols,key);\n  if (LocaleNCompare(symbol,\"depth\",5) == 0)\n    {\n      size_t\n        depth;\n\n      depth=GetImageDepth(image,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%.20g\",(double)\n        depth);\n    }\n  if (LocaleNCompare(symbol,\"kurtosis\",8) == 0)\n    {\n      double\n        kurtosis,\n        skewness;\n\n      (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",kurtosis);\n    }\n  if (LocaleNCompare(symbol,\"maxima\",6) == 0)\n    {\n      double\n        maxima,\n        minima;\n\n      (void) GetImageRange(image,&minima,&maxima,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",maxima);\n    }\n  if (LocaleNCompare(symbol,\"mean\",4) == 0)\n    {\n      double\n        mean,\n        standard_deviation;\n\n      (void) GetImageMean(image,&mean,&standard_deviation,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",mean);\n    }\n  if (LocaleNCompare(symbol,\"minima\",6) == 0)\n    {\n      double\n        maxima,\n        minima;\n\n      (void) GetImageRange(image,&minima,&maxima,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",minima);\n    }\n  if (LocaleNCompare(symbol,\"skewness\",8) == 0)\n    {\n      double\n        kurtosis,\n        skewness;\n\n      (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",skewness);\n    }\n  if (LocaleNCompare(symbol,\"standard_deviation\",18) == 0)\n    {\n      double\n        mean,\n        standard_deviation;\n\n      (void) GetImageMean(image,&mean,&standard_deviation,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",\n        standard_deviation);\n    }\n  if (channel_mask != UndefinedChannel)\n    (void) SetPixelChannelMask(image,channel_mask);\n  (void) AddValueToSplayTree(fx_info->symbols,ConstantString(key),\n    ConstantString(statistic));\n  return(QuantumScale*StringToDouble(statistic,(char **) NULL));\n}\n\nstatic double\n  FxEvaluateSubexpression(FxInfo *,const PixelChannel,const ssize_t,\n    const ssize_t,const char *,size_t *,double *,ExceptionInfo *);\n\nstatic MagickOffsetType FxGCD(MagickOffsetType alpha,MagickOffsetType beta)\n{\n  if (beta != 0)\n    return(FxGCD(beta,alpha % beta));\n  return(alpha);\n}\n\nstatic inline const char *FxSubexpression(const char *expression,\n  ExceptionInfo *exception)\n{\n  const char\n    *subexpression;\n\n  register ssize_t\n    level;\n\n  level=0;\n  subexpression=expression;\n  while ((*subexpression != '\\0') &&\n         ((level != 1) || (strchr(\")\",(int) *subexpression) == (char *) NULL)))\n  {\n    if (strchr(\"(\",(int) *subexpression) != (char *) NULL)\n      level++;\n    else\n      if (strchr(\")\",(int) *subexpression) != (char *) NULL)\n        level--;\n    subexpression++;\n  }\n  if (*subexpression == '\\0')\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"UnbalancedParenthesis\",\"`%s'\",expression);\n  return(subexpression);\n}\n\nstatic double FxGetSymbol(FxInfo *fx_info,const PixelChannel channel,\n  const ssize_t x,const ssize_t y,const char *expression,\n  ExceptionInfo *exception)\n{\n  char\n    *q,\n    subexpression[MagickPathExtent],\n    symbol[MagickPathExtent];\n\n  const char\n    *p,\n    *value;\n\n  Image\n    *image;\n\n  PixelInfo\n    pixel;\n\n  double\n    alpha,\n    beta;\n\n  PointInfo\n    point;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length,\n    level;\n\n  p=expression;\n  i=GetImageIndexInList(fx_info->images);\n  depth=0;\n  level=0;\n  point.x=(double) x;\n  point.y=(double) y;\n  if (isalpha((int) ((unsigned char) *(p+1))) == 0)\n    {\n      if (strchr(\"suv\",(int) *p) != (char *) NULL)\n        {\n          switch (*p)\n          {\n            case 's':\n            default:\n            {\n              i=GetImageIndexInList(fx_info->images);\n              break;\n            }\n            case 'u': i=0; break;\n            case 'v': i=1; break;\n          }\n          p++;\n          if (*p == '[')\n            {\n              level++;\n              q=subexpression;\n              for (p++; *p != '\\0'; )\n              {\n                if (*p == '[')\n                  level++;\n                else\n                  if (*p == ']')\n                    {\n                      level--;\n                      if (level == 0)\n                        break;\n                    }\n                *q++=(*p++);\n              }\n              *q='\\0';\n              alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,\n                &depth,&beta,exception);\n              i=(ssize_t) (alpha+0.5);\n              p++;\n            }\n          if (*p == '.')\n            p++;\n        }\n      if ((*p == 'p') && (isalpha((int) ((unsigned char) *(p+1))) == 0))\n        {\n          p++;\n          if (*p == '{')\n            {\n              level++;\n              q=subexpression;\n              for (p++; *p != '\\0'; )\n              {\n                if (*p == '{')\n                  level++;\n                else\n                  if (*p == '}')\n                    {\n                      level--;\n                      if (level == 0)\n                        break;\n                    }\n                *q++=(*p++);\n              }\n              *q='\\0';\n              alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,\n                &depth,&beta,exception);\n              point.x=alpha;\n              point.y=beta;\n              p++;\n            }\n          else\n            if (*p == '[')\n              {\n                level++;\n                q=subexpression;\n                for (p++; *p != '\\0'; )\n                {\n                  if (*p == '[')\n                    level++;\n                  else\n                    if (*p == ']')\n                      {\n                        level--;\n                        if (level == 0)\n                          break;\n                      }\n                  *q++=(*p++);\n                }\n                *q='\\0';\n                alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,\n                  &depth,&beta,exception);\n                point.x+=alpha;\n                point.y+=beta;\n                p++;\n              }\n          if (*p == '.')\n            p++;\n        }\n    }\n  length=GetImageListLength(fx_info->images);\n  while (i < 0)\n    i+=(ssize_t) length;\n  if (length != 0)\n    i%=length;\n  image=GetImageFromList(fx_info->images,i);\n  if (image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"NoSuchImage\",\"`%s'\",expression);\n      return(0.0);\n    }\n  GetPixelInfo(image,&pixel);\n  (void) InterpolatePixelInfo(image,fx_info->view[i],image->interpolate,\n    point.x,point.y,&pixel,exception);\n  if ((strlen(p) > 2) && (LocaleCompare(p,\"intensity\") != 0) &&\n      (LocaleCompare(p,\"luma\") != 0) && (LocaleCompare(p,\"luminance\") != 0) &&\n      (LocaleCompare(p,\"hue\") != 0) && (LocaleCompare(p,\"saturation\") != 0) &&\n      (LocaleCompare(p,\"lightness\") != 0))\n    {\n      char\n        name[MagickPathExtent];\n\n      (void) CopyMagickString(name,p,MagickPathExtent);\n      for (q=name+(strlen(name)-1); q > name; q--)\n      {\n        if (*q == ')')\n          break;\n        if (*q == '.')\n          {\n            *q='\\0';\n            break;\n          }\n      }\n      if ((strlen(name) > 2) &&\n          (GetValueFromSplayTree(fx_info->symbols,name) == (const char *) NULL))\n        {\n          PixelInfo\n            *color;\n\n          color=(PixelInfo *) GetValueFromSplayTree(fx_info->colors,name);\n          if (color != (PixelInfo *) NULL)\n            {\n              pixel=(*color);\n              p+=strlen(name);\n            }\n          else\n            {\n              MagickBooleanType\n                status;\n\n              status=QueryColorCompliance(name,AllCompliance,&pixel,\n                fx_info->exception);\n              if (status != MagickFalse)\n                {\n                  (void) AddValueToSplayTree(fx_info->colors,ConstantString(\n                    name),ClonePixelInfo(&pixel));\n                  p+=strlen(name);\n                }\n            }\n        }\n    }\n  (void) CopyMagickString(symbol,p,MagickPathExtent);\n  StripString(symbol);\n  if (*symbol == '\\0')\n    {\n      switch (channel)\n      {\n        case RedPixelChannel: return(QuantumScale*pixel.red);\n        case GreenPixelChannel: return(QuantumScale*pixel.green);\n        case BluePixelChannel: return(QuantumScale*pixel.blue);\n        case BlackPixelChannel:\n        {\n          if (image->colorspace != CMYKColorspace)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                ImageError,\"ColorSeparatedImageRequired\",\"`%s'\",\n                image->filename);\n              return(0.0);\n            }\n          return(QuantumScale*pixel.black);\n        }\n        case AlphaPixelChannel:\n        {\n          if (pixel.alpha_trait == UndefinedPixelTrait)\n            return(1.0);\n          alpha=(double) (QuantumScale*pixel.alpha);\n          return(alpha);\n        }\n        case IndexPixelChannel:\n          return(0.0);\n        case IntensityPixelChannel:\n        {\n          Quantum\n            quantum_pixel[MaxPixelChannels];\n\n          SetPixelViaPixelInfo(image,&pixel,quantum_pixel);\n          return(QuantumScale*GetPixelIntensity(image,quantum_pixel));\n        }\n        default:\n          break;\n      }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"UnableToParseExpression\",\"`%s'\",p);\n      return(0.0);\n    }\n  switch (*symbol)\n  {\n    case 'A':\n    case 'a':\n    {\n      if (LocaleCompare(symbol,\"a\") == 0)\n        return((QuantumScale*pixel.alpha));\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(symbol,\"b\") == 0)\n        return(QuantumScale*pixel.blue);\n      break;\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleNCompare(symbol,\"channel\",7) == 0)\n        {\n          GeometryInfo\n            channel_info;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(symbol+7,&channel_info);\n          if (image->colorspace == CMYKColorspace)\n            switch (channel)\n            {\n              case CyanPixelChannel:\n              {\n                if ((flags & RhoValue) == 0)\n                  return(0.0);\n                return(channel_info.rho);\n              }\n              case MagentaPixelChannel:\n              {\n                if ((flags & SigmaValue) == 0)\n                  return(0.0);\n                return(channel_info.sigma);\n              }\n              case YellowPixelChannel:\n              {\n                if ((flags & XiValue) == 0)\n                  return(0.0);\n                return(channel_info.xi);\n              }\n              case BlackPixelChannel:\n              {\n                if ((flags & PsiValue) == 0)\n                  return(0.0);\n                return(channel_info.psi);\n              }\n              case AlphaPixelChannel:\n              {\n                if ((flags & ChiValue) == 0)\n                  return(0.0);\n                return(channel_info.chi);\n              }\n              default:\n                return(0.0);\n            }\n          switch (channel)\n          {\n            case RedPixelChannel:\n            {\n              if ((flags & RhoValue) == 0)\n                return(0.0);\n              return(channel_info.rho);\n            }\n            case GreenPixelChannel:\n            {\n              if ((flags & SigmaValue) == 0)\n                return(0.0);\n              return(channel_info.sigma);\n            }\n            case BluePixelChannel:\n            {\n              if ((flags & XiValue) == 0)\n                return(0.0);\n              return(channel_info.xi);\n            }\n            case BlackPixelChannel:\n            {\n              if ((flags & ChiValue) == 0)\n                return(0.0);\n              return(channel_info.chi);\n            }\n            case AlphaPixelChannel:\n            {\n              if ((flags & PsiValue) == 0)\n                return(0.0);\n              return(channel_info.psi);\n            }\n            default:\n              return(0.0);\n          }\n        }\n      if (LocaleCompare(symbol,\"c\") == 0)\n        return(QuantumScale*pixel.red);\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleNCompare(symbol,\"depth\",5) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(symbol,\"g\") == 0)\n        return(QuantumScale*pixel.green);\n      break;\n    }\n    case 'K':\n    case 'k':\n    {\n      if (LocaleNCompare(symbol,\"kurtosis\",8) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleCompare(symbol,\"k\") == 0)\n        {\n          if (image->colorspace != CMYKColorspace)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"ColorSeparatedImageRequired\",\"`%s'\",\n                image->filename);\n              return(0.0);\n            }\n          return(QuantumScale*pixel.black);\n        }\n      break;\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(symbol,\"h\") == 0)\n        return(image->rows);\n      if (LocaleCompare(symbol,\"hue\") == 0)\n        {\n          double\n            hue,\n            lightness,\n            saturation;\n\n          ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,\n            &lightness);\n          return(hue);\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if ((LocaleCompare(symbol,\"image.depth\") == 0) ||\n          (LocaleCompare(symbol,\"image.minima\") == 0) ||\n          (LocaleCompare(symbol,\"image.maxima\") == 0) ||\n          (LocaleCompare(symbol,\"image.mean\") == 0) ||\n          (LocaleCompare(symbol,\"image.kurtosis\") == 0) ||\n          (LocaleCompare(symbol,\"image.skewness\") == 0) ||\n          (LocaleCompare(symbol,\"image.standard_deviation\") == 0))\n        return(FxChannelStatistics(fx_info,image,channel,symbol+6,exception));\n      if (LocaleCompare(symbol,\"image.resolution.x\") == 0)\n        return(image->resolution.x);\n      if (LocaleCompare(symbol,\"image.resolution.y\") == 0)\n        return(image->resolution.y);\n      if (LocaleCompare(symbol,\"intensity\") == 0)\n        {\n          Quantum\n            quantum_pixel[MaxPixelChannels];\n\n          SetPixelViaPixelInfo(image,&pixel,quantum_pixel);\n          return(QuantumScale*GetPixelIntensity(image,quantum_pixel));\n        }\n      if (LocaleCompare(symbol,\"i\") == 0)\n        return(x);\n      break;\n    }\n    case 'J':\n    case 'j':\n    {\n      if (LocaleCompare(symbol,\"j\") == 0)\n        return(y);\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(symbol,\"lightness\") == 0)\n        {\n          double\n            hue,\n            lightness,\n            saturation;\n\n          ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,\n            &lightness);\n          return(lightness);\n        }\n      if (LocaleCompare(symbol,\"luma\") == 0)\n        {\n          double\n            luma;\n\n          luma=0.212656*pixel.red+0.715158*pixel.green+0.072186*pixel.blue;\n          return(QuantumScale*luma);\n        }\n      if (LocaleCompare(symbol,\"luminance\") == 0)\n        {\n          double\n            luminence;\n\n          luminence=0.212656*pixel.red+0.715158*pixel.green+0.072186*pixel.blue;\n          return(QuantumScale*luminence);\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleNCompare(symbol,\"maxima\",6) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleNCompare(symbol,\"mean\",4) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleNCompare(symbol,\"minima\",6) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleCompare(symbol,\"m\") == 0)\n        return(QuantumScale*pixel.green);\n      break;\n    }\n    case 'N':\n    case 'n':\n    {\n      if (LocaleCompare(symbol,\"n\") == 0)\n        return(GetImageListLength(fx_info->images));\n      break;\n    }\n    case 'O':\n    case 'o':\n    {\n      if (LocaleCompare(symbol,\"o\") == 0)\n        return(QuantumScale*pixel.alpha);\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(symbol,\"page.height\") == 0)\n        return(image->page.height);\n      if (LocaleCompare(symbol,\"page.width\") == 0)\n        return(image->page.width);\n      if (LocaleCompare(symbol,\"page.x\") == 0)\n        return(image->page.x);\n      if (LocaleCompare(symbol,\"page.y\") == 0)\n        return(image->page.y);\n      break;\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare(symbol,\"quality\") == 0)\n        return(image->quality);\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(symbol,\"resolution.x\") == 0)\n        return(image->resolution.x);\n      if (LocaleCompare(symbol,\"resolution.y\") == 0)\n        return(image->resolution.y);\n      if (LocaleCompare(symbol,\"r\") == 0)\n        return(QuantumScale*pixel.red);\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare(symbol,\"saturation\") == 0)\n        {\n          double\n            hue,\n            lightness,\n            saturation;\n\n          ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,\n            &lightness);\n          return(saturation);\n        }\n      if (LocaleNCompare(symbol,\"skewness\",8) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleNCompare(symbol,\"standard_deviation\",18) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(symbol,\"t\") == 0)\n        return(GetImageIndexInList(fx_info->images));\n      break;\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(symbol,\"w\") == 0)\n        return(image->columns);\n      break;\n    }\n    case 'Y':\n    case 'y':\n    {\n      if (LocaleCompare(symbol,\"y\") == 0)\n        return(QuantumScale*pixel.blue);\n      break;\n    }\n    case 'Z':\n    case 'z':\n    {\n      if (LocaleCompare(symbol,\"z\") == 0)\n        return((double)GetImageDepth(image, fx_info->exception));\n      break;\n    }\n    default:\n      break;\n  }\n  value=(const char *) GetValueFromSplayTree(fx_info->symbols,symbol);\n  if (value != (const char *) NULL)\n    return(StringToDouble(value,(char **) NULL));\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n    \"UnableToParseExpression\",\"`%s'\",symbol);\n  return(0.0);\n}\n\nstatic const char *FxOperatorPrecedence(const char *expression,\n  ExceptionInfo *exception)\n{\n  typedef enum\n  {\n    UndefinedPrecedence,\n    NullPrecedence,\n    BitwiseComplementPrecedence,\n    ExponentPrecedence,\n    ExponentialNotationPrecedence,\n    MultiplyPrecedence,\n    AdditionPrecedence,\n    ShiftPrecedence,\n    RelationalPrecedence,\n    EquivalencyPrecedence,\n    BitwiseAndPrecedence,\n    BitwiseOrPrecedence,\n    LogicalAndPrecedence,\n    LogicalOrPrecedence,\n    TernaryPrecedence,\n    AssignmentPrecedence,\n    CommaPrecedence,\n    SeparatorPrecedence\n  } FxPrecedence;\n\n  FxPrecedence\n    precedence,\n    target;\n\n  register const char\n    *subexpression;\n\n  register int\n    c;\n\n  size_t\n    level;\n\n  c=0;\n  level=0;\n  subexpression=(const char *) NULL;\n  target=NullPrecedence;\n  while (*expression != '\\0')\n  {\n    precedence=UndefinedPrecedence;\n    if ((isspace((int) ((unsigned char) *expression)) != 0) || (c == (int) '@'))\n      {\n        expression++;\n        continue;\n      }\n    switch (*expression)\n    {\n      case 'A':\n      case 'a':\n      {\n#if defined(MAGICKCORE_HAVE_ACOSH)\n        if (LocaleNCompare(expression,\"acosh\",5) == 0)\n          {\n            expression+=5;\n            break;\n          }\n#endif\n#if defined(MAGICKCORE_HAVE_ASINH)\n        if (LocaleNCompare(expression,\"asinh\",5) == 0)\n          {\n            expression+=5;\n            break;\n          }\n#endif\n#if defined(MAGICKCORE_HAVE_ATANH)\n        if (LocaleNCompare(expression,\"atanh\",5) == 0)\n          {\n            expression+=5;\n            break;\n          }\n#endif\n        if (LocaleNCompare(expression,\"atan2\",5) == 0)\n          {\n            expression+=5;\n            break;\n          }\n        break;\n      }\n      case 'E':\n      case 'e':\n      {\n        if ((isdigit((int) ((unsigned char) c)) != 0) &&\n            ((LocaleNCompare(expression,\"E+\",2) == 0) ||\n             (LocaleNCompare(expression,\"E-\",2) == 0)))\n          {\n            expression+=2;  /* scientific notation */\n            break;\n          }\n      }\n      case 'J':\n      case 'j':\n      {\n        if ((LocaleNCompare(expression,\"j0\",2) == 0) ||\n            (LocaleNCompare(expression,\"j1\",2) == 0))\n          {\n            expression+=2;\n            break;\n          }\n        break;\n      }\n      case '#':\n      {\n        while (isxdigit((int) ((unsigned char) *(expression+1))) != 0)\n          expression++;\n        break;\n      }\n      default:\n        break;\n    }\n    if ((c == (int) '{') || (c == (int) '['))\n      level++;\n    else\n      if ((c == (int) '}') || (c == (int) ']'))\n        level--;\n    if (level == 0)\n      switch ((unsigned char) *expression)\n      {\n        case '~':\n        case '!':\n        {\n          precedence=BitwiseComplementPrecedence;\n          break;\n        }\n        case '^':\n        case '@':\n        {\n          precedence=ExponentPrecedence;\n          break;\n        }\n        default:\n        {\n          if (((c != 0) && ((isdigit((int) ((unsigned char) c)) != 0) ||\n               (strchr(\")\",(int) ((unsigned char) c)) != (char *) NULL))) &&\n              (((islower((int) ((unsigned char) *expression)) != 0) ||\n               (strchr(\"(\",(int) ((unsigned char) *expression)) != (char *) NULL)) ||\n               ((isdigit((int) ((unsigned char) c)) == 0) &&\n                (isdigit((int) ((unsigned char) *expression)) != 0))) &&\n              (strchr(\"xy\",(int) ((unsigned char) *expression)) == (char *) NULL))\n            precedence=MultiplyPrecedence;\n          break;\n        }\n        case '*':\n        case '/':\n        case '%':\n        {\n          precedence=MultiplyPrecedence;\n          break;\n        }\n        case '+':\n        case '-':\n        {\n          if ((strchr(\"(+-/*%:&^|<>~,\",c) == (char *) NULL) ||\n              (isalpha(c) != 0))\n            precedence=AdditionPrecedence;\n          break;\n        }\n        case LeftShiftOperator:\n        case RightShiftOperator:\n        {\n          precedence=ShiftPrecedence;\n          break;\n        }\n        case '<':\n        case LessThanEqualOperator:\n        case GreaterThanEqualOperator:\n        case '>':\n        {\n          precedence=RelationalPrecedence;\n          break;\n        }\n        case EqualOperator:\n        case NotEqualOperator:\n        {\n          precedence=EquivalencyPrecedence;\n          break;\n        }\n        case '&':\n        {\n          precedence=BitwiseAndPrecedence;\n          break;\n        }\n        case '|':\n        {\n          precedence=BitwiseOrPrecedence;\n          break;\n        }\n        case LogicalAndOperator:\n        {\n          precedence=LogicalAndPrecedence;\n          break;\n        }\n        case LogicalOrOperator:\n        {\n          precedence=LogicalOrPrecedence;\n          break;\n        }\n        case ExponentialNotation:\n        {\n          precedence=ExponentialNotationPrecedence;\n          break;\n        }\n        case ':':\n        case '?':\n        {\n          precedence=TernaryPrecedence;\n          break;\n        }\n        case '=':\n        {\n          precedence=AssignmentPrecedence;\n          break;\n        }\n        case ',':\n        {\n          precedence=CommaPrecedence;\n          break;\n        }\n        case ';':\n        {\n          precedence=SeparatorPrecedence;\n          break;\n        }\n      }\n    if ((precedence == BitwiseComplementPrecedence) ||\n        (precedence == TernaryPrecedence) ||\n        (precedence == AssignmentPrecedence))\n      {\n        if (precedence > target)\n          {\n            /*\n              Right-to-left associativity.\n            */\n            target=precedence;\n            subexpression=expression;\n          }\n      }\n    else\n      if (precedence >= target)\n        {\n          /*\n            Left-to-right associativity.\n          */\n          target=precedence;\n          subexpression=expression;\n        }\n    if (strchr(\"(\",(int) *expression) != (char *) NULL)\n      expression=FxSubexpression(expression,exception);\n    c=(int) (*expression++);\n  }\n  return(subexpression);\n}\n\nstatic double FxEvaluateSubexpression(FxInfo *fx_info,\n  const PixelChannel channel,const ssize_t x,const ssize_t y,\n  const char *expression,size_t *depth,double *beta,ExceptionInfo *exception)\n{\n#define FxMaxParenthesisDepth  58\n\n  char\n    *q,\n    subexpression[MagickPathExtent];\n\n  double\n    alpha,\n    gamma;\n\n  register const char\n    *p;\n\n  *beta=0.0;\n  if (exception->severity >= ErrorException)\n    return(0.0);\n  while (isspace((int) ((unsigned char) *expression)) != 0)\n    expression++;\n  if (*expression == '\\0')\n    return(0.0);\n  *subexpression='\\0';\n  p=FxOperatorPrecedence(expression,exception);\n  if (p != (const char *) NULL)\n    {\n      (void) CopyMagickString(subexpression,expression,(size_t)\n        (p-expression+1));\n      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth,\n        beta,exception);\n      switch ((unsigned char) *p)\n      {\n        case '~':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) (~(size_t) *beta);\n          return(*beta);\n        }\n        case '!':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(*beta == 0.0 ? 1.0 : 0.0);\n        }\n        case '^':\n        {\n          *beta=pow(alpha,FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,\n            beta,exception));\n          return(*beta);\n        }\n        case '*':\n        case ExponentialNotation:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha*(*beta));\n        }\n        case '/':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          if (*beta == 0.0)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"DivideByZero\",\"`%s'\",expression);\n              return(0.0);\n            }\n          return(alpha/(*beta));\n        }\n        case '%':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=fabs(floor((*beta)+0.5));\n          if (*beta == 0.0)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"DivideByZero\",\"`%s'\",expression);\n              return(0.0);\n            }\n          return(fmod(alpha,*beta));\n        }\n        case '+':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha+(*beta));\n        }\n        case '-':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha-(*beta));\n        }\n        case LeftShiftOperator:\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) << (size_t) (gamma+0.5));\n          return(*beta);\n        }\n        case RightShiftOperator:\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) >> (size_t) (gamma+0.5));\n          return(*beta);\n        }\n        case '<':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha < *beta ? 1.0 : 0.0);\n        }\n        case LessThanEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha <= *beta ? 1.0 : 0.0);\n        }\n        case '>':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha > *beta ? 1.0 : 0.0);\n        }\n        case GreaterThanEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha >= *beta ? 1.0 : 0.0);\n        }\n        case EqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(fabs(alpha-(*beta)) < MagickEpsilon ? 1.0 : 0.0);\n        }\n        case NotEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(fabs(alpha-(*beta)) >= MagickEpsilon ? 1.0 : 0.0);\n        }\n        case '&':\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) & (size_t) (gamma+0.5));\n          return(*beta);\n        }\n        case '|':\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) | (size_t) (gamma+0.5));\n          return(*beta);\n        }\n        case LogicalAndOperator:\n        {\n          p++;\n          if (alpha <= 0.0)\n            {\n              *beta=0.0;\n              return(*beta);\n            }\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,beta,\n            exception);\n          *beta=(gamma > 0.0) ? 1.0 : 0.0;\n          return(*beta);\n        }\n        case LogicalOrOperator:\n        {\n          p++;\n          if (alpha > 0.0)\n            {\n             *beta=1.0;\n             return(*beta);\n            }\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,beta,\n            exception);\n          *beta=(gamma > 0.0) ? 1.0 : 0.0;\n          return(*beta);\n        }\n        case '?':\n        {\n          (void) CopyMagickString(subexpression,++p,MagickPathExtent);\n          q=subexpression;\n          p=StringToken(\":\",&q);\n          if (q == (char *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              return(0.0);\n            }\n          if (fabs(alpha) >= MagickEpsilon)\n            gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,beta,\n              exception);\n          else\n            gamma=FxEvaluateSubexpression(fx_info,channel,x,y,q,depth,beta,\n              exception);\n          return(gamma);\n        }\n        case '=':\n        {\n          char\n            numeric[MagickPathExtent];\n\n          q=subexpression;\n          while (isalpha((int) ((unsigned char) *q)) != 0)\n            q++;\n          if (*q != '\\0')\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              return(0.0);\n            }\n          ClearMagickException(exception);\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          (void) FormatLocaleString(numeric,MagickPathExtent,\"%g\",*beta);\n          (void) DeleteNodeFromSplayTree(fx_info->symbols,subexpression);\n          (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n            subexpression),ConstantString(numeric));\n          return(*beta);\n        }\n        case ',':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha);\n        }\n        case ';':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(*beta);\n        }\n        default:\n        {\n          gamma=alpha*FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,beta,\n            exception);\n          return(gamma);\n        }\n      }\n    }\n  if (strchr(\"(\",(int) *expression) != (char *) NULL)\n    {\n      (*depth)++;\n      if (*depth >= FxMaxParenthesisDepth)\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"ParenthesisNestedTooDeeply\",\"`%s'\",expression);\n      (void) CopyMagickString(subexpression,expression+1,MagickPathExtent);\n      subexpression[strlen(subexpression)-1]='\\0';\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth,\n        beta,exception);\n      (*depth)--;\n      return(gamma);\n    }\n  switch (*expression)\n  {\n    case '+':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth,beta,\n        exception);\n      return(1.0*gamma);\n    }\n    case '-':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth,beta,\n        exception);\n      return(-1.0*gamma);\n    }\n    case '~':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth,beta,\n        exception);\n      return((~(size_t) (gamma+0.5)));\n    }\n    case 'A':\n    case 'a':\n    {\n      if (LocaleNCompare(expression,\"abs\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(fabs(alpha));\n        }\n#if defined(MAGICKCORE_HAVE_ACOSH)\n      if (LocaleNCompare(expression,\"acosh\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(acosh(alpha));\n        }\n#endif\n      if (LocaleNCompare(expression,\"acos\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(acos(alpha));\n        }\n#if defined(MAGICKCORE_HAVE_J1)\n      if (LocaleNCompare(expression,\"airy\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          if (alpha == 0.0)\n            return(1.0);\n          gamma=2.0*j1((MagickPI*alpha))/(MagickPI*alpha);\n          return(gamma*gamma);\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_ASINH)\n      if (LocaleNCompare(expression,\"asinh\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(asinh(alpha));\n        }\n#endif\n      if (LocaleNCompare(expression,\"asin\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(asin(alpha));\n        }\n      if (LocaleNCompare(expression,\"alt\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(((ssize_t) alpha) & 0x01 ? -1.0 : 1.0);\n        }\n      if (LocaleNCompare(expression,\"atan2\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(atan2(alpha,*beta));\n        }\n#if defined(MAGICKCORE_HAVE_ATANH)\n      if (LocaleNCompare(expression,\"atanh\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(atanh(alpha));\n        }\n#endif\n      if (LocaleNCompare(expression,\"atan\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(atan(alpha));\n        }\n      if (LocaleCompare(expression,\"a\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(expression,\"b\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleNCompare(expression,\"ceil\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(ceil(alpha));\n        }\n      if (LocaleNCompare(expression,\"clamp\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          if (alpha < 0.0)\n            return(0.0);\n          if (alpha > 1.0)\n            return(1.0);\n          return(alpha);\n        }\n      if (LocaleNCompare(expression,\"cosh\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(cosh(alpha));\n        }\n      if (LocaleNCompare(expression,\"cos\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(cos(alpha));\n        }\n      if (LocaleCompare(expression,\"c\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleNCompare(expression,\"debug\",5) == 0)\n        {\n          const char\n            *type;\n\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          if (fx_info->images->colorspace == CMYKColorspace)\n            switch (channel)\n            {\n              case CyanPixelChannel: type=\"cyan\"; break;\n              case MagentaPixelChannel: type=\"magenta\"; break;\n              case YellowPixelChannel: type=\"yellow\"; break;\n              case AlphaPixelChannel: type=\"opacity\"; break;\n              case BlackPixelChannel: type=\"black\"; break;\n              default: type=\"unknown\"; break;\n            }\n          else\n            switch (channel)\n            {\n              case RedPixelChannel: type=\"red\"; break;\n              case GreenPixelChannel: type=\"green\"; break;\n              case BluePixelChannel: type=\"blue\"; break;\n              case AlphaPixelChannel: type=\"opacity\"; break;\n              default: type=\"unknown\"; break;\n            }\n          (void) CopyMagickString(subexpression,expression+6,MagickPathExtent);\n          if (strlen(subexpression) > 1)\n            subexpression[strlen(subexpression)-1]='\\0';\n          if (fx_info->file != (FILE *) NULL)\n            (void) FormatLocaleFile(fx_info->file,\"%s[%.20g,%.20g].%s: \"\n               \"%s=%.*g\\n\",fx_info->images->filename,(double) x,(double) y,type,\n               subexpression,GetMagickPrecision(),alpha);\n          return(0.0);\n        }\n      if (LocaleNCompare(expression,\"drc\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return((alpha/(*beta*(alpha-1.0)+1.0)));\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare(expression,\"epsilon\") == 0)\n        return(MagickEpsilon);\n#if defined(MAGICKCORE_HAVE_ERF)\n      if (LocaleNCompare(expression,\"erf\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(erf(alpha));\n        }\n#endif\n      if (LocaleNCompare(expression,\"exp\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(exp(alpha));\n        }\n      if (LocaleCompare(expression,\"e\") == 0)\n        return(2.7182818284590452354);\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(expression,\"floor\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(floor(alpha));\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleNCompare(expression,\"gauss\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          gamma=exp((-alpha*alpha/2.0))/sqrt(2.0*MagickPI);\n          return(gamma);\n        }\n      if (LocaleNCompare(expression,\"gcd\",3) == 0)\n        {\n          MagickOffsetType\n            gcd;\n\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          gcd=FxGCD((MagickOffsetType) (alpha+0.5),(MagickOffsetType) (*beta+\n            0.5));\n          return(gcd);\n        }\n      if (LocaleCompare(expression,\"g\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(expression,\"h\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      if (LocaleCompare(expression,\"hue\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      if (LocaleNCompare(expression,\"hypot\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(hypot(alpha,*beta));\n        }\n      break;\n    }\n    case 'K':\n    case 'k':\n    {\n      if (LocaleCompare(expression,\"k\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(expression,\"intensity\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      if (LocaleNCompare(expression,\"int\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(floor(alpha));\n        }\n      if (LocaleNCompare(expression,\"isnan\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(!!IsNaN(alpha));\n        }\n      if (LocaleCompare(expression,\"i\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'J':\n    case 'j':\n    {\n      if (LocaleCompare(expression,\"j\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n#if defined(MAGICKCORE_HAVE_J0)\n      if (LocaleNCompare(expression,\"j0\",2) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth,\n            beta,exception);\n          return(j0(alpha));\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_J1)\n      if (LocaleNCompare(expression,\"j1\",2) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth,\n            beta,exception);\n          return(j1(alpha));\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_J1)\n      if (LocaleNCompare(expression,\"jinc\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          if (alpha == 0.0)\n            return(1.0);\n          gamma=(2.0*j1((MagickPI*alpha))/(MagickPI*alpha));\n          return(gamma);\n        }\n#endif\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleNCompare(expression,\"ln\",2) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth,\n            beta,exception);\n          return(log(alpha));\n        }\n      if (LocaleNCompare(expression,\"logtwo\",6) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+6,depth,\n            beta,exception);\n          return(log10(alpha))/log10(2.0);\n        }\n      if (LocaleNCompare(expression,\"log\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(log10(alpha));\n        }\n      if (LocaleCompare(expression,\"lightness\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare(expression,\"MaxRGB\") == 0)\n        return(QuantumRange);\n      if (LocaleNCompare(expression,\"maxima\",6) == 0)\n        break;\n      if (LocaleNCompare(expression,\"max\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(alpha > *beta ? alpha : *beta);\n        }\n      if (LocaleNCompare(expression,\"minima\",6) == 0)\n        break;\n      if (LocaleNCompare(expression,\"min\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(alpha < *beta ? alpha : *beta);\n        }\n      if (LocaleNCompare(expression,\"mod\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          gamma=alpha-floor((alpha/(*beta)))*(*beta);\n          return(gamma);\n        }\n      if (LocaleCompare(expression,\"m\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'N':\n    case 'n':\n    {\n      if (LocaleNCompare(expression,\"not\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return((alpha < MagickEpsilon));\n        }\n      if (LocaleCompare(expression,\"n\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'O':\n    case 'o':\n    {\n      if (LocaleCompare(expression,\"Opaque\") == 0)\n        return(1.0);\n      if (LocaleCompare(expression,\"o\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(expression,\"phi\") == 0)\n        return(MagickPHI);\n      if (LocaleCompare(expression,\"pi\") == 0)\n        return(MagickPI);\n      if (LocaleNCompare(expression,\"pow\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(pow(alpha,*beta));\n        }\n      if (LocaleCompare(expression,\"p\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare(expression,\"QuantumRange\") == 0)\n        return(QuantumRange);\n      if (LocaleCompare(expression,\"QuantumScale\") == 0)\n        return(QuantumScale);\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleNCompare(expression,\"rand\",4) == 0)\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FxEvaluateSubexpression)\n#endif\n          alpha=GetPseudoRandomValue(fx_info->random_info);\n          return(alpha);\n        }\n      if (LocaleNCompare(expression,\"round\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(floor(alpha+0.5));\n        }\n      if (LocaleCompare(expression,\"r\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare(expression,\"saturation\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      if (LocaleNCompare(expression,\"sign\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(alpha < 0.0 ? -1.0 : 1.0);\n        }\n      if (LocaleNCompare(expression,\"sinc\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          if (alpha == 0)\n            return(1.0);\n          gamma=sin((MagickPI*alpha))/(MagickPI*alpha);\n          return(gamma);\n        }\n      if (LocaleNCompare(expression,\"sinh\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(sinh(alpha));\n        }\n      if (LocaleNCompare(expression,\"sin\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(sin(alpha));\n        }\n      if (LocaleNCompare(expression,\"sqrt\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(sqrt(alpha));\n        }\n      if (LocaleNCompare(expression,\"squish\",6) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+6,depth,\n            beta,exception);\n          return((1.0/(1.0+exp(-alpha))));\n        }\n      if (LocaleCompare(expression,\"s\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleNCompare(expression,\"tanh\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(tanh(alpha));\n        }\n      if (LocaleNCompare(expression,\"tan\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(tan(alpha));\n        }\n      if (LocaleCompare(expression,\"Transparent\") == 0)\n        return(0.0);\n      if (LocaleNCompare(expression,\"trunc\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          if (alpha >= 0.0)\n            return(floor(alpha));\n          return(ceil(alpha));\n        }\n      if (LocaleCompare(expression,\"t\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(expression,\"u\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(expression,\"v\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleNCompare(expression,\"while\",5) == 0)\n        {\n          do\n          {\n            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n              depth,beta,exception);\n          } while (fabs(alpha) >= MagickEpsilon);\n          return(*beta);\n        }\n      if (LocaleCompare(expression,\"w\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'Y':\n    case 'y':\n    {\n      if (LocaleCompare(expression,\"y\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'Z':\n    case 'z':\n    {\n      if (LocaleCompare(expression,\"z\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    default:\n      break;\n  }\n  q=(char *) expression;\n  alpha=InterpretSiPrefixValue(expression,&q);\n  if (q == expression)\n    return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n  return(alpha);\n}\n\nMagickPrivate MagickBooleanType FxEvaluateExpression(FxInfo *fx_info,\n  double *alpha,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=FxEvaluateChannelExpression(fx_info,GrayPixelChannel,0,0,alpha,\n    exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType FxPreprocessExpression(FxInfo *fx_info,\n  double *alpha,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  MagickBooleanType\n    status;\n\n  file=fx_info->file;\n  fx_info->file=(FILE *) NULL;\n  status=FxEvaluateChannelExpression(fx_info,GrayPixelChannel,0,0,alpha,\n    exception);\n  fx_info->file=file;\n  return(status);\n}\n\nMagickPrivate MagickBooleanType FxEvaluateChannelExpression(FxInfo *fx_info,\n  const PixelChannel channel,const ssize_t x,const ssize_t y,\n  double *alpha,ExceptionInfo *exception)\n{\n  double\n    beta;\n\n  size_t\n    depth;\n\n  depth=0;\n  beta=0.0;\n  *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,fx_info->expression,&depth,\n    &beta,exception);\n  return(exception->severity == OptionError ? MagickFalse : MagickTrue);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F x I m a g e                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FxImage() applies a mathematical expression to the specified image.\n%\n%  The format of the FxImage method is:\n%\n%      Image *FxImage(const Image *image,const char *expression,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o expression: A mathematical expression.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic FxInfo **DestroyFxThreadSet(FxInfo **fx_info)\n{\n  register ssize_t\n    i;\n\n  assert(fx_info != (FxInfo **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (fx_info[i] != (FxInfo *) NULL)\n      fx_info[i]=DestroyFxInfo(fx_info[i]);\n  fx_info=(FxInfo **) RelinquishMagickMemory(fx_info);\n  return(fx_info);\n}\n\nstatic FxInfo **AcquireFxThreadSet(const Image *image,const char *expression,\n  ExceptionInfo *exception)\n{\n  char\n    *fx_expression;\n\n  FxInfo\n    **fx_info;\n\n  double\n    alpha;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  fx_info=(FxInfo **) AcquireQuantumMemory(number_threads,sizeof(*fx_info));\n  if (fx_info == (FxInfo **) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return((FxInfo **) NULL);\n    }\n  (void) ResetMagickMemory(fx_info,0,number_threads*sizeof(*fx_info));\n  if (*expression != '@')\n    fx_expression=ConstantString(expression);\n  else\n    fx_expression=FileToString(expression+1,~0UL,exception);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    MagickBooleanType\n      status;\n\n    fx_info[i]=AcquireFxInfo(image,fx_expression,exception);\n    if (fx_info[i] == (FxInfo *) NULL)\n      break;\n    status=FxPreprocessExpression(fx_info[i],&alpha,exception);\n    if (status == MagickFalse)\n      break;\n  }\n  fx_expression=DestroyString(fx_expression);\n  if (i < (ssize_t) number_threads)\n    fx_info=DestroyFxThreadSet(fx_info);\n  return(fx_info);\n}\n\nMagickExport Image *FxImage(const Image *image,const char *expression,\n  ExceptionInfo *exception)\n{\n#define FxImageTag  \"Fx/Image\"\n\n  CacheView\n    *fx_view,\n    *image_view;\n\n  FxInfo\n    **magick_restrict fx_info;\n\n  Image\n    *fx_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  fx_info=AcquireFxThreadSet(image,expression,exception);\n  if (fx_info == (FxInfo **) NULL)\n    return((Image *) NULL);\n  fx_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (fx_image == (Image *) NULL)\n    {\n      fx_info=DestroyFxThreadSet(fx_info);\n      return((Image *) NULL);\n    }\n  if (SetImageStorageClass(fx_image,DirectClass,exception) == MagickFalse)\n    {\n      fx_info=DestroyFxThreadSet(fx_info);\n      fx_image=DestroyImage(fx_image);\n      return((Image *) NULL);\n    }\n  /*\n    Fx image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  fx_view=AcquireAuthenticCacheView(fx_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,fx_image,fx_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) fx_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(fx_view,0,y,fx_image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) fx_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          alpha;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait fx_traits=GetPixelChannelTraits(fx_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (fx_traits == UndefinedPixelTrait))\n          continue;\n        if (((fx_traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(image,p) == 0))\n          {\n            SetPixelChannel(fx_image,channel,p[i],q);\n            continue;\n          }\n        alpha=0.0;\n        (void) FxEvaluateChannelExpression(fx_info[id],channel,x,y,&alpha,\n          exception);\n        q[i]=ClampToQuantum(QuantumRange*alpha);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(fx_image);\n    }\n    if (SyncCacheViewAuthenticPixels(fx_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FxImage)\n#endif\n        proceed=SetImageProgress(image,FxImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  fx_view=DestroyCacheView(fx_view);\n  image_view=DestroyCacheView(image_view);\n  fx_info=DestroyFxThreadSet(fx_info);\n  if (status == MagickFalse)\n    fx_image=DestroyImage(fx_image);\n  return(fx_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I m p l o d e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImplodeImage() creates a new image that is a copy of an existing\n%  one with the image pixels \"implode\" by the specified percentage.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ImplodeImage method is:\n%\n%      Image *ImplodeImage(const Image *image,const double amount,\n%        const PixelInterpolateMethod method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o implode_image: Method ImplodeImage returns a pointer to the image\n%      after it is implode.  A null image is returned if there is a memory\n%      shortage.\n%\n%    o image: the image.\n%\n%    o amount:  Define the extent of the implosion.\n%\n%    o method: the pixel interpolation method.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ImplodeImage(const Image *image,const double amount,\n  const PixelInterpolateMethod method,ExceptionInfo *exception)\n{\n#define ImplodeImageTag  \"Implode/Image\"\n\n  CacheView\n    *image_view,\n    *implode_view,\n    *interpolate_view;\n\n  Image\n    *implode_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  double\n    radius;\n\n  PointInfo\n    center,\n    scale;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize implode image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  implode_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception);\n  if (implode_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(implode_image,DirectClass,exception) == MagickFalse)\n    {\n      implode_image=DestroyImage(implode_image);\n      return((Image *) NULL);\n    }\n  if (implode_image->background_color.alpha != OpaqueAlpha)\n    implode_image->alpha_trait=BlendPixelTrait;\n  /*\n    Compute scaling factor.\n  */\n  scale.x=1.0;\n  scale.y=1.0;\n  center.x=0.5*image->columns;\n  center.y=0.5*image->rows;\n  radius=center.x;\n  if (image->columns > image->rows)\n    scale.y=(double) image->columns/(double) image->rows;\n  else\n    if (image->columns < image->rows)\n      {\n        scale.x=(double) image->rows/(double) image->columns;\n        radius=center.y;\n      }\n  /*\n    Implode image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  interpolate_view=AcquireVirtualCacheView(image,exception);\n  implode_view=AcquireAuthenticCacheView(implode_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,implode_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      distance;\n\n    PointInfo\n      delta;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(implode_view,0,y,implode_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    delta.y=scale.y*(double) (y-center.y);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      /*\n        Determine if the pixel is within an ellipse.\n      */\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(implode_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(implode_image);\n          continue;\n        }\n      delta.x=scale.x*(double) (x-center.x);\n      distance=delta.x*delta.x+delta.y*delta.y;\n      if (distance >= (radius*radius))\n        for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n        {\n          PixelChannel channel=GetPixelChannelChannel(image,i);\n          PixelTrait traits=GetPixelChannelTraits(image,channel);\n          PixelTrait implode_traits=GetPixelChannelTraits(implode_image,\n            channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (implode_traits == UndefinedPixelTrait))\n            continue;\n          SetPixelChannel(implode_image,channel,p[i],q);\n        }\n      else\n        {\n          double\n            factor;\n\n          /*\n            Implode the pixel.\n          */\n          factor=1.0;\n          if (distance > 0.0)\n            factor=pow(sin(MagickPI*sqrt((double) distance)/radius/2),-amount);\n          status=InterpolatePixelChannels(image,interpolate_view,implode_image,\n            method,(double) (factor*delta.x/scale.x+center.x),(double) (factor*\n            delta.y/scale.y+center.y),q,exception);\n        }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(implode_image);\n    }\n    if (SyncCacheViewAuthenticPixels(implode_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ImplodeImage)\n#endif\n        proceed=SetImageProgress(image,ImplodeImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  implode_view=DestroyCacheView(implode_view);\n  interpolate_view=DestroyCacheView(interpolate_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    implode_image=DestroyImage(implode_image);\n  return(implode_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     M o r p h I m a g e s                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  The MorphImages() method requires a minimum of two images.  The first\n%  image is transformed into the second by a number of intervening images\n%  as specified by frames.\n%\n%  The format of the MorphImage method is:\n%\n%      Image *MorphImages(const Image *image,const size_t number_frames,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o number_frames:  Define the number of in-between image to generate.\n%      The more in-between frames, the smoother the morph.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *MorphImages(const Image *image,const size_t number_frames,\n  ExceptionInfo *exception)\n{\n#define MorphImageTag  \"Morph/Image\"\n\n  double\n    alpha,\n    beta;\n\n  Image\n    *morph_image,\n    *morph_images;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  register const Image\n    *next;\n\n  register ssize_t\n    n;\n\n  ssize_t\n    y;\n\n  /*\n    Clone first frame in sequence.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  morph_images=CloneImage(image,0,0,MagickTrue,exception);\n  if (morph_images == (Image *) NULL)\n    return((Image *) NULL);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    {\n      /*\n        Morph single image.\n      */\n      for (n=1; n < (ssize_t) number_frames; n++)\n      {\n        morph_image=CloneImage(image,0,0,MagickTrue,exception);\n        if (morph_image == (Image *) NULL)\n          {\n            morph_images=DestroyImageList(morph_images);\n            return((Image *) NULL);\n          }\n        AppendImageToList(&morph_images,morph_image);\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,MorphImageTag,(MagickOffsetType) n,\n              number_frames);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      return(GetFirstImageInList(morph_images));\n    }\n  /*\n    Morph image sequence.\n  */\n  status=MagickTrue;\n  scene=0;\n  next=image;\n  for ( ; GetNextImageInList(next) != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    for (n=0; n < (ssize_t) number_frames; n++)\n    {\n      CacheView\n        *image_view,\n        *morph_view;\n\n      beta=(double) (n+1.0)/(double) (number_frames+1.0);\n      alpha=1.0-beta;\n      morph_image=ResizeImage(next,(size_t) (alpha*next->columns+beta*\n        GetNextImageInList(next)->columns+0.5),(size_t) (alpha*next->rows+beta*\n        GetNextImageInList(next)->rows+0.5),next->filter,exception);\n      if (morph_image == (Image *) NULL)\n        {\n          morph_images=DestroyImageList(morph_images);\n          return((Image *) NULL);\n        }\n      status=SetImageStorageClass(morph_image,DirectClass,exception);\n      if (status == MagickFalse)\n        {\n          morph_image=DestroyImage(morph_image);\n          return((Image *) NULL);\n        }\n      AppendImageToList(&morph_images,morph_image);\n      morph_images=GetLastImageInList(morph_images);\n      morph_image=ResizeImage(GetNextImageInList(next),morph_images->columns,\n        morph_images->rows,GetNextImageInList(next)->filter,exception);\n      if (morph_image == (Image *) NULL)\n        {\n          morph_images=DestroyImageList(morph_images);\n          return((Image *) NULL);\n        }\n      image_view=AcquireVirtualCacheView(morph_image,exception);\n      morph_view=AcquireAuthenticCacheView(morph_images,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(morph_image,morph_image,morph_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) morph_images->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *magick_restrict p;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *magick_restrict q;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(image_view,0,y,morph_image->columns,1,\n          exception);\n        q=GetCacheViewAuthenticPixels(morph_view,0,y,morph_images->columns,1,\n          exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) morph_images->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(morph_image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(morph_image,i);\n            PixelTrait traits=GetPixelChannelTraits(morph_image,channel);\n            PixelTrait morph_traits=GetPixelChannelTraits(morph_images,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (morph_traits == UndefinedPixelTrait))\n              continue;\n            if (((morph_traits & CopyPixelTrait) != 0) ||\n                (GetPixelReadMask(morph_images,p) == 0))\n              {\n                SetPixelChannel(morph_image,channel,p[i],q);\n                continue;\n              }\n            SetPixelChannel(morph_image,channel,ClampToQuantum(alpha*\n              GetPixelChannel(morph_images,channel,q)+beta*p[i]),q);\n          }\n          p+=GetPixelChannels(morph_image);\n          q+=GetPixelChannels(morph_images);\n        }\n        sync=SyncCacheViewAuthenticPixels(morph_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n      }\n      morph_view=DestroyCacheView(morph_view);\n      image_view=DestroyCacheView(image_view);\n      morph_image=DestroyImage(morph_image);\n    }\n    if (n < (ssize_t) number_frames)\n      break;\n    /*\n      Clone last frame in sequence.\n    */\n    morph_image=CloneImage(GetNextImageInList(next),0,0,MagickTrue,exception);\n    if (morph_image == (Image *) NULL)\n      {\n        morph_images=DestroyImageList(morph_images);\n        return((Image *) NULL);\n      }\n    AppendImageToList(&morph_images,morph_image);\n    morph_images=GetLastImageInList(morph_images);\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_MorphImages)\n#endif\n        proceed=SetImageProgress(image,MorphImageTag,scene,\n          GetImageListLength(image));\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n    scene++;\n  }\n  if (GetNextImageInList(next) != (Image *) NULL)\n    {\n      morph_images=DestroyImageList(morph_images);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(morph_images));\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P l a s m a I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PlasmaImage() initializes an image with plasma fractal values.  The image\n%  must be initialized with a base color and the random number generator\n%  seeded before this method is called.\n%\n%  The format of the PlasmaImage method is:\n%\n%      MagickBooleanType PlasmaImage(Image *image,const SegmentInfo *segment,\n%        size_t attenuate,size_t depth,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o segment:   Define the region to apply plasma fractals values.\n%\n%    o attenuate: Define the plasma attenuation factor.\n%\n%    o depth: Limit the plasma recursion depth.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PlasmaPixel(RandomInfo *random_info,\n  const double pixel,const double noise)\n{\n  Quantum\n    plasma;\n\n  plasma=ClampToQuantum(pixel+noise*GetPseudoRandomValue(random_info)-\n    noise/2.0);\n  if (plasma <= 0)\n    return((Quantum) 0);\n  if (plasma >= QuantumRange)\n    return(QuantumRange);\n  return(plasma);\n}\n\nstatic MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,\n  CacheView *u_view,CacheView *v_view,RandomInfo *random_info,\n  const SegmentInfo *segment,size_t attenuate,size_t depth,\n  ExceptionInfo *exception)\n{\n  double\n    plasma;\n\n  register const Quantum\n    *magick_restrict u,\n    *magick_restrict v;\n\n  register Quantum\n    *magick_restrict q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    x,\n    x_mid,\n    y,\n    y_mid;\n\n  if ((fabs(segment->x2-segment->x1) <= MagickEpsilon) &&\n      (fabs(segment->y2-segment->y1) <= MagickEpsilon))\n    return(MagickTrue);\n  if (depth != 0)\n    {\n      MagickBooleanType\n        status;\n\n      SegmentInfo\n        local_info;\n\n      /*\n        Divide the area into quadrants and recurse.\n      */\n      depth--;\n      attenuate++;\n      x_mid=(ssize_t) ceil((segment->x1+segment->x2)/2-0.5);\n      y_mid=(ssize_t) ceil((segment->y1+segment->y2)/2-0.5);\n      local_info=(*segment);\n      local_info.x2=(double) x_mid;\n      local_info.y2=(double) y_mid;\n      (void) PlasmaImageProxy(image,image_view,u_view,v_view,random_info,\n        &local_info,attenuate,depth,exception);\n      local_info=(*segment);\n      local_info.y1=(double) y_mid;\n      local_info.x2=(double) x_mid;\n      (void) PlasmaImageProxy(image,image_view,u_view,v_view,random_info,\n        &local_info,attenuate,depth,exception);\n      local_info=(*segment);\n      local_info.x1=(double) x_mid;\n      local_info.y2=(double) y_mid;\n      (void) PlasmaImageProxy(image,image_view,u_view,v_view,random_info,\n        &local_info,attenuate,depth,exception);\n      local_info=(*segment);\n      local_info.x1=(double) x_mid;\n      local_info.y1=(double) y_mid;\n      status=PlasmaImageProxy(image,image_view,u_view,v_view,random_info,\n        &local_info,attenuate,depth,exception);\n      return(status);\n    }\n  x_mid=(ssize_t) ceil((segment->x1+segment->x2)/2-0.5);\n  y_mid=(ssize_t) ceil((segment->y1+segment->y2)/2-0.5);\n  if ((fabs(segment->x1-x_mid) < MagickEpsilon) &&\n      (fabs(segment->x2-x_mid) < MagickEpsilon) &&\n      (fabs(segment->y1-y_mid) < MagickEpsilon) &&\n      (fabs(segment->y2-y_mid) < MagickEpsilon))\n    return(MagickFalse);\n  /*\n    Average pixels and apply plasma.\n  */\n  plasma=(double) QuantumRange/(2.0*attenuate);\n  if ((fabs(segment->x1-x_mid) > MagickEpsilon) ||\n      (fabs(segment->x2-x_mid) > MagickEpsilon))\n    {\n      /*\n        Left pixel.\n      */\n      x=(ssize_t) ceil(segment->x1-0.5);\n      u=GetCacheViewVirtualPixels(u_view,x,(ssize_t) ceil(segment->y1-0.5),1,1,\n        exception);\n      v=GetCacheViewVirtualPixels(v_view,x,(ssize_t) ceil(segment->y2-0.5),1,1,\n        exception);\n      q=QueueCacheViewAuthenticPixels(image_view,x,y_mid,1,1,exception);\n      if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n          (q == (Quantum *) NULL))\n        return(MagickTrue);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n      }\n      (void) SyncCacheViewAuthenticPixels(image_view,exception);\n      if (fabs(segment->x1-segment->x2) > MagickEpsilon)\n        {\n          /*\n            Right pixel.\n          */\n          x=(ssize_t) ceil(segment->x2-0.5);\n          u=GetCacheViewVirtualPixels(u_view,x,(ssize_t) ceil(segment->y1-0.5),\n            1,1,exception);\n          v=GetCacheViewVirtualPixels(v_view,x,(ssize_t) ceil(segment->y2-0.5),\n            1,1,exception);\n          q=QueueCacheViewAuthenticPixels(image_view,x,y_mid,1,1,exception);\n          if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n              (q == (Quantum *) NULL))\n            return(MagickTrue);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n          }\n          (void) SyncCacheViewAuthenticPixels(image_view,exception);\n        }\n    }\n  if ((fabs(segment->y1-y_mid) > MagickEpsilon) ||\n      (fabs(segment->y2-y_mid) > MagickEpsilon))\n    {\n      if ((fabs(segment->x1-x_mid) > MagickEpsilon) ||\n          (fabs(segment->y2-y_mid) > MagickEpsilon))\n        {\n          /*\n            Bottom pixel.\n          */\n          y=(ssize_t) ceil(segment->y2-0.5);\n          u=GetCacheViewVirtualPixels(u_view,(ssize_t) ceil(segment->x1-0.5),y,\n            1,1,exception);\n          v=GetCacheViewVirtualPixels(v_view,(ssize_t) ceil(segment->x2-0.5),y,\n            1,1,exception);\n          q=QueueCacheViewAuthenticPixels(image_view,x_mid,y,1,1,exception);\n          if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n              (q == (Quantum *) NULL))\n            return(MagickTrue);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n          }\n          (void) SyncCacheViewAuthenticPixels(image_view,exception);\n        }\n      if (fabs(segment->y1-segment->y2) > MagickEpsilon)\n        {\n          /*\n            Top pixel.\n          */\n          y=(ssize_t) ceil(segment->y1-0.5);\n          u=GetCacheViewVirtualPixels(u_view,(ssize_t) ceil(segment->x1-0.5),y,\n            1,1,exception);\n          v=GetCacheViewVirtualPixels(v_view,(ssize_t) ceil(segment->x2-0.5),y,\n            1,1,exception);\n          q=QueueCacheViewAuthenticPixels(image_view,x_mid,y,1,1,exception);\n          if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n              (q == (Quantum *) NULL))\n            return(MagickTrue);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n          }\n          (void) SyncCacheViewAuthenticPixels(image_view,exception);\n        }\n    }\n  if ((fabs(segment->x1-segment->x2) > MagickEpsilon) ||\n      (fabs(segment->y1-segment->y2) > MagickEpsilon))\n    {\n      /*\n        Middle pixel.\n      */\n      x=(ssize_t) ceil(segment->x1-0.5);\n      y=(ssize_t) ceil(segment->y1-0.5);\n      u=GetCacheViewVirtualPixels(u_view,x,y,1,1,exception);\n      x=(ssize_t) ceil(segment->x2-0.5);\n      y=(ssize_t) ceil(segment->y2-0.5);\n      v=GetCacheViewVirtualPixels(v_view,x,y,1,1,exception);\n      q=QueueCacheViewAuthenticPixels(image_view,x_mid,y_mid,1,1,exception);\n      if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n          (q == (Quantum *) NULL))\n        return(MagickTrue);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n      }\n      (void) SyncCacheViewAuthenticPixels(image_view,exception);\n    }\n  if ((fabs(segment->x2-segment->x1) < 3.0) &&\n      (fabs(segment->y2-segment->y1) < 3.0))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nMagickExport MagickBooleanType PlasmaImage(Image *image,\n  const SegmentInfo *segment,size_t attenuate,size_t depth,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view,\n    *u_view,\n    *v_view;\n\n  MagickBooleanType\n    status;\n\n  RandomInfo\n    *random_info;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  image_view=AcquireAuthenticCacheView(image,exception);\n  u_view=AcquireVirtualCacheView(image,exception);\n  v_view=AcquireVirtualCacheView(image,exception);\n  random_info=AcquireRandomInfo();\n  status=PlasmaImageProxy(image,image_view,u_view,v_view,random_info,segment,\n    attenuate,depth,exception);\n  random_info=DestroyRandomInfo(random_info);\n  v_view=DestroyCacheView(v_view);\n  u_view=DestroyCacheView(u_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P o l a r o i d I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PolaroidImage() simulates a Polaroid picture.\n%\n%  The format of the PolaroidImage method is:\n%\n%      Image *PolaroidImage(const Image *image,const DrawInfo *draw_info,\n%        const char *caption,const double angle,\n%        const PixelInterpolateMethod method,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o caption: the Polaroid caption.\n%\n%    o angle: Apply the effect along this angle.\n%\n%    o method: the pixel interpolation method.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *PolaroidImage(const Image *image,const DrawInfo *draw_info,\n  const char *caption,const double angle,const PixelInterpolateMethod method,\n  ExceptionInfo *exception)\n{\n  Image\n    *bend_image,\n    *caption_image,\n    *flop_image,\n    *picture_image,\n    *polaroid_image,\n    *rotate_image,\n    *trim_image;\n\n  size_t\n    height;\n\n  ssize_t\n    quantum;\n\n  /*\n    Simulate a Polaroid picture.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  quantum=(ssize_t) MagickMax(MagickMax((double) image->columns,(double)\n    image->rows)/25.0,10.0);\n  height=image->rows+2*quantum;\n  caption_image=(Image *) NULL;\n  if (caption != (const char *) NULL)\n    {\n      char\n        geometry[MagickPathExtent],\n        *text;\n\n      DrawInfo\n        *annotate_info;\n\n      ImageInfo\n        *image_info;\n\n      MagickBooleanType\n        status;\n\n      ssize_t\n        count;\n\n      TypeMetric\n        metrics;\n\n      /*\n        Generate caption image.\n      */\n      caption_image=CloneImage(image,image->columns,1,MagickTrue,exception);\n      if (caption_image == (Image *) NULL)\n        return((Image *) NULL);\n      image_info=AcquireImageInfo();\n      annotate_info=CloneDrawInfo((const ImageInfo *) NULL,draw_info);\n      text=InterpretImageProperties(image_info,(Image *) image,caption,\n        exception);\n      image_info=DestroyImageInfo(image_info);\n      (void) CloneString(&annotate_info->text,text);\n      count=FormatMagickCaption(caption_image,annotate_info,MagickTrue,&metrics,\n        &text,exception);\n      status=SetImageExtent(caption_image,image->columns,(size_t) ((count+1)*\n        (metrics.ascent-metrics.descent)+0.5),exception);\n      if (status == MagickFalse)\n        caption_image=DestroyImage(caption_image);\n      else\n        {\n          caption_image->background_color=image->border_color;\n          (void) SetImageBackgroundColor(caption_image,exception);\n          (void) CloneString(&annotate_info->text,text);\n          (void) FormatLocaleString(geometry,MagickPathExtent,\"+0+%g\",\n            metrics.ascent);\n          if (annotate_info->gravity == UndefinedGravity)\n            (void) CloneString(&annotate_info->geometry,AcquireString(\n              geometry));\n          (void) AnnotateImage(caption_image,annotate_info,exception);\n          height+=caption_image->rows;\n        }\n      annotate_info=DestroyDrawInfo(annotate_info);\n      text=DestroyString(text);\n    }\n  picture_image=CloneImage(image,image->columns+2*quantum,height,MagickTrue,\n    exception);\n  if (picture_image == (Image *) NULL)\n    {\n      if (caption_image != (Image *) NULL)\n        caption_image=DestroyImage(caption_image);\n      return((Image *) NULL);\n    }\n  picture_image->background_color=image->border_color;\n  (void) SetImageBackgroundColor(picture_image,exception);\n  (void) CompositeImage(picture_image,image,OverCompositeOp,MagickTrue,quantum,\n    quantum,exception);\n  if (caption_image != (Image *) NULL)\n    {\n      (void) CompositeImage(picture_image,caption_image,OverCompositeOp,\n        MagickTrue,quantum,(ssize_t) (image->rows+3*quantum/2),exception);\n      caption_image=DestroyImage(caption_image);\n    }\n  (void) QueryColorCompliance(\"none\",AllCompliance,\n    &picture_image->background_color,exception);\n  (void) SetImageAlphaChannel(picture_image,OpaqueAlphaChannel,exception);\n  rotate_image=RotateImage(picture_image,90.0,exception);\n  picture_image=DestroyImage(picture_image);\n  if (rotate_image == (Image *) NULL)\n    return((Image *) NULL);\n  picture_image=rotate_image;\n  bend_image=WaveImage(picture_image,0.01*picture_image->rows,2.0*\n    picture_image->columns,method,exception);\n  picture_image=DestroyImage(picture_image);\n  if (bend_image == (Image *) NULL)\n    return((Image *) NULL);\n  picture_image=bend_image;\n  rotate_image=RotateImage(picture_image,-90.0,exception);\n  picture_image=DestroyImage(picture_image);\n  if (rotate_image == (Image *) NULL)\n    return((Image *) NULL);\n  picture_image=rotate_image;\n  picture_image->background_color=image->background_color;\n  polaroid_image=ShadowImage(picture_image,80.0,2.0,quantum/3,quantum/3,\n    exception);\n  if (polaroid_image == (Image *) NULL)\n    {\n      picture_image=DestroyImage(picture_image);\n      return(picture_image);\n    }\n  flop_image=FlopImage(polaroid_image,exception);\n  polaroid_image=DestroyImage(polaroid_image);\n  if (flop_image == (Image *) NULL)\n    {\n      picture_image=DestroyImage(picture_image);\n      return(picture_image);\n    }\n  polaroid_image=flop_image;\n  (void) CompositeImage(polaroid_image,picture_image,OverCompositeOp,\n    MagickTrue,(ssize_t) (-0.01*picture_image->columns/2.0),0L,exception);\n  picture_image=DestroyImage(picture_image);\n  (void) QueryColorCompliance(\"none\",AllCompliance,\n    &polaroid_image->background_color,exception);\n  rotate_image=RotateImage(polaroid_image,angle,exception);\n  polaroid_image=DestroyImage(polaroid_image);\n  if (rotate_image == (Image *) NULL)\n    return((Image *) NULL);\n  polaroid_image=rotate_image;\n  trim_image=TrimImage(polaroid_image,exception);\n  polaroid_image=DestroyImage(polaroid_image);\n  if (trim_image == (Image *) NULL)\n    return((Image *) NULL);\n  polaroid_image=trim_image;\n  return(polaroid_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S e p i a T o n e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickSepiaToneImage() applies a special effect to the image, similar to the\n%  effect achieved in a photo darkroom by sepia toning.  Threshold ranges from\n%  0 to QuantumRange and is a measure of the extent of the sepia toning.  A\n%  threshold of 80% is a good starting point for a reasonable tone.\n%\n%  The format of the SepiaToneImage method is:\n%\n%      Image *SepiaToneImage(const Image *image,const double threshold,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: the tone threshold.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SepiaToneImage(const Image *image,const double threshold,\n  ExceptionInfo *exception)\n{\n#define SepiaToneImageTag  \"SepiaTone/Image\"\n\n  CacheView\n    *image_view,\n    *sepia_view;\n\n  Image\n    *sepia_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize sepia-toned image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  sepia_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (sepia_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(sepia_image,DirectClass,exception) == MagickFalse)\n    {\n      sepia_image=DestroyImage(sepia_image);\n      return((Image *) NULL);\n    }\n  /*\n    Tone each row of the image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  sepia_view=AcquireAuthenticCacheView(sepia_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,sepia_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(sepia_view,0,y,sepia_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        intensity,\n        tone;\n\n      intensity=GetPixelIntensity(image,p);\n      tone=intensity > threshold ? (double) QuantumRange : intensity+\n        (double) QuantumRange-threshold;\n      SetPixelRed(sepia_image,ClampToQuantum(tone),q);\n      tone=intensity > (7.0*threshold/6.0) ? (double) QuantumRange :\n        intensity+(double) QuantumRange-7.0*threshold/6.0;\n      SetPixelGreen(sepia_image,ClampToQuantum(tone),q);\n      tone=intensity < (threshold/6.0) ? 0 : intensity-threshold/6.0;\n      SetPixelBlue(sepia_image,ClampToQuantum(tone),q);\n      tone=threshold/7.0;\n      if ((double) GetPixelGreen(image,q) < tone)\n        SetPixelGreen(sepia_image,ClampToQuantum(tone),q);\n      if ((double) GetPixelBlue(image,q) < tone)\n        SetPixelBlue(sepia_image,ClampToQuantum(tone),q);\n      SetPixelAlpha(sepia_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(sepia_image);\n    }\n    if (SyncCacheViewAuthenticPixels(sepia_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SepiaToneImage)\n#endif\n        proceed=SetImageProgress(image,SepiaToneImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  sepia_view=DestroyCacheView(sepia_view);\n  image_view=DestroyCacheView(image_view);\n  (void) NormalizeImage(sepia_image,exception);\n  (void) ContrastImage(sepia_image,MagickTrue,exception);\n  if (status == MagickFalse)\n    sepia_image=DestroyImage(sepia_image);\n  return(sepia_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S h a d o w I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ShadowImage() simulates a shadow from the specified image and returns it.\n%\n%  The format of the ShadowImage method is:\n%\n%      Image *ShadowImage(const Image *image,const double alpha,\n%        const double sigma,const ssize_t x_offset,const ssize_t y_offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o alpha: percentage transparency.\n%\n%    o sigma: the standard deviation of the Gaussian, in pixels.\n%\n%    o x_offset: the shadow x-offset.\n%\n%    o y_offset: the shadow y-offset.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ShadowImage(const Image *image,const double alpha,\n  const double sigma,const ssize_t x_offset,const ssize_t y_offset,\n  ExceptionInfo *exception)\n{\n#define ShadowImageTag  \"Shadow/Image\"\n\n  CacheView\n    *image_view;\n\n  ChannelType\n    channel_mask;\n\n  Image\n    *border_image,\n    *clone_image,\n    *shadow_image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    background_color;\n\n  RectangleInfo\n    border_info;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  clone_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (clone_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(clone_image,sRGBColorspace,exception);\n  (void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod,\n    exception);\n  border_info.width=(size_t) floor(2.0*sigma+0.5);\n  border_info.height=(size_t) floor(2.0*sigma+0.5);\n  border_info.x=0;\n  border_info.y=0;\n  (void) QueryColorCompliance(\"none\",AllCompliance,&clone_image->border_color,\n    exception);\n  clone_image->alpha_trait=BlendPixelTrait;\n  border_image=BorderImage(clone_image,&border_info,OverCompositeOp,exception);\n  clone_image=DestroyImage(clone_image);\n  if (border_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (border_image->alpha_trait == UndefinedPixelTrait)\n    (void) SetImageAlphaChannel(border_image,OpaqueAlphaChannel,exception);\n  /*\n    Shadow image.\n  */\n  status=MagickTrue;\n  background_color=border_image->background_color;\n  background_color.alpha_trait=BlendPixelTrait;\n  image_view=AcquireAuthenticCacheView(border_image,exception);\n  for (y=0; y < (ssize_t) border_image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,border_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) border_image->columns; x++)\n    {\n      if (border_image->alpha_trait != UndefinedPixelTrait)\n        background_color.alpha=GetPixelAlpha(border_image,q)*alpha/100.0;\n      SetPixelViaPixelInfo(border_image,&background_color,q);\n      q+=GetPixelChannels(border_image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    {\n      border_image=DestroyImage(border_image);\n      return((Image *) NULL);\n    }\n  channel_mask=SetImageChannelMask(border_image,AlphaChannel);\n  shadow_image=BlurImage(border_image,0.0,sigma,exception);\n  border_image=DestroyImage(border_image);\n  if (shadow_image == (Image *) NULL)\n    return((Image *) NULL);\n  (void) SetPixelChannelMask(shadow_image,channel_mask);\n  if (shadow_image->page.width == 0)\n    shadow_image->page.width=shadow_image->columns;\n  if (shadow_image->page.height == 0)\n    shadow_image->page.height=shadow_image->rows;\n  shadow_image->page.width+=x_offset-(ssize_t) border_info.width;\n  shadow_image->page.height+=y_offset-(ssize_t) border_info.height;\n  shadow_image->page.x+=x_offset-(ssize_t) border_info.width;\n  shadow_image->page.y+=y_offset-(ssize_t) border_info.height;\n  return(shadow_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S k e t c h I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SketchImage() simulates a pencil sketch.  We convolve the image with a\n%  Gaussian operator of the given radius and standard deviation (sigma).  For\n%  reasonable results, radius should be larger than sigma.  Use a radius of 0\n%  and SketchImage() selects a suitable radius for you.  Angle gives the angle\n%  of the sketch.\n%\n%  The format of the SketchImage method is:\n%\n%    Image *SketchImage(const Image *image,const double radius,\n%      const double sigma,const double angle,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o radius: the radius of the Gaussian, in pixels, not counting the\n%      center pixel.\n%\n%    o sigma: the standard deviation of the Gaussian, in pixels.\n%\n%    o angle: apply the effect along this angle.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SketchImage(const Image *image,const double radius,\n  const double sigma,const double angle,ExceptionInfo *exception)\n{\n  CacheView\n    *random_view;\n\n  Image\n    *blend_image,\n    *blur_image,\n    *dodge_image,\n    *random_image,\n    *sketch_image;\n\n  MagickBooleanType\n    status;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  /*\n    Sketch image.\n  */\n  random_image=CloneImage(image,image->columns << 1,image->rows << 1,\n    MagickTrue,exception);\n  if (random_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=MagickTrue;\n  random_info=AcquireRandomInfoThreadSet();\n  random_view=AcquireAuthenticCacheView(random_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(random_image,random_image,random_image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) random_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(random_view,0,y,random_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) random_image->columns; x++)\n    {\n      double\n        value;\n\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(random_image,q) == 0)\n        {\n          q+=GetPixelChannels(random_image);\n          continue;\n        }\n      value=GetPseudoRandomValue(random_info[id]);\n      for (i=0; i < (ssize_t) GetPixelChannels(random_image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=ClampToQuantum(QuantumRange*value);\n      }\n      q+=GetPixelChannels(random_image);\n    }\n    if (SyncCacheViewAuthenticPixels(random_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  random_view=DestroyCacheView(random_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  if (status == MagickFalse)\n    {\n      random_image=DestroyImage(random_image);\n      return(random_image);\n    }\n  blur_image=MotionBlurImage(random_image,radius,sigma,angle,exception);\n  random_image=DestroyImage(random_image);\n  if (blur_image == (Image *) NULL)\n    return((Image *) NULL);\n  dodge_image=EdgeImage(blur_image,radius,exception);\n  blur_image=DestroyImage(blur_image);\n  if (dodge_image == (Image *) NULL)\n    return((Image *) NULL);\n  (void) NormalizeImage(dodge_image,exception);\n  (void) NegateImage(dodge_image,MagickFalse,exception);\n  (void) TransformImage(&dodge_image,(char *) NULL,\"50%\",exception);\n  sketch_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (sketch_image == (Image *) NULL)\n    {\n      dodge_image=DestroyImage(dodge_image);\n      return((Image *) NULL);\n    }\n  (void) CompositeImage(sketch_image,dodge_image,ColorDodgeCompositeOp,\n    MagickTrue,0,0,exception);\n  dodge_image=DestroyImage(dodge_image);\n  blend_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (blend_image == (Image *) NULL)\n    {\n      sketch_image=DestroyImage(sketch_image);\n      return((Image *) NULL);\n    }\n  if (blend_image->alpha_trait != BlendPixelTrait)\n    (void) SetImageAlpha(blend_image,TransparentAlpha,exception);\n  (void) SetImageArtifact(blend_image,\"compose:args\",\"20x80\");\n  (void) CompositeImage(sketch_image,blend_image,BlendCompositeOp,MagickTrue,\n    0,0,exception);\n  blend_image=DestroyImage(blend_image);\n  return(sketch_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S o l a r i z e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SolarizeImage() applies a special effect to the image, similar to the effect\n%  achieved in a photo darkroom by selectively exposing areas of photo\n%  sensitive paper to light.  Threshold ranges from 0 to QuantumRange and is a\n%  measure of the extent of the solarization.\n%\n%  The format of the SolarizeImage method is:\n%\n%      MagickBooleanType SolarizeImage(Image *image,const double threshold,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold:  Define the extent of the solarization.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SolarizeImage(Image *image,\n  const double threshold,ExceptionInfo *exception)\n{\n#define SolarizeImageTag  \"Solarize/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      /*\n        Solarize colormap.\n      */\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if ((double) image->colormap[i].red > threshold)\n          image->colormap[i].red=QuantumRange-image->colormap[i].red;\n        if ((double) image->colormap[i].green > threshold)\n          image->colormap[i].green=QuantumRange-image->colormap[i].green;\n        if ((double) image->colormap[i].blue > threshold)\n          image->colormap[i].blue=QuantumRange-image->colormap[i].blue;\n      }\n    }\n  /*\n    Solarize image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if ((double) q[i] > threshold)\n          q[i]=QuantumRange-q[i];\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SolarizeImage)\n#endif\n        proceed=SetImageProgress(image,SolarizeImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S t e g a n o I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SteganoImage() hides a digital watermark within the image.  Recover\n%  the hidden watermark later to prove that the authenticity of an image.\n%  Offset defines the start position within the image to hide the watermark.\n%\n%  The format of the SteganoImage method is:\n%\n%      Image *SteganoImage(const Image *image,Image *watermark,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o watermark: the watermark image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SteganoImage(const Image *image,const Image *watermark,\n  ExceptionInfo *exception)\n{\n#define GetBit(alpha,i) ((((size_t) (alpha) >> (size_t) (i)) & 0x01) != 0)\n#define SetBit(alpha,i,set) (Quantum) ((set) != 0 ? (size_t) (alpha) \\\n  | (one << (size_t) (i)) : (size_t) (alpha) & ~(one << (size_t) (i)))\n#define SteganoImageTag  \"Stegano/Image\"\n\n  CacheView\n    *stegano_view,\n    *watermark_view;\n\n  Image\n    *stegano_image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    depth,\n    one;\n\n  ssize_t\n    i,\n    j,\n    k,\n    y;\n\n  /*\n    Initialize steganographic image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(watermark != (const Image *) NULL);\n  assert(watermark->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1UL;\n  stegano_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (stegano_image == (Image *) NULL)\n    return((Image *) NULL);\n  stegano_image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  if (SetImageStorageClass(stegano_image,DirectClass,exception) == MagickFalse)\n    {\n      stegano_image=DestroyImage(stegano_image);\n      return((Image *) NULL);\n    }\n  /*\n    Hide watermark in low-order bits of image.\n  */\n  c=0;\n  i=0;\n  j=0;\n  depth=stegano_image->depth;\n  k=stegano_image->offset;\n  status=MagickTrue;\n  watermark_view=AcquireVirtualCacheView(watermark,exception);\n  stegano_view=AcquireAuthenticCacheView(stegano_image,exception);\n  for (i=(ssize_t) depth-1; (i >= 0) && (j < (ssize_t) depth); i--)\n  {\n    for (y=0; (y < (ssize_t) watermark->rows) && (j < (ssize_t) depth); y++)\n    {\n      for (x=0; (x < (ssize_t) watermark->columns) && (j < (ssize_t) depth); x++)\n      {\n        ssize_t\n          offset;\n\n        (void) GetOneCacheViewVirtualPixelInfo(watermark_view,x,y,&pixel,\n          exception);\n        offset=k/(ssize_t) stegano_image->columns;\n        if (offset >= (ssize_t) stegano_image->rows)\n          break;\n        q=GetCacheViewAuthenticPixels(stegano_view,k % (ssize_t)\n          stegano_image->columns,k/(ssize_t) stegano_image->columns,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          break;\n        switch (c)\n        {\n          case 0:\n          {\n            SetPixelRed(stegano_image,SetBit(GetPixelRed(stegano_image,q),j,\n              GetBit(GetPixelInfoIntensity(stegano_image,&pixel),i)),q);\n            break;\n          }\n          case 1:\n          {\n            SetPixelGreen(stegano_image,SetBit(GetPixelGreen(stegano_image,q),j,\n              GetBit(GetPixelInfoIntensity(stegano_image,&pixel),i)),q);\n            break;\n          }\n          case 2:\n          {\n            SetPixelBlue(stegano_image,SetBit(GetPixelBlue(stegano_image,q),j,\n              GetBit(GetPixelInfoIntensity(stegano_image,&pixel),i)),q);\n            break;\n          }\n        }\n        if (SyncCacheViewAuthenticPixels(stegano_view,exception) == MagickFalse)\n          break;\n        c++;\n        if (c == 3)\n          c=0;\n        k++;\n        if (k == (ssize_t) (stegano_image->columns*stegano_image->columns))\n          k=0;\n        if (k == stegano_image->offset)\n          j++;\n      }\n    }\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,SteganoImageTag,(MagickOffsetType)\n          (depth-i),depth);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  stegano_view=DestroyCacheView(stegano_view);\n  watermark_view=DestroyCacheView(watermark_view);\n  if (status == MagickFalse)\n    stegano_image=DestroyImage(stegano_image);\n  return(stegano_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S t e r e o A n a g l y p h I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StereoAnaglyphImage() combines two images and produces a single image that\n%  is the composite of a left and right image of a stereo pair.  Special\n%  red-green stereo glasses are required to view this effect.\n%\n%  The format of the StereoAnaglyphImage method is:\n%\n%      Image *StereoImage(const Image *left_image,const Image *right_image,\n%        ExceptionInfo *exception)\n%      Image *StereoAnaglyphImage(const Image *left_image,\n%        const Image *right_image,const ssize_t x_offset,const ssize_t y_offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o left_image: the left image.\n%\n%    o right_image: the right image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%    o x_offset: amount, in pixels, by which the left image is offset to the\n%      right of the right image.\n%\n%    o y_offset: amount, in pixels, by which the left image is offset to the\n%      bottom of the right image.\n%\n%\n*/\nMagickExport Image *StereoImage(const Image *left_image,\n  const Image *right_image,ExceptionInfo *exception)\n{\n  return(StereoAnaglyphImage(left_image,right_image,0,0,exception));\n}\n\nMagickExport Image *StereoAnaglyphImage(const Image *left_image,\n  const Image *right_image,const ssize_t x_offset,const ssize_t y_offset,\n  ExceptionInfo *exception)\n{\n#define StereoImageTag  \"Stereo/Image\"\n\n  const Image\n    *image;\n\n  Image\n    *stereo_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(left_image != (const Image *) NULL);\n  assert(left_image->signature == MagickCoreSignature);\n  if (left_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      left_image->filename);\n  assert(right_image != (const Image *) NULL);\n  assert(right_image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(right_image != (const Image *) NULL);\n  image=left_image;\n  if ((left_image->columns != right_image->columns) ||\n      (left_image->rows != right_image->rows))\n    ThrowImageException(ImageError,\"LeftAndRightImageSizesDiffer\");\n  /*\n    Initialize stereo image attributes.\n  */\n  stereo_image=CloneImage(left_image,left_image->columns,left_image->rows,\n    MagickTrue,exception);\n  if (stereo_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(stereo_image,DirectClass,exception) == MagickFalse)\n    {\n      stereo_image=DestroyImage(stereo_image);\n      return((Image *) NULL);\n    }\n  (void) SetImageColorspace(stereo_image,sRGBColorspace,exception);\n  /*\n    Copy left image to red channel and right image to blue channel.\n  */\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) stereo_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p,\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict r;\n\n    p=GetVirtualPixels(left_image,-x_offset,y-y_offset,image->columns,1,\n      exception);\n    q=GetVirtualPixels(right_image,0,y,right_image->columns,1,exception);\n    r=QueueAuthenticPixels(stereo_image,0,y,stereo_image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL) ||\n        (r == (Quantum *) NULL))\n      break;\n    for (x=0; x < (ssize_t) stereo_image->columns; x++)\n    {\n      SetPixelRed(image,GetPixelRed(left_image,p),r);\n      SetPixelGreen(image,GetPixelGreen(right_image,q),r);\n      SetPixelBlue(image,GetPixelBlue(right_image,q),r);\n      if ((GetPixelAlphaTraits(stereo_image) & CopyPixelTrait) != 0)\n        SetPixelAlpha(image,(GetPixelAlpha(left_image,p)+\n          GetPixelAlpha(right_image,q))/2,r);\n      p+=GetPixelChannels(left_image);\n      q+=GetPixelChannels(right_image);\n      r+=GetPixelChannels(stereo_image);\n    }\n    if (SyncAuthenticPixels(stereo_image,exception) == MagickFalse)\n      break;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,StereoImageTag,(MagickOffsetType) y,\n          stereo_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  if (status == MagickFalse)\n    stereo_image=DestroyImage(stereo_image);\n  return(stereo_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S w i r l I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SwirlImage() swirls the pixels about the center of the image, where\n%  degrees indicates the sweep of the arc through which each pixel is moved.\n%  You get a more dramatic effect as the degrees move from 1 to 360.\n%\n%  The format of the SwirlImage method is:\n%\n%      Image *SwirlImage(const Image *image,double degrees,\n%        const PixelInterpolateMethod method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o degrees: Define the tightness of the swirling effect.\n%\n%    o method: the pixel interpolation method.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SwirlImage(const Image *image,double degrees,\n  const PixelInterpolateMethod method,ExceptionInfo *exception)\n{\n#define SwirlImageTag  \"Swirl/Image\"\n\n  CacheView\n    *image_view,\n    *interpolate_view,\n    *swirl_view;\n\n  Image\n    *swirl_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  double\n    radius;\n\n  PointInfo\n    center,\n    scale;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize swirl image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  swirl_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (swirl_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(swirl_image,DirectClass,exception) == MagickFalse)\n    {\n      swirl_image=DestroyImage(swirl_image);\n      return((Image *) NULL);\n    }\n  if (swirl_image->background_color.alpha != OpaqueAlpha)\n    swirl_image->alpha_trait=BlendPixelTrait;\n  /*\n    Compute scaling factor.\n  */\n  center.x=(double) image->columns/2.0;\n  center.y=(double) image->rows/2.0;\n  radius=MagickMax(center.x,center.y);\n  scale.x=1.0;\n  scale.y=1.0;\n  if (image->columns > image->rows)\n    scale.y=(double) image->columns/(double) image->rows;\n  else\n    if (image->columns < image->rows)\n      scale.x=(double) image->rows/(double) image->columns;\n  degrees=(double) DegreesToRadians(degrees);\n  /*\n    Swirl image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  interpolate_view=AcquireVirtualCacheView(image,exception);\n  swirl_view=AcquireAuthenticCacheView(swirl_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,swirl_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      distance;\n\n    PointInfo\n      delta;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(swirl_view,0,y,swirl_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    delta.y=scale.y*(double) (y-center.y);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      /*\n        Determine if the pixel is within an ellipse.\n      */\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(swirl_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(swirl_image);\n          continue;\n        }\n      delta.x=scale.x*(double) (x-center.x);\n      distance=delta.x*delta.x+delta.y*delta.y;\n      if (distance >= (radius*radius))\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait swirl_traits=GetPixelChannelTraits(swirl_image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (swirl_traits == UndefinedPixelTrait))\n              continue;\n            SetPixelChannel(swirl_image,channel,p[i],q);\n          }\n        }\n      else\n        {\n          double\n            cosine,\n            factor,\n            sine;\n\n          /*\n            Swirl the pixel.\n          */\n          factor=1.0-sqrt((double) distance)/radius;\n          sine=sin((double) (degrees*factor*factor));\n          cosine=cos((double) (degrees*factor*factor));\n          status=InterpolatePixelChannels(image,interpolate_view,swirl_image,\n            method,((cosine*delta.x-sine*delta.y)/scale.x+center.x),(double)\n            ((sine*delta.x+cosine*delta.y)/scale.y+center.y),q,exception);\n        }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(swirl_image);\n    }\n    if (SyncCacheViewAuthenticPixels(swirl_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SwirlImage)\n#endif\n        proceed=SetImageProgress(image,SwirlImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  swirl_view=DestroyCacheView(swirl_view);\n  interpolate_view=DestroyCacheView(interpolate_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    swirl_image=DestroyImage(swirl_image);\n  return(swirl_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     T i n t I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TintImage() applies a color vector to each pixel in the image.  The length\n%  of the vector is 0 for black and white and at its maximum for the midtones.\n%  The vector weighting function is f(x)=(1-(4.0*((x-0.5)*(x-0.5))))\n%\n%  The format of the TintImage method is:\n%\n%      Image *TintImage(const Image *image,const char *blend,\n%        const PixelInfo *tint,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o blend: A color value used for tinting.\n%\n%    o tint: A color value used for tinting.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *TintImage(const Image *image,const char *blend,\n  const PixelInfo *tint,ExceptionInfo *exception)\n{\n#define TintImageTag  \"Tint/Image\"\n\n  CacheView\n    *image_view,\n    *tint_view;\n\n  double\n    intensity;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *tint_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    color_vector;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate tint image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  tint_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (tint_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(tint_image,DirectClass,exception) == MagickFalse)\n    {\n      tint_image=DestroyImage(tint_image);\n      return((Image *) NULL);\n    }\n  if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&\n      (IsPixelInfoGray(tint) == MagickFalse))\n    (void) SetImageColorspace(tint_image,sRGBColorspace,exception);\n  if (blend == (const char *) NULL)\n    return(tint_image);\n  /*\n    Determine RGB values of the color.\n  */\n  GetPixelInfo(image,&color_vector);\n  flags=ParseGeometry(blend,&geometry_info);\n  color_vector.red=geometry_info.rho;\n  color_vector.green=geometry_info.rho;\n  color_vector.blue=geometry_info.rho;\n  color_vector.alpha=(MagickRealType) OpaqueAlpha;\n  if ((flags & SigmaValue) != 0)\n    color_vector.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    color_vector.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    color_vector.alpha=geometry_info.psi;\n  if (image->colorspace == CMYKColorspace)\n    {\n      color_vector.black=geometry_info.rho;\n      if ((flags & PsiValue) != 0)\n        color_vector.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        color_vector.alpha=geometry_info.chi;\n    }\n  intensity=(double) GetPixelInfoIntensity((const Image *) NULL,tint);\n  color_vector.red=(double) (color_vector.red*tint->red/100.0-intensity);\n  color_vector.green=(double) (color_vector.green*tint->green/100.0-intensity);\n  color_vector.blue=(double) (color_vector.blue*tint->blue/100.0-intensity);\n  color_vector.black=(double) (color_vector.black*tint->black/100.0-intensity);\n  color_vector.alpha=(double) (color_vector.alpha*tint->alpha/100.0-intensity);\n  /*\n    Tint image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  tint_view=AcquireAuthenticCacheView(tint_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,tint_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(tint_view,0,y,tint_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      PixelInfo\n        pixel;\n\n      double\n        weight;\n\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait tint_traits=GetPixelChannelTraits(tint_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (tint_traits == UndefinedPixelTrait))\n          continue;\n        if (((tint_traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(image,p) == 0))\n          {\n            SetPixelChannel(tint_image,channel,p[i],q);\n            continue;\n          }\n      }\n      GetPixelInfo(image,&pixel);\n      weight=QuantumScale*GetPixelRed(image,p)-0.5;\n      pixel.red=(double) GetPixelRed(image,p)+color_vector.red*(1.0-(4.0*\n        (weight*weight)));\n      weight=QuantumScale*GetPixelGreen(image,p)-0.5;\n      pixel.green=(double) GetPixelGreen(image,p)+color_vector.green*(1.0-(4.0*\n        (weight*weight)));\n      weight=QuantumScale*GetPixelBlue(image,p)-0.5;\n      pixel.blue=(double) GetPixelBlue(image,p)+color_vector.blue*(1.0-(4.0*\n        (weight*weight)));\n      weight=QuantumScale*GetPixelBlack(image,p)-0.5;\n      pixel.black=(double) GetPixelBlack(image,p)+color_vector.black*(1.0-(4.0*\n        (weight*weight)));\n      SetPixelViaPixelInfo(tint_image,&pixel,q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(tint_image);\n    }\n    if (SyncCacheViewAuthenticPixels(tint_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TintImage)\n#endif\n        proceed=SetImageProgress(image,TintImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  tint_view=DestroyCacheView(tint_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    tint_image=DestroyImage(tint_image);\n  return(tint_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     V i g n e t t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  VignetteImage() softens the edges of the image in vignette style.\n%\n%  The format of the VignetteImage method is:\n%\n%      Image *VignetteImage(const Image *image,const double radius,\n%        const double sigma,const ssize_t x,const ssize_t y,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o radius: the radius of the pixel neighborhood.\n%\n%    o sigma: the standard deviation of the Gaussian, in pixels.\n%\n%    o x, y:  Define the x and y ellipse offset.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *VignetteImage(const Image *image,const double radius,\n  const double sigma,const ssize_t x,const ssize_t y,ExceptionInfo *exception)\n{\n  char\n    ellipse[MagickPathExtent];\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *canvas_image,\n    *blur_image,\n    *oval_image,\n    *vignette_image;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  canvas_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (canvas_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(canvas_image,DirectClass,exception) == MagickFalse)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      return((Image *) NULL);\n    }\n  canvas_image->alpha_trait=BlendPixelTrait;\n  oval_image=CloneImage(canvas_image,canvas_image->columns,canvas_image->rows,\n    MagickTrue,exception);\n  if (oval_image == (Image *) NULL)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      return((Image *) NULL);\n    }\n  (void) QueryColorCompliance(\"#000000\",AllCompliance,\n    &oval_image->background_color,exception);\n  (void) SetImageBackgroundColor(oval_image,exception);\n  draw_info=CloneDrawInfo((const ImageInfo *) NULL,(const DrawInfo *) NULL);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&draw_info->fill,\n    exception);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&draw_info->stroke,\n    exception);\n  (void) FormatLocaleString(ellipse,MagickPathExtent,\"ellipse %g,%g,%g,%g,\"\n    \"0.0,360.0\",image->columns/2.0,image->rows/2.0,image->columns/2.0-x,\n    image->rows/2.0-y);\n  draw_info->primitive=AcquireString(ellipse);\n  (void) DrawImage(oval_image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  blur_image=BlurImage(oval_image,radius,sigma,exception);\n  oval_image=DestroyImage(oval_image);\n  if (blur_image == (Image *) NULL)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      return((Image *) NULL);\n    }\n  blur_image->alpha_trait=UndefinedPixelTrait;\n  (void) CompositeImage(canvas_image,blur_image,IntensityCompositeOp,MagickTrue,\n    0,0,exception);\n  blur_image=DestroyImage(blur_image);\n  vignette_image=MergeImageLayers(canvas_image,FlattenLayer,exception);\n  canvas_image=DestroyImage(canvas_image);\n  if (vignette_image != (Image *) NULL)\n    (void) TransformImageColorspace(vignette_image,image->colorspace,exception);\n  return(vignette_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     W a v e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WaveImage() creates a \"ripple\" effect in the image by shifting the pixels\n%  vertically along a sine wave whose amplitude and wavelength is specified\n%  by the given parameters.\n%\n%  The format of the WaveImage method is:\n%\n%      Image *WaveImage(const Image *image,const double amplitude,\n%        const double wave_length,const PixelInterpolateMethod method,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o amplitude, wave_length:  Define the amplitude and wave length of the\n%      sine wave.\n%\n%    o interpolate: the pixel interpolation method.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *WaveImage(const Image *image,const double amplitude,\n  const double wave_length,const PixelInterpolateMethod method,\n  ExceptionInfo *exception)\n{\n#define WaveImageTag  \"Wave/Image\"\n\n  CacheView\n    *image_view,\n    *wave_view;\n\n  Image\n    *wave_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  double\n    *sine_map;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize wave image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  wave_image=CloneImage(image,image->columns,(size_t) (image->rows+2.0*\n    fabs(amplitude)),MagickTrue,exception);\n  if (wave_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(wave_image,DirectClass,exception) == MagickFalse)\n    {\n      wave_image=DestroyImage(wave_image);\n      return((Image *) NULL);\n    }\n  if (wave_image->background_color.alpha != OpaqueAlpha)\n    wave_image->alpha_trait=BlendPixelTrait;\n  /*\n    Allocate sine map.\n  */\n  sine_map=(double *) AcquireQuantumMemory((size_t) wave_image->columns,\n    sizeof(*sine_map));\n  if (sine_map == (double *) NULL)\n    {\n      wave_image=DestroyImage(wave_image);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i=0; i < (ssize_t) wave_image->columns; i++)\n    sine_map[i]=fabs(amplitude)+amplitude*sin((double) ((2.0*MagickPI*i)/\n      wave_length));\n  /*\n    Wave image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  wave_view=AcquireAuthenticCacheView(wave_image,exception);\n  (void) SetCacheViewVirtualPixelMethod(image_view,\n    BackgroundVirtualPixelMethod);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,wave_image,wave_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) wave_image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(wave_view,0,y,wave_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) wave_image->columns; x++)\n    {\n      status=InterpolatePixelChannels(image,image_view,wave_image,method,\n        (double) x,(double) (y-sine_map[x]),q,exception);\n      q+=GetPixelChannels(wave_image);\n    }\n    if (SyncCacheViewAuthenticPixels(wave_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_WaveImage)\n#endif\n        proceed=SetImageProgress(image,WaveImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  wave_view=DestroyCacheView(wave_view);\n  image_view=DestroyCacheView(image_view);\n  sine_map=(double *) RelinquishMagickMemory(sine_map);\n  if (status == MagickFalse)\n    wave_image=DestroyImage(wave_image);\n  return(wave_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     W a v e l e t D e n o i s e I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WaveletDenoiseImage() removes noise from the image using a wavelet\n%  transform.  The wavelet transform is a fast hierarchical scheme for\n%  processing an image using a set of consecutive lowpass and high_pass filters,\n%  followed by a decimation.  This results in a decomposition into different\n%  scales which can be regarded as different \u201cfrequency bands\u201d, determined by\n%  the mother wavelet.  Adapted from dcraw.c by David Coffin.\n%\n%  The format of the WaveletDenoiseImage method is:\n%\n%      Image *WaveletDenoiseImage(const Image *image,const double threshold,\n%        const double softness,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: set the threshold for smoothing.\n%\n%    o softness: attenuate the smoothing threshold.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline void HatTransform(const float *magick_restrict pixels,\n  const size_t stride,const size_t extent,const size_t scale,float *kernel)\n{\n  const float\n    *magick_restrict p,\n    *magick_restrict q,\n    *magick_restrict r;\n\n  register ssize_t\n    i;\n\n  p=pixels;\n  q=pixels+scale*stride;\n  r=pixels+scale*stride;\n  for (i=0; i < (ssize_t) scale; i++)\n  {\n    kernel[i]=0.25f*(*p+(*p)+(*q)+(*r));\n    p+=stride;\n    q-=stride;\n    r+=stride;\n  }\n  for ( ; i < (ssize_t) (extent-scale); i++)\n  {\n    kernel[i]=0.25f*(2.0f*(*p)+*(p-scale*stride)+*(p+scale*stride));\n    p+=stride;\n  }\n  q=p-scale*stride;\n  r=pixels+stride*(extent-2);\n  for ( ; i < (ssize_t) extent; i++)\n  {\n    kernel[i]=0.25f*(*p+(*p)+(*q)+(*r));\n    p+=stride;\n    q+=stride;\n    r-=stride;\n  }\n}\n\nMagickExport Image *WaveletDenoiseImage(const Image *image,\n  const double threshold,const double softness,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view,\n    *noise_view;\n\n  float\n    *kernel,\n    *pixels;\n\n  Image\n    *noise_image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixels_info;\n\n  ssize_t\n    channel;\n\n  static const float\n    noise_levels[] = { 0.8002f, 0.2735f, 0.1202f, 0.0585f, 0.0291f, 0.0152f,\n      0.0080f, 0.0044f };\n\n  /*\n    Initialize noise image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  noise_image=AccelerateWaveletDenoiseImage(image,threshold,exception);\n  if (noise_image != (Image *) NULL)\n    return(noise_image);\n#endif\n  noise_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (noise_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(noise_image,DirectClass,exception) == MagickFalse)\n    {\n      noise_image=DestroyImage(noise_image);\n      return((Image *) NULL);\n    }\n  if (AcquireMagickResource(WidthResource,4*image->columns) == MagickFalse)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*\n    sizeof(*pixels));\n  kernel=(float *) AcquireQuantumMemory(MagickMax(image->rows,image->columns),\n    GetOpenMPMaximumThreads()*sizeof(*kernel));\n  if ((pixels_info == (MemoryInfo *) NULL) || (kernel == (float *) NULL))\n    {\n      if (kernel != (float *) NULL)\n        kernel=(float *) RelinquishMagickMemory(kernel);\n      if (pixels_info != (MemoryInfo *) NULL)\n        pixels_info=RelinquishVirtualMemory(pixels_info);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  pixels=(float *) GetVirtualMemoryBlob(pixels_info);\n  status=MagickTrue;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  noise_view=AcquireAuthenticCacheView(noise_image,exception);\n  for (channel=0; channel < (ssize_t) GetPixelChannels(image); channel++)\n  {\n    register ssize_t\n      i;\n\n    size_t\n      high_pass,\n      low_pass;\n\n    ssize_t\n      level,\n      y;\n\n    PixelChannel\n      pixel_channel;\n\n    PixelTrait\n      traits;\n\n    if (status == MagickFalse)\n      continue;\n    traits=GetPixelChannelTraits(image,(PixelChannel) channel);\n    if (traits == UndefinedPixelTrait)\n      continue;\n    pixel_channel=GetPixelChannelChannel(image,channel);\n    if ((pixel_channel != RedPixelChannel) &&\n        (pixel_channel != GreenPixelChannel) &&\n        (pixel_channel != BluePixelChannel))\n      continue;\n    /*\n      Copy channel from image to wavelet pixel array.\n    */\n    i=0;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register const Quantum\n        *magick_restrict p;\n\n      ssize_t\n        x;\n\n      p=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        pixels[i++]=(float) p[channel];\n        p+=GetPixelChannels(image);\n      }\n    }\n    /*\n      Low pass filter outputs are called approximation kernel & high pass\n      filters are referred to as detail kernel. The detail kernel\n      have high values in the noisy parts of the signal.\n    */\n    high_pass=0;\n    for (level=0; level < 5; level++)\n    {\n      double\n        magnitude;\n\n      ssize_t\n        x,\n        y;\n\n      low_pass=(size_t) (number_pixels*((level & 0x01)+1));\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,1) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        register float\n          *magick_restrict p,\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        p=kernel+id*image->columns;\n        q=pixels+y*image->columns;\n        HatTransform(q+high_pass,1,image->columns,(size_t) (1 << level),p);\n        q+=low_pass;\n        for (x=0; x < (ssize_t) image->columns; x++)\n          *q++=(*p++);\n      }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,1) \\\n        magick_threads(image,image,image->columns,1)\n#endif\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        register float\n          *magick_restrict p,\n          *magick_restrict q;\n\n        register ssize_t\n          y;\n\n        p=kernel+id*image->rows;\n        q=pixels+x+low_pass;\n        HatTransform(q,image->columns,image->rows,(size_t) (1 << level),p);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          *q=(*p++);\n          q+=image->columns;\n        }\n      }\n      /*\n        To threshold, each coefficient is compared to a threshold value and\n        attenuated / shrunk by some factor.\n      */\n      magnitude=threshold*noise_levels[level];\n      for (i=0; i < (ssize_t) number_pixels; ++i)\n      {\n        pixels[high_pass+i]-=pixels[low_pass+i];\n        if (pixels[high_pass+i] < -magnitude)\n          pixels[high_pass+i]+=magnitude-softness*magnitude;\n        else\n          if (pixels[high_pass+i] > magnitude)\n            pixels[high_pass+i]-=magnitude-softness*magnitude;\n          else\n            pixels[high_pass+i]*=softness;\n        if (high_pass != 0)\n          pixels[i]+=pixels[high_pass+i];\n      }\n      high_pass=low_pass;\n    }\n    /*\n      Reconstruct image from the thresholded wavelet kernel.\n    */\n    i=0;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      MagickBooleanType\n        sync;\n\n      register Quantum\n        *magick_restrict q;\n\n      register ssize_t\n        x;\n\n      ssize_t\n        offset;\n\n      q=GetCacheViewAuthenticPixels(noise_view,0,y,noise_image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      offset=GetPixelChannelOffset(noise_image,pixel_channel);\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        MagickRealType\n          pixel;\n\n        pixel=(MagickRealType) pixels[i]+pixels[low_pass+i];\n        q[offset]=ClampToQuantum(pixel);\n        i++;\n        q+=GetPixelChannels(noise_image);\n      }\n      sync=SyncCacheViewAuthenticPixels(noise_view,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,AddNoiseImageTag,(MagickOffsetType)\n          channel,GetPixelChannels(image));\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  noise_view=DestroyCacheView(noise_view);\n  image_view=DestroyCacheView(image_view);\n  kernel=(float *) RelinquishMagickMemory(kernel);\n  pixels_info=RelinquishVirtualMemory(pixels_info);\n  if (status == MagickFalse)\n    noise_image=DestroyImage(noise_image);\n  return(noise_image);\n}\n", "#!/usr/bin/perl\n#\n# Overall demo of the major PerlMagick methods.\n#\nuse Image::Magick;\n\n#\n# Read model & smile image.\n#\nprint \"Read...\\n\";\n$null=Image::Magick->new;\n$null->Set(size=>'70x70');\n$x=$null->ReadImage('NULL:black');\nwarn \"$x\" if \"$x\";\n\n$model=Image::Magick->new();\n$x=$model->ReadImage('model.gif');\nwarn \"$x\" if \"$x\";\n$model->Label('Magick');\n$model->Set(background=>'white');\n\n$smile=Image::Magick->new;\n$x=$smile->ReadImage('smile.gif');\nwarn \"$x\" if \"$x\";\n$smile->Label('Smile');\n$smile->Set(background=>'white');\n#\n# Create image stack.\n#\nprint \"Transform image...\\n\";\n$images=Image::Magick->new();\n\nprint \"Adaptive Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Adaptive Blur');\n$example->AdaptiveBlur('0x1');\npush(@$images,$example);\n\nprint \"Adaptive Resize...\\n\";\n$example=$model->Clone();\n$example->Label('Adaptive Resize');\n$example->AdaptiveResize('60%');\npush(@$images,$example);\n\nprint \"Adaptive Sharpen...\\n\";\n$example=$model->Clone();\n$example->Label('Adaptive Sharpen');\n$example->AdaptiveSharpen('0x1');\npush(@$images,$example);\n\nprint \"Adaptive Threshold...\\n\";\n$example=$model->Clone();\n$example->Label('Adaptive Threshold');\n$example->AdaptiveThreshold('5x5+5%');\npush(@$images,$example);\n\nprint \"Add Noise...\\n\";\n$example=$model->Clone();\n$example->Label('Add Noise');\n$example->AddNoise(\"Laplacian\");\npush(@$images,$example);\n\nprint \"Annotate...\\n\";\n$example=$model->Clone();\n$example->Label('Annotate');\n$example->Annotate(text=>'Magick',geometry=>'+0+20',font=>'Generic.ttf',\n  fill=>'gold',gravity=>'North',pointsize=>14);\npush(@$images,$example);\n\nprint \"Auto-gamma...\\n\";\n$example=$model->Clone();\n$example->Label('Auto Gamma');\n$example->AutoGamma();\npush(@$images,$example);\n\nprint \"Auto-level...\\n\";\n$example=$model->Clone();\n$example->Label('Auto Level');\n$example->AutoLevel();\npush(@$images,$example);\n\nprint \"Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Blur');\n$example->Blur('0.0x1.0');\npush(@$images,$example);\n\nprint \"Border...\\n\";\n$example=$model->Clone();\n$example->Label('Border');\n$example->Border(geometry=>'6x6',color=>'gold');\npush(@$images,$example);\n\nprint \"Channel...\\n\";\n$example=$model->Clone();\n$example->Label('Channel');\n$example->Channel(channel=>'red');\npush(@$images,$example);\n\nprint \"Charcoal...\\n\";\n$example=$model->Clone();\n$example->Label('Charcoal');\n$example->Charcoal('2x1');\npush(@$images,$example);\n\nprint \"ColorMatrix...\\n\";\n$example=$model->Clone();\n$example->Label('ColorMatrix');\n$example->ColorMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\npush(@$images,$example);\n\nprint \"Composite...\\n\";\n$example=$model->Clone();\n$example->Label('Composite');\n$example->Composite(image=>$smile,compose=>'over',geometry=>'+35+65');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Contrast...\\n\";\n$example=$model->Clone();\n$example->Label('Contrast');\n$example->Contrast();\npush(@$images,$example);\n\nprint \"Contrast Stretch...\\n\";\n$example=$model->Clone();\n$example->Label('Contrast Stretch');\n$example->ContrastStretch('5%');\npush(@$images,$example);\n\nprint \"Convolve...\\n\";\n$example=$model->Clone();\n$example->Label('Convolve');\n$example->Convolve([0.125, 0.125, 0.125, 0.125, 0.5, 0.125, 0.125, 0.125, 0.125]);\npush(@$images,$example);\n\nprint \"Crop...\\n\";\n$example=$model->Clone();\n$example->Label('Crop');\n$example->Crop(geometry=>'80x80+25+50');\n$example->Set(page=>'0x0+0+0');\npush(@$images,$example);\n\nprint \"Despeckle...\\n\";\n$example=$model->Clone();\n$example->Label('Despeckle');\n$example->Despeckle();\npush(@$images,$example);\n\nprint \"Distort...\\n\";\n$example=$model->Clone();\n$example->Label('Distort');\n$example->Distort(method=>'arc',points=>[60],'virtual-pixel'=>'white');\npush(@$images,$example);\n\nprint \"Draw...\\n\";\n$example=$model->Clone();\n$example->Label('Draw');\n$example->Draw(fill=>'none',stroke=>'gold',primitive=>'circle',\n  points=>'60,90 60,120',strokewidth=>2);\npush(@$images,$example);\n\nprint \"Detect Edges...\\n\";\n$example=$model->Clone();\n$example->Label('Detect Edges');\n$example->Edge('2x0.5');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Emboss...\\n\";\n$example=$model->Clone();\n$example->Label('Emboss');\n$example->Emboss('0x1');\npush(@$images,$example);\n\nprint \"Encipher...\\n\";\n$example=$model->Clone();\n$example->Label('Encipher');\n$example->Encipher('Magick');\npush(@$images,$example);\n\nprint \"Equalize...\\n\";\n$example=$model->Clone();\n$example->Label('Equalize');\n$example->Equalize();\npush(@$images,$example);\n\nprint \"Explode...\\n\";\n$example=$model->Clone();\n$example->Label('Explode');\n$example->Implode(-1);\npush(@$images,$example);\n\nprint \"Flip...\\n\";\n$example=$model->Clone();\n$example->Label('Flip');\n$example->Flip();\npush(@$images,$example);\n\nprint \"Flop...\\n\";\n$example=$model->Clone();\n$example->Label('Flop');\n$example->Flop();\npush(@$images,$example);\n\nprint \"Frame...\\n\";\n$example=$model->Clone();\n$example->Label('Frame');\n$example->Frame('15x15+3+3');\npush(@$images,$example);\n\nprint \"Fx...\\n\";\n$example=$model->Clone();\n$example->Label('Fx');\npush(@$images,$example->Fx(expression=>'0.5*u'));\n\nprint \"Gamma...\\n\";\n$example=$model->Clone();\n$example->Label('Gamma');\n$example->Gamma(1.6);\npush(@$images,$example);\n\nprint \"Gaussian Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Gaussian Blur');\n$example->GaussianBlur('0.0x1.5');\npush(@$images,$example);\n\nprint \"Gradient...\\n\";\n$gradient=Image::Magick->new;\n$gradient->Set(size=>'130x194');\n$x=$gradient->ReadImage('gradient:#20a0ff-#ffff00');\nwarn \"$x\" if \"$x\";\n$gradient->Label('Gradient');\npush(@$images,$gradient);\n\nprint \"Grayscale...\\n\";\n$example=$model->Clone();\n$example->Label('Grayscale');\n$example->Set(type=>'grayscale');\npush(@$images,$example);\n\nprint \"Implode...\\n\";\n$example=$model->Clone();\n$example->Label('Implode');\n$example->Implode(0.5);\npush(@$images,$example);\n\nprint \"Kuwahara...\\n\";\n$example=$model->Clone();\n$example->Label('Kuwahara');\n$example->Kuwahara('0x1');\npush(@$images,$example);\n\nprint \"Level...\\n\";\n$example=$model->Clone();\n$example->Label('Level');\n$example->Level('20%x');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Linear stretch...\\n\";\n$example=$model->Clone();\n$example->Label('Linear Stretch');\n$example->LinearStretch('5x5');\npush(@$images,$example);\n\nprint \"Median Filter...\\n\";\n$example=$model->Clone();\n$example->Label('Median Filter');\n$example->MedianFilter('4x4');\npush(@$images,$example);\n\nprint \"Mode...\\n\";\n$example=$model->Clone();\n$example->Label('Mode');\n$example->Mode('4x4');\npush(@$images,$example);\n\nprint \"Modulate...\\n\";\n$example=$model->Clone();\n$example->Label('Modulate');\n$example->Modulate(brightness=>110,saturation=>110,hue=>110);\npush(@$images,$example);\n$example=$model->Clone();\n\nprint \"Monochrome...\\n\";\n$example=$model->Clone();\n$example->Label('Monochrome');\n$example->Quantize(colorspace=>'gray',colors=>2,dither=>'false');\npush(@$images,$example);\n\nprint \"Morphology...\\n\";\n$example=$model->Clone();\n$example->Label('Morphology');\n$example->Morphology(method=>'Dilate',kernel=>'Diamond',iterations=>2);\npush(@$images,$example);\n\nprint \"Motion Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Motion Blur');\n$example->MotionBlur('0x13+10-10');\npush(@$images,$example);\n\nprint \"Negate...\\n\";\n$example=$model->Clone();\n$example->Label('Negate');\n$example->Negate();\npush(@$images,$example);\n\nprint \"Normalize...\\n\";\n$example=$model->Clone();\n$example->Label('Normalize');\n$example->Normalize();\npush(@$images,$example);\n\nprint \"Oil Paint...\\n\";\n$example=$model->Clone();\n$example->Label('Oil Paint');\n$example->OilPaint('2x0.5');\npush(@$images,$example);\n\nprint \"Plasma...\\n\";\n$plasma=Image::Magick->new;\n$plasma->Set(size=>'130x194');\n$x=$plasma->ReadImage('plasma:fractal');\nwarn \"$x\" if \"$x\";\n$plasma->Label('Plasma');\npush(@$images,$plasma);\n\nprint \"Polaroid...\\n\";\n$example=$model->Clone();\n$example->Label('Polaroid');\n$example->Polaroid(caption=>'Magick',angle=>-5.0,gravity=>'center');\npush(@$images,$example);\n\nprint \"Posterize...\\n\";\n$example=$model->Clone();\n$example->Label('Posterize');\n$example->Posterize(5);\npush(@$images,$example);\n\nprint \"Quantize...\\n\";\n$example=$model->Clone();\n$example->Label('Quantize');\n$example->Quantize();\npush(@$images,$example);\n\nprint \"Rotational Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Rotational Blur');\n$example->RotationalBlur(10);\npush(@$images,$example);\n\nprint \"Raise...\\n\";\n$example=$model->Clone();\n$example->Label('Raise');\n$example->Raise('10x10');\npush(@$images,$example);\n\nprint \"Reduce Noise...\\n\";\n$example=$model->Clone();\n$example->Label('Reduce Noise');\n$example->ReduceNoise('2x2');\npush(@$images,$example);\n\nprint \"Resize...\\n\";\n$example=$model->Clone();\n$example->Label('Resize');\n$example->Resize('60%');\npush(@$images,$example);\n\nprint \"Roll...\\n\";\n$example=$model->Clone();\n$example->Label('Roll');\n$example->Roll(geometry=>'+20+10');\npush(@$images,$example);\n\nprint \"Rotate...\\n\";\n$example=$model->Clone();\n$example->Label('Rotate');\n$example->Rotate(45);\npush(@$images,$example);\n\nprint \"Sample...\\n\";\n$example=$model->Clone();\n$example->Label('Sample');\n$example->Sample('60%');\npush(@$images,$example);\n\nprint \"Scale...\\n\";\n$example=$model->Clone();\n$example->Label('Scale');\n$example->Scale('60%');\npush(@$images,$example);\n\nprint \"Segment...\\n\";\n$example=$model->Clone();\n$example->Label('Segment');\n$example->Segment();\npush(@$images,$example);\n\nprint \"Shade...\\n\";\n$example=$model->Clone();\n$example->Label('Shade');\n$example->Shade(geometry=>'30x30',gray=>'true');\npush(@$images,$example);\n\nprint \"Sharpen...\\n\";\n$example=$model->Clone();\n$example->Label('Sharpen');\n$example->Sharpen('0.0x1.0');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Shave...\\n\";\n$example=$model->Clone();\n$example->Label('Shave');\n$example->Shave('10x10');\npush(@$images,$example);\n\nprint \"Shear...\\n\";\n$example=$model->Clone();\n$example->Label('Shear');\n$example->Shear('-20x20');\npush(@$images,$example);\n\nprint \"Sketch...\\n\";\n$example=$model->Clone();\n$example->Label('Sketch');\n$example->Set(colorspace=>'Gray');\n$example->Sketch('0x20+120');\npush(@$images,$example);\n\nprint \"Sigmoidal Contrast...\\n\";\n$example=$model->Clone();\n$example->Label('Sigmoidal Contrast');\n$example->SigmoidalContrast(\"3x50%\");\npush(@$images,$example);\n\nprint \"Spread...\\n\";\n$example=$model->Clone();\n$example->Label('Spread');\n$example->Spread();\npush(@$images,$example);\n\nprint \"Solarize...\\n\";\n$example=$model->Clone();\n$example->Label('Solarize');\n$example->Solarize();\npush(@$images,$example);\n\nprint \"Swirl...\\n\";\n$example=$model->Clone();\n$example->Label('Swirl');\n$example->Swirl(90);\npush(@$images,$example);\n\nprint \"Tint...\\n\";\n$example=$model->Clone();\n$example->Label('Tint');\n$example->Tint('wheat');\npush(@$images,$example);\n\nprint \"Unsharp Mask...\\n\";\n$example=$model->Clone();\n$example->Label('Unsharp Mask');\n$example->UnsharpMask('0.0x1.0');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Vignette...\\n\";\n$example=$model->Clone();\n$example->Label('Vignette');\n$example->Vignette('0x20');\npush(@$images,$example);\n\nprint \"Wave...\\n\";\n$example=$model->Clone();\n$example->Label('Wave');\n$example->Wave('25x150');\npush(@$images,$example);\n\nprint \"WaveletDenoise...\\n\";\n$example=$model->Clone();\n$example->Label('WaveletDenoise');\n$example->WaveletDenoise('5%');\npush(@$images,$example);\n\n#\n# Create image montage.\n#\nprint \"Montage...\\n\";\n$montage=$images->Montage(geometry=>'128x160+8+4>',gravity=>'Center',\n  tile=>'5x+10+200',compose=>'over',background=>'#ffffff',font=>'Generic.ttf',\n  pointsize=>18,fill=>'#600',stroke=>'none',shadow=>'true');\n\n$logo=Image::Magick->new();\n$logo->Read('logo:');\n$logo->Zoom('40%');\n$montage->Composite(image=>$logo,gravity=>'North');\n\nprint \"Write...\\n\";\n$montage->Set(matte=>'false');\n$montage->Write('demo.jpg');\nprint \"Display...\\n\";\n$montage->Write('win:');\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                                 FFFFF  X   X                                %\n%                                 F       X X                                 %\n%                                 FFF      X                                  %\n%                                 F       X X                                 %\n%                                 F      X   X                                %\n%                                                                             %\n%                                                                             %\n%                   MagickCore Image Special Effects Methods                  %\n%                                                                             %\n%                               Software Design                               %\n%                                    Cristy                                   %\n%                                 October 1996                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\n\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/accelerate-private.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/fx-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/gem-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/random-private.h\"\n#include \"MagickCore/resample.h\"\n#include \"MagickCore/resample-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/transform-private.h\"\n#include \"MagickCore/utility.h\"\n\n\n/*\n  Define declarations.\n*/\n#define LeftShiftOperator  0xf5U\n#define RightShiftOperator  0xf6U\n#define LessThanEqualOperator  0xf7U\n#define GreaterThanEqualOperator  0xf8U\n#define EqualOperator  0xf9U\n#define NotEqualOperator  0xfaU\n#define LogicalAndOperator  0xfbU\n#define LogicalOrOperator  0xfcU\n#define ExponentialNotation 0xfdU\n\nstruct _FxInfo\n{\n  const Image\n    *images;\n\n  char\n    *expression;\n\n  FILE\n    *file;\n\n  SplayTreeInfo\n    *colors,\n    *symbols;\n\n  CacheView\n    **view;\n\n  RandomInfo\n    *random_info;\n\n  ExceptionInfo\n    *exception;\n};\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e F x I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireFxInfo() allocates the FxInfo structure.\n%\n%  The format of the AcquireFxInfo method is:\n%\n%      FxInfo *AcquireFxInfo(Image *image,const char *expression,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o expression: the expression.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate FxInfo *AcquireFxInfo(const Image *image,const char *expression,\n  ExceptionInfo *exception)\n{\n  char\n    fx_op[2];\n\n  const Image\n    *next;\n\n  FxInfo\n    *fx_info;\n\n  register ssize_t\n    i;\n\n  fx_info=(FxInfo *) AcquireMagickMemory(sizeof(*fx_info));\n  if (fx_info == (FxInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(fx_info,0,sizeof(*fx_info));\n  fx_info->exception=AcquireExceptionInfo();\n  fx_info->images=image;\n  fx_info->colors=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n    RelinquishAlignedMemory);\n  fx_info->symbols=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n    RelinquishMagickMemory);\n  fx_info->view=(CacheView **) AcquireQuantumMemory(GetImageListLength(\n    fx_info->images),sizeof(*fx_info->view));\n  if (fx_info->view == (CacheView **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  i=0;\n  next=GetFirstImageInList(fx_info->images);\n  for ( ; next != (Image *) NULL; next=next->next)\n  {\n    fx_info->view[i]=AcquireVirtualCacheView(next,exception);\n    i++;\n  }\n  fx_info->random_info=AcquireRandomInfo();\n  fx_info->expression=ConstantString(expression);\n  fx_info->file=stderr;\n  (void) SubstituteString(&fx_info->expression,\" \",\"\");  /* compact string */\n  /*\n    Force right-to-left associativity for unary negation.\n  */\n  (void) SubstituteString(&fx_info->expression,\"-\",\"-1.0*\");\n  (void) SubstituteString(&fx_info->expression,\"^-1.0*\",\"^-\");\n  (void) SubstituteString(&fx_info->expression,\"E-1.0*\",\"E-\");\n  (void) SubstituteString(&fx_info->expression,\"e-1.0*\",\"e-\");\n  /*\n    Convert compound to simple operators.\n  */\n  fx_op[1]='\\0';\n  *fx_op=(char) LeftShiftOperator;\n  (void) SubstituteString(&fx_info->expression,\"<<\",fx_op);\n  *fx_op=(char) RightShiftOperator;\n  (void) SubstituteString(&fx_info->expression,\">>\",fx_op);\n  *fx_op=(char) LessThanEqualOperator;\n  (void) SubstituteString(&fx_info->expression,\"<=\",fx_op);\n  *fx_op=(char) GreaterThanEqualOperator;\n  (void) SubstituteString(&fx_info->expression,\">=\",fx_op);\n  *fx_op=(char) EqualOperator;\n  (void) SubstituteString(&fx_info->expression,\"==\",fx_op);\n  *fx_op=(char) NotEqualOperator;\n  (void) SubstituteString(&fx_info->expression,\"!=\",fx_op);\n  *fx_op=(char) LogicalAndOperator;\n  (void) SubstituteString(&fx_info->expression,\"&&\",fx_op);\n  *fx_op=(char) LogicalOrOperator;\n  (void) SubstituteString(&fx_info->expression,\"||\",fx_op);\n  *fx_op=(char) ExponentialNotation;\n  (void) SubstituteString(&fx_info->expression,\"**\",fx_op);\n  return(fx_info);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A d d N o i s e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AddNoiseImage() adds random noise to the image.\n%\n%  The format of the AddNoiseImage method is:\n%\n%      Image *AddNoiseImage(const Image *image,const NoiseType noise_type,\n%        const double attenuate,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel type.\n%\n%    o noise_type:  The type of noise: Uniform, Gaussian, Multiplicative,\n%      Impulse, Laplacian, or Poisson.\n%\n%    o attenuate:  attenuate the random distribution.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AddNoiseImage(const Image *image,const NoiseType noise_type,\n  const double attenuate,ExceptionInfo *exception)\n{\n#define AddNoiseImageTag  \"AddNoise/Image\"\n\n  CacheView\n    *image_view,\n    *noise_view;\n\n  Image\n    *noise_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  /*\n    Initialize noise image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  noise_image=AccelerateAddNoiseImage(image,noise_type,exception);\n  if (noise_image != (Image *) NULL)\n    return(noise_image);\n#endif\n  noise_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (noise_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(noise_image,DirectClass,exception) == MagickFalse)\n    {\n      noise_image=DestroyImage(noise_image);\n      return((Image *) NULL);\n    }\n  /*\n    Add noise in each row.\n  */\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  image_view=AcquireVirtualCacheView(image,exception);\n  noise_view=AcquireAuthenticCacheView(noise_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,noise_image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(noise_view,0,y,noise_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait noise_traits=GetPixelChannelTraits(noise_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (noise_traits == UndefinedPixelTrait))\n          continue;\n        if (((noise_traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(image,p) == 0))\n          {\n            SetPixelChannel(noise_image,channel,p[i],q);\n            continue;\n          }\n        SetPixelChannel(noise_image,channel,ClampToQuantum(\n          GenerateDifferentialNoise(random_info[id],p[i],noise_type,attenuate)),\n          q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(noise_image);\n    }\n    sync=SyncCacheViewAuthenticPixels(noise_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_AddNoiseImage)\n#endif\n        proceed=SetImageProgress(image,AddNoiseImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  noise_view=DestroyCacheView(noise_view);\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  if (status == MagickFalse)\n    noise_image=DestroyImage(noise_image);\n  return(noise_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B l u e S h i f t I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlueShiftImage() mutes the colors of the image to simulate a scene at\n%  nighttime in the moonlight.\n%\n%  The format of the BlueShiftImage method is:\n%\n%      Image *BlueShiftImage(const Image *image,const double factor,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o factor: the shift factor.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *BlueShiftImage(const Image *image,const double factor,\n  ExceptionInfo *exception)\n{\n#define BlueShiftImageTag  \"BlueShift/Image\"\n\n  CacheView\n    *image_view,\n    *shift_view;\n\n  Image\n    *shift_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate blue shift image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  shift_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (shift_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(shift_image,DirectClass,exception) == MagickFalse)\n    {\n      shift_image=DestroyImage(shift_image);\n      return((Image *) NULL);\n    }\n  /*\n    Blue-shift DirectClass image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  shift_view=AcquireAuthenticCacheView(shift_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,shift_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    PixelInfo\n      pixel;\n\n    Quantum\n      quantum;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(shift_view,0,y,shift_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      quantum=GetPixelRed(image,p);\n      if (GetPixelGreen(image,p) < quantum)\n        quantum=GetPixelGreen(image,p);\n      if (GetPixelBlue(image,p) < quantum)\n        quantum=GetPixelBlue(image,p);\n      pixel.red=0.5*(GetPixelRed(image,p)+factor*quantum);\n      pixel.green=0.5*(GetPixelGreen(image,p)+factor*quantum);\n      pixel.blue=0.5*(GetPixelBlue(image,p)+factor*quantum);\n      quantum=GetPixelRed(image,p);\n      if (GetPixelGreen(image,p) > quantum)\n        quantum=GetPixelGreen(image,p);\n      if (GetPixelBlue(image,p) > quantum)\n        quantum=GetPixelBlue(image,p);\n      pixel.red=0.5*(pixel.red+factor*quantum);\n      pixel.green=0.5*(pixel.green+factor*quantum);\n      pixel.blue=0.5*(pixel.blue+factor*quantum);\n      SetPixelRed(shift_image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(shift_image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(shift_image,ClampToQuantum(pixel.blue),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(shift_image);\n    }\n    sync=SyncCacheViewAuthenticPixels(shift_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_BlueShiftImage)\n#endif\n        proceed=SetImageProgress(image,BlueShiftImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  shift_view=DestroyCacheView(shift_view);\n  if (status == MagickFalse)\n    shift_image=DestroyImage(shift_image);\n  return(shift_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C h a r c o a l I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CharcoalImage() creates a new image that is a copy of an existing one with\n%  the edge highlighted.  It allocates the memory necessary for the new Image\n%  structure and returns a pointer to the new image.\n%\n%  The format of the CharcoalImage method is:\n%\n%      Image *CharcoalImage(const Image *image,const double radius,\n%        const double sigma,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o radius: the radius of the pixel neighborhood.\n%\n%    o sigma: the standard deviation of the Gaussian, in pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CharcoalImage(const Image *image,const double radius,\n  const double sigma,ExceptionInfo *exception)\n{\n  Image\n    *charcoal_image,\n    *clone_image,\n    *edge_image;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  clone_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (clone_image == (Image *) NULL)\n    return((Image *) NULL);\n  edge_image=EdgeImage(clone_image,radius,exception);\n  clone_image=DestroyImage(clone_image);\n  if (edge_image == (Image *) NULL)\n    return((Image *) NULL);\n  charcoal_image=BlurImage(edge_image,radius,sigma,exception);\n  edge_image=DestroyImage(edge_image);\n  if (charcoal_image == (Image *) NULL)\n    return((Image *) NULL);\n  (void) NormalizeImage(charcoal_image,exception);\n  (void) NegateImage(charcoal_image,MagickFalse,exception);\n  (void) GrayscaleImage(charcoal_image,image->intensity,exception);\n  return(charcoal_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o l o r i z e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ColorizeImage() blends the fill color with each pixel in the image.\n%  A percentage blend is specified with opacity.  Control the application\n%  of different color components by specifying a different percentage for\n%  each component (e.g. 90/100/10 is 90% red, 100% green, and 10% blue).\n%\n%  The format of the ColorizeImage method is:\n%\n%      Image *ColorizeImage(const Image *image,const char *blend,\n%        const PixelInfo *colorize,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o blend:  A character string indicating the level of blending as a\n%      percentage.\n%\n%    o colorize: A color value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ColorizeImage(const Image *image,const char *blend,\n  const PixelInfo *colorize,ExceptionInfo *exception)\n{\n#define ColorizeImageTag  \"Colorize/Image\"\n#define Colorize(pixel,blend_percentage,colorize)  \\\n  (((pixel)*(100.0-(blend_percentage))+(colorize)*(blend_percentage))/100.0)\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *colorize_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickStatusType\n    flags;\n\n  PixelInfo\n    blend_percentage;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate colorized image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  colorize_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (colorize_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(colorize_image,DirectClass,exception) == MagickFalse)\n    {\n      colorize_image=DestroyImage(colorize_image);\n      return((Image *) NULL);\n    }\n  if ((IsGrayColorspace(colorize_image->colorspace) != MagickFalse) ||\n      (IsPixelInfoGray(colorize) != MagickFalse))\n    (void) SetImageColorspace(colorize_image,sRGBColorspace,exception);\n  if ((colorize_image->alpha_trait == UndefinedPixelTrait) &&\n      (colorize->alpha_trait != UndefinedPixelTrait))\n    (void) SetImageAlpha(colorize_image,OpaqueAlpha,exception);\n  if (blend == (const char *) NULL)\n    return(colorize_image);\n  GetPixelInfo(colorize_image,&blend_percentage);\n  flags=ParseGeometry(blend,&geometry_info);\n  blend_percentage.red=geometry_info.rho;\n  blend_percentage.green=geometry_info.rho;\n  blend_percentage.blue=geometry_info.rho;\n  blend_percentage.black=geometry_info.rho;\n  blend_percentage.alpha=(MagickRealType) TransparentAlpha;\n  if ((flags & SigmaValue) != 0)\n    blend_percentage.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    blend_percentage.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    blend_percentage.alpha=geometry_info.psi;\n  if (blend_percentage.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        blend_percentage.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        blend_percentage.alpha=geometry_info.chi;\n    }\n  /*\n    Colorize DirectClass image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(colorize_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(colorize_image,colorize_image,colorize_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) colorize_image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,colorize_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) colorize_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(colorize_image); i++)\n      {\n        PixelTrait traits=GetPixelChannelTraits(colorize_image,\n          (PixelChannel) i);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if (((traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(colorize_image,q) == 0))\n          continue;\n        SetPixelChannel(colorize_image,(PixelChannel) i,ClampToQuantum(\n          Colorize(q[i],GetPixelInfoChannel(&blend_percentage,(PixelChannel) i),\n          GetPixelInfoChannel(colorize,(PixelChannel) i))),q);\n      }\n      q+=GetPixelChannels(colorize_image);\n    }\n    sync=SyncCacheViewAuthenticPixels(image_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ColorizeImage)\n#endif\n        proceed=SetImageProgress(image,ColorizeImageTag,progress++,\n          colorize_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    colorize_image=DestroyImage(colorize_image);\n  return(colorize_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o l o r M a t r i x I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ColorMatrixImage() applies color transformation to an image. This method\n%  permits saturation changes, hue rotation, luminance to alpha, and various\n%  other effects.  Although variable-sized transformation matrices can be used,\n%  typically one uses a 5x5 matrix for an RGBA image and a 6x6 for CMYKA\n%  (or RGBA with offsets).  The matrix is similar to those used by Adobe Flash\n%  except offsets are in column 6 rather than 5 (in support of CMYKA images)\n%  and offsets are normalized (divide Flash offset by 255).\n%\n%  The format of the ColorMatrixImage method is:\n%\n%      Image *ColorMatrixImage(const Image *image,\n%        const KernelInfo *color_matrix,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o color_matrix:  the color matrix.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n/* FUTURE: modify to make use of a MagickMatrix Mutliply function\n   That should be provided in \"matrix.c\"\n   (ASIDE: actually distorts should do this too but currently doesn't)\n*/\n\nMagickExport Image *ColorMatrixImage(const Image *image,\n  const KernelInfo *color_matrix,ExceptionInfo *exception)\n{\n#define ColorMatrixImageTag  \"ColorMatrix/Image\"\n\n  CacheView\n    *color_view,\n    *image_view;\n\n  double\n    ColorMatrix[6][6] =\n    {\n      { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n      { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },\n      { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },\n      { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },\n      { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },\n      { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 }\n    };\n\n  Image\n    *color_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    u,\n    v,\n    y;\n\n  /*\n    Map given color_matrix, into a 6x6 matrix   RGBKA and a constant\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  i=0;\n  for (v=0; v < (ssize_t) color_matrix->height; v++)\n    for (u=0; u < (ssize_t) color_matrix->width; u++)\n    {\n      if ((v < 6) && (u < 6))\n        ColorMatrix[v][u]=color_matrix->values[i];\n      i++;\n    }\n  /*\n    Initialize color image.\n  */\n  color_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (color_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(color_image,DirectClass,exception) == MagickFalse)\n    {\n      color_image=DestroyImage(color_image);\n      return((Image *) NULL);\n    }\n  if (image->debug != MagickFalse)\n    {\n      char\n        format[MagickPathExtent],\n        *message;\n\n      (void) LogMagickEvent(TransformEvent,GetMagickModule(),\n        \"  ColorMatrix image with color matrix:\");\n      message=AcquireString(\"\");\n      for (v=0; v < 6; v++)\n      {\n        *message='\\0';\n        (void) FormatLocaleString(format,MagickPathExtent,\"%.20g: \",(double) v);\n        (void) ConcatenateString(&message,format);\n        for (u=0; u < 6; u++)\n        {\n          (void) FormatLocaleString(format,MagickPathExtent,\"%+f \",\n            ColorMatrix[v][u]);\n          (void) ConcatenateString(&message,format);\n        }\n        (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"%s\",message);\n      }\n      message=DestroyString(message);\n    }\n  /*\n    Apply the ColorMatrix to image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  color_view=AcquireAuthenticCacheView(color_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,color_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelInfo\n      pixel;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(color_view,0,y,color_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    GetPixelInfo(image,&pixel);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        v;\n\n      size_t\n        height;\n\n      GetPixelInfoPixel(image,p,&pixel);\n      height=color_matrix->height > 6 ? 6UL : color_matrix->height;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        double\n          sum;\n\n        sum=ColorMatrix[v][0]*GetPixelRed(image,p)+ColorMatrix[v][1]*\n          GetPixelGreen(image,p)+ColorMatrix[v][2]*GetPixelBlue(image,p);\n        if (image->colorspace == CMYKColorspace)\n          sum+=ColorMatrix[v][3]*GetPixelBlack(image,p);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          sum+=ColorMatrix[v][4]*GetPixelAlpha(image,p);\n        sum+=QuantumRange*ColorMatrix[v][5];\n        switch (v)\n        {\n          case 0: pixel.red=sum; break;\n          case 1: pixel.green=sum; break;\n          case 2: pixel.blue=sum; break;\n          case 3: pixel.black=sum; break;\n          case 4: pixel.alpha=sum; break;\n          default: break;\n        }\n      }\n      SetPixelViaPixelInfo(color_image,&pixel,q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(color_image);\n    }\n    if (SyncCacheViewAuthenticPixels(color_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ColorMatrixImage)\n#endif\n        proceed=SetImageProgress(image,ColorMatrixImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  color_view=DestroyCacheView(color_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    color_image=DestroyImage(color_image);\n  return(color_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y F x I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyFxInfo() deallocates memory associated with an FxInfo structure.\n%\n%  The format of the DestroyFxInfo method is:\n%\n%      ImageInfo *DestroyFxInfo(ImageInfo *fx_info)\n%\n%  A description of each parameter follows:\n%\n%    o fx_info: the fx info.\n%\n*/\nMagickPrivate FxInfo *DestroyFxInfo(FxInfo *fx_info)\n{\n  register ssize_t\n    i;\n\n  fx_info->exception=DestroyExceptionInfo(fx_info->exception);\n  fx_info->expression=DestroyString(fx_info->expression);\n  fx_info->symbols=DestroySplayTree(fx_info->symbols);\n  fx_info->colors=DestroySplayTree(fx_info->colors);\n  for (i=(ssize_t) GetImageListLength(fx_info->images)-1; i >= 0; i--)\n    fx_info->view[i]=DestroyCacheView(fx_info->view[i]);\n  fx_info->view=(CacheView **) RelinquishMagickMemory(fx_info->view);\n  fx_info->random_info=DestroyRandomInfo(fx_info->random_info);\n  fx_info=(FxInfo *) RelinquishMagickMemory(fx_info);\n  return(fx_info);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+     F x E v a l u a t e C h a n n e l E x p r e s s i o n                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FxEvaluateChannelExpression() evaluates an expression and returns the\n%  results.\n%\n%  The format of the FxEvaluateExpression method is:\n%\n%      double FxEvaluateChannelExpression(FxInfo *fx_info,\n%        const PixelChannel channel,const ssize_t x,const ssize_t y,\n%        double *alpha,Exceptioninfo *exception)\n%      double FxEvaluateExpression(FxInfo *fx_info,\n%        double *alpha,Exceptioninfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o fx_info: the fx info.\n%\n%    o channel: the channel.\n%\n%    o x,y: the pixel position.\n%\n%    o alpha: the result.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic double FxChannelStatistics(FxInfo *fx_info,Image *image,\n  PixelChannel channel,const char *symbol,ExceptionInfo *exception)\n{\n  ChannelType\n    channel_mask;\n\n  char\n    key[MagickPathExtent],\n    statistic[MagickPathExtent];\n\n  const char\n    *value;\n\n  register const char\n    *p;\n\n  channel_mask=UndefinedChannel;\n  for (p=symbol; (*p != '.') && (*p != '\\0'); p++) ;\n  if (*p == '.')\n    {\n      ssize_t\n        option;\n\n      option=ParseCommandOption(MagickPixelChannelOptions,MagickTrue,p+1);\n      if (option >= 0)\n        {\n          channel=(PixelChannel) option;\n          channel_mask=(ChannelType) (channel_mask | (1 << channel));\n          (void) SetPixelChannelMask(image,channel_mask);\n        }\n    }\n  (void) FormatLocaleString(key,MagickPathExtent,\"%p.%.20g.%s\",(void *) image,\n    (double) channel,symbol);\n  value=(const char *) GetValueFromSplayTree(fx_info->symbols,key);\n  if (value != (const char *) NULL)\n    {\n      if (channel_mask != UndefinedChannel)\n        (void) SetPixelChannelMask(image,channel_mask);\n      return(QuantumScale*StringToDouble(value,(char **) NULL));\n    }\n  (void) DeleteNodeFromSplayTree(fx_info->symbols,key);\n  if (LocaleNCompare(symbol,\"depth\",5) == 0)\n    {\n      size_t\n        depth;\n\n      depth=GetImageDepth(image,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%.20g\",(double)\n        depth);\n    }\n  if (LocaleNCompare(symbol,\"kurtosis\",8) == 0)\n    {\n      double\n        kurtosis,\n        skewness;\n\n      (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",kurtosis);\n    }\n  if (LocaleNCompare(symbol,\"maxima\",6) == 0)\n    {\n      double\n        maxima,\n        minima;\n\n      (void) GetImageRange(image,&minima,&maxima,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",maxima);\n    }\n  if (LocaleNCompare(symbol,\"mean\",4) == 0)\n    {\n      double\n        mean,\n        standard_deviation;\n\n      (void) GetImageMean(image,&mean,&standard_deviation,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",mean);\n    }\n  if (LocaleNCompare(symbol,\"minima\",6) == 0)\n    {\n      double\n        maxima,\n        minima;\n\n      (void) GetImageRange(image,&minima,&maxima,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",minima);\n    }\n  if (LocaleNCompare(symbol,\"skewness\",8) == 0)\n    {\n      double\n        kurtosis,\n        skewness;\n\n      (void) GetImageKurtosis(image,&kurtosis,&skewness,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",skewness);\n    }\n  if (LocaleNCompare(symbol,\"standard_deviation\",18) == 0)\n    {\n      double\n        mean,\n        standard_deviation;\n\n      (void) GetImageMean(image,&mean,&standard_deviation,exception);\n      (void) FormatLocaleString(statistic,MagickPathExtent,\"%g\",\n        standard_deviation);\n    }\n  if (channel_mask != UndefinedChannel)\n    (void) SetPixelChannelMask(image,channel_mask);\n  (void) AddValueToSplayTree(fx_info->symbols,ConstantString(key),\n    ConstantString(statistic));\n  return(QuantumScale*StringToDouble(statistic,(char **) NULL));\n}\n\nstatic double\n  FxEvaluateSubexpression(FxInfo *,const PixelChannel,const ssize_t,\n    const ssize_t,const char *,size_t *,double *,ExceptionInfo *);\n\nstatic MagickOffsetType FxGCD(MagickOffsetType alpha,MagickOffsetType beta)\n{\n  if (beta != 0)\n    return(FxGCD(beta,alpha % beta));\n  return(alpha);\n}\n\nstatic inline const char *FxSubexpression(const char *expression,\n  ExceptionInfo *exception)\n{\n  const char\n    *subexpression;\n\n  register ssize_t\n    level;\n\n  level=0;\n  subexpression=expression;\n  while ((*subexpression != '\\0') &&\n         ((level != 1) || (strchr(\")\",(int) *subexpression) == (char *) NULL)))\n  {\n    if (strchr(\"(\",(int) *subexpression) != (char *) NULL)\n      level++;\n    else\n      if (strchr(\")\",(int) *subexpression) != (char *) NULL)\n        level--;\n    subexpression++;\n  }\n  if (*subexpression == '\\0')\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"UnbalancedParenthesis\",\"`%s'\",expression);\n  return(subexpression);\n}\n\nstatic double FxGetSymbol(FxInfo *fx_info,const PixelChannel channel,\n  const ssize_t x,const ssize_t y,const char *expression,\n  ExceptionInfo *exception)\n{\n  char\n    *q,\n    subexpression[MagickPathExtent],\n    symbol[MagickPathExtent];\n\n  const char\n    *p,\n    *value;\n\n  Image\n    *image;\n\n  PixelInfo\n    pixel;\n\n  double\n    alpha,\n    beta;\n\n  PointInfo\n    point;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    length,\n    level;\n\n  p=expression;\n  i=GetImageIndexInList(fx_info->images);\n  depth=0;\n  level=0;\n  point.x=(double) x;\n  point.y=(double) y;\n  if (isalpha((int) ((unsigned char) *(p+1))) == 0)\n    {\n      if (strchr(\"suv\",(int) *p) != (char *) NULL)\n        {\n          switch (*p)\n          {\n            case 's':\n            default:\n            {\n              i=GetImageIndexInList(fx_info->images);\n              break;\n            }\n            case 'u': i=0; break;\n            case 'v': i=1; break;\n          }\n          p++;\n          if (*p == '[')\n            {\n              level++;\n              q=subexpression;\n              for (p++; *p != '\\0'; )\n              {\n                if (*p == '[')\n                  level++;\n                else\n                  if (*p == ']')\n                    {\n                      level--;\n                      if (level == 0)\n                        break;\n                    }\n                *q++=(*p++);\n              }\n              *q='\\0';\n              alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,\n                &depth,&beta,exception);\n              i=(ssize_t) (alpha+0.5);\n              p++;\n            }\n          if (*p == '.')\n            p++;\n        }\n      if ((*p == 'p') && (isalpha((int) ((unsigned char) *(p+1))) == 0))\n        {\n          p++;\n          if (*p == '{')\n            {\n              level++;\n              q=subexpression;\n              for (p++; *p != '\\0'; )\n              {\n                if (*p == '{')\n                  level++;\n                else\n                  if (*p == '}')\n                    {\n                      level--;\n                      if (level == 0)\n                        break;\n                    }\n                *q++=(*p++);\n              }\n              *q='\\0';\n              alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,\n                &depth,&beta,exception);\n              point.x=alpha;\n              point.y=beta;\n              p++;\n            }\n          else\n            if (*p == '[')\n              {\n                level++;\n                q=subexpression;\n                for (p++; *p != '\\0'; )\n                {\n                  if (*p == '[')\n                    level++;\n                  else\n                    if (*p == ']')\n                      {\n                        level--;\n                        if (level == 0)\n                          break;\n                      }\n                  *q++=(*p++);\n                }\n                *q='\\0';\n                alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,\n                  &depth,&beta,exception);\n                point.x+=alpha;\n                point.y+=beta;\n                p++;\n              }\n          if (*p == '.')\n            p++;\n        }\n    }\n  length=GetImageListLength(fx_info->images);\n  while (i < 0)\n    i+=(ssize_t) length;\n  if (length != 0)\n    i%=length;\n  image=GetImageFromList(fx_info->images,i);\n  if (image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"NoSuchImage\",\"`%s'\",expression);\n      return(0.0);\n    }\n  GetPixelInfo(image,&pixel);\n  (void) InterpolatePixelInfo(image,fx_info->view[i],image->interpolate,\n    point.x,point.y,&pixel,exception);\n  if ((strlen(p) > 2) && (LocaleCompare(p,\"intensity\") != 0) &&\n      (LocaleCompare(p,\"luma\") != 0) && (LocaleCompare(p,\"luminance\") != 0) &&\n      (LocaleCompare(p,\"hue\") != 0) && (LocaleCompare(p,\"saturation\") != 0) &&\n      (LocaleCompare(p,\"lightness\") != 0))\n    {\n      char\n        name[MagickPathExtent];\n\n      (void) CopyMagickString(name,p,MagickPathExtent);\n      for (q=name+(strlen(name)-1); q > name; q--)\n      {\n        if (*q == ')')\n          break;\n        if (*q == '.')\n          {\n            *q='\\0';\n            break;\n          }\n      }\n      if ((strlen(name) > 2) &&\n          (GetValueFromSplayTree(fx_info->symbols,name) == (const char *) NULL))\n        {\n          PixelInfo\n            *color;\n\n          color=(PixelInfo *) GetValueFromSplayTree(fx_info->colors,name);\n          if (color != (PixelInfo *) NULL)\n            {\n              pixel=(*color);\n              p+=strlen(name);\n            }\n          else\n            {\n              MagickBooleanType\n                status;\n\n              status=QueryColorCompliance(name,AllCompliance,&pixel,\n                fx_info->exception);\n              if (status != MagickFalse)\n                {\n                  (void) AddValueToSplayTree(fx_info->colors,ConstantString(\n                    name),ClonePixelInfo(&pixel));\n                  p+=strlen(name);\n                }\n            }\n        }\n    }\n  (void) CopyMagickString(symbol,p,MagickPathExtent);\n  StripString(symbol);\n  if (*symbol == '\\0')\n    {\n      switch (channel)\n      {\n        case RedPixelChannel: return(QuantumScale*pixel.red);\n        case GreenPixelChannel: return(QuantumScale*pixel.green);\n        case BluePixelChannel: return(QuantumScale*pixel.blue);\n        case BlackPixelChannel:\n        {\n          if (image->colorspace != CMYKColorspace)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                ImageError,\"ColorSeparatedImageRequired\",\"`%s'\",\n                image->filename);\n              return(0.0);\n            }\n          return(QuantumScale*pixel.black);\n        }\n        case AlphaPixelChannel:\n        {\n          if (pixel.alpha_trait == UndefinedPixelTrait)\n            return(1.0);\n          alpha=(double) (QuantumScale*pixel.alpha);\n          return(alpha);\n        }\n        case IndexPixelChannel:\n          return(0.0);\n        case IntensityPixelChannel:\n        {\n          Quantum\n            quantum_pixel[MaxPixelChannels];\n\n          SetPixelViaPixelInfo(image,&pixel,quantum_pixel);\n          return(QuantumScale*GetPixelIntensity(image,quantum_pixel));\n        }\n        default:\n          break;\n      }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"UnableToParseExpression\",\"`%s'\",p);\n      return(0.0);\n    }\n  switch (*symbol)\n  {\n    case 'A':\n    case 'a':\n    {\n      if (LocaleCompare(symbol,\"a\") == 0)\n        return((QuantumScale*pixel.alpha));\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(symbol,\"b\") == 0)\n        return(QuantumScale*pixel.blue);\n      break;\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleNCompare(symbol,\"channel\",7) == 0)\n        {\n          GeometryInfo\n            channel_info;\n\n          MagickStatusType\n            flags;\n\n          flags=ParseGeometry(symbol+7,&channel_info);\n          if (image->colorspace == CMYKColorspace)\n            switch (channel)\n            {\n              case CyanPixelChannel:\n              {\n                if ((flags & RhoValue) == 0)\n                  return(0.0);\n                return(channel_info.rho);\n              }\n              case MagentaPixelChannel:\n              {\n                if ((flags & SigmaValue) == 0)\n                  return(0.0);\n                return(channel_info.sigma);\n              }\n              case YellowPixelChannel:\n              {\n                if ((flags & XiValue) == 0)\n                  return(0.0);\n                return(channel_info.xi);\n              }\n              case BlackPixelChannel:\n              {\n                if ((flags & PsiValue) == 0)\n                  return(0.0);\n                return(channel_info.psi);\n              }\n              case AlphaPixelChannel:\n              {\n                if ((flags & ChiValue) == 0)\n                  return(0.0);\n                return(channel_info.chi);\n              }\n              default:\n                return(0.0);\n            }\n          switch (channel)\n          {\n            case RedPixelChannel:\n            {\n              if ((flags & RhoValue) == 0)\n                return(0.0);\n              return(channel_info.rho);\n            }\n            case GreenPixelChannel:\n            {\n              if ((flags & SigmaValue) == 0)\n                return(0.0);\n              return(channel_info.sigma);\n            }\n            case BluePixelChannel:\n            {\n              if ((flags & XiValue) == 0)\n                return(0.0);\n              return(channel_info.xi);\n            }\n            case BlackPixelChannel:\n            {\n              if ((flags & ChiValue) == 0)\n                return(0.0);\n              return(channel_info.chi);\n            }\n            case AlphaPixelChannel:\n            {\n              if ((flags & PsiValue) == 0)\n                return(0.0);\n              return(channel_info.psi);\n            }\n            default:\n              return(0.0);\n          }\n        }\n      if (LocaleCompare(symbol,\"c\") == 0)\n        return(QuantumScale*pixel.red);\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleNCompare(symbol,\"depth\",5) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(symbol,\"g\") == 0)\n        return(QuantumScale*pixel.green);\n      break;\n    }\n    case 'K':\n    case 'k':\n    {\n      if (LocaleNCompare(symbol,\"kurtosis\",8) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleCompare(symbol,\"k\") == 0)\n        {\n          if (image->colorspace != CMYKColorspace)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"ColorSeparatedImageRequired\",\"`%s'\",\n                image->filename);\n              return(0.0);\n            }\n          return(QuantumScale*pixel.black);\n        }\n      break;\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(symbol,\"h\") == 0)\n        return(image->rows);\n      if (LocaleCompare(symbol,\"hue\") == 0)\n        {\n          double\n            hue,\n            lightness,\n            saturation;\n\n          ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,\n            &lightness);\n          return(hue);\n        }\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if ((LocaleCompare(symbol,\"image.depth\") == 0) ||\n          (LocaleCompare(symbol,\"image.minima\") == 0) ||\n          (LocaleCompare(symbol,\"image.maxima\") == 0) ||\n          (LocaleCompare(symbol,\"image.mean\") == 0) ||\n          (LocaleCompare(symbol,\"image.kurtosis\") == 0) ||\n          (LocaleCompare(symbol,\"image.skewness\") == 0) ||\n          (LocaleCompare(symbol,\"image.standard_deviation\") == 0))\n        return(FxChannelStatistics(fx_info,image,channel,symbol+6,exception));\n      if (LocaleCompare(symbol,\"image.resolution.x\") == 0)\n        return(image->resolution.x);\n      if (LocaleCompare(symbol,\"image.resolution.y\") == 0)\n        return(image->resolution.y);\n      if (LocaleCompare(symbol,\"intensity\") == 0)\n        {\n          Quantum\n            quantum_pixel[MaxPixelChannels];\n\n          SetPixelViaPixelInfo(image,&pixel,quantum_pixel);\n          return(QuantumScale*GetPixelIntensity(image,quantum_pixel));\n        }\n      if (LocaleCompare(symbol,\"i\") == 0)\n        return(x);\n      break;\n    }\n    case 'J':\n    case 'j':\n    {\n      if (LocaleCompare(symbol,\"j\") == 0)\n        return(y);\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(symbol,\"lightness\") == 0)\n        {\n          double\n            hue,\n            lightness,\n            saturation;\n\n          ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,\n            &lightness);\n          return(lightness);\n        }\n      if (LocaleCompare(symbol,\"luma\") == 0)\n        {\n          double\n            luma;\n\n          luma=0.212656*pixel.red+0.715158*pixel.green+0.072186*pixel.blue;\n          return(QuantumScale*luma);\n        }\n      if (LocaleCompare(symbol,\"luminance\") == 0)\n        {\n          double\n            luminence;\n\n          luminence=0.212656*pixel.red+0.715158*pixel.green+0.072186*pixel.blue;\n          return(QuantumScale*luminence);\n        }\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleNCompare(symbol,\"maxima\",6) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleNCompare(symbol,\"mean\",4) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleNCompare(symbol,\"minima\",6) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleCompare(symbol,\"m\") == 0)\n        return(QuantumScale*pixel.green);\n      break;\n    }\n    case 'N':\n    case 'n':\n    {\n      if (LocaleCompare(symbol,\"n\") == 0)\n        return(GetImageListLength(fx_info->images));\n      break;\n    }\n    case 'O':\n    case 'o':\n    {\n      if (LocaleCompare(symbol,\"o\") == 0)\n        return(QuantumScale*pixel.alpha);\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(symbol,\"page.height\") == 0)\n        return(image->page.height);\n      if (LocaleCompare(symbol,\"page.width\") == 0)\n        return(image->page.width);\n      if (LocaleCompare(symbol,\"page.x\") == 0)\n        return(image->page.x);\n      if (LocaleCompare(symbol,\"page.y\") == 0)\n        return(image->page.y);\n      break;\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare(symbol,\"quality\") == 0)\n        return(image->quality);\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(symbol,\"resolution.x\") == 0)\n        return(image->resolution.x);\n      if (LocaleCompare(symbol,\"resolution.y\") == 0)\n        return(image->resolution.y);\n      if (LocaleCompare(symbol,\"r\") == 0)\n        return(QuantumScale*pixel.red);\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare(symbol,\"saturation\") == 0)\n        {\n          double\n            hue,\n            lightness,\n            saturation;\n\n          ConvertRGBToHSL(pixel.red,pixel.green,pixel.blue,&hue,&saturation,\n            &lightness);\n          return(saturation);\n        }\n      if (LocaleNCompare(symbol,\"skewness\",8) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      if (LocaleNCompare(symbol,\"standard_deviation\",18) == 0)\n        return(FxChannelStatistics(fx_info,image,channel,symbol,exception));\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(symbol,\"t\") == 0)\n        return(GetImageIndexInList(fx_info->images));\n      break;\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(symbol,\"w\") == 0)\n        return(image->columns);\n      break;\n    }\n    case 'Y':\n    case 'y':\n    {\n      if (LocaleCompare(symbol,\"y\") == 0)\n        return(QuantumScale*pixel.blue);\n      break;\n    }\n    case 'Z':\n    case 'z':\n    {\n      if (LocaleCompare(symbol,\"z\") == 0)\n        return((double)GetImageDepth(image, fx_info->exception));\n      break;\n    }\n    default:\n      break;\n  }\n  value=(const char *) GetValueFromSplayTree(fx_info->symbols,symbol);\n  if (value != (const char *) NULL)\n    return(StringToDouble(value,(char **) NULL));\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n    \"UnableToParseExpression\",\"`%s'\",symbol);\n  return(0.0);\n}\n\nstatic const char *FxOperatorPrecedence(const char *expression,\n  ExceptionInfo *exception)\n{\n  typedef enum\n  {\n    UndefinedPrecedence,\n    NullPrecedence,\n    BitwiseComplementPrecedence,\n    ExponentPrecedence,\n    ExponentialNotationPrecedence,\n    MultiplyPrecedence,\n    AdditionPrecedence,\n    ShiftPrecedence,\n    RelationalPrecedence,\n    EquivalencyPrecedence,\n    BitwiseAndPrecedence,\n    BitwiseOrPrecedence,\n    LogicalAndPrecedence,\n    LogicalOrPrecedence,\n    TernaryPrecedence,\n    AssignmentPrecedence,\n    CommaPrecedence,\n    SeparatorPrecedence\n  } FxPrecedence;\n\n  FxPrecedence\n    precedence,\n    target;\n\n  register const char\n    *subexpression;\n\n  register int\n    c;\n\n  size_t\n    level;\n\n  c=0;\n  level=0;\n  subexpression=(const char *) NULL;\n  target=NullPrecedence;\n  while (*expression != '\\0')\n  {\n    precedence=UndefinedPrecedence;\n    if ((isspace((int) ((unsigned char) *expression)) != 0) || (c == (int) '@'))\n      {\n        expression++;\n        continue;\n      }\n    switch (*expression)\n    {\n      case 'A':\n      case 'a':\n      {\n#if defined(MAGICKCORE_HAVE_ACOSH)\n        if (LocaleNCompare(expression,\"acosh\",5) == 0)\n          {\n            expression+=5;\n            break;\n          }\n#endif\n#if defined(MAGICKCORE_HAVE_ASINH)\n        if (LocaleNCompare(expression,\"asinh\",5) == 0)\n          {\n            expression+=5;\n            break;\n          }\n#endif\n#if defined(MAGICKCORE_HAVE_ATANH)\n        if (LocaleNCompare(expression,\"atanh\",5) == 0)\n          {\n            expression+=5;\n            break;\n          }\n#endif\n        if (LocaleNCompare(expression,\"atan2\",5) == 0)\n          {\n            expression+=5;\n            break;\n          }\n        break;\n      }\n      case 'E':\n      case 'e':\n      {\n        if ((isdigit((int) ((unsigned char) c)) != 0) &&\n            ((LocaleNCompare(expression,\"E+\",2) == 0) ||\n             (LocaleNCompare(expression,\"E-\",2) == 0)))\n          {\n            expression+=2;  /* scientific notation */\n            break;\n          }\n      }\n      case 'J':\n      case 'j':\n      {\n        if ((LocaleNCompare(expression,\"j0\",2) == 0) ||\n            (LocaleNCompare(expression,\"j1\",2) == 0))\n          {\n            expression+=2;\n            break;\n          }\n        break;\n      }\n      case '#':\n      {\n        while (isxdigit((int) ((unsigned char) *(expression+1))) != 0)\n          expression++;\n        break;\n      }\n      default:\n        break;\n    }\n    if ((c == (int) '{') || (c == (int) '['))\n      level++;\n    else\n      if ((c == (int) '}') || (c == (int) ']'))\n        level--;\n    if (level == 0)\n      switch ((unsigned char) *expression)\n      {\n        case '~':\n        case '!':\n        {\n          precedence=BitwiseComplementPrecedence;\n          break;\n        }\n        case '^':\n        case '@':\n        {\n          precedence=ExponentPrecedence;\n          break;\n        }\n        default:\n        {\n          if (((c != 0) && ((isdigit((int) ((unsigned char) c)) != 0) ||\n               (strchr(\")\",(int) ((unsigned char) c)) != (char *) NULL))) &&\n              (((islower((int) ((unsigned char) *expression)) != 0) ||\n               (strchr(\"(\",(int) ((unsigned char) *expression)) != (char *) NULL)) ||\n               ((isdigit((int) ((unsigned char) c)) == 0) &&\n                (isdigit((int) ((unsigned char) *expression)) != 0))) &&\n              (strchr(\"xy\",(int) ((unsigned char) *expression)) == (char *) NULL))\n            precedence=MultiplyPrecedence;\n          break;\n        }\n        case '*':\n        case '/':\n        case '%':\n        {\n          precedence=MultiplyPrecedence;\n          break;\n        }\n        case '+':\n        case '-':\n        {\n          if ((strchr(\"(+-/*%:&^|<>~,\",c) == (char *) NULL) ||\n              (isalpha(c) != 0))\n            precedence=AdditionPrecedence;\n          break;\n        }\n        case LeftShiftOperator:\n        case RightShiftOperator:\n        {\n          precedence=ShiftPrecedence;\n          break;\n        }\n        case '<':\n        case LessThanEqualOperator:\n        case GreaterThanEqualOperator:\n        case '>':\n        {\n          precedence=RelationalPrecedence;\n          break;\n        }\n        case EqualOperator:\n        case NotEqualOperator:\n        {\n          precedence=EquivalencyPrecedence;\n          break;\n        }\n        case '&':\n        {\n          precedence=BitwiseAndPrecedence;\n          break;\n        }\n        case '|':\n        {\n          precedence=BitwiseOrPrecedence;\n          break;\n        }\n        case LogicalAndOperator:\n        {\n          precedence=LogicalAndPrecedence;\n          break;\n        }\n        case LogicalOrOperator:\n        {\n          precedence=LogicalOrPrecedence;\n          break;\n        }\n        case ExponentialNotation:\n        {\n          precedence=ExponentialNotationPrecedence;\n          break;\n        }\n        case ':':\n        case '?':\n        {\n          precedence=TernaryPrecedence;\n          break;\n        }\n        case '=':\n        {\n          precedence=AssignmentPrecedence;\n          break;\n        }\n        case ',':\n        {\n          precedence=CommaPrecedence;\n          break;\n        }\n        case ';':\n        {\n          precedence=SeparatorPrecedence;\n          break;\n        }\n      }\n    if ((precedence == BitwiseComplementPrecedence) ||\n        (precedence == TernaryPrecedence) ||\n        (precedence == AssignmentPrecedence))\n      {\n        if (precedence > target)\n          {\n            /*\n              Right-to-left associativity.\n            */\n            target=precedence;\n            subexpression=expression;\n          }\n      }\n    else\n      if (precedence >= target)\n        {\n          /*\n            Left-to-right associativity.\n          */\n          target=precedence;\n          subexpression=expression;\n        }\n    if (strchr(\"(\",(int) *expression) != (char *) NULL)\n      expression=FxSubexpression(expression,exception);\n    c=(int) (*expression++);\n  }\n  return(subexpression);\n}\n\nstatic double FxEvaluateSubexpression(FxInfo *fx_info,\n  const PixelChannel channel,const ssize_t x,const ssize_t y,\n  const char *expression,size_t *depth,double *beta,ExceptionInfo *exception)\n{\n#define FxMaxParenthesisDepth  58\n\n  char\n    *q,\n    subexpression[MagickPathExtent];\n\n  double\n    alpha,\n    gamma;\n\n  register const char\n    *p;\n\n  *beta=0.0;\n  if (exception->severity >= ErrorException)\n    return(0.0);\n  while (isspace((int) ((unsigned char) *expression)) != 0)\n    expression++;\n  if (*expression == '\\0')\n    return(0.0);\n  *subexpression='\\0';\n  p=FxOperatorPrecedence(expression,exception);\n  if (p != (const char *) NULL)\n    {\n      (void) CopyMagickString(subexpression,expression,(size_t)\n        (p-expression+1));\n      alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth,\n        beta,exception);\n      switch ((unsigned char) *p)\n      {\n        case '~':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) (~(size_t) *beta);\n          return(*beta);\n        }\n        case '!':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(*beta == 0.0 ? 1.0 : 0.0);\n        }\n        case '^':\n        {\n          *beta=pow(alpha,FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,\n            beta,exception));\n          return(*beta);\n        }\n        case '*':\n        case ExponentialNotation:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha*(*beta));\n        }\n        case '/':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          if (*beta == 0.0)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"DivideByZero\",\"`%s'\",expression);\n              return(0.0);\n            }\n          return(alpha/(*beta));\n        }\n        case '%':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=fabs(floor((*beta)+0.5));\n          if (*beta == 0.0)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"DivideByZero\",\"`%s'\",expression);\n              return(0.0);\n            }\n          return(fmod(alpha,*beta));\n        }\n        case '+':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha+(*beta));\n        }\n        case '-':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha-(*beta));\n        }\n        case LeftShiftOperator:\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) << (size_t) (gamma+0.5));\n          return(*beta);\n        }\n        case RightShiftOperator:\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) >> (size_t) (gamma+0.5));\n          return(*beta);\n        }\n        case '<':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha < *beta ? 1.0 : 0.0);\n        }\n        case LessThanEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha <= *beta ? 1.0 : 0.0);\n        }\n        case '>':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha > *beta ? 1.0 : 0.0);\n        }\n        case GreaterThanEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha >= *beta ? 1.0 : 0.0);\n        }\n        case EqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(fabs(alpha-(*beta)) < MagickEpsilon ? 1.0 : 0.0);\n        }\n        case NotEqualOperator:\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(fabs(alpha-(*beta)) >= MagickEpsilon ? 1.0 : 0.0);\n        }\n        case '&':\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) & (size_t) (gamma+0.5));\n          return(*beta);\n        }\n        case '|':\n        {\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          *beta=(double) ((size_t) (alpha+0.5) | (size_t) (gamma+0.5));\n          return(*beta);\n        }\n        case LogicalAndOperator:\n        {\n          p++;\n          if (alpha <= 0.0)\n            {\n              *beta=0.0;\n              return(*beta);\n            }\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,beta,\n            exception);\n          *beta=(gamma > 0.0) ? 1.0 : 0.0;\n          return(*beta);\n        }\n        case LogicalOrOperator:\n        {\n          p++;\n          if (alpha > 0.0)\n            {\n             *beta=1.0;\n             return(*beta);\n            }\n          gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,beta,\n            exception);\n          *beta=(gamma > 0.0) ? 1.0 : 0.0;\n          return(*beta);\n        }\n        case '?':\n        {\n          (void) CopyMagickString(subexpression,++p,MagickPathExtent);\n          q=subexpression;\n          p=StringToken(\":\",&q);\n          if (q == (char *) NULL)\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              return(0.0);\n            }\n          if (fabs(alpha) >= MagickEpsilon)\n            gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,beta,\n              exception);\n          else\n            gamma=FxEvaluateSubexpression(fx_info,channel,x,y,q,depth,beta,\n              exception);\n          return(gamma);\n        }\n        case '=':\n        {\n          char\n            numeric[MagickPathExtent];\n\n          q=subexpression;\n          while (isalpha((int) ((unsigned char) *q)) != 0)\n            q++;\n          if (*q != '\\0')\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionError,\"UnableToParseExpression\",\"`%s'\",subexpression);\n              return(0.0);\n            }\n          ClearMagickException(exception);\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          (void) FormatLocaleString(numeric,MagickPathExtent,\"%g\",*beta);\n          (void) DeleteNodeFromSplayTree(fx_info->symbols,subexpression);\n          (void) AddValueToSplayTree(fx_info->symbols,ConstantString(\n            subexpression),ConstantString(numeric));\n          return(*beta);\n        }\n        case ',':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(alpha);\n        }\n        case ';':\n        {\n          *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth,beta,\n            exception);\n          return(*beta);\n        }\n        default:\n        {\n          gamma=alpha*FxEvaluateSubexpression(fx_info,channel,x,y,p,depth,beta,\n            exception);\n          return(gamma);\n        }\n      }\n    }\n  if (strchr(\"(\",(int) *expression) != (char *) NULL)\n    {\n      (*depth)++;\n      if (*depth >= FxMaxParenthesisDepth)\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"ParenthesisNestedTooDeeply\",\"`%s'\",expression);\n      (void) CopyMagickString(subexpression,expression+1,MagickPathExtent);\n      subexpression[strlen(subexpression)-1]='\\0';\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth,\n        beta,exception);\n      (*depth)--;\n      return(gamma);\n    }\n  switch (*expression)\n  {\n    case '+':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth,beta,\n        exception);\n      return(1.0*gamma);\n    }\n    case '-':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth,beta,\n        exception);\n      return(-1.0*gamma);\n    }\n    case '~':\n    {\n      gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth,beta,\n        exception);\n      return((~(size_t) (gamma+0.5)));\n    }\n    case 'A':\n    case 'a':\n    {\n      if (LocaleNCompare(expression,\"abs\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(fabs(alpha));\n        }\n#if defined(MAGICKCORE_HAVE_ACOSH)\n      if (LocaleNCompare(expression,\"acosh\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(acosh(alpha));\n        }\n#endif\n      if (LocaleNCompare(expression,\"acos\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(acos(alpha));\n        }\n#if defined(MAGICKCORE_HAVE_J1)\n      if (LocaleNCompare(expression,\"airy\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          if (alpha == 0.0)\n            return(1.0);\n          gamma=2.0*j1((MagickPI*alpha))/(MagickPI*alpha);\n          return(gamma*gamma);\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_ASINH)\n      if (LocaleNCompare(expression,\"asinh\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(asinh(alpha));\n        }\n#endif\n      if (LocaleNCompare(expression,\"asin\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(asin(alpha));\n        }\n      if (LocaleNCompare(expression,\"alt\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(((ssize_t) alpha) & 0x01 ? -1.0 : 1.0);\n        }\n      if (LocaleNCompare(expression,\"atan2\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(atan2(alpha,*beta));\n        }\n#if defined(MAGICKCORE_HAVE_ATANH)\n      if (LocaleNCompare(expression,\"atanh\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(atanh(alpha));\n        }\n#endif\n      if (LocaleNCompare(expression,\"atan\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(atan(alpha));\n        }\n      if (LocaleCompare(expression,\"a\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(expression,\"b\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleNCompare(expression,\"ceil\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(ceil(alpha));\n        }\n      if (LocaleNCompare(expression,\"clamp\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          if (alpha < 0.0)\n            return(0.0);\n          if (alpha > 1.0)\n            return(1.0);\n          return(alpha);\n        }\n      if (LocaleNCompare(expression,\"cosh\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(cosh(alpha));\n        }\n      if (LocaleNCompare(expression,\"cos\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(cos(alpha));\n        }\n      if (LocaleCompare(expression,\"c\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleNCompare(expression,\"debug\",5) == 0)\n        {\n          const char\n            *type;\n\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          if (fx_info->images->colorspace == CMYKColorspace)\n            switch (channel)\n            {\n              case CyanPixelChannel: type=\"cyan\"; break;\n              case MagentaPixelChannel: type=\"magenta\"; break;\n              case YellowPixelChannel: type=\"yellow\"; break;\n              case AlphaPixelChannel: type=\"opacity\"; break;\n              case BlackPixelChannel: type=\"black\"; break;\n              default: type=\"unknown\"; break;\n            }\n          else\n            switch (channel)\n            {\n              case RedPixelChannel: type=\"red\"; break;\n              case GreenPixelChannel: type=\"green\"; break;\n              case BluePixelChannel: type=\"blue\"; break;\n              case AlphaPixelChannel: type=\"opacity\"; break;\n              default: type=\"unknown\"; break;\n            }\n          (void) CopyMagickString(subexpression,expression+6,MagickPathExtent);\n          if (strlen(subexpression) > 1)\n            subexpression[strlen(subexpression)-1]='\\0';\n          if (fx_info->file != (FILE *) NULL)\n            (void) FormatLocaleFile(fx_info->file,\"%s[%.20g,%.20g].%s: \"\n               \"%s=%.*g\\n\",fx_info->images->filename,(double) x,(double) y,type,\n               subexpression,GetMagickPrecision(),alpha);\n          return(0.0);\n        }\n      if (LocaleNCompare(expression,\"drc\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return((alpha/(*beta*(alpha-1.0)+1.0)));\n        }\n      break;\n    }\n    case 'E':\n    case 'e':\n    {\n      if (LocaleCompare(expression,\"epsilon\") == 0)\n        return(MagickEpsilon);\n#if defined(MAGICKCORE_HAVE_ERF)\n      if (LocaleNCompare(expression,\"erf\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(erf(alpha));\n        }\n#endif\n      if (LocaleNCompare(expression,\"exp\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(exp(alpha));\n        }\n      if (LocaleCompare(expression,\"e\") == 0)\n        return(2.7182818284590452354);\n      break;\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(expression,\"floor\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(floor(alpha));\n        }\n      break;\n    }\n    case 'G':\n    case 'g':\n    {\n      if (LocaleNCompare(expression,\"gauss\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          gamma=exp((-alpha*alpha/2.0))/sqrt(2.0*MagickPI);\n          return(gamma);\n        }\n      if (LocaleNCompare(expression,\"gcd\",3) == 0)\n        {\n          MagickOffsetType\n            gcd;\n\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          gcd=FxGCD((MagickOffsetType) (alpha+0.5),(MagickOffsetType) (*beta+\n            0.5));\n          return(gcd);\n        }\n      if (LocaleCompare(expression,\"g\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(expression,\"h\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      if (LocaleCompare(expression,\"hue\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      if (LocaleNCompare(expression,\"hypot\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(hypot(alpha,*beta));\n        }\n      break;\n    }\n    case 'K':\n    case 'k':\n    {\n      if (LocaleCompare(expression,\"k\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(expression,\"intensity\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      if (LocaleNCompare(expression,\"int\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(floor(alpha));\n        }\n      if (LocaleNCompare(expression,\"isnan\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(!!IsNaN(alpha));\n        }\n      if (LocaleCompare(expression,\"i\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'J':\n    case 'j':\n    {\n      if (LocaleCompare(expression,\"j\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n#if defined(MAGICKCORE_HAVE_J0)\n      if (LocaleNCompare(expression,\"j0\",2) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth,\n            beta,exception);\n          return(j0(alpha));\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_J1)\n      if (LocaleNCompare(expression,\"j1\",2) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth,\n            beta,exception);\n          return(j1(alpha));\n        }\n#endif\n#if defined(MAGICKCORE_HAVE_J1)\n      if (LocaleNCompare(expression,\"jinc\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          if (alpha == 0.0)\n            return(1.0);\n          gamma=(2.0*j1((MagickPI*alpha))/(MagickPI*alpha));\n          return(gamma);\n        }\n#endif\n      break;\n    }\n    case 'L':\n    case 'l':\n    {\n      if (LocaleNCompare(expression,\"ln\",2) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,depth,\n            beta,exception);\n          return(log(alpha));\n        }\n      if (LocaleNCompare(expression,\"logtwo\",6) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+6,depth,\n            beta,exception);\n          return(log10(alpha))/log10(2.0);\n        }\n      if (LocaleNCompare(expression,\"log\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(log10(alpha));\n        }\n      if (LocaleCompare(expression,\"lightness\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'M':\n    case 'm':\n    {\n      if (LocaleCompare(expression,\"MaxRGB\") == 0)\n        return(QuantumRange);\n      if (LocaleNCompare(expression,\"maxima\",6) == 0)\n        break;\n      if (LocaleNCompare(expression,\"max\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(alpha > *beta ? alpha : *beta);\n        }\n      if (LocaleNCompare(expression,\"minima\",6) == 0)\n        break;\n      if (LocaleNCompare(expression,\"min\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(alpha < *beta ? alpha : *beta);\n        }\n      if (LocaleNCompare(expression,\"mod\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          gamma=alpha-floor((alpha/(*beta)))*(*beta);\n          return(gamma);\n        }\n      if (LocaleCompare(expression,\"m\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'N':\n    case 'n':\n    {\n      if (LocaleNCompare(expression,\"not\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return((alpha < MagickEpsilon));\n        }\n      if (LocaleCompare(expression,\"n\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'O':\n    case 'o':\n    {\n      if (LocaleCompare(expression,\"Opaque\") == 0)\n        return(1.0);\n      if (LocaleCompare(expression,\"o\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(expression,\"phi\") == 0)\n        return(MagickPHI);\n      if (LocaleCompare(expression,\"pi\") == 0)\n        return(MagickPI);\n      if (LocaleNCompare(expression,\"pow\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(pow(alpha,*beta));\n        }\n      if (LocaleCompare(expression,\"p\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'Q':\n    case 'q':\n    {\n      if (LocaleCompare(expression,\"QuantumRange\") == 0)\n        return(QuantumRange);\n      if (LocaleCompare(expression,\"QuantumScale\") == 0)\n        return(QuantumScale);\n      break;\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleNCompare(expression,\"rand\",4) == 0)\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FxEvaluateSubexpression)\n#endif\n          alpha=GetPseudoRandomValue(fx_info->random_info);\n          return(alpha);\n        }\n      if (LocaleNCompare(expression,\"round\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          return(floor(alpha+0.5));\n        }\n      if (LocaleCompare(expression,\"r\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'S':\n    case 's':\n    {\n      if (LocaleCompare(expression,\"saturation\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      if (LocaleNCompare(expression,\"sign\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(alpha < 0.0 ? -1.0 : 1.0);\n        }\n      if (LocaleNCompare(expression,\"sinc\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          if (alpha == 0)\n            return(1.0);\n          gamma=sin((MagickPI*alpha))/(MagickPI*alpha);\n          return(gamma);\n        }\n      if (LocaleNCompare(expression,\"sinh\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(sinh(alpha));\n        }\n      if (LocaleNCompare(expression,\"sin\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(sin(alpha));\n        }\n      if (LocaleNCompare(expression,\"sqrt\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(sqrt(alpha));\n        }\n      if (LocaleNCompare(expression,\"squish\",6) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+6,depth,\n            beta,exception);\n          return((1.0/(1.0+exp(-alpha))));\n        }\n      if (LocaleCompare(expression,\"s\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'T':\n    case 't':\n    {\n      if (LocaleNCompare(expression,\"tanh\",4) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,depth,\n            beta,exception);\n          return(tanh(alpha));\n        }\n      if (LocaleNCompare(expression,\"tan\",3) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,depth,\n            beta,exception);\n          return(tan(alpha));\n        }\n      if (LocaleCompare(expression,\"Transparent\") == 0)\n        return(0.0);\n      if (LocaleNCompare(expression,\"trunc\",5) == 0)\n        {\n          alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,depth,\n            beta,exception);\n          if (alpha >= 0.0)\n            return(floor(alpha));\n          return(ceil(alpha));\n        }\n      if (LocaleCompare(expression,\"t\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(expression,\"u\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(expression,\"v\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleNCompare(expression,\"while\",5) == 0)\n        {\n          do\n          {\n            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,\n              depth,beta,exception);\n          } while (fabs(alpha) >= MagickEpsilon);\n          return(*beta);\n        }\n      if (LocaleCompare(expression,\"w\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'Y':\n    case 'y':\n    {\n      if (LocaleCompare(expression,\"y\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    case 'Z':\n    case 'z':\n    {\n      if (LocaleCompare(expression,\"z\") == 0)\n        return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n      break;\n    }\n    default:\n      break;\n  }\n  q=(char *) expression;\n  alpha=InterpretSiPrefixValue(expression,&q);\n  if (q == expression)\n    return(FxGetSymbol(fx_info,channel,x,y,expression,exception));\n  return(alpha);\n}\n\nMagickPrivate MagickBooleanType FxEvaluateExpression(FxInfo *fx_info,\n  double *alpha,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  status=FxEvaluateChannelExpression(fx_info,GrayPixelChannel,0,0,alpha,\n    exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType FxPreprocessExpression(FxInfo *fx_info,\n  double *alpha,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  MagickBooleanType\n    status;\n\n  file=fx_info->file;\n  fx_info->file=(FILE *) NULL;\n  status=FxEvaluateChannelExpression(fx_info,GrayPixelChannel,0,0,alpha,\n    exception);\n  fx_info->file=file;\n  return(status);\n}\n\nMagickPrivate MagickBooleanType FxEvaluateChannelExpression(FxInfo *fx_info,\n  const PixelChannel channel,const ssize_t x,const ssize_t y,\n  double *alpha,ExceptionInfo *exception)\n{\n  double\n    beta;\n\n  size_t\n    depth;\n\n  depth=0;\n  beta=0.0;\n  *alpha=FxEvaluateSubexpression(fx_info,channel,x,y,fx_info->expression,&depth,\n    &beta,exception);\n  return(exception->severity == OptionError ? MagickFalse : MagickTrue);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F x I m a g e                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FxImage() applies a mathematical expression to the specified image.\n%\n%  The format of the FxImage method is:\n%\n%      Image *FxImage(const Image *image,const char *expression,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o expression: A mathematical expression.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic FxInfo **DestroyFxThreadSet(FxInfo **fx_info)\n{\n  register ssize_t\n    i;\n\n  assert(fx_info != (FxInfo **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (fx_info[i] != (FxInfo *) NULL)\n      fx_info[i]=DestroyFxInfo(fx_info[i]);\n  fx_info=(FxInfo **) RelinquishMagickMemory(fx_info);\n  return(fx_info);\n}\n\nstatic FxInfo **AcquireFxThreadSet(const Image *image,const char *expression,\n  ExceptionInfo *exception)\n{\n  char\n    *fx_expression;\n\n  FxInfo\n    **fx_info;\n\n  double\n    alpha;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  fx_info=(FxInfo **) AcquireQuantumMemory(number_threads,sizeof(*fx_info));\n  if (fx_info == (FxInfo **) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return((FxInfo **) NULL);\n    }\n  (void) ResetMagickMemory(fx_info,0,number_threads*sizeof(*fx_info));\n  if (*expression != '@')\n    fx_expression=ConstantString(expression);\n  else\n    fx_expression=FileToString(expression+1,~0UL,exception);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    MagickBooleanType\n      status;\n\n    fx_info[i]=AcquireFxInfo(image,fx_expression,exception);\n    if (fx_info[i] == (FxInfo *) NULL)\n      break;\n    status=FxPreprocessExpression(fx_info[i],&alpha,exception);\n    if (status == MagickFalse)\n      break;\n  }\n  fx_expression=DestroyString(fx_expression);\n  if (i < (ssize_t) number_threads)\n    fx_info=DestroyFxThreadSet(fx_info);\n  return(fx_info);\n}\n\nMagickExport Image *FxImage(const Image *image,const char *expression,\n  ExceptionInfo *exception)\n{\n#define FxImageTag  \"Fx/Image\"\n\n  CacheView\n    *fx_view,\n    *image_view;\n\n  FxInfo\n    **magick_restrict fx_info;\n\n  Image\n    *fx_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  fx_info=AcquireFxThreadSet(image,expression,exception);\n  if (fx_info == (FxInfo **) NULL)\n    return((Image *) NULL);\n  fx_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (fx_image == (Image *) NULL)\n    {\n      fx_info=DestroyFxThreadSet(fx_info);\n      return((Image *) NULL);\n    }\n  if (SetImageStorageClass(fx_image,DirectClass,exception) == MagickFalse)\n    {\n      fx_info=DestroyFxThreadSet(fx_info);\n      fx_image=DestroyImage(fx_image);\n      return((Image *) NULL);\n    }\n  /*\n    Fx image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  fx_view=AcquireAuthenticCacheView(fx_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,fx_image,fx_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) fx_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(fx_view,0,y,fx_image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) fx_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          alpha;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait fx_traits=GetPixelChannelTraits(fx_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (fx_traits == UndefinedPixelTrait))\n          continue;\n        if (((fx_traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(image,p) == 0))\n          {\n            SetPixelChannel(fx_image,channel,p[i],q);\n            continue;\n          }\n        alpha=0.0;\n        (void) FxEvaluateChannelExpression(fx_info[id],channel,x,y,&alpha,\n          exception);\n        q[i]=ClampToQuantum(QuantumRange*alpha);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(fx_image);\n    }\n    if (SyncCacheViewAuthenticPixels(fx_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_FxImage)\n#endif\n        proceed=SetImageProgress(image,FxImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  fx_view=DestroyCacheView(fx_view);\n  image_view=DestroyCacheView(image_view);\n  fx_info=DestroyFxThreadSet(fx_info);\n  if (status == MagickFalse)\n    fx_image=DestroyImage(fx_image);\n  return(fx_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I m p l o d e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImplodeImage() creates a new image that is a copy of an existing\n%  one with the image pixels \"implode\" by the specified percentage.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ImplodeImage method is:\n%\n%      Image *ImplodeImage(const Image *image,const double amount,\n%        const PixelInterpolateMethod method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o implode_image: Method ImplodeImage returns a pointer to the image\n%      after it is implode.  A null image is returned if there is a memory\n%      shortage.\n%\n%    o image: the image.\n%\n%    o amount:  Define the extent of the implosion.\n%\n%    o method: the pixel interpolation method.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ImplodeImage(const Image *image,const double amount,\n  const PixelInterpolateMethod method,ExceptionInfo *exception)\n{\n#define ImplodeImageTag  \"Implode/Image\"\n\n  CacheView\n    *image_view,\n    *implode_view,\n    *interpolate_view;\n\n  Image\n    *implode_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  double\n    radius;\n\n  PointInfo\n    center,\n    scale;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize implode image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  implode_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception);\n  if (implode_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(implode_image,DirectClass,exception) == MagickFalse)\n    {\n      implode_image=DestroyImage(implode_image);\n      return((Image *) NULL);\n    }\n  if (implode_image->background_color.alpha != OpaqueAlpha)\n    implode_image->alpha_trait=BlendPixelTrait;\n  /*\n    Compute scaling factor.\n  */\n  scale.x=1.0;\n  scale.y=1.0;\n  center.x=0.5*image->columns;\n  center.y=0.5*image->rows;\n  radius=center.x;\n  if (image->columns > image->rows)\n    scale.y=(double) image->columns/(double) image->rows;\n  else\n    if (image->columns < image->rows)\n      {\n        scale.x=(double) image->rows/(double) image->columns;\n        radius=center.y;\n      }\n  /*\n    Implode image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  interpolate_view=AcquireVirtualCacheView(image,exception);\n  implode_view=AcquireAuthenticCacheView(implode_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,implode_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      distance;\n\n    PointInfo\n      delta;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(implode_view,0,y,implode_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    delta.y=scale.y*(double) (y-center.y);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      /*\n        Determine if the pixel is within an ellipse.\n      */\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(implode_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(implode_image);\n          continue;\n        }\n      delta.x=scale.x*(double) (x-center.x);\n      distance=delta.x*delta.x+delta.y*delta.y;\n      if (distance >= (radius*radius))\n        for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n        {\n          PixelChannel channel=GetPixelChannelChannel(image,i);\n          PixelTrait traits=GetPixelChannelTraits(image,channel);\n          PixelTrait implode_traits=GetPixelChannelTraits(implode_image,\n            channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (implode_traits == UndefinedPixelTrait))\n            continue;\n          SetPixelChannel(implode_image,channel,p[i],q);\n        }\n      else\n        {\n          double\n            factor;\n\n          /*\n            Implode the pixel.\n          */\n          factor=1.0;\n          if (distance > 0.0)\n            factor=pow(sin(MagickPI*sqrt((double) distance)/radius/2),-amount);\n          status=InterpolatePixelChannels(image,interpolate_view,implode_image,\n            method,(double) (factor*delta.x/scale.x+center.x),(double) (factor*\n            delta.y/scale.y+center.y),q,exception);\n        }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(implode_image);\n    }\n    if (SyncCacheViewAuthenticPixels(implode_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ImplodeImage)\n#endif\n        proceed=SetImageProgress(image,ImplodeImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  implode_view=DestroyCacheView(implode_view);\n  interpolate_view=DestroyCacheView(interpolate_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    implode_image=DestroyImage(implode_image);\n  return(implode_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     M o r p h I m a g e s                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  The MorphImages() method requires a minimum of two images.  The first\n%  image is transformed into the second by a number of intervening images\n%  as specified by frames.\n%\n%  The format of the MorphImage method is:\n%\n%      Image *MorphImages(const Image *image,const size_t number_frames,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o number_frames:  Define the number of in-between image to generate.\n%      The more in-between frames, the smoother the morph.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *MorphImages(const Image *image,const size_t number_frames,\n  ExceptionInfo *exception)\n{\n#define MorphImageTag  \"Morph/Image\"\n\n  double\n    alpha,\n    beta;\n\n  Image\n    *morph_image,\n    *morph_images;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  register const Image\n    *next;\n\n  register ssize_t\n    n;\n\n  ssize_t\n    y;\n\n  /*\n    Clone first frame in sequence.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  morph_images=CloneImage(image,0,0,MagickTrue,exception);\n  if (morph_images == (Image *) NULL)\n    return((Image *) NULL);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    {\n      /*\n        Morph single image.\n      */\n      for (n=1; n < (ssize_t) number_frames; n++)\n      {\n        morph_image=CloneImage(image,0,0,MagickTrue,exception);\n        if (morph_image == (Image *) NULL)\n          {\n            morph_images=DestroyImageList(morph_images);\n            return((Image *) NULL);\n          }\n        AppendImageToList(&morph_images,morph_image);\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,MorphImageTag,(MagickOffsetType) n,\n              number_frames);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      return(GetFirstImageInList(morph_images));\n    }\n  /*\n    Morph image sequence.\n  */\n  status=MagickTrue;\n  scene=0;\n  next=image;\n  for ( ; GetNextImageInList(next) != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    for (n=0; n < (ssize_t) number_frames; n++)\n    {\n      CacheView\n        *image_view,\n        *morph_view;\n\n      beta=(double) (n+1.0)/(double) (number_frames+1.0);\n      alpha=1.0-beta;\n      morph_image=ResizeImage(next,(size_t) (alpha*next->columns+beta*\n        GetNextImageInList(next)->columns+0.5),(size_t) (alpha*next->rows+beta*\n        GetNextImageInList(next)->rows+0.5),next->filter,exception);\n      if (morph_image == (Image *) NULL)\n        {\n          morph_images=DestroyImageList(morph_images);\n          return((Image *) NULL);\n        }\n      status=SetImageStorageClass(morph_image,DirectClass,exception);\n      if (status == MagickFalse)\n        {\n          morph_image=DestroyImage(morph_image);\n          return((Image *) NULL);\n        }\n      AppendImageToList(&morph_images,morph_image);\n      morph_images=GetLastImageInList(morph_images);\n      morph_image=ResizeImage(GetNextImageInList(next),morph_images->columns,\n        morph_images->rows,GetNextImageInList(next)->filter,exception);\n      if (morph_image == (Image *) NULL)\n        {\n          morph_images=DestroyImageList(morph_images);\n          return((Image *) NULL);\n        }\n      image_view=AcquireVirtualCacheView(morph_image,exception);\n      morph_view=AcquireAuthenticCacheView(morph_images,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(morph_image,morph_image,morph_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) morph_images->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *magick_restrict p;\n\n        register ssize_t\n          x;\n\n        register Quantum\n          *magick_restrict q;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(image_view,0,y,morph_image->columns,1,\n          exception);\n        q=GetCacheViewAuthenticPixels(morph_view,0,y,morph_images->columns,1,\n          exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) morph_images->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(morph_image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(morph_image,i);\n            PixelTrait traits=GetPixelChannelTraits(morph_image,channel);\n            PixelTrait morph_traits=GetPixelChannelTraits(morph_images,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (morph_traits == UndefinedPixelTrait))\n              continue;\n            if (((morph_traits & CopyPixelTrait) != 0) ||\n                (GetPixelReadMask(morph_images,p) == 0))\n              {\n                SetPixelChannel(morph_image,channel,p[i],q);\n                continue;\n              }\n            SetPixelChannel(morph_image,channel,ClampToQuantum(alpha*\n              GetPixelChannel(morph_images,channel,q)+beta*p[i]),q);\n          }\n          p+=GetPixelChannels(morph_image);\n          q+=GetPixelChannels(morph_images);\n        }\n        sync=SyncCacheViewAuthenticPixels(morph_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n      }\n      morph_view=DestroyCacheView(morph_view);\n      image_view=DestroyCacheView(image_view);\n      morph_image=DestroyImage(morph_image);\n    }\n    if (n < (ssize_t) number_frames)\n      break;\n    /*\n      Clone last frame in sequence.\n    */\n    morph_image=CloneImage(GetNextImageInList(next),0,0,MagickTrue,exception);\n    if (morph_image == (Image *) NULL)\n      {\n        morph_images=DestroyImageList(morph_images);\n        return((Image *) NULL);\n      }\n    AppendImageToList(&morph_images,morph_image);\n    morph_images=GetLastImageInList(morph_images);\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_MorphImages)\n#endif\n        proceed=SetImageProgress(image,MorphImageTag,scene,\n          GetImageListLength(image));\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n    scene++;\n  }\n  if (GetNextImageInList(next) != (Image *) NULL)\n    {\n      morph_images=DestroyImageList(morph_images);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(morph_images));\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P l a s m a I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PlasmaImage() initializes an image with plasma fractal values.  The image\n%  must be initialized with a base color and the random number generator\n%  seeded before this method is called.\n%\n%  The format of the PlasmaImage method is:\n%\n%      MagickBooleanType PlasmaImage(Image *image,const SegmentInfo *segment,\n%        size_t attenuate,size_t depth,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o segment:   Define the region to apply plasma fractals values.\n%\n%    o attenuate: Define the plasma attenuation factor.\n%\n%    o depth: Limit the plasma recursion depth.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PlasmaPixel(RandomInfo *random_info,\n  const double pixel,const double noise)\n{\n  Quantum\n    plasma;\n\n  plasma=ClampToQuantum(pixel+noise*GetPseudoRandomValue(random_info)-\n    noise/2.0);\n  if (plasma <= 0)\n    return((Quantum) 0);\n  if (plasma >= QuantumRange)\n    return(QuantumRange);\n  return(plasma);\n}\n\nstatic MagickBooleanType PlasmaImageProxy(Image *image,CacheView *image_view,\n  CacheView *u_view,CacheView *v_view,RandomInfo *random_info,\n  const SegmentInfo *segment,size_t attenuate,size_t depth,\n  ExceptionInfo *exception)\n{\n  double\n    plasma;\n\n  register const Quantum\n    *magick_restrict u,\n    *magick_restrict v;\n\n  register Quantum\n    *magick_restrict q;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    x,\n    x_mid,\n    y,\n    y_mid;\n\n  if ((fabs(segment->x2-segment->x1) <= MagickEpsilon) &&\n      (fabs(segment->y2-segment->y1) <= MagickEpsilon))\n    return(MagickTrue);\n  if (depth != 0)\n    {\n      MagickBooleanType\n        status;\n\n      SegmentInfo\n        local_info;\n\n      /*\n        Divide the area into quadrants and recurse.\n      */\n      depth--;\n      attenuate++;\n      x_mid=(ssize_t) ceil((segment->x1+segment->x2)/2-0.5);\n      y_mid=(ssize_t) ceil((segment->y1+segment->y2)/2-0.5);\n      local_info=(*segment);\n      local_info.x2=(double) x_mid;\n      local_info.y2=(double) y_mid;\n      (void) PlasmaImageProxy(image,image_view,u_view,v_view,random_info,\n        &local_info,attenuate,depth,exception);\n      local_info=(*segment);\n      local_info.y1=(double) y_mid;\n      local_info.x2=(double) x_mid;\n      (void) PlasmaImageProxy(image,image_view,u_view,v_view,random_info,\n        &local_info,attenuate,depth,exception);\n      local_info=(*segment);\n      local_info.x1=(double) x_mid;\n      local_info.y2=(double) y_mid;\n      (void) PlasmaImageProxy(image,image_view,u_view,v_view,random_info,\n        &local_info,attenuate,depth,exception);\n      local_info=(*segment);\n      local_info.x1=(double) x_mid;\n      local_info.y1=(double) y_mid;\n      status=PlasmaImageProxy(image,image_view,u_view,v_view,random_info,\n        &local_info,attenuate,depth,exception);\n      return(status);\n    }\n  x_mid=(ssize_t) ceil((segment->x1+segment->x2)/2-0.5);\n  y_mid=(ssize_t) ceil((segment->y1+segment->y2)/2-0.5);\n  if ((fabs(segment->x1-x_mid) < MagickEpsilon) &&\n      (fabs(segment->x2-x_mid) < MagickEpsilon) &&\n      (fabs(segment->y1-y_mid) < MagickEpsilon) &&\n      (fabs(segment->y2-y_mid) < MagickEpsilon))\n    return(MagickFalse);\n  /*\n    Average pixels and apply plasma.\n  */\n  plasma=(double) QuantumRange/(2.0*attenuate);\n  if ((fabs(segment->x1-x_mid) > MagickEpsilon) ||\n      (fabs(segment->x2-x_mid) > MagickEpsilon))\n    {\n      /*\n        Left pixel.\n      */\n      x=(ssize_t) ceil(segment->x1-0.5);\n      u=GetCacheViewVirtualPixels(u_view,x,(ssize_t) ceil(segment->y1-0.5),1,1,\n        exception);\n      v=GetCacheViewVirtualPixels(v_view,x,(ssize_t) ceil(segment->y2-0.5),1,1,\n        exception);\n      q=QueueCacheViewAuthenticPixels(image_view,x,y_mid,1,1,exception);\n      if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n          (q == (Quantum *) NULL))\n        return(MagickTrue);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n      }\n      (void) SyncCacheViewAuthenticPixels(image_view,exception);\n      if (fabs(segment->x1-segment->x2) > MagickEpsilon)\n        {\n          /*\n            Right pixel.\n          */\n          x=(ssize_t) ceil(segment->x2-0.5);\n          u=GetCacheViewVirtualPixels(u_view,x,(ssize_t) ceil(segment->y1-0.5),\n            1,1,exception);\n          v=GetCacheViewVirtualPixels(v_view,x,(ssize_t) ceil(segment->y2-0.5),\n            1,1,exception);\n          q=QueueCacheViewAuthenticPixels(image_view,x,y_mid,1,1,exception);\n          if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n              (q == (Quantum *) NULL))\n            return(MagickTrue);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n          }\n          (void) SyncCacheViewAuthenticPixels(image_view,exception);\n        }\n    }\n  if ((fabs(segment->y1-y_mid) > MagickEpsilon) ||\n      (fabs(segment->y2-y_mid) > MagickEpsilon))\n    {\n      if ((fabs(segment->x1-x_mid) > MagickEpsilon) ||\n          (fabs(segment->y2-y_mid) > MagickEpsilon))\n        {\n          /*\n            Bottom pixel.\n          */\n          y=(ssize_t) ceil(segment->y2-0.5);\n          u=GetCacheViewVirtualPixels(u_view,(ssize_t) ceil(segment->x1-0.5),y,\n            1,1,exception);\n          v=GetCacheViewVirtualPixels(v_view,(ssize_t) ceil(segment->x2-0.5),y,\n            1,1,exception);\n          q=QueueCacheViewAuthenticPixels(image_view,x_mid,y,1,1,exception);\n          if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n              (q == (Quantum *) NULL))\n            return(MagickTrue);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n          }\n          (void) SyncCacheViewAuthenticPixels(image_view,exception);\n        }\n      if (fabs(segment->y1-segment->y2) > MagickEpsilon)\n        {\n          /*\n            Top pixel.\n          */\n          y=(ssize_t) ceil(segment->y1-0.5);\n          u=GetCacheViewVirtualPixels(u_view,(ssize_t) ceil(segment->x1-0.5),y,\n            1,1,exception);\n          v=GetCacheViewVirtualPixels(v_view,(ssize_t) ceil(segment->x2-0.5),y,\n            1,1,exception);\n          q=QueueCacheViewAuthenticPixels(image_view,x_mid,y,1,1,exception);\n          if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n              (q == (Quantum *) NULL))\n            return(MagickTrue);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n          }\n          (void) SyncCacheViewAuthenticPixels(image_view,exception);\n        }\n    }\n  if ((fabs(segment->x1-segment->x2) > MagickEpsilon) ||\n      (fabs(segment->y1-segment->y2) > MagickEpsilon))\n    {\n      /*\n        Middle pixel.\n      */\n      x=(ssize_t) ceil(segment->x1-0.5);\n      y=(ssize_t) ceil(segment->y1-0.5);\n      u=GetCacheViewVirtualPixels(u_view,x,y,1,1,exception);\n      x=(ssize_t) ceil(segment->x2-0.5);\n      y=(ssize_t) ceil(segment->y2-0.5);\n      v=GetCacheViewVirtualPixels(v_view,x,y,1,1,exception);\n      q=QueueCacheViewAuthenticPixels(image_view,x_mid,y_mid,1,1,exception);\n      if ((u == (const Quantum *) NULL) || (v == (const Quantum *) NULL) ||\n          (q == (Quantum *) NULL))\n        return(MagickTrue);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=PlasmaPixel(random_info,(u[i]+v[i])/2.0,plasma);\n      }\n      (void) SyncCacheViewAuthenticPixels(image_view,exception);\n    }\n  if ((fabs(segment->x2-segment->x1) < 3.0) &&\n      (fabs(segment->y2-segment->y1) < 3.0))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nMagickExport MagickBooleanType PlasmaImage(Image *image,\n  const SegmentInfo *segment,size_t attenuate,size_t depth,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view,\n    *u_view,\n    *v_view;\n\n  MagickBooleanType\n    status;\n\n  RandomInfo\n    *random_info;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  image_view=AcquireAuthenticCacheView(image,exception);\n  u_view=AcquireVirtualCacheView(image,exception);\n  v_view=AcquireVirtualCacheView(image,exception);\n  random_info=AcquireRandomInfo();\n  status=PlasmaImageProxy(image,image_view,u_view,v_view,random_info,segment,\n    attenuate,depth,exception);\n  random_info=DestroyRandomInfo(random_info);\n  v_view=DestroyCacheView(v_view);\n  u_view=DestroyCacheView(u_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P o l a r o i d I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PolaroidImage() simulates a Polaroid picture.\n%\n%  The format of the PolaroidImage method is:\n%\n%      Image *PolaroidImage(const Image *image,const DrawInfo *draw_info,\n%        const char *caption,const double angle,\n%        const PixelInterpolateMethod method,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o caption: the Polaroid caption.\n%\n%    o angle: Apply the effect along this angle.\n%\n%    o method: the pixel interpolation method.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *PolaroidImage(const Image *image,const DrawInfo *draw_info,\n  const char *caption,const double angle,const PixelInterpolateMethod method,\n  ExceptionInfo *exception)\n{\n  Image\n    *bend_image,\n    *caption_image,\n    *flop_image,\n    *picture_image,\n    *polaroid_image,\n    *rotate_image,\n    *trim_image;\n\n  size_t\n    height;\n\n  ssize_t\n    quantum;\n\n  /*\n    Simulate a Polaroid picture.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  quantum=(ssize_t) MagickMax(MagickMax((double) image->columns,(double)\n    image->rows)/25.0,10.0);\n  height=image->rows+2*quantum;\n  caption_image=(Image *) NULL;\n  if (caption != (const char *) NULL)\n    {\n      char\n        geometry[MagickPathExtent],\n        *text;\n\n      DrawInfo\n        *annotate_info;\n\n      ImageInfo\n        *image_info;\n\n      MagickBooleanType\n        status;\n\n      ssize_t\n        count;\n\n      TypeMetric\n        metrics;\n\n      /*\n        Generate caption image.\n      */\n      caption_image=CloneImage(image,image->columns,1,MagickTrue,exception);\n      if (caption_image == (Image *) NULL)\n        return((Image *) NULL);\n      image_info=AcquireImageInfo();\n      annotate_info=CloneDrawInfo((const ImageInfo *) NULL,draw_info);\n      text=InterpretImageProperties(image_info,(Image *) image,caption,\n        exception);\n      image_info=DestroyImageInfo(image_info);\n      (void) CloneString(&annotate_info->text,text);\n      count=FormatMagickCaption(caption_image,annotate_info,MagickTrue,&metrics,\n        &text,exception);\n      status=SetImageExtent(caption_image,image->columns,(size_t) ((count+1)*\n        (metrics.ascent-metrics.descent)+0.5),exception);\n      if (status == MagickFalse)\n        caption_image=DestroyImage(caption_image);\n      else\n        {\n          caption_image->background_color=image->border_color;\n          (void) SetImageBackgroundColor(caption_image,exception);\n          (void) CloneString(&annotate_info->text,text);\n          (void) FormatLocaleString(geometry,MagickPathExtent,\"+0+%g\",\n            metrics.ascent);\n          if (annotate_info->gravity == UndefinedGravity)\n            (void) CloneString(&annotate_info->geometry,AcquireString(\n              geometry));\n          (void) AnnotateImage(caption_image,annotate_info,exception);\n          height+=caption_image->rows;\n        }\n      annotate_info=DestroyDrawInfo(annotate_info);\n      text=DestroyString(text);\n    }\n  picture_image=CloneImage(image,image->columns+2*quantum,height,MagickTrue,\n    exception);\n  if (picture_image == (Image *) NULL)\n    {\n      if (caption_image != (Image *) NULL)\n        caption_image=DestroyImage(caption_image);\n      return((Image *) NULL);\n    }\n  picture_image->background_color=image->border_color;\n  (void) SetImageBackgroundColor(picture_image,exception);\n  (void) CompositeImage(picture_image,image,OverCompositeOp,MagickTrue,quantum,\n    quantum,exception);\n  if (caption_image != (Image *) NULL)\n    {\n      (void) CompositeImage(picture_image,caption_image,OverCompositeOp,\n        MagickTrue,quantum,(ssize_t) (image->rows+3*quantum/2),exception);\n      caption_image=DestroyImage(caption_image);\n    }\n  (void) QueryColorCompliance(\"none\",AllCompliance,\n    &picture_image->background_color,exception);\n  (void) SetImageAlphaChannel(picture_image,OpaqueAlphaChannel,exception);\n  rotate_image=RotateImage(picture_image,90.0,exception);\n  picture_image=DestroyImage(picture_image);\n  if (rotate_image == (Image *) NULL)\n    return((Image *) NULL);\n  picture_image=rotate_image;\n  bend_image=WaveImage(picture_image,0.01*picture_image->rows,2.0*\n    picture_image->columns,method,exception);\n  picture_image=DestroyImage(picture_image);\n  if (bend_image == (Image *) NULL)\n    return((Image *) NULL);\n  picture_image=bend_image;\n  rotate_image=RotateImage(picture_image,-90.0,exception);\n  picture_image=DestroyImage(picture_image);\n  if (rotate_image == (Image *) NULL)\n    return((Image *) NULL);\n  picture_image=rotate_image;\n  picture_image->background_color=image->background_color;\n  polaroid_image=ShadowImage(picture_image,80.0,2.0,quantum/3,quantum/3,\n    exception);\n  if (polaroid_image == (Image *) NULL)\n    {\n      picture_image=DestroyImage(picture_image);\n      return(picture_image);\n    }\n  flop_image=FlopImage(polaroid_image,exception);\n  polaroid_image=DestroyImage(polaroid_image);\n  if (flop_image == (Image *) NULL)\n    {\n      picture_image=DestroyImage(picture_image);\n      return(picture_image);\n    }\n  polaroid_image=flop_image;\n  (void) CompositeImage(polaroid_image,picture_image,OverCompositeOp,\n    MagickTrue,(ssize_t) (-0.01*picture_image->columns/2.0),0L,exception);\n  picture_image=DestroyImage(picture_image);\n  (void) QueryColorCompliance(\"none\",AllCompliance,\n    &polaroid_image->background_color,exception);\n  rotate_image=RotateImage(polaroid_image,angle,exception);\n  polaroid_image=DestroyImage(polaroid_image);\n  if (rotate_image == (Image *) NULL)\n    return((Image *) NULL);\n  polaroid_image=rotate_image;\n  trim_image=TrimImage(polaroid_image,exception);\n  polaroid_image=DestroyImage(polaroid_image);\n  if (trim_image == (Image *) NULL)\n    return((Image *) NULL);\n  polaroid_image=trim_image;\n  return(polaroid_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S e p i a T o n e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MagickSepiaToneImage() applies a special effect to the image, similar to the\n%  effect achieved in a photo darkroom by sepia toning.  Threshold ranges from\n%  0 to QuantumRange and is a measure of the extent of the sepia toning.  A\n%  threshold of 80% is a good starting point for a reasonable tone.\n%\n%  The format of the SepiaToneImage method is:\n%\n%      Image *SepiaToneImage(const Image *image,const double threshold,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: the tone threshold.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SepiaToneImage(const Image *image,const double threshold,\n  ExceptionInfo *exception)\n{\n#define SepiaToneImageTag  \"SepiaTone/Image\"\n\n  CacheView\n    *image_view,\n    *sepia_view;\n\n  Image\n    *sepia_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize sepia-toned image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  sepia_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (sepia_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(sepia_image,DirectClass,exception) == MagickFalse)\n    {\n      sepia_image=DestroyImage(sepia_image);\n      return((Image *) NULL);\n    }\n  /*\n    Tone each row of the image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  sepia_view=AcquireAuthenticCacheView(sepia_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,sepia_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(sepia_view,0,y,sepia_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        intensity,\n        tone;\n\n      intensity=GetPixelIntensity(image,p);\n      tone=intensity > threshold ? (double) QuantumRange : intensity+\n        (double) QuantumRange-threshold;\n      SetPixelRed(sepia_image,ClampToQuantum(tone),q);\n      tone=intensity > (7.0*threshold/6.0) ? (double) QuantumRange :\n        intensity+(double) QuantumRange-7.0*threshold/6.0;\n      SetPixelGreen(sepia_image,ClampToQuantum(tone),q);\n      tone=intensity < (threshold/6.0) ? 0 : intensity-threshold/6.0;\n      SetPixelBlue(sepia_image,ClampToQuantum(tone),q);\n      tone=threshold/7.0;\n      if ((double) GetPixelGreen(image,q) < tone)\n        SetPixelGreen(sepia_image,ClampToQuantum(tone),q);\n      if ((double) GetPixelBlue(image,q) < tone)\n        SetPixelBlue(sepia_image,ClampToQuantum(tone),q);\n      SetPixelAlpha(sepia_image,GetPixelAlpha(image,p),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(sepia_image);\n    }\n    if (SyncCacheViewAuthenticPixels(sepia_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SepiaToneImage)\n#endif\n        proceed=SetImageProgress(image,SepiaToneImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  sepia_view=DestroyCacheView(sepia_view);\n  image_view=DestroyCacheView(image_view);\n  (void) NormalizeImage(sepia_image,exception);\n  (void) ContrastImage(sepia_image,MagickTrue,exception);\n  if (status == MagickFalse)\n    sepia_image=DestroyImage(sepia_image);\n  return(sepia_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S h a d o w I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ShadowImage() simulates a shadow from the specified image and returns it.\n%\n%  The format of the ShadowImage method is:\n%\n%      Image *ShadowImage(const Image *image,const double alpha,\n%        const double sigma,const ssize_t x_offset,const ssize_t y_offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o alpha: percentage transparency.\n%\n%    o sigma: the standard deviation of the Gaussian, in pixels.\n%\n%    o x_offset: the shadow x-offset.\n%\n%    o y_offset: the shadow y-offset.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ShadowImage(const Image *image,const double alpha,\n  const double sigma,const ssize_t x_offset,const ssize_t y_offset,\n  ExceptionInfo *exception)\n{\n#define ShadowImageTag  \"Shadow/Image\"\n\n  CacheView\n    *image_view;\n\n  ChannelType\n    channel_mask;\n\n  Image\n    *border_image,\n    *clone_image,\n    *shadow_image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    background_color;\n\n  RectangleInfo\n    border_info;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  clone_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (clone_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(clone_image,sRGBColorspace,exception);\n  (void) SetImageVirtualPixelMethod(clone_image,EdgeVirtualPixelMethod,\n    exception);\n  border_info.width=(size_t) floor(2.0*sigma+0.5);\n  border_info.height=(size_t) floor(2.0*sigma+0.5);\n  border_info.x=0;\n  border_info.y=0;\n  (void) QueryColorCompliance(\"none\",AllCompliance,&clone_image->border_color,\n    exception);\n  clone_image->alpha_trait=BlendPixelTrait;\n  border_image=BorderImage(clone_image,&border_info,OverCompositeOp,exception);\n  clone_image=DestroyImage(clone_image);\n  if (border_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (border_image->alpha_trait == UndefinedPixelTrait)\n    (void) SetImageAlphaChannel(border_image,OpaqueAlphaChannel,exception);\n  /*\n    Shadow image.\n  */\n  status=MagickTrue;\n  background_color=border_image->background_color;\n  background_color.alpha_trait=BlendPixelTrait;\n  image_view=AcquireAuthenticCacheView(border_image,exception);\n  for (y=0; y < (ssize_t) border_image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,border_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) border_image->columns; x++)\n    {\n      if (border_image->alpha_trait != UndefinedPixelTrait)\n        background_color.alpha=GetPixelAlpha(border_image,q)*alpha/100.0;\n      SetPixelViaPixelInfo(border_image,&background_color,q);\n      q+=GetPixelChannels(border_image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    {\n      border_image=DestroyImage(border_image);\n      return((Image *) NULL);\n    }\n  channel_mask=SetImageChannelMask(border_image,AlphaChannel);\n  shadow_image=BlurImage(border_image,0.0,sigma,exception);\n  border_image=DestroyImage(border_image);\n  if (shadow_image == (Image *) NULL)\n    return((Image *) NULL);\n  (void) SetPixelChannelMask(shadow_image,channel_mask);\n  if (shadow_image->page.width == 0)\n    shadow_image->page.width=shadow_image->columns;\n  if (shadow_image->page.height == 0)\n    shadow_image->page.height=shadow_image->rows;\n  shadow_image->page.width+=x_offset-(ssize_t) border_info.width;\n  shadow_image->page.height+=y_offset-(ssize_t) border_info.height;\n  shadow_image->page.x+=x_offset-(ssize_t) border_info.width;\n  shadow_image->page.y+=y_offset-(ssize_t) border_info.height;\n  return(shadow_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S k e t c h I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SketchImage() simulates a pencil sketch.  We convolve the image with a\n%  Gaussian operator of the given radius and standard deviation (sigma).  For\n%  reasonable results, radius should be larger than sigma.  Use a radius of 0\n%  and SketchImage() selects a suitable radius for you.  Angle gives the angle\n%  of the sketch.\n%\n%  The format of the SketchImage method is:\n%\n%    Image *SketchImage(const Image *image,const double radius,\n%      const double sigma,const double angle,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o radius: the radius of the Gaussian, in pixels, not counting the\n%      center pixel.\n%\n%    o sigma: the standard deviation of the Gaussian, in pixels.\n%\n%    o angle: apply the effect along this angle.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SketchImage(const Image *image,const double radius,\n  const double sigma,const double angle,ExceptionInfo *exception)\n{\n  CacheView\n    *random_view;\n\n  Image\n    *blend_image,\n    *blur_image,\n    *dodge_image,\n    *random_image,\n    *sketch_image;\n\n  MagickBooleanType\n    status;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  /*\n    Sketch image.\n  */\n  random_image=CloneImage(image,image->columns << 1,image->rows << 1,\n    MagickTrue,exception);\n  if (random_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=MagickTrue;\n  random_info=AcquireRandomInfoThreadSet();\n  random_view=AcquireAuthenticCacheView(random_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(random_image,random_image,random_image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) random_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(random_view,0,y,random_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) random_image->columns; x++)\n    {\n      double\n        value;\n\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(random_image,q) == 0)\n        {\n          q+=GetPixelChannels(random_image);\n          continue;\n        }\n      value=GetPseudoRandomValue(random_info[id]);\n      for (i=0; i < (ssize_t) GetPixelChannels(random_image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=ClampToQuantum(QuantumRange*value);\n      }\n      q+=GetPixelChannels(random_image);\n    }\n    if (SyncCacheViewAuthenticPixels(random_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  random_view=DestroyCacheView(random_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  if (status == MagickFalse)\n    {\n      random_image=DestroyImage(random_image);\n      return(random_image);\n    }\n  blur_image=MotionBlurImage(random_image,radius,sigma,angle,exception);\n  random_image=DestroyImage(random_image);\n  if (blur_image == (Image *) NULL)\n    return((Image *) NULL);\n  dodge_image=EdgeImage(blur_image,radius,exception);\n  blur_image=DestroyImage(blur_image);\n  if (dodge_image == (Image *) NULL)\n    return((Image *) NULL);\n  (void) NormalizeImage(dodge_image,exception);\n  (void) NegateImage(dodge_image,MagickFalse,exception);\n  (void) TransformImage(&dodge_image,(char *) NULL,\"50%\",exception);\n  sketch_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (sketch_image == (Image *) NULL)\n    {\n      dodge_image=DestroyImage(dodge_image);\n      return((Image *) NULL);\n    }\n  (void) CompositeImage(sketch_image,dodge_image,ColorDodgeCompositeOp,\n    MagickTrue,0,0,exception);\n  dodge_image=DestroyImage(dodge_image);\n  blend_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (blend_image == (Image *) NULL)\n    {\n      sketch_image=DestroyImage(sketch_image);\n      return((Image *) NULL);\n    }\n  if (blend_image->alpha_trait != BlendPixelTrait)\n    (void) SetImageAlpha(blend_image,TransparentAlpha,exception);\n  (void) SetImageArtifact(blend_image,\"compose:args\",\"20x80\");\n  (void) CompositeImage(sketch_image,blend_image,BlendCompositeOp,MagickTrue,\n    0,0,exception);\n  blend_image=DestroyImage(blend_image);\n  return(sketch_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S o l a r i z e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SolarizeImage() applies a special effect to the image, similar to the effect\n%  achieved in a photo darkroom by selectively exposing areas of photo\n%  sensitive paper to light.  Threshold ranges from 0 to QuantumRange and is a\n%  measure of the extent of the solarization.\n%\n%  The format of the SolarizeImage method is:\n%\n%      MagickBooleanType SolarizeImage(Image *image,const double threshold,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold:  Define the extent of the solarization.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SolarizeImage(Image *image,\n  const double threshold,ExceptionInfo *exception)\n{\n#define SolarizeImageTag  \"Solarize/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      /*\n        Solarize colormap.\n      */\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if ((double) image->colormap[i].red > threshold)\n          image->colormap[i].red=QuantumRange-image->colormap[i].red;\n        if ((double) image->colormap[i].green > threshold)\n          image->colormap[i].green=QuantumRange-image->colormap[i].green;\n        if ((double) image->colormap[i].blue > threshold)\n          image->colormap[i].blue=QuantumRange-image->colormap[i].blue;\n      }\n    }\n  /*\n    Solarize image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if ((double) q[i] > threshold)\n          q[i]=QuantumRange-q[i];\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SolarizeImage)\n#endif\n        proceed=SetImageProgress(image,SolarizeImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S t e g a n o I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SteganoImage() hides a digital watermark within the image.  Recover\n%  the hidden watermark later to prove that the authenticity of an image.\n%  Offset defines the start position within the image to hide the watermark.\n%\n%  The format of the SteganoImage method is:\n%\n%      Image *SteganoImage(const Image *image,Image *watermark,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o watermark: the watermark image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SteganoImage(const Image *image,const Image *watermark,\n  ExceptionInfo *exception)\n{\n#define GetBit(alpha,i) ((((size_t) (alpha) >> (size_t) (i)) & 0x01) != 0)\n#define SetBit(alpha,i,set) (Quantum) ((set) != 0 ? (size_t) (alpha) \\\n  | (one << (size_t) (i)) : (size_t) (alpha) & ~(one << (size_t) (i)))\n#define SteganoImageTag  \"Stegano/Image\"\n\n  CacheView\n    *stegano_view,\n    *watermark_view;\n\n  Image\n    *stegano_image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    depth,\n    one;\n\n  ssize_t\n    i,\n    j,\n    k,\n    y;\n\n  /*\n    Initialize steganographic image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(watermark != (const Image *) NULL);\n  assert(watermark->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1UL;\n  stegano_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (stegano_image == (Image *) NULL)\n    return((Image *) NULL);\n  stegano_image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  if (SetImageStorageClass(stegano_image,DirectClass,exception) == MagickFalse)\n    {\n      stegano_image=DestroyImage(stegano_image);\n      return((Image *) NULL);\n    }\n  /*\n    Hide watermark in low-order bits of image.\n  */\n  c=0;\n  i=0;\n  j=0;\n  depth=stegano_image->depth;\n  k=stegano_image->offset;\n  status=MagickTrue;\n  watermark_view=AcquireVirtualCacheView(watermark,exception);\n  stegano_view=AcquireAuthenticCacheView(stegano_image,exception);\n  for (i=(ssize_t) depth-1; (i >= 0) && (j < (ssize_t) depth); i--)\n  {\n    for (y=0; (y < (ssize_t) watermark->rows) && (j < (ssize_t) depth); y++)\n    {\n      for (x=0; (x < (ssize_t) watermark->columns) && (j < (ssize_t) depth); x++)\n      {\n        ssize_t\n          offset;\n\n        (void) GetOneCacheViewVirtualPixelInfo(watermark_view,x,y,&pixel,\n          exception);\n        offset=k/(ssize_t) stegano_image->columns;\n        if (offset >= (ssize_t) stegano_image->rows)\n          break;\n        q=GetCacheViewAuthenticPixels(stegano_view,k % (ssize_t)\n          stegano_image->columns,k/(ssize_t) stegano_image->columns,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          break;\n        switch (c)\n        {\n          case 0:\n          {\n            SetPixelRed(stegano_image,SetBit(GetPixelRed(stegano_image,q),j,\n              GetBit(GetPixelInfoIntensity(stegano_image,&pixel),i)),q);\n            break;\n          }\n          case 1:\n          {\n            SetPixelGreen(stegano_image,SetBit(GetPixelGreen(stegano_image,q),j,\n              GetBit(GetPixelInfoIntensity(stegano_image,&pixel),i)),q);\n            break;\n          }\n          case 2:\n          {\n            SetPixelBlue(stegano_image,SetBit(GetPixelBlue(stegano_image,q),j,\n              GetBit(GetPixelInfoIntensity(stegano_image,&pixel),i)),q);\n            break;\n          }\n        }\n        if (SyncCacheViewAuthenticPixels(stegano_view,exception) == MagickFalse)\n          break;\n        c++;\n        if (c == 3)\n          c=0;\n        k++;\n        if (k == (ssize_t) (stegano_image->columns*stegano_image->columns))\n          k=0;\n        if (k == stegano_image->offset)\n          j++;\n      }\n    }\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,SteganoImageTag,(MagickOffsetType)\n          (depth-i),depth);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  stegano_view=DestroyCacheView(stegano_view);\n  watermark_view=DestroyCacheView(watermark_view);\n  if (status == MagickFalse)\n    stegano_image=DestroyImage(stegano_image);\n  return(stegano_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S t e r e o A n a g l y p h I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StereoAnaglyphImage() combines two images and produces a single image that\n%  is the composite of a left and right image of a stereo pair.  Special\n%  red-green stereo glasses are required to view this effect.\n%\n%  The format of the StereoAnaglyphImage method is:\n%\n%      Image *StereoImage(const Image *left_image,const Image *right_image,\n%        ExceptionInfo *exception)\n%      Image *StereoAnaglyphImage(const Image *left_image,\n%        const Image *right_image,const ssize_t x_offset,const ssize_t y_offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o left_image: the left image.\n%\n%    o right_image: the right image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%    o x_offset: amount, in pixels, by which the left image is offset to the\n%      right of the right image.\n%\n%    o y_offset: amount, in pixels, by which the left image is offset to the\n%      bottom of the right image.\n%\n%\n*/\nMagickExport Image *StereoImage(const Image *left_image,\n  const Image *right_image,ExceptionInfo *exception)\n{\n  return(StereoAnaglyphImage(left_image,right_image,0,0,exception));\n}\n\nMagickExport Image *StereoAnaglyphImage(const Image *left_image,\n  const Image *right_image,const ssize_t x_offset,const ssize_t y_offset,\n  ExceptionInfo *exception)\n{\n#define StereoImageTag  \"Stereo/Image\"\n\n  const Image\n    *image;\n\n  Image\n    *stereo_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(left_image != (const Image *) NULL);\n  assert(left_image->signature == MagickCoreSignature);\n  if (left_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      left_image->filename);\n  assert(right_image != (const Image *) NULL);\n  assert(right_image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(right_image != (const Image *) NULL);\n  image=left_image;\n  if ((left_image->columns != right_image->columns) ||\n      (left_image->rows != right_image->rows))\n    ThrowImageException(ImageError,\"LeftAndRightImageSizesDiffer\");\n  /*\n    Initialize stereo image attributes.\n  */\n  stereo_image=CloneImage(left_image,left_image->columns,left_image->rows,\n    MagickTrue,exception);\n  if (stereo_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(stereo_image,DirectClass,exception) == MagickFalse)\n    {\n      stereo_image=DestroyImage(stereo_image);\n      return((Image *) NULL);\n    }\n  (void) SetImageColorspace(stereo_image,sRGBColorspace,exception);\n  /*\n    Copy left image to red channel and right image to blue channel.\n  */\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) stereo_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p,\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict r;\n\n    p=GetVirtualPixels(left_image,-x_offset,y-y_offset,image->columns,1,\n      exception);\n    q=GetVirtualPixels(right_image,0,y,right_image->columns,1,exception);\n    r=QueueAuthenticPixels(stereo_image,0,y,stereo_image->columns,1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL) ||\n        (r == (Quantum *) NULL))\n      break;\n    for (x=0; x < (ssize_t) stereo_image->columns; x++)\n    {\n      SetPixelRed(image,GetPixelRed(left_image,p),r);\n      SetPixelGreen(image,GetPixelGreen(right_image,q),r);\n      SetPixelBlue(image,GetPixelBlue(right_image,q),r);\n      if ((GetPixelAlphaTraits(stereo_image) & CopyPixelTrait) != 0)\n        SetPixelAlpha(image,(GetPixelAlpha(left_image,p)+\n          GetPixelAlpha(right_image,q))/2,r);\n      p+=GetPixelChannels(left_image);\n      q+=GetPixelChannels(right_image);\n      r+=GetPixelChannels(stereo_image);\n    }\n    if (SyncAuthenticPixels(stereo_image,exception) == MagickFalse)\n      break;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,StereoImageTag,(MagickOffsetType) y,\n          stereo_image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  if (status == MagickFalse)\n    stereo_image=DestroyImage(stereo_image);\n  return(stereo_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S w i r l I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SwirlImage() swirls the pixels about the center of the image, where\n%  degrees indicates the sweep of the arc through which each pixel is moved.\n%  You get a more dramatic effect as the degrees move from 1 to 360.\n%\n%  The format of the SwirlImage method is:\n%\n%      Image *SwirlImage(const Image *image,double degrees,\n%        const PixelInterpolateMethod method,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o degrees: Define the tightness of the swirling effect.\n%\n%    o method: the pixel interpolation method.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *SwirlImage(const Image *image,double degrees,\n  const PixelInterpolateMethod method,ExceptionInfo *exception)\n{\n#define SwirlImageTag  \"Swirl/Image\"\n\n  CacheView\n    *image_view,\n    *interpolate_view,\n    *swirl_view;\n\n  Image\n    *swirl_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  double\n    radius;\n\n  PointInfo\n    center,\n    scale;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize swirl image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  swirl_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (swirl_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(swirl_image,DirectClass,exception) == MagickFalse)\n    {\n      swirl_image=DestroyImage(swirl_image);\n      return((Image *) NULL);\n    }\n  if (swirl_image->background_color.alpha != OpaqueAlpha)\n    swirl_image->alpha_trait=BlendPixelTrait;\n  /*\n    Compute scaling factor.\n  */\n  center.x=(double) image->columns/2.0;\n  center.y=(double) image->rows/2.0;\n  radius=MagickMax(center.x,center.y);\n  scale.x=1.0;\n  scale.y=1.0;\n  if (image->columns > image->rows)\n    scale.y=(double) image->columns/(double) image->rows;\n  else\n    if (image->columns < image->rows)\n      scale.x=(double) image->rows/(double) image->columns;\n  degrees=(double) DegreesToRadians(degrees);\n  /*\n    Swirl image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  interpolate_view=AcquireVirtualCacheView(image,exception);\n  swirl_view=AcquireAuthenticCacheView(swirl_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,swirl_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      distance;\n\n    PointInfo\n      delta;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(swirl_view,0,y,swirl_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    delta.y=scale.y*(double) (y-center.y);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      /*\n        Determine if the pixel is within an ellipse.\n      */\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(swirl_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(swirl_image);\n          continue;\n        }\n      delta.x=scale.x*(double) (x-center.x);\n      distance=delta.x*delta.x+delta.y*delta.y;\n      if (distance >= (radius*radius))\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait swirl_traits=GetPixelChannelTraits(swirl_image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (swirl_traits == UndefinedPixelTrait))\n              continue;\n            SetPixelChannel(swirl_image,channel,p[i],q);\n          }\n        }\n      else\n        {\n          double\n            cosine,\n            factor,\n            sine;\n\n          /*\n            Swirl the pixel.\n          */\n          factor=1.0-sqrt((double) distance)/radius;\n          sine=sin((double) (degrees*factor*factor));\n          cosine=cos((double) (degrees*factor*factor));\n          status=InterpolatePixelChannels(image,interpolate_view,swirl_image,\n            method,((cosine*delta.x-sine*delta.y)/scale.x+center.x),(double)\n            ((sine*delta.x+cosine*delta.y)/scale.y+center.y),q,exception);\n        }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(swirl_image);\n    }\n    if (SyncCacheViewAuthenticPixels(swirl_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SwirlImage)\n#endif\n        proceed=SetImageProgress(image,SwirlImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  swirl_view=DestroyCacheView(swirl_view);\n  interpolate_view=DestroyCacheView(interpolate_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    swirl_image=DestroyImage(swirl_image);\n  return(swirl_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     T i n t I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TintImage() applies a color vector to each pixel in the image.  The length\n%  of the vector is 0 for black and white and at its maximum for the midtones.\n%  The vector weighting function is f(x)=(1-(4.0*((x-0.5)*(x-0.5))))\n%\n%  The format of the TintImage method is:\n%\n%      Image *TintImage(const Image *image,const char *blend,\n%        const PixelInfo *tint,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o blend: A color value used for tinting.\n%\n%    o tint: A color value used for tinting.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *TintImage(const Image *image,const char *blend,\n  const PixelInfo *tint,ExceptionInfo *exception)\n{\n#define TintImageTag  \"Tint/Image\"\n\n  CacheView\n    *image_view,\n    *tint_view;\n\n  double\n    intensity;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *tint_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    color_vector;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate tint image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  tint_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (tint_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(tint_image,DirectClass,exception) == MagickFalse)\n    {\n      tint_image=DestroyImage(tint_image);\n      return((Image *) NULL);\n    }\n  if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&\n      (IsPixelInfoGray(tint) == MagickFalse))\n    (void) SetImageColorspace(tint_image,sRGBColorspace,exception);\n  if (blend == (const char *) NULL)\n    return(tint_image);\n  /*\n    Determine RGB values of the color.\n  */\n  GetPixelInfo(image,&color_vector);\n  flags=ParseGeometry(blend,&geometry_info);\n  color_vector.red=geometry_info.rho;\n  color_vector.green=geometry_info.rho;\n  color_vector.blue=geometry_info.rho;\n  color_vector.alpha=(MagickRealType) OpaqueAlpha;\n  if ((flags & SigmaValue) != 0)\n    color_vector.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    color_vector.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    color_vector.alpha=geometry_info.psi;\n  if (image->colorspace == CMYKColorspace)\n    {\n      color_vector.black=geometry_info.rho;\n      if ((flags & PsiValue) != 0)\n        color_vector.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        color_vector.alpha=geometry_info.chi;\n    }\n  intensity=(double) GetPixelInfoIntensity((const Image *) NULL,tint);\n  color_vector.red=(double) (color_vector.red*tint->red/100.0-intensity);\n  color_vector.green=(double) (color_vector.green*tint->green/100.0-intensity);\n  color_vector.blue=(double) (color_vector.blue*tint->blue/100.0-intensity);\n  color_vector.black=(double) (color_vector.black*tint->black/100.0-intensity);\n  color_vector.alpha=(double) (color_vector.alpha*tint->alpha/100.0-intensity);\n  /*\n    Tint image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  tint_view=AcquireAuthenticCacheView(tint_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,tint_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(tint_view,0,y,tint_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      PixelInfo\n        pixel;\n\n      double\n        weight;\n\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait tint_traits=GetPixelChannelTraits(tint_image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (tint_traits == UndefinedPixelTrait))\n          continue;\n        if (((tint_traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(image,p) == 0))\n          {\n            SetPixelChannel(tint_image,channel,p[i],q);\n            continue;\n          }\n      }\n      GetPixelInfo(image,&pixel);\n      weight=QuantumScale*GetPixelRed(image,p)-0.5;\n      pixel.red=(double) GetPixelRed(image,p)+color_vector.red*(1.0-(4.0*\n        (weight*weight)));\n      weight=QuantumScale*GetPixelGreen(image,p)-0.5;\n      pixel.green=(double) GetPixelGreen(image,p)+color_vector.green*(1.0-(4.0*\n        (weight*weight)));\n      weight=QuantumScale*GetPixelBlue(image,p)-0.5;\n      pixel.blue=(double) GetPixelBlue(image,p)+color_vector.blue*(1.0-(4.0*\n        (weight*weight)));\n      weight=QuantumScale*GetPixelBlack(image,p)-0.5;\n      pixel.black=(double) GetPixelBlack(image,p)+color_vector.black*(1.0-(4.0*\n        (weight*weight)));\n      SetPixelViaPixelInfo(tint_image,&pixel,q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(tint_image);\n    }\n    if (SyncCacheViewAuthenticPixels(tint_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_TintImage)\n#endif\n        proceed=SetImageProgress(image,TintImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  tint_view=DestroyCacheView(tint_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    tint_image=DestroyImage(tint_image);\n  return(tint_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     V i g n e t t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  VignetteImage() softens the edges of the image in vignette style.\n%\n%  The format of the VignetteImage method is:\n%\n%      Image *VignetteImage(const Image *image,const double radius,\n%        const double sigma,const ssize_t x,const ssize_t y,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o radius: the radius of the pixel neighborhood.\n%\n%    o sigma: the standard deviation of the Gaussian, in pixels.\n%\n%    o x, y:  Define the x and y ellipse offset.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *VignetteImage(const Image *image,const double radius,\n  const double sigma,const ssize_t x,const ssize_t y,ExceptionInfo *exception)\n{\n  char\n    ellipse[MagickPathExtent];\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *canvas_image,\n    *blur_image,\n    *oval_image,\n    *vignette_image;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  canvas_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (canvas_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(canvas_image,DirectClass,exception) == MagickFalse)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      return((Image *) NULL);\n    }\n  canvas_image->alpha_trait=BlendPixelTrait;\n  oval_image=CloneImage(canvas_image,canvas_image->columns,canvas_image->rows,\n    MagickTrue,exception);\n  if (oval_image == (Image *) NULL)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      return((Image *) NULL);\n    }\n  (void) QueryColorCompliance(\"#000000\",AllCompliance,\n    &oval_image->background_color,exception);\n  (void) SetImageBackgroundColor(oval_image,exception);\n  draw_info=CloneDrawInfo((const ImageInfo *) NULL,(const DrawInfo *) NULL);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&draw_info->fill,\n    exception);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&draw_info->stroke,\n    exception);\n  (void) FormatLocaleString(ellipse,MagickPathExtent,\"ellipse %g,%g,%g,%g,\"\n    \"0.0,360.0\",image->columns/2.0,image->rows/2.0,image->columns/2.0-x,\n    image->rows/2.0-y);\n  draw_info->primitive=AcquireString(ellipse);\n  (void) DrawImage(oval_image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  blur_image=BlurImage(oval_image,radius,sigma,exception);\n  oval_image=DestroyImage(oval_image);\n  if (blur_image == (Image *) NULL)\n    {\n      canvas_image=DestroyImage(canvas_image);\n      return((Image *) NULL);\n    }\n  blur_image->alpha_trait=UndefinedPixelTrait;\n  (void) CompositeImage(canvas_image,blur_image,IntensityCompositeOp,MagickTrue,\n    0,0,exception);\n  blur_image=DestroyImage(blur_image);\n  vignette_image=MergeImageLayers(canvas_image,FlattenLayer,exception);\n  canvas_image=DestroyImage(canvas_image);\n  if (vignette_image != (Image *) NULL)\n    (void) TransformImageColorspace(vignette_image,image->colorspace,exception);\n  return(vignette_image);\n}\n\n\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     W a v e I m a g e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WaveImage() creates a \"ripple\" effect in the image by shifting the pixels\n%  vertically along a sine wave whose amplitude and wavelength is specified\n%  by the given parameters.\n%\n%  The format of the WaveImage method is:\n%\n%      Image *WaveImage(const Image *image,const double amplitude,\n%        const double wave_length,const PixelInterpolateMethod method,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o amplitude, wave_length:  Define the amplitude and wave length of the\n%      sine wave.\n%\n%    o interpolate: the pixel interpolation method.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *WaveImage(const Image *image,const double amplitude,\n  const double wave_length,const PixelInterpolateMethod method,\n  ExceptionInfo *exception)\n{\n#define WaveImageTag  \"Wave/Image\"\n\n  CacheView\n    *image_view,\n    *wave_view;\n\n  Image\n    *wave_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  double\n    *sine_map;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize wave image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  wave_image=CloneImage(image,image->columns,(size_t) (image->rows+2.0*\n    fabs(amplitude)),MagickTrue,exception);\n  if (wave_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(wave_image,DirectClass,exception) == MagickFalse)\n    {\n      wave_image=DestroyImage(wave_image);\n      return((Image *) NULL);\n    }\n  if (wave_image->background_color.alpha != OpaqueAlpha)\n    wave_image->alpha_trait=BlendPixelTrait;\n  /*\n    Allocate sine map.\n  */\n  sine_map=(double *) AcquireQuantumMemory((size_t) wave_image->columns,\n    sizeof(*sine_map));\n  if (sine_map == (double *) NULL)\n    {\n      wave_image=DestroyImage(wave_image);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i=0; i < (ssize_t) wave_image->columns; i++)\n    sine_map[i]=fabs(amplitude)+amplitude*sin((double) ((2.0*MagickPI*i)/\n      wave_length));\n  /*\n    Wave image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  wave_view=AcquireAuthenticCacheView(wave_image,exception);\n  (void) SetCacheViewVirtualPixelMethod(image_view,\n    BackgroundVirtualPixelMethod);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,wave_image,wave_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) wave_image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(wave_view,0,y,wave_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) wave_image->columns; x++)\n    {\n      status=InterpolatePixelChannels(image,image_view,wave_image,method,\n        (double) x,(double) (y-sine_map[x]),q,exception);\n      q+=GetPixelChannels(wave_image);\n    }\n    if (SyncCacheViewAuthenticPixels(wave_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_WaveImage)\n#endif\n        proceed=SetImageProgress(image,WaveImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  wave_view=DestroyCacheView(wave_view);\n  image_view=DestroyCacheView(image_view);\n  sine_map=(double *) RelinquishMagickMemory(sine_map);\n  if (status == MagickFalse)\n    wave_image=DestroyImage(wave_image);\n  return(wave_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     W a v e l e t D e n o i s e I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WaveletDenoiseImage() removes noise from the image using a wavelet\n%  transform.  The wavelet transform is a fast hierarchical scheme for\n%  processing an image using a set of consecutive lowpass and high_pass filters,\n%  followed by a decimation.  This results in a decomposition into different\n%  scales which can be regarded as different \u201cfrequency bands\u201d, determined by\n%  the mother wavelet.  Adapted from dcraw.c by David Coffin.\n%\n%  The format of the WaveletDenoiseImage method is:\n%\n%      Image *WaveletDenoiseImage(const Image *image,const double threshold,\n%        const double softness,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: set the threshold for smoothing.\n%\n%    o softness: attenuate the smoothing threshold.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline void HatTransform(const float *magick_restrict pixels,\n  const size_t stride,const size_t extent,const size_t scale,float *kernel)\n{\n  const float\n    *magick_restrict p,\n    *magick_restrict q,\n    *magick_restrict r;\n\n  register ssize_t\n    i;\n\n  p=pixels;\n  q=pixels+scale*stride;\n  r=pixels+scale*stride;\n  for (i=0; i < (ssize_t) scale; i++)\n  {\n    kernel[i]=0.25f*(*p+(*p)+(*q)+(*r));\n    p+=stride;\n    q-=stride;\n    r+=stride;\n  }\n  for ( ; i < (ssize_t) (extent-scale); i++)\n  {\n    kernel[i]=0.25f*(2.0f*(*p)+*(p-scale*stride)+*(p+scale*stride));\n    p+=stride;\n  }\n  q=p-scale*stride;\n  r=pixels+stride*(extent-2);\n  for ( ; i < (ssize_t) extent; i++)\n  {\n    kernel[i]=0.25f*(*p+(*p)+(*q)+(*r));\n    p+=stride;\n    q+=stride;\n    r-=stride;\n  }\n}\n\nMagickExport Image *WaveletDenoiseImage(const Image *image,\n  const double threshold,const double softness,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view,\n    *noise_view;\n\n  float\n    *kernel,\n    *pixels;\n\n  Image\n    *noise_image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixels_info;\n\n  ssize_t\n    channel;\n\n  static const float\n    noise_levels[] = { 0.8002f, 0.2735f, 0.1202f, 0.0585f, 0.0291f, 0.0152f,\n      0.0080f, 0.0044f };\n\n  /*\n    Initialize noise image attributes.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  noise_image=AccelerateWaveletDenoiseImage(image,threshold,exception);\n  if (noise_image != (Image *) NULL)\n    return(noise_image);\n#endif\n  noise_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (noise_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(noise_image,DirectClass,exception) == MagickFalse)\n    {\n      noise_image=DestroyImage(noise_image);\n      return((Image *) NULL);\n    }\n  if (AcquireMagickResource(WidthResource,4*image->columns) == MagickFalse)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*\n    sizeof(*pixels));\n  kernel=(float *) AcquireQuantumMemory(MagickMax(image->rows,image->columns)+1,\n    GetOpenMPMaximumThreads()*sizeof(*kernel));\n  if ((pixels_info == (MemoryInfo *) NULL) || (kernel == (float *) NULL))\n    {\n      if (kernel != (float *) NULL)\n        kernel=(float *) RelinquishMagickMemory(kernel);\n      if (pixels_info != (MemoryInfo *) NULL)\n        pixels_info=RelinquishVirtualMemory(pixels_info);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  pixels=(float *) GetVirtualMemoryBlob(pixels_info);\n  status=MagickTrue;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  noise_view=AcquireAuthenticCacheView(noise_image,exception);\n  for (channel=0; channel < (ssize_t) GetPixelChannels(image); channel++)\n  {\n    register ssize_t\n      i;\n\n    size_t\n      high_pass,\n      low_pass;\n\n    ssize_t\n      level,\n      y;\n\n    PixelChannel\n      pixel_channel;\n\n    PixelTrait\n      traits;\n\n    if (status == MagickFalse)\n      continue;\n    traits=GetPixelChannelTraits(image,(PixelChannel) channel);\n    if (traits == UndefinedPixelTrait)\n      continue;\n    pixel_channel=GetPixelChannelChannel(image,channel);\n    if ((pixel_channel != RedPixelChannel) &&\n        (pixel_channel != GreenPixelChannel) &&\n        (pixel_channel != BluePixelChannel))\n      continue;\n    /*\n      Copy channel from image to wavelet pixel array.\n    */\n    i=0;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register const Quantum\n        *magick_restrict p;\n\n      ssize_t\n        x;\n\n      p=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        pixels[i++]=(float) p[channel];\n        p+=GetPixelChannels(image);\n      }\n    }\n    /*\n      Low pass filter outputs are called approximation kernel & high pass\n      filters are referred to as detail kernel. The detail kernel\n      have high values in the noisy parts of the signal.\n    */\n    high_pass=0;\n    for (level=0; level < 5; level++)\n    {\n      double\n        magnitude;\n\n      ssize_t\n        x,\n        y;\n\n      low_pass=(size_t) (number_pixels*((level & 0x01)+1));\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,1) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        register float\n          *magick_restrict p,\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        p=kernel+id*image->columns;\n        q=pixels+y*image->columns;\n        HatTransform(q+high_pass,1,image->columns,(size_t) (1 << level),p);\n        q+=low_pass;\n        for (x=0; x < (ssize_t) image->columns; x++)\n          *q++=(*p++);\n      }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,1) \\\n        magick_threads(image,image,image->columns,1)\n#endif\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        register float\n          *magick_restrict p,\n          *magick_restrict q;\n\n        register ssize_t\n          y;\n\n        p=kernel+id*image->rows;\n        q=pixels+x+low_pass;\n        HatTransform(q,image->columns,image->rows,(size_t) (1 << level),p);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          *q=(*p++);\n          q+=image->columns;\n        }\n      }\n      /*\n        To threshold, each coefficient is compared to a threshold value and\n        attenuated / shrunk by some factor.\n      */\n      magnitude=threshold*noise_levels[level];\n      for (i=0; i < (ssize_t) number_pixels; ++i)\n      {\n        pixels[high_pass+i]-=pixels[low_pass+i];\n        if (pixels[high_pass+i] < -magnitude)\n          pixels[high_pass+i]+=magnitude-softness*magnitude;\n        else\n          if (pixels[high_pass+i] > magnitude)\n            pixels[high_pass+i]-=magnitude-softness*magnitude;\n          else\n            pixels[high_pass+i]*=softness;\n        if (high_pass != 0)\n          pixels[i]+=pixels[high_pass+i];\n      }\n      high_pass=low_pass;\n    }\n    /*\n      Reconstruct image from the thresholded wavelet kernel.\n    */\n    i=0;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      MagickBooleanType\n        sync;\n\n      register Quantum\n        *magick_restrict q;\n\n      register ssize_t\n        x;\n\n      ssize_t\n        offset;\n\n      q=GetCacheViewAuthenticPixels(noise_view,0,y,noise_image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        {\n          status=MagickFalse;\n          break;\n        }\n      offset=GetPixelChannelOffset(noise_image,pixel_channel);\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        MagickRealType\n          pixel;\n\n        pixel=(MagickRealType) pixels[i]+pixels[low_pass+i];\n        q[offset]=ClampToQuantum(pixel);\n        i++;\n        q+=GetPixelChannels(noise_image);\n      }\n      sync=SyncCacheViewAuthenticPixels(noise_view,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,AddNoiseImageTag,(MagickOffsetType)\n          channel,GetPixelChannels(image));\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  noise_view=DestroyCacheView(noise_view);\n  image_view=DestroyCacheView(image_view);\n  kernel=(float *) RelinquishMagickMemory(kernel);\n  pixels_info=RelinquishVirtualMemory(pixels_info);\n  if (status == MagickFalse)\n    noise_image=DestroyImage(noise_image);\n  return(noise_image);\n}\n", "#!/usr/bin/perl\n#\n# Overall demo of the major PerlMagick methods.\n#\nuse Image::Magick;\n\n#\n# Read model & smile image.\n#\nprint \"Read...\\n\";\n$null=Image::Magick->new;\n$null->Set(size=>'70x70');\n$x=$null->ReadImage('NULL:black');\nwarn \"$x\" if \"$x\";\n\n$model=Image::Magick->new();\n$x=$model->ReadImage('model.gif');\nwarn \"$x\" if \"$x\";\n$model->Label('Magick');\n$model->Set(background=>'white');\n\n$smile=Image::Magick->new;\n$x=$smile->ReadImage('smile.gif');\nwarn \"$x\" if \"$x\";\n$smile->Label('Smile');\n$smile->Set(background=>'white');\n#\n# Create image stack.\n#\nprint \"Transform image...\\n\";\n$images=Image::Magick->new();\n\nprint \"Adaptive Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Adaptive Blur');\n$example->AdaptiveBlur('0x1');\npush(@$images,$example);\n\nprint \"Adaptive Resize...\\n\";\n$example=$model->Clone();\n$example->Label('Adaptive Resize');\n$example->AdaptiveResize('60%');\npush(@$images,$example);\n\nprint \"Adaptive Sharpen...\\n\";\n$example=$model->Clone();\n$example->Label('Adaptive Sharpen');\n$example->AdaptiveSharpen('0x1');\npush(@$images,$example);\n\nprint \"Adaptive Threshold...\\n\";\n$example=$model->Clone();\n$example->Label('Adaptive Threshold');\n$example->AdaptiveThreshold('5x5+5%');\npush(@$images,$example);\n\nprint \"Add Noise...\\n\";\n$example=$model->Clone();\n$example->Label('Add Noise');\n$example->AddNoise(\"Laplacian\");\npush(@$images,$example);\n\nprint \"Annotate...\\n\";\n$example=$model->Clone();\n$example->Label('Annotate');\n$example->Annotate(text=>'Magick',geometry=>'+0+20',font=>'Generic.ttf',\n  fill=>'gold',gravity=>'North',pointsize=>14);\npush(@$images,$example);\n\nprint \"Auto-gamma...\\n\";\n$example=$model->Clone();\n$example->Label('Auto Gamma');\n$example->AutoGamma();\npush(@$images,$example);\n\nprint \"Auto-level...\\n\";\n$example=$model->Clone();\n$example->Label('Auto Level');\n$example->AutoLevel();\npush(@$images,$example);\n\nprint \"Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Blur');\n$example->Blur('0.0x1.0');\npush(@$images,$example);\n\nprint \"Border...\\n\";\n$example=$model->Clone();\n$example->Label('Border');\n$example->Border(geometry=>'6x6',color=>'gold');\npush(@$images,$example);\n\nprint \"Channel...\\n\";\n$example=$model->Clone();\n$example->Label('Channel');\n$example->Channel(channel=>'red');\npush(@$images,$example);\n\nprint \"Charcoal...\\n\";\n$example=$model->Clone();\n$example->Label('Charcoal');\n$example->Charcoal('2x1');\npush(@$images,$example);\n\nprint \"ColorMatrix...\\n\";\n$example=$model->Clone();\n$example->Label('ColorMatrix');\n$example->ColorMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0.5, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\npush(@$images,$example);\n\nprint \"Composite...\\n\";\n$example=$model->Clone();\n$example->Label('Composite');\n$example->Composite(image=>$smile,compose=>'over',geometry=>'+35+65');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Contrast...\\n\";\n$example=$model->Clone();\n$example->Label('Contrast');\n$example->Contrast();\npush(@$images,$example);\n\nprint \"Contrast Stretch...\\n\";\n$example=$model->Clone();\n$example->Label('Contrast Stretch');\n$example->ContrastStretch('5%');\npush(@$images,$example);\n\nprint \"Convolve...\\n\";\n$example=$model->Clone();\n$example->Label('Convolve');\n$example->Convolve([0.125, 0.125, 0.125, 0.125, 0.5, 0.125, 0.125, 0.125, 0.125]);\npush(@$images,$example);\n\nprint \"Crop...\\n\";\n$example=$model->Clone();\n$example->Label('Crop');\n$example->Crop(geometry=>'80x80+25+50');\n$example->Set(page=>'0x0+0+0');\npush(@$images,$example);\n\nprint \"Despeckle...\\n\";\n$example=$model->Clone();\n$example->Label('Despeckle');\n$example->Despeckle();\npush(@$images,$example);\n\nprint \"Distort...\\n\";\n$example=$model->Clone();\n$example->Label('Distort');\n$example->Distort(method=>'arc',points=>[60],'virtual-pixel'=>'white');\npush(@$images,$example);\n\nprint \"Draw...\\n\";\n$example=$model->Clone();\n$example->Label('Draw');\n$example->Draw(fill=>'none',stroke=>'gold',primitive=>'circle',\n  points=>'60,90 60,120',strokewidth=>2);\npush(@$images,$example);\n\nprint \"Detect Edges...\\n\";\n$example=$model->Clone();\n$example->Label('Detect Edges');\n$example->Edge('2x0.5');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Emboss...\\n\";\n$example=$model->Clone();\n$example->Label('Emboss');\n$example->Emboss('0x1');\npush(@$images,$example);\n\nprint \"Encipher...\\n\";\n$example=$model->Clone();\n$example->Label('Encipher');\n$example->Encipher('Magick');\npush(@$images,$example);\n\nprint \"Equalize...\\n\";\n$example=$model->Clone();\n$example->Label('Equalize');\n$example->Equalize();\npush(@$images,$example);\n\nprint \"Explode...\\n\";\n$example=$model->Clone();\n$example->Label('Explode');\n$example->Implode(-1);\npush(@$images,$example);\n\nprint \"Flip...\\n\";\n$example=$model->Clone();\n$example->Label('Flip');\n$example->Flip();\npush(@$images,$example);\n\nprint \"Flop...\\n\";\n$example=$model->Clone();\n$example->Label('Flop');\n$example->Flop();\npush(@$images,$example);\n\nprint \"Frame...\\n\";\n$example=$model->Clone();\n$example->Label('Frame');\n$example->Frame('15x15+3+3');\npush(@$images,$example);\n\nprint \"Fx...\\n\";\n$example=$model->Clone();\n$example->Label('Fx');\npush(@$images,$example->Fx(expression=>'0.5*u'));\n\nprint \"Gamma...\\n\";\n$example=$model->Clone();\n$example->Label('Gamma');\n$example->Gamma(1.6);\npush(@$images,$example);\n\nprint \"Gaussian Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Gaussian Blur');\n$example->GaussianBlur('0.0x1.5');\npush(@$images,$example);\n\nprint \"Gradient...\\n\";\n$gradient=Image::Magick->new;\n$gradient->Set(size=>'130x194');\n$x=$gradient->ReadImage('gradient:#20a0ff-#ffff00');\nwarn \"$x\" if \"$x\";\n$gradient->Label('Gradient');\npush(@$images,$gradient);\n\nprint \"Grayscale...\\n\";\n$example=$model->Clone();\n$example->Label('Grayscale');\n$example->Set(type=>'grayscale');\npush(@$images,$example);\n\nprint \"Implode...\\n\";\n$example=$model->Clone();\n$example->Label('Implode');\n$example->Implode(0.5);\npush(@$images,$example);\n\nprint \"Kuwahara...\\n\";\n$example=$model->Clone();\n$example->Label('Kuwahara');\n$example->Kuwahara('0x1');\npush(@$images,$example);\n\nprint \"Level...\\n\";\n$example=$model->Clone();\n$example->Label('Level');\n$example->Level('20%x');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Linear stretch...\\n\";\n$example=$model->Clone();\n$example->Label('Linear Stretch');\n$example->LinearStretch('5x5');\npush(@$images,$example);\n\nprint \"Median Filter...\\n\";\n$example=$model->Clone();\n$example->Label('Median Filter');\n$example->MedianFilter('4x4');\npush(@$images,$example);\n\nprint \"Mode...\\n\";\n$example=$model->Clone();\n$example->Label('Mode');\n$example->Mode('4x4');\npush(@$images,$example);\n\nprint \"Modulate...\\n\";\n$example=$model->Clone();\n$example->Label('Modulate');\n$example->Modulate(brightness=>110,saturation=>110,hue=>110);\npush(@$images,$example);\n$example=$model->Clone();\n\nprint \"Monochrome...\\n\";\n$example=$model->Clone();\n$example->Label('Monochrome');\n$example->Quantize(colorspace=>'gray',colors=>2,dither=>'false');\npush(@$images,$example);\n\nprint \"Morphology...\\n\";\n$example=$model->Clone();\n$example->Label('Morphology');\n$example->Morphology(method=>'Dilate',kernel=>'Diamond',iterations=>2);\npush(@$images,$example);\n\nprint \"Motion Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Motion Blur');\n$example->MotionBlur('0x13+10-10');\npush(@$images,$example);\n\nprint \"Negate...\\n\";\n$example=$model->Clone();\n$example->Label('Negate');\n$example->Negate();\npush(@$images,$example);\n\nprint \"Normalize...\\n\";\n$example=$model->Clone();\n$example->Label('Normalize');\n$example->Normalize();\npush(@$images,$example);\n\nprint \"Oil Paint...\\n\";\n$example=$model->Clone();\n$example->Label('Oil Paint');\n$example->OilPaint('2x0.5');\npush(@$images,$example);\n\nprint \"Plasma...\\n\";\n$plasma=Image::Magick->new;\n$plasma->Set(size=>'130x194');\n$x=$plasma->ReadImage('plasma:fractal');\nwarn \"$x\" if \"$x\";\n$plasma->Label('Plasma');\npush(@$images,$plasma);\n\nprint \"Polaroid...\\n\";\n$example=$model->Clone();\n$example->Label('Polaroid');\n$example->Polaroid(caption=>'Magick',angle=>-5.0,gravity=>'center');\npush(@$images,$example);\n\nprint \"Posterize...\\n\";\n$example=$model->Clone();\n$example->Label('Posterize');\n$example->Posterize(5);\npush(@$images,$example);\n\nprint \"Quantize...\\n\";\n$example=$model->Clone();\n$example->Label('Quantize');\n$example->Quantize();\npush(@$images,$example);\n\nprint \"Rotational Blur...\\n\";\n$example=$model->Clone();\n$example->Label('Rotational Blur');\n$example->RotationalBlur(10);\npush(@$images,$example);\n\nprint \"Raise...\\n\";\n$example=$model->Clone();\n$example->Label('Raise');\n$example->Raise('10x10');\npush(@$images,$example);\n\nprint \"Reduce Noise...\\n\";\n$example=$model->Clone();\n$example->Label('Reduce Noise');\n$example->ReduceNoise('2x2');\npush(@$images,$example);\n\nprint \"Resize...\\n\";\n$example=$model->Clone();\n$example->Label('Resize');\n$example->Resize('60%');\npush(@$images,$example);\n\nprint \"Roll...\\n\";\n$example=$model->Clone();\n$example->Label('Roll');\n$example->Roll(geometry=>'+20+10');\npush(@$images,$example);\n\nprint \"Rotate...\\n\";\n$example=$model->Clone();\n$example->Label('Rotate');\n$example->Rotate(45);\npush(@$images,$example);\n\nprint \"Sample...\\n\";\n$example=$model->Clone();\n$example->Label('Sample');\n$example->Sample('60%');\npush(@$images,$example);\n\nprint \"Scale...\\n\";\n$example=$model->Clone();\n$example->Label('Scale');\n$example->Scale('60%');\npush(@$images,$example);\n\nprint \"Segment...\\n\";\n$example=$model->Clone();\n$example->Label('Segment');\n$example->Segment();\npush(@$images,$example);\n\nprint \"Shade...\\n\";\n$example=$model->Clone();\n$example->Label('Shade');\n$example->Shade(geometry=>'30x30',gray=>'true');\npush(@$images,$example);\n\nprint \"Sharpen...\\n\";\n$example=$model->Clone();\n$example->Label('Sharpen');\n$example->Sharpen('0.0x1.0');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Shave...\\n\";\n$example=$model->Clone();\n$example->Label('Shave');\n$example->Shave('10x10');\npush(@$images,$example);\n\nprint \"Shear...\\n\";\n$example=$model->Clone();\n$example->Label('Shear');\n$example->Shear('-20x20');\npush(@$images,$example);\n\nprint \"Sketch...\\n\";\n$example=$model->Clone();\n$example->Label('Sketch');\n$example->Set(colorspace=>'Gray');\n$example->Sketch('0x20+120');\npush(@$images,$example);\n\nprint \"Sigmoidal Contrast...\\n\";\n$example=$model->Clone();\n$example->Label('Sigmoidal Contrast');\n$example->SigmoidalContrast(\"3x50%\");\npush(@$images,$example);\n\nprint \"Spread...\\n\";\n$example=$model->Clone();\n$example->Label('Spread');\n$example->Spread();\npush(@$images,$example);\n\nprint \"Solarize...\\n\";\n$example=$model->Clone();\n$example->Label('Solarize');\n$example->Solarize();\npush(@$images,$example);\n\nprint \"Swirl...\\n\";\n$example=$model->Clone();\n$example->Label('Swirl');\n$example->Swirl(90);\npush(@$images,$example);\n\nprint \"Tint...\\n\";\n$example=$model->Clone();\n$example->Label('Tint');\n$example->Tint('wheat');\npush(@$images,$example);\n\nprint \"Unsharp Mask...\\n\";\n$example=$model->Clone();\n$example->Label('Unsharp Mask');\n$example->UnsharpMask('0.0x1.0');\n$example->Clamp();\npush(@$images,$example);\n\nprint \"Vignette...\\n\";\n$example=$model->Clone();\n$example->Label('Vignette');\n$example->Vignette('0x20');\npush(@$images,$example);\n\nprint \"Wave...\\n\";\n$example=$model->Clone();\n$example->Label('Wave');\n$example->Wave('25x150');\npush(@$images,$example);\n\nprint \"WaveletDenoise...\\n\";\n$example=$model->Clone();\n$example->Label('Wavelet Denoise');\n$example->WaveletDenoise('5%');\npush(@$images,$example);\n\n#\n# Create image montage.\n#\nprint \"Montage...\\n\";\n$montage=$images->Montage(geometry=>'128x160+8+4>',gravity=>'Center',\n  tile=>'5x+10+200',compose=>'over',background=>'#ffffff',font=>'Generic.ttf',\n  pointsize=>18,fill=>'#600',stroke=>'none',shadow=>'true');\n\n$logo=Image::Magick->new();\n$logo->Read('logo:');\n$logo->Zoom('40%');\n$montage->Composite(image=>$logo,gravity=>'North');\n\nprint \"Write...\\n\";\n$montage->Set(matte=>'false');\n$montage->Write('demo.jpg');\nprint \"Display...\\n\";\n$montage->Write('win:');\n"], "filenames": ["MagickCore/fx.c", "PerlMagick/demo/demo.pl"], "buggy_code_start_loc": [5870, 486], "buggy_code_end_loc": [5871, 487], "fixing_code_start_loc": [5870, 486], "fixing_code_end_loc": [5871, 487], "type": "CWE-119", "message": "Heap overflow in the WaveletDenoiseImage function in MagickCore/fx.c in ImageMagick before 6.9.6-4 and 7.x before 7.0.3-6 allows remote attackers to cause a denial of service (crash) via a crafted image.", "other": {"cve": {"id": "CVE-2016-9298", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-27T22:59:01.897", "lastModified": "2017-07-01T01:30:12.533", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap overflow in the WaveletDenoiseImage function in MagickCore/fx.c in ImageMagick before 6.9.6-4 and 7.x before 7.0.3-6 allows remote attackers to cause a denial of service (crash) via a crafted image."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n WaveletDenoiseImage en MagickCore/fx.c en ImageMagick en versiones anteriores a 6.9.6-4 y 7.x en versiones anteriores a 7.0.3-6 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de una imagen manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.6-3", "matchCriteriaId": "687107C7-3539-40D5-8C53-62554B347711"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-0:*:*:*:*:*:*:*", "matchCriteriaId": "693C9F8F-A8C1-4D06-8F31-E085E16E701C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-1:*:*:*:*:*:*:*", "matchCriteriaId": "6D3D3DFC-8459-41BA-BF3E-AE84E48FCEE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-2:*:*:*:*:*:*:*", "matchCriteriaId": "A3E12EB4-B8F6-43A3-847D-DBC96AE10905"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-3:*:*:*:*:*:*:*", "matchCriteriaId": "30539421-5872-4C2E-94AE-8A2B05C952C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-4:*:*:*:*:*:*:*", "matchCriteriaId": "1A5B7537-8563-409D-82DE-EB07107D3C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-5:*:*:*:*:*:*:*", "matchCriteriaId": "FA648D3C-A464-4F54-8B5E-E8431531FBB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-6:*:*:*:*:*:*:*", "matchCriteriaId": "D6666BB0-B211-490F-884C-BE410CD19DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-7:*:*:*:*:*:*:*", "matchCriteriaId": "5FF2582D-1513-448B-8B61-9C4844B08324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-8:*:*:*:*:*:*:*", "matchCriteriaId": "E57E6BA4-A727-4CF5-B15F-76632D02617A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-9:*:*:*:*:*:*:*", "matchCriteriaId": "C721BC6F-61DD-4ED1-8024-2946C494AEC4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.1-10:*:*:*:*:*:*:*", "matchCriteriaId": "CD319D32-FE7A-456D-AFEE-DC9F0D98652C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-0:*:*:*:*:*:*:*", "matchCriteriaId": "09CDF263-38F5-469F-984B-9D9A223159B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-1:*:*:*:*:*:*:*", "matchCriteriaId": "243FF3C1-D676-4D5F-A90C-3017DCBBE73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-2:*:*:*:*:*:*:*", "matchCriteriaId": "1B8BDDE6-6B38-442B-83A4-FAADBAE1C792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-3:*:*:*:*:*:*:*", "matchCriteriaId": "4DCD89B9-6A69-41DE-BE38-5E9193828279"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-4:*:*:*:*:*:*:*", "matchCriteriaId": "139BC277-8E00-4700-8B47-6D3A3CB38B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-5:*:*:*:*:*:*:*", "matchCriteriaId": "D0FA2E18-6F7B-49D6-B60C-38851398F9B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-6:*:*:*:*:*:*:*", "matchCriteriaId": "7B7F510A-A439-47A3-AF31-4BF7F74D58A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-7:*:*:*:*:*:*:*", "matchCriteriaId": "A91B94E3-33BB-46B6-A1AE-EAA9906605CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-8:*:*:*:*:*:*:*", "matchCriteriaId": "F5B3DE17-08A8-457D-9AEB-BD6E04376B34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-9:*:*:*:*:*:*:*", "matchCriteriaId": "98AD438E-28B7-4491-B58F-55FDE7F67CFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.2-10:*:*:*:*:*:*:*", "matchCriteriaId": "7E033A09-4F2F-4957-A9A8-5C9E7D90A1CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-0:*:*:*:*:*:*:*", "matchCriteriaId": "BB9B68E7-0E40-437A-A71B-0C078FE76FD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "948D5778-AD2A-4293-AE39-A406D75F5678"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-3:*:*:*:*:*:*:*", "matchCriteriaId": "CC773CB4-0E7B-4D73-AB9C-D7CC98C38BD7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-4:*:*:*:*:*:*:*", "matchCriteriaId": "24A0C584-9DA3-48B0-B152-67B9E0239876"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-5:*:*:*:*:*:*:*", "matchCriteriaId": "E42943C5-CC66-4E88-9085-1BD39937C09B"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/13/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/14/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94310", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/3cbfb163cff9e5b8cdeace8312e9bfee810ed02b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/296", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201702-09", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/3cbfb163cff9e5b8cdeace8312e9bfee810ed02b"}}