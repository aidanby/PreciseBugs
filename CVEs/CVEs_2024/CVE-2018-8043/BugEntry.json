{"buggy_code": ["/*\n * Broadcom UniMAC MDIO bus controller driver\n *\n * Copyright (C) 2014-2017 Broadcom\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/kernel.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_mdio.h>\n\n#include <linux/platform_data/mdio-bcm-unimac.h>\n\n#define MDIO_CMD\t\t0x00\n#define  MDIO_START_BUSY\t(1 << 29)\n#define  MDIO_READ_FAIL\t\t(1 << 28)\n#define  MDIO_RD\t\t(2 << 26)\n#define  MDIO_WR\t\t(1 << 26)\n#define  MDIO_PMD_SHIFT\t\t21\n#define  MDIO_PMD_MASK\t\t0x1F\n#define  MDIO_REG_SHIFT\t\t16\n#define  MDIO_REG_MASK\t\t0x1F\n\n#define MDIO_CFG\t\t0x04\n#define  MDIO_C22\t\t(1 << 0)\n#define  MDIO_C45\t\t0\n#define  MDIO_CLK_DIV_SHIFT\t4\n#define  MDIO_CLK_DIV_MASK\t0x3F\n#define  MDIO_SUPP_PREAMBLE\t(1 << 12)\n\nstruct unimac_mdio_priv {\n\tstruct mii_bus\t\t*mii_bus;\n\tvoid __iomem\t\t*base;\n\tint (*wait_func)\t(void *wait_func_data);\n\tvoid\t\t\t*wait_func_data;\n};\n\nstatic inline u32 unimac_mdio_readl(struct unimac_mdio_priv *priv, u32 offset)\n{\n\t/* MIPS chips strapped for BE will automagically configure the\n\t * peripheral registers for CPU-native byte order.\n\t */\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\treturn __raw_readl(priv->base + offset);\n\telse\n\t\treturn readl_relaxed(priv->base + offset);\n}\n\nstatic inline void unimac_mdio_writel(struct unimac_mdio_priv *priv, u32 val,\n\t\t\t\t      u32 offset)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\t__raw_writel(val, priv->base + offset);\n\telse\n\t\twritel_relaxed(val, priv->base + offset);\n}\n\nstatic inline void unimac_mdio_start(struct unimac_mdio_priv *priv)\n{\n\tu32 reg;\n\n\treg = unimac_mdio_readl(priv, MDIO_CMD);\n\treg |= MDIO_START_BUSY;\n\tunimac_mdio_writel(priv, reg, MDIO_CMD);\n}\n\nstatic inline unsigned int unimac_mdio_busy(struct unimac_mdio_priv *priv)\n{\n\treturn unimac_mdio_readl(priv, MDIO_CMD) & MDIO_START_BUSY;\n}\n\nstatic int unimac_mdio_poll(void *wait_func_data)\n{\n\tstruct unimac_mdio_priv *priv = wait_func_data;\n\tunsigned int timeout = 1000;\n\n\tdo {\n\t\tif (!unimac_mdio_busy(priv))\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t} while (--timeout);\n\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int unimac_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct unimac_mdio_priv *priv = bus->priv;\n\tint ret;\n\tu32 cmd;\n\n\t/* Prepare the read operation */\n\tcmd = MDIO_RD | (phy_id << MDIO_PMD_SHIFT) | (reg << MDIO_REG_SHIFT);\n\tunimac_mdio_writel(priv, cmd, MDIO_CMD);\n\n\t/* Start MDIO transaction */\n\tunimac_mdio_start(priv);\n\n\tret = priv->wait_func(priv->wait_func_data);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd = unimac_mdio_readl(priv, MDIO_CMD);\n\n\t/* Some broken devices are known not to release the line during\n\t * turn-around, e.g: Broadcom BCM53125 external switches, so check for\n\t * that condition here and ignore the MDIO controller read failure\n\t * indication.\n\t */\n\tif (!(bus->phy_ignore_ta_mask & 1 << phy_id) && (cmd & MDIO_READ_FAIL))\n\t\treturn -EIO;\n\n\treturn cmd & 0xffff;\n}\n\nstatic int unimac_mdio_write(struct mii_bus *bus, int phy_id,\n\t\t\t     int reg, u16 val)\n{\n\tstruct unimac_mdio_priv *priv = bus->priv;\n\tu32 cmd;\n\n\t/* Prepare the write operation */\n\tcmd = MDIO_WR | (phy_id << MDIO_PMD_SHIFT) |\n\t\t(reg << MDIO_REG_SHIFT) | (0xffff & val);\n\tunimac_mdio_writel(priv, cmd, MDIO_CMD);\n\n\tunimac_mdio_start(priv);\n\n\treturn priv->wait_func(priv->wait_func_data);\n}\n\n/* Workaround for integrated BCM7xxx Gigabit PHYs which have a problem with\n * their internal MDIO management controller making them fail to successfully\n * be read from or written to for the first transaction.  We insert a dummy\n * BMSR read here to make sure that phy_get_device() and get_phy_id() can\n * correctly read the PHY MII_PHYSID1/2 registers and successfully register a\n * PHY device for this peripheral.\n *\n * Once the PHY driver is registered, we can workaround subsequent reads from\n * there (e.g: during system-wide power management).\n *\n * bus->reset is invoked before mdiobus_scan during mdiobus_register and is\n * therefore the right location to stick that workaround. Since we do not want\n * to read from non-existing PHYs, we either use bus->phy_mask or do a manual\n * Device Tree scan to limit the search area.\n */\nstatic int unimac_mdio_reset(struct mii_bus *bus)\n{\n\tstruct device_node *np = bus->dev.of_node;\n\tstruct device_node *child;\n\tu32 read_mask = 0;\n\tint addr;\n\n\tif (!np) {\n\t\tread_mask = ~bus->phy_mask;\n\t} else {\n\t\tfor_each_available_child_of_node(np, child) {\n\t\t\taddr = of_mdio_parse_addr(&bus->dev, child);\n\t\t\tif (addr < 0)\n\t\t\t\tcontinue;\n\n\t\t\tread_mask |= 1 << addr;\n\t\t}\n\t}\n\n\tfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\n\t\tif (read_mask & 1 << addr) {\n\t\t\tdev_dbg(&bus->dev, \"Workaround for PHY @ %d\\n\", addr);\n\t\t\tmdiobus_read(bus, addr, MII_BMSR);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\t/* Just ioremap, as this MDIO block is usually integrated into an\n\t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}\n\nstatic int unimac_mdio_remove(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_priv *priv = platform_get_drvdata(pdev);\n\n\tmdiobus_unregister(priv->mii_bus);\n\tmdiobus_free(priv->mii_bus);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id unimac_mdio_ids[] = {\n\t{ .compatible = \"brcm,genet-mdio-v5\", },\n\t{ .compatible = \"brcm,genet-mdio-v4\", },\n\t{ .compatible = \"brcm,genet-mdio-v3\", },\n\t{ .compatible = \"brcm,genet-mdio-v2\", },\n\t{ .compatible = \"brcm,genet-mdio-v1\", },\n\t{ .compatible = \"brcm,unimac-mdio\", },\n\t{ /* sentinel */ },\n};\nMODULE_DEVICE_TABLE(of, unimac_mdio_ids);\n\nstatic struct platform_driver unimac_mdio_driver = {\n\t.driver = {\n\t\t.name = UNIMAC_MDIO_DRV_NAME,\n\t\t.of_match_table = unimac_mdio_ids,\n\t},\n\t.probe\t= unimac_mdio_probe,\n\t.remove\t= unimac_mdio_remove,\n};\nmodule_platform_driver(unimac_mdio_driver);\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"Broadcom UniMAC MDIO bus controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" UNIMAC_MDIO_DRV_NAME);\n"], "fixing_code": ["/*\n * Broadcom UniMAC MDIO bus controller driver\n *\n * Copyright (C) 2014-2017 Broadcom\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n#include <linux/kernel.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_mdio.h>\n\n#include <linux/platform_data/mdio-bcm-unimac.h>\n\n#define MDIO_CMD\t\t0x00\n#define  MDIO_START_BUSY\t(1 << 29)\n#define  MDIO_READ_FAIL\t\t(1 << 28)\n#define  MDIO_RD\t\t(2 << 26)\n#define  MDIO_WR\t\t(1 << 26)\n#define  MDIO_PMD_SHIFT\t\t21\n#define  MDIO_PMD_MASK\t\t0x1F\n#define  MDIO_REG_SHIFT\t\t16\n#define  MDIO_REG_MASK\t\t0x1F\n\n#define MDIO_CFG\t\t0x04\n#define  MDIO_C22\t\t(1 << 0)\n#define  MDIO_C45\t\t0\n#define  MDIO_CLK_DIV_SHIFT\t4\n#define  MDIO_CLK_DIV_MASK\t0x3F\n#define  MDIO_SUPP_PREAMBLE\t(1 << 12)\n\nstruct unimac_mdio_priv {\n\tstruct mii_bus\t\t*mii_bus;\n\tvoid __iomem\t\t*base;\n\tint (*wait_func)\t(void *wait_func_data);\n\tvoid\t\t\t*wait_func_data;\n};\n\nstatic inline u32 unimac_mdio_readl(struct unimac_mdio_priv *priv, u32 offset)\n{\n\t/* MIPS chips strapped for BE will automagically configure the\n\t * peripheral registers for CPU-native byte order.\n\t */\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\treturn __raw_readl(priv->base + offset);\n\telse\n\t\treturn readl_relaxed(priv->base + offset);\n}\n\nstatic inline void unimac_mdio_writel(struct unimac_mdio_priv *priv, u32 val,\n\t\t\t\t      u32 offset)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\t__raw_writel(val, priv->base + offset);\n\telse\n\t\twritel_relaxed(val, priv->base + offset);\n}\n\nstatic inline void unimac_mdio_start(struct unimac_mdio_priv *priv)\n{\n\tu32 reg;\n\n\treg = unimac_mdio_readl(priv, MDIO_CMD);\n\treg |= MDIO_START_BUSY;\n\tunimac_mdio_writel(priv, reg, MDIO_CMD);\n}\n\nstatic inline unsigned int unimac_mdio_busy(struct unimac_mdio_priv *priv)\n{\n\treturn unimac_mdio_readl(priv, MDIO_CMD) & MDIO_START_BUSY;\n}\n\nstatic int unimac_mdio_poll(void *wait_func_data)\n{\n\tstruct unimac_mdio_priv *priv = wait_func_data;\n\tunsigned int timeout = 1000;\n\n\tdo {\n\t\tif (!unimac_mdio_busy(priv))\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t} while (--timeout);\n\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int unimac_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct unimac_mdio_priv *priv = bus->priv;\n\tint ret;\n\tu32 cmd;\n\n\t/* Prepare the read operation */\n\tcmd = MDIO_RD | (phy_id << MDIO_PMD_SHIFT) | (reg << MDIO_REG_SHIFT);\n\tunimac_mdio_writel(priv, cmd, MDIO_CMD);\n\n\t/* Start MDIO transaction */\n\tunimac_mdio_start(priv);\n\n\tret = priv->wait_func(priv->wait_func_data);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd = unimac_mdio_readl(priv, MDIO_CMD);\n\n\t/* Some broken devices are known not to release the line during\n\t * turn-around, e.g: Broadcom BCM53125 external switches, so check for\n\t * that condition here and ignore the MDIO controller read failure\n\t * indication.\n\t */\n\tif (!(bus->phy_ignore_ta_mask & 1 << phy_id) && (cmd & MDIO_READ_FAIL))\n\t\treturn -EIO;\n\n\treturn cmd & 0xffff;\n}\n\nstatic int unimac_mdio_write(struct mii_bus *bus, int phy_id,\n\t\t\t     int reg, u16 val)\n{\n\tstruct unimac_mdio_priv *priv = bus->priv;\n\tu32 cmd;\n\n\t/* Prepare the write operation */\n\tcmd = MDIO_WR | (phy_id << MDIO_PMD_SHIFT) |\n\t\t(reg << MDIO_REG_SHIFT) | (0xffff & val);\n\tunimac_mdio_writel(priv, cmd, MDIO_CMD);\n\n\tunimac_mdio_start(priv);\n\n\treturn priv->wait_func(priv->wait_func_data);\n}\n\n/* Workaround for integrated BCM7xxx Gigabit PHYs which have a problem with\n * their internal MDIO management controller making them fail to successfully\n * be read from or written to for the first transaction.  We insert a dummy\n * BMSR read here to make sure that phy_get_device() and get_phy_id() can\n * correctly read the PHY MII_PHYSID1/2 registers and successfully register a\n * PHY device for this peripheral.\n *\n * Once the PHY driver is registered, we can workaround subsequent reads from\n * there (e.g: during system-wide power management).\n *\n * bus->reset is invoked before mdiobus_scan during mdiobus_register and is\n * therefore the right location to stick that workaround. Since we do not want\n * to read from non-existing PHYs, we either use bus->phy_mask or do a manual\n * Device Tree scan to limit the search area.\n */\nstatic int unimac_mdio_reset(struct mii_bus *bus)\n{\n\tstruct device_node *np = bus->dev.of_node;\n\tstruct device_node *child;\n\tu32 read_mask = 0;\n\tint addr;\n\n\tif (!np) {\n\t\tread_mask = ~bus->phy_mask;\n\t} else {\n\t\tfor_each_available_child_of_node(np, child) {\n\t\t\taddr = of_mdio_parse_addr(&bus->dev, child);\n\t\t\tif (addr < 0)\n\t\t\t\tcontinue;\n\n\t\t\tread_mask |= 1 << addr;\n\t\t}\n\t}\n\n\tfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\n\t\tif (read_mask & 1 << addr) {\n\t\t\tdev_dbg(&bus->dev, \"Workaround for PHY @ %d\\n\", addr);\n\t\t\tmdiobus_read(bus, addr, MII_BMSR);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\n\t/* Just ioremap, as this MDIO block is usually integrated into an\n\t * Ethernet MAC controller register range\n\t */\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\n\treturn 0;\n\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}\n\nstatic int unimac_mdio_remove(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_priv *priv = platform_get_drvdata(pdev);\n\n\tmdiobus_unregister(priv->mii_bus);\n\tmdiobus_free(priv->mii_bus);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id unimac_mdio_ids[] = {\n\t{ .compatible = \"brcm,genet-mdio-v5\", },\n\t{ .compatible = \"brcm,genet-mdio-v4\", },\n\t{ .compatible = \"brcm,genet-mdio-v3\", },\n\t{ .compatible = \"brcm,genet-mdio-v2\", },\n\t{ .compatible = \"brcm,genet-mdio-v1\", },\n\t{ .compatible = \"brcm,unimac-mdio\", },\n\t{ /* sentinel */ },\n};\nMODULE_DEVICE_TABLE(of, unimac_mdio_ids);\n\nstatic struct platform_driver unimac_mdio_driver = {\n\t.driver = {\n\t\t.name = UNIMAC_MDIO_DRV_NAME,\n\t\t.of_match_table = unimac_mdio_ids,\n\t},\n\t.probe\t= unimac_mdio_probe,\n\t.remove\t= unimac_mdio_remove,\n};\nmodule_platform_driver(unimac_mdio_driver);\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"Broadcom UniMAC MDIO bus controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" UNIMAC_MDIO_DRV_NAME);\n"], "filenames": ["drivers/net/phy/mdio-bcm-unimac.c"], "buggy_code_start_loc": [207], "buggy_code_end_loc": [207], "fixing_code_start_loc": [208], "fixing_code_end_loc": [210], "type": "CWE-476", "message": "The unimac_mdio_probe function in drivers/net/phy/mdio-bcm-unimac.c in the Linux kernel through 4.15.8 does not validate certain resource availability, which allows local users to cause a denial of service (NULL pointer dereference).", "other": {"cve": {"id": "CVE-2018-8043", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-10T22:29:00.397", "lastModified": "2019-03-04T19:11:06.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The unimac_mdio_probe function in drivers/net/phy/mdio-bcm-unimac.c in the Linux kernel through 4.15.8 does not validate certain resource availability, which allows local users to cause a denial of service (NULL pointer dereference)."}, {"lang": "es", "value": "La funci\u00f3n unimac_mdio_probe en drivers/net/phy/mdio-bcm-unimac.c en el kernel de Linux hasta la versi\u00f3n 4.15.8 no valida la disponibilidad de ciertos recursos. Esto permite que usuarios locales provoquen una denegaci\u00f3n de servicio (desreferencia de puntero NULL)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.15.8", "matchCriteriaId": "0278205C-4B96-48BC-B53F-14897F367C40"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securitytracker.com/id/1040749", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3619-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3619-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3630-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3630-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3632-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5"}}