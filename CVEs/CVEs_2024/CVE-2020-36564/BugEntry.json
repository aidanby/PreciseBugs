{"buggy_code": ["package nosurf\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n)\n\nconst (\n\ttokenLength = 32\n)\n\n/*\nThere are two types of tokens.\n\n* The unmasked \"real\" token consists of 32 random bytes.\n  It is stored in a cookie (base64-encoded) and it's the\n  \"reference\" value that sent tokens get compared to.\n\n* The masked \"sent\" token consists of 64 bytes:\n  32 byte key used for one-time pad masking and\n  32 byte \"real\" token masked with the said key.\n  It is used as a value (base64-encoded as well)\n  in forms and/or headers.\n\nUpon processing, both tokens are base64-decoded\nand then treated as 32/64 byte slices.\n*/\n\n// A token is generated by returning tokenLength bytes\n// from crypto/rand\nfunc generateToken() []byte {\n\tbytes := make([]byte, tokenLength)\n\n\tif _, err := io.ReadFull(rand.Reader, bytes); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn bytes\n}\n\nfunc b64encode(data []byte) string {\n\treturn base64.StdEncoding.EncodeToString(data)\n}\n\nfunc b64decode(data string) []byte {\n\tdecoded, err := base64.StdEncoding.DecodeString(data)\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn decoded\n}\n\n// VerifyToken verifies the sent token equals the real one\n// and returns a bool value indicating if tokens are equal.\n// Supports masked tokens. realToken comes from Token(r) and\n// sentToken is token sent unusual way.\nfunc VerifyToken(realToken, sentToken string) bool {\n\tr := b64decode(realToken)\n\tif len(r) == 2*tokenLength {\n\t\tr = unmaskToken(r)\n\t}\n\ts := b64decode(sentToken)\n\tif len(s) == 2*tokenLength {\n\t\ts = unmaskToken(s)\n\t}\n\treturn subtle.ConstantTimeCompare(r, s) == 1\n}\n\nfunc verifyToken(realToken, sentToken []byte) bool {\n\trealN := len(realToken)\n\tsentN := len(sentToken)\n\n\t// sentN == tokenLength means the token is unmasked\n\t// sentN == 2*tokenLength means the token is masked.\n\n\tif realN == tokenLength && sentN == 2*tokenLength {\n\t\treturn verifyMasked(realToken, sentToken)\n\t}\n\treturn false\n}\n\n// Verifies the masked token\nfunc verifyMasked(realToken, sentToken []byte) bool {\n\tsentPlain := unmaskToken(sentToken)\n\treturn subtle.ConstantTimeCompare(realToken, sentPlain) == 1\n}\n\nfunc checkForPRNG() {\n\t// Check that cryptographically secure PRNG is available\n\t// In case it's not, panic.\n\tbuf := make([]byte, 1)\n\t_, err := io.ReadFull(rand.Reader, buf)\n\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"crypto/rand is unavailable: Read() failed with %#v\", err))\n\t}\n}\n\nfunc init() {\n\tcheckForPRNG()\n}\n", "package nosurf\n\nimport (\n\t\"crypto/rand\"\n\t\"testing\"\n)\n\nfunc TestChecksForPRNG(t *testing.T) {\n\t// Monkeypatch crypto/rand with an always-failing reader\n\toldReader := rand.Reader\n\trand.Reader = failReader{}\n\t// Restore it later for other tests\n\tdefer func() {\n\t\trand.Reader = oldReader\n\t}()\n\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"Expected checkForPRNG() to panic\")\n\t\t}\n\t}()\n\n\tcheckForPRNG()\n}\n\nfunc TestGeneratesAValidToken(t *testing.T) {\n\t// We can't test much with any certainity here,\n\t// since we generate tokens randomly\n\t// Basically we check that the length of the\n\t// token is what it should be\n\n\ttoken := generateToken()\n\tl := len(token)\n\n\tif l != tokenLength {\n\t\tt.Errorf(\"Bad decoded token length: expected %d, got %d\", tokenLength, l)\n\t}\n}\n\nfunc TestVerifyTokenChecksLengthCorrectly(t *testing.T) {\n\tfor i := 0; i < 64; i++ {\n\t\tslice := make([]byte, i)\n\t\tresult := verifyToken(slice, slice)\n\t\tif result {\n\t\t\tt.Errorf(\"VerifyToken should've returned false with slices of length %d\", i)\n\t\t}\n\t}\n\n\tslice := make([]byte, 64)\n\tresult := verifyToken(slice[:32], slice)\n\tif !result {\n\t\tt.Errorf(\"VerifyToken should've returned true on a zeroed slice of length 64\")\n\t}\n}\n\nfunc TestVerifiesMaskedTokenCorrectly(t *testing.T) {\n\trealToken := []byte(\"qwertyuiopasdfghjklzxcvbnm123456\")\n\tsentToken := []byte(\"qwertyuiopasdfghjklzxcvbnm123456\" +\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n\n\tif !verifyToken(realToken, sentToken) {\n\t\tt.Errorf(\"VerifyToken returned a false negative\")\n\t}\n\n\trealToken[0] = 'x'\n\n\tif verifyToken(realToken, sentToken) {\n\t\tt.Errorf(\"VerifyToken returned a false positive\")\n\t}\n}\n"], "fixing_code": ["package nosurf\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n)\n\nconst (\n\ttokenLength = 32\n)\n\n/*\nThere are two types of tokens.\n\n* The unmasked \"real\" token consists of 32 random bytes.\n  It is stored in a cookie (base64-encoded) and it's the\n  \"reference\" value that sent tokens get compared to.\n\n* The masked \"sent\" token consists of 64 bytes:\n  32 byte key used for one-time pad masking and\n  32 byte \"real\" token masked with the said key.\n  It is used as a value (base64-encoded as well)\n  in forms and/or headers.\n\nUpon processing, both tokens are base64-decoded\nand then treated as 32/64 byte slices.\n*/\n\n// A token is generated by returning tokenLength bytes\n// from crypto/rand\nfunc generateToken() []byte {\n\tbytes := make([]byte, tokenLength)\n\n\tif _, err := io.ReadFull(rand.Reader, bytes); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn bytes\n}\n\nfunc b64encode(data []byte) string {\n\treturn base64.StdEncoding.EncodeToString(data)\n}\n\nfunc b64decode(data string) []byte {\n\tdecoded, err := base64.StdEncoding.DecodeString(data)\n\tif err != nil {\n\t\treturn nil\n\t}\n\treturn decoded\n}\n\n// VerifyToken verifies the sent token equals the real one\n// and returns a bool value indicating if tokens are equal.\n// Supports masked tokens. realToken comes from Token(r) and\n// sentToken is token sent unusual way.\nfunc VerifyToken(realToken, sentToken string) bool {\n\tr, err := base64.StdEncoding.DecodeString(realToken)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif len(r) == 2*tokenLength {\n\t\tr = unmaskToken(r)\n\t}\n\ts, err := base64.StdEncoding.DecodeString(sentToken)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif len(s) == 2*tokenLength {\n\t\ts = unmaskToken(s)\n\t}\n\treturn tokensEqual(r, s)\n}\n\n// verifyToken expects the realToken to be unmasked and the sentToken to be masked\nfunc verifyToken(realToken, sentToken []byte) bool {\n\trealN := len(realToken)\n\tsentN := len(sentToken)\n\n\t// sentN == tokenLength means the token is unmasked\n\t// sentN == 2*tokenLength means the token is masked.\n\n\tif realN == tokenLength && sentN == 2*tokenLength {\n\t\treturn tokensEqual(realToken, unmaskToken(sentToken))\n\t}\n\treturn false\n}\n\n// tokensEqual expects both tokens to be unmasked\nfunc tokensEqual(realToken, sentToken []byte) bool {\n\treturn len(realToken) == tokenLength &&\n\t\tlen(sentToken) == tokenLength &&\n\t\tsubtle.ConstantTimeCompare(realToken, sentToken) == 1\n}\n\nfunc checkForPRNG() {\n\t// Check that cryptographically secure PRNG is available\n\t// In case it's not, panic.\n\tbuf := make([]byte, 1)\n\t_, err := io.ReadFull(rand.Reader, buf)\n\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"crypto/rand is unavailable: Read() failed with %#v\", err))\n\t}\n}\n\nfunc init() {\n\tcheckForPRNG()\n}\n", "package nosurf\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"testing\"\n)\n\nfunc TestChecksForPRNG(t *testing.T) {\n\t// Monkeypatch crypto/rand with an always-failing reader\n\toldReader := rand.Reader\n\trand.Reader = failReader{}\n\t// Restore it later for other tests\n\tdefer func() {\n\t\trand.Reader = oldReader\n\t}()\n\n\tdefer func() {\n\t\tr := recover()\n\t\tif r == nil {\n\t\t\tt.Errorf(\"Expected checkForPRNG() to panic\")\n\t\t}\n\t}()\n\n\tcheckForPRNG()\n}\n\nfunc TestGeneratesAValidToken(t *testing.T) {\n\t// We can't test much with any certainity here,\n\t// since we generate tokens randomly\n\t// Basically we check that the length of the\n\t// token is what it should be\n\n\ttoken := generateToken()\n\tl := len(token)\n\n\tif l != tokenLength {\n\t\tt.Errorf(\"Bad decoded token length: expected %d, got %d\", tokenLength, l)\n\t}\n}\n\nfunc TestVerifyTokenChecksLengthCorrectly(t *testing.T) {\n\tfor i := 0; i < 64; i++ {\n\t\tslice := make([]byte, i)\n\t\tresult := verifyToken(slice, slice)\n\t\tif result {\n\t\t\tt.Errorf(\"VerifyToken should've returned false with slices of length %d\", i)\n\t\t}\n\t}\n\n\tslice := make([]byte, 64)\n\tresult := verifyToken(slice[:32], slice)\n\tif !result {\n\t\tt.Errorf(\"VerifyToken should've returned true on a zeroed slice of length 64\")\n\t}\n}\n\nfunc TestVerifiesMaskedTokenCorrectly(t *testing.T) {\n\trealToken := []byte(\"qwertyuiopasdfghjklzxcvbnm123456\")\n\tsentToken := []byte(\"qwertyuiopasdfghjklzxcvbnm123456\" +\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\n\n\tif !verifyToken(realToken, sentToken) {\n\t\tt.Errorf(\"VerifyToken returned a false negative\")\n\t}\n\n\trealToken[0] = 'x'\n\n\tif verifyToken(realToken, sentToken) {\n\t\tt.Errorf(\"VerifyToken returned a false positive\")\n\t}\n}\n\nfunc TestVerifyTokenBase64Invalid(t *testing.T) {\n\tfor _, pairs := range [][]string{\n\t\t{\"foo\", \"bar\"},\n\t\t{\"foo\", \"\"},\n\t\t{\"\", \"bar\"},\n\t\t{\"\", \"\"},\n\t} {\n\t\tif VerifyToken(pairs[0], pairs[1]) {\n\t\t\tt.Errorf(\"VerifyToken returned a false positive for: %v\", pairs)\n\t\t}\n\t}\n}\n\nfunc TestVerifyTokenUnMasked(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\treal  string\n\t\tsend  string\n\t\tvalid bool\n\t}{\n\t\t{\n\t\t\treal:  \"qwertyuiopasdfghjklzxcvbnm123456\",\n\t\t\tsend:  \"qwertyuiopasdfghjklzxcvbnm123456\",\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\treal: \"qwertyuiopasdfghjklzxcvbnm123456\",\n\t\t\tsend: \"qwertyuiopasdfghjklzxcvbnm123456\" +\n\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\treal: \"qwertyuiopasdfghjklzxcvbnm123456\" +\n\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\tsend: \"qwertyuiopasdfghjklzxcvbnm123456\" +\n\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\tvalid: true,\n\t\t},\n\t\t{\n\t\t\treal: \"qwertyuiopasdfghjklzxcvbnm123456\" +\n\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n\t\t\tsend:  \"qwertyuiopasdfghjklzxcvbnm123456\",\n\t\t\tvalid: true,\n\t\t},\n\t} {\n\t\tif VerifyToken(\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(tc.real)),\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(tc.send)),\n\t\t) != tc.valid {\n\t\t\tt.Errorf(\"Verify token returned wrong result for case %d: %+v\", i, tc)\n\t\t}\n\t}\n}\n"], "filenames": ["token.go", "token_test.go"], "buggy_code_start_loc": [61, 4], "buggy_code_end_loc": [89, 72], "fixing_code_start_loc": [61, 5], "fixing_code_end_loc": [97, 131], "type": "CWE-20", "message": "Due to improper validation of caller input, validation is silently disabled if the provided expected token is malformed, causing any user supplied token to be considered valid.", "other": {"cve": {"id": "CVE-2020-36564", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.673", "lastModified": "2023-01-06T01:27:25.043", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Due to improper validation of caller input, validation is silently disabled if the provided expected token is malformed, causing any user supplied token to be considered valid."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nosurf_project:nosurf:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "A223A3C0-6811-4238-B5A6-3BE3DFE734C0"}]}]}], "references": [{"url": "https://github.com/justinas/nosurf/commit/4d86df7a4affa1fa50ab39fb09aac56c3ce9c314", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/justinas/nosurf/pull/60", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0049", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/justinas/nosurf/commit/4d86df7a4affa1fa50ab39fb09aac56c3ce9c314"}}