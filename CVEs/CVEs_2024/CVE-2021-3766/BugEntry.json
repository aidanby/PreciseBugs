{"buggy_code": ["'use strict';\n\nconst { clone, cloneDeep } = require('./clone');\nconst SMALL_ARRAY_SIZE = 10;\n\nfunction isEmpty(item) {\n  if (Array.isArray(item) || Buffer.isBuffer(item)) {\n    return item.length === 0;\n  } else if (isObject(item)) {\n    return Object.keys(item).length === 0;\n  } else {\n    return true;\n  }\n}\n\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n// Quick and dirty check if an object is a plain object and not\n// for example an instance of some class.\nfunction isPlainObject(value) {\n  return (\n    isObject(value) &&\n    (!value.constructor || value.constructor === Object) &&\n    (!value.toString || value.toString === Object.prototype.toString)\n  );\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction asSingle(value) {\n  return Array.isArray(value) ? value[0] : value;\n}\n\nfunction uniqBy(items, keyGetter = null) {\n  const map = new Map();\n\n  for (let i = 0, l = items.length; i < l; ++i) {\n    const item = items[i];\n    const key = keyGetter !== null ? keyGetter(item) : item;\n\n    map.set(key, item);\n  }\n\n  return Array.from(map.values());\n}\n\nfunction groupBy(items, keyGetter = null) {\n  const groups = new Map();\n\n  for (const item of items) {\n    const key = keyGetter !== null ? keyGetter(item) : item;\n    let group = groups.get(key);\n\n    if (!group) {\n      group = [];\n      groups.set(key, group);\n    }\n\n    group.push(item);\n  }\n\n  return groups;\n}\n\nfunction omit(obj, keysToOmit) {\n  keysToOmit = asArray(keysToOmit);\n\n  const keys = Object.keys(obj);\n  const out = {};\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n\n    if (!keysToOmit.includes(key)) {\n      out[key] = obj[key];\n    }\n  }\n\n  return out;\n}\n\nfunction difference(arr1, arr2) {\n  const arr2Set = new Set(arr2);\n  const diff = [];\n\n  for (let i = 0; i < arr1.length; ++i) {\n    const value = arr1[i];\n\n    if (!arr2Set.has(value)) {\n      diff.push(value);\n    }\n  }\n\n  return diff;\n}\n\nfunction union(arr1, arr2) {\n  if (arr1.length < SMALL_ARRAY_SIZE && arr2.length < SMALL_ARRAY_SIZE) {\n    return unionSmall(arr1, arr2);\n  } else {\n    return unionGeneric(arr1, arr2);\n  }\n}\n\nfunction unionSmall(arr1, arr2) {\n  const all = arr1.slice();\n\n  for (let i = 0, l = arr2.length; i < l; ++i) {\n    const item = arr2[i];\n\n    if (all.indexOf(item) === -1) {\n      all.push(item);\n    }\n  }\n\n  return all;\n}\n\nfunction unionGeneric(arr1, arr2) {\n  const all = new Set();\n\n  for (let i = 0; i < arr1.length; ++i) {\n    all.add(arr1[i]);\n  }\n\n  for (let i = 0; i < arr2.length; ++i) {\n    all.add(arr2[i]);\n  }\n\n  return Array.from(all);\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction upperFirst(str) {\n  return str[0].toUpperCase() + str.substring(1);\n}\n\nfunction values(obj) {\n  if (isObject(obj)) {\n    const keys = Object.keys(obj);\n    const values = new Array(keys.length);\n\n    for (let i = 0, l = keys.length; i < l; ++i) {\n      values[i] = obj[keys[i]];\n    }\n\n    return values;\n  } else {\n    return [];\n  }\n}\n\nfunction once(func) {\n  let called = false;\n  let value = undefined;\n\n  return function () {\n    if (called === false) {\n      called = true;\n      value = func.apply(this, arguments);\n    }\n\n    return value;\n  };\n}\n\nfunction flatten(arrays) {\n  const out = [];\n  let outIdx = 0;\n\n  for (let i = 0, l = arrays.length; i < l; ++i) {\n    const value = arrays[i];\n\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        out.push(value[j]);\n      }\n    } else {\n      out.push(value);\n    }\n  }\n\n  return out;\n}\n\nfunction get(obj, path) {\n  for (let i = 0, l = path.length; i < l; ++i) {\n    const key = path[i];\n\n    if (!isObject(obj)) {\n      return undefined;\n    }\n\n    obj = obj[key];\n  }\n\n  return obj;\n}\n\nfunction set(obj, path, value) {\n  const inputObj = obj;\n\n  for (let i = 0, l = path.length - 1; i < l; ++i) {\n    const key = path[i];\n    let child = obj[key];\n\n    if (!isObject(child)) {\n      const nextKey = path[i + 1];\n\n      if (isNaN(nextKey)) {\n        child = {};\n      } else {\n        child = [];\n      }\n\n      obj[key] = child;\n    }\n\n    obj = child;\n  }\n\n  if (path.length > 0 && isObject(obj)) {\n    obj[path[path.length - 1]] = value;\n  }\n\n  return inputObj;\n}\n\nfunction zipObject(keys, values) {\n  const out = {};\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    out[keys[i]] = values[i];\n  }\n\n  return out;\n}\n\nfunction chunk(arr, chunkSize) {\n  const out = [];\n\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    const item = arr[i];\n\n    if (out.length === 0 || out[out.length - 1].length === chunkSize) {\n      out.push([]);\n    }\n\n    out[out.length - 1].push(item);\n  }\n\n  return out;\n}\n\nfunction jsonEquals(val1, val2) {\n  return jsonEqualsBase(val1, val2, compareStrict);\n}\n\nfunction jsonEqualsBase(val1, val2, compare) {\n  if (val1 === val2) {\n    return true;\n  }\n\n  return jsonEqualsSlowPath(val1, val2, compare);\n}\n\nfunction jsonEqualsSlowPath(val1, val2, compare) {\n  const type1 = typeof val1;\n  const type2 = typeof val2;\n\n  const isNonNullObject1 = type1 === 'object' && !compare(val1, null);\n  const isNonNullObject2 = type2 === 'object' && !compare(val2, null);\n\n  if (isNonNullObject1 && isNonNullObject2) {\n    const isArray1 = Array.isArray(val1);\n    const isArray2 = Array.isArray(val2);\n\n    if (isArray1 && isArray2) {\n      return jsonEqualsArray(val1, val2, compare);\n    } else if (!isArray1 && !isArray2) {\n      return jsonEqualsObject(val1, val2, compare);\n    } else {\n      return false;\n    }\n  } else if (isNonNullObject1 !== isNonNullObject2) {\n    return false;\n  } else {\n    return compare(val1, val2);\n  }\n}\n\nfunction jsonEqualsArray(arr1, arr2, compare) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0, l = arr1.length; i < l; ++i) {\n    if (!jsonEqualsBase(arr1[i], arr2[i], compare)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction jsonEqualsObject(obj1, obj2, compare) {\n  if (obj1.constructor === Date && obj2.constructor === Date) {\n    return equalsDate(obj1, obj2);\n  }\n\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (let i = 0, l = keys1.length; i < l; ++i) {\n    const key = keys1[i];\n\n    if (!jsonEqualsBase(obj1[key], obj2[key], compare)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction equalsDate(date1, date2) {\n  return date1.getTime() === date2.getTime();\n}\n\nfunction compareStrict(val1, val2) {\n  return val1 === val2;\n}\n\nmodule.exports = {\n  isEmpty,\n  isString,\n  isRegExp,\n  isObject,\n  isNumber,\n  isFunction,\n  jsonEquals,\n  isPlainObject,\n  difference,\n  upperFirst,\n  zipObject,\n  cloneDeep,\n  asSingle,\n  asArray,\n  flatten,\n  groupBy,\n  uniqBy,\n  values,\n  union,\n  chunk,\n  clone,\n  omit,\n  once,\n  last,\n  get,\n  set,\n};\n"], "fixing_code": ["'use strict';\n\nconst { clone, cloneDeep } = require('./clone');\nconst SMALL_ARRAY_SIZE = 10;\n\nfunction isEmpty(item) {\n  if (Array.isArray(item) || Buffer.isBuffer(item)) {\n    return item.length === 0;\n  } else if (isObject(item)) {\n    return Object.keys(item).length === 0;\n  } else {\n    return true;\n  }\n}\n\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n// Quick and dirty check if an object is a plain object and not\n// for example an instance of some class.\nfunction isPlainObject(value) {\n  return (\n    isObject(value) &&\n    (!value.constructor || value.constructor === Object) &&\n    (!value.toString || value.toString === Object.prototype.toString)\n  );\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction asSingle(value) {\n  return Array.isArray(value) ? value[0] : value;\n}\n\nfunction uniqBy(items, keyGetter = null) {\n  const map = new Map();\n\n  for (let i = 0, l = items.length; i < l; ++i) {\n    const item = items[i];\n    const key = keyGetter !== null ? keyGetter(item) : item;\n\n    map.set(key, item);\n  }\n\n  return Array.from(map.values());\n}\n\nfunction groupBy(items, keyGetter = null) {\n  const groups = new Map();\n\n  for (const item of items) {\n    const key = keyGetter !== null ? keyGetter(item) : item;\n    let group = groups.get(key);\n\n    if (!group) {\n      group = [];\n      groups.set(key, group);\n    }\n\n    group.push(item);\n  }\n\n  return groups;\n}\n\nfunction omit(obj, keysToOmit) {\n  keysToOmit = asArray(keysToOmit);\n\n  const keys = Object.keys(obj);\n  const out = {};\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n\n    if (!keysToOmit.includes(key)) {\n      out[key] = obj[key];\n    }\n  }\n\n  return out;\n}\n\nfunction difference(arr1, arr2) {\n  const arr2Set = new Set(arr2);\n  const diff = [];\n\n  for (let i = 0; i < arr1.length; ++i) {\n    const value = arr1[i];\n\n    if (!arr2Set.has(value)) {\n      diff.push(value);\n    }\n  }\n\n  return diff;\n}\n\nfunction union(arr1, arr2) {\n  if (arr1.length < SMALL_ARRAY_SIZE && arr2.length < SMALL_ARRAY_SIZE) {\n    return unionSmall(arr1, arr2);\n  } else {\n    return unionGeneric(arr1, arr2);\n  }\n}\n\nfunction unionSmall(arr1, arr2) {\n  const all = arr1.slice();\n\n  for (let i = 0, l = arr2.length; i < l; ++i) {\n    const item = arr2[i];\n\n    if (all.indexOf(item) === -1) {\n      all.push(item);\n    }\n  }\n\n  return all;\n}\n\nfunction unionGeneric(arr1, arr2) {\n  const all = new Set();\n\n  for (let i = 0; i < arr1.length; ++i) {\n    all.add(arr1[i]);\n  }\n\n  for (let i = 0; i < arr2.length; ++i) {\n    all.add(arr2[i]);\n  }\n\n  return Array.from(all);\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction upperFirst(str) {\n  return str[0].toUpperCase() + str.substring(1);\n}\n\nfunction values(obj) {\n  if (isObject(obj)) {\n    const keys = Object.keys(obj);\n    const values = new Array(keys.length);\n\n    for (let i = 0, l = keys.length; i < l; ++i) {\n      values[i] = obj[keys[i]];\n    }\n\n    return values;\n  } else {\n    return [];\n  }\n}\n\nfunction once(func) {\n  let called = false;\n  let value = undefined;\n\n  return function () {\n    if (called === false) {\n      called = true;\n      value = func.apply(this, arguments);\n    }\n\n    return value;\n  };\n}\n\nfunction flatten(arrays) {\n  const out = [];\n  let outIdx = 0;\n\n  for (let i = 0, l = arrays.length; i < l; ++i) {\n    const value = arrays[i];\n\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        out.push(value[j]);\n      }\n    } else {\n      out.push(value);\n    }\n  }\n\n  return out;\n}\n\nfunction get(obj, path) {\n  for (let i = 0, l = path.length; i < l; ++i) {\n    const key = path[i];\n\n    if (!isObject(obj)) {\n      return undefined;\n    }\n\n    obj = obj[key];\n  }\n\n  return obj;\n}\n\nfunction set(obj, path, value) {\n  const inputObj = obj;\n\n  for (let i = 0, l = path.length - 1; i < l; ++i) {\n    const key = path[i];\n    if (key === '__proto__') {\n      return false;\n    }\n    let child = obj[key];\n\n    if (!isObject(child)) {\n      const nextKey = path[i + 1];\n\n      if (isNaN(nextKey)) {\n        child = {};\n      } else {\n        child = [];\n      }\n\n      obj[key] = child;\n    }\n\n    obj = child;\n  }\n\n  if (path.length > 0 && isObject(obj)) {\n    obj[path[path.length - 1]] = value;\n  }\n\n  return inputObj;\n}\n\nfunction zipObject(keys, values) {\n  const out = {};\n\n  for (let i = 0, l = keys.length; i < l; ++i) {    \n    if (keys[i] === '__proto__') {\n      return false;\n    }\n    out[keys[i]] = values[i];\n  }\n\n  return out;\n}\n\nfunction chunk(arr, chunkSize) {\n  const out = [];\n\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    const item = arr[i];\n\n    if (out.length === 0 || out[out.length - 1].length === chunkSize) {\n      out.push([]);\n    }\n\n    out[out.length - 1].push(item);\n  }\n\n  return out;\n}\n\nfunction jsonEquals(val1, val2) {\n  return jsonEqualsBase(val1, val2, compareStrict);\n}\n\nfunction jsonEqualsBase(val1, val2, compare) {\n  if (val1 === val2) {\n    return true;\n  }\n\n  return jsonEqualsSlowPath(val1, val2, compare);\n}\n\nfunction jsonEqualsSlowPath(val1, val2, compare) {\n  const type1 = typeof val1;\n  const type2 = typeof val2;\n\n  const isNonNullObject1 = type1 === 'object' && !compare(val1, null);\n  const isNonNullObject2 = type2 === 'object' && !compare(val2, null);\n\n  if (isNonNullObject1 && isNonNullObject2) {\n    const isArray1 = Array.isArray(val1);\n    const isArray2 = Array.isArray(val2);\n\n    if (isArray1 && isArray2) {\n      return jsonEqualsArray(val1, val2, compare);\n    } else if (!isArray1 && !isArray2) {\n      return jsonEqualsObject(val1, val2, compare);\n    } else {\n      return false;\n    }\n  } else if (isNonNullObject1 !== isNonNullObject2) {\n    return false;\n  } else {\n    return compare(val1, val2);\n  }\n}\n\nfunction jsonEqualsArray(arr1, arr2, compare) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0, l = arr1.length; i < l; ++i) {\n    if (!jsonEqualsBase(arr1[i], arr2[i], compare)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction jsonEqualsObject(obj1, obj2, compare) {\n  if (obj1.constructor === Date && obj2.constructor === Date) {\n    return equalsDate(obj1, obj2);\n  }\n\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (let i = 0, l = keys1.length; i < l; ++i) {\n    const key = keys1[i];\n\n    if (!jsonEqualsBase(obj1[key], obj2[key], compare)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction equalsDate(date1, date2) {\n  return date1.getTime() === date2.getTime();\n}\n\nfunction compareStrict(val1, val2) {\n  return val1 === val2;\n}\n\nmodule.exports = {\n  isEmpty,\n  isString,\n  isRegExp,\n  isObject,\n  isNumber,\n  isFunction,\n  jsonEquals,\n  isPlainObject,\n  difference,\n  upperFirst,\n  zipObject,\n  cloneDeep,\n  asSingle,\n  asArray,\n  flatten,\n  groupBy,\n  uniqBy,\n  values,\n  union,\n  chunk,\n  clone,\n  omit,\n  once,\n  last,\n  get,\n  set,\n};\n"], "filenames": ["lib/utils/objectUtils.js"], "buggy_code_start_loc": [227], "buggy_code_end_loc": [256], "fixing_code_start_loc": [228], "fixing_code_end_loc": [262], "type": "CWE-1321", "message": "objection.js is vulnerable to Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')", "other": {"cve": {"id": "CVE-2021-3766", "sourceIdentifier": "security@huntr.dev", "published": "2021-09-06T12:15:08.177", "lastModified": "2022-07-29T16:45:44.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "objection.js is vulnerable to Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')"}, {"lang": "es", "value": "objection.js es vulnerable a una Modificaci\u00f3n Inapropiada de los Atributos de los Prototipos de Objetos (\"Contaminaci\u00f3n de Prototipos\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:objection_project:objection:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.2.16", "matchCriteriaId": "D663B715-80DD-4456-9330-B657A937EA9F"}]}]}], "references": [{"url": "https://github.com/Vincit/objection.js/commit/46b842a6bc897198b83f41ac85c92864b991d7e9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c98e0f0e-ebf2-4072-be73-a1848ea031cc", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Vincit/objection.js/commit/46b842a6bc897198b83f41ac85c92864b991d7e9"}}