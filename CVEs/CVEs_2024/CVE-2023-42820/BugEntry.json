{"buggy_code": ["# -*- coding: utf-8 -*-\n#\nimport struct\nimport random\nimport socket\nimport string\n\n\nstring_punctuation = '!#$%&()*+,-.:;<=>?@[]^_~'\n\n\ndef random_datetime(date_start, date_end):\n    random_delta = (date_end - date_start) * random.random()\n    return date_start + random_delta\n\n\ndef random_ip():\n    return socket.inet_ntoa(struct.pack('>I', random.randint(1, 0xffffffff)))\n\n\ndef random_string(length: int, lower=True, upper=True, digit=True, special_char=False):\n    args_names = ['lower', 'upper', 'digit', 'special_char']\n    args_values = [lower, upper, digit, special_char]\n    args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation]\n    args_string_map = dict(zip(args_names, args_string))\n    kwargs = dict(zip(args_names, args_values))\n    kwargs_keys = list(kwargs.keys())\n    kwargs_values = list(kwargs.values())\n    args_true_count = len([i for i in kwargs_values if i])\n    assert any(kwargs_values), f'Parameters {kwargs_keys} must have at least one `True`'\n    assert length >= args_true_count, f'Expected length >= {args_true_count}, bug got {length}'\n\n    can_startswith_special_char = args_true_count == 1 and special_char\n\n    chars = ''.join([args_string_map[k] for k, v in kwargs.items() if v])\n\n    while True:\n        password = list(random.choice(chars) for i in range(length))\n        for k, v in kwargs.items():\n            if v and not (set(password) & set(args_string_map[k])):\n                # \u6ca1\u6709\u5305\u542b\u6307\u5b9a\u7684\u5b57\u7b26, retry\n                break\n        else:\n            if not can_startswith_special_char and password[0] in args_string_map['special_char']:\n                # \u9996\u4f4d\u4e0d\u80fd\u4e3a\u7279\u6b8a\u5b57\u7b26, retry\n                continue\n            else:\n                # \u6ee1\u8db3\u8981\u6c42\u7ec8\u6b62 while \u5faa\u73af\n                break\n\n    password = ''.join(password)\n    return password\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\nimport uuid\nimport base64\nimport string\nimport random\nimport datetime\nfrom typing import Callable\n\nfrom django.db import models\nfrom django.conf import settings\nfrom django.utils import timezone\nfrom django.core.cache import cache\nfrom django.contrib.auth.models import AbstractUser\nfrom django.contrib.auth.hashers import check_password\nfrom django.utils.translation import ugettext_lazy as _\nfrom django.shortcuts import reverse\nfrom django.utils.module_loading import import_string\n\nfrom orgs.utils import current_org\nfrom orgs.models import Organization\nfrom rbac.const import Scope\nfrom common.db import fields, models as jms_models\nfrom common.utils import (\n    date_expired_default, get_logger, lazyproperty, random_string, bulk_create_with_signal\n)\nfrom ..signals import post_user_change_password, post_user_leave_org, pre_user_leave_org\n\n__all__ = ['User', 'UserPasswordHistory']\n\nlogger = get_logger(__file__)\n\n\nclass AuthMixin:\n    date_password_last_updated: datetime.datetime\n    history_passwords: models.Manager\n    need_update_password: bool\n    public_key: str\n    is_local: bool\n    set_password: Callable\n    save: Callable\n    history_passwords: models.Manager\n\n    @property\n    def password_raw(self):\n        raise AttributeError('Password raw is not a readable attribute')\n\n    #: Use this attr to set user object password, example\n    #: user = User(username='example', password_raw='password', ...)\n    #: It's equal:\n    #: user = User(username='example', ...)\n    #: user.set_password('password')\n    @password_raw.setter\n    def password_raw(self, password_raw_):\n        self.set_password(password_raw_)\n\n    def set_password(self, raw_password):\n        if self.can_update_password():\n            self.date_password_last_updated = timezone.now()\n            post_user_change_password.send(self.__class__, user=self)\n            super().set_password(raw_password)\n\n    def set_public_key(self, public_key):\n        if self.can_update_ssh_key():\n            self.public_key = public_key\n            self.save()\n\n    def can_update_password(self):\n        return self.is_local\n\n    def can_update_ssh_key(self):\n        return self.can_use_ssh_key_login()\n\n    @staticmethod\n    def can_use_ssh_key_login():\n        return settings.TERMINAL_PUBLIC_KEY_AUTH\n\n    def is_history_password(self, password):\n        allow_history_password_count = settings.OLD_PASSWORD_HISTORY_LIMIT_COUNT\n        history_passwords = self.history_passwords.all() \\\n                                .order_by('-date_created')[:int(allow_history_password_count)]\n\n        for history_password in history_passwords:\n            if check_password(password, history_password.password):\n                return True\n        else:\n            return False\n\n    def is_public_key_valid(self):\n        \"\"\"\n            Check if the user's ssh public key is valid.\n            This function is used in base.html.\n        \"\"\"\n        if self.public_key:\n            return True\n        return False\n\n    @property\n    def public_key_obj(self):\n        class PubKey(object):\n            def __getattr__(self, item):\n                return ''\n\n        if self.public_key:\n            import sshpubkeys\n            try:\n                return sshpubkeys.SSHKey(self.public_key)\n            except (TabError, TypeError):\n                pass\n        return PubKey()\n\n    def get_public_key_comment(self):\n        return self.public_key_obj.comment\n\n    def get_public_key_hash_md5(self):\n        if not callable(self.public_key_obj.hash_md5):\n            return ''\n        try:\n            return self.public_key_obj.hash_md5()\n        except:\n            return ''\n\n    def reset_password(self, new_password):\n        self.set_password(new_password)\n        self.need_update_password = False\n        self.save()\n\n    @property\n    def date_password_expired(self):\n        interval = settings.SECURITY_PASSWORD_EXPIRATION_TIME\n        date_expired = self.date_password_last_updated + timezone.timedelta(\n            days=int(interval))\n        return date_expired\n\n    @property\n    def password_expired_remain_days(self):\n        date_remain = self.date_password_expired - timezone.now()\n        return date_remain.days\n\n    @property\n    def password_has_expired(self):\n        if self.is_local and self.password_expired_remain_days < 0:\n            return True\n        return False\n\n    @property\n    def password_will_expired(self):\n        if self.is_local and 0 <= self.password_expired_remain_days < 5:\n            return True\n        return False\n\n    @staticmethod\n    def get_public_key_body(key):\n        for i in key.split():\n            if len(i) > 256:\n                return i\n        return key\n\n    def check_public_key(self, key):\n        if not self.public_key:\n            return False\n        key = self.get_public_key_body(key)\n        key_saved = self.get_public_key_body(self.public_key)\n        if key == key_saved:\n            return True\n        else:\n            return False\n\n\nclass RoleManager(models.Manager):\n    scope = None\n    _cache = None\n\n    def __init__(self, user, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.user = user\n\n    @lazyproperty\n    def role_binding_cls(self):\n        from rbac.models import SystemRoleBinding, OrgRoleBinding\n        if self.scope == Scope.org:\n            return OrgRoleBinding\n        else:\n            return SystemRoleBinding\n\n    @lazyproperty\n    def role_cls(self):\n        from rbac.models import SystemRole, OrgRole\n        if self.scope == Scope.org:\n            return OrgRole\n        else:\n            return SystemRole\n\n    @property\n    def display(self):\n        roles = sorted(list(self.all()), key=lambda r: r.scope)\n        roles_display = [role.display_name for role in roles]\n        return ', '.join(roles_display)\n\n    @property\n    def role_bindings(self):\n        queryset = self.role_binding_cls.objects.filter(user=self.user)\n        if self.scope:\n            queryset = queryset.filter(scope=self.scope)\n        return queryset\n\n    def _get_queryset(self):\n        queryset = self.role_binding_cls.get_user_roles(self.user)\n        if self.scope:\n            queryset = queryset.filter(scope=self.scope)\n        return queryset\n\n    def get_queryset(self):\n        if self._cache is not None:\n            return self._cache\n        return self._get_queryset()\n\n    def clear(self):\n        if not self.scope:\n            return\n        return self.role_bindings.delete()\n\n    def _clean_roles(self, roles_or_ids):\n        if not roles_or_ids:\n            return\n        is_model = isinstance(roles_or_ids[0], models.Model)\n        if not is_model:\n            roles = self.role_cls.objects.filter(id__in=roles_or_ids)\n        else:\n            roles = roles_or_ids\n        roles = list([r for r in roles if r.scope == self.scope])\n        return roles\n\n    def add(self, *roles):\n        if not roles:\n            return\n\n        roles = self._clean_roles(roles)\n        old_ids = self.role_bindings.values_list('role', flat=True)\n        need_adds = [r for r in roles if r.id not in old_ids]\n\n        items = []\n        for role in need_adds:\n            kwargs = {'role': role, 'user': self.user, 'scope': self.scope}\n            if self.scope == Scope.org:\n                if current_org.is_root():\n                    continue\n                else:\n                    kwargs['org_id'] = current_org.id\n            items.append(self.role_binding_cls(**kwargs))\n\n        try:\n            result = bulk_create_with_signal(self.role_binding_cls, items, ignore_conflicts=True)\n            self.user.expire_users_rbac_perms_cache()\n            return result\n        except Exception as e:\n            logger.error('Create role binding error: {}'.format(e))\n\n    def set(self, roles, clear=False):\n        if clear:\n            self.clear()\n            self.add(*roles)\n            return\n\n        role_ids = set([r.id for r in roles])\n        old_ids = self.role_bindings.values_list('role', flat=True)\n        old_ids = set(old_ids)\n\n        del_ids = old_ids - role_ids\n        add_ids = role_ids - old_ids\n        self.remove(*del_ids)\n        self.add(*add_ids)\n\n    def remove(self, *roles):\n        if not roles:\n            return\n        roles = self._clean_roles(roles)\n        deleted = self.role_bindings.filter(role__in=roles).delete()\n        self.user.expire_users_rbac_perms_cache()\n        return deleted\n\n    def cache_set(self, roles):\n        query = self._get_queryset()\n        query._result_cache = roles\n        self._cache = query\n\n    @property\n    def builtin_role(self):\n        from rbac.builtin import BuiltinRole\n        return BuiltinRole\n\n\nclass OrgRoleManager(RoleManager):\n    def __init__(self, *args, **kwargs):\n        from rbac.const import Scope\n        self.scope = Scope.org\n        super().__init__(*args, **kwargs)\n\n\nclass SystemRoleManager(RoleManager):\n    def __init__(self, *args, **kwargs):\n        from rbac.const import Scope\n        self.scope = Scope.system\n        super().__init__(*args, **kwargs)\n\n    def remove_role_system_admin(self):\n        role = self.builtin_role.system_admin.get_role()\n        return self.remove(role)\n\n    def add_role_system_admin(self):\n        role = self.builtin_role.system_admin.get_role()\n        return self.add(role)\n\n    def add_role_system_user(self):\n        role = self.builtin_role.system_user.get_role()\n        return self.add(role)\n\n    def add_role_system_component(self):\n        role = self.builtin_role.system_component.get_role()\n        self.add(role)\n\n\nclass RoleMixin:\n    objects: models.Manager\n    is_authenticated: bool\n    is_valid: bool\n    id: str\n    _org_roles = None\n    _system_roles = None\n    PERM_CACHE_KEY = 'USER_PERMS_{}_{}'\n    _is_superuser = None\n    _update_superuser = False\n\n    @lazyproperty\n    def roles(self):\n        return RoleManager(self)\n\n    @lazyproperty\n    def org_roles(self):\n        return OrgRoleManager(self)\n\n    @lazyproperty\n    def system_roles(self):\n        return SystemRoleManager(self)\n\n    @lazyproperty\n    def perms(self):\n        key = self.PERM_CACHE_KEY.format(self.id, current_org.id)\n        perms = cache.get(key)\n        if not perms or settings.DEBUG:\n            perms = self.get_all_permissions()\n            cache.set(key, perms, 3600)\n        return perms\n\n    def expire_rbac_perms_cache(self):\n        key = self.PERM_CACHE_KEY.format(self.id, '*')\n        cache.delete_pattern(key)\n\n    @classmethod\n    def expire_users_rbac_perms_cache(cls):\n        key = cls.PERM_CACHE_KEY.format('*', '*')\n        cache.delete_pattern(key)\n\n    @property\n    def is_superuser(self):\n        \"\"\"\n        \u7531\u4e8e\u8fd9\u91cc\u7528\u4e86 cache \uff0c\u6240\u4ee5\u4e0d\u80fd\u6539\u6210 self.system_roles.filter().exists() \u4f1a\u67e5\u8be2\u7684\n        \"\"\"\n        if self._is_superuser is not None:\n            return self._is_superuser\n\n        from rbac.builtin import BuiltinRole\n        ids = [str(r.id) for r in self.system_roles.all()]\n        yes = BuiltinRole.system_admin.id in ids\n        self._is_superuser = yes\n        return yes\n\n    @is_superuser.setter\n    def is_superuser(self, value):\n        self._is_superuser = value\n        self._update_superuser = True\n        if value:\n            self.system_roles.add_role_system_admin()\n        else:\n            self.system_roles.remove_role_system_admin()\n\n    @lazyproperty\n    def is_org_admin(self):\n        from rbac.builtin import BuiltinRole\n        if self.is_superuser:\n            return True\n        ids = [str(r.id) for r in self.org_roles.all()]\n        yes = BuiltinRole.org_admin.id in ids\n        return yes\n\n    @property\n    def is_staff(self):\n        return self.is_authenticated and self.is_valid\n\n    @is_staff.setter\n    def is_staff(self, value):\n        pass\n\n    service_account_email_suffix = '@local.domain'\n\n    @classmethod\n    def create_service_account(cls, name, email, comment):\n        app = cls.objects.create(\n            username=name, name=name, email=email,\n            comment=comment, is_first_login=False,\n            created_by='System', is_service_account=True,\n        )\n        access_key = app.create_access_key()\n        return app, access_key\n\n    def remove(self):\n        if current_org.is_root():\n            return\n        kwargs = dict(sender=self.__class__, user=self, org=current_org)\n        pre_user_leave_org.send(**kwargs)\n        self.org_roles.clear()\n        post_user_leave_org.send(**kwargs)\n\n    @classmethod\n    def get_super_admins(cls):\n        from rbac.models import Role, RoleBinding\n        system_admin = Role.BuiltinRole.system_admin.get_role()\n        return RoleBinding.get_role_users(system_admin)\n\n    @classmethod\n    def get_org_admins(cls):\n        from rbac.models import Role, RoleBinding\n        org_admin = Role.BuiltinRole.org_admin.get_role()\n        return RoleBinding.get_role_users(org_admin)\n\n    @classmethod\n    def get_super_and_org_admins(cls):\n        super_admins = cls.get_super_admins()\n        org_admins = cls.get_org_admins()\n        admins = org_admins | super_admins\n        return admins.distinct()\n\n    @staticmethod\n    def filter_not_service_account(queryset):\n        return queryset.filter(is_service_account=False)\n\n    @classmethod\n    def get_nature_users(cls):\n        queryset = cls.objects.all()\n        return cls.filter_not_service_account(queryset)\n\n    @classmethod\n    def get_org_users(cls, org=None):\n        queryset = cls.objects.all()\n        if org is None:\n            org = current_org\n        if not org.is_root():\n            queryset = org.get_members()\n        queryset = cls.filter_not_service_account(queryset)\n        return queryset\n\n    def get_all_permissions(self):\n        from rbac.models import RoleBinding\n        perms = RoleBinding.get_user_perms(self)\n        return perms\n\n\nclass TokenMixin:\n    CACHE_KEY_USER_RESET_PASSWORD_PREFIX = \"_KEY_USER_RESET_PASSWORD_{}\"\n    email = ''\n    id = None\n\n    @property\n    def private_token(self):\n        return self.create_private_token()\n\n    def create_private_token(self):\n        from authentication.models import PrivateToken\n        token, created = PrivateToken.objects.get_or_create(user=self)\n        return token\n\n    def delete_private_token(self):\n        from authentication.models import PrivateToken\n        PrivateToken.objects.filter(user=self).delete()\n\n    def refresh_private_token(self):\n        self.delete_private_token()\n        return self.create_private_token()\n\n    def create_bearer_token(self, request=None):\n        expiration = settings.TOKEN_EXPIRATION or 3600\n        if request:\n            remote_addr = request.META.get('REMOTE_ADDR', '')\n        else:\n            remote_addr = '0.0.0.0'\n        if not isinstance(remote_addr, bytes):\n            remote_addr = remote_addr.encode(\"utf-8\")\n        remote_addr = base64.b16encode(remote_addr)  # .replace(b'=', '')\n        cache_key = '%s_%s' % (self.id, remote_addr)\n        token = cache.get(cache_key)\n        if not token:\n            token = random_string(36)\n        cache.set(token, self.id, expiration)\n        cache.set('%s_%s' % (self.id, remote_addr), token, expiration)\n        date_expired = timezone.now() + timezone.timedelta(seconds=expiration)\n        return token, date_expired\n\n    def refresh_bearer_token(self, token):\n        pass\n\n    def create_access_key(self):\n        access_key = self.access_keys.create()\n        return access_key\n\n    @property\n    def access_key(self):\n        return self.access_keys.first()\n\n    def generate_reset_token(self):\n        letter = string.ascii_letters + string.digits\n        token = ''.join([random.choice(letter) for _ in range(50)])\n        self.set_cache(token)\n        return token\n\n    @classmethod\n    def validate_reset_password_token(cls, token):\n        if not token:\n            return None\n        key = cls.CACHE_KEY_USER_RESET_PASSWORD_PREFIX.format(token)\n        value = cache.get(key)\n        if not value:\n            return None\n        try:\n            user_id = value.get('id', '')\n            email = value.get('email', '')\n            user = cls.objects.get(id=user_id, email=email)\n            return user\n        except (AttributeError, cls.DoesNotExist) as e:\n            logger.error(e, exc_info=True)\n            return None\n\n    def set_cache(self, token):\n        key = self.CACHE_KEY_USER_RESET_PASSWORD_PREFIX.format(token)\n        cache.set(key, {'id': self.id, 'email': self.email}, 3600)\n\n    @classmethod\n    def expired_reset_password_token(cls, token):\n        key = cls.CACHE_KEY_USER_RESET_PASSWORD_PREFIX.format(token)\n        cache.delete(key)\n\n\nclass MFAMixin:\n    mfa_level = 0\n    otp_secret_key = ''\n    MFA_LEVEL_CHOICES = (\n        (0, _('Disable')),\n        (1, _('Enable')),\n        (2, _(\"Force enable\")),\n    )\n    is_org_admin: bool\n    username: str\n    phone: str\n\n    @property\n    def mfa_enabled(self):\n        if self.mfa_force_enabled:\n            return True\n        return self.mfa_level > 0\n\n    @property\n    def mfa_force_enabled(self):\n        force_level = settings.SECURITY_MFA_AUTH\n        if force_level in [True, 1]:\n            return True\n        # 2 \u7ba1\u7406\u5458\u5f3a\u5236\u5f00\u542f\n        if force_level == 2 and self.is_org_admin:\n            return True\n        return self.mfa_level == 2\n\n    def enable_mfa(self):\n        if not self.mfa_level == 2:\n            self.mfa_level = 1\n\n    def force_enable_mfa(self):\n        self.mfa_level = 2\n\n    def disable_mfa(self):\n        self.mfa_level = 0\n\n    def no_active_mfa(self):\n        return len(self.active_mfa_backends) == 0\n\n    @lazyproperty\n    def active_mfa_backends(self):\n        backends = self.get_user_mfa_backends(self)\n        active_backends = [b for b in backends if b.is_active()]\n        return active_backends\n\n    @property\n    def active_mfa_backends_mapper(self):\n        return {b.name: b for b in self.active_mfa_backends}\n\n    @staticmethod\n    def get_user_mfa_backends(user):\n        backends = []\n        for cls in settings.MFA_BACKENDS:\n            cls = import_string(cls)\n            if cls.global_enabled():\n                backends.append(cls(user))\n        return backends\n\n    def get_active_mfa_backend_by_type(self, mfa_type):\n        backend = self.get_mfa_backend_by_type(mfa_type)\n        if not backend or not backend.is_active():\n            return None\n        return backend\n\n    def get_mfa_backend_by_type(self, mfa_type):\n        mfa_mapper = {b.name: b for b in self.get_user_mfa_backends(self)}\n        backend = mfa_mapper.get(mfa_type)\n        if not backend:\n            return None\n        return backend\n\n\nclass User(AuthMixin, TokenMixin, RoleMixin, MFAMixin, AbstractUser):\n    class Source(models.TextChoices):\n        local = 'local', _('Local')\n        ldap = 'ldap', 'LDAP/AD'\n        openid = 'openid', 'OpenID'\n        radius = 'radius', 'Radius'\n        cas = 'cas', 'CAS'\n        saml2 = 'saml2', 'SAML2'\n        oauth2 = 'oauth2', 'OAuth2'\n        custom = 'custom', 'Custom'\n\n    SOURCE_BACKEND_MAPPING = {\n        Source.local: [\n            settings.AUTH_BACKEND_MODEL,\n            settings.AUTH_BACKEND_PUBKEY,\n            settings.AUTH_BACKEND_WECOM,\n            settings.AUTH_BACKEND_DINGTALK,\n        ],\n        Source.ldap: [\n            settings.AUTH_BACKEND_LDAP\n        ],\n        Source.openid: [\n            settings.AUTH_BACKEND_OIDC_PASSWORD,\n            settings.AUTH_BACKEND_OIDC_CODE\n        ],\n        Source.radius: [\n            settings.AUTH_BACKEND_RADIUS\n        ],\n        Source.cas: [\n            settings.AUTH_BACKEND_CAS\n        ],\n        Source.saml2: [\n            settings.AUTH_BACKEND_SAML2\n        ],\n        Source.oauth2: [\n            settings.AUTH_BACKEND_OAUTH2\n        ],\n        Source.custom: [\n            settings.AUTH_BACKEND_CUSTOM\n        ]\n    }\n\n    id = models.UUIDField(default=uuid.uuid4, primary_key=True)\n    username = models.CharField(\n        max_length=128, unique=True, verbose_name=_('Username')\n    )\n    name = models.CharField(max_length=128, verbose_name=_('Name'))\n    email = models.EmailField(\n        max_length=128, unique=True, verbose_name=_('Email')\n    )\n    groups = models.ManyToManyField(\n        'users.UserGroup', related_name='users',\n        blank=True, verbose_name=_('User group')\n    )\n    role = models.CharField(\n        default='User', max_length=10,\n        blank=True, verbose_name=_('Role')\n    )\n    is_service_account = models.BooleanField(default=False, verbose_name=_(\"Is service account\"))\n    avatar = models.ImageField(\n        upload_to=\"avatar\", null=True, verbose_name=_('Avatar')\n    )\n    wechat = models.CharField(\n        max_length=128, blank=True, verbose_name=_('Wechat')\n    )\n    phone = models.CharField(\n        max_length=20, blank=True, null=True, verbose_name=_('Phone')\n    )\n    mfa_level = models.SmallIntegerField(\n        default=0, choices=MFAMixin.MFA_LEVEL_CHOICES, verbose_name=_('MFA')\n    )\n    otp_secret_key = fields.EncryptCharField(\n        max_length=128, blank=True, null=True, verbose_name=_('OTP secret key')\n    )\n    # Todo: Auto generate key, let user download\n    private_key = fields.EncryptTextField(\n        blank=True, null=True, verbose_name=_('Private key')\n    )\n    public_key = fields.EncryptTextField(\n        blank=True, null=True, verbose_name=_('Public key')\n    )\n    secret_key = fields.EncryptCharField(\n        max_length=256, blank=True, null=True, verbose_name=_('Secret key')\n    )\n    comment = models.TextField(\n        blank=True, null=True, verbose_name=_('Comment')\n    )\n    is_first_login = models.BooleanField(default=True, verbose_name=_('Is first login'))\n    date_expired = models.DateTimeField(\n        default=date_expired_default, blank=True, null=True,\n        db_index=True, verbose_name=_('Date expired')\n    )\n    created_by = models.CharField(\n        max_length=30, default='', blank=True, verbose_name=_('Created by')\n    )\n    source = models.CharField(\n        max_length=30, default=Source.local,\n        choices=Source.choices,\n        verbose_name=_('Source')\n    )\n    date_password_last_updated = models.DateTimeField(\n        auto_now_add=True, blank=True, null=True,\n        verbose_name=_('Date password last updated')\n    )\n    need_update_password = models.BooleanField(\n        default=False, verbose_name=_('Need update password')\n    )\n    wecom_id = models.CharField(null=True, default=None, unique=True, max_length=128, verbose_name=_('WeCom'))\n    dingtalk_id = models.CharField(null=True, default=None, unique=True, max_length=128, verbose_name=_('DingTalk'))\n    feishu_id = models.CharField(null=True, default=None, unique=True, max_length=128, verbose_name=_('FeiShu'))\n\n    DATE_EXPIRED_WARNING_DAYS = 5\n\n    def __str__(self):\n        return '{0.name}({0.username})'.format(self)\n\n    @classmethod\n    def get_group_ids_by_user_id(cls, user_id):\n        group_ids = cls.groups.through.objects.filter(user_id=user_id) \\\n            .distinct().values_list('usergroup_id', flat=True)\n        group_ids = list(group_ids)\n        return group_ids\n\n    @property\n    def receive_backends(self):\n        return self.user_msg_subscription.receive_backends\n\n    @property\n    def is_wecom_bound(self):\n        return bool(self.wecom_id)\n\n    @property\n    def is_dingtalk_bound(self):\n        return bool(self.dingtalk_id)\n\n    @property\n    def is_feishu_bound(self):\n        return bool(self.feishu_id)\n\n    @property\n    def is_otp_secret_key_bound(self):\n        return bool(self.otp_secret_key)\n\n    def get_absolute_url(self):\n        return reverse('users:user-detail', args=(self.id,))\n\n    @property\n    def groups_display(self):\n        return ' '.join([group.name for group in self.groups.all()])\n\n    @property\n    def source_display(self):\n        return self.get_source_display()\n\n    @property\n    def is_expired(self):\n        if self.date_expired and self.date_expired < timezone.now():\n            return True\n        else:\n            return False\n\n    @property\n    def expired_remain_days(self):\n        date_remain = self.date_expired - timezone.now()\n        return date_remain.days\n\n    @property\n    def will_expired(self):\n        if 0 <= self.expired_remain_days <= self.DATE_EXPIRED_WARNING_DAYS:\n            return True\n        else:\n            return False\n\n    @property\n    def is_valid(self):\n        if self.is_active and not self.is_expired:\n            return True\n        return False\n\n    @property\n    def is_local(self):\n        return self.source == self.Source.local.value\n\n    def is_password_authenticate(self):\n        cas = self.Source.cas\n        saml2 = self.Source.saml2\n        oauth2 = self.Source.oauth2\n        return self.source not in [cas, saml2, oauth2]\n\n    def set_unprovide_attr_if_need(self):\n        if not self.name:\n            self.name = self.username\n        if not self.email or '@' not in self.email:\n            email = '{}@{}'.format(self.username, settings.EMAIL_SUFFIX)\n            if '@' in self.username:\n                email = self.username\n            self.email = email\n\n    def save(self, *args, **kwargs):\n        self.set_unprovide_attr_if_need()\n        if self.username == 'admin':\n            self.role = 'Admin'\n            self.is_active = True\n        return super().save(*args, **kwargs)\n\n    def is_member_of(self, user_group):\n        if user_group in self.groups.all():\n            return True\n        return False\n\n    def set_avatar(self, f):\n        self.avatar.save(self.username, f)\n\n    @classmethod\n    def get_avatar_url(cls, username):\n        user_default = settings.STATIC_URL + \"img/avatar/user.png\"\n        return user_default\n\n    def avatar_url(self):\n        admin_default = settings.STATIC_URL + \"img/avatar/admin.png\"\n        user_default = settings.STATIC_URL + \"img/avatar/user.png\"\n        if self.avatar:\n            return self.avatar.url\n        if self.is_superuser:\n            return admin_default\n        else:\n            return user_default\n\n    def unblock_login(self):\n        from users.utils import LoginBlockUtil, MFABlockUtils\n        LoginBlockUtil.unblock_user(self.username)\n        MFABlockUtils.unblock_user(self.username)\n\n    @property\n    def login_blocked(self):\n        from users.utils import LoginBlockUtil, MFABlockUtils\n        if LoginBlockUtil.is_user_block(self.username):\n            return True\n        if MFABlockUtils.is_user_block(self.username):\n            return True\n        return False\n\n    def delete(self, using=None, keep_parents=False):\n        if self.pk == 1 or self.username == 'admin':\n            return\n        return super(User, self).delete()\n\n    @classmethod\n    def get_user_allowed_auth_backend_paths(cls, username):\n        if not settings.ONLY_ALLOW_AUTH_FROM_SOURCE or not username:\n            return None\n        user = cls.objects.filter(username=username).first()\n        if not user:\n            return None\n        return user.get_allowed_auth_backend_paths()\n\n    def get_allowed_auth_backend_paths(self):\n        if not settings.ONLY_ALLOW_AUTH_FROM_SOURCE:\n            return None\n        return self.SOURCE_BACKEND_MAPPING.get(self.source, [])\n\n    @lazyproperty\n    def console_orgs(self):\n        from rbac.models import RoleBinding\n        return RoleBinding.get_user_has_the_perm_orgs('rbac.view_console', self)\n\n    @lazyproperty\n    def audit_orgs(self):\n        from rbac.models import RoleBinding\n        return RoleBinding.get_user_has_the_perm_orgs('rbac.view_audit', self)\n\n    @lazyproperty\n    def workbench_orgs(self):\n        from rbac.models import RoleBinding\n        return RoleBinding.get_user_has_the_perm_orgs('rbac.view_workbench', self)\n\n    class Meta:\n        ordering = ['username']\n        verbose_name = _(\"User\")\n        permissions = [\n            ('invite_user', _('Can invite user')),\n            ('remove_user', _('Can remove user')),\n            ('match_user', _('Can match user')),\n        ]\n\n    #: Use this method initial user\n    @classmethod\n    def initial(cls):\n        from .group import UserGroup\n        user = cls(username='admin',\n                   email='admin@jumpserver.org',\n                   name=_('Administrator'),\n                   password_raw='admin',\n                   role='Admin',\n                   comment=_('Administrator is the super user of system'),\n                   created_by=_('System'))\n        user.save()\n        user.groups.add(UserGroup.initial())\n\n    def can_send_created_mail(self):\n        if self.email and self.source == self.Source.local.value:\n            return True\n        return False\n\n\nclass UserPasswordHistory(models.Model):\n    id = models.UUIDField(default=uuid.uuid4, primary_key=True)\n    password = models.CharField(max_length=128)\n    user = models.ForeignKey(\"users.User\", related_name='history_passwords',\n                             on_delete=jms_models.CASCADE_SIGNAL_SKIP, verbose_name=_('User'))\n    date_created = models.DateTimeField(auto_now_add=True, verbose_name=_(\"Date created\"))\n\n    def __str__(self):\n        return f'{self.user} set at {self.date_created}'\n\n    def __repr__(self):\n        return self.__str__()\n\n    class Meta:\n        verbose_name = _(\"User password history\")\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#\nimport random\nimport socket\nimport string\nimport struct\n\nstring_punctuation = '!#$%&()*+,-.:;<=>?@[]^_~'\n\n\ndef random_datetime(date_start, date_end):\n    random_delta = (date_end - date_start) * random.random()\n    return date_start + random_delta\n\n\ndef random_ip():\n    return socket.inet_ntoa(struct.pack('>I', random.randint(1, 0xffffffff)))\n\n\ndef random_string(length: int, lower=True, upper=True, digit=True, special_char=False):\n    random.seed()\n    args_names = ['lower', 'upper', 'digit', 'special_char']\n    args_values = [lower, upper, digit, special_char]\n    args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation]\n    args_string_map = dict(zip(args_names, args_string))\n    kwargs = dict(zip(args_names, args_values))\n    kwargs_keys = list(kwargs.keys())\n    kwargs_values = list(kwargs.values())\n    args_true_count = len([i for i in kwargs_values if i])\n    assert any(kwargs_values), f'Parameters {kwargs_keys} must have at least one `True`'\n    assert length >= args_true_count, f'Expected length >= {args_true_count}, bug got {length}'\n\n    can_startswith_special_char = args_true_count == 1 and special_char\n\n    chars = ''.join([args_string_map[k] for k, v in kwargs.items() if v])\n\n    while True:\n        password = list(random.choice(chars) for i in range(length))\n        for k, v in kwargs.items():\n            if v and not (set(password) & set(args_string_map[k])):\n                # \u6ca1\u6709\u5305\u542b\u6307\u5b9a\u7684\u5b57\u7b26, retry\n                break\n        else:\n            if not can_startswith_special_char and password[0] in args_string_map['special_char']:\n                # \u9996\u4f4d\u4e0d\u80fd\u4e3a\u7279\u6b8a\u5b57\u7b26, retry\n                continue\n            else:\n                # \u6ee1\u8db3\u8981\u6c42\u7ec8\u6b62 while \u5faa\u73af\n                break\n\n    password = ''.join(password)\n    return password\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\nimport base64\nimport datetime\nimport uuid\nfrom typing import Callable\n\nfrom django.conf import settings\nfrom django.contrib.auth.hashers import check_password\nfrom django.contrib.auth.models import AbstractUser\nfrom django.core.cache import cache\nfrom django.db import models\nfrom django.shortcuts import reverse\nfrom django.utils import timezone\nfrom django.utils.module_loading import import_string\nfrom django.utils.translation import ugettext_lazy as _\n\nfrom common.db import fields, models as jms_models\nfrom common.utils import (\n    date_expired_default, get_logger, lazyproperty, random_string, bulk_create_with_signal\n)\nfrom orgs.utils import current_org\nfrom rbac.const import Scope\nfrom ..signals import post_user_change_password, post_user_leave_org, pre_user_leave_org\n\n__all__ = ['User', 'UserPasswordHistory']\n\nlogger = get_logger(__file__)\n\n\nclass AuthMixin:\n    date_password_last_updated: datetime.datetime\n    history_passwords: models.Manager\n    need_update_password: bool\n    public_key: str\n    is_local: bool\n    set_password: Callable\n    save: Callable\n    history_passwords: models.Manager\n\n    @property\n    def password_raw(self):\n        raise AttributeError('Password raw is not a readable attribute')\n\n    #: Use this attr to set user object password, example\n    #: user = User(username='example', password_raw='password', ...)\n    #: It's equal:\n    #: user = User(username='example', ...)\n    #: user.set_password('password')\n    @password_raw.setter\n    def password_raw(self, password_raw_):\n        self.set_password(password_raw_)\n\n    def set_password(self, raw_password):\n        if self.can_update_password():\n            self.date_password_last_updated = timezone.now()\n            post_user_change_password.send(self.__class__, user=self)\n            super().set_password(raw_password)\n\n    def set_public_key(self, public_key):\n        if self.can_update_ssh_key():\n            self.public_key = public_key\n            self.save()\n\n    def can_update_password(self):\n        return self.is_local\n\n    def can_update_ssh_key(self):\n        return self.can_use_ssh_key_login()\n\n    @staticmethod\n    def can_use_ssh_key_login():\n        return settings.TERMINAL_PUBLIC_KEY_AUTH\n\n    def is_history_password(self, password):\n        allow_history_password_count = settings.OLD_PASSWORD_HISTORY_LIMIT_COUNT\n        history_passwords = self.history_passwords.all() \\\n                                .order_by('-date_created')[:int(allow_history_password_count)]\n\n        for history_password in history_passwords:\n            if check_password(password, history_password.password):\n                return True\n        else:\n            return False\n\n    def is_public_key_valid(self):\n        \"\"\"\n            Check if the user's ssh public key is valid.\n            This function is used in base.html.\n        \"\"\"\n        if self.public_key:\n            return True\n        return False\n\n    @property\n    def public_key_obj(self):\n        class PubKey(object):\n            def __getattr__(self, item):\n                return ''\n\n        if self.public_key:\n            import sshpubkeys\n            try:\n                return sshpubkeys.SSHKey(self.public_key)\n            except (TabError, TypeError):\n                pass\n        return PubKey()\n\n    def get_public_key_comment(self):\n        return self.public_key_obj.comment\n\n    def get_public_key_hash_md5(self):\n        if not callable(self.public_key_obj.hash_md5):\n            return ''\n        try:\n            return self.public_key_obj.hash_md5()\n        except:\n            return ''\n\n    def reset_password(self, new_password):\n        self.set_password(new_password)\n        self.need_update_password = False\n        self.save()\n\n    @property\n    def date_password_expired(self):\n        interval = settings.SECURITY_PASSWORD_EXPIRATION_TIME\n        date_expired = self.date_password_last_updated + timezone.timedelta(\n            days=int(interval))\n        return date_expired\n\n    @property\n    def password_expired_remain_days(self):\n        date_remain = self.date_password_expired - timezone.now()\n        return date_remain.days\n\n    @property\n    def password_has_expired(self):\n        if self.is_local and self.password_expired_remain_days < 0:\n            return True\n        return False\n\n    @property\n    def password_will_expired(self):\n        if self.is_local and 0 <= self.password_expired_remain_days < 5:\n            return True\n        return False\n\n    @staticmethod\n    def get_public_key_body(key):\n        for i in key.split():\n            if len(i) > 256:\n                return i\n        return key\n\n    def check_public_key(self, key):\n        if not self.public_key:\n            return False\n        key = self.get_public_key_body(key)\n        key_saved = self.get_public_key_body(self.public_key)\n        if key == key_saved:\n            return True\n        else:\n            return False\n\n\nclass RoleManager(models.Manager):\n    scope = None\n    _cache = None\n\n    def __init__(self, user, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.user = user\n\n    @lazyproperty\n    def role_binding_cls(self):\n        from rbac.models import SystemRoleBinding, OrgRoleBinding\n        if self.scope == Scope.org:\n            return OrgRoleBinding\n        else:\n            return SystemRoleBinding\n\n    @lazyproperty\n    def role_cls(self):\n        from rbac.models import SystemRole, OrgRole\n        if self.scope == Scope.org:\n            return OrgRole\n        else:\n            return SystemRole\n\n    @property\n    def display(self):\n        roles = sorted(list(self.all()), key=lambda r: r.scope)\n        roles_display = [role.display_name for role in roles]\n        return ', '.join(roles_display)\n\n    @property\n    def role_bindings(self):\n        queryset = self.role_binding_cls.objects.filter(user=self.user)\n        if self.scope:\n            queryset = queryset.filter(scope=self.scope)\n        return queryset\n\n    def _get_queryset(self):\n        queryset = self.role_binding_cls.get_user_roles(self.user)\n        if self.scope:\n            queryset = queryset.filter(scope=self.scope)\n        return queryset\n\n    def get_queryset(self):\n        if self._cache is not None:\n            return self._cache\n        return self._get_queryset()\n\n    def clear(self):\n        if not self.scope:\n            return\n        return self.role_bindings.delete()\n\n    def _clean_roles(self, roles_or_ids):\n        if not roles_or_ids:\n            return\n        is_model = isinstance(roles_or_ids[0], models.Model)\n        if not is_model:\n            roles = self.role_cls.objects.filter(id__in=roles_or_ids)\n        else:\n            roles = roles_or_ids\n        roles = list([r for r in roles if r.scope == self.scope])\n        return roles\n\n    def add(self, *roles):\n        if not roles:\n            return\n\n        roles = self._clean_roles(roles)\n        old_ids = self.role_bindings.values_list('role', flat=True)\n        need_adds = [r for r in roles if r.id not in old_ids]\n\n        items = []\n        for role in need_adds:\n            kwargs = {'role': role, 'user': self.user, 'scope': self.scope}\n            if self.scope == Scope.org:\n                if current_org.is_root():\n                    continue\n                else:\n                    kwargs['org_id'] = current_org.id\n            items.append(self.role_binding_cls(**kwargs))\n\n        try:\n            result = bulk_create_with_signal(self.role_binding_cls, items, ignore_conflicts=True)\n            self.user.expire_users_rbac_perms_cache()\n            return result\n        except Exception as e:\n            logger.error('Create role binding error: {}'.format(e))\n\n    def set(self, roles, clear=False):\n        if clear:\n            self.clear()\n            self.add(*roles)\n            return\n\n        role_ids = set([r.id for r in roles])\n        old_ids = self.role_bindings.values_list('role', flat=True)\n        old_ids = set(old_ids)\n\n        del_ids = old_ids - role_ids\n        add_ids = role_ids - old_ids\n        self.remove(*del_ids)\n        self.add(*add_ids)\n\n    def remove(self, *roles):\n        if not roles:\n            return\n        roles = self._clean_roles(roles)\n        deleted = self.role_bindings.filter(role__in=roles).delete()\n        self.user.expire_users_rbac_perms_cache()\n        return deleted\n\n    def cache_set(self, roles):\n        query = self._get_queryset()\n        query._result_cache = roles\n        self._cache = query\n\n    @property\n    def builtin_role(self):\n        from rbac.builtin import BuiltinRole\n        return BuiltinRole\n\n\nclass OrgRoleManager(RoleManager):\n    def __init__(self, *args, **kwargs):\n        from rbac.const import Scope\n        self.scope = Scope.org\n        super().__init__(*args, **kwargs)\n\n\nclass SystemRoleManager(RoleManager):\n    def __init__(self, *args, **kwargs):\n        from rbac.const import Scope\n        self.scope = Scope.system\n        super().__init__(*args, **kwargs)\n\n    def remove_role_system_admin(self):\n        role = self.builtin_role.system_admin.get_role()\n        return self.remove(role)\n\n    def add_role_system_admin(self):\n        role = self.builtin_role.system_admin.get_role()\n        return self.add(role)\n\n    def add_role_system_user(self):\n        role = self.builtin_role.system_user.get_role()\n        return self.add(role)\n\n    def add_role_system_component(self):\n        role = self.builtin_role.system_component.get_role()\n        self.add(role)\n\n\nclass RoleMixin:\n    objects: models.Manager\n    is_authenticated: bool\n    is_valid: bool\n    id: str\n    _org_roles = None\n    _system_roles = None\n    PERM_CACHE_KEY = 'USER_PERMS_{}_{}'\n    _is_superuser = None\n    _update_superuser = False\n\n    @lazyproperty\n    def roles(self):\n        return RoleManager(self)\n\n    @lazyproperty\n    def org_roles(self):\n        return OrgRoleManager(self)\n\n    @lazyproperty\n    def system_roles(self):\n        return SystemRoleManager(self)\n\n    @lazyproperty\n    def perms(self):\n        key = self.PERM_CACHE_KEY.format(self.id, current_org.id)\n        perms = cache.get(key)\n        if not perms or settings.DEBUG:\n            perms = self.get_all_permissions()\n            cache.set(key, perms, 3600)\n        return perms\n\n    def expire_rbac_perms_cache(self):\n        key = self.PERM_CACHE_KEY.format(self.id, '*')\n        cache.delete_pattern(key)\n\n    @classmethod\n    def expire_users_rbac_perms_cache(cls):\n        key = cls.PERM_CACHE_KEY.format('*', '*')\n        cache.delete_pattern(key)\n\n    @property\n    def is_superuser(self):\n        \"\"\"\n        \u7531\u4e8e\u8fd9\u91cc\u7528\u4e86 cache \uff0c\u6240\u4ee5\u4e0d\u80fd\u6539\u6210 self.system_roles.filter().exists() \u4f1a\u67e5\u8be2\u7684\n        \"\"\"\n        if self._is_superuser is not None:\n            return self._is_superuser\n\n        from rbac.builtin import BuiltinRole\n        ids = [str(r.id) for r in self.system_roles.all()]\n        yes = BuiltinRole.system_admin.id in ids\n        self._is_superuser = yes\n        return yes\n\n    @is_superuser.setter\n    def is_superuser(self, value):\n        self._is_superuser = value\n        self._update_superuser = True\n        if value:\n            self.system_roles.add_role_system_admin()\n        else:\n            self.system_roles.remove_role_system_admin()\n\n    @lazyproperty\n    def is_org_admin(self):\n        from rbac.builtin import BuiltinRole\n        if self.is_superuser:\n            return True\n        ids = [str(r.id) for r in self.org_roles.all()]\n        yes = BuiltinRole.org_admin.id in ids\n        return yes\n\n    @property\n    def is_staff(self):\n        return self.is_authenticated and self.is_valid\n\n    @is_staff.setter\n    def is_staff(self, value):\n        pass\n\n    service_account_email_suffix = '@local.domain'\n\n    @classmethod\n    def create_service_account(cls, name, email, comment):\n        app = cls.objects.create(\n            username=name, name=name, email=email,\n            comment=comment, is_first_login=False,\n            created_by='System', is_service_account=True,\n        )\n        access_key = app.create_access_key()\n        return app, access_key\n\n    def remove(self):\n        if current_org.is_root():\n            return\n        kwargs = dict(sender=self.__class__, user=self, org=current_org)\n        pre_user_leave_org.send(**kwargs)\n        self.org_roles.clear()\n        post_user_leave_org.send(**kwargs)\n\n    @classmethod\n    def get_super_admins(cls):\n        from rbac.models import Role, RoleBinding\n        system_admin = Role.BuiltinRole.system_admin.get_role()\n        return RoleBinding.get_role_users(system_admin)\n\n    @classmethod\n    def get_org_admins(cls):\n        from rbac.models import Role, RoleBinding\n        org_admin = Role.BuiltinRole.org_admin.get_role()\n        return RoleBinding.get_role_users(org_admin)\n\n    @classmethod\n    def get_super_and_org_admins(cls):\n        super_admins = cls.get_super_admins()\n        org_admins = cls.get_org_admins()\n        admins = org_admins | super_admins\n        return admins.distinct()\n\n    @staticmethod\n    def filter_not_service_account(queryset):\n        return queryset.filter(is_service_account=False)\n\n    @classmethod\n    def get_nature_users(cls):\n        queryset = cls.objects.all()\n        return cls.filter_not_service_account(queryset)\n\n    @classmethod\n    def get_org_users(cls, org=None):\n        queryset = cls.objects.all()\n        if org is None:\n            org = current_org\n        if not org.is_root():\n            queryset = org.get_members()\n        queryset = cls.filter_not_service_account(queryset)\n        return queryset\n\n    def get_all_permissions(self):\n        from rbac.models import RoleBinding\n        perms = RoleBinding.get_user_perms(self)\n        return perms\n\n\nclass TokenMixin:\n    CACHE_KEY_USER_RESET_PASSWORD_PREFIX = \"_KEY_USER_RESET_PASSWORD_{}\"\n    email = ''\n    id = None\n\n    @property\n    def private_token(self):\n        return self.create_private_token()\n\n    def create_private_token(self):\n        from authentication.models import PrivateToken\n        token, created = PrivateToken.objects.get_or_create(user=self)\n        return token\n\n    def delete_private_token(self):\n        from authentication.models import PrivateToken\n        PrivateToken.objects.filter(user=self).delete()\n\n    def refresh_private_token(self):\n        self.delete_private_token()\n        return self.create_private_token()\n\n    def create_bearer_token(self, request=None):\n        expiration = settings.TOKEN_EXPIRATION or 3600\n        if request:\n            remote_addr = request.META.get('REMOTE_ADDR', '')\n        else:\n            remote_addr = '0.0.0.0'\n        if not isinstance(remote_addr, bytes):\n            remote_addr = remote_addr.encode(\"utf-8\")\n        remote_addr = base64.b16encode(remote_addr)  # .replace(b'=', '')\n        cache_key = '%s_%s' % (self.id, remote_addr)\n        token = cache.get(cache_key)\n        if not token:\n            token = random_string(36)\n        cache.set(token, self.id, expiration)\n        cache.set('%s_%s' % (self.id, remote_addr), token, expiration)\n        date_expired = timezone.now() + timezone.timedelta(seconds=expiration)\n        return token, date_expired\n\n    def refresh_bearer_token(self, token):\n        pass\n\n    def create_access_key(self):\n        access_key = self.access_keys.create()\n        return access_key\n\n    @property\n    def access_key(self):\n        return self.access_keys.first()\n\n    def generate_reset_token(self):\n        token = random_string(50)\n        self.set_cache(token)\n        return token\n\n    @classmethod\n    def validate_reset_password_token(cls, token):\n        if not token:\n            return None\n        key = cls.CACHE_KEY_USER_RESET_PASSWORD_PREFIX.format(token)\n        value = cache.get(key)\n        if not value:\n            return None\n        try:\n            user_id = value.get('id', '')\n            email = value.get('email', '')\n            user = cls.objects.get(id=user_id, email=email)\n            return user\n        except (AttributeError, cls.DoesNotExist) as e:\n            logger.error(e, exc_info=True)\n            return None\n\n    def set_cache(self, token):\n        key = self.CACHE_KEY_USER_RESET_PASSWORD_PREFIX.format(token)\n        cache.set(key, {'id': self.id, 'email': self.email}, 3600)\n\n    @classmethod\n    def expired_reset_password_token(cls, token):\n        key = cls.CACHE_KEY_USER_RESET_PASSWORD_PREFIX.format(token)\n        cache.delete(key)\n\n\nclass MFAMixin:\n    mfa_level = 0\n    otp_secret_key = ''\n    MFA_LEVEL_CHOICES = (\n        (0, _('Disable')),\n        (1, _('Enable')),\n        (2, _(\"Force enable\")),\n    )\n    is_org_admin: bool\n    username: str\n    phone: str\n\n    @property\n    def mfa_enabled(self):\n        if self.mfa_force_enabled:\n            return True\n        return self.mfa_level > 0\n\n    @property\n    def mfa_force_enabled(self):\n        force_level = settings.SECURITY_MFA_AUTH\n        if force_level in [True, 1]:\n            return True\n        # 2 \u7ba1\u7406\u5458\u5f3a\u5236\u5f00\u542f\n        if force_level == 2 and self.is_org_admin:\n            return True\n        return self.mfa_level == 2\n\n    def enable_mfa(self):\n        if not self.mfa_level == 2:\n            self.mfa_level = 1\n\n    def force_enable_mfa(self):\n        self.mfa_level = 2\n\n    def disable_mfa(self):\n        self.mfa_level = 0\n\n    def no_active_mfa(self):\n        return len(self.active_mfa_backends) == 0\n\n    @lazyproperty\n    def active_mfa_backends(self):\n        backends = self.get_user_mfa_backends(self)\n        active_backends = [b for b in backends if b.is_active()]\n        return active_backends\n\n    @property\n    def active_mfa_backends_mapper(self):\n        return {b.name: b for b in self.active_mfa_backends}\n\n    @staticmethod\n    def get_user_mfa_backends(user):\n        backends = []\n        for cls in settings.MFA_BACKENDS:\n            cls = import_string(cls)\n            if cls.global_enabled():\n                backends.append(cls(user))\n        return backends\n\n    def get_active_mfa_backend_by_type(self, mfa_type):\n        backend = self.get_mfa_backend_by_type(mfa_type)\n        if not backend or not backend.is_active():\n            return None\n        return backend\n\n    def get_mfa_backend_by_type(self, mfa_type):\n        mfa_mapper = {b.name: b for b in self.get_user_mfa_backends(self)}\n        backend = mfa_mapper.get(mfa_type)\n        if not backend:\n            return None\n        return backend\n\n\nclass User(AuthMixin, TokenMixin, RoleMixin, MFAMixin, AbstractUser):\n    class Source(models.TextChoices):\n        local = 'local', _('Local')\n        ldap = 'ldap', 'LDAP/AD'\n        openid = 'openid', 'OpenID'\n        radius = 'radius', 'Radius'\n        cas = 'cas', 'CAS'\n        saml2 = 'saml2', 'SAML2'\n        oauth2 = 'oauth2', 'OAuth2'\n        custom = 'custom', 'Custom'\n\n    SOURCE_BACKEND_MAPPING = {\n        Source.local: [\n            settings.AUTH_BACKEND_MODEL,\n            settings.AUTH_BACKEND_PUBKEY,\n            settings.AUTH_BACKEND_WECOM,\n            settings.AUTH_BACKEND_DINGTALK,\n        ],\n        Source.ldap: [\n            settings.AUTH_BACKEND_LDAP\n        ],\n        Source.openid: [\n            settings.AUTH_BACKEND_OIDC_PASSWORD,\n            settings.AUTH_BACKEND_OIDC_CODE\n        ],\n        Source.radius: [\n            settings.AUTH_BACKEND_RADIUS\n        ],\n        Source.cas: [\n            settings.AUTH_BACKEND_CAS\n        ],\n        Source.saml2: [\n            settings.AUTH_BACKEND_SAML2\n        ],\n        Source.oauth2: [\n            settings.AUTH_BACKEND_OAUTH2\n        ],\n        Source.custom: [\n            settings.AUTH_BACKEND_CUSTOM\n        ]\n    }\n\n    id = models.UUIDField(default=uuid.uuid4, primary_key=True)\n    username = models.CharField(\n        max_length=128, unique=True, verbose_name=_('Username')\n    )\n    name = models.CharField(max_length=128, verbose_name=_('Name'))\n    email = models.EmailField(\n        max_length=128, unique=True, verbose_name=_('Email')\n    )\n    groups = models.ManyToManyField(\n        'users.UserGroup', related_name='users',\n        blank=True, verbose_name=_('User group')\n    )\n    role = models.CharField(\n        default='User', max_length=10,\n        blank=True, verbose_name=_('Role')\n    )\n    is_service_account = models.BooleanField(default=False, verbose_name=_(\"Is service account\"))\n    avatar = models.ImageField(\n        upload_to=\"avatar\", null=True, verbose_name=_('Avatar')\n    )\n    wechat = models.CharField(\n        max_length=128, blank=True, verbose_name=_('Wechat')\n    )\n    phone = models.CharField(\n        max_length=20, blank=True, null=True, verbose_name=_('Phone')\n    )\n    mfa_level = models.SmallIntegerField(\n        default=0, choices=MFAMixin.MFA_LEVEL_CHOICES, verbose_name=_('MFA')\n    )\n    otp_secret_key = fields.EncryptCharField(\n        max_length=128, blank=True, null=True, verbose_name=_('OTP secret key')\n    )\n    # Todo: Auto generate key, let user download\n    private_key = fields.EncryptTextField(\n        blank=True, null=True, verbose_name=_('Private key')\n    )\n    public_key = fields.EncryptTextField(\n        blank=True, null=True, verbose_name=_('Public key')\n    )\n    secret_key = fields.EncryptCharField(\n        max_length=256, blank=True, null=True, verbose_name=_('Secret key')\n    )\n    comment = models.TextField(\n        blank=True, null=True, verbose_name=_('Comment')\n    )\n    is_first_login = models.BooleanField(default=True, verbose_name=_('Is first login'))\n    date_expired = models.DateTimeField(\n        default=date_expired_default, blank=True, null=True,\n        db_index=True, verbose_name=_('Date expired')\n    )\n    created_by = models.CharField(\n        max_length=30, default='', blank=True, verbose_name=_('Created by')\n    )\n    source = models.CharField(\n        max_length=30, default=Source.local,\n        choices=Source.choices,\n        verbose_name=_('Source')\n    )\n    date_password_last_updated = models.DateTimeField(\n        auto_now_add=True, blank=True, null=True,\n        verbose_name=_('Date password last updated')\n    )\n    need_update_password = models.BooleanField(\n        default=False, verbose_name=_('Need update password')\n    )\n    wecom_id = models.CharField(null=True, default=None, unique=True, max_length=128, verbose_name=_('WeCom'))\n    dingtalk_id = models.CharField(null=True, default=None, unique=True, max_length=128, verbose_name=_('DingTalk'))\n    feishu_id = models.CharField(null=True, default=None, unique=True, max_length=128, verbose_name=_('FeiShu'))\n\n    DATE_EXPIRED_WARNING_DAYS = 5\n\n    def __str__(self):\n        return '{0.name}({0.username})'.format(self)\n\n    @classmethod\n    def get_group_ids_by_user_id(cls, user_id):\n        group_ids = cls.groups.through.objects.filter(user_id=user_id) \\\n            .distinct().values_list('usergroup_id', flat=True)\n        group_ids = list(group_ids)\n        return group_ids\n\n    @property\n    def receive_backends(self):\n        return self.user_msg_subscription.receive_backends\n\n    @property\n    def is_wecom_bound(self):\n        return bool(self.wecom_id)\n\n    @property\n    def is_dingtalk_bound(self):\n        return bool(self.dingtalk_id)\n\n    @property\n    def is_feishu_bound(self):\n        return bool(self.feishu_id)\n\n    @property\n    def is_otp_secret_key_bound(self):\n        return bool(self.otp_secret_key)\n\n    def get_absolute_url(self):\n        return reverse('users:user-detail', args=(self.id,))\n\n    @property\n    def groups_display(self):\n        return ' '.join([group.name for group in self.groups.all()])\n\n    @property\n    def source_display(self):\n        return self.get_source_display()\n\n    @property\n    def is_expired(self):\n        if self.date_expired and self.date_expired < timezone.now():\n            return True\n        else:\n            return False\n\n    @property\n    def expired_remain_days(self):\n        date_remain = self.date_expired - timezone.now()\n        return date_remain.days\n\n    @property\n    def will_expired(self):\n        if 0 <= self.expired_remain_days <= self.DATE_EXPIRED_WARNING_DAYS:\n            return True\n        else:\n            return False\n\n    @property\n    def is_valid(self):\n        if self.is_active and not self.is_expired:\n            return True\n        return False\n\n    @property\n    def is_local(self):\n        return self.source == self.Source.local.value\n\n    def is_password_authenticate(self):\n        cas = self.Source.cas\n        saml2 = self.Source.saml2\n        oauth2 = self.Source.oauth2\n        return self.source not in [cas, saml2, oauth2]\n\n    def set_unprovide_attr_if_need(self):\n        if not self.name:\n            self.name = self.username\n        if not self.email or '@' not in self.email:\n            email = '{}@{}'.format(self.username, settings.EMAIL_SUFFIX)\n            if '@' in self.username:\n                email = self.username\n            self.email = email\n\n    def save(self, *args, **kwargs):\n        self.set_unprovide_attr_if_need()\n        if self.username == 'admin':\n            self.role = 'Admin'\n            self.is_active = True\n        return super().save(*args, **kwargs)\n\n    def is_member_of(self, user_group):\n        if user_group in self.groups.all():\n            return True\n        return False\n\n    def set_avatar(self, f):\n        self.avatar.save(self.username, f)\n\n    @classmethod\n    def get_avatar_url(cls, username):\n        user_default = settings.STATIC_URL + \"img/avatar/user.png\"\n        return user_default\n\n    def avatar_url(self):\n        admin_default = settings.STATIC_URL + \"img/avatar/admin.png\"\n        user_default = settings.STATIC_URL + \"img/avatar/user.png\"\n        if self.avatar:\n            return self.avatar.url\n        if self.is_superuser:\n            return admin_default\n        else:\n            return user_default\n\n    def unblock_login(self):\n        from users.utils import LoginBlockUtil, MFABlockUtils\n        LoginBlockUtil.unblock_user(self.username)\n        MFABlockUtils.unblock_user(self.username)\n\n    @property\n    def login_blocked(self):\n        from users.utils import LoginBlockUtil, MFABlockUtils\n        if LoginBlockUtil.is_user_block(self.username):\n            return True\n        if MFABlockUtils.is_user_block(self.username):\n            return True\n        return False\n\n    def delete(self, using=None, keep_parents=False):\n        if self.pk == 1 or self.username == 'admin':\n            return\n        return super(User, self).delete()\n\n    @classmethod\n    def get_user_allowed_auth_backend_paths(cls, username):\n        if not settings.ONLY_ALLOW_AUTH_FROM_SOURCE or not username:\n            return None\n        user = cls.objects.filter(username=username).first()\n        if not user:\n            return None\n        return user.get_allowed_auth_backend_paths()\n\n    def get_allowed_auth_backend_paths(self):\n        if not settings.ONLY_ALLOW_AUTH_FROM_SOURCE:\n            return None\n        return self.SOURCE_BACKEND_MAPPING.get(self.source, [])\n\n    @lazyproperty\n    def console_orgs(self):\n        from rbac.models import RoleBinding\n        return RoleBinding.get_user_has_the_perm_orgs('rbac.view_console', self)\n\n    @lazyproperty\n    def audit_orgs(self):\n        from rbac.models import RoleBinding\n        return RoleBinding.get_user_has_the_perm_orgs('rbac.view_audit', self)\n\n    @lazyproperty\n    def workbench_orgs(self):\n        from rbac.models import RoleBinding\n        return RoleBinding.get_user_has_the_perm_orgs('rbac.view_workbench', self)\n\n    class Meta:\n        ordering = ['username']\n        verbose_name = _(\"User\")\n        permissions = [\n            ('invite_user', _('Can invite user')),\n            ('remove_user', _('Can remove user')),\n            ('match_user', _('Can match user')),\n        ]\n\n    #: Use this method initial user\n    @classmethod\n    def initial(cls):\n        from .group import UserGroup\n        user = cls(username='admin',\n                   email='admin@jumpserver.org',\n                   name=_('Administrator'),\n                   password_raw='admin',\n                   role='Admin',\n                   comment=_('Administrator is the super user of system'),\n                   created_by=_('System'))\n        user.save()\n        user.groups.add(UserGroup.initial())\n\n    def can_send_created_mail(self):\n        if self.email and self.source == self.Source.local.value:\n            return True\n        return False\n\n\nclass UserPasswordHistory(models.Model):\n    id = models.UUIDField(default=uuid.uuid4, primary_key=True)\n    password = models.CharField(max_length=128)\n    user = models.ForeignKey(\"users.User\", related_name='history_passwords',\n                             on_delete=jms_models.CASCADE_SIGNAL_SKIP, verbose_name=_('User'))\n    date_created = models.DateTimeField(auto_now_add=True, verbose_name=_(\"Date created\"))\n\n    def __str__(self):\n        return f'{self.user} set at {self.date_created}'\n\n    def __repr__(self):\n        return self.__str__()\n\n    class Meta:\n        verbose_name = _(\"User password history\")\n"], "filenames": ["apps/common/utils/random.py", "apps/users/models/user.py"], "buggy_code_start_loc": [3, 3], "buggy_code_end_loc": [21, 523], "fixing_code_start_loc": [2, 4], "fixing_code_end_loc": [22, 519], "type": "NVD-CWE-noinfo", "message": "JumpServer is an open source bastion host. This vulnerability is due to exposing the random number seed to the API, potentially allowing the randomly generated verification codes to be replayed, which could lead to password resets. If MFA is enabled users are not affect. Users not using local authentication are also not affected. Users are advised to upgrade to either version 2.28.19 or to 3.6.5. There are no known workarounds or this issue.", "other": {"cve": {"id": "CVE-2023-42820", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-27T15:19:33.227", "lastModified": "2023-09-29T15:04:32.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "JumpServer is an open source bastion host. This vulnerability is due to exposing the random number seed to the API, potentially allowing the randomly generated verification codes to be replayed, which could lead to password resets. If MFA is enabled users are not affect. Users not using local authentication are also not affected. Users are advised to upgrade to either version 2.28.19 or to 3.6.5. There are no known workarounds or this issue."}, {"lang": "es", "value": "JumpServer es un host bastionado de c\u00f3digo abierto. Esta vulnerabilidad se debe a la exposici\u00f3n de la seed de n\u00famero aleatorio a la API, lo que potencialmente permite que se reproduzcan los c\u00f3digos de verificaci\u00f3n generados aleatoriamente, lo que podr\u00eda provocar restablecimientos de contrase\u00f1a. Si MFA est\u00e1 habilitado, los usuarios no se ven afectados. Los usuarios que no utilizan la autenticaci\u00f3n local tampoco se ven afectados. Se recomienda a los usuarios que actualicen a la versi\u00f3n 2.28.19 o 3.6.5. No se conocen workarounds para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:jumpserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.24.0", "versionEndExcluding": "2.28.19", "matchCriteriaId": "B7BF12DA-F3E0-44F2-99DB-E983B84FE42C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:jumpserver:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.6.5", "matchCriteriaId": "3102E381-1725-4710-BA7F-F41189347AFE"}]}]}], "references": [{"url": "https://github.com/jumpserver/jumpserver/commit/42337f0d00b2a8d45ef063eb5b7deeef81597da5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/jumpserver/jumpserver/security/advisories/GHSA-7prv-g565-82qp", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jumpserver/jumpserver/commit/42337f0d00b2a8d45ef063eb5b7deeef81597da5"}}