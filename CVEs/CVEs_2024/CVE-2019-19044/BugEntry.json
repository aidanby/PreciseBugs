{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/* Copyright (C) 2014-2018 Broadcom */\n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_syncobj.h>\n#include <uapi/drm/v3d_drm.h>\n\n#include \"v3d_drv.h\"\n#include \"v3d_regs.h\"\n#include \"v3d_trace.h\"\n\nstatic void\nv3d_init_core(struct v3d_dev *v3d, int core)\n{\n\t/* Set OVRTMUOUT, which means that the texture sampler uniform\n\t * configuration's tmu output type field is used, instead of\n\t * using the hardware default behavior based on the texture\n\t * type.  If you want the default behavior, you can still put\n\t * \"2\" in the indirect texture state's output_type field.\n\t */\n\tif (v3d->ver < 40)\n\t\tV3D_CORE_WRITE(core, V3D_CTL_MISCCFG, V3D_MISCCFG_OVRTMUOUT);\n\n\t/* Whenever we flush the L2T cache, we always want to flush\n\t * the whole thing.\n\t */\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TFLSTA, 0);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TFLEND, ~0);\n}\n\n/* Sets invariant state for the HW. */\nstatic void\nv3d_init_hw_state(struct v3d_dev *v3d)\n{\n\tv3d_init_core(v3d, 0);\n}\n\nstatic void\nv3d_idle_axi(struct v3d_dev *v3d, int core)\n{\n\tV3D_CORE_WRITE(core, V3D_GMP_CFG, V3D_GMP_CFG_STOP_REQ);\n\n\tif (wait_for((V3D_CORE_READ(core, V3D_GMP_STATUS) &\n\t\t      (V3D_GMP_STATUS_RD_COUNT_MASK |\n\t\t       V3D_GMP_STATUS_WR_COUNT_MASK |\n\t\t       V3D_GMP_STATUS_CFG_BUSY)) == 0, 100)) {\n\t\tDRM_ERROR(\"Failed to wait for safe GMP shutdown\\n\");\n\t}\n}\n\nstatic void\nv3d_idle_gca(struct v3d_dev *v3d)\n{\n\tif (v3d->ver >= 41)\n\t\treturn;\n\n\tV3D_GCA_WRITE(V3D_GCA_SAFE_SHUTDOWN, V3D_GCA_SAFE_SHUTDOWN_EN);\n\n\tif (wait_for((V3D_GCA_READ(V3D_GCA_SAFE_SHUTDOWN_ACK) &\n\t\t      V3D_GCA_SAFE_SHUTDOWN_ACK_ACKED) ==\n\t\t     V3D_GCA_SAFE_SHUTDOWN_ACK_ACKED, 100)) {\n\t\tDRM_ERROR(\"Failed to wait for safe GCA shutdown\\n\");\n\t}\n}\n\nstatic void\nv3d_reset_by_bridge(struct v3d_dev *v3d)\n{\n\tint version = V3D_BRIDGE_READ(V3D_TOP_GR_BRIDGE_REVISION);\n\n\tif (V3D_GET_FIELD(version, V3D_TOP_GR_BRIDGE_MAJOR) == 2) {\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_0,\n\t\t\t\t V3D_TOP_GR_BRIDGE_SW_INIT_0_V3D_CLK_108_SW_INIT);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_0, 0);\n\n\t\t/* GFXH-1383: The SW_INIT may cause a stray write to address 0\n\t\t * of the unit, so reset it to its power-on value here.\n\t\t */\n\t\tV3D_WRITE(V3D_HUB_AXICFG, V3D_HUB_AXICFG_MAX_LEN_MASK);\n\t} else {\n\t\tWARN_ON_ONCE(V3D_GET_FIELD(version,\n\t\t\t\t\t   V3D_TOP_GR_BRIDGE_MAJOR) != 7);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_1,\n\t\t\t\t V3D_TOP_GR_BRIDGE_SW_INIT_1_V3D_CLK_108_SW_INIT);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_1, 0);\n\t}\n}\n\nstatic void\nv3d_reset_v3d(struct v3d_dev *v3d)\n{\n\tif (v3d->reset)\n\t\treset_control_reset(v3d->reset);\n\telse\n\t\tv3d_reset_by_bridge(v3d);\n\n\tv3d_init_hw_state(v3d);\n}\n\nvoid\nv3d_reset(struct v3d_dev *v3d)\n{\n\tstruct drm_device *dev = &v3d->drm;\n\n\tDRM_DEV_ERROR(dev->dev, \"Resetting GPU for hang.\\n\");\n\tDRM_DEV_ERROR(dev->dev, \"V3D_ERR_STAT: 0x%08x\\n\",\n\t\t      V3D_CORE_READ(0, V3D_ERR_STAT));\n\ttrace_v3d_reset_begin(dev);\n\n\t/* XXX: only needed for safe powerdown, not reset. */\n\tif (false)\n\t\tv3d_idle_axi(v3d, 0);\n\n\tv3d_idle_gca(v3d);\n\tv3d_reset_v3d(v3d);\n\n\tv3d_mmu_set_page_table(v3d);\n\tv3d_irq_reset(v3d);\n\n\ttrace_v3d_reset_end(dev);\n}\n\nstatic void\nv3d_flush_l3(struct v3d_dev *v3d)\n{\n\tif (v3d->ver < 41) {\n\t\tu32 gca_ctrl = V3D_GCA_READ(V3D_GCA_CACHE_CTRL);\n\n\t\tV3D_GCA_WRITE(V3D_GCA_CACHE_CTRL,\n\t\t\t      gca_ctrl | V3D_GCA_CACHE_CTRL_FLUSH);\n\n\t\tif (v3d->ver < 33) {\n\t\t\tV3D_GCA_WRITE(V3D_GCA_CACHE_CTRL,\n\t\t\t\t      gca_ctrl & ~V3D_GCA_CACHE_CTRL_FLUSH);\n\t\t}\n\t}\n}\n\n/* Invalidates the (read-only) L2C cache.  This was the L2 cache for\n * uniforms and instructions on V3D 3.2.\n */\nstatic void\nv3d_invalidate_l2c(struct v3d_dev *v3d, int core)\n{\n\tif (v3d->ver > 32)\n\t\treturn;\n\n\tV3D_CORE_WRITE(core, V3D_CTL_L2CACTL,\n\t\t       V3D_L2CACTL_L2CCLR |\n\t\t       V3D_L2CACTL_L2CENA);\n}\n\n/* Invalidates texture L2 cachelines */\nstatic void\nv3d_flush_l2t(struct v3d_dev *v3d, int core)\n{\n\t/* While there is a busy bit (V3D_L2TCACTL_L2TFLS), we don't\n\t * need to wait for completion before dispatching the job --\n\t * L2T accesses will be stalled until the flush has completed.\n\t * However, we do need to make sure we don't try to trigger a\n\t * new flush while the L2_CLEAN queue is trying to\n\t * synchronously clean after a job.\n\t */\n\tmutex_lock(&v3d->cache_clean_lock);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL,\n\t\t       V3D_L2TCACTL_L2TFLS |\n\t\t       V3D_SET_FIELD(V3D_L2TCACTL_FLM_FLUSH, V3D_L2TCACTL_FLM));\n\tmutex_unlock(&v3d->cache_clean_lock);\n}\n\n/* Cleans texture L1 and L2 cachelines (writing back dirty data).\n *\n * For cleaning, which happens from the CACHE_CLEAN queue after CSD has\n * executed, we need to make sure that the clean is done before\n * signaling job completion.  So, we synchronously wait before\n * returning, and we make sure that L2 invalidates don't happen in the\n * meantime to confuse our are-we-done checks.\n */\nvoid\nv3d_clean_caches(struct v3d_dev *v3d)\n{\n\tstruct drm_device *dev = &v3d->drm;\n\tint core = 0;\n\n\ttrace_v3d_cache_clean_begin(dev);\n\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL, V3D_L2TCACTL_TMUWCF);\n\tif (wait_for(!(V3D_CORE_READ(core, V3D_CTL_L2TCACTL) &\n\t\t       V3D_L2TCACTL_L2TFLS), 100)) {\n\t\tDRM_ERROR(\"Timeout waiting for L1T write combiner flush\\n\");\n\t}\n\n\tmutex_lock(&v3d->cache_clean_lock);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL,\n\t\t       V3D_L2TCACTL_L2TFLS |\n\t\t       V3D_SET_FIELD(V3D_L2TCACTL_FLM_CLEAN, V3D_L2TCACTL_FLM));\n\n\tif (wait_for(!(V3D_CORE_READ(core, V3D_CTL_L2TCACTL) &\n\t\t       V3D_L2TCACTL_L2TFLS), 100)) {\n\t\tDRM_ERROR(\"Timeout waiting for L2T clean\\n\");\n\t}\n\n\tmutex_unlock(&v3d->cache_clean_lock);\n\n\ttrace_v3d_cache_clean_end(dev);\n}\n\n/* Invalidates the slice caches.  These are read-only caches. */\nstatic void\nv3d_invalidate_slices(struct v3d_dev *v3d, int core)\n{\n\tV3D_CORE_WRITE(core, V3D_CTL_SLCACTL,\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_TVCCS) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_TDCCS) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_UCC) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_ICC));\n}\n\nvoid\nv3d_invalidate_caches(struct v3d_dev *v3d)\n{\n\t/* Invalidate the caches from the outside in.  That way if\n\t * another CL's concurrent use of nearby memory were to pull\n\t * an invalidated cacheline back in, we wouldn't leave stale\n\t * data in the inner cache.\n\t */\n\tv3d_flush_l3(v3d);\n\tv3d_invalidate_l2c(v3d, 0);\n\tv3d_flush_l2t(v3d, 0);\n\tv3d_invalidate_slices(v3d, 0);\n}\n\n/* Takes the reservation lock on all the BOs being referenced, so that\n * at queue submit time we can update the reservations.\n *\n * We don't lock the RCL the tile alloc/state BOs, or overflow memory\n * (all of which are on exec->unref_list).  They're entirely private\n * to v3d, so we don't attach dma-buf fences to them.\n */\nstatic int\nv3d_lock_bo_reservations(struct v3d_job *job,\n\t\t\t struct ww_acquire_ctx *acquire_ctx)\n{\n\tint i, ret;\n\n\tret = drm_gem_lock_reservations(job->bo, job->bo_count, acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tret = drm_gem_fence_array_add_implicit(&job->deps,\n\t\t\t\t\t\t       job->bo[i], true);\n\t\tif (ret) {\n\t\t\tdrm_gem_unlock_reservations(job->bo, job->bo_count,\n\t\t\t\t\t\t    acquire_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * v3d_lookup_bos() - Sets up job->bo[] with the GEM objects\n * referenced by the job.\n * @dev: DRM device\n * @file_priv: DRM file for this fd\n * @job: V3D job being set up\n *\n * The command validator needs to reference BOs by their index within\n * the submitted job's BO list.  This does the validation of the job's\n * BO list and reference counting for the lifetime of the job.\n *\n * Note that this function doesn't need to unreference the BOs on\n * failure, because that will happen at v3d_exec_cleanup() time.\n */\nstatic int\nv3d_lookup_bos(struct drm_device *dev,\n\t       struct drm_file *file_priv,\n\t       struct v3d_job *job,\n\t       u64 bo_handles,\n\t       u32 bo_count)\n{\n\tu32 *handles;\n\tint ret = 0;\n\tint i;\n\n\tjob->bo_count = bo_count;\n\n\tif (!job->bo_count) {\n\t\t/* See comment on bo_index for why we have to check\n\t\t * this.\n\t\t */\n\t\tDRM_DEBUG(\"Rendering requires BOs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjob->bo = kvmalloc_array(job->bo_count,\n\t\t\t\t sizeof(struct drm_gem_cma_object *),\n\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (!job->bo) {\n\t\tDRM_DEBUG(\"Failed to allocate validated BO pointers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thandles = kvmalloc_array(job->bo_count, sizeof(u32), GFP_KERNEL);\n\tif (!handles) {\n\t\tret = -ENOMEM;\n\t\tDRM_DEBUG(\"Failed to allocate incoming GEM handles\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (copy_from_user(handles,\n\t\t\t   (void __user *)(uintptr_t)bo_handles,\n\t\t\t   job->bo_count * sizeof(u32))) {\n\t\tret = -EFAULT;\n\t\tDRM_DEBUG(\"Failed to copy in GEM handles\\n\");\n\t\tgoto fail;\n\t}\n\n\tspin_lock(&file_priv->table_lock);\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tstruct drm_gem_object *bo = idr_find(&file_priv->object_idr,\n\t\t\t\t\t\t     handles[i]);\n\t\tif (!bo) {\n\t\t\tDRM_DEBUG(\"Failed to look up GEM BO %d: %d\\n\",\n\t\t\t\t  i, handles[i]);\n\t\t\tret = -ENOENT;\n\t\t\tspin_unlock(&file_priv->table_lock);\n\t\t\tgoto fail;\n\t\t}\n\t\tdrm_gem_object_get(bo);\n\t\tjob->bo[i] = bo;\n\t}\n\tspin_unlock(&file_priv->table_lock);\n\nfail:\n\tkvfree(handles);\n\treturn ret;\n}\n\nstatic void\nv3d_job_free(struct kref *ref)\n{\n\tstruct v3d_job *job = container_of(ref, struct v3d_job, refcount);\n\tunsigned long index;\n\tstruct dma_fence *fence;\n\tint i;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tif (job->bo[i])\n\t\t\tdrm_gem_object_put_unlocked(job->bo[i]);\n\t}\n\tkvfree(job->bo);\n\n\txa_for_each(&job->deps, index, fence) {\n\t\tdma_fence_put(fence);\n\t}\n\txa_destroy(&job->deps);\n\n\tdma_fence_put(job->irq_fence);\n\tdma_fence_put(job->done_fence);\n\n\tpm_runtime_mark_last_busy(job->v3d->dev);\n\tpm_runtime_put_autosuspend(job->v3d->dev);\n\n\tkfree(job);\n}\n\nstatic void\nv3d_render_job_free(struct kref *ref)\n{\n\tstruct v3d_render_job *job = container_of(ref, struct v3d_render_job,\n\t\t\t\t\t\t  base.refcount);\n\tstruct v3d_bo *bo, *save;\n\n\tlist_for_each_entry_safe(bo, save, &job->unref_list, unref_head) {\n\t\tdrm_gem_object_put_unlocked(&bo->base.base);\n\t}\n\n\tv3d_job_free(ref);\n}\n\nvoid v3d_job_put(struct v3d_job *job)\n{\n\tkref_put(&job->refcount, job->free);\n}\n\nint\nv3d_wait_bo_ioctl(struct drm_device *dev, void *data,\n\t\t  struct drm_file *file_priv)\n{\n\tint ret;\n\tstruct drm_v3d_wait_bo *args = data;\n\tktime_t start = ktime_get();\n\tu64 delta_ns;\n\tunsigned long timeout_jiffies =\n\t\tnsecs_to_jiffies_timeout(args->timeout_ns);\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tret = drm_gem_dma_resv_wait(file_priv, args->handle,\n\t\t\t\t\t      true, timeout_jiffies);\n\n\t/* Decrement the user's timeout, in case we got interrupted\n\t * such that the ioctl will be restarted.\n\t */\n\tdelta_ns = ktime_to_ns(ktime_sub(ktime_get(), start));\n\tif (delta_ns < args->timeout_ns)\n\t\targs->timeout_ns -= delta_ns;\n\telse\n\t\targs->timeout_ns = 0;\n\n\t/* Asked to wait beyond the jiffie/scheduler precision? */\n\tif (ret == -ETIME && args->timeout_ns)\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}\n\nstatic int\nv3d_job_init(struct v3d_dev *v3d, struct drm_file *file_priv,\n\t     struct v3d_job *job, void (*free)(struct kref *ref),\n\t     u32 in_sync)\n{\n\tstruct dma_fence *in_fence = NULL;\n\tint ret;\n\n\tjob->v3d = v3d;\n\tjob->free = free;\n\n\tret = pm_runtime_get_sync(v3d->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\txa_init_flags(&job->deps, XA_FLAGS_ALLOC);\n\n\tret = drm_syncobj_find_fence(file_priv, in_sync, 0, 0, &in_fence);\n\tif (ret == -EINVAL)\n\t\tgoto fail;\n\n\tret = drm_gem_fence_array_add(&job->deps, in_fence);\n\tif (ret)\n\t\tgoto fail;\n\n\tkref_init(&job->refcount);\n\n\treturn 0;\nfail:\n\txa_destroy(&job->deps);\n\tpm_runtime_put_autosuspend(v3d->dev);\n\treturn ret;\n}\n\nstatic int\nv3d_push_job(struct v3d_file_priv *v3d_priv,\n\t     struct v3d_job *job, enum v3d_queue queue)\n{\n\tint ret;\n\n\tret = drm_sched_job_init(&job->base, &v3d_priv->sched_entity[queue],\n\t\t\t\t v3d_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tjob->done_fence = dma_fence_get(&job->base.s_fence->finished);\n\n\t/* put by scheduler job completion */\n\tkref_get(&job->refcount);\n\n\tdrm_sched_entity_push_job(&job->base, &v3d_priv->sched_entity[queue]);\n\n\treturn 0;\n}\n\nstatic void\nv3d_attach_fences_and_unlock_reservation(struct drm_file *file_priv,\n\t\t\t\t\t struct v3d_job *job,\n\t\t\t\t\t struct ww_acquire_ctx *acquire_ctx,\n\t\t\t\t\t u32 out_sync,\n\t\t\t\t\t struct dma_fence *done_fence)\n{\n\tstruct drm_syncobj *sync_out;\n\tint i;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\t/* XXX: Use shared fences for read-only objects. */\n\t\tdma_resv_add_excl_fence(job->bo[i]->resv,\n\t\t\t\t\t\t  job->done_fence);\n\t}\n\n\tdrm_gem_unlock_reservations(job->bo, job->bo_count, acquire_ctx);\n\n\t/* Update the return sync object for the job */\n\tsync_out = drm_syncobj_find(file_priv, out_sync);\n\tif (sync_out) {\n\t\tdrm_syncobj_replace_fence(sync_out, done_fence);\n\t\tdrm_syncobj_put(sync_out);\n\t}\n}\n\n/**\n * v3d_submit_cl_ioctl() - Submits a job (frame) to the V3D.\n * @dev: DRM device\n * @data: ioctl argument\n * @file_priv: DRM file for this fd\n *\n * This is the main entrypoint for userspace to submit a 3D frame to\n * the GPU.  Userspace provides the binner command list (if\n * applicable), and the kernel sets up the render command list to draw\n * to the framebuffer described in the ioctl, using the command lists\n * that the 3D engine's binner will produce.\n */\nint\nv3d_submit_cl_ioctl(struct drm_device *dev, void *data,\n\t\t    struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_cl *args = data;\n\tstruct v3d_bin_job *bin = NULL;\n\tstruct v3d_render_job *render;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret = 0;\n\n\ttrace_v3d_submit_cl_ioctl(&v3d->drm, args->rcl_start, args->rcl_end);\n\n\tif (args->pad != 0) {\n\t\tDRM_INFO(\"pad must be zero: %d\\n\", args->pad);\n\t\treturn -EINVAL;\n\t}\n\n\trender = kcalloc(1, sizeof(*render), GFP_KERNEL);\n\tif (!render)\n\t\treturn -ENOMEM;\n\n\trender->start = args->rcl_start;\n\trender->end = args->rcl_end;\n\tINIT_LIST_HEAD(&render->unref_list);\n\n\tret = v3d_job_init(v3d, file_priv, &render->base,\n\t\t\t   v3d_render_job_free, args->in_sync_rcl);\n\tif (ret) {\n\t\tkfree(render);\n\t\treturn ret;\n\t}\n\n\tif (args->bcl_start != args->bcl_end) {\n\t\tbin = kcalloc(1, sizeof(*bin), GFP_KERNEL);\n\t\tif (!bin)\n\t\t\treturn -ENOMEM;\n\n\t\tret = v3d_job_init(v3d, file_priv, &bin->base,\n\t\t\t\t   v3d_job_free, args->in_sync_bcl);\n\t\tif (ret) {\n\t\t\tv3d_job_put(&render->base);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbin->start = args->bcl_start;\n\t\tbin->end = args->bcl_end;\n\t\tbin->qma = args->qma;\n\t\tbin->qms = args->qms;\n\t\tbin->qts = args->qts;\n\t\tbin->render = render;\n\t}\n\n\tret = v3d_lookup_bos(dev, file_priv, &render->base,\n\t\t\t     args->bo_handles, args->bo_handle_count);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_lock_bo_reservations(&render->base, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tif (bin) {\n\t\tret = v3d_push_job(v3d_priv, &bin->base, V3D_BIN);\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\n\t\tret = drm_gem_fence_array_add(&render->base.deps,\n\t\t\t\t\t      dma_fence_get(bin->base.done_fence));\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\t}\n\n\tret = v3d_push_job(v3d_priv, &render->base, V3D_RENDER);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t &render->base,\n\t\t\t\t\t\t &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t render->base.done_fence);\n\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\n\tdrm_gem_unlock_reservations(render->base.bo,\n\t\t\t\t    render->base.bo_count, &acquire_ctx);\nfail:\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\n\treturn ret;\n}\n\n/**\n * v3d_submit_tfu_ioctl() - Submits a TFU (texture formatting) job to the V3D.\n * @dev: DRM device\n * @data: ioctl argument\n * @file_priv: DRM file for this fd\n *\n * Userspace provides the register setup for the TFU, which we don't\n * need to validate since the TFU is behind the MMU.\n */\nint\nv3d_submit_tfu_ioctl(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_tfu *args = data;\n\tstruct v3d_tfu_job *job;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret = 0;\n\n\ttrace_v3d_submit_tfu_ioctl(&v3d->drm, args->iia);\n\n\tjob = kcalloc(1, sizeof(*job), GFP_KERNEL);\n\tif (!job)\n\t\treturn -ENOMEM;\n\n\tret = v3d_job_init(v3d, file_priv, &job->base,\n\t\t\t   v3d_job_free, args->in_sync);\n\tif (ret) {\n\t\tkfree(job);\n\t\treturn ret;\n\t}\n\n\tjob->base.bo = kcalloc(ARRAY_SIZE(args->bo_handles),\n\t\t\t       sizeof(*job->base.bo), GFP_KERNEL);\n\tif (!job->base.bo) {\n\t\tv3d_job_put(&job->base);\n\t\treturn -ENOMEM;\n\t}\n\n\tjob->args = *args;\n\n\tspin_lock(&file_priv->table_lock);\n\tfor (job->base.bo_count = 0;\n\t     job->base.bo_count < ARRAY_SIZE(args->bo_handles);\n\t     job->base.bo_count++) {\n\t\tstruct drm_gem_object *bo;\n\n\t\tif (!args->bo_handles[job->base.bo_count])\n\t\t\tbreak;\n\n\t\tbo = idr_find(&file_priv->object_idr,\n\t\t\t      args->bo_handles[job->base.bo_count]);\n\t\tif (!bo) {\n\t\t\tDRM_DEBUG(\"Failed to look up GEM BO %d: %d\\n\",\n\t\t\t\t  job->base.bo_count,\n\t\t\t\t  args->bo_handles[job->base.bo_count]);\n\t\t\tret = -ENOENT;\n\t\t\tspin_unlock(&file_priv->table_lock);\n\t\t\tgoto fail;\n\t\t}\n\t\tdrm_gem_object_get(bo);\n\t\tjob->base.bo[job->base.bo_count] = bo;\n\t}\n\tspin_unlock(&file_priv->table_lock);\n\n\tret = v3d_lock_bo_reservations(&job->base, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tret = v3d_push_job(v3d_priv, &job->base, V3D_TFU);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t &job->base, &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t job->base.done_fence);\n\n\tv3d_job_put(&job->base);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\n\tdrm_gem_unlock_reservations(job->base.bo, job->base.bo_count,\n\t\t\t\t    &acquire_ctx);\nfail:\n\tv3d_job_put(&job->base);\n\n\treturn ret;\n}\n\n/**\n * v3d_submit_csd_ioctl() - Submits a CSD (texture formatting) job to the V3D.\n * @dev: DRM device\n * @data: ioctl argument\n * @file_priv: DRM file for this fd\n *\n * Userspace provides the register setup for the CSD, which we don't\n * need to validate since the CSD is behind the MMU.\n */\nint\nv3d_submit_csd_ioctl(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_csd *args = data;\n\tstruct v3d_csd_job *job;\n\tstruct v3d_job *clean_job;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret;\n\n\ttrace_v3d_submit_csd_ioctl(&v3d->drm, args->cfg[5], args->cfg[6]);\n\n\tif (!v3d_has_csd(v3d)) {\n\t\tDRM_DEBUG(\"Attempting CSD submit on non-CSD hardware\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjob = kcalloc(1, sizeof(*job), GFP_KERNEL);\n\tif (!job)\n\t\treturn -ENOMEM;\n\n\tret = v3d_job_init(v3d, file_priv, &job->base,\n\t\t\t   v3d_job_free, args->in_sync);\n\tif (ret) {\n\t\tkfree(job);\n\t\treturn ret;\n\t}\n\n\tclean_job = kcalloc(1, sizeof(*clean_job), GFP_KERNEL);\n\tif (!clean_job) {\n\t\tv3d_job_put(&job->base);\n\t\tkfree(job);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = v3d_job_init(v3d, file_priv, clean_job, v3d_job_free, 0);\n\tif (ret) {\n\t\tv3d_job_put(&job->base);\n\t\tkfree(clean_job);\n\t\treturn ret;\n\t}\n\n\tjob->args = *args;\n\n\tret = v3d_lookup_bos(dev, file_priv, clean_job,\n\t\t\t     args->bo_handles, args->bo_handle_count);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_lock_bo_reservations(clean_job, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tret = v3d_push_job(v3d_priv, &job->base, V3D_CSD);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\n\tret = drm_gem_fence_array_add(&clean_job->deps,\n\t\t\t\t      dma_fence_get(job->base.done_fence));\n\tif (ret)\n\t\tgoto fail_unreserve;\n\n\tret = v3d_push_job(v3d_priv, clean_job, V3D_CACHE_CLEAN);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t clean_job,\n\t\t\t\t\t\t &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t clean_job->done_fence);\n\n\tv3d_job_put(&job->base);\n\tv3d_job_put(clean_job);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\n\tdrm_gem_unlock_reservations(clean_job->bo, clean_job->bo_count,\n\t\t\t\t    &acquire_ctx);\nfail:\n\tv3d_job_put(&job->base);\n\tv3d_job_put(clean_job);\n\n\treturn ret;\n}\n\nint\nv3d_gem_init(struct drm_device *dev)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tu32 pt_size = 4096 * 1024;\n\tint ret, i;\n\n\tfor (i = 0; i < V3D_MAX_QUEUES; i++)\n\t\tv3d->queue[i].fence_context = dma_fence_context_alloc(1);\n\n\tspin_lock_init(&v3d->mm_lock);\n\tspin_lock_init(&v3d->job_lock);\n\tmutex_init(&v3d->bo_lock);\n\tmutex_init(&v3d->reset_lock);\n\tmutex_init(&v3d->sched_lock);\n\tmutex_init(&v3d->cache_clean_lock);\n\n\t/* Note: We don't allocate address 0.  Various bits of HW\n\t * treat 0 as special, such as the occlusion query counters\n\t * where 0 means \"disabled\".\n\t */\n\tdrm_mm_init(&v3d->mm, 1, pt_size / sizeof(u32) - 1);\n\n\tv3d->pt = dma_alloc_wc(v3d->dev, pt_size,\n\t\t\t       &v3d->pt_paddr,\n\t\t\t       GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\tif (!v3d->pt) {\n\t\tdrm_mm_takedown(&v3d->mm);\n\t\tdev_err(v3d->dev,\n\t\t\t\"Failed to allocate page tables. \"\n\t\t\t\"Please ensure you have CMA enabled.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tv3d_init_hw_state(v3d);\n\tv3d_mmu_set_page_table(v3d);\n\n\tret = v3d_sched_init(v3d);\n\tif (ret) {\n\t\tdrm_mm_takedown(&v3d->mm);\n\t\tdma_free_coherent(v3d->dev, 4096 * 1024, (void *)v3d->pt,\n\t\t\t\t  v3d->pt_paddr);\n\t}\n\n\treturn 0;\n}\n\nvoid\nv3d_gem_destroy(struct drm_device *dev)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\n\tv3d_sched_fini(v3d);\n\n\t/* Waiting for jobs to finish would need to be done before\n\t * unregistering V3D.\n\t */\n\tWARN_ON(v3d->bin_job);\n\tWARN_ON(v3d->render_job);\n\n\tdrm_mm_takedown(&v3d->mm);\n\n\tdma_free_coherent(v3d->dev, 4096 * 1024, (void *)v3d->pt, v3d->pt_paddr);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/* Copyright (C) 2014-2018 Broadcom */\n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_syncobj.h>\n#include <uapi/drm/v3d_drm.h>\n\n#include \"v3d_drv.h\"\n#include \"v3d_regs.h\"\n#include \"v3d_trace.h\"\n\nstatic void\nv3d_init_core(struct v3d_dev *v3d, int core)\n{\n\t/* Set OVRTMUOUT, which means that the texture sampler uniform\n\t * configuration's tmu output type field is used, instead of\n\t * using the hardware default behavior based on the texture\n\t * type.  If you want the default behavior, you can still put\n\t * \"2\" in the indirect texture state's output_type field.\n\t */\n\tif (v3d->ver < 40)\n\t\tV3D_CORE_WRITE(core, V3D_CTL_MISCCFG, V3D_MISCCFG_OVRTMUOUT);\n\n\t/* Whenever we flush the L2T cache, we always want to flush\n\t * the whole thing.\n\t */\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TFLSTA, 0);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TFLEND, ~0);\n}\n\n/* Sets invariant state for the HW. */\nstatic void\nv3d_init_hw_state(struct v3d_dev *v3d)\n{\n\tv3d_init_core(v3d, 0);\n}\n\nstatic void\nv3d_idle_axi(struct v3d_dev *v3d, int core)\n{\n\tV3D_CORE_WRITE(core, V3D_GMP_CFG, V3D_GMP_CFG_STOP_REQ);\n\n\tif (wait_for((V3D_CORE_READ(core, V3D_GMP_STATUS) &\n\t\t      (V3D_GMP_STATUS_RD_COUNT_MASK |\n\t\t       V3D_GMP_STATUS_WR_COUNT_MASK |\n\t\t       V3D_GMP_STATUS_CFG_BUSY)) == 0, 100)) {\n\t\tDRM_ERROR(\"Failed to wait for safe GMP shutdown\\n\");\n\t}\n}\n\nstatic void\nv3d_idle_gca(struct v3d_dev *v3d)\n{\n\tif (v3d->ver >= 41)\n\t\treturn;\n\n\tV3D_GCA_WRITE(V3D_GCA_SAFE_SHUTDOWN, V3D_GCA_SAFE_SHUTDOWN_EN);\n\n\tif (wait_for((V3D_GCA_READ(V3D_GCA_SAFE_SHUTDOWN_ACK) &\n\t\t      V3D_GCA_SAFE_SHUTDOWN_ACK_ACKED) ==\n\t\t     V3D_GCA_SAFE_SHUTDOWN_ACK_ACKED, 100)) {\n\t\tDRM_ERROR(\"Failed to wait for safe GCA shutdown\\n\");\n\t}\n}\n\nstatic void\nv3d_reset_by_bridge(struct v3d_dev *v3d)\n{\n\tint version = V3D_BRIDGE_READ(V3D_TOP_GR_BRIDGE_REVISION);\n\n\tif (V3D_GET_FIELD(version, V3D_TOP_GR_BRIDGE_MAJOR) == 2) {\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_0,\n\t\t\t\t V3D_TOP_GR_BRIDGE_SW_INIT_0_V3D_CLK_108_SW_INIT);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_0, 0);\n\n\t\t/* GFXH-1383: The SW_INIT may cause a stray write to address 0\n\t\t * of the unit, so reset it to its power-on value here.\n\t\t */\n\t\tV3D_WRITE(V3D_HUB_AXICFG, V3D_HUB_AXICFG_MAX_LEN_MASK);\n\t} else {\n\t\tWARN_ON_ONCE(V3D_GET_FIELD(version,\n\t\t\t\t\t   V3D_TOP_GR_BRIDGE_MAJOR) != 7);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_1,\n\t\t\t\t V3D_TOP_GR_BRIDGE_SW_INIT_1_V3D_CLK_108_SW_INIT);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_1, 0);\n\t}\n}\n\nstatic void\nv3d_reset_v3d(struct v3d_dev *v3d)\n{\n\tif (v3d->reset)\n\t\treset_control_reset(v3d->reset);\n\telse\n\t\tv3d_reset_by_bridge(v3d);\n\n\tv3d_init_hw_state(v3d);\n}\n\nvoid\nv3d_reset(struct v3d_dev *v3d)\n{\n\tstruct drm_device *dev = &v3d->drm;\n\n\tDRM_DEV_ERROR(dev->dev, \"Resetting GPU for hang.\\n\");\n\tDRM_DEV_ERROR(dev->dev, \"V3D_ERR_STAT: 0x%08x\\n\",\n\t\t      V3D_CORE_READ(0, V3D_ERR_STAT));\n\ttrace_v3d_reset_begin(dev);\n\n\t/* XXX: only needed for safe powerdown, not reset. */\n\tif (false)\n\t\tv3d_idle_axi(v3d, 0);\n\n\tv3d_idle_gca(v3d);\n\tv3d_reset_v3d(v3d);\n\n\tv3d_mmu_set_page_table(v3d);\n\tv3d_irq_reset(v3d);\n\n\ttrace_v3d_reset_end(dev);\n}\n\nstatic void\nv3d_flush_l3(struct v3d_dev *v3d)\n{\n\tif (v3d->ver < 41) {\n\t\tu32 gca_ctrl = V3D_GCA_READ(V3D_GCA_CACHE_CTRL);\n\n\t\tV3D_GCA_WRITE(V3D_GCA_CACHE_CTRL,\n\t\t\t      gca_ctrl | V3D_GCA_CACHE_CTRL_FLUSH);\n\n\t\tif (v3d->ver < 33) {\n\t\t\tV3D_GCA_WRITE(V3D_GCA_CACHE_CTRL,\n\t\t\t\t      gca_ctrl & ~V3D_GCA_CACHE_CTRL_FLUSH);\n\t\t}\n\t}\n}\n\n/* Invalidates the (read-only) L2C cache.  This was the L2 cache for\n * uniforms and instructions on V3D 3.2.\n */\nstatic void\nv3d_invalidate_l2c(struct v3d_dev *v3d, int core)\n{\n\tif (v3d->ver > 32)\n\t\treturn;\n\n\tV3D_CORE_WRITE(core, V3D_CTL_L2CACTL,\n\t\t       V3D_L2CACTL_L2CCLR |\n\t\t       V3D_L2CACTL_L2CENA);\n}\n\n/* Invalidates texture L2 cachelines */\nstatic void\nv3d_flush_l2t(struct v3d_dev *v3d, int core)\n{\n\t/* While there is a busy bit (V3D_L2TCACTL_L2TFLS), we don't\n\t * need to wait for completion before dispatching the job --\n\t * L2T accesses will be stalled until the flush has completed.\n\t * However, we do need to make sure we don't try to trigger a\n\t * new flush while the L2_CLEAN queue is trying to\n\t * synchronously clean after a job.\n\t */\n\tmutex_lock(&v3d->cache_clean_lock);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL,\n\t\t       V3D_L2TCACTL_L2TFLS |\n\t\t       V3D_SET_FIELD(V3D_L2TCACTL_FLM_FLUSH, V3D_L2TCACTL_FLM));\n\tmutex_unlock(&v3d->cache_clean_lock);\n}\n\n/* Cleans texture L1 and L2 cachelines (writing back dirty data).\n *\n * For cleaning, which happens from the CACHE_CLEAN queue after CSD has\n * executed, we need to make sure that the clean is done before\n * signaling job completion.  So, we synchronously wait before\n * returning, and we make sure that L2 invalidates don't happen in the\n * meantime to confuse our are-we-done checks.\n */\nvoid\nv3d_clean_caches(struct v3d_dev *v3d)\n{\n\tstruct drm_device *dev = &v3d->drm;\n\tint core = 0;\n\n\ttrace_v3d_cache_clean_begin(dev);\n\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL, V3D_L2TCACTL_TMUWCF);\n\tif (wait_for(!(V3D_CORE_READ(core, V3D_CTL_L2TCACTL) &\n\t\t       V3D_L2TCACTL_L2TFLS), 100)) {\n\t\tDRM_ERROR(\"Timeout waiting for L1T write combiner flush\\n\");\n\t}\n\n\tmutex_lock(&v3d->cache_clean_lock);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL,\n\t\t       V3D_L2TCACTL_L2TFLS |\n\t\t       V3D_SET_FIELD(V3D_L2TCACTL_FLM_CLEAN, V3D_L2TCACTL_FLM));\n\n\tif (wait_for(!(V3D_CORE_READ(core, V3D_CTL_L2TCACTL) &\n\t\t       V3D_L2TCACTL_L2TFLS), 100)) {\n\t\tDRM_ERROR(\"Timeout waiting for L2T clean\\n\");\n\t}\n\n\tmutex_unlock(&v3d->cache_clean_lock);\n\n\ttrace_v3d_cache_clean_end(dev);\n}\n\n/* Invalidates the slice caches.  These are read-only caches. */\nstatic void\nv3d_invalidate_slices(struct v3d_dev *v3d, int core)\n{\n\tV3D_CORE_WRITE(core, V3D_CTL_SLCACTL,\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_TVCCS) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_TDCCS) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_UCC) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_ICC));\n}\n\nvoid\nv3d_invalidate_caches(struct v3d_dev *v3d)\n{\n\t/* Invalidate the caches from the outside in.  That way if\n\t * another CL's concurrent use of nearby memory were to pull\n\t * an invalidated cacheline back in, we wouldn't leave stale\n\t * data in the inner cache.\n\t */\n\tv3d_flush_l3(v3d);\n\tv3d_invalidate_l2c(v3d, 0);\n\tv3d_flush_l2t(v3d, 0);\n\tv3d_invalidate_slices(v3d, 0);\n}\n\n/* Takes the reservation lock on all the BOs being referenced, so that\n * at queue submit time we can update the reservations.\n *\n * We don't lock the RCL the tile alloc/state BOs, or overflow memory\n * (all of which are on exec->unref_list).  They're entirely private\n * to v3d, so we don't attach dma-buf fences to them.\n */\nstatic int\nv3d_lock_bo_reservations(struct v3d_job *job,\n\t\t\t struct ww_acquire_ctx *acquire_ctx)\n{\n\tint i, ret;\n\n\tret = drm_gem_lock_reservations(job->bo, job->bo_count, acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tret = drm_gem_fence_array_add_implicit(&job->deps,\n\t\t\t\t\t\t       job->bo[i], true);\n\t\tif (ret) {\n\t\t\tdrm_gem_unlock_reservations(job->bo, job->bo_count,\n\t\t\t\t\t\t    acquire_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * v3d_lookup_bos() - Sets up job->bo[] with the GEM objects\n * referenced by the job.\n * @dev: DRM device\n * @file_priv: DRM file for this fd\n * @job: V3D job being set up\n *\n * The command validator needs to reference BOs by their index within\n * the submitted job's BO list.  This does the validation of the job's\n * BO list and reference counting for the lifetime of the job.\n *\n * Note that this function doesn't need to unreference the BOs on\n * failure, because that will happen at v3d_exec_cleanup() time.\n */\nstatic int\nv3d_lookup_bos(struct drm_device *dev,\n\t       struct drm_file *file_priv,\n\t       struct v3d_job *job,\n\t       u64 bo_handles,\n\t       u32 bo_count)\n{\n\tu32 *handles;\n\tint ret = 0;\n\tint i;\n\n\tjob->bo_count = bo_count;\n\n\tif (!job->bo_count) {\n\t\t/* See comment on bo_index for why we have to check\n\t\t * this.\n\t\t */\n\t\tDRM_DEBUG(\"Rendering requires BOs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjob->bo = kvmalloc_array(job->bo_count,\n\t\t\t\t sizeof(struct drm_gem_cma_object *),\n\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (!job->bo) {\n\t\tDRM_DEBUG(\"Failed to allocate validated BO pointers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thandles = kvmalloc_array(job->bo_count, sizeof(u32), GFP_KERNEL);\n\tif (!handles) {\n\t\tret = -ENOMEM;\n\t\tDRM_DEBUG(\"Failed to allocate incoming GEM handles\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (copy_from_user(handles,\n\t\t\t   (void __user *)(uintptr_t)bo_handles,\n\t\t\t   job->bo_count * sizeof(u32))) {\n\t\tret = -EFAULT;\n\t\tDRM_DEBUG(\"Failed to copy in GEM handles\\n\");\n\t\tgoto fail;\n\t}\n\n\tspin_lock(&file_priv->table_lock);\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tstruct drm_gem_object *bo = idr_find(&file_priv->object_idr,\n\t\t\t\t\t\t     handles[i]);\n\t\tif (!bo) {\n\t\t\tDRM_DEBUG(\"Failed to look up GEM BO %d: %d\\n\",\n\t\t\t\t  i, handles[i]);\n\t\t\tret = -ENOENT;\n\t\t\tspin_unlock(&file_priv->table_lock);\n\t\t\tgoto fail;\n\t\t}\n\t\tdrm_gem_object_get(bo);\n\t\tjob->bo[i] = bo;\n\t}\n\tspin_unlock(&file_priv->table_lock);\n\nfail:\n\tkvfree(handles);\n\treturn ret;\n}\n\nstatic void\nv3d_job_free(struct kref *ref)\n{\n\tstruct v3d_job *job = container_of(ref, struct v3d_job, refcount);\n\tunsigned long index;\n\tstruct dma_fence *fence;\n\tint i;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tif (job->bo[i])\n\t\t\tdrm_gem_object_put_unlocked(job->bo[i]);\n\t}\n\tkvfree(job->bo);\n\n\txa_for_each(&job->deps, index, fence) {\n\t\tdma_fence_put(fence);\n\t}\n\txa_destroy(&job->deps);\n\n\tdma_fence_put(job->irq_fence);\n\tdma_fence_put(job->done_fence);\n\n\tpm_runtime_mark_last_busy(job->v3d->dev);\n\tpm_runtime_put_autosuspend(job->v3d->dev);\n\n\tkfree(job);\n}\n\nstatic void\nv3d_render_job_free(struct kref *ref)\n{\n\tstruct v3d_render_job *job = container_of(ref, struct v3d_render_job,\n\t\t\t\t\t\t  base.refcount);\n\tstruct v3d_bo *bo, *save;\n\n\tlist_for_each_entry_safe(bo, save, &job->unref_list, unref_head) {\n\t\tdrm_gem_object_put_unlocked(&bo->base.base);\n\t}\n\n\tv3d_job_free(ref);\n}\n\nvoid v3d_job_put(struct v3d_job *job)\n{\n\tkref_put(&job->refcount, job->free);\n}\n\nint\nv3d_wait_bo_ioctl(struct drm_device *dev, void *data,\n\t\t  struct drm_file *file_priv)\n{\n\tint ret;\n\tstruct drm_v3d_wait_bo *args = data;\n\tktime_t start = ktime_get();\n\tu64 delta_ns;\n\tunsigned long timeout_jiffies =\n\t\tnsecs_to_jiffies_timeout(args->timeout_ns);\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tret = drm_gem_dma_resv_wait(file_priv, args->handle,\n\t\t\t\t\t      true, timeout_jiffies);\n\n\t/* Decrement the user's timeout, in case we got interrupted\n\t * such that the ioctl will be restarted.\n\t */\n\tdelta_ns = ktime_to_ns(ktime_sub(ktime_get(), start));\n\tif (delta_ns < args->timeout_ns)\n\t\targs->timeout_ns -= delta_ns;\n\telse\n\t\targs->timeout_ns = 0;\n\n\t/* Asked to wait beyond the jiffie/scheduler precision? */\n\tif (ret == -ETIME && args->timeout_ns)\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}\n\nstatic int\nv3d_job_init(struct v3d_dev *v3d, struct drm_file *file_priv,\n\t     struct v3d_job *job, void (*free)(struct kref *ref),\n\t     u32 in_sync)\n{\n\tstruct dma_fence *in_fence = NULL;\n\tint ret;\n\n\tjob->v3d = v3d;\n\tjob->free = free;\n\n\tret = pm_runtime_get_sync(v3d->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\txa_init_flags(&job->deps, XA_FLAGS_ALLOC);\n\n\tret = drm_syncobj_find_fence(file_priv, in_sync, 0, 0, &in_fence);\n\tif (ret == -EINVAL)\n\t\tgoto fail;\n\n\tret = drm_gem_fence_array_add(&job->deps, in_fence);\n\tif (ret)\n\t\tgoto fail;\n\n\tkref_init(&job->refcount);\n\n\treturn 0;\nfail:\n\txa_destroy(&job->deps);\n\tpm_runtime_put_autosuspend(v3d->dev);\n\treturn ret;\n}\n\nstatic int\nv3d_push_job(struct v3d_file_priv *v3d_priv,\n\t     struct v3d_job *job, enum v3d_queue queue)\n{\n\tint ret;\n\n\tret = drm_sched_job_init(&job->base, &v3d_priv->sched_entity[queue],\n\t\t\t\t v3d_priv);\n\tif (ret)\n\t\treturn ret;\n\n\tjob->done_fence = dma_fence_get(&job->base.s_fence->finished);\n\n\t/* put by scheduler job completion */\n\tkref_get(&job->refcount);\n\n\tdrm_sched_entity_push_job(&job->base, &v3d_priv->sched_entity[queue]);\n\n\treturn 0;\n}\n\nstatic void\nv3d_attach_fences_and_unlock_reservation(struct drm_file *file_priv,\n\t\t\t\t\t struct v3d_job *job,\n\t\t\t\t\t struct ww_acquire_ctx *acquire_ctx,\n\t\t\t\t\t u32 out_sync,\n\t\t\t\t\t struct dma_fence *done_fence)\n{\n\tstruct drm_syncobj *sync_out;\n\tint i;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\t/* XXX: Use shared fences for read-only objects. */\n\t\tdma_resv_add_excl_fence(job->bo[i]->resv,\n\t\t\t\t\t\t  job->done_fence);\n\t}\n\n\tdrm_gem_unlock_reservations(job->bo, job->bo_count, acquire_ctx);\n\n\t/* Update the return sync object for the job */\n\tsync_out = drm_syncobj_find(file_priv, out_sync);\n\tif (sync_out) {\n\t\tdrm_syncobj_replace_fence(sync_out, done_fence);\n\t\tdrm_syncobj_put(sync_out);\n\t}\n}\n\n/**\n * v3d_submit_cl_ioctl() - Submits a job (frame) to the V3D.\n * @dev: DRM device\n * @data: ioctl argument\n * @file_priv: DRM file for this fd\n *\n * This is the main entrypoint for userspace to submit a 3D frame to\n * the GPU.  Userspace provides the binner command list (if\n * applicable), and the kernel sets up the render command list to draw\n * to the framebuffer described in the ioctl, using the command lists\n * that the 3D engine's binner will produce.\n */\nint\nv3d_submit_cl_ioctl(struct drm_device *dev, void *data,\n\t\t    struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_cl *args = data;\n\tstruct v3d_bin_job *bin = NULL;\n\tstruct v3d_render_job *render;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret = 0;\n\n\ttrace_v3d_submit_cl_ioctl(&v3d->drm, args->rcl_start, args->rcl_end);\n\n\tif (args->pad != 0) {\n\t\tDRM_INFO(\"pad must be zero: %d\\n\", args->pad);\n\t\treturn -EINVAL;\n\t}\n\n\trender = kcalloc(1, sizeof(*render), GFP_KERNEL);\n\tif (!render)\n\t\treturn -ENOMEM;\n\n\trender->start = args->rcl_start;\n\trender->end = args->rcl_end;\n\tINIT_LIST_HEAD(&render->unref_list);\n\n\tret = v3d_job_init(v3d, file_priv, &render->base,\n\t\t\t   v3d_render_job_free, args->in_sync_rcl);\n\tif (ret) {\n\t\tkfree(render);\n\t\treturn ret;\n\t}\n\n\tif (args->bcl_start != args->bcl_end) {\n\t\tbin = kcalloc(1, sizeof(*bin), GFP_KERNEL);\n\t\tif (!bin) {\n\t\t\tv3d_job_put(&render->base);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = v3d_job_init(v3d, file_priv, &bin->base,\n\t\t\t\t   v3d_job_free, args->in_sync_bcl);\n\t\tif (ret) {\n\t\t\tv3d_job_put(&render->base);\n\t\t\tkfree(bin);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbin->start = args->bcl_start;\n\t\tbin->end = args->bcl_end;\n\t\tbin->qma = args->qma;\n\t\tbin->qms = args->qms;\n\t\tbin->qts = args->qts;\n\t\tbin->render = render;\n\t}\n\n\tret = v3d_lookup_bos(dev, file_priv, &render->base,\n\t\t\t     args->bo_handles, args->bo_handle_count);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_lock_bo_reservations(&render->base, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tif (bin) {\n\t\tret = v3d_push_job(v3d_priv, &bin->base, V3D_BIN);\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\n\t\tret = drm_gem_fence_array_add(&render->base.deps,\n\t\t\t\t\t      dma_fence_get(bin->base.done_fence));\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\t}\n\n\tret = v3d_push_job(v3d_priv, &render->base, V3D_RENDER);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t &render->base,\n\t\t\t\t\t\t &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t render->base.done_fence);\n\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\n\tdrm_gem_unlock_reservations(render->base.bo,\n\t\t\t\t    render->base.bo_count, &acquire_ctx);\nfail:\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\n\treturn ret;\n}\n\n/**\n * v3d_submit_tfu_ioctl() - Submits a TFU (texture formatting) job to the V3D.\n * @dev: DRM device\n * @data: ioctl argument\n * @file_priv: DRM file for this fd\n *\n * Userspace provides the register setup for the TFU, which we don't\n * need to validate since the TFU is behind the MMU.\n */\nint\nv3d_submit_tfu_ioctl(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_tfu *args = data;\n\tstruct v3d_tfu_job *job;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret = 0;\n\n\ttrace_v3d_submit_tfu_ioctl(&v3d->drm, args->iia);\n\n\tjob = kcalloc(1, sizeof(*job), GFP_KERNEL);\n\tif (!job)\n\t\treturn -ENOMEM;\n\n\tret = v3d_job_init(v3d, file_priv, &job->base,\n\t\t\t   v3d_job_free, args->in_sync);\n\tif (ret) {\n\t\tkfree(job);\n\t\treturn ret;\n\t}\n\n\tjob->base.bo = kcalloc(ARRAY_SIZE(args->bo_handles),\n\t\t\t       sizeof(*job->base.bo), GFP_KERNEL);\n\tif (!job->base.bo) {\n\t\tv3d_job_put(&job->base);\n\t\treturn -ENOMEM;\n\t}\n\n\tjob->args = *args;\n\n\tspin_lock(&file_priv->table_lock);\n\tfor (job->base.bo_count = 0;\n\t     job->base.bo_count < ARRAY_SIZE(args->bo_handles);\n\t     job->base.bo_count++) {\n\t\tstruct drm_gem_object *bo;\n\n\t\tif (!args->bo_handles[job->base.bo_count])\n\t\t\tbreak;\n\n\t\tbo = idr_find(&file_priv->object_idr,\n\t\t\t      args->bo_handles[job->base.bo_count]);\n\t\tif (!bo) {\n\t\t\tDRM_DEBUG(\"Failed to look up GEM BO %d: %d\\n\",\n\t\t\t\t  job->base.bo_count,\n\t\t\t\t  args->bo_handles[job->base.bo_count]);\n\t\t\tret = -ENOENT;\n\t\t\tspin_unlock(&file_priv->table_lock);\n\t\t\tgoto fail;\n\t\t}\n\t\tdrm_gem_object_get(bo);\n\t\tjob->base.bo[job->base.bo_count] = bo;\n\t}\n\tspin_unlock(&file_priv->table_lock);\n\n\tret = v3d_lock_bo_reservations(&job->base, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tret = v3d_push_job(v3d_priv, &job->base, V3D_TFU);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t &job->base, &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t job->base.done_fence);\n\n\tv3d_job_put(&job->base);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\n\tdrm_gem_unlock_reservations(job->base.bo, job->base.bo_count,\n\t\t\t\t    &acquire_ctx);\nfail:\n\tv3d_job_put(&job->base);\n\n\treturn ret;\n}\n\n/**\n * v3d_submit_csd_ioctl() - Submits a CSD (texture formatting) job to the V3D.\n * @dev: DRM device\n * @data: ioctl argument\n * @file_priv: DRM file for this fd\n *\n * Userspace provides the register setup for the CSD, which we don't\n * need to validate since the CSD is behind the MMU.\n */\nint\nv3d_submit_csd_ioctl(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_csd *args = data;\n\tstruct v3d_csd_job *job;\n\tstruct v3d_job *clean_job;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret;\n\n\ttrace_v3d_submit_csd_ioctl(&v3d->drm, args->cfg[5], args->cfg[6]);\n\n\tif (!v3d_has_csd(v3d)) {\n\t\tDRM_DEBUG(\"Attempting CSD submit on non-CSD hardware\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjob = kcalloc(1, sizeof(*job), GFP_KERNEL);\n\tif (!job)\n\t\treturn -ENOMEM;\n\n\tret = v3d_job_init(v3d, file_priv, &job->base,\n\t\t\t   v3d_job_free, args->in_sync);\n\tif (ret) {\n\t\tkfree(job);\n\t\treturn ret;\n\t}\n\n\tclean_job = kcalloc(1, sizeof(*clean_job), GFP_KERNEL);\n\tif (!clean_job) {\n\t\tv3d_job_put(&job->base);\n\t\tkfree(job);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = v3d_job_init(v3d, file_priv, clean_job, v3d_job_free, 0);\n\tif (ret) {\n\t\tv3d_job_put(&job->base);\n\t\tkfree(clean_job);\n\t\treturn ret;\n\t}\n\n\tjob->args = *args;\n\n\tret = v3d_lookup_bos(dev, file_priv, clean_job,\n\t\t\t     args->bo_handles, args->bo_handle_count);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_lock_bo_reservations(clean_job, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tret = v3d_push_job(v3d_priv, &job->base, V3D_CSD);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\n\tret = drm_gem_fence_array_add(&clean_job->deps,\n\t\t\t\t      dma_fence_get(job->base.done_fence));\n\tif (ret)\n\t\tgoto fail_unreserve;\n\n\tret = v3d_push_job(v3d_priv, clean_job, V3D_CACHE_CLEAN);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t clean_job,\n\t\t\t\t\t\t &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t clean_job->done_fence);\n\n\tv3d_job_put(&job->base);\n\tv3d_job_put(clean_job);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\n\tdrm_gem_unlock_reservations(clean_job->bo, clean_job->bo_count,\n\t\t\t\t    &acquire_ctx);\nfail:\n\tv3d_job_put(&job->base);\n\tv3d_job_put(clean_job);\n\n\treturn ret;\n}\n\nint\nv3d_gem_init(struct drm_device *dev)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tu32 pt_size = 4096 * 1024;\n\tint ret, i;\n\n\tfor (i = 0; i < V3D_MAX_QUEUES; i++)\n\t\tv3d->queue[i].fence_context = dma_fence_context_alloc(1);\n\n\tspin_lock_init(&v3d->mm_lock);\n\tspin_lock_init(&v3d->job_lock);\n\tmutex_init(&v3d->bo_lock);\n\tmutex_init(&v3d->reset_lock);\n\tmutex_init(&v3d->sched_lock);\n\tmutex_init(&v3d->cache_clean_lock);\n\n\t/* Note: We don't allocate address 0.  Various bits of HW\n\t * treat 0 as special, such as the occlusion query counters\n\t * where 0 means \"disabled\".\n\t */\n\tdrm_mm_init(&v3d->mm, 1, pt_size / sizeof(u32) - 1);\n\n\tv3d->pt = dma_alloc_wc(v3d->dev, pt_size,\n\t\t\t       &v3d->pt_paddr,\n\t\t\t       GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\tif (!v3d->pt) {\n\t\tdrm_mm_takedown(&v3d->mm);\n\t\tdev_err(v3d->dev,\n\t\t\t\"Failed to allocate page tables. \"\n\t\t\t\"Please ensure you have CMA enabled.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tv3d_init_hw_state(v3d);\n\tv3d_mmu_set_page_table(v3d);\n\n\tret = v3d_sched_init(v3d);\n\tif (ret) {\n\t\tdrm_mm_takedown(&v3d->mm);\n\t\tdma_free_coherent(v3d->dev, 4096 * 1024, (void *)v3d->pt,\n\t\t\t\t  v3d->pt_paddr);\n\t}\n\n\treturn 0;\n}\n\nvoid\nv3d_gem_destroy(struct drm_device *dev)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\n\tv3d_sched_fini(v3d);\n\n\t/* Waiting for jobs to finish would need to be done before\n\t * unregistering V3D.\n\t */\n\tWARN_ON(v3d->bin_job);\n\tWARN_ON(v3d->render_job);\n\n\tdrm_mm_takedown(&v3d->mm);\n\n\tdma_free_coherent(v3d->dev, 4096 * 1024, (void *)v3d->pt, v3d->pt_paddr);\n}\n"], "filenames": ["drivers/gpu/drm/v3d/v3d_gem.c"], "buggy_code_start_loc": [560], "buggy_code_end_loc": [566], "fixing_code_start_loc": [560], "fixing_code_end_loc": [570], "type": "CWE-401", "message": "Two memory leaks in the v3d_submit_cl_ioctl() function in drivers/gpu/drm/v3d/v3d_gem.c in the Linux kernel before 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering kcalloc() or v3d_job_init() failures, aka CID-29cd13cfd762.", "other": {"cve": {"id": "CVE-2019-19044", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.280", "lastModified": "2023-01-20T14:35:42.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Two memory leaks in the v3d_submit_cl_ioctl() function in drivers/gpu/drm/v3d/v3d_gem.c in the Linux kernel before 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering kcalloc() or v3d_job_init() failures, aka CID-29cd13cfd762."}, {"lang": "es", "value": "Dos p\u00e9rdidas de memoria en la funci\u00f3n v3d_submit_cl_ioctl() en el archivo drivers/gpu/drm/v3d/v3d_gem.c en el kernel de Linux versiones anteriores a la versi\u00f3n 5.3.11, permiten a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n kcalloc() o v3d_job_init(), tambi\u00e9n se conoce como CID-29cd13cfd762."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.3", "versionEndExcluding": "5.3.11", "matchCriteriaId": "5DE0A98B-691B-452B-8586-6A95E92C4C98"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C0ADE5D-F91D-4E0D-B6C5-3511B19665F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "8AFF1109-26F3-43A5-A4CB-0F169FDBC0DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5AF71C49-ADEF-4EE2-802C-6159ADD51355"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.20:*:*:*:*:*:*:*", "matchCriteriaId": "B3BC6E59-2134-4A28-AAD2-77C8AE236BCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.25:*:*:*:*:*:*:*", "matchCriteriaId": "24377899-5389-4BDC-AC82-0E4186F4DE53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30:*:*:*:*:*:*:*", "matchCriteriaId": "23FE83DE-AE7C-4313-88E3-886110C31302"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30.5r3:*:*:*:*:*:*:*", "matchCriteriaId": "490B327B-AC20-419B-BB76-8AB6971304BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40:*:*:*:*:*:*:*", "matchCriteriaId": "8DCE2754-7A9E-4B3B-91D1-DCF90C1BABE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.3r2:*:*:*:*:*:*:*", "matchCriteriaId": "6CA74E8B-51E2-4A7C-8A98-0583D31134A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.5:*:*:*:*:*:*:*", "matchCriteriaId": "7B64AB37-A1D9-4163-A51B-4C780361F1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.1:*:*:*:*:*:*:*", "matchCriteriaId": "7BE9C9D7-9CED-4184-A190-1024A6FB8C82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:-:*:*:*:*:*:*", "matchCriteriaId": "B73D4C3C-A511-4E14-B19F-91F561ACB1B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:p1:*:*:*:*:*:*", "matchCriteriaId": "0C47D72C-9B6B-4E52-AF0E-56AD58E4A930"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60:*:*:*:*:*:*:*", "matchCriteriaId": "039C3790-5AA2-4895-AEAE-CC84A71DB907"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4592238-D1F2-43D6-9BAB-2F63ECF9C965"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.1:*:*:*:*:*:*:*", "matchCriteriaId": "0BA78068-80E9-4E49-9056-88EAB7E3682C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.3:*:*:*:*:*:*:*", "matchCriteriaId": "092F366C-E8B0-4BE5-B106-0B7A73B08D34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.1:*:*:*:*:*:*:*", "matchCriteriaId": "E7992E92-B159-4810-B895-01A9B944058A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.2:*:*:*:*:*:*:*", "matchCriteriaId": "5BDD7AAB-2BF3-4E8C-BEE2-5217E2926C11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:fas\\/aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "66EEA3CA-8CC7-4F0B-8204-6132D4114873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h610s:*:*:*:*:*:*:*", "matchCriteriaId": "DE7C6010-F736-4BDA-9E3B-C4370BBFA149"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:broadcom:brocade_fabric_operating_system_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "B2748912-FC54-47F6-8C0C-B96784765B8E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:solidfire_baseboard_management_controller_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB9B8171-F6CA-427D-81E0-6536D3BBFA8D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:solidfire_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "090AA6F4-4404-4E26-82AB-C3A22636F276"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/29cd13cfd7624726d9e6becbae9aa419ef35af7f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/29cd13cfd7624726d9e6becbae9aa419ef35af7f"}}